<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="102dc7d3bf538e66387889d7daeeb05e53a870a4" translate="yes" xml:space="preserve">
          <source>Utilities to compile all Python source files in a directory tree.</source>
          <target state="translated">디렉토리 트리에서 모든 Python 소스 파일을 컴파일하는 유틸리티</target>
        </trans-unit>
        <trans-unit id="894c08b4d341d3181d652622edf583cdb792b50d" translate="yes" xml:space="preserve">
          <source>Utilities to help work with fonts.</source>
          <target state="translated">글꼴 작업에 도움이되는 유틸리티.</target>
        </trans-unit>
        <trans-unit id="9b5439bb171dd02403cd4a0162c5e608f757fe9b" translate="yes" xml:space="preserve">
          <source>Utilities to run asyncio programs, create Tasks, and await on multiple things with timeouts.</source>
          <target state="translated">asyncio 프로그램을 실행하고 작업을 생성하며 시간 초과로 여러 항목을 기다리는 유틸리티</target>
        </trans-unit>
        <trans-unit id="4fafea3320bd24aef44e569f108bcf7bb663fa8f" translate="yes" xml:space="preserve">
          <source>Utilities to spawn subprocesses and run shell commands.</source>
          <target state="translated">서브 프로세스를 생성하고 쉘 명령을 실행하는 유틸리티.</target>
        </trans-unit>
        <trans-unit id="f16cdccb3faaa5e67faa6fdb65caa5cf29d51cbb" translate="yes" xml:space="preserve">
          <source>Utility functions</source>
          <target state="translated">유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="6e7be9dc79ed50d8c704d7f221a2758927ee65a3" translate="yes" xml:space="preserve">
          <source>Uuencode file &lt;em&gt;in_file&lt;/em&gt; into file &lt;em&gt;out_file&lt;/em&gt;. The uuencoded file will have the header specifying &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; as the defaults for the results of decoding the file. The default defaults are taken from &lt;em&gt;in_file&lt;/em&gt;, or &lt;code&gt;'-'&lt;/code&gt; and &lt;code&gt;0o666&lt;/code&gt; respectively. If &lt;em&gt;backtick&lt;/em&gt; is true, zeros are represented by &lt;code&gt;'`'&lt;/code&gt; instead of spaces.</source>
          <target state="translated">uuencode 파일 &lt;em&gt;in_file&lt;/em&gt; 을 파일 &lt;em&gt;out_file로&lt;/em&gt; . 인코딩 된 파일에는 파일 디코딩 결과의 기본값으로 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;모드&lt;/em&gt; 를 지정하는 헤더 가 있습니다. 기본 기본값은 &lt;em&gt;in_file&lt;/em&gt; 또는 각각 &lt;code&gt;'-'&lt;/code&gt; 및 &lt;code&gt;0o666&lt;/code&gt; 에서 가져옵니다 . 경우 &lt;em&gt;역 따옴표는&lt;/em&gt; 사실이다 영 (0)으로 표현된다 &lt;code&gt;'`'&lt;/code&gt; 대신 공간.</target>
        </trans-unit>
        <trans-unit id="51920a4103a076cddaea8c5320e3e3d41f0fe359" translate="yes" xml:space="preserve">
          <source>VRFY</source>
          <target state="translated">VRFY</target>
        </trans-unit>
        <trans-unit id="6ef9fae42b29329a1ed8c77701fe1700d757002f" translate="yes" xml:space="preserve">
          <source>Valid String Arg</source>
          <target state="translated">유효한 문자열 인수</target>
        </trans-unit>
        <trans-unit id="ae9f1d564485db39fcd34520a7886185a9f3d9bb" translate="yes" xml:space="preserve">
          <source>Valid enum Arg</source>
          <target state="translated">유효한 열거 형 Arg</target>
        </trans-unit>
        <trans-unit id="d11dea5084c554faaf9051f680e8d26ff170b6ad" translate="yes" xml:space="preserve">
          <source>Valid values are &lt;code&gt;7bit&lt;/code&gt;, &lt;code&gt;8bit&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, and &lt;code&gt;quoted-printable&lt;/code&gt;. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">유효한 값은 &lt;code&gt;7bit&lt;/code&gt; , &lt;code&gt;8bit&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; 및 &lt;code&gt;quoted-printable&lt;/code&gt; 입니다. 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ed34a07f3d8b83630e9e822f76c6734a7177025" translate="yes" xml:space="preserve">
          <source>Validating Parsers must use this method to report each chunk of ignorable whitespace (see the W3C XML 1.0 recommendation, section 2.10): non-validating parsers may also use this method if they are capable of parsing and using content models.</source>
          <target state="translated">유효성 검사 파서는 무시할 수있는 공백의 각 청크를보고하기 위해이 방법을 사용해야합니다 (W3C XML 1.0 권장 사항, 섹션 2.10 참조).</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="0701d51e2238471096af133360d47b98e784ca3c" translate="yes" xml:space="preserve">
          <source>Value Types</source>
          <target state="translated">가치 유형</target>
        </trans-unit>
        <trans-unit id="2ee2c05664be5bc3b7425a3cd5c2eaeb9af87ebe" translate="yes" xml:space="preserve">
          <source>Value if not present</source>
          <target state="translated">존재하지 않는 경우의 값</target>
        </trans-unit>
        <trans-unit id="7dd7eb81edd524ab9b2cc8166a90a72809941195" translate="yes" xml:space="preserve">
          <source>Value lengths are limited by available memory. Long values (more than 2048 bytes) should be stored as files with the filenames stored in the configuration registry. This helps the registry perform efficiently.</source>
          <target state="translated">사용 가능한 메모리에 따라 값 길이가 제한됩니다. 긴 값 (2048 바이트 이상)은 구성 레지스트리에 저장된 파일 이름을 가진 파일로 저장해야합니다. 이렇게하면 레지스트리가 효율적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4442e3ee6e85b03ce0d04c09a9f9afc7926b83" translate="yes" xml:space="preserve">
          <source>Value may be supplied as either a keyword or positional argument (this is the standard binding behaviour for functions implemented in Python.)</source>
          <target state="translated">값은 키워드 또는 위치 인수로 제공 될 수 있습니다 (Python으로 구현 된 함수에 대한 표준 바인딩 동작입니다).</target>
        </trans-unit>
        <trans-unit id="e606eb6146ca90bd2780303c47db18287309d201" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a keyword argument. Keyword only parameters are those which appear after a &lt;code&gt;*&lt;/code&gt; or &lt;code&gt;*args&lt;/code&gt; entry in a Python function definition.</source>
          <target state="translated">키워드 인수로 값을 제공해야합니다. 키워드 전용 매개 변수는 Python 함수 정의에서 &lt;code&gt;*&lt;/code&gt; 또는 &lt;code&gt;*args&lt;/code&gt; 항목 다음에 나타나는 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="f281af900c7055431a7ba9336e9f5b33972ace2e" translate="yes" xml:space="preserve">
          <source>Value must be supplied as a positional argument. Positional only parameters are those which appear before a &lt;code&gt;/&lt;/code&gt; entry (if present) in a Python function definition.</source>
          <target state="translated">위치 인수로 값을 제공해야합니다. 위치 만 매개 변수는 Python 함수 정의에서 &lt;code&gt;/&lt;/code&gt; 항목 (있는 경우) 앞에 표시되는 매개 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="86d356e451eb275892ab84a0a8cabfd82d894744" translate="yes" xml:space="preserve">
          <source>Value of function key &lt;em&gt;n&lt;/em&gt;</source>
          <target state="translated">기능 키 &lt;em&gt;n의&lt;/em&gt; 값&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="58abe8dc89cf79184a2726248be2244df3ce518b" translate="yes" xml:space="preserve">
          <source>Value too large for defined data type</source>
          <target state="translated">정의 된 데이터 유형에 비해 너무 큰 값</target>
        </trans-unit>
        <trans-unit id="0f22edd532486ea6c69bc19fb1bb15eb52cfdba0" translate="yes" xml:space="preserve">
          <source>Value used to identify the event. The interpretation depends on the filter but it&amp;rsquo;s usually the file descriptor. In the constructor ident can either be an int or an object with a &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method. kevent stores the integer internally.</source>
          <target state="translated">이벤트를 식별하는 데 사용되는 값입니다. 해석은 필터에 따라 다르지만 일반적으로 파일 디스크립터입니다. 생성자에서 ident는 int이거나 &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메서드가 있는 객체 일 수 있습니다 . kevent는 정수를 내부적으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="4ffc08181d2110828c38d18c73ceb4f5562de955" translate="yes" xml:space="preserve">
          <source>Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;#plistlib.Data&quot;&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;bytesarray&lt;/code&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">값은 문자열, 정수, 부동 소수점, 부울, 튜플, 목록, 사전 (문자열 키만 포함), &lt;a href=&quot;#plistlib.Data&quot;&gt; &lt;code&gt;Data&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;bytesarray&lt;/code&gt; 또는 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6acf79ae6557a4f6cef52f8868d47e669eb915d" translate="yes" xml:space="preserve">
          <source>Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">Values can be strings, integers, floats, booleans, tuples, lists, dictionaries (but only with string keys), &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; objects.</target>
        </trans-unit>
        <trans-unit id="d4af2aaf629c09c7b586c6140040cd042f1b5dae" translate="yes" xml:space="preserve">
          <source>Values from other sections can be fetched as well:</source>
          <target state="translated">다른 섹션의 값도 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7c8e3c3012e41d09c6656db5fddb8ed8d0ecd84" translate="yes" xml:space="preserve">
          <source>Values in the registry have name, type, and data components. This method retrieves the data for a key&amp;rsquo;s first value that has a &lt;code&gt;NULL&lt;/code&gt; name. But the underlying API call doesn&amp;rsquo;t return the type, so always use &lt;a href=&quot;#winreg.QueryValueEx&quot;&gt;&lt;code&gt;QueryValueEx()&lt;/code&gt;&lt;/a&gt; if possible.</source>
          <target state="translated">레지스트리의 값에는 이름, 유형 및 데이터 구성 요소가 있습니다. 이 메소드는 &lt;code&gt;NULL&lt;/code&gt; 이름 을 가진 키의 첫 번째 값에 대한 데이터를 검색합니다 . 그러나 기본 API 호출은 유형을 반환하지 않으므로 가능하면 항상 &lt;a href=&quot;#winreg.QueryValueEx&quot;&gt; &lt;code&gt;QueryValueEx()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64c44a2d0d8fe41ed1dbff4d435d6b3be6cd0c3f" translate="yes" xml:space="preserve">
          <source>Values of &lt;em&gt;n&lt;/em&gt; less than &lt;code&gt;0&lt;/code&gt; are treated as &lt;code&gt;0&lt;/code&gt; (which yields an empty sequence of the same type as &lt;em&gt;s&lt;/em&gt;). Note that items in the sequence &lt;em&gt;s&lt;/em&gt; are not copied; they are referenced multiple times. This often haunts new Python programmers; consider:</source>
          <target state="translated">값 &lt;em&gt;N&lt;/em&gt; 미만 &lt;code&gt;0&lt;/code&gt; 으로 취급 &lt;code&gt;0&lt;/code&gt; (동일한 타입의 빈 시퀀스 산출하는 &lt;em&gt;들&lt;/em&gt; ). 시퀀스 &lt;em&gt;의&lt;/em&gt; 항목은 복사되지 않습니다. 그들은 여러 번 참조됩니다. 이것은 종종 새로운 파이썬 프로그래머를 괴롭 힙니다. 치다:</target>
        </trans-unit>
        <trans-unit id="99882406ebedbb37513cb23cc3017de1859ae178" translate="yes" xml:space="preserve">
          <source>Values that cannot be determined are returned as given by the parameter presets. If bits is given as &lt;code&gt;''&lt;/code&gt;, the &lt;code&gt;sizeof(pointer)&lt;/code&gt; (or &lt;code&gt;sizeof(long)&lt;/code&gt; on Python version &amp;lt; 1.5.2) is used as indicator for the supported pointer size.</source>
          <target state="translated">결정할 수없는 값은 매개 변수 사전 설정에 따라 반환됩니다. 비트가로 주어지면 &lt;code&gt;''&lt;/code&gt; 상기 &lt;code&gt;sizeof(pointer)&lt;/code&gt; (또는 &lt;code&gt;sizeof(long)&lt;/code&gt; 파이썬 버전 &amp;lt;1.5.2에)을 지원 포인터 크기의 지표로 사용된다.</target>
        </trans-unit>
        <trans-unit id="b7fc44b31c7c9574a8212b50dbd39bc45209ed3f" translate="yes" xml:space="preserve">
          <source>Values to pass as the &lt;em&gt;mode&lt;/em&gt; parameter of &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; to test the existence, readability, writability and executability of &lt;em&gt;path&lt;/em&gt;, respectively.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 의 존재, 가독성, 쓰기 가능성 및 실행 가능성을 각각 테스트하기 위해 &lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;모드&lt;/em&gt; 매개 변수 로 전달할 값 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9675228400dbafe37ef560b13bae74e47caa9aac" translate="yes" xml:space="preserve">
          <source>Variable references can be used to load the value of a variable, to assign a new value to it, or to delete it. Variable references are given a context to distinguish these cases.</source>
          <target state="translated">Variable references can be used to load the value of a variable, to assign a new value to it, or to delete it. Variable references are given a context to distinguish these cases.</target>
        </trans-unit>
        <trans-unit id="505c78fab28aa9b0b70f7dcbd71feb993b8ff277" translate="yes" xml:space="preserve">
          <source>Variable that specifies the user agent of the opener object. To get &lt;a href=&quot;urllib#module-urllib&quot;&gt;&lt;code&gt;urllib&lt;/code&gt;&lt;/a&gt; to tell servers that it is a particular user agent, set this in a subclass as a class variable or in the constructor before calling the base constructor.</source>
          <target state="translated">오프너 객체의 사용자 에이전트를 지정하는 변수입니다. &lt;a href=&quot;urllib#module-urllib&quot;&gt; &lt;code&gt;urllib&lt;/code&gt; &lt;/a&gt; 가 서버에 특정 사용자 에이전트임을 알리 려면 기본 생성자를 호출하기 전에 서브 클래스에서 클래스 변수 또는 생성자로이를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="acc4399a5b517cf7222cd58ad2c32cfd48aac016" translate="yes" xml:space="preserve">
          <source>Variable-sized data types</source>
          <target state="translated">가변 크기 데이터 유형</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="25482e67402e6c3f5fe20df41e9dcae2a9ba2841" translate="yes" xml:space="preserve">
          <source>Various structures for implementing schedulers have been extensively studied, and heaps are good for this, as they are reasonably speedy, the speed is almost constant, and the worst case is not much different than the average case. However, there are other representations which are more efficient overall, yet the worst cases might be terrible.</source>
          <target state="translated">스케줄러를 구현하기위한 다양한 구조가 광범위하게 연구되었으며 힙은 합리적으로 빠르며 속도가 거의 일정하며 최악의 경우는 평균 경우와 크게 다르지 않기 때문에 이것에 좋습니다. 그러나 전반적으로 더 효율적인 다른 표현이 있지만 최악의 경우는 끔찍할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01dc65ed82215cf4434e1aca2d7412f6c775240" translate="yes" xml:space="preserve">
          <source>Vector example:</source>
          <target state="translated">벡터 예 :</target>
        </trans-unit>
        <trans-unit id="965ef7e332ac200f4b5e70778db19b375745f0da" translate="yes" xml:space="preserve">
          <source>Verbose output</source>
          <target state="translated">자세한 출력</target>
        </trans-unit>
        <trans-unit id="8a8830ff167eaa3505bc00fdd4111ea514743436" translate="yes" xml:space="preserve">
          <source>Verbose output.</source>
          <target state="translated">자세한 출력.</target>
        </trans-unit>
        <trans-unit id="c3b257b1e9f0266480a6612a0d51d64c417b942e" translate="yes" xml:space="preserve">
          <source>Verify that &lt;em&gt;cert&lt;/em&gt; (in decoded format as returned by &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;) matches the given &lt;em&gt;hostname&lt;/em&gt;. The rules applied are those for checking the identity of HTTPS servers as outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125&lt;/strong&gt;&lt;/a&gt;. In addition to HTTPS, this function should be suitable for checking the identity of servers in various SSL-based protocols such as FTPS, IMAPS, POPS and others.</source>
          <target state="translated">&lt;em&gt;cert&lt;/em&gt; ( &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 디코딩 된 형식 )가 지정된 &lt;em&gt;hostname&lt;/em&gt; 과 일치 하는지 확인하십시오 . 적용되는 규칙은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2818&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5280.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5280&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6125.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6125에&lt;/strong&gt;&lt;/a&gt; 요약 된 HTTPS 서버의 ID를 확인하기위한 규칙 입니다. HTTPS 외에도이 기능은 FTPS, IMAPS, POPS 등과 같은 다양한 SSL 기반 프로토콜에서 서버의 ID를 확인하는 데 적합해야합니다.</target>
        </trans-unit>
        <trans-unit id="53ba4e70726a4a91e073b0dd557344bd475a0a8b" translate="yes" xml:space="preserve">
          <source>Verifying certificates</source>
          <target state="translated">인증서 확인</target>
        </trans-unit>
        <trans-unit id="63f133e763468a73947f4629707ecc9c9d90bb76" translate="yes" xml:space="preserve">
          <source>Version interface for Jython.</source>
          <target state="translated">자이 썬 버전 인터페이스.</target>
        </trans-unit>
        <trans-unit id="19e3aaed4d8f8b4a00e21a218ae1c005508d0951" translate="yes" xml:space="preserve">
          <source>Vertical highlight</source>
          <target state="translated">수직 하이라이트</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">세로 탭</target>
        </trans-unit>
        <trans-unit id="1d6b8a691f0d907efa971075035a145a937381ac" translate="yes" xml:space="preserve">
          <source>Vietnamese</source>
          <target state="translated">Vietnamese</target>
        </trans-unit>
        <trans-unit id="c72e003330b099c436ab550f7c7a659390de0b50" translate="yes" xml:space="preserve">
          <source>View Last Restart</source>
          <target state="translated">마지막 재시작보기</target>
        </trans-unit>
        <trans-unit id="f633d1002c0f5f6ce6be33d7377af0ab89993bbb" translate="yes" xml:space="preserve">
          <source>View Objects</source>
          <target state="translated">객체보기</target>
        </trans-unit>
        <trans-unit id="8674ea8214e1ae57f3e50b4fb7b3ef79a1d1476a" translate="yes" xml:space="preserve">
          <source>Vincent Bernat.</source>
          <target state="translated">빈센트 베르나 트.</target>
        </trans-unit>
        <trans-unit id="82cb0e10bd78d0153cd1698ceb6ca31fb1f0f1e3" translate="yes" xml:space="preserve">
          <source>Virtual Events</source>
          <target state="translated">가상 이벤트</target>
        </trans-unit>
        <trans-unit id="17939436623483b052de1e4d3f9d6c11ccdc98ad" translate="yes" xml:space="preserve">
          <source>Virtual events</source>
          <target state="translated">가상 이벤트</target>
        </trans-unit>
        <trans-unit id="7d9ff4f0de398581c4640bcbb6e536c355a391be" translate="yes" xml:space="preserve">
          <source>Visibility</source>
          <target state="translated">Visibility</target>
        </trans-unit>
        <trans-unit id="5a2efe7f1abb84c38f1725a2ecc3c4e87349a479" translate="yes" xml:space="preserve">
          <source>Visit a node. The default implementation calls the method called &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; where &lt;em&gt;classname&lt;/em&gt; is the name of the node class, or &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt;&lt;code&gt;generic_visit()&lt;/code&gt;&lt;/a&gt; if that method doesn&amp;rsquo;t exist.</source>
          <target state="translated">노드를 방문하십시오. 기본 구현은 &lt;code&gt;self.visit_&lt;em&gt;classname&lt;/em&gt;&lt;/code&gt; 이라는 메소드를 호출합니다. 여기서 &lt;em&gt;classname&lt;/em&gt; 은 노드 클래스의 이름이거나 해당 메소드가없는 경우 &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt; &lt;code&gt;generic_visit()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bb3c755d8a06e5cd333fac0016835f914045f69e" translate="yes" xml:space="preserve">
          <source>Visual inspection shows that the certificate does identify the desired service (that is, the HTTPS host &lt;code&gt;www.python.org&lt;/code&gt;):</source>
          <target state="translated">육안 검사에 따르면 인증서가 원하는 서비스 (즉, HTTPS 호스트 &lt;code&gt;www.python.org&lt;/code&gt; )를 식별합니다 .</target>
        </trans-unit>
        <trans-unit id="5eee88bfaa26b0b2250c40217a4675afbea5cd23" translate="yes" xml:space="preserve">
          <source>Volume number of file header.</source>
          <target state="translated">파일 헤더의 볼륨 번호입니다.</target>
        </trans-unit>
        <trans-unit id="c328c0ed13eb319fbdea95de7337047e0b069c45" translate="yes" xml:space="preserve">
          <source>Voluntarily relinquish the CPU.</source>
          <target state="translated">자발적으로 CPU를 포기합니다.</target>
        </trans-unit>
        <trans-unit id="30e1c76ac6526fc5debd6d9e1463cc9f2e2c997b" translate="yes" xml:space="preserve">
          <source>VxWorks only supports setting &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt;&lt;code&gt;RLIMIT_NOFILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">VxWorks는 &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt; &lt;code&gt;RLIMIT_NOFILE&lt;/code&gt; &lt;/a&gt; 설정 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="b3645a420f6c8c0399ea11997839dc3fbde6f0ad" translate="yes" xml:space="preserve">
          <source>Wait for child process to terminate. Set and return &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">자식 프로세스가 종료 될 때까지 기다립니다. 리턴 &lt;a href=&quot;#subprocess.Popen.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 속성을 설정하고 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee4b0606dd5fd109342b9b5b4880dd14615482ba" translate="yes" xml:space="preserve">
          <source>Wait for completion of a child process, and return a tuple containing its pid and exit status indication: a 16-bit number, whose low byte is the signal number that killed the process, and whose high byte is the exit status (if the signal number is zero); the high bit of the low byte is set if a core file was produced.</source>
          <target state="translated">하위 프로세스가 완료 될 때까지 기다렸다가 pid 및 exit 상태 표시를 포함하는 튜플을 리턴하십시오. 16 비트 숫자, 하위 바이트는 프로세스를 종료 한 신호 번호이고 상위 바이트는 종료 상태 (신호가있는 경우) 숫자는 0); 코어 파일이 생성 된 경우 하위 바이트의 상위 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6cf3a1c5971c4c21eec5eb16a888eb935b06df3a" translate="yes" xml:space="preserve">
          <source>Wait for events. timeout in seconds (float)</source>
          <target state="translated">이벤트를 기다리십시오. 초 단위의 시간 초과 (부동)</target>
        </trans-unit>
        <trans-unit id="cabdac1beb596d1e8239e59912c30fa91617e2d4" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; instances (possibly created by different &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; instances) given by &lt;em&gt;fs&lt;/em&gt; to complete. Returns a named 2-tuple of sets. The first set, named &lt;code&gt;done&lt;/code&gt;, contains the futures that completed (finished or cancelled futures) before the wait completed. The second set, named &lt;code&gt;not_done&lt;/code&gt;, contains the futures that did not complete (pending or running futures).</source>
          <target state="translated">&lt;em&gt;fs&lt;/em&gt; 가 제공 한 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 인스턴스 (다른 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 인스턴스에 의해 생성 될 수 있음 ) 가 완료 될 때까지 기다 립니다. 명명 된 2- 튜플 세트를 반환합니다. &lt;code&gt;done&lt;/code&gt; 이라는 첫 번째 세트 에는 대기가 완료되기 전에 완료된 (미완료 또는 취소 된 선물) 선물이 포함됩니다. &lt;code&gt;not_done&lt;/code&gt; 이라는 두 번째 세트 에는 완료되지 않은 선물 (미래 또는 보류중인 선물)이 포함됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="29151336d8a123354d0b207654c1c2fac16dbab5" translate="yes" xml:space="preserve">
          <source>Wait for the &lt;em&gt;aw&lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt; to complete with a timeout.</source>
          <target state="translated">기다립니다 &lt;em&gt;아 &lt;/em&gt;&lt;a href=&quot;#asyncio-awaitables&quot;&gt;awaitable&lt;/a&gt; 타임 아웃 완료합니다.</target>
        </trans-unit>
        <trans-unit id="d5bfcef6a02be7849ca322a1b7fa63807a4361ed" translate="yes" xml:space="preserve">
          <source>Wait for the child process to terminate.</source>
          <target state="translated">하위 프로세스가 종료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="fc57d83fd49bf3b1beb38bc11fe23ab63ce80444" translate="yes" xml:space="preserve">
          <source>Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt;&lt;code&gt;P_PID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt;&lt;code&gt;P_PGID&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.P_ALL&quot;&gt;&lt;code&gt;P_ALL&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt;&lt;code&gt;WEXITED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt;&lt;code&gt;WSTOPPED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt;&lt;code&gt;WCONTINUED&lt;/code&gt;&lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt;&lt;code&gt;WNOWAIT&lt;/code&gt;&lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; is specified and there are no children in a waitable state.</source>
          <target state="translated">하나 이상의 자식 프로세스가 완료 될 때까지 기다립니다. &lt;em&gt;idtype&lt;/em&gt; 은 &lt;a href=&quot;#os.P_PID&quot;&gt; &lt;code&gt;P_PID&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.P_PGID&quot;&gt; &lt;code&gt;P_PGID&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.P_ALL&quot;&gt; &lt;code&gt;P_ALL&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . &lt;em&gt;id&lt;/em&gt; 는 기다릴 pid를 지정합니다. &lt;em&gt;옵션&lt;/em&gt; 은 &lt;a href=&quot;#os.WEXITED&quot;&gt; &lt;code&gt;WEXITED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.WSTOPPED&quot;&gt; &lt;code&gt;WSTOPPED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.WCONTINUED&quot;&gt; &lt;code&gt;WCONTINUED&lt;/code&gt; &lt;/a&gt; 중 하나 이상의 ORing으로 구성되며 추가로 &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.WNOWAIT&quot;&gt; &lt;code&gt;WNOWAIT&lt;/code&gt; &lt;/a&gt; 로 OR 될 수 있습니다 . 리턴 값은 포함 된 데이터 표현 목적 &lt;code&gt;siginfo_t&lt;/code&gt; : 즉 구조 &lt;code&gt;si_pid&lt;/code&gt; , &lt;code&gt;si_uid&lt;/code&gt; , &lt;code&gt;si_signo&lt;/code&gt; , &lt;code&gt;si_status&lt;/code&gt; , &lt;code&gt;si_code&lt;/code&gt; 을또는 &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; 이 지정되고 대기 가능한 상태의 하위가없는 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8fb0e69dd9fcfb951c44934a49370ba0848fdd14" translate="yes" xml:space="preserve">
          <source>Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt;&lt;code&gt;P_PID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt;&lt;code&gt;P_PGID&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.P_ALL&quot;&gt;&lt;code&gt;P_ALL&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#os.P_PIDFD&quot;&gt;&lt;code&gt;P_PIDFD&lt;/code&gt;&lt;/a&gt; on Linux. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt;&lt;code&gt;WEXITED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt;&lt;code&gt;WSTOPPED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt;&lt;code&gt;WCONTINUED&lt;/code&gt;&lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt;&lt;code&gt;WNOWAIT&lt;/code&gt;&lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt;&lt;code&gt;WNOHANG&lt;/code&gt;&lt;/a&gt; is specified and there are no children in a waitable state.</source>
          <target state="translated">Wait for the completion of one or more child processes. &lt;em&gt;idtype&lt;/em&gt; can be &lt;a href=&quot;#os.P_PID&quot;&gt; &lt;code&gt;P_PID&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#os.P_PGID&quot;&gt; &lt;code&gt;P_PGID&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#os.P_ALL&quot;&gt; &lt;code&gt;P_ALL&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;#os.P_PIDFD&quot;&gt; &lt;code&gt;P_PIDFD&lt;/code&gt; &lt;/a&gt; on Linux. &lt;em&gt;id&lt;/em&gt; specifies the pid to wait on. &lt;em&gt;options&lt;/em&gt; is constructed from the ORing of one or more of &lt;a href=&quot;#os.WEXITED&quot;&gt; &lt;code&gt;WEXITED&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#os.WSTOPPED&quot;&gt; &lt;code&gt;WSTOPPED&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#os.WCONTINUED&quot;&gt; &lt;code&gt;WCONTINUED&lt;/code&gt; &lt;/a&gt; and additionally may be ORed with &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#os.WNOWAIT&quot;&gt; &lt;code&gt;WNOWAIT&lt;/code&gt; &lt;/a&gt;. The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_pid&lt;/code&gt; , &lt;code&gt;si_uid&lt;/code&gt; , &lt;code&gt;si_signo&lt;/code&gt; , &lt;code&gt;si_status&lt;/code&gt; , &lt;code&gt;si_code&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt; if &lt;a href=&quot;#os.WNOHANG&quot;&gt; &lt;code&gt;WNOHANG&lt;/code&gt; &lt;/a&gt; is specified and there are no children in a waitable state.</target>
        </trans-unit>
        <trans-unit id="5ec9481f9a89a7f37a291ebe888b480fa7b27740" translate="yes" xml:space="preserve">
          <source>Wait for the worker processes to exit. One must call &lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; before using &lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업자 프로세스가 종료 될 때까지 기다리십시오. &lt;a href=&quot;#multiprocessing.pool.Pool.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 사용하기 전에 &lt;a href=&quot;#multiprocessing.pool.Pool.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.pool.Pool.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="24c2968b108d264170fd51a0470c595df02b5436" translate="yes" xml:space="preserve">
          <source>Wait till an object in &lt;em&gt;object_list&lt;/em&gt; is ready. Returns the list of those objects in &lt;em&gt;object_list&lt;/em&gt; which are ready. If &lt;em&gt;timeout&lt;/em&gt; is a float then the call blocks for at most that many seconds. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then it will block for an unlimited period. A negative timeout is equivalent to a zero timeout.</source>
          <target state="translated">&lt;em&gt;object_list&lt;/em&gt; 의 오브젝트 가 준비 될 때까지 기다리십시오 . &lt;em&gt;object_list&lt;/em&gt; 에서 준비된 오브젝트 목록을 리턴합니다 . 경우 &lt;em&gt;시간 제한은&lt;/em&gt; 부동는 대부분의 많은 초 동안 통화 블록이다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 그때는 무제한 기간 동안 차단합니다. 음의 타임 아웃은 타임 아웃 제로와 같습니다.</target>
        </trans-unit>
        <trans-unit id="70307f0b7918be1c3ba2811e4af742880bd148cb" translate="yes" xml:space="preserve">
          <source>Wait until a condition evaluates to true. &lt;em&gt;predicate&lt;/em&gt; should be a callable which result will be interpreted as a boolean value. A &lt;em&gt;timeout&lt;/em&gt; may be provided giving the maximum time to wait.</source>
          <target state="translated">조건이 true로 평가 될 때까지 기다리십시오. &lt;em&gt;술어&lt;/em&gt; 는 호출 가능해야하며 결과는 부울 값으로 해석됩니다. 최대 대기 시간을 제공 하는 &lt;em&gt;제한 시간&lt;/em&gt; 이 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2cef329a9efde14e8d238168106e3ca5692ee07" translate="yes" xml:space="preserve">
          <source>Wait until a file descriptor received some data using the &lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; method and then close the event loop:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 파일 디스크립터가 데이터를 수신 할 때까지 기다린 후 이벤트 루프를 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="74ad20c64b497f2ca5ab845b7554279263b0f679" translate="yes" xml:space="preserve">
          <source>Wait until a predicate becomes &lt;em&gt;true&lt;/em&gt;.</source>
          <target state="translated">술어가 &lt;em&gt;true&lt;/em&gt; 가 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="a6ca18daf863b117483b5967387209392304958f" translate="yes" xml:space="preserve">
          <source>Wait until a socket receives data using the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; method with a protocol:</source>
          <target state="translated">프로토콜과 함께 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 소켓이 데이터를 수신 할 때까지 기다 립니다 .</target>
        </trans-unit>
        <trans-unit id="07a9261621d8e68aedbd16e18722b9a67f39cec1" translate="yes" xml:space="preserve">
          <source>Wait until all output written to file descriptor &lt;em&gt;fd&lt;/em&gt; has been transmitted.</source>
          <target state="translated">파일 디스크립터 &lt;em&gt;fd에&lt;/em&gt; 기록 된 모든 출력 이 전송 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe11ac9dce22748ac5bc6e88601147ef1f88fb6" translate="yes" xml:space="preserve">
          <source>Wait until it is appropriate to resume writing to the stream. Example:</source>
          <target state="translated">스트림 쓰기를 다시 시작할 때까지 기다립니다. 예:</target>
        </trans-unit>
        <trans-unit id="b67b0cd8f0df8f71b4a7721db60c000c4a9aaff5" translate="yes" xml:space="preserve">
          <source>Wait until notified or until a timeout occurs. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">통지 될 때까지 또는 시간 종료가 발생할 때까지 기다리십시오. 이 메소드가 호출 될 때 호출 스레드가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d0970419de06465ae0edf094213021ffbd86ca8c" translate="yes" xml:space="preserve">
          <source>Wait until notified.</source>
          <target state="translated">통지 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="c2fc9d1ed3712ef7d3bde153348d7c6c6cfd49a2" translate="yes" xml:space="preserve">
          <source>Wait until process &lt;em&gt;pid&lt;/em&gt; completes and check that the process exit code is &lt;em&gt;exitcode&lt;/em&gt;.</source>
          <target state="translated">Wait until process &lt;em&gt;pid&lt;/em&gt; completes and check that the process exit code is &lt;em&gt;exitcode&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="ec9622e8f50c22884aacc0c6a6c6d1d859b01b43" translate="yes" xml:space="preserve">
          <source>Wait until some registered file objects become ready, or the timeout expires.</source>
          <target state="translated">등록 된 일부 파일 객체가 준비되거나 타임 아웃이 만료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="c5ec2047d1b5f0f5a23a91d4267a89adebce9d94" translate="yes" xml:space="preserve">
          <source>Wait until the &lt;a href=&quot;#asyncio.Server.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method completes.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Server.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 완료 될 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="fdc40d911794127c221170ea25e3065e9d790a27" translate="yes" xml:space="preserve">
          <source>Wait until the event is set.</source>
          <target state="translated">이벤트가 설정 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="29508508455305b1db6d27aa2e48c694fd3d730b" translate="yes" xml:space="preserve">
          <source>Wait until the result is available or until &lt;em&gt;timeout&lt;/em&gt; seconds pass.</source>
          <target state="translated">결과가 나올 때까지 또는 &lt;em&gt;시간 초과&lt;/em&gt; 초가 지날 때까지 기다리십시오 .</target>
        </trans-unit>
        <trans-unit id="056d3e2f705449186f7ac1299798e318e2219fbd" translate="yes" xml:space="preserve">
          <source>Wait until the sound device has played every byte in its buffer. (This happens implicitly when the device is closed.) The OSS documentation recommends closing and re-opening the device rather than using &lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사운드 장치가 버퍼의 모든 바이트를 재생할 때까지 기다리십시오. (이것은 장치가 닫힐 때 암시 적으로 발생합니다.) OSS 설명서는 &lt;a href=&quot;#ossaudiodev.oss_audio_device.sync&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt; 사용하는 대신 장치를 닫았다가 다시 열 것을 권장 합니다.</target>
        </trans-unit>
        <trans-unit id="ec111d4c42deb0f141e5bb12ebeed4601999588c" translate="yes" xml:space="preserve">
          <source>Wait until the stream is closed.</source>
          <target state="translated">스트림이 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="eba24cad077b45f2680eff0bdf9fd0536486f778" translate="yes" xml:space="preserve">
          <source>Wait until the thread terminates. This blocks the calling thread until the thread whose &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called terminates &amp;ndash; either normally or through an unhandled exception &amp;ndash; or until the optional timeout occurs.</source>
          <target state="translated">스레드가 끝날 때까지 기다리십시오. 이것은 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 스레드가 정상적으로 또는 처리되지 않은 예외를 통해 종료 될 때까지 또는 선택적 시간 종료가 발생할 때까지 호출 스레드를 차단 합니다.</target>
        </trans-unit>
        <trans-unit id="08e6575bce34aa7e829066c628e1bbe5ee1d226d" translate="yes" xml:space="preserve">
          <source>Waiting Primitives</source>
          <target state="translated">대기 프리미티브</target>
        </trans-unit>
        <trans-unit id="f3bea4a4b6439483e8e78f429d91872ebd9c3c18" translate="yes" xml:space="preserve">
          <source>Wake only one epoll object when the associated fd has an event. The default (if this flag is not set) is to wake all epoll objects polling on a fd.</source>
          <target state="translated">연관된 fd에 이벤트가있을 때 하나의 epoll 오브젝트 만 깨우십시오. 디폴트 (이 플래그가 설정되지 않은 경우)는 fd에서 폴링하는 모든 epoll 오브젝트를 깨우는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a8cfa9cdcc5cfd14c9ca062c6bc6c63f61f28de" translate="yes" xml:space="preserve">
          <source>Wake up all tasks waiting on this condition.</source>
          <target state="translated">이 상태에서 대기중인 모든 작업을 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="93ae74426e9dc6545cb55c36b1af9d2f7460d6e8" translate="yes" xml:space="preserve">
          <source>Wake up all threads waiting on this condition. This method acts like &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt;, but wakes up all waiting threads instead of one. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 상태에서 대기중인 모든 스레드를 깨 웁니다. 이 메소드는 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 처럼 작동 하지만 하나 대신에 대기중인 모든 스레드를 깨 웁니다. 이 메소드가 호출 될 때 호출 스레드가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bd4a765d51a4008bcc07316f2233df4d04edeb34" translate="yes" xml:space="preserve">
          <source>Wake up at most &lt;em&gt;n&lt;/em&gt; tasks (1 by default) waiting on this condition. The method is no-op if no tasks are waiting.</source>
          <target state="translated">이 상태에서 대기하는 최대 &lt;em&gt;n 개의&lt;/em&gt; 작업 (기본적으로 1 개)을 깨 웁니다 . 대기중인 작업이 없으면이 방법은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf340b925958411b04f22ec98ee18783d9a1e220" translate="yes" xml:space="preserve">
          <source>Walk a stack following &lt;code&gt;f.f_back&lt;/code&gt; from the given frame, yielding the frame and line number for each frame. If &lt;em&gt;f&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the current stack is used. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 프레임에서 &lt;code&gt;f.f_back&lt;/code&gt; 뒤에 스택을 걸어 각 프레임의 프레임과 라인 번호를 산출합니다. 하면 &lt;em&gt;F가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 현재 스택이 사용된다. 이 도우미는 &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1a27a446a60fb72e15035278b0c8eb08c42135e9" translate="yes" xml:space="preserve">
          <source>Walk a traceback following &lt;code&gt;tb_next&lt;/code&gt; yielding the frame and line number for each frame. This helper is used with &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt;&lt;code&gt;StackSummary.extract()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tb_next&lt;/code&gt; 다음에 역 추적을 걸어 각 프레임의 프레임과 라인 번호를 산출하십시오. 이 도우미는 &lt;a href=&quot;#traceback.StackSummary.extract&quot;&gt; &lt;code&gt;StackSummary.extract()&lt;/code&gt; &lt;/a&gt; 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="f0b8c638923d24a321f5c6972c05277cf144fb7b" translate="yes" xml:space="preserve">
          <source>Warning Categories</source>
          <target state="translated">경고 카테고리</target>
        </trans-unit>
        <trans-unit id="4b2c3cc9b73eb686d163d3880f8c1912f8b96956" translate="yes" xml:space="preserve">
          <source>Warning categories that are primarily of interest to Python developers (rather than end users of applications written in Python) are ignored by default.</source>
          <target state="translated">Python으로 작성된 응용 프로그램의 최종 사용자가 아닌 Python 개발자가 주로 관심을 갖는 경고 범주는 기본적으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="847345091f804153cb593f84ad497f73b760d180" translate="yes" xml:space="preserve">
          <source>Warning messages are normally written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;, but their disposition can be changed flexibly, from ignoring all warnings to turning them into exceptions. The disposition of warnings can vary based on the &lt;a href=&quot;#warning-categories&quot;&gt;warning category&lt;/a&gt;, the text of the warning message, and the source location where it is issued. Repetitions of a particular warning for the same source location are typically suppressed.</source>
          <target state="translated">경고 메시지는 일반적으로 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 에&lt;/a&gt; 작성 되지만 모든 경고를 무시하는 것에서 예외로 변경하는 것에 이르기까지 배치를 유연하게 변경할 수 있습니다. 경고 처리는 경고 &lt;a href=&quot;#warning-categories&quot;&gt;범주&lt;/a&gt; , 경고 메시지의 텍스트 및 경고가 발생한 원본 위치 에 따라 달라질 수 있습니다 . 동일한 소스 위치에 대한 특정 경고의 반복은 일반적으로 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="6fa8d6a7b1b2b2ba758f00991e78c8631d91fa69" translate="yes" xml:space="preserve">
          <source>Warning messages are typically issued in situations where it is useful to alert the user of some condition in a program, where that condition (normally) doesn&amp;rsquo;t warrant raising an exception and terminating the program. For example, one might want to issue a warning when a program uses an obsolete module.</source>
          <target state="translated">경고 메시지는 일반적으로 프로그램에서 사용자에게 특정 조건에 대해 경고하는 것이 유용한 상황 (일반적으로)에서 예외 발생 및 프로그램 종료를 보증하지 않는 상황에서 발행됩니다. 예를 들어, 프로그램이 더 이상 사용되지 않는 모듈을 사용할 때 경고를 발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="09505683c6b5bf3932806860c33becb79c315a18" translate="yes" xml:space="preserve">
          <source>Watch a file descriptor for read events</source>
          <target state="translated">읽기 이벤트에 대한 파일 디스크립터 시청</target>
        </trans-unit>
        <trans-unit id="56bdf1df2d6de2dce3cb70cc7a1d445ff547ab4f" translate="yes" xml:space="preserve">
          <source>Watch for events on a network device [not available on Mac OS X]</source>
          <target state="translated">네트워크 장비에서 이벤트를 확인하십시오 (Mac OS X에서는 사용할 수 없음)</target>
        </trans-unit>
        <trans-unit id="a77a9f44b3dc9612388cdc66f0973471511ca754" translate="yes" xml:space="preserve">
          <source>Watch for events on a process id</source>
          <target state="translated">프로세스 ID에서 이벤트를 감시하십시오</target>
        </trans-unit>
        <trans-unit id="7b8d444f092659996944c98103896607bf61afda" translate="yes" xml:space="preserve">
          <source>WatchedFileHandler</source>
          <target state="translated">WatchedFileHandler</target>
        </trans-unit>
        <trans-unit id="6c952491e9149238af6d5009db8cdd488e66dcb2" translate="yes" xml:space="preserve">
          <source>Watching file descriptors</source>
          <target state="translated">파일 디스크립터 관찰</target>
        </trans-unit>
        <trans-unit id="853f81f21983a508519fe18408fdef4381a53c85" translate="yes" xml:space="preserve">
          <source>Wave_read Objects</source>
          <target state="translated">Wave_read 객체</target>
        </trans-unit>
        <trans-unit id="40b33acc387d819933f3a4e356b1224932bc5fe4" translate="yes" xml:space="preserve">
          <source>Wave_read objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 Wave_read 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e5965f88e6bbc53b5aa0194a15009dfa785bfa" translate="yes" xml:space="preserve">
          <source>Wave_write Objects</source>
          <target state="translated">Wave_write 객체</target>
        </trans-unit>
        <trans-unit id="b2438cc47ac4cf690f00fb0bcb5a03c6f4fd235a" translate="yes" xml:space="preserve">
          <source>Wave_write objects, as returned by &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 Wave_write 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1d2fa5af87cd6de5bce19db6524cc1d529a3d0" translate="yes" xml:space="preserve">
          <source>Ways to reference it</source>
          <target state="translated">그것을 참조하는 방법</target>
        </trans-unit>
        <trans-unit id="d85190bf88b389c7893fdc3f90cf47dcd9cbeca0" translate="yes" xml:space="preserve">
          <source>We can import this data by reading from a file:</source>
          <target state="translated">파일을 읽어서이 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b789995e580ea25048a2285a5926e24768d9cf2" translate="yes" xml:space="preserve">
          <source>We can remove elements using &lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt;&lt;code&gt;Element.remove()&lt;/code&gt;&lt;/a&gt;. Let&amp;rsquo;s say we want to remove all countries with a rank higher than 50:</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.Element.remove&quot;&gt; &lt;code&gt;Element.remove()&lt;/code&gt; &lt;/a&gt; 사용하여 요소를 제거 할 수 있습니다 . 순위가 50보다 높은 모든 국가를 제거하려고한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="215e314610fefea13b5da68c465496bf961d967a" translate="yes" xml:space="preserve">
          <source>We can see that Python has loaded &lt;code&gt;8173 KiB&lt;/code&gt; of module data (bytecode and constants), and that this is &lt;code&gt;4428 KiB&lt;/code&gt; more than had been loaded before the tests, when the previous snapshot was taken. Similarly, the &lt;a href=&quot;linecache#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module has cached &lt;code&gt;940 KiB&lt;/code&gt; of Python source code to format tracebacks, all of it since the previous snapshot.</source>
          <target state="translated">우리는 파이썬이 &lt;code&gt;8173 KiB&lt;/code&gt; 의 모듈 데이터 (바이트 코드와 상수)를 로드했으며, 이전 스냅 샷을 만들 때 테스트 이전에로드 된 것보다 &lt;code&gt;4428 KiB&lt;/code&gt; 더 많은 것을 알 수 있습니다. 마찬가지로 &lt;a href=&quot;linecache#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;code&gt;940 KiB&lt;/code&gt; 의 Python 소스 코드를 캐시 하여 이전 스냅 샷 이후의 모든 역 추적 형식을 추적했습니다.</target>
        </trans-unit>
        <trans-unit id="a3cfb793dfee5070acdfd0a536b9c921adeb6f59" translate="yes" xml:space="preserve">
          <source>We can see that Python loaded &lt;code&gt;4855 KiB&lt;/code&gt; data (bytecode and constants) from modules and that the &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module allocated &lt;code&gt;244 KiB&lt;/code&gt; to build &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">파이썬이 모듈에서 &lt;code&gt;4855 KiB&lt;/code&gt; 데이터 (바이트 코드 및 상수)를 로드 했으며 &lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈이 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt; 유형 을 빌드하기 위해 &lt;code&gt;244 KiB&lt;/code&gt; 를 할당 했음을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b16f5f4ffc8f56cb2bb30fa071edafeee046554" translate="yes" xml:space="preserve">
          <source>We can see that the most memory was allocated in the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; module to load data (bytecode and constants) from modules: &lt;code&gt;870.1 KiB&lt;/code&gt;. The traceback is where the &lt;a href=&quot;importlib#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; loaded data most recently: on the &lt;code&gt;import pdb&lt;/code&gt; line of the &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module. The traceback may change if a new module is loaded.</source>
          <target state="translated">&lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 모듈 에 가장 많은 메모리가 할당되어 모듈 ( &lt;code&gt;870.1 KiB&lt;/code&gt; )에서 데이터 (바이트 코드 및 상수)를로드 했음을 알 수 있습니다. 역 추적은 &lt;a href=&quot;importlib#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 가 가장 최근에 데이터를로드 한 위치 입니다 ( &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;import pdb&lt;/code&gt; 행) . 새 모듈이로드되면 트레이스 백이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41498dcbefc1d323bf74e1d9ce5b53a4cc360514" translate="yes" xml:space="preserve">
          <source>We have defined the &lt;code&gt;struct _frozen&lt;/code&gt; data type, so we can get the pointer to the table:</source>
          <target state="translated">&lt;code&gt;struct _frozen&lt;/code&gt; 데이터 형식 을 정의 했으므로 테이블에 대한 포인터를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cfcb5b8900d48c6735c6871c6773651f8b0c087" translate="yes" xml:space="preserve">
          <source>We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method as follows:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 클래스를 구현하려고 시도 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd9a3eb14b1a885e62804e74860fd9a945f731e9" translate="yes" xml:space="preserve">
          <source>We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; method as follows:</source>
          <target state="translated">We might try to implement the class using a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; method as follows:</target>
        </trans-unit>
        <trans-unit id="31f330039a177b6f4ba692d81baa88bba27b8da4" translate="yes" xml:space="preserve">
          <source>We recommend that all application designers seriously consider doing this; we have seen many protocols where a hash that is computed in one part of the protocol can be used in an entirely different part because two hash computations were done on similar or related data, and the attacker can force the application to make the hash inputs the same. Personalizing each hash function used in the protocol summarily stops this type of attack.</source>
          <target state="translated">모든 응용 프로그램 디자이너는이 작업을 진지하게 고려할 것을 권장합니다. 우리는 프로토콜의 한 부분에서 계산 된 해시가 유사하거나 관련된 데이터에 대해 두 개의 해시 계산이 수행 되었기 때문에 완전히 다른 부분에서 사용될 수있는 많은 프로토콜을 보았으며, 공격자는 응용 프로그램이 해시 입력을하도록 강제 할 수 있습니다. 같은. 프로토콜에 사용 된 각 해시 함수를 개인화하면 이러한 유형의 공격이 요약됩니다.</target>
        </trans-unit>
        <trans-unit id="366243de9e8dd818c63915fa0eb00c27eb54fd4e" translate="yes" xml:space="preserve">
          <source>We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</source>
          <target state="translated">우리는 객체가 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 표현식 에서 사용될 수 있다면 &lt;strong&gt;awaitable&lt;/strong&gt; 객체 라고 말합니다 . 많은 asyncio API는 대기 가능 항목을 허용하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d1fe7a751621e826dae3cf98b7078b3b5dca2ddc" translate="yes" xml:space="preserve">
          <source>We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</source>
          <target state="translated">We say that an object is an &lt;strong&gt;awaitable&lt;/strong&gt; object if it can be used in an &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; expression. Many asyncio APIs are designed to accept awaitables.</target>
        </trans-unit>
        <trans-unit id="57b5ab6e43e7e9a6b2ac86fe4eb61e522b2004b3" translate="yes" xml:space="preserve">
          <source>We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt;&lt;code&gt;Integral&lt;/code&gt;&lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; should be defined as:</source>
          <target state="translated">혼합 모드 연산이 저자가 두 인수의 유형에 대해 알고있는 구현을 호출하거나 가장 가까운 내장 유형으로 변환하여 연산을 수행하도록 산술 연산을 구현하려고합니다. &lt;a href=&quot;#numbers.Integral&quot;&gt; &lt;code&gt;Integral&lt;/code&gt; &lt;/a&gt; 하위 유형의 경우 이는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 가 다음과 같이 정의되어야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="bc761093cffe85e655f26465122794f56dd31a1d" translate="yes" xml:space="preserve">
          <source>We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt;&lt;code&gt;Integral&lt;/code&gt;&lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; should be defined as:</source>
          <target state="translated">We want to implement the arithmetic operations so that mixed-mode operations either call an implementation whose author knew about the types of both arguments, or convert both to the nearest built in type and do the operation there. For subtypes of &lt;a href=&quot;#numbers.Integral&quot;&gt; &lt;code&gt;Integral&lt;/code&gt; &lt;/a&gt;, this means that &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; should be defined as:</target>
        </trans-unit>
        <trans-unit id="f7d8571598e317c5f7d8abde12db88f57270cea2" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll be using the following XML document as the sample data for this section:</source>
          <target state="translated">이 섹션의 샘플 데이터로 다음 XML 문서를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="498251e1ee5e102841353e28c1ae8f3a3c95d0ed" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re given a training dataset with measurements for eight people. The measurements are assumed to be normally distributed, so we summarize the data with &lt;a href=&quot;#statistics.NormalDist&quot;&gt;&lt;code&gt;NormalDist&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리는 8 명을 측정 한 훈련 데이터 세트를 받았습니다. 측정 값은 정규 분포로 가정되므로 &lt;a href=&quot;#statistics.NormalDist&quot;&gt; &lt;code&gt;NormalDist&lt;/code&gt; 로&lt;/a&gt; 데이터를 요약합니다 .</target>
        </trans-unit>
        <trans-unit id="53fa691162f39e16d25e99147762bfdb99f7853f" translate="yes" xml:space="preserve">
          <source>Weak Reference Objects</source>
          <target state="translated">약한 참조 객체</target>
        </trans-unit>
        <trans-unit id="5ee5214a04390535aa3407199b4313f1342ce933" translate="yes" xml:space="preserve">
          <source>Weak reference objects have no methods and no attributes besides &lt;a href=&quot;#weakref.ref.__callback__&quot;&gt;&lt;code&gt;ref.__callback__&lt;/code&gt;&lt;/a&gt;. A weak reference object allows the referent to be obtained, if it still exists, by calling it:</source>
          <target state="translated">약한 참조 객체에는 &lt;a href=&quot;#weakref.ref.__callback__&quot;&gt; &lt;code&gt;ref.__callback__&lt;/code&gt; &lt;/a&gt; 외에 메소드와 속성이 없습니다 . 약한 참조 객체는 참조가 존재한다면 참조를 호출하여 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="269b06c67f58c7694dc71ae7f0afae036d4818c7" translate="yes" xml:space="preserve">
          <source>Weak references are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;객체&lt;/em&gt; 가 해시 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;가능한&lt;/a&gt; 경우 약한 참조는 해시 가능합니다 . &lt;em&gt;객체&lt;/em&gt; 가 삭제 된 후에도 해시 값을 유지합니다 . 경우 &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; 유일한 후 처음이라고 &lt;em&gt;객체가&lt;/em&gt; 삭제 된 통화가 올릴 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="04913217684b6d8f5cd00da928dd46e054c1b557" translate="yes" xml:space="preserve">
          <source>Weak references are &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt;&lt;code&gt;hash()&lt;/code&gt;&lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Weak references are &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; if the &lt;em&gt;object&lt;/em&gt; is hashable. They will maintain their hash value even after the &lt;em&gt;object&lt;/em&gt; was deleted. If &lt;a href=&quot;functions#hash&quot;&gt; &lt;code&gt;hash()&lt;/code&gt; &lt;/a&gt; is called the first time only after the &lt;em&gt;object&lt;/em&gt; was deleted, the call will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="bf5772b94a870ac2c2a272ce1b65b3d3ec5cdd0a" translate="yes" xml:space="preserve">
          <source>Weak references support tests for equality, but not ordering. If the referents are still alive, two references have the same equality relationship as their referents (regardless of the &lt;em&gt;callback&lt;/em&gt;). If either referent has been deleted, the references are equal only if the reference objects are the same object.</source>
          <target state="translated">약한 참조는 평등에 대한 테스트를 지원하지만 순서는 지원하지 않습니다. 참조가 여전히 살아있는 경우 두 참조는 ( &lt;em&gt;콜백에&lt;/em&gt; 관계없이) 참조와 동일한 동등 관계를 갖습니다 . 참조가 삭제 된 경우 참조 개체가 동일한 개체 인 경우에만 참조가 동일합니다.</target>
        </trans-unit>
        <trans-unit id="160d43660c7e93a34cbf9e6d0683b3f1d070e0fc" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt;, Section 10.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc2518.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2518&lt;/strong&gt;&lt;/a&gt; , 섹션 10.1</target>
        </trans-unit>
        <trans-unit id="4a73d3d2fe230642eaf557fd34c51c84ef4ff1ba" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.1</target>
        </trans-unit>
        <trans-unit id="295bedc312a6b750f29bbdcb9c55b71841762311" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.1</target>
        </trans-unit>
        <trans-unit id="74f89d6c2e38467f5b13ae0091d9a8a51c1b16e1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-41&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.2</target>
        </trans-unit>
        <trans-unit id="a2bff95c1e44c73456e7cae10cda54d6fa398f6f" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-42&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.3</target>
        </trans-unit>
        <trans-unit id="abe7a48219d118193d54ce7547d400d9545dd2cc" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.2</target>
        </trans-unit>
        <trans-unit id="fd468def379a57145ba45b0607d05b11370a29a3" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-43&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.4</target>
        </trans-unit>
        <trans-unit id="8819e6862e6a19eeb00ace3fec0603e588d8328b" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-44&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.3</target>
        </trans-unit>
        <trans-unit id="bca3fc2cd5c152a0bdbb345654a6d0db591b3ea4" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.4</target>
        </trans-unit>
        <trans-unit id="98acc379abdeda29844b5028a71fa64b09754bd1" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-56&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt; , 섹션 11.5</target>
        </trans-unit>
        <trans-unit id="45ce951509f93a486a7c99b75337871dfff2d631" translate="yes" xml:space="preserve">
          <source>WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-59&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</source>
          <target state="translated">WebDAV &lt;a href=&quot;https://tools.ietf.org/html/rfc4918.html&quot; id=&quot;index-59&quot;&gt;&lt;strong&gt;RFC 4918&lt;/strong&gt;&lt;/a&gt;, Section 11.5</target>
        </trans-unit>
        <trans-unit id="98047a8d0918ebb9d2a9d3244b26fc929a5bcb7c" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</source>
          <target state="translated">WebDAV 바인딩 확장 &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt; , 섹션 7.1 (실험적)</target>
        </trans-unit>
        <trans-unit id="c50e846faf966023af5fd09f48f61a853f3480e1" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</source>
          <target state="translated">WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.1 (Experimental)</target>
        </trans-unit>
        <trans-unit id="2525087157bd91fd05837fb713cd7d80f247559d" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</source>
          <target state="translated">WebDAV 바인딩 확장 &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-57&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt; , 섹션 7.2 (실험적)</target>
        </trans-unit>
        <trans-unit id="5b74f2b39309ad2c4f5a3646e6db00e00616b578" translate="yes" xml:space="preserve">
          <source>WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-60&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</source>
          <target state="translated">WebDAV Binding Extensions &lt;a href=&quot;https://tools.ietf.org/html/rfc5842.html&quot; id=&quot;index-60&quot;&gt;&lt;strong&gt;RFC 5842&lt;/strong&gt;&lt;/a&gt;, Section 7.2 (Experimental)</target>
        </trans-unit>
        <trans-unit id="efaa49e0aaddcee60c9e56544c7c0972d0e98dcb" translate="yes" xml:space="preserve">
          <source>WebP files</source>
          <target state="translated">WebP 파일</target>
        </trans-unit>
        <trans-unit id="fe3f61ddecbabd9df7b81c596b0e344f7a9a1ef0" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (월요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 월요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="957344126e376dfec66a5865493968e5033a759d" translate="yes" xml:space="preserve">
          <source>Week number of the year (Monday as the first day of the week) as a decimal number. All days in a new year preceding the first Monday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (월요일의 첫 번째 요일)를 10 진수로 나타냅니다. 첫 번째 월요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3aadb81eb1a1699671247b51c01b0cc44432b8bb" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a decimal number [00,53]. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">연도의 주 번호 (일요일의 첫 번째 요일)를 10 진수로 표시합니다 [00,53]. 첫 번째 일요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f93371df01a8682d904d17bbc9258abc77e066be" translate="yes" xml:space="preserve">
          <source>Week number of the year (Sunday as the first day of the week) as a zero padded decimal number. All days in a new year preceding the first Sunday are considered to be in week 0.</source>
          <target state="translated">0으로 채워진 10 진수로 표시되는 연중 주 번호 (일요일의 첫 번째 요일)입니다. 첫 번째 일요일 이전의 새해의 모든 날은 0 주로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="027417f7bd7fb85e6bdc77ed8d873c5e62146b37" translate="yes" xml:space="preserve">
          <source>Weekday (0=Monday)</source>
          <target state="translated">평일 (0 = 월요일)</target>
        </trans-unit>
        <trans-unit id="da94621ef8999a8ac972599f062234bc846d53f9" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number [0(Sunday),6].</source>
          <target state="translated">평일을 10 진수로 표시 [0 (일요일), 6].</target>
        </trans-unit>
        <trans-unit id="149ccb2de453647267122d8a96dda7b0ae559978" translate="yes" xml:space="preserve">
          <source>Weekday as a decimal number, where 0 is Sunday and 6 is Saturday.</source>
          <target state="translated">평일을 10 진수로 표시합니다. 여기서 0은 일요일이고 6은 토요일입니다.</target>
        </trans-unit>
        <trans-unit id="bb0fc2dc3a75233397a7a28f15f9662ee67c106e" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s abbreviated name.</source>
          <target state="translated">로케일의 약칭으로 평일.</target>
        </trans-unit>
        <trans-unit id="bb1e28b07531c9368250cf22e73ebdac9375108f" translate="yes" xml:space="preserve">
          <source>Weekday as locale&amp;rsquo;s full name.</source>
          <target state="translated">로케일의 전체 이름으로 평일.</target>
        </trans-unit>
        <trans-unit id="f6103eca7ab314d7e7cfd58095933632e58c72c4" translate="yes" xml:space="preserve">
          <source>Weibull distribution. &lt;em&gt;alpha&lt;/em&gt; is the scale parameter and &lt;em&gt;beta&lt;/em&gt; is the shape parameter.</source>
          <target state="translated">와 이블 분포. &lt;em&gt;alpha&lt;/em&gt; 는 scale 매개 변수이고 &lt;em&gt;beta&lt;/em&gt; 는 shape 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="c74e5c5d315ff3f823c6f47d8fb4fc7d0c8fe3e0" translate="yes" xml:space="preserve">
          <source>Western Europe</source>
          <target state="translated">서유럽</target>
        </trans-unit>
        <trans-unit id="ed6c63b0557e98944ebbf0299cfb303283e1e58e" translate="yes" xml:space="preserve">
          <source>What About Exceptions?</source>
          <target state="translated">예외는 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="6ee52e14b570b091324e858324b60dbe6df01e5a" translate="yes" xml:space="preserve">
          <source>What Is Deterministic Profiling?</source>
          <target state="translated">결정 론적 프로파일 링이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e5ac2d9156eb23a3dbdb1999476310a8ac6727e3" translate="yes" xml:space="preserve">
          <source>What can be pickled and unpickled?</source>
          <target state="translated">피클과 피클 링 할 수있는 것은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="fcf1ade96b2641b7f1c03643a78aaf7e4461cb47" translate="yes" xml:space="preserve">
          <source>What has happened is that &lt;code&gt;[[]]&lt;/code&gt; is a one-element list containing an empty list, so all three elements of &lt;code&gt;[[]] * 3&lt;/code&gt; are references to this single empty list. Modifying any of the elements of &lt;code&gt;lists&lt;/code&gt; modifies this single list. You can create a list of different lists this way:</source>
          <target state="translated">일어났던 것은 즉 &lt;code&gt;[[]]&lt;/code&gt; 모든 세 요소 있도록 빈 목록을 포함하는 하나의 요소 목록 &lt;code&gt;[[]] * 3&lt;/code&gt; 이 하나의 빈 목록을 참조한다. &lt;code&gt;lists&lt;/code&gt; 요소를 수정하면이 단일 목록이 수정됩니다. 이 방법으로 다른 목록의 목록을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea4146566e7e0cd8f5a8d4c34d120c18c585cf1" translate="yes" xml:space="preserve">
          <source>What the &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt;&lt;code&gt;parseString()&lt;/code&gt;&lt;/a&gt; functions do is connect an XML parser with a &amp;ldquo;DOM builder&amp;rdquo; that can accept parse events from any SAX parser and convert them into a DOM tree. The name of the functions are perhaps misleading, but are easy to grasp when learning the interfaces. The parsing of the document will be completed before these functions return; it&amp;rsquo;s simply that these functions do not provide a parser implementation themselves.</source>
          <target state="translated">무엇 &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#xml.dom.minidom.parseString&quot;&gt; &lt;code&gt;parseString()&lt;/code&gt; &lt;/a&gt; 함수가하는 일은 어떤 SAX 파서에서 구문 분석 이벤트를 받아 DOM 트리로 변환 할 수있는 &quot;DOM 빌더&quot;와 XML 파서를 연결합니다. 함수의 이름은 오해의 소지가 있지만 인터페이스를 배울 때 이해하기 쉽습니다. 이러한 함수가 반환되기 전에 문서 파싱이 완료됩니다. 단순히 이러한 함수가 파서 구현 자체를 제공하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e3c2e61a8fe0f76312d3b9af5434565ee7de2ec5" translate="yes" xml:space="preserve">
          <source>What the new Enum class will record as its name.</source>
          <target state="translated">새 Enum 클래스 이름으로 기록 할 내용</target>
        </trans-unit>
        <trans-unit id="0711f3c581dc5072b2cf9e260f7e705f68754df8" translate="yes" xml:space="preserve">
          <source>What this means in practice is that to support finding distribution package metadata in locations other than the file system, subclass &lt;code&gt;Distribution&lt;/code&gt; and implement the abstract methods. Then from a custom finder, return instances of this derived &lt;code&gt;Distribution&lt;/code&gt; in the &lt;code&gt;find_distributions()&lt;/code&gt; method.</source>
          <target state="translated">이것이 실제로 의미하는 것은 파일 시스템, 서브 클래스 &lt;code&gt;Distribution&lt;/code&gt; 이외의 위치에서 배포 패키지 메타 데이터 찾기를 지원 하고 추상 메서드를 구현한다는 것입니다. 그런 다음 사용자 정의 파인더 에서 &lt;code&gt;find_distributions()&lt;/code&gt; 메소드 에서이 파생 된 &lt;code&gt;Distribution&lt;/code&gt; 의 인스턴스를 리턴 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5390d096f592c9ee00a6e75cd2a40d199772255f" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the Execution Context?</source>
          <target state="translated">실행 컨텍스트는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="86d433886770959c5f8b1c7316fb956a27baddc4" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#abc.abstractmethod&quot;&gt;&lt;code&gt;abstractmethod()&lt;/code&gt;&lt;/a&gt; is applied in combination with other method descriptors, it should be applied as the innermost decorator, as shown in the following usage examples:</source>
          <target state="translated">경우 &lt;a href=&quot;#abc.abstractmethod&quot;&gt; &lt;code&gt;abstractmethod()&lt;/code&gt; &lt;/a&gt; 다른 방법 디스크립터와 함께 적용되는 다음의 예문에 도시 된 바와 같이, 또, 최 데코으로 적용되어야한다 :</target>
        </trans-unit>
        <trans-unit id="7f660ad4252bf5d8a48ac42ba8b9a8060d0a917e" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; generates help messages, it needs some way to refer to each expected argument. By default, ArgumentParser objects use the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value as the &amp;ldquo;name&amp;rdquo; of each object. By default, for positional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is used directly, and for optional argument actions, the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value is uppercased. So, a single positional argument with &lt;code&gt;dest='bar'&lt;/code&gt; will be referred to as &lt;code&gt;bar&lt;/code&gt;. A single optional argument &lt;code&gt;--foo&lt;/code&gt; that should be followed by a single command-line argument will be referred to as &lt;code&gt;FOO&lt;/code&gt;. An example:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 가 도움말 메시지를 생성 할 때 예상되는 각 인수를 참조 할 방법이 필요합니다. 기본적으로 ArgumentParser 객체는 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값을 각 객체의 &quot;이름&quot;으로 사용합니다. 기본적으로 위치 인수 조치의 경우 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값이 직접 사용되며 선택적 인수 조치의 경우 &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; 값이 대문자입니다. 따라서 &lt;code&gt;dest='bar'&lt;/code&gt; 인 단일 위치 인수는 bar 라고 &lt;code&gt;bar&lt;/code&gt; . 단일 명령 행 인수 뒤에 와야 하는 단일 선택적 인수 &lt;code&gt;--foo&lt;/code&gt; 는 &lt;code&gt;FOO&lt;/code&gt; 라고합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="bbb7e98f193941e94a08737449c4a58a55c161fa" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with &lt;code&gt;action='store_const'&lt;/code&gt; or &lt;code&gt;action='append_const'&lt;/code&gt;. These actions add the &lt;code&gt;const&lt;/code&gt; value to one of the attributes of the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;#action&quot;&gt;action&lt;/a&gt; description for examples.</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 호출되는 &lt;code&gt;action='store_const'&lt;/code&gt; 또는 &lt;code&gt;action='append_const'&lt;/code&gt; . 이러한 액션은 &lt;code&gt;const&lt;/code&gt; 값을 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 반환 한 객체의 속성 중 하나에 추가합니다 . 예제 는 &lt;a href=&quot;#action&quot;&gt;조치&lt;/a&gt; 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="908430b67ffab7192c58d413878590107f99ac8a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is called with option strings (like &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--foo&lt;/code&gt;) and &lt;code&gt;nargs='?'&lt;/code&gt;. This creates an optional argument that can be followed by zero or one command-line arguments. When parsing the command line, if the option string is encountered with no command-line argument following it, the value of &lt;code&gt;const&lt;/code&gt; will be assumed instead. See the &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; description for examples.</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 옵션 (같은 문자열이라고 &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--foo&lt;/code&gt; )와 &lt;code&gt;nargs='?'&lt;/code&gt; . 이렇게하면 0 개 또는 1 개의 명령 줄 인수가 올 수있는 선택적 인수가 만들어집니다. 명령 행을 구문 분석 할 때 옵션 문자열에 명령 행 인수가 없으면 &lt;code&gt;const&lt;/code&gt; 값이 대신 가정됩니다. 예제 는 &lt;a href=&quot;#nargs&quot;&gt;nargs&lt;/a&gt; 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02441c1f960fb0baf4239fae2d2c88d890e1b2fc" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; is called, optional arguments will be identified by the &lt;code&gt;-&lt;/code&gt; prefix, and the remaining arguments will be assumed to be positional:</source>
          <target state="translated">때 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 호출, 선택적 인수는에 의해 식별됩니다 &lt;code&gt;-&lt;/code&gt; 접두사, 나머지 인수는 위치로 간주됩니다</target>
        </trans-unit>
        <trans-unit id="629de685613646d00ea10bd953237cc1c7924121" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; is available then backwards-compatible functionality is provided.</source>
          <target state="translated">때 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 다음, 이전 버전과 호환 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d39c6fdaaf5a388a75f42af12f2c38b99a2423" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; is executed:</source>
          <target state="translated">&lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; &lt;/a&gt; 가 실행될 때 :</target>
        </trans-unit>
        <trans-unit id="fd23a56d325ff0bf7a6e61d85cd4f34a2147f5d5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; is initialized the main process is assigned a random string using &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 초기화되는 주요 프로세스를 사용하여 임의의 문자열을 할당 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11aa0c7fff9e9b567a187a2e5b13f5a8d5be7181" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; is supported, assignments to items in &lt;code&gt;os.environ&lt;/code&gt; are automatically translated into corresponding calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to assign to items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 지원되며 항목에 할당 &lt;code&gt;os.environ&lt;/code&gt; 은 자동으로 호출 해당로 번역 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; ; 그러나, 호출 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 업데이트되지 않습니다 &lt;code&gt;os.environ&lt;/code&gt; 그것의 항목에 할당하는 것이 실제로 바람직하므로, &lt;code&gt;os.environ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c01e42f0e3d04cc243dd7a57f8e10baf4c6db3b1" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt;&lt;code&gt;st_file_attributes&lt;/code&gt;&lt;/a&gt; has the &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; set, this field contains the tag identifying the type of reparse point. See the &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt; &lt;code&gt;st_file_attributes&lt;/code&gt; 가&lt;/a&gt; 갖는다 &lt;code&gt;FILE_ATTRIBUTE_REPARSE_POINT&lt;/code&gt; 의 집합,이 필드는 재분석 포인트의 종류를 식별하는 태그를 포함한다. &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;code&gt;IO_REPARSE_TAG_*&lt;/code&gt; 상수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf790e480175785930a548355dd8f5086f5c9b7a" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; is supported, deletion of items in &lt;code&gt;os.environ&lt;/code&gt; is automatically translated into a corresponding call to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to delete items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 지지되어있는 항목의 삭제 &lt;code&gt;os.environ&lt;/code&gt; 가 자동으로 해당 통화로 번역 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; ; 그러나, 호출 &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 업데이트되지 않습니다 &lt;code&gt;os.environ&lt;/code&gt; 가의 항목을 삭제 실제로 바람직하므로, &lt;code&gt;os.environ&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="e962e2ecd1be54236efb9b9cd0dcb1c0a6890061" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; detects a source request (see &lt;a href=&quot;#shlex.shlex.source&quot;&gt;&lt;code&gt;source&lt;/code&gt;&lt;/a&gt; below) this method is given the following token as argument, and expected to return a tuple consisting of a filename and an open file-like object.</source>
          <target state="translated">경우 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; 은&lt;/a&gt; 원본 요청을 검출한다 (참조 &lt;a href=&quot;#shlex.shlex.source&quot;&gt; &lt;code&gt;source&lt;/code&gt; &lt;/a&gt; 이 방법은, 인수로서 주어진 다음 토큰 및 파일명으로 이루어지는 튜플과 같은 오픈 파일 객체를 반환 할 것으로 예상된다 아래 참조).</target>
        </trans-unit>
        <trans-unit id="003413e572cb08fc012d56140cf949b7ac4b28b8" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt;&lt;code&gt;keylog_filename&lt;/code&gt;&lt;/a&gt; is supported and the environment variable &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; is set, &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; enables key logging.</source>
          <target state="translated">경우 &lt;a href=&quot;#ssl.SSLContext.keylog_filename&quot;&gt; &lt;code&gt;keylog_filename&lt;/code&gt; 가&lt;/a&gt; 지지되고 환경 변수 &lt;code id=&quot;index-2&quot;&gt;SSLKEYLOGFILE&lt;/code&gt; 가 설정되어 &lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 키 로깅 할 수있다.</target>
        </trans-unit>
        <trans-unit id="ae592f12245b7b672b2b312ad6a41430e2206fbb" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is creating a mock for you, it is common that the first thing you need to do is to configure the mock. Some of that configuration can be done in the call to patch. Any arbitrary keywords you pass into the call will be used to set attributes on the created mock:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 가 모의 객체를 만들 때 가장 먼저해야 할 일은 모의 객체를 구성하는 것입니다. 해당 구성 중 일부는 패치 호출에서 수행 할 수 있습니다. 호출에 전달한 임의의 키워드는 생성 된 모의 속성을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="984f54d038232b41fa8fb278710d0228edce2b46" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, whitespace immediately following the &lt;em&gt;delimiter&lt;/em&gt; is ignored. The default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 바로 다음 공백, &lt;em&gt;구분 기호는&lt;/em&gt; 무시됩니다. 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5fbc90776622a0bcb40ca2bd0c844997d03d08a5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;COLUMNS&lt;/code&gt; or &lt;code&gt;LINES&lt;/code&gt; is not defined, which is the common case, the terminal connected to &lt;a href=&quot;sys#sys.__stdout__&quot;&gt;&lt;code&gt;sys.__stdout__&lt;/code&gt;&lt;/a&gt; is queried by invoking &lt;a href=&quot;os#os.get_terminal_size&quot;&gt;&lt;code&gt;os.get_terminal_size()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;COLUMNS&lt;/code&gt; 또는 &lt;code&gt;LINES&lt;/code&gt; 정의되지 않고, 일반적인 경우, 접속 단자에 이는 &lt;a href=&quot;sys#sys.__stdout__&quot;&gt; &lt;code&gt;sys.__stdout__&lt;/code&gt; &lt;/a&gt; IS 조회 된 호출하여 &lt;a href=&quot;os#os.get_terminal_size&quot;&gt; &lt;code&gt;os.get_terminal_size()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="be1c8634db85a77e79d600408825132f805fd2d9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;None&lt;/code&gt; is passed, it&amp;rsquo;s up to the class designer to decide the best response. For example, returning &lt;code&gt;None&lt;/code&gt; is appropriate if the class wishes to say that time objects don&amp;rsquo;t participate in the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; protocols. It may be more useful for &lt;code&gt;utcoffset(None)&lt;/code&gt; to return the standard UTC offset, as there is no other convention for discovering the standard offset.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 전달 되면 최상의 응답을 결정하는 것은 클래스 디자이너의 책임입니다. 예를 들어, 클래스가 시간 객체가 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 프로토콜에 참여하지 않는다고 말하고 싶다면 &lt;code&gt;None&lt;/code&gt; 을 반환하는 것이 적절 합니다. 표준 오프셋을 발견하는 다른 규칙이 없으므로 &lt;code&gt;utcoffset(None)&lt;/code&gt; 이 표준 UTC 오프셋을 반환하는 것이 더 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d247f34d37a9741e0b40611aec77465bb0b0659a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PATH_INFO&lt;/code&gt; is just a &amp;ldquo;/&amp;rdquo;, this routine returns an empty string and appends a trailing slash to &lt;code&gt;SCRIPT_NAME&lt;/code&gt;, even though empty path segments are normally ignored, and &lt;code&gt;SCRIPT_NAME&lt;/code&gt; doesn&amp;rsquo;t normally end in a slash. This is intentional behavior, to ensure that an application can tell the difference between URIs ending in &lt;code&gt;/x&lt;/code&gt; from ones ending in &lt;code&gt;/x/&lt;/code&gt; when using this routine to do object traversal.</source>
          <target state="translated">때 &lt;code&gt;PATH_INFO&lt;/code&gt; 는 단지 &quot;/&quot;이 돌아 간다 빈 문자열과에 후행 슬래시 추가 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 을 빈 경로 세그먼트는 일반적으로 무시에도 불구하고, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 은 일반적으로 슬래시로 끝나지 않습니다. 이 응용 프로그램이 종료 된 URI 사이의 차이를 구별 할 수 있도록하기 위해, 의도적 인 동작입니다에서 &lt;code&gt;/x&lt;/code&gt; 로 끝나는 것과 &lt;code&gt;/x/&lt;/code&gt; 객체 탐색을 할이 루틴을 사용하는 경우.</target>
        </trans-unit>
        <trans-unit id="3259a3e106d026a974e471af3e09c6877af341cc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;True&lt;/code&gt;, raise exception &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; on bad CSV input. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">때 &lt;code&gt;True&lt;/code&gt; , 인상 예외 &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 나쁜 CSV 입력합니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e22a01415028c5429e1a93f81e2fccf26594dcd7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;ZoneInfo(key)&lt;/code&gt; is called, the constructor first searches the directories specified in &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; for a file matching &lt;code&gt;key&lt;/code&gt;, and on failure looks for a match in the tzdata package. This behavior can be configured in three ways:</source>
          <target state="translated">When &lt;code&gt;ZoneInfo(key)&lt;/code&gt; is called, the constructor first searches the directories specified in &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; &lt;/a&gt; for a file matching &lt;code&gt;key&lt;/code&gt; , and on failure looks for a match in the tzdata package. This behavior can be configured in three ways:</target>
        </trans-unit>
        <trans-unit id="7249093ec9e4d3cc83bc42119bb94a864c87dc19" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;punctuation_chars&lt;/code&gt; is specified, the &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt;&lt;code&gt;wordchars&lt;/code&gt;&lt;/a&gt; attribute is augmented with the characters &lt;code&gt;~-./*?=&lt;/code&gt;. That is because these characters can appear in file names (including wildcards) and command-line arguments (e.g. &lt;code&gt;--color=auto&lt;/code&gt;). Hence:</source>
          <target state="translated">때 &lt;code&gt;punctuation_chars&lt;/code&gt; 가 지정되면, &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt; &lt;code&gt;wordchars&lt;/code&gt; 의&lt;/a&gt; 속성은 문자로 증강되어 &lt;code&gt;~-./*?=&lt;/code&gt; . 이러한 문자는 파일 이름 (와일드 카드 포함)과 명령 줄 인수 (예 : &lt;code&gt;--color=auto&lt;/code&gt; )에 나타날 수 있기 때문 입니다. 그 후:</target>
        </trans-unit>
        <trans-unit id="18714bad76b2938b84e76ca6a48899884c985828" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;cmd&lt;/em&gt; is &lt;code&gt;LOCK_SH&lt;/code&gt; or &lt;code&gt;LOCK_EX&lt;/code&gt;, it can also be bitwise ORed with &lt;code&gt;LOCK_NB&lt;/code&gt; to avoid blocking on lock acquisition. If &lt;code&gt;LOCK_NB&lt;/code&gt; is used and the lock cannot be acquired, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised and the exception will have an &lt;em&gt;errno&lt;/em&gt; attribute set to &lt;code&gt;EACCES&lt;/code&gt; or &lt;code&gt;EAGAIN&lt;/code&gt; (depending on the operating system; for portability, check for both values). On at least some systems, &lt;code&gt;LOCK_EX&lt;/code&gt; can only be used if the file descriptor refers to a file opened for writing.</source>
          <target state="translated">때 &lt;em&gt;cmd를이&lt;/em&gt; 입니다 &lt;code&gt;LOCK_SH&lt;/code&gt; 또는 &lt;code&gt;LOCK_EX&lt;/code&gt; , 그것은 또한과 단위의 논리합 수 있습니다 &lt;code&gt;LOCK_NB&lt;/code&gt; 락 취득에 막지 않도록. 경우 &lt;code&gt;LOCK_NB&lt;/code&gt; 가 사용되며, 로크가 획득 될 수없는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 제기되고 예외가있을 것이다 &lt;em&gt;의 errno&lt;/em&gt; 에 속성 세트 &lt;code&gt;EACCES&lt;/code&gt; 또는 &lt;code&gt;EAGAIN&lt;/code&gt; (오퍼레이팅 시스템에 따라, 휴대가 두 값을 확인). 적어도 일부 시스템에서는 파일 디스크립터가 쓰기 위해 열린 파일을 참조하는 경우에만 &lt;code&gt;LOCK_EX&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b83c29eb631fb560f29f322bca1a715e76bddb07" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;converters&lt;/em&gt; is given, it should be a dictionary where each key represents the name of a type converter and each value is a callable implementing the conversion from string to the desired datatype. Every converter gets its own corresponding &lt;code&gt;get*()&lt;/code&gt; method on the parser object and section proxies.</source>
          <target state="translated">&lt;em&gt;변환기&lt;/em&gt; 가 제공 되면 각 키는 유형 변환기의 이름을 나타내며 각 값은 문자열에서 원하는 데이터 유형으로의 변환을 구현하는 호출 가능 인 사전이어야합니다. 모든 변환기는 파서 객체와 섹션 프록시에서 해당 &lt;code&gt;get*()&lt;/code&gt; 메소드를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="af9e0a3c67c495e5f8455996a807bfc6861a7af3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;decode&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default) the body is returned as a string without decoding the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. However, for a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of 8bit, an attempt is made to decode the original bytes using the &lt;code&gt;charset&lt;/code&gt; specified by the &lt;em&gt;Content-Type&lt;/em&gt; header, using the &lt;code&gt;replace&lt;/code&gt; error handler. If no &lt;code&gt;charset&lt;/code&gt; is specified, or if the &lt;code&gt;charset&lt;/code&gt; given is not recognized by the email package, the body is decoded using the default ASCII charset.</source>
          <target state="translated">때 &lt;em&gt;디코드&lt;/em&gt; 이다 &lt;code&gt;False&lt;/code&gt; (기본) 몸은 디코딩하지 않고 문자열로 반환되는 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; . 그러나 8 비트 의 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 의 경우 , &lt;code&gt;replace&lt;/code&gt; 오류 핸들러를 사용하여 &lt;em&gt;Content-Type&lt;/em&gt; 헤더에 지정된 &lt;code&gt;charset&lt;/code&gt; 사용하여 원래 바이트를 디코딩하려고 시도 합니다. 어떤 경우 &lt;code&gt;charset&lt;/code&gt; 지정되지 않는 경우, 또는 &lt;code&gt;charset&lt;/code&gt; 주어진이 이메일 패키지를 인식하지 못하는, 몸은 기본 ASCII 문자 세트를 사용하여 디코딩된다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f8896ffa0276b29fe5abcec59ab4dbb6132b4621" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;default_section&lt;/em&gt; is given, it specifies the name for the special section holding default values for other sections and interpolation purposes (normally named &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt;). This value can be retrieved and changed on runtime using the &lt;code&gt;default_section&lt;/code&gt; instance attribute.</source>
          <target state="translated">&lt;em&gt;default_section&lt;/em&gt; 이 지정 되면 다른 섹션 및 보간 목적으로 기본값을 보유하는 특수 섹션의 이름을 지정합니다 (일반적으로 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; ). 이 값은 &lt;code&gt;default_section&lt;/code&gt; 인스턴스 속성을 사용하여 런타임시 검색하고 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ec4070356db325dd5a3a1a7a7c4a6d9c8470430" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;delimiters&lt;/em&gt; is given, it is used as the set of substrings that divide keys from values. When &lt;em&gt;comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in otherwise empty lines. Comments can be indented. When &lt;em&gt;inline_comment_prefixes&lt;/em&gt; is given, it will be used as the set of substrings that prefix comments in non-empty lines.</source>
          <target state="translated">&lt;em&gt;구분 기호&lt;/em&gt; 가 제공 되면 키를 값과 나누는 하위 문자열 집합으로 사용됩니다. 때 &lt;em&gt;comment_prefixes이&lt;/em&gt; 주어집니다, 그것은 그렇지 않으면 빈 줄에 주석을 앞에 문자열의 집합으로 사용됩니다. 주석을 들여 쓸 수 있습니다. 때 &lt;em&gt;inline_comment_prefixes이&lt;/em&gt; 주어집니다, 그것은 문자열의 집합으로 사용됩니다 비어 있지 않은 라인의 접두사 주석이.</target>
        </trans-unit>
        <trans-unit id="017422042ed5196395fe163f83a712b974664f00" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;fileobj&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the &lt;em&gt;filename&lt;/em&gt; argument is only used to be included in the &lt;strong&gt;gzip&lt;/strong&gt; file header, which may include the original filename of the uncompressed file. It defaults to the filename of &lt;em&gt;fileobj&lt;/em&gt;, if discernible; otherwise, it defaults to the empty string, and in this case the original filename is not included in the header.</source>
          <target state="translated">때 &lt;em&gt;fileobj가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; 의 &lt;em&gt;파일 이름&lt;/em&gt; 인수는에 포함하는 데 사용됩니다 &lt;strong&gt;은 gzip&lt;/strong&gt; 압축되지 않은 파일의 원래 파일 이름을 포함 할 수있다 파일 헤더. 식별 가능한 경우 기본적으로 &lt;em&gt;fileobj&lt;/em&gt; 의 파일 이름이 사용 됩니다. 그렇지 않으면, 기본값은 빈 문자열이며,이 경우 원래 파일 이름은 헤더에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e007940c1a1ac1b90ed239aaae563d08c3c83e5c" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; attempts to copy all metadata from the &lt;em&gt;src&lt;/em&gt; symbolic link to the newly-created &lt;em&gt;dst&lt;/em&gt; symbolic link. However, this functionality is not available on all platforms. On platforms where some or all of this functionality is unavailable, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; will preserve all the metadata it can; &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; never raises an exception because it cannot preserve file metadata.</source>
          <target state="translated">때 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 시도는 모든 메타 데이터를 복사 &lt;em&gt;SRC&lt;/em&gt; 새로 생성에 심볼릭 링크 &lt;em&gt;DST&lt;/em&gt; 심볼릭 링크. 그러나이 기능이 모든 플랫폼에서 사용 가능한 것은 아닙니다. 이 기능 중 일부 또는 전부를 사용할 수없는 플랫폼에서 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 는 가능한 모든 메타 데이터를 유지합니다. &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 는 파일 메타 데이터를 보존 할 수 없으므로 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef749f2221652284c69ca1d8aca13dd2c69b4877" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a descriptor (such as a normal Python function, &lt;a href=&quot;functions#classmethod&quot;&gt;&lt;code&gt;classmethod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;abstractmethod()&lt;/code&gt; or another instance of &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt;), calls to &lt;code&gt;__get__&lt;/code&gt; are delegated to the underlying descriptor, and an appropriate &lt;a href=&quot;#partial-objects&quot;&gt;partial object&lt;/a&gt; returned as the result.</source>
          <target state="translated">경우 &lt;em&gt;FUNC는&lt;/em&gt; 디스크립터이다 (예컨대 정상적인 파이썬 함수 &lt;a href=&quot;functions#classmethod&quot;&gt; &lt;code&gt;classmethod()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;abstractmethod()&lt;/code&gt; 또는 다른 인스턴스 &lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; &lt;/a&gt; ) 호출 &lt;code&gt;__get__&lt;/code&gt; 가 기본 기술자에게 위임 및 적절한 &lt;a href=&quot;#partial-objects&quot;&gt;부분 목적은&lt;/a&gt; 결과로서 리턴 .</target>
        </trans-unit>
        <trans-unit id="2a7099d0edd318bbd39005c2813b14b352de9cce" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;func&lt;/em&gt; is a non-descriptor callable, an appropriate bound method is created dynamically. This behaves like a normal Python function when used as a method: the &lt;em&gt;self&lt;/em&gt; argument will be inserted as the first positional argument, even before the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;keywords&lt;/em&gt; supplied to the &lt;a href=&quot;#functools.partialmethod&quot;&gt;&lt;code&gt;partialmethod&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">경우 &lt;em&gt;FUNC가&lt;/em&gt; 아닌 기술자 호출하고, 적절한 결합 방법이 동적으로 생성된다. 이것은 메소드로 사용될 때 일반적인 Python 함수처럼 작동합니다. &lt;em&gt;self&lt;/em&gt; 인수는 &lt;a href=&quot;#functools.partialmethod&quot;&gt; &lt;code&gt;partialmethod&lt;/code&gt; &lt;/a&gt; 생성자에 제공된 &lt;em&gt;인수&lt;/em&gt; 및 &lt;em&gt;키워드&lt;/em&gt; 앞에도 첫 번째 위치 인수로 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="45e75310ec28936ea5e8f063d0b326f7a35ceaaa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;limits&lt;/em&gt; is not given the function returns the &lt;em&gt;resource&lt;/em&gt; limit of the process &lt;em&gt;pid&lt;/em&gt;. When &lt;em&gt;limits&lt;/em&gt; is given the &lt;em&gt;resource&lt;/em&gt; limit of the process is set and the former resource limit is returned.</source>
          <target state="translated">때 &lt;em&gt;제한이&lt;/em&gt; 함수가 반환을 부여하지 않는 &lt;em&gt;자원&lt;/em&gt; 프로세스의 제한 &lt;em&gt;PID&lt;/em&gt; . 경우 &lt;em&gt;제한이&lt;/em&gt; 주어진되는 &lt;em&gt;자원&lt;/em&gt; 공정의 한계를 설정하고, 이전의 자원 한계가 반환된다.</target>
        </trans-unit>
        <trans-unit id="e06b2c5a32e26f67b12baa218e1362803c4f76e3" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;operation&lt;/em&gt; is not specified or &lt;code&gt;'open'&lt;/code&gt;, this acts like double-clicking the file in Windows Explorer, or giving the file name as an argument to the &lt;strong&gt;start&lt;/strong&gt; command from the interactive command shell: the file is opened with whatever application (if any) its extension is associated.</source>
          <target state="translated">때 &lt;em&gt;작업이&lt;/em&gt; 지정되지 않았거나 &lt;code&gt;'open'&lt;/code&gt; 이 Windows 탐색기에서 파일을 두 번 클릭하거나 인수로 파일 이름을 지정 같은 역할을 &lt;strong&gt;시작&lt;/strong&gt; 대화 형 명령 셸에서 명령 파일 (있는 경우 어떤 응용 프로그램과 함께 열립니다 ) 확장이 연결되었습니다.</target>
        </trans-unit>
        <trans-unit id="821a2ea402d2f70a801f8008ac1f17c8a85bc5fa" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;pathsegments&lt;/em&gt; is empty, the current directory is assumed:</source>
          <target state="translated">때 &lt;em&gt;pathsegments가&lt;/em&gt; 비어 현재 디렉토리로 간주됩니다 :</target>
        </trans-unit>
        <trans-unit id="75967987830adb468980e21d08d3b79aba8262fe" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;section&lt;/em&gt; is not given, return a list of &lt;em&gt;section_name&lt;/em&gt;, &lt;em&gt;section_proxy&lt;/em&gt; pairs, including DEFAULTSECT.</source>
          <target state="translated">때 &lt;em&gt;섹션이&lt;/em&gt; 주어지지의 목록 반환 &lt;em&gt;SECTION_NAME&lt;/em&gt; , &lt;em&gt;section_proxy&lt;/em&gt; DEFAULTSECT 포함 쌍.</target>
        </trans-unit>
        <trans-unit id="ceee677568b16b47671c5f9b32ba5aa7d309179a" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;skipkeys&lt;/em&gt; is false (the default) the function raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when a key of a dictionary is not a string, otherwise such keys are skipped.</source>
          <target state="translated">때 &lt;em&gt;skipkeys가&lt;/em&gt; false (기본값) 기능이 제기 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 사전의 키가 문자열이 아닌 경우, 그렇지 않으면 같은 키를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="472dd01686c20762dc7bf928e1bdbe2e019a8702" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;sort_keys&lt;/em&gt; is true (the default) the keys for dictionaries will be written to the plist in sorted order, otherwise they will be written in the iteration order of the dictionary.</source>
          <target state="translated">때 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본)이 사전의 키는 그렇지 않은 경우는 사전의 반복 순서로 쓸 수있게되어, 정렬 된 순서로 PLIST에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c2f903cfa4c4022ca7d7343290d72e1caad4bcee" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;st&lt;/em&gt; represents an &lt;code&gt;'eval'&lt;/code&gt; form, this function returns &lt;code&gt;True&lt;/code&gt;, otherwise it returns &lt;code&gt;False&lt;/code&gt;. This is useful, since code objects normally cannot be queried for this information using existing built-in functions. Note that the code objects created by &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt; cannot be queried like this either, and are identical to those created by the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">때 &lt;em&gt;일이&lt;/em&gt; 대표하는 &lt;code&gt;'eval'&lt;/code&gt; 양식을,이 함수는 반환 &lt;code&gt;True&lt;/code&gt; , 그렇지 않으면 반환 &lt;code&gt;False&lt;/code&gt; . 일반적으로 기존 내장 함수를 사용하여이 정보에 대해 코드 객체를 쿼리 할 수 ​​없으므로 유용합니다. &lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt; 작성된 코드 오브젝트는 이와 같이 조회 할 수 없으며 내장 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수로 작성된 코드 오브젝트 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="c4701dad121dbacff21ec8bfc48ee5a248faeaec" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the mapping will be added to the official MIME types, otherwise to the non-standard ones.</source>
          <target state="translated">때 &lt;em&gt;엄격한가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본), 매핑 그렇지 않으면 표준이 아닌 것들로, 공식 MIME 유형에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8f2e3f887ca166194ca9ecc8d2f3c166b6328e" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), the parser won&amp;rsquo;t allow for any section or option duplicates while reading from a single source (file, string or dictionary), raising &lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt;&lt;code&gt;DuplicateSectionError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt;&lt;code&gt;DuplicateOptionError&lt;/code&gt;&lt;/a&gt;. When &lt;em&gt;empty_lines_in_values&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (default: &lt;code&gt;True&lt;/code&gt;), each empty line marks the end of an option. Otherwise, internal empty lines of a multiline option are kept as part of the value. When &lt;em&gt;allow_no_value&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (default: &lt;code&gt;False&lt;/code&gt;), options without values are accepted; the value held for these is &lt;code&gt;None&lt;/code&gt; and they are serialized without the trailing delimiter.</source>
          <target state="translated">때 &lt;em&gt;엄격한가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본) 상승, 단일 소스 (파일, 문자열 또는 사전)에서 읽는 동안, 파서는 섹션 또는 옵션 중복을 허용하지 않습니다 &lt;a href=&quot;#configparser.DuplicateSectionError&quot;&gt; &lt;code&gt;DuplicateSectionError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#configparser.DuplicateOptionError&quot;&gt; &lt;code&gt;DuplicateOptionError&lt;/code&gt; 을&lt;/a&gt; . 때 &lt;em&gt;empty_lines_in_values이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본 : &lt;code&gt;True&lt;/code&gt; ), 각각의 빈 줄 표시 옵션의 끝. 그렇지 않으면 여러 줄 옵션의 내부 빈 줄이 값의 일부로 유지됩니다. 때 &lt;em&gt;allow_no_value가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (기본값 : &lt;code&gt;False&lt;/code&gt; ), 값이없는 옵션이 허용됩니다; 이에 대한 가치는 &lt;code&gt;None&lt;/code&gt; 후행 구분 기호없이 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="13434fcf0e93bac1cc2c94533fc5d1edd99c06f4" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;symlinks&lt;/em&gt; is false, if the file pointed by the symlink doesn&amp;rsquo;t exist, an exception will be added in the list of errors raised in an &lt;a href=&quot;#shutil.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; exception at the end of the copy process. You can set the optional &lt;em&gt;ignore_dangling_symlinks&lt;/em&gt; flag to true if you want to silence this exception. Notice that this option has no effect on platforms that don&amp;rsquo;t support &lt;a href=&quot;os#os.symlink&quot;&gt;&lt;code&gt;os.symlink()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">때 &lt;em&gt;심볼릭 링크가&lt;/em&gt; 거짓 심볼릭 링크가 가리키는 파일이 존재하지 않는 경우, 예외가에서 제기 된 오류 목록에 추가됩니다 &lt;a href=&quot;#shutil.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 복사 프로세스의 마지막에 예외입니다. 이 예외를 침묵 시키려면 선택적 &lt;em&gt;ignore_dangling_symlinks&lt;/em&gt; 플래그를 true로 설정할 수 있습니다 . 이 옵션은 &lt;a href=&quot;os#os.symlink&quot;&gt; &lt;code&gt;os.symlink()&lt;/code&gt; &lt;/a&gt; 지원하지 않는 플랫폼에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2a3c9dea5d3009f072403af68bc41dbee55be1" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</source>
          <target state="translated">때 &lt;em&gt;하향식이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 호출자는 수정할 수 있습니다 &lt;em&gt;dirnames의&lt;/em&gt; (아마도 사용하여 현재 위치 목록을 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt; 및 또는 슬라이스 할당) &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 만이 같이 Recurse 이름이 유지 하위 디렉토리에 &lt;em&gt;dirnames&lt;/em&gt; ; 검색을 제거하거나, 특정 방문 순서를 적용하거나 , 호출자가 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 다시 시작하기 전에 작성하거나 이름을 바꾸는 디렉토리에 대해 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 에 알리는 데 사용할 수 있습니다 . &lt;em&gt;하향식&lt;/em&gt; 모드에서 디렉토리의 디렉토리는 &lt;em&gt;하향식이므로&lt;/em&gt; 디렉토리 가 &lt;code&gt;False&lt;/code&gt; &lt;em&gt;일&lt;/em&gt; 때 &lt;em&gt;디렉토리 이름을&lt;/em&gt; 수정 &lt;em&gt;해도&lt;/em&gt; 도보 동작에 영향을 미치지 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;dirpath&lt;/em&gt; 자체가 생성되기 전에 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7132c69782a8b6829ef6b03b540baba57ab12b2e" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</source>
          <target state="translated">When &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; , the caller can modify the &lt;em&gt;dirnames&lt;/em&gt; list in-place (perhaps using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#del&quot;&gt; &lt;code&gt;del&lt;/code&gt; &lt;/a&gt; or slice assignment), and &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; will only recurse into the subdirectories whose names remain in &lt;em&gt;dirnames&lt;/em&gt;; this can be used to prune the search, impose a specific order of visiting, or even to inform &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; about directories the caller creates or renames before it resumes &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; again. Modifying &lt;em&gt;dirnames&lt;/em&gt; when &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; has no effect on the behavior of the walk, because in bottom-up mode the directories in &lt;em&gt;dirnames&lt;/em&gt; are generated before &lt;em&gt;dirpath&lt;/em&gt; itself is generated.</target>
        </trans-unit>
        <trans-unit id="40cb053f7928b5af0b380bb285ed3b898bb57205" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;pydoc&lt;/strong&gt; generates documentation, it uses the current environment and path to locate modules. Thus, invoking &lt;strong&gt;pydoc spam&lt;/strong&gt; documents precisely the version of the module you would get if you started the Python interpreter and typed &lt;code&gt;import spam&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;pydoc&lt;/strong&gt; 은 문서를 생성 할 때 현재 환경과 경로를 사용하여 모듈을 찾습니다. 따라서 Python 인터프리터를 시작하고 &lt;code&gt;import spam&lt;/code&gt; 을 입력하면 &lt;strong&gt;pydoc 스팸&lt;/strong&gt; 문서를 정확하게 호출 하는 모듈 버전을 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="966d03fa55cf89b971f2711329e87cfb6a8d70ef" translate="yes" xml:space="preserve">
          <source>When DST ends (the &amp;ldquo;end&amp;rdquo; line), there&amp;rsquo;s a potentially worse problem: there&amp;rsquo;s an hour that can&amp;rsquo;t be spelled unambiguously in local wall time: the last hour of daylight time. In Eastern, that&amp;rsquo;s times of the form 5:MM UTC on the day daylight time ends. The local wall clock leaps from 1:59 (daylight time) back to 1:00 (standard time) again. Local times of the form 1:MM are ambiguous. &lt;code&gt;astimezone()&lt;/code&gt; mimics the local clock&amp;rsquo;s behavior by mapping two adjacent UTC hours into the same local hour then. In the Eastern example, UTC times of the form 5:MM and 6:MM both map to 1:MM when converted to Eastern, but earlier times have the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute set to 0 and the later times have it set to 1. For example, at the Fall back transition of 2016, we get:</source>
          <target state="translated">DST가 끝날 때 ( &quot;종료&quot;줄) 잠재적으로 더 나쁜 문제가 있습니다. 현지 시간으로 명확하게 표기 할 수없는 한 시간이 있습니다. 일광 시간의 마지막 시간입니다. 동부에서 일광 절약 시간이 종료되는 날의 시간은 5 : MM UTC입니다. 현지 벽시계는 1:59 (일광 시간)에서 1:00 (표준 시간)으로 다시 뛰었습니다. 1 : MM 형식의 현지 시간은 모호합니다. &lt;code&gt;astimezone()&lt;/code&gt; 은 인접한 두 UTC 시간을 동일한 현지 시간으로 매핑하여 로컬 시계의 동작을 모방합니다. 동부 예제에서 동부 형식으로 변환 할 때 5 : MM 및 6 : MM 형식의 UTC 시간은 모두 동부 표준시로 1 : MM으로 매핑되지만 이전에는 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 속성이 0으로 설정되고 나중에는 1로 설정됩니다. 2016 년 폴백 전환에서 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9e5d2b07f1f34036b37e1fe11345da1aa1e1630" translate="yes" xml:space="preserve">
          <source>When DST starts (the &amp;ldquo;start&amp;rdquo; line), the local wall clock leaps from 1:59 to 3:00. A wall time of the form 2:MM doesn&amp;rsquo;t really make sense on that day, so &lt;code&gt;astimezone(Eastern)&lt;/code&gt; won&amp;rsquo;t deliver a result with &lt;code&gt;hour == 2&lt;/code&gt; on the day DST begins. For example, at the Spring forward transition of 2016, we get:</source>
          <target state="translated">DST가 시작되면 ( &quot;시작&quot;라인) 로컬 벽시계가 1:59에서 3:00으로 도약합니다. 2 : MM 형식의 월 타임은 해당 날짜에 실제로 의미 가 없으므로 DST가 시작되는 날에 &lt;code&gt;astimezone(Eastern)&lt;/code&gt; 가 &lt;code&gt;hour == 2&lt;/code&gt; 결과를 제공하지 않습니다 . 예를 들어, 2016 년 스프링 포워드 전환에서 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="607bcef959d2c892c1b6a1b372716350bf979b2f" translate="yes" xml:space="preserve">
          <source>When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand, using the configuration dialog, under Options, instead Options. Once it happens, the solution may be to delete one or more of the configuration files.</source>
          <target state="translated">IDLE이 처음 시작되면 &lt;code&gt;~/.idlerc/&lt;/code&gt; 에서 사용자 구성 파일을 읽으려고 시도합니다 (~는 홈 디렉토리 임). 문제가 있으면 오류 메시지가 표시되어야합니다. 임의 디스크 결함을 남기지 않고, 옵션 대신 구성 대화 상자의 옵션 대화 상자를 사용하여 파일을 직접 편집하지 않으면이를 방지 할 수 있습니다. 일단 발생하면 해결책은 하나 이상의 구성 파일을 삭제하는 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33e01015396bc2a1d42f9b6722c229ffeab0414f" translate="yes" xml:space="preserve">
          <source>When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand. Instead, use the configuration dialog, under Options. Once there is an error in a user configuration file, the best solution may be to delete it and start over with the settings dialog.</source>
          <target state="translated">When IDLE first starts, it attempts to read user configuration files in &lt;code&gt;~/.idlerc/&lt;/code&gt; (~ is one&amp;rsquo;s home directory). If there is a problem, an error message should be displayed. Leaving aside random disk glitches, this can be prevented by never editing the files by hand. Instead, use the configuration dialog, under Options. Once there is an error in a user configuration file, the best solution may be to delete it and start over with the settings dialog.</target>
        </trans-unit>
        <trans-unit id="8e8cfacfb0ec66c495be055f582089d68c4b5869" translate="yes" xml:space="preserve">
          <source>When Python code uses the &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module to change the locale, this also affects the embedding application. If the embedding application doesn&amp;rsquo;t want this to happen, it should remove the &lt;code&gt;_locale&lt;/code&gt; extension module (which does all the work) from the table of built-in modules in the &lt;code&gt;config.c&lt;/code&gt; file, and make sure that the &lt;code&gt;_locale&lt;/code&gt; module is not accessible as a shared library.</source>
          <target state="translated">Python 코드가 &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 로케일 을 변경하면 임베드 응용 프로그램에도 영향을줍니다. 임베드 응용 프로그램이이를 원하지 않으면 &lt;code&gt;config.c&lt;/code&gt; 파일 의 내장 모듈 테이블에서 &lt;code&gt;_locale&lt;/code&gt; 확장 모듈 (모든 작업을 수행함)을 제거 하고 &lt;code&gt;_locale&lt;/code&gt; 모듈이 아닌지 확인해야합니다. 공유 라이브러리로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5f41d4f67b29d3c1098269b891e9bec309ad5e3" translate="yes" xml:space="preserve">
          <source>When Shell has the focus, it controls the keyboard and screen. This is normally transparent, but functions that directly access the keyboard and screen will not work. These include system-specific functions that determine whether a key has been pressed and if so, which.</source>
          <target state="translated">Shell에 포커스가 있으면 키보드와 화면을 제어합니다. 이것은 일반적으로 투명하지만 키보드와 화면에 직접 액세스하는 기능은 작동하지 않습니다. 여기에는 키를 눌렀는지 여부를 결정하는 시스템 별 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7a359f4fa5e01180f16295319eaf53142e2c0994" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object is passed in response to a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; method, &lt;code&gt;dt.tzinfo&lt;/code&gt; is the same object as &lt;em&gt;self&lt;/em&gt;. &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods can rely on this, unless user code calls &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods directly. The intent is that the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods interpret &lt;em&gt;dt&lt;/em&gt; as being in local time, and not need worry about objects in other timezones.</source>
          <target state="translated">때 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 오브젝트가 응답으로 전달되는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 에있어서, &lt;code&gt;dt.tzinfo&lt;/code&gt; 는 동일한 목적 &lt;em&gt;자기&lt;/em&gt; . 사용자 코드가 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드를 직접 호출하지 않는 한 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드는 이에 의존 할 수 있습니다. 의도는 점이다 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 방법은 해석 &lt;em&gt;DT&lt;/em&gt; 현지 시간 것으로, 그리고 다른 시간대에있는 개체에 대한 걱정이 필요합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc52f05baa4394318109ef8dd16b0838e7819096" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="a87ed137d28adb4e7367125bf334be63876e2c24" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4e6e7fb6abd8fd4a202f9606c8570fc783915cb4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ca33d6c3c9d25ed20394d7c3deaa901e7846bdec" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s original headers are modified, the visible headers are not automatically modified to correspond. This method updates the visible headers as follows: each visible header with a corresponding original header is set to the value of the original header, each visible header without a corresponding original header is removed, and any of &lt;em&gt;Date&lt;/em&gt;, &lt;em&gt;From&lt;/em&gt;, &lt;em&gt;Reply-To&lt;/em&gt;, &lt;em&gt;To&lt;/em&gt;, &lt;em&gt;CC&lt;/em&gt;, and &lt;em&gt;Subject&lt;/em&gt; that are present in the original headers but not the visible headers are added to the visible headers.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt; 인스턴스의 원래 헤더가 수정 될 때 보이는 헤더는 자동으로 수정되지 않습니다. 이 메소드는 표시되는 헤더를 다음과 같이 업데이트합니다. 해당하는 원래 헤더가있는 각 표시되는 헤더는 원래 헤더의 값으로 설정되고 해당하는 원래 헤더가없는 각 표시되는 헤더는 제거되며 &lt;em&gt;Date&lt;/em&gt; , &lt;em&gt;From&lt;/em&gt; , &lt;em&gt;Reply-To&lt;/em&gt; , &lt;em&gt;To&lt;/em&gt; 원래 헤더에는 있지만 표시되는 헤더는없는 , &lt;em&gt;CC&lt;/em&gt; 및 &lt;em&gt;Subject&lt;/em&gt; 가 표시되는 헤더에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="75531aef3bfb04565ed01de282e0e8a5dd90cd56" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="a351f9e4fca060cf05b544590758e13c938d87a1" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="1152ba9f8c4290368623aeaac928cca549892729" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ebde1da7e650fdde9e9869ca15dbe9af33e8273e" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 라인이 복사되고 모든 플래그가 직접 대응 &quot;에서&quot;</target>
        </trans-unit>
        <trans-unit id="b0a451fe8c2a75c0a9d07b757e5b645a5db0c95a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object is created, it will inherit the authentication key of its parent process, although this may be changed by setting &lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt;&lt;code&gt;authkey&lt;/code&gt;&lt;/a&gt; to another byte string.</source>
          <target state="translated">때 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 오브젝트가 작성이 설정에 의해 변경 될 수 있지만, 그 부모 프로세스의 인증 키를 상속 &lt;a href=&quot;#multiprocessing.Process.authkey&quot;&gt; &lt;code&gt;authkey&lt;/code&gt; &lt;/a&gt; 다른 바이트 스트링.</target>
        </trans-unit>
        <trans-unit id="bd552e17015aa5c66496ae4f45468cddbe08da34" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is created, it acquires a policy. If the message is created by a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt;, a policy passed to the parser will be the policy used by the message it creates. If the message is created by the program, then the policy can be specified when it is created. When a message is passed to a &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;, the generator uses the policy from the message by default, but you can also pass a specific policy to the generator that will override the one stored on the message object.</source>
          <target state="translated">때 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 개체가 만들어, 그것은 정책을 획득한다. 메시지가 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 의해 생성되면 파서 에 전달 된 정책 은 메시지가 생성 한 메시지에 의해 사용되는 정책이됩니다. 프로그램이 메시지를 작성하면 작성 될 때 정책을 지정할 수 있습니다. 메시지가 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 로 전달 되면 생성기는 기본적으로 메시지의 정책을 사용하지만 특정 정책을 생성기에 전달하여 메시지 객체에 저장된 정책을 재정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="796474d1752f90ea152f5dd6af4e1499894479a4" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</source>
          <target state="translated">때 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 함수 리턴 새로운 &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 인스턴스가 발생되고, 함수에 의해 리턴 된 값으로 사용되는 &lt;code&gt;value&lt;/code&gt; 예외의 생성자 파라미터.</target>
        </trans-unit>
        <trans-unit id="d12afd02904407ac827bc33a9ab049515e5bb6a2" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</source>
          <target state="translated">When a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; function returns, a new &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; instance is raised, and the value returned by the function is used as the &lt;code&gt;value&lt;/code&gt; parameter to the constructor of the exception.</target>
        </trans-unit>
        <trans-unit id="f43590acc1cf538fae98de86cea41d189b3c470b" translate="yes" xml:space="preserve">
          <source>When a Future object is &lt;em&gt;awaited&lt;/em&gt; it means that the coroutine will wait until the Future is resolved in some other place.</source>
          <target state="translated">Future를 객체가 될 때 &lt;em&gt;기다려온&lt;/em&gt; 은 미래가 다른 곳에서 해결 될 때까지 코 루틴이 대기하는 것을 의미한다.</target>
        </trans-unit>
        <trans-unit id="a501ed1c9da143e744360045a70756ab3a3c2bbc" translate="yes" xml:space="preserve">
          <source>When a HTTP/1.1 compliant server receives an &lt;code&gt;Expect: 100-continue&lt;/code&gt; request header it responds back with a &lt;code&gt;100 Continue&lt;/code&gt; followed by &lt;code&gt;200
OK&lt;/code&gt; headers. This method can be overridden to raise an error if the server does not want the client to continue. For e.g. server can chose to send &lt;code&gt;417
Expectation Failed&lt;/code&gt; as a response header and &lt;code&gt;return False&lt;/code&gt;.</source>
          <target state="translated">HTTP / 1.1 호환 서버는 &lt;code&gt;Expect: 100-continue&lt;/code&gt; 요청 헤더를 받으면 &lt;code&gt;100 Continue&lt;/code&gt; 와 &lt;code&gt;200 OK&lt;/code&gt; 헤더로 다시 응답합니다 . 서버가 클라이언트를 계속하지 않으려는 경우 오류를 발생시키기 위해이 메소드를 대체 할 수 있습니다. 예를 들어, 서버는 &lt;code&gt;417 Expectation Failed&lt;/code&gt; 를 응답 헤더로 &lt;code&gt;return False&lt;/code&gt; 하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a4f1159e7b0d3c34483e2df19f60fd60e258658c" translate="yes" xml:space="preserve">
          <source>When a binary (or in-place) method returns &lt;code&gt;NotImplemented&lt;/code&gt; the interpreter will try the reflected operation on the other type (or some other fallback, depending on the operator). If all attempts return &lt;code&gt;NotImplemented&lt;/code&gt;, the interpreter will raise an appropriate exception. Incorrectly returning &lt;code&gt;NotImplemented&lt;/code&gt; will result in a misleading error message or the &lt;code&gt;NotImplemented&lt;/code&gt; value being returned to Python code.</source>
          <target state="translated">이진 (또는 내부) 메소드가 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 하면 인터프리터는 다른 유형 (또는 연산자에 따라 다른 대체)에 대해 반영된 조작을 시도합니다. 모든 시도가 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 하면 인터프리터는 적절한 예외를 발생시킵니다. &lt;code&gt;NotImplemented&lt;/code&gt; 를 잘못 반환 하면 잘못된 오류 메시지 또는 &lt;code&gt;NotImplemented&lt;/code&gt; 값이 Python 코드로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="63fc5ba727ad83fc978cb83426ef44950fb22f0c" translate="yes" xml:space="preserve">
          <source>When a client connects, you&amp;rsquo;ll call &lt;code&gt;accept()&lt;/code&gt; on the socket to get the new socket from the other end, and use the context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt; method to create a server-side SSL socket for the connection:</source>
          <target state="translated">클라이언트가 연결되면 소켓에서 &lt;code&gt;accept()&lt;/code&gt; 를 호출 하여 다른 쪽 끝에서 새 소켓을 가져오고 컨텍스트의 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 연결을위한 서버 측 SSL 소켓을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="14355459d065a2126b707c1cdaf9a9ce0eb37d01" translate="yes" xml:space="preserve">
          <source>When a coroutine function is called, but not awaited (e.g. &lt;code&gt;coro()&lt;/code&gt; instead of &lt;code&gt;await coro()&lt;/code&gt;) or the coroutine is not scheduled with &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt;, asyncio will emit a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">코 루틴 함수를 호출하지만 기다리게하지 (예되면 &lt;code&gt;coro()&lt;/code&gt; 대신 &lt;code&gt;await coro()&lt;/code&gt; ) 또는 코 루틴과는 예약되지 &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; , asyncio가 발광한다 &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; 을&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="80027fbdb3d8bf1a0774de4650e2b1aab343032a" translate="yes" xml:space="preserve">
          <source>When a coroutine is wrapped into a &lt;em&gt;Task&lt;/em&gt; with functions like &lt;a href=&quot;#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; the coroutine is automatically scheduled to run soon:</source>
          <target state="translated">코 루틴이 &lt;a href=&quot;#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 와 같은 함수 를 사용하여 &lt;em&gt;Task에&lt;/em&gt; 래핑 되면 코 루틴이 자동으로 곧 실행되도록 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="29bdbe2316b1cfa1ea855e4c3c8a620f07d98c69" translate="yes" xml:space="preserve">
          <source>When a database is accessed by multiple connections, and one of the processes modifies the database, the SQLite database is locked until that transaction is committed. The &lt;em&gt;timeout&lt;/em&gt; parameter specifies how long the connection should wait for the lock to go away until raising an exception. The default for the timeout parameter is 5.0 (five seconds).</source>
          <target state="translated">여러 연결로 데이터베이스에 액세스하고 프로세스 중 하나에서 데이터베이스를 수정하면 해당 트랜잭션이 커밋 될 때까지 SQLite 데이터베이스가 잠 깁니다. &lt;em&gt;타임 아웃&lt;/em&gt; 연결이 잠금을 기다리는 시간 매개 변수를 지정 예외를 제기 할 때까지 멀리 이동합니다. 시간 종료 매개 변수의 기본값은 5.0 (5 초)입니다.</target>
        </trans-unit>
        <trans-unit id="58541f13ed67949530f68a704b5ad0ef345cd0ab" translate="yes" xml:space="preserve">
          <source>When a foreign function is called, each actual argument is passed to the &lt;code&gt;from_param()&lt;/code&gt; class method of the items in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple, this method allows adapting the actual argument to an object that the foreign function accepts. For example, a &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; item in the &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt;&lt;code&gt;argtypes&lt;/code&gt;&lt;/a&gt; tuple will convert a string passed as argument into a bytes object using ctypes conversion rules.</source>
          <target state="translated">외부 함수가 호출 될 때 각 실제 인수는 &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt; 튜플 에있는 항목 의 &lt;code&gt;from_param()&lt;/code&gt; 클래스 메소드로 전달됩니다. 이 메소드를 사용하면 외부 인수가 허용하는 오브젝트에 실제 인수를 적용 할 수 있습니다. 예를 들어, &lt;a href=&quot;#ctypes._FuncPtr.argtypes&quot;&gt; &lt;code&gt;argtypes&lt;/code&gt; &lt;/a&gt; 튜플 의 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 항목은 ctypes 변환 규칙을 사용하여 인수로 전달 된 문자열을 bytes 객체로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b49ea0d90c828ff025e45c681bc2ce260779892" translate="yes" xml:space="preserve">
          <source>When a form is submitted in the &amp;ldquo;old&amp;rdquo; format (as the query string or as a single data part of type &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt;), the items will actually be instances of the class &lt;code&gt;MiniFieldStorage&lt;/code&gt;. In this case, the &lt;code&gt;list&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, and &lt;code&gt;filename&lt;/code&gt; attributes are always &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">쿼리 문자열 또는 &lt;em&gt;application / x-www-form-urlencoded&lt;/em&gt; 유형의 단일 데이터 부분으로 양식을 &quot;이전&quot;형식으로 제출 하면 항목은 실제로 &lt;code&gt;MiniFieldStorage&lt;/code&gt; 클래스의 인스턴스가 됩니다. 이 경우 &lt;code&gt;list&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; 및 &lt;code&gt;filename&lt;/code&gt; 속성은 항상 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ff8b51f9aced6e65bff3f4369665f2c727321580" translate="yes" xml:space="preserve">
          <source>When a header parameter is encoded in &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; format, &lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt;&lt;code&gt;Message.get_param&lt;/code&gt;&lt;/a&gt; may return a 3-tuple containing the character set, language, and value. &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt;&lt;code&gt;collapse_rfc2231_value()&lt;/code&gt;&lt;/a&gt; turns this into a unicode string. Optional &lt;em&gt;errors&lt;/em&gt; is passed to the &lt;em&gt;errors&lt;/em&gt; argument of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; method; it defaults to &lt;code&gt;'replace'&lt;/code&gt;. Optional &lt;em&gt;fallback_charset&lt;/em&gt; specifies the character set to use if the one in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; header is not known by Python; it defaults to &lt;code&gt;'us-ascii'&lt;/code&gt;.</source>
          <target state="translated">헤더 매개 변수가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 형식으로 인코딩 되면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_param&quot;&gt; &lt;code&gt;Message.get_param&lt;/code&gt; &lt;/a&gt; 은 문자 세트, 언어 및 값을 포함하는 3 개의 튜플을 리턴 할 수 있습니다. &lt;a href=&quot;#email.utils.collapse_rfc2231_value&quot;&gt; &lt;code&gt;collapse_rfc2231_value()&lt;/code&gt; &lt;/a&gt; 는 이것을 유니 코드 문자열로 변환합니다. 선택적 &lt;em&gt;오류&lt;/em&gt; 는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 메소드 의 &lt;em&gt;errors&lt;/em&gt; 인수로 전달됩니다 . 기본값은 &lt;code&gt;'replace'&lt;/code&gt; 입니다. 선택적 &lt;em&gt;fallback_charset&lt;/em&gt; 은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 헤더에 있는 문자 를 Python에서 알 수없는 경우 사용할 문자 세트를 지정합니다 . 기본값은 &lt;code&gt;'us-ascii'&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d710381a25baff3243b6945ecd27556783f6e36" translate="yes" xml:space="preserve">
          <source>When a letter is first encountered, it is missing from the mapping, so the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function calls &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; to supply a default count of zero. The increment operation then builds up the count for each letter.</source>
          <target state="translated">문자가 처음 발견되면 맵핑에서 누락되므로 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 함수는 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 기본 카운트 0을 제공합니다. 그런 다음 증분 연산은 각 문자의 개수를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="32fdfac5d569cc8091912ece10591faa073940b3" translate="yes" xml:space="preserve">
          <source>When a logger is created, the level is set to &lt;code&gt;NOTSET&lt;/code&gt; (which causes all messages to be processed when the logger is the root logger, or delegation to the parent when the logger is a non-root logger). Note that the root logger is created with level &lt;code&gt;WARNING&lt;/code&gt;.</source>
          <target state="translated">로거가 작성되면 레벨은 &lt;code&gt;NOTSET&lt;/code&gt; 으로 설정됩니다 (로거가 루트 로거 일 때 모든 메시지가 처리되거나 로거가 루트 로거가 아닌 경우 부모에게 위임). 루트 로거는 &lt;code&gt;WARNING&lt;/code&gt; 레벨로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1c121beda2f5083b1511f5b13c9899bd1d6ba9b6" translate="yes" xml:space="preserve">
          <source>When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</source>
          <target state="translated">모듈을 다시로드하면 사전 (모듈의 전역 변수 포함)이 유지됩니다. 이름을 재정의하면 이전 정의가 재정의되므로 일반적으로 문제가되지 않습니다. 새 버전의 모듈에서 이전 버전으로 정의 된 이름을 정의하지 않으면 이전 정의가 그대로 유지됩니다. 이 기능은 전역 테이블 또는 객체 캐시를 유지하는 경우 모듈의 이점에 사용될 수 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; 문을 사용하면 테이블의 존재 여부를 테스트하고 원하는 경우 초기화를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b14b90e029d5b6f2e02ad6ead9c927a62548a2" translate="yes" xml:space="preserve">
          <source>When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</source>
          <target state="translated">When a module is reloaded, its dictionary (containing the module&amp;rsquo;s global variables) is retained. Redefinitions of names will override the old definitions, so this is generally not a problem. If the new version of a module does not define a name that was defined by the old version, the old definition remains. This feature can be used to the module&amp;rsquo;s advantage if it maintains a global table or cache of objects &amp;mdash; with a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; statement it can test for the table&amp;rsquo;s presence and skip its initialization if desired:</target>
        </trans-unit>
        <trans-unit id="102ecaca0081733892ac9c0922de0ed7ff3dd82f" translate="yes" xml:space="preserve">
          <source>When a process exits, it attempts to terminate all of its daemonic child processes.</source>
          <target state="translated">프로세스가 종료되면 모든 데몬 하위 프로세스를 종료하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="f779be4e8bb9308b016d27968c5002b765b616cf" translate="yes" xml:space="preserve">
          <source>When a program outputs text, the result is determined by the corresponding output device. When IDLE executes user code, &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; are connected to the display area of IDLE&amp;rsquo;s Shell. Some of its features are inherited from the underlying Tk Text widget. Others are programmed additions. Where it matters, Shell is designed for development rather than production runs.</source>
          <target state="translated">프로그램이 텍스트를 출력 할 때 결과는 해당 출력 장치에 의해 결정됩니다. IDLE이 사용자 코드를 실행하면 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 이 IDLE 셸의 표시 영역에 연결됩니다. 그 기능 중 일부는 기본 Tk Text 위젯에서 상속됩니다. 다른 것은 프로그래밍 된 추가 사항입니다. 중요한 경우, Shell은 생산 작업이 아닌 개발 용으로 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="b145886bd139940193c9516b5aa5ce15ebcfa79a" translate="yes" xml:space="preserve">
          <source>When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</source>
          <target state="translated">When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; evaluates to &lt;code&gt;True&lt;/code&gt; , individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</target>
        </trans-unit>
        <trans-unit id="5fe3fda7a7625ed5821ce75af517849bfdd0407e" translate="yes" xml:space="preserve">
          <source>When a sequence of two-element tuples is used as the &lt;em&gt;query&lt;/em&gt; argument, the first element of each tuple is a key and the second is a value. The value element in itself can be a sequence and in that case, if the optional parameter &lt;em&gt;doseq&lt;/em&gt; is evaluates to &lt;code&gt;True&lt;/code&gt;, individual &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; are generated for each element of the value sequence for the key. The order of parameters in the encoded string will match the order of parameter tuples in the sequence.</source>
          <target state="translated">두 요소 튜플의 시퀀스가 &lt;em&gt;쿼리&lt;/em&gt; 인수 로 사용되는 경우 각 튜플의 첫 번째 요소는 키이고 두 번째 요소는 값입니다. 값 요소 자체는 시퀀스 일 수 있으며,이 경우 선택적 매개 변수 &lt;em&gt;doseq&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 평가되면 &lt;code&gt;key=value&lt;/code&gt; 에 대한 값 시퀀스의 각 요소에 대해 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 로 구분 된 개별 키 = 값 쌍이 생성됩니다. 인코딩 된 문자열의 매개 변수 순서는 시퀀스의 매개 변수 튜플 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="7b4f273f661846773d9602c6e5e1ab50f3c31c65" translate="yes" xml:space="preserve">
          <source>When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">스냅 샷이 작성되면 추적 추적이 &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; 프레임으로 제한됩니다 . &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="16c2b7b95a617a78019f007b1a6276ff133633a3" translate="yes" xml:space="preserve">
          <source>When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function. The original number of frames of the traceback is stored in the &lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt;&lt;code&gt;Traceback.total_nframe&lt;/code&gt;&lt;/a&gt; attribute. That allows to know if a traceback has been truncated by the traceback limit.</source>
          <target state="translated">When a snapshot is taken, tracebacks of traces are limited to &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; frames. See the &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt; function. The original number of frames of the traceback is stored in the &lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt; &lt;code&gt;Traceback.total_nframe&lt;/code&gt; &lt;/a&gt; attribute. That allows to know if a traceback has been truncated by the traceback limit.</target>
        </trans-unit>
        <trans-unit id="f0093f870eef1dbea47bfba379efd8c3efa29578" translate="yes" xml:space="preserve">
          <source>When a test needs to look more deeply into the warnings, rather than just checking whether or not they occurred, code like this can be used:</source>
          <target state="translated">테스트가 단순히 발생했는지 여부를 확인하는 것보다 경고를 더 자세히 조사해야하는 경우 다음과 같은 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c867916e7973025c622ee7e9b701da070179716" translate="yes" xml:space="preserve">
          <source>When a tool or a library does not support annotations or encounters an unknown annotation it should just ignore it and treat annotated type as the underlying type.</source>
          <target state="translated">When a tool or a library does not support annotations or encounters an unknown annotation it should just ignore it and treat annotated type as the underlying type.</target>
        </trans-unit>
        <trans-unit id="ace6e48a34ddec70b997e7ed4ef30cd1200e48dd" translate="yes" xml:space="preserve">
          <source>When a tuple is returned, it must be between two and six items long. Optional items can either be omitted, or &lt;code&gt;None&lt;/code&gt; can be provided as their value. The semantics of each item are in order:</source>
          <target state="translated">튜플이 반환되면 길이는 2-6 개의 항목이어야합니다. 선택적 항목을 생략하거나 값으로 &lt;code&gt;None&lt;/code&gt; 을 제공 할 수 있습니다. 각 항목의 의미는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6e91619aaae63d9b1d57efcb79896aa3fdd3e043" translate="yes" xml:space="preserve">
          <source>When a tuple with an incorrect length is passed to a function expecting a &lt;a href=&quot;#time.struct_time&quot;&gt;&lt;code&gt;struct_time&lt;/code&gt;&lt;/a&gt;, or having elements of the wrong type, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">길이가 잘못된 튜플이 &lt;a href=&quot;#time.struct_time&quot;&gt; &lt;code&gt;struct_time&lt;/code&gt; 을&lt;/a&gt; 예상 하거나 잘못된 유형의 요소 가있는 함수에 전달 되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="122b5a9e98f973011f8c23604c35ee0744f01180" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active (i.e., the virtual environment&amp;rsquo;s Python interpreter is running), the attributes &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; point to the base directory of the virtual environment, whereas &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; point to the non-virtual environment Python installation which was used to create the virtual environment. If a virtual environment is not active, then &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt;&lt;code&gt;sys.exec_prefix&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt;&lt;code&gt;sys.base_exec_prefix&lt;/code&gt;&lt;/a&gt; (they all point to a non-virtual environment Python installation).</source>
          <target state="translated">가상 환경이 활성화 된 경우 (즉, 가상 환경의 Python 인터프리터가 실행중인 경우) &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt; 속성 은 가상 환경의 기본 디렉토리를 가리키고 &lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt; 는 비 환경을 가리 킵니다. 가상 환경 가상 환경을 만드는 데 사용 된 Python 설치. 가상 환경이 활성화되어 있지 않은 경우 &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;sys#sys.exec_prefix&quot;&gt; &lt;code&gt;sys.exec_prefix&lt;/code&gt; &lt;/a&gt; 는 sys.base_exec_prefix 와 &lt;a href=&quot;sys#sys.base_exec_prefix&quot;&gt; &lt;code&gt;sys.base_exec_prefix&lt;/code&gt; &lt;/a&gt; (모두 비가 상 환경 Python 설치 를 가리킴 ).</target>
        </trans-unit>
        <trans-unit id="49099fe8787d9b66d249172b5b8c16fae8d8776e" translate="yes" xml:space="preserve">
          <source>When a virtual environment is active, any options that change the installation path will be ignored from all &lt;a href=&quot;distutils#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; configuration files to prevent projects being inadvertently installed outside of the virtual environment.</source>
          <target state="translated">가상 환경이 활성화되면 프로젝트가 가상 환경 외부에 실수로 설치되지 않도록 설치 경로를 변경하는 모든 옵션이 모든 &lt;a href=&quot;distutils#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 구성 파일 에서 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="e73006af8303cac324a6bee6ebfb9a71386816b0" translate="yes" xml:space="preserve">
          <source>When activated, code entered in the Shell or run from an Editor will run under the debugger. In the Editor, breakpoints can be set with the context menu. This feature is still incomplete and somewhat experimental.</source>
          <target state="translated">활성화되면 셸에 입력되거나 편집기에서 실행 된 코드가 디버거에서 실행됩니다. 편집기에서 상황에 맞는 메뉴를 사용하여 중단 점을 설정할 수 있습니다. 이 기능은 여전히 ​​불완전하고 다소 실험적입니다.</target>
        </trans-unit>
        <trans-unit id="cbdd2a51e4781c318a7a1a81e4c3eb4ba6ae291d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="ddc891f4c25b8225fd0001cdae26af6639e7537e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e46ed5b47728cdf79b8e4b0ea7954bf28bac75b9" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance, the &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers are omitted and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X-상태&lt;/em&gt; 헤더는 생략하고 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e173b2ac8c61d6fbcc0ffb178a6f5c0aa5074e9e" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4a95e85d749bc7be23343bcb5277621335a1948d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스 (A)는 라인 &quot;에서&quot;를 기반으로 생성되는 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스의 납기, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="e255b577d6bbc86290e4f9d517b3ffbe62bbaae4" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="10d8c3d31070cdae2a2783c0d5f2693fbf078f89" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt;&lt;code&gt;MMDFMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance, the &amp;ldquo;From &amp;rdquo; line is copied and all flags directly correspond:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.MMDFMessage&quot;&gt; &lt;code&gt;MMDFMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 라인이 복사되고 모든 플래그가 직접 대응 &quot;에서&quot;</target>
        </trans-unit>
        <trans-unit id="286e3f12905a38714edf02bf122a3f8052a6268d" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4c4296d06ab3b5a40fe3f89cb3f43ef0aef304f8" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon a &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance, a &amp;ldquo;From &amp;rdquo; line is generated based upon the &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt;&lt;code&gt;MaildirMessage&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s delivery date, and the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스 (A)는 라인 &quot;에서&quot;를 기반으로 생성되는 &lt;a href=&quot;#mailbox.MaildirMessage&quot;&gt; &lt;code&gt;MaildirMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스의 납기, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="4d0342e5504d800d945bf2084fb63194683176ac" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance is created based upon an &lt;a href=&quot;#mailbox.MHMessage&quot;&gt;&lt;code&gt;MHMessage&lt;/code&gt;&lt;/a&gt; instance, the following conversions take place:</source>
          <target state="translated">때 &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가 기반으로 만들어집니다 &lt;a href=&quot;#mailbox.MHMessage&quot;&gt; &lt;code&gt;MHMessage&lt;/code&gt; 의&lt;/a&gt; 경우, 다음과 같은 변환이 일어난다 :</target>
        </trans-unit>
        <trans-unit id="d9ae3b18f623ec44c4c53a80c85290adab2b1644" translate="yes" xml:space="preserve">
          <source>When an array object is printed or converted to a string, it is represented as &lt;code&gt;array(typecode, initializer)&lt;/code&gt;. The &lt;em&gt;initializer&lt;/em&gt; is omitted if the array is empty, otherwise it is a string if the &lt;em&gt;typecode&lt;/em&gt; is &lt;code&gt;'u'&lt;/code&gt;, otherwise it is a list of numbers. The string is guaranteed to be able to be converted back to an array with the same type and value using &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;, so long as the &lt;a href=&quot;#array.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; class has been imported using &lt;code&gt;from array import array&lt;/code&gt;. Examples:</source>
          <target state="translated">배열 객체가 인쇄되거나 문자열로 변환되면 &lt;code&gt;array(typecode, initializer)&lt;/code&gt; 됩니다. &lt;em&gt;이니셜&lt;/em&gt; 어레이가 비어 있으면, 그렇지 않으면 그 캐릭터가 생략 &lt;em&gt;타입 코드가&lt;/em&gt; 인 &lt;code&gt;'u'&lt;/code&gt; 그렇지 않으면 번호의 목록이다. 문자열은 동일한 유형 및 값 사용에 배열 변환 돌아올 수 있도록 보장 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 너무 오래로, &lt;a href=&quot;#array.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 클래스가 가져온 사용하여 &lt;code&gt;from array import array&lt;/code&gt; . 예 :</target>
        </trans-unit>
        <trans-unit id="e57a24f717690d606e0285653c2532690dac8586" translate="yes" xml:space="preserve">
          <source>When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt;&lt;code&gt;sys.audit()&lt;/code&gt;&lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; are called first, followed by hooks added in the current interpreter.</source>
          <target state="translated">&lt;a href=&quot;#sys.audit&quot;&gt; &lt;code&gt;sys.audit()&lt;/code&gt; &lt;/a&gt; 함수를 통해 감사 이벤트가 발생 하면 각 후크는 이벤트 이름 및 인수 튜플과 함께 추가 된 순서대로 호출됩니다. &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt; 에 의해 추가 된 기본 후크 가 먼저 호출 된 후 현재 인터프리터에 추가 된 후크가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="da37c46dce4431adb3ffa8a7a4157478f4800eb9" translate="yes" xml:space="preserve">
          <source>When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt;&lt;code&gt;sys.audit()&lt;/code&gt;&lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt;&lt;code&gt;PySys_AddAuditHook()&lt;/code&gt;&lt;/a&gt; are called first, followed by hooks added in the current interpreter. Hooks can then log the event, raise an exception to abort the operation, or terminate the process entirely.</source>
          <target state="translated">When an auditing event is raised through the &lt;a href=&quot;#sys.audit&quot;&gt; &lt;code&gt;sys.audit()&lt;/code&gt; &lt;/a&gt; function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PySys_AddAuditHook&quot;&gt; &lt;code&gt;PySys_AddAuditHook()&lt;/code&gt; &lt;/a&gt; are called first, followed by hooks added in the current interpreter. Hooks can then log the event, raise an exception to abort the operation, or terminate the process entirely.</target>
        </trans-unit>
        <trans-unit id="a060e94770f6ada605adcbe7b40294d9f24ee084" translate="yes" xml:space="preserve">
          <source>When an exception is raised and uncaught, the interpreter calls &lt;code&gt;sys.excepthook&lt;/code&gt; with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; in a Python program this happens just before the program exits. The handling of such top-level exceptions can be customized by assigning another three-argument function to &lt;code&gt;sys.excepthook&lt;/code&gt;.</source>
          <target state="translated">예외가 발생하여 포착되지 않으면 인터프리터는 세 개의 인수, 예외 클래스, 예외 인스턴스 및 추적 백 오브젝트와 함께 &lt;code&gt;sys.excepthook&lt;/code&gt; 을 호출 합니다. 대화식 세션에서는 제어가 프롬프트로 리턴되기 직전에 발생합니다. 파이썬 프로그램에서 이것은 프로그램이 종료되기 직전에 발생합니다. 이러한 최상위 예외 처리는 &lt;code&gt;sys.excepthook&lt;/code&gt; 에 다른 3 개의 인수 함수를 할당하여 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd8e7c6427b144ae5ce58a35c7ec85907800fd4" translate="yes" xml:space="preserve">
          <source>When an expression, such as a function call, appears as a statement by itself with its return value not used or stored, it is wrapped in this container. &lt;code&gt;value&lt;/code&gt; holds one of the other nodes in this section, a &lt;a href=&quot;#ast.Constant&quot;&gt;&lt;code&gt;Constant&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Lambda&quot;&gt;&lt;code&gt;Lambda&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Yield&quot;&gt;&lt;code&gt;Yield&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.YieldFrom&quot;&gt;&lt;code&gt;YieldFrom&lt;/code&gt;&lt;/a&gt; node.</source>
          <target state="translated">When an expression, such as a function call, appears as a statement by itself with its return value not used or stored, it is wrapped in this container. &lt;code&gt;value&lt;/code&gt; holds one of the other nodes in this section, a &lt;a href=&quot;#ast.Constant&quot;&gt; &lt;code&gt;Constant&lt;/code&gt; &lt;/a&gt;, a &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt;, a &lt;a href=&quot;#ast.Lambda&quot;&gt; &lt;code&gt;Lambda&lt;/code&gt; &lt;/a&gt;, a &lt;a href=&quot;#ast.Yield&quot;&gt; &lt;code&gt;Yield&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#ast.YieldFrom&quot;&gt; &lt;code&gt;YieldFrom&lt;/code&gt; &lt;/a&gt; node.</target>
        </trans-unit>
        <trans-unit id="b9ffd4c1a0ac9fe5d9bc16351d2b81ce70edccab" translate="yes" xml:space="preserve">
          <source>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt;&lt;code&gt;signal.ITIMER_REAL&lt;/code&gt;&lt;/a&gt; will deliver &lt;a href=&quot;#signal.SIGALRM&quot;&gt;&lt;code&gt;SIGALRM&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt;&lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt;&lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt;, and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt;&lt;code&gt;signal.ITIMER_PROF&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt;.</source>
          <target state="translated">When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt; &lt;code&gt;signal.ITIMER_REAL&lt;/code&gt; &lt;/a&gt; will deliver &lt;a href=&quot;#signal.SIGALRM&quot;&gt; &lt;code&gt;SIGALRM&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt; &lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt; &lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt; , and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt; &lt;code&gt;signal.ITIMER_PROF&lt;/code&gt; &lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98cb90ca3fe9c876d8490b4b2d59b0b2fc0154fc" translate="yes" xml:space="preserve">
          <source>When an interval timer fires, a signal is sent to the process. The signal sent is dependent on the timer being used; &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt;&lt;code&gt;signal.ITIMER_REAL&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGALRM&lt;/code&gt;, &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt;&lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt;&lt;/a&gt; sends &lt;code&gt;SIGVTALRM&lt;/code&gt;, and &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt;&lt;code&gt;signal.ITIMER_PROF&lt;/code&gt;&lt;/a&gt; will deliver &lt;code&gt;SIGPROF&lt;/code&gt;.</source>
          <target state="translated">인터벌 타이머가 작동하면 신호가 프로세스로 전송됩니다. 전송되는 신호는 사용중인 타이머에 따라 다릅니다. &lt;a href=&quot;#signal.ITIMER_REAL&quot;&gt; &lt;code&gt;signal.ITIMER_REAL&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGALRM&lt;/code&gt; 을 전달 하고 &lt;a href=&quot;#signal.ITIMER_VIRTUAL&quot;&gt; &lt;code&gt;signal.ITIMER_VIRTUAL&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGVTALRM&lt;/code&gt; 을 전송 하며 &lt;a href=&quot;#signal.ITIMER_PROF&quot;&gt; &lt;code&gt;signal.ITIMER_PROF&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;SIGPROF&lt;/code&gt; 를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="d729011a0caf801b2d3090cac48b85a3ba68cf73" translate="yes" xml:space="preserve">
          <source>When an object is put on a queue, the object is pickled and a background thread later flushes the pickled data to an underlying pipe. This has some consequences which are a little surprising, but should not cause any practical difficulties &amp;ndash; if they really bother you then you can instead use a queue created with a &lt;a href=&quot;#multiprocessing-managers&quot;&gt;manager&lt;/a&gt;.</source>
          <target state="translated">객체가 대기열에 놓이면 객체가 피클되고 백그라운드 스레드가 나중에 피클 된 데이터를 기본 파이프로 플러시합니다. 이것은 약간 놀라운 결과이지만 실제적으로 어려움을 겪지 않아야합니다. 만약 실제로 귀찮게한다면 대신 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;관리자로&lt;/a&gt; 만든 대기열을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46c6a7ab062a3f1ac7a1fa12015f2ab3e6c6e8ef" translate="yes" xml:space="preserve">
          <source>When an ordinary Python script raises an unhandled exception (for whatever reason: of a typo in a module name, a file that can&amp;rsquo;t be opened, etc.), the Python interpreter prints a nice traceback and exits. While the Python interpreter will still do this when your CGI script raises an exception, most likely the traceback will end up in one of the HTTP server&amp;rsquo;s log files, or be discarded altogether.</source>
          <target state="translated">일반적인 파이썬 스크립트가 처리되지 않은 예외 (어떤 이유로 모듈 이름의 오타, 열 수없는 파일 등)를 발생 시키면, 파이썬 인터프리터는 훌륭한 역 추적을 출력하고 종료합니다. Python 인터프리터는 CGI 스크립트에서 예외가 발생할 때 여전히이 작업을 수행하지만 대부분의 경우 역 추적이 HTTP 서버의 로그 파일 중 하나에서 발생하거나 완전히 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="f0b18b0dca198469e2e5821b568a8af8553f7137" translate="yes" xml:space="preserve">
          <source>When another &lt;em&gt;operation&lt;/em&gt; is given, it must be a &amp;ldquo;command verb&amp;rdquo; that specifies what should be done with the file. Common verbs documented by Microsoft are &lt;code&gt;'print'&lt;/code&gt; and &lt;code&gt;'edit'&lt;/code&gt; (to be used on files) as well as &lt;code&gt;'explore'&lt;/code&gt; and &lt;code&gt;'find'&lt;/code&gt; (to be used on directories).</source>
          <target state="translated">다른 &lt;em&gt;작업&lt;/em&gt; 이 제공되면 파일로 수행 할 작업을 지정하는 &quot;명령 동사&quot;여야합니다. Microsoft가 문서화 한 일반적인 동사는 &lt;code&gt;'print'&lt;/code&gt; 및 &lt;code&gt;'edit'&lt;/code&gt; (파일에 사용)과 &lt;code&gt;'explore'&lt;/code&gt; 및 &lt;code&gt;'find'&lt;/code&gt; (디렉토리에 사용)입니다.</target>
        </trans-unit>
        <trans-unit id="c4d9c23255dc7b8ca6f19ef5a940eb877d9642dd" translate="yes" xml:space="preserve">
          <source>When another data type is mixed in, the &lt;code&gt;value&lt;/code&gt; attribute is &lt;em&gt;not the same&lt;/em&gt; as the enum member itself, although it is equivalent and will compare equal.</source>
          <target state="translated">다른 데이터 타입이 혼합 될 때, &lt;code&gt;value&lt;/code&gt; 특성은 &lt;em&gt;동일하지&lt;/em&gt; 가 동일하며 동일한 비교한다하더라도, ENUM 부재 자체.</target>
        </trans-unit>
        <trans-unit id="782a74b6093e9a274767f8a985a07199d8c71046" translate="yes" xml:space="preserve">
          <source>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</source>
          <target state="translated">정수 변환 코드 중 하나를 사용하여 정수가 아닌 팩을 패킹하려고 할 때, 정수가 아닌 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 메소드가 있으면 해당 메소드가 호출되어 인수 전에 정수를 변환하여 팩킹합니다.</target>
        </trans-unit>
        <trans-unit id="b4bcdffe284cc4209a6efda0e7fcb83ad577a516" translate="yes" xml:space="preserve">
          <source>When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</source>
          <target state="translated">When attempting to pack a non-integer using any of the integer conversion codes, if the non-integer has a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; method then that method is called to convert the argument to an integer before packing.</target>
        </trans-unit>
        <trans-unit id="38f8d78459f2077063513420c80633ee6ca35e36" translate="yes" xml:space="preserve">
          <source>When called as a program from the command line, the following form is used:</source>
          <target state="translated">명령 행에서 프로그램으로 호출되면 다음 형식이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7774c1b19e4f3bda02017096fe4f300d221be9d7" translate="yes" xml:space="preserve">
          <source>When called with the entire population, this gives the population variance &amp;sigma;&amp;sup2;. When called on a sample instead, this is the biased sample variance s&amp;sup2;, also known as variance with N degrees of freedom.</source>
          <target state="translated">전체 모집단과 함께 호출하면 모집단 분산 &amp;sigma;&amp;sup2;가됩니다. 대신 샘플에서 호출 될 때 이것은 바이어스 된 샘플 분산 s&amp;sup2;이며 N 자유도의 분산이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e1510a977d9eec8bae218f453f2180521adfa1a6" translate="yes" xml:space="preserve">
          <source>When called without arguments this function removes the control-c handler if it has been installed. This function can also be used as a test decorator to temporarily remove the handler while the test is being executed:</source>
          <target state="translated">인수없이 호출되면이 함수는 control-c 핸들러가 설치된 경우이를 제거합니다. 이 함수는 테스트가 실행되는 동안 핸들러를 일시적으로 제거하기 위해 테스트 데코레이터로 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b31def5bdc28465822c89803310f8ec7825150" translate="yes" xml:space="preserve">
          <source>When called, the generic function dispatches on the type of the first argument:</source>
          <target state="translated">호출되면 일반 함수는 첫 번째 인수의 유형을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="49f7a0d990e54e7e4ff423f9bcf931e35657cbac" translate="yes" xml:space="preserve">
          <source>When calling the &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; constructor directly, &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; is the default. Since it does not authenticate the other peer, it can be insecure, especially in client mode where most of time you would like to ensure the authenticity of the server you&amp;rsquo;re talking to. Therefore, when in client mode, it is highly recommended to use &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. However, it is in itself not sufficient; you also have to check that the server certificate, which can be obtained by calling &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt;&lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt;&lt;/a&gt;, matches the desired service. For many protocols and applications, the service can be identified by the hostname; in this case, the &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; function can be used. This common check is automatically performed when &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;SSLContext.check_hostname&lt;/code&gt;&lt;/a&gt; is enabled.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 생성자를 직접 호출 할 때 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 이 기본값입니다. 다른 피어를 인증하지 않으므로 특히 대화하는 서버의 신뢰성을 보장하려는 대부분의 클라이언트 모드에서는 안전하지 않을 수 있습니다. 따라서 클라이언트 모드에서는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 . 그러나 그 자체로는 충분하지 않습니다. &lt;a href=&quot;#ssl.SSLSocket.getpeercert&quot;&gt; &lt;code&gt;SSLSocket.getpeercert()&lt;/code&gt; &lt;/a&gt; 를 호출하여 얻을 수있는 서버 인증서 가 원하는 서비스와 일치 하는지 확인해야합니다 . 많은 프로토콜과 응용 프로그램의 경우 호스트 이름으로 서비스를 식별 할 수 있습니다. 이 경우 &lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다. 이 공통 점검은 자동으로 수행됩니다&lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;SSLContext.check_hostname&lt;/code&gt; &lt;/a&gt; 이 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4dc40bbe639d96f637bd93855f1791e60c735e90" translate="yes" xml:space="preserve">
          <source>When calling with the two argument form you omit the replacement object, and a mock is created for you and passed in as an extra argument to the decorated function:</source>
          <target state="translated">두 개의 인수 형식으로 호출하면 대체 객체가 생략되고 모의 객체가 만들어져 장식 된 함수에 대한 추가 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="18e0548d845776f7d9fb1bb48334763d7bb375ac" translate="yes" xml:space="preserve">
          <source>When compared to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;, this object lacks the following features:</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 과 비교할 때이 객체에는 다음 기능이 없습니다.</target>
        </trans-unit>
        <trans-unit id="856a45270239471af6c5f0a357260107cdc44d90" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt;&lt;code&gt;hexdigest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">확인 루틴 동안 &lt;a href=&quot;#hmac.HMAC.hexdigest&quot;&gt; &lt;code&gt;hexdigest()&lt;/code&gt; &lt;/a&gt; 의 출력을 외부 제공 다이제스트와 &lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt; 때 타이밍 공격에 대한 취약성을 줄이기 위해 &lt;code&gt;==&lt;/code&gt; 연산자 대신 compare_digest () 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="92028d8951df45be6cbda2380b77dd7080678d69" translate="yes" xml:space="preserve">
          <source>When comparing the output of &lt;a href=&quot;#hmac.digest&quot;&gt;&lt;code&gt;digest()&lt;/code&gt;&lt;/a&gt; to an externally-supplied digest during a verification routine, it is recommended to use the &lt;a href=&quot;#hmac.compare_digest&quot;&gt;&lt;code&gt;compare_digest()&lt;/code&gt;&lt;/a&gt; function instead of the &lt;code&gt;==&lt;/code&gt; operator to reduce the vulnerability to timing attacks.</source>
          <target state="translated">검증 루틴 동안 &lt;a href=&quot;#hmac.digest&quot;&gt; &lt;code&gt;digest()&lt;/code&gt; &lt;/a&gt; 의 출력을 외부 제공 다이제스트와 &lt;a href=&quot;#hmac.compare_digest&quot;&gt; &lt;code&gt;compare_digest()&lt;/code&gt; &lt;/a&gt; 때 타이밍 공격에 대한 취약성을 줄이기 위해 &lt;code&gt;==&lt;/code&gt; 연산자 대신 compare_digest () 함수 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cc34f0feb28081050c116e0b782b908cc2cd4bfa" translate="yes" xml:space="preserve">
          <source>When comparing unions, the argument order is ignored, e.g.:</source>
          <target state="translated">공용체를 비교할 때 인수 순서는 무시됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ed05a329db63e10d1f8fb992f1545e7cd8c147c7" translate="yes" xml:space="preserve">
          <source>When compiling a string with multi-line code in &lt;code&gt;'single'&lt;/code&gt; or &lt;code&gt;'eval'&lt;/code&gt; mode, input must be terminated by at least one newline character. This is to facilitate detection of incomplete and complete statements in the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;code&gt;'single'&lt;/code&gt; 또는 &lt;code&gt;'eval'&lt;/code&gt; 모드 에서 여러 줄 코드로 문자열을 컴파일 할 때 입력은 하나 이상의 줄 바꿈 문자로 끝나야합니다. 이는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 모듈 에서 불완전하고 완전한 문장을 쉽게 감지 할 수 있도록하기위한 것 입니다.</target>
        </trans-unit>
        <trans-unit id="696dab8a84aeff4c3a2e883a2314face9ba4d539" translate="yes" xml:space="preserve">
          <source>When computing the next rollover time for the first time (when the handler is created), the last modification time of an existing log file, or else the current time, is used to compute when the next rotation will occur.</source>
          <target state="translated">다음 롤오버 시간을 처음 계산할 때 (핸들러가 생성 될 때) 기존 로그 파일의 마지막 수정 시간 또는 현재 시간은 다음 회전이 발생할시기를 계산하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d884d8babe5a567edcfd0ea18f46faab02d32494" translate="yes" xml:space="preserve">
          <source>When connected, &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt;&lt;code&gt;NNTP_SSL&lt;/code&gt;&lt;/a&gt; objects support the following methods and attributes.</source>
          <target state="translated">연결되면 &lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#nntplib.NNTP_SSL&quot;&gt; &lt;code&gt;NNTP_SSL&lt;/code&gt; &lt;/a&gt; 객체는 다음 방법과 속성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="060ff3bcb23f907c12e71640fb12cf92d2d0e3e5" translate="yes" xml:space="preserve">
          <source>When converting from a string, the string must not contain whitespace around the central &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; operator. For example, &lt;code&gt;complex('1+2j')&lt;/code&gt; is fine, but &lt;code&gt;complex('1 + 2j')&lt;/code&gt; raises &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열에서 변환 할 때 문자열에는 중앙 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 연산자 주위에 공백이 없어야합니다 . 예를 들어, &lt;code&gt;complex('1+2j')&lt;/code&gt; 좋지만 &lt;code&gt;complex('1 + 2j')&lt;/code&gt; 상승 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="729cf6941132415f4f8f822faa0d6fea63ed2df7" translate="yes" xml:space="preserve">
          <source>When converting from another time zone, the fold will be set to the correct value:</source>
          <target state="translated">When converting from another time zone, the fold will be set to the correct value:</target>
        </trans-unit>
        <trans-unit id="c6c5e5ce837c0e22ffcd56a47571a9b383672bcb" translate="yes" xml:space="preserve">
          <source>When copying an existing archive, file objects supplied only need &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;readline&lt;/code&gt;, or &lt;code&gt;write&lt;/code&gt; methods. When creating an archive from a directory, if the target is a file object it will be passed to the &lt;code&gt;zipfile.ZipFile&lt;/code&gt; class, and must supply the methods needed by that class.</source>
          <target state="translated">기존 아카이브를 복사 할 때 제공된 파일 오브젝트에는 &lt;code&gt;read&lt;/code&gt; 및 &lt;code&gt;readline&lt;/code&gt; 또는 &lt;code&gt;write&lt;/code&gt; 메소드 만 필요 합니다. 디렉토리에서 아카이브를 작성할 때 대상이 파일 오브젝트 인 경우 &lt;code&gt;zipfile.ZipFile&lt;/code&gt; 클래스 로 전달 되며 해당 클래스에 필요한 메소드를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="62f08dfe8f53d7f93ca2ca215d1e0ef6f39c519e" translate="yes" xml:space="preserve">
          <source>When counting with floating point numbers, better accuracy can sometimes be achieved by substituting multiplicative code such as: &lt;code&gt;(start + step * i
for i in count())&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;(start + step * i for i in count())&lt;/code&gt; 와 같은 곱셈 코드를 대체하여 정확도를 향상시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a51eebc4aef573b36497fe8c2650ded21d78cac" translate="yes" xml:space="preserve">
          <source>When creating &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects from scratch, you often need to encode the payloads for transport through compliant mail servers. This is especially true for &lt;em&gt;image/*&lt;/em&gt; and &lt;em&gt;text/*&lt;/em&gt; type messages containing binary data.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체를 처음부터 만들 때 종종 호환 메일 서버를 통한 전송을 위해 페이로드를 인코딩해야합니다. 이진 데이터가 포함 된 &lt;em&gt;image / *&lt;/em&gt; 및 &lt;em&gt;text / *&lt;/em&gt; 유형 메시지의 경우 특히 그렇습니다 .</target>
        </trans-unit>
        <trans-unit id="6c409f842f8763b8712502f5713a4839b3224fe8" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;Call&lt;/code&gt; node, &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;keywords&lt;/code&gt; are required, but they can be empty lists. &lt;code&gt;starargs&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are optional.</source>
          <target state="translated">When creating a &lt;code&gt;Call&lt;/code&gt; node, &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;keywords&lt;/code&gt; are required, but they can be empty lists. &lt;code&gt;starargs&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt; are optional.</target>
        </trans-unit>
        <trans-unit id="a423c248f1413b6e1e0f4f3faa51f5f733b512cd" translate="yes" xml:space="preserve">
          <source>When creating a &lt;code&gt;DateHeader&lt;/code&gt;, &lt;em&gt;value&lt;/em&gt; may be &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance. This means, for example, that the following code is valid and does what one would expect:</source>
          <target state="translated">작성할 때 &lt;code&gt;DateHeader&lt;/code&gt; , &lt;em&gt;값이&lt;/em&gt; 될 수 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스. 예를 들어, 다음 코드가 유효하고 기대하는 것을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a4db0b5c5393d0800539c706fee74aab4223e2df" translate="yes" xml:space="preserve">
          <source>When creating a breakpoint, its associated filename should be in canonical form. If a &lt;em&gt;funcname&lt;/em&gt; is defined, a breakpoint hit will be counted when the first line of that function is executed. A conditional breakpoint always counts a hit.</source>
          <target state="translated">중단 점을 만들 때 관련된 파일 이름은 정식 형식이어야합니다. 경우 &lt;em&gt;funcname에이&lt;/em&gt; 정의됨을 함수의 첫 번째 행이 실행되면, 브레이크 포인트의 히트를 카운트한다. 조건부 중단 점은 항상 적중을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="672bf0c86c2581afe64984ce3a00746c2792ef5c" translate="yes" xml:space="preserve">
          <source>When creating new WSGI application objects, frameworks, servers, or middleware, it can be useful to validate the new code&amp;rsquo;s conformance using &lt;a href=&quot;#module-wsgiref.validate&quot;&gt;&lt;code&gt;wsgiref.validate&lt;/code&gt;&lt;/a&gt;. This module provides a function that creates WSGI application objects that validate communications between a WSGI server or gateway and a WSGI application object, to check both sides for protocol conformance.</source>
          <target state="translated">새 WSGI 애플리케이션 오브젝트, 프레임 워크, 서버 또는 미들웨어를 작성할 때 &lt;a href=&quot;#module-wsgiref.validate&quot;&gt; &lt;code&gt;wsgiref.validate&lt;/code&gt; 를&lt;/a&gt; 사용하여 새 코드의 적합성을 검증하는 것이 유용 할 수 있습니다 . 이 모듈은 WSGI 서버 또는 게이트웨이와 WSGI 응용 프로그램 개체 간의 통신을 확인하여 프로토콜 적합성을 확인하는 WSGI 응용 프로그램 개체를 만드는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e5bb3321cca6ff1fb46c71f838479a459fa1e5d" translate="yes" xml:space="preserve">
          <source>When decompressing a stream, the window size must not be smaller than the size originally used to compress the stream; using a too-small value may result in an &lt;a href=&quot;#zlib.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; exception. The default &lt;em&gt;wbits&lt;/em&gt; value corresponds to the largest window size and requires a zlib header and trailer to be included.</source>
          <target state="translated">스트림을 압축 해제 할 때 창 크기는 스트림을 압축하는 데 원래 사용 된 크기보다 작아서는 안됩니다. 너무 작은 값을 사용하면 &lt;a href=&quot;#zlib.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 예외 가 발생할 수 있습니다 . 기본 &lt;em&gt;wbits&lt;/em&gt; 값은 가장 큰 창 크기에 해당하며 zlib 헤더와 트레일러를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="4d74f26e8d112aef4595ce1a87bdb3b198f7b5e3" translate="yes" xml:space="preserve">
          <source>When decompressing, the value of the last modification time field in the most recently read header may be read from this attribute, as an integer. The initial value before reading any headers is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">압축을 풀 때 가장 최근에 읽은 헤더의 마지막 수정 시간 필드 값을 정수로이 속성에서 읽을 수 있습니다. 헤더를 읽기 전의 초기 값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3403f72d755a11055123ac4361d68696ca02cdee" translate="yes" xml:space="preserve">
          <source>When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the &lt;code&gt;values&lt;/code&gt; list, with a &lt;code&gt;None&lt;/code&gt; at the corresponding position in &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">When doing dictionary unpacking using dictionary literals the expression to be expanded goes in the &lt;code&gt;values&lt;/code&gt; list, with a &lt;code&gt;None&lt;/code&gt; at the corresponding position in &lt;code&gt;keys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02833f75f25f075b18c22a28c5aa2ba25a8444fc" translate="yes" xml:space="preserve">
          <source>When each key is encountered for the first time, it is not already in the mapping; so an entry is automatically created using the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; function which returns an empty &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;list.append()&lt;/code&gt; operation then attaches the value to the new list. When keys are encountered again, the look-up proceeds normally (returning the list for that key) and the &lt;code&gt;list.append()&lt;/code&gt; operation adds another value to the list. This technique is simpler and faster than an equivalent technique using &lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt;&lt;code&gt;dict.setdefault()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">각 키가 처음 발견되면 아직 맵핑에 있지 않은 것입니다. 따라서 빈 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 을 리턴하는 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 항목이 자동으로 작성 됩니다 . &lt;code&gt;list.append()&lt;/code&gt; 연산은 다음의 새로운리스트에 값을 첨부. 키가 다시 발생하면 조회가 정상적으로 진행되고 (해당 키의 목록을 반환) &lt;code&gt;list.append()&lt;/code&gt; 작업이 다른 값을 목록에 추가합니다. 이 기술은 &lt;a href=&quot;stdtypes#dict.setdefault&quot;&gt; &lt;code&gt;dict.setdefault()&lt;/code&gt; &lt;/a&gt; 사용하는 동등한 기술보다 간단하고 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="e7a986ad80ec6a19bad35676d48184874aeb1f45" translate="yes" xml:space="preserve">
          <source>When editing code in an editor (as oppose to Shell), increase the available module-level names by running your code and not restarting the Shell thereafter. This is especially useful after adding imports at the top of a file. This also increases possible attribute completions.</source>
          <target state="translated">When editing code in an editor (as oppose to Shell), increase the available module-level names by running your code and not restarting the Shell thereafter. This is especially useful after adding imports at the top of a file. This also increases possible attribute completions.</target>
        </trans-unit>
        <trans-unit id="9887fe8e3c1a8945458c737be092d9fc035304db" translate="yes" xml:space="preserve">
          <source>When enabled on client-side sockets, the client signals the server that it supports post-handshake authentication.</source>
          <target state="translated">클라이언트 측 소켓에서 활성화되면 클라이언트는 서버에게 핸드 셰이크 후 인증을 지원한다는 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="4b197cf7dc7faf88b3cb2e54d710a0d303daee67" translate="yes" xml:space="preserve">
          <source>When enabled on server-side sockets, &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;SSLContext.verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, too. The actual client cert exchange is delayed until &lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt;&lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt;&lt;/a&gt; is called and some I/O is performed.</source>
          <target state="translated">서버 측 소켓에서 사용 가능한 경우 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;SSLContext.verify_mode&lt;/code&gt; 도&lt;/a&gt;&lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 로 설정해야합니다 . 실제 클라이언트 인증서 교환은 &lt;a href=&quot;#ssl.SSLSocket.verify_client_post_handshake&quot;&gt; &lt;code&gt;SSLSocket.verify_client_post_handshake()&lt;/code&gt; &lt;/a&gt; 가 호출되고 일부 I / O가 수행 될 때까지 지연 됩니다.</target>
        </trans-unit>
        <trans-unit id="a621755ca7f41470229f75442067ad0d1c20faff" translate="yes" xml:space="preserve">
          <source>When encountering a &lt;code&gt;multipart/related&lt;/code&gt;, check the &lt;code&gt;start&lt;/code&gt; parameter and if a part with a matching &lt;em&gt;Content-ID&lt;/em&gt; is found, consider only it when looking for candidate matches. Otherwise consider only the first (default root) part of the &lt;code&gt;multipart/related&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;multipart/related&lt;/code&gt; 를 발견 하면 &lt;code&gt;start&lt;/code&gt; 매개 변수를 확인하고 일치하는 &lt;em&gt;Content-ID를&lt;/em&gt; 가진 부품을 찾으면 후보 일치를 찾을 때만 고려하십시오. 그렇지 않으면 &lt;code&gt;multipart/related&lt;/code&gt; 의 첫 번째 (기본 루트) 부분 만 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="d720d1be1de6b788b045c550171b49ace0d34e71" translate="yes" xml:space="preserve">
          <source>When executed without arguments &lt;a href=&quot;#unittest-test-discovery&quot;&gt;Test Discovery&lt;/a&gt; is started:</source>
          <target state="translated">인수없이 실행하면 &lt;a href=&quot;#unittest-test-discovery&quot;&gt;Test Discovery&lt;/a&gt; 가 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d9f5758875cf66a5a33444f0562ccc5e99c8db03" translate="yes" xml:space="preserve">
          <source>When first created the logger has level &lt;code&gt;logging.NOTSET&lt;/code&gt; and no default handler. Messages sent to this logger will not by default propagate to the root logger.</source>
          <target state="translated">처음 작성된 로거에는 레벨 &lt;code&gt;logging.NOTSET&lt;/code&gt; 이 있으며 기본 핸들러는 없습니다. 이 로거로 전송 된 메시지는 기본적으로 루트 로거로 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69309127fb83429d8269e5e345250adcff5991bf" translate="yes" xml:space="preserve">
          <source>When formatting a number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt; and subclasses) with the &lt;code&gt;n&lt;/code&gt; type (ex: &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt;), the function temporarily sets the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale to the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale to decode &lt;code&gt;decimal_point&lt;/code&gt; and &lt;code&gt;thousands_sep&lt;/code&gt; fields of &lt;code&gt;localeconv()&lt;/code&gt; if they are non-ASCII or longer than 1 byte, and the &lt;code&gt;LC_NUMERIC&lt;/code&gt; locale is different than the &lt;code&gt;LC_CTYPE&lt;/code&gt; locale. This temporary change affects other threads.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 유형 (예 : &lt;code&gt;'{:n}'.format(1234)&lt;/code&gt; ) 으로 숫자 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 및 서브 클래스)를 형식화 할 때이 함수는 일시적으로 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로케일을 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로케일로 설정하여 디코딩합니다. &lt;code&gt;localeconv()&lt;/code&gt; 의 &lt;code&gt;decimal_point&lt;/code&gt; 및 &lt;code&gt;thousands_sep&lt;/code&gt; 필드는 ASCII가 아니거나 1 바이트보다 길고 &lt;code&gt;LC_NUMERIC&lt;/code&gt; 로캘이 &lt;code&gt;LC_CTYPE&lt;/code&gt; 로캘 과 다른 경우 입니다. 이 임시 변경은 다른 스레드에 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="0c6c0444904253e2eedbaa36573956718aa2948c" translate="yes" xml:space="preserve">
          <source>When generating annotated listings, mark lines which were not executed with &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">주석이 달린 리스팅을 생성 할 때 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 실행되지 않은 라인을 표시하십시오 .</target>
        </trans-unit>
        <trans-unit id="be8e8b32da74a37571c34b0e9517346b53020b30" translate="yes" xml:space="preserve">
          <source>When identifying things (such as host names) in the internet, it is often necessary to compare such identifications for &amp;ldquo;equality&amp;rdquo;. Exactly how this comparison is executed may depend on the application domain, e.g. whether it should be case-insensitive or not. It may be also necessary to restrict the possible identifications, to allow only identifications consisting of &amp;ldquo;printable&amp;rdquo; characters.</source>
          <target state="translated">인터넷에서 사물 (예 : 호스트 이름)을 식별 할 때 이러한 식별을 &quot;평등&quot;과 비교해야하는 경우가 종종 있습니다. 이 비교가 정확히 어떻게 수행되는지는 애플리케이션 도메인에 따라 다를 수 있습니다 (예 : 대소 문자를 구분하지 않아야하는지). &amp;ldquo;인쇄 가능한&amp;rdquo;문자로 구성된 식별 만 허용하기 위해 가능한 식별을 제한해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e7e37fe6162273e5e4281cf61c42ffd2d46e957" translate="yes" xml:space="preserve">
          <source>When implementing coroutine schedulers and for other advanced uses of generators, it is useful to determine whether a generator is currently executing, is waiting to start or resume or execution, or has already terminated. &lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt;&lt;code&gt;getgeneratorstate()&lt;/code&gt;&lt;/a&gt; allows the current state of a generator to be determined easily.</source>
          <target state="translated">코 루틴 스케줄러를 구현하고 기타 고급 생성기를 사용하는 경우 생성기가 현재 실행 중인지, 시작 또는 재개 또는 실행 대기 중인지 또는 이미 종료되었는지 여부를 판별하는 것이 유용합니다. &lt;a href=&quot;#inspect.getgeneratorstate&quot;&gt; &lt;code&gt;getgeneratorstate()&lt;/code&gt; &lt;/a&gt; 사용하면 생성기의 현재 상태를 쉽게 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5376e91d28fee3241c94e60ac21eaf1934266aa4" translate="yes" xml:space="preserve">
          <source>When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the data needed to be written to the raw stream but it couldn&amp;rsquo;t accept all the data without blocking.</source>
          <target state="translated">비 차단 모드 에서 데이터를 원시 스트림에 기록해야하지만 차단하지 않고 모든 데이터를 받아 들일 수없는 경우 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="949c191a2b89d062d5cb3c84d7a255f7ab9b1114" translate="yes" xml:space="preserve">
          <source>When inheriting from &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; for threaded connection behavior, you should explicitly declare how you want your threads to behave on an abrupt shutdown. The &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; class defines an attribute &lt;em&gt;daemon_threads&lt;/em&gt;, which indicates whether or not the server should wait for thread termination. You should set the flag explicitly if you would like threads to behave autonomously; the default is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, meaning that Python will not exit until all threads created by &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; have exited.</source>
          <target state="translated">스레드 연결 동작을 위해 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; 에서 상속 할 때 갑작스러운 종료시 스레드 작동 방식을 명시 적으로 선언해야합니다. &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; 의&lt;/a&gt; 클래스는 속성 정의 &lt;em&gt;daemon_threads&lt;/em&gt; 서버가 스레드 종료를 기다릴 것인지 여부를 나타냅니다. 스레드가 자율적으로 동작하게하려면 플래그를 명시 적으로 설정해야합니다. 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 입니다&lt;/a&gt; . 이는 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 모든 스레드가 종료 될 때까지 Python이 종료되지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="0c4ce52ce81abe52a94c5ca1b4e84054f0c345e6" translate="yes" xml:space="preserve">
          <source>When inheriting from generic classes, some type variables could be fixed:</source>
          <target state="translated">일반 클래스에서 상속 할 때 일부 유형 변수가 수정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d13155b8b331b5e8b4a6adbaa811a4f85484dce4" translate="yes" xml:space="preserve">
          <source>When initializing &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; (either at import time or whenever &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt;&lt;code&gt;reset_tzpath()&lt;/code&gt;&lt;/a&gt; is called with no arguments), the &lt;code&gt;zoneinfo&lt;/code&gt; module will use the environment variable &lt;code&gt;PYTHONTZPATH&lt;/code&gt;, if it exists, to set the search path.</source>
          <target state="translated">When initializing &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; &lt;/a&gt; (either at import time or whenever &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt; &lt;code&gt;reset_tzpath()&lt;/code&gt; &lt;/a&gt; is called with no arguments), the &lt;code&gt;zoneinfo&lt;/code&gt; module will use the environment variable &lt;code&gt;PYTHONTZPATH&lt;/code&gt; , if it exists, to set the search path.</target>
        </trans-unit>
        <trans-unit id="2d57a9f5d007446cdead859ca66e2d6075df536d" translate="yes" xml:space="preserve">
          <source>When instantiated, &lt;em&gt;msg&lt;/em&gt; should be a human-readable description of the error. The optional &lt;em&gt;exception&lt;/em&gt; parameter, if given, should be &lt;code&gt;None&lt;/code&gt; or an exception that was caught by the parsing code and is being passed along as information.</source>
          <target state="translated">인스턴스화 될 때 &lt;em&gt;msg&lt;/em&gt; 는 사람이 읽을 수있는 오류에 대한 설명이어야합니다. 선택적인 &lt;em&gt;예외&lt;/em&gt; 매개 변수 (제공된 경우)는 &lt;code&gt;None&lt;/code&gt; 또는 구문 분석 코드에 의해 포착되어 정보로 전달되는 예외 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a44c954d6ff4db8ecacb3e811d6941f43087b96" translate="yes" xml:space="preserve">
          <source>When interactive, &lt;code&gt;stdout&lt;/code&gt; and &lt;code&gt;stderr&lt;/code&gt; streams are line-buffered. Otherwise, they are block-buffered like regular text files. You can override this value with the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/a&gt; command-line option.</source>
          <target state="translated">대화식 일 때 &lt;code&gt;stdout&lt;/code&gt; 및 &lt;code&gt;stderr&lt;/code&gt; 스트림은 라인 버퍼링됩니다. 그렇지 않으면 일반 텍스트 파일처럼 차단됩니다. &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-u&quot;&gt; &lt;code&gt;-u&lt;/code&gt; &lt;/a&gt; 명령 행 옵션 으로이 값을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c9d780f23a2b4601e2764bf38f20738f15f23667" translate="yes" xml:space="preserve">
          <source>When interactive, the &lt;code&gt;stdout&lt;/code&gt; stream is line-buffered. Otherwise, it is block-buffered like regular text files. The &lt;code&gt;stderr&lt;/code&gt; stream is line-buffered in both cases. You can make both streams unbuffered by passing the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-u&quot;&gt;&lt;code&gt;-u&lt;/code&gt;&lt;/a&gt; command-line option or setting the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONUNBUFFERED&quot; id=&quot;index-36&quot;&gt;&lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt;&lt;/a&gt; environment variable.</source>
          <target state="translated">When interactive, the &lt;code&gt;stdout&lt;/code&gt; stream is line-buffered. Otherwise, it is block-buffered like regular text files. The &lt;code&gt;stderr&lt;/code&gt; stream is line-buffered in both cases. You can make both streams unbuffered by passing the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-u&quot;&gt; &lt;code&gt;-u&lt;/code&gt; &lt;/a&gt; command-line option or setting the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONUNBUFFERED&quot; id=&quot;index-36&quot;&gt; &lt;code&gt;PYTHONUNBUFFERED&lt;/code&gt; &lt;/a&gt; environment variable.</target>
        </trans-unit>
        <trans-unit id="995afee8f4fa71b9b054d20a6203385ccf1bd50f" translate="yes" xml:space="preserve">
          <source>When invoked as a script, pdb will automatically enter post-mortem debugging if the program being debugged exits abnormally. After post-mortem debugging (or after normal exit of the program), pdb will restart the program. Automatic restarting preserves pdb&amp;rsquo;s state (such as breakpoints) and in most cases is more useful than quitting the debugger upon program&amp;rsquo;s exit.</source>
          <target state="translated">스크립트로 호출 될 때 pdb는 디버깅중인 프로그램이 비정상적으로 종료되면 사후 디버깅에 자동으로 들어갑니다. 사후 디버깅 후 (또는 프로그램이 정상적으로 종료 된 후) pdb는 프로그램을 다시 시작합니다. 자동 재시작은 pdb의 상태 (예 : 중단 점)를 유지하며 대부분의 경우 프로그램 종료시 디버거를 종료하는 것보다 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2539ba7b8e0eee8855621eedd477ec61c17b8f6b" translate="yes" xml:space="preserve">
          <source>When invoked from the command line, &lt;code&gt;python -m pickletools&lt;/code&gt; will disassemble the contents of one or more pickle files. Note that if you want to see the Python object stored in the pickle rather than the details of pickle format, you may want to use &lt;code&gt;-m pickle&lt;/code&gt; instead. However, when the pickle file that you want to examine comes from an untrusted source, &lt;code&gt;-m pickletools&lt;/code&gt; is a safer option because it does not execute pickle bytecode.</source>
          <target state="translated">명령 행에서 호출하면 &lt;code&gt;python -m pickletools&lt;/code&gt; 는 하나 이상의 pickle 파일의 내용을 디스 어셈블합니다. 피클 형식의 세부 정보가 아닌 피클에 저장된 Python 객체를 보려면 대신 &lt;code&gt;-m pickle&lt;/code&gt; 을 사용하는 것이 좋습니다. 그러나 검사하려는 피클 파일이 신뢰할 수없는 소스에서 온 경우 &lt;code&gt;-m pickletools&lt;/code&gt; 는 피클 바이트 코드를 실행하지 않기 때문에 더 안전한 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="4b61fed1c9136364f71b07a1ac9ee9de891cc79e" translate="yes" xml:space="preserve">
          <source>When invoked on an unlocked lock, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">잠금 해제 된 잠금에서 호출되면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a4c03388380d599f150c844d9f2270ba506b4b5" translate="yes" xml:space="preserve">
          <source>When invoked with &lt;em&gt;blocking&lt;/em&gt; set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;차단&lt;/em&gt; 을 false로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 인수가없는 호출이 차단되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 인수없이 호출 할 때와 동일한 작업을 수행하고 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="3215b0285b31a2e686d7f6ba8334728310827391" translate="yes" xml:space="preserve">
          <source>When invoked with a &lt;em&gt;timeout&lt;/em&gt; other than &lt;code&gt;None&lt;/code&gt;, it will block for at most &lt;em&gt;timeout&lt;/em&gt; seconds. If acquire does not complete successfully in that interval, return &lt;code&gt;False&lt;/code&gt;. Return &lt;code&gt;True&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이외 의 &lt;em&gt;시간 초과로&lt;/em&gt; 호출하면 최대 &lt;em&gt;시간 초과&lt;/em&gt; 초 동안 차단됩니다 . 해당 간격에서 획득이 성공적으로 완료되지 않으면 &lt;code&gt;False&lt;/code&gt; 를 리턴하십시오 . 반환 &lt;code&gt;True&lt;/code&gt; 이 없습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1e3e192edfe421df0ce1b99d20b60757870a5ac" translate="yes" xml:space="preserve">
          <source>When invoked with a positive, floating-point value for &lt;em&gt;timeout&lt;/em&gt;, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; as long as the lock can not be acquired. Invocations with a negative value for &lt;em&gt;timeout&lt;/em&gt; are equivalent to a &lt;em&gt;timeout&lt;/em&gt; of zero. Invocations with a &lt;em&gt;timeout&lt;/em&gt; value of &lt;code&gt;None&lt;/code&gt; (the default) set the timeout period to infinite. Note that the treatment of negative or &lt;code&gt;None&lt;/code&gt; values for &lt;em&gt;timeout&lt;/em&gt; differs from the implemented behavior in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;timeout&lt;/em&gt; argument has no practical implications if the &lt;em&gt;block&lt;/em&gt; argument is set to &lt;code&gt;False&lt;/code&gt; and is thus ignored. Returns &lt;code&gt;True&lt;/code&gt; if the lock has been acquired or &lt;code&gt;False&lt;/code&gt; if the timeout period has elapsed.</source>
          <target state="translated">&lt;em&gt;timeout에&lt;/em&gt; 양의 부동 소수점 값을 사용하여 호출 하면 잠금을 획득 할 수없는 한 &lt;em&gt;시간 초과&lt;/em&gt; 로 지정된 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;em&gt;시간 종료&lt;/em&gt; 값이 음수 인 호출 은 &lt;em&gt;시간 종료&lt;/em&gt; 0 과 같습니다 . &lt;em&gt;시간 종료&lt;/em&gt; 값이 &lt;code&gt;None&lt;/code&gt; (기본값) 인 호출 은 시간 종료 기간을 무한대로 설정합니다. &lt;em&gt;시간 초과에&lt;/em&gt; 대한 음수 또는 &lt;code&gt;None&lt;/code&gt; 값 처리는 &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; &lt;/a&gt; 의 구현 된 동작과 다릅니다 . &lt;em&gt;타임 아웃&lt;/em&gt; 경우 생성 인자는 실제적인 의미가 없습니다 &lt;em&gt;블록&lt;/em&gt; 인수로 설정&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; &lt;code&gt;False&lt;/code&gt; 이므로 무시됩니다. 반환 &lt;code&gt;True&lt;/code&gt; 잠금이 획득하거나 한 경우 &lt;code&gt;False&lt;/code&gt; 제한 시간이 경과 한 경우.</target>
        </trans-unit>
        <trans-unit id="b7920fec1db552b1e56262de88d29376efd098e4" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If the lock has already been acquired (and thus is owned) by another process or thread, the current process or thread does not take ownership and the recursion level within the lock is not changed, resulting in a return value of &lt;code&gt;False&lt;/code&gt;. If the lock is in an unlocked state, the current process or thread takes ownership and the recursion level is incremented, resulting in a return value of &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;block&lt;/em&gt; 인수를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 다른 프로세스 또는 스레드가 잠금을 이미 획득하여 소유 한 경우 현재 프로세스 또는 스레드는 소유권을 얻지 못하고 잠금 내 재귀 수준이 변경되지 않아 &lt;code&gt;False&lt;/code&gt; 의 반환 값이 발생 합니다. 잠금이 잠금 해제 상태 인 경우 현재 프로세스 또는 스레드가 소유권을 가져오고 재귀 수준이 증가하여 반환 값이 &lt;code&gt;True&lt;/code&gt; 가 됩니다.</target>
        </trans-unit>
        <trans-unit id="26d84ac2fed2d1d6bf35aca2492e7a51b1254f22" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt;, block until the lock is in an unlocked state (not owned by any process or thread) unless the lock is already owned by the current process or thread. The current process or thread then takes ownership of the lock (if it does not already have ownership) and the recursion level inside the lock increments by one, resulting in a return value of &lt;code&gt;True&lt;/code&gt;. Note that there are several differences in this first argument&amp;rsquo;s behavior compared to the implementation of &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt;&lt;code&gt;threading.RLock.acquire()&lt;/code&gt;&lt;/a&gt;, starting with the name of the argument itself.</source>
          <target state="translated">&lt;em&gt;block&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정하여 호출 하면 잠금이 현재 프로세스 또는 스레드에 의해 이미 소유되어 있지 않은 경우 잠금이 잠금 해제 상태 (프로세스 또는 스레드가 소유하지 않음)가 될 때까지 차단합니다. 그런 다음 현재 프로세스 또는 스레드는 잠금 소유권 (아직 소유권이없는 경우)을 가져오고 잠금 내부의 재귀 수준은 1 씩 증가하여 반환 값은 &lt;code&gt;True&lt;/code&gt; 입니다. 인수 자체의 이름으로 시작하는 &lt;a href=&quot;threading#threading.RLock.acquire&quot;&gt; &lt;code&gt;threading.RLock.acquire()&lt;/code&gt; &lt;/a&gt; 의 구현과 비교하여이 첫 번째 인수의 동작에는 몇 가지 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3adb7479baf4957251699e2c3f19fc3aa413e8ed" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, do not block. If a call with &lt;em&gt;blocking&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt; would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, set the lock to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;blocking&lt;/em&gt; 인수를 &lt;code&gt;False&lt;/code&gt; 로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. &lt;em&gt;차단&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 로 설정된 통화가 &lt;em&gt;차단&lt;/em&gt; 되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 잠금을 잠금으로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 리턴하십시오. .</target>
        </trans-unit>
        <trans-unit id="00fee988fe737d2ff47fe5cb9ac426ebebb9888c" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), block until the lock is unlocked, then set it to locked and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;차단&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; (기본값)로 설정하여 호출 하면 잠금이 해제 될 때까지 차단 한 다음 잠금으로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="530808d79c5fd710b7d8c76ae1e70cbe8c467712" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to false, do not block. If a call without an argument would block, return &lt;code&gt;False&lt;/code&gt; immediately; otherwise, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;blocking&lt;/em&gt; 인수를 false로 설정하여 호출하면 &lt;em&gt;차단&lt;/em&gt; 하지 마십시오. 인수가없는 호출이 차단되면 즉시 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. 그렇지 않으면 인수없이 호출 할 때와 동일한 작업을 수행하고 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. 합니다.</target>
        </trans-unit>
        <trans-unit id="4c7b2e8b0136f5c21ccc0f8e3de7ab48e6ebe94d" translate="yes" xml:space="preserve">
          <source>When invoked with the &lt;em&gt;blocking&lt;/em&gt; argument set to true, do the same thing as when called without arguments, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">호출 할 때 &lt;em&gt;차단&lt;/em&gt; true로 인수 세트, 인수없이 호출 할 때와 같은 일을하고, 반환 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b710997372980f7c6061e22520300cdf15b9436e" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. A &lt;em&gt;timeout&lt;/em&gt; argument of &lt;code&gt;-1&lt;/code&gt; specifies an unbounded wait. It is forbidden to specify a &lt;em&gt;timeout&lt;/em&gt; when &lt;em&gt;blocking&lt;/em&gt; is false.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수를 양수 값으로 설정하여 호출 할 경우 , 잠금을 확보 할 수없는 한 &lt;em&gt;시간 종료로&lt;/em&gt; 지정된 최대 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;em&gt;초과&lt;/em&gt; 의 인자 &lt;code&gt;-1&lt;/code&gt; 안 바운드 대기를 지정한다. &lt;em&gt;차단할&lt;/em&gt; 때 &lt;em&gt;시간 초과&lt;/em&gt; 를 지정하는 것은 금지되어 있습니다&lt;em&gt;&lt;/em&gt; 이 거짓 일 있습니다.</target>
        </trans-unit>
        <trans-unit id="2140b5f65b8ba6f4b2bd371613d7e60332a2c64a" translate="yes" xml:space="preserve">
          <source>When invoked with the floating-point &lt;em&gt;timeout&lt;/em&gt; argument set to a positive value, block for at most the number of seconds specified by &lt;em&gt;timeout&lt;/em&gt; and as long as the lock cannot be acquired. Return &lt;code&gt;True&lt;/code&gt; if the lock has been acquired, false if the timeout has elapsed.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수를 양수 값으로 설정하여 호출 할 경우 , 잠금을 확보 할 수없는 한 &lt;em&gt;시간 종료로&lt;/em&gt; 지정된 최대 &lt;em&gt;시간 (&lt;/em&gt; 초) 동안 차단 하십시오. &lt;code&gt;True&lt;/code&gt; 반환잠금이 획득되면 , 제한 시간이 경과하면 false를 합니다.</target>
        </trans-unit>
        <trans-unit id="dec567edc06d3b9893b2e7ade359dacbc93eb18e" translate="yes" xml:space="preserve">
          <source>When invoked without arguments:</source>
          <target state="translated">인수없이 호출 된 경우 :</target>
        </trans-unit>
        <trans-unit id="2c15ab576c9f7d8bf5867e09294955007cfb98cc" translate="yes" xml:space="preserve">
          <source>When invoked without arguments: if this thread already owns the lock, increment the recursion level by one, and return immediately. Otherwise, if another thread owns the lock, block until the lock is unlocked. Once the lock is unlocked (not owned by any thread), then grab ownership, set the recursion level to one, and return. If more than one thread is blocked waiting until the lock is unlocked, only one at a time will be able to grab ownership of the lock. There is no return value in this case.</source>
          <target state="translated">인수없이 호출 된 경우 :이 스레드가 이미 잠금을 소유 한 경우 재귀 레벨을 1 씩 늘리고 즉시 리턴하십시오. 그렇지 않으면 다른 스레드가 잠금을 소유 한 경우 잠금이 해제 될 때까지 차단하십시오. 잠금이 해제되면 (스레드가 소유하지 않은) 소유권을 잡고 재귀 수준을 1로 설정 한 후 돌아갑니다. 잠금이 해제 될 때까지 대기중인 스레드가 둘 이상인 경우 한 번에 하나만 잠금 소유권을 잡을 수 있습니다. 이 경우 반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b96b14764f1e6579b1b14032256583960d45abf4" translate="yes" xml:space="preserve">
          <source>When invoking external programs, make sure they can be found. Usually, this means using absolute path names &amp;mdash; &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; is usually not set to a very useful value in a CGI script.</source>
          <target state="translated">외부 프로그램을 호출 할 때 찾을 수 있는지 확인하십시오. 일반적으로 이것은 절대 경로 이름을 사용함을 의미합니다. &lt;code id=&quot;index-5&quot;&gt;PATH&lt;/code&gt; 는 일반적으로 CGI 스크립트에서 매우 유용한 값으로 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d49406082e5d3ef12b51588b4ee561e90642dbb" translate="yes" xml:space="preserve">
          <source>When more than one coroutine is blocked in &lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the lock to be unlocked, only one coroutine eventually proceeds.</source>
          <target state="translated">잠금 해제를 기다리는 &lt;a href=&quot;#asyncio.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 둘 이상의 코 루틴이 차단되면 결국 하나의 코 루틴 만 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="d757253ec842e92c57d2efdf31bbd2d4624ea4d1" translate="yes" xml:space="preserve">
          <source>When more than one key is provided, then additional keys are used as secondary criteria when there is equality in all keys selected before them. For example, &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; will sort all the entries according to their function name, and resolve all ties (identical function names) by sorting by file name.</source>
          <target state="translated">둘 이상의 키가 제공되면, 이전에 선택된 모든 키가 동일 할 때 추가 키가 보조 기준으로 사용됩니다. 예를 들어 &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILE)&lt;/code&gt; 은 함수 이름에 따라 모든 항목을 정렬하고 파일 이름을 기준으로 정렬하여 모든 관계 (동일한 함수 이름)를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ea00e1f9fb3773e02544a5c95c6a57b4665e0f48" translate="yes" xml:space="preserve">
          <source>When more than one pickle file are specified, print given preamble before each disassembly.</source>
          <target state="translated">하나 이상의 피클 파일이 지정되면 각 분해 전에 주어진 프리앰블을 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="9a26198a4f09f3862bf0af3dbd7f4aeaa0993b74" translate="yes" xml:space="preserve">
          <source>When more than one thread is blocked in &lt;a href=&quot;#threading.Lock.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; waiting for the state to turn to unlocked, only one thread proceeds when a &lt;a href=&quot;#threading.Lock.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; call resets the state to unlocked; which one of the waiting threads proceeds is not defined, and may vary across implementations.</source>
          <target state="translated">상태가 잠금 해제 상태가되기를 기다리는 &lt;a href=&quot;#threading.Lock.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 에서 둘 이상의 스레드가 차단 되면 &lt;a href=&quot;#threading.Lock.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출이 상태를 잠금 해제 상태로 재설정 할 때 하나의 스레드 만 진행 됩니다. 대기 스레드 중 하나가 진행되는 것은 정의되지 않았으며 구현에 따라 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf9260c7b087d873e21d35d7eab19843d9322220" translate="yes" xml:space="preserve">
          <source>When multiple objects are disassembled, preserve memo between disassemblies.</source>
          <target state="translated">여러 개체를 분해 할 때는 분해간에 메모를 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="d053b7be9831593a88afbed3a5bc6fa5f8506a45" translate="yes" xml:space="preserve">
          <source>When multiple processes with differing UIDs assign sockets to an identical UDP socket address with &lt;code&gt;SO_REUSEADDR&lt;/code&gt;, incoming packets can become randomly distributed among the sockets.</source>
          <target state="translated">UID가 다른 여러 프로세스가 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 사용하여 동일한 UDP 소켓 주소에 소켓을 할당 하면 들어오는 패킷이 소켓간에 무작위로 분산 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3978842d4de4c74136c46923ed77df9264119bc1" translate="yes" xml:space="preserve">
          <source>When no &lt;em&gt;path&lt;/em&gt; is specified, the results of &lt;a href=&quot;os#os.environ&quot;&gt;&lt;code&gt;os.environ()&lt;/code&gt;&lt;/a&gt; are used, returning either the &amp;ldquo;PATH&amp;rdquo; value or a fallback of &lt;a href=&quot;os#os.defpath&quot;&gt;&lt;code&gt;os.defpath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 를 지정 하지 않으면 &lt;a href=&quot;os#os.environ&quot;&gt; &lt;code&gt;os.environ()&lt;/code&gt; &lt;/a&gt; 의 결과 가 사용되어&amp;ldquo;PATH&amp;rdquo;값 또는 &lt;a href=&quot;os#os.defpath&quot;&gt; &lt;code&gt;os.defpath&lt;/code&gt; &lt;/a&gt; 의 폴백을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="60fa2ee1d31958e02f93bc8b356815374fa1d19b" translate="yes" xml:space="preserve">
          <source>When no explicit alignment is given, preceding the &lt;em&gt;width&lt;/em&gt; field by a zero (&lt;code&gt;'0'&lt;/code&gt;) character enables sign-aware zero-padding for numeric types. This is equivalent to a &lt;em&gt;fill&lt;/em&gt; character of &lt;code&gt;'0'&lt;/code&gt; with an &lt;em&gt;alignment&lt;/em&gt; type of &lt;code&gt;'='&lt;/code&gt;.</source>
          <target state="translated">명시적인 정렬이 지정되지 않은 경우 &lt;em&gt;너비&lt;/em&gt; 필드 앞에 0 ( &lt;code&gt;'0'&lt;/code&gt; ) 문자 가 있으면 숫자 유형에 대해 부호 인식 제로 패딩이 가능합니다. 이것은 &lt;em&gt;정렬&lt;/em&gt; 유형이 &lt;code&gt;'='&lt;/code&gt; 인&lt;em&gt;채우기&lt;/em&gt; 문자 &lt;code&gt;'0'&lt;/code&gt; 과 같습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6065b034a11abad3d959f6d6989348ca636780d3" translate="yes" xml:space="preserve">
          <source>When no match is found, return whatever is available instead, possibly empty bytes. Raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; if the connection is closed and no cooked data is available.</source>
          <target state="translated">일치하는 것이 없으면 빈 바이트가 아닌 사용 가능한 것을 반환하십시오. 인상 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 연결이 닫혀없이 조리 데이터를 사용할 수있는 경우.</target>
        </trans-unit>
        <trans-unit id="4d974deeca1f469c2b5a6fa343cdf431c097d9b5" translate="yes" xml:space="preserve">
          <source>When one pastes code into Shell, it is not compiled and possibly executed until one hits</source>
          <target state="translated">셸에 코드를 붙여 넣을 때 코드가 컴파일되지 않고 적중 될 때까지 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df4178055aedbbbaa771fd15ebbc33ceeea78f97" translate="yes" xml:space="preserve">
          <source>When one uses &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;Connection.recv&lt;/code&gt;&lt;/a&gt;, the data received is automatically unpickled. Unfortunately unpickling data from an untrusted source is a security risk. Therefore &lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt;&lt;code&gt;Listener&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt;&lt;code&gt;Client()&lt;/code&gt;&lt;/a&gt; use the &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module to provide digest authentication.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;Connection.recv&lt;/code&gt; 를&lt;/a&gt; 사용하면 수신 된 데이터가 자동으로 선택 해제됩니다. 불행히도 신뢰할 수없는 출처에서 데이터를 뽑아내는 것은 보안 상 위험합니다. 따라서 &lt;a href=&quot;#multiprocessing.connection.Listener&quot;&gt; &lt;code&gt;Listener&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#multiprocessing.connection.Client&quot;&gt; &lt;code&gt;Client()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 다이제스트 인증을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="defeae2dfe201352a7bdcfddb389352110acc25b" translate="yes" xml:space="preserve">
          <source>When one wants to match a literal backslash, it must be escaped in the regular expression. With raw string notation, this means &lt;code&gt;r&quot;\\&quot;&lt;/code&gt;. Without raw string notation, one must use &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt;, making the following lines of code functionally identical:</source>
          <target state="translated">리터럴 백 슬래시와 일치 시키려면 정규식에서 이스케이프해야합니다. 원시 문자열 표기법을 사용하면 &lt;code&gt;r&quot;\\&quot;&lt;/code&gt; 입니다. 원시 문자열 표기법이 없으면 &lt;code&gt;&quot;\\\\&quot;&lt;/code&gt; 를 사용해야 다음 코드 행의 기능이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb74b28bda4099bc79fd005722acae57fc6872e" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the &lt;em&gt;format&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;. In this case, the &lt;em&gt;check&lt;/em&gt; and &lt;em&gt;preset&lt;/em&gt; arguments should not be used.</source>
          <target state="translated">읽을 파일을 열 때 &lt;em&gt;형식&lt;/em&gt; 및 &lt;em&gt;필터&lt;/em&gt; 인수는 &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 . 이 경우 &lt;em&gt;확인&lt;/em&gt; 및 &lt;em&gt;사전 설정&lt;/em&gt; 인수를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2aa3b23d9c311bebcce2d82c3b6469767bdd03e8" translate="yes" xml:space="preserve">
          <source>When opening a file for reading, the input file may be the concatenation of multiple separate compressed streams. These are transparently decoded as a single logical stream.</source>
          <target state="translated">읽을 파일을 열 때 입력 파일은 여러 개의 개별 압축 스트림을 연결 한 것일 수 있습니다. 이들은 단일 논리 스트림으로 투명하게 디코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="b40148ffbc845740f7452ddadab19f55d4a0a189" translate="yes" xml:space="preserve">
          <source>When opening a file for writing, the &lt;em&gt;format&lt;/em&gt;, &lt;em&gt;check&lt;/em&gt;, &lt;em&gt;preset&lt;/em&gt; and &lt;em&gt;filters&lt;/em&gt; arguments have the same meanings as for &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt;&lt;code&gt;LZMACompressor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쓰기 위해 파일을 열 때 &lt;em&gt;형식&lt;/em&gt; , &lt;em&gt;검사&lt;/em&gt; , &lt;em&gt;사전 설정&lt;/em&gt; 및 &lt;em&gt;필터&lt;/em&gt; 인수는 &lt;a href=&quot;#lzma.LZMACompressor&quot;&gt; &lt;code&gt;LZMACompressor&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="0673e8efa9150c8c2de8c19210f1833061eca945" translate="yes" xml:space="preserve">
          <source>When operating in POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following parsing rules.</source>
          <target state="translated">POSIX 모드에서 작동 할 때 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 는 다음 구문 분석 규칙을 따르려고합니다.</target>
        </trans-unit>
        <trans-unit id="07b63f3da75da4705f49d38fa15d535bbd4d2a24" translate="yes" xml:space="preserve">
          <source>When operating in non-POSIX mode, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will try to obey to the following rules.</source>
          <target state="translated">비 POSIX 모드에서 작동 할 때 &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 는 다음 규칙을 따르려고합니다.</target>
        </trans-unit>
        <trans-unit id="45df7e43b0ea1fa603be77df6607a8c7e5ebe833" translate="yes" xml:space="preserve">
          <source>When packing a value &lt;code&gt;x&lt;/code&gt; using one of the integer formats (&lt;code&gt;'b'&lt;/code&gt;, &lt;code&gt;'B'&lt;/code&gt;, &lt;code&gt;'h'&lt;/code&gt;, &lt;code&gt;'H'&lt;/code&gt;, &lt;code&gt;'i'&lt;/code&gt;, &lt;code&gt;'I'&lt;/code&gt;, &lt;code&gt;'l'&lt;/code&gt;, &lt;code&gt;'L'&lt;/code&gt;, &lt;code&gt;'q'&lt;/code&gt;, &lt;code&gt;'Q'&lt;/code&gt;), if &lt;code&gt;x&lt;/code&gt; is outside the valid range for that format then &lt;a href=&quot;#struct.error&quot;&gt;&lt;code&gt;struct.error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">정수 형식 ( &lt;code&gt;'b'&lt;/code&gt; , &lt;code&gt;'B'&lt;/code&gt; , &lt;code&gt;'h'&lt;/code&gt; , &lt;code&gt;'H'&lt;/code&gt; , &lt;code&gt;'i'&lt;/code&gt; , &lt;code&gt;'I'&lt;/code&gt; , &lt;code&gt;'l'&lt;/code&gt; , &lt;code&gt;'L'&lt;/code&gt; , &lt;code&gt;'q'&lt;/code&gt; , &lt;code&gt;'Q'&lt;/code&gt; 중 하나를 사용하여 값 &lt;code&gt;x&lt;/code&gt; 를 패킹 할 때 ' ), &lt;code&gt;x&lt;/code&gt; 가 해당 형식의 유효한 범위를 벗어나면 &lt;a href=&quot;#struct.error&quot;&gt; &lt;code&gt;struct.error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4ff53ce933cb55e5d195fd8da14f24a9ea8a7dec" translate="yes" xml:space="preserve">
          <source>When passing a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance as the &lt;em&gt;zinfo_or_arcname&lt;/em&gt; parameter, the compression method used will be that specified in the &lt;em&gt;compress_type&lt;/em&gt; member of the given &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance. By default, the &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; constructor sets this member to &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt;&lt;code&gt;ZIP_STORED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스를 &lt;em&gt;zinfo_or_arcname&lt;/em&gt; 매개 변수 로 전달할 때 사용 된 압축 방법 은 지정된 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 의 &lt;em&gt;compress_type&lt;/em&gt; 멤버에 지정된 압축 방법 입니다. 기본적으로 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 생성자는이 멤버를 &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt; &lt;code&gt;ZIP_STORED&lt;/code&gt; 로&lt;/a&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="fbfc7a1fdbd85a7a8af9ae652a598a7fb18209e5" translate="yes" xml:space="preserve">
          <source>When passing strings, characters special to XML such as &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; will be automatically escaped. However, it&amp;rsquo;s the caller&amp;rsquo;s responsibility to ensure that the string is free of characters that aren&amp;rsquo;t allowed in XML, such as the control characters with ASCII values between 0 and 31 (except, of course, tab, newline and carriage return); failing to do this will result in an XML-RPC request that isn&amp;rsquo;t well-formed XML. If you have to pass arbitrary bytes via XML-RPC, use &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; classes or the &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; wrapper class described below.</source>
          <target state="translated">문자열을 전달하면 &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;&lt;/code&gt; 와 같은 XML에 특수한 문자 가 자동으로 이스케이프됩니다. 그러나 0에서 31 사이의 ASCII 값을 가진 제어 문자 (물론 탭, 줄 바꿈 및 캐리지 리턴 제외)와 같이 문자열에 XML에서 허용되지 않는 문자가 없는지 확인하는 것은 호출자의 책임입니다. 이렇게하지 않으면 XML 형식이 잘못된 XML-RPC 요청이 발생합니다. XML-RPC를 통해 임의의 바이트를 전달해야하는 경우 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 바이트 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 클래스 또는 아래 설명 된 &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt; 래퍼 클래스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="63bc2447bdc66517ffbc569605d6b0a283df40ef" translate="yes" xml:space="preserve">
          <source>When performing basic authentication, a &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; instance calls its &lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt;&lt;code&gt;prompt_user_passwd()&lt;/code&gt;&lt;/a&gt; method. The default implementation asks the users for the required information on the controlling terminal. A subclass may override this method to support more appropriate behavior if needed.</source>
          <target state="translated">기본 인증을 수행 할 때 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;#urllib.request.FancyURLopener.prompt_user_passwd&quot;&gt; &lt;code&gt;prompt_user_passwd()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 . 기본 구현은 사용자에게 제어 터미널에 대한 필수 정보를 요청합니다. 필요한 경우 서브 클래스가이 메소드를 대체하여보다 적절한 동작을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdd3028f0460b2a38b88a225adf972c3a4a4fe5b" translate="yes" xml:space="preserve">
          <source>When printing output to the console, &lt;strong&gt;pydoc&lt;/strong&gt; attempts to paginate the output for easier reading. If the &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; environment variable is set, &lt;strong&gt;pydoc&lt;/strong&gt; will use its value as a pagination program.</source>
          <target state="translated">콘솔에 출력을 인쇄 할 때 &lt;strong&gt;pydoc&lt;/strong&gt; 은 더 읽기 쉽게 출력을 페이지 매김하려고 시도합니다. 경우] &lt;code id=&quot;index-1&quot;&gt;PAGER&lt;/code&gt; 환경 변수 설정, &lt;strong&gt;pydoc이는&lt;/strong&gt; 페이지 매김 프로그램으로 그 값을 사용한다.</target>
        </trans-unit>
        <trans-unit id="0ed1e3583fcf60dc14b51dea1fcf2276215158d1" translate="yes" xml:space="preserve">
          <source>When programming in a compiled language, shared libraries are accessed when compiling/linking a program, and when the program is run.</source>
          <target state="translated">컴파일 된 언어로 프로그래밍 할 때 프로그램을 컴파일 / 링크 할 때 및 프로그램이 실행될 때 공유 라이브러리에 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="03f1758f540eba7a39f832dfe0bdad388ef357ae" translate="yes" xml:space="preserve">
          <source>When provided, &lt;em&gt;extra_args&lt;/em&gt; is a sequence of &lt;code&gt;(name, value)&lt;/code&gt; tuples that will be passed as keywords arguments to the callable.</source>
          <target state="translated">제공되면 &lt;em&gt;extra_args&lt;/em&gt; 는 &lt;code&gt;(name, value)&lt;/code&gt; 튜플 의 시퀀스로 , 키워드 인수로 호출 가능 항목에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7d590e3c7f8f976b86d3937ef37f23bbcf9e23b0" translate="yes" xml:space="preserve">
          <source>When raising (or re-raising) an exception in an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause &lt;code&gt;__context__&lt;/code&gt; is automatically set to the last exception caught; if the new exception is not handled the traceback that is eventually displayed will include the originating exception(s) and the final exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절 에서 예외를 발생 (또는 다시 발생) 할 때 &lt;code&gt;__context__&lt;/code&gt; 는 마지막으로 발생한 예외로 자동 설정됩니다. 새 예외가 처리되지 않으면 결국 표시되는 추적에는 원래 예외 및 최종 예외가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a67ffe067c715a48c6e91eae37f79dcbfbe58ddb" translate="yes" xml:space="preserve">
          <source>When raising (or re-raising) an exception in an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause &lt;code&gt;__context__&lt;/code&gt; is automatically set to the last exception caught; if the new exception is not handled the traceback that is eventually displayed will include the originating exception(s) and the final exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절 에서 예외를 발생 (또는 다시 발생) 할 때 &lt;code&gt;__context__&lt;/code&gt; 는 마지막으로 포착 된 예외로 자동 설정됩니다. 새 예외가 처리되지 않으면 최종적으로 표시되는 역 추적에는 원래 예외와 최종 예외가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="84626ccb1f1b7c51c54d20b65a4d9d24bac172db" translate="yes" xml:space="preserve">
          <source>When raising a new exception (rather than using a bare &lt;code&gt;raise&lt;/code&gt; to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">현재 처리중인 예외를 다시 발생시키기 &lt;code&gt;raise&lt;/code&gt; 베어 인상 을 사용하지 않고 새 예외를 발생 시킬 때 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#raise&quot;&gt; &lt;code&gt;raise&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; 을 사용하여 명시 적 원인으로 암시 적 예외 컨텍스트를 보완 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93bd48fad8b203b60c5efe8bb8ffe28fea84868a" translate="yes" xml:space="preserve">
          <source>When raising a new exception (rather than using a bare &lt;code&gt;raise&lt;/code&gt; to re-raise the exception currently being handled), the implicit exception context can be supplemented with an explicit cause by using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#raise&quot;&gt;&lt;code&gt;raise&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">새 예외를 발생시킬 때 ( 현재 처리중인 예외를 다시 발생시키기 &lt;code&gt;raise&lt;/code&gt; 베어 발생 을 사용하는 대신 ) 암시 적 예외 컨텍스트를 &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; with &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#raise&quot;&gt; &lt;code&gt;raise&lt;/code&gt; &lt;/a&gt; 를 사용하여 명시적인 원인으로 보완 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebdaa4be34e107dcd8db3e5870c90743caace639" translate="yes" xml:space="preserve">
          <source>When reading data from this object, a larger amount of data may be requested from the underlying raw stream, and kept in an internal buffer. The buffered data can then be returned directly on subsequent reads.</source>
          <target state="translated">이 개체에서 데이터를 읽을 때 기본 원시 스트림에서 더 많은 양의 데이터를 요청하고 내부 버퍼에 보관할 수 있습니다. 버퍼링 된 데이터는 후속 읽기에서 직접 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc416240914fa2f9d0a3585ee1b058f79fc51d82" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">스트림에서 입력을 읽을 때 &lt;em&gt;개행&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용 개행&lt;/a&gt; 모드가 사용됩니다. 입력의 행은 &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\r\n'&lt;/code&gt; 끝날 수 있으며 호출자에게 반환되기 전에 &lt;code&gt;'\n'&lt;/code&gt; 으로 변환됩니다 . 이 경우 &lt;code&gt;''&lt;/code&gt; 보편적 인 줄 바꿈 모드가 활성화되어 있지만, 라인 끝은 번역되지 않은 호출자에게 반환됩니다. 다른 유효한 값이 있으면 입력 줄은 주어진 문자열로만 끝나고 줄 끝은 번역되지 않은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cdc9df5bfe580172c92099968262f07274c0e815" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If &lt;em&gt;newline&lt;/em&gt; has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">스트림에서 입력을 읽을 때 &lt;em&gt;newline&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;범용 &lt;/a&gt;&lt;em&gt;줄 &lt;/em&gt;바꿈 모드가 활성화됩니다. 입력의 줄은 &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\r\n'&lt;/code&gt; 끝날 수 있으며 호출자에게 반환되기 전에 &lt;code&gt;'\n'&lt;/code&gt; 으로 변환됩니다 . 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 있다 &lt;code&gt;''&lt;/code&gt; 보편적 줄 바꿈 모드가 활성화되어 있지만, 라인 끝은 번역되지 않은 호출자에게 반환됩니다. 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 다른 법적 값 중 하나를 가지고, 입력 라인은 지정된 캐릭터로 종료되며, 라인 결말은 번역되지 않은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="521e95b377d73dc55cb2baf5c5af8fdf1ed894f3" translate="yes" xml:space="preserve">
          <source>When reading input from the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, universal newlines mode is enabled. Lines in the input can end in &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt;, or &lt;code&gt;'\r\n'&lt;/code&gt;, and these are translated into &lt;code&gt;'\n'&lt;/code&gt; before being returned to the caller. If it is &lt;code&gt;''&lt;/code&gt;, universal newlines mode is enabled, but line endings are returned to the caller untranslated. If it has any of the other legal values, input lines are only terminated by the given string, and the line ending is returned to the caller untranslated.</source>
          <target state="translated">스트림에서 입력을 읽을 때 &lt;em&gt;개행&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 범용 개행 모드가 사용됩니다. 입력의 행은 &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\r\n'&lt;/code&gt; 끝날 수 있으며 호출자에게 반환되기 전에 &lt;code&gt;'\n'&lt;/code&gt; 으로 변환됩니다 . 이 경우 &lt;code&gt;''&lt;/code&gt; 보편적 인 줄 바꿈 모드가 활성화되어 있지만, 라인 끝은 번역되지 않은 호출자에게 반환됩니다. 다른 유효한 값이 있으면 입력 줄은 주어진 문자열로만 끝나고 줄 끝은 번역되지 않은 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ef6664d6092937daced8b81f9ccf4a2841a1ee61" translate="yes" xml:space="preserve">
          <source>When reading or writing external files, make sure they can be read or written by the userid under which your CGI script will be running: this is typically the userid under which the web server is running, or some explicitly specified userid for a web server&amp;rsquo;s &lt;code&gt;suexec&lt;/code&gt; feature.</source>
          <target state="translated">외부 파일을 읽거나 쓸 때 CGI 스크립트가 실행될 사용자 ID로 파일을 읽거나 쓸 수 있는지 확인하십시오. 일반적으로 웹 서버가 실행되는 사용자 ID이거나 웹 서버의 &lt;code&gt;suexec&lt;/code&gt; 에 대해 명시 적으로 지정된 사용자 ID입니다. 특색.</target>
        </trans-unit>
        <trans-unit id="d8df0ae7a831d2bc654fc7f26ceaddd0fec6a53d" translate="yes" xml:space="preserve">
          <source>When receiving host names from the wire (such as in reverse name lookup), no automatic conversion to Unicode is performed: applications wishing to present such host names to the user should decode them to Unicode.</source>
          <target state="translated">유선에서 호스트 이름을 수신 할 때 (예 : 리버스 이름 검색에서) 유니 코드로 자동 변환되지 않습니다. 이러한 호스트 이름을 사용자에게 제공하려는 응용 프로그램은 유니 코드로 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="c249fada241449b7a8d98255500a026f1ff7ff6e" translate="yes" xml:space="preserve">
          <source>When rotating, rotate the current log.</source>
          <target state="translated">회전 할 때 현재 로그를 회전하십시오.</target>
        </trans-unit>
        <trans-unit id="009f8f1003bd38ceb66bdf4766db141ef685c52a" translate="yes" xml:space="preserve">
          <source>When run with the appropriate arguments, it prints either the sum or the max of the command-line integers:</source>
          <target state="translated">적절한 인수를 사용하여 실행하면 명령 줄 정수의 합계 또는 최대 값을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="d2c61737a1449cc5834b15d481c322aac953d7bb" translate="yes" xml:space="preserve">
          <source>When running a tkinter program from an IDLE editor, one can comment out the mainloop call. One then gets a shell prompt immediately and can interact with the live application. One just has to remember to re-enable the mainloop call when running in standard Python.</source>
          <target state="translated">IDLE 편집기에서 tkinter 프로그램을 실행할 때 mainloop 호출을 주석 처리 할 수 ​​있습니다. 그러면 즉시 쉘 프롬프트가 표시되고 라이브 애플리케이션과 상호 작용할 수 있습니다. 표준 파이썬에서 실행할 때 mainloop 호출을 다시 활성화해야한다는 것을 기억해야합니다.</target>
        </trans-unit>
        <trans-unit id="ef04bb8c76c31bcff2e40b83fb3b51dbc495fd47" translate="yes" xml:space="preserve">
          <source>When serializing to JSON, beware any such limitations in applications that may consume your JSON. In particular, it is common for JSON numbers to be deserialized into IEEE 754 double precision numbers and thus subject to that representation&amp;rsquo;s range and precision limitations. This is especially relevant when serializing Python &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; values of extremely large magnitude, or when serializing instances of &amp;ldquo;exotic&amp;rdquo; numerical types such as &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">JSON으로 직렬화 할 때 JSON을 소비 할 수있는 애플리케이션에서 이러한 제한 사항에 유의하십시오. 특히 JSON 숫자는 IEEE 754 배정 밀도 숫자로 역 직렬화되는 것이 일반적이므로 해당 표현의 범위 및 정밀도 제한이 적용됩니다. 이것은 매우 큰 규모의 Python &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 값을 직렬화하거나 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; 과 같은 &quot;이국적인&quot;숫자 유형의 인스턴스를 직렬화 할 때 특히 관련이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3856e8bd6a5962d17cc2916a2ad00664a1e6d558" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;True&lt;/code&gt;, the parser will not allow for any section or option duplicates while reading from a single source (using &lt;code&gt;read_file()&lt;/code&gt;, &lt;code&gt;read_string()&lt;/code&gt; or &lt;code&gt;read_dict()&lt;/code&gt;). It is recommended to use strict parsers in new applications.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 로 설정 하면 구문 분석기는 단일 소스에서 읽는 동안 ( &lt;code&gt;read_file()&lt;/code&gt; , &lt;code&gt;read_string()&lt;/code&gt; 또는 &lt;code&gt;read_dict()&lt;/code&gt; ) 섹션 또는 옵션 중복을 허용하지 않습니다 . 새로운 응용 프로그램에서는 엄격한 파서를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="af553f6e77f3799cc572c24f6b17d618156fcd66" translate="yes" xml:space="preserve">
          <source>When set to a value other than &lt;code&gt;None&lt;/code&gt;, this variable defines the default value for the &lt;em&gt;dir&lt;/em&gt; argument to the functions defined in this module.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이외의 값으로 설정되면 이 변수는 &lt;em&gt;dir&lt;/em&gt; 인수 의 기본값 을이 모듈에 정의 된 함수로 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a651c4386e23ffbd8bc757cc1022ed6e854c9c0d" translate="yes" xml:space="preserve">
          <source>When set, all unreachable objects found will be appended to &lt;em&gt;garbage&lt;/em&gt; rather than being freed. This can be useful for debugging a leaking program.</source>
          <target state="translated">설정하면 발견 할 수없는 모든 오브젝트 가 해제되지 않고 &lt;em&gt;가비지에&lt;/em&gt; 추가됩니다 . 누출 프로그램을 디버깅하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="966461a5030c03e1d1f1351234001ea1acd1bcfd" translate="yes" xml:space="preserve">
          <source>When setting cookies, require a full &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; domain-match.</source>
          <target state="translated">쿠키를 설정할 때 전체 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 도메인 일치가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="962945e9937ea98d222513b922d5881fd1bf1687" translate="yes" xml:space="preserve">
          <source>When setting cookies, the &amp;lsquo;host prefix&amp;rsquo; must not contain a dot (eg. &lt;code&gt;www.foo.bar.com&lt;/code&gt; can&amp;rsquo;t set a cookie for &lt;code&gt;.bar.com&lt;/code&gt;, because &lt;code&gt;www.foo&lt;/code&gt; contains a dot).</source>
          <target state="translated">쿠키를 설정하면, '호스트 접두사'는 점을 포함 할 수 없습니다 (예를 들면. &lt;code&gt;www.foo.bar.com&lt;/code&gt; 을 위해 쿠키를 설정할 수 없습니다 &lt;code&gt;.bar.com&lt;/code&gt; 을 하기 때문에, &lt;code&gt;www.foo&lt;/code&gt; 는 점을 포함).</target>
        </trans-unit>
        <trans-unit id="1497d638ca2af8c9832a39909543a42d33c7e1e0" translate="yes" xml:space="preserve">
          <source>When several absolute paths are given, the last is taken as an anchor (mimicking &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s behaviour):</source>
          <target state="translated">몇 개의 절대 경로가 주어지면 마지막은 앵커로 간주됩니다 ( &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; 의 동작을 모방 ).</target>
        </trans-unit>
        <trans-unit id="0ef246b92ec78bbb2904be545cecaaa31079bddf" translate="yes" xml:space="preserve">
          <source>When specified, all sequences of whitespace (blanks and newlines) are treated as equal. Any sequence of whitespace within the expected output will match any sequence of whitespace within the actual output. By default, whitespace must match exactly. &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt;&lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt;&lt;/a&gt; is especially useful when a line of expected output is very long, and you want to wrap it across multiple lines in your source.</source>
          <target state="translated">지정하면 모든 공백 문자 (공백 및 개행)가 동일하게 처리됩니다. 예상 출력 내의 공백 시퀀스는 실제 출력 내의 공백 시퀀스와 일치합니다. 기본적으로 공백은 정확히 일치해야합니다. &lt;a href=&quot;#doctest.NORMALIZE_WHITESPACE&quot;&gt; &lt;code&gt;NORMALIZE_WHITESPACE&lt;/code&gt; &lt;/a&gt; 는 예상 출력 라인이 매우 길고 소스의 여러 라인에 랩핑하려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1b218a31cb42b5880f2b77432b336a4dc41d9aa7" translate="yes" xml:space="preserve">
          <source>When specified, an ellipsis marker (&lt;code&gt;...&lt;/code&gt;) in the expected output can match any substring in the actual output. This includes substrings that span line boundaries, and empty substrings, so it&amp;rsquo;s best to keep usage of this simple. Complicated uses can lead to the same kinds of &amp;ldquo;oops, it matched too much!&amp;rdquo; surprises that &lt;code&gt;.*&lt;/code&gt; is prone to in regular expressions.</source>
          <target state="translated">지정된 경우 예상 출력 의 줄임표 마커 ( &lt;code&gt;...&lt;/code&gt; )는 실제 출력의 모든 하위 문자열과 일치 할 수 있습니다. 여기에는 줄 경계에 걸쳐있는 하위 문자열과 빈 하위 문자열이 포함되므로이 사용법을 간단하게 유지하는 것이 가장 좋습니다. 복잡한 사용으로 인해 같은 종류의 &quot;죄송합니다. 너무 많이 일치합니다!&quot; 그 놀라움 &lt;code&gt;.*&lt;/code&gt; 정규식에서하는 경향이있다.</target>
        </trans-unit>
        <trans-unit id="dcb31cc2903efca845f37ae06ecb0d7faead34bc" translate="yes" xml:space="preserve">
          <source>When specified, an example that expects an exception passes if an exception of the expected type is raised, even if the exception detail does not match. For example, an example expecting &lt;code&gt;ValueError: 42&lt;/code&gt; will pass if the actual exception raised is &lt;code&gt;ValueError: 3*14&lt;/code&gt;, but will fail, e.g., if &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 경우 예외 세부 사항이 일치하지 않더라도 예상 유형의 예외가 발생하면 예외를 예상하는 예제가 전달됩니다. 예를 들어, 실제 발생 된 예외가 &lt;code&gt;ValueError: 3*14&lt;/code&gt; 인 경우 &lt;code&gt;ValueError: 42&lt;/code&gt; 를 예상하는 예제 가 전달 되지만 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="506d23fee0102647e3e510ecb1828895d54af340" translate="yes" xml:space="preserve">
          <source>When specified, differences are computed by &lt;code&gt;difflib.Differ&lt;/code&gt;, using the same algorithm as the popular &lt;code&gt;ndiff.py&lt;/code&gt; utility. This is the only method that marks differences within lines as well as across lines. For example, if a line of expected output contains digit &lt;code&gt;1&lt;/code&gt; where actual output contains letter &lt;code&gt;l&lt;/code&gt;, a line is inserted with a caret marking the mismatching column positions.</source>
          <target state="translated">지정되면, 차이점은 &lt;code&gt;difflib.Differ&lt;/code&gt; 사용되는 &lt;code&gt;ndiff.py&lt;/code&gt; 유틸리티 와 동일한 알고리즘을 사용하여 difflib.Differ 에 의해 계산됩니다 . 이것은 라인과 라인 간의 차이를 표시하는 유일한 방법입니다. 예를 들어, 예상 출력 행에 실제 출력에 문자 &lt;code&gt;l&lt;/code&gt; 이 포함 된 숫자 &lt;code&gt;1&lt;/code&gt; 이 포함 된 경우, 일치하지 않는 열 위치를 표시하는 캐럿이있는 행이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="725ed21a520fb4bdfd0c582f999632c3b3e1a3c6" translate="yes" xml:space="preserve">
          <source>When specified, display the first failing example in each doctest, but suppress output for all remaining examples. This will prevent doctest from reporting correct examples that break because of earlier failures; but it might also hide incorrect examples that fail independently of the first failure. When &lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt;&lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt;&lt;/a&gt; is specified, the remaining examples are still run, and still count towards the total number of failures reported; only the output is suppressed.</source>
          <target state="translated">지정된 경우, 각 doctest에서 첫 번째 실패한 예제를 표시하지만 나머지 모든 예제의 출력은 억제하십시오. 이렇게하면 doctest가 초기 실패로 인해 깨지는 올바른 예제를보고하지 못하게됩니다. 그러나 첫 번째 실패와 독립적으로 실패한 잘못된 예를 숨길 수도 있습니다. 때 &lt;a href=&quot;#doctest.REPORT_ONLY_FIRST_FAILURE&quot;&gt; &lt;code&gt;REPORT_ONLY_FIRST_FAILURE&lt;/code&gt; 가&lt;/a&gt; 지정되어, 남아있는 예는 아직 실행하고 여전히보고 실패의 총 수에 반영된다 출력 만 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="aeb4572ffe4ed819ce94cd6722f54cd0aadb9fe4" translate="yes" xml:space="preserve">
          <source>When specified, do not run the example at all. This can be useful in contexts where doctest examples serve as both documentation and test cases, and an example should be included for documentation purposes, but should not be checked. E.g., the example&amp;rsquo;s output might be random; or the example might depend on resources which would be unavailable to the test driver.</source>
          <target state="translated">지정된 경우 예제를 전혀 실행하지 마십시오. 이것은 doctest 예제가 문서 및 테스트 사례로 사용되는 상황에서 유용 할 수 있으며, 예제는 문서 목적으로 포함되어야하지만 점검해서는 안됩니다. 예를 들어, 예제의 출력은 무작위 일 수 있습니다. 또는 예제는 테스트 드라이버가 사용할 수없는 자원에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1313668fddf2714b9e79f58afa68fecf0d72d780" translate="yes" xml:space="preserve">
          <source>When specified, exit after the first failing example and don&amp;rsquo;t attempt to run the remaining examples. Thus, the number of failures reported will be at most 1. This flag may be useful during debugging, since examples after the first failure won&amp;rsquo;t even produce debugging output.</source>
          <target state="translated">지정된 경우 첫 번째 실패한 예제를 종료 한 후 나머지 예제를 실행하지 마십시오. 따라서보고 된 실패 수는 최대 1입니다.이 플래그는 첫 번째 실패 이후의 예에서는 디버깅 출력을 생성하지 않기 때문에 디버깅 중에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a165ac4e0fc877daf25b2fcfe0a4d6e37cd8566f" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs are displayed using a unified diff.</source>
          <target state="translated">지정된 경우 다중 라인 예상 및 실제 출력과 관련된 장애는 통합 된 diff를 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="210d27f93a6ffbf0d54ba3a0a4a851f82c25d9b1" translate="yes" xml:space="preserve">
          <source>When specified, failures that involve multi-line expected and actual outputs will be displayed using a context diff.</source>
          <target state="translated">지정된 경우 다중 라인 예상 및 실제 출력과 관련된 실패는 컨텍스트 차이를 사용하여 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e021460883f1eef6780ecadd57bc2f7a8e86c36" translate="yes" xml:space="preserve">
          <source>When specified, the pattern character &lt;code&gt;'^'&lt;/code&gt; matches at the beginning of the string and at the beginning of each line (immediately following each newline); and the pattern character &lt;code&gt;'$'&lt;/code&gt; matches at the end of the string and at the end of each line (immediately preceding each newline). By default, &lt;code&gt;'^'&lt;/code&gt; matches only at the beginning of the string, and &lt;code&gt;'$'&lt;/code&gt; only at the end of the string and immediately before the newline (if any) at the end of the string. Corresponds to the inline flag &lt;code&gt;(?m)&lt;/code&gt;.</source>
          <target state="translated">지정 될 때 패턴 문자 &lt;code&gt;'^'&lt;/code&gt; 은 문자열의 시작과 각 줄의 시작 부분에서 일치합니다 (각 줄 바꿈 바로 다음). 패턴 문자 &lt;code&gt;'$'&lt;/code&gt; 는 문자열의 끝과 각 줄의 끝에서 (각 줄 바꿈 바로 앞에) 일치합니다. 기본적으로 &lt;code&gt;'^'&lt;/code&gt; 은 문자열의 시작 부분에서만, &lt;code&gt;'$'&lt;/code&gt; 는 문자열의 끝 부분에서만 , 그리고 문자열 끝에서 줄 바꿈 바로 앞 (있는 경우) 에만 일치 합니다. 인라인 플래그 &lt;code&gt;(?m)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6508ccae0114f70101a39c1ade3be77f9a0e54cc" translate="yes" xml:space="preserve">
          <source>When subclassing &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, mix-in types must appear before &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; itself in the sequence of bases, as in the &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; example above.</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 을&lt;/a&gt; 서브 클래 싱 할 때 , 위 의 &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 예제 에서와 같이 믹스 인 타입 은 기본 시퀀스에서 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 자체 앞에 나타나야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ab9f2e0c84d1cef2e81d17d102b665c42c1b918" translate="yes" xml:space="preserve">
          <source>When symbolic link cycles occur, the returned path will be one member of the cycle, but no guarantee is made about which member that will be.</source>
          <target state="translated">심볼릭 링크 사이클이 발생하면 반환 된 경로는 사이클의 한 멤버가되지만 어떤 멤버가 될지는 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dda516a7e878443b38c4fe64189ee1bdd2488b07" translate="yes" xml:space="preserve">
          <source>When testing multiple operations that raise the same kind of warning, it is important to test them in a manner that confirms each operation is raising a new warning (e.g. set warnings to be raised as exceptions and check the operations raise exceptions, check that the length of the warning list continues to increase after each operation, or else delete the previous entries from the warnings list before each new operation).</source>
          <target state="translated">동일한 종류의 경고를 발생시키는 여러 작업을 테스트 할 때는 각 작업이 새로운 경고를 발생시키는 지 확인하는 방식으로 테스트하는 것이 중요합니다 (예 : 예외로 발생하는 경고를 설정하고 작업에서 예외가 발생하는지 확인하고 길이를 확인하십시오) 각 작업 후에 경고 목록이 계속 증가하거나 새 작업 전에 경고 목록에서 이전 항목을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="32c986eba58685d8d5c5b9096bea3ea17575dc2a" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt;&lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt;&lt;/a&gt; doctest option is specified, everything following the leftmost colon and any module information in the exception name is ignored.</source>
          <target state="translated">때 &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt; &lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt; &lt;/a&gt; 옵션 doctest가 지정되면, 왼쪽 콜론과 예외 이름에 모듈 정보를 다음의 모든 것을 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3f49f30bcc7e091d5c01e4ab7c4d154fba44f7" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;noqiflush()&lt;/code&gt; routine is used, normal flush of input and output queues associated with the &lt;code&gt;INTR&lt;/code&gt;, &lt;code&gt;QUIT&lt;/code&gt; and &lt;code&gt;SUSP&lt;/code&gt; characters will not be done. You may want to call &lt;code&gt;noqiflush()&lt;/code&gt; in a signal handler if you want output to continue as though the interrupt had not occurred, after the handler exits.</source>
          <target state="translated">때 &lt;code&gt;noqiflush()&lt;/code&gt; 루틴을 사용하는 경우,과 관련된 입력 및 출력 큐의 정상 높이 &lt;code&gt;INTR&lt;/code&gt; 은 , &lt;code&gt;QUIT&lt;/code&gt; 및 &lt;code&gt;SUSP&lt;/code&gt; 문자는 수행되지 않습니다. 핸들러가 종료 된 후 인터럽트가 발생하지 않은 것처럼 출력을 계속하려면 신호 핸들러에서 &lt;code&gt;noqiflush()&lt;/code&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92f7176cdc28e8fabe1cc4ce9c92d06ff62a9627" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;value&lt;/code&gt; attribute is retrieved from a ctypes instance, usually a new object is returned each time. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; does &lt;em&gt;not&lt;/em&gt; implement original object return, always a new object is constructed. The same is true for all other ctypes object instances.</source>
          <target state="translated">때 &lt;code&gt;value&lt;/code&gt; 속성이하는 ctypes 인스턴스에서 검색, 일반적으로 새로운 객체가 리턴됩니다. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 원래 객체 반환을 구현 하지 &lt;em&gt;않으며&lt;/em&gt; 항상 새로운 객체가 생성됩니다. 다른 모든 ctypes 객체 인스턴스도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cba25eeaf6632c7ebc55efeeb8b1a2231818ee6e" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;name&lt;/em&gt; variable is of the form &lt;code&gt;package.module&lt;/code&gt;, normally, the top-level package (the name up till the first dot) is returned, &lt;em&gt;not&lt;/em&gt; the module named by &lt;em&gt;name&lt;/em&gt;. However, when a non-empty &lt;em&gt;fromlist&lt;/em&gt; argument is given, the module named by &lt;em&gt;name&lt;/em&gt; is returned.</source>
          <target state="translated">때 &lt;em&gt;이름&lt;/em&gt; 변수 폼이다 &lt;code&gt;package.module&lt;/code&gt; 통상, 최상위 레벨 패키지 (제 점까지 이름까지)를 반환 &lt;em&gt;하지&lt;/em&gt; 명명 한 모듈 &lt;em&gt;이름&lt;/em&gt; . 그러나 비어 있지 않은 &lt;em&gt;fromlist&lt;/em&gt; 인수가 제공되면 &lt;em&gt;name&lt;/em&gt; 으로 &lt;em&gt;이름&lt;/em&gt; 지정된 모듈 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0839b23fb2fd3debdac05fc9ae13ae6b565a4724" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is not present or &lt;code&gt;None&lt;/code&gt;, the operation will block until the thread terminates.</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재 아닌지 &lt;code&gt;None&lt;/code&gt; , 동작은 스레드가 종료 될 때까지 차단된다.</target>
        </trans-unit>
        <trans-unit id="a4f2a083cefefece0f9a989089d273d2343db7c8" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 이는 초 작동 시간 제한 (또는 이의 분획물)를 특정하는 부동 소수점 수이어야한다.</target>
        </trans-unit>
        <trans-unit id="9427976e1510be53b2baa1d26a02bd7a239f5c51" translate="yes" xml:space="preserve">
          <source>When the &lt;em&gt;timeout&lt;/em&gt; argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof). As &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; always returns &lt;code&gt;None&lt;/code&gt;, you must call &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; to decide whether a timeout happened &amp;ndash; if the thread is still alive, the &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; call timed out.</source>
          <target state="translated">때 &lt;em&gt;시간 제한&lt;/em&gt; 인자가 존재하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 이는 초 작동 시간 제한 (또는 이의 분획물)를 특정하는 부동 소수점 수이어야한다. 로 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 항상 반환 &lt;code&gt;None&lt;/code&gt; , 당신은 호출해야합니다&lt;a href=&quot;#threading.Thread.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; 이후&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 타임 아웃이 발생 여부를 결정하기 - 스레드가 아직 살아 경우&lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 호출이 초과되었습니다.</target>
        </trans-unit>
        <trans-unit id="4efa641d2d18d3d35e2f53ff91c7db9472e3c6c4" translate="yes" xml:space="preserve">
          <source>When the database has been opened in fast mode, this method forces any unwritten data to be written to the disk.</source>
          <target state="translated">데이터베이스가 빠른 모드로 열린 경우이 방법을 사용하면 쓰지 않은 데이터가 디스크에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b82443f1c4eff35532245efa9cbc5d46a5e79a79" translate="yes" xml:space="preserve">
          <source>When the dataclass is being created by the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator, it looks through all of the class&amp;rsquo;s base classes in reverse MRO (that is, starting at &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;) and, for each dataclass that it finds, adds the fields from that base class to an ordered mapping of fields. After all of the base class fields are added, it adds its own fields to the ordered mapping. All of the generated methods will use this combined, calculated ordered mapping of fields. Because the fields are in insertion order, derived classes override base classes. An example:</source>
          <target state="translated">에 의해 데이터 클래스가 생성 될 때 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 장식, 그것은 (에서 시작된다 역 MRO의 클래스의 기본 클래스의 모든 통해 보이는&lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 는 발견하는 각 dataclass에 대한 등)에 그 기본 클래스에서 필드를 추가합니다 정렬 된 필드 매핑 모든 기본 클래스 필드가 추가 된 후 자체 맵핑 된 필드를 순서 맵핑에 추가합니다. 생성 된 모든 메소드는이 결합 된 계산 된 순서화 된 필드 맵핑을 사용합니다. 필드는 삽입 순서이므로 파생 클래스는 기본 클래스를 재정의합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d9b66dd18ce1e12e4286175c7d8752f320de1be6" translate="yes" xml:space="preserve">
          <source>When the debug mode is enabled:</source>
          <target state="translated">디버그 모드가 활성화 된 경우 :</target>
        </trans-unit>
        <trans-unit id="3d323c0b3abd37e8843f26f7250d48151ff4e9e4" translate="yes" xml:space="preserve">
          <source>When the deque is not empty, rotating one step to the right is equivalent to &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt;, and rotating one step to the left is equivalent to &lt;code&gt;d.append(d.popleft())&lt;/code&gt;.</source>
          <target state="translated">데크가 비어 있지 않은 경우 오른쪽으로 한 단계 씩 회전하는 것은 &lt;code&gt;d.appendleft(d.pop())&lt;/code&gt; 와 같으며 왼쪽으로 한 단계 씩 회전하는 것은 &lt;code&gt;d.append(d.popleft())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="965bb2961456fd9ec18c155c435cd124d7f1e1f7" translate="yes" xml:space="preserve">
          <source>When the following functions return &amp;ldquo;frame records,&amp;rdquo; each record is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt;. The tuple contains the frame object, the filename, the line number of the current line, the function name, a list of lines of context from the source code, and the index of the current line within that list.</source>
          <target state="translated">다음 함수가 &quot;프레임 레코드&quot;를 반환하면 각 레코드는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt; 명명 된 튜플 &lt;/a&gt; &lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt; 입니다. 튜플에는 프레임 객체, 파일 이름, 현재 줄의 줄 번호, 함수 이름, 소스 코드의 컨텍스트 줄 목록 및 해당 목록 내 현재 줄의 색인이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3c368910c5373a95bb55df52216e148f6cdcaba8" translate="yes" xml:space="preserve">
          <source>When the following functions return &amp;ldquo;frame records,&amp;rdquo; each record is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt;. The tuple contains the frame object, the filename, the line number of the current line, the function name, a list of lines of context from the source code, and the index of the current line within that list.</source>
          <target state="translated">다음 함수가 &quot;프레임 레코드&quot;를 반환하면 각 레코드는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플 &lt;/a&gt; &lt;code&gt;FrameInfo(frame, filename, lineno, function, code_context, index)&lt;/code&gt; 입니다. 튜플에는 프레임 개체, 파일 이름, 현재 줄의 줄 번호, 함수 이름, 소스 코드의 컨텍스트 줄 목록 및 해당 목록 내 현재 줄의 인덱스가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a192ce7dd917b79cdadcecc69d15e0e840e3fac2" translate="yes" xml:space="preserve">
          <source>When the function raises a &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; exception, it is silently ignored.</source>
          <target state="translated">함수가 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 예외를 발생 시키면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="0c8af2d5b431a64609659111ed46cf47a5a6d0cb" translate="yes" xml:space="preserve">
          <source>When the function returns, the thread silently exits.</source>
          <target state="translated">함수가 반환되면 스레드가 자동으로 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="2939cf22671cec72fb407f91f1dd1da33466f4b0" translate="yes" xml:space="preserve">
          <source>When the function terminates with an unhandled exception, &lt;a href=&quot;sys#sys.unraisablehook&quot;&gt;&lt;code&gt;sys.unraisablehook()&lt;/code&gt;&lt;/a&gt; is called to handle the exception. The &lt;em&gt;object&lt;/em&gt; attribute of the hook argument is &lt;em&gt;function&lt;/em&gt;. By default, a stack trace is printed and then the thread exits (but other threads continue to run).</source>
          <target state="translated">처리되지 않은 예외로 함수가 종료되면 예외 를 처리하기 위해 &lt;a href=&quot;sys#sys.unraisablehook&quot;&gt; &lt;code&gt;sys.unraisablehook()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. 후크 인수 의 &lt;em&gt;객체&lt;/em&gt; 속성은&lt;em&gt; function&lt;/em&gt; 입니다. 기본적으로 스택 추적이 인쇄 된 다음 스레드가 종료되지만 다른 스레드는 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="11e1f7a5314c521814efab7673f88a014796119b" translate="yes" xml:space="preserve">
          <source>When the iterable is empty, return the start value. This function is intended specifically for use with numeric values and may reject non-numeric types.</source>
          <target state="translated">iterable이 비어 있으면 시작 값을 리턴하십시오. 이 기능은 숫자 값과 함께 사용하기위한 것으로 숫자가 아닌 유형을 거부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0619f802303d6a776090a8553bcded1600861c45" translate="yes" xml:space="preserve">
          <source>When the lock is &lt;em&gt;locked&lt;/em&gt;, reset it to &lt;em&gt;unlocked&lt;/em&gt; and return.</source>
          <target state="translated">잠금이 &lt;em&gt;잠기면&lt;/em&gt; 잠금 을 &lt;em&gt;해제&lt;/em&gt; 하여 다시 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="12b90fc7c45f662a12bf1ee8cea1898d278f7026" translate="yes" xml:space="preserve">
          <source>When the lock is locked, reset it to unlocked, and return. If any other threads are blocked waiting for the lock to become unlocked, allow exactly one of them to proceed.</source>
          <target state="translated">잠금 장치가 잠기면 잠금 해제로 재설정하고 돌아갑니다. 잠금이 해제 될 때까지 다른 스레드가 차단 된 경우 정확히 하나의 스레드가 진행되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="6c398f7629217467760d733727be89698cfaee23" translate="yes" xml:space="preserve">
          <source>When the logging module is imported, it registers this function as an exit handler (see &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt;), so normally there&amp;rsquo;s no need to do that manually.</source>
          <target state="translated">로깅 모듈을 가져 오면이 함수를 종료 핸들러로 등록합니다 ( &lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 참조). )로 등록하므로 일반적으로 수동으로 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cdd980ea6acc8763679979a08e2398cb455101b4" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it does not do any of its usual cleanup (except that &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses are honored), and the standard I/O files are not flushed.</source>
          <target state="translated">기본 스레드가 종료되면 일반적인 정리는 수행되지 않으며 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; ... &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절이 적용되는 것을 제외하고 ) 표준 I / O 파일은 플러시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="447b65a54ecd195ca52b1bbe7503032f5367dc81" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it does not do any of its usual cleanup (except that &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses are honored), and the standard I/O files are not flushed.</source>
          <target state="translated">주 스레드가 종료되면 일반적인 정리를 수행하지 않으며 ( &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절이 적용되는 경우 제외 ) 표준 I / O 파일은 플러시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5af7554aea463351096c790b6eebb65f8d0e1e78" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses or executing object destructors.</source>
          <target state="translated">주 스레드가 종료되면 다른 스레드가 존속하는지 여부가 시스템 정의입니다. 대부분의 시스템에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절을 실행하거나 객체 소멸자를 실행 하지 않고 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="abc6ab97345fb3adba854a2e5fae01d5e49e1ac2" translate="yes" xml:space="preserve">
          <source>When the main thread exits, it is system defined whether the other threads survive. On most systems, they are killed without executing &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clauses or executing object destructors.</source>
          <target state="translated">메인 스레드가 종료 될 때 다른 스레드가 살아남는지 여부는 시스템 정의입니다. 대부분의 시스템에서는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절을 실행하거나 객체 소멸자를 실행 하지 않고 종료 됩니다.</target>
        </trans-unit>
        <trans-unit id="df8416c53a3fab417f18d34ff6b2c7c89921bb9b" translate="yes" xml:space="preserve">
          <source>When the number of data points is even, the median is interpolated by taking the average of the two middle values:</source>
          <target state="translated">데이터 포인트 수가 짝수 인 경우 중간 값은 두 중간 값의 평균을 취하여 보간됩니다.</target>
        </trans-unit>
        <trans-unit id="c3727a0d49a696958b7e7aedf6197c454a60d276" translate="yes" xml:space="preserve">
          <source>When the parser is instantiated it is ready to begin accepting data from the feed method immediately. After parsing has been finished with a call to close the reset method must be called to make the parser ready to accept new data, either from feed or using the parse method.</source>
          <target state="translated">파서가 인스턴스화되면 즉시 피드 메소드에서 데이터를 수락 할 수 있습니다. 구문 분석이 닫히는 호출로 구문 분석이 완료된 후, 구문 분석기가 피드에서 또는 구문 분석 메소드를 사용하여 새 데이터를 승인 할 준비가되도록 재설정 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="512d3776530707ff872caf29c6b20b7211d9d8d5" translate="yes" xml:space="preserve">
          <source>When the path points to a directory, yield path objects of the directory contents:</source>
          <target state="translated">경로가 디렉토리를 가리키는 경우 디렉토리 내용의 경로 객체를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="df6ac2fad722ee466b6d6cb46713a1963668153e" translate="yes" xml:space="preserve">
          <source>When the program exits, each remaining live finalizer is called unless its &lt;a href=&quot;atexit#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; attribute has been set to false. They are called in reverse order of creation.</source>
          <target state="translated">프로그램이 종료되면 해당 &lt;a href=&quot;atexit#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 속성이 false로 설정되어 있지 않으면 남아있는 각 라이브 파이널 라이저가 호출됩니다 . 그것들은 생성 순서와 반대로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a67cebb1835e8e6bf7a770664e7365b4b2e21589" translate="yes" xml:space="preserve">
          <source>When the program starts and selects the &lt;em&gt;forkserver&lt;/em&gt; start method, a server process is started. From then on, whenever a new process is needed, the parent process connects to the server and requests that it fork a new process. The fork server process is single threaded so it is safe for it to use &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt;. No unnecessary resources are inherited.</source>
          <target state="translated">프로그램이 시작되고 &lt;em&gt;forkserver&lt;/em&gt; start 메소드를 선택하면 서버 프로세스가 시작됩니다. 그때부터 새 프로세스가 필요할 때마다 상위 프로세스가 서버에 연결하여 새 프로세스를 분기하도록 요청합니다. 포크 서버 프로세스는 단일 스레드이므로 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 안전합니다 . 불필요한 리소스는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1f5136bd917b359254fcb25318d6cf9878572072" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the bytes object &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">올바른 인수가 사전 (또는 다른 매핑 유형) 인 경우 bytes 객체의 형식 에는 &lt;code&gt;'%'&lt;/code&gt; 문자 바로 뒤에 삽입 된 사전에 괄호로 묶인 매핑 키 &lt;em&gt;가&lt;/em&gt; 포함 &lt;em&gt;되어야합니다&lt;/em&gt; . 맵핑 키는 맵핑에서 형식화 할 값을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1b647f4b9964ada60f8adbae790c7e50f0a7417" translate="yes" xml:space="preserve">
          <source>When the right argument is a dictionary (or other mapping type), then the formats in the string &lt;em&gt;must&lt;/em&gt; include a parenthesised mapping key into that dictionary inserted immediately after the &lt;code&gt;'%'&lt;/code&gt; character. The mapping key selects the value to be formatted from the mapping. For example:</source>
          <target state="translated">올바른 인수가 사전 (또는 다른 매핑 유형) 인 경우 문자열의 형식 에는 &lt;code&gt;'%'&lt;/code&gt; 문자 바로 뒤에 삽입 된 사전에 괄호로 묶인 매핑 키 &lt;em&gt;가&lt;/em&gt; 포함 &lt;em&gt;되어야합니다&lt;/em&gt; . 맵핑 키는 맵핑에서 형식화 할 값을 선택합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c542987ce2fae3c5dd363658acde3db213bccc7" translate="yes" xml:space="preserve">
          <source>When the timeout argument is present and not &lt;code&gt;None&lt;/code&gt;, it should be a floating point number specifying a timeout for the operation in seconds (or fractions thereof).</source>
          <target state="translated">제한 시간 인수가 존재하지만 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우, 조작에 대한 제한 시간을 초 (또는 소수)로 지정하는 부동 소수점 숫자 여야합니다.</target>
        </trans-unit>
        <trans-unit id="dcaffd14aa04c2c35de2956e1ed898667e511dfc" translate="yes" xml:space="preserve">
          <source>When the underlying lock is an &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt;, it is not released using its &lt;a href=&quot;#threading.Condition.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; method, since this may not actually unlock the lock when it was acquired multiple times recursively. Instead, an internal interface of the &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; class is used, which really unlocks it even when it has been recursively acquired several times. Another internal interface is then used to restore the recursion level when the lock is reacquired.</source>
          <target state="translated">기본 잠금이 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;a href=&quot;#threading.Condition.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 잠금을 해제하지 않습니다. 잠금이 여러 번 재귀 적으로 획득되었을 때 잠금을 실제로 잠금 해제하지 못할 수 있습니다. 대신 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 클래스 의 내부 인터페이스 가 사용되는데,이 인터페이스는 재귀 적으로 여러 번 획득 한 경우에도 실제로 잠금을 해제합니다. 그런 다음 다른 내부 인터페이스를 사용하여 잠금을 다시 획득 할 때 재귀 수준을 복원합니다.</target>
        </trans-unit>
        <trans-unit id="a547e1586802e299eb73e97be7ee39d485999089" translate="yes" xml:space="preserve">
          <source>When the view in the widget&amp;rsquo;s window change, the widget will generate a Tcl command based on the scrollcommand.</source>
          <target state="translated">위젯 창의보기가 변경되면 위젯은 scroll 명령을 기반으로 Tcl 명령을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="befa970eff3f7ebe6809143ffe66cd7843089ead" translate="yes" xml:space="preserve">
          <source>When there are two numbers in the first column (for example &lt;code&gt;3/1&lt;/code&gt;), it means that the function recursed. The second value is the number of primitive calls and the former is the total number of calls. Note that when the function does not recurse, these two values are the same, and only the single figure is printed.</source>
          <target state="translated">첫 번째 열에 두 개의 숫자 (예 : &lt;code&gt;3/1&lt;/code&gt; )가 있으면 함수가 반복되었음을 의미합니다. 두 번째 값은 기본 통화 수이고 전자는 총 통화 수입니다. 함수가 되풀이되지 않으면이 두 값은 동일하며 단일 숫자 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ab22dc5a231f8fc7cacd590361630a5e4a9cd4ba" translate="yes" xml:space="preserve">
          <source>When there are very small differences among your tests, for instance some parameters, unittest allows you to distinguish them inside the body of a test method using the &lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt;&lt;code&gt;subTest()&lt;/code&gt;&lt;/a&gt; context manager.</source>
          <target state="translated">테스트간에 약간의 차이가있을 경우 (예 : 일부 매개 변수), unittest를 사용하면 &lt;a href=&quot;#unittest.TestCase.subTest&quot;&gt; &lt;code&gt;subTest()&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 사용하여 테스트 메소드 본문 내에서이를 구별 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83c77d278084a249196dc8ad39e0428b94116b8a" translate="yes" xml:space="preserve">
          <source>When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. This is done after the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file is read, so that you can set this hook there. The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module &lt;a href=&quot;site#rlcompleter-config&quot;&gt;sets this&lt;/a&gt;.</source>
          <target state="translated">이 속성이 존재하면 인터프리터가 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화식 모드&lt;/a&gt; 에서 시작될 때 값이 인수없이 자동으로 호출 됩니다 . 이것은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-16&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt; 파일을 읽은 후에 수행 되므로이 후크를 설정할 수 있습니다. &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈 &lt;a href=&quot;site#rlcompleter-config&quot;&gt;이 설정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="176b8013f9b255204e913f81e2aad8839519f277" translate="yes" xml:space="preserve">
          <source>When this attribute exists, its value is automatically called (with no arguments) when the interpreter is launched in &lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. This is done after the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-17&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file is read, so that you can set this hook there. The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module &lt;a href=&quot;site#rlcompleter-config&quot;&gt;sets this&lt;/a&gt;.</source>
          <target state="translated">이 속성이 존재하면 인터프리터가 &lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;대화 형 모드&lt;/a&gt; 에서 시작될 때 해당 값이 인수없이 자동으로 호출 됩니다 . 이것은 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-17&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; &lt;/a&gt; 파일을 읽은 후에 수행 되므로 여기에서이 후크를 설정할 수 있습니다. &lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈 &lt;a href=&quot;site#rlcompleter-config&quot;&gt;이 설정됩니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5561b0bcfc3026fbfdb899d58edadb60d7787f" translate="yes" xml:space="preserve">
          <source>When this module is imported on a Unix platform with the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module available, an instance of the &lt;code&gt;Completer&lt;/code&gt; class is automatically created and its &lt;code&gt;complete()&lt;/code&gt; method is set as the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; completer.</source>
          <target state="translated">&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈을 사용할 수 있는 Unix 플랫폼에서이 모듈을 가져 오면 &lt;code&gt;Completer&lt;/code&gt; 클래스 의 인스턴스 가 자동으로 생성되고 &lt;code&gt;complete()&lt;/code&gt; 메서드가 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; completer 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="51abaa779be741115f9981dd161abaf14ca5f234" translate="yes" xml:space="preserve">
          <source>When this module is run as a script, the &lt;a href=&quot;#py_compile.main&quot;&gt;&lt;code&gt;main()&lt;/code&gt;&lt;/a&gt; is used to compile all the files named on the command line. The exit status is nonzero if one of the files could not be compiled.</source>
          <target state="translated">이 모듈이 스크립트로 실행될 때 &lt;a href=&quot;#py_compile.main&quot;&gt; &lt;code&gt;main()&lt;/code&gt; &lt;/a&gt; 은 명령 행에 이름이 지정된 모든 파일을 컴파일하는 데 사용됩니다. 파일 중 하나를 컴파일 할 수없는 경우 종료 상태는 0이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ad505c5cec1abb554c0e70fe34e8dfe5e8ee251d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a URL.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 URL입니다.</target>
        </trans-unit>
        <trans-unit id="c4271730cf91863d7eba060c9ce05e17fb1e5d3d" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is a fully-qualified domain name.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 정규화 된 도메인 이름입니다.</target>
        </trans-unit>
        <trans-unit id="df57f6bd5424a2b48ed53224b034c92f20111436" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an ISO OID.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 ISO OID입니다.</target>
        </trans-unit>
        <trans-unit id="b118949a5b99f77f5500b4d3f0d5939a3e84377f" translate="yes" xml:space="preserve">
          <source>When this namespace is specified, the &lt;em&gt;name&lt;/em&gt; string is an X.500 DN in DER or a text output format.</source>
          <target state="translated">이 네임 스페이스가 지정되면 &lt;em&gt;이름&lt;/em&gt; 문자열은 DER의 X.500 DN 또는 텍스트 출력 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1ac5dffa9ac6727f876535e5fe1228a53748f38d" translate="yes" xml:space="preserve">
          <source>When this variable is set to an integer value, it determines the maximum number of levels of traceback information printed when an unhandled exception occurs. The default is &lt;code&gt;1000&lt;/code&gt;. When set to &lt;code&gt;0&lt;/code&gt; or less, all traceback information is suppressed and only the exception type and value are printed.</source>
          <target state="translated">이 변수가 정수 값으로 설정되면 처리되지 않은 예외가 발생할 때 인쇄되는 최대 역 추적 정보 레벨 수를 판별합니다. 기본값은 &lt;code&gt;1000&lt;/code&gt; 입니다. &lt;code&gt;0&lt;/code&gt; 이하로 설정하면 모든 역 추적 정보가 억제되고 예외 유형 및 값만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="45ed44e1c2deee3726f1fb9e1612d293ad1c8ed8" translate="yes" xml:space="preserve">
          <source>When threads are enabled, this function can only be called from &lt;a href=&quot;#signals-and-threads&quot;&gt;the main thread of the main interpreter&lt;/a&gt;; attempting to call it from other threads will cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">스레드가 활성화되면이 함수는 &lt;a href=&quot;#signals-and-threads&quot;&gt;주 인터프리터의 주 스레드&lt;/a&gt; 에서만 호출 할 수 있습니다 . 다른 스레드에서 호출하려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="278cf1fb88404480dadf9b626eaab7ebb46fb611" translate="yes" xml:space="preserve">
          <source>When threads are enabled, this function can only be called from the main thread; attempting to call it from other threads will cause a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">스레드가 활성화되면이 기능은 기본 스레드에서만 호출 할 수 있습니다. 다른 스레드에서 호출하려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fa49c23d5b633ba09194c60a98a0663082ee806f" translate="yes" xml:space="preserve">
          <source>When to use __new__() vs. __init__()</source>
          <target state="translated">__new __ () 및 __init __ ()을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="ae8e822e628357a56fee4e1e237f47916afdb25d" translate="yes" xml:space="preserve">
          <source>When trying to answer questions of the form &amp;ldquo;how do I do blah&amp;rdquo;, it is often best to find out how to do &amp;ldquo;blah&amp;rdquo; in straight Tk, and then convert this back into the corresponding &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; call. Python programmers can often guess at the correct Python command by looking at the Tk documentation. This means that in order to use Tkinter, you will have to know a little bit about Tk. This document can&amp;rsquo;t fulfill that role, so the best we can do is point you to the best documentation that exists. Here are some hints:</source>
          <target state="translated">&amp;ldquo;어떻게해야합니까?&amp;rdquo;형식의 질문에 대답하려고 할 때, 직선 Tk에서&amp;ldquo;blah&amp;rdquo;를 수행하는 방법을 찾은 다음이를 해당 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 호출 로 다시 변환하는 것이 가장 좋습니다 . 파이썬 프로그래머는 종종 Tk 문서를보고 올바른 파이썬 명령을 추측 할 수 있습니다. 이것은 Tkinter를 사용하기 위해서는 Tk에 대해 약간 알아야한다는 것을 의미합니다. 이 문서는 그 역할을 수행 할 수 없으므로 최선을 다하는 것이 최선의 문서를 제시하는 것입니다. 힌트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="76b7fde33d91393f4e37520e38b01684ea8be333" translate="yes" xml:space="preserve">
          <source>When trying to resolve a path that may contain links, use &lt;a href=&quot;os.path#os.path.realpath&quot;&gt;&lt;code&gt;realpath()&lt;/code&gt;&lt;/a&gt; to properly handle recursion and platform differences.</source>
          <target state="translated">링크가 포함 된 경로를 해결하려고 할 때 &lt;a href=&quot;os.path#os.path.realpath&quot;&gt; &lt;code&gt;realpath()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 재귀 및 플랫폼 차이를 올바르게 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="2f3811d14f89d59ba51a06a1a040db1eba48fe96" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; (default to &lt;code&gt;'test'&lt;/code&gt;) for choosing which methods to wrap:</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt; 는 포장 할 메소드를 선택 하기 위해 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; (기본값은 &lt;code&gt;'test'&lt;/code&gt; )를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="705e7c80833fc33cb99db4df5a3694a333edc598" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 은 어떤 메소드를 포장할지 선택하는 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="5b03309707733138089592715f0e9b9ff4448b18" translate="yes" xml:space="preserve">
          <source>When used as a class decorator &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; honours &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; for choosing which methods to wrap.</source>
          <target state="translated">클래스 데코레이터로 사용될 때 &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt; 는 어떤 메소드를 포장할지 선택하는 &lt;code&gt;patch.TEST_PREFIX&lt;/code&gt; 를 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="fba105ce35abd2dc08e1a686f3ddd015c632904f" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용될 때 &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 는 추가 키워드 인수 &lt;em&gt;msg를&lt;/em&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="83414cd2e98b72f702142fb8a769008e29f7a984" translate="yes" xml:space="preserve">
          <source>When used as a context manager, &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt; accepts the additional keyword argument &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">컨텍스트 관리자로 사용될 때 &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt; 는 추가 키워드 인수 &lt;em&gt;msg를&lt;/em&gt; 허용합니다 .</target>
        </trans-unit>
        <trans-unit id="a119452aa32cdce61667b0d150a3806d0c9b047c" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the year are specified.</source>
          <target state="translated">&lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 함수 와 함께 사용하면 &lt;code&gt;%U&lt;/code&gt; 및 &lt;code&gt;%W&lt;/code&gt; 는 요일과 연도가 지정된 경우에만 계산에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c496b450e8c39131b7391ec30143aac02a4ea29" translate="yes" xml:space="preserve">
          <source>When used with the &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; function, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">함께 사용하면 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 함수는 &lt;code&gt;%p&lt;/code&gt; 경우 생성 지시문은 출력 시간 필드 영향 &lt;code&gt;%I&lt;/code&gt; 지정이 시간을 해석하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="53f6e3b18d54172809724ec98b1116def825fde0" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, &lt;code&gt;%U&lt;/code&gt; and &lt;code&gt;%W&lt;/code&gt; are only used in calculations when the day of the week and the calendar year (&lt;code&gt;%Y&lt;/code&gt;) are specified.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용하면 &lt;code&gt;%U&lt;/code&gt; 및 &lt;code&gt;%W&lt;/code&gt; 는 요일과 달력 연도 ( &lt;code&gt;%Y&lt;/code&gt; )가 지정된 경우에만 계산에 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4b2ee1207071c0489d96d299dd458032cc3f29e2" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%f&lt;/code&gt; directive accepts from one to six digits and zero pads on the right. &lt;code&gt;%f&lt;/code&gt; is an extension to the set of format characters in the C standard (but implemented separately in datetime objects, and therefore always available).</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용되는 경우, &lt;code&gt;%f&lt;/code&gt; 지시문은 오른쪽에 1-6 자리 숫자와 제로 패드를 허용합니다. &lt;code&gt;%f&lt;/code&gt; 는 C 표준의 형식 문자 세트에 대한 확장입니다 (하지만 datetime 오브젝트에 별도로 구현되므로 항상 사용 가능함).</target>
        </trans-unit>
        <trans-unit id="dc1c5087fa82a6d1840533fce5b820256e369ddd" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the &lt;code&gt;%p&lt;/code&gt; directive only affects the output hour field if the &lt;code&gt;%I&lt;/code&gt; directive is used to parse the hour.</source>
          <target state="translated">함께 사용하면 &lt;code&gt;strptime()&lt;/code&gt; 에있어서, 상기 &lt;code&gt;%p&lt;/code&gt; 경우 생성 지시문은 출력 시간 필드 영향 &lt;code&gt;%I&lt;/code&gt; 지정이 시간을 해석하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="8b8a227fcef52e704757038bfb5a5f8a8ba80e0a" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;strptime()&lt;/code&gt; method, the leading zero is optional for formats &lt;code&gt;%d&lt;/code&gt;, &lt;code&gt;%m&lt;/code&gt;, &lt;code&gt;%H&lt;/code&gt;, &lt;code&gt;%I&lt;/code&gt;, &lt;code&gt;%M&lt;/code&gt;, &lt;code&gt;%S&lt;/code&gt;, &lt;code&gt;%J&lt;/code&gt;, &lt;code&gt;%U&lt;/code&gt;, &lt;code&gt;%W&lt;/code&gt;, and &lt;code&gt;%V&lt;/code&gt;. Format &lt;code&gt;%y&lt;/code&gt; does require a leading zero.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드 와 함께 사용되는 경우 앞에 오는 0은 형식 &lt;code&gt;%d&lt;/code&gt; , &lt;code&gt;%m&lt;/code&gt; , &lt;code&gt;%H&lt;/code&gt; , &lt;code&gt;%I&lt;/code&gt; , &lt;code&gt;%M&lt;/code&gt; , &lt;code&gt;%S&lt;/code&gt; , &lt;code&gt;%J&lt;/code&gt; , &lt;code&gt;%U&lt;/code&gt; , &lt;code&gt;%W&lt;/code&gt; 및 &lt;code&gt;%V&lt;/code&gt; 입니다. &lt;code&gt;%y&lt;/code&gt; 형식 은 앞에 0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8993c4db89e355448ee2758089ff089b6167f894" translate="yes" xml:space="preserve">
          <source>When user code raises SystemExit either directly or by calling sys.exit, IDLE returns to a Shell prompt instead of exiting.</source>
          <target state="translated">사용자 코드가 직접 또는 sys.exit를 호출하여 SystemExit를 발생 시키면 IDLE은 종료하지 않고 쉘 프롬프트로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e8d99d6e745dcc773c5780813fa3d777f5ab117b" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#cmdoption-trace-r&quot;&gt;&lt;code&gt;--report&lt;/code&gt;&lt;/a&gt;, write a brief summary to stdout for each file processed.</source>
          <target state="translated">&lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#cmdoption-trace-r&quot;&gt; &lt;code&gt;--report&lt;/code&gt; 를&lt;/a&gt; 사용할 때는 처리 된 각 파일에 대해 간단한 요약을 stdout에 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="d69285961c4bd67c93bcd61d97d840352615a6b6" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt;, this method chops &lt;em&gt;iterables&lt;/em&gt; into a number of chunks which it submits to the pool as separate tasks. The (approximate) size of these chunks can be specified by setting &lt;em&gt;chunksize&lt;/em&gt; to a positive integer. For very long iterables, using a large value for &lt;em&gt;chunksize&lt;/em&gt; can significantly improve performance compared to the default size of 1. With &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;chunksize&lt;/em&gt; has no effect.</source>
          <target state="translated">사용시 &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 를&lt;/a&gt; ,이 방법은 자르면 &lt;em&gt;반복 가능 객체를&lt;/em&gt; 이 분리 작업시에 풀에 제출 청크들로. 이 청크의 대략적인 크기는 &lt;em&gt;chunksize&lt;/em&gt; 를 양의 정수 로 설정하여 지정할 수 있습니다 . 에 대한 큰 값을 사용하여 매우 긴 반복 가능 객체의 경우, &lt;em&gt;chunksize 영역은&lt;/em&gt; 크게 1.의 기본 크기에 비해 성능을 향상시킬 수 &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; , &lt;em&gt;chunksize 영역은&lt;/em&gt; 아무런 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="67dbf8b14ab5b34c346cf0ec2ca601d364ad77a4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;shell=True&lt;/code&gt;, the &lt;a href=&quot;shlex#shlex.quote&quot;&gt;&lt;code&gt;shlex.quote()&lt;/code&gt;&lt;/a&gt; function can be used to properly escape whitespace and shell metacharacters in strings that are going to be used to construct shell commands.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;shell=True&lt;/code&gt; 의 &lt;a href=&quot;shlex#shlex.quote&quot;&gt; &lt;code&gt;shlex.quote()&lt;/code&gt; &lt;/a&gt; 기능이 제대로 구조 쉘 명령에 사용하려고하는 문자열의 공백과 쉘 메타 문자를 탈출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8018ded6871ec6f5c2db4b1df5eb57ea72056b" translate="yes" xml:space="preserve">
          <source>When using IDLE, tooltips show the signatures and first lines of the docstrings of typed in function-/method calls.</source>
          <target state="translated">IDLE을 사용할 때 툴팁은 함수 / 메소드 호출에 입력 된 문서 문자열의 서명과 첫 줄을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="6a5ee388e1f0b24ab337fb675482fe01a76a1b13" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;SharedMemoryManager&lt;/code&gt; in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the shared memory blocks created using that manager are all released when the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s code block finishes execution.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 을 A의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문, 공유 메모리 블록이 모두 출시되는 관리자를 사용하여 만들 때 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 코드 블록이 완료 실행.</target>
        </trans-unit>
        <trans-unit id="f1f4fd3135a6c1c4c361b9300a12a8082ea070bb" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;SharedMemoryManager&lt;/code&gt; in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, the shared memory blocks created using that manager are all released when the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement&amp;rsquo;s code block finishes execution.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;SharedMemoryManager&lt;/code&gt; 을 A의 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문, 공유 메모리 블록이 모두 출시되는 관리자를 사용하여 만들 때 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 코드 블록이 완료 실행.</target>
        </trans-unit>
        <trans-unit id="cff5871a771c52192ce76b27da8593fb1ba702e3" translate="yes" xml:space="preserve">
          <source>When using any of the policy objects derived from &lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicy&lt;/code&gt;&lt;/a&gt;, all headers are produced by &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt; and have &lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt;&lt;code&gt;BaseHeader&lt;/code&gt;&lt;/a&gt; as their last base class. Each header class has an additional base class that is determined by the type of the header. For example, many headers have the class &lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt;&lt;code&gt;UnstructuredHeader&lt;/code&gt;&lt;/a&gt; as their other base class. The specialized second class for a header is determined by the name of the header, using a lookup table stored in the &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;. All of this is managed transparently for the typical application program, but interfaces are provided for modifying the default behavior for use by more complex applications.</source>
          <target state="translated">&lt;a href=&quot;email.policy#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicy&lt;/code&gt; &lt;/a&gt; 에서 파생 된 정책 객체를 사용하는 경우 모든 헤더는 &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; 에&lt;/a&gt; 의해 생성되며 마지막 기본 클래스로 &lt;a href=&quot;#email.headerregistry.BaseHeader&quot;&gt; &lt;code&gt;BaseHeader&lt;/code&gt; &lt;/a&gt; 를 갖 습니다 . 각 헤더 클래스에는 헤더 유형에 따라 결정되는 추가 기본 클래스가 있습니다. 예를 들어 많은 헤더에는 다른 기본 클래스로 &lt;a href=&quot;#email.headerregistry.UnstructuredHeader&quot;&gt; &lt;code&gt;UnstructuredHeader&lt;/code&gt; &lt;/a&gt; 클래스가 있습니다. 헤더의 특수한 두 번째 클래스는 &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; 에&lt;/a&gt; 저장된 조회 테이블을 사용하여 헤더 이름으로 결정됩니다 . 이 모든 것은 일반적인 응용 프로그램에 대해 투명하게 관리되지만보다 복잡한 응용 프로그램에서 사용할 수 있도록 기본 동작을 수정하기위한 인터페이스가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b05e16fdd139b928e5d9f97d7e26405bb10ad23a" translate="yes" xml:space="preserve">
          <source>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects. This method is maintained for backward compatibility and should be avoided in new code. The buffer interface is documented in &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;.</source>
          <target state="translated">C 또는 C ++로 작성된 코드에서 배열 오브젝트를 사용할 때 (이 정보를 효과적으로 사용하는 유일한 방법) 배열 오브젝트가 지원하는 버퍼 인터페이스를 사용하는 것이 더 합리적입니다. 이 방법은 이전 버전과의 호환성을 위해 유지되므로 새 코드에서는 사용하지 않아야합니다. 버퍼 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c71a3439a3427537cb3ed1f93938eddd01e21c" translate="yes" xml:space="preserve">
          <source>When using array objects from code written in C or C++ (the only way to effectively make use of this information), it makes more sense to use the buffer interface supported by array objects. This method is maintained for backward compatibility and should be avoided in new code. The buffer interface is documented in &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;.</source>
          <target state="translated">C 또는 C ++로 작성된 코드에서 배열 객체를 사용할 때 (이 정보를 효과적으로 사용하는 유일한 방법) 배열 객체가 지원하는 버퍼 인터페이스를 사용하는 것이 더 합리적입니다. 이 메서드는 이전 버전과의 호환성을 위해 유지되며 새 코드에서는 사용하지 않아야합니다. 버퍼 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6b80cace7f20688ab820fe8baf0df818b93de50" translate="yes" xml:space="preserve">
          <source>When using multiple processes, one generally uses message passing for communication between processes and avoids having to use any synchronization primitives like locks.</source>
          <target state="translated">다중 프로세스를 사용할 때 일반적으로 프로세스 간 통신을 위해 메시지 전달을 사용하고 잠금과 같은 동기화 기본 요소를 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd6a46b825093b75110261b57205d3c8b35775e" translate="yes" xml:space="preserve">
          <source>When using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods many types from &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; need to be picklable so that child processes can use them. However, one should generally avoid sending shared objects to other processes using pipes or queues. Instead you should arrange the program so that a process which needs access to a shared resource created elsewhere can inherit it from an ancestor process.</source>
          <target state="translated">사용하는 경우 &lt;em&gt;산란을&lt;/em&gt; 하거나 &lt;em&gt;forkserver&lt;/em&gt; 에서 방법에게 많은 유형을 시작 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 이 자식 프로세스를 사용할 수 있도록 요구하는 것은 picklable 수 있습니다. 그러나 일반적으로 파이프 나 큐를 사용하여 공유 객체를 다른 프로세스로 보내지 않아야합니다. 대신 다른 곳에서 작성된 공유 자원에 액세스해야하는 프로세스가 상위 프로세스에서이를 상속 할 수 있도록 프로그램을 배열해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0f3d8f9182ed3d95d5c0426514f0709e918d398" translate="yes" xml:space="preserve">
          <source>When using this pattern, remember that all classes that inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; are run as tests. The &lt;code&gt;Mixin&lt;/code&gt; class in the example above does not have any data and so can&amp;rsquo;t be run by itself, thus it does not inherit from &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패턴을 사용할 때 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 에서 상속 된 모든 클래스는 테스트로 실행됩니다. 위 예제 의 &lt;code&gt;Mixin&lt;/code&gt; 클래스에는 데이터가 없으므로 자체적으로 실행할 수 없으므로 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; &lt;/a&gt; 에서 상속되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3bc63598e62f8448d98f0887d22314a85ab47257" translate="yes" xml:space="preserve">
          <source>When using weekday-based rotation, specify &amp;lsquo;W0&amp;rsquo; for Monday, &amp;lsquo;W1&amp;rsquo; for Tuesday, and so on up to &amp;lsquo;W6&amp;rsquo; for Sunday. In this case, the value passed for &lt;em&gt;interval&lt;/em&gt; isn&amp;rsquo;t used.</source>
          <target state="translated">주중 회전을 사용할 때는 월요일에 'W0', 화요일에 'W1'등을 일요일에 'W6'까지 지정하십시오. 이 경우 &lt;em&gt;interval에&lt;/em&gt; 전달 된 값 은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6aea84bd51b5a34854466c47a84c480e9d183e1" translate="yes" xml:space="preserve">
          <source>When working in a command shell, users can make a virtual environment active by running an &lt;code&gt;activate&lt;/code&gt; script in the virtual environment&amp;rsquo;s executables directory (the precise filename and command to use the file is shell-dependent), which prepends the virtual environment&amp;rsquo;s directory for executables to the &lt;code&gt;PATH&lt;/code&gt; environment variable for the running shell. There should be no need in other circumstances to activate a virtual environment; scripts installed into virtual environments have a &amp;ldquo;shebang&amp;rdquo; line which points to the virtual environment&amp;rsquo;s Python interpreter. This means that the script will run with that interpreter regardless of the value of &lt;code&gt;PATH&lt;/code&gt;. On Windows, &amp;ldquo;shebang&amp;rdquo; line processing is supported if you have the Python Launcher for Windows installed (this was added to Python in 3.3 - see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt; for more details). Thus, double-clicking an installed script in a Windows Explorer window should run the script with the correct interpreter without there needing to be any reference to its virtual environment in &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">명령 셸에서 작업 할 때 사용자는 가상 환경의 실행 파일 디렉토리 (파일을 사용하는 정확한 파일 이름 및 명령이 셸에 따라 다름)에서 &lt;code&gt;activate&lt;/code&gt; 스크립트를 실행하여 가상 환경을 활성화 할 수 있습니다. 실행중인 쉘 의 &lt;code&gt;PATH&lt;/code&gt; 환경 변수 다른 환경에서는 가상 환경을 활성화 할 필요가 없습니다. 가상 환경에 설치된 스크립트에는 가상 환경의 Python 인터프리터를 가리키는 &quot;shebang&quot;줄이 있습니다. 이는 스크립트가 &lt;code&gt;PATH&lt;/code&gt; 값에 관계없이 해당 인터프리터와 함께 실행됨을 의미합니다. Windows에서는 Windows 용 Python Launcher를 설치 한 경우 &quot;shebang&quot;라인 처리가 지원됩니다 (3.3에서 Python에 추가됨- 자세한 내용 은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0397&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 397&lt;/strong&gt;&lt;/a&gt; 참조). 따라서 Windows 탐색기 창에서 설치된 스크립트를 두 번 클릭하면 &lt;code&gt;PATH&lt;/code&gt; 의 가상 환경에 대한 참조가 없어도 올바른 인터프리터로 스크립트를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8a8029dbde9896495f35f3b5cc6049139cf4061" translate="yes" xml:space="preserve">
          <source>When writing a docstring, choose docstring examples with care. There&amp;rsquo;s an art to this that needs to be learned&amp;mdash;it may not be natural at first. Examples should add genuine value to the documentation. A good example can often be worth many words. If done with care, the examples will be invaluable for your users, and will pay back the time it takes to collect them many times over as the years go by and things change. I&amp;rsquo;m still amazed at how often one of my &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; examples stops working after a &amp;ldquo;harmless&amp;rdquo; change.</source>
          <target state="translated">docstring을 작성할 때 docstring 예제를 신중하게 선택하십시오. 여기에는 배워야 할 예술이 있습니다. 처음에는 자연스럽지 않을 수도 있습니다. 예제는 문서에 진정한 가치를 부여해야합니다. 좋은 예는 종종 많은 단어의 가치가 있습니다. 주의를 기울이면 예제는 사용자에게 귀중한 것이며 시간이 지남에 따라 여러 번 수집하는 데 걸리는 시간을 상환 할 것입니다. 나는 여전히 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 예제 중 하나가 &quot;무해한&quot;변경 후에 작동을 멈추는 빈도에 놀랐습니다 .</target>
        </trans-unit>
        <trans-unit id="8592ae082c5c9b46046c7a2f018c32ed0f608909" translate="yes" xml:space="preserve">
          <source>When writing a file, if the file size is not known in advance but may exceed 2 GiB, pass &lt;code&gt;force_zip64=True&lt;/code&gt; to ensure that the header format is capable of supporting large files. If the file size is known in advance, construct a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object with &lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt;&lt;code&gt;file_size&lt;/code&gt;&lt;/a&gt; set, and use that as the &lt;em&gt;name&lt;/em&gt; parameter.</source>
          <target state="translated">파일을 쓸 때 파일 크기를 미리 알 수 없지만 &lt;code&gt;force_zip64=True&lt;/code&gt; 초과 할 수있는 경우 force_zip64 = True 를 전달 하여 헤더 형식이 큰 파일을 지원할 수 있는지 확인하십시오. 파일 크기가 미리 알려진 경우 &lt;a href=&quot;#zipfile.ZipInfo.file_size&quot;&gt; &lt;code&gt;file_size&lt;/code&gt; 가&lt;/a&gt; 설정된 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 객체를 구성하고 이를&lt;em&gt; 이름&lt;/em&gt; 매개 변수로 사용하십시오.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2eabb64e4773edb5fffc016299f8bed93923cd8c" translate="yes" xml:space="preserve">
          <source>When writing output to the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the system default line separator, &lt;a href=&quot;os#os.linesep&quot;&gt;&lt;code&gt;os.linesep&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;''&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt;, no translation takes place. If &lt;em&gt;newline&lt;/em&gt; is any of the other legal values, any &lt;code&gt;'\n'&lt;/code&gt; characters written are translated to the given string.</source>
          <target state="translated">출력을 스트림에 쓸 때 &lt;em&gt;줄 바꿈&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이면 기록 된 &lt;code&gt;'\n'&lt;/code&gt; 문자는 시스템 기본 줄 구분자 &lt;a href=&quot;os#os.linesep&quot;&gt; &lt;code&gt;os.linesep&lt;/code&gt; 로 변환&lt;/a&gt; 됩니다. 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 있다 &lt;code&gt;''&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; , 어떤 번역은 일어나지 않는다. 경우 &lt;em&gt;줄 바꿈이&lt;/em&gt; 다른 법적 값 중 하나입니다, 어떤 &lt;code&gt;'\n'&lt;/code&gt; 쓴 문자는 주어진 문자열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="067f2ecb8b6372c1f3e42f05250baae071a8c1df" translate="yes" xml:space="preserve">
          <source>When writing to the path fails because the path is read-only (&lt;a href=&quot;errno#errno.EACCES&quot;&gt;&lt;code&gt;errno.EACCES&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt;), do not propagate the exception.</source>
          <target state="translated">경로가 읽기 전용 ( &lt;a href=&quot;errno#errno.EACCES&quot;&gt; &lt;code&gt;errno.EACCES&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt; ) 이므로 경로 에 쓰지 못하는 경우 예외를 전파하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="248ff5afb565bdd43eb7abc7973b09733b696289" translate="yes" xml:space="preserve">
          <source>When writing to this object, data is normally placed into an internal buffer. The buffer will be written out to the underlying &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; object under various conditions, including:</source>
          <target state="translated">이 개체에 쓸 때 데이터는 일반적으로 내부 버퍼에 배치됩니다. 버퍼는 다음 과 같은 다양한 조건 에서 기본 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 개체에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="0aec152755409343dddc07ce07a2031e69c7060e" translate="yes" xml:space="preserve">
          <source>When you are finished with a DOM tree, you may optionally call the &lt;code&gt;unlink()&lt;/code&gt; method to encourage early cleanup of the now-unneeded objects. &lt;code&gt;unlink()&lt;/code&gt; is an &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;-specific extension to the DOM API that renders the node and its descendants are essentially useless. Otherwise, Python&amp;rsquo;s garbage collector will eventually take care of the objects in the tree.</source>
          <target state="translated">DOM 트리가 끝나면 필요에 따라 &lt;code&gt;unlink()&lt;/code&gt; 메소드를 호출하여 필요없는 객체를 조기에 정리할 수 있습니다. &lt;code&gt;unlink()&lt;/code&gt; 는 노드를 렌더링하는 DOM API에 대한 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 특정 확장이며 그 하위 항목은 본질적으로 쓸모가 없습니다. 그렇지 않으면 파이썬의 가비지 수집기는 결국 트리의 객체를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d8b4b9124db1d9506c6395b32b710d76c6d1388e" translate="yes" xml:space="preserve">
          <source>When you attach a mock as an attribute of another mock (or as the return value) it becomes a &amp;ldquo;child&amp;rdquo; of that mock. Calls to the child are recorded in the &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; attributes of the parent. This is useful for configuring child mocks and then attaching them to the parent, or for attaching mocks to a parent that records all calls to the children and allows you to make assertions about the order of calls between mocks:</source>
          <target state="translated">모의 객체를 다른 모의 속성 (또는 반환 값)으로 첨부하면 해당 모의 &quot;자식&quot;이됩니다. 자식에 대한 호출 은 부모 의 &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 속성에 기록됩니다 . 이는 자식 모의를 구성한 다음 부모에 연결하거나 자식에 대한 모든 호출을 기록하고 모의 호출 순서에 대한 어설 션을 만들 수있는 모의 부모에 연결하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="be1b470500af8dd6da06d2ce49d4cefe28a83a6b" translate="yes" xml:space="preserve">
          <source>When you compile a node tree with &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, the compiler expects &lt;code&gt;lineno&lt;/code&gt; and &lt;code&gt;col_offset&lt;/code&gt; attributes for every node that supports them. This is rather tedious to fill in for generated nodes, so this helper adds these attributes recursively where not already set, by setting them to the values of the parent node. It works recursively starting at &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 으로 노드 트리를 컴파일 할 때 컴파일러는 이를 지원하는 모든 노드에 대해 &lt;code&gt;lineno&lt;/code&gt; 및 &lt;code&gt;col_offset&lt;/code&gt; 속성을 예상 합니다. 이는 생성 된 노드를 채우는 데 다소 지루하므로,이 헬퍼는 이러한 속성을 아직 설정되지 않은 위치에 부모 노드의 값으로 설정하여 재귀 적으로 추가합니다. &lt;em&gt;node&lt;/em&gt; 에서 재귀 적으로 시작 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="8168a6e30b1a0dd14b3d6bed0aa248b7873034b1" translate="yes" xml:space="preserve">
          <source>When you have a consistent answer, there are three ways you can use it:</source>
          <target state="translated">일관된 답변이 있으면 세 가지 방법으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="980c6f4da1cfe70fd805b5d970a5223e7e867fdd" translate="yes" xml:space="preserve">
          <source>When you have finished providing data to the compressor, call the &lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; method to finish the compression process.</source>
          <target state="translated">압축기에 데이터를 제공 한 후 &lt;a href=&quot;#bz2.BZ2Compressor.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 하여 압축 프로세스를 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="ebaa64dbb3e64356296053a73cf19b2addb5348d" translate="yes" xml:space="preserve">
          <source>When you have placed your tests in a module, the module can itself be the test runner. When a test fails, you can arrange for your test runner to re-run only the failing doctest while you debug the problem. Here is a minimal example of such a test runner:</source>
          <target state="translated">테스트를 모듈에 배치하면 모듈 자체가 테스트 실행자가 될 수 있습니다. 테스트가 실패하면 문제를 디버그하는 동안 테스트 실행기가 실패한 doctest 만 다시 실행하도록 할 수 있습니다. 다음은 이러한 테스트 러너의 최소 예입니다.</target>
        </trans-unit>
        <trans-unit id="f6bcd3b04b0d7cac7cf2e9d8396970c1121f17d6" translate="yes" xml:space="preserve">
          <source>When you nest patch decorators the mocks are passed in to the decorated function in the same order they applied (the normal &lt;em&gt;Python&lt;/em&gt; order that decorators are applied). This means from the bottom up, so in the example above the mock for &lt;code&gt;module.ClassName1&lt;/code&gt; is passed in first.</source>
          <target state="translated">패치 데코레이터를 중첩하면 모의 객체는 적용한 순서 ( 데코레이터가 적용되는 일반적인 &lt;em&gt;Python&lt;/em&gt; 순서)로 꾸며진 함수에 전달됩니다 . 이것은 위에서 아래를 의미하므로 위의 예에서 &lt;code&gt;module.ClassName1&lt;/code&gt; 에 대한 모의 가 먼저 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0ae07c9462ed9e0e688008d531cdc33cae796d" translate="yes" xml:space="preserve">
          <source>When you use the context to connect to a server, &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; validate the server certificate: it ensures that the server certificate was signed with one of the CA certificates, checks the signature for correctness, and verifies other properties like validity and identity of the hostname:</source>
          <target state="translated">컨텍스트를 사용하여 서버에 연결하는 경우 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 은 서버 인증서의 유효성을 검증합니다. 서버 인증서가 CA 인증서 중 하나로 서명되었는지 확인하고, 서명이 올바른지 확인하고, 유효성 및 ID와 같은 다른 특성을 검증합니다. 호스트 이름 :</target>
        </trans-unit>
        <trans-unit id="693ee6b490569d4d5711a3b5add559ce77978de6" translate="yes" xml:space="preserve">
          <source>When you write a new script, consider adding these lines:</source>
          <target state="translated">새 스크립트를 작성할 때 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="205afaa9a1fee6195f966485ecd67e9562f2bb6a" translate="yes" xml:space="preserve">
          <source>Whenever &lt;em&gt;x&lt;/em&gt; or &lt;em&gt;y&lt;/em&gt; arguments to a function or a method are optional, they default to the current cursor location. Whenever &lt;em&gt;attr&lt;/em&gt; is optional, it defaults to &lt;code&gt;A_NORMAL&lt;/code&gt;.</source>
          <target state="translated">때마다 &lt;em&gt;X&lt;/em&gt; 또는 &lt;em&gt;Y&lt;/em&gt; 함수 나 방법에 대한 인수는 선택, 그들은 현재의 커서 위치에 기본. &lt;em&gt;attr&lt;/em&gt; 이 선택적 일 때마다 기본값은 &lt;code&gt;A_NORMAL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8765d4b8962f94d6b6eef545316618c01d52eff3" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character string&lt;/em&gt; it can be specified as a Unicode string or a byte string.</source>
          <target state="translated">설명서에서 &lt;em&gt;문자열을&lt;/em&gt; 언급 할 때마다 유니 코드 문자열 또는 바이트 문자열로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="999400ad526ca682840c4c4ec0cf126c5252625e" translate="yes" xml:space="preserve">
          <source>Whenever the documentation mentions a &lt;em&gt;character&lt;/em&gt; it can be specified as an integer, a one-character Unicode string or a one-byte byte string.</source>
          <target state="translated">설명서에서 &lt;em&gt;문자를&lt;/em&gt; 언급 할 때마다 정수, 1 문자 유니 코드 문자열 또는 1 바이트 바이트 문자열로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6bfb2c4bd7e77dce0abe22138a5a1dba3fd4d8e" translate="yes" xml:space="preserve">
          <source>Where T is the total number of elements in both sequences, and M is the number of matches, this is 2.0*M / T. Note that this is &lt;code&gt;1.0&lt;/code&gt; if the sequences are identical, and &lt;code&gt;0.0&lt;/code&gt; if they have nothing in common.</source>
          <target state="translated">여기서 T는 두 시퀀스의 총 요소 수이고 M은 일치 수입니다. 이는 2.0 * M / T입니다 . 시퀀스가 ​​동일하면 &lt;code&gt;1.0&lt;/code&gt; , 공통점이없는 경우 &lt;code&gt;0.0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b0698d3446ab96f16d8d0f4a7d46e511ffaa1b1a" translate="yes" xml:space="preserve">
          <source>Where the components are:</source>
          <target state="translated">구성 요소가있는 위치 :</target>
        </trans-unit>
        <trans-unit id="9043b61aa57de9fe6a9cd0fbf895ea057d46ea33" translate="yes" xml:space="preserve">
          <source>Where the following options are understood:</source>
          <target state="translated">다음 옵션이 이해되는 경우 :</target>
        </trans-unit>
        <trans-unit id="f5a5f04e05ccffc4c2734a94e36079f88e06a02b" translate="yes" xml:space="preserve">
          <source>Where there is no registered implementation for a specific type, its method resolution order is used to find a more generic implementation. The original function decorated with &lt;code&gt;@singledispatch&lt;/code&gt; is registered for the base &lt;code&gt;object&lt;/code&gt; type, which means it is used if no better implementation is found.</source>
          <target state="translated">특정 유형에 대해 등록 된 구현이없는 경우 메소드 해결 순서는보다 일반적인 구현을 찾는 데 사용됩니다. &lt;code&gt;@singledispatch&lt;/code&gt; 로 장식 된 원래 함수 는 기본 &lt;code&gt;object&lt;/code&gt; 유형에 등록되어 있으므로 더 나은 구현이 없으면 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53573fb4e5abc3ff45094b0052fde922a5a87848" translate="yes" xml:space="preserve">
          <source>Where to patch</source>
          <target state="translated">패치 할 곳</target>
        </trans-unit>
        <trans-unit id="c18e7a9c733c88bde9faa67d79db05fefdfd3ec9" translate="yes" xml:space="preserve">
          <source>Wherever the former background character appears, it is changed to the new background character.</source>
          <target state="translated">이전 배경 문자가 나타날 때마다 새 배경 문자로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0a042ada48fa9e3c00cffdff61a30274621080e2" translate="yes" xml:space="preserve">
          <source>Whether &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; falls back to verify the cert&amp;rsquo;s subject common name in the absence of a subject alternative name extension (default: true).</source>
          <target state="translated">주제 대체 이름 확장자가없는 경우 인증서의 주제 공통 이름을 확인하기 위해 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 이 폴백 되는지 여부 (기본값 : true)</target>
        </trans-unit>
        <trans-unit id="8cd43d90a2c53503d089732d23dcac513590b751" translate="yes" xml:space="preserve">
          <source>Whether &lt;em&gt;K&lt;/em&gt; is a member of the set of keys of a &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">여부 &lt;em&gt;K는&lt;/em&gt; (A)의 키 세트의 구성원 인 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4d302d51b9f99d9aa32a01277d93fb96ac09ca34" translate="yes" xml:space="preserve">
          <source>Whether a frame is considered to originate in a certain module is determined by the &lt;code&gt;__name__&lt;/code&gt; in the frame globals.</source>
          <target state="translated">프레임이 특정 모듈에서 시작된 것으로 간주되는지 여부는 프레임 전역 의 &lt;code&gt;__name__&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a943fe736644b8b8c93795478580ff25f5fcf6e7" translate="yes" xml:space="preserve">
          <source>Whether line buffering is enabled.</source>
          <target state="translated">라인 버퍼링 활성화 여부.</target>
        </trans-unit>
        <trans-unit id="0c5318374911071b186050497110ee2859024b25" translate="yes" xml:space="preserve">
          <source>Whether or not overlap regions for self-intersecting polygons or multiple shapes are filled depends on the operating system graphics, type of overlap, and number of overlaps. For example, the Turtle star above may be either all yellow or have some white regions.</source>
          <target state="translated">자체 교차하는 다각형의 중첩 영역 또는 여러 모양이 채워지는지 여부는 운영 체제 그래픽, 중첩 유형 및 중첩 수에 따라 다릅니다. 예를 들어, 위의 거북이 별은 모두 노란색이거나 일부 흰색 영역이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04435c32a748b091872ac0d2173dbfad57d8cf08" translate="yes" xml:space="preserve">
          <source>Whether or not two values are considered close is determined according to given absolute and relative tolerances.</source>
          <target state="translated">두 값이 근접한 것으로 간주되는지의 여부는 주어진 절대 및 상대 공차에 따라 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="704f9ab62db9376e10128b17cb17cbd1569fe1d7" translate="yes" xml:space="preserve">
          <source>Whether output is buffered is usually determined by &lt;em&gt;file&lt;/em&gt;, but if the &lt;em&gt;flush&lt;/em&gt; keyword argument is true, the stream is forcibly flushed.</source>
          <target state="translated">출력이 버퍼링되는지 여부는 일반적으로 &lt;em&gt;file&lt;/em&gt; 에 의해 결정 되지만 &lt;em&gt;flush&lt;/em&gt; 키워드 인수가 true이면 스트림이 강제로 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="e9704f5d09c8a18f1f4b364c56355a76782182d8" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Application-Layer Protocol Negotiation&lt;/em&gt; TLS extension as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">에는 OpenSSL 라이브러리가 내장되어 있는지의 여부에 대한 지원 &lt;em&gt;응용 프로그램 계층 프로토콜 협상&lt;/em&gt; TLS 확장에 설명 된대로 &lt;a href=&quot;https://tools.ietf.org/html/rfc7301.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 7301&lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f75f6bb7fcb11e2f45c69c0a7ca4c4682d4f5923" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Next Protocol Negotiation&lt;/em&gt; as described in the &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;Application Layer Protocol Negotiation&lt;/a&gt;. When true, you can use the &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt;&lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt;&lt;/a&gt; method to advertise which protocols you want to support.</source>
          <target state="translated">에는 OpenSSL 라이브러리가 내장되어 있는지의 여부에 대한 지원 &lt;em&gt;다음 프로토콜 협상&lt;/em&gt; 에서 설명한대로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation&quot;&gt;응용 계층 프로토콜 협상&lt;/a&gt; . true 인 경우 &lt;a href=&quot;#ssl.SSLContext.set_npn_protocols&quot;&gt; &lt;code&gt;SSLContext.set_npn_protocols()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 지원하려는 프로토콜을 알릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a2de0f65d5d2e9aa283fe9814ef530df9f4d7f4" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the &lt;em&gt;Server Name Indication&lt;/em&gt; extension (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">OpenSSL 라이브러리에 &lt;em&gt;서버 이름 표시&lt;/em&gt; 확장 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6066.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 6066에&lt;/strong&gt;&lt;/a&gt; 정의 된 &lt;strong&gt;대로&lt;/strong&gt; ) 이 기본적으로 지원되는지 여부</target>
        </trans-unit>
        <trans-unit id="f10549c2669f338103d9d69275acd6ff0bb42f85" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the Elliptic Curve-based Diffie-Hellman key exchange. This should be true unless the feature was explicitly disabled by the distributor.</source>
          <target state="translated">OpenSSL 라이브러리가 Elliptic Curve 기반 Diffie-Hellman 키 교환을 기본적으로 지원하는지 여부 이 기능은 배포자가 명시 적으로 비활성화하지 않은 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="189c811d0c4a89efbb0bd31d293ff4f4943d0dbe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 2.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 SSL 2.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="cc2afc4d9cd37973dffe79768c99919a50576238" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the SSL 3.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 SSL 3.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="89e2466bdf6938ea2d60c44e09f1c3edaea29f39" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.0 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.0 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="adb5564adfd4cdc59e03f6665550cc56692d4f99" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.1 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.1 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="cca6b49130e274478019943c2fbeb20a7cbc1d17" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.2 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.2 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="e350ddccc623cf6675373d55c31c906ec7237c92" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support for the TLS 1.3 protocol.</source>
          <target state="translated">OpenSSL 라이브러리가 TLS 1.3 프로토콜을 기본적으로 지원하는지 여부</target>
        </trans-unit>
        <trans-unit id="fb7e4191f43e54b167216c9758819c2068bd3dfe" translate="yes" xml:space="preserve">
          <source>Whether the OpenSSL library has built-in support not checking subject common name and &lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt;&lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt;&lt;/a&gt; is writeable.</source>
          <target state="translated">에는 OpenSSL 라이브러리 지원 확인하지 주제 공통 이름 내장 여부 &lt;a href=&quot;#ssl.SSLContext.hostname_checks_common_name&quot;&gt; &lt;code&gt;SSLContext.hostname_checks_common_name&lt;/code&gt; 은&lt;/a&gt; 쓰기 가능합니다.</target>
        </trans-unit>
        <trans-unit id="88f23b4bf4e20fc7a9bdac4783297fabf3f1c246" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol is separated from the value by a space (for positive resp. negative values).</source>
          <target state="translated">통화 기호가 공백으로 값과 구분되는지 여부 (양의 음수 값).</target>
        </trans-unit>
        <trans-unit id="7bb65cdf22c5687fc74b96fb5b3b8c68399e1532" translate="yes" xml:space="preserve">
          <source>Whether the currency symbol precedes the value (for positive resp. negative values).</source>
          <target state="translated">통화 기호가 값보다 우선하는지 여부 (양의 음수 값).</target>
        </trans-unit>
        <trans-unit id="b6318ba22ae30ad3468f9876a3fd1a5745b34ced" translate="yes" xml:space="preserve">
          <source>Whether the data is buffered, chunked or reassembled depends on the transport. In general, you shouldn&amp;rsquo;t rely on specific semantics and instead make your parsing generic and flexible. However, data is always received in the correct order.</source>
          <target state="translated">데이터의 버퍼링, 청크 분할 또는 재 조립 여부는 전송에 따라 다릅니다. 일반적으로 특정 의미에 의존하지 말고 구문 분석을 일반적이고 유연하게 만드십시오. 그러나 데이터는 항상 올바른 순서로 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="728787761dd4dda0e68398ac7fa7afe469103a47" translate="yes" xml:space="preserve">
          <source>Whether the path points to an existing file or directory:</source>
          <target state="translated">경로가 기존 파일 또는 디렉토리를 가리키는 지 여부 :</target>
        </trans-unit>
        <trans-unit id="7c0b74000f7c6661d85ff5da8e8055be52233230" translate="yes" xml:space="preserve">
          <source>Whether the server will allow the reuse of an address. This defaults to &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, and can be set in subclasses to change the policy.</source>
          <target state="translated">서버가 주소를 재사용 할 수 있는지 여부 기본값은 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 이며 정책을 변경하기 위해 서브 클래스에서 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4273367589a735b6de5ee51a98d1f45ef36ee8a3" translate="yes" xml:space="preserve">
          <source>Whether to match the peer cert&amp;rsquo;s hostname with &lt;a href=&quot;#ssl.match_hostname&quot;&gt;&lt;code&gt;match_hostname()&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt;. The context&amp;rsquo;s &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; must be set to &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;, and you must pass &lt;em&gt;server_hostname&lt;/em&gt; to &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; in order to match the hostname. Enabling hostname checking automatically sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;. It cannot be set back to &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt; as long as hostname checking is enabled. The &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; protocol enables hostname checking by default. With other protocols, hostname checking must be enabled explicitly.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 에서 피어 인증서의 호스트 이름을 &lt;a href=&quot;#ssl.match_hostname&quot;&gt; &lt;code&gt;match_hostname()&lt;/code&gt; &lt;/a&gt; 과 일치 시킬지 여부 입니다. 컨텍스트의 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 로 설정 되어야 하며 호스트 이름과 일치하도록 &lt;em&gt;server_hostname&lt;/em&gt; 을 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 에 전달해야합니다 . 호스트 이름 확인을 활성화 하면 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 로 자동 설정됩니다 . 호스트 이름 확인이 활성화 되어 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; 으로 다시 설정할 수 없습니다 . &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;프로토콜은 기본적으로 호스트 이름 확인을 활성화합니다. 다른 프로토콜의 경우 호스트 이름 확인을 명시 적으로 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b724e20c7a82379a9a08525bdba888f74aefd96" translate="yes" xml:space="preserve">
          <source>Whether to try to verify other peers&amp;rsquo; certificates and how to behave if verification fails. This attribute must be one of &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt;&lt;code&gt;CERT_NONE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt;&lt;code&gt;CERT_OPTIONAL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 피어의 인증서를 확인하려고하는지 여부와 확인에 실패한 경우 동작하는 방법 이 속성은 &lt;a href=&quot;#ssl.CERT_NONE&quot;&gt; &lt;code&gt;CERT_NONE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.CERT_OPTIONAL&quot;&gt; &lt;code&gt;CERT_OPTIONAL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="25631d4668b3c0f9f32771f513f7cdbaf448ad8a" translate="yes" xml:space="preserve">
          <source>Whether writes are passed immediately to the underlying binary buffer.</source>
          <target state="translated">쓰기가 기본 바이너리 버퍼로 즉시 전달되는지 여부</target>
        </trans-unit>
        <trans-unit id="71cfd83d887f9f86d88898814a6869aad231de3a" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;package&lt;/a&gt; a module belongs to. If the module is top-level (i.e. not a part of any specific package) then the attribute should be set to &lt;code&gt;''&lt;/code&gt;, else it should be set to the name of the package (which can be &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; if the module is a package itself). Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">어떤 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-package&quot;&gt;패키지&lt;/a&gt; 모듈이 속한. 모듈이 최상위 레벨 (예 : 특정 패키지의 일부가 아님) 인 경우 속성을 &lt;code&gt;''&lt;/code&gt; 로 설정해야합니다. 그렇지 않으면 패키지 이름으로 설정해야합니다 ( 모듈이 패키지 자체 인 경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt; 일 수 있음). ). 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6bf7777d6a8548936df37db843584a88bd1bbbf8" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-package&quot;&gt;package&lt;/a&gt; a module belongs to. If the module is top-level (i.e. not a part of any specific package) then the attribute should be set to &lt;code&gt;''&lt;/code&gt;, else it should be set to the name of the package (which can be &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; if the module is a package itself). Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">어떤 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-package&quot;&gt;패키지&lt;/a&gt; 모듈이 속한. 모듈이 최상위 수준 (즉, 특정 패키지의 일부가 아님)이면 속성을 &lt;code&gt;''&lt;/code&gt; 로 설정해야합니다. 그렇지 않으면 패키지 이름으로 설정해야합니다 ( 모듈이 패키지 자체 인 경우 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; &lt;/a&gt; 일 수 있음). ). 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4040c278cd792b1142c2b0b1b82b0f58225cee15" translate="yes" xml:space="preserve">
          <source>Which Docstrings Are Examined?</source>
          <target state="translated">어떤 독 스트링이 검사됩니까?</target>
        </trans-unit>
        <trans-unit id="422d9e85c4992821c007871473f5fa36c3b56c95" translate="yes" xml:space="preserve">
          <source>Which produces</source>
          <target state="translated">어느 생산</target>
        </trans-unit>
        <trans-unit id="a995c55c592cf94976c7d041d87c783ecf9451c8" translate="yes" xml:space="preserve">
          <source>Which solves the fundamental issue of processes colliding with each other resulting in a bad file descriptor error, but introduces a potential danger to applications which replace &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin()&lt;/code&gt;&lt;/a&gt; with a &amp;ldquo;file-like object&amp;rdquo; with output buffering. This danger is that if multiple processes call &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; on this file-like object, it could result in the same data being flushed to the object multiple times, resulting in corruption.</source>
          <target state="translated">서로 충돌하는 프로세스의 근본적인 문제를 해결하면 파일 디스크립터 오류가 발생하지만 출력 버퍼링을 사용하여 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin()&lt;/code&gt; &lt;/a&gt; 을 &quot;file-like object&quot;로 바꾸는 응용 프로그램에 잠재적 인 위험이 발생합니다 . 이 위험은 여러 프로세스 가이 파일과 같은 객체에서 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 를 호출 하면 동일한 데이터가 객체에 여러 번 플러시되어 손상 될 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddaaf09868cf6400cdcb648881000117dda08bc9" translate="yes" xml:space="preserve">
          <source>Whichever method you choose, you should provide a &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; that also hides the (unimportant) value:</source>
          <target state="translated">어떤 방법을 선택 하든지 (중요하지 않은) 값을 숨기는 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c646905a39f0ba1aaa09265f14adc54f064ca461" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; above. This restriction does not apply to mix-ins which only add methods and don&amp;rsquo;t specify another data type such as &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 은 모든 유형의 멤버를 가질 수 있지만 추가 유형을 혼합하면 모든 멤버는 해당 유형의 값을 가져야합니다 (예 : 위의 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; )&lt;/a&gt; . 이 제한은 메소드 만 추가하고 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 같은 다른 데이터 유형을 지정하지 않는 믹스 인에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d9477fc38246177b0f8120236145f55c4f04194" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; can have members of any type, once you mix in an additional type, all the members must have values of that type, e.g. &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; above. This restriction does not apply to mix-ins which only add methods and don&amp;rsquo;t specify another type.</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 은 모든 유형의 멤버를 가질 수 있지만 추가 유형을 혼합하면 모든 멤버에는 해당 유형의 값이 있어야합니다 (예 : 위의 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; )&lt;/a&gt; . 이 제한은 메서드 만 추가하고 다른 유형을 지정하지 않는 믹스 인에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e556a67224525bf738669c6821725b3262368ed7" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; are expected to cover the majority of use-cases, they cannot cover them all. Here are recipes for some different types of enumerations that can be used directly, or as examples for creating one&amp;rsquo;s own.</source>
          <target state="translated">하지만 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 사용 사례의 대부분을 포함 할 것으로 예상된다, 그들은 그들 모두를 포함 할 수 없습니다. 다음은 직접 사용할 수 있거나 직접 작성하는 예제로 사용할 수있는 여러 유형의 열거에 대한 레시피입니다.</target>
        </trans-unit>
        <trans-unit id="fe708d810599cc0f179e22587c1998a55fa295c9" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; is part of the &lt;a href=&quot;#module-enum&quot;&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/a&gt; module, it would be very simple to implement independently:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#module-enum&quot;&gt; &lt;code&gt;enum&lt;/code&gt; &lt;/a&gt; 모듈의 일부 이지만 독립적으로 구현하는 것은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="1a6d1449ab3b35e2bc83dba53adce17079ecd21a" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;#graphlib.TopologicalSorter.is_active&quot;&gt;&lt;code&gt;is_active()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;, iterate over the nodes returned by &lt;a href=&quot;#graphlib.TopologicalSorter.get_ready&quot;&gt;&lt;code&gt;get_ready()&lt;/code&gt;&lt;/a&gt; and process them. Call &lt;a href=&quot;#graphlib.TopologicalSorter.done&quot;&gt;&lt;code&gt;done()&lt;/code&gt;&lt;/a&gt; on each node as it finishes processing.</source>
          <target state="translated">동안 &lt;a href=&quot;#graphlib.TopologicalSorter.is_active&quot;&gt; &lt;code&gt;is_active()&lt;/code&gt; &lt;/a&gt; 있다 &lt;code&gt;True&lt;/code&gt; 반복,에 의해 반환 된 노드 이상 &lt;a href=&quot;#graphlib.TopologicalSorter.get_ready&quot;&gt; &lt;code&gt;get_ready()&lt;/code&gt; &lt;/a&gt; 및 공정 그들. 처리가 완료되면 각 노드에서 &lt;a href=&quot;#graphlib.TopologicalSorter.done&quot;&gt; &lt;code&gt;done()&lt;/code&gt; &lt;/a&gt; 을 호출 합니다 .</target>
        </trans-unit>
        <trans-unit id="02cb7cf515d5ba420c468f846b2ed31c98f290b6" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt; describes the exact syntax and semantics of the Python language, this library reference manual describes the standard library that is distributed with Python. It also describes some of the optional components that are commonly included in Python distributions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/index.html#reference-index&quot;&gt;Python 언어 참조&lt;/a&gt; 는 Python 언어 의 정확한 구문과 의미를 설명 하지만 이 라이브러리 참조 설명서는 Python과 함께 배포되는 표준 라이브러리를 설명합니다. 또한 파이썬 배포판에 일반적으로 포함되는 일부 선택적 구성 요소에 대해서도 설명합니다.</target>
        </trans-unit>
        <trans-unit id="297f2a972c76e5f7a1e934cb7cea1a69f71a15df" translate="yes" xml:space="preserve">
          <source>While &lt;a href=&quot;https://docs.python.org/3.9/reference/index.html#reference-index&quot;&gt;The Python Language Reference&lt;/a&gt; describes the exact syntax and semantics of the Python language, this library reference manual describes the standard library that is distributed with Python. It also describes some of the optional components that are commonly included in Python distributions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/index.html#reference-index&quot;&gt;Python 언어 참조&lt;/a&gt; 는 Python 언어 의 정확한 구문과 의미를 설명 하지만 이 라이브러리 참조 설명서는 Python과 함께 배포되는 표준 라이브러리를 설명합니다. 또한 Python 배포에 일반적으로 포함되는 일부 선택적 구성 요소에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="e0785829e0c8a5f6cee5eb7d590c1588c0e86596" translate="yes" xml:space="preserve">
          <source>While ConfigParser objects also use an &lt;code&gt;OPTCRE&lt;/code&gt; attribute for recognizing option lines, it&amp;rsquo;s not recommended to override it because that would interfere with constructor options &lt;em&gt;allow_no_value&lt;/em&gt; and &lt;em&gt;delimiters&lt;/em&gt;.</source>
          <target state="translated">ConfigParser 객체는 옵션 라인을 인식 하기 위해 &lt;code&gt;OPTCRE&lt;/code&gt; 속성 도 사용하지만 생성자 옵션 &lt;em&gt;allow_no_value&lt;/em&gt; 및 &lt;em&gt;delimiters를&lt;/em&gt; 방해하므로이를 무시하지 않는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="0aea4fc9adcf74252cf54344d84df634df38ce92" translate="yes" xml:space="preserve">
          <source>While bytes literals and representations are based on ASCII text, bytes objects actually behave like immutable sequences of integers, with each value in the sequence restricted such that &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; (attempts to violate this restriction will trigger &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;). This is done deliberately to emphasise that while many binary formats include ASCII based elements and can be usefully manipulated with some text-oriented algorithms, this is not generally the case for arbitrary binary data (blindly applying text processing algorithms to binary data formats that are not ASCII compatible will usually lead to data corruption).</source>
          <target state="translated">바이트 리터럴과 표현은 ASCII 텍스트를 기반으로하지만 바이트 객체는 실제로 불변의 정수 시퀀스처럼 동작하며, 시퀀스의 각 값은 &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; (제한을 위반하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 트리거됩니다 )으로 제한됩니다 . 이것은 많은 바이너리 형식이 ASCII 기반 요소를 포함하고 일부 텍스트 지향 알고리즘으로 유용하게 조작 될 수 있지만, 일반적으로 임의의 이진 데이터 (텍스트 처리 알고리즘을 그렇지 않은 이진 데이터 형식에 맹목적으로 적용)에는 해당되지 않는다는 점을 강조하기 위해 의도적으로 수행됩니다. ASCII 호환은 일반적으로 데이터 손상을 초래합니다).</target>
        </trans-unit>
        <trans-unit id="afca682adab62f0880b590c7e59b89279df102ab" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;#bz2.BZ2File.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;em&gt;filename&lt;/em&gt; 의 파일 객체를 전달 하여 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 이 구성된 경우 ).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38177ebefc8686714a66d6d82cf4ee10e3058268" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; was constructed with the &lt;em&gt;fileobj&lt;/em&gt; parameter).</source>
          <target state="translated">&lt;a href=&quot;#gzip.GzipFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 이 &lt;em&gt;fileobj&lt;/em&gt; 매개 변수 로 구성된 경우 ).</target>
        </trans-unit>
        <trans-unit id="e6545af489ed1f20fcc9c3b27afc7248e80f9df3" translate="yes" xml:space="preserve">
          <source>While calling &lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt;&lt;code&gt;peek()&lt;/code&gt;&lt;/a&gt; does not change the file position of the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;, it may change the position of the underlying file object (e.g. if the &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt; was constructed by passing a file object for &lt;em&gt;filename&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;#lzma.LZMAFile.peek&quot;&gt; &lt;code&gt;peek()&lt;/code&gt; &lt;/a&gt; 호출 해도 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 의 파일 위치는 변경되지 않지만 기본 파일 객체의 위치가 변경 될 수 있습니다 (예 : &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 이 &lt;em&gt;filename&lt;/em&gt; 의 파일 객체를 전달하여 생성 된 경우 ).</target>
        </trans-unit>
        <trans-unit id="c0bb1fc2909ab24f32996f8a6e44f36be2000ff2" translate="yes" xml:space="preserve">
          <source>While curses is most widely used in the Unix environment, versions are available for Windows, DOS, and possibly other systems as well. This extension module is designed to match the API of ncurses, an open-source curses library hosted on Linux and the BSD variants of Unix.</source>
          <target state="translated">curses는 Unix 환경에서 가장 널리 사용되는 반면 Windows, DOS 및 기타 시스템에서도 버전을 사용할 수 있습니다. 이 확장 모듈은 Linux에서 호스팅되는 오픈 소스 curses 라이브러리 인 ncurses의 API 및 Unix의 BSD 변형과 일치하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="786cdfb379403ea4cce195f3dca6c17b6ee0052a" translate="yes" xml:space="preserve">
          <source>While date and time arithmetic is supported, the focus of the implementation is on efficient attribute extraction for output formatting and manipulation.</source>
          <target state="translated">날짜 및 시간 산술이 지원되지만 구현의 초점은 출력 형식 및 조작을위한 효율적인 속성 추출에 있습니다.</target>
        </trans-unit>
        <trans-unit id="67281bc9ed61750f29460e86ce99cc6681899c14" translate="yes" xml:space="preserve">
          <source>While many objects natively support use in with statements, sometimes a resource needs to be managed that isn&amp;rsquo;t a context manager in its own right, and doesn&amp;rsquo;t implement a &lt;code&gt;close()&lt;/code&gt; method for use with &lt;code&gt;contextlib.closing&lt;/code&gt;</source>
          <target state="translated">기본적으로 많은 객체가 with 문에서의 사용을 지원하지만 자체적으로 컨텍스트 관리자가 아니고 &lt;code&gt;contextlib.closing&lt;/code&gt; 과 함께 사용할 &lt;code&gt;close()&lt;/code&gt; 메서드를 구현하지 않는 리소스를 관리해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93bfa21ab3a98f4858cf4bc1efde7812c899e149" translate="yes" xml:space="preserve">
          <source>While many useful operations may take place between parsing and bytecode generation, the simplest operation is to do nothing. For this purpose, using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module to produce an intermediate data structure is equivalent to the code</source>
          <target state="translated">구문 분석과 바이트 코드 생성간에 많은 유용한 작업이 수행 될 수 있지만 가장 간단한 작업은 아무 것도 수행하지 않는 것입니다. 이를 위해 &lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 중간 데이터 구조를 생성하는 것은 코드와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b514cb7bc8722d4e70eacb8c91412ef7465d4c76" translate="yes" xml:space="preserve">
          <source>While other exceptions may still occur, this method is called &amp;ldquo;safe&amp;rdquo; because it always tries to return a usable string instead of raising an exception. In another sense, &lt;a href=&quot;#string.Template.safe_substitute&quot;&gt;&lt;code&gt;safe_substitute()&lt;/code&gt;&lt;/a&gt; may be anything other than safe, since it will silently ignore malformed templates containing dangling delimiters, unmatched braces, or placeholders that are not valid Python identifiers.</source>
          <target state="translated">다른 예외가 여전히 발생할 수 있지만이 메서드는 항상 예외를 발생시키는 대신 사용 가능한 문자열을 반환하려고하기 때문에 &quot;안전&quot;이라고합니다. 다른 의미에서 &lt;a href=&quot;#string.Template.safe_substitute&quot;&gt; &lt;code&gt;safe_substitute()&lt;/code&gt; &lt;/a&gt; 는 안전한 구분 기호, 일치하지 않는 중괄호 또는 유효한 Python 식별자가 아닌 자리 표시자를 포함하는 잘못된 템플릿을 자동으로 무시하므로 safe 이외의 것일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a915d6b0d37f05b5affd54282cd5bb33c1eff648" translate="yes" xml:space="preserve">
          <source>While parsing the command line, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; checks for a variety of errors, including ambiguous options, invalid types, invalid options, wrong number of positional arguments, etc. When it encounters such an error, it exits and prints the error along with a usage message:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 명령 행을 구문 분석하는 동안 모호한 옵션, 유효하지 않은 유형, 유효하지 않은 옵션, 잘못된 수의 위치 인수 등을 포함하여 다양한 오류를 검사합니다. 이러한 오류가 발생하면 종료되고 오류와 함께 오류가 인쇄됩니다. 사용 메시지 :</target>
        </trans-unit>
        <trans-unit id="af0a5de79e2df6a8d199d3d065c11df24c028f5b" translate="yes" xml:space="preserve">
          <source>While symlinks are supported on Windows, they are not recommended. Of particular note is that double-clicking &lt;code&gt;python.exe&lt;/code&gt; in File Explorer will resolve the symlink eagerly and ignore the virtual environment.</source>
          <target state="translated">심볼릭 링크는 Windows에서 지원되지만 권장되지 않습니다. 특히 주목할 점은 파일 탐색기에서 &lt;code&gt;python.exe&lt;/code&gt; 를 두 번 클릭하면 심볼릭 링크를 열심히 해결하고 가상 환경을 무시한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0e04edc4d322f07593d9595090717727de98239" translate="yes" xml:space="preserve">
          <source>While the &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;not in&lt;/code&gt; operations are used only for simple containment testing in the general case, some specialised sequences (such as &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) also use them for subsequence testing:</source>
          <target state="translated">그동안 &lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;not in&lt;/code&gt; 작업에만 일반적인 경우에 간단한 봉쇄 테스트에 사용된다 (예 : 일부 전문 시퀀스 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; )도 서브 테스트에 사용할 :</target>
        </trans-unit>
        <trans-unit id="5d31855d6be2ba764837d00ac8c9c8aa85b873bb" translate="yes" xml:space="preserve">
          <source>While the above API is the most common and convenient usage, you can get all of that information from the &lt;code&gt;Distribution&lt;/code&gt; class. A &lt;code&gt;Distribution&lt;/code&gt; is an abstract object that represents the metadata for a Python package. You can get the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">위의 API가 가장 일반적이고 편리한 사용법이지만 &lt;code&gt;Distribution&lt;/code&gt; 클래스 에서 해당 정보를 모두 얻을 수 있습니다 . &lt;code&gt;Distribution&lt;/code&gt; 파이썬 패키지에 대한 메타 데이터를 나타내는 추상 개체입니다. &lt;code&gt;Distribution&lt;/code&gt; 인스턴스를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6319151ce24cde9d9afeaf68fdcdbec22e36ba3" translate="yes" xml:space="preserve">
          <source>While the builtin &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; and the associated &lt;a href=&quot;io#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module are the recommended approach for working with encoded text files, this module provides additional utility functions and classes that allow the use of a wider range of codecs when working with binary files:</source>
          <target state="translated">내장 된 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 및 관련 &lt;a href=&quot;io#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈은 인코딩 된 텍스트 파일 작업에 권장되는 접근 방법이지만이 모듈은 바이너리 파일로 작업 할 때 더 넓은 범위의 코덱을 사용할 수있는 추가 유틸리티 함수 및 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="42821c116527a74cd5c9f35556c03beeb2cf5d8f" translate="yes" xml:space="preserve">
          <source>While the method has a default implementation, it is suggested that it be overridden if possible for performance.</source>
          <target state="translated">이 방법에는 기본 구현이 있지만 가능한 경우 성능을 위해 재정의하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14032b7a66889d07d3394faf5c484ef0cdf94cea" translate="yes" xml:space="preserve">
          <source>While these are technically &lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;built-in exceptions&lt;/a&gt;, they are documented here, because conceptually they belong to the warnings mechanism.</source>
          <target state="translated">이들은 기술적으로 &lt;a href=&quot;exceptions#warning-categories-as-exceptions&quot;&gt;내장 된 예외&lt;/a&gt; 이지만 개념적으로 경고 메커니즘에 속하기 때문에 여기에 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcfc856d002acccc1fa089a7e19be1782a8e1118" translate="yes" xml:space="preserve">
          <source>While they are not listed below, the &lt;code&gt;camelCase&lt;/code&gt; names used for some methods and functions in this module in the Python 2.x series are still supported by this module.</source>
          <target state="translated">아래에 나열되어 있지는 않지만 Python 2.x 시리즈에서이 모듈의 일부 메소드 및 함수에 사용 된 &lt;code&gt;camelCase&lt;/code&gt; 이름은이 모듈에서 계속 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="0f4b7324352db1ad0e38dfcfad84d64814555c92" translate="yes" xml:space="preserve">
          <source>While this decorator makes it easy to create well behaved totally ordered types, it &lt;em&gt;does&lt;/em&gt; come at the cost of slower execution and more complex stack traces for the derived comparison methods. If performance benchmarking indicates this is a bottleneck for a given application, implementing all six rich comparison methods instead is likely to provide an easy speed boost.</source>
          <target state="translated">이 장식은 쉽게 잘 완전히 주문 행동 유형을 만들 수 있지만, 그것은 &lt;em&gt;않습니다&lt;/em&gt; 파생 비교 방법에 대한 느린 실행과 더 복잡한 스택 추적의 비용으로 제공됩니다. 성능 벤치마킹이 이것이 특정 응용 프로그램의 병목 현상이라고 표시하는 경우 6 가지의 풍부한 비교 방법을 모두 구현하면 속도를 쉽게 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8863d901011fb351d3633ca34f340a2828c5fea0" translate="yes" xml:space="preserve">
          <source>While this might be annoying, this feature is intended for use in specialized circumstances, such as multi-threaded servers where the same code executes in many contexts, and interesting conditions which arise are dependent on this context (such as remote client IP address and authenticated user name, in the above example). In such circumstances, it is likely that specialized &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;s would be used with particular &lt;a href=&quot;#logging.Handler&quot;&gt;&lt;code&gt;Handler&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이 작업은 성가신 일이지만이 기능은 동일한 코드가 여러 컨텍스트에서 실행되는 멀티 스레드 서버와 같은 특수한 환경에서 사용하기위한 것이며 흥미로운 상황은이 컨텍스트에 따라 다릅니다 (예 : 원격 클라이언트 IP 주소 및 인증 됨) 위의 예에서 사용자 이름). 이러한 상황에서는 특수한 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 가 특정 &lt;a href=&quot;#logging.Handler&quot;&gt; &lt;code&gt;Handler&lt;/code&gt; &lt;/a&gt; 와 함께 사용될 가능성이 높습니다 .</target>
        </trans-unit>
        <trans-unit id="840def8eae0283a6cbfe40db44014f3c77b1c43b" translate="yes" xml:space="preserve">
          <source>While using a hierarchy of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt;-derived classes can be convenient in sharing fixtures and helper functions, defining test methods on base classes that are not intended to be instantiated directly does not play well with this method. Doing so, however, can be useful when the fixtures are different and defined in subclasses.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 파생 클래스 의 계층 구조를 사용하면 조명기 및 도우미 함수를 공유하는 데 편리 할 수 ​​있지만 직접 인스턴스화되지 않는 기본 클래스에서 테스트 메소드를 정의하는 것은이 메소드에서 잘 작동하지 않습니다. 그러나 픽스쳐가 다르고 서브 클래스에 정의 된 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="988a0cff7503163f428287a56046c0bb09b3b7fd" translate="yes" xml:space="preserve">
          <source>While within the context manager all warnings will simply be ignored. This allows you to use known-deprecated code without having to see the warning while not suppressing the warning for other code that might not be aware of its use of deprecated code. Note: this can only be guaranteed in a single-threaded application. If two or more threads use the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager at the same time, the behavior is undefined.</source>
          <target state="translated">컨텍스트 관리자 내에서 모든 경고는 무시됩니다. 이를 통해 더 이상 사용되지 않는 코드 사용을 인식하지 못하는 다른 코드에 대한 경고를 표시하지 않으면 서 경고를 보지 않고도 알려진 사용되지 않는 코드를 사용할 수 있습니다. 참고 : 이것은 단일 스레드 응용 프로그램에서만 보장 될 수 있습니다. 둘 이상의 스레드가 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 동시에 사용하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37619fc13053f82b7cb7da3d24ceb1598ab6d05c" translate="yes" xml:space="preserve">
          <source>White</source>
          <target state="translated">White</target>
        </trans-unit>
        <trans-unit id="62d692a71777fd55efffbdb0ca5893dd735770aa" translate="yes" xml:space="preserve">
          <source>Whitebox testing (examining the code being tested when the tests are being written) is preferred. Blackbox testing (testing only the published user interface) is not complete enough to make sure all boundary and edge cases are tested.</source>
          <target state="translated">화이트 박스 테스트 (테스트를 작성할 때 테스트중인 코드 검사)가 선호됩니다. 블랙 박스 테스트 (게시 된 사용자 인터페이스 만 테스트)는 모든 경계 및 경계 사례를 테스트하기에 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="931f4c5c75b75b488b411586b1c52d7e9f8da29c" translate="yes" xml:space="preserve">
          <source>Whiteout.</source>
          <target state="translated">Whiteout.</target>
        </trans-unit>
        <trans-unit id="b78a557954071d939474b0820ce2d887c5949beb" translate="yes" xml:space="preserve">
          <source>Whitespace characters between formats are ignored; a count and its format must not contain whitespace though.</source>
          <target state="translated">형식 사이의 공백 문자는 무시됩니다. 카운트와 형식에는 공백이 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="6b7e00ea7c678d4c6c68704506146cc03ff76587" translate="yes" xml:space="preserve">
          <source>Whitespace is not allowed between the &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; and the directive option name. The directive option name can be any of the option flag names explained above.</source>
          <target state="translated">&lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; 와 지시문 옵션 이름 사이에는 공백이 허용되지 않습니다 . 지시문 옵션 이름은 위에서 설명한 옵션 플래그 이름 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8fe1444c5cef2f1bf2942426dad26edc71785bf" translate="yes" xml:space="preserve">
          <source>Why is it printing &lt;code&gt;False&lt;/code&gt;? ctypes instances are objects containing a memory block plus some &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the &lt;code&gt;contents&lt;/code&gt; of the object is stored. Accessing the contents again constructs a new Python object each time!</source>
          <target state="translated">왜 &lt;code&gt;False&lt;/code&gt; 를 인쇄 합니까? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 일부 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-descriptor&quot;&gt;디스크립터를&lt;/a&gt; 포함하는 객체 입니다. 메모리 블록에 파이썬 객체를 저장하면 객체 자체가 저장되지 않고 객체의 &lt;code&gt;contents&lt;/code&gt; 이 저장됩니다. 내용에 다시 액세스하면 매번 새로운 Python 객체가 생성됩니다!</target>
        </trans-unit>
        <trans-unit id="abe93e8d7ae385c7fa16cc4105c3de888fe59d53" translate="yes" xml:space="preserve">
          <source>Why is it printing &lt;code&gt;False&lt;/code&gt;? ctypes instances are objects containing a memory block plus some &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;descriptor&lt;/a&gt;s accessing the contents of the memory. Storing a Python object in the memory block does not store the object itself, instead the &lt;code&gt;contents&lt;/code&gt; of the object is stored. Accessing the contents again constructs a new Python object each time!</source>
          <target state="translated">왜 &lt;code&gt;False&lt;/code&gt; 로 인쇄 됩니까? ctypes 인스턴스는 메모리 블록과 메모리 내용에 액세스하는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-descriptor&quot;&gt;설명자를&lt;/a&gt; 포함하는 객체 입니다. 파이썬 객체를 메모리 블록에 저장하면 객체 자체가 저장되지 않고 대신 객체의 &lt;code&gt;contents&lt;/code&gt; 이 저장됩니다. 콘텐츠에 다시 액세스하면 매번 새로운 Python 객체가 생성됩니다!</target>
        </trans-unit>
        <trans-unit id="fb8f747f33b6f74dbe7fd5ac838801c9d72b22ac" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형으로 유니 코드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5be99ca3a70e3977f2f65814d98de5c5b56d2d2" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.getche&quot;&gt;&lt;code&gt;getche()&lt;/code&gt;&lt;/a&gt;, returning a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.getche&quot;&gt; &lt;code&gt;getche()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형으로 유니 코드 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="255f38720857b44ab5ff2e2d98e37a3c89e37d00" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.putch&quot;&gt;&lt;code&gt;putch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">&lt;a href=&quot;#msvcrt.putch&quot;&gt; &lt;code&gt;putch()&lt;/code&gt; &lt;/a&gt; 의 넓은 문자 변형으로 유니 코드 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6f0779174f97c45da57524e6b209ae90dff53c3d" translate="yes" xml:space="preserve">
          <source>Wide char variant of &lt;a href=&quot;#msvcrt.ungetch&quot;&gt;&lt;code&gt;ungetch()&lt;/code&gt;&lt;/a&gt;, accepting a Unicode value.</source>
          <target state="translated">유니 코드 값을 허용하는 &lt;a href=&quot;#msvcrt.ungetch&quot;&gt; &lt;code&gt;ungetch()&lt;/code&gt; &lt;/a&gt; 의 넓은 char 변형 .</target>
        </trans-unit>
        <trans-unit id="df15305cc141d8294713eba43aaee44d1edfe3bd" translate="yes" xml:space="preserve">
          <source>Widget</source>
          <target state="translated">Widget</target>
        </trans-unit>
        <trans-unit id="bfee860a8a5dc6ac74dd99d215ad1d51cce5c8c7" translate="yes" xml:space="preserve">
          <source>Widget States</source>
          <target state="translated">위젯 상태</target>
        </trans-unit>
        <trans-unit id="79beed1fb49764e8862ef327797df09e07c316a6" translate="yes" xml:space="preserve">
          <source>Widget has keyboard focus</source>
          <target state="translated">위젯에 키보드 포커스가 있습니다</target>
        </trans-unit>
        <trans-unit id="2233730413ec55a5b571e7d775be44e6e3e013b3" translate="yes" xml:space="preserve">
          <source>Widget is being pressed</source>
          <target state="translated">위젯을 누르고 있습니다</target>
        </trans-unit>
        <trans-unit id="da46e3b7f16d7ede37378d1c431a4c43fb3ef6fc" translate="yes" xml:space="preserve">
          <source>Widget is disabled under program control</source>
          <target state="translated">프로그램 제어에서 위젯이 비활성화 됨</target>
        </trans-unit>
        <trans-unit id="211f67af4e336b2c25b87952f14880aca797600a" translate="yes" xml:space="preserve">
          <source>Widget should not allow user modification</source>
          <target state="translated">위젯은 사용자 수정을 허용하지 않아야합니다</target>
        </trans-unit>
        <trans-unit id="802f4ec2a7a115583d6e55e6d32a4beead4d14b2" translate="yes" xml:space="preserve">
          <source>Width of the terminal window in characters.</source>
          <target state="translated">문자로 된 터미널 창의 너비.</target>
        </trans-unit>
        <trans-unit id="080323da0bfe1ab0191a174c2237858164d7cdaf" translate="yes" xml:space="preserve">
          <source>Wikipedia article with information on which algorithms have known issues and what that means regarding their use.</source>
          <target state="translated">알려진 알고리즘에 대해 알고있는 알고리즘과 그 사용에 대한 의미에 대한 정보가 포함 된 Wikipedia 기사</target>
        </trans-unit>
        <trans-unit id="c1b3cf193c6d821b49984f993d3ea75cf5a5a2be" translate="yes" xml:space="preserve">
          <source>Wikipedia entry for &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;Multisets&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Multiset&quot;&gt;다중 집합에&lt;/a&gt; 대한 Wikipedia 항목 .</target>
        </trans-unit>
        <trans-unit id="113f18f5469ce5347437610dd55d140a53fa09c6" translate="yes" xml:space="preserve">
          <source>Wikipedia has a &lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;nice example of a Naive Bayesian Classifier&lt;/a&gt;. The challenge is to predict a person&amp;rsquo;s gender from measurements of normally distributed features including height, weight, and foot size.</source>
          <target state="translated">Wikipedia에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Bayes_classifier#Sex_classification&quot;&gt;Naive Bayesian Classifier&lt;/a&gt; 의 좋은 예가 있습니다. 문제는 키, 몸무게 및 발 크기를 포함하여 정상적으로 분포 된 피처를 측정하여 사람의 성별을 예측하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f6fe06680d0563e4e9deb6c1d86aa445e8e5c908" translate="yes" xml:space="preserve">
          <source>Will add, among other things, a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; that looks like:</source>
          <target state="translated">무엇보다도 다음과 같은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d058ba61c1be1593a1050216418b28999b88eb0a" translate="yes" xml:space="preserve">
          <source>Will add, among other things, a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; that looks like:</source>
          <target state="translated">무엇보다도 다음과 같은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d239e74c0170d39d6786ccf1a848d04c2c537ed2" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the indicated number of characters have been received</source>
          <target state="translated">표시된 문자 수가 수신되면 &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="4426413765c214020905681f96c46df4a803dd94" translate="yes" xml:space="preserve">
          <source>Will call &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; when the string is found in the input stream</source>
          <target state="translated">입력 스트림에서 문자열이 발견되면 &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="47374c257b33abb533116a9cb9651554e18faed7" translate="yes" xml:space="preserve">
          <source>Will generally raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; if executed on a 32-bit operating system.</source>
          <target state="translated">32 비트 운영 체제에서 실행되면 일반적으로 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b90c5925294b920cc6ddfbe599b541b3edf485fe" translate="yes" xml:space="preserve">
          <source>Will try to match with &lt;code&gt;yes-pattern&lt;/code&gt; if the group with given &lt;em&gt;id&lt;/em&gt; or &lt;em&gt;name&lt;/em&gt; exists, and with &lt;code&gt;no-pattern&lt;/code&gt; if it doesn&amp;rsquo;t. &lt;code&gt;no-pattern&lt;/code&gt; is optional and can be omitted. For example, &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; is a poor email matching pattern, which will match with &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; as well as &lt;code&gt;'user@host.com'&lt;/code&gt;, but not with &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; nor &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">일치하려고합니다 &lt;code&gt;yes-pattern&lt;/code&gt; 주어진과 그룹 경우 &lt;em&gt;ID&lt;/em&gt; 나 &lt;em&gt;이름이&lt;/em&gt; 존재하고와 &lt;code&gt;no-pattern&lt;/code&gt; 이하지 않는 경우. &lt;code&gt;no-pattern&lt;/code&gt; 은 선택 사항이며 생략 할 수 있습니다. 예를 들어, &lt;code&gt;(&amp;lt;)?(\w+@\w+(?:\.\w+)+)(?(1)&amp;gt;|$)&lt;/code&gt; 는 전자 메일 일치 패턴이 잘못되어 &lt;code&gt;'&amp;lt;user@host.com&amp;gt;'&lt;/code&gt; 과 일치합니다. &amp;gt; ' 뿐만 아니라 &lt;code&gt;'user@host.com'&lt;/code&gt; 이지만 &lt;code&gt;'&amp;lt;user@host.com'&lt;/code&gt; 또는 &lt;code&gt;'user@host.com&amp;gt;'&lt;/code&gt; 과는 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="81dab24e3d9f50cff7ee608ff0514afa0cfa05b9" translate="yes" xml:space="preserve">
          <source>Window Objects</source>
          <target state="translated">창 객체</target>
        </trans-unit>
        <trans-unit id="ce658069fb4ffc6d3ca8e791633d8df32975802b" translate="yes" xml:space="preserve">
          <source>Window control</source>
          <target state="translated">창 제어</target>
        </trans-unit>
        <trans-unit id="660e57fa2bc58f9dadba0b1f9648498cca7a58e4" translate="yes" xml:space="preserve">
          <source>Window menu (Shell and Editor)</source>
          <target state="translated">창 메뉴 (쉘 및 편집기)</target>
        </trans-unit>
        <trans-unit id="b7e449a2f3ba9b16acfab22bc1c12f4e17b45718" translate="yes" xml:space="preserve">
          <source>Window objects, as returned by &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#curses.newwin&quot;&gt;&lt;code&gt;newwin()&lt;/code&gt;&lt;/a&gt; above, have the following methods and attributes:</source>
          <target state="translated">위의 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#curses.newwin&quot;&gt; &lt;code&gt;newwin()&lt;/code&gt; &lt;/a&gt; 반환 된 Window 객체 에는 다음과 같은 메서드와 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64271b944dda3c434c1d350e41c4b9a56d00bf95" translate="yes" xml:space="preserve">
          <source>Window resize signal.</source>
          <target state="translated">창 크기 조정 신호.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="e23575cabbcb9b7c4f9b7f51a07387fed98002f0" translate="yes" xml:space="preserve">
          <source>Windows Constants</source>
          <target state="translated">윈도우 상수</target>
        </trans-unit>
        <trans-unit id="733b53500cac45b1ccabfeea23e2dd3682ceafd7" translate="yes" xml:space="preserve">
          <source>Windows Platform</source>
          <target state="translated">윈도우 플랫폼</target>
        </trans-unit>
        <trans-unit id="707d9815b3e7e66dfa8de1e9a953cf814bb32ace" translate="yes" xml:space="preserve">
          <source>Windows Popen Helpers</source>
          <target state="translated">Windows Popen 도우미</target>
        </trans-unit>
        <trans-unit id="059cace6c4e4f2ba24a96dd77457fa820cea57be" translate="yes" xml:space="preserve">
          <source>Windows and Mac have a notion of an &amp;ldquo;active&amp;rdquo; or foreground window. The &lt;em&gt;background&lt;/em&gt; state is set for widgets in a background window, and cleared for those in the foreground window</source>
          <target state="translated">Windows 및 Mac에는 &quot;활성&quot;또는 포 그라운드 창이라는 개념이 있습니다. &lt;em&gt;배경&lt;/em&gt; 상태는 전경 창에서 사람들을 위해 배경 화면에서 위젯 설정 및 해제</target>
        </trans-unit>
        <trans-unit id="58f8b33dac190c990211b26ccc6956c320800b74" translate="yes" xml:space="preserve">
          <source>Windows appends the usual &lt;code&gt;.dll&lt;/code&gt; file suffix automatically.</source>
          <target state="translated">Windows는 일반적인 &lt;code&gt;.dll&lt;/code&gt; 파일 접미사를 자동으로 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="c3fc7bf4a41cf349e493878f4d10064c2cb45383" translate="yes" xml:space="preserve">
          <source>Windows file attributes: &lt;code&gt;dwFileAttributes&lt;/code&gt; member of the &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; structure returned by &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt;. See the &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; constants in the &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows 파일 속성 : &lt;code&gt;GetFileInformationByHandle()&lt;/code&gt; 의해 리턴 된 &lt;code&gt;BY_HANDLE_FILE_INFORMATION&lt;/code&gt; 구조 의 &lt;code&gt;dwFileAttributes&lt;/code&gt; 멤버 . &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;FILE_ATTRIBUTE_*&lt;/code&gt; 상수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3fbab09a7f617cae95132c649f8e0c1742cca65" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.OleDLL&quot;&gt;&lt;code&gt;OleDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">Windows 전용 : &lt;a href=&quot;#ctypes.OleDLL&quot;&gt; &lt;code&gt;OleDLL&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="612e01f22f9c1d88221548d271f8b961715eb8ed" translate="yes" xml:space="preserve">
          <source>Windows only: Creates &lt;a href=&quot;#ctypes.WinDLL&quot;&gt;&lt;code&gt;WinDLL&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">Windows 전용 : &lt;a href=&quot;#ctypes.WinDLL&quot;&gt; &lt;code&gt;WinDLL&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="e2c52f5bde98e844c1500dc7688f5098974c8782" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the ANSI codepage (CP_ACP).</source>
          <target state="translated">Windows 전용 : ANSI 코드 페이지 (CP_ACP)에 따라 피연산자를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="266fb264e8732c43ca999faee5d793005f28e1c9" translate="yes" xml:space="preserve">
          <source>Windows only: Encode the operand according to the OEM codepage (CP_OEMCP).</source>
          <target state="translated">Windows 전용 : OEM 코드 페이지 (CP_OEMCP)에 따라 피연산자를 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="edb6ed45a1b723b7af51540eab62bf7ae64e1059" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return &lt;code&gt;int&lt;/code&gt; by default.</source>
          <target state="translated">Windows 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며,이 라이브러리의 함수는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하며 기본적으로 &lt;code&gt;int&lt;/code&gt; 를 리턴하는 것으로 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a8baa6ebf95b244d430b0bac19d2d4be067fc743" translate="yes" xml:space="preserve">
          <source>Windows only: Instances of this class represent loaded shared libraries, functions in these libraries use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and are assumed to return the windows specific &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; code. &lt;a href=&quot;#ctypes.HRESULT&quot;&gt;&lt;code&gt;HRESULT&lt;/code&gt;&lt;/a&gt; values contain information specifying whether the function call failed or succeeded, together with additional error code. If the return value signals a failure, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is automatically raised.</source>
          <target state="translated">Windows 전용 :이 클래스의 인스턴스는로드 된 공유 라이브러리를 나타내며,이 라이브러리의 함수는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용 하며 Windows 고유의 &lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt; 코드 를 리턴하는 것으로 가정 합니다. &lt;a href=&quot;#ctypes.HRESULT&quot;&gt; &lt;code&gt;HRESULT&lt;/code&gt; &lt;/a&gt; 값에는 추가 오류 코드와 함께 함수 호출 실패 또는 성공 여부를 지정하는 정보가 포함됩니다. 리턴 값이 실패를 신호하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 자동으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4996849541b713bd583a818c47de0918c05b035c" translate="yes" xml:space="preserve">
          <source>Windows only: Represents a &lt;code&gt;HRESULT&lt;/code&gt; value, which contains success or error information for a function or method call.</source>
          <target state="translated">Windows 전용 : 함수 또는 메소드 호출에 대한 성공 또는 오류 정보가 포함 된 &lt;code&gt;HRESULT&lt;/code&gt; 값을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bdabf613004cb36f7b1c0e46576c928355e113b5" translate="yes" xml:space="preserve">
          <source>Windows only: Returns a textual description of the error code &lt;em&gt;code&lt;/em&gt;. If no error code is specified, the last error code is used by calling the Windows api function GetLastError.</source>
          <target state="translated">Windows 전용 : 오류 코드 &lt;em&gt;code&lt;/em&gt; 의 텍스트 설명을 리턴합니다 . 오류 코드를 지정하지 않으면 Windows API 함수 GetLastError를 호출하여 마지막 오류 코드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fbcbf3ad5bd151aa5b3e3fde3eb8d692caac57ec" translate="yes" xml:space="preserve">
          <source>Windows only: Returns the last error code set by Windows in the calling thread. This function calls the Windows &lt;code&gt;GetLastError()&lt;/code&gt; function directly, it does not return the ctypes-private copy of the error code.</source>
          <target state="translated">Windows 전용 : 호출 스레드에서 Windows가 설정 한 마지막 오류 코드를 리턴합니다. 이 함수는 Windows &lt;code&gt;GetLastError()&lt;/code&gt; 함수를 직접 호출 하며 오류 코드의 ctypes-private 복사본을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2511b1a5b947b91013c7afa28eb6b0b78fe0e385" translate="yes" xml:space="preserve">
          <source>Windows only: The returned function prototype creates functions that use the &lt;code&gt;stdcall&lt;/code&gt; calling convention, except on Windows CE where &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt;&lt;code&gt;WINFUNCTYPE()&lt;/code&gt;&lt;/a&gt; is the same as &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt;&lt;code&gt;CFUNCTYPE()&lt;/code&gt;&lt;/a&gt;. The function will release the GIL during the call. &lt;em&gt;use_errno&lt;/em&gt; and &lt;em&gt;use_last_error&lt;/em&gt; have the same meaning as above.</source>
          <target state="translated">Windows 전용 : 반환 된 함수 프로토 타입은 사용하는 함수 생성 &lt;code&gt;stdcall&lt;/code&gt; 을 어디에 윈도우 CE를 제외하고, 호출 규칙을 &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt; &lt;code&gt;WINFUNCTYPE()&lt;/code&gt; &lt;/a&gt; 과 동일 &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt; &lt;code&gt;CFUNCTYPE()&lt;/code&gt; &lt;/a&gt; . 이 기능은 호출 중에 GIL을 해제합니다. &lt;em&gt;use_errno&lt;/em&gt; 및 &lt;em&gt;use_last_error&lt;/em&gt; 는 위와 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="08605ae2b964896441a344b5311963123c2e7022" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllCanUnloadNow function that the _ctypes extension dll exports.</source>
          <target state="translated">Windows 전용 :이 기능은 ctypes를 사용하여 처리중인 COM 서버를 구현할 수있는 후크입니다. _ctypes 확장명 dll이 내보내는 DllCanUnloadNow 함수에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="29751233ae7d28491bf89fa51c323518e5fedbd3" translate="yes" xml:space="preserve">
          <source>Windows only: This function is a hook which allows implementing in-process COM servers with ctypes. It is called from the DllGetClassObject function that the &lt;code&gt;_ctypes&lt;/code&gt; extension dll exports.</source>
          <target state="translated">Windows 전용 :이 기능은 ctypes를 사용하여 처리중인 COM 서버를 구현할 수있는 후크입니다. &lt;code&gt;_ctypes&lt;/code&gt; 확장 dll이 내보내는 DllGetClassObject 함수에서 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="4880e94875e68f82bb6fce3490b9c97c9c5d775d" translate="yes" xml:space="preserve">
          <source>Windows only: return the filename of the VC runtime library used by Python, and by the extension modules. If the name of the library cannot be determined, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">Windows 전용 : Python 및 확장 모듈에서 사용하는 VC 런타임 라이브러리의 파일 이름을 리턴하십시오. 라이브러리 이름을 판별 할 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="d3e388ef290e4bd8ff8d89808b87dad3695d974a" translate="yes" xml:space="preserve">
          <source>Windows only: returns the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread.</source>
          <target state="translated">Windows 전용 : 호출 스레드에서 시스템 &lt;code&gt;LastError&lt;/code&gt; 변수 의 ctypes-private 사본의 현재 값을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="bb8310fccfe554408a2574b1c48ddf84fd935b53" translate="yes" xml:space="preserve">
          <source>Windows only: set the current value of the ctypes-private copy of the system &lt;code&gt;LastError&lt;/code&gt; variable in the calling thread to &lt;em&gt;value&lt;/em&gt; and return the previous value.</source>
          <target state="translated">Windows에만 해당 : 시스템의하는 ctypes - 개인 복사본의 현재 값으로 설정 &lt;code&gt;LastError&lt;/code&gt; 의 에 호출 스레드에서 변수 &lt;em&gt;값을&lt;/em&gt; 이전 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8358fc5d14e0fbf09bf3e54d163a390795bbe4f7" translate="yes" xml:space="preserve">
          <source>Windows only: this function is probably the worst-named thing in ctypes. It creates an instance of OSError. If &lt;em&gt;code&lt;/em&gt; is not specified, &lt;code&gt;GetLastError&lt;/code&gt; is called to determine the error code. If &lt;em&gt;descr&lt;/em&gt; is not specified, &lt;a href=&quot;#ctypes.FormatError&quot;&gt;&lt;code&gt;FormatError()&lt;/code&gt;&lt;/a&gt; is called to get a textual description of the error.</source>
          <target state="translated">Windows 전용 :이 기능은 아마도 ctypes에서 최악의 이름 일 것입니다. OSError의 인스턴스를 만듭니다. 경우 &lt;em&gt;코드가&lt;/em&gt; 지정되지 않은, &lt;code&gt;GetLastError&lt;/code&gt; 는 에러 코드를 확인하기 위해 호출됩니다. 경우 &lt;em&gt;DESCR가&lt;/em&gt; 지정되지 않은, &lt;a href=&quot;#ctypes.FormatError&quot;&gt; &lt;code&gt;FormatError()&lt;/code&gt; &lt;/a&gt; 오류의 텍스트 설명을 얻기 위해 호출된다.</target>
        </trans-unit>
        <trans-unit id="db996879e3dc4634bda2abfa9ed3e517199ceb69" translate="yes" xml:space="preserve">
          <source>Windows will return one of:</source>
          <target state="translated">Windows는 다음 중 하나를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9cd7eea9943b6fe344a02e8fbc71ef279241c91a" translate="yes" xml:space="preserve">
          <source>Windows/Cygwin</source>
          <target state="translated">Windows/Cygwin</target>
        </trans-unit>
        <trans-unit id="a807de5503cda53ca6fea19efe8608ddcb20996b" translate="yes" xml:space="preserve">
          <source>Windows: The &lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt;&lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt;&lt;/a&gt; signals are special signals which can only be sent to console processes which share a common console window, e.g., some subprocesses. Any other value for &lt;em&gt;sig&lt;/em&gt; will cause the process to be unconditionally killed by the TerminateProcess API, and the exit code will be set to &lt;em&gt;sig&lt;/em&gt;. The Windows version of &lt;a href=&quot;#os.kill&quot;&gt;&lt;code&gt;kill()&lt;/code&gt;&lt;/a&gt; additionally takes process handles to be killed.</source>
          <target state="translated">Windows : &lt;a href=&quot;signal#signal.CTRL_C_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_C_EVENT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;signal#signal.CTRL_BREAK_EVENT&quot;&gt; &lt;code&gt;signal.CTRL_BREAK_EVENT&lt;/code&gt; &lt;/a&gt; 신호는 공통 콘솔 창을 공유하는 콘솔 프로세스 (예 : 일부 하위 프로세스)로만 보낼 수있는 특수 신호입니다. &lt;em&gt;sig의&lt;/em&gt; 다른 값 은 프로세스가 TerminateProcess API에 의해 무조건 종료되며 종료 코드는 &lt;em&gt;sig&lt;/em&gt; 로 설정됩니다 . &lt;a href=&quot;#os.kill&quot;&gt; &lt;code&gt;kill()&lt;/code&gt; &lt;/a&gt; 의 Windows 버전은 추가로 프로세스 핸들을 강제 종료합니다.</target>
        </trans-unit>
        <trans-unit id="adf309288e97790d19b86dd6d3f7067de5f4100b" translate="yes" xml:space="preserve">
          <source>WindowsError</source>
          <target state="translated">WindowsError</target>
        </trans-unit>
        <trans-unit id="a20440ab3aefcfb4bb482ffec0fe5d04e27395bf" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; event loop, the &lt;em&gt;pipe&lt;/em&gt; is set to non-blocking mode.</source>
          <target state="translated">함께 &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; 의&lt;/a&gt; 이벤트 루프의 &lt;em&gt;관&lt;/em&gt; 비 차단 모드로 설정된다.</target>
        </trans-unit>
        <trans-unit id="c2504489b4771be876382108e6f7ae9120afc09b" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;, each caller is preceded by three numbers: the number of times this specific call was made, and the total and cumulative times spent in the current function while it was invoked by this specific caller.</source>
          <target state="translated">&lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 을&lt;/a&gt; 사용하면 각 호출자 앞에이 특정 호출이 발생한 횟수와이 특정 호출자가 호출 한 동안 현재 함수에 소요 된 총 및 누적 시간의 세 숫자가 앞에옵니다.</target>
        </trans-unit>
        <trans-unit id="d44b294510f145891db9e384bc38c4e88df7f7c7" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt;, a number is shown in parentheses after each caller to show how many times this specific call was made. For convenience, a second non-parenthesized number repeats the cumulative time spent in the function at the right.</source>
          <target state="translated">&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; 을&lt;/a&gt; 사용하면 각 호출자 다음에 괄호 안에 숫자가 표시되어이 특정 호출이 몇 번이나되었는지 표시됩니다. 편의를 위해 두 번째 괄호로 묶지 않은 숫자는 오른쪽 함수에서 소비 한 누적 시간을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="cab1487529e22885346d5098b46bd492a9089ff9" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt;&lt;code&gt;PureWindowsPath&lt;/code&gt;&lt;/a&gt;, return &lt;code&gt;True&lt;/code&gt; if the path is considered reserved under Windows, &lt;code&gt;False&lt;/code&gt; otherwise. With &lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt;&lt;code&gt;PurePosixPath&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;False&lt;/code&gt; is always returned.</source>
          <target state="translated">&lt;a href=&quot;#pathlib.PureWindowsPath&quot;&gt; &lt;code&gt;PureWindowsPath&lt;/code&gt; 를&lt;/a&gt; 사용 하여 경로가 Windows에서 예약 된 것으로 간주되면 &lt;code&gt;True&lt;/code&gt; 를 , &lt;code&gt;False&lt;/code&gt; 않으면 False를 리턴 하십시오 . 로 &lt;a href=&quot;#pathlib.PurePosixPath&quot;&gt; &lt;code&gt;PurePosixPath&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;False&lt;/code&gt; 항상 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3e771f57ddca6161f395e0eeba63e82d899e7d5f" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; it matters that you patch objects in the namespace where they are looked up. This is normally straightforward, but for a quick guide read &lt;a href=&quot;#where-to-patch&quot;&gt;where to patch&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하면 검색된 네임 스페이스에서 객체를 패치해야합니다. 이것은 일반적으로 간단하지만, 빠른 가이드 &lt;a href=&quot;#where-to-patch&quot;&gt;를 위해 패치 할 곳을&lt;/a&gt; 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="687dc08f377a2b328a8f70bc97535a43cc502f58" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;interpolation&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;, the parser would simply return &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; as the value of &lt;code&gt;my_pictures&lt;/code&gt; and &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; as the value of &lt;code&gt;my_dir&lt;/code&gt;.</source>
          <target state="translated">하여 &lt;code&gt;interpolation&lt;/code&gt; 에 집합 &lt;code&gt;None&lt;/code&gt; 파서 단순히 반환 &lt;code&gt;%(my_dir)s/Pictures&lt;/code&gt; 의 값으로 &lt;code&gt;my_pictures&lt;/code&gt; 및 &lt;code&gt;%(home_dir)s/lumberjack&lt;/code&gt; 의 값 &lt;code&gt;my_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15bc87ebe549a152d95621af5e9d7461b775788e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;mode='w'&lt;/code&gt;, a writable file handle is returned, which supports the &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method. While a writable file handle is open, attempting to read or write other files in the ZIP file will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">로 &lt;code&gt;mode='w'&lt;/code&gt; , 쓰기 가능한 파일 핸들이지지되는 반환 &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 방법. 쓰기 가능한 파일 핸들이 열려있는 동안 ZIP 파일에서 다른 파일을 읽거나 쓰려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fd7953113e258fb4a03370e957ae379b0c21dcb8" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt; you can specify which file mode will be passed to &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. It must be one of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rU'&lt;/code&gt;, &lt;code&gt;'U'&lt;/code&gt; and &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;mode&lt;/em&gt; 를 사용하면 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 전달할 파일 모드를 지정할 수 있습니다 . &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rU'&lt;/code&gt; , &lt;code&gt;'U'&lt;/code&gt; 및 &lt;code&gt;'rb'&lt;/code&gt; 중 하나 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="2da8c5473cf49716c34f3c81822b2920eb1d2993" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; the file-like object (&lt;code&gt;ZipExtFile&lt;/code&gt;) is read-only and provides the following methods: &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.seek&quot;&gt;&lt;code&gt;seek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.tell&quot;&gt;&lt;code&gt;tell()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt;. These objects can operate independently of the ZipFile.</source>
          <target state="translated">&lt;code&gt;'r'&lt;/code&gt; &lt;em&gt;모드를&lt;/em&gt; 사용 하면 파일과 유사한 객체 ( &lt;code&gt;ZipExtFile&lt;/code&gt; )는 읽기 전용이며 &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.seek&quot;&gt; &lt;code&gt;seek()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.tell&quot;&gt; &lt;code&gt;tell()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다 . 이러한 객체는 ZipFile과 독립적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379f83dca17684083b0f735691e8be9c7a53a82e" translate="yes" xml:space="preserve">
          <source>With &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; the file-like object (&lt;code&gt;ZipExtFile&lt;/code&gt;) is read-only and provides the following methods: &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;readlines()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.seek&quot;&gt;&lt;code&gt;seek()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.IOBase.tell&quot;&gt;&lt;code&gt;tell()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt;. These objects can operate independently of the ZipFile.</source>
          <target state="translated">&lt;code&gt;'r'&lt;/code&gt; &lt;em&gt;모드를&lt;/em&gt; 사용 하면 파일 류 객체 ( &lt;code&gt;ZipExtFile&lt;/code&gt; )는 읽기 전용이며 &lt;a href=&quot;io#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;readlines()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.seek&quot;&gt; &lt;code&gt;seek()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;io#io.IOBase.tell&quot;&gt; &lt;code&gt;tell()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메서드를 제공합니다. . 이러한 개체는 ZipFile과 독립적으로 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="760bad3e7ab6068220380f26094e6c0104a0a57d" translate="yes" xml:space="preserve">
          <source>With IDLE&amp;rsquo;s Shell, one enters, edits, and recalls complete statements. Most consoles and terminals only work with a single physical line at a time.</source>
          <target state="translated">IDLE의 Shell을 사용하면 완전한 진술을 입력, 편집 및 호출 할 수 있습니다. 대부분의 콘솔과 터미널은 한 번에 하나의 물리적 회선으로 만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c8624f48bb5849e7e5433618835e15f38bb647da" translate="yes" xml:space="preserve">
          <source>With SQLite versions before 3.6.5, &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt; is set to 0 if you make a &lt;code&gt;DELETE FROM table&lt;/code&gt; without any condition.</source>
          <target state="translated">3.6.5 이전의 SQLite 버전에서는 조건없이 &lt;code&gt;DELETE FROM table&lt;/code&gt; 을 만들면 &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt; 가 0으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ab21266758b5ede32eaf88e6036970613bdaaa" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;filename:lineno&lt;/em&gt; argument, clear all the breakpoints at this line. With a space separated list of breakpoint numbers, clear those breakpoints. Without argument, clear all breaks (but first ask confirmation).</source>
          <target state="translated">A의 &lt;em&gt;파일 이름 : LINENO의&lt;/em&gt; 인수,이 라인에서 모든 중단 점을 취소합니다. 공백으로 구분 된 중단 점 번호 목록을 사용하여 해당 중단 점을 지우십시오. 논증없이 모든 휴식 시간을 지 웁니다 (그러나 먼저 확인을 요청하십시오).</target>
        </trans-unit>
        <trans-unit id="2f04d9aa94fac16f17c271f8cc6b74f5e423a9cf" translate="yes" xml:space="preserve">
          <source>With a &lt;em&gt;lineno&lt;/em&gt; argument, set a break there in the current file. With a &lt;em&gt;function&lt;/em&gt; argument, set a break at the first executable statement within that function. The line number may be prefixed with a filename and a colon, to specify a breakpoint in another file (probably one that hasn&amp;rsquo;t been loaded yet). The file is searched on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;. Note that each breakpoint is assigned a number to which all the other breakpoint commands refer.</source>
          <target state="translated">A를 &lt;em&gt;LINENO의&lt;/em&gt; 인수, 현재 파일에 휴식이 설정합니다. &lt;em&gt;함수&lt;/em&gt; 인수를 사용하여 해당 함수 내 첫 번째 실행 문에서 구분을 설정하십시오. 줄 번호 앞에 파일 이름과 콜론을 붙여 다른 파일 (아마도 아직로드되지 않은)에 중단 점을 지정할 수 있습니다. 파일은 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에서&lt;/a&gt; 검색됩니다 . 각 중단 점에는 다른 모든 중단 점 명령이 참조하는 번호가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2644e40930b324401a9a51c3ee62d4106eb004ee" translate="yes" xml:space="preserve">
          <source>With a line number, continue execution until a line with a number greater or equal to that is reached. In both cases, also stop when the current frame returns.</source>
          <target state="translated">줄 번호를 사용하면 그보다 크거나 같은 줄에 도달 할 때까지 계속 실행하십시오. 두 경우 모두 현재 프레임이 반환되면 중지합니다.</target>
        </trans-unit>
        <trans-unit id="38ea4c11846bc3197c60dd6b0099e4ae33231ccb" translate="yes" xml:space="preserve">
          <source>With all of these &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt;&lt;code&gt;EmailPolicies&lt;/code&gt;&lt;/a&gt;, the effective API of the email package is changed from the Python 3.2 API in the following ways:</source>
          <target state="translated">이러한 모든 &lt;a href=&quot;#email.policy.EmailPolicy&quot;&gt; &lt;code&gt;EmailPolicies&lt;/code&gt; &lt;/a&gt; 를 사용하면 이메일 패키지의 유효 API가 다음과 같은 방식으로 Python 3.2 API에서 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b96c4be50c56eb883550373721c030d4e8832643" translate="yes" xml:space="preserve">
          <source>With all these new widgets, you can introduce new interaction techniques into applications, creating more useful and more intuitive user interfaces. You can design your application by choosing the most appropriate widgets to match the special needs of your application and users.</source>
          <target state="translated">이러한 모든 새로운 위젯을 사용하면 응용 프로그램에 새로운 상호 작용 기술을 도입하여보다 유용하고 직관적 인 사용자 인터페이스를 만들 수 있습니다. 애플리케이션과 사용자의 특수 요구에 맞는 가장 적합한 위젯을 선택하여 애플리케이션을 설계 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfb01d15923e2347d124cf6810b6f7bbee6f12aa" translate="yes" xml:space="preserve">
          <source>With an explicit &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; argument, the result is a byte string in the specified encoding. With no &lt;em&gt;encoding&lt;/em&gt; argument, the result is a Unicode string, and the XML declaration in the resulting string does not specify an encoding. Encoding this string in an encoding other than UTF-8 is likely incorrect, since UTF-8 is the default encoding of XML.</source>
          <target state="translated">명시 적 &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 인수를 사용하면 결과는 지정된 인코딩의 바이트 문자열입니다. &lt;em&gt;인코딩&lt;/em&gt; 인수가 없으면 결과는 유니 코드 문자열이며 결과 문자열의 XML 선언은 인코딩을 지정하지 않습니다. UTF-8이 XML의 기본 인코딩이므로 UTF-8 이외의 인코딩으로이 문자열을 인코딩하는 것은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4880d188a38217b2e5a2d31451fe8eadcea721e6" translate="yes" xml:space="preserve">
          <source>With arguments, return a list of values that result from looking up each argument in the configuration variable dictionary.</source>
          <target state="translated">인수를 사용하여 구성 변수 사전에서 각 인수를 찾은 결과 값 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="764867c8bff630b1f0ada90f3f9eb8f138801c7b" translate="yes" xml:space="preserve">
          <source>With filtering on, &lt;code&gt;dir(some_mock)&lt;/code&gt; shows only useful attributes and will include any dynamically created attributes that wouldn&amp;rsquo;t normally be shown. If the mock was created with a &lt;em&gt;spec&lt;/em&gt; (or &lt;em&gt;autospec&lt;/em&gt; of course) then all the attributes from the original are shown, even if they haven&amp;rsquo;t been accessed yet:</source>
          <target state="translated">필터링을 설정하면 &lt;code&gt;dir(some_mock)&lt;/code&gt; 은 유용한 속성 만 표시하며 일반적으로 표시되지 않는 동적으로 생성 된 속성을 포함합니다. 모의가 &lt;em&gt;스펙&lt;/em&gt; (또는 &lt;em&gt;자동 &lt;/em&gt;&lt;em&gt;스펙)&lt;/em&gt; 으로 작성된 경우, 아직 액세스하지 않은 경우에도 원본의 모든 속성이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="aab53d4374bfcc2a7d9f8f2e07cc334e9b8d4ebe" translate="yes" xml:space="preserve">
          <source>With no &lt;em&gt;bpnumber&lt;/em&gt; argument, &lt;code&gt;commands&lt;/code&gt; refers to the last breakpoint set.</source>
          <target state="translated">&lt;em&gt;bpnumber&lt;/em&gt; 인수가 없으면 &lt;code&gt;commands&lt;/code&gt; 은 마지막 중단 점 세트를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a0d7fd252a8ac0acd7b9c9b4e24a97bf47857d8f" translate="yes" xml:space="preserve">
          <source>With no arguments, return a dictionary of all configuration variables relevant for the current platform.</source>
          <target state="translated">인수없이, 현재 플랫폼과 관련된 모든 구성 변수의 사전을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="efd89a071ec612fcc528b4ebb7e35378e6acc199" translate="yes" xml:space="preserve">
          <source>With no arguments, run a full collection. The optional argument &lt;em&gt;generation&lt;/em&gt; may be an integer specifying which generation to collect (from 0 to 2). A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if the generation number is invalid. The number of unreachable objects found is returned.</source>
          <target state="translated">인수없이 전체 컬렉션을 실행하십시오. 선택적 인수 &lt;em&gt;생성&lt;/em&gt; 은 수집 할 생성을 지정하는 정수일 수 있습니다 (0에서 2까지). &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 생성 번호가 무효 인 경우 발생합니다. 찾을 수없는 개체의 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ed5301520b7fd396ab2dfe6409c5f533e884e4c5" translate="yes" xml:space="preserve">
          <source>With one argument, return the natural logarithm of &lt;em&gt;x&lt;/em&gt; (to base &lt;em&gt;e&lt;/em&gt;).</source>
          <target state="translated">하나의 인수로 &lt;em&gt;x&lt;/em&gt; 의 자연 로그 ( &lt;em&gt;e&lt;/em&gt; 를 밑으로 ) 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="b5717389f2b0fe33f8fc1d55c281454fe06d5e2b" translate="yes" xml:space="preserve">
          <source>With one argument, return the type of an &lt;em&gt;object&lt;/em&gt;. The return value is a type object and generally the same object as returned by &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt;&lt;code&gt;object.__class__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하나의 인수로 &lt;em&gt;객체&lt;/em&gt; 의 유형을 반환 &lt;em&gt;합니다&lt;/em&gt; . 리턴 값은 유형 오브젝트이며 일반적으로 &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt; &lt;code&gt;object.__class__&lt;/code&gt; &lt;/a&gt; 리턴 한 것과 동일한 오브젝트 입니다.</target>
        </trans-unit>
        <trans-unit id="3010b34325387d6e0374de77099e8677662b587d" translate="yes" xml:space="preserve">
          <source>With one argument, returns a dictionary of column/value pairs for the specified &lt;em&gt;item&lt;/em&gt;. With two arguments, returns the current value of the specified &lt;em&gt;column&lt;/em&gt;. With three arguments, sets the value of given &lt;em&gt;column&lt;/em&gt; in given &lt;em&gt;item&lt;/em&gt; to the specified &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">하나의 인수로 지정된 &lt;em&gt;item에&lt;/em&gt; 대한 열 / 값 쌍 사전을 리턴합니다 . 두 개의 인수를 사용하면 지정된 &lt;em&gt;column&lt;/em&gt; 의 현재 값을 반환합니다 . 세 인수로 주어진 값으로 설정 &lt;em&gt;열의&lt;/em&gt; 소정의 &lt;em&gt;항목에&lt;/em&gt; 지정된 행 &lt;em&gt;값&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f254b557ac83471d6ca20286be89daa2ca79428b" translate="yes" xml:space="preserve">
          <source>With optional argument &lt;em&gt;i&lt;/em&gt;, &lt;a href=&quot;#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; will return the &lt;em&gt;i&lt;/em&gt;-th element of the payload, counting from zero, if &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. An &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is less than 0 or greater than or equal to the number of items in the payload. If the payload is a string (i.e. &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;) and &lt;em&gt;i&lt;/em&gt; is given, a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">선택적 인수로 &lt;em&gt;난&lt;/em&gt; , &lt;a href=&quot;#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 반환됩니다 &lt;em&gt;난&lt;/em&gt; 경우, 0에서 페이로드, 계산의 번째 요소를 &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;True&lt;/code&gt; . &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; 는&lt;/a&gt; 경우 발생한다 &lt;em&gt;제가&lt;/em&gt; 0보다 작거나 또는보다 큰 페이로드의 항목 수와 같다. 페이로드가 문자열이고 (즉, &lt;a href=&quot;#email.message.Message.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; is &lt;code&gt;False&lt;/code&gt; ) &lt;em&gt;i&lt;/em&gt; 가 제공되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95cfd380016562aed86b66b762be2eb99843bf08" translate="yes" xml:space="preserve">
          <source>With pickle protocol version 4 it is possible to easily pickle enums nested in other classes.</source>
          <target state="translated">피클 프로토콜 버전 4를 사용하면 다른 클래스에 중첩 된 열거 형을 쉽게 피클 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1839f1bd0fed63c796608b36a191d7890a7fee" translate="yes" xml:space="preserve">
          <source>With rare exceptions, the result of executing Python code with IDLE is intended to be the same as executing the same code by the default method, directly with Python in a text-mode system console or terminal window. However, the different interface and operation occasionally affect visible results. For instance, &lt;code&gt;sys.modules&lt;/code&gt; starts with more entries, and &lt;code&gt;threading.activeCount()&lt;/code&gt; returns 2 instead of 1.</source>
          <target state="translated">드문 경우를 제외하고 IDLE을 사용하여 Python 코드를 실행 한 결과는 텍스트 모드 시스템 콘솔 또는 터미널 창에서 Python을 사용하여 기본 방법으로 동일한 코드를 실행하는 것과 동일합니다. 그러나 다른 인터페이스와 작업은 때때로 가시적 인 결과에 영향을줍니다. 예를 들어 &lt;code&gt;sys.modules&lt;/code&gt; 는 더 많은 항목으로 시작하고 &lt;code&gt;threading.activeCount()&lt;/code&gt; 는 1 대신 2를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0015f869c31b401bfecbb86dbfba0c4047c9bd7" translate="yes" xml:space="preserve">
          <source>With server socket, this mode provides mandatory TLS client cert authentication. A client certificate request is sent to the client and the client must provide a valid and trusted certificate.</source>
          <target state="translated">서버 소켓을 사용하면이 모드는 필수 TLS 클라이언트 인증서 인증을 제공합니다. 클라이언트 인증서 요청이 클라이언트로 전송되고 클라이언트는 유효하고 신뢰할 수있는 인증서를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d44fbe6e65b12b51b031a5cae9513730c1dc7435" translate="yes" xml:space="preserve">
          <source>With sufficient knowledge of applicable algorithmic and political time adjustments, such as time zone and daylight saving time information, an &lt;strong&gt;aware&lt;/strong&gt; object can locate itself relative to other aware objects. An aware object represents a specific moment in time that is not open to interpretation. &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">시간대 및 일광 절약 시간제 정보와 같은 적용 가능한 알고리즘 및 정치적 시간 조정에 대한 충분한 지식이 있으면 &lt;strong&gt;인식&lt;/strong&gt; 대상은 다른 인식 대상에 상대적으로 위치 할 수 있습니다. 인식 객체는 해석 할 수없는 특정 시점을 나타냅니다. &lt;a href=&quot;#id5&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="deac18952e93d68efd06227e703e6bf5a3115b23" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;'store_const'&lt;/code&gt; and &lt;code&gt;'append_const'&lt;/code&gt; actions, the &lt;code&gt;const&lt;/code&gt; keyword argument must be given. For other actions, it defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;code&gt;'store_const'&lt;/code&gt; 와 &lt;code&gt;'append_const'&lt;/code&gt; 행동의 &lt;code&gt;const&lt;/code&gt; 키워드 인수를 제공해야합니다. 다른 조치의 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="194119009270c68f60a1104e8b4240dd2ceaff94" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;False&lt;/code&gt;, the method call does not block. If the lock is currently in a locked state, return &lt;code&gt;False&lt;/code&gt;; otherwise set the lock to a locked state and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">으로 &lt;em&gt;블록&lt;/em&gt; 에 인수 세트 &lt;code&gt;False&lt;/code&gt; , 메서드 호출이 차단되지 않습니다. 잠금이 현재 잠금 상태 인 경우 &lt;code&gt;False&lt;/code&gt; 를 리턴하십시오 . 그렇지 않으면 잠금을 잠금 상태로 설정하고 &lt;code&gt;True&lt;/code&gt; 를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e871eb88b98ae8c67b374e93e1e89a7c0c7dcd5" translate="yes" xml:space="preserve">
          <source>With the &lt;em&gt;block&lt;/em&gt; argument set to &lt;code&gt;True&lt;/code&gt; (the default), the method call will block until the lock is in an unlocked state, then set it to locked and return &lt;code&gt;True&lt;/code&gt;. Note that the name of this first argument differs from that in &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt;&lt;code&gt;threading.Lock.acquire()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">으로 &lt;em&gt;블록&lt;/em&gt; 에 인수 세트 &lt;code&gt;True&lt;/code&gt; (기본), 메소드 호출은 잠금이 해제 상태가 될 때까지, 다음 잠금으로 설정하고 반환 차단합니다 &lt;code&gt;True&lt;/code&gt; . 이 첫 번째 인수의 이름은 &lt;a href=&quot;threading#threading.Lock.acquire&quot;&gt; &lt;code&gt;threading.Lock.acquire()&lt;/code&gt; &lt;/a&gt; 의 이름과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2269bdd62541838f898684dcd5142d85924bfe48" translate="yes" xml:space="preserve">
          <source>With the subsequent code object one can execute it in a module by running &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt;.</source>
          <target state="translated">후속 코드 객체를 사용하면 &lt;code&gt;exec(code, module.__dict__)&lt;/code&gt; 를 실행하여 모듈에서 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebbacdcf56db793c4cc45ee8691bf7b6605ec5c1" translate="yes" xml:space="preserve">
          <source>With this pattern, multiple factories could be chained, and as long as they don&amp;rsquo;t overwrite each other&amp;rsquo;s attributes or unintentionally overwrite the standard attributes listed above, there should be no surprises.</source>
          <target state="translated">이 패턴을 사용하면 여러 팩토리를 체인화 할 수 있으며 서로의 속성을 덮어 쓰지 않거나 위에 나열된 표준 속성을 실수로 덮어 쓰지 않는 한 놀랄 일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="40a6ba4daa5a2342ad82ea7038d0c1a705a07197" translate="yes" xml:space="preserve">
          <source>With three arguments, compute &lt;code&gt;(x**y) % modulo&lt;/code&gt;. For the three argument form, the following restrictions on the arguments hold:</source>
          <target state="translated">세 개의 인수를 사용하여 &lt;code&gt;(x**y) % modulo&lt;/code&gt; . 세 가지 인수 형식의 경우 다음과 같은 인수 제한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fab22f970395c672be8c4c452402f6883149c6e" translate="yes" xml:space="preserve">
          <source>With three arguments, return a new type object. This is essentially a dynamic form of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; statement. The &lt;em&gt;name&lt;/em&gt; string is the class name and becomes the &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; attribute; the &lt;em&gt;bases&lt;/em&gt; tuple itemizes the base classes and becomes the &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt;&lt;code&gt;__bases__&lt;/code&gt;&lt;/a&gt; attribute; and the &lt;em&gt;dict&lt;/em&gt; dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. For example, the following two statements create identical &lt;a href=&quot;#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">세 개의 인수를 사용하여 새 유형 객체를 반환하십시오. 이것은 본질적으로 동적 인 형태의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt; 진술이다. &lt;em&gt;이름&lt;/em&gt; 문자열은 클래스 이름이며,이된다 &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; 의&lt;/a&gt; 속성; &lt;em&gt;염기&lt;/em&gt; 기본 클래스를 항목별로 상기 튜플된다 &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt; &lt;code&gt;__bases__&lt;/code&gt; 의&lt;/a&gt; 특성; 그리고 &lt;em&gt;DICT의&lt;/em&gt; 사전 클래스 본문에 대한 정의를 포함하는 네임 스페이스와되기 위해 표준 사전에 복사 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; 의&lt;/a&gt; 속성. 예를 들어, 다음 두 명령문은 동일한 &lt;a href=&quot;#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 오브젝트를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="fa3a7fb3b8e9ab7d2857a7405a359bd983f4cf63" translate="yes" xml:space="preserve">
          <source>With three arguments, return a new type object. This is essentially a dynamic form of the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#class&quot;&gt;&lt;code&gt;class&lt;/code&gt;&lt;/a&gt; statement. The &lt;em&gt;name&lt;/em&gt; string is the class name and becomes the &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt;&lt;code&gt;__name__&lt;/code&gt;&lt;/a&gt; attribute; the &lt;em&gt;bases&lt;/em&gt; tuple itemizes the base classes and becomes the &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt;&lt;code&gt;__bases__&lt;/code&gt;&lt;/a&gt; attribute; and the &lt;em&gt;dict&lt;/em&gt; dictionary is the namespace containing definitions for class body and is copied to a standard dictionary to become the &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. For example, the following two statements create identical &lt;a href=&quot;#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects:</source>
          <target state="translated">세 개의 인수를 사용하여 새 유형 객체를 반환합니다. 이것은 본질적으로 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#class&quot;&gt; &lt;code&gt;class&lt;/code&gt; &lt;/a&gt; 문의 동적 형식입니다 . &lt;em&gt;이름&lt;/em&gt; 문자열은 클래스 이름이며,이된다 &lt;a href=&quot;stdtypes#definition.__name__&quot;&gt; &lt;code&gt;__name__&lt;/code&gt; 의&lt;/a&gt; 속성; &lt;em&gt;염기&lt;/em&gt; 기본 클래스를 항목별로 상기 튜플된다 &lt;a href=&quot;stdtypes#class.__bases__&quot;&gt; &lt;code&gt;__bases__&lt;/code&gt; 의&lt;/a&gt; 특성; 그리고 &lt;em&gt;dict&lt;/em&gt; 사전은 클래스 본문에 대한 정의를 포함하는 네임 스페이스이며 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성 이되기 위해 표준 사전에 복사됩니다 . 예를 들어, 다음 두 문은 동일한 &lt;a href=&quot;#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 객체를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="f8885c6119b55f6917eee9f2b9372898c8263a3e" translate="yes" xml:space="preserve">
          <source>With two arguments, compute &lt;code&gt;x**y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is negative then &lt;code&gt;y&lt;/code&gt; must be integral. The result will be inexact unless &lt;code&gt;y&lt;/code&gt; is integral and the result is finite and can be expressed exactly in &amp;lsquo;precision&amp;rsquo; digits. The rounding mode of the context is used. Results are always correctly-rounded in the Python version.</source>
          <target state="translated">두 개의 인수로 &lt;code&gt;x**y&lt;/code&gt; 계산하십시오 . 경우 &lt;code&gt;x&lt;/code&gt; 음수 후 &lt;code&gt;y&lt;/code&gt; 정수이어야한다. &lt;code&gt;y&lt;/code&gt; 가 정수이고 결과가 유한 하지 않고 정확하게 '정밀'숫자로 표현 될 수 없으면 결과는 정확하지 않습니다 . 컨텍스트의 반올림 모드가 사용됩니다. 파이썬 버전에서는 항상 결과가 올바로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="b43cb0e0aa8bf5b547ad83f94e989da6ff98d438" translate="yes" xml:space="preserve">
          <source>With two arguments, return the logarithm of &lt;em&gt;x&lt;/em&gt; to the given &lt;em&gt;base&lt;/em&gt;, calculated as &lt;code&gt;log(x)/log(base)&lt;/code&gt;.</source>
          <target state="translated">두 개의 인수 를 사용하여 &lt;code&gt;log(x)/log(base)&lt;/code&gt; 로 계산 된 &lt;em&gt;x&lt;/em&gt; 의 로그를 주어진 &lt;em&gt;base&lt;/em&gt; 로 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="00a50c0d900159dbcd62b43debe7309bd2b37fad" translate="yes" xml:space="preserve">
          <source>With version 1 (provided for reproducing random sequences from older versions of Python), the algorithm for &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; generates a narrower range of seeds.</source>
          <target state="translated">버전 1 (이전 버전의 Python에서 임의의 시퀀스를 재생하기 위해 제공됨)을 사용하면 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 알고리즘 이 더 좁은 범위의 시드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b20bd639ded266fcc391752e271e39a98c7700d3" translate="yes" xml:space="preserve">
          <source>With version 2 (the default), a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; object gets converted to an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; and all of its bits are used.</source>
          <target state="translated">버전 2 (기본값)를 사용하면 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 객체가 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 로 변환 되고 모든 비트가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec63c85650e7ada817c79ea880456525b435a75" translate="yes" xml:space="preserve">
          <source>With versions of OpenSSL older than 0.9.8m, it is only possible to set options, not to clear them. Attempting to clear an option (by resetting the corresponding bits) will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">0.9.8m 이전의 OpenSSL 버전에서는 옵션을 지우지 않고 설정할 수 있습니다. 해당 비트를 재설정하여 옵션을 지우려고하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6887de87bb8914463818ce0668d423fe277ff788" translate="yes" xml:space="preserve">
          <source>Within an editor window containing Python code, code context can be toggled in order to show or hide a pane at the top of the window. When shown, this pane freezes the opening lines for block code, such as those beginning with &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;def&lt;/code&gt;, or &lt;code&gt;if&lt;/code&gt; keywords, that would have otherwise scrolled out of view. The size of the pane will be expanded and contracted as needed to show the all current levels of context, up to the maximum number of lines defined in the Configure IDLE dialog (which defaults to 15). If there are no current context lines and the feature is toggled on, a single blank line will display. Clicking on a line in the context pane will move that line to the top of the editor.</source>
          <target state="translated">Python 코드가 포함 된 편집기 창 내에서 창의 상단에 창을 표시하거나 숨기려면 코드 컨텍스트를 토글 할 수 있습니다. 표시 할 때,이 창은로 시작하는 것과 같은 블록 코드의 오프닝 라인, 정지 &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;def&lt;/code&gt; , 또는 &lt;code&gt;if&lt;/code&gt; 그렇지 않으면보기 밖으로 스크롤했을 그 키워드를. 분할 창의 크기는 모든 현재 컨텍스트 레벨을 표시하기 위해 필요에 따라 확장 및 축소되며 IDLE 구성 대화 상자에 정의 된 최대 줄 수 (기본값은 15)입니다. 현재 상황에 맞는 줄이없고 기능이 설정되어 있으면 빈 줄 하나가 표시됩니다. 상황에 맞는 창에서 행을 클릭하면 해당 행이 편집기 맨 위로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="2f8b057e4c0feacb665a8a7757beb8aa22e2fdde" translate="yes" xml:space="preserve">
          <source>Without an argument, &lt;a href=&quot;#vars&quot;&gt;&lt;code&gt;vars()&lt;/code&gt;&lt;/a&gt; acts like &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt;. Note, the locals dictionary is only useful for reads since updates to the locals dictionary are ignored.</source>
          <target state="translated">인수가 없으면 &lt;a href=&quot;#vars&quot;&gt; &lt;code&gt;vars()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 처럼 작동 합니다. 지역 사전에 대한 업데이트는 무시되므로 지역 사전은 읽기에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89afaf5902230f11dab6931656e83d660578a26d" translate="yes" xml:space="preserve">
          <source>Without an argument, an array of size 0 is created.</source>
          <target state="translated">인수가 없으면 크기가 0 인 배열이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="9879a08d72136016023f63f62288fdbd06d5e766" translate="yes" xml:space="preserve">
          <source>Without any optional argument, this method acquires the lock unconditionally, if necessary waiting until it is released by another thread (only one thread at a time can acquire a lock &amp;mdash; that&amp;rsquo;s their reason for existence).</source>
          <target state="translated">선택적인 인수가 없으면이 메소드는 필요에 따라 다른 스레드에 의해 해제 될 때까지 대기하는 동안 무조건 잠금을 획득합니다 (한 번에 하나의 스레드 만 잠금을 획득 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="eb98828bb03ebff04d92f1d4995a6a336ce35b0c" translate="yes" xml:space="preserve">
          <source>Without argument, continue execution until the line with a number greater than the current one is reached.</source>
          <target state="translated">인수가 없으면 현재 행보다 큰 행에 도달 할 때까지 실행을 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="c89138ed071a0b6e27259e35980ae9555134901d" translate="yes" xml:space="preserve">
          <source>Without argument, list all breaks, including for each breakpoint, the number of times that breakpoint has been hit, the current ignore count, and the associated condition if any.</source>
          <target state="translated">인수없이 각 중단 점, 중단 점에 도달 한 횟수, 현재 무시 횟수 및 연관된 조건이있는 경우를 포함하여 모든 중단을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="5eeedd2237cda7b0eb8c9cc1a204ca22979c1c18" translate="yes" xml:space="preserve">
          <source>Without argument, print the list of available commands. With a &lt;em&gt;command&lt;/em&gt; as argument, print help about that command. &lt;code&gt;help pdb&lt;/code&gt; displays the full documentation (the docstring of the &lt;a href=&quot;#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module). Since the &lt;em&gt;command&lt;/em&gt; argument must be an identifier, &lt;code&gt;help exec&lt;/code&gt; must be entered to get help on the &lt;code&gt;!&lt;/code&gt; command.</source>
          <target state="translated">인수없이 사용 가능한 명령 목록을 인쇄하십시오. &lt;em&gt;명령&lt;/em&gt; 을 인수로 사용하여 해당 명령에 대한 도움말을 인쇄하십시오. &lt;code&gt;help pdb&lt;/code&gt; 는 전체 문서 ( &lt;a href=&quot;#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 모듈 의 docstring)를 표시합니다 . 때문에 &lt;em&gt;명령&lt;/em&gt; 인수가 식별자 여야합니다, &lt;code&gt;help exec&lt;/code&gt; 상의 도움을받을 수를 입력해야합니다 &lt;code&gt;!&lt;/code&gt; 명령.</target>
        </trans-unit>
        <trans-unit id="77f66cab56a49a5274a00828711f0d39b63586e1" translate="yes" xml:space="preserve">
          <source>Without arguments, return the list of names in the current local scope. With an argument, attempt to return a list of valid attributes for that object.</source>
          <target state="translated">인수가 없으면 현재 로컬 범위의 이름 목록을 반환하십시오. 인수를 사용하여 해당 오브젝트에 유효한 속성 목록을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="769b9bb5176bd30fc5c9a906deb72757797c5114" translate="yes" xml:space="preserve">
          <source>Without expression, list all display expressions for the current frame.</source>
          <target state="translated">표현식없이 현재 프레임에 대한 모든 표시 표현식을 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="f094cebe8a845676c5da8b2f31cd1951b0afca42" translate="yes" xml:space="preserve">
          <source>Without external information it&amp;rsquo;s impossible to reliably determine which encoding was used for encoding a string. Each charmap encoding can decode any random byte sequence. However that&amp;rsquo;s not possible with UTF-8, as UTF-8 byte sequences have a structure that doesn&amp;rsquo;t allow arbitrary byte sequences. To increase the reliability with which a UTF-8 encoding can be detected, Microsoft invented a variant of UTF-8 (that Python 2.5 calls &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt;) for its Notepad program: Before any of the Unicode characters is written to the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: &lt;code&gt;0xef&lt;/code&gt;, &lt;code&gt;0xbb&lt;/code&gt;, &lt;code&gt;0xbf&lt;/code&gt;) is written. As it&amp;rsquo;s rather improbable that any charmap encoded file starts with these byte values (which would e.g. map to</source>
          <target state="translated">외부 정보가 없으면 문자열 인코딩에 사용 된 인코딩을 확실하게 확인할 수 없습니다. 각 charmap 인코딩은 임의의 바이트 시퀀스를 디코딩 할 수 있습니다. 그러나 UTF-8 바이트 시퀀스에는 임의의 바이트 시퀀스를 허용하지 않는 구조가 있으므로 UTF-8에서는 불가능합니다. UTF-8 인코딩을 감지 할 수있는 안정성을 높이기 위해 Microsoft 는 메모장 프로그램에 대해 UTF-8 (Python 2.5에서 &lt;code&gt;&quot;utf-8-sig&quot;&lt;/code&gt; 라고 함 ) 변형을 개발했습니다 . 유니 코드 문자를 쓰기 전에 UTF-8로 인코딩 된 BOM (바이트 시퀀스 : &lt;code&gt;0xef&lt;/code&gt; , &lt;code&gt;0xbb&lt;/code&gt; , &lt;code&gt;0xbf&lt;/code&gt; 으로 보이는 파일 )이 작성됩니다. 모든 charmap 인코딩 파일이 이러한 바이트 값으로 시작한다는 것은 다소 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="7849a7a1c3473cfd49dc9807cf4c861c767d29df" translate="yes" xml:space="preserve">
          <source>Without the directive it would fail, both because the actual output doesn&amp;rsquo;t have two blanks before the single-digit list elements, and because the actual output is on a single line. This test also passes, and also requires a directive to do so:</source>
          <target state="translated">지시문이 없으면 실제 출력에 한 자리 목록 요소 앞에 두 개의 공백이없고 실제 출력이 한 줄에 있기 때문에 실패합니다. 이 테스트는 또한 통과하며 지시문이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b56f8f7059663881528e5f04cc607dbf57d02130" translate="yes" xml:space="preserve">
          <source>Without the use of this decorator factory, the name of the example function would have been &lt;code&gt;'wrapper'&lt;/code&gt;, and the docstring of the original &lt;code&gt;example()&lt;/code&gt; would have been lost.</source>
          <target state="translated">이 데코레이터 팩토리를 사용하지 않으면 예제 함수의 이름은 &lt;code&gt;'wrapper'&lt;/code&gt; 였고 원래 &lt;code&gt;example()&lt;/code&gt; 의 docstring은 손실되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7fe2fe1baf1ec16cf5ceba69d9460d06d020a49" translate="yes" xml:space="preserve">
          <source>Without using a subtest, execution would stop after the first failure, and the error would be less easy to diagnose because the value of &lt;code&gt;i&lt;/code&gt; wouldn&amp;rsquo;t be displayed:</source>
          <target state="translated">하위 테스트를 사용하지 않으면 첫 번째 실패 후 실행이 중지되며 &lt;code&gt;i&lt;/code&gt; 값 이 표시되지 않으므로 오류를 진단하기가 쉽지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5ea2ab24d7c35c5430a569d407bd85c65f4e85bc" translate="yes" xml:space="preserve">
          <source>Without using the lock output from the different processes is liable to get all mixed up.</source>
          <target state="translated">다른 프로세스의 잠금 출력을 사용하지 않으면 모든 것이 섞일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27c0f0558f8802b19cb669e94d2076c0c6c0fda" translate="yes" xml:space="preserve">
          <source>Worker processes within a &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; typically live for the complete duration of the Pool&amp;rsquo;s work queue. A frequent pattern found in other systems (such as Apache, mod_wsgi, etc) to free resources held by workers is to allow a worker within a pool to complete only a set amount of work before being exiting, being cleaned up and a new process spawned to replace the old one. The &lt;em&gt;maxtasksperchild&lt;/em&gt; argument to the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; exposes this ability to the end user.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 내의 작업자 프로세스는 일반적으로 풀 작업 대기열의 전체 기간 동안 존재합니다. 작업자가 보유한 자원을 확보하기 위해 다른 시스템 (예 : Apache, mod_wsgi 등)에서 발견되는 빈번한 패턴은 풀 내의 작업자가 종료, 정리 및 새 프로세스 생성 전에 정해진 양의 작업 만 완료하도록 허용하는 것입니다. 이전 것을 교체하십시오. &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 대한 &lt;em&gt;maxtasksperchild&lt;/em&gt; 인수 는이 기능을 최종 사용자에게 노출합니다.</target>
        </trans-unit>
        <trans-unit id="89015cfdb27fab11c50f80e1f354316ca91c613f" translate="yes" xml:space="preserve">
          <source>Working with pipes</source>
          <target state="translated">파이프 작업</target>
        </trans-unit>
        <trans-unit id="8bae363ed38dab1b6d087a54fbbd4f84ed78b18a" translate="yes" xml:space="preserve">
          <source>Working with socket objects directly</source>
          <target state="translated">소켓 객체로 직접 작업</target>
        </trans-unit>
        <trans-unit id="9d6d7f52d1d150a89cde4bda127b7602fe0e15d9" translate="yes" xml:space="preserve">
          <source>Working with threads</source>
          <target state="translated">스레드 작업</target>
        </trans-unit>
        <trans-unit id="67bb3765ae259f479c80ae46b7c05de23c1886aa" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a list.</source>
          <target state="translated">&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 목록을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fb8fe5d39fb592372defca4a7c0cdd14adfc931a" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt;&lt;code&gt;BUILD_TUPLE&lt;/code&gt;&lt;/a&gt;, but creates a set.</source>
          <target state="translated">&lt;a href=&quot;#opcode-BUILD_TUPLE&quot;&gt; &lt;code&gt;BUILD_TUPLE&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 세트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="2e4b35ffa278b6b960046684c3fd2fa34208fe21" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt;&lt;code&gt;DELETE_NAME&lt;/code&gt;&lt;/a&gt;, but deletes a global name.</source>
          <target state="translated">&lt;a href=&quot;#opcode-DELETE_NAME&quot;&gt; &lt;code&gt;DELETE_NAME&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 전체 이름을 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="9391eb2e809296019b9e1392d2df6abc88491766" translate="yes" xml:space="preserve">
          <source>Works as &lt;a href=&quot;#opcode-STORE_NAME&quot;&gt;&lt;code&gt;STORE_NAME&lt;/code&gt;&lt;/a&gt;, but stores the name as a global.</source>
          <target state="translated">&lt;a href=&quot;#opcode-STORE_NAME&quot;&gt; &lt;code&gt;STORE_NAME&lt;/code&gt; 으로&lt;/a&gt; 작동 하지만 이름을 전역으로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f9b523701c081148b44a5e161316a03f46215499" translate="yes" xml:space="preserve">
          <source>Works like &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt; except that the input to the &lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt;&lt;code&gt;feed()&lt;/code&gt;&lt;/a&gt; method must be a string. This is of limited utility, since the only way for such a message to be valid is for it to contain only ASCII text or, if &lt;code&gt;utf8&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, no binary attachments.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesFeedParser.feed&quot;&gt; &lt;code&gt;feed()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 입력 이 문자열이어야 &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; &lt;/a&gt; 점을 제외하면 BytesFeedParser 와 유사하게 작동 합니다. 이러한 메시지가 유효한 유일한 방법은 ASCII 텍스트 만 포함하거나 &lt;code&gt;utf8&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 이면 이진 첨부 파일이없는 것이므로 유틸리티의 기능이 제한적 입니다.</target>
        </trans-unit>
        <trans-unit id="185db21e361257c180478865bbb0efa3b0737049" translate="yes" xml:space="preserve">
          <source>Works the same way as &lt;a href=&quot;#inspect.Signature.bind&quot;&gt;&lt;code&gt;Signature.bind()&lt;/code&gt;&lt;/a&gt;, but allows the omission of some required arguments (mimics &lt;a href=&quot;functools#functools.partial&quot;&gt;&lt;code&gt;functools.partial()&lt;/code&gt;&lt;/a&gt; behavior.) Returns &lt;a href=&quot;#inspect.BoundArguments&quot;&gt;&lt;code&gt;BoundArguments&lt;/code&gt;&lt;/a&gt;, or raises a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if the passed arguments do not match the signature.</source>
          <target state="translated">&lt;a href=&quot;#inspect.Signature.bind&quot;&gt; &lt;code&gt;Signature.bind()&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 작동 하지만 일부 필수 인수 (mimics &lt;a href=&quot;functools#functools.partial&quot;&gt; &lt;code&gt;functools.partial()&lt;/code&gt; &lt;/a&gt; 동작 )를 생략 할 수 있습니다. &lt;a href=&quot;#inspect.BoundArguments&quot;&gt; &lt;code&gt;BoundArguments&lt;/code&gt; 를&lt;/a&gt; 반환 하거나 전달 된 인수가 서명과 일치하지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e1783e364fda74448269ebe2d7f239fb3ef7f871" translate="yes" xml:space="preserve">
          <source>Wrap &lt;em&gt;application&lt;/em&gt; and return a new WSGI application object. The returned application will forward all requests to the original &lt;em&gt;application&lt;/em&gt;, and will check that both the &lt;em&gt;application&lt;/em&gt; and the server invoking it are conforming to the WSGI specification and to &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;애플리케이션을&lt;/em&gt; 랩핑 하고 새 WSGI 애플리케이션 오브젝트를 리턴하십시오. 리턴 된 애플리케이션은 모든 요청을 원래 &lt;em&gt;애플리케이션&lt;/em&gt; 으로 전달하고 이를 호출 하는 &lt;em&gt;애플리케이션&lt;/em&gt; 과 서버가 WSGI 스펙 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt; 을 준수하는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="50ddf4360a796894dae0f6d5a9d4445df2e11d56" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt;&lt;code&gt;concurrent.futures.Future&lt;/code&gt;&lt;/a&gt; object in a &lt;a href=&quot;#asyncio.Future&quot;&gt;&lt;code&gt;asyncio.Future&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">랩 &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt; &lt;code&gt;concurrent.futures.Future&lt;/code&gt; 의&lt;/a&gt; A의 객체를 &lt;a href=&quot;#asyncio.Future&quot;&gt; &lt;code&gt;asyncio.Future&lt;/code&gt; 의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2b27f3224dafe97e6c0b3e8a8fa06d53cea4dc76" translate="yes" xml:space="preserve">
          <source>Wrap a &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 감싸십시오 .</target>
        </trans-unit>
        <trans-unit id="c612d6e5f7981ee986eea5813673351e3cb45b2c" translate="yes" xml:space="preserve">
          <source>Wrap a read end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">파이프의 읽기 끝을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="ff3306add2272df4e9ce3ccf3f316e30e699743f" translate="yes" xml:space="preserve">
          <source>Wrap a write end of a pipe into a &lt;code&gt;(transport, protocol)&lt;/code&gt; pair.</source>
          <target state="translated">파이프의 쓰기 끝을 &lt;code&gt;(transport, protocol)&lt;/code&gt; 쌍 으로 랩핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="b76b940bb5be2bb8e2a70d99685e901b66b64693" translate="yes" xml:space="preserve">
          <source>Wrap an already accepted connection into a transport/protocol pair.</source>
          <target state="translated">이미 승인 된 연결을 전송 / 프로토콜 쌍으로 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="6a18c9e5ad1f9bbb6b629543bc34a3ee5302486a" translate="yes" xml:space="preserve">
          <source>Wrap an existing Python socket &lt;em&gt;sock&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt;&lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;). The returned SSL socket is tied to the context, its settings and certificates. &lt;em&gt;sock&lt;/em&gt; must be a &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; socket; other socket types are unsupported.</source>
          <target state="translated">기존 Python 소켓 &lt;em&gt;양말을&lt;/em&gt; 감싸고 &lt;a href=&quot;#ssl.SSLContext.sslsocket_class&quot;&gt; &lt;code&gt;SSLContext.sslsocket_class&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하십시오 (기본 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; ). 반환 된 SSL 소켓은 컨텍스트, 설정 및 인증서에 연결됩니다. &lt;em&gt;양말&lt;/em&gt; 은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 소켓 이어야합니다 . 다른 소켓 유형은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0016efeeb31ae253fc49cf82049e6b29fd8ba856" translate="yes" xml:space="preserve">
          <source>Wrap the &lt;em&gt;coro&lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;coroutine&lt;/a&gt; into a &lt;a href=&quot;#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; and schedule its execution. Return the Task object.</source>
          <target state="translated">&lt;em&gt;코로 &lt;/em&gt;&lt;a href=&quot;#coroutine&quot;&gt;코 루틴&lt;/a&gt; 을 &lt;a href=&quot;#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 싸서 실행을 예약합니다. Task 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f98244aacb2a997c25507ffd260f55a5828e5faa" translate="yes" xml:space="preserve">
          <source>Wrap the BIO objects &lt;em&gt;incoming&lt;/em&gt; and &lt;em&gt;outgoing&lt;/em&gt; and return an instance of &lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt;&lt;code&gt;SSLContext.sslobject_class&lt;/code&gt;&lt;/a&gt; (default &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;). The SSL routines will read input data from the incoming BIO and write data to the outgoing BIO.</source>
          <target state="translated">&lt;em&gt;수신&lt;/em&gt; 및 &lt;em&gt;발신&lt;/em&gt; BIO 오브젝트를 랩핑하고 &lt;a href=&quot;#ssl.SSLContext.sslobject_class&quot;&gt; &lt;code&gt;SSLContext.sslobject_class&lt;/code&gt; &lt;/a&gt; 인스턴스 (기본 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; )를 리턴 하십시오. SSL 루틴은 들어오는 BIO에서 입력 데이터를 읽고 나가는 BIO에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="25c90f8fd4499cd6197f01d510ea3f1b389a2d87" translate="yes" xml:space="preserve">
          <source>Wraps an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. This is used when reading or writing NSKeyedArchiver encoded data, which contains UID (see PList manual).</source>
          <target state="translated">&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 를&lt;/a&gt; 랩합니다 . UID를 포함하는 NSKeyedArchiver 인코딩 데이터를 읽거나 쓸 때 사용됩니다 (PList 매뉴얼 참조).</target>
        </trans-unit>
        <trans-unit id="68ffa41434f5ef07bf1b79c543ee91e505e4515d" translate="yes" xml:space="preserve">
          <source>Wraps the &lt;code&gt;posix_spawn()&lt;/code&gt; C library API for use from Python.</source>
          <target state="translated">Python에서 사용하기 위해 &lt;code&gt;posix_spawn()&lt;/code&gt; C 라이브러리 API를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="b8e4112a55e8230798780d123b0e6ee7624c2bdb" translate="yes" xml:space="preserve">
          <source>Wraps the &lt;code&gt;posix_spawnp()&lt;/code&gt; C library API for use from Python.</source>
          <target state="translated">파이썬에서 사용하기 위해 &lt;code&gt;posix_spawnp()&lt;/code&gt; C 라이브러리 API를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="d43d22b5ed05f4ee8e1729b35aef77956fd174aa" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt; (a string) so every line is at most &lt;a href=&quot;#textwrap.TextWrapper.width&quot;&gt;&lt;code&gt;width&lt;/code&gt;&lt;/a&gt; characters long. All wrapping options are taken from instance attributes of the &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; instance. Returns a list of output lines, without final newlines. If the wrapped output has no content, the returned list is empty.</source>
          <target state="translated">모든 단락 이 최대 &lt;a href=&quot;#textwrap.TextWrapper.width&quot;&gt; &lt;code&gt;width&lt;/code&gt; &lt;/a&gt; 문자 가되도록 단일 단락을 &lt;em&gt;텍스트&lt;/em&gt; (문자열)로 묶습니다 . 모든 줄 바꿈 옵션은 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스 의 인스턴스 속성에서 가져옵니다 . 마지막 줄 바꿈없이 출력 줄 목록을 반환합니다. 랩핑 된 출력에 내용이 없으면 리턴 된 목록이 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc06193157378861d75bff7a2f1b594fb5b1d3ad" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt; (a string) so every line is at most &lt;em&gt;width&lt;/em&gt; characters long. Returns a list of output lines, without final newlines.</source>
          <target state="translated">모든 단락 이 최대 &lt;em&gt;너비&lt;/em&gt; 문자 가되도록 단일 단락을 &lt;em&gt;텍스트&lt;/em&gt; (문자열)로 묶습니다 . 마지막 줄 바꿈없이 출력 줄 목록을 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bbb266e216d3a300ed723990a06600b7e04df65" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt;, and returns a single string containing the wrapped paragraph.</source>
          <target state="translated">단일 단락을 &lt;em&gt;text로&lt;/em&gt; 랩핑하고 랩핑 된 단락을 포함하는 단일 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ca151de3d39257aaa7ef51f09776d9426a4e86bf" translate="yes" xml:space="preserve">
          <source>Wraps the single paragraph in &lt;em&gt;text&lt;/em&gt;, and returns a single string containing the wrapped paragraph. &lt;a href=&quot;#textwrap.fill&quot;&gt;&lt;code&gt;fill()&lt;/code&gt;&lt;/a&gt; is shorthand for</source>
          <target state="translated">단일 단락을 &lt;em&gt;text로&lt;/em&gt; 랩핑하고 랩핑 된 단락을 포함하는 단일 문자열을 리턴합니다. &lt;a href=&quot;#textwrap.fill&quot;&gt; &lt;code&gt;fill()&lt;/code&gt; &lt;/a&gt; 은 속기입니다</target>
        </trans-unit>
        <trans-unit id="cbb520367f46e90cee8b8f5b1e6c21207124495b" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;buf&lt;/em&gt; to the SSL socket and return the number of bytes written. The &lt;em&gt;buf&lt;/em&gt; argument must be an object supporting the buffer interface.</source>
          <target state="translated">쓰기 &lt;em&gt;BUF&lt;/em&gt; 는 SSL 소켓 및 서면 바이트 수를 반환합니다. &lt;em&gt;버피&lt;/em&gt; 인자 버퍼 인터페이스를 지원하는 객체 여야한다.</target>
        </trans-unit>
        <trans-unit id="aef4a515b7b057bb68f87f064fae35143ec9e666" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;rootObject&lt;/em&gt; to an XML plist file. &lt;em&gt;pathOrFile&lt;/em&gt; may be either a file name or a (writable and binary) file object</source>
          <target state="translated">쓰다 &lt;em&gt;rootObject&lt;/em&gt; 를 XML plist 파일에 하십시오. &lt;em&gt;pathOrFile&lt;/em&gt; 은 파일 이름이거나 (쓰기 가능 및 이진) 파일 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a124faaf6d6424254bc6c3fa325a5691ed3e90" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;s&lt;/em&gt; to the &lt;em&gt;write&lt;/em&gt; method of the &lt;em&gt;outfp&lt;/em&gt; passed to the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s constructor. This provides just enough file-like API for &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; instances to be used in the &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 의 생성자에 전달 된 &lt;em&gt;outfp&lt;/em&gt; 의 &lt;em&gt;write&lt;/em&gt; 메소드에 &lt;em&gt;s&lt;/em&gt; 를 씁니다 . &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 충분한 파일 형 API를 제공합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; 인스턴스가 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수 에서 사용될 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="6d2124f354eb98d13eab8a7539f15f0cde6ced95" translate="yes" xml:space="preserve">
          <source>Write &lt;em&gt;value&lt;/em&gt; to a plist file. &lt;em&gt;Fp&lt;/em&gt; should be a writable, binary file object.</source>
          <target state="translated">쓰다 &lt;em&gt;&lt;/em&gt;plist 파일에 &lt;em&gt;값&lt;/em&gt; 을 . &lt;em&gt;Fp&lt;/em&gt; 는 쓰기 가능한 이진 파일 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3fc569fdf3522d7fe1d58d73b6d385b8c188e591" translate="yes" xml:space="preserve">
          <source>Write TLS keys to a keylog file, whenever key material is generated or received. The keylog file is designed for debugging purposes only. The file format is specified by NSS and used by many traffic analyzers such as Wireshark. The log file is opened in append-only mode. Writes are synchronized between threads, but not between processes.</source>
          <target state="translated">키 자료가 생성되거나 수신 될 때마다 TLS 키를 키로그 파일에 기록하십시오. 키로그 파일은 디버깅 목적으로 만 설계되었습니다. 파일 형식은 NSS에 의해 지정되며 Wireshark와 같은 많은 트래픽 분석기에서 사용됩니다. 로그 파일은 추가 전용 모드로 열립니다. 쓰레드간에 쓰기가 동기화되지만 프로세스간에 동기화되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="37c8d727588366243c8993e3e979b39ba193db5c" translate="yes" xml:space="preserve">
          <source>Write Transports</source>
          <target state="translated">전송 작성</target>
        </trans-unit>
        <trans-unit id="7f87fb907ae200e452ff1d664c58831d2d4084b7" translate="yes" xml:space="preserve">
          <source>Write XML to the writer object. The writer receives texts but not bytes as input, it should have a &lt;code&gt;write()&lt;/code&gt; method which matches that of the file object interface. The &lt;em&gt;indent&lt;/em&gt; parameter is the indentation of the current node. The &lt;em&gt;addindent&lt;/em&gt; parameter is the incremental indentation to use for subnodes of the current one. The &lt;em&gt;newl&lt;/em&gt; parameter specifies the string to use to terminate newlines.</source>
          <target state="translated">작성기 개체에 XML을 씁니다. 라이터는 텍스트를 수신하지만 바이트는 입력하지 않으며 , 파일 객체 인터페이스의 텍스트 와 일치 하는 &lt;code&gt;write()&lt;/code&gt; 메소드 가 있어야합니다 . &lt;em&gt;들여&lt;/em&gt; 파라미터는 현재 노드의 압입된다. &lt;em&gt;addindent 된&lt;/em&gt; 파라미터는 현재의 서브 노드에 사용하는 점증 압입된다. &lt;em&gt;newl&lt;/em&gt; 매개 변수는 줄 바꿈을 종료하는 데 사용할 문자열을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="34af1234d1be52e185f56532800f5c20e29687e6" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device and return the number of bytes written. If the audio device is in blocking mode (the default), the entire data is always written (again, this is different from usual Unix device semantics). If the device is in non-blocking mode, some data may not be written&amp;mdash;see &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쓰기 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;데이터를&lt;/em&gt; 오디오 장치에 기입해진 바이트 수를 반환합니다. 오디오 장치가 차단 모드 인 경우 (기본값) 전체 데이터가 항상 기록됩니다 (다시 말하면 일반적인 Unix 장치 의미와 다릅니다). 장치가 비 차단 모드 인 경우 일부 데이터가 기록되지 않을 수 있습니다 &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt; 참조 ) .</target>
        </trans-unit>
        <trans-unit id="7530782eb2bf804763cda334f2dc760226b94c6f" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device: waits until the audio device is able to accept data, writes as much data as it will accept, and repeats until &lt;em&gt;data&lt;/em&gt; has been completely written. If the device is in blocking mode (the default), this has the same effect as &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt; is only useful in non-blocking mode. Has no return value, since the amount of data written is always equal to the amount of data supplied.</source>
          <target state="translated">쓰기 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;데이터&lt;/em&gt; 오디오 장치를 : 때까지 기다립니다 오디오 장치가 데이터를 수신 할 수있을 때까지, 많은 그것을 받아 들일 것 같은 데이터 및 반복으로 기록 &lt;em&gt;데이터가&lt;/em&gt; 완전하게 작성되었습니다. 장치가 차단 모드 인 경우 (기본값) &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 와 동일한 효과가 있습니다 . &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt; 은 비 블로킹 모드에서만 유용합니다. 기록 된 데이터의 양이 항상 제공된 데이터의 양과 같으므로 리턴 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="93cb6941cbab90f65c71948e43ce9d15dbc779e0" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device and return the number of bytes written. If the audio device is in blocking mode (the default), the entire data is always written (again, this is different from usual Unix device semantics). If the device is in non-blocking mode, some data may not be written&amp;mdash;see &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쓰기 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체 &lt;/a&gt;&lt;em&gt;데이터를&lt;/em&gt; 오디오 장치에 기입해진 바이트 수를 반환합니다. 오디오 장치가 차단 모드 (기본값)이면 전체 데이터가 항상 기록됩니다 (다시 말하지만 일반적인 Unix 장치 의미 체계와 다릅니다). 장치가 비 차단 모드 인 경우 일부 데이터가 기록되지 않을 수 있습니다 . &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3c2555eb091dc69472d9fd280785d6512fad99a5" translate="yes" xml:space="preserve">
          <source>Write a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;&lt;em&gt;data&lt;/em&gt; to the audio device: waits until the audio device is able to accept data, writes as much data as it will accept, and repeats until &lt;em&gt;data&lt;/em&gt; has been completely written. If the device is in blocking mode (the default), this has the same effect as &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;; &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt;&lt;code&gt;writeall()&lt;/code&gt;&lt;/a&gt; is only useful in non-blocking mode. Has no return value, since the amount of data written is always equal to the amount of data supplied.</source>
          <target state="translated">오디오 장치에 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체 &lt;/a&gt;&lt;em&gt;데이터&lt;/em&gt; 쓰기 : 오디오 장치가 데이터를 받아 들일 수있을 때까지 기다렸다가 받아 들일만큼 많은 데이터를 쓰고, &lt;em&gt;데이터&lt;/em&gt; 가 완전히 기록 될 때까지 반복 합니다. 장치가 차단 모드 (기본값)이면 &lt;a href=&quot;#ossaudiodev.oss_audio_device.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 와 동일한 효과를 갖습니다 . &lt;a href=&quot;#ossaudiodev.oss_audio_device.writeall&quot;&gt; &lt;code&gt;writeall()&lt;/code&gt; &lt;/a&gt; 은 비 차단 모드에서만 유용합니다. 기록 된 데이터의 양이 항상 제공된 데이터의 양과 같으므로 반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ab07be95f65e1f944e226c637379683c5bcbbeff" translate="yes" xml:space="preserve">
          <source>Write a &lt;code&gt;__main__.py&lt;/code&gt; file to the archive that executes &lt;em&gt;mainfn&lt;/em&gt;. The &lt;em&gt;mainfn&lt;/em&gt; argument should have the form &amp;ldquo;pkg.mod:fn&amp;rdquo;, where &amp;ldquo;pkg.mod&amp;rdquo; is a package/module in the archive, and &amp;ldquo;fn&amp;rdquo; is a callable in the given module. The &lt;code&gt;__main__.py&lt;/code&gt; file will execute that callable.</source>
          <target state="translated">&lt;em&gt;mainfn&lt;/em&gt; 을 실행하는 아카이브에 &lt;code&gt;__main__.py&lt;/code&gt; 파일을 작성하십시오 . &lt;em&gt;mainfn의&lt;/em&gt; 인수는 형식이 있어야합니다 &quot;pkg.mod&quot;는 아카이브에 패키지 / 모듈입니다 &quot;pkg.mod FN&quot;, 및 &quot;FN은&quot;주어진 모듈의 호출이다. &lt;code&gt;__main__.py&lt;/code&gt; 의 파일은 해당 호출을 실행합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7ee50cf63ba8885dc61601f8b5cd0b79d178853d" translate="yes" xml:space="preserve">
          <source>Write a byte string to the socket, doubling any IAC characters. This can block if the connection is blocked. May raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if the connection is closed.</source>
          <target state="translated">소켓에 바이트 문자열을 쓰면 IAC 문자가 두 배가됩니다. 연결이 차단되면 차단 될 수 있습니다. 올릴 수 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 연결이 닫혀있는 경우.</target>
        </trans-unit>
        <trans-unit id="11050f94833bd03482233f6f4a212266c002bd4d" translate="yes" xml:space="preserve">
          <source>Write a file into the archive. The contents is &lt;em&gt;data&lt;/em&gt;, which may be either a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; instance; if it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, it is encoded as UTF-8 first. &lt;em&gt;zinfo_or_arcname&lt;/em&gt; is either the file name it will be given in the archive, or a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance. If it&amp;rsquo;s an instance, at least the filename, date, and time must be given. If it&amp;rsquo;s a name, the date and time is set to the current date and time. The archive must be opened with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">파일을 아카이브에 씁니다. 내용은 &lt;em&gt;data&lt;/em&gt; 이며 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 인스턴스 일 수 있습니다. 그것은 경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 이를 제 UTF-8로 인코딩된다. &lt;em&gt;zinfo_or_arcname&lt;/em&gt; 은 아카이브에 제공 될 파일 이름이거나 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. 인스턴스 인 경우 최소한 파일 이름, 날짜 및 시간을 지정해야합니다. 이름 인 경우 날짜 및 시간이 현재 날짜 및 시간으로 설정됩니다. 아카이브는 &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 열어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f3eb00f495508e3700c4ba0640bfacc98b0501ae" translate="yes" xml:space="preserve">
          <source>Write a list (or any iterable) of data bytes to the transport. This is functionally equivalent to calling &lt;a href=&quot;#asyncio.WriteTransport.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; on each element yielded by the iterable, but may be implemented more efficiently.</source>
          <target state="translated">전송에 데이터 바이트 목록 (또는 반복 가능)을 작성하십시오. 이는 iterable이 생성 한 각 요소에서 &lt;a href=&quot;#asyncio.WriteTransport.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것과 기능적으로 동일 하지만보다 효율적으로 구현 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7437d7098997ca3f0b36ac87a6783125bd334ba" translate="yes" xml:space="preserve">
          <source>Write a list of lines to the stream. Line separators are not added, so it is usual for each of the lines provided to have a line separator at the end.</source>
          <target state="translated">스트림의 행 목록을 작성하십시오. 줄 구분 기호는 추가되지 않으므로 제공된 각 줄 끝에 줄 구분 기호가있는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="37e2299e025bd71effd4f4c8ea111a73efc09766" translate="yes" xml:space="preserve">
          <source>Write a prompt and read a line. The returned line does not include the trailing newline. When the user enters the EOF key sequence, &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; is raised. The base implementation reads from &lt;code&gt;sys.stdin&lt;/code&gt;; a subclass may replace this with a different implementation.</source>
          <target state="translated">프롬프트를 작성하고 줄을 읽습니다. 반환 된 줄에는 후행 줄 바꿈이 포함되지 않습니다. 사용자가 EOF 키 시퀀스를 입력하면 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 기본 구현은 &lt;code&gt;sys.stdin&lt;/code&gt; 에서 읽습니다 . 서브 클래스는 이것을 다른 구현으로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f447e1ee94708098c72a4348432a023a0a8cf9" translate="yes" xml:space="preserve">
          <source>Write a representation of the configuration to the specified &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which must be opened in text mode (accepting strings). This representation can be parsed by a future &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; call. If &lt;em&gt;space_around_delimiters&lt;/em&gt; is true, delimiters between keys and values are surrounded by spaces.</source>
          <target state="translated">지정된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트에&lt;/a&gt; 구성 표현을 작성하십시오. 텍스트 오브젝트 에서 열어야합니다 (문자열 허용). 이 표현은 향후 &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 호출 로 구문 분석 할 수 있습니다 . &lt;em&gt;space_around_delimiters&lt;/em&gt; 가 true 인 경우 키와 값 사이의 구분 기호는 공백으로 &lt;em&gt;묶습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0eef9c11e095a7379d1c8f9b621d22452c461848" translate="yes" xml:space="preserve">
          <source>Write a representation of the configuration to the specified &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which must be opened in text mode (accepting strings). This representation can be parsed by a future &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; call. If &lt;em&gt;space_around_delimiters&lt;/em&gt; is true, delimiters between keys and values are surrounded by spaces.</source>
          <target state="translated">텍스트 모드 (문자열 허용)에서 열어야하는 지정된 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체에&lt;/a&gt; 구성 표현을 씁니다 . 이 표현은 향후 &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 호출 로 구문 분석 할 수 있습니다 . 경우 &lt;em&gt;space_around_delimiters는&lt;/em&gt; 사실, 키와 값 사이의 구분은 공백으로 둘러싸여있다.</target>
        </trans-unit>
        <trans-unit id="44f425021d217395cd90bd3e1c685d406345abef" translate="yes" xml:space="preserve">
          <source>Write a row with the field names (as specified in the constructor) to the writer&amp;rsquo;s file object, formatted according to the current dialect. Return the return value of the &lt;a href=&quot;#csv.csvwriter.writerow&quot;&gt;&lt;code&gt;csvwriter.writerow()&lt;/code&gt;&lt;/a&gt; call used internally.</source>
          <target state="translated">필드 이름이있는 행 (생성자에 지정된대로)을 현재 방언에 따라 형식화 된 작성기의 파일 객체에 씁니다. 내부적으로 사용 된 &lt;a href=&quot;#csv.csvwriter.writerow&quot;&gt; &lt;code&gt;csvwriter.writerow()&lt;/code&gt; &lt;/a&gt; 호출 의 반환 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3de22fd70b48f7f02d64b21199c74c551c5a4056" translate="yes" xml:space="preserve">
          <source>Write a string to the standard error stream (&lt;code&gt;sys.stderr&lt;/code&gt;). Derived classes should override this to provide the appropriate output handling as needed.</source>
          <target state="translated">표준 오류 스트림 ( &lt;code&gt;sys.stderr&lt;/code&gt; )에 문자열을 작성하십시오 . 파생 클래스는 필요에 따라 적절한 출력 처리를 제공하기 위해이 클래스를 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d612d16d0cf266e7ebef3c7987599b4fd184d79d" translate="yes" xml:space="preserve">
          <source>Write a warning to a file. The default implementation calls &lt;code&gt;formatwarning(message, category, filename, lineno, line)&lt;/code&gt; and writes the resulting string to &lt;em&gt;file&lt;/em&gt;, which defaults to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;. You may replace this function with any callable by assigning to &lt;code&gt;warnings.showwarning&lt;/code&gt;. &lt;em&gt;line&lt;/em&gt; is a line of source code to be included in the warning message; if &lt;em&gt;line&lt;/em&gt; is not supplied, &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt; will try to read the line specified by &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;lineno&lt;/em&gt;.</source>
          <target state="translated">파일에 경고를 작성하십시오. 기본 구현은 &lt;code&gt;formatwarning(message, category, filename, lineno, line)&lt;/code&gt; 호출 하고 결과 문자열을 &lt;em&gt;file에&lt;/em&gt; 씁니다 . 기본값은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt; 입니다. &lt;code&gt;warnings.showwarning&lt;/code&gt; 을 지정하여이 함수를 호출 가능한 것으로 대체 할 수 있습니다 . &lt;em&gt;line&lt;/em&gt; 은 경고 메시지에 포함될 소스 코드 라인입니다. 경우 &lt;em&gt;라인이&lt;/em&gt; 제공되지 않으면 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 로 지정된 행 읽으려고합니다 &lt;em&gt;파일 이름&lt;/em&gt; 및 &lt;em&gt;LINENO를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bb845fd32652cc2e4f58bebbf5d18bb847fd06c2" translate="yes" xml:space="preserve">
          <source>Write all data associated with the window into the provided file object. This information can be later retrieved using the &lt;a href=&quot;#curses.getwin&quot;&gt;&lt;code&gt;getwin()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">창과 연관된 모든 데이터를 제공된 파일 오브젝트에 기록하십시오. 이 정보는 나중에 &lt;a href=&quot;#curses.getwin&quot;&gt; &lt;code&gt;getwin()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81abe8375bf8942cde0da27f3d6c849d0068cc77" translate="yes" xml:space="preserve">
          <source>Write all elements in &lt;em&gt;rows&lt;/em&gt; (an iterable of &lt;em&gt;row&lt;/em&gt; objects as described above) to the writer&amp;rsquo;s file object, formatted according to the current dialect.</source>
          <target state="translated">&lt;em&gt;행의&lt;/em&gt; 모든 요소 ( 위에 설명 된대로 &lt;em&gt;행&lt;/em&gt; 오브젝트 의 반복 가능 )를 현재 방언에 따라 형식화 된 작성기의 파일 오브젝트에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="fc9ceb61920372f0588b9d7561124c54016a1122" translate="yes" xml:space="preserve">
          <source>Write all items (as machine values) to the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">모든 항목 (기계 값)을 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;f에&lt;/em&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="d0c36c3ce32990a4354e9f9b514a715f25ec2591" translate="yes" xml:space="preserve">
          <source>Write all items (as machine values) to the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;f&lt;/em&gt;.</source>
          <target state="translated">모든 항목 (시스템 값으로)을 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;f에&lt;/em&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="f81f2599a0df03842e1b569bdbf1ec30324a18f4" translate="yes" xml:space="preserve">
          <source>Write an EOF marker to the memory BIO. After this method has been called, it is illegal to call &lt;a href=&quot;#ssl.MemoryBIO.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt;. The attribute &lt;a href=&quot;#ssl.MemoryBIO.eof&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; will become true after all data currently in the buffer has been read.</source>
          <target state="translated">EOF 마커를 메모리 BIO에 씁니다. 이 메소드가 호출 된 후에 &lt;a href=&quot;#ssl.MemoryBIO.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것은 불법 입니다. 현재 버퍼에있는 모든 데이터를 읽은 후에 &lt;a href=&quot;#ssl.MemoryBIO.eof&quot;&gt; &lt;code&gt;eof&lt;/code&gt; &lt;/a&gt; 속성 이 true가됩니다.</target>
        </trans-unit>
        <trans-unit id="fd0862fa068194298c775ee76e1f456320747a5a" translate="yes" xml:space="preserve">
          <source>Write any pending changes to the filesystem. For some &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; subclasses, changes are always written immediately and &lt;a href=&quot;#mailbox.Mailbox.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; does nothing, but you should still make a habit of calling this method.</source>
          <target state="translated">보류중인 변경 사항을 파일 시스템에 씁니다. 일부 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 서브 클래스의 경우, 변경 사항은 항상 즉시 작성되며 &lt;a href=&quot;#mailbox.Mailbox.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 는 아무 것도 수행하지 않지만 여전히이 메소드를 호출하는 습관을 들여야합니다.</target>
        </trans-unit>
        <trans-unit id="5a1297c30d5d72fb62f06bfd02306776bc567c17" translate="yes" xml:space="preserve">
          <source>Write audio frames and make sure &lt;em&gt;nframes&lt;/em&gt; is correct. It will raise an error if the output stream is not seekable and the total number of frames that have been written after &lt;em&gt;data&lt;/em&gt; has been written does not match the previously set value for &lt;em&gt;nframes&lt;/em&gt;.</source>
          <target state="translated">오디오 프레임을 작성하고 &lt;em&gt;nframe&lt;/em&gt; 이 올바른지 확인 하십시오. 출력 스트림을 검색 할 수없고 &lt;em&gt;데이터&lt;/em&gt; 가 기록 된 후 기록 된 총 프레임 수가 &lt;em&gt;nframe에&lt;/em&gt; 대해 이전에 설정 한 값과 일치하지 않으면 &lt;em&gt;오류가 발생&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6374207475d74b69e79e3c97cb15756f85e6eecd" translate="yes" xml:space="preserve">
          <source>Write audio frames, without correcting &lt;em&gt;nframes&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;nframe&lt;/em&gt; 을 수정하지 않고 오디오 프레임을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="10d10592df13916c769fed5ce2f6051eab11d892" translate="yes" xml:space="preserve">
          <source>Write back all entries in the cache if the shelf was opened with &lt;em&gt;writeback&lt;/em&gt; set to &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;. Also empty the cache and synchronize the persistent dictionary on disk, if feasible. This is called automatically when the shelf is closed with &lt;a href=&quot;#shelve.Shelf.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">쓰기 &lt;em&gt;저장&lt;/em&gt; 이 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 로&lt;/a&gt; 설정된 선반이 열린 경우 캐시의 모든 항목을 다시 기록하십시오 . 또한 가능한 경우 캐시를 비우고 디스크에서 영구 사전을 동기화하십시오. 선반이 &lt;a href=&quot;#shelve.Shelf.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 닫히면 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfb4b78e519e7550928b490acec5cdf38eb80432" translate="yes" xml:space="preserve">
          <source>Write buffers to the transport.</source>
          <target state="translated">전송에 버퍼를 씁니다.</target>
        </trans-unit>
        <trans-unit id="ef28f2b25c05e4ce563406a1aa0120af14871caf" translate="yes" xml:space="preserve">
          <source>Write coverage results. Set &lt;em&gt;show_missing&lt;/em&gt; to show lines that had no hits. Set &lt;em&gt;summary&lt;/em&gt; to include in the output the coverage summary per module. &lt;em&gt;coverdir&lt;/em&gt; specifies the directory into which the coverage result files will be output. If &lt;code&gt;None&lt;/code&gt;, the results for each source file are placed in its directory.</source>
          <target state="translated">커버리지 결과를 씁니다. 적중이없는 행을 표시하려면 &lt;em&gt;show_missing&lt;/em&gt; 을 설정하십시오 . 모듈 당 적용 범위 요약을 출력에 포함하도록 &lt;em&gt;요약&lt;/em&gt; 을 설정하십시오 . &lt;em&gt;coverdir&lt;/em&gt; 은 적용 범위 결과 파일이 출력 될 디렉토리를 지정합니다. 경우 &lt;code&gt;None&lt;/code&gt; , 각 소스 파일에 대한 결과는 그 디렉토리에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="de823fe8fae6707bcca7ae9d265deafd25388197" translate="yes" xml:space="preserve">
          <source>Write data to the output file. This method can only be called after the audio file parameters have been set.</source>
          <target state="translated">출력 파일에 데이터를 씁니다. 이 메소드는 오디오 파일 매개 변수가 설정된 후에 만 ​​호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e0192353108eeff55932692ba801f256905196f" translate="yes" xml:space="preserve">
          <source>Write data to the transport.</source>
          <target state="translated">전송에 데이터를 씁니다.</target>
        </trans-unit>
        <trans-unit id="b37ba65d2a4a6d647d50783ee4565efe21874280" translate="yes" xml:space="preserve">
          <source>Write only mode.</source>
          <target state="translated">쓰기 전용 모드.</target>
        </trans-unit>
        <trans-unit id="de43cb842768a7bf97800356094a1d534b6900c6" translate="yes" xml:space="preserve">
          <source>Write some &lt;em&gt;data&lt;/em&gt; bytes to the transport.</source>
          <target state="translated">전송에 일부 &lt;em&gt;데이터&lt;/em&gt; 바이트를 씁니다 .</target>
        </trans-unit>
        <trans-unit id="871c8f9286c953dd029dbbaeca8bcb6b99962da0" translate="yes" xml:space="preserve">
          <source>Write text - the string representation of &lt;em&gt;arg&lt;/em&gt; - at the current turtle position according to &lt;em&gt;align&lt;/em&gt; (&amp;ldquo;left&amp;rdquo;, &amp;ldquo;center&amp;rdquo; or right&amp;rdquo;) and with the given font. If &lt;em&gt;move&lt;/em&gt; is true, the pen is moved to the bottom-right corner of the text. By default, &lt;em&gt;move&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">주어진 글꼴을 사용 하여 &lt;em&gt;정렬&lt;/em&gt; ( &quot;왼쪽&quot;, &quot;중심&quot;또는 오른쪽) 에 따라 현재 거북이 위치에 텍스트 ( &lt;em&gt;arg&lt;/em&gt; 의 문자열 표현)를 씁니다 . 경우 &lt;em&gt;이동이&lt;/em&gt; 사실이다, 펜 텍스트의 오른쪽 하단으로 이동합니다. 기본적으로 &lt;em&gt;이동&lt;/em&gt; 은 &lt;code&gt;False&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3378a681ace2c9c5d6e0cd6c28d0e5dc9a0608f5" translate="yes" xml:space="preserve">
          <source>Write text files containing test cases as interactive examples, and test the files using &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt;&lt;code&gt;DocFileSuite()&lt;/code&gt;&lt;/a&gt;. This is recommended, although is easiest to do for new projects, designed from the start to use doctest.</source>
          <target state="translated">테스트 케이스가 포함 된 텍스트 파일을 대화식 예제로 작성하고 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#doctest.DocFileSuite&quot;&gt; &lt;code&gt;DocFileSuite()&lt;/code&gt; &lt;/a&gt; 사용하여 파일을 테스트하십시오 . 처음부터 doctest를 사용하도록 설계된 새 프로젝트에 가장 쉬운 방법이지만 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="c49bb785234b8ca3d65e01ef187d421d2ad64c53" translate="yes" xml:space="preserve">
          <source>Write the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written. When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the buffer needs to be written out but the raw stream blocks.</source>
          <target state="translated">쓰기 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;em&gt;B를&lt;/em&gt; , 기입해진 바이트 수를 반환합니다. 비 차단 모드에 있을 때 버퍼를 작성해야하지만 원시 스트림 블록 은 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e7c7d79640aa2b1f9a0829b07201eaf51d80f7b0" translate="yes" xml:space="preserve">
          <source>Write the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written. When in non-blocking mode, a &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; is raised if the buffer needs to be written out but the raw stream blocks.</source>
          <target state="translated">쓰기 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;em&gt;B를&lt;/em&gt; , 기입해진 바이트 수를 반환합니다. 비 차단 모드 에서 버퍼를 작성해야하지만 원시 스트림이 차단되면 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="80c87e056df756962ad8a4e0b3ed6dfcb114b2df" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;buffers&lt;/em&gt; contents to file descriptor &lt;em&gt;fd&lt;/em&gt; at a offset &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">파일 오프셋을 변경하지 않고 &lt;em&gt;버퍼&lt;/em&gt; 오프셋 내용을 오프셋 &lt;em&gt;오프셋&lt;/em&gt; 에서 파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; 에 씁니다 . &lt;em&gt;버퍼&lt;/em&gt; 는 일련의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야 합니다 . 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7cac7e50579b40392dcb2dcea2d2c807901f780c" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;buffers&lt;/em&gt; contents to file descriptor &lt;em&gt;fd&lt;/em&gt; at a offset &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">쓰기 &lt;em&gt;버퍼&lt;/em&gt; 파일 기술자에 대한 내용 &lt;em&gt;FD를&lt;/em&gt; A는 오프셋에서 &lt;em&gt;오프셋&lt;/em&gt; 파일을 떠나는는 변경되지 않은 오프셋. &lt;em&gt;버퍼&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트 열류 객체&lt;/a&gt; 의 시퀀스 여야 합니다 . 버퍼는 배열 순서로 처리됩니다. 두 번째 버퍼로 진행하기 전에 첫 번째 버퍼의 전체 내용이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b68098901631691c20ac4c25cf82febd1b870a65" translate="yes" xml:space="preserve">
          <source>Write the &lt;em&gt;row&lt;/em&gt; parameter to the writer&amp;rsquo;s file object, formatted according to the current dialect. Return the return value of the call to the &lt;em&gt;write&lt;/em&gt; method of the underlying file object.</source>
          <target state="translated">&lt;em&gt;행&lt;/em&gt; 매개 변수를 현재 방언에 따라 형식화 된 작성기의 파일 객체에 씁니다 . 기본 파일 객체 의 &lt;em&gt;write&lt;/em&gt; 메소드에 대한 호출의 리턴 값을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="73ec3e1f52340e46c299e8d695880b094a6fd996" translate="yes" xml:space="preserve">
          <source>Write the XML-RPC base 64 encoding of this binary item to the &lt;em&gt;out&lt;/em&gt; stream object.</source>
          <target state="translated">이 바이너리 아이템의 XML-RPC base 64 인코딩을 &lt;em&gt;아웃&lt;/em&gt; 스트림 객체에 기입합니다.</target>
        </trans-unit>
        <trans-unit id="09605d772916211b4f273ac78b4abb90e0284a69" translate="yes" xml:space="preserve">
          <source>Write the XML-RPC encoding of this &lt;a href=&quot;#xmlrpc.client.DateTime&quot;&gt;&lt;code&gt;DateTime&lt;/code&gt;&lt;/a&gt; item to the &lt;em&gt;out&lt;/em&gt; stream object.</source>
          <target state="translated">이 &lt;a href=&quot;#xmlrpc.client.DateTime&quot;&gt; &lt;code&gt;DateTime&lt;/code&gt; &lt;/a&gt; 항목 의 XML-RPC 인코딩을 &lt;em&gt;출력&lt;/em&gt; 스트림 객체에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="bef2916cd925d9f570653604eed88e3d7738b49e" translate="yes" xml:space="preserve">
          <source>Write the byte-code files to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">바이트 코드 파일을 레거시 위치 및 이름에 쓰면 다른 버전의 Python에서 만든 바이트 코드 파일을 덮어 쓸 수 있습니다. 기본값은 파일을 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 위치 및 이름 에 쓰는 &lt;strong&gt;것이므로&lt;/strong&gt; 여러 버전의 Python의 바이트 코드 파일이 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cdd677e07f573fdbc799f5165e8f7ed05952f7f" translate="yes" xml:space="preserve">
          <source>Write the bytes from &lt;em&gt;buf&lt;/em&gt; to the memory BIO. The &lt;em&gt;buf&lt;/em&gt; argument must be an object supporting the buffer protocol.</source>
          <target state="translated">바이트 쓰기 &lt;em&gt;buf&lt;/em&gt; 에서 메모리 BIO로 . &lt;em&gt;버피&lt;/em&gt; 인수 퍼 프로토콜을 지원하는 객체 여야한다.</target>
        </trans-unit>
        <trans-unit id="f3354e519dec860fd5b4513b4f703e6282b70945" translate="yes" xml:space="preserve">
          <source>Write the bytes in &lt;em&gt;bytes&lt;/em&gt; into memory at the current position of the file pointer and return the number of bytes written (never less than &lt;code&gt;len(bytes)&lt;/code&gt;, since if the write fails, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised). The file position is updated to point after the bytes that were written. If the mmap was created with &lt;code&gt;ACCESS_READ&lt;/code&gt;, then writing to it will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">바이트 단위의 &lt;em&gt;바이트&lt;/em&gt; 를 파일 포인터의 현재 위치에서 메모리에 기록하고 쓴 바이트 수를 반환합니다 &lt;code&gt;len(bytes)&lt;/code&gt; 쓰기에 실패하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생하므로 len (bytes) 미만 ). 쓰여진 바이트 뒤를 가리 키도록 파일 위치가 업데이트됩니다. mmap이 &lt;code&gt;ACCESS_READ&lt;/code&gt; 로 작성된 경우 , 다음 올릴 것이다 그것을 쓰는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외.</target>
        </trans-unit>
        <trans-unit id="791c39fe68f1524d71fee0a4ea28b01783eda89a" translate="yes" xml:space="preserve">
          <source>Write the bytestring in &lt;em&gt;str&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt; at position of &lt;em&gt;offset&lt;/em&gt;, leaving the file offset unchanged.</source>
          <target state="translated">&lt;em&gt;str&lt;/em&gt; 의 바이트 &lt;em&gt;스트링&lt;/em&gt; 을 파일 디스크립터에 작성&lt;em&gt;&lt;/em&gt; 을 &lt;em&gt;offset의&lt;/em&gt; 위치에있는&lt;em&gt; fd&lt;/em&gt; 에 파일 오프셋은 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="5328e34fbdfb16a49801df3179dac7827d6c2c5e" translate="yes" xml:space="preserve">
          <source>Write the bytestring in &lt;em&gt;str&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;.</source>
          <target state="translated">바이트 열을 &lt;em&gt;str 스트링&lt;/em&gt; 을 파일 디스크립터 &lt;em&gt;fd&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="27b94773d284ac100a9d67d6a8514f6713ad81c9" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;buffers&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 의 내용 을 파일 디스크립터 &lt;em&gt;fd에&lt;/em&gt; 씁니다 . &lt;em&gt;버퍼&lt;/em&gt; 는 일련의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야 합니다 . 버퍼는 배열 순서로 처리됩니다. 첫 번째 버퍼의 전체 내용은 두 번째 버퍼로 진행하기 전에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="3b30bae590878dfc74fd0b3a60ccfd65b4215fed" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;buffers&lt;/em&gt; to file descriptor &lt;em&gt;fd&lt;/em&gt;. &lt;em&gt;buffers&lt;/em&gt; must be a sequence of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. Buffers are processed in array order. Entire contents of the first buffer is written before proceeding to the second, and so on.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 의 내용 을 파일 설명자 &lt;em&gt;fd에&lt;/em&gt; 씁니다 . &lt;em&gt;버퍼&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트 열류 객체&lt;/a&gt; 의 시퀀스 여야 합니다 . 버퍼는 배열 순서로 처리됩니다. 두 번째 버퍼로 진행하기 전에 첫 번째 버퍼의 전체 내용이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="c2efd35168142cd179ef29ca72c5ec8a98f503be" translate="yes" xml:space="preserve">
          <source>Write the file named &lt;em&gt;filename&lt;/em&gt; to the archive, giving it the archive name &lt;em&gt;arcname&lt;/em&gt; (by default, this will be the same as &lt;em&gt;filename&lt;/em&gt;, but without a drive letter and with leading path separators removed). If given, &lt;em&gt;compress_type&lt;/em&gt; overrides the value given for the &lt;em&gt;compression&lt;/em&gt; parameter to the constructor for the new entry. Similarly, &lt;em&gt;compresslevel&lt;/em&gt; will override the constructor if given. The archive must be open with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일&lt;/em&gt; 을 아카이브에 작성하여 아카이브 이름 &lt;em&gt;arcname을&lt;/em&gt; 지정 &lt;em&gt;하십시오&lt;/em&gt; (기본적으로 &lt;em&gt;filename&lt;/em&gt; 과 동일 하지만 드라이브 문자가없고 선행 경로 구분 기호가 제거됨). 주어진 경우, &lt;em&gt;compress_type&lt;/em&gt; 은 &lt;em&gt;compression&lt;/em&gt; 매개 변수에 제공된 값을 새 항목의 생성자로 대체합니다 . 마찬가지로, &lt;em&gt;압축&lt;/em&gt; 레벨은 주어진 경우 생성자를 대체합니다. 아카이브는 &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 열려 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f0122c32b529e0fe1cabeadad2b8ff8edccbce43" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written (always equal to the length of &lt;em&gt;b&lt;/em&gt; in bytes, since if the write fails an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised). Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.</source>
          <target state="translated">주어진 쓰기 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;em&gt;B를&lt;/em&gt; 기입해진 바이트 수를 반환 (항상의 길이와 같아야 &lt;em&gt;나&lt;/em&gt; 쓰기가 실패하면 이후 바이트&lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 이&lt;/a&gt; 제기됩니다). 실제 구현에 따라 이러한 바이트는 기본 스트림에 쉽게 쓰거나 성능 및 대기 시간 이유로 버퍼에 보관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28a6af62d0fddfdcac2699f837e4923a4e0da362" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, to the underlying raw stream, and return the number of bytes written. This can be less than the length of &lt;em&gt;b&lt;/em&gt; in bytes, depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. &lt;code&gt;None&lt;/code&gt; is returned if the raw stream is set not to block and no single byte could be readily written to it. The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">주어진 쓰기 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;em&gt;B&lt;/em&gt; , 기본 원료 스트림을 기입해진 바이트 수를 반환합니다. 이것의 길이보다 작을 수있다 &lt;em&gt;B&lt;/em&gt; 기본 원료 스트림의 특성에 따라, 바이트 단위로하고,이 비 블록 모드 특히. 원시 스트림이 차단되지 않고 단일 바이트를 쉽게 기록 할 수없는 경우 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다. 호출자는 이 메소드가 리턴 된 후 &lt;em&gt;b를&lt;/em&gt; 해제하거나 변경할 수 있으므로 구현은 메소드 호출 중 &lt;em&gt;b&lt;/em&gt; 에만 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="27455b21fa23722a89a9798d0a3301fc564413fb" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, and return the number of bytes written (always equal to the length of &lt;em&gt;b&lt;/em&gt; in bytes, since if the write fails an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised). Depending on the actual implementation, these bytes may be readily written to the underlying stream, or held in a buffer for performance and latency reasons.</source>
          <target state="translated">주어진 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; , &lt;em&gt;b를&lt;/em&gt; 쓰고 쓴 바이트 수를 반환합니다 ( 쓰기가 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생하기 때문에 항상 &lt;em&gt;b&lt;/em&gt; 의 길이 와 바이트 단위 ). 실제 구현에 따라 이러한 바이트는 기본 스트림에 쉽게 기록되거나 성능 및 대기 시간 이유로 버퍼에 보관 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78bb881db0e1f430d7902b668b98e8528e172885" translate="yes" xml:space="preserve">
          <source>Write the given &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, &lt;em&gt;b&lt;/em&gt;, to the underlying raw stream, and return the number of bytes written. This can be less than the length of &lt;em&gt;b&lt;/em&gt; in bytes, depending on specifics of the underlying raw stream, and especially if it is in non-blocking mode. &lt;code&gt;None&lt;/code&gt; is returned if the raw stream is set not to block and no single byte could be readily written to it. The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">주어진 쓰기 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , &lt;em&gt;B&lt;/em&gt; , 기본 원료 스트림을 기입해진 바이트 수를 반환합니다. 기본 원시 스트림의 특성에 따라 특히 비 차단 모드 인 경우 &lt;em&gt;b&lt;/em&gt; 길이 ( 바이트) 보다 작을 수 있습니다 . 원시 스트림이 차단되지 않도록 설정되어 있고 단일 바이트를 쉽게 쓸 수없는 경우 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 호출자는 이 메서드가 반환 된 후 &lt;em&gt;b를&lt;/em&gt; 해제하거나 변경할 수 있으므로 구현은 메서드 호출 중에 만 &lt;em&gt;b&lt;/em&gt; 에 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="02aca4b0c4cf6c2a7fe54cc559e99496d0c3f596" translate="yes" xml:space="preserve">
          <source>Write the integer &lt;em&gt;byte&lt;/em&gt; into memory at the current position of the file pointer; the file position is advanced by &lt;code&gt;1&lt;/code&gt;. If the mmap was created with &lt;code&gt;ACCESS_READ&lt;/code&gt;, then writing to it will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">파일 포인터의 현재 위치에서 정수 &lt;em&gt;바이트&lt;/em&gt; 를 메모리에 씁니다 . 파일 위치는 &lt;code&gt;1&lt;/code&gt; 씩 증가 합니다. 의 mmap을 만든 경우 &lt;code&gt;ACCESS_READ&lt;/code&gt; , 다음 올릴 것이다 그것을 쓰는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외.</target>
        </trans-unit>
        <trans-unit id="edb72d7ee339e68a0aebdb5f886ea9310729e068" translate="yes" xml:space="preserve">
          <source>Write the modified properties to the summary information stream, using &lt;code&gt;MsiSummaryInfoPersist()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MsiSummaryInfoPersist()&lt;/code&gt; 사용하여 수정 된 특성을 요약 정보 스트림에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="55bf2fe45536bc78a1a8caf7889193c631c34161" translate="yes" xml:space="preserve">
          <source>Write the output of the &lt;em&gt;infile&lt;/em&gt; to the given &lt;em&gt;outfile&lt;/em&gt;. Otherwise, write it to &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;infile&lt;/em&gt; 의 출력을 주어진 &lt;em&gt;outfile에&lt;/em&gt; 씁니다 . 그렇지 않으면 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; 에&lt;/a&gt; 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d838008f04fccbdbd310f0f2eda2be824679476" translate="yes" xml:space="preserve">
          <source>Write the output to a file named &lt;em&gt;output&lt;/em&gt;. If this option is not specified, the output filename will be the same as the input &lt;em&gt;source&lt;/em&gt;, with the extension &lt;code&gt;.pyz&lt;/code&gt; added. If an explicit filename is given, it is used as is (so a &lt;code&gt;.pyz&lt;/code&gt; extension should be included if required).</source>
          <target state="translated">라는 이름의 파일로 출력 쓰기 &lt;em&gt;출력을&lt;/em&gt; . 이 옵션을 지정하지 않으면 출력 파일 이름은 확장자가 &lt;code&gt;.pyz&lt;/code&gt; 인 입력 &lt;em&gt;소스&lt;/em&gt; 와 동일합니다 . 명시적인 파일 이름이 제공되면 그대로 사용됩니다. &lt;code&gt;.pyz&lt;/code&gt; 필요한 경우 .pyz 확장자를 포함해야 함).</target>
        </trans-unit>
        <trans-unit id="b82530a5087bab2d42ad0ddb90cf1ef9792a699a" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of &lt;em&gt;obj&lt;/em&gt; to the open file object given in the constructor.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 의 절인 표현을 생성자에 제공된 열린 파일 객체에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="2e3cb793d567a188a0b227ebd8f0b39627a11406" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of the object &lt;em&gt;obj&lt;/em&gt; to the open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;file&lt;/em&gt;. This is equivalent to &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt;.</source>
          <target state="translated">객체 &lt;em&gt;obj&lt;/em&gt; 의 pickled 표현을 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;파일에&lt;/em&gt; 씁니다 . 이것은 &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="014ee2af4e701fcab5e779636a1bab6243c960b6" translate="yes" xml:space="preserve">
          <source>Write the pickled representation of the object &lt;em&gt;obj&lt;/em&gt; to the open &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;file&lt;/em&gt;. This is equivalent to &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt;.</source>
          <target state="translated">객체 &lt;em&gt;obj&lt;/em&gt; 의 피클 표현을 열린 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;파일에&lt;/em&gt; 씁니다 . 이것은 &lt;code&gt;Pickler(file, protocol).dump(obj)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d26b0a11db95123185fa367e58a8b7362b3ed079" translate="yes" xml:space="preserve">
          <source>Write the results of the current profile to &lt;em&gt;filename&lt;/em&gt;.</source>
          <target state="translated">현재 프로파일의 결과를 &lt;em&gt;filename에&lt;/em&gt; 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5fb7530657763f9875f7b1f976e2ce7f011577e9" translate="yes" xml:space="preserve">
          <source>Write the snapshot into a file.</source>
          <target state="translated">스냅 샷을 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="85d258d2fb226ec2c0c709a20107d7d1cd49dda7" translate="yes" xml:space="preserve">
          <source>Write the string &lt;em&gt;s&lt;/em&gt; to the stream and return the number of characters written.</source>
          <target state="translated">문자열 기록 &lt;em&gt;들&lt;/em&gt; 스트림에 서면 문자 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a1f9fa39199b8be1519faca0bdbf541e2e1411a7" translate="yes" xml:space="preserve">
          <source>Write the value on the open file. The value must be a supported type. The file must be a writeable &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;binary file&lt;/a&gt;.</source>
          <target state="translated">열린 파일에 값을 씁니다. 값은 지원되는 유형이어야합니다. 파일은 쓰기 가능한 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;이진&lt;/a&gt; 파일이어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="0c7340eaff729a0a7bab0ac8f74a10c0b4a0bbbe" translate="yes" xml:space="preserve">
          <source>Write the value on the open file. The value must be a supported type. The file must be a writeable &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-binary-file&quot;&gt;binary file&lt;/a&gt;.</source>
          <target state="translated">열린 파일에 값을 씁니다. 값은 지원되는 유형이어야합니다. 파일은 쓰기 가능한 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-binary-file&quot;&gt;이진&lt;/a&gt; 파일이어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="2f0ad1cd3dd03f0a6c9c662064a29f7888fb5ccf" translate="yes" xml:space="preserve">
          <source>Write-only Transports</source>
          <target state="translated">쓰기 전용 전송</target>
        </trans-unit>
        <trans-unit id="335cbd7aaa63f61606a8ce6bfa9ddbc970e54241" translate="yes" xml:space="preserve">
          <source>Writer Objects</source>
          <target state="translated">라이터 객체</target>
        </trans-unit>
        <trans-unit id="4d0bf7b553d43cfdd760c33cc20420dd919b351d" translate="yes" xml:space="preserve">
          <source>Writer objects have the following public attribute:</source>
          <target state="translated">기록기 객체에는 다음과 같은 공용 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="35eda2b27bf2882a31d059cb23f01e9439d450de" translate="yes" xml:space="preserve">
          <source>Writes a sentinel to the queue to tell the listener to quit. This implementation uses &lt;code&gt;put_nowait()&lt;/code&gt;. You may want to override this method if you want to use timeouts or work with custom queue implementations.</source>
          <target state="translated">청취자를 종료하도록 알리기 위해 센티넬을 큐에 씁니다. 이 구현은 &lt;code&gt;put_nowait()&lt;/code&gt; 사용합니다 . 시간 종료를 사용하거나 사용자 정의 큐 구현에 대해 작업하려는 경우이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17739c26273b3c54186e1d431020da69cfc1db41" translate="yes" xml:space="preserve">
          <source>Writes all the attributes of a key to the registry.</source>
          <target state="translated">키의 모든 속성을 레지스트리에 씁니다.</target>
        </trans-unit>
        <trans-unit id="e658a7fb3a51b39345e62d94dba9025da173bea3" translate="yes" xml:space="preserve">
          <source>Writes an element tree or element structure to sys.stdout. This function should be used for debugging only.</source>
          <target state="translated">요소 트리 또는 요소 구조를 sys.stdout에 씁니다. 이 기능은 디버깅에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c80c0741f41bf444cf6674603a6956344dc09d2c" translate="yes" xml:space="preserve">
          <source>Writes the concatenated list of strings to the stream (possibly by reusing the &lt;a href=&quot;#codecs.StreamWriter.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method). The standard bytes-to-bytes codecs do not support this method.</source>
          <target state="translated">연결된 문자열 목록을 스트림에 &lt;a href=&quot;#codecs.StreamWriter.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 메서드를 재사용하여 가능 ). 표준 바이트-바이트 바이트 코덱은이 방법을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5380803f5da36b35d28343f1d050c78f6fcd7c0d" translate="yes" xml:space="preserve">
          <source>Writes the element tree to a file, as XML. &lt;em&gt;file&lt;/em&gt; is a file name, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for writing. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; controls if an XML declaration should be added to the file. Use &lt;code&gt;False&lt;/code&gt; for never, &lt;code&gt;True&lt;/code&gt; for always, &lt;code&gt;None&lt;/code&gt; for only if not US-ASCII or UTF-8 or Unicode (default is &lt;code&gt;None&lt;/code&gt;). &lt;em&gt;default_namespace&lt;/em&gt; sets the default XML namespace (for &amp;ldquo;xmlns&amp;rdquo;). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). The keyword-only &lt;em&gt;short_empty_elements&lt;/em&gt; parameter controls the formatting of elements that contain no content. If &lt;code&gt;True&lt;/code&gt; (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags.</source>
          <target state="translated">요소 트리를 XML로 파일에 씁니다. &lt;em&gt;file&lt;/em&gt; 은 파일 이름이거나 쓰기 위해 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; 은 출력 인코딩입니다 (기본값은 US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; 은 파일에 XML 선언을 추가 &lt;em&gt;해야하는지 여부를&lt;/em&gt; 제어합니다. US-ASCII 또는 UTF-8 또는 유니 코드가 아닌 경우에만 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;False&lt;/code&gt; 를 사용하고 , 항상 &lt;code&gt;True&lt;/code&gt; 를 사용하고 , None 을 사용하십시오 (기본값은 &lt;code&gt;None&lt;/code&gt; ). &lt;em&gt;default_namespace&lt;/em&gt; 는 기본 XML 네임 스페이스 ( &quot;xmlns&quot;의 경우)를 설정합니다. &lt;em&gt;메소드&lt;/em&gt; 는 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; , &lt;code&gt;&quot;html&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 입니다 (기본값은 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; ). 키워드 만&lt;em&gt; short_empty_elements&lt;/em&gt; 매개 변수는 내용이없는 요소의 형식을 제어합니다. 경우 &lt;code&gt;True&lt;/code&gt; (기본), 그들은 하나의 자기 폐쇄 태그로 방출, 그렇지 않은 경우는 시작 / 종료 태그의 쌍으로 방출된다.</target>
        </trans-unit>
        <trans-unit id="fc5eb318d92101439c44d64e484a16b9153e0a31" translate="yes" xml:space="preserve">
          <source>Writes the element tree to a file, as XML. &lt;em&gt;file&lt;/em&gt; is a file name, or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened for writing. &lt;em&gt;encoding&lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; is the output encoding (default is US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; controls if an XML declaration should be added to the file. Use &lt;code&gt;False&lt;/code&gt; for never, &lt;code&gt;True&lt;/code&gt; for always, &lt;code&gt;None&lt;/code&gt; for only if not US-ASCII or UTF-8 or Unicode (default is &lt;code&gt;None&lt;/code&gt;). &lt;em&gt;default_namespace&lt;/em&gt; sets the default XML namespace (for &amp;ldquo;xmlns&amp;rdquo;). &lt;em&gt;method&lt;/em&gt; is either &lt;code&gt;&quot;xml&quot;&lt;/code&gt;, &lt;code&gt;&quot;html&quot;&lt;/code&gt; or &lt;code&gt;&quot;text&quot;&lt;/code&gt; (default is &lt;code&gt;&quot;xml&quot;&lt;/code&gt;). The keyword-only &lt;em&gt;short_empty_elements&lt;/em&gt; parameter controls the formatting of elements that contain no content. If &lt;code&gt;True&lt;/code&gt; (the default), they are emitted as a single self-closed tag, otherwise they are emitted as a pair of start/end tags.</source>
          <target state="translated">요소 트리를 파일에 XML로 씁니다. &lt;em&gt;file&lt;/em&gt; 은 파일 이름 또는 쓰기 위해 열린 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 개체&lt;/a&gt; 입니다. &lt;em&gt;인코딩 &lt;/em&gt;&lt;a href=&quot;#id9&quot; id=&quot;id6&quot;&gt;1&lt;/a&gt; 은 출력 인코딩입니다 (기본값은 US-ASCII). &lt;em&gt;xml_declaration&lt;/em&gt; 은 XML 선언이 파일에 추가되어야하는지 여부를 제어합니다. US-ASCII, UTF-8 또는 유니 코드가 아닌 경우에만 &lt;code&gt;False&lt;/code&gt; , 항상 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;None&lt;/code&gt; 을 사용하십시오 (기본값은 &lt;code&gt;None&lt;/code&gt; ). &lt;em&gt;default_namespace&lt;/em&gt; 는 기본 XML 네임 스페이스 ( &quot;xmlns&quot;용)를 설정합니다. &lt;em&gt;method&lt;/em&gt; 는 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; , &lt;code&gt;&quot;html&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;text&quot;&lt;/code&gt; 입니다 (기본값은 &lt;code&gt;&quot;xml&quot;&lt;/code&gt; 입니다.). 키워드 전용 &lt;em&gt;short_empty_elements&lt;/em&gt; 매개 변수는 콘텐츠가없는 요소의 형식을 제어합니다. 경우 &lt;code&gt;True&lt;/code&gt; (기본), 그들은 하나의 자기 폐쇄 태그로 방출, 그렇지 않은 경우는 시작 / 종료 태그의 쌍으로 방출된다.</target>
        </trans-unit>
        <trans-unit id="25a8fba70140127a17356ef143684300827e20e9" translate="yes" xml:space="preserve">
          <source>Writes the object&amp;rsquo;s contents encoded to the stream.</source>
          <target state="translated">스트림에 인코딩 된 객체의 내용을 씁니다.</target>
        </trans-unit>
        <trans-unit id="cae18decb80c060b17ef47ce0c96553cc5c6d777" translate="yes" xml:space="preserve">
          <source>Writing PyUnit regression tests.</source>
          <target state="translated">PyUnit 회귀 테스트 작성</target>
        </trans-unit>
        <trans-unit id="25cc1ad64131bcda2eb3e49d5f401de5ae0fa111" translate="yes" xml:space="preserve">
          <source>Writing Unit Tests for the &lt;code&gt;test&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 패키지에 대한 단위 테스트 작성</target>
        </trans-unit>
        <trans-unit id="66d735f0726a922d346407641bd5cf2708118ab7" translate="yes" xml:space="preserve">
          <source>Writing Unit Tests for the test package</source>
          <target state="translated">테스트 패키지에 대한 단위 테스트 작성</target>
        </trans-unit>
        <trans-unit id="6623bd8fdf17715345d6e193b4a938d36d3a8912" translate="yes" xml:space="preserve">
          <source>Writing a Tokenizer</source>
          <target state="translated">토큰 화기 작성</target>
        </trans-unit>
        <trans-unit id="a7970cd648ac7bccb04089bb24dad00d62fe7de4" translate="yes" xml:space="preserve">
          <source>Writing an adapter lets you send custom Python types to SQLite. But to make it really useful we need to make the Python to SQLite to Python roundtrip work.</source>
          <target state="translated">어댑터를 작성하면 사용자 정의 Python 유형을 SQLite로 보낼 수 있습니다. 그러나 실제로 유용하게 만들려면 Python to SQLite to Python 왕복 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8dcb129b81a9b97ee4f1424a1e0fb697ea634d2f" translate="yes" xml:space="preserve">
          <source>Writing and reading a bzip2-compressed file in binary mode:</source>
          <target state="translated">바이너리 모드에서 bzip2 압축 파일 작성 및 읽기 :</target>
        </trans-unit>
        <trans-unit id="90d1fb7894a11f529f52cf8ecb5d9976ceef53b1" translate="yes" xml:space="preserve">
          <source>Writing compressed data to an already-open file:</source>
          <target state="translated">압축 파일을 이미 열린 파일에 쓰기 :</target>
        </trans-unit>
        <trans-unit id="423fd842912e5704c1495f92cbf775b3b301aaec" translate="yes" xml:space="preserve">
          <source>Writing outside the window, subwindow, or pad raises &lt;a href=&quot;#curses.error&quot;&gt;&lt;code&gt;curses.error&lt;/code&gt;&lt;/a&gt;. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the string is printed.</source>
          <target state="translated">창, &lt;a href=&quot;#curses.error&quot;&gt; &lt;code&gt;curses.error&lt;/code&gt; &lt;/a&gt; 창 또는 패드 외부에 쓰면 curses.error 가 발생 합니다. 창, 하위 창 또는 패드의 오른쪽 하단에 쓰려고하면 문자열이 인쇄 된 후 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="66b0caed981253d594af909c645888be42302ac7" translate="yes" xml:space="preserve">
          <source>Writing outside the window, subwindow, or pad raises a &lt;a href=&quot;#curses.error&quot;&gt;&lt;code&gt;curses.error&lt;/code&gt;&lt;/a&gt;. Attempting to write to the lower right corner of a window, subwindow, or pad will cause an exception to be raised after the character is printed.</source>
          <target state="translated">창, &lt;a href=&quot;#curses.error&quot;&gt; &lt;code&gt;curses.error&lt;/code&gt; &lt;/a&gt; 창 또는 패드 외부에 쓰면 저주가 발생 합니다. 창, 하위 창 또는 패드의 오른쪽 하단에 쓰려고하면 문자가 인쇄 된 후 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="463175f0030d6c5bc93c5ba14c4b34f90a466ed2" translate="yes" xml:space="preserve">
          <source>Written by James C. Ahlstrom, who also provided an implementation. Python 2.3 follows the specification in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0273&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 273&lt;/strong&gt;&lt;/a&gt;, but uses an implementation written by Just van Rossum that uses the import hooks described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">James C. Ahlstrom이 작성했으며 구현도 제공했습니다. Python 2.3은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0273&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 273&lt;/strong&gt;&lt;/a&gt; 의 사양을 따르지만 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302에&lt;/strong&gt;&lt;/a&gt; 설명 된 가져 오기 후크를 사용하는 Just van Rossum이 작성한 구현을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="270c60956bc9c23c8fe9a0b4bac1ed97cf2f4291" translate="yes" xml:space="preserve">
          <source>X Bitmap Files</source>
          <target state="translated">X 비트 맵 파일</target>
        </trans-unit>
        <trans-unit id="df2e2736374ccada1de5c3b7c05f3612bbc80534" translate="yes" xml:space="preserve">
          <source>XInclude support</source>
          <target state="translated">XInclude 지원</target>
        </trans-unit>
        <trans-unit id="1ad96390f6242f3cec13bdeae582a19d9407d608" translate="yes" xml:space="preserve">
          <source>XML Processing Modules</source>
          <target state="translated">XML 처리 모듈</target>
        </trans-unit>
        <trans-unit id="4c7f7159a8411bf46c36150c878849d3426e4995" translate="yes" xml:space="preserve">
          <source>XML data for the &lt;a href=&quot;#plistlib.FMT_XML&quot;&gt;&lt;code&gt;FMT_XML&lt;/code&gt;&lt;/a&gt; format is parsed using the Expat parser from &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; &amp;ndash; see its documentation for possible exceptions on ill-formed XML. Unknown elements will simply be ignored by the plist parser.</source>
          <target state="translated">에 대한 XML 데이터 &lt;a href=&quot;#plistlib.FMT_XML&quot;&gt; &lt;code&gt;FMT_XML&lt;/code&gt; 의&lt;/a&gt; 형식에서 국외 거주자 파서 사용하여 구문 분석 &lt;a href=&quot;pyexpat#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; 을&lt;/a&gt; - 잘못 형성된 XML에 가능한 예외에 대한 설명서를 참조하십시오. 알 수없는 요소는 plist 파서에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4e1a90d8df93786f8530be82d70f96c907403f" translate="yes" xml:space="preserve">
          <source>XML is an inherently hierarchical data format, and the most natural way to represent it is with a tree. &lt;code&gt;ET&lt;/code&gt; has two classes for this purpose - &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; represents the whole XML document as a tree, and &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; represents a single node in this tree. Interactions with the whole document (reading and writing to/from files) are usually done on the &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; level. Interactions with a single XML element and its sub-elements are done on the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; level.</source>
          <target state="translated">XML은 본질적으로 계층 적 데이터 형식이며이를 나타내는 가장 자연스러운 방법은 트리를 사용하는 것입니다. &lt;code&gt;ET&lt;/code&gt; 는이를 위해 두 개의 클래스를 가지고 있습니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; &lt;/a&gt; 는 전체 XML 문서를 트리로 나타내고 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 는이 트리에서 단일 노드를 나타냅니다. 전체 문서와의 상호 작용 (파일 읽기 / 쓰기)은 일반적으로 &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; &lt;/a&gt; 수준 에서 수행됩니다 . 단일 XML 요소 및 해당 하위 요소와의 상호 작용은 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 수준 에서 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9924906708da9844dcf966582660a824d07419a9" translate="yes" xml:space="preserve">
          <source>XML parse error, raised by the various parsing methods in this module when parsing fails. The string representation of an instance of this exception will contain a user-friendly error message. In addition, it will have the following attributes available:</source>
          <target state="translated">구문 분석이 실패 할 때이 모듈의 다양한 구문 분석 방법으로 인해 XML 구문 분석 오류가 발생합니다. 이 예외 인스턴스의 문자열 표현에는 사용자에게 친숙한 오류 메시지가 포함됩니다. 또한 다음과 같은 속성을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="096332ac995cd54246f20718b546ac8586de4200" translate="yes" xml:space="preserve">
          <source>XML tree and elements</source>
          <target state="translated">XML 트리 및 요소</target>
        </trans-unit>
        <trans-unit id="d10f7ada917a0516264a166e94fe43f43a7f141e" translate="yes" xml:space="preserve">
          <source>XML vulnerabilities</source>
          <target state="translated">XML 취약점</target>
        </trans-unit>
        <trans-unit id="c5d50f18d7b7a0ea894fe5f24aec3e7baf72508e" translate="yes" xml:space="preserve">
          <source>XML-RPC HOWTO</source>
          <target state="translated">XML-RPC 하우투</target>
        </trans-unit>
        <trans-unit id="5ecaf07183071066578274e8760e0bea165e82a4" translate="yes" xml:space="preserve">
          <source>XML-RPC Introspection</source>
          <target state="translated">XML-RPC 검사</target>
        </trans-unit>
        <trans-unit id="e68fd76cd84fb2c95d9fbb40006ec3cb311e1bc2" translate="yes" xml:space="preserve">
          <source>XML-RPC Specification</source>
          <target state="translated">XML-RPC 사양</target>
        </trans-unit>
        <trans-unit id="2e48b9fbebc39ff8c9f81e1b9bc7ae35dc6312d6" translate="yes" xml:space="preserve">
          <source>XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP as a transport. With it, a client can call methods with parameters on a remote server (the server is named by a URI) and get back structured data.</source>
          <target state="translated">XML-RPC는 HTTP를 통해 전달 된 XML을 전송으로 사용하는 원격 프로 시저 호출 방법입니다. 이를 통해 클라이언트는 원격 서버에서 매개 변수가있는 메소드를 호출하고 (서버는 URI로 이름 지정됨) 구조화 된 데이터를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a3256ce956df095fe4314c0a860638e54fbdef5" translate="yes" xml:space="preserve">
          <source>XML-RPC is a Remote Procedure Call method that uses XML passed via HTTP(S) as a transport. With it, a client can call methods with parameters on a remote server (the server is named by a URI) and get back structured data. This module supports writing XML-RPC client code; it handles all the details of translating between conformable Python objects and XML on the wire.</source>
          <target state="translated">XML-RPC는 HTTP (S)를 통해 전달 된 XML을 전송으로 사용하는 원격 프로 시저 호출 방법입니다. 이를 통해 클라이언트는 원격 서버에서 매개 변수가있는 메소드를 호출하고 (서버는 URI로 이름 지정됨) 구조화 된 데이터를 다시 가져올 수 있습니다. 이 모듈은 XML-RPC 클라이언트 코드 작성을 지원합니다. 그것은 적합한 파이썬 객체와 XML을 XML로 변환하는 모든 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="466d1915a26cde29cec1e37e7777bd7f436a3403" translate="yes" xml:space="preserve">
          <source>XML-RPC type</source>
          <target state="translated">XML-RPC 유형</target>
        </trans-unit>
        <trans-unit id="b48dd5178a470f86e203690c7805dc9b0b2341c0" translate="yes" xml:space="preserve">
          <source>XMLParser Objects</source>
          <target state="translated">XMLParser 객체</target>
        </trans-unit>
        <trans-unit id="9e9410180aab9a821557dcc7d0d4c2058d73dd7c" translate="yes" xml:space="preserve">
          <source>XMLPullParser Objects</source>
          <target state="translated">XMLPullParser 객체</target>
        </trans-unit>
        <trans-unit id="c0a5ba60aa26c1d7531b3906ecd8c55209f2d410" translate="yes" xml:space="preserve">
          <source>XMLReader Objects</source>
          <target state="translated">XMLReader 객체</target>
        </trans-unit>
        <trans-unit id="bfa3cfc9c89b42310a22b649c3f853faf5dd886d" translate="yes" xml:space="preserve">
          <source>XOFF, for flow control</source>
          <target state="translated">흐름 제어를위한 XOFF</target>
        </trans-unit>
        <trans-unit id="dd84031d44b67a1ddb8cdee96e88fe594f8656ed" translate="yes" xml:space="preserve">
          <source>XON, for flow control</source>
          <target state="translated">흐름 제어용 XON</target>
        </trans-unit>
        <trans-unit id="39c789da8e50b0e071e1c885013d7a4b29164374" translate="yes" xml:space="preserve">
          <source>XPath support</source>
          <target state="translated">XPath 지원</target>
        </trans-unit>
        <trans-unit id="6060d77ff0f25227959b320cc3c85a394bdc6230" translate="yes" xml:space="preserve">
          <source>Xlib (C)</source>
          <target state="translated">Xlib (C)</target>
        </trans-unit>
        <trans-unit id="53c91c9cd5c47000ef428a9ab7e99e267172260b" translate="yes" xml:space="preserve">
          <source>Year (&amp;gt;= 1980)</source>
          <target state="translated">연도 (&amp;gt; = 1980)</target>
        </trans-unit>
        <trans-unit id="b5b7f5d30699e5d4e15b4875dbd3728c364030a0" translate="yes" xml:space="preserve">
          <source>Year with century as a decimal number.</source>
          <target state="translated">십진수로 세기를 가진 년.</target>
        </trans-unit>
        <trans-unit id="c64879d90ccc2fc0d06f018314bfc95458d99f67" translate="yes" xml:space="preserve">
          <source>Year without century as a decimal number [00,99].</source>
          <target state="translated">세기가없는 연도 (10 진수) [00,99].</target>
        </trans-unit>
        <trans-unit id="872bdd7e5e7113390d4c8fa46dd39ec67115b808" translate="yes" xml:space="preserve">
          <source>Year without century as a zero-padded decimal number.</source>
          <target state="translated">세기가없는 연도는 0으로 채워진 10 진수입니다.</target>
        </trans-unit>
        <trans-unit id="3526f607bcd4f51ad0bc05f814579a42c2c0ba57" translate="yes" xml:space="preserve">
          <source>Yellow</source>
          <target state="translated">Yellow</target>
        </trans-unit>
        <trans-unit id="4b7d9108b065dee3edad5735649aad18773cab07" translate="yes" xml:space="preserve">
          <source>Yet another view is the transport and protocol interfaces together define an abstract interface for using network I/O and interprocess I/O.</source>
          <target state="translated">또 다른 관점은 전송 및 프로토콜 인터페이스가 네트워크 I / O 및 프로세스 간 I / O를 사용하기위한 추상 인터페이스를 함께 정의한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a7feecab2e1b4006a64972db4b4b19657a1f23d1" translate="yes" xml:space="preserve">
          <source>Yield &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; objects for the given module name.</source>
          <target state="translated">항복 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;찾기&lt;/a&gt; 주어진 모듈 이름을 객체.</target>
        </trans-unit>
        <trans-unit id="831464f24cac0120f2caade5d640afb021f5150a" translate="yes" xml:space="preserve">
          <source>Yield &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; objects for the given module name.</source>
          <target state="translated">주어진 모듈 이름에 대한 Yield &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;Finder&lt;/a&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="023c595fbee175f8fca03795fa86cafa1a4d11e0" translate="yes" xml:space="preserve">
          <source>Yield a tuple of &lt;code&gt;(fieldname, value)&lt;/code&gt; for each field in &lt;code&gt;node._fields&lt;/code&gt; that is present on &lt;em&gt;node&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;node&lt;/em&gt; 에 있는 &lt;code&gt;node._fields&lt;/code&gt; 의 각 필드에 대해 (필드 &lt;code&gt;(fieldname, value)&lt;/code&gt; 튜플 을 생성 &lt;em&gt;합니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d6779be84159814116de4d6defda58236dc2d77b" translate="yes" xml:space="preserve">
          <source>Yield all direct child nodes of &lt;em&gt;node&lt;/em&gt;, that is, all fields that are nodes and all items of fields that are lists of nodes.</source>
          <target state="translated">node의 모든 직접 하위 노드 , 즉 &lt;em&gt;노드&lt;/em&gt; 인 모든 필드와 노드 목록 인 모든 필드 항목을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="836fb31f30edf4301b980b0c16e58e5aca0eb9ba" translate="yes" xml:space="preserve">
          <source>Yields &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt;&lt;code&gt;ModuleInfo&lt;/code&gt;&lt;/a&gt; for all modules recursively on &lt;em&gt;path&lt;/em&gt;, or, if &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, all accessible modules.</source>
          <target state="translated">수익률은 &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt; &lt;code&gt;ModuleInfo&lt;/code&gt; &lt;/a&gt; 재귀 적으로 모든 모듈에 대한 &lt;em&gt;경로&lt;/em&gt; 경우, 또는 &lt;em&gt;경로가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 액세스 가능한 모든 모듈을.</target>
        </trans-unit>
        <trans-unit id="e9faaa5a777c93309c3cc258992e9b2bf854a04d" translate="yes" xml:space="preserve">
          <source>Yields &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt;&lt;code&gt;ModuleInfo&lt;/code&gt;&lt;/a&gt; for all submodules on &lt;em&gt;path&lt;/em&gt;, or, if &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, all top-level modules on &lt;code&gt;sys.path&lt;/code&gt;.</source>
          <target state="translated">수익률은 &lt;a href=&quot;#pkgutil.ModuleInfo&quot;&gt; &lt;code&gt;ModuleInfo&lt;/code&gt; &lt;/a&gt; 의 모든 서브 모듈에 대한 &lt;em&gt;경로&lt;/em&gt; 경우, 또는 &lt;em&gt;경로가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 모든 최상위 모듈 &lt;code&gt;sys.path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7e2b5d8b96f15b1607e0fd8f2aba767f499b4cc" translate="yes" xml:space="preserve">
          <source>You &amp;ldquo;block&amp;rdquo; attributes by deleting them. Once deleted, accessing an attribute will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성을 삭제하여 &quot;차단&quot;합니다. 삭제되면 속성에 액세스하면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="e75e02c51bec7a3ae6df9959824abb351dfd2a65" translate="yes" xml:space="preserve">
          <source>You can add a call to &lt;a href=&quot;pdb#pdb.set_trace&quot;&gt;&lt;code&gt;pdb.set_trace()&lt;/code&gt;&lt;/a&gt; in a doctest example, and you&amp;rsquo;ll drop into the Python debugger when that line is executed. Then you can inspect current values of variables, and so on. For example, suppose &lt;code&gt;a.py&lt;/code&gt; contains just this module docstring:</source>
          <target state="translated">doctest 예제에서 &lt;a href=&quot;pdb#pdb.set_trace&quot;&gt; &lt;code&gt;pdb.set_trace()&lt;/code&gt; &lt;/a&gt; 에 대한 호출을 추가 할 수 있으며 해당 행이 실행될 때 Python 디버거에 빠지게됩니다. 그런 다음 변수의 현재 값 등을 검사 할 수 있습니다. 예를 들어, &lt;code&gt;a.py&lt;/code&gt; 에이 모듈 docstring 만 포함되어 있다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="8cb5ee2b3c4d39d5885e625e1382b9b2cbcbbadc" translate="yes" xml:space="preserve">
          <source>You can also create a &lt;code&gt;Document&lt;/code&gt; by calling a method on a &amp;ldquo;DOM Implementation&amp;rdquo; object. You can get this object either by calling the &lt;code&gt;getDOMImplementation()&lt;/code&gt; function in the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; package or the &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; module. Once you have a &lt;code&gt;Document&lt;/code&gt;, you can add child nodes to it to populate the DOM:</source>
          <target state="translated">&quot;DOM 구현&quot;개체에서 메서드를 호출 하여 &lt;code&gt;Document&lt;/code&gt; 를 만들 수도 있습니다 . &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 패키지 또는 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;code&gt;getDOMImplementation()&lt;/code&gt; 함수를 호출하여이 오브젝트를 얻을 수 있습니다 . 당신은 일단 &lt;code&gt;Document&lt;/code&gt; , 당신은 DOM을 채우는 데에 자식 노드를 추가 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6cd29f26483ed42fd8dc1116c4e8174423d8b0c6" translate="yes" xml:space="preserve">
          <source>You can also customize &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; argument conversion to allow instances of your own classes be used as function arguments. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; looks for an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute and uses this as the function argument. Of course, it must be one of integer, string, or bytes:</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 인수 변환을 사용자 정의 하여 자신의 클래스 인스턴스를 함수 인수로 사용할 수 있습니다. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;_as_parameter_&lt;/code&gt; 속성을 찾고 이를 함수 인수로 사용합니다. 물론 정수, 문자열 또는 바이트 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="04e30ddb9ce13f853c2bfa8e3007580a9b8c57cc" translate="yes" xml:space="preserve">
          <source>You can also extract a tar archive into a different directory by passing the directory&amp;rsquo;s name:</source>
          <target state="translated">디렉토리 이름을 전달하여 tar 아카이브를 다른 디렉토리로 추출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bd455d2467cd1dcd0d2e97d17dee374eccd5cfd" translate="yes" xml:space="preserve">
          <source>You can also get a &lt;a href=&quot;#version&quot;&gt;distribution&amp;rsquo;s version number&lt;/a&gt;, list its &lt;a href=&quot;#files&quot;&gt;constituent files&lt;/a&gt;, and get a list of the distribution&amp;rsquo;s &lt;a href=&quot;#requirements&quot;&gt;Distribution requirements&lt;/a&gt;.</source>
          <target state="translated">또한 얻을 수 &lt;a href=&quot;#version&quot;&gt;배포판의 버전 번호를&lt;/a&gt; 그 목록을 &lt;a href=&quot;#files&quot;&gt;구성 파일&lt;/a&gt; 및 분배의 목록을 얻을 &lt;a href=&quot;#requirements&quot;&gt;배포 요구 사항을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68300502198932658513c3b6ded30832208e1d6" translate="yes" xml:space="preserve">
          <source>You can also get the full set of files contained within a distribution. The &lt;code&gt;files()&lt;/code&gt; function takes a distribution package name and returns all of the files installed by this distribution. Each file object returned is a &lt;code&gt;PackagePath&lt;/code&gt;, a &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;pathlib.Path&lt;/a&gt; derived object with additional &lt;code&gt;dist&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;hash&lt;/code&gt; properties as indicated by the metadata. For example:</source>
          <target state="translated">배포에 포함 된 전체 파일 세트를 얻을 수도 있습니다. &lt;code&gt;files()&lt;/code&gt; 함수는 배포 패키지 이름과 반환이 배포에 의해 설치된 모든 파일을합니다. 반환 된 각 파일 객체 는 메타 데이터로 표시되는 추가 &lt;code&gt;dist&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; 및 &lt;code&gt;hash&lt;/code&gt; 속성이 있는 &lt;a href=&quot;https://docs.python.org/3/library/pathlib.html#pathlib.Path&quot;&gt;pathlib.Path&lt;/a&gt; 파생 객체 인 &lt;code&gt;PackagePath&lt;/code&gt; 입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c6a42f0aeadf60a525c55a9533ae3027f565e03f" translate="yes" xml:space="preserve">
          <source>You can also get the full set of files contained within a distribution. The &lt;code&gt;files()&lt;/code&gt; function takes a distribution package name and returns all of the files installed by this distribution. Each file object returned is a &lt;code&gt;PackagePath&lt;/code&gt;, a &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; derived object with additional &lt;code&gt;dist&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt;, and &lt;code&gt;hash&lt;/code&gt; properties as indicated by the metadata. For example:</source>
          <target state="translated">배포에 포함 된 전체 파일 세트를 가져올 수도 있습니다. &lt;code&gt;files()&lt;/code&gt; 함수는 배포 패키지 이름과 반환이 배포에 의해 설치된 모든 파일을합니다. 반환 된 각 파일 객체 는 메타 데이터에 표시된 추가 &lt;code&gt;dist&lt;/code&gt; , &lt;code&gt;size&lt;/code&gt; 및 &lt;code&gt;hash&lt;/code&gt; 속성이 있는 &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 파생 객체 인 &lt;code&gt;PackagePath&lt;/code&gt; 입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="13be6cdea4e3d4decb6434c0ceed8a0ae35d3756" translate="yes" xml:space="preserve">
          <source>You can also get the set of entry points keyed by group, such as &lt;code&gt;console_scripts&lt;/code&gt;, &lt;code&gt;distutils.commands&lt;/code&gt; and others. Each group contains a sequence of &lt;a href=&quot;#entry-points&quot;&gt;EntryPoint&lt;/a&gt; objects.</source>
          <target state="translated">&lt;code&gt;console_scripts&lt;/code&gt; , &lt;code&gt;distutils.commands&lt;/code&gt; 등과 같은 그룹별로 키 입력 항목 세트를 얻을 수도 있습니다. 각 그룹에는 일련의 &lt;a href=&quot;#entry-points&quot;&gt;EntryPoint&lt;/a&gt; 객체 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="c554438646a4fbb6bf065d2eb85cf775c355cab2" translate="yes" xml:space="preserve">
          <source>You can also override this method in an abstract base class:</source>
          <target state="translated">추상 기본 클래스에서이 메소드를 대체 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="190f0f3ab62c7ad1e17bcd39e5e06e81ea5e0af0" translate="yes" xml:space="preserve">
          <source>You can also set it to any other callable that accepts a single bytestring parameter and returns the resulting object.</source>
          <target state="translated">단일 바이트 문자열 매개 변수를 허용하고 결과 객체를 반환하는 다른 호출 가능으로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdf53e0a2dfd4a1e030ae29ed48f2c5b451befc1" translate="yes" xml:space="preserve">
          <source>You can also supply the special name &lt;code&gt;:memory:&lt;/code&gt; to create a database in RAM.</source>
          <target state="translated">RAM에 데이터베이스를 작성하기 위해 특수 이름 &lt;code&gt;:memory:&lt;/code&gt; 를 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10258a035721306e7f2e7a26bdaef81ffbba54de" translate="yes" xml:space="preserve">
          <source>You can also use &lt;strong&gt;pydoc&lt;/strong&gt; to start an HTTP server on the local machine that will serve documentation to visiting Web browsers. &lt;strong&gt;pydoc -p 1234&lt;/strong&gt; will start a HTTP server on port 1234, allowing you to browse the documentation at &lt;code&gt;http://localhost:1234/&lt;/code&gt; in your preferred Web browser. Specifying &lt;code&gt;0&lt;/code&gt; as the port number will select an arbitrary unused port.</source>
          <target state="translated">&lt;strong&gt;pydoc&lt;/strong&gt; 을 사용 하여 웹 브라우저 방문에 대한 문서를 제공하는 로컬 시스템에서 HTTP 서버를 시작할 수도 있습니다 . &lt;strong&gt;pydoc -p 1234&lt;/strong&gt; 는 포트 1234에서 HTTP 서버를 시작하여 &lt;code&gt;http://localhost:1234/&lt;/code&gt; 하여 원하는 웹 브라우저 http : // localhost : 1234 / . 포트 번호로 &lt;code&gt;0&lt;/code&gt; 을 지정 하면 임의의 미사용 포트가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="eda72f19cb6e48b513d9b28377c92f2ebdb8b1bd" translate="yes" xml:space="preserve">
          <source>You can also use a callable Python object (a function or a class for example) as the &lt;code&gt;restype&lt;/code&gt; attribute, if the foreign function returns an integer. The callable will be called with the &lt;em&gt;integer&lt;/em&gt; the C function returns, and the result of this call will be used as the result of your function call. This is useful to check for error return values and automatically raise an exception:</source>
          <target state="translated">호출 가능한 Python 객체 (예 : 함수 또는 클래스)를 &lt;code&gt;restype&lt;/code&gt; 으로 사용할 수도 있습니다.외부 함수가 정수를 반환하는 경우 속성 . callable은 C 함수가 반환 하는 &lt;em&gt;정수로&lt;/em&gt; 호출되며이 호출 의 결과는 함수 호출의 결과로 사용됩니다. 이는 오류 반환 값을 확인하고 자동으로 예외를 발생시키는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="454870431f74d4866521fb0079e0632baf5ce8fd" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;#decimal.localcontext&quot;&gt;&lt;code&gt;localcontext()&lt;/code&gt;&lt;/a&gt; function to temporarily change the active context.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문과 &lt;a href=&quot;#decimal.localcontext&quot;&gt; &lt;code&gt;localcontext()&lt;/code&gt; &lt;/a&gt; 사용할 수도 있습니다 일시적으로 활성화 컨텍스트를 변경하는 기능.</target>
        </trans-unit>
        <trans-unit id="b60697ea5592e1d15b0989fd09285ea42c7ffe7a" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement and the &lt;a href=&quot;#decimal.localcontext&quot;&gt;&lt;code&gt;localcontext()&lt;/code&gt;&lt;/a&gt; function to temporarily change the active context.</source>
          <target state="translated">당신은 또한 사용할 수 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문과 &lt;a href=&quot;#decimal.localcontext&quot;&gt; &lt;code&gt;localcontext()&lt;/code&gt; &lt;/a&gt; 일시적으로 활성화 컨텍스트를 변경하는 기능.</target>
        </trans-unit>
        <trans-unit id="80f46ed4471fe65e1faf5ebf1891ef4d016092a2" translate="yes" xml:space="preserve">
          <source>You can avoid calling this method explicitly by using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The following code will automatically unlink &lt;em&gt;dom&lt;/em&gt; when the &lt;code&gt;with&lt;/code&gt; block is exited:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 을 사용하여이 메서드를 명시 적으로 호출하지 않아도 됩니다. &lt;code&gt;with&lt;/code&gt; 블록이 종료 되면 다음 코드는 &lt;em&gt;dom&lt;/em&gt; 을 자동으로 연결 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="dde83b96548c4f32be3edb9f1d11f917c25e4700" translate="yes" xml:space="preserve">
          <source>You can avoid calling this method explicitly by using the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The following code will automatically unlink &lt;em&gt;dom&lt;/em&gt; when the &lt;code&gt;with&lt;/code&gt; block is exited:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 을 사용하여이 메서드를 명시 적으로 호출하지 않도록 할 수 있습니다 . 다음 코드는 &lt;code&gt;with&lt;/code&gt; 블록이 종료 될 때 자동으로 &lt;em&gt;dom&lt;/em&gt; 연결을 해제합니다 .</target>
        </trans-unit>
        <trans-unit id="9ff8e543590eb6efdd79bbec14ee431d600224b1" translate="yes" xml:space="preserve">
          <source>You can avoid having to call this method explicitly if you use the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will shutdown the &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; (waiting as if &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt;&lt;code&gt;Executor.shutdown()&lt;/code&gt;&lt;/a&gt; were called with &lt;em&gt;wait&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 을 사용 하면 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 를 종료시키는 ( &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt; &lt;code&gt;Executor.shutdown()&lt;/code&gt; &lt;/a&gt; 이 &lt;em&gt;wait로&lt;/em&gt; 설정된 상태에서 &lt;em&gt;대기 한 상태&lt;/em&gt; 에서 &lt;code&gt;True&lt;/code&gt; 로 설정 되는 경우 ) 대기 하는 경우이 메소드를 명시 적으로 호출하지 않아도됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ce715771653f7d4737a60a7668bc850ae2719d7" translate="yes" xml:space="preserve">
          <source>You can avoid having to call this method explicitly if you use the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will shutdown the &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; (waiting as if &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt;&lt;code&gt;Executor.shutdown()&lt;/code&gt;&lt;/a&gt; were called with &lt;em&gt;wait&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 을 사용하면이 메서드를 명시 적으로 호출하지 않아도됩니다. 그러면 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 가 종료 됩니다 &lt;a href=&quot;#concurrent.futures.Executor.shutdown&quot;&gt; &lt;code&gt;Executor.shutdown()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; wait&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정된 상태에서 Executor.shutdown () 이 호출 된 것처럼 대기 함 ).</target>
        </trans-unit>
        <trans-unit id="eddf45cff20d1b2f04fdafeec9e97e0ab7dd24ce" translate="yes" xml:space="preserve">
          <source>You can call &lt;a href=&quot;#hashlib.hash.update&quot;&gt;&lt;code&gt;hash.update()&lt;/code&gt;&lt;/a&gt; as many times as you need to iteratively update the hash:</source>
          <target state="translated">해시를 반복적으로 업데이트하는 데 필요한 횟수만큼 &lt;a href=&quot;#hashlib.hash.update&quot;&gt; &lt;code&gt;hash.update()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34c3da7abf9b07dabb72b6daa7e9e7c974938c68" translate="yes" xml:space="preserve">
          <source>You can call these functions like any other Python callable. This example uses the &lt;code&gt;time()&lt;/code&gt; function, which returns system time in seconds since the Unix epoch, and the &lt;code&gt;GetModuleHandleA()&lt;/code&gt; function, which returns a win32 module handle.</source>
          <target state="translated">이 함수를 다른 파이썬 호출 가능 함수와 같이 호출 할 수 있습니다. 이 예제는 유닉스 시대 이후 시스템 시간을 초 단위로 반환 하는 &lt;code&gt;time()&lt;/code&gt; 함수와 win32 모듈 핸들을 반환하는 &lt;code&gt;GetModuleHandleA()&lt;/code&gt; 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9c9c3c4d6ee67054cff47adecf258437ce7a8a43" translate="yes" xml:space="preserve">
          <source>You can call this method from a different thread to abort any queries that might be executing on the connection. The query will then abort and the caller will get an exception.</source>
          <target state="translated">다른 스레드에서이 메소드를 호출하여 연결에서 실행될 수있는 쿼리를 중단 할 수 있습니다. 그러면 쿼리가 중단되고 호출자에게 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f34bf214bdf66878eb786811d2f218be800ab6aa" translate="yes" xml:space="preserve">
          <source>You can change this attribute to a callable that accepts the cursor and the original row as a tuple and will return the real result row. This way, you can implement more advanced ways of returning results, such as returning an object that can also access columns by name.</source>
          <target state="translated">이 속성을 커서와 원래 행을 튜플로 승인하고 실제 결과 행을 리턴하는 호출 가능으로 변경할 수 있습니다. 이런 식으로 이름별로 열에 액세스 할 수있는 객체를 반환하는 등보다 고급 결과 반환 방법을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dfc510d44c70187526acac335d43e20ac9ac3b7" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;dir_fd&lt;/em&gt; is supported for a particular function on your platform using &lt;a href=&quot;#os.supports_dir_fd&quot;&gt;&lt;code&gt;os.supports_dir_fd&lt;/code&gt;&lt;/a&gt;. If it&amp;rsquo;s unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 있는지 여부를 확인할 수 있습니다 &lt;em&gt;dir_fd&lt;/em&gt; 사용하여 플랫폼에 특정 기능이 지원됩니다 &lt;a href=&quot;#os.supports_dir_fd&quot;&gt; &lt;code&gt;os.supports_dir_fd&lt;/code&gt; &lt;/a&gt; . 사용할 수 없으면 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="f63f9df6440b712c040a96a597c89c59d5cd17c0" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;follow_symlinks&lt;/em&gt; is supported for a particular function on your platform using &lt;a href=&quot;#os.supports_follow_symlinks&quot;&gt;&lt;code&gt;os.supports_follow_symlinks&lt;/code&gt;&lt;/a&gt;. If it&amp;rsquo;s unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 있는지 여부를 확인할 수 있습니다 &lt;em&gt;follow_symlinks를&lt;/em&gt; 사용하여 플랫폼에 특정 기능이 지원됩니다 &lt;a href=&quot;#os.supports_follow_symlinks&quot;&gt; &lt;code&gt;os.supports_follow_symlinks&lt;/code&gt; 을&lt;/a&gt; . 사용할 수없는 경우 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생합니다&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2d14bdf3cfbfc55eeb19102c8785836424dd0384" translate="yes" xml:space="preserve">
          <source>You can check whether or not &lt;em&gt;path&lt;/em&gt; can be specified as a file descriptor for a particular function on your platform using &lt;a href=&quot;#os.supports_fd&quot;&gt;&lt;code&gt;os.supports_fd&lt;/code&gt;&lt;/a&gt;. If this functionality is unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신이 있는지 여부를 확인할 수 있습니다 &lt;em&gt;경로를&lt;/em&gt; 사용하여 플랫폼의 특정 기능을위한 파일 기술자로 지정할 수 있습니다 &lt;a href=&quot;#os.supports_fd&quot;&gt; &lt;code&gt;os.supports_fd&lt;/code&gt; &lt;/a&gt; . 이 기능을 사용할 수없는 경우 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6e32b868cec8c152364c46842077c4cc9e7fa693" translate="yes" xml:space="preserve">
          <source>You can control how files are opened by providing an opening hook via the &lt;em&gt;openhook&lt;/em&gt; parameter to &lt;a href=&quot;#fileinput.input&quot;&gt;&lt;code&gt;fileinput.input()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#fileinput.FileInput&quot;&gt;&lt;code&gt;FileInput()&lt;/code&gt;&lt;/a&gt;. The hook must be a function that takes two arguments, &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt;, and returns an accordingly opened file-like object. Two useful hooks are already provided by this module.</source>
          <target state="translated">&lt;em&gt;openhook&lt;/em&gt; 매개 변수를 통해 &lt;a href=&quot;#fileinput.input&quot;&gt; &lt;code&gt;fileinput.input()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#fileinput.FileInput&quot;&gt; &lt;code&gt;FileInput()&lt;/code&gt; &lt;/a&gt; 오프닝 후크를 제공하여 파일을 여는 방법을 제어 할 수 있습니다 . 후크는 &lt;em&gt;파일 이름&lt;/em&gt; 과 &lt;em&gt;모드&lt;/em&gt; 라는 두 가지 인수를 취하는 함수 여야 &lt;em&gt;합니다&lt;/em&gt; 그에 따라 열린 파일과 같은 객체를 반환하는 합니다. 이 모듈에는 두 가지 유용한 후크가 이미 제공되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="759d4b35c7817f3e8c98a2e2dd3e428931ede384" translate="yes" xml:space="preserve">
          <source>You can control which kind of &lt;code&gt;BEGIN&lt;/code&gt; statements &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; implicitly executes via the &lt;em&gt;isolation_level&lt;/em&gt; parameter to the &lt;a href=&quot;#sqlite3.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; call, or via the &lt;code&gt;isolation_level&lt;/code&gt; property of connections. If you specify no &lt;em&gt;isolation_level&lt;/em&gt;, a plain &lt;code&gt;BEGIN&lt;/code&gt; is used, which is equivalent to specifying &lt;code&gt;DEFERRED&lt;/code&gt;. Other possible values are &lt;code&gt;IMMEDIATE&lt;/code&gt; and &lt;code&gt;EXCLUSIVE&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#sqlite3.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 호출에 대한 &lt;em&gt;isolation_level&lt;/em&gt; 매개 변수를 통해 또는 연결의 &lt;code&gt;isolation_level&lt;/code&gt; 특성을 통해 암시 적으로 실행하는 &lt;code&gt;BEGIN&lt;/code&gt; 문의 종류를 제어 할 수 있습니다 . &lt;em&gt;isolation_level&lt;/em&gt; 을 지정하지 않으면 일반 &lt;code&gt;BEGIN&lt;/code&gt; 이 사용되며 이는 &lt;code&gt;DEFERRED&lt;/code&gt; 지정과 동일합니다 . 다른 가능한 값은 &lt;code&gt;IMMEDIATE&lt;/code&gt; 및 &lt;code&gt;EXCLUSIVE&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="34baf03473d0f12ec482dd3869630ac31ac0cdee" translate="yes" xml:space="preserve">
          <source>You can create a new object structure by creating &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instances, adding attachments and all the appropriate headers manually. For MIME messages though, the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package provides some convenient subclasses to make things easier.</source>
          <target state="translated">&lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성 하고 첨부 파일 및 모든 해당 헤더를 수동으로 추가 하여 새 오브젝트 구조를 작성할 수 있습니다. 그러나 MIME 메시지의 경우 &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 작업을 쉽게하기 위해 편리한 하위 클래스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f5697da2c07ba075dd78f5d4867d1c352a9a54b9" translate="yes" xml:space="preserve">
          <source>You can deactivate a virtual environment by typing &amp;ldquo;deactivate&amp;rdquo; in your shell. The exact mechanism is platform-specific and is an internal implementation detail (typically a script or shell function will be used).</source>
          <target state="translated">쉘에&amp;ldquo;비활성화&amp;rdquo;를 입력하여 가상 환경을 비활성화 할 수 있습니다. 정확한 메커니즘은 플랫폼에 따라 다르며 내부 구현 세부 사항입니다 (일반적으로 스크립트 또는 셸 함수가 사용됨).</target>
        </trans-unit>
        <trans-unit id="ac0ac8096a20f57f84bc75d77322b86d3e701044" translate="yes" xml:space="preserve">
          <source>You can delete items in this mapping to unset environment variables. &lt;a href=&quot;#os.unsetenv&quot;&gt;&lt;code&gt;unsetenv()&lt;/code&gt;&lt;/a&gt; will be called automatically when an item is deleted from &lt;code&gt;os.environ&lt;/code&gt;, and when one of the &lt;code&gt;pop()&lt;/code&gt; or &lt;code&gt;clear()&lt;/code&gt; methods is called.</source>
          <target state="translated">이 매핑에서 항목을 삭제하여 환경 변수를 설정 해제 할 수 있습니다. &lt;a href=&quot;#os.unsetenv&quot;&gt; &lt;code&gt;unsetenv()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;os.environ&lt;/code&gt; 에서 항목이 삭제 될 때와 &lt;code&gt;pop()&lt;/code&gt; 또는 &lt;code&gt;clear()&lt;/code&gt; 메서드 중 하나 가 호출 될 때 자동으로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="3165c20f5760e56d7cc769937fc9c54ec9eb5b3c" translate="yes" xml:space="preserve">
          <source>You can disable the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s implicit transaction management by setting &lt;code&gt;isolation_level&lt;/code&gt; to &lt;code&gt;None&lt;/code&gt;. This will leave the underlying &lt;code&gt;sqlite3&lt;/code&gt; library operating in &lt;code&gt;autocommit&lt;/code&gt; mode. You can then completely control the transaction state by explicitly issuing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;ROLLBACK&lt;/code&gt;, &lt;code&gt;SAVEPOINT&lt;/code&gt;, and &lt;code&gt;RELEASE&lt;/code&gt; statements in your code.</source>
          <target state="translated">&lt;code&gt;isolation_level&lt;/code&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정 하여 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈의 암시 적 트랜잭션 관리를 비활성화 할 수 있습니다 . 그러면 기본 &lt;code&gt;sqlite3&lt;/code&gt; 라이브러리가 &lt;code&gt;autocommit&lt;/code&gt; 모드 에서 작동 합니다. 그런 다음 코드에서 &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;ROLLBACK&lt;/code&gt; , &lt;code&gt;SAVEPOINT&lt;/code&gt; 및 &lt;code&gt;RELEASE&lt;/code&gt; 문을 명시 적으로 실행하여 트랜잭션 상태를 완전히 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="700422f5e3ee3a72c11fcc9addee940ea1cbf9da" translate="yes" xml:space="preserve">
          <source>You can either call &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; with three arguments or two arguments. The three argument form takes the object to be patched, the attribute name and the object to replace the attribute with.</source>
          <target state="translated">세 개의 인수 또는 두 개의 인수로 &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt; 를 호출 할 수 있습니다 . 세 개의 인수 형식은 패치 할 객체, 속성 이름 및 속성을 대체 할 객체를 취합니다.</target>
        </trans-unit>
        <trans-unit id="931d434403a5284cf6c44cafa1f3fb736e71253d" translate="yes" xml:space="preserve">
          <source>You can escape other strings of data by passing a dictionary as the optional &lt;em&gt;entities&lt;/em&gt; parameter. The keys and values must all be strings; each key will be replaced with its corresponding value. The characters &lt;code&gt;'&amp;amp;'&lt;/code&gt;, &lt;code&gt;'&amp;lt;'&lt;/code&gt; and &lt;code&gt;'&amp;gt;'&lt;/code&gt; are always escaped, even if &lt;em&gt;entities&lt;/em&gt; is provided.</source>
          <target state="translated">사전을 선택적 &lt;em&gt;엔티티&lt;/em&gt; 매개 변수 로 전달하여 다른 데이터 문자열을 이스케이프 할 수 있습니다 . 키와 값은 모두 문자열이어야합니다. 각 키는 해당 값으로 바뀝니다. &lt;em&gt;엔티티&lt;/em&gt; 가 제공 되더라도 &lt;code&gt;'&amp;amp;'&lt;/code&gt; , &lt;code&gt;'&amp;lt;'&lt;/code&gt; 및 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 문자 는 항상 이스케이프 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="573f2efb0ec1c2a5d9e8ef8857e1296252240138" translate="yes" xml:space="preserve">
          <source>You can extend the list of file types &lt;a href=&quot;#module-imghdr&quot;&gt;&lt;code&gt;imghdr&lt;/code&gt;&lt;/a&gt; can recognize by appending to this variable:</source>
          <target state="translated">이 변수에 추가하여 &lt;a href=&quot;#module-imghdr&quot;&gt; &lt;code&gt;imghdr&lt;/code&gt; &lt;/a&gt; 이 인식 할 수 있는 파일 형식 목록을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="195ad7b8f2b09586418660df23685063cb22b239" translate="yes" xml:space="preserve">
          <source>You can force use of your own dict as the execution context by passing &lt;code&gt;globs=your_dict&lt;/code&gt; to &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;globs=your_dict&lt;/code&gt; 를 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 에 전달하여 자신의 dict를 실행 컨텍스트로 강제 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcb97e241e1e5c9620f24676030d9e232a3c7a23" translate="yes" xml:space="preserve">
          <source>You can force verbose mode by passing &lt;code&gt;verbose=True&lt;/code&gt; to &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, or prohibit it by passing &lt;code&gt;verbose=False&lt;/code&gt;. In either of those cases, &lt;code&gt;sys.argv&lt;/code&gt; is not examined by &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; (so passing &lt;code&gt;-v&lt;/code&gt; or not has no effect).</source>
          <target state="translated">&lt;code&gt;verbose=True&lt;/code&gt; 를 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 에 전달하여 verbose 모드를 강제 실행 하거나 &lt;code&gt;verbose=False&lt;/code&gt; 를 전달하여 금지 모드를 금지 할 수 있습니다. 두 경우 모두 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;sys.argv&lt;/code&gt; 를 검사 하지 않으므로 &lt;code&gt;-v&lt;/code&gt; 를 전달 하거나 적용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35c7606f98e9dd961b696a7ddeffebdba225ead4" translate="yes" xml:space="preserve">
          <source>You can get the &lt;a href=&quot;#metadata&quot;&gt;metadata for a distribution&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#metadata&quot;&gt;배포판&lt;/a&gt; 의 메타 데이터를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a35d8910326f07b0f1906f10b52c07b4fa3a76e" translate="yes" xml:space="preserve">
          <source>You can get the version string for &lt;code&gt;wheel&lt;/code&gt; by running the following:</source>
          <target state="translated">다음을 실행하여 &lt;code&gt;wheel&lt;/code&gt; 의 버전 문자열을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a032c7f821aa0424d57257b08c9ddac86e6e7e57" translate="yes" xml:space="preserve">
          <source>You can handle these with code like the following. Note that for arbitrary getset descriptors invoking these may trigger code execution:</source>
          <target state="translated">다음과 같은 코드로이를 처리 할 수 ​​있습니다. 임의의 getset 디스크립터의 경우이를 호출하면 코드 실행이 트리거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb8c4e2de3a151cd226fb06b93bdaeac63f0b4d" translate="yes" xml:space="preserve">
          <source>You can instantiate a &lt;a href=&quot;#curses.textpad.Textbox&quot;&gt;&lt;code&gt;Textbox&lt;/code&gt;&lt;/a&gt; object as follows:</source>
          <target state="translated">다음과 같이 &lt;a href=&quot;#curses.textpad.Textbox&quot;&gt; &lt;code&gt;Textbox&lt;/code&gt; &lt;/a&gt; 객체를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a5d59662d5371a0fdfca7a9eef49f35ae3ce64a" translate="yes" xml:space="preserve">
          <source>You can modify some of the &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s attributes before you add it using &lt;a href=&quot;#tarfile.TarFile.addfile&quot;&gt;&lt;code&gt;addfile()&lt;/code&gt;&lt;/a&gt;. If the file object is not an ordinary file object positioned at the beginning of the file, attributes such as &lt;a href=&quot;#tarfile.TarInfo.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt; may need modifying. This is the case for objects such as &lt;a href=&quot;gzip#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#tarfile.TarInfo.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; may also be modified, in which case &lt;em&gt;arcname&lt;/em&gt; could be a dummy string.</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.addfile&quot;&gt; &lt;code&gt;addfile()&lt;/code&gt; &lt;/a&gt; 사용하여 TarInfo 속성을 추가하기 전에 일부 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt; 속성을 수정할 수 있습니다 . 파일 객체가 파일 시작 부분에있는 일반 파일 객체가 아닌 경우 &lt;a href=&quot;#tarfile.TarInfo.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 와 같은 속성을 수정해야 할 수 있습니다. &lt;a href=&quot;gzip#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 과 같은 객체의 경우입니다 . &lt;a href=&quot;#tarfile.TarInfo.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 또한 그 경우, 변형 될 수있다 &lt;em&gt;arcname는&lt;/em&gt; 더미 문자열이 될 수있다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e839e79b2480577448952d6abaeadf88b91bec05" translate="yes" xml:space="preserve">
          <source>You can only instantiate the class flavour that corresponds to your system (allowing system calls on non-compatible path flavours could lead to bugs or failures in your application):</source>
          <target state="translated">시스템에 해당하는 클래스 플레이버 만 인스턴스화 할 수 있습니다 (호환되지 않는 경로 플레이버에 대한 시스템 호출을 허용하면 응용 프로그램에서 버그 또는 실패가 발생할 수 있음).</target>
        </trans-unit>
        <trans-unit id="0578dfb60398ddde818b7586a4e3117026258d03" translate="yes" xml:space="preserve">
          <source>You can override this to implement custom flushing behavior. This version just zaps the buffer to empty.</source>
          <target state="translated">이를 덮어 쓰기하여 사용자 지정 플러시 동작을 구현할 수 있습니다. 이 버전은 버퍼를 비우기 위해 압축합니다.</target>
        </trans-unit>
        <trans-unit id="2bc87e2256f9989176b847850b749c9cc0cc6702" translate="yes" xml:space="preserve">
          <source>You can pass in a list with any combination of module names, and fully qualified class or method names.</source>
          <target state="translated">모듈 이름과 정규화 된 클래스 또는 메소드 이름의 조합으로 목록을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a41bb05a43844e14e9db9886115ec4b066bd61b1" translate="yes" xml:space="preserve">
          <source>You can pass integers 0 or 1 or the strings &lt;code&gt;&quot;yes&quot;&lt;/code&gt; or &lt;code&gt;&quot;no&quot;&lt;/code&gt;.</source>
          <target state="translated">정수 0 또는 1 또는 문자열 &lt;code&gt;&quot;yes&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;no&quot;&lt;/code&gt; 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad0da7097c864ecb1de37d622a186a7c648c4e2a" translate="yes" xml:space="preserve">
          <source>You can patch any builtins within a module. The following example patches builtin &lt;a href=&quot;functions#ord&quot;&gt;&lt;code&gt;ord()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">모듈 내의 모든 내장을 패치 할 수 있습니다. 다음 예제는 내장 &lt;a href=&quot;functions#ord&quot;&gt; &lt;code&gt;ord()&lt;/code&gt; &lt;/a&gt; 를 패치합니다 .</target>
        </trans-unit>
        <trans-unit id="9ec973428da2c09e12914b4e9b653d668597b96e" translate="yes" xml:space="preserve">
          <source>You can place the definitions of test cases and test suites in the same modules as the code they are to test (such as &lt;code&gt;widget.py&lt;/code&gt;), but there are several advantages to placing the test code in a separate module, such as &lt;code&gt;test_widget.py&lt;/code&gt;:</source>
          <target state="translated">테스트 케이스 및 테스트 스위트의 정의를 테스트 할 코드와 같은 모듈 ( &lt;code&gt;widget.py&lt;/code&gt; 등 )에 배치 할 수 있지만 &lt;code&gt;test_widget.py&lt;/code&gt; 와 같은 별도의 모듈에 테스트 코드를 배치하면 몇 가지 장점이 있습니다. :</target>
        </trans-unit>
        <trans-unit id="64d273c86ad6ae2b4218d4f8a1cf522c0e7dff12" translate="yes" xml:space="preserve">
          <source>You can re-use the same &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; object many times, and you can change any of its options through direct assignment to instance attributes between uses.</source>
          <target state="translated">동일한 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; 객체를 여러 번 재사용 할 수 있으며 사용간에 인스턴스 속성에 직접 할당하여 옵션을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="185356fb3c67fcf9bd0085c884b80c32a2e93e4d" translate="yes" xml:space="preserve">
          <source>You can register new formats or provide your own archiver for any existing formats, by using &lt;a href=&quot;#shutil.register_archive_format&quot;&gt;&lt;code&gt;register_archive_format()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#shutil.register_archive_format&quot;&gt; &lt;code&gt;register_archive_format()&lt;/code&gt; &lt;/a&gt; 을 사용하여 새 형식을 등록하거나 기존 형식에 대해 고유 한 아카이버를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9c59d52c0ef34971a017a80bfad6dc0e9a43e0e" translate="yes" xml:space="preserve">
          <source>You can register new formats or provide your own unpacker for any existing formats, by using &lt;a href=&quot;#shutil.register_unpack_format&quot;&gt;&lt;code&gt;register_unpack_format()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#shutil.register_unpack_format&quot;&gt; &lt;code&gt;register_unpack_format()&lt;/code&gt; &lt;/a&gt; 을 사용하여 새 형식을 등록하거나 기존 형식에 대한 고유 한 언 패커를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6eab1e30d733d2bc722869dacae533e1cfa585d" translate="yes" xml:space="preserve">
          <source>You can run tests with more detail (higher verbosity) by passing in the -v flag:</source>
          <target state="translated">-v 플래그를 전달하여보다 자세한 (더 자세한 정보) 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1b607c7c24b44337173d6d898a09d86d78747aa" translate="yes" xml:space="preserve">
          <source>You can run tests with more detailed information by passing in the verbosity argument:</source>
          <target state="translated">verbosity 인수를 전달하여보다 자세한 정보로 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98e511b3bdd1ce757c87785c523b616f2db1ad16" translate="yes" xml:space="preserve">
          <source>You can see that &lt;code&gt;request.Request&lt;/code&gt; has a spec. &lt;code&gt;request.Request&lt;/code&gt; takes two arguments in the constructor (one of which is &lt;em&gt;self&lt;/em&gt;). Here&amp;rsquo;s what happens if we try to call it incorrectly:</source>
          <target state="translated">당신은 것을 볼 수 있습니다 &lt;code&gt;request.Request&lt;/code&gt; 가 스펙을 가지고있다. &lt;code&gt;request.Request&lt;/code&gt; 는 생성자에서 두 개의 인수를 취합니다 (이 중 하나는 &lt;em&gt;self&lt;/em&gt; ). 잘못 호출하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="7dc1b0288d71a05f65580cdcbf7bcc461729fa07" translate="yes" xml:space="preserve">
          <source>You can specify &lt;em&gt;stack_info&lt;/em&gt; independently of &lt;em&gt;exc_info&lt;/em&gt;, e.g. to just show how you got to a certain point in your code, even when no exceptions were raised. The stack frames are printed following a header line which says:</source>
          <target state="translated">&lt;em&gt;exc_info&lt;/em&gt; 와 독립적으로 &lt;em&gt;stack_info&lt;/em&gt; 를 지정할 수 있습니다 . 예를 들어 예외가 발생하지 않은 경우에도 코드의 특정 지점에 도달하는 방법을 보여줍니다. 스택 프레임은 다음과 같은 헤더 행을 따라 인쇄됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="680d7a6fb2ebb3408e9b53cb231daa64e3270083" translate="yes" xml:space="preserve">
          <source>You can stack up multiple patch decorators using this pattern:</source>
          <target state="translated">이 패턴을 사용하여 여러 패치 데코레이터를 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c62dfcabd935ea8e9bffc17a00618ffafad4ff5" translate="yes" xml:space="preserve">
          <source>You can still read the original number of total frames that composed the traceback by looking at the &lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt;&lt;code&gt;Traceback.total_nframe&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.Traceback.total_nframe&quot;&gt; &lt;code&gt;Traceback.total_nframe&lt;/code&gt; &lt;/a&gt; 속성 을 살펴보면 트레이스 백을 구성한 원래 총 프레임 수를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c643863a496cceedd3383ac19ac4ae419cf4d464" translate="yes" xml:space="preserve">
          <source>You can still retrieve the downloaded data in this case, it is stored in the &lt;code&gt;content&lt;/code&gt; attribute of the exception instance.</source>
          <target state="translated">이 경우에도 다운로드 된 데이터를 검색 할 수 있으며 예외 인스턴스 의 &lt;code&gt;content&lt;/code&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="1de115a11b34194063eb6b97040f48ef6d842aca" translate="yes" xml:space="preserve">
          <source>You can unescape other strings of data by passing a dictionary as the optional &lt;em&gt;entities&lt;/em&gt; parameter. The keys and values must all be strings; each key will be replaced with its corresponding value. &lt;code&gt;'&amp;amp;amp'&lt;/code&gt;, &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt;, and &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; are always unescaped, even if &lt;em&gt;entities&lt;/em&gt; is provided.</source>
          <target state="translated">사전을 선택적 &lt;em&gt;엔티티&lt;/em&gt; 매개 변수 로 전달하여 다른 데이터 문자열을 이스케이프 할 수 있습니다 . 키와 값은 모두 문자열이어야합니다. 각 키는 해당 값으로 바뀝니다. &lt;code&gt;'&amp;amp;amp'&lt;/code&gt; , &lt;code&gt;'&amp;amp;lt;'&lt;/code&gt; 및 &lt;code&gt;'&amp;amp;gt;'&lt;/code&gt; &lt;em&gt;엔티티&lt;/em&gt; 가 제공 되더라도 항상 이스케이프 처리되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="301b27cb1683d2e7c0b8ba419ff685e93d50ce4d" translate="yes" xml:space="preserve">
          <source>You can unregister a finalizer using its &lt;a href=&quot;#weakref.finalize.detach&quot;&gt;&lt;code&gt;detach()&lt;/code&gt;&lt;/a&gt; method. This kills the finalizer and returns the arguments passed to the constructor when it was created.</source>
          <target state="translated">&lt;a href=&quot;#weakref.finalize.detach&quot;&gt; &lt;code&gt;detach()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 종료 자를 등록 취소 할 수 있습니다 . 그러면 종료자가 종료되고 생성자가 생성 될 때 생성자에 전달 된 인수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="166be8a8478c4349774e11ae954bcf15ea13c98f" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#module-sysconfig&quot;&gt;&lt;code&gt;sysconfig&lt;/code&gt;&lt;/a&gt; as a script with Python&amp;rsquo;s &lt;em&gt;-m&lt;/em&gt; option:</source>
          <target state="translated">Python의 &lt;em&gt;-m&lt;/em&gt; 옵션을 사용하여 &lt;a href=&quot;#module-sysconfig&quot;&gt; &lt;code&gt;sysconfig&lt;/code&gt; &lt;/a&gt; 를 스크립트로 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4a2a75932fb642063f33320e42bd47704f40bcf9" translate="yes" xml:space="preserve">
          <source>You can use &lt;a href=&quot;#str.maketrans&quot;&gt;&lt;code&gt;str.maketrans()&lt;/code&gt;&lt;/a&gt; to create a translation map from character-to-character mappings in different formats.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;a href=&quot;#str.maketrans&quot;&gt; &lt;code&gt;str.maketrans()&lt;/code&gt; &lt;/a&gt; 다른 형식의 문자에 대한 문자 매핑에서 번역 맵을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ef37ecf8c36fd08b114602b0f13c55a48235640" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;Optional[X]&lt;/code&gt; as a shorthand for &lt;code&gt;Union[X, None]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Optional[X]&lt;/code&gt; 를 &lt;code&gt;Union[X, None]&lt;/code&gt; 의 속기로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93860cdb857fa2ccab62a0fe438384b6ec2ab456" translate="yes" xml:space="preserve">
          <source>You can use breakpoint commands to start your program up again. Simply use the &lt;a href=&quot;#pdbcommand-continue&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; command, or &lt;a href=&quot;#pdbcommand-step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt;, or any other command that resumes execution.</source>
          <target state="translated">중단 점 명령을 사용하여 프로그램을 다시 시작할 수 있습니다. 간단하게 사용 &lt;a href=&quot;#pdbcommand-continue&quot;&gt; &lt;code&gt;continue&lt;/code&gt; &lt;/a&gt; 명령 또는 &lt;a href=&quot;#pdbcommand-step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; , 또는 실행을 재개 다른 명령을.</target>
        </trans-unit>
        <trans-unit id="18a9f7442f0c27445596b606f02263419595de19" translate="yes" xml:space="preserve">
          <source>You can use multiple inheritance with &lt;a href=&quot;#typing.Generic&quot;&gt;&lt;code&gt;Generic&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#typing.Generic&quot;&gt; &lt;code&gt;Generic&lt;/code&gt; &lt;/a&gt; 과 함께 여러 상속을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08a65a4fd87ab3260a2995232edfe49d33c5209f" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;#bytes.maketrans&quot;&gt;&lt;code&gt;bytes.maketrans()&lt;/code&gt;&lt;/a&gt; method to create a translation table.</source>
          <target state="translated">&lt;a href=&quot;#bytes.maketrans&quot;&gt; &lt;code&gt;bytes.maketrans()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 변환 테이블을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3a1452d46bec95e5b939ca953e994a40a430f62" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;maxBytes&lt;/em&gt; and &lt;em&gt;backupCount&lt;/em&gt; values to allow the file to &lt;em&gt;rollover&lt;/em&gt; at a predetermined size. When the size is about to be exceeded, the file is closed and a new file is silently opened for output. Rollover occurs whenever the current log file is nearly &lt;em&gt;maxBytes&lt;/em&gt; in length; but if either of &lt;em&gt;maxBytes&lt;/em&gt; or &lt;em&gt;backupCount&lt;/em&gt; is zero, rollover never occurs, so you generally want to set &lt;em&gt;backupCount&lt;/em&gt; to at least 1, and have a non-zero &lt;em&gt;maxBytes&lt;/em&gt;. When &lt;em&gt;backupCount&lt;/em&gt; is non-zero, the system will save old log files by appending the extensions &amp;lsquo;.1&amp;rsquo;, &amp;lsquo;.2&amp;rsquo; etc., to the filename. For example, with a &lt;em&gt;backupCount&lt;/em&gt; of 5 and a base file name of &lt;code&gt;app.log&lt;/code&gt;, you would get &lt;code&gt;app.log&lt;/code&gt;, &lt;code&gt;app.log.1&lt;/code&gt;, &lt;code&gt;app.log.2&lt;/code&gt;, up to &lt;code&gt;app.log.5&lt;/code&gt;. The file being written to is always &lt;code&gt;app.log&lt;/code&gt;. When this file is filled, it is closed and renamed to &lt;code&gt;app.log.1&lt;/code&gt;, and if files &lt;code&gt;app.log.1&lt;/code&gt;, &lt;code&gt;app.log.2&lt;/code&gt;, etc. exist, then they are renamed to &lt;code&gt;app.log.2&lt;/code&gt;, &lt;code&gt;app.log.3&lt;/code&gt; etc. respectively.</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;em&gt;maxBytes&lt;/em&gt; 및 &lt;em&gt;BACKUPCOUNT의&lt;/em&gt; 에 파일을 허용하는 값을 &lt;em&gt;롤오버를&lt;/em&gt; 소정 크기로. 크기를 초과하려고하면 파일이 닫히고 출력을 위해 새 파일이 자동으로 열립니다. 롤오버는 현재 로그 파일의 길이 가 거의 &lt;em&gt;maxBytes 일&lt;/em&gt; 때마다 발생합니다 . 그러나 &lt;em&gt;maxBytes&lt;/em&gt; 또는 &lt;em&gt;backupCount&lt;/em&gt; 중 하나 가 0이면 롤오버가 발생하지 않으므로 일반적으로 &lt;em&gt;backupCount&lt;/em&gt; 를 1 이상 으로 설정 하고 0이 아닌 &lt;em&gt;maxBytes를 원합니다&lt;/em&gt; . 때 &lt;em&gt;BACKUPCOUNT가&lt;/em&gt; 아닌 제로입니다, 시스템은 확장을 추가하여 이전 로그 파일을 저장합니다 '0.1', '0.2'등, 파일 이름에. 예를 들어 &lt;em&gt;backupCount&lt;/em&gt;5의 기본 파일 이름의 &lt;code&gt;app.log&lt;/code&gt; , 당신은 얻을 것 &lt;code&gt;app.log&lt;/code&gt; , &lt;code&gt;app.log.1&lt;/code&gt; , &lt;code&gt;app.log.2&lt;/code&gt; 을 최대 &lt;code&gt;app.log.5&lt;/code&gt; . 기록되는 파일은 항상 &lt;code&gt;app.log&lt;/code&gt; 입니다. 이 파일이 채워지면 파일이 닫히고 &lt;code&gt;app.log.1&lt;/code&gt; 로 이름이 바뀌고 &lt;code&gt;app.log.1&lt;/code&gt; , &lt;code&gt;app.log.2&lt;/code&gt; 등의 파일이 있으면 &lt;code&gt;app.log.2&lt;/code&gt; , &lt;code&gt;app.log.3&lt;/code&gt; 이름이 바뀝니다 . log.3 등.</target>
        </trans-unit>
        <trans-unit id="1d81a63f3a0b165e52e93538340d0368d87d32f2" translate="yes" xml:space="preserve">
          <source>You can use the &lt;em&gt;when&lt;/em&gt; to specify the type of &lt;em&gt;interval&lt;/em&gt;. The list of possible values is below. Note that they are not case sensitive.</source>
          <target state="translated">&lt;em&gt;시기&lt;/em&gt; 를 사용하여 &lt;em&gt;간격&lt;/em&gt; 유형을 지정할 수 있습니다 . 가능한 값 목록은 다음과 같습니다. 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0cca2e6adbd32c2d102c851414d65aceb06c207" translate="yes" xml:space="preserve">
          <source>You can use their &amp;ldquo;tupleness&amp;rdquo; to pull out the individual arguments for more complex introspection and assertions. The positional arguments are a tuple (an empty tuple if there are no positional arguments) and the keyword arguments are a dictionary:</source>
          <target state="translated">그들의&amp;ldquo;튜플 니스&amp;rdquo;를 사용하여 더 복잡한 내성 및 주장에 대한 개별 논쟁을 이끌어 낼 수 있습니다. 위치 인수는 튜플 (위치 인수가없는 경우 비어있는 튜플)이며 키워드 인수는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="4ad3bae98cc6e6098bbeb87c404b93a8af1ae980" translate="yes" xml:space="preserve">
          <source>You can use these objects to do transparent transcodings, e.g., from Latin-1 to UTF-8 and back.</source>
          <target state="translated">이러한 객체를 사용하여 라틴 -1에서 UTF-8로 또는 그 반대로 투명 트랜스 코딩을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7a3127c0bc2be176f0faafcf4a37b1cfc1abb3f" translate="yes" xml:space="preserve">
          <source>You can use this value if you want to wait on several events at once using &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt;&lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt;&lt;/a&gt;. Otherwise calling &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is simpler.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt; &lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt; &lt;/a&gt; 사용하여 한 번에 여러 이벤트를 대기하려는 경우이 값을 사용할 수 있습니다 . 그렇지 않으면 &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 호출 이 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e2350bed90650fb87541671e1d3f3ffd1c20689e" translate="yes" xml:space="preserve">
          <source>You can, however, build much more complicated structures. A structure can itself contain other structures by using a structure as a field type.</source>
          <target state="translated">그러나 훨씬 더 복잡한 구조를 만들 수 있습니다. 구조는 필드 유형으로 구조를 사용하여 다른 구조를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64232b1d30a4b1e7f9e804d9e5b5aeafaf0b3c72" translate="yes" xml:space="preserve">
          <source>You cannot go past an anchor, or empty path:</source>
          <target state="translated">앵커 나 빈 경로를 지나갈 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e66b26b6f2c6b7b9831acdd5ef8c996027377922" translate="yes" xml:space="preserve">
          <source>You cannot subclass or instantiate a union.</source>
          <target state="translated">공용체를 서브 클래스 화하거나 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="966bda9fba3346ce89e289b42714a0f9e137407c" translate="yes" xml:space="preserve">
          <source>You cannot write &lt;code&gt;Union[X][Y]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Union[X][Y]&lt;/code&gt; 쓸 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="752587134d14b2eaf8447f7b6f2d68877dfdd6b9" translate="yes" xml:space="preserve">
          <source>You do not need to create instances of this class directly; they are automatically created as needed by &lt;a href=&quot;#wsgiref.simple_server.WSGIServer&quot;&gt;&lt;code&gt;WSGIServer&lt;/code&gt;&lt;/a&gt; objects. You can, however, subclass this class and supply it as a &lt;em&gt;handler_class&lt;/em&gt; to the &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt; function. Some possibly relevant methods for overriding in subclasses:</source>
          <target state="translated">이 클래스의 인스턴스를 직접 만들 필요는 없습니다. &lt;a href=&quot;#wsgiref.simple_server.WSGIServer&quot;&gt; &lt;code&gt;WSGIServer&lt;/code&gt; &lt;/a&gt; 오브젝트에서 필요에 따라 자동으로 작성됩니다 . 그러나이 클래스를 서브 클래스 로 작성하여 &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt; 함수에 &lt;em&gt;handler_class&lt;/em&gt; 로 제공 할 수 있습니다. 서브 클래스에서 재정의 할 수있는 관련 메소드 :</target>
        </trans-unit>
        <trans-unit id="431cbf03af6322a0c5713e5104bf689d6714c32c" translate="yes" xml:space="preserve">
          <source>You do not need to set the epilogue to the empty string in order for the &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to print a newline at the end of the file.</source>
          <target state="translated">&lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 가 파일 끝에 줄 바꿈을 인쇄 하기 위해 에필로그를 빈 문자열로 설정할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a17530dc8c32d2acb8875bd9c97bc5b2d12e7a45" translate="yes" xml:space="preserve">
          <source>You do not normally need to call this constructor, as the &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt; function can handle all the details for you.</source>
          <target state="translated">&lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt; 함수가 모든 세부 정보를 처리 할 수 ​​있으므로 일반적으로이 생성자를 호출 할 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ea99f60bcd9ea0794f5438dbea50265ec904cc2b" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t actually need to subclass &lt;code&gt;Filter&lt;/code&gt;: you can pass any instance which has a &lt;code&gt;filter&lt;/code&gt; method with the same semantics.</source>
          <target state="translated">실제로 &lt;code&gt;Filter&lt;/code&gt; 를 서브 클래스 화할 필요는 없습니다 . 동일한 의미를 가진 &lt;code&gt;filter&lt;/code&gt; 메소드 가있는 인스턴스를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc60677ef0241f3f9196c36f2e70aeee248e2fbd" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to subclass the parser to use this method, you can also set it on an instance, to a function that takes a string argument and returns a string. Setting it to &lt;code&gt;str&lt;/code&gt;, for example, would make option names case sensitive:</source>
          <target state="translated">이 메소드를 사용하기 위해 구문 분석기를 서브 클래스화할 필요는 없으며 인스턴스에서 문자열 인수를 가져 와서 문자열을 리턴하는 함수로 설정할 수도 있습니다. 예를 들어 &lt;code&gt;str&lt;/code&gt; 으로 설정하면 옵션 이름은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="07066c5c390391f5b0549847d58ead8ad1fc7cf5" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t need to wrap with &lt;a href=&quot;functions#staticmethod&quot;&gt;&lt;code&gt;staticmethod()&lt;/code&gt;&lt;/a&gt; if you&amp;rsquo;re setting the import callable on a configurator &lt;em&gt;instance&lt;/em&gt;.</source>
          <target state="translated">구성자 &lt;em&gt;인스턴스&lt;/em&gt; 에서 가져 오기 호출 가능을 설정하는 경우 &lt;a href=&quot;functions#staticmethod&quot;&gt; &lt;code&gt;staticmethod()&lt;/code&gt; &lt;/a&gt; 로 랩핑하지 않아도됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50060718f1fe46b8db95adb5dafc6399b74bdccf" translate="yes" xml:space="preserve">
          <source>You don&amp;rsquo;t specifically &lt;em&gt;need&lt;/em&gt; to activate an environment; activation just prepends the virtual environment&amp;rsquo;s binary directory to your path, so that &amp;ldquo;python&amp;rdquo; invokes the virtual environment&amp;rsquo;s Python interpreter and you can run installed scripts without having to use their full path. However, all scripts installed in a virtual environment should be runnable without activating it, and run with the virtual environment&amp;rsquo;s Python automatically.</source>
          <target state="translated">특별히 환경을 활성화 할 &lt;em&gt;필요&lt;/em&gt; 는 없습니다 . 활성화는 가상 환경의 바이너리 디렉토리를 경로 앞에 추가하기 때문에 &quot;python&quot;은 가상 환경의 Python 인터프리터를 호출하고 전체 경로를 사용하지 않고도 설치된 스크립트를 실행할 수 있습니다. 그러나 가상 환경에 설치된 모든 스크립트는 활성화하지 않고 실행 가능해야하며 가상 환경의 Python으로 자동 실행되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6d235d73a43398a64c313b4126a55b055ef79602" translate="yes" xml:space="preserve">
          <source>You load libraries by accessing them as attributes of these objects. &lt;em&gt;cdll&lt;/em&gt; loads libraries which export functions using the standard &lt;code&gt;cdecl&lt;/code&gt; calling convention, while &lt;em&gt;windll&lt;/em&gt; libraries call functions using the &lt;code&gt;stdcall&lt;/code&gt; calling convention. &lt;em&gt;oledll&lt;/em&gt; also uses the &lt;code&gt;stdcall&lt;/code&gt; calling convention, and assumes the functions return a Windows &lt;code&gt;HRESULT&lt;/code&gt; error code. The error code is used to automatically raise an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception when the function call fails.</source>
          <target state="translated">이러한 객체의 속성으로 라이브러리에 액세스하여 라이브러리를로드합니다. &lt;em&gt;cdll&lt;/em&gt; 은 표준 &lt;code&gt;cdecl&lt;/code&gt; 호출 규칙을 사용하여 함수를 내보내는 라이브러리를로드하는 반면 &lt;em&gt;windll&lt;/em&gt; 라이브러리는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하여 함수를 호출합니다 . &lt;em&gt;oledll&lt;/em&gt; 은 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하며 함수가 Windows &lt;code&gt;HRESULT&lt;/code&gt; 오류 코드를 리턴한다고 가정합니다 . 오류 코드는 함수 호출이 실패 할 때 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 를 자동으로 발생 시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aac6314187cc5d9a54cb395d4bf42121079c9e85" translate="yes" xml:space="preserve">
          <source>You may also specify an arbitrary action by passing an Action subclass or other object that implements the same interface. The &lt;code&gt;BooleanOptionalAction&lt;/code&gt; is available in &lt;code&gt;argparse&lt;/code&gt; and adds support for boolean actions such as &lt;code&gt;--foo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt;:</source>
          <target state="translated">Action 서브 클래스 또는 동일한 인터페이스를 구현하는 다른 객체를 전달하여 임의의 작업을 지정할 수도 있습니다. &lt;code&gt;BooleanOptionalAction&lt;/code&gt; 이 가능합니다 &lt;code&gt;argparse&lt;/code&gt; 과 같은 부울 동작에 대한 지원을 추가 &lt;code&gt;--foo&lt;/code&gt; 및 &lt;code&gt;--no-foo&lt;/code&gt; 는 :</target>
        </trans-unit>
        <trans-unit id="7a9f24d09ce2fac5b6b5e198261279380d5bbbd5" translate="yes" xml:space="preserve">
          <source>You may also specify an arbitrary action by passing an Action subclass or other object that implements the same interface. The recommended way to do this is to extend &lt;a href=&quot;#argparse.Action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;, overriding the &lt;code&gt;__call__&lt;/code&gt; method and optionally the &lt;code&gt;__init__&lt;/code&gt; method.</source>
          <target state="translated">Action 서브 클래스 나 동일한 인터페이스를 구현하는 다른 객체를 전달하여 임의의 액션을 지정할 수도 있습니다. 권장되는 방법은 &lt;a href=&quot;#argparse.Action&quot;&gt; &lt;code&gt;Action&lt;/code&gt; &lt;/a&gt; 을 확장 하여 &lt;code&gt;__call__&lt;/code&gt; 메서드 및 선택적으로 &lt;code&gt;__init__&lt;/code&gt; 메서드를 재정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="355be00ad0a55445558f75bdbc18f08ec59ccd73" translate="yes" xml:space="preserve">
          <source>You may override this method in a subclass. The standard &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method invokes the callable object passed to the object&amp;rsquo;s constructor as the target argument, if any, with sequential and keyword arguments taken from the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; arguments, respectively.</source>
          <target state="translated">서브 클래스에서이 메소드를 대체 할 수 있습니다. 표준 &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwargs&lt;/em&gt; 인수에서 각각 순차적 인 키워드 인수와 키워드 인수를 사용하여 오브젝트의 생성자에 전달 된 호출 가능 오브젝트를 대상 인수 (있는 경우)로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="63d0895d58df495742a522d15640d62134175d03" translate="yes" xml:space="preserve">
          <source>You may override this method in a subclass. The standard &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method invokes the callable object passed to the object&amp;rsquo;s constructor as the &lt;em&gt;target&lt;/em&gt; argument, if any, with positional and keyword arguments taken from the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwargs&lt;/em&gt; arguments, respectively.</source>
          <target state="translated">서브 클래스에서이 메소드를 대체 할 수 있습니다. 표준 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwargs&lt;/em&gt; 인수에서 각각 위치 및 키워드 인수 를 사용하여 오브젝트의 생성자에 전달 된 호출 가능 오브젝트를 &lt;em&gt;대상&lt;/em&gt; 인수 (있는 경우) 로 호출합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="559ac3792a61fab934579c9348c599af2f6ebff8" translate="yes" xml:space="preserve">
          <source>You may still perform all &lt;code&gt;int&lt;/code&gt; operations on a variable of type &lt;code&gt;UserId&lt;/code&gt;, but the result will always be of type &lt;code&gt;int&lt;/code&gt;. This lets you pass in a &lt;code&gt;UserId&lt;/code&gt; wherever an &lt;code&gt;int&lt;/code&gt; might be expected, but will prevent you from accidentally creating a &lt;code&gt;UserId&lt;/code&gt; in an invalid way:</source>
          <target state="translated">&lt;code&gt;UserId&lt;/code&gt; 유형의 변수에 대해 모든 &lt;code&gt;int&lt;/code&gt; 조작을 계속 수행 할 수 있지만 결과는 항상 &lt;code&gt;int&lt;/code&gt; 유형 입니다. 이렇게하면 &lt;code&gt;int&lt;/code&gt; 가 예상되는 곳이면 어디에서나 &lt;code&gt;UserId&lt;/code&gt; 를 전달할 수 있지만 실수로 잘못된 방식으로 &lt;code&gt;UserId&lt;/code&gt; 를 만들 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d58ea92f23614149b70f3349883f40aae428e954" translate="yes" xml:space="preserve">
          <source>You may then fetch the certificate:</source>
          <target state="translated">그런 다음 인증서를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f46d58993c757c98a68957af7a5a798eec2a9d" translate="yes" xml:space="preserve">
          <source>You may want a mock object to return &lt;code&gt;False&lt;/code&gt; to a &lt;a href=&quot;functions#hasattr&quot;&gt;&lt;code&gt;hasattr()&lt;/code&gt;&lt;/a&gt; call, or raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; when an attribute is fetched. You can do this by providing an object as a &lt;code&gt;spec&lt;/code&gt; for a mock, but that isn&amp;rsquo;t always convenient.</source>
          <target state="translated">당신은 모의 개체를 반환 할 수 있습니다 &lt;code&gt;False&lt;/code&gt; A를 &lt;a href=&quot;functions#hasattr&quot;&gt; &lt;code&gt;hasattr()&lt;/code&gt; &lt;/a&gt; 호출, 또는 인상 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 를&lt;/a&gt; 속성이 인출됩니다. 객체를 모의 &lt;code&gt;spec&lt;/code&gt; 으로 제공하여이를 수행 할 수 있지만 항상 편리한 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="332990ee9355f487c806f435103a83563f35c4ce" translate="yes" xml:space="preserve">
          <source>You might also try:</source>
          <target state="translated">시도해 볼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5406fdd2ad0d5807786d625bddb416283fad614" translate="yes" xml:space="preserve">
          <source>You might want to override this method if you want to convert the record to a dict or JSON string, or send a modified copy of the record while leaving the original intact.</source>
          <target state="translated">레코드를 dict 또는 JSON 문자열로 변환하거나 원본을 그대로두고 레코드의 수정 된 사본을 보내려는 경우이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52e922832e7caa53085050a22089bcfc200171f5" translate="yes" xml:space="preserve">
          <source>You mock magic methods by setting the method you are interested in to a function or a mock instance. If you are using a function then it &lt;em&gt;must&lt;/em&gt; take &lt;code&gt;self&lt;/code&gt; as the first argument &lt;a href=&quot;#id10&quot; id=&quot;id8&quot;&gt;3&lt;/a&gt;.</source>
          <target state="translated">관심있는 메소드를 함수 또는 모의 인스턴스로 설정하여 마술 메소드를 조롱합니다. 이 기능을 사용하는 경우 그것은 &lt;em&gt;해야한다&lt;/em&gt; 걸릴 &lt;code&gt;self&lt;/code&gt; 첫 번째 인수로 &lt;a href=&quot;#id10&quot; id=&quot;id8&quot;&gt;3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09b20a74562a4b523aea5e75b3238fba4872f230" translate="yes" xml:space="preserve">
          <source>You must fully initialize the parsers before passing them via &lt;code&gt;parents=&lt;/code&gt;. If you change the parent parsers after the child parser, those changes will not be reflected in the child.</source>
          <target state="translated">&lt;code&gt;parents=&lt;/code&gt; 를 통해 파서를 전달하기 전에 파서를 완전히 초기화해야합니다 . 자식 파서 다음에 부모 파서를 변경하면 해당 변경 사항이 자식에 반영되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="094bc364ccd654aa3f90655ab2f56388f1bc3a61" translate="yes" xml:space="preserve">
          <source>You must have enough privileges to access the shadow password database (this usually means you have to be root).</source>
          <target state="translated">섀도 비밀번호 데이터베이스에 액세스 할 수있는 충분한 권한이 있어야합니다 (일반적으로 루트 여야 함).</target>
        </trans-unit>
        <trans-unit id="6b23fc7062bc1845bf77eb0ae69f21c191174259" translate="yes" xml:space="preserve">
          <source>You need to derive a concrete subclass, and (at least) supply implementations of the standard &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; methods needed by the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; methods you use. The &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module provides &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;, a simple concrete subclass of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; which can represent timezones with fixed offset from UTC such as UTC itself or North American EST and EDT.</source>
          <target state="translated">구체적인 서브 클래스를 도출하고 사용 하는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 메소드에 필요한 표준 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드의 구현을 제공 해야합니다. &lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈이 제공하는 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; , 간단한 콘크리트 서브 클래스 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 같은 UTC 자체 또는 북미 EST와 EDT로 UTC로부터의 오프셋 (offset) 고정과 시간대를 나타낼 수있다.</target>
        </trans-unit>
        <trans-unit id="7740fbb5cd79d6ed8c08a1c933712cfcb8fda34d" translate="yes" xml:space="preserve">
          <source>You should be careful, however, not to pass them to functions expecting pointers to mutable memory. If you need mutable memory blocks, ctypes has a &lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt;&lt;code&gt;create_string_buffer()&lt;/code&gt;&lt;/a&gt; function which creates these in various ways. The current memory block contents can be accessed (or changed) with the &lt;code&gt;raw&lt;/code&gt; property; if you want to access it as NUL terminated string, use the &lt;code&gt;value&lt;/code&gt; property:</source>
          <target state="translated">그러나 변경 가능한 메모리에 대한 포인터를 기대하는 함수에는 전달하지 않도록주의해야합니다. 변경 가능한 메모리 블록이 필요한 경우 ctypes에는 다양한 방법으로이를 생성 하는 &lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt; &lt;code&gt;create_string_buffer()&lt;/code&gt; &lt;/a&gt; 함수가 있습니다. 현재 메모리 블록 내용은 &lt;code&gt;raw&lt;/code&gt; 속성 으로 액세스 (또는 변경) 할 수 있습니다 . NUL 종료 문자열로 액세스하려면 &lt;code&gt;value&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b1f3cec241149216d9168d1204ff3d17a2754cc" translate="yes" xml:space="preserve">
          <source>You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;https://creativecommons.org/publicdomain/zero/1.0/&lt;/a&gt;.</source>
          <target state="translated">이 소프트웨어와 함께 CC0 Public Domain Dedication의 사본을 받았어야합니다. 그렇지 않은 경우 &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;https://creativecommons.org/publicdomain/zero/1.0/을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="aed8e41ce1b3c70de9323f77dbec3def95dca2b2" translate="yes" xml:space="preserve">
          <source>You should implement this method if the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method of your class requires keyword-only arguments. Otherwise, it is recommended for compatibility to implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래스 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메서드에 키워드 전용 인수가 필요한 경우이 메서드를 구현해야합니다 . 그렇지 않으면 호환성을 위해 &lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt; 를 구현하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4426329de7889e8e5e4d602d5363ef6bb0119a4c" translate="yes" xml:space="preserve">
          <source>You should implement this method if the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method of your class requires keyword-only arguments. Otherwise, it is recommended for compatibility to implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래스 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메서드에 키워드 전용 인수가 필요한 경우이 메서드를 구현해야합니다 . 그렇지 않으면 호환성을 위해 &lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt; 를 구현하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="608bdf7953eb348170dc085e02eb0651f71c21f7" translate="yes" xml:space="preserve">
          <source>You should report this to the author or maintainer of your Python interpreter. Be sure to report the version of the Python interpreter (&lt;code&gt;sys.version&lt;/code&gt;; it is also printed at the start of an interactive Python session), the exact error message (the exception&amp;rsquo;s associated value) and if possible the source of the program that triggered the error.</source>
          <target state="translated">이것을 파이썬 인터프리터의 저자 나 관리자에게보고해야합니다. Python 인터프리터 버전 ( &lt;code&gt;sys.version&lt;/code&gt; ; 대화식 Python 세션 시작시 인쇄 됨), 정확한 오류 메시지 (예외 관련 값) 및 가능하면 트리거 된 프로그램의 소스를보고하십시오. 오류.</target>
        </trans-unit>
        <trans-unit id="b6c782fc647ff3aa498d746efee7b7356d8e5253" translate="yes" xml:space="preserve">
          <source>You shouldn&amp;rsquo;t need to format this yourself.</source>
          <target state="translated">이 형식을 직접 지정할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b88788ab2aad4e62798ccc5bda983ef8733f0b94" translate="yes" xml:space="preserve">
          <source>You want to make sure that your code only manipulates paths without actually accessing the OS. In this case, instantiating one of the pure classes may be useful since those simply don&amp;rsquo;t have any OS-accessing operations.</source>
          <target state="translated">코드가 실제로 OS에 액세스하지 않고 경로 만 조작하는지 확인하려고합니다. 이 경우 순수 클래스 중 하나를 인스턴스화하면 OS 액세스 작업이 없기 때문에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="916096316bc5b5aae5496f6bd41e8229ed9c923a" translate="yes" xml:space="preserve">
          <source>Your App Here (Python)</source>
          <target state="translated">여기에 앱 (Python)</target>
        </trans-unit>
        <trans-unit id="ef1c084cf7519afce21379d5a8c3eb6c5c1b462b" translate="yes" xml:space="preserve">
          <source>Your tests can pass silently and incorrectly because of the typo.</source>
          <target state="translated">오타로 인해 테스트가 자동으로 잘못 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2020bd4ed774a09d2ace95d49cf92fbcbd6e4c" translate="yes" xml:space="preserve">
          <source>ZIP flag bits.</source>
          <target state="translated">ZIP 플래그 비트.</target>
        </trans-unit>
        <trans-unit id="3bf3f71c4d3d91d72b09100088bc05f6648939f4" translate="yes" xml:space="preserve">
          <source>ZeroDivisionError</source>
          <target state="translated">ZeroDivisionError</target>
        </trans-unit>
        <trans-unit id="b44e96f9df87d40173b4e4687155b468a0e9dfd0" translate="yes" xml:space="preserve">
          <source>ZipFile Objects</source>
          <target state="translated">ZipFile 객체</target>
        </trans-unit>
        <trans-unit id="d3c28efb247369df3c23761952bb20eddb7ead55" translate="yes" xml:space="preserve">
          <source>ZipFile is also a context manager and therefore supports the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. In the example, &lt;em&gt;myzip&lt;/em&gt; is closed after the &lt;code&gt;with&lt;/code&gt; statement&amp;rsquo;s suite is finished&amp;mdash;even if an exception occurs:</source>
          <target state="translated">ZipFile은 또한 컨텍스트 관리자이므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 지원합니다 . 이 예에서 예외가 발생하더라도 &lt;code&gt;with&lt;/code&gt; 문의 제품군이 완료된 후 &lt;em&gt;myzip&lt;/em&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="502e78ecee4a8d17fd59824d3b090f299b014bbf" translate="yes" xml:space="preserve">
          <source>ZipFile is also a context manager and therefore supports the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. In the example, &lt;em&gt;myzip&lt;/em&gt; is closed after the &lt;code&gt;with&lt;/code&gt; statement&amp;rsquo;s suite is finished&amp;mdash;even if an exception occurs:</source>
          <target state="translated">ZipFile은 컨텍스트 관리자이기도하므로 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 지원합니다 . 예제에서 &lt;em&gt;myzip&lt;/em&gt; 은 예외가 발생하더라도 &lt;code&gt;with&lt;/code&gt; 문의 스위트가 완료된 후 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="32dece39948d14cba87cb98ecec9b9ed1ae759c7" translate="yes" xml:space="preserve">
          <source>ZipInfo Objects</source>
          <target state="translated">ZipInfo 객체</target>
        </trans-unit>
        <trans-unit id="1c1f3fc8258eaf3393e718a8a2747228a7fb364a" translate="yes" xml:space="preserve">
          <source>Zoom/Restore Height</source>
          <target state="translated">줌 / 복원 높이</target>
        </trans-unit>
        <trans-unit id="817238a139f150e9f4f1383dbd74c0b91ee8bae0" translate="yes" xml:space="preserve">
          <source>__annotations__</source>
          <target state="translated">__annotations__</target>
        </trans-unit>
        <trans-unit id="f409f35afb6adb9d0745380c602ca135f47ef811" translate="yes" xml:space="preserve">
          <source>__code__</source>
          <target state="translated">__code__</target>
        </trans-unit>
        <trans-unit id="62bbeb1e267c62609bdf2f95e593915d20733a27" translate="yes" xml:space="preserve">
          <source>__debug__</source>
          <target state="translated">__debug__</target>
        </trans-unit>
        <trans-unit id="a0ea0ae317994102ce4319f4d6a770bf60eb5981" translate="yes" xml:space="preserve">
          <source>__defaults__</source>
          <target state="translated">__defaults__</target>
        </trans-unit>
        <trans-unit id="2922e12594306ed2f517ef5a341de5247c8c8b83" translate="yes" xml:space="preserve">
          <source>__doc__</source>
          <target state="translated">__doc__</target>
        </trans-unit>
        <trans-unit id="c75fde63c1afd749e27a30c936498ccc7b596d55" translate="yes" xml:space="preserve">
          <source>__file__</source>
          <target state="translated">__file__</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="05a73385f8915931c595c28004a15b3861ea5391" translate="yes" xml:space="preserve">
          <source>__future__</source>
          <target state="translated">__future__</target>
        </trans-unit>
        <trans-unit id="8243a95f4a52e809ca3146b71b1c4eb64e88daec" translate="yes" xml:space="preserve">
          <source>__future__ &amp;mdash; Future statement definitions</source>
          <target state="translated">__future__ &amp;mdash; 향후 진술 정의</target>
        </trans-unit>
        <trans-unit id="42a6b9c717b079d3902c3d927cc73c750f401249" translate="yes" xml:space="preserve">
          <source>__globals__</source>
          <target state="translated">__globals__</target>
        </trans-unit>
        <trans-unit id="7fa022a1dbbda2854490c44ddb9bbf67c875072a" translate="yes" xml:space="preserve">
          <source>__import__()</source>
          <target state="translated">__import__()</target>
        </trans-unit>
        <trans-unit id="8f67cc8062d70ff192a2db59e5936d1454a10513" translate="yes" xml:space="preserve">
          <source>__kwdefaults__</source>
          <target state="translated">__kwdefaults__</target>
        </trans-unit>
        <trans-unit id="3a64a9fca18e24c6cc560c53c3603d38f21d45e1" translate="yes" xml:space="preserve">
          <source>__main__</source>
          <target state="translated">__main__</target>
        </trans-unit>
        <trans-unit id="67b7e3744be66edbab900391343b344e45582311" translate="yes" xml:space="preserve">
          <source>__main__ &amp;mdash; Top-level script environment</source>
          <target state="translated">__main__ &amp;mdash; 최상위 스크립트 환경</target>
        </trans-unit>
        <trans-unit id="dafa226dd7478c948168cc8fe05f819f78f92608" translate="yes" xml:space="preserve">
          <source>__module__</source>
          <target state="translated">__module__</target>
        </trans-unit>
        <trans-unit id="c1dab70a8cae8ab6675cd1dd0933150036c91264" translate="yes" xml:space="preserve">
          <source>__name__</source>
          <target state="translated">__name__</target>
        </trans-unit>
        <trans-unit id="507d7fdd431c9a0168a6ce7ab07d6fddb7444e35" translate="yes" xml:space="preserve">
          <source>__qualname__</source>
          <target state="translated">__qualname__</target>
        </trans-unit>
        <trans-unit id="85e18720c20496ae00ef9cf6b8aa9ea49b266a6b" translate="yes" xml:space="preserve">
          <source>__self__</source>
          <target state="translated">__self__</target>
        </trans-unit>
        <trans-unit id="64f034dabbb4855ca6a80405bbada75a41e4f8cc" translate="yes" xml:space="preserve">
          <source>_dummy_thread</source>
          <target state="translated">_dummy_thread</target>
        </trans-unit>
        <trans-unit id="05d8fbde3570a77c3787f305a76091073da240c1" translate="yes" xml:space="preserve">
          <source>_dummy_thread &amp;mdash; Drop-in replacement for the _thread module</source>
          <target state="translated">_dummy_thread &amp;mdash; _thread 모듈의 드롭 인 교체</target>
        </trans-unit>
        <trans-unit id="415e8b762f52dba735a8941f5c118bbcbe9c97d0" translate="yes" xml:space="preserve">
          <source>_thread</source>
          <target state="translated">_thread</target>
        </trans-unit>
        <trans-unit id="da5b2839c3debda59dc6d44d96457dca817c02c5" translate="yes" xml:space="preserve">
          <source>_thread &amp;mdash; Low-level threading API</source>
          <target state="translated">_thread &amp;mdash; 저수준 스레딩 API</target>
        </trans-unit>
        <trans-unit id="1197d3e3671fe302e212fc6e01a5599df1e24739" translate="yes" xml:space="preserve">
          <source>_thread.LockType</source>
          <target state="translated">_thread.LockType</target>
        </trans-unit>
        <trans-unit id="10b6524890c56d7b3c9d02dd5f9974643c3f4270" translate="yes" xml:space="preserve">
          <source>_thread.TIMEOUT_MAX</source>
          <target state="translated">_thread.TIMEOUT_MAX</target>
        </trans-unit>
        <trans-unit id="e53d1af9d5893b2846a539cfb58a8f7a8d22c89e" translate="yes" xml:space="preserve">
          <source>_thread.allocate_lock()</source>
          <target state="translated">_thread.allocate_lock()</target>
        </trans-unit>
        <trans-unit id="197f373125020edee90662419f7aad02a7b9c17d" translate="yes" xml:space="preserve">
          <source>_thread.error</source>
          <target state="translated">_thread.error</target>
        </trans-unit>
        <trans-unit id="f77734f9a672561ada2f9d806095e7dfabbef029" translate="yes" xml:space="preserve">
          <source>_thread.exit()</source>
          <target state="translated">_thread.exit()</target>
        </trans-unit>
        <trans-unit id="5c63f8bac316bfc2484ee6625f020abc63787523" translate="yes" xml:space="preserve">
          <source>_thread.get_ident()</source>
          <target state="translated">_thread.get_ident()</target>
        </trans-unit>
        <trans-unit id="6ac74f7dc2c2fc2ce38eefb755e928f8633dea0f" translate="yes" xml:space="preserve">
          <source>_thread.get_native_id()</source>
          <target state="translated">_thread.get_native_id()</target>
        </trans-unit>
        <trans-unit id="d0da4946a68555999c188366affeae7b761778a5" translate="yes" xml:space="preserve">
          <source>_thread.interrupt_main()</source>
          <target state="translated">_thread.interrupt_main()</target>
        </trans-unit>
        <trans-unit id="9d73ffbe13b07689c72d68cf3437ff8586dc3977" translate="yes" xml:space="preserve">
          <source>_thread.lock.acquire()</source>
          <target state="translated">_thread.lock.acquire()</target>
        </trans-unit>
        <trans-unit id="a66a2bd7cd05e13cbc2c202fe9970f286f342d5b" translate="yes" xml:space="preserve">
          <source>_thread.lock.locked()</source>
          <target state="translated">_thread.lock.locked()</target>
        </trans-unit>
        <trans-unit id="d9d44b39308b962300683283a9f5c9e4432e993d" translate="yes" xml:space="preserve">
          <source>_thread.lock.release()</source>
          <target state="translated">_thread.lock.release()</target>
        </trans-unit>
        <trans-unit id="92e76f45930236545f796bf83967a90dae1c5dae" translate="yes" xml:space="preserve">
          <source>_thread.stack_size()</source>
          <target state="translated">_thread.stack_size()</target>
        </trans-unit>
        <trans-unit id="fafa7fa9e2fa93f20e14a4830e70ee7f5c7a4195" translate="yes" xml:space="preserve">
          <source>_thread.start_new_thread()</source>
          <target state="translated">_thread.start_new_thread()</target>
        </trans-unit>
        <trans-unit id="e57494049e3e9cb998a365df5ebf284df3d8cd6d" translate="yes" xml:space="preserve">
          <source>_tkinter (C)</source>
          <target state="translated">_tkinter (C)</target>
        </trans-unit>
        <trans-unit id="cf88a375687c70756a66d746b4ebd426c66dbb60" translate="yes" xml:space="preserve">
          <source>_winapi.CreateFile</source>
          <target state="translated">_winapi.CreateFile</target>
        </trans-unit>
        <trans-unit id="a1a90d648c83f9aabd0d2a0dacb93d3412e6d995" translate="yes" xml:space="preserve">
          <source>_winapi.CreateJunction</source>
          <target state="translated">_winapi.CreateJunction</target>
        </trans-unit>
        <trans-unit id="5ca29ded1fb74a7907ca7408a90e333780366dc4" translate="yes" xml:space="preserve">
          <source>_winapi.CreateNamedPipe</source>
          <target state="translated">_winapi.CreateNamedPipe</target>
        </trans-unit>
        <trans-unit id="dc51e4276a5e454e6c63094807a9c12f2ad1f2f6" translate="yes" xml:space="preserve">
          <source>_winapi.CreatePipe</source>
          <target state="translated">_winapi.CreatePipe</target>
        </trans-unit>
        <trans-unit id="dcce143154225c5a0ab697cb248ee9c2fba45c2d" translate="yes" xml:space="preserve">
          <source>_winapi.CreateProcess</source>
          <target state="translated">_winapi.CreateProcess</target>
        </trans-unit>
        <trans-unit id="5e9194d15423b1a890eeb18441f1c13c49032b82" translate="yes" xml:space="preserve">
          <source>_winapi.OpenProcess</source>
          <target state="translated">_winapi.OpenProcess</target>
        </trans-unit>
        <trans-unit id="193eeb1b9fc659d49913a0171364814314d95fb7" translate="yes" xml:space="preserve">
          <source>_winapi.TerminateProcess</source>
          <target state="translated">_winapi.TerminateProcess</target>
        </trans-unit>
        <trans-unit id="884a8a81095a6c975cc5f46c5535aca47a40cc29" translate="yes" xml:space="preserve">
          <source>a (graphical) breadth first tree (using generators)</source>
          <target state="translated">(그래픽) 너비의 첫 번째 트리 (생성기 사용)</target>
        </trans-unit>
        <trans-unit id="2a3c787e15c30f9b3971b501cda113129f37b40e" translate="yes" xml:space="preserve">
          <source>a 4:1 compressed format defined by the Interactive Multimedia Association</source>
          <target state="translated">Interactive Multimedia Association에서 정의한 4 : 1 압축 형식</target>
        </trans-unit>
        <trans-unit id="2a607ef8d6e4ef1cfa7c1eb06d4c3bf4e4ce6fb6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object that would await on &lt;em&gt;obj&lt;/em&gt;, if &lt;em&gt;obj&lt;/em&gt; is an awaitable (&lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt;&lt;code&gt;inspect.isawaitable()&lt;/code&gt;&lt;/a&gt; is used for the test.)</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 에 기다리는 것이 목적 &lt;em&gt;OBJ&lt;/em&gt; 경우, &lt;em&gt;obj가&lt;/em&gt; awaitable입니다 ( &lt;a href=&quot;inspect#inspect.isawaitable&quot;&gt; &lt;code&gt;inspect.isawaitable()&lt;/code&gt; &lt;/a&gt; 테스트에 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="d5940cf955ef1b31a29e37f1f63d6add86f7a107" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; object wrapping &lt;em&gt;obj&lt;/em&gt;, if &lt;em&gt;obj&lt;/em&gt; is a coroutine (&lt;a href=&quot;asyncio-task#asyncio.iscoroutine&quot;&gt;&lt;code&gt;iscoroutine()&lt;/code&gt;&lt;/a&gt; is used for the test); in this case the coroutine will be scheduled by &lt;code&gt;ensure_future()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 오브젝트 배치 &lt;em&gt;OBJ&lt;/em&gt; , 경우 &lt;em&gt;obj가&lt;/em&gt; 코 루틴 (인 &lt;a href=&quot;asyncio-task#asyncio.iscoroutine&quot;&gt; &lt;code&gt;iscoroutine()&lt;/code&gt; &lt;/a&gt; 시험에 사용된다); 이 경우 코 루틴은 &lt;code&gt;ensure_future()&lt;/code&gt; 의해 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="60f2374ba0e896c62e9d0dd5eb89cdd040867b25" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine function&lt;/em&gt;: an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; function;</source>
          <target state="translated">&lt;em&gt;코 루틴 함수&lt;/em&gt; :는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 기능;</target>
        </trans-unit>
        <trans-unit id="cc72dc913dfd037f65ff0c8fc40195445cf586b1" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine function&lt;/em&gt;: an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; function;</source>
          <target state="translated">&lt;em&gt;코 루틴 함수&lt;/em&gt; :는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 기능;</target>
        </trans-unit>
        <trans-unit id="f127c8970e8aa4599e65040eeb62944bf8597ce0" translate="yes" xml:space="preserve">
          <source>a &lt;em&gt;coroutine object&lt;/em&gt;: an object returned by calling a &lt;em&gt;coroutine function&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;코 루틴 객체&lt;/em&gt; : 발신에 의해 반환 된 객체 &lt;em&gt;코 루틴 함수를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3911806e29cd9080090236543824b5efe243359e" translate="yes" xml:space="preserve">
          <source>a Future-like object with a &lt;code&gt;_asyncio_future_blocking&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;_asyncio_future_blocking&lt;/code&gt; 속성 을 가진 미래형 객체 .</target>
        </trans-unit>
        <trans-unit id="5891a4d5a151f585a0c68c891e76d580817faf7b" translate="yes" xml:space="preserve">
          <source>a Microsoft Windows code page, which is typically derived from an 8859 codeset, but replaces control characters with additional graphic characters</source>
          <target state="translated">일반적으로 8859 코드 세트에서 파생되지만 제어 문자를 추가 그래픽 문자로 대체하는 Microsoft Windows 코드 페이지</target>
        </trans-unit>
        <trans-unit id="933e55c18eda96ea117a68f16b3c87e563cf2584" translate="yes" xml:space="preserve">
          <source>a character string or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object representing the path to the file which will be opened. In this case closefd must be &lt;code&gt;True&lt;/code&gt; (the default) otherwise an error will be raised.</source>
          <target state="translated">열리는 파일의 경로를 나타내는 문자열 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 이 경우 closefd는 &lt;code&gt;True&lt;/code&gt; (기본값) 여야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="176fa9b59e72ef5e9b661ef430b1c1b283c9b900" translate="yes" xml:space="preserve">
          <source>a complex number with real part &lt;em&gt;re&lt;/em&gt;, imaginary part &lt;em&gt;im&lt;/em&gt;. &lt;em&gt;im&lt;/em&gt; defaults to zero.</source>
          <target state="translated">실수 부와 복소수 &lt;em&gt;재&lt;/em&gt; , 허수 부분의 &lt;em&gt;메신저&lt;/em&gt; . &lt;em&gt;im의&lt;/em&gt; 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="04cb47559c45099cd55090b108360692573d92cd" translate="yes" xml:space="preserve">
          <source>a connected and readable &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt; object; or</source>
          <target state="translated">연결되고 읽을 수있는 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt; 객체; 또는</target>
        </trans-unit>
        <trans-unit id="c913dab07a3e871b091d09309c9a97d8b988174f" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard error stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 사용하여 서브 프로세스의 표준 오류 스트림에 연결될 파이프를 나타내는 파일과 같은 객체</target>
        </trans-unit>
        <trans-unit id="1b8f3cba0ae0c31b00f743c2c6d5a5b70d8654de" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard input stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 사용하여 서브 프로세스의 표준 입력 스트림에 연결될 파이프를 나타내는 파일과 같은 객체</target>
        </trans-unit>
        <trans-unit id="58ab911c5e7c464d2be123c8d268865bad923208" translate="yes" xml:space="preserve">
          <source>a file-like object representing a pipe to be connected to the subprocess&amp;rsquo;s standard output stream using &lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt;&lt;code&gt;connect_write_pipe()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.connect_write_pipe&quot;&gt; &lt;code&gt;connect_write_pipe()&lt;/code&gt; &lt;/a&gt; 사용하여 서브 프로세스의 표준 출력 스트림에 연결될 파이프를 나타내는 파일과 같은 객체</target>
        </trans-unit>
        <trans-unit id="386f15c8139cf75838d497f40399a9103a530d1f" translate="yes" xml:space="preserve">
          <source>a labelled instruction, indicated with &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;,</source>
          <target state="translated">표지로 표시 지시 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="7f0697684cc35bd1f5f3599ded2ae60e4e90d78e" translate="yes" xml:space="preserve">
          <source>a list of all received parameters to the &lt;code&gt;MAIL&lt;/code&gt; command (the elements are uppercase strings; example: &lt;code&gt;['BODY=8BITMIME', 'SMTPUTF8']&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;MAIL&lt;/code&gt; 명령에 수신 된 모든 매개 변수 목록 (요소는 대문자 문자열입니다 (예 : &lt;code&gt;['BODY=8BITMIME', 'SMTPUTF8']&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="ebfac224217452ba9a90f212a902ee1a47ab2ecc" translate="yes" xml:space="preserve">
          <source>a logarithmic encoding</source>
          <target state="translated">로그 인코딩</target>
        </trans-unit>
        <trans-unit id="fc1acc3823ec59584f589d733c73ebf69a828ee4" translate="yes" xml:space="preserve">
          <source>a logarithmic encoding (used by Sun &lt;code&gt;.au&lt;/code&gt; files and &lt;code&gt;/dev/audio&lt;/code&gt;)</source>
          <target state="translated">로그 인코딩 (Sun &lt;code&gt;.au&lt;/code&gt; 파일 및 &lt;code&gt;/dev/audio&lt;/code&gt; 에서 사용 )</target>
        </trans-unit>
        <trans-unit id="3cbc86209c99fc06fedc28d20e4c6998dc771f44" translate="yes" xml:space="preserve">
          <source>a pattern from the wikipedia article on turtle graphics</source>
          <target state="translated">거북이 그래픽에 관한 Wikipedia 기사의 패턴</target>
        </trans-unit>
        <trans-unit id="48bc4d762f4726ec868d6099b805944b28af3288" translate="yes" xml:space="preserve">
          <source>a polygon-tuple, i.e. a tuple of pairs of coordinates</source>
          <target state="translated">다각형 튜플, 즉 좌표 쌍 튜플</target>
        </trans-unit>
        <trans-unit id="d95f33def911a2c6829c8462e2721a2559400b0d" translate="yes" xml:space="preserve">
          <source>a readable &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object;</source>
          <target state="translated">읽을 수있는 &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 객체;</target>
        </trans-unit>
        <trans-unit id="f0901badac04f3b74bfcc02503440581292c0bb3" translate="yes" xml:space="preserve">
          <source>a text string that is pattern matched against the label of the menu entry, as scanned from the top of the menu to the bottom. Note that this index type is considered after all the others, which means that matches for menu items labelled &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;, or &lt;code&gt;none&lt;/code&gt; may be interpreted as the above literals, instead.</source>
          <target state="translated">메뉴 상단에서 하단으로 스캔 할 때 메뉴 항목의 레이블과 패턴이 일치하는 텍스트 문자열. 이 색인 유형은 다른 모든 항목 다음에 고려되므로 &lt;code&gt;last&lt;/code&gt; , &lt;code&gt;active&lt;/code&gt; 또는 &lt;code&gt;none&lt;/code&gt; 으로 표시된 메뉴 항목과 일치하는 항목 은 위의 리터럴로 해석 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05df3d7b372bd2ddee06b6095e01e0e750c166b5" translate="yes" xml:space="preserve">
          <source>a write occurred</source>
          <target state="translated">쓰기가 발생했습니다</target>
        </trans-unit>
        <trans-unit id="4afe0f0bc0033bb9859082e1c5eae63420774b7a" translate="yes" xml:space="preserve">
          <source>abbreviation of timezone name</source>
          <target state="translated">시간대 이름의 약어</target>
        </trans-unit>
        <trans-unit id="a9993e364706816aba3e25717850c26c9cd0d89d" translate="yes" xml:space="preserve">
          <source>abc</source>
          <target state="translated">abc</target>
        </trans-unit>
        <trans-unit id="c08753fb4d9d1abe3ccddc9ff169db6e7c7528c6" translate="yes" xml:space="preserve">
          <source>abc &amp;mdash; Abstract Base Classes</source>
          <target state="translated">abc &amp;mdash; 추상 기본 클래스</target>
        </trans-unit>
        <trans-unit id="bf9ea26d3d8e8312edf5a0bebaf7517d3a4dd7e1" translate="yes" xml:space="preserve">
          <source>abc.ABC</source>
          <target state="translated">abc.ABC</target>
        </trans-unit>
        <trans-unit id="ba245dfb03cc341cb848315c70bc52fbf739961d" translate="yes" xml:space="preserve">
          <source>abc.ABCMeta</source>
          <target state="translated">abc.ABCMeta</target>
        </trans-unit>
        <trans-unit id="c29b9fa83144882e32d4099551dd42373c86d00c" translate="yes" xml:space="preserve">
          <source>abc.ABCMeta.__subclasshook__()</source>
          <target state="translated">abc.ABCMeta.__subclasshook__()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
