<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="06cb3a2370ac3af4084ddb6774ba1f927d10f1da" translate="yes" xml:space="preserve">
          <source>How the compiler treats future imports.</source>
          <target state="translated">컴파일러가 향후 가져 오기를 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="9621e5b402eaf2bc653d7acbb6c0fc8aec7dbcee" translate="yes" xml:space="preserve">
          <source>How to configure Screen and Turtles</source>
          <target state="translated">화면과 거북이를 구성하는 방법</target>
        </trans-unit>
        <trans-unit id="8a47b2e2c48117dfb7843cebb091861bfbbbe021" translate="yes" xml:space="preserve">
          <source>How to create an archive and reset the user information using the &lt;em&gt;filter&lt;/em&gt; parameter in &lt;a href=&quot;#tarfile.TarFile.add&quot;&gt;&lt;code&gt;TarFile.add()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.add&quot;&gt; &lt;code&gt;TarFile.add()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;필터&lt;/em&gt; 매개 변수를 사용하여 아카이브를 작성하고 사용자 정보를 재설정하는 방법 :</target>
        </trans-unit>
        <trans-unit id="e8fa6daa5f75642da8422e72ceb883cde131d7f0" translate="yes" xml:space="preserve">
          <source>How to create an uncompressed tar archive from a list of filenames:</source>
          <target state="translated">파일 이름 목록에서 압축되지 않은 tar 아카이브를 작성하는 방법 :</target>
        </trans-unit>
        <trans-unit id="54799d0a1acb21e18739c385fc568caa565a6484" translate="yes" xml:space="preserve">
          <source>How to extract a subset of a tar archive with &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt;&lt;code&gt;TarFile.extractall()&lt;/code&gt;&lt;/a&gt; using a generator function instead of a list:</source>
          <target state="translated">목록 대신 생성기 함수를 사용하여 &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt; &lt;code&gt;TarFile.extractall()&lt;/code&gt; &lt;/a&gt; 사용하여 tar 아카이브의 서브 세트를 추출하는 방법 :</target>
        </trans-unit>
        <trans-unit id="125dc6e327af012b85b1699c8d0b4aea4fd5aa6e" translate="yes" xml:space="preserve">
          <source>How to extract an entire tar archive to the current working directory:</source>
          <target state="translated">전체 tar 아카이브를 현재 작업 디렉토리로 추출하는 방법 :</target>
        </trans-unit>
        <trans-unit id="6187ce11d668add52961b9aad04fcebce97277f5" translate="yes" xml:space="preserve">
          <source>How to read a gzip compressed tar archive and display some member information:</source>
          <target state="translated">gzip 압축 tar 아카이브를 읽고 일부 멤버 정보를 표시하는 방법 :</target>
        </trans-unit>
        <trans-unit id="6979f33c643743b3e1710eb3c8b04ebe15229773" translate="yes" xml:space="preserve">
          <source>How to use help</source>
          <target state="translated">도움말 사용법</target>
        </trans-unit>
        <trans-unit id="0ca8006d50f8b1fe3fcd3fbdbf73e28bca7fec95" translate="yes" xml:space="preserve">
          <source>How you use the &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module in your code depends on whether you are internationalizing a single module or your entire application. The next two sections will discuss each case.</source>
          <target state="translated">코드에서 &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 방법 은 단일 모듈 또는 전체 애플리케이션을 국제화하는지 여부에 따라 다릅니다. 다음 두 섹션에서는 각 사례에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="cc2d951db9dd240ca5bf48d29a4e5261e13b4412" translate="yes" xml:space="preserve">
          <source>However, &lt;a href=&quot;#asyncio.Protocol.eof_received&quot;&gt;&lt;code&gt;protocol.eof_received()&lt;/code&gt;&lt;/a&gt; is called at most once. Once &lt;code&gt;eof_received()&lt;/code&gt; is called, &lt;code&gt;data_received()&lt;/code&gt; is not called anymore.</source>
          <target state="translated">그러나 &lt;a href=&quot;#asyncio.Protocol.eof_received&quot;&gt; &lt;code&gt;protocol.eof_received()&lt;/code&gt; &lt;/a&gt; 가 최대 한 번 호출됩니다. 일단 &lt;code&gt;eof_received()&lt;/code&gt; , 호출 &lt;code&gt;data_received()&lt;/code&gt; 더 이상 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0a858d192763a36609cbf2152f0a6b9ea1b92e5" translate="yes" xml:space="preserve">
          <source>However, a more generic mechanism is needed for user-defined objects which are not known to the &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; module. For example, consider &lt;a href=&quot;logging.handlers#logging.handlers.MemoryHandler&quot;&gt;&lt;code&gt;logging.handlers.MemoryHandler&lt;/code&gt;&lt;/a&gt;, which takes a &lt;code&gt;target&lt;/code&gt; argument which is another handler to delegate to. Since the system already knows about this class, then in the configuration, the given &lt;code&gt;target&lt;/code&gt; just needs to be the object id of the relevant target handler, and the system will resolve to the handler from the id. If, however, a user defines a &lt;code&gt;my.package.MyHandler&lt;/code&gt; which has an &lt;code&gt;alternate&lt;/code&gt; handler, the configuration system would not know that the &lt;code&gt;alternate&lt;/code&gt; referred to a handler. To cater for this, a generic resolution system allows the user to specify:</source>
          <target state="translated">그러나 &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 모듈에 알려지지 않은 사용자 정의 개체에는보다 일반적인 메커니즘이 필요 합니다. 예를 들어, &lt;a href=&quot;logging.handlers#logging.handlers.MemoryHandler&quot;&gt; &lt;code&gt;logging.handlers.MemoryHandler&lt;/code&gt; 를&lt;/a&gt; 고려해보십시오 . 이는 위임 할 다른 핸들러 인 &lt;code&gt;target&lt;/code&gt; 인수를 사용합니다. 시스템은 이미이 클래스에 대해 알고 있으므로 구성에서 지정된 &lt;code&gt;target&lt;/code&gt; 은 관련 대상 핸들러의 오브젝트 ID 일 뿐이며 시스템은 ID에서 핸들러로 해석됩니다. 그러나, 사용자가 정의하는 경우 &lt;code&gt;my.package.MyHandler&lt;/code&gt; 가 &lt;code&gt;alternate&lt;/code&gt; 핸들러를 구성 시스템은 알지 못 할 &lt;code&gt;alternate&lt;/code&gt; 핸들러를 참조하십시오. 이를 위해 일반 해상도 시스템을 사용하면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f378a310ff84ad7919807057388f38c47b1c65e4" translate="yes" xml:space="preserve">
          <source>However, consider the alternative scenario where instead of &lt;code&gt;from a import
SomeClass&lt;/code&gt; module b does &lt;code&gt;import a&lt;/code&gt; and &lt;code&gt;some_function&lt;/code&gt; uses &lt;code&gt;a.SomeClass&lt;/code&gt;. Both of these import forms are common. In this case the class we want to patch is being looked up in the module and so we have to patch &lt;code&gt;a.SomeClass&lt;/code&gt; instead:</source>
          <target state="translated">그러나 대신에 다른 시나리오를 고려 &lt;code&gt;from a import SomeClass&lt;/code&gt; 수행 모듈 B &lt;code&gt;import a&lt;/code&gt; 하고 &lt;code&gt;some_function&lt;/code&gt; 가 사용 &lt;code&gt;a.SomeClass&lt;/code&gt; 을 . 이 두 가지 가져 오기 양식이 일반적입니다. 이 경우 패치하려는 클래스가 모듈에서 검색되므로 &lt;code&gt;a.SomeClass&lt;/code&gt; 를 대신 패치 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="439bf14282c72fd1ed84e1410444feb63481ab8b" translate="yes" xml:space="preserve">
          <source>However, global variables which are just module level constants cause no problems.</source>
          <target state="translated">그러나 모듈 수준 상수 인 전역 변수는 문제를 일으키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8da1514a7f4d0b15655c2472b7999f9854a1d368" translate="yes" xml:space="preserve">
          <source>However, handling of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; methods is notoriously implementation specific, since it depends on internal details of the interpreter&amp;rsquo;s garbage collector implementation.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메서드 처리 는 인터프리터의 가비지 수집기 구현에 대한 내부 세부 정보에 의존하기 때문에 구현별로 악명이 높습니다.</target>
        </trans-unit>
        <trans-unit id="1ce34591ae0ca15bf16f23d12befc169e2bb9a82" translate="yes" xml:space="preserve">
          <source>However, handling of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;__del__()&lt;/code&gt;&lt;/a&gt; methods is notoriously implementation specific, since it depends on internal details of the interpreter&amp;rsquo;s garbage collector implementation.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;__del__()&lt;/code&gt; &lt;/a&gt; 메서드의 처리는 인터프리터의 가비지 수집기 구현의 내부 세부 사항에 의존하기 때문에 구현에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="524385f4308742264684061a603d78f1b65969ea" translate="yes" xml:space="preserve">
          <source>However, if you are writing a library (and do not control in which context its code will be executed), be aware that the standard streams may be replaced with file-like objects like &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; which do not support the &lt;code&gt;buffer&lt;/code&gt; attribute.</source>
          <target state="translated">그러나 라이브러리를 작성하는 경우 (코드가 실행될 컨텍스트를 제어하지 않는 경우) 표준 스트림은 &lt;code&gt;buffer&lt;/code&gt; 속성을 지원하지 않는 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 와 같은 파일과 유사한 객체로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b769de1746f60e4baa053e7572f0057d9c8fe3d0" translate="yes" xml:space="preserve">
          <source>However, if you really do need to use some shared data then &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; provides a couple of ways of doing so.</source>
          <target state="translated">그러나 실제로 공유 데이터를 사용해야하는 경우 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 은 몇 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="23eebfaf8db57314d57e41112830f6a06b63dacc" translate="yes" xml:space="preserve">
          <source>However, in a Windows path, changing the local root doesn&amp;rsquo;t discard the previous drive setting:</source>
          <target state="translated">그러나 Windows 경로에서 로컬 루트를 변경해도 이전 드라이브 설정은 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f42d2d8c9bca01face2f0640d30c8b6b4f7aef41" translate="yes" xml:space="preserve">
          <source>However, it is possible to create a &lt;a href=&quot;#typing.NewType&quot;&gt;&lt;code&gt;NewType()&lt;/code&gt;&lt;/a&gt; based on a &amp;lsquo;derived&amp;rsquo; &lt;code&gt;NewType&lt;/code&gt;:</source>
          <target state="translated">그러나 '파생' &lt;code&gt;NewType&lt;/code&gt; 을 기반으로 &lt;a href=&quot;#typing.NewType&quot;&gt; &lt;code&gt;NewType()&lt;/code&gt; &lt;/a&gt; 을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d78b154c37b0dfd16aaf863d992caf9a3e8512e0" translate="yes" xml:space="preserve">
          <source>However, should you want to customize the building of your test suite, you can do it yourself:</source>
          <target state="translated">그러나 테스트 스위트의 빌드를 사용자 정의하려는 경우 직접 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e105ff00b24b9693a483aad8940ba6101edec1f" translate="yes" xml:space="preserve">
          <source>However, since the SSL (and TLS) protocol has its own framing atop of TCP, the SSL sockets abstraction can, in certain respects, diverge from the specification of normal, OS-level sockets. See especially the &lt;a href=&quot;#ssl-nonblocking&quot;&gt;notes on non-blocking sockets&lt;/a&gt;.</source>
          <target state="translated">그러나 SSL (및 TLS) 프로토콜에는 TCP 위에 자체 프레이밍이 있으므로 SSL 소켓 추상화는 특정 측면에서 정상적인 OS 수준 소켓 사양과 다를 수 있습니다. &lt;a href=&quot;#ssl-nonblocking&quot;&gt;비 차단 소켓에&lt;/a&gt; 대한 참고 사항을 특히 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="53fcc45334330c2206a16cded9422e941e3c0225" translate="yes" xml:space="preserve">
          <source>However, such expressions are valid when &lt;a href=&quot;typing#generics&quot;&gt;type variables&lt;/a&gt; are used. The index must have as many elements as there are type variable items in the &lt;code&gt;GenericAlias&lt;/code&gt; object&amp;rsquo;s &lt;a href=&quot;#genericalias.__args__&quot;&gt;&lt;code&gt;__args__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그러나 이러한 식은 &lt;a href=&quot;typing#generics&quot;&gt;유형 변수&lt;/a&gt; 를 사용할 때 유효합니다 . 인덱스에는 &lt;code&gt;GenericAlias&lt;/code&gt; 객체의 &lt;a href=&quot;#genericalias.__args__&quot;&gt; &lt;code&gt;__args__&lt;/code&gt; &lt;/a&gt; 에있는 유형 변수 항목만큼 많은 요소가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8fede9e85907b8edc885805dba8e1a629627b87" translate="yes" xml:space="preserve">
          <source>However, the &lt;a href=&quot;#module-multiprocessing.connection&quot;&gt;&lt;code&gt;multiprocessing.connection&lt;/code&gt;&lt;/a&gt; module allows some extra flexibility. It basically gives a high level message oriented API for dealing with sockets or Windows named pipes. It also has support for &lt;em&gt;digest authentication&lt;/em&gt; using the &lt;a href=&quot;hmac#module-hmac&quot;&gt;&lt;code&gt;hmac&lt;/code&gt;&lt;/a&gt; module, and for polling multiple connections at the same time.</source>
          <target state="translated">그러나 &lt;a href=&quot;#module-multiprocessing.connection&quot;&gt; &lt;code&gt;multiprocessing.connection&lt;/code&gt; &lt;/a&gt; 모듈은 추가적인 유연성을 제공합니다. 기본적으로 소켓 또는 Windows 명명 된 파이프를 처리하기위한 고급 메시지 지향 API를 제공합니다. 또한 &lt;a href=&quot;hmac#module-hmac&quot;&gt; &lt;code&gt;hmac&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 &lt;em&gt;다이제스트 인증&lt;/em&gt; 을 지원 하고 동시에 여러 연결을 폴링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6a9f983b8ff7cdac272806e8c7920846eea877" translate="yes" xml:space="preserve">
          <source>However, they still can&amp;rsquo;t be compared to standard &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; enumerations:</source>
          <target state="translated">그러나 여전히 표준 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 형 열거 형 과 비교할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="91333f2e4bfca97b3f05dfcc743022c8782b7559" translate="yes" xml:space="preserve">
          <source>However, to match the shell as closely as possible, it is recommended to always use &lt;code&gt;posix&lt;/code&gt; and &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; when using &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt;, which will negate &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt;&lt;code&gt;wordchars&lt;/code&gt;&lt;/a&gt; entirely.</source>
          <target state="translated">그러나 밀접하게 가능한 쉘에 맞게 항상 사용을 권장 &lt;code&gt;posix&lt;/code&gt; 및 &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 사용하는 경우 &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; &lt;/a&gt; 부정하는 것, &lt;a href=&quot;#shlex.shlex.wordchars&quot;&gt; &lt;code&gt;wordchars&lt;/code&gt; 을&lt;/a&gt; 완전히합니다.</target>
        </trans-unit>
        <trans-unit id="9b74bb3116de6c2b6f2b5b3489fa54307c65fc89" translate="yes" xml:space="preserve">
          <source>However, two enum members are allowed to have the same value. Given two members A and B with the same value (and A defined first), B is an alias to A. By-value lookup of the value of A and B will return A. By-name lookup of B will also return A:</source>
          <target state="translated">그러나 두 열거 형 멤버는 동일한 값을 가질 수 있습니다. 같은 값을 가진 두 멤버 A와 B (그리고 A가 먼저 정의 됨)가 주어지면 B는 A의 별칭입니다. A와 B 값의 값별 조회는 A를 반환합니다. B의 이름 별 조회도 A를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d317839ba4e2c85ee86b52a46ee27291e7f15167" translate="yes" xml:space="preserve">
          <source>However, when using a proxy for a namespace object, an attribute beginning with &lt;code&gt;'_'&lt;/code&gt; will be an attribute of the proxy and not an attribute of the referent:</source>
          <target state="translated">그러나 네임 스페이스 객체에 프록시를 사용하는 경우 &lt;code&gt;'_'&lt;/code&gt; 로 시작 하는 속성은 참조 속성이 아닌 프록시 속성이됩니다.</target>
        </trans-unit>
        <trans-unit id="9db1c257cbf6348bd2bdc6bec9835ad1ee2611cd" translate="yes" xml:space="preserve">
          <source>Human-readable time when the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; was created. By default this is of the form &amp;lsquo;2003-07-08 16:49:45,896&amp;rsquo; (the numbers after the comma are millisecond portion of the time).</source>
          <target state="translated">&lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt; 가 작성된 사람이 읽을 수있는 시간 입니다. 기본적으로 '2003-07-08 16 : 49 : 45,896'형식입니다 (쉼표 뒤의 숫자는 시간의 밀리 초입니다).</target>
        </trans-unit>
        <trans-unit id="9c8511b78ed54aa0fa96cb081001b1a2bf46efeb" translate="yes" xml:space="preserve">
          <source>Human-readable version of &lt;a href=&quot;#wave.Wave_read.getcomptype&quot;&gt;&lt;code&gt;getcomptype()&lt;/code&gt;&lt;/a&gt;. Usually &lt;code&gt;'not compressed'&lt;/code&gt; parallels &lt;code&gt;'NONE'&lt;/code&gt;.</source>
          <target state="translated">사람이 읽을 수있는 &lt;a href=&quot;#wave.Wave_read.getcomptype&quot;&gt; &lt;code&gt;getcomptype()&lt;/code&gt; &lt;/a&gt; 버전 . 일반적으로 &lt;code&gt;'not compressed'&lt;/code&gt; &lt;code&gt;'NONE'&lt;/code&gt; 과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="add9ea21e0134d1a6dc92640398cf0190b05790e" translate="yes" xml:space="preserve">
          <source>Hung up</source>
          <target state="translated">전화를 끊다</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="de2470c480abd98424dacb0f44f27ca062690dfb" translate="yes" xml:space="preserve">
          <source>I will present an example here which uses the standard C library&amp;rsquo;s &lt;code&gt;qsort()&lt;/code&gt; function, that is used to sort items with the help of a callback function. &lt;code&gt;qsort()&lt;/code&gt; will be used to sort an array of integers:</source>
          <target state="translated">콜백 함수를 사용하여 항목을 정렬 하는 데 사용되는 표준 C 라이브러리의 &lt;code&gt;qsort()&lt;/code&gt; 함수 를 사용하는 예제를 여기에 표시합니다 . &lt;code&gt;qsort()&lt;/code&gt; 는 정수 배열을 정렬하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9a9c3553918e97b386614c46b9394f4b8471c979" translate="yes" xml:space="preserve">
          <source>I/O Base Classes</source>
          <target state="translated">I / O 기본 클래스</target>
        </trans-unit>
        <trans-unit id="0676b814ab2a9d403059287e94b18b3f3ed5e63c" translate="yes" xml:space="preserve">
          <source>I/O error</source>
          <target state="translated">입출력 오류</target>
        </trans-unit>
        <trans-unit id="2711395734586dad19e3e7e6bf6c599633c758e2" translate="yes" xml:space="preserve">
          <source>I/O operations may fail even when &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; indicates that they would succeed, particularly for operations on network filesystems which may have permissions semantics beyond the usual POSIX permission-bit model.</source>
          <target state="translated">&lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 가 성공할 것임을 나타내는 경우에도 특히 I / O 작업이 실패 할 수 있습니다. 특히 일반적인 POSIX 권한 비트 모델 이외의 권한 의미가있는 네트워크 파일 시스템에서의 작업의 경우.</target>
        </trans-unit>
        <trans-unit id="f7d467a87245290159a1b6af42928666730653f6" translate="yes" xml:space="preserve">
          <source>IANA</source>
          <target state="translated">IANA</target>
        </trans-unit>
        <trans-unit id="fd1cdb7e9dcbc4982fb094e6764772bf3b00e12c" translate="yes" xml:space="preserve">
          <source>IANA TLS: Transport Layer Security (TLS) Parameters</source>
          <target state="translated">IANA TLS : TLS (Transport Layer Security) 매개 변수</target>
        </trans-unit>
        <trans-unit id="5936f115af9d290a0d4c51a3b370fe51eb023734" translate="yes" xml:space="preserve">
          <source>IANA timezone database</source>
          <target state="translated">IANA 시간대 데이터베이스</target>
        </trans-unit>
        <trans-unit id="bce52158db4ea934391bad4260ff69db81d9b587" translate="yes" xml:space="preserve">
          <source>IBM&amp;rsquo;s General Decimal Arithmetic Specification, &lt;a href=&quot;http://speleotrove.com/decimal/decarith.html&quot;&gt;The General Decimal Arithmetic Specification&lt;/a&gt;.</source>
          <target state="translated">IBM의 일반 십진 산술 스펙, &lt;a href=&quot;http://speleotrove.com/decimal/decarith.html&quot;&gt;일반 십진 산술 스펙&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d384f46aa316c46d9da3980789c420f3f02914f" translate="yes" xml:space="preserve">
          <source>IBM037, IBM039</source>
          <target state="translated">IBM037, IBM039</target>
        </trans-unit>
        <trans-unit id="25c9f2e3939dfc2b3f7f8e99803711ba0f10dd8f" translate="yes" xml:space="preserve">
          <source>IBM775</source>
          <target state="translated">IBM775</target>
        </trans-unit>
        <trans-unit id="2e03293740ecf9023db87941f55d98d607008460" translate="yes" xml:space="preserve">
          <source>IBM864</source>
          <target state="translated">IBM864</target>
        </trans-unit>
        <trans-unit id="d0c6332e03ed7288ab9fabcfcbe8f7d47ead9f1d" translate="yes" xml:space="preserve">
          <source>IDL Type</source>
          <target state="translated">IDL 유형</target>
        </trans-unit>
        <trans-unit id="6bf8911095af71a660308ff2f022e3f091e35f17" translate="yes" xml:space="preserve">
          <source>IDL attributes map to instance attributes. For compatibility with the OMG IDL language mapping for Python, an attribute &lt;code&gt;foo&lt;/code&gt; can also be accessed through accessor methods &lt;code&gt;_get_foo()&lt;/code&gt; and &lt;code&gt;_set_foo()&lt;/code&gt;. &lt;code&gt;readonly&lt;/code&gt; attributes must not be changed; this is not enforced at runtime.</source>
          <target state="translated">IDL 속성은 인스턴스 속성에 매핑됩니다. Python 용 OMG IDL 언어 매핑과의 호환성을 위해 접근 자 메소드 &lt;code&gt;_get_foo()&lt;/code&gt; 및 &lt;code&gt;_set_foo()&lt;/code&gt; 통해 속성 &lt;code&gt;foo&lt;/code&gt; 에 액세스 할 수 있습니다 . &lt;code&gt;readonly&lt;/code&gt; 속성은 변경하지 않아야합니다. 런타임에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4646e9f2b71a8bdc5087acabdc0352b0d257af74" translate="yes" xml:space="preserve">
          <source>IDLE</source>
          <target state="translated">IDLE</target>
        </trans-unit>
        <trans-unit id="619274f5a3734b1f62b9c727af1d75beec311b03" translate="yes" xml:space="preserve">
          <source>IDLE Help</source>
          <target state="translated">유휴 도움말</target>
        </trans-unit>
        <trans-unit id="898dce9ecf90e7e7d5d02cf64e27fe2734513168" translate="yes" xml:space="preserve">
          <source>IDLE assumes that files with a known .py* extension contain Python code and that other files do not. Run Python code with the Run menu.</source>
          <target state="translated">IDLE은 알려진 .py * 확장자를 가진 파일에 Python 코드가 포함되어 있고 다른 파일은 포함하지 않는다고 가정합니다. 실행 메뉴를 사용하여 Python 코드를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="75bbc791a4aa40f6497c42cba8acc7f613d3b8cb" translate="yes" xml:space="preserve">
          <source>IDLE contains an extension facility. Preferences for extensions can be changed with the Extensions tab of the preferences dialog. See the beginning of config-extensions.def in the idlelib directory for further information. The only current default extension is zzdummy, an example also used for testing.</source>
          <target state="translated">IDLE에는 확장 기능이 포함되어 있습니다. 기본 설정 대화 상자의 확장 탭에서 확장에 대한 기본 설정을 변경할 수 있습니다. 자세한 정보는 idlelib 디렉토리에서 config-extensions.def 시작을 참조하십시오. 현재 기본 확장명은 zzdummy 뿐이며 테스트에도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ea11f11dfc2e4dc9fcce02ad959e9a853a35043" translate="yes" xml:space="preserve">
          <source>IDLE has the following features:</source>
          <target state="translated">IDLE에는 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="44f3701f5db6a9639148f6560d8fff5476184868" translate="yes" xml:space="preserve">
          <source>IDLE has two main window types, the Shell window and the Editor window. It is possible to have multiple editor windows simultaneously. On Windows and Linux, each has its own top menu. Each menu documented below indicates which window type it is associated with.</source>
          <target state="translated">IDLE에는 셸 창과 편집기 창이라는 두 가지 기본 창 유형이 있습니다. 여러 개의 편집기 창을 동시에 가질 수 있습니다. Windows 및 Linux에서는 각각 고유 한 최상위 메뉴가 있습니다. 아래에 문서화 된 각 메뉴는 연관된 창 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44fac21ae0e0592212109932c2b71c550bd61ce6" translate="yes" xml:space="preserve">
          <source>IDLE is Python&amp;rsquo;s Integrated Development and Learning Environment.</source>
          <target state="translated">IDLE은 Python의 통합 개발 및 학습 환경입니다.</target>
        </trans-unit>
        <trans-unit id="6e56c2de541f27a1c04500e97b2142294c0794aa" translate="yes" xml:space="preserve">
          <source>IDLE is intentionally different from standard Python in order to facilitate development of tkinter programs. Enter &lt;code&gt;import tkinter as tk;
root = tk.Tk()&lt;/code&gt; in standard Python and nothing appears. Enter the same in IDLE and a tk window appears. In standard Python, one must also enter &lt;code&gt;root.update()&lt;/code&gt; to see the window. IDLE does the equivalent in the background, about 20 times a second, which is about every 50 milliseconds. Next enter &lt;code&gt;b = tk.Button(root, text='button'); b.pack()&lt;/code&gt;. Again, nothing visibly changes in standard Python until one enters &lt;code&gt;root.update()&lt;/code&gt;.</source>
          <target state="translated">IDLE은 tkinter 프로그램 개발을 용이하게하기 위해 표준 Python과 의도적으로 다릅니다. &lt;code&gt;import tkinter as tk; root = tk.Tk()&lt;/code&gt; 입력하십시오 . 표준 파이썬에서는 root = tk.Tk () 가 나타나지 않습니다. IDLE에 동일하게 입력하면 tk 창이 나타납니다. 표준 파이썬에서는 창을 보려면 &lt;code&gt;root.update()&lt;/code&gt; 를 입력해야합니다 . IDLE은 초당 약 20 회 (50 밀리 초마다) 백그라운드에서 동등한 기능을 수행합니다. 다음으로 &lt;code&gt;b = tk.Button(root, text='button'); b.pack()&lt;/code&gt; . 다시 말하지만, &lt;code&gt;root.update()&lt;/code&gt; 들어갈 때까지 표준 Python에서 아무것도 변경되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8d796c27be2cf21ed59c8759c905bc23b350d7b4" translate="yes" xml:space="preserve">
          <source>IDLE may open editor windows when it starts, depending on settings and how you start IDLE. Thereafter, use the File menu. There can be only one open editor window for a given file.</source>
          <target state="translated">설정 및 IDLE 시작 방법에 따라 IDLE이 시작될 때 편집기 창을 열 수 있습니다. 그런 다음 파일 메뉴를 사용하십시오. 주어진 파일에 대해 열린 편집기 창이 하나만있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="253f821a5f3a1c94a0536918c1450667d7b406ce" translate="yes" xml:space="preserve">
          <source>IDLE on macOS</source>
          <target state="translated">macOS의 유휴</target>
        </trans-unit>
        <trans-unit id="07b20364b24d2a4a15afcdbe6b5431a328e5b391" translate="yes" xml:space="preserve">
          <source>IDLE uses a socket to communicate between the IDLE GUI process and the user code execution process. A connection must be established whenever the Shell starts or restarts. (The latter is indicated by a divider line that says &amp;lsquo;RESTART&amp;rsquo;). If the user process fails to connect to the GUI process, it displays a &lt;code&gt;Tk&lt;/code&gt; error box with a &amp;lsquo;cannot connect&amp;rsquo; message that directs the user here. It then exits.</source>
          <target state="translated">IDLE은 소켓을 사용하여 IDLE GUI 프로세스와 사용자 코드 실행 프로세스간에 통신합니다. 셸을 시작하거나 다시 시작할 때마다 연결을 설정해야합니다. 후자는 'RESTART'라고 표시된 구분선으로 표시됩니다. 사용자 프로세스가 GUI 프로세스에 연결하지 못하면 여기에 사용자를 지시하는 '연결할 수 없음'메시지와 함께 &lt;code&gt;Tk&lt;/code&gt; 오류 상자가 표시됩니다 . 그런 다음 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="294f9b9e7d21007e31d5bb92fc308b2f7b9ed947" translate="yes" xml:space="preserve">
          <source>IDLE&amp;rsquo;s standard stream replacements are not inherited by subprocesses created in the execution process, whether directly by user code or by modules such as multiprocessing. If such subprocess use &lt;code&gt;input&lt;/code&gt; from sys.stdin or &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;write&lt;/code&gt; to sys.stdout or sys.stderr, IDLE should be started in a command line window. The secondary subprocess will then be attached to that window for input and output.</source>
          <target state="translated">IDLE의 표준 스트림 대체는 사용자 코드 또는 멀티 프로세싱과 같은 모듈에 의해 실행 프로세스에서 작성된 서브 프로세스에 의해 상속되지 않습니다. 이러한 서브 프로세스 가 sys.stdin의 &lt;code&gt;input&lt;/code&gt; 을 사용 하거나 sys.stdout 또는 sys.stderr에 &lt;code&gt;print&lt;/code&gt; 하거나 &lt;code&gt;write&lt;/code&gt; 명령 행 창에서 IDLE을 시작해야합니다. 그러면 보조 하위 프로세스가 입력 및 출력을 위해 해당 창에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="aea80ada688c48062d55019e094cc1143e3a0adc" translate="yes" xml:space="preserve">
          <source>IETF</source>
          <target state="translated">IETF</target>
        </trans-unit>
        <trans-unit id="a3cbd29464a3f016524be318899e3b8625bcb53b" translate="yes" xml:space="preserve">
          <source>IIS can be configured to pass the correct &lt;code&gt;PATH_INFO&lt;/code&gt;, but this causes another bug where &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; is wrong. Luckily this variable is rarely used and is not guaranteed by WSGI. On IIS&amp;lt;7, though, the setting can only be made on a vhost level, affecting all other script mappings, many of which break when exposed to the &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; bug. For this reason IIS&amp;lt;7 is almost never deployed with the fix (Even IIS7 rarely uses it because there is still no UI for it.).</source>
          <target state="translated">IIS는 올바른 &lt;code&gt;PATH_INFO&lt;/code&gt; 를 전달하도록 구성 할 수 있지만 이로 인해 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 가 잘못된 또 다른 버그가 발생 합니다. 다행히이 변수는 거의 사용되지 않으며 WSGI에 의해 보장되지 않습니다. 그러나 IIS &amp;lt;7에서는 가상 호스트 수준에서만 설정을 수행 할 수 있으며 다른 모든 스크립트 매핑에 영향을 미치며 대부분 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 버그에 노출되면 중단됩니다 . 이러한 이유로 IIS &amp;lt;7은 수정 사항과 함께 배포되지 않습니다 (IIS7조차도 UI가 없기 때문에 거의 사용하지 않습니다.).</target>
        </trans-unit>
        <trans-unit id="f9c9fbbc612c61efdc44101bdc0b4c61f818bba4" translate="yes" xml:space="preserve">
          <source>IIS can be configured to pass the correct &lt;code&gt;PATH_INFO&lt;/code&gt;, but this causes another bug where &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; is wrong. Luckily this variable is rarely used and is not guaranteed by WSGI. On IIS&amp;lt;7, though, the setting can only be made on a vhost level, affecting all other script mappings, many of which break when exposed to the &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; bug. For this reason IIS&amp;lt;7 is almost never deployed with the fix. (Even IIS7 rarely uses it because there is still no UI for it.)</source>
          <target state="translated">IIS는 올바른 &lt;code&gt;PATH_INFO&lt;/code&gt; 를 전달하도록 구성 할 수 있지만 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 가 잘못된 다른 버그가 발생 합니다. 운 좋게도이 변수는 거의 사용되지 않으며 WSGI에서 보장하지 않습니다. 그러나 IIS &amp;lt;7에서는이 설정을 가상 호스트 수준에서만 수행 할 수 있으며 다른 모든 스크립트 매핑에 영향을 미치며 대부분은 &lt;code&gt;PATH_TRANSLATED&lt;/code&gt; 버그에 노출되면 중단됩니다 . 이러한 이유로 IIS &amp;lt;7은 거의 수정 사항으로 배포되지 않습니다. (IIS7조차도 UI가 없기 때문에 거의 사용하지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="dc5982d33dd23bd8d90805fafc24a3114eaf3d91" translate="yes" xml:space="preserve">
          <source>IMAP (Internet Message Access Protocol) client</source>
          <target state="translated">IMAP (Internet Message Access Protocol) 클라이언트</target>
        </trans-unit>
        <trans-unit id="ee980c33b9d65ac696be3577604e43ad769530f5" translate="yes" xml:space="preserve">
          <source>IMAP4 Example</source>
          <target state="translated">IMAP4 예</target>
        </trans-unit>
        <trans-unit id="0bf33cf42855fe39a37a956bf4ca9bce143662b0" translate="yes" xml:space="preserve">
          <source>IMAP4 Objects</source>
          <target state="translated">IMAP4 객체</target>
        </trans-unit>
        <trans-unit id="54a2e0f83d696897f7938ff4e902b96cfe7ebe39" translate="yes" xml:space="preserve">
          <source>IMAP4 server errors cause this exception to be raised. This is a sub-class of &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt;&lt;code&gt;IMAP4.error&lt;/code&gt;&lt;/a&gt;. Note that closing the instance and instantiating a new one will usually allow recovery from this exception.</source>
          <target state="translated">IMAP4 서버 오류로 인해이 예외가 발생합니다. 이것은 &lt;a href=&quot;#imaplib.IMAP4.error&quot;&gt; &lt;code&gt;IMAP4.error&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 인스턴스를 닫고 새 인스턴스를 인스턴스화하면 일반적으로이 예외에서 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="2ccb5c6f3f5eedcfc4714430d8777d910b94fd71" translate="yes" xml:space="preserve">
          <source>IP Addresses</source>
          <target state="translated">IP 주소</target>
        </trans-unit>
        <trans-unit id="9e3725069a7ec82ac5ffec06a0726dc4f7d933d6" translate="yes" xml:space="preserve">
          <source>IP Network definitions</source>
          <target state="translated">IP 네트워크 정의</target>
        </trans-unit>
        <trans-unit id="0c1d08e522b1ada055f757b0f439e1183ee338ed" translate="yes" xml:space="preserve">
          <source>ISO 8601 week as a decimal number with Monday as the first day of the week. Week 01 is the week containing Jan 4.</source>
          <target state="translated">월요일을 요일의 첫 번째 요일로하는 ISO 8601 주 (10 진수) 주 01은 1 월 4 일이 포함 된 주입니다.</target>
        </trans-unit>
        <trans-unit id="f8995e635cfe9c3a98e07c9ba781f0a6358cb3c9" translate="yes" xml:space="preserve">
          <source>ISO 8601 weekday as a decimal number where 1 is Monday.</source>
          <target state="translated">평일 1은 월요일 인 ISO 8601 평일입니다.</target>
        </trans-unit>
        <trans-unit id="514bf155d39ffefb08418af80af6de7e45130d9e" translate="yes" xml:space="preserve">
          <source>ISO 8601 year with century representing the year that contains the greater part of the ISO week (&lt;code&gt;%V&lt;/code&gt;).</source>
          <target state="translated">ISO 주 ( &lt;code&gt;%V&lt;/code&gt; ) 의 대부분을 포함하는 연도를 나타내는 세기가있는 ISO 8601 연도입니다 .</target>
        </trans-unit>
        <trans-unit id="f55f5622b2b522bc805cc41ff05e2c603a2bf278" translate="yes" xml:space="preserve">
          <source>ISO/IEC 9899:1999. &amp;ldquo;Programming languages &amp;ndash; C.&amp;rdquo; A public draft of this standard is available at &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt;.</source>
          <target state="translated">ISO / IEC 9899 : 1999. &amp;ldquo;프로그래밍 언어 &amp;ndash; C&amp;rdquo; 이 표준의 공개 초안은 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&quot;&gt;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1256.pdf&lt;/a&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4908b12c142b7bd671d43e5185556c158bb0999c" translate="yes" xml:space="preserve">
          <source>Icelandic</source>
          <target state="translated">Icelandic</target>
        </trans-unit>
        <trans-unit id="acd1e6f9426d838c20ce10c0d69c37b84f105784" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; except that &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; also attempts to preserve file metadata.</source>
          <target state="translated">동일 &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 하는 것을 제외 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 또한 파일의 메타 데이터를 보존하려고합니다.</target>
        </trans-unit>
        <trans-unit id="3b67836a7558b5c8eb65d018d9c3da891c5dbd61" translate="yes" xml:space="preserve">
          <source>Identical to &lt;a href=&quot;#time.CLOCK_MONOTONIC&quot;&gt;&lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt;&lt;/a&gt;, except it also includes any time that the system is suspended.</source>
          <target state="translated">와 동일 &lt;a href=&quot;#time.CLOCK_MONOTONIC&quot;&gt; &lt;code&gt;CLOCK_MONOTONIC&lt;/code&gt; &lt;/a&gt; , 또한 시스템이 일시 중단되는 모든 시간을 포함 예외입니다.</target>
        </trans-unit>
        <trans-unit id="82e2063541c7fa099ab5e5a901852b54a66c49b9" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#decimal.Decimal.to_integral_value&quot;&gt;&lt;code&gt;to_integral_value()&lt;/code&gt;&lt;/a&gt; method. The &lt;code&gt;to_integral&lt;/code&gt; name has been kept for compatibility with older versions.</source>
          <target state="translated">&lt;a href=&quot;#decimal.Decimal.to_integral_value&quot;&gt; &lt;code&gt;to_integral_value()&lt;/code&gt; &lt;/a&gt; 메소드와 동일합니다 . &lt;code&gt;to_integral&lt;/code&gt; 이름은 이전 버전과의 호환성을 위해 유지되었습니다.</target>
        </trans-unit>
        <trans-unit id="46f3fa216b3c32403a41514a86cd404ca3c83cb5" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용 하는 &lt;a href=&quot;#re.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="a45d4848c68ab0522b00bbc2c7242ac143f0b900" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.sub&quot;&gt;&lt;code&gt;sub()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용 하는 &lt;a href=&quot;#re.sub&quot;&gt; &lt;code&gt;sub()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c6bfdcc3ee2262d164aa72a90a32911e18ec94a5" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#re.subn&quot;&gt;&lt;code&gt;subn()&lt;/code&gt;&lt;/a&gt; function, using the compiled pattern.</source>
          <target state="translated">컴파일 된 패턴을 사용하여 &lt;a href=&quot;#re.subn&quot;&gt; &lt;code&gt;subn()&lt;/code&gt; &lt;/a&gt; 함수와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c2f8627bc91378e78cf995740ad3e1715d475219" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.iter_unpack&quot;&gt;&lt;code&gt;iter_unpack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes must be a multiple of &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용 하는 &lt;a href=&quot;#struct.iter_unpack&quot;&gt; &lt;code&gt;iter_unpack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 바이트 단위의 버퍼 크기는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 의 배수 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d21eeb3027709bab3da92975257519368ad08d9e" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.pack&quot;&gt;&lt;code&gt;pack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. (&lt;code&gt;len(result)&lt;/code&gt; will equal &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.pack&quot;&gt; &lt;code&gt;pack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. ( &lt;code&gt;len(result)&lt;/code&gt; 는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; 와&lt;/a&gt; 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="c3375660e2fad4e52469c1195b329fc8e41df84c" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.pack_into&quot;&gt;&lt;code&gt;pack_into()&lt;/code&gt;&lt;/a&gt; function, using the compiled format.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.pack_into&quot;&gt; &lt;code&gt;pack_into()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="0d39ae1b34f63264f0cee42f0a4d4a1a122e5077" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.unpack&quot;&gt;&lt;code&gt;unpack()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes must equal &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.unpack&quot;&gt; &lt;code&gt;unpack()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 바이트 단위의 버퍼 크기는 size와 같아야 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fe688fb8f7fbdc7bcfef76db53d21a9a791cad" translate="yes" xml:space="preserve">
          <source>Identical to the &lt;a href=&quot;#struct.unpack_from&quot;&gt;&lt;code&gt;unpack_from()&lt;/code&gt;&lt;/a&gt; function, using the compiled format. The buffer&amp;rsquo;s size in bytes, starting at position &lt;em&gt;offset&lt;/em&gt;, must be at least &lt;a href=&quot;#struct.Struct.size&quot;&gt;&lt;code&gt;size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컴파일 된 형식을 사용하여 &lt;a href=&quot;#struct.unpack_from&quot;&gt; &lt;code&gt;unpack_from()&lt;/code&gt; &lt;/a&gt; 함수와 동일 합니다. 위치 &lt;em&gt;offset&lt;/em&gt; 에서 시작하는 버퍼 크기 (바이트 )는 &lt;a href=&quot;#struct.Struct.size&quot;&gt; &lt;code&gt;size&lt;/code&gt; &lt;/a&gt; 이상이어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="01924aa1a07ec0c16adf4b5d09634cea505a484d" translate="yes" xml:space="preserve">
          <source>Identifier of the device on which this file resides.</source>
          <target state="translated">이 파일이 상주하는 장치의 식별자.</target>
        </trans-unit>
        <trans-unit id="7c1a745105ff9b6c357cf50bdd91090ffef6ae55" translate="yes" xml:space="preserve">
          <source>Identifier removed</source>
          <target state="translated">식별자 제거</target>
        </trans-unit>
        <trans-unit id="1e75596418519eaa6fe966ace8634031be7fdfca" translate="yes" xml:space="preserve">
          <source>Identify the client using a plaintext password. The &lt;em&gt;password&lt;/em&gt; will be quoted.</source>
          <target state="translated">일반 텍스트 비밀번호를 사용하여 클라이언트를 식별하십시오. &lt;em&gt;암호가&lt;/em&gt; 인용 될 것이다.</target>
        </trans-unit>
        <trans-unit id="20298f2cb970734bced6da962363cfab14944346" translate="yes" xml:space="preserve">
          <source>Identify yourself to an ESMTP server using &lt;code&gt;EHLO&lt;/code&gt;. The hostname argument defaults to the fully qualified domain name of the local host. Examine the response for ESMTP option and store them for use by &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt;&lt;code&gt;has_extn()&lt;/code&gt;&lt;/a&gt;. Also sets several informational attributes: the message returned by the server is stored as the &lt;code&gt;ehlo_resp&lt;/code&gt; attribute, &lt;code&gt;does_esmtp&lt;/code&gt; is set to true or false depending on whether the server supports ESMTP, and &lt;code&gt;esmtp_features&lt;/code&gt; will be a dictionary containing the names of the SMTP service extensions this server supports, and their parameters (if any).</source>
          <target state="translated">&lt;code&gt;EHLO&lt;/code&gt; 를 사용하여 ESMTP 서버에 자신을 식별하십시오 . hostname 인수의 기본값은 로컬 호스트의 완전한 도메인 이름입니다. ESMTP 옵션에 대한 응답을 검사하고 &lt;a href=&quot;#smtplib.SMTP.has_extn&quot;&gt; &lt;code&gt;has_extn()&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 있도록 저장하십시오 . 또한 몇 가지 정보 속성을 설정합니다. 서버가 반환 한 메시지는 &lt;code&gt;ehlo_resp&lt;/code&gt; 속성 으로 저장되고 &lt;code&gt;does_esmtp&lt;/code&gt; 는 서버가 ESMTP를 지원하는지에 따라 true 또는 false로 설정되며 &lt;code&gt;esmtp_features&lt;/code&gt; 는이 서버의 SMTP 서비스 확장명을 포함하는 사전이됩니다. 지원 및 해당 매개 변수 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="1a6cc0c49eff29b1de2a0094d71e3e849917c5a5" translate="yes" xml:space="preserve">
          <source>Identify yourself to the SMTP server using &lt;code&gt;HELO&lt;/code&gt;. The hostname argument defaults to the fully qualified domain name of the local host. The message returned by the server is stored as the &lt;code&gt;helo_resp&lt;/code&gt; attribute of the object.</source>
          <target state="translated">&lt;code&gt;HELO&lt;/code&gt; 를 사용하여 SMTP 서버에 자신을 식별하십시오 . hostname 인수의 기본값은 로컬 호스트의 완전한 도메인 이름입니다. 서버가 리턴 한 메시지 는 오브젝트 의 &lt;code&gt;helo_resp&lt;/code&gt; 속성으로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e5a975b6add84fd53e3710a9ceac15eb06663b7" translate="yes" xml:space="preserve">
          <source>Identity</source>
          <target state="translated">Identity</target>
        </trans-unit>
        <trans-unit id="bf6a9618acf9bc1e72899605a417801bb69aeed6" translate="yes" xml:space="preserve">
          <source>Idle defaults to black on white text, but colors text with special meanings. For the shell, these are shell output, shell error, user output, and user error. For Python code, at the shell prompt or in an editor, these are keywords, builtin class and function names, names following &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;def&lt;/code&gt;, strings, and comments. For any text window, these are the cursor (when present), found text (when possible), and selected text.</source>
          <target state="translated">유휴는 흰색 텍스트에서 기본적으로 검은 색이지만 특수한 의미로 텍스트를 채색합니다. 쉘의 경우 쉘 출력, 쉘 오류, 사용자 출력 및 사용자 오류입니다. Python 코드의 경우 쉘 프롬프트 또는 편집기에서 키워드, 내장 클래스 및 함수 이름, &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;def&lt;/code&gt; 다음에 오는 이름 , 문자열 및 주석입니다. 모든 텍스트 창에서 커서 (있는 경우), 찾은 텍스트 (가능한 경우) 및 선택한 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="4dbc654d77cb8c9c5dc993be159da8b61b1ecd5b" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;from&amp;rdquo; is used as the value of &lt;em&gt;etype&lt;/em&gt;, &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt;&lt;code&gt;element_create()&lt;/code&gt;&lt;/a&gt; will clone an existing element. &lt;em&gt;args&lt;/em&gt; is expected to contain a themename, from which the element will be cloned, and optionally an element to clone from. If this element to clone from is not specified, an empty element will be used. &lt;em&gt;kw&lt;/em&gt; is discarded.</source>
          <target state="translated">&quot;from&quot;이 &lt;em&gt;etype&lt;/em&gt; 값으로 사용 되면 &lt;a href=&quot;#tkinter.ttk.Style.element_create&quot;&gt; &lt;code&gt;element_create()&lt;/code&gt; &lt;/a&gt; 는 기존 요소를 복제합니다. &lt;em&gt;args&lt;/em&gt; 는 요소가 복제 될 테마 이름과 선택적으로 복제 할 요소를 포함해야합니다. 복제 할이 요소를 지정하지 않으면 빈 요소가 사용됩니다. &lt;em&gt;kw&lt;/em&gt; 는 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="f944010bcb8e6d344f99a27fdf59f6cb446f5d23" translate="yes" xml:space="preserve">
          <source>If &amp;ldquo;image&amp;rdquo; is used, &lt;em&gt;args&lt;/em&gt; should contain the default image name followed by statespec/value pairs (this is the imagespec), and &lt;em&gt;kw&lt;/em&gt; may have the following options:</source>
          <target state="translated">&quot;image&quot;를 사용하는 경우 &lt;em&gt;args&lt;/em&gt; 는 기본 이미지 이름 뒤에 statespec / value 쌍 (imagespec)을 포함해야하며 &lt;em&gt;kw&lt;/em&gt; 는 다음 옵션을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14802572f6d100ba7a53b320def8eef6093842e7" translate="yes" xml:space="preserve">
          <source>If 0 bytes are returned, and &lt;em&gt;size&lt;/em&gt; was not 0, this indicates end of file. If the object is in non-blocking mode and no bytes are available, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">0 바이트가 리턴되고 &lt;em&gt;크기&lt;/em&gt; 가 0이 아닌 경우 파일의 끝을 나타냅니다. 객체가 비 블로킹 모드에 있고 사용 가능한 바이트가 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="03ee5cecdbc6fb98434a921a66e38d3fc5541ed7" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#ast.NodeTransformer&quot;&gt;&lt;code&gt;NodeTransformer&lt;/code&gt;&lt;/a&gt; introduces new nodes (that weren&amp;rsquo;t part of original tree) without giving them location information (such as &lt;code&gt;lineno&lt;/code&gt;), &lt;a href=&quot;#ast.fix_missing_locations&quot;&gt;&lt;code&gt;fix_missing_locations()&lt;/code&gt;&lt;/a&gt; should be called with the new sub-tree to recalculate the location information:</source>
          <target state="translated">경우 &lt;a href=&quot;#ast.NodeTransformer&quot;&gt; &lt;code&gt;NodeTransformer&lt;/code&gt; 은&lt;/a&gt; 그 위치 정보 (예 : 포기하지 않고 새로운 노드를 (원래 나무의 일부가 아닌 그) 소개 &lt;code&gt;lineno&lt;/code&gt; ), &lt;a href=&quot;#ast.fix_missing_locations&quot;&gt; &lt;code&gt;fix_missing_locations()&lt;/code&gt; &lt;/a&gt; 위치 정보를 계산하기 위해 새 하위 트리를 호출해야합니다 :</target>
        </trans-unit>
        <trans-unit id="c02c4acde96b174846ba50faba8ca5546f01adef" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#asyncio.loop.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; is called before &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; is called, the loop will poll the I/O selector once with a timeout of zero, run all callbacks scheduled in response to I/O events (and those that were already scheduled), and then exit.</source>
          <target state="translated">경우 &lt;a href=&quot;#asyncio.loop.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 전에 호출된다 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 라고, 루프가 I에 대한 응답으로 예정된 모든 콜백을 실행, 0의 타임 아웃 번 I / O 선택을 폴링 / O 이벤트 (이미 계획 한 것), 그리고 그런 다음 종료하십시오.</target>
        </trans-unit>
        <trans-unit id="05e8eca43c8b5bd5bc36cb778852fb6cfcbe90e4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#asyncio.loop.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; is called while &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; is running, the loop will run the current batch of callbacks and then exit. Note that new callbacks scheduled by callbacks will not run in this case; instead, they will run the next time &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;run_forever()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#asyncio.loop.run_until_complete&quot;&gt;&lt;code&gt;run_until_complete()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">경우 &lt;a href=&quot;#asyncio.loop.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 동안이라고 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 실행되고, 루프는 현재 콜백 배치 한 후 종료를 실행합니다. 이 경우 콜백으로 예약 된 새 콜백은 실행되지 않습니다. 대신 다음에 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;run_forever()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#asyncio.loop.run_until_complete&quot;&gt; &lt;code&gt;run_until_complete()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="d04305c691531cc120abb78c9b6420c339ccd744" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt;&lt;code&gt;-n&lt;/code&gt;&lt;/a&gt; is not given, a suitable number of loops is calculated by trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, &amp;hellip; until the total time is at least 0.2 seconds.</source>
          <target state="translated">경우 &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt; &lt;code&gt;-n&lt;/code&gt; 가&lt;/a&gt; 부여되지 않고, 루프의 적절한 개수의 총 시간은 적어도 0.2 초까지 ... 서열 1, 2, 5, 10, 20, 50에서 점점 더 많은 노력에 의해 계산된다.</target>
        </trans-unit>
        <trans-unit id="d1678f57ce6088308b33179279e335b67a5b9075" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt;&lt;code&gt;-n&lt;/code&gt;&lt;/a&gt; is not given, a suitable number of loops is calculated by trying successive powers of 10 until the total time is at least 0.2 seconds.</source>
          <target state="translated">경우 &lt;a href=&quot;#cmdoption-timeit-n&quot;&gt; &lt;code&gt;-n&lt;/code&gt; 이&lt;/a&gt; 주어지지 루프의 적절한 수는 총 시간은 적어도 0.2 초까지 (10)의 연속적인 힘을 시도하여 계산된다.</target>
        </trans-unit>
        <trans-unit id="582ba31da26c45d3b235552a7d51ae121320d8b0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; is not &lt;code&gt;None&lt;/code&gt;, it is called without arguments to provide a default value for the given &lt;em&gt;key&lt;/em&gt;, this value is inserted in the dictionary for the &lt;em&gt;key&lt;/em&gt;, and returned.</source>
          <target state="translated">&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 주어진 &lt;em&gt;키에&lt;/em&gt; 대한 기본값을 제공하기 위해 인수없이 호출되며 ,이 값은 &lt;em&gt;키&lt;/em&gt; 의 사전에 삽입되어 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9cde1ada951bb0301fa7df4ab6c0c9e7ef70a81d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; is used just as a simple decorator with no parameters, it acts as if it has the default values documented in this signature. That is, these three uses of &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; are equivalent:</source>
          <target state="translated">경우 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 바로 매개 변수없이 간단한 장식으로 사용, 그것은이 서명에 설명 된 기본 값이있는 경우 역할을합니다. 즉, 다음 세 가지 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="06790524e2c9624dd66bf4e80174a491c71a47d3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance &lt;em&gt;d&lt;/em&gt; is naive, this is the same as &lt;code&gt;d.timetuple()&lt;/code&gt; except that &lt;code&gt;tm_isdst&lt;/code&gt; is forced to 0 regardless of what &lt;code&gt;d.dst()&lt;/code&gt; returns. DST is never in effect for a UTC time.</source>
          <target state="translated">&lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 &lt;em&gt;d&lt;/em&gt; 가 순진한 경우 &lt;code&gt;d.dst()&lt;/code&gt; 반환 하는 내용에 관계없이 &lt;code&gt;tm_isdst&lt;/code&gt; 가 0으로 설정 된다는 점을 제외하면 &lt;code&gt;d.timetuple()&lt;/code&gt; 과 같습니다 . DST는 UTC 시간 동안 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7e0c40c35052a5f701990cfae358459eb5e545e6" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.dst(self)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.dst(self)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="f8caa4545a15722244f6b65e83c6c19542a6ab44" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.tzname(self)&lt;/code&gt;, raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a string object,</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 이&lt;/a&gt; 있다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.tzname(self)&lt;/code&gt; 후자는 반환하지 않는 경우, 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 문자열 객체를,</target>
        </trans-unit>
        <trans-unit id="009d47938690bf44a446761016995961a2f2f6ff" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.utcoffset(self)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.utcoffset(self)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="aa3f64ecaf560bd1451a3c877d9f543b04fcbe06" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, a string is appended, giving the UTC offset:</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 문자열은 UTC 오프셋을주는 추가됩니다 :</target>
        </trans-unit>
        <trans-unit id="e7fddffca5059ab1879694ef1968947dba191d2e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.dst(None)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt;, or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.dst(None)&lt;/code&gt; , 후자는 반환하지 않습니다 경우 예외 제기 &lt;code&gt;None&lt;/code&gt; , 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 작은 일일 이상의 크기를 가진 개체를.</target>
        </trans-unit>
        <trans-unit id="f9853982dbae22fa9c2c2cdec0356caa1586b4dd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.tzname(None)&lt;/code&gt;, or raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a string object.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 가&lt;/a&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.tzname(None)&lt;/code&gt; , 또는 예외가 발생 후자는 반환하지 않습니다 경우 &lt;code&gt;None&lt;/code&gt; 또는 문자열 개체를.</target>
        </trans-unit>
        <trans-unit id="01eb5a0fb7bdeeed7668f56b440e9918155d69bd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, returns &lt;code&gt;None&lt;/code&gt;, else returns &lt;code&gt;self.tzinfo.utcoffset(None)&lt;/code&gt;, and raises an exception if the latter doesn&amp;rsquo;t return &lt;code&gt;None&lt;/code&gt; or a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object with magnitude less than one day.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 는&lt;/a&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 반환 &lt;code&gt;None&lt;/code&gt; , 다른 반환 &lt;code&gt;self.tzinfo.utcoffset(None)&lt;/code&gt; , 후자는 반환하지 않을 경우 예외가 발생 &lt;code&gt;None&lt;/code&gt; 또는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 일일보다 작은 크기로 개체를.</target>
        </trans-unit>
        <trans-unit id="bf4cf586488675e2ebba410a57aa3e353d6385cd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; should not return &lt;code&gt;None&lt;/code&gt; either.</source>
          <target state="translated">경우 &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 반환하지 안 &lt;code&gt;None&lt;/code&gt; 하나를.</target>
        </trans-unit>
        <trans-unit id="9011595808dcf4d293ad800bfc6c37bf4507550c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#decimal.setcontext&quot;&gt;&lt;code&gt;setcontext()&lt;/code&gt;&lt;/a&gt; has not been called before &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; will automatically create a new context for use in the current thread.</source>
          <target state="translated">경우 &lt;a href=&quot;#decimal.setcontext&quot;&gt; &lt;code&gt;setcontext()&lt;/code&gt; &lt;/a&gt; 전에 호출되지 않은 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; , 다음 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 자동으로 현재 스레드에서 사용하기위한 새로운 컨텍스트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="21415457c1d139549ef89f97140496dfdfab045c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt;, non-ASCII binary data is converted back into bytes. Headers with binary data are not refolded, regardless of the &lt;code&gt;refold_header&lt;/code&gt; setting, since there is no way to know whether the binary data consists of single byte characters or multibyte characters.</source>
          <target state="translated">경우 &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; 아닌 ASCII 이진 데이터를 바이트로 변환 돌아왔다. 이진 데이터가 단일 바이트 문자인지 멀티 바이트 문자로 구성되어 있는지 알 수있는 방법이 없기 때문에 &lt;code&gt;refold_header&lt;/code&gt; 설정에 관계없이 이진 데이터가있는 헤더는 다시 접히지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4c20a0126fb2339f46306a2ced37ad168e88f98" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#gc.DEBUG_SAVEALL&quot;&gt;&lt;code&gt;DEBUG_SAVEALL&lt;/code&gt;&lt;/a&gt; is set, then all unreachable objects will be added to this list rather than freed.</source>
          <target state="translated">경우 &lt;a href=&quot;#gc.DEBUG_SAVEALL&quot;&gt; &lt;code&gt;DEBUG_SAVEALL&lt;/code&gt; 이&lt;/a&gt; 설정되어, 모든 도달 할 수없는 개체가이 목록에 추가보다는 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="5b0b664a2e9905229df91a5d790cbb723cbe0e9d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt;&lt;code&gt;domain_return_ok()&lt;/code&gt;&lt;/a&gt; returns true for the cookie domain, &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; is called for the cookie path. Otherwise, &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; are never called for that cookie domain. If &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt; returns true, &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; is called with the &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; object itself for a full check. Otherwise, &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt; is never called for that cookie path.</source>
          <target state="translated">경우 &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt; &lt;code&gt;domain_return_ok()&lt;/code&gt; &lt;/a&gt; 쿠키 도메인에 대해 true를 반환 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 쿠키 경로라고합니다. 그렇지 않으면 해당 쿠키 도메인에 대해 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다. 경우 &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; true를 반환 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 불려 &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 전체 검사에 대한 개체 자체. 그렇지 않으면 해당 쿠키 경로에 대해 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f9948b67acbf113dce0d3f91e1cc50fba431b125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;spec.loader.create_module&lt;/code&gt;&lt;/a&gt; does not return &lt;code&gt;None&lt;/code&gt;, then any pre-existing attributes will not be reset. Also, no &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; will be raised if triggered while accessing &lt;strong&gt;spec&lt;/strong&gt; or setting an attribute on the module.</source>
          <target state="translated">경우 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;spec.loader.create_module&lt;/code&gt; 는&lt;/a&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그 다음 어떤 사전 기존의 속성이 초기화되지 않습니다. 또한 &lt;strong&gt;스펙에&lt;/strong&gt; 액세스 하거나 모듈에서 속성을 설정하는 동안 트리거되면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생 하지 않습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d25bfcae1ced7878a90923a3bbc911ce54352476" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.MetaPathFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; is defined, backwards-compatible functionality is provided.</source>
          <target state="translated">경우 &lt;a href=&quot;#importlib.abc.MetaPathFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 정의되어, 이전 버전과 호환 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f015a253da746e1e2dd5daec6dd710fa4d38756c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#importlib.abc.PathEntryFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; is defined then backwards-compatible functionality is provided.</source>
          <target state="translated">&lt;a href=&quot;#importlib.abc.PathEntryFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 이 정의 되면 이전 버전과 호환되는 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9b326804ec799be875e38c1a2930a4c25cd8cef4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#memoryview.format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt; is one of the native format specifiers from the &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module, indexing with an integer or a tuple of integers is also supported and returns a single &lt;em&gt;element&lt;/em&gt; with the correct type. One-dimensional memoryviews can be indexed with an integer or a one-integer tuple. Multi-dimensional memoryviews can be indexed with tuples of exactly &lt;em&gt;ndim&lt;/em&gt; integers where &lt;em&gt;ndim&lt;/em&gt; is the number of dimensions. Zero-dimensional memoryviews can be indexed with the empty tuple.</source>
          <target state="translated">경우 &lt;a href=&quot;#memoryview.format&quot;&gt; &lt;code&gt;format&lt;/code&gt; &lt;/a&gt; 로부터 기본 형식 지정자 중 하나 인 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 도 지원됩니다 정수 또는 정수의 튜플로 색인 모듈, 단일 반환 &lt;em&gt;요소&lt;/em&gt; 올바른 유형을. 1 차원 메모 리뷰는 정수 또는 1 정수 터플을 사용하여 인덱스 할 수 있습니다. 다차원 메모 리뷰는 정확히 &lt;em&gt;ndim&lt;/em&gt; 정수의 튜플을 사용하여 인덱스 할 수 있습니다. 여기서 &lt;em&gt;ndim&lt;/em&gt; 은 차원의 수입니다. 빈 튜플을 사용하여 0 차원 메모리 뷰를 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e778bfa133d88df69f23727150ca404e8c30f386" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#object.__getstate__&quot;&gt;&lt;code&gt;__getstate__()&lt;/code&gt;&lt;/a&gt; returns a false value, the &lt;a href=&quot;#object.__setstate__&quot;&gt;&lt;code&gt;__setstate__()&lt;/code&gt;&lt;/a&gt; method will not be called upon unpickling.</source>
          <target state="translated">경우 &lt;a href=&quot;#object.__getstate__&quot;&gt; &lt;code&gt;__getstate__()&lt;/code&gt; &lt;/a&gt; false 값을 반환의 &lt;a href=&quot;#object.__setstate__&quot;&gt; &lt;code&gt;__setstate__()&lt;/code&gt; &lt;/a&gt; 메소드는 unpickling에 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a3e787ee0d7f7e8be6223781b46958dd72b0562d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; is not provided, a modified copy of this mapping may be passed to the appropriate process-creation functions to cause child processes to use a modified environment.</source>
          <target state="translated">경우 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 제공되지 않고,이 맵핑의 수정 된 사본은 자식 프로세스는 수정 된 환경을 사용하게 할 수있는 적절한 프로세스 생성 함수에 전달 될 수있다.</target>
        </trans-unit>
        <trans-unit id="475a717000de0e2b757369a1ff16dc88df2752ce" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;obj&lt;/em&gt; is pickled as usual. Any other value causes &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; to emit the returned value as a persistent ID for &lt;em&gt;obj&lt;/em&gt;. The meaning of this persistent ID should be defined by &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;Unpickler.persistent_load()&lt;/code&gt;&lt;/a&gt;. Note that the value returned by &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; cannot itself have a persistent ID.</source>
          <target state="translated">경우 &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 를 반환 &lt;code&gt;None&lt;/code&gt; , &lt;em&gt;OBJ는&lt;/em&gt; 평소와 같이 절인된다. 다른 값을 사용하면 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 가 반환 된 값을 &lt;em&gt;obj&lt;/em&gt; 의 영구 ID로 내 &lt;em&gt;보냅니다&lt;/em&gt; . 이 영구 ID의 의미는 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;Unpickler.persistent_load()&lt;/code&gt; &lt;/a&gt; 의해 정의되어야합니다 . &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 값 자체는 지속적 ID를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6eb3f096073e3576908ab443228929f5d208920" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, any character not declared to be a word character, whitespace, or a quote will be returned as a single-character token. If it is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; will only split words in whitespaces;</source>
          <target state="translated">경우 &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 모든 문자는 단어 문자, 공백 선언, 또는 따옴표는 단일 문자 토큰으로 반환하지 않습니다. 이 경우 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 공백 만 분할 말 것이다;</target>
        </trans-unit>
        <trans-unit id="18eeb508085769b9d25fd4a01e99172032cc7b0e" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt;&lt;code&gt;getdefaulttimeout()&lt;/code&gt;&lt;/a&gt; is not &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, sockets returned by the &lt;a href=&quot;#socket.socket.accept&quot;&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/a&gt; method inherit that timeout. Otherwise, the behaviour depends on settings of the listening socket:</source>
          <target state="translated">경우 &lt;a href=&quot;#socket.getdefaulttimeout&quot;&gt; &lt;code&gt;getdefaulttimeout()&lt;/code&gt; &lt;/a&gt; 되지 않습니다 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 소켓에 의해 반환 &lt;a href=&quot;#socket.socket.accept&quot;&gt; &lt;code&gt;accept()&lt;/code&gt; &lt;/a&gt; 메서드 상속 제한 시간이. 그렇지 않으면 동작은 청취 소켓의 설정에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1595b340863f62eada1ad0f3d8d078a3995d33d4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.CompletedProcess.returncode&quot;&gt;&lt;code&gt;returncode&lt;/code&gt;&lt;/a&gt; is non-zero, raise a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.CompletedProcess.returncode&quot;&gt; &lt;code&gt;returncode&lt;/code&gt; &lt;/a&gt; 가 0이 아닌 경우 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9911da4fc9a0f7d03f013c47079f09932dd87298" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESHOWWINDOW&quot;&gt;&lt;code&gt;STARTF_USESHOWWINDOW&lt;/code&gt;&lt;/a&gt;, this attribute can be any of the values that can be specified in the &lt;code&gt;nCmdShow&lt;/code&gt; parameter for the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms633548(v=vs.85).aspx&quot;&gt;ShowWindow&lt;/a&gt; function, except for &lt;code&gt;SW_SHOWDEFAULT&lt;/code&gt;. Otherwise, this attribute is ignored.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESHOWWINDOW&quot;&gt; &lt;code&gt;STARTF_USESHOWWINDOW&lt;/code&gt; &lt;/a&gt; 이 속성이 지정 될 수있는 값 중 하나 일 수 &lt;code&gt;nCmdShow&lt;/code&gt; 의 위한 매개 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms633548(v=vs.85).aspx&quot;&gt;이 ShowWindow를&lt;/a&gt; 제외한 기능 &lt;code&gt;SW_SHOWDEFAULT&lt;/code&gt; 를 . 그렇지 않으면이 속성이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17afb4874f7b74c33ba1f0a22fdede7fd8bbd2cb" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard error handle for the process. Otherwise, this attribute is ignored and the default for standard error is the console window&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 오류 핸들입니다. 그렇지 않으면이 속성은 무시되고 표준 오류의 기본값은 콘솔 창의 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="8fb5e8f987ab98575e4a5bf2c5bf6153ecdee636" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard input handle for the process. If &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt; is not specified, the default for standard input is the keyboard buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 입력 핸들입니다. 경우 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; 가&lt;/a&gt; 지정되지 않은, 표준 입력의 기본은 키보드 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="2459b411dc5f72300ea61c717f86aac25d4f6c97" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt;&lt;code&gt;dwFlags&lt;/code&gt;&lt;/a&gt; specifies &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt;&lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt;&lt;/a&gt;, this attribute is the standard output handle for the process. Otherwise, this attribute is ignored and the default for standard output is the console window&amp;rsquo;s buffer.</source>
          <target state="translated">경우 &lt;a href=&quot;#subprocess.STARTUPINFO.dwFlags&quot;&gt; &lt;code&gt;dwFlags&lt;/code&gt; &lt;/a&gt; 지정 &lt;a href=&quot;#subprocess.STARTF_USESTDHANDLES&quot;&gt; &lt;code&gt;STARTF_USESTDHANDLES&lt;/code&gt; &lt;/a&gt; ,이 속성은 프로세스의 표준 출력 핸들입니다. 그렇지 않으면이 속성이 무시되고 표준 출력의 기본값은 콘솔 창의 버퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0a30adf3ca5293f47c1189f27a38687cc18999e3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; has not been called prior to the call to &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;openlog()&lt;/code&gt; will be called with no arguments.</source>
          <target state="translated">경우 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 이전에 호출에 호출되지 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;openlog()&lt;/code&gt; 인수없이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fa24a5d03ba78592ea146659696b16ffe43b9a77" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt;&lt;code&gt;expand_tabs&lt;/code&gt;&lt;/a&gt; is false and &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt;&lt;code&gt;replace_whitespace&lt;/code&gt;&lt;/a&gt; is true, each tab character will be replaced by a single space, which is &lt;em&gt;not&lt;/em&gt; the same as tab expansion.</source>
          <target state="translated">경우 &lt;a href=&quot;#textwrap.TextWrapper.expand_tabs&quot;&gt; &lt;code&gt;expand_tabs&lt;/code&gt; 가&lt;/a&gt; 거짓이고 &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt; &lt;code&gt;replace_whitespace&lt;/code&gt; 는&lt;/a&gt; 사실, 각 탭 문자는 하나의 공간으로 대체 될 것이다 &lt;em&gt;되지&lt;/em&gt; 탭 확장과 같은.</target>
        </trans-unit>
        <trans-unit id="401fb6d910d793ac1a606938fd5c1e335d50c524" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt;&lt;code&gt;replace_whitespace&lt;/code&gt;&lt;/a&gt; is false, newlines may appear in the middle of a line and cause strange output. For this reason, text should be split into paragraphs (using &lt;a href=&quot;stdtypes#str.splitlines&quot;&gt;&lt;code&gt;str.splitlines()&lt;/code&gt;&lt;/a&gt; or similar) which are wrapped separately.</source>
          <target state="translated">경우 &lt;a href=&quot;#textwrap.TextWrapper.replace_whitespace&quot;&gt; &lt;code&gt;replace_whitespace&lt;/code&gt; 은&lt;/a&gt; 거짓, 뉴 라인은 라인의 중간에 나타나는 이상한 출력의 원인이 될 수 있습니다. 이러한 이유로 텍스트는 단락으로 분리되어야하며 ( &lt;a href=&quot;stdtypes#str.splitlines&quot;&gt; &lt;code&gt;str.splitlines()&lt;/code&gt; &lt;/a&gt; 또는 이와 유사한 방법을 사용하여 ) 별도로 감싸 야합니다.</target>
        </trans-unit>
        <trans-unit id="5440dd0e7910d37a11dd3863c46d6c4daaf6a686" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; fails, meaning that &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 즉, 실패 &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt; 호출되어 있지 않은 경우, 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="11e9aa6a0b626486b9748ffe7b0fd4868dfa4de3" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; succeeded, &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; will be run whether the test method succeeded or not.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 성공 &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt; 시험 방법의 성공 여부에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2f754fa973712c4da8b8b5a253b88e6d78c5436a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.TestCase.setUpClass&quot;&gt;&lt;code&gt;setUpClass()&lt;/code&gt;&lt;/a&gt; fails, meaning that &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt;&lt;code&gt;tearDownClass()&lt;/code&gt;&lt;/a&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.TestCase.setUpClass&quot;&gt; &lt;code&gt;setUpClass()&lt;/code&gt; &lt;/a&gt; 의미 실패 &lt;a href=&quot;#unittest.TestCase.tearDownClass&quot;&gt; &lt;code&gt;tearDownClass()&lt;/code&gt; &lt;/a&gt; 호출되어 있지 않은 경우, 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a56b554a11ada97428e4f6b7fc43139d2ce66dfd" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; is set then it will be called after the call has been recorded, so if &lt;code&gt;side_effect&lt;/code&gt; raises an exception the call is still recorded.</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; 가&lt;/a&gt; 다음 설정되어 통화가 기록 된 후에는 그렇다면, 호출 될 &lt;code&gt;side_effect&lt;/code&gt; 는 통화가 여전히 기록되는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0daae280f7ddf940c3563e2d3ab6d3e152cdba08" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt;&lt;code&gt;patch.multiple()&lt;/code&gt;&lt;/a&gt; is used as a context manager, the value returned by the context manager is a dictionary where created mocks are keyed by name:</source>
          <target state="translated">경우 &lt;a href=&quot;#unittest.mock.patch.multiple&quot;&gt; &lt;code&gt;patch.multiple()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자로서 사용되는, 콘텍스트 관리자에 의해 반환 된 값이 생성 모의 객체 이름 키잉되는 사전이다 :</target>
        </trans-unit>
        <trans-unit id="7ea197c7086cd8e399adabc6fac58ed3712540b4" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt;&lt;code&gt;origin_server&lt;/code&gt;&lt;/a&gt; is true, this string attribute is used to set the HTTP version of the response set to the client. It defaults to &lt;code&gt;&quot;1.0&quot;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt; &lt;code&gt;origin_server&lt;/code&gt; 는&lt;/a&gt; 사실이 문자열 속성은 클라이언트로 설정 응답의 HTTP 버전을 설정하는 데 사용됩니다. 기본값은 &lt;code&gt;&quot;1.0&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="273da1adde160734ed233b111094a596981762d8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is enabled, the number of bytes stored in the buffer. These bytes represent UTF-8 encoded text. This attribute has no meaningful interpretation when &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is false.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; &lt;/a&gt; 가 사용 가능한 경우 버퍼에 저장된 바이트 수입니다. 이 바이트는 UTF-8로 인코딩 된 텍스트를 나타냅니다. &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; 일&lt;/a&gt; 때이 속성은 의미가 없습니다. 가 false 인 .</target>
        </trans-unit>
        <trans-unit id="5969c407e8a5884e8705a2163a3f42bcc5ab4f5f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, any defects encountered will be raised as errors. If &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; (the default), defects will be passed to the &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt;&lt;code&gt;register_defect()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 발생하는 모든 결함이 오류로 발생합니다. 경우 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; (기본), 결함이 전달됩니다 &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt; &lt;code&gt;register_defect()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="fef1119ed2a7515183a2fa43ee13d86ddee0c639" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, lines starting with &lt;em&gt;&amp;ldquo;From &amp;ldquo;&lt;/em&gt; in the body are escaped by putting a &lt;code&gt;&amp;gt;&lt;/code&gt; in front of them. This parameter is used when the message is being serialized by a generator. Default: &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 본문에서 &lt;em&gt;&quot;From&quot;&lt;/em&gt; 으로 시작하는 행 은 앞에 &lt;code&gt;&amp;gt;&lt;/code&gt; 를 넣어서 이스케이프 합니다. 이 매개 변수는 생성자가 메시지를 직렬화 할 때 사용됩니다. 기본값 : &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3847911e0aa3faa42e57a768e6d9c9134161e5d0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; is not explicit defined, or if it is set to &lt;code&gt;None&lt;/code&gt;, then &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;may&lt;/em&gt; add an implicit &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Although not recommended, you can force &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; to create a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method with &lt;code&gt;unsafe_hash=True&lt;/code&gt;. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.</source>
          <target state="translated">만약 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 명시 적으로 정의되지 않은 경우, 또는로 설정되어있는 경우 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 할 수 있습니다&lt;/em&gt; 암시 추가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메소드를. 권장되지는 않지만, &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;unsafe_hash=True&lt;/code&gt; 로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드 를 만들 도록 할 수 있습니다 . 클래스가 논리적으로 변경 불가능하지만 변경 될 수있는 경우가 이에 해당합니다. 이것은 특수한 사용 사례이므로 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="e04c3d63f8f0b660bf5ea6424df45f9aabfeea2f" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; is defined the value of the enum member will be passed to those methods:</source>
          <target state="translated">경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의 된 열거 부재의 값은 그 방법으로 전달 될 것이다 :</target>
        </trans-unit>
        <trans-unit id="c2fc9783c650081b684b1471be048e00bfcf1c2a" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; is not explicit defined, or if it is set to &lt;code&gt;None&lt;/code&gt;, then &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;may&lt;/em&gt; add an implicit &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Although not recommended, you can force &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; to create a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method with &lt;code&gt;unsafe_hash=True&lt;/code&gt;. This might be the case if your class is logically immutable but can nonetheless be mutated. This is a specialized use case and should be considered carefully.</source>
          <target state="translated">만약 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 명시 적으로 정의되지 않은 경우, 또는로 설정되어있는 경우 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 할 수 있습니다&lt;/em&gt; 암시 추가 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메소드를. 권장되지는 않지만, 당신은 강제 할 수 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 만들 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 와 방법 &lt;code&gt;unsafe_hash=True&lt;/code&gt; . 클래스가 논리적으로 불변이지만 그럼에도 불구하고 변경 될 수있는 경우 일 수 있습니다. 이것은 특수한 사용 사례이며 신중하게 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6e0bf03147eeca5dcbc1a65f0d8dfc48889baf2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; is defined the value of the enum member will be passed to those methods:</source>
          <target state="translated">경우 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의 된 열거 부재의 값은 그 방법으로 전달 될 것이다 :</target>
        </trans-unit>
        <trans-unit id="1a25fcf949e895e543466fc090449ac64a3c56b0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;signal#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; isn&amp;rsquo;t handled by Python (it was set to &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt;&lt;code&gt;signal.SIG_DFL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt;&lt;code&gt;signal.SIG_IGN&lt;/code&gt;&lt;/a&gt;), this function does nothing.</source>
          <target state="translated">&lt;a href=&quot;signal#signal.SIGINT&quot;&gt; &lt;code&gt;signal.SIGINT&lt;/code&gt; &lt;/a&gt; 가 Python에서 처리되지 않는 경우 ( &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt; &lt;code&gt;signal.SIG_DFL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt; &lt;code&gt;signal.SIG_IGN&lt;/code&gt; &lt;/a&gt; 으로 설정 됨 )이 함수는 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a87d22d7e499f0ee61056877808ca82fe9ec45b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data is passed in, the result will also contain only &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data. If &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; data is passed in, the result will contain only &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; data.</source>
          <target state="translated">경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터가 전달되고, 결과는 단지 포함 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; 을&lt;/a&gt; 데이터를. 경우 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 데이터가 전달되고, 결과는 포함 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 의 데이터를.</target>
        </trans-unit>
        <trans-unit id="aed3bfed2c45e20b453e673260527b4602b0fa6c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; is passed in, it is returned unchanged. Otherwise &lt;a href=&quot;#os.PathLike.__fspath__&quot;&gt;&lt;code&gt;__fspath__()&lt;/code&gt;&lt;/a&gt; is called and its value is returned as long as it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. In all other cases, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 전달, 그것은 변화가 반환됩니다. 그렇지 않으면 &lt;a href=&quot;#os.PathLike.__fspath__&quot;&gt; &lt;code&gt;__fspath__()&lt;/code&gt; &lt;/a&gt; 가 호출되고 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 인 경우 해당 값이 반환됩니다 . 다른 모든 경우에는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="caf032867f63b3726a28645ba313d2c3e89d2da5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;-c&lt;/code&gt;, or &lt;code&gt;r&lt;/code&gt; is used, all arguments are placed in &lt;code&gt;sys.argv[1:...]&lt;/code&gt; and &lt;code&gt;sys.argv[0]&lt;/code&gt; is set to &lt;code&gt;''&lt;/code&gt;, &lt;code&gt;'-c'&lt;/code&gt;, or &lt;code&gt;'-r'&lt;/code&gt;. No editor window is opened, even if that is the default set in the Options dialog.</source>
          <target state="translated">경우 &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;-c&lt;/code&gt; , 또는 &lt;code&gt;r&lt;/code&gt; 사용되어, 모든 인수에 배치 &lt;code&gt;sys.argv[1:...]&lt;/code&gt; 및 &lt;code&gt;sys.argv[0]&lt;/code&gt; 으로 설정 &lt;code&gt;''&lt;/code&gt; , &lt;code&gt;'-c'&lt;/code&gt; 또는 &lt;code&gt;'-r'&lt;/code&gt; . 옵션 대화 상자에서 기본값이 설정되어 있어도 편집기 창이 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21627f7daf7e31d0ed2c5b5ad287f10a5bba0e4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; is supplied at the command line, the ArgumentParser help will be printed:</source>
          <target state="translated">경우 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 이 명령 줄에서 공급되면, ArgumentParser 도움이 인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="c7a9c72b700c6c23304dc413d4be9c57f931cd8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; and &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; without sharing any other knowledge, then the appropriate shared operation is the one involving the built in &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, and both &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; s land there, so &lt;code&gt;a+b
== b+a&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; 및 &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; 다른 지식을 공유하지 않고, 다음 해당 공유 작업이이 내장 관련된 하나입니다 &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; , 두 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 이의 땅, 그래서 &lt;code&gt;a+b == b+a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="860d1ded473a39b8214f3cb82ab754be95ed22c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; and &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; without sharing any other knowledge, then the appropriate shared operation is the one involving the built in &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;, and both &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; s land there, so &lt;code&gt;a+b
== b+a&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;A &amp;lt;: Complex&lt;/code&gt; 및 &lt;code&gt;B &amp;lt;: Real&lt;/code&gt; 다른 지식을 공유하지 않고, 다음 해당 공유 작업이이 내장 관련된 하나입니다 &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; , 두 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 이의 땅, 그래서 &lt;code&gt;a+b == b+a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b801947cfd092d953ccf6831d669c267f173f35e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; defines an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; which accepts &lt;code&gt;b&lt;/code&gt;, all is well.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 수용 &lt;code&gt;b&lt;/code&gt; 모두 잘.</target>
        </trans-unit>
        <trans-unit id="a3ba8aa5fe7b9755b92f7e04fab9b569ede2734b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; defines an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; which accepts &lt;code&gt;b&lt;/code&gt;, all is well.</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 는 정의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 수용 &lt;code&gt;b&lt;/code&gt; 모두 잘.</target>
        </trans-unit>
        <trans-unit id="ed23788452e71ff7756d04b76ef0e4ea7b1ec3ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; falls back to the boilerplate code, and it were to return a value from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, we&amp;rsquo;d miss the possibility that &lt;code&gt;B&lt;/code&gt; defines a more intelligent &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt;, so the boilerplate should return &lt;a href=&quot;constants#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;. (Or &lt;code&gt;A&lt;/code&gt; may not implement &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; at all.)</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 다시 상용구 코드에 떨어지면, 그것은에서 값을 반환했다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; , 우리는 가능성 그리워하는 &lt;code&gt;B&lt;/code&gt; 가 더 지능적인 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 상용구가 반환해야하므로, &lt;a href=&quot;constants#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; . 또는 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 를 전혀 구현하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4777237f57dbf633ec241445ffb03cbb24e6301" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A&lt;/code&gt; falls back to the boilerplate code, and it were to return a value from &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, we&amp;rsquo;d miss the possibility that &lt;code&gt;B&lt;/code&gt; defines a more intelligent &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt;, so the boilerplate should return &lt;a href=&quot;constants#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; from &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;. (Or &lt;code&gt;A&lt;/code&gt; may not implement &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt; at all.)</source>
          <target state="translated">경우 &lt;code&gt;A&lt;/code&gt; 가 다시 상용구 코드에 떨어지면, 그것은에서 값을 반환했다 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; , 우리는 가능성 그리워하는 &lt;code&gt;B&lt;/code&gt; 가 더 지능적인 정의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 상용구가 반환해야하므로, &lt;a href=&quot;constants#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; . (또는 &lt;code&gt;A&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 를 전혀 구현하지 않을 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="c99da1870c17ce7d3d3018a203be0bafc8dccfae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;B &amp;lt;: A&lt;/code&gt;, Python tries &lt;code&gt;B.__radd__&lt;/code&gt; before &lt;code&gt;A.__add__&lt;/code&gt;. This is ok, because it was implemented with knowledge of &lt;code&gt;A&lt;/code&gt;, so it can handle those instances before delegating to &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;B &amp;lt;: A&lt;/code&gt; , 파이썬은 시도 &lt;code&gt;B.__radd__&lt;/code&gt; 하기 전에 &lt;code&gt;A.__add__&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt; 에 대한 지식으로 구현 되었으므로 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; 에&lt;/a&gt; 위임하기 전에 해당 인스턴스를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c0b502541a012336c972c1fd26bc2444183bb6c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, follow &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, supporting non-ASCII characters in headers by encoding them as &amp;ldquo;encoded words&amp;rdquo;. If &lt;code&gt;True&lt;/code&gt;, follow &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; and use &lt;code&gt;utf-8&lt;/code&gt; encoding for headers. Messages formatted in this way may be passed to SMTP servers that support the &lt;code&gt;SMTPUTF8&lt;/code&gt; extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 5322에&lt;/strong&gt;&lt;/a&gt; 따라 헤더에서 비 ASCII 문자를&amp;ldquo;인코딩 된 단어&amp;rdquo;로 인코딩하여 지원하십시오. &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 6532를&lt;/strong&gt;&lt;/a&gt; 따르고 헤더에 &lt;code&gt;utf-8&lt;/code&gt; 인코딩을 사용하십시오 . 이러한 방식으로 형식화 된 메시지는 &lt;code&gt;SMTPUTF8&lt;/code&gt; 확장 을 지원하는 SMTP 서버 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; ) 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f0aa57a54bd4c37d36f82fb559a78314f58cdaa4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SMTPUTF8&lt;/code&gt; is included in &lt;em&gt;mail_options&lt;/em&gt;, and the server supports it, &lt;em&gt;from_addr&lt;/em&gt; and &lt;em&gt;to_addrs&lt;/em&gt; may contain non-ASCII characters.</source>
          <target state="translated">경우 &lt;code&gt;SMTPUTF8&lt;/code&gt; 가 포함되어 &lt;em&gt;mail_options&lt;/em&gt; 하고 서버에서 지원, &lt;em&gt;from_addr&lt;/em&gt; 및 &lt;em&gt;to_addrs는&lt;/em&gt; 비 ASCII 문자를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5dc45558ebcea6d610bad35d84ea39326606ff5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TOS&lt;/code&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;generator iterator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; object it is left as is. Otherwise, implements &lt;code&gt;TOS = iter(TOS)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TOS&lt;/code&gt; 는 A는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator-iterator&quot;&gt;발전기 반복자&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 그대로 남아 있습니다. 그렇지 않으면 &lt;code&gt;TOS = iter(TOS)&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="e645f28378b987a0eff4f27f4b513520653577fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TOS&lt;/code&gt; is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator-iterator&quot;&gt;generator iterator&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; object it is left as is. Otherwise, implements &lt;code&gt;TOS = iter(TOS)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;TOS&lt;/code&gt; 는 A는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator-iterator&quot;&gt;발전기 반복자&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 그대로 남아 있습니다. 그렇지 않으면 &lt;code&gt;TOS = iter(TOS)&lt;/code&gt; 구현 합니다.</target>
        </trans-unit>
        <trans-unit id="711424b518e686db6f3128ec091800680cf2d7e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, tokens will only be split in whitespaces. This is useful, for example, for parsing command lines with &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt;, getting tokens in a similar way to shell arguments. When used in combination with &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt;, tokens will be split on whitespace in addition to those characters.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 토큰은 공백으로 만 분할됩니다. 예를 들어, &lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; 로&lt;/a&gt; 명령 행을 구문 분석 하고 쉘 인수와 유사한 방식으로 토큰을 가져 오는 데 유용합니다 . &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 토큰은 해당 문자 외에도 공백으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="17f7ba8d172e5c3d522143611d4e644d4d525629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;WIFEXITED(status)&lt;/code&gt; is true, return the integer parameter to the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/exit(2)&quot;&gt;exit(2)&lt;/a&gt;&lt;/em&gt; system call. Otherwise, the return value is meaningless.</source>
          <target state="translated">경우 &lt;code&gt;WIFEXITED(status)&lt;/code&gt; 참의로 정수 매개 변수를 반환 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/exit(2)&quot;&gt;출구 (2)&lt;/a&gt;&lt;/em&gt; 시스템 호출. 그렇지 않으면 반환 값은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="eab713d9f34725181e53e9763d51930268ca8cbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arcname&lt;/code&gt; (or &lt;code&gt;filename&lt;/code&gt;, if &lt;code&gt;arcname&lt;/code&gt; is not given) contains a null byte, the name of the file in the archive will be truncated at the null byte.</source>
          <target state="translated">경우 &lt;code&gt;arcname&lt;/code&gt; (또는 &lt;code&gt;filename&lt;/code&gt; , 경우 &lt;code&gt;arcname&lt;/code&gt; 이 제공되지 않음) 널 바이트를 포함, 아카이브에서 파일의 이름은 널 바이트에서 잘립니다.</target>
        </trans-unit>
        <trans-unit id="fe6d01c5807b14dd92c652de9261e96f2f0d4073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;e&lt;/code&gt; is an instance of &lt;a href=&quot;#multiprocessing.BufferTooShort&quot;&gt;&lt;code&gt;BufferTooShort&lt;/code&gt;&lt;/a&gt; then &lt;code&gt;e.args[0]&lt;/code&gt; will give the message as a byte string.</source>
          <target state="translated">경우 &lt;code&gt;e&lt;/code&gt; 는 의 인스턴스 &lt;a href=&quot;#multiprocessing.BufferTooShort&quot;&gt; &lt;code&gt;BufferTooShort&lt;/code&gt; 는&lt;/a&gt; 다음 &lt;code&gt;e.args[0]&lt;/code&gt; , 바이트의 문자열로 메시지를 제공한다.</target>
        </trans-unit>
        <trans-unit id="700a5fc739f38418d59d1b88b3aa6552134ba97a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;frozen&lt;/code&gt; are both true, by default &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; will generate a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method for you. If &lt;code&gt;eq&lt;/code&gt; is true and &lt;code&gt;frozen&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;None&lt;/code&gt;, marking it unhashable (which it is, since it is mutable). If &lt;code&gt;eq&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be left untouched meaning the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method of the superclass will be used (if the superclass is &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, this means it will fall back to id-based hashing).</source>
          <target state="translated">경우 &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;frozen&lt;/code&gt; 기본적으로 사실 모두 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 생성 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 당신을위한 방법을. 경우 &lt;code&gt;eq&lt;/code&gt; 사실과 &lt;code&gt;frozen&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 &lt;code&gt;None&lt;/code&gt; 은 unhashable (이 인이 변경할 수 있기 때문에) 표시. 경우 &lt;code&gt;eq&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 의미 그대로 남아있을 것이다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 상위 클래스의 메소드 (슈퍼 인 경우 사용되는 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; ,이 수단은 ID 기반 해싱 다시 떨어질 것이다).</target>
        </trans-unit>
        <trans-unit id="f3e7fdf20356595a6bde624dc8a0964ea7673d86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;frozen&lt;/code&gt; are both true, by default &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; will generate a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method for you. If &lt;code&gt;eq&lt;/code&gt; is true and &lt;code&gt;frozen&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be set to &lt;code&gt;None&lt;/code&gt;, marking it unhashable (which it is, since it is mutable). If &lt;code&gt;eq&lt;/code&gt; is false, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; will be left untouched meaning the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method of the superclass will be used (if the superclass is &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, this means it will fall back to id-based hashing).</source>
          <target state="translated">경우 &lt;code&gt;eq&lt;/code&gt; 및 &lt;code&gt;frozen&lt;/code&gt; 기본적으로 사실 모두 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 생성 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 당신을위한 방법을. 경우 &lt;code&gt;eq&lt;/code&gt; 사실과 &lt;code&gt;frozen&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 &lt;code&gt;None&lt;/code&gt; 은 unhashable (이 인이 변경할 수 있기 때문에) 표시. 경우 &lt;code&gt;eq&lt;/code&gt; 거짓, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 의미 그대로 남아있을 것이다 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 상위 클래스의 메소드 (슈퍼 인 경우 사용되는 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; ,이 수단은 ID 기반 해싱 다시 떨어질 것이다).</target>
        </trans-unit>
        <trans-unit id="0b14e032175d28c1ba6eb0b6e2412729c87fd343" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;filename.py&lt;/code&gt; is specified its contents are tokenized to stdout. Otherwise, tokenization is performed on stdin.</source>
          <target state="translated">경우 &lt;code&gt;filename.py&lt;/code&gt; 가 지정되어 그 내용은 표준 출력 토큰 화된다. 그렇지 않으면, stdin에서 토큰 화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="933359dd3a335a93ae641667d496c6067a552576" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;from __future__ import annotations&lt;/code&gt; is used in Python 3.7 or later, annotations are not evaluated at function definition time. Instead, they are stored as strings in &lt;code&gt;__annotations__&lt;/code&gt;, This makes it unnecessary to use quotes around the annotation. (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0563&quot; id=&quot;index-64&quot;&gt;&lt;strong&gt;PEP 563&lt;/strong&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;code&gt;from __future__ import annotations&lt;/code&gt; 파이썬 3.7 이상에서 사용되는 주석이 함수 정의시에 평가되지 않습니다. 대신 &lt;code&gt;__annotations__&lt;/code&gt; 에 문자열로 저장되므로 주석 주위에 따옴표를 사용할 필요가 없습니다. ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0563&quot; id=&quot;index-64&quot;&gt;&lt;strong&gt;PEP 563&lt;/strong&gt;&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b78ebbf676987b9b08d03411af825fbaec6187a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;gather()&lt;/code&gt; is &lt;em&gt;cancelled&lt;/em&gt;, all submitted awaitables (that have not completed yet) are also &lt;em&gt;cancelled&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;code&gt;gather()&lt;/code&gt; 되어 &lt;em&gt;취소&lt;/em&gt; , (아직 완료하지 않은 경우) 모든 제출 awaitables도 있습니다 &lt;em&gt;취소&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e8177b4a39b5cb16f60785cde4b45bed17e60bdb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;infile&lt;/code&gt; is specified its contents are parsed to AST and dumped to stdout. Otherwise, the content is read from stdin.</source>
          <target state="translated">&lt;code&gt;infile&lt;/code&gt; 이 지정 되면 그 내용은 AST로 구문 분석되고 stdout에 덤프됩니다. 그렇지 않으면 stdin에서 내용을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="98e2ca390d09cb4c5d93c787d1a1e77d3b50a6b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;load_tests&lt;/code&gt; exists then discovery does &lt;em&gt;not&lt;/em&gt; recurse into the package, &lt;code&gt;load_tests&lt;/code&gt; is responsible for loading all tests in the package.</source>
          <target state="translated">경우 &lt;code&gt;load_tests&lt;/code&gt; 은 다음 발견 않는 존재 &lt;em&gt;하지&lt;/em&gt; 패키지로 재귀 적, &lt;code&gt;load_tests&lt;/code&gt; 는 패키지의 모든 테스트를로드 할 책임이있다.</target>
        </trans-unit>
        <trans-unit id="9a58c1405d0e16b64227f1566491186e0f5dddcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;module&lt;/code&gt; is not supplied, and Enum cannot determine what it is, the new Enum members will not be unpicklable; to keep errors closer to the source, pickling will be disabled.</source>
          <target state="translated">경우 &lt;code&gt;module&lt;/code&gt; 제공되지 않으며, 열거 그것이 무엇인지 확인할 수없는, 새로운 열거 회원 unpicklable되지 않습니다; 오류를 소스에 더 가깝게 유지하기 위해 산 세척이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3736d9d355c250769a78d1fa815bd9cfa2ab47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;newline=''&lt;/code&gt; is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use &lt;code&gt;\r\n&lt;/code&gt; linendings on write an extra &lt;code&gt;\r&lt;/code&gt; will be added. It should always be safe to specify &lt;code&gt;newline=''&lt;/code&gt;, since the csv module does its own (&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal&lt;/a&gt;) newline handling.</source>
          <target state="translated">경우 &lt;code&gt;newline=''&lt;/code&gt; 지정되지 않은 인용 필드 내부에 포함 된 개행 문자가 올바르게 해석하고 사용하는 플랫폼되지 않습니다 &lt;code&gt;\r\n&lt;/code&gt; 쓰기에 linendings 추가 &lt;code&gt;\r&lt;/code&gt; 추가됩니다. csv 모듈은 고유 한 ( &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용&lt;/a&gt; ) 개행 처리를 수행하므로 항상 &lt;code&gt;newline=''&lt;/code&gt; 을 지정하는 것이 안전해야합니다 .</target>
        </trans-unit>
        <trans-unit id="db91609c54b3c7ee79666f02ea8dab67263fa1cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;newline=''&lt;/code&gt; is not specified, newlines embedded inside quoted fields will not be interpreted correctly, and on platforms that use &lt;code&gt;\r\n&lt;/code&gt; linendings on write an extra &lt;code&gt;\r&lt;/code&gt; will be added. It should always be safe to specify &lt;code&gt;newline=''&lt;/code&gt;, since the csv module does its own (&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal&lt;/a&gt;) newline handling.</source>
          <target state="translated">경우 &lt;code&gt;newline=''&lt;/code&gt; 지정되지 않은 인용 필드 내부에 포함 된 개행 문자가 올바르게 해석하고 사용하는 플랫폼되지 않습니다 &lt;code&gt;\r\n&lt;/code&gt; 쓰기에 linendings 추가 &lt;code&gt;\r&lt;/code&gt; 추가됩니다. csv 모듈이 자체 ( &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;범용&lt;/a&gt; ) 개행 처리를 수행하므로 항상 &lt;code&gt;newline=''&lt;/code&gt; 을 지정하는 것이 안전해야합니다 .</target>
        </trans-unit>
        <trans-unit id="abd59bc323474e8d28c3b6cf30956ad3087d1391" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.chflags in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the flags of a symbolic link. (&lt;code&gt;os.chflags&lt;/code&gt; is not available on all platforms.)</source>
          <target state="translated">경우 &lt;code&gt;os.chflags in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 플래그를 수정할 수 있습니다. ( &lt;code&gt;os.chflags&lt;/code&gt; 는 모든 플랫폼에서 사용할 수 없습니다.)</target>
        </trans-unit>
        <trans-unit id="8e10e24faf09ce3b9d96dd7e061eb030aca8d0b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.chmod in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the permission bits of a symbolic link.</source>
          <target state="translated">경우 &lt;code&gt;os.chmod in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 권한 비트를 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33018c8d997e147843c0242b5f72f3cc52abfcee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os.utime in os.supports_follow_symlinks&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; can modify the last access and modification times of a symbolic link.</source>
          <target state="translated">경우 &lt;code&gt;os.utime in os.supports_follow_symlinks&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 심볼릭 링크의 최종 액세스 및 수정 시간을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a05957a485610f250e41b862c6cf8205d2ef4e95" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;proxy&lt;/code&gt; is a proxy whose referent is &lt;code&gt;obj&lt;/code&gt; then the expression</source>
          <target state="translated">경우 &lt;code&gt;proxy&lt;/code&gt; 그 지시 대상이다 프록시 &lt;code&gt;obj&lt;/code&gt; 그 표현은</target>
        </trans-unit>
        <trans-unit id="4198a79dad12cd8b876f2f71ca5d8af1485c0d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;related&lt;/code&gt; is not included in &lt;em&gt;preferencelist&lt;/em&gt;, consider the root part (or subpart of the root part) of any related encountered as a candidate if the (sub-)part matches a preference.</source>
          <target state="translated">경우 &lt;code&gt;related&lt;/code&gt; 포함되어 있지 않습니다 &lt;em&gt;preferencelist&lt;/em&gt; 의 (하위) 부분은 기본 설정을 일치하는 경우라도 후보로 발생 관련의 루트 부분 (또는 루트 부분의 서브 파트)를 고려한다.</target>
        </trans-unit>
        <trans-unit id="876e1c7c8abfc9cc30ff4722fb3870e77a933987" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;respect_handler_level&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, a handler&amp;rsquo;s level is respected (compared with the level for the message) when deciding whether to pass messages to that handler; otherwise, the behaviour is as in previous Python versions - to always pass each message to each handler.</source>
          <target state="translated">&lt;code&gt;respect_handler_level&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 메시지를 해당 핸들러로 전달할지 여부를 결정할 때 핸들러의 레벨이 존중됩니다 (메시지의 레벨과 비교). 그렇지 않으면 동작은 이전 Python 버전과 동일합니다. 항상 각 메시지를 각 처리기에 전달합니다.</target>
        </trans-unit>
        <trans-unit id="b8ba649cc272ffd32fbf67fb183157eb6f6df18c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.tzinfo&lt;/code&gt; is &lt;em&gt;tz&lt;/em&gt;, &lt;code&gt;self.astimezone(tz)&lt;/code&gt; is equal to &lt;em&gt;self&lt;/em&gt;: no adjustment of date or time data is performed. Else the result is local time in the timezone &lt;em&gt;tz&lt;/em&gt;, representing the same UTC time as &lt;em&gt;self&lt;/em&gt;: after &lt;code&gt;astz = dt.astimezone(tz)&lt;/code&gt;, &lt;code&gt;astz - astz.utcoffset()&lt;/code&gt; will have the same date and time data as &lt;code&gt;dt - dt.utcoffset()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;self.tzinfo&lt;/code&gt; 가 있다 &lt;em&gt;TZ&lt;/em&gt; , &lt;code&gt;self.astimezone(tz)&lt;/code&gt; 같은지 &lt;em&gt;자기&lt;/em&gt; : 날짜 또는 시간 데이터에는 조정이 수행되지 않는다. 그렇지 않으면 결과는 시간대의 현지 시간을 &lt;em&gt;TZ&lt;/em&gt; 와 같은 UTC 시간을 나타내는, &lt;em&gt;자기는&lt;/em&gt; : 후 &lt;code&gt;astz = dt.astimezone(tz)&lt;/code&gt; , &lt;code&gt;astz - astz.utcoffset()&lt;/code&gt; 와 같은 날짜 및 시간 데이터해야합니다 &lt;code&gt;dt - dt.utcoffset()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367bdb474eb8abb8f4c9cfe3276f05ae7bdd8611" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;setUpModule()&lt;/code&gt; fails, meaning that &lt;code&gt;tearDownModule()&lt;/code&gt; is not called, then any cleanup functions added will still be called.</source>
          <target state="translated">경우 &lt;code&gt;setUpModule()&lt;/code&gt; 실패, 그 의미 &lt;code&gt;tearDownModule()&lt;/code&gt; 호출되지 않습니다를 다음 추가 된 정리 기능은 여전히 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5df6e6854ff33d1db70399b9e7421342b26d1f49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;side_effect&lt;/code&gt; is a function then whatever that function returns is what calls to the mock return. The &lt;code&gt;side_effect&lt;/code&gt; function is called with the same arguments as the mock. This allows you to vary the return value of the call dynamically, based on the input:</source>
          <target state="translated">경우 &lt;code&gt;side_effect&lt;/code&gt; 이 기능은 다음 무엇이든 그 함수가 반환은 모의 리턴 호출 것입니다. &lt;code&gt;side_effect&lt;/code&gt; 의 기능은 모의와 동일한 인자와 함께 호출됩니다. 이를 통해 입력에 따라 호출의 반환 값을 동적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="087e65b3a7a454d1f380ea833e17e5e2da02afee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signal.SIGINT&lt;/code&gt; isn&amp;rsquo;t handled by Python (it was set to &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt;&lt;code&gt;signal.SIG_DFL&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt;&lt;code&gt;signal.SIG_IGN&lt;/code&gt;&lt;/a&gt;), this function does nothing.</source>
          <target state="translated">경우 &lt;code&gt;signal.SIGINT&lt;/code&gt; 이 (가로 설정되어 파이썬에 의해 처리되지 &lt;a href=&quot;signal#signal.SIG_DFL&quot;&gt; &lt;code&gt;signal.SIG_DFL&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;signal#signal.SIG_IGN&quot;&gt; &lt;code&gt;signal.SIG_IGN&lt;/code&gt; &lt;/a&gt; ),이 함수는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f66a0119d36ff434bd176a0f14f955171a2dbfee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;something()&lt;/code&gt; is cancelled by other means (i.e. from within itself) that would also cancel &lt;code&gt;shield()&lt;/code&gt;.</source>
          <target state="translated">다른 방법으로 (즉, 자체에서 &lt;code&gt;something()&lt;/code&gt; 를 취소 하면 &lt;code&gt;shield()&lt;/code&gt; 도 취소 됩니다.</target>
        </trans-unit>
        <trans-unit id="8c1aae3855096a38e20d34c3153d0204c6e5add8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sys.stdin&lt;/code&gt; is used more than once, the second and further use will return no lines, except perhaps for interactive use, or if it has been explicitly reset (e.g. using &lt;code&gt;sys.stdin.seek(0)&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;sys.stdin&lt;/code&gt; 가 두 번 이상 사용하는 경우, 두번째 이후 사용, 더 라인을 반환하지 상호 작용 사용 아마도 제외시켰다하거나 있었는지 명시 적으로 초기화됩니다 (예를 들어, 사용 &lt;code&gt;sys.stdin.seek(0)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a1540606a988a3eee5d0cd32d98e93f7bdb7662c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sys&lt;/code&gt; is reset by user code, such as with &lt;code&gt;importlib.reload(sys)&lt;/code&gt;, IDLE&amp;rsquo;s changes are lost and input from the keyboard and output to the screen will not work correctly.</source>
          <target state="translated">경우 &lt;code&gt;sys&lt;/code&gt; 같은과 같은 사용자 코드에 의해 리셋 &lt;code&gt;importlib.reload(sys)&lt;/code&gt; , IDLE의 변경 내용이 손실되고 화면에 키보드와 출력의 입력은 제대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ef4296b0d6745bb7998092ae95ff303a8c4712b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tempdir&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; (the default) at any call to any of the above functions except &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt;&lt;code&gt;gettempprefix()&lt;/code&gt;&lt;/a&gt; it is initialized following the algorithm described in &lt;a href=&quot;#tempfile.gettempdir&quot;&gt;&lt;code&gt;gettempdir()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;tempdir&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 제외한 상기의 모든 기능에 대한 호출의 (디폴트) &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt; &lt;code&gt;gettempprefix()&lt;/code&gt; &lt;/a&gt; 그것의 한 알고리즘은 다음 초기화 &lt;a href=&quot;#tempfile.gettempdir&quot;&gt; &lt;code&gt;gettempdir()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ce6afbd1542483776b1f19987aee4fdaea2af84" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timeout &amp;gt; 0&lt;/code&gt;, this specifies the maximum wait time, in seconds. If &lt;code&gt;timeout &amp;lt;= 0&lt;/code&gt;, the call won&amp;rsquo;t block, and will report the currently ready file objects. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the call will block until a monitored file object becomes ready.</source>
          <target state="translated">만약 &lt;code&gt;timeout &amp;gt; 0&lt;/code&gt; (초)이 지정하는 최대 대기 시간. 경우 &lt;code&gt;timeout &amp;lt;= 0&lt;/code&gt; , 통화가 차단되지 않으며, 현재 준비 파일 객체를보고합니다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 모니터링 파일 객체가 준비 될 때까지 호출이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="4f3174ca6f611f2bc6b0b745bb585c33a3deecae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_comments=True&lt;/code&gt; is given, the parser is modified to check and return type comments as specified by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;. This is equivalent to adding &lt;a href=&quot;#ast.PyCF_TYPE_COMMENTS&quot;&gt;&lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt;&lt;/a&gt; to the flags passed to &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;. This will report syntax errors for misplaced type comments. Without this flag, type comments will be ignored, and the &lt;code&gt;type_comment&lt;/code&gt; field on selected AST nodes will always be &lt;code&gt;None&lt;/code&gt;. In addition, the locations of &lt;code&gt;# type:
ignore&lt;/code&gt; comments will be returned as the &lt;code&gt;type_ignores&lt;/code&gt; attribute of &lt;code&gt;Module&lt;/code&gt; (otherwise it is always an empty list).</source>
          <target state="translated">경우 &lt;code&gt;type_comments=True&lt;/code&gt; 주어진다, 파서는 지정한대로 확인하고 반환 형식 댓글 수정 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP (484)&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; . 이것은 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 전달 된 플래그에 &lt;a href=&quot;#ast.PyCF_TYPE_COMMENTS&quot;&gt; &lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt; &lt;/a&gt; 를 추가하는 것과 같습니다 . 잘못 배치 된 유형 주석에 대한 구문 오류를보고합니다. 이 플래그가 없으면 유형 주석이 무시 되고 선택한 AST 노드 의 &lt;code&gt;type_comment&lt;/code&gt; 필드는 항상 &lt;code&gt;None&lt;/code&gt; 이 됩니다. 또한 &lt;code&gt;# type: ignore&lt;/code&gt; comments 의 위치는 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;type_ignores&lt;/code&gt; 속성 으로 반환됩니다 (그렇지 않으면 항상 빈 목록 임).</target>
        </trans-unit>
        <trans-unit id="b883d86f843b47e0cc5cb4e22ef7491a75061003" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_comments=True&lt;/code&gt; is given, the parser is modified to check and return type comments as specified by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 484&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;. This is equivalent to adding &lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt; to the flags passed to &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;. This will report syntax errors for misplaced type comments. Without this flag, type comments will be ignored, and the &lt;code&gt;type_comment&lt;/code&gt; field on selected AST nodes will always be &lt;code&gt;None&lt;/code&gt;. In addition, the locations of &lt;code&gt;# type:
ignore&lt;/code&gt; comments will be returned as the &lt;code&gt;type_ignores&lt;/code&gt; attribute of &lt;code&gt;Module&lt;/code&gt; (otherwise it is always an empty list).</source>
          <target state="translated">경우 &lt;code&gt;type_comments=True&lt;/code&gt; 주어진다, 파서는 지정한대로 확인하고 반환 형식 댓글 수정 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP (484)&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; . 이것은 &lt;code&gt;ast.PyCF_TYPE_COMMENTS&lt;/code&gt; 를 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 전달 된 플래그 에 추가하는 것과 같습니다 . 잘못 배치 된 유형 주석에 대한 구문 오류를보고합니다. 이 플래그가 없으면 형식 설명은 무시 되고 선택한 AST 노드 의 &lt;code&gt;type_comment&lt;/code&gt; 필드는 항상 &lt;code&gt;None&lt;/code&gt; 입니다. 또한 &lt;code&gt;# type: ignore&lt;/code&gt; 주석 의 위치는 &lt;code&gt;Module&lt;/code&gt; 의 &lt;code&gt;type_ignores&lt;/code&gt; 속성 으로 반환됩니다 (그렇지 않으면 항상 빈 목록 임).</target>
        </trans-unit>
        <trans-unit id="a0593491fc7f673a2fbc8bcde73d064bd5a237d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tzname()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;%Z&lt;/code&gt; is replaced by an empty string. Otherwise &lt;code&gt;%Z&lt;/code&gt; is replaced by the returned value, which must be a string.</source>
          <target state="translated">경우 &lt;code&gt;tzname()&lt;/code&gt; 를 반환 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;%Z&lt;/code&gt; 빈 문자열로 대체됩니다. 그렇지 않으면 &lt;code&gt;%Z&lt;/code&gt; 는 반환 된 값으로 대체되며, 이는 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2650dd8391d760c4b3dcdc53f8ee4bce8296ecf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a negative rational number define &lt;code&gt;hash(x)&lt;/code&gt; as &lt;code&gt;-hash(-x)&lt;/code&gt;. If the resulting hash is &lt;code&gt;-1&lt;/code&gt;, replace it with &lt;code&gt;-2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x = m / n&lt;/code&gt; 인 네거티브 유리수 정의 &lt;code&gt;hash(x)&lt;/code&gt; 로서 &lt;code&gt;-hash(-x)&lt;/code&gt; . 결과 해시가 &lt;code&gt;-1&lt;/code&gt; 이면 &lt;code&gt;-2&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="93635faa94af4f4c677484e54d0cfef7e6922367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a nonnegative rational number and &lt;code&gt;n&lt;/code&gt; is divisible by &lt;code&gt;P&lt;/code&gt; (but &lt;code&gt;m&lt;/code&gt; is not) then &lt;code&gt;n&lt;/code&gt; has no inverse modulo &lt;code&gt;P&lt;/code&gt; and the rule above doesn&amp;rsquo;t apply; in this case define &lt;code&gt;hash(x)&lt;/code&gt; to be the constant value &lt;code&gt;sys.hash_info.inf&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;x = m / n&lt;/code&gt; 음이 아닌 유리수이고, &lt;code&gt;n&lt;/code&gt; 에 의해 나누어 &lt;code&gt;P&lt;/code&gt; (단, &lt;code&gt;m&lt;/code&gt; 은 아니다)을 &lt;code&gt;n&lt;/code&gt; 에는 역 모듈이없는 &lt;code&gt;P&lt;/code&gt; 와 적용하지 않고 상기 규칙; 이 경우 &lt;code&gt;hash(x)&lt;/code&gt; 를 상수 값 &lt;code&gt;sys.hash_info.inf&lt;/code&gt; 로 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="575b723cab08b731a281088430618a5e6637507d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x = m / n&lt;/code&gt; is a nonnegative rational number and &lt;code&gt;n&lt;/code&gt; is not divisible by &lt;code&gt;P&lt;/code&gt;, define &lt;code&gt;hash(x)&lt;/code&gt; as &lt;code&gt;m * invmod(n, P) % P&lt;/code&gt;, where &lt;code&gt;invmod(n,
P)&lt;/code&gt; gives the inverse of &lt;code&gt;n&lt;/code&gt; modulo &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x = m / n&lt;/code&gt; 음수가 아닌 유리수이고, &lt;code&gt;n&lt;/code&gt; 에 의해 나누어 아닌 &lt;code&gt;P&lt;/code&gt; 정의 &lt;code&gt;hash(x)&lt;/code&gt; 로서 &lt;code&gt;m * invmod(n, P) % P&lt;/code&gt; , &lt;code&gt;invmod(n, P)&lt;/code&gt; 의 역 제공 &lt;code&gt;n&lt;/code&gt; 모듈로 &lt;code&gt;P&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="00f7d3383e6e96fe7eb1f9df5004df74f9efec98" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;PIPE&lt;/em&gt; is passed to &lt;em&gt;stdin&lt;/em&gt; argument, the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt;&lt;code&gt;Process.stdin&lt;/code&gt;&lt;/a&gt; attribute will point to a &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">경우 &lt;em&gt;파이프&lt;/em&gt; 에 전달 &lt;em&gt;하여 stdin&lt;/em&gt; 인수의 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdin&quot;&gt; &lt;code&gt;Process.stdin&lt;/code&gt; 의&lt;/a&gt; 속성은 가리 킵니다 &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="38a0b86cb262bdd72cf16c86faa970fbee2eca97" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;PIPE&lt;/em&gt; is passed to &lt;em&gt;stdout&lt;/em&gt; or &lt;em&gt;stderr&lt;/em&gt; arguments, the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt;&lt;code&gt;Process.stdout&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt;&lt;code&gt;Process.stderr&lt;/code&gt;&lt;/a&gt; attributes will point to &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">경우 &lt;em&gt;파이프&lt;/em&gt; 에 전달되는 &lt;em&gt;표준 출력&lt;/em&gt; 또는 &lt;em&gt;표준 오류&lt;/em&gt; 인수는 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stdout&quot;&gt; &lt;code&gt;Process.stdout&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.stderr&quot;&gt; &lt;code&gt;Process.stderr&lt;/code&gt; &lt;/a&gt; 속성을 가리 킵니다 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="a3d56b8626e52a3b745f55fc2379e816f304457a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; are of different lengths, or if an error occurs, a timing attack could theoretically reveal information about the types and lengths of &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt;&amp;mdash;but not their values.</source>
          <target state="translated">경우 와 &lt;em&gt;b는&lt;/em&gt; 서로 다른 길이의하다 에러가 발생했을 경우, 또는, 타이밍 공격은 이론적으로의 종류와 길이에 대한 정보를 공개 할 수 &lt;em&gt;을&lt;/em&gt; 하고 &lt;em&gt;ㄱ&lt;/em&gt; 그 값을하지 -하지만.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dc5c1185931e9b5fe08eb862e8faf706f6f24540" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; is an int, it is used directly.</source>
          <target state="translated">경우 &lt;em&gt;A는&lt;/em&gt; int로, 그것은 직접적으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="08098ecc02f15e5298805376eb97d21770273b65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;a&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, the current system time is used. If randomness sources are provided by the operating system, they are used instead of the system time (see the &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt; function for details on availability).</source>
          <target state="translated">경우 &lt;em&gt;A는&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 현재 시스템 시간을 사용한다. 운영 체제에서 임의 소스를 제공하는 경우 시스템 시간 대신 소스가 사용됩니다 (사용 가능 여부에 대한 자세한 내용은 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 함수 참조).</target>
        </trans-unit>
        <trans-unit id="ddd2d43954115612f47582f7f40c2da1ce1c45e3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_ID&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the node, &lt;em&gt;v2&lt;/em&gt; is the reference, and &lt;em&gt;v3&lt;/em&gt; should be set to 0.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_ID&lt;/code&gt; 후 &lt;em&gt;V1&lt;/em&gt; 노드이고, &lt;em&gt;V2는&lt;/em&gt; 기준이며, &lt;em&gt;V3은&lt;/em&gt; 0으로 설정되어야한다.</target>
        </trans-unit>
        <trans-unit id="8daf1756c4685b74aa3a32fb2dad0e27162099fa" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_NAME&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the server type, &lt;em&gt;v2&lt;/em&gt; is the port identifier, and &lt;em&gt;v3&lt;/em&gt; should be 0.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_NAME&lt;/code&gt; 후 &lt;em&gt;V1&lt;/em&gt; 서버 유형 인 &lt;em&gt;V2가&lt;/em&gt; 포트 식별자이며, &lt;em&gt;V3은&lt;/em&gt; 0이어야한다.</target>
        </trans-unit>
        <trans-unit id="5ee8f55dc5cb9c1fddf1d3f67dd30328327823b8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;addr_type&lt;/em&gt; is &lt;code&gt;TIPC_ADDR_NAMESEQ&lt;/code&gt;, then &lt;em&gt;v1&lt;/em&gt; is the server type, &lt;em&gt;v2&lt;/em&gt; is the lower port number, and &lt;em&gt;v3&lt;/em&gt; is the upper port number.</source>
          <target state="translated">경우 &lt;em&gt;addr_type가&lt;/em&gt; 있다 &lt;code&gt;TIPC_ADDR_NAMESEQ&lt;/code&gt; , 다음 &lt;em&gt;V1&lt;/em&gt; 서버 유형이있다 &lt;em&gt;V2가&lt;/em&gt; 낮은 포트 번호이며, &lt;em&gt;V3는&lt;/em&gt; 상단 포트 번호입니다.</target>
        </trans-unit>
        <trans-unit id="e3c769a1fb511af595c339c328e4e17c4c3ff2b6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;aliased&lt;/em&gt; is true, the function will use aliases for various platforms that report system names which differ from their common names, for example SunOS will be reported as Solaris. The &lt;a href=&quot;#platform.system_alias&quot;&gt;&lt;code&gt;system_alias()&lt;/code&gt;&lt;/a&gt; function is used to implement this.</source>
          <target state="translated">경우 &lt;em&gt;별칭이&lt;/em&gt; 사실이다, 함수는 공통 이름과 다를 보고서 시스템 이름이, 예를 들어 SunOS의이 솔라리스로보고됩니다 다양한 플랫폼에 대한 별칭을 사용합니다. &lt;a href=&quot;#platform.system_alias&quot;&gt; &lt;code&gt;system_alias()&lt;/code&gt; &lt;/a&gt; 함수는이를 구현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35db95e9a28719ea3058976c910d71b26ef3098a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;all_frames&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, all frames of the traceback are checked. If &lt;em&gt;all_frames&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, only the most recent frame is checked.</source>
          <target state="translated">&lt;em&gt;all_frames&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 , 역 추적의 모든 프레임이 검사됩니다. 경우 &lt;em&gt;all_frames이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 가장 최근의 프레임이 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="3e12368612ae3dc2365f369a9caafd4788de7974" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allowZip64&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) zipfile will create ZIP files that use the ZIP64 extensions when the zipfile is larger than 4 GiB. If it is &lt;code&gt;false&lt;/code&gt;&lt;a href=&quot;#module-zipfile&quot;&gt;&lt;code&gt;zipfile&lt;/code&gt;&lt;/a&gt; will raise an exception when the ZIP file would require ZIP64 extensions.</source>
          <target state="translated">&lt;em&gt;allowZip64&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; (기본값) 인 경우 zip 파일은 zip 파일이 4GiB보다 큰 경우 ZIP64 확장자를 사용하는 ZIP 파일을 생성합니다. 이 경우 &lt;code&gt;false&lt;/code&gt; &lt;a href=&quot;#module-zipfile&quot;&gt; &lt;code&gt;zipfile&lt;/code&gt; &lt;/a&gt; 예외를 발생한다이 ZIP 파일은 ZIP64 확장을 필요로 할 때.</target>
        </trans-unit>
        <trans-unit id="eb1877b149e4a559e04aa18e7cbd9b76903ad1d4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allow_nan&lt;/em&gt; is false (default: &lt;code&gt;True&lt;/code&gt;), then it will be a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to serialize out of range &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values (&lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, &lt;code&gt;-inf&lt;/code&gt;) in strict compliance of the JSON specification. If &lt;em&gt;allow_nan&lt;/em&gt; is true, their JavaScript equivalents (&lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;) will be used.</source>
          <target state="translated">경우 &lt;em&gt;allow_nan이&lt;/em&gt; (기본값 : 거짓 &lt;code&gt;True&lt;/code&gt; ), 다음이 될 것입니다 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 범위 밖으로 직렬화하는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값 ( &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; json으로 사양의 엄격한 준수). 경우 &lt;em&gt;allow_nan는&lt;/em&gt; 사실, 자신의 자바 스크립트 등가물 ( &lt;code&gt;NaN&lt;/code&gt; 를 , &lt;code&gt;Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 는 ) 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="365b8c9a025c7c15e2aa49096f5708db96335579" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;allow_nan&lt;/em&gt; is true (the default), then &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;Infinity&lt;/code&gt;, and &lt;code&gt;-Infinity&lt;/code&gt; will be encoded as such. This behavior is not JSON specification compliant, but is consistent with most JavaScript based encoders and decoders. Otherwise, it will be a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to encode such floats.</source>
          <target state="translated">경우 &lt;em&gt;allow_nan가&lt;/em&gt; true (디폴트), 다음 &lt;code&gt;NaN&lt;/code&gt; 의 , &lt;code&gt;Infinity&lt;/code&gt; 하고, &lt;code&gt;-Infinity&lt;/code&gt; 는 같은 인코딩됩니다. 이 동작은 JSON 사양과 호환되지 않지만 대부분의 JavaScript 기반 인코더 및 디코더와 일치합니다. 그렇지 않으면 그러한 float를 인코딩 하는 것은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c5a8dca769532cade2fe55bfaac93ebef45b3887" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;altinstall&lt;/em&gt; is set, then &lt;code&gt;pipX&lt;/code&gt; will &lt;em&gt;not&lt;/em&gt; be installed.</source>
          <target state="translated">경우 &lt;em&gt;altinstall가&lt;/em&gt; 설정되어, 다음 &lt;code&gt;pipX&lt;/code&gt; 는 것입니다 &lt;em&gt;하지&lt;/em&gt; 설치.</target>
        </trans-unit>
        <trans-unit id="50026840e798123dd4e7c9c3c6b090021e307025" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is false then the awaits must be sequential. There can be extra calls before or after the specified awaits.</source>
          <target state="translated">&lt;em&gt;any_order&lt;/em&gt; 가 false 이면 &lt;em&gt;대기&lt;/em&gt; 는 순차적이어야합니다. 지정된 대기 전 또는 후에 추가 호출이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83074f9b97aea52bc40947133bf7966023c0dfb4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is false then the calls must be sequential. There can be extra calls before or after the specified calls.</source>
          <target state="translated">경우 &lt;em&gt;any_order이&lt;/em&gt; 거짓 다음 호출은 순차적으로해야합니다. 지정된 통화 전후에 추가 통화가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00f36f468d7fc72d5086c39c28c3ab3335e0b213" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is true then the awaits can be in any order, but they must all appear in &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt;&lt;code&gt;await_args_list&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;any_order&lt;/em&gt; 가 true 이면 &lt;em&gt;awaits&lt;/em&gt; 는 순서에 관계없이 모두 &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt; &lt;code&gt;await_args_list&lt;/code&gt; &lt;/a&gt; 에 나타나야 합니다.</target>
        </trans-unit>
        <trans-unit id="77ac2e901cc5aeaa722f2e4e6b975f2f2972f688" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any_order&lt;/em&gt; is true then the calls can be in any order, but they must all appear in &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;any_order이&lt;/em&gt; 사실 다음 호출은 임의의 순서로 될 수 있지만, 그들은 모두에 표시되어야합니다 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b896efed823ebecf1bef68285349fa5d05fe09f8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arcname&lt;/em&gt; is specified, it is used as the name within the archive. If &lt;em&gt;arcname&lt;/em&gt; is not specified, the name will be the same as &lt;em&gt;filename&lt;/em&gt;, but with any drive letter and leading path separators removed.</source>
          <target state="translated">경우 &lt;em&gt;arcname가&lt;/em&gt; 지정되어, 그것은 아카이브 내 이름으로 사용됩니다. 경우 &lt;em&gt;arcname가&lt;/em&gt; 지정되지 않은, 이름과 동일합니다 &lt;em&gt;파일 이름&lt;/em&gt; 만 분리 한 드라이브 문자 및 선행 경로 구분와.</target>
        </trans-unit>
        <trans-unit id="bb3e312374b1b5d8dccea78b576f639dc980f7ee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;atTime&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a &lt;code&gt;datetime.time&lt;/code&gt; instance which specifies the time of day when rollover occurs, for the cases where rollover is set to happen &amp;ldquo;at midnight&amp;rdquo; or &amp;ldquo;on a particular weekday&amp;rdquo;. Note that in these cases, the &lt;em&gt;atTime&lt;/em&gt; value is effectively used to compute the &lt;em&gt;initial&lt;/em&gt; rollover, and subsequent rollovers would be calculated via the normal interval calculation.</source>
          <target state="translated">경우 &lt;em&gt;atTime가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그것은해야합니다 &lt;code&gt;datetime.time&lt;/code&gt; 의 롤오버가 &quot;특정 평일에&quot; &quot;자정&quot;발생하거나 설정되어있는 경우에 롤오버가 발생했을 때 하루의 시간을 지정 인스턴스. 이러한 경우 &lt;em&gt;atTime&lt;/em&gt; 값은 효과적으로 &lt;em&gt;초기&lt;/em&gt; 롤오버 를 계산하는 데 사용 되며 후속 롤오버는 일반 간격 계산을 통해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="64ed490d101bfcd7c524cd7f6470fd6dd92855bd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;authkey&lt;/em&gt; is given and not None, it should be a byte string and will be used as the secret key for an HMAC-based authentication challenge. No authentication is done if &lt;em&gt;authkey&lt;/em&gt; is None. &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised if authentication fails. See &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;Authentication keys&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;인증 키가&lt;/em&gt; 없음 주어지지되지 않으며, 그것은 바이트 문자열해야하고, HMAC 기반의 인증 요청에 대한 비밀 키로 사용됩니다. &lt;em&gt;authkey&lt;/em&gt; 가 None 이면 인증이 수행되지 않습니다. &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 에 실패하면 AuthenticationError 가 발생합니다. &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;인증 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59231b8d6544c6fca57984e1be4fe078812fe3b1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;aw&lt;/em&gt; is a coroutine it is automatically scheduled as a Task.</source>
          <target state="translated">경우 &lt;em&gt;아이&lt;/em&gt; 코 루틴입니다 자동 태스크로 예정되어있다.</target>
        </trans-unit>
        <trans-unit id="846999a5b8612ebabe5165c0323a01a132f354c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;backupCount&lt;/em&gt; is nonzero, at most &lt;em&gt;backupCount&lt;/em&gt; files will be kept, and if more would be created when rollover occurs, the oldest one is deleted. The deletion logic uses the interval to determine which files to delete, so changing the interval may leave old files lying around.</source>
          <target state="translated">경우 &lt;em&gt;BACKUPCOUNT는&lt;/em&gt; 최대 0이 아닌입니다 &lt;em&gt;BACKUPCOUNT의&lt;/em&gt; 파일이 유지되고, 더이 생성 될 경우 롤오버가 발생했을 때, 가장 오래된이 삭제됩니다. 삭제 논리는 간격을 사용하여 삭제할 파일을 결정하므로 간격을 변경하면 오래된 파일이 남아있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="254adf80a9b6b968549efbd28f181bb6475f5a82" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;blocking&lt;/em&gt; is false executes the scheduled events due to expire soonest (if any) and then return the deadline of the next scheduled call in the scheduler (if any).</source>
          <target state="translated">경우 &lt;em&gt;차단이&lt;/em&gt; 거짓이 실행 인해 예약 된 이벤트가 조속한 만료 (있는 경우) 다음 스케줄러 (있는 경우)에서 다음 예약 전화의 기한을 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="a72b7baa5a4df5ed7a19b9faf38f50add7609350" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;body&lt;/em&gt; is specified, the specified data is sent after the headers are finished. It may be a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, an open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, or an iterable of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;body&lt;/em&gt; is a string, it is encoded as ISO-8859-1, the default for HTTP. If it is a bytes-like object, the bytes are sent as is. If it is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, the contents of the file is sent; this file object should support at least the &lt;code&gt;read()&lt;/code&gt; method. If the file object is an instance of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt;, the data returned by the &lt;code&gt;read()&lt;/code&gt; method will be encoded as ISO-8859-1, otherwise the data returned by &lt;code&gt;read()&lt;/code&gt; is sent as is. If &lt;em&gt;body&lt;/em&gt; is an iterable, the elements of the iterable are sent as is until the iterable is exhausted.</source>
          <target state="translated">경우 &lt;em&gt;몸이&lt;/em&gt; 지정된 헤더를 완료 한 후, 지정된 데이터가 전송됩니다. 그것은있을 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , 또는의 반복 가능한 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열 인, 그것은 ISO-8859-1, HTTP의 기본값으로 인코딩됩니다. 바이트와 ​​유사한 객체 인 경우 바이트는 그대로 전송됩니다. 그것은 경우 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; , 파일의 내용이 전송됩니다; 이 파일 객체는 최소한 &lt;code&gt;read()&lt;/code&gt; 메소드를 지원해야합니다 . 파일 객체가 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; 의 인스턴스 인 경우 , &lt;code&gt;read()&lt;/code&gt; 메소드에 의해 반환 된 데이터는 ISO-8859-1로 인코딩되고 그렇지 않으면 &lt;code&gt;read()&lt;/code&gt; 있는 그대로 전송됩니다. 경우 &lt;em&gt;본체&lt;/em&gt; 반복 가능되면, 반복 가능한 요소는 반복 가능한 소진 될 때까지 그대로 전송된다.</target>
        </trans-unit>
        <trans-unit id="039a71d8df3fedc4f6546669f8067430aeab29a9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;body&lt;/em&gt; is specified, the specified data is sent after the headers are finished. It may be a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, an open &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, or an iterable of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;body&lt;/em&gt; is a string, it is encoded as ISO-8859-1, the default for HTTP. If it is a bytes-like object, the bytes are sent as is. If it is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, the contents of the file is sent; this file object should support at least the &lt;code&gt;read()&lt;/code&gt; method. If the file object is an instance of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt;, the data returned by the &lt;code&gt;read()&lt;/code&gt; method will be encoded as ISO-8859-1, otherwise the data returned by &lt;code&gt;read()&lt;/code&gt; is sent as is. If &lt;em&gt;body&lt;/em&gt; is an iterable, the elements of the iterable are sent as is until the iterable is exhausted.</source>
          <target state="translated">경우 &lt;em&gt;몸이&lt;/em&gt; 지정된 헤더를 완료 한 후, 지정된 데이터가 전송됩니다. 그것은있을 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 하는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , 열린 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , 또는의 반복 가능한 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열 인, 그것은 ISO-8859-1, HTTP의 기본값으로 인코딩됩니다. 바이트와 ​​유사한 객체 인 경우 바이트는 그대로 전송됩니다. 그것은 경우 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; , 파일의 내용이 전송됩니다; 이 파일 객체는 최소한 &lt;code&gt;read()&lt;/code&gt; 메서드를 지원해야합니다 . 파일 객체가 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; 의 인스턴스 이면 &lt;code&gt;read()&lt;/code&gt; 메서드가 반환하는 데이터는 ISO-8859-1로 인코딩되고 그렇지 않으면 &lt;code&gt;read()&lt;/code&gt; 반환하는 데이터가됩니다.있는 그대로 전송됩니다. 경우 &lt;em&gt;본체&lt;/em&gt; 반복 가능되면, 반복 가능한 요소는 반복 가능한 소진 될 때까지 그대로 전송된다.</target>
        </trans-unit>
        <trans-unit id="a95a187d480705fc824e774d84d0311d36773db9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffer_callback&lt;/em&gt; is None (the default), buffer views are serialized into &lt;em&gt;file&lt;/em&gt; as part of the pickle stream.</source>
          <target state="translated">경우 &lt;em&gt;buffer_callback가&lt;/em&gt; 없음 (디폴트)이없고, 버퍼 뷰에 직렬화 &lt;em&gt;파일&lt;/em&gt; 피클 스트림의 일부로.</target>
        </trans-unit>
        <trans-unit id="2802d994edfbf276788a825388162db7061822a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffer_callback&lt;/em&gt; is not None, then it can be called any number of times with a buffer view. If the callback returns a false value (such as None), the given buffer is &lt;a href=&quot;#pickle-oob&quot;&gt;out-of-band&lt;/a&gt;; otherwise the buffer is serialized in-band, i.e. inside the pickle stream.</source>
          <target state="translated">&lt;em&gt;buffer_callback&lt;/em&gt; 이 None이 아닌 경우 버퍼 뷰를 사용하여 여러 번 호출 할 수 있습니다. 콜백이 잘못된 값 (예 : None)을 반환하면 지정된 버퍼가 &lt;a href=&quot;#pickle-oob&quot;&gt;대역 외입니다&lt;/a&gt; . 그렇지 않으면 버퍼는 대역 내에서, 즉 피클 스트림 내부에서 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="65eadafe837a031d16efa4765ff11c2ea5982995" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffers&lt;/em&gt; is None (the default), then all data necessary for deserialization must be contained in the pickle stream. This means that the &lt;em&gt;buffer_callback&lt;/em&gt; argument was None when a &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; was instantiated (or when &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; was called).</source>
          <target state="translated">경우 &lt;em&gt;버퍼가&lt;/em&gt; 없음 (기본값)입니다, 다음, 직렬화 복원에 필요한 모든 데이터는 피클 스트림에 포함되어야합니다. 이는 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 가 인스턴스화 될 때 (또는 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 &lt;em&gt;buffer_callback&lt;/em&gt; 인수가 없음 &lt;em&gt;임을&lt;/em&gt; 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3072f53b48e04deeb5f6a92a951e4b7b30fd9b43" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;buffers&lt;/em&gt; is not None, it should be an iterable of buffer-enabled objects that is consumed each time the pickle stream references an &lt;a href=&quot;#pickle-oob&quot;&gt;out-of-band&lt;/a&gt; buffer view. Such buffers have been given in order to the &lt;em&gt;buffer_callback&lt;/em&gt; of a Pickler object.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 가 없음이 아닌 경우 , 피클 스트림 &lt;a href=&quot;#pickle-oob&quot;&gt;이 대역 외&lt;/a&gt; 버퍼 뷰를 참조 할 때마다 사용되는 반복 가능한 버퍼 가능 오브젝트 여야합니다 . 이러한 버퍼는 Pickler 객체 의 &lt;em&gt;buffer_callback&lt;/em&gt; 에 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="99e4b8756b05030f0547669e2cd91b89c6443032" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;c&lt;/em&gt; is an instance of &lt;em&gt;C&lt;/em&gt;, &lt;code&gt;c.x&lt;/code&gt; will invoke the getter, &lt;code&gt;c.x = value&lt;/code&gt; will invoke the setter and &lt;code&gt;del c.x&lt;/code&gt; the deleter.</source>
          <target state="translated">경우 &lt;em&gt;C는&lt;/em&gt; 의 인스턴스 &lt;em&gt;C&lt;/em&gt; , &lt;code&gt;c.x&lt;/code&gt; 게터, 호출한다 &lt;code&gt;c.x = value&lt;/code&gt; 세터 및 호출한다 &lt;code&gt;del c.x&lt;/code&gt; Deleter가있다.</target>
        </trans-unit>
        <trans-unit id="c89346ab698759df4344532dd364a8daa21e4b53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;callback&lt;/em&gt; is given and is not &lt;code&gt;None&lt;/code&gt;, it will be called after each trial with two arguments: &lt;code&gt;callback(number, time_taken)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 이 제공되고 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 두 번의 인수 &lt;code&gt;callback(number, time_taken)&lt;/code&gt; 와 함께 각 평가판 이후에 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="209e198351f5a2406fae647dd06611db91524849" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;callback&lt;/em&gt; is specified then it should be a callable which accepts a single argument. When the result becomes ready &lt;em&gt;callback&lt;/em&gt; is applied to it, that is unless the call failed, in which case the &lt;em&gt;error_callback&lt;/em&gt; is applied instead.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 이 지정 되면 단일 인수를 허용하는 콜 러블이어야합니다. 결과가 준비되면 &lt;em&gt;콜백&lt;/em&gt; 이 적용됩니다. 즉, 콜이 실패하지 않은 경우에는 &lt;em&gt;error_callback&lt;/em&gt; 이 대신 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="926477b21383aa762abee37a66c366b4fc577527" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cancel_futures&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, this method will cancel all pending futures that the executor has not started running. Any futures that are completed or running won&amp;rsquo;t be cancelled, regardless of the value of &lt;em&gt;cancel_futures&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;cancel_futures가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; ,이 방법은 실행 프로그램 실행 시작되지 않았 음을 보류중인 모든 선물을 취소합니다. 완료되었거나 실행중인 모든 선물은 &lt;em&gt;cancel_futures&lt;/em&gt; 의 값에 관계없이 취소되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3329be05687a53fb5199343c2abf71b394411819" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the redirection of warnings to the logging system will stop, and warnings will be redirected to their original destinations (i.e. those in effect before &lt;code&gt;captureWarnings(True)&lt;/code&gt; was called).</source>
          <target state="translated">&lt;em&gt;capture&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 로깅 시스템으로의 경고 리디렉션이 중지되고 경고는 원래 대상 (즉, &lt;code&gt;captureWarnings(True)&lt;/code&gt; 이 호출 되기 전에 유효한 대상)으로 리디렉션됩니다 .</target>
        </trans-unit>
        <trans-unit id="73194c77e6fb03e0903f0813816661b5e4e396b1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, warnings issued by the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module will be redirected to the logging system. Specifically, a warning will be formatted using &lt;a href=&quot;warnings#warnings.formatwarning&quot;&gt;&lt;code&gt;warnings.formatwarning()&lt;/code&gt;&lt;/a&gt; and the resulting string logged to a logger named &lt;code&gt;'py.warnings'&lt;/code&gt; with a severity of &lt;code&gt;WARNING&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;캡처&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈에서 발행 한 경고 는 로깅 시스템으로 리디렉션됩니다. 특히 경고는 &lt;a href=&quot;warnings#warnings.formatwarning&quot;&gt; &lt;code&gt;warnings.formatwarning()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 결과 문자열 은 심각도가 &lt;code&gt;WARNING&lt;/code&gt; 인 &lt;code&gt;'py.warnings'&lt;/code&gt; 라는 로거에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f69f734be44d12f98816d1aeb3d6e28ef2ec1b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;capture_output&lt;/em&gt; is true, stdout and stderr will be captured. When used, the internal &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; object is automatically created with &lt;code&gt;stdout=PIPE&lt;/code&gt; and &lt;code&gt;stderr=PIPE&lt;/code&gt;. The &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; arguments may not be supplied at the same time as &lt;em&gt;capture_output&lt;/em&gt;. If you wish to capture and combine both streams into one, use &lt;code&gt;stdout=PIPE&lt;/code&gt; and &lt;code&gt;stderr=STDOUT&lt;/code&gt; instead of &lt;em&gt;capture_output&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;capture_output는&lt;/em&gt; 사실, 표준 출력 및 표준 오류가 캡처됩니다. 사용될 때 내부 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 오브젝트는 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 &lt;code&gt;stderr=PIPE&lt;/code&gt; 로 자동 작성됩니다 . &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러&lt;/em&gt; 인수와 동시에 공급되지 않을 수 있습니다 &lt;em&gt;capture_output&lt;/em&gt; . 두 스트림을 모두 캡처하여 하나로 결합하려면 &lt;em&gt;capture_output&lt;/em&gt; 대신 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 &lt;code&gt;stderr=STDOUT&lt;/code&gt; 을 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="91d8516461260217396c41f9b221cbdb1d7bcd25" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;chain&lt;/em&gt; is not &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;__cause__&lt;/code&gt; and &lt;code&gt;__context__&lt;/code&gt; will not be formatted.</source>
          <target state="translated">경우 &lt;em&gt;체인이&lt;/em&gt; 없는 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;__cause__&lt;/code&gt; 및 &lt;code&gt;__context__&lt;/code&gt; 는 포맷되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac90c4494a891aa8301770b24d249be59f8193e9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;charset&lt;/em&gt; is provided (which is valid only for &lt;code&gt;str&lt;/code&gt;), encode the string to bytes using the specified character set. The default is &lt;code&gt;utf-8&lt;/code&gt;. If the specified &lt;em&gt;charset&lt;/em&gt; is a known alias for a standard MIME charset name, use the standard charset instead.</source>
          <target state="translated">&lt;em&gt;문자 세트&lt;/em&gt; 가 제공되는 경우 ( &lt;code&gt;str&lt;/code&gt; 에만 유효 ) 지정된 문자 세트를 사용하여 문자열을 바이트로 인코딩하십시오. 기본값은 &lt;code&gt;utf-8&lt;/code&gt; 입니다. 지정된 &lt;em&gt;문자 세트&lt;/em&gt; 가 표준 MIME 문자 세트 이름의 알려진 별명 인 경우 표준 문자 세트를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="76ebf40876e36c44c7a4a24267a19bbe7cda5256" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check&lt;/em&gt; is true, and the process exits with a non-zero exit code, a &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt;&lt;code&gt;CalledProcessError&lt;/code&gt;&lt;/a&gt; exception will be raised. Attributes of that exception hold the arguments, the exit code, and stdout and stderr if they were captured.</source>
          <target state="translated">경우 &lt;em&gt;검사가&lt;/em&gt; 사실이고, 0이 아닌 종료 코드와 함께 프로세스가 종료하는 &lt;a href=&quot;#subprocess.CalledProcessError&quot;&gt; &lt;code&gt;CalledProcessError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생합니다. 해당 예외의 속성은 인수, 종료 코드 및 stdout 및 stderr이 캡처 된 경우 보유합니다.</target>
        </trans-unit>
        <trans-unit id="3067072fcca20de243ec4fbab69b95d01e9a85a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check_circular&lt;/em&gt; is false (default: &lt;code&gt;True&lt;/code&gt;), then the circular reference check for container types will be skipped and a circular reference will result in an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; (or worse).</source>
          <target state="translated">경우 &lt;em&gt;check_circular가&lt;/em&gt; 거짓 (기본값 :은 &lt;code&gt;True&lt;/code&gt; )이면 컨테이너 타입 원형 기준 검사 건너 뛰고 순환 참조가 될 것이다 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; (또는 악화).</target>
        </trans-unit>
        <trans-unit id="506ca45692a2977cbc33f7b00103c60271d4b598" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;check_circular&lt;/em&gt; is true (the default), then lists, dicts, and custom encoded objects will be checked for circular references during encoding to prevent an infinite recursion (which would cause an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;). Otherwise, no such check takes place.</source>
          <target state="translated">경우 &lt;em&gt;check_circular가&lt;/em&gt; true (디폴트), 다음 목록, dicts 및 사용자 정의 인코딩 된 객체 (AN 원인이되는 무한 재귀를 방지하기 위해 인코딩하는 동안 순환 참조를 검사합니다 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 을&lt;/a&gt; ). 그렇지 않으면 그러한 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29652dd7c4e96908711afe7bf508091b6dae2068" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cid&lt;/em&gt; is specified, add a &lt;em&gt;Content-ID&lt;/em&gt; header with &lt;em&gt;cid&lt;/em&gt; as its value.</source>
          <target state="translated">경우 &lt;em&gt;CID가&lt;/em&gt; 지정하는 추가 &lt;em&gt;컨텐츠 ID&lt;/em&gt; 와 헤더를 &lt;em&gt;CID&lt;/em&gt; 값으로.</target>
        </trans-unit>
        <trans-unit id="575fcd59aad367b156b538716b2f3891b088a393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;clear&lt;/em&gt; is true then the dictionary will be cleared before the new values are set.</source>
          <target state="translated">경우 &lt;em&gt;분명이&lt;/em&gt; 사실 새 값을 설정하기 전에 다음 사전은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5d45120b80df607441d6ca3435c79fa5678f78f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;close_fds&lt;/em&gt; is true, all file descriptors except &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt; will be closed before the child process is executed. Otherwise when &lt;em&gt;close_fds&lt;/em&gt; is false, file descriptors obey their inheritable flag as described in &lt;a href=&quot;os#fd-inheritance&quot;&gt;Inheritance of File Descriptors&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;close_fds는&lt;/em&gt; 사실이다 제외한 모든 파일 디스크립터 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;2&lt;/code&gt; 는 자식 프로세스가 실행되기 전에 종료됩니다. 그렇지 않은 경우 &lt;em&gt;close_fds이&lt;/em&gt; 거짓에 설명 된대로, 파일 기술자는 상속 플래그를 순종하는 &lt;a href=&quot;os#fd-inheritance&quot;&gt;파일 기술자의 상속&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b29d4c51339df497f6673dde2e116862b6acefa2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;closefd&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and a file descriptor rather than a filename was given, the underlying file descriptor will be kept open when the file is closed. If a filename is given &lt;em&gt;closefd&lt;/em&gt; must be &lt;code&gt;True&lt;/code&gt; (the default) otherwise an error will be raised.</source>
          <target state="translated">경우 &lt;em&gt;closefd이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 과 파일 기술자가 아닌 파일 이름이 부여 된 파일을 닫을 때, 기본 파일 기술자가 열려 유지됩니다. 파일 이름이 &lt;em&gt;closefd이면 &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; (기본값) 여야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2066d93e3b1d41752de819f855fa84984bfaf655" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;column&lt;/em&gt; is specified, returns the bounding box of that cell. If the &lt;em&gt;item&lt;/em&gt; is not visible (i.e., if it is a descendant of a closed item or is scrolled offscreen), returns an empty string.</source>
          <target state="translated">경우 &lt;em&gt;열이&lt;/em&gt; 지정되어, 해당 셀의 경계 상자를 반환합니다. 경우 &lt;em&gt;항목이&lt;/em&gt; 표시되지 않습니다 (이 폐쇄 된 항목의 하위 또는 오프 스크린을 스크롤하는 경우 즉,), 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0213da647cc77316ae40d8c30349f6bd76c97885" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;context&lt;/em&gt; is specified, it must be a &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; instance describing the various SSL options. See &lt;a href=&quot;http.client#http.client.HTTPSConnection&quot;&gt;&lt;code&gt;HTTPSConnection&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">경우 &lt;em&gt;컨텍스트가&lt;/em&gt; 지정되어, 그것은해야합니다 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 의&lt;/a&gt; 다양한 SSL 옵션을 설명하는 예. 자세한 내용은 &lt;a href=&quot;http.client#http.client.HTTPSConnection&quot;&gt; &lt;code&gt;HTTPSConnection&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7608590b57586e180487b61183db6caeedb6256" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;convert_charrefs&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), all character references (except the ones in &lt;code&gt;script&lt;/code&gt;/&lt;code&gt;style&lt;/code&gt; elements) are automatically converted to the corresponding Unicode characters.</source>
          <target state="translated">경우 &lt;em&gt;convert_charrefs가&lt;/em&gt; 있습니다 &lt;code&gt;True&lt;/code&gt; (기본), (에서 제외한 모든 문자 참조 &lt;code&gt;script&lt;/code&gt; / &lt;code&gt;style&lt;/code&gt; 요소)가 자동으로 해당 유니 코드 문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="6de5e65f0ef648a4c375cfaa4c0d9dd995bb3618" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;copy_function&lt;/em&gt; is given, it must be a callable that takes two arguments &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt;, and will be used to copy &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; if &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; cannot be used. If the source is a directory, &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; is called, passing it the &lt;code&gt;copy_function()&lt;/code&gt;. The default &lt;em&gt;copy_function&lt;/em&gt; is &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt;. Using &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; as the &lt;em&gt;copy_function&lt;/em&gt; allows the move to succeed when it is not possible to also copy the metadata, at the expense of not copying any of the metadata.</source>
          <target state="translated">경우 &lt;em&gt;copy_function이&lt;/em&gt; 주어집니다, 두 개의 인수 소요하는 호출해야 &lt;em&gt;SRC&lt;/em&gt; 와 &lt;em&gt;DST를&lt;/em&gt; , 복사하는 데 사용됩니다 &lt;em&gt;SRC를&lt;/em&gt; 에 &lt;em&gt;이명 령&lt;/em&gt; 경우 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 사용할 수 없습니다. 소스가 디렉토리 인 경우, &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 그것에게 전달이라고 &lt;code&gt;copy_function()&lt;/code&gt; . 기본 &lt;em&gt;copy_function&lt;/em&gt; 은 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 입니다. &lt;em&gt;copy_function&lt;/em&gt; 으로 &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 를 사용 하면 메타 데이터를 복사하지 않고 메타 데이터를 복사 할 수없는 경우에도 이동에 성공할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf30482a1cb319bb4547b70cb32a2c3b05801150" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;copy_function&lt;/em&gt; is given, it must be a callable that takes two arguments &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt;, and will be used to copy &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dst&lt;/em&gt; if &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; cannot be used. If the source is a directory, &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; is called, passing it the &lt;code&gt;copy_function()&lt;/code&gt;. The default &lt;em&gt;copy_function&lt;/em&gt; is &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt;. Using &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; as the &lt;em&gt;copy_function&lt;/em&gt; allows the move to succeed when it is not possible to also copy the metadata, at the expense of not copying any of the metadata.</source>
          <target state="translated">경우 &lt;em&gt;copy_function이&lt;/em&gt; 주어집니다, 두 개의 인수를 취하는 호출해야 &lt;em&gt;SRC&lt;/em&gt; 와 &lt;em&gt;DST를&lt;/em&gt; , 복사하는 데 사용됩니다 &lt;em&gt;SRC를&lt;/em&gt; 에 &lt;em&gt;DST&lt;/em&gt; 경우 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 사용할 수 없습니다. 소스가 디렉토리이면 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 가 호출되어 &lt;code&gt;copy_function()&lt;/code&gt; 전달합니다 . 기본 &lt;em&gt;copy_function&lt;/em&gt; 은 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 입니다. 사용 &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 는 AS &lt;em&gt;copy_function을&lt;/em&gt; 또한 메타 데이터의 복사하지의 비용으로 메타 데이터를 복사하는 것이 가능하지 않을 때 성공 이동을 허용한다.</target>
        </trans-unit>
        <trans-unit id="6bf033ef6d8a1bf2457829466585d1c77570d91e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;copy_function&lt;/em&gt; is given, it must be a callable that will be used to copy each file. It will be called with the source path and the destination path as arguments. By default, &lt;a href=&quot;#shutil.copy2&quot;&gt;&lt;code&gt;copy2()&lt;/code&gt;&lt;/a&gt; is used, but any function that supports the same signature (like &lt;a href=&quot;#shutil.copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt;) can be used.</source>
          <target state="translated">경우 &lt;em&gt;copy_function이&lt;/em&gt; 주어집니다, 각 파일을 복사하는 데 사용할 호출해야합니다. 소스 경로와 대상 경로를 인수로 사용하여 호출됩니다. 기본적으로 &lt;a href=&quot;#shutil.copy2&quot;&gt; &lt;code&gt;copy2()&lt;/code&gt; &lt;/a&gt; 가 사용되지만 동일한 서명을 지원하는 모든 함수 ( &lt;a href=&quot;#shutil.copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0549453cb5d46211e07003c2a7307ea21880714" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;create&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and the &lt;em&gt;dirname&lt;/em&gt; path exists, it will be treated as an existing maildir without attempting to verify its directory layout.</source>
          <target state="translated">경우 &lt;em&gt;만들&lt;/em&gt; 것입니다 &lt;code&gt;True&lt;/code&gt; 하고 &lt;em&gt;있는 dirname의&lt;/em&gt; 경로가 존재, 그것의 디렉토리 레이아웃을 확인하기 위해 시도하지 않고 기존 MAILDIR로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="8898e2cfb55415011220e6c35dcb72cd30c93364" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cte&lt;/em&gt; is set, encode the payload using the specified content transfer encoding, and set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header to that value. Possible values for &lt;em&gt;cte&lt;/em&gt; are &lt;code&gt;quoted-printable&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;7bit&lt;/code&gt;, &lt;code&gt;8bit&lt;/code&gt;, and &lt;code&gt;binary&lt;/code&gt;. If the input cannot be encoded in the specified encoding (for example, specifying a &lt;em&gt;cte&lt;/em&gt; of &lt;code&gt;7bit&lt;/code&gt; for an input that contains non-ASCII values), raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;cte&lt;/em&gt; 가 설정된 경우 지정된 컨텐츠 전송 인코딩을 사용하여 페이로드를 인코딩하고 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 해당 값으로 설정하십시오. &lt;em&gt;cte에&lt;/em&gt; 가능한 값 은 &lt;code&gt;quoted-printable&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;7bit&lt;/code&gt; , &lt;code&gt;8bit&lt;/code&gt; 및 &lt;code&gt;binary&lt;/code&gt; 입니다. 입력은 (a 지정, 예를 들어 지정된 인코딩으로 인코딩 될 수없는 경우 &lt;em&gt;CTE&lt;/em&gt; 의 &lt;code&gt;7bit&lt;/code&gt; 비 ASCII 값을 포함하는 입력) 인상 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ac96e90d352b33de98fd5ace363c0516fa39090" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cumulative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, cumulate size and count of memory blocks of all frames of the traceback of a trace, not only the most recent frame. The cumulative mode can only be used with &lt;em&gt;key_type&lt;/em&gt; equals to &lt;code&gt;'filename'&lt;/code&gt; and &lt;code&gt;'lineno'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;cumulative&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 가장 최근의 프레임뿐만 아니라 트레이스의 트레이스 백에 대한 모든 프레임의 메모리 블록 수와 크기를 계산합니다. 누적 모드는 &lt;em&gt;key_type&lt;/em&gt; 이 &lt;code&gt;'filename'&lt;/code&gt; 및 &lt;code&gt;'lineno'&lt;/code&gt; 와 함께 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eacfbd2cb2014105749c4358d998bb8bd55cbab6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;current_offset&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it refers to an instruction offset in the disassembled code. Setting this means &lt;a href=&quot;#dis.Bytecode.dis&quot;&gt;&lt;code&gt;dis()&lt;/code&gt;&lt;/a&gt; will display a &amp;ldquo;current instruction&amp;rdquo; marker against the specified opcode.</source>
          <target state="translated">&lt;em&gt;current_offset&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 디스 어셈블 된 코드의 명령어 오프셋을 나타냅니다. 이를 설정하면 &lt;a href=&quot;#dis.Bytecode.dis&quot;&gt; &lt;code&gt;dis()&lt;/code&gt; &lt;/a&gt; 는 지정된 opcode에 대해 &quot;현재 명령&quot;마커를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b5d4c33f63f2f37671afb0edc3a13524b04cb537" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cwd&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the function changes the working directory to &lt;em&gt;cwd&lt;/em&gt; before executing the child. &lt;em&gt;cwd&lt;/em&gt; can be a string, bytes or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object. In particular, the function looks for &lt;em&gt;executable&lt;/em&gt; (or for the first item in &lt;em&gt;args&lt;/em&gt;) relative to &lt;em&gt;cwd&lt;/em&gt; if the executable path is a relative path.</source>
          <target state="translated">&lt;em&gt;cwd&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 함수 는 하위를 실행하기 전에 작업 디렉토리를 &lt;em&gt;cwd로&lt;/em&gt; 변경합니다 . &lt;em&gt;cwd&lt;/em&gt; 는 문자열, 바이트 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한&lt;/a&gt; 객체 일 수 있습니다. 특히 함수는 실행 경로가 상대 경로 인 경우 &lt;em&gt;cwd를&lt;/em&gt; 기준으로 &lt;em&gt;실행 파일&lt;/em&gt; (또는 &lt;em&gt;args&lt;/em&gt; 의 첫 번째 항목)을 찾습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="92a7ab7c208d86687fece009c75e098dbaff2e60" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;cwd&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the function changes the working directory to &lt;em&gt;cwd&lt;/em&gt; before executing the child. &lt;em&gt;cwd&lt;/em&gt; can be a string, bytes or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object. In particular, the function looks for &lt;em&gt;executable&lt;/em&gt; (or for the first item in &lt;em&gt;args&lt;/em&gt;) relative to &lt;em&gt;cwd&lt;/em&gt; if the executable path is a relative path.</source>
          <target state="translated">경우 &lt;em&gt;CWD가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , 함수에 대한 작업 디렉토리 변경 &lt;em&gt;CWD를&lt;/em&gt; 아이를 실행하기 전에. &lt;em&gt;cwd&lt;/em&gt; 는 문자열, 바이트 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;경로 류&lt;/a&gt; 객체 일 수 있습니다. 특히, 함수는 실행 가능 경로가 상대 경로 인 경우 &lt;em&gt;cwd에&lt;/em&gt; 상대적인 &lt;em&gt;실행 파일&lt;/em&gt; (또는 &lt;em&gt;args&lt;/em&gt; 의 첫 번째 항목)을 찾습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="abe309a388dca84dd7a05e235de450c0f31358b8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;d&lt;/em&gt; is aware, &lt;em&gt;d&lt;/em&gt; is normalized to UTC time, by subtracting &lt;code&gt;d.utcoffset()&lt;/code&gt;, and a &lt;a href=&quot;time#time.struct_time&quot;&gt;&lt;code&gt;time.struct_time&lt;/code&gt;&lt;/a&gt; for the normalized time is returned. &lt;code&gt;tm_isdst&lt;/code&gt; is forced to 0. Note that an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; may be raised if &lt;em&gt;d&lt;/em&gt;.year was &lt;code&gt;MINYEAR&lt;/code&gt; or &lt;code&gt;MAXYEAR&lt;/code&gt; and UTC adjustment spills over a year boundary.</source>
          <target state="translated">경우 &lt;em&gt;d는&lt;/em&gt; 인식, &lt;em&gt;D는&lt;/em&gt; 감산하여, UTC 시간으로 정규화 &lt;code&gt;d.utcoffset()&lt;/code&gt; , 및 &lt;a href=&quot;time#time.struct_time&quot;&gt; &lt;code&gt;time.struct_time&lt;/code&gt; &lt;/a&gt; 정규화 시간을 반환한다. &lt;code&gt;tm_isdst&lt;/code&gt; 는 0으로 설정 됩니다. &lt;em&gt;d&lt;/em&gt; .year가 &lt;code&gt;MINYEAR&lt;/code&gt; 또는 &lt;code&gt;MAXYEAR&lt;/code&gt; 이고 UTC 조정이 1 년 동안 유출 되면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="412f0af923015004c94c91a0798c5634f520a8c3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is empty, &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 비어 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1bd76e6354043e84cab72b15b26a288207008710" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is the concatenation of multiple compressed streams, decompress all of the streams.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 여러 압축 스트림의 연결은, 모든 스트림을 압축 해제.</target>
        </trans-unit>
        <trans-unit id="9dbf42aa701352d3426aa0b9e6d8ce207f8e0f9c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is the concatenation of multiple distinct compressed streams, decompress all of these streams, and return the concatenation of the results.</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 여러 별개의 압축 스트림을 연결 한 다음 모든 스트림을 압축 해제하고, 그 결과의 연결을 반환한다.</target>
        </trans-unit>
        <trans-unit id="3efb743eb6b84a13ce1c37d5a413fec15e776cc1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ddir&lt;/em&gt; is given, it is prepended to the path to each file being compiled for use in compilation time tracebacks, and is also compiled in to the byte-code file, where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed.</source>
          <target state="translated">경우 &lt;em&gt;ddir이&lt;/em&gt; 주어집니다, 컴파일 시간을 역 추적에 사용하기 위해 컴파일되는 각 파일의 경로 앞에 추가되며, 또한이 경우 역 추적 및 기타 메시지에서 사용되는 바이트 코드 파일, 소스를 컴파일한다 바이트 코드 파일이 실행될 때 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0eb4f5a84f724ffad64d00f6c44b99d63a5274b2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ddir&lt;/em&gt; is given, it is prepended to the path to the file being compiled for use in compilation time tracebacks, and is also compiled in to the byte-code file, where it will be used in tracebacks and other messages in cases where the source file does not exist at the time the byte-code file is executed.</source>
          <target state="translated">경우 &lt;em&gt;ddir이&lt;/em&gt; 주어집니다, 컴파일 시간을 역 추적에 사용하기 위해 컴파일되는 파일의 경로 앞에 추가되며, 또한이 경우 역 추적 및 기타 메시지에서 사용되는 바이트 코드 파일, 소스를 컴파일한다 바이트 코드 파일이 실행될 때 파일이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4c4d1acb8ff67a497d8ef936eb0e07f0337e4c2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;debug&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the event loop will be run in debug mode.</source>
          <target state="translated">경우 &lt;em&gt;디버그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 이벤트 루프는 디버그 모드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="475c14c8e2569012dc880a97fd4fa51777aa405a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;default_pip&lt;/em&gt; is set, then &lt;code&gt;pip&lt;/code&gt; will be installed in addition to the two regular scripts.</source>
          <target state="translated">경우 &lt;em&gt;default_pip가&lt;/em&gt; 설정되어, 다음 &lt;code&gt;pip&lt;/code&gt; 두 개의 일반 스크립트에 추가로 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="1c8c126e6c7b0f2e8bd2913dccf7f6d01c5144a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;delay&lt;/em&gt; is true, then file opening is deferred until the first call to &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler.emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;지연&lt;/em&gt; 에 해당하는 다음 파일 개구는 첫 번째 호출까지 지연되는 &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler.emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0056a36933eb229c50c4c08ad60c4c6100860930" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;delta&lt;/em&gt; is supplied instead of &lt;em&gt;places&lt;/em&gt; then the difference between &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; must be less or equal to (or greater than) &lt;em&gt;delta&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;장소&lt;/em&gt; 대신 &lt;em&gt;델타&lt;/em&gt; 가 제공되는 경우 &lt;em&gt;first&lt;/em&gt; 와 &lt;em&gt;second&lt;/em&gt; 의 차이는 &lt;em&gt;delta&lt;/em&gt; 보다 작거나 같아야합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c3e614afb3a12f1f008bd5a8a6fdbe9c09e6230" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dereference&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, add symbolic and hard links to the archive. If it is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, add the content of the target files to the archive. This has no effect on systems that do not support symbolic links.</source>
          <target state="translated">경우 &lt;em&gt;역 참조&lt;/em&gt; 입니다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 아카이브에 대한 기호 및 하드 링크를 추가 할 수 있습니다. 이 경우 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; , 아카이브에 대상 파일의 내용을 추가합니다. 이는 심볼릭 링크를 지원하지 않는 시스템에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89e297698f3919befb6ad412d44099f294057f3e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dir&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file will be created in that directory; otherwise, a default directory is used. The default directory is chosen from a platform-dependent list, but the user of the application can control the directory location by setting the &lt;em&gt;TMPDIR&lt;/em&gt;, &lt;em&gt;TEMP&lt;/em&gt; or &lt;em&gt;TMP&lt;/em&gt; environment variables. There is thus no guarantee that the generated filename will have any nice properties, such as not requiring quoting when passed to external commands via &lt;code&gt;os.popen()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;dir&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일은 해당 디렉토리에 작성됩니다. 그렇지 않으면 기본 디렉토리가 사용됩니다. 기본 디렉토리는 플랫폼 종속 목록에서 선택되지만 애플리케이션 사용자는 &lt;em&gt;TMPDIR&lt;/em&gt; , &lt;em&gt;TEMP&lt;/em&gt; 또는 &lt;em&gt;TMP&lt;/em&gt; 환경 변수 를 설정하여 디렉토리 위치를 제어 할 수 있습니다 . 따라서 생성 된 파일 이름에 &lt;code&gt;os.popen()&lt;/code&gt; 통해 외부 명령에 전달 될 때 인용 할 필요가없는 것과 같은 멋진 속성이 있다는 보장은 없습니다 .</target>
        </trans-unit>
        <trans-unit id="36e5a4ee826ffb2f15f36ae09720b225045e3a17" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dirname&lt;/em&gt; is a string, a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; finder is created that searches that directory. If &lt;em&gt;dirname&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; finder is created that searches the current &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;, plus any modules that are frozen or built-in.</source>
          <target state="translated">경우 &lt;em&gt;dirname은이&lt;/em&gt; 문자열 인하는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 파인더는 검색 디렉토리를 생성됩니다. 경우 &lt;em&gt;이 dirname이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 하는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; 파인더가 생성되는 검색 현재 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에&lt;/a&gt; 플러스 냉동 또는 내장 된 모든 모듈.</target>
        </trans-unit>
        <trans-unit id="551154ba8498eafba8ea7b74270354b26c0ca404" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;disposition&lt;/em&gt; is set, use it as the value of the &lt;em&gt;Content-Disposition&lt;/em&gt; header. If not specified, and &lt;em&gt;filename&lt;/em&gt; is specified, add the header with the value &lt;code&gt;attachment&lt;/code&gt;. If &lt;em&gt;disposition&lt;/em&gt; is not specified and &lt;em&gt;filename&lt;/em&gt; is also not specified, do not add the header. The only valid values for &lt;em&gt;disposition&lt;/em&gt; are &lt;code&gt;attachment&lt;/code&gt; and &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;배치가&lt;/em&gt; 설정되면, 값으로 사용 &lt;em&gt;내용 - 처리&lt;/em&gt; 헤더. 지정되지 않고 &lt;em&gt;파일 이름&lt;/em&gt; 이 지정되면 값이 &lt;code&gt;attachment&lt;/code&gt; 인 헤더를 추가하십시오 . 경우 &lt;em&gt;처분이&lt;/em&gt; 지정되지 않고 &lt;em&gt;파일 이름&lt;/em&gt; 도 지정되지 않은 헤더를 추가하지 마십시오. &lt;em&gt;적절한 처분&lt;/em&gt; 값 은 &lt;code&gt;attachment&lt;/code&gt; 및 &lt;code&gt;inline&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="22732b32fe6ac6ba02ba73f066c5867ab756d641" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dnd_accept&lt;/em&gt; is not present or returns None, search moves to parent widget</source>
          <target state="translated">경우 &lt;em&gt;dnd_accept가&lt;/em&gt; 존재하지 않거나 None을 돌려, 부모 위젯으로 이동 검색</target>
        </trans-unit>
        <trans-unit id="2ec590024eac4ba112689a063f854bf9db2f78c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dry_run&lt;/em&gt; is true, no archive is created, but the operations that would be executed are logged to &lt;em&gt;logger&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;dry_run는&lt;/em&gt; 사실, 더 아카이브가 생성되지 않지만, 실행되는 것이 작업에 기록 &lt;em&gt;로거&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="94267f95134956d72ce6e87e0afa84eedaad7aa3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dualstack_ipv6&lt;/em&gt; is true and the platform supports it the socket will be able to accept both IPv4 and IPv6 connections, else it will raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. Most POSIX platforms and Windows are supposed to support this functionality. When this functionality is enabled the address returned by &lt;a href=&quot;#socket.socket.getpeername&quot;&gt;&lt;code&gt;socket.getpeername()&lt;/code&gt;&lt;/a&gt; when an IPv4 connection occurs will be an IPv6 address represented as an IPv4-mapped IPv6 address. If &lt;em&gt;dualstack_ipv6&lt;/em&gt; is false it will explicitly disable this functionality on platforms that enable it by default (e.g. Linux). This parameter can be used in conjunction with &lt;a href=&quot;#socket.has_dualstack_ipv6&quot;&gt;&lt;code&gt;has_dualstack_ipv6()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우 &lt;em&gt;dualstack_ipv6이&lt;/em&gt; 사실과 플랫폼을 지원하는 소켓이 모두 IPv4 및 IPv6 연결을 받아 들일 수있을 것입니다, 다른 사람이 인상됩니다 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; . 대부분의 POSIX 플랫폼과 Windows는이 기능을 지원해야합니다. 이 기능이 활성화 되면 IPv4 연결이 발생할 때 &lt;a href=&quot;#socket.socket.getpeername&quot;&gt; &lt;code&gt;socket.getpeername()&lt;/code&gt; &lt;/a&gt; 반환 한 주소는 IPv4 매핑 된 IPv6 주소로 표시되는 IPv6 주소가됩니다. 경우 &lt;em&gt;dualstack_ipv6이&lt;/em&gt; 거짓 명시 적으로 기본 (예를 들어, 리눅스)에 의해 활성화 플랫폼에서이 기능을 비활성화합니다. 이 매개 변수는 &lt;a href=&quot;#socket.has_dualstack_ipv6&quot;&gt; &lt;code&gt;has_dualstack_ipv6()&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9581453393604a0750f4d82252f2e5cd9d18898" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;duplex&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then the pipe is bidirectional. If &lt;em&gt;duplex&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then the pipe is unidirectional: &lt;code&gt;conn1&lt;/code&gt; can only be used for receiving messages and &lt;code&gt;conn2&lt;/code&gt; can only be used for sending messages.</source>
          <target state="translated">경우 &lt;em&gt;양면&lt;/em&gt; 이다 &lt;code&gt;True&lt;/code&gt; (기본값) 다음 파이프는 양방향입니다. 경우 &lt;em&gt;양면&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 그 파이프는 단방향 : &lt;code&gt;conn1&lt;/code&gt; 이라는이 메시지 만 수신 사용할 수 있으며 &lt;code&gt;conn2&lt;/code&gt; 메시지 만 보내는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99baa917d4196e3d9a478f232fed0c3fe22f8f57" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;effective_ids&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#os.access&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt; will perform its access checks using the effective uid/gid instead of the real uid/gid. &lt;em&gt;effective_ids&lt;/em&gt; may not be supported on your platform; you can check whether or not it is available using &lt;a href=&quot;#os.supports_effective_ids&quot;&gt;&lt;code&gt;os.supports_effective_ids&lt;/code&gt;&lt;/a&gt;. If it is unavailable, using it will raise a &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;effective_ids가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#os.access&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; 유효 UID / GID 대신 실제의 UID / GID를 사용하여 액세스 검사를 수행합니다. 플랫폼에서 &lt;em&gt;effective_ids&lt;/em&gt; 가 지원되지 않을 수 있습니다. &lt;a href=&quot;#os.supports_effective_ids&quot;&gt; &lt;code&gt;os.supports_effective_ids&lt;/code&gt; 를&lt;/a&gt; 사용하여 사용 가능한지 여부를 확인할 수 있습니다 . 사용할 수 없으면 사용하면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="607534724be78a927f3354c8bcd6f86f04925384" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encode_chunked&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the result of each iteration of &lt;em&gt;message_body&lt;/em&gt; will be chunk-encoded as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt;, Section 3.3.1. How the data is encoded is dependent on the type of &lt;em&gt;message_body&lt;/em&gt;. If &lt;em&gt;message_body&lt;/em&gt; implements the &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; the encoding will result in a single chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt;&lt;code&gt;collections.abc.Iterable&lt;/code&gt;&lt;/a&gt;, each iteration of &lt;em&gt;message_body&lt;/em&gt; will result in a chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, each call to &lt;code&gt;.read()&lt;/code&gt; will result in a chunk. The method automatically signals the end of the chunk-encoded data immediately after &lt;em&gt;message_body&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;encode_chunked가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 각 반복의 결과 &lt;em&gt;MESSAGE_BODY은&lt;/em&gt; 청크 인코딩에 규정 된 것 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt; , 3.3.1 절. 데이터가 인코딩되는 방식은 &lt;em&gt;message_body&lt;/em&gt; 유형에 따라 다릅니다 . 경우 &lt;em&gt;MESSAGE_BODY&lt;/em&gt; 구현하는 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;인터페이스 버퍼&lt;/a&gt; 인코딩은 단일 청크 될 것이다. 경우 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; A는 &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt; &lt;code&gt;collections.abc.Iterable&lt;/code&gt; &lt;/a&gt; 의 각 반복 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; 덩어리가 발생합니다. &lt;em&gt;message_body&lt;/em&gt; 가 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 인 경우 &lt;code&gt;.read()&lt;/code&gt; 호출 할 때마다청크가 발생합니다. 이 메소드는 &lt;em&gt;message_body&lt;/em&gt; 바로 뒤에 청크 인코딩 된 데이터의 끝을 자동으로 알립니다 .</target>
        </trans-unit>
        <trans-unit id="7faf6374bee803b26834d04a5420d6f0d4969007" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encode_chunked&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the result of each iteration of &lt;em&gt;message_body&lt;/em&gt; will be chunk-encoded as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt;, Section 3.3.1. How the data is encoded is dependent on the type of &lt;em&gt;message_body&lt;/em&gt;. If &lt;em&gt;message_body&lt;/em&gt; implements the &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; the encoding will result in a single chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt;&lt;code&gt;collections.abc.Iterable&lt;/code&gt;&lt;/a&gt;, each iteration of &lt;em&gt;message_body&lt;/em&gt; will result in a chunk. If &lt;em&gt;message_body&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, each call to &lt;code&gt;.read()&lt;/code&gt; will result in a chunk. The method automatically signals the end of the chunk-encoded data immediately after &lt;em&gt;message_body&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;encode_chunked가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 각 반복의 결과 &lt;em&gt;MESSAGE_BODY은&lt;/em&gt; 청크 인코딩에 규정 된 것 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 7230&lt;/strong&gt;&lt;/a&gt; , 3.3.1 절. 데이터 인코딩 방법은 &lt;em&gt;message_body&lt;/em&gt; 유형에 따라 다릅니다 . 경우 &lt;em&gt;MESSAGE_BODY&lt;/em&gt; 구현하는 &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;인터페이스 버퍼&lt;/a&gt; 인코딩은 단일 청크 될 것이다. 경우 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; A는 &lt;a href=&quot;collections.abc#collections.abc.Iterable&quot;&gt; &lt;code&gt;collections.abc.Iterable&lt;/code&gt; &lt;/a&gt; 의 각 반복 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; 덩어리가 발생합니다. 경우 &lt;em&gt;MESSAGE_BODY는&lt;/em&gt; A는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체가&lt;/a&gt; , 각 호출하기 &lt;code&gt;.read()&lt;/code&gt; 청크가 생성됩니다. 이 메서드는 &lt;em&gt;message_body&lt;/em&gt; 직후에 청크 인코딩 된 데이터의 끝을 자동으로 알립니다 .</target>
        </trans-unit>
        <trans-unit id="7edf08fcadb288478ca315f1c2600e7b135a30a9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; (also known as &lt;em&gt;universal_newlines&lt;/em&gt;) is true, the file objects &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; will be opened in text mode using the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; specified in the call or the defaults for &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정, 또는 &lt;em&gt;텍스트&lt;/em&gt; (로도 알려져 &lt;em&gt;universal_newlines 것은&lt;/em&gt; ) 사실, 파일은 객체 &lt;em&gt;표준 입력&lt;/em&gt; , &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러는&lt;/em&gt; 사용하여 텍스트 모드에서 열립니다 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 호출에 지정된 또는에 대한 기본값 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="699e55008224a367497000a7c90840cae537dfba" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; is true, file objects for stdin, stdout and stderr are opened in text mode using the specified &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; or the &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; default. The &lt;em&gt;universal_newlines&lt;/em&gt; argument is equivalent to &lt;em&gt;text&lt;/em&gt; and is provided for backwards compatibility. By default, file objects are opened in binary mode.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정하거나 &lt;em&gt;텍스트가&lt;/em&gt; 사실, 파일은 표준 입력, 표준 출력을 위해 개체 및 stderr 지정된 사용하여 텍스트 모드에서 열립니다 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 또는 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 의&lt;/a&gt; 기본. &lt;em&gt;universal_newlines의&lt;/em&gt; 인수에 해당 &lt;em&gt;텍스트&lt;/em&gt; 및 이전 버전과의 호환성을 위해 제공됩니다. 기본적으로 파일 객체는 이진 모드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="52638c3e8d67fa2ec0fd557d0879c7a9e57eca8b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; are specified, or &lt;em&gt;text&lt;/em&gt; is true, the file objects &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; are opened in text mode with the specified encoding and &lt;em&gt;errors&lt;/em&gt;, as described above in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt;. The &lt;em&gt;universal_newlines&lt;/em&gt; argument is equivalent to &lt;em&gt;text&lt;/em&gt; and is provided for backwards compatibility. By default, file objects are opened in binary mode.</source>
          <target state="translated">경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류가&lt;/em&gt; 지정하거나 &lt;em&gt;텍스트가&lt;/em&gt; 사실, 파일 객체 &lt;em&gt;표준 입력&lt;/em&gt; , &lt;em&gt;표준 출력&lt;/em&gt; 및 &lt;em&gt;표준 오류는&lt;/em&gt; 지정된 인코딩과 함께 텍스트 모드에서 열립니다 &lt;em&gt;오류&lt;/em&gt; 에 전술 한 바와 같이, &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용하는 인수&lt;/a&gt; . &lt;em&gt;universal_newlines의&lt;/em&gt; 인수에 해당 &lt;em&gt;텍스트&lt;/em&gt; 및 이전 버전과의 호환성을 위해 제공됩니다. 기본적으로 파일 객체는 이진 모드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="63d0f1a5631a1c9c1ee3f2e8299762fd8cd8e7d4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ensure_ascii&lt;/em&gt; is true (the default), the output is guaranteed to have all incoming non-ASCII characters escaped. If &lt;em&gt;ensure_ascii&lt;/em&gt; is false, these characters will be output as-is.</source>
          <target state="translated">경우 &lt;em&gt;ensure_ascii가&lt;/em&gt; true (디폴트), 출력은 들어오는 모든 비 ASCII 문자 이스케이프이 보장됩니다. 경우 &lt;em&gt;ensure_ascii이&lt;/em&gt; 거짓-이기 때문에, 이러한 문자가 출력 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5c427089fb1de4505a7a9e6a8fc25b18c3e6e0c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;env&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a mapping that defines the environment variables for the new process; these are used instead of the default behavior of inheriting the current process&amp;rsquo; environment.</source>
          <target state="translated">&lt;em&gt;env&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 새 프로세스의 환경 변수를 정의하는 맵핑이어야합니다. 이들은 현재 프로세스 환경을 상속하는 기본 동작 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87535ea7e24348fb8f4d57c12202af9ca447538a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;env&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a mapping that defines the environment variables for the new process; these are used instead of the default behavior of inheriting the current process&amp;rsquo; environment. It is passed directly to &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;env&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 새 프로세스의 환경 변수를 정의하는 맵핑이어야합니다. 이들은 현재 프로세스 환경을 상속하는 기본 동작 대신 사용됩니다. &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; 에&lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff8cd5fc3865815194e6f233b530a23aa3eba258" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;error_callback&lt;/em&gt; is specified then it should be a callable which accepts a single argument. If the target function fails, then the &lt;em&gt;error_callback&lt;/em&gt; is called with the exception instance.</source>
          <target state="translated">&lt;em&gt;error_callback&lt;/em&gt; 이 지정 되면 단일 인수를 허용하는 호출 가능이어야합니다. 대상 함수가 실패 하면 예외 인스턴스와 함께 &lt;em&gt;error_callback&lt;/em&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a716812bb95f42a90866514c37dd0d4203eae841" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;errorlevel&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt;, all errors are ignored when using &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt;&lt;code&gt;TarFile.extract()&lt;/code&gt;&lt;/a&gt;. Nevertheless, they appear as error messages in the debug output, when debugging is enabled. If &lt;code&gt;1&lt;/code&gt;, all &lt;em&gt;fatal&lt;/em&gt; errors are raised as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions. If &lt;code&gt;2&lt;/code&gt;, all &lt;em&gt;non-fatal&lt;/em&gt; errors are raised as &lt;a href=&quot;#tarfile.TarError&quot;&gt;&lt;code&gt;TarError&lt;/code&gt;&lt;/a&gt; exceptions as well.</source>
          <target state="translated">경우 &lt;em&gt;오류 수준이&lt;/em&gt; 이다 &lt;code&gt;0&lt;/code&gt; , 모든 오류는 사용할 때 무시됩니다 &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt; &lt;code&gt;TarFile.extract()&lt;/code&gt; &lt;/a&gt; . 그럼에도 불구하고 디버깅이 활성화되면 디버그 출력에 오류 메시지로 나타납니다. &lt;code&gt;1&lt;/code&gt; 인 경우 모든 &lt;em&gt;치명적&lt;/em&gt; 오류가 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외로 발생합니다. &lt;code&gt;2&lt;/code&gt; 인 경우 &lt;em&gt;치명적이지 않은&lt;/em&gt; 모든 오류도 &lt;a href=&quot;#tarfile.TarError&quot;&gt; &lt;code&gt;TarError&lt;/code&gt; &lt;/a&gt; 예외로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e2f22ab75959b0a406d0827c55880256650c56f6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;errors&lt;/em&gt; is specified, it&amp;rsquo;s used to determine how encoding errors are handled.</source>
          <target state="translated">경우 &lt;em&gt;오류가&lt;/em&gt; 지정되어, 인코딩 오류를 처리하는 방법을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdee59d973926ccbf68873b846e74e0fc64b06e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exc_info&lt;/em&gt; does not evaluate as false, it causes exception information to be added to the logging message. If an exception tuple (in the format returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) or an exception instance is provided, it is used; otherwise, &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt; is called to get the exception information.</source>
          <target state="translated">경우 &lt;em&gt;exc_info이&lt;/em&gt; 거짓으로 평가하지 않습니다, 그것은 예외 정보 로깅 메시지에 추가됩니다. 예외 튜플 ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 형식 ) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 예외 정보를 얻기 위해 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="97d130dcbf3bae5b901a129e219774af57b99697" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exc_type&lt;/em&gt; is &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;, the exception is silently ignored. Otherwise, the exception is printed out on &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;exc_type가&lt;/em&gt; 있다 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 없이&lt;/a&gt; , 예외가 자동으로 무시됩니다. 그렇지 않으면 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt; 에 예외가 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="d411ffd6142ab0891751015edec151dc77ef2c0a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default), an &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised if the target directory already exists.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 은&lt;/a&gt; 대상 디렉토리가 이미 존재하는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2db5d05fedef1a16fd234aa31609df5c35a8e34b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is false (the default), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised if the target directory already exists.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok가&lt;/em&gt; false (기본값), &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 은&lt;/a&gt; 대상 디렉토리가 이미 존재하는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="151c18046b0057879a6273bc9b7b8b67d5a66254" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;exist_ok&lt;/em&gt; is true, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; exceptions will be ignored (same behavior as the POSIX &lt;code&gt;mkdir -p&lt;/code&gt; command), but only if the last path component is not an existing non-directory file.</source>
          <target state="translated">경우 &lt;em&gt;exist_ok는&lt;/em&gt; 사실, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 의&lt;/a&gt; 예외합니다 (POSIX와 같은 행동을 무시됩니다 &lt;code&gt;mkdir -p&lt;/code&gt; 명령을),하지만 마지막 경로 구성 요소가 기존 디렉토리가 아닌 파일이 아닌 경우에만 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3700ef2eaa5a7011d3f7e0d02c4ae3309bb21da3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expand&lt;/em&gt; is set to &lt;code&gt;False&lt;/code&gt;, the path will not be expanded using the variables.</source>
          <target state="translated">경우 &lt;em&gt;확장&lt;/em&gt; 으로 설정 &lt;code&gt;False&lt;/code&gt; , 경로 변수를 사용하여 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3d0c579641706b0f541c875d40a987796ca4535" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;expand&lt;/em&gt; is set to false, the paths will not be expanded.</source>
          <target state="translated">경우 &lt;em&gt;확장&lt;/em&gt; false로 설정, 경로가 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="327ea4efd1b1ff657d3d4e06234f91e61ded279a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;extra_groups&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the setgroups() system call will be made in the child process prior to the execution of the subprocess. Strings provided in &lt;em&gt;extra_groups&lt;/em&gt; will be looked up via &lt;a href=&quot;grp#grp.getgrnam&quot;&gt;&lt;code&gt;grp.getgrnam()&lt;/code&gt;&lt;/a&gt; and the values in &lt;code&gt;gr_gid&lt;/code&gt; will be used. Integer values will be passed verbatim. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;extra_groups가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , setgroups () 시스템 호출 전에 서브 프로세스의 실행을 자식 프로세스에서 이루어집니다. 제공 문자열 &lt;em&gt;extra_groups를&lt;/em&gt; 통해 조회한다 &lt;a href=&quot;grp#grp.getgrnam&quot;&gt; &lt;code&gt;grp.getgrnam()&lt;/code&gt; &lt;/a&gt; 및의 값 &lt;code&gt;gr_gid&lt;/code&gt; 가 사용될 것이다. 정수 값은 그대로 전달됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="950957f8e4ed1166943a35b1541f1f3253fb73bb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;factory&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; the default task factory will be set. Otherwise, &lt;em&gt;factory&lt;/em&gt; must be a &lt;em&gt;callable&lt;/em&gt; with the signature matching &lt;code&gt;(loop, coro)&lt;/code&gt;, where &lt;em&gt;loop&lt;/em&gt; is a reference to the active event loop, and &lt;em&gt;coro&lt;/em&gt; is a coroutine object. The callable must return a &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt;&lt;code&gt;asyncio.Future&lt;/code&gt;&lt;/a&gt;-compatible object.</source>
          <target state="translated">경우 &lt;em&gt;공장&lt;/em&gt; 입니다 &lt;code&gt;None&lt;/code&gt; 기본 작업 공장이 설정됩니다. 그렇지 않으면, &lt;em&gt;팩토리&lt;/em&gt; 는 서명 일치 &lt;code&gt;(loop, coro)&lt;/code&gt; 로 &lt;em&gt;호출 가능&lt;/em&gt; 해야합니다. 여기서 &lt;em&gt;loop&lt;/em&gt; 는 활성 이벤트 루프에 대한 참조이고 &lt;em&gt;coro&lt;/em&gt; 는 코 루틴 오브젝트입니다. 콜 &lt;a href=&quot;asyncio-future#asyncio.Future&quot;&gt; &lt;code&gt;asyncio.Future&lt;/code&gt; &lt;/a&gt; 은 asyncio.Future 호환 객체를 반환해야 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cde1a7a5d298627fbad97256eb936031b2f8b9e2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file&lt;/em&gt; is a string, open the file by that name, otherwise treat it as a file-like object. &lt;em&gt;mode&lt;/em&gt; can be:</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 이 문자열 인 경우 해당 이름으로 파일을 열거 나 그렇지 않으면 파일과 같은 객체로 취급하십시오. &lt;em&gt;모드&lt;/em&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="67d175cb8486589a948e2cf74ce3849b7236be76" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file&lt;/em&gt; is not specified, read from &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;파일이&lt;/em&gt; 지정되지 않은, 읽기 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49c9ed3d94894a12395907e88bfe7b2901ae44f4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file_encoding&lt;/em&gt; is not given, it defaults to &lt;em&gt;data_encoding&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;file_encoding을&lt;/em&gt; 하기 위해서는 기본적으로 제공되지 &lt;em&gt;data_encoding을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="76758843e2e5c710ae0a6372d1081e6f9d9e89c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;file_or_dir&lt;/em&gt; is a directory and not a symbolic link, then recursively descend the directory tree named by &lt;em&gt;file_or_dir&lt;/em&gt;, checking all &lt;code&gt;.py&lt;/code&gt; files along the way. If &lt;em&gt;file_or_dir&lt;/em&gt; is an ordinary Python source file, it is checked for whitespace related problems. The diagnostic messages are written to standard output using the &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;em&gt;file_or_dir&lt;/em&gt; 이 심볼릭 링크가 아닌 디렉토리 인 경우 &lt;em&gt;file_or_dir&lt;/em&gt; 로 명명 된 디렉토리 트리를 재귀 적으로 &lt;em&gt;내림차순&lt;/em&gt; 으로 모든 &lt;code&gt;.py&lt;/code&gt; 파일을 검사합니다 . 경우 &lt;em&gt;에 나오는 file_or_dir은&lt;/em&gt; 일반 파이썬 소스 파일입니다, 그것은 공백 관련 문제를 확인합니다. 진단 메시지는 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 표준 출력에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="8147d1cd319a466257a1243b03ade84b3c9e406b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filelike&lt;/em&gt; has a &lt;code&gt;close()&lt;/code&gt; method, the returned object will also have a &lt;code&gt;close()&lt;/code&gt; method, and it will invoke the &lt;em&gt;filelike&lt;/em&gt; object&amp;rsquo;s &lt;code&gt;close()&lt;/code&gt; method when called.</source>
          <target state="translated">&lt;em&gt;filelike&lt;/em&gt; 에 &lt;code&gt;close()&lt;/code&gt; 메서드 가 있으면 반환 된 객체에도 &lt;code&gt;close()&lt;/code&gt; 메서드가 있으며 호출 될 때 &lt;em&gt;파일과 같은&lt;/em&gt; 객체의 &lt;code&gt;close()&lt;/code&gt; 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="48cc1454e821d6920b8394ca56ab7ba76323cb6d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object, open the named file directly. Otherwise, &lt;em&gt;filename&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which will be used to read or write the compressed data.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름이&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 직접라는 이름의 파일을 엽니 다. 그렇지 않으면 &lt;em&gt;filename&lt;/em&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 여야하며 압축 된 데이터를 읽거나 쓰는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd79be35e2c082fb1f3647342729bedac741b12" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object, open the named file directly. Otherwise, &lt;em&gt;filename&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;, which will be used to read or write the compressed data.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름이&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 직접라는 이름의 파일을 엽니 다. 그렇지 않으면 &lt;em&gt;filename&lt;/em&gt; 은 압축 된 데이터를 읽거나 쓰는 데 사용되는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="b07d149a1e1e8508bf416df0ffabf52508cd4717" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a file object (rather than an actual file name), a mode of &lt;code&gt;&quot;w&quot;&lt;/code&gt; does not truncate the file, and is instead equivalent to &lt;code&gt;&quot;a&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 실제 파일 이름이 아닌 파일 객체 인 경우 &lt;code&gt;&quot;w&quot;&lt;/code&gt; 모드 는 파일을 자르지 않으며 대신 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1c18ac97e77df1feec965478ce33eedf1e1130a6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is a file object (rather than an actual file name), a mode of &lt;code&gt;'w'&lt;/code&gt; does not truncate the file, and is instead equivalent to &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 실제 파일 이름이 아닌 파일 객체 인 경우 &lt;code&gt;'w'&lt;/code&gt; 모드 는 파일을 자르지 않으며 대신 &lt;code&gt;'a'&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4b4caaad3a0e78f58783527b4ec2b5bee1735031" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is specified, open the file in this &lt;a href=&quot;functions#filemodes&quot;&gt;mode&lt;/a&gt;. Defaults to &lt;code&gt;'a'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 지정이있는 파일 열기 &lt;a href=&quot;functions#filemodes&quot;&gt;모드를&lt;/a&gt; . 기본값은 &lt;code&gt;'a'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6af85c4bc7806c30929d3ef968f1f66afef5d04c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filename&lt;/em&gt; is specified, use it as the value of the &lt;code&gt;filename&lt;/code&gt; parameter of the &lt;em&gt;Content-Disposition&lt;/em&gt; header.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이 지정된 경우 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 의 &lt;code&gt;filename&lt;/code&gt; 매개 변수 값으로 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9df42f67fa743cce97d1afbbf64f8287dc75452d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filenames&lt;/em&gt; is a string, a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, it is treated as a single filename. If a file named in &lt;em&gt;filenames&lt;/em&gt; cannot be opened, that file will be ignored. This is designed so that you can specify an iterable of potential configuration file locations (for example, the current directory, the user&amp;rsquo;s home directory, and some system-wide directory), and all existing configuration files in the iterable will be read.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 문자열입니다하는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로가 같은 객체&lt;/a&gt; 는, 단일의 파일 이름으로 처리됩니다. &lt;em&gt;filenames로 이름&lt;/em&gt; 이 지정된 &lt;em&gt;파일&lt;/em&gt; 을 열 수 없으면 해당 파일은 무시됩니다. 이는 잠재적 인 구성 파일 위치 (예 : 현재 디렉토리, 사용자의 홈 디렉토리 및 일부 시스템 전체 디렉토리)의 반복 가능을 지정할 수 있도록 설계되었으며 반복 가능한 기존의 모든 구성 파일을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="8b2ae28dd64625ad8615f00b37b95205f862e6fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;filenames&lt;/em&gt; is a string, a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, it is treated as a single filename. If a file named in &lt;em&gt;filenames&lt;/em&gt; cannot be opened, that file will be ignored. This is designed so that you can specify an iterable of potential configuration file locations (for example, the current directory, the user&amp;rsquo;s home directory, and some system-wide directory), and all existing configuration files in the iterable will be read.</source>
          <target state="translated">경우 &lt;em&gt;파일 이름&lt;/em&gt; 문자열입니다하는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;경로가 같은 객체&lt;/a&gt; 는, 단일의 파일 이름으로 처리됩니다. &lt;em&gt;filenames&lt;/em&gt; 에 &lt;em&gt;이름&lt;/em&gt; 이 지정된 &lt;em&gt;파일&lt;/em&gt; 을 열 수없는 경우 해당 파일은 무시됩니다. 이는 잠재적 구성 파일 위치 (예 : 현재 디렉토리, 사용자의 홈 디렉토리 및 일부 시스템 전체 디렉토리)의 반복 가능을 지정할 수 있도록 설계되었으며 반복 가능의 모든 기존 구성 파일을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb50194f67b844fcbdfed4147a0e69c6aa03bd88" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileno&lt;/em&gt; is specified, the values for &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, and &lt;em&gt;proto&lt;/em&gt; are auto-detected from the specified file descriptor. Auto-detection can be overruled by calling the function with explicit &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt;, or &lt;em&gt;proto&lt;/em&gt; arguments. This only affects how Python represents e.g. the return value of &lt;a href=&quot;#socket.socket.getpeername&quot;&gt;&lt;code&gt;socket.getpeername()&lt;/code&gt;&lt;/a&gt; but not the actual OS resource. Unlike &lt;a href=&quot;#socket.fromfd&quot;&gt;&lt;code&gt;socket.fromfd()&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;fileno&lt;/em&gt; will return the same socket and not a duplicate. This may help close a detached socket using &lt;a href=&quot;#socket.close&quot;&gt;&lt;code&gt;socket.close()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;fileno가&lt;/em&gt; 지정된 경우의 값 &lt;em&gt;가족&lt;/em&gt; , &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;프로토는&lt;/em&gt; 자동으로 감지 지정된 파일 기술자에서입니다. 명시 적 &lt;em&gt;family&lt;/em&gt; , &lt;em&gt;type&lt;/em&gt; 또는 &lt;em&gt;proto&lt;/em&gt; 인수를 사용 하여 함수를 호출하면 자동 감지를 무시할 수 있습니다 . 이것은 파이썬이 표현하는 방법에만 영향을 미칩니다. 예를 들어 &lt;a href=&quot;#socket.socket.getpeername&quot;&gt; &lt;code&gt;socket.getpeername()&lt;/code&gt; &lt;/a&gt; 의 반환 값은 실제 OS 리소스가 아닙니다. 달리 &lt;a href=&quot;#socket.fromfd&quot;&gt; &lt;code&gt;socket.fromfd()&lt;/code&gt; &lt;/a&gt; , &lt;em&gt;fileno는&lt;/em&gt; 같은 소켓이 아닌 중복을 반환합니다. 이것은 &lt;a href=&quot;#socket.close&quot;&gt; &lt;code&gt;socket.close()&lt;/code&gt; &lt;/a&gt; 사용하여 분리 된 소켓을 닫는 데 도움이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cad3934c4f6ad00649995ab7289422c5ddfc6d68" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileobj&lt;/em&gt; is given, it is used for reading or writing data. If it can be determined, &lt;em&gt;mode&lt;/em&gt; is overridden by &lt;em&gt;fileobj&lt;/em&gt;&amp;rsquo;s mode. &lt;em&gt;fileobj&lt;/em&gt; will be used from position 0.</source>
          <target state="translated">경우 &lt;em&gt;fileobj이&lt;/em&gt; 주어집니다, 그것은 데이터를 읽거나 쓰기 위해 사용된다. 그것이 결정될 수 있다면, &lt;em&gt;모드&lt;/em&gt; 는 &lt;em&gt;fileobj&lt;/em&gt; 의 &lt;em&gt;모드&lt;/em&gt; 로 대체됩니다 . &lt;em&gt;fileobj&lt;/em&gt; 는 위치 0에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d760e902d1a9a9274ea97101800dd62b508b5620" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileobj&lt;/em&gt; is specified, it is used as an alternative to a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened in binary mode for &lt;em&gt;name&lt;/em&gt;. It is supposed to be at position 0.</source>
          <target state="translated">경우 &lt;em&gt;fileobj가&lt;/em&gt; 지정되어, 그것은 대안으로 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 에 대한 바이너리 모드로 열 &lt;em&gt;이름&lt;/em&gt; . 위치 0에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="eecdea127c82d2e7e3361c3981fe40eabedcc5c4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fileobj&lt;/em&gt; is specified, it is used as an alternative to a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; opened in binary mode for &lt;em&gt;name&lt;/em&gt;. It is supposed to be at position 0.</source>
          <target state="translated">경우 &lt;em&gt;fileobj가&lt;/em&gt; 지정되어, 그것은 대안으로 사용되는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 에 대한 바이너리 모드로 열 &lt;em&gt;이름&lt;/em&gt; . 위치 0에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dae7cbc850bce550396ab6a5e4f90017603d189c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;files&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; the internal data structure is completely rebuilt to its initial default value. This is a stable operation and will produce the same results when called multiple times.</source>
          <target state="translated">경우 &lt;em&gt;파일&lt;/em&gt; 입니다 &lt;code&gt;None&lt;/code&gt; 내부 데이터 구조가 완전히 초기 기본 값으로 재 구축됩니다. 이는 안정적인 작업이며 여러 번 호출 될 때 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="342f942c82ec8e80a515a3a240295a1556b0f119" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;first_line&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it indicates the line number that should be reported for the first source line in the disassembled code. Otherwise, the source line information (if any) is taken directly from the disassembled code object.</source>
          <target state="translated">&lt;em&gt;first_line&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 디스 어셈블 된 코드에서 첫 번째 소스 행에 대해보고해야하는 행 번호를 나타냅니다. 그렇지 않으면 소스 라인 정보 (있는 경우)가 디스 어셈블 된 코드 객체에서 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6e5911d01f22e7a53df624823fe8cad9cc059dfb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fix_imports&lt;/em&gt; is true and &lt;em&gt;protocol&lt;/em&gt; is less than 3, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">경우 &lt;em&gt;fix_imports가&lt;/em&gt; 사실이고 &lt;em&gt;프로토콜은&lt;/em&gt; 3보다 작은 피클은 피클 데이터 스트림 파이썬 2 읽을 그래서, 파이썬 2에서 사용 된 모듈 이름에 새로운 파이썬 3 명을 매핑 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c458fcb92551aa4179a0ee8c3ec9f897777d84c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; has another value, then the status of the newsgroup should be considered unknown.</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 에 다른 값이 있으면 뉴스 그룹의 상태를 알 수없는 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd5ac0ee5de4a2ac67078bdcdfed8efdc0a7e6d9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, after a few milliseconds, an escape sequence will not be interpreted, and will be left in the input stream as is.</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 몇 밀리 초 후에 이스케이프 시퀀스가 ​​해석되지 않고 그대로 입력 스트림에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="05e2c86e5fa6ae70395c93eb2082fe2efd1b66ad" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, curses no longer considers using the hardware insert/delete character feature of the terminal; if &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, use of character insertion and deletion is enabled. When curses is first initialized, use of character insert/delete is enabled by default.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 더 이상 단말기의 하드웨어 삽입 / 삭제 문자 기능을 사용하여 고려 저주 없다 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 문자 삽입과 삭제의 사용이 활성화됩니다. 저주가 처음 초기화되면 기본적으로 문자 삽입 / 삭제 사용이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="93111a903d42affcb1b92cdf76c31a4ded5864f7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, cursor will always be at &amp;ldquo;cursor position&amp;rdquo; after an update.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 업데이트 후 커서는 항상 &quot;커서 위치&quot;에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="927b0ac6123fcfbd9d4b43d6b6a0df82d95c5b38" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the effect is the same as calling &lt;a href=&quot;#curses.noqiflush&quot;&gt;&lt;code&gt;noqiflush()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, or no argument is provided, the queues will be flushed when these control characters are read.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 효과가 호출하는 것과 동일 &lt;a href=&quot;#curses.noqiflush&quot;&gt; &lt;code&gt;noqiflush()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 또는 인수를 제공하지 이러한 제어 문자를 읽을 때 큐를 플러시 할 것이다.</target>
        </trans-unit>
        <trans-unit id="dc34adf1b0cd9cd2daf9fae31e473262b7ba2c27" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#curses.window.getch&quot;&gt;&lt;code&gt;getch()&lt;/code&gt;&lt;/a&gt; will be non-blocking.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#curses.window.getch&quot;&gt; &lt;code&gt;getch()&lt;/code&gt; &lt;/a&gt; 비 차단 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="7b4b0114fea39b01c456c42a03e99b9d6724d928" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; will try and use hardware line editing facilities. Otherwise, line insertion/deletion are disabled.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 하려고합니다 사용 하드웨어 라인 설비를 편집. 그렇지 않으면 라인 삽입 / 삭제가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="76906428c5886677b5bf5a701073b0866ac9c47c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, allow 8-bit characters to be input. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, allow only 7-bit chars.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 8 비트 문자를 입력 할 수 있습니다. 경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 만 7 비트 문자를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="06fc114a8ed7cdc8c7c9f51b3779e8ccf43597dc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, any change in the window image automatically causes the window to be refreshed; you no longer have to call &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; yourself. However, it may degrade performance considerably, due to repeated calls to wrefresh. This option is disabled by default.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 윈도우 이미지의 모든 변경 사항이 자동으로 갱신 할 수있는 창이 원인; 더 이상 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 직접 호출 할 필요가 없습니다 . 그러나 wrefresh 호출이 반복되어 성능이 크게 저하 될 수 있습니다. 이 옵션은 기본적으로 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="06be27fe5690b343d7c782f196aedecd59d5593b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, cursor is left where it is on update, instead of being at &amp;ldquo;cursor position.&amp;rdquo; This reduces cursor movement where possible. If possible the cursor will be made invisible.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 대신에가되는 업데이트에이고, 커서는 남아 &quot;커서 위치.&quot; 가능한 경우 커서 이동이 줄어 듭니다. 가능하면 커서가 보이지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="e8f3b65bf56ecd36575c4c78068a2150d9cf1c52" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, escape sequences generated by some keys (keypad, function keys) will be interpreted by &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, escape sequences will be left as is in the input stream.</source>
          <target state="translated">&lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 일부 키 (키패드, 기능 키)로 생성 된 이스케이프 시퀀스는 &lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 . &lt;em&gt;flag&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 , 이스케이프 시퀀스는 입력 스트림에서 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a9d18c81906fc88496c93e2ee95c2ec1e7a5f5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, escape sequences will not be timed out.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 이스케이프 시퀀스 시간이 초과되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffb0dbfa616feb4ae93cd41e04da978adc1b3014" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the next call to &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; will clear the window completely.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; 에 다음 호출 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 완전히 창을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a8c3c261a3289123c7ec484215dd4ac72bcaec28" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;a href=&quot;#curses.window.syncup&quot;&gt;&lt;code&gt;syncup()&lt;/code&gt;&lt;/a&gt; is called automatically whenever there is a change in the window.</source>
          <target state="translated">경우 &lt;em&gt;플래그&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 다음 &lt;a href=&quot;#curses.window.syncup&quot;&gt; &lt;code&gt;syncup()&lt;/code&gt; &lt;/a&gt; 윈도우에 변화가있을 때마다 자동으로 호출된다.</target>
        </trans-unit>
        <trans-unit id="54238747de3a909db924c82086364dce0b3b6035" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;flag&lt;/em&gt; is true, turn debugging on. Otherwise, turn debugging off. When debugging is on, commands to be executed are printed, and the shell is given &lt;code&gt;set -x&lt;/code&gt; command to be more verbose.</source>
          <target state="translated">경우 &lt;em&gt;플래그가&lt;/em&gt; true 인, 디버깅을 켜십시오. 그렇지 않으면 디버깅을 끕니다. 디버깅이 설정되면 실행할 명령이 인쇄되고 쉘에 &lt;code&gt;set -x&lt;/code&gt; 명령이 더 자세하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0a676f79bdec3d8d55c49f7b6418938f946ea982" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;fmt&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, use the following default &lt;em&gt;fmt&lt;/em&gt;:</source>
          <target state="translated">경우 &lt;em&gt;FMT가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음과 같은 기본 사용 &lt;em&gt;FMT를&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="3b5abf51d5e979202e366a84df39077b1602bd52" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, return &lt;code&gt;True&lt;/code&gt; only if this entry is a directory (without following symlinks); return &lt;code&gt;False&lt;/code&gt; if the entry is any other kind of file or if it doesn&amp;rsquo;t exist anymore.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 를 반환 &lt;code&gt;True&lt;/code&gt; 이 항목이 디렉토리 (다음 심볼릭 링크없이) 인 경우에만; 항목이 다른 종류의 파일이거나 더 이상 존재하지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b449d1a838bf30bc8e83f6404dc93c18180c4e9b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, return &lt;code&gt;True&lt;/code&gt; only if this entry is a file (without following symlinks); return &lt;code&gt;False&lt;/code&gt; if the entry is a directory or other non-file entry, or if it doesn&amp;rsquo;t exist anymore.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 를 반환 &lt;code&gt;True&lt;/code&gt; 이 항목이 파일 (다음 심볼릭 링크없이) 인 경우에만; 항목이 디렉토리 또는 기타 파일이 아닌 항목이거나 더 이상 존재하지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="2c810ead4934973b38f7ba460ecc6b76eb321e40" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false and &lt;em&gt;src&lt;/em&gt; is a symbolic link, a new symbolic link will be created instead of copying the file &lt;em&gt;src&lt;/em&gt; points to.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, 새로운 심볼 링크 대신에 파일을 복사하는 생성됩니다 &lt;em&gt;SRC&lt;/em&gt; 에 포인트를.</target>
        </trans-unit>
        <trans-unit id="3791f9b1ad913c64dfe3c483d0e89806dc737039" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt; both refer to symbolic links, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; will operate on the symbolic links themselves rather than the files the symbolic links refer to&amp;mdash;reading the information from the &lt;em&gt;src&lt;/em&gt; symbolic link, and writing the information to the &lt;em&gt;dst&lt;/em&gt; symbolic link.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이고 &lt;em&gt;SRC&lt;/em&gt; 와 &lt;em&gt;DST&lt;/em&gt; 모두 기호 링크를 참조 &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 기호 링크에서 작동 자체가 아니라 심볼릭 링크가-읽기의 정보 참조하는 파일보다 &lt;em&gt;SRC&lt;/em&gt; 심볼릭 링크를, 그리고에 대한 정보를 기록 &lt;em&gt;dst&lt;/em&gt; 기호 링크.</target>
        </trans-unit>
        <trans-unit id="05aea198a5b1eab18e23d436268151142cdfb7c9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;follow_symlinks&lt;/em&gt; is false, and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;em&gt;dst&lt;/em&gt; will be created as a symbolic link. If &lt;em&gt;follow_symlinks&lt;/em&gt; is true and &lt;em&gt;src&lt;/em&gt; is a symbolic link, &lt;em&gt;dst&lt;/em&gt; will be a copy of the file &lt;em&gt;src&lt;/em&gt; refers to.</source>
          <target state="translated">경우 &lt;em&gt;follow_symlinks은&lt;/em&gt; 거짓이며, &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;em&gt;DST는&lt;/em&gt; 심볼릭 링크로 생성됩니다. 경우 &lt;em&gt;follow_symlinks가&lt;/em&gt; 사실이고 &lt;em&gt;SRC는&lt;/em&gt; 심볼릭 링크, &lt;em&gt;DST는&lt;/em&gt; 파일의 복사본이 될 것입니다 &lt;em&gt;SRC가&lt;/em&gt; 에 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad63af89430c98aa694c40b5d47925c5c967f84b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;force&lt;/em&gt; is true, modules are re-compiled even if the timestamps are up to date.</source>
          <target state="translated">경우 &lt;em&gt;힘은&lt;/em&gt; 사실, 모듈 타임 스탬프가 최신 인 경우에도 재 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="db56c32c75e8f39f5a049b963d87f7483bb3f491" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; is specified, use this style for the format string. One of &lt;code&gt;'%'&lt;/code&gt;, &lt;code&gt;'{'&lt;/code&gt; or &lt;code&gt;'$'&lt;/code&gt; for &lt;a href=&quot;stdtypes#old-string-formatting&quot;&gt;printf-style&lt;/a&gt;, &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt; respectively. Defaults to &lt;code&gt;'%'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 이 지정된 경우 &lt;em&gt;형식&lt;/em&gt; 문자열에이 스타일을 사용하십시오. 하나의 &lt;code&gt;'%'&lt;/code&gt; , &lt;code&gt;'{'&lt;/code&gt; 또는 &lt;code&gt;'$'&lt;/code&gt; 에 대한 &lt;a href=&quot;stdtypes#old-string-formatting&quot;&gt;printf와 스타일&lt;/a&gt; , &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; &lt;/a&gt; 각각. 기본값은 &lt;code&gt;'%'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c993dc4953aefb555e95150b85e635f8eb734c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; requires a single argument, &lt;em&gt;values&lt;/em&gt; may be a single non-tuple object. &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt; Otherwise, &lt;em&gt;values&lt;/em&gt; must be a tuple with exactly the number of items specified by the format string, or a single mapping object (for example, a dictionary).</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 에 단일 인수가 필요한 경우 &lt;em&gt;값&lt;/em&gt; 은 단일 비 튜플 객체 일 수 있습니다. &lt;a href=&quot;#id16&quot; id=&quot;id10&quot;&gt;5&lt;/a&gt; 그렇지 않으면, &lt;em&gt;값&lt;/em&gt; 은 형식 문자열로 지정된 항목 수 또는 단일 맵핑 오브젝트 (예 : 사전)가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7bc9128599baccee2d3226e85c7c2b9cc2cb9b2f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;format&lt;/em&gt; requires a single argument, &lt;em&gt;values&lt;/em&gt; may be a single non-tuple object. &lt;a href=&quot;#id16&quot; id=&quot;id11&quot;&gt;5&lt;/a&gt; Otherwise, &lt;em&gt;values&lt;/em&gt; must be a tuple with exactly the number of items specified by the format bytes object, or a single mapping object (for example, a dictionary).</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 에 단일 인수가 필요한 경우 &lt;em&gt;값&lt;/em&gt; 은 단일 비 튜플 객체 일 수 있습니다. &lt;a href=&quot;#id16&quot; id=&quot;id11&quot;&gt;5&lt;/a&gt; 그렇지 않으면 &lt;em&gt;값&lt;/em&gt; 은 format bytes 객체에 지정된 항목 수 또는 단일 매핑 객체 (예 : 사전)가있는 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d48e3331edd32ebb17d2aa8d9c936c8508567fe2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;from_addr&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or &lt;em&gt;to_addrs&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;code&gt;send_message&lt;/code&gt; fills those arguments with addresses extracted from the headers of &lt;em&gt;msg&lt;/em&gt; as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;: &lt;em&gt;from_addr&lt;/em&gt; is set to the &lt;em&gt;Sender&lt;/em&gt; field if it is present, and otherwise to the &lt;em&gt;From&lt;/em&gt; field. &lt;em&gt;to_addrs&lt;/em&gt; combines the values (if any) of the &lt;em&gt;To&lt;/em&gt;, &lt;em&gt;Cc&lt;/em&gt;, and &lt;em&gt;Bcc&lt;/em&gt; fields from &lt;em&gt;msg&lt;/em&gt;. If exactly one set of &lt;em&gt;Resent-*&lt;/em&gt; headers appear in the message, the regular headers are ignored and the &lt;em&gt;Resent-*&lt;/em&gt; headers are used instead. If the message contains more than one set of &lt;em&gt;Resent-*&lt;/em&gt; headers, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised, since there is no way to unambiguously detect the most recent set of &lt;em&gt;Resent-&lt;/em&gt; headers.</source>
          <target state="translated">경우 &lt;em&gt;from_addr가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 또는 &lt;em&gt;to_addrs가&lt;/em&gt; 된다 &lt;code&gt;None&lt;/code&gt; , &lt;code&gt;send_message&lt;/code&gt; 채우기의 헤더로부터 추출 주소지 인수 &lt;em&gt;MSG&lt;/em&gt; 에 규정 된 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; : &lt;em&gt;from_addr가&lt;/em&gt; 받는 설정 &lt;em&gt;발신자&lt;/em&gt; 가 존재한다면 필드와 달리 행 &lt;em&gt;에서&lt;/em&gt; 필드. &lt;em&gt;to_addrs&lt;/em&gt; 는 &lt;em&gt;msg&lt;/em&gt; 의 &lt;em&gt;To&lt;/em&gt; , &lt;em&gt;Cc&lt;/em&gt; 및 &lt;em&gt;Bcc&lt;/em&gt; 필드 값 (있는 경우)을 결합합니다 . 정확히 하나의 &lt;em&gt;Resent- *&lt;/em&gt; 헤더 세트가 메시지에 표시되면 일반 헤더는 무시되고&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;Resent- *&lt;/em&gt; 헤더가 대신 사용됩니다. 메시지에 둘 이상의 &lt;em&gt;Resent- *&lt;/em&gt; 헤더 세트가 포함 된 경우 가장 최근 &lt;em&gt;Resent-&lt;/em&gt; 헤더 세트를 명확하게 감지 할 방법이 없으므로 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="feea519ba7ec87396ed4869230c2a276f4279c66" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;func&lt;/em&gt; is supplied, it should be a function of two arguments. Elements of the input &lt;em&gt;iterable&lt;/em&gt; may be any type that can be accepted as arguments to &lt;em&gt;func&lt;/em&gt;. (For example, with the default operation of addition, elements may be any addable type including &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">경우 &lt;em&gt;FUNC가&lt;/em&gt; 공급되고, 두 개의 인수의 함수이어야한다. 입력 &lt;em&gt;iterable의&lt;/em&gt; 요소는 &lt;em&gt;func에&lt;/em&gt; 대한 인수로 허용 될 수있는 모든 유형일 수 있습니다 . 예를 들어, 더하기의 기본 연산에서 요소는 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 포함한 추가 가능한 유형일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="164544b1932b60456584e8f1c72c01d2623fcbf2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;gen_func&lt;/em&gt; is a generator function, it will be modified in-place.</source>
          <target state="translated">경우 &lt;em&gt;gen_func가&lt;/em&gt; 발전기 기능은, 그것은 현재 위치에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae0ede519983eaf3ab2b7313089869e4e7d5c637" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;gen_func&lt;/em&gt; is not a generator function, it will be wrapped. If it returns an instance of &lt;a href=&quot;collections.abc#collections.abc.Generator&quot;&gt;&lt;code&gt;collections.abc.Generator&lt;/code&gt;&lt;/a&gt;, the instance will be wrapped in an &lt;em&gt;awaitable&lt;/em&gt; proxy object. All other types of objects will be returned as is.</source>
          <target state="translated">&lt;em&gt;gen_func&lt;/em&gt; 가 생성기 함수가 아닌 경우 랩핑됩니다. &lt;a href=&quot;collections.abc#collections.abc.Generator&quot;&gt; &lt;code&gt;collections.abc.Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하면 인스턴스 는 &lt;em&gt;대기 가능한&lt;/em&gt; 프록시 오브젝트 로 랩핑됩니다 . 다른 모든 유형의 객체는 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf24817a5521bbff63768774eb4199f2d3c3e247" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;generator&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; with no currently associated frame, then an empty dictionary is returned. &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised if &lt;em&gt;generator&lt;/em&gt; is not a Python generator object.</source>
          <target state="translated">경우 &lt;em&gt;발전기&lt;/em&gt; A는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 없이 현재 관련 프레임, 빈 상태 (empty)의 사전이 반환됩니다. &lt;em&gt;generator&lt;/em&gt; 가 Python 생성기 객체가 아닌 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1fc71b1dd40b526df07584c19b8a60564d1afabb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;generator&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt; with no currently associated frame, then an empty dictionary is returned. &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised if &lt;em&gt;generator&lt;/em&gt; is not a Python generator object.</source>
          <target state="translated">경우 &lt;em&gt;발전기&lt;/em&gt; A는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 없이 현재 관련 프레임, 빈 상태 (empty)의 사전이 반환됩니다. &lt;em&gt;생성기&lt;/em&gt; 가 Python 생성기 객체가 아닌 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="32d78d5d1b808d4fae3e941bac29fe312e9966f1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;group&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the setregid() system call will be made in the child process prior to the execution of the subprocess. If the provided value is a string, it will be looked up via &lt;a href=&quot;grp#grp.getgrnam&quot;&gt;&lt;code&gt;grp.getgrnam()&lt;/code&gt;&lt;/a&gt; and the value in &lt;code&gt;gr_gid&lt;/code&gt; will be used. If the value is an integer, it will be passed verbatim. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;그룹&lt;/em&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 은이 setregid () 시스템 호출 전에 구성 프로세스의 실행 자식 프로세스에 대하여 설명한다. 제공된 값이 문자열이면 &lt;a href=&quot;grp#grp.getgrnam&quot;&gt; &lt;code&gt;grp.getgrnam()&lt;/code&gt; &lt;/a&gt; 통해 조회 되고 &lt;code&gt;gr_gid&lt;/code&gt; 의 값 이 사용됩니다. 값이 정수이면 그대로 전달됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="46bc5fd0aa6bec8a23e0345b1203f16848d81f41" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;handler&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the default exception handler will be set. Otherwise, &lt;em&gt;handler&lt;/em&gt; must be a callable with the signature matching &lt;code&gt;(loop, context)&lt;/code&gt;, where &lt;code&gt;loop&lt;/code&gt; is a reference to the active event loop, and &lt;code&gt;context&lt;/code&gt; is a &lt;code&gt;dict&lt;/code&gt; object containing the details of the exception (see &lt;a href=&quot;#asyncio.loop.call_exception_handler&quot;&gt;&lt;code&gt;call_exception_handler()&lt;/code&gt;&lt;/a&gt; documentation for details about context).</source>
          <target state="translated">경우 &lt;em&gt;핸들러가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 기본 예외 핸들러가 설정됩니다. 그렇지 않으면 &lt;em&gt;핸들러&lt;/em&gt; 는 서명 일치 &lt;code&gt;(loop, context)&lt;/code&gt; 로 호출 가능해야합니다. 여기서 &lt;code&gt;loop&lt;/code&gt; 는 활성 이벤트 루프에 대한 참조이고 &lt;code&gt;context&lt;/code&gt; 는 예외에 대한 세부 사항을 포함 하는 &lt;code&gt;dict&lt;/code&gt; 오브젝트입니다 &lt;a href=&quot;#asyncio.loop.call_exception_handler&quot;&gt; &lt;code&gt;call_exception_handler()&lt;/code&gt; &lt;/a&gt; 컨텍스트에 대한 세부 사항 은 call_exception_handler () 문서 참조 ). ).</target>
        </trans-unit>
        <trans-unit id="d76c1251be1504007598c6c1b5f67777c519d2a0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;hardlink_dupes&lt;/em&gt; is true and two &lt;code&gt;.pyc&lt;/code&gt; files with different optimization level have the same content, use hard links to consolidate duplicate files.</source>
          <target state="translated">경우 &lt;em&gt;hardlink_dupes가&lt;/em&gt; 사실이고이 개 &lt;code&gt;.pyc&lt;/code&gt; 다른 최적화 수준 파일이 동일한 내용이 중복 파일을 통합하기 위해 하드 링크를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f0f448033d3ee18b041c00dcd5e55dde7d7efa40" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;headers&lt;/em&gt; contains neither Content-Length nor Transfer-Encoding, but there is a request body, one of those header fields will be added automatically. If &lt;em&gt;body&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the Content-Length header is set to &lt;code&gt;0&lt;/code&gt; for methods that expect a body (&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;PATCH&lt;/code&gt;). If &lt;em&gt;body&lt;/em&gt; is a string or a bytes-like object that is not also a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file&lt;/a&gt;, the Content-Length header is set to its length. Any other type of &lt;em&gt;body&lt;/em&gt; (files and iterables in general) will be chunk-encoded, and the Transfer-Encoding header will automatically be set instead of Content-Length.</source>
          <target state="translated">경우 &lt;em&gt;헤더&lt;/em&gt; 도 콘텐츠 길이도 전송 인코딩을 포함하지만, 요청 본문이 그 헤더 필드 중 하나가 자동으로 추가됩니다. &lt;em&gt;body&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이면 &lt;em&gt;본문&lt;/em&gt; 을 예상하는 메서드 ( &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 및 &lt;code&gt;PATCH&lt;/code&gt; )에 대해 Content-Length 헤더가 &lt;code&gt;0&lt;/code&gt; 으로 설정됩니다 . 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열이나 바이트와 같은 객체도 아닌 것입니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일&lt;/a&gt; , 콘텐츠 길이 헤더의 길이로 설정됩니다. 다른 유형의 &lt;em&gt;본문&lt;/em&gt; (일반적으로 파일 및 이터 러블)은 청크 인코딩되며 전송 길이 헤더는 Content-Length 대신 자동으로 설정됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b8df36b7b079d2ceeb7784e1710bf797f0f853e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;headers&lt;/em&gt; contains neither Content-Length nor Transfer-Encoding, but there is a request body, one of those header fields will be added automatically. If &lt;em&gt;body&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the Content-Length header is set to &lt;code&gt;0&lt;/code&gt; for methods that expect a body (&lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, and &lt;code&gt;PATCH&lt;/code&gt;). If &lt;em&gt;body&lt;/em&gt; is a string or a bytes-like object that is not also a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file&lt;/a&gt;, the Content-Length header is set to its length. Any other type of &lt;em&gt;body&lt;/em&gt; (files and iterables in general) will be chunk-encoded, and the Transfer-Encoding header will automatically be set instead of Content-Length.</source>
          <target state="translated">경우 &lt;em&gt;헤더&lt;/em&gt; 도 콘텐츠 길이도 전송 인코딩을 포함하지만, 요청 본문이 그 헤더 필드 중 하나가 자동으로 추가됩니다. 경우 &lt;em&gt;본체&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 콘텐츠 길이 헤더에 설정되어있는 &lt;code&gt;0&lt;/code&gt; 본체 (예상 메소드 &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; 및 &lt;code&gt;PATCH&lt;/code&gt; 을 ). 경우 &lt;em&gt;몸이&lt;/em&gt; 문자열이나 바이트와 같은 객체도 아닌 것입니다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일&lt;/a&gt; , 콘텐츠 길이 헤더의 길이로 설정됩니다. 다른 유형의 &lt;em&gt;본문&lt;/em&gt; (일반적으로 파일 및 이터 러블)은 청크 인코딩되며 Transfer-Encoding 헤더는 Content-Length 대신 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5623776bc8cb206e64b194eac78038ac0ca5ac63" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;headers&lt;/em&gt; is specified and is a list of strings of the form &lt;code&gt;headername: headervalue&lt;/code&gt; or a list of &lt;code&gt;header&lt;/code&gt; objects (distinguished from strings by having a &lt;code&gt;name&lt;/code&gt; attribute), add the headers to &lt;em&gt;msg&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;헤더&lt;/em&gt; 지정 및 형식 문자열의 목록은 &lt;code&gt;headername: headervalue&lt;/code&gt; 또는리스트 &lt;code&gt;header&lt;/code&gt; (a함으로써 문자열 구별 개체 &lt;code&gt;name&lt;/code&gt; 속성)에 헤더를 추가 &lt;em&gt;MSG&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="67f11944e8694918226bb92f8c98cd866fee3ff0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;hkey&lt;/em&gt; is not closed using this method (or via &lt;a href=&quot;#winreg.PyHKEY.Close&quot;&gt;&lt;code&gt;hkey.Close()&lt;/code&gt;&lt;/a&gt;), it is closed when the &lt;em&gt;hkey&lt;/em&gt; object is destroyed by Python.</source>
          <target state="translated">경우 &lt;em&gt;HKEY은&lt;/em&gt; 이 방법을 사용하여 폐쇄되지 않은 (또는 비아 &lt;a href=&quot;#winreg.PyHKEY.Close&quot;&gt; &lt;code&gt;hkey.Close()&lt;/code&gt; &lt;/a&gt; )의 경우가 닫혀 &lt;em&gt;HKEY의&lt;/em&gt; 개체 파이썬 의해 파괴된다.</target>
        </trans-unit>
        <trans-unit id="0fe3a2ba8d8de975e9e62d14d77fcd64824c3a2c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is a sequence of strings, the TCP server is bound to all network interfaces specified by the sequence.</source>
          <target state="translated">경우 &lt;em&gt;호스트가&lt;/em&gt; 문자열의 순서되면, TCP 서버는 순서에 의해 지정된 모든 네트워크 인터페이스에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="3f345f9c27305214c887b3eec3da087bc1be8192" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is a string, the TCP server is bound to a single network interface specified by &lt;em&gt;host&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;호스트&lt;/em&gt; 문자열입니다는 TCP 서버에 의해 지정된 단일 네트워크 인터페이스에 바인딩 &lt;em&gt;호스트&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2f9d505cd78099d9626b9c1d857032185127ef87" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;host&lt;/em&gt; is an empty string or &lt;code&gt;None&lt;/code&gt;, all interfaces are assumed and a list of multiple sockets will be returned (most likely one for IPv4 and another one for IPv6).</source>
          <target state="translated">경우 &lt;em&gt;호스트가&lt;/em&gt; 빈 문자열이거나 &lt;code&gt;None&lt;/code&gt; , 모든 인터페이스는 (대부분 IPv4의 하나와 IPv6에 대한 또 다른 하나) 가정 및 다중 소켓의 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc492cbe67d58bcc667802df9fc3fe37624b350" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is negative, the index is relative to the end of sequence &lt;em&gt;s&lt;/em&gt;: &lt;code&gt;len(s) + i&lt;/code&gt; or &lt;code&gt;len(s) + j&lt;/code&gt; is substituted. But note that &lt;code&gt;-0&lt;/code&gt; is still &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J가&lt;/em&gt; 마이너스이고, 인덱스 시퀀스의 끝을 기준으로 &lt;em&gt;S&lt;/em&gt; : &lt;code&gt;len(s) + i&lt;/code&gt; 또는 &lt;code&gt;len(s) + j&lt;/code&gt; 치환된다. 그러나 &lt;code&gt;-0&lt;/code&gt; 은 여전히 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44afe41d193d3ce2b1d38185232d5624b2955990" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ignore&lt;/em&gt; is given, it must be a callable that will receive as its arguments the directory being visited by &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt;, and a list of its contents, as returned by &lt;a href=&quot;os#os.listdir&quot;&gt;&lt;code&gt;os.listdir()&lt;/code&gt;&lt;/a&gt;. Since &lt;a href=&quot;#shutil.copytree&quot;&gt;&lt;code&gt;copytree()&lt;/code&gt;&lt;/a&gt; is called recursively, the &lt;em&gt;ignore&lt;/em&gt; callable will be called once for each directory that is copied. The callable must return a sequence of directory and file names relative to the current directory (i.e. a subset of the items in its second argument); these names will then be ignored in the copy process. &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt;&lt;code&gt;ignore_patterns()&lt;/code&gt;&lt;/a&gt; can be used to create such a callable that ignores names based on glob-style patterns.</source>
          <target state="translated">경우 &lt;em&gt;무시&lt;/em&gt; 주어, 그것은 방문중인 디렉토리의 인수로받을 것입니다 호출해야합니다 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 에 의해 반환, 그 내용의 목록 &lt;a href=&quot;os#os.listdir&quot;&gt; &lt;code&gt;os.listdir()&lt;/code&gt; &lt;/a&gt; . 이후 &lt;a href=&quot;#shutil.copytree&quot;&gt; &lt;code&gt;copytree()&lt;/code&gt; &lt;/a&gt; 재귀 적으로 호출되면이 &lt;em&gt;무시&lt;/em&gt; 복사됩니다 각 디렉토리에 대해 한 번 호출됩니다 호출. 호출 가능 파일은 현재 디렉토리와 관련된 디렉토리 및 파일 이름 시퀀스를 반환해야합니다 (즉, 두 번째 인수에있는 항목의 하위 집합). 이러한 이름은 복사 과정에서 무시됩니다. &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt; &lt;code&gt;ignore_patterns()&lt;/code&gt; &lt;/a&gt; 를 사용하여 glob 스타일 패턴을 기반으로 이름을 무시하는 호출 가능 파일을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d785f3192b45198013e900cff1faf46eb9fbd317" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ignore_zeros&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, treat an empty block as the end of the archive. If it is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, skip empty (and invalid) blocks and try to get as many members as possible. This is only useful for reading concatenated or damaged archives.</source>
          <target state="translated">경우 &lt;em&gt;ignore_zeros이&lt;/em&gt; 있다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 아카이브의 마지막으로 빈 블록을 취급합니다. &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 비어 있고 유효하지 않은 블록을 건너 뛰고 가능한 한 많은 멤버를 확보하십시오. 연결되거나 손상된 아카이브를 읽을 때만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a4a7904c070e056ee4cfdf2fa61877eb76ea87e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (exclude), ignore memory blocks allocated in a file with a name matching &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt;&lt;code&gt;filename_pattern&lt;/code&gt;&lt;/a&gt; at line number &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (제외), 이름 일치와 파일에 할당 된 메모리 블록을 무시 &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt; &lt;code&gt;filename_pattern&lt;/code&gt; &lt;/a&gt; 줄 번호에서 &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b63248eefccbe6a3d667aec993979939e6087d1e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (exclude), match memory blocks not allocated in the address space &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (제외), 일치하는 메모리 블록 주소 공간에 할당되지 않은 &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49de2929ffeb92d24b9cb57a7b7a1ea592c5170b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (include), match memory blocks allocated in the address space &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 주소 공간 할당 일치하는 메모리 블록 (포함) &lt;a href=&quot;#tracemalloc.DomainFilter.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0dcfc5893b04256daaa03f0059c6ea1a4e39d096" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;inclusive&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (include), only match memory blocks allocated in a file with a name matching &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt;&lt;code&gt;filename_pattern&lt;/code&gt;&lt;/a&gt; at line number &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt;&lt;code&gt;lineno&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;포함이&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; (포함), 이름 만 일치와 파일에 할당 된 메모리 블록과 일치 &lt;a href=&quot;#tracemalloc.Filter.filename_pattern&quot;&gt; &lt;code&gt;filename_pattern&lt;/code&gt; &lt;/a&gt; 줄 번호에서 &lt;a href=&quot;#tracemalloc.Filter.lineno&quot;&gt; &lt;code&gt;lineno&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58fc395684d347d785cfee92daad9292f6d2e8a8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;indent&lt;/em&gt; is a non-negative integer or string, then JSON array elements and object members will be pretty-printed with that indent level. An indent level of 0, negative, or &lt;code&gt;&quot;&quot;&lt;/code&gt; will only insert newlines. &lt;code&gt;None&lt;/code&gt; (the default) selects the most compact representation. Using a positive integer indent indents that many spaces per level. If &lt;em&gt;indent&lt;/em&gt; is a string (such as &lt;code&gt;&quot;\t&quot;&lt;/code&gt;), that string is used to indent each level.</source>
          <target state="translated">경우 &lt;em&gt;덴트는&lt;/em&gt; 음이 아닌 정수 나 문자열은 다음 JSON 어레이 요소와 물체 부재는 오목 레벨 꽤 인쇄 될 것이다. 들여 쓰기 수준 0, 음수 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 는 줄 바꿈 만 삽입합니다. &lt;code&gt;None&lt;/code&gt; (기본값)은 가장 간단한 표현을 선택합니다. 양의 정수 들여 쓰기를 사용하면 레벨 당 많은 공간이 들여 쓰기됩니다. 경우 &lt;em&gt;들여 쓰기&lt;/em&gt; (같은 문자열 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), 해당 문자열이 각 레벨을 들여 사용된다.</target>
        </trans-unit>
        <trans-unit id="86444e3b248e51f216f473f027a72d0450d6ad4e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;indent&lt;/em&gt; is a non-negative integer or string, then the tree will be pretty-printed with that indent level. An indent level of 0, negative, or &lt;code&gt;&quot;&quot;&lt;/code&gt; will only insert newlines. &lt;code&gt;None&lt;/code&gt; (the default) selects the single line representation. Using a positive integer indent indents that many spaces per level. If &lt;em&gt;indent&lt;/em&gt; is a string (such as &lt;code&gt;&quot;\t&quot;&lt;/code&gt;), that string is used to indent each level.</source>
          <target state="translated">경우 &lt;em&gt;들여 쓰기는&lt;/em&gt; 양의 정수 또는 문자열이며, 그 나무는 들여 쓰기 수준을 꽤 인쇄 될 것입니다. 0, 음수 또는 &lt;code&gt;&quot;&quot;&lt;/code&gt; 의 들여 쓰기 수준은 개행 만 삽입합니다. &lt;code&gt;None&lt;/code&gt; (기본값)은 단일 선 표현을 선택합니다. 양의 정수 들여 쓰기를 사용하면 수준 당 많은 공백이 들여 쓰기됩니다. 경우 &lt;em&gt;들여 쓰기&lt;/em&gt; (같은 문자열 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; ), 해당 문자열이 각 레벨을 들여 사용된다.</target>
        </trans-unit>
        <trans-unit id="685f4df3ebb7bcdd656a69b4b08c67818137a416" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;infile&lt;/em&gt; is not specified, read from &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;INFILE이&lt;/em&gt; 지정되지 않은, 읽기 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af42a72d9390faa93a1048c54ee6e3245c21c2a3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;initializer&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt; then each worker process will call &lt;code&gt;initializer(*initargs)&lt;/code&gt; when it starts.</source>
          <target state="translated">&lt;em&gt;초기화 프로그램&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 각 작업자 프로세스는 시작할 때 &lt;code&gt;initializer(*initargs)&lt;/code&gt; 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="fc855a607663f5eac05d5c21762309db29ce88bf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;input&lt;/em&gt; is given, it is passed to the &lt;a href=&quot;#http.cookies.BaseCookie.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;em&gt;입력이&lt;/em&gt; 주어지고 그것은에 전달되는 &lt;a href=&quot;#http.cookies.BaseCookie.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="2b8380ea7e230485aa00a5b7a9d5e448bafe1787" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isjunk&lt;/em&gt; was omitted or &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt;&lt;code&gt;find_longest_match()&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;(i, j, k)&lt;/code&gt; such that &lt;code&gt;a[i:i+k]&lt;/code&gt; is equal to &lt;code&gt;b[j:j+k]&lt;/code&gt;, where &lt;code&gt;alo
&amp;lt;= i &amp;lt;= i+k &amp;lt;= ahi&lt;/code&gt; and &lt;code&gt;blo &amp;lt;= j &amp;lt;= j+k &amp;lt;= bhi&lt;/code&gt;. For all &lt;code&gt;(i', j',
k')&lt;/code&gt; meeting those conditions, the additional conditions &lt;code&gt;k &amp;gt;= k'&lt;/code&gt;, &lt;code&gt;i
&amp;lt;= i'&lt;/code&gt;, and if &lt;code&gt;i == i'&lt;/code&gt;, &lt;code&gt;j &amp;lt;= j'&lt;/code&gt; are also met. In other words, of all maximal matching blocks, return one that starts earliest in &lt;em&gt;a&lt;/em&gt;, and of all those maximal matching blocks that start earliest in &lt;em&gt;a&lt;/em&gt;, return the one that starts earliest in &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;isjunk가&lt;/em&gt; 생략되거나 하였다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt; &lt;code&gt;find_longest_match()&lt;/code&gt; &lt;/a&gt; 복귀 &lt;code&gt;(i, j, k)&lt;/code&gt; 되도록 &lt;code&gt;a[i:i+k]&lt;/code&gt; 같다 &lt;code&gt;b[j:j+k]&lt;/code&gt; , &lt;code&gt;alo &amp;lt;= i &amp;lt;= i+k &amp;lt;= ahi&lt;/code&gt; 및 &lt;code&gt;blo &amp;lt;= j &amp;lt;= j+k &amp;lt;= bhi&lt;/code&gt; . 이러한 조건을 충족하는 모든 &lt;code&gt;(i', j', k')&lt;/code&gt; 에 대해 추가 조건 &lt;code&gt;k &amp;gt;= k'&lt;/code&gt; , &lt;code&gt;i &amp;lt;= i'&lt;/code&gt; 이고 &lt;code&gt;i == i'&lt;/code&gt; 이면 &lt;code&gt;j &amp;lt;= j'&lt;/code&gt; 도 충족됩니다. 다시 말해, 모든 최대 매칭 블록 중에서 가장 빠른 것으로 시작하는 블록과 &lt;em&gt;a&lt;/em&gt; 에서 가장 빠른 시작 블록을 반환 &lt;em&gt;합니다.&lt;/em&gt;&lt;em&gt;b&lt;/em&gt; 에서 가장 빨리 시작하는 것을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="75fee0a269e631f121c00c49961541eaff1b3b2d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;isjunk&lt;/em&gt; was provided, first the longest matching block is determined as above, but with the additional restriction that no junk element appears in the block. Then that block is extended as far as possible by matching (only) junk elements on both sides. So the resulting block never matches on junk except as identical junk happens to be adjacent to an interesting match.</source>
          <target state="translated">경우 &lt;em&gt;isjunk을&lt;/em&gt; 구비하고, 제 긴 정합 블록은 있지만 정크 요소가 블록에 나타나지 않는 것을 부가적인 제약과, 전술과 같이 결정된다. 그런 다음 양쪽의 정크 요소를 일치시켜 해당 블록을 최대한 확장합니다. 따라서 동일한 정크가 흥미로운 일치 항목에 인접하는 것을 제외하고 결과 블록은 정크와 절대 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab8363bacc86dbccdda686c60e9f57e64899a0a7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is not specified, returns root children.</source>
          <target state="translated">경우 &lt;em&gt;항목이&lt;/em&gt; 지정되지 않은 루트 아이들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="640e4676019d2f35b4e680f21a70d725650c2978" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is specified, returns 1 or 0 depending on whether the specified &lt;em&gt;item&lt;/em&gt; has the given &lt;em&gt;tagname&lt;/em&gt;. Otherwise, returns a list of all items that have the specified tag.</source>
          <target state="translated">&lt;em&gt;item&lt;/em&gt; 이 지정된 경우 지정된 &lt;em&gt;항목&lt;/em&gt; 에 지정된 &lt;em&gt;tagname&lt;/em&gt; 이 있는지에 따라 1 또는 0을 반환합니다 . 그렇지 않으면 지정된 태그가있는 모든 항목의 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e440a41e05f93e2a1c6c6399b8430876ac4585da" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;item&lt;/em&gt; is specified, sets the focus item to &lt;em&gt;item&lt;/em&gt;. Otherwise, returns the current focus item, or &amp;lsquo;&amp;rsquo; if there is none.</source>
          <target state="translated">경우 &lt;em&gt;항목이&lt;/em&gt; 지정에 초점 항목을 설정 &lt;em&gt;항목&lt;/em&gt; . 그렇지 않으면 현재 포커스 항목을 반환하거나없는 경우 ''를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4bf186b875e926737f447fba52ea416adfe07ffd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;k&lt;/em&gt; is not specified or is None, then &lt;em&gt;k&lt;/em&gt; defaults to &lt;em&gt;n&lt;/em&gt; and the function returns &lt;code&gt;n!&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;K가&lt;/em&gt; 지정 또는 없음입니다되어 있지 않은 경우, &lt;em&gt;케이&lt;/em&gt; 기본값은 &lt;em&gt;N&lt;/em&gt; 과 함수가 반환 &lt;code&gt;n!&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e0d95fc7b381f24c17900b74659214f4eeca1c2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;keepends&lt;/em&gt; is false line-endings will be stripped from the lines returned.</source>
          <target state="translated">&lt;em&gt;keepends&lt;/em&gt; 가 false 이면 줄 끝이 반환 된 줄에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="344b03a8bbb6978f881befbb3ab7e00dbc466836" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is a handle returned by &lt;a href=&quot;#winreg.ConnectRegistry&quot;&gt;&lt;code&gt;ConnectRegistry()&lt;/code&gt;&lt;/a&gt;, then the path specified in &lt;em&gt;file_name&lt;/em&gt; is relative to the remote computer.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 &lt;a href=&quot;#winreg.ConnectRegistry&quot;&gt; &lt;code&gt;ConnectRegistry()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 핸들 인 경우 &lt;em&gt;file_name에&lt;/em&gt; 지정된 경로 는 원격 컴퓨터와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab3be292f079b8eebf6e1f757e8daea0ea1d6b83" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is in the dictionary, remove it and return its value, else return &lt;em&gt;default&lt;/em&gt;. If &lt;em&gt;default&lt;/em&gt; is not given and &lt;em&gt;key&lt;/em&gt; is not in the dictionary, a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 사전에 있으면 &lt;em&gt;키를&lt;/em&gt; 제거하고 값을 리턴하고 그렇지 않으면 &lt;em&gt;기본값을&lt;/em&gt; 리턴하십시오 . 경우 &lt;em&gt;기본값이&lt;/em&gt; 주어지지하고 &lt;em&gt;키가&lt;/em&gt; 사전에없는하는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa8380eba14f04ad4419f7fe956d6020b048af57" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is in the dictionary, return its value. If not, insert &lt;em&gt;key&lt;/em&gt; with a value of &lt;em&gt;default&lt;/em&gt; and return &lt;em&gt;default&lt;/em&gt;. &lt;em&gt;default&lt;/em&gt; defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;키&lt;/em&gt; 가 사전에 있으면 해당 값을 리턴하십시오. 그렇지 않은 경우, 삽입 &lt;em&gt;키&lt;/em&gt; 의 값을 &lt;em&gt;기본&lt;/em&gt; 및 반환 &lt;em&gt;기본&lt;/em&gt; . &lt;em&gt;기본&lt;/em&gt; 기본값 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d7a7b3cf6e17b5ad90262940a29bd912e9ee0f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; is one of the predefined keys, &lt;em&gt;sub_key&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt;. In that case, the handle returned is the same key handle passed in to the function.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 가 사전 정의 된 키 중 하나 인 경우 &lt;em&gt;sub_key&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 이 경우 반환 된 핸들은 함수에 전달 된 것과 동일한 키 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="35e9d157870368f01d939d30e1c0a35b6624a0fe" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;key&lt;/em&gt; represents a key on a remote computer, the path described by &lt;em&gt;file_name&lt;/em&gt; is relative to the remote computer. The caller of this method must possess the &lt;code&gt;SeBackupPrivilege&lt;/code&gt; security privilege. Note that privileges are different than permissions &amp;ndash; see the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;Conflicts Between User Rights and Permissions documentation&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;em&gt;key&lt;/em&gt; 가 원격 컴퓨터의 키를 나타내는 경우 &lt;em&gt;file_name&lt;/em&gt; 으로 설명 된 경로는 원격 컴퓨터와 관련이 있습니다. 이 메소드의 호출자는 &lt;code&gt;SeBackupPrivilege&lt;/code&gt; 보안 권한을 가지고 있어야합니다 . 권한은 권한과 다릅니다 . 자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724878%28v=VS.85%29.aspx&quot;&gt;사용자 권한과 권한 간 충돌 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48e0a5a607822047e064bb2a97449353075f69c6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;keyfile&lt;/em&gt; and &lt;em&gt;certfile&lt;/em&gt; are provided, they are used to create an &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;키 파일&lt;/em&gt; 및 &lt;em&gt;certfile가&lt;/em&gt; 제공됩니다, 그들은는 만드는 데 사용되는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e59ed370148bc2a0a46b54a3228d31bb0bd9d0f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the column option values. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that &lt;em&gt;option&lt;/em&gt; is returned. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 않는, 열 옵션 값의 딕셔너리를 반환합니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 &lt;em&gt;옵션&lt;/em&gt; 의 값 이 반환됩니다. 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="22c41db084d38f1f4e00c46ef68becd286a4c27a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the heading option values. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that &lt;em&gt;option&lt;/em&gt; is returned. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 않는, 제목 옵션 값의 딕셔너리를 반환합니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 &lt;em&gt;옵션&lt;/em&gt; 의 값 이 반환됩니다. 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4d77b28bc9353645c16eb77f2989195d66a0666b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dict of the option settings for &lt;em&gt;tagname&lt;/em&gt;. If &lt;em&gt;option&lt;/em&gt; is specified, returns the value for that &lt;em&gt;option&lt;/em&gt; for the specified &lt;em&gt;tagname&lt;/em&gt;. Otherwise, sets the options to the corresponding values for the given &lt;em&gt;tagname&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지에 대한 옵션 설정의 DICT 반환 &lt;em&gt;태그 이름을&lt;/em&gt; . 경우 &lt;em&gt;옵션을&lt;/em&gt; 지정, 그 값 반환 &lt;em&gt;옵션&lt;/em&gt; 지정된 대한 &lt;em&gt;태그 이름을&lt;/em&gt; . 그렇지 않으면 옵션을 주어진 &lt;em&gt;tagname에&lt;/em&gt; 해당하는 값으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="23258f5a93a28264e5494954dc925f4fb9fe94ea" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;kw&lt;/em&gt; is not given, returns a dictionary of the tab option values. If &lt;em&gt;option&lt;/em&gt; is specified, returns the value of that &lt;em&gt;option&lt;/em&gt;. Otherwise, sets the options to the corresponding values.</source>
          <target state="translated">경우 &lt;em&gt;kw가&lt;/em&gt; 주어지지 탭 옵션 값의 사전을 반환합니다. 경우 &lt;em&gt;옵션을&lt;/em&gt; 지정, 그 값 반환 &lt;em&gt;옵션을&lt;/em&gt; . 그렇지 않으면 옵션을 해당 값으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="5223d4b1bee76d3b490192f2e0c760f67a403d03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;legacy&lt;/em&gt; is true, byte-code files are written to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">경우 &lt;em&gt;유산은&lt;/em&gt; 사실, 바이트 코드 파일은 파이썬의 다른 버전에 의해 생성 된 바이트 코드 파일을 덮어 쓸 수 있습니다 자신의 기존 위치와 이름에 기록됩니다. 기본값은 파일을 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 위치 및 이름 에 쓰는 &lt;strong&gt;것이므로&lt;/strong&gt; 여러 버전의 Python의 바이트 코드 파일이 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edac46e04363a344725a2ab2e33375a697b6340a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;legacy&lt;/em&gt; is true, byte-code files are written to their legacy locations and names, which may overwrite byte-code files created by another version of Python. The default is to write files to their &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; locations and names, which allows byte-code files from multiple versions of Python to coexist.</source>
          <target state="translated">경우 &lt;em&gt;유산은&lt;/em&gt; 사실, 바이트 코드 파일은 파이썬의 다른 버전에 의해 생성 된 바이트 코드 파일을 덮어 쓸 수 있습니다 자신의 기존 위치와 이름에 기록됩니다. 기본값은 파일을 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3147&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;PEP 3147&lt;/strong&gt;&lt;/a&gt; 위치 및 이름 에 쓰는 &lt;strong&gt;것이므로&lt;/strong&gt; 여러 버전의 Python의 바이트 코드 파일이 공존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f4f479018d14901ee93b65aaa185ab78cef0218" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;limit&lt;/em&gt; is supplied, only this many frames are taken from &lt;em&gt;frame_gen&lt;/em&gt;. If &lt;em&gt;lookup_lines&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the returned &lt;a href=&quot;#traceback.FrameSummary&quot;&gt;&lt;code&gt;FrameSummary&lt;/code&gt;&lt;/a&gt; objects will not have read their lines in yet, making the cost of creating the &lt;a href=&quot;#traceback.StackSummary&quot;&gt;&lt;code&gt;StackSummary&lt;/code&gt;&lt;/a&gt; cheaper (which may be valuable if it may not actually get formatted). If &lt;em&gt;capture_locals&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; the local variables in each &lt;a href=&quot;#traceback.FrameSummary&quot;&gt;&lt;code&gt;FrameSummary&lt;/code&gt;&lt;/a&gt; are captured as object representations.</source>
          <target state="translated">경우 &lt;em&gt;제한&lt;/em&gt; 공급 만이 많은 프레임에서 가져 &lt;em&gt;frame_gen&lt;/em&gt; . 경우 &lt;em&gt;lookup_lines이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 반환 &lt;a href=&quot;#traceback.FrameSummary&quot;&gt; &lt;code&gt;FrameSummary&lt;/code&gt; &lt;/a&gt; 개체가 생성하는 비용하고, 아직 자신의 라인을 읽을 필요가 없습니다 &lt;a href=&quot;#traceback.StackSummary&quot;&gt; &lt;code&gt;StackSummary&lt;/code&gt; 을&lt;/a&gt; 저렴 (실제로 포맷되지 않을 수 있습니다 경우에 도움이 될 수있다). &lt;em&gt;capture_locals&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 각 &lt;a href=&quot;#traceback.FrameSummary&quot;&gt; &lt;code&gt;FrameSummary&lt;/code&gt; &lt;/a&gt; 의 로컬 변수는 객체 표현으로 캡처됩니다.</target>
        </trans-unit>
        <trans-unit id="9ab87e10d3d835d14c47f616a3c51abbf809ee1f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_buffering&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;flush()&lt;/code&gt; is implied when a call to write contains a newline character or a carriage return.</source>
          <target state="translated">&lt;em&gt;line_buffering&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 쓰기 호출에 줄 바꾸기 문자 또는 캐리지 리턴이 포함되면 &lt;code&gt;flush()&lt;/code&gt; 가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="723be276409e68c389387a7fa507f58dd05a3b3c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_info&lt;/em&gt; is true, line number information will be included for all terminal tokens as a third element of the list representing the token. Note that the line number provided specifies the line on which the token &lt;em&gt;ends&lt;/em&gt;. This information is omitted if the flag is false or omitted.</source>
          <target state="translated">경우 &lt;em&gt;line_info는&lt;/em&gt; 사실, 행 번호 정보를 나타내는 토큰리스트의 세 번째 요소로서 모든 단말 토큰 포함한다. 제공된 줄 번호는 토큰이 &lt;em&gt;끝나는&lt;/em&gt; 줄을 지정합니다 . 플래그가 false이거나 생략되면이 정보는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="a4aca6b106e2f5c8314da4294c104be01489c777" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;line_info&lt;/em&gt; is true, line number information will be included for all terminal tokens as a third element of the list representing the token. This information is omitted if the flag is false or omitted.</source>
          <target state="translated">경우 &lt;em&gt;line_info는&lt;/em&gt; 사실, 행 번호 정보를 나타내는 토큰리스트의 세 번째 요소로서 모든 단말 토큰 포함한다. 플래그가 false이거나 생략되면이 정보는 생략됩니다.</target>
        </trans-unit>
        <trans-unit id="33fc9ad31dc069d4994bc5cc54acaf1808e638de" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;linesep&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, use it as the separator character between all the lines of the flattened message. If &lt;em&gt;linesep&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), use the value specified in the &lt;em&gt;policy&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;linesep&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 병합 된 메시지의 모든 행 사이의 구분 문자로 사용하십시오. 경우 &lt;em&gt;linesep가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; (기본값)에 지정된 값 사용 &lt;em&gt;정책을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="1569426afcc62ae89d6a7fcd1beae10acbe198a6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;locale&lt;/em&gt; is given and not &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; modifies the locale setting for the &lt;em&gt;category&lt;/em&gt;. The available categories are listed in the data description below. &lt;em&gt;locale&lt;/em&gt; may be a string, or an iterable of two strings (language code and encoding). If it&amp;rsquo;s an iterable, it&amp;rsquo;s converted to a locale name using the locale aliasing engine. An empty string specifies the user&amp;rsquo;s default settings. If the modification of the locale fails, the exception &lt;a href=&quot;#locale.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised. If successful, the new locale setting is returned.</source>
          <target state="translated">경우 &lt;em&gt;로케일&lt;/em&gt; 이 아닌 주어 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 수정에게 대한 로케일 설정 &lt;em&gt;범주를&lt;/em&gt; . 사용 가능한 범주는 아래 데이터 설명에 나열되어 있습니다. &lt;em&gt;로케일&lt;/em&gt; 은 문자열이거나 두 개의 문자열 (언어 코드 및 인코딩)의 반복 가능일 수 있습니다. iterable 인 경우, 로케일 별명 엔진을 사용하여 로케일 이름으로 변환됩니다. 빈 문자열은 사용자의 기본 설정을 지정합니다. 로케일 수정이 실패하면 예외 &lt;a href=&quot;#locale.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 성공하면 새 로캘 설정이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="951c3928ce25063e5377b210aad3f1281db3bfa5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;locale&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, the current setting for &lt;em&gt;category&lt;/em&gt; is returned.</source>
          <target state="translated">경우 &lt;em&gt;로케일이&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 현재 설정 &lt;em&gt;카테고리가&lt;/em&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="9f4491f562e18db7a7f85c5110ce868482f309ac" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;localedir&lt;/em&gt; is not given, then the default system locale directory is used. &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; If &lt;em&gt;languages&lt;/em&gt; is not given, then the following environment variables are searched: &lt;code id=&quot;index-5&quot;&gt;LANGUAGE&lt;/code&gt;, &lt;code id=&quot;index-6&quot;&gt;LC_ALL&lt;/code&gt;, &lt;code id=&quot;index-7&quot;&gt;LC_MESSAGES&lt;/code&gt;, and &lt;code id=&quot;index-8&quot;&gt;LANG&lt;/code&gt;. The first one returning a non-empty value is used for the &lt;em&gt;languages&lt;/em&gt; variable. The environment variables should contain a colon separated list of languages, which will be split on the colon to produce the expected list of language code strings.</source>
          <target state="translated">경우 &lt;em&gt;localedir가&lt;/em&gt; 지정되어 있지 않은 경우, 기본 시스템 로케일 디렉토리가 사용됩니다. &lt;a href=&quot;#id4&quot; id=&quot;id2&quot;&gt;이&lt;/a&gt; 경우 &lt;em&gt;언어가&lt;/em&gt; 지정되어 있지 않은 경우, 다음과 같은 환경 변수가 검색됩니다 : &lt;code id=&quot;index-5&quot;&gt;LANGUAGE&lt;/code&gt; , &lt;code id=&quot;index-6&quot;&gt;LC_ALL&lt;/code&gt; , &lt;code id=&quot;index-7&quot;&gt;LC_MESSAGES&lt;/code&gt; 및 &lt;code id=&quot;index-8&quot;&gt;LANG&lt;/code&gt; . 비어 있지 않은 값을 반환하는 첫 번째 값은 &lt;em&gt;언어&lt;/em&gt; 변수에 사용됩니다. 환경 변수는 콜론으로 구분 된 언어 목록을 포함해야하며, 콜론에서 분할되어 예상되는 언어 코드 문자열 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a0d295e26c689b54481242876c86a7d434af28e8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;localedir&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, then the current binding for &lt;em&gt;domain&lt;/em&gt; is returned. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">경우 &lt;em&gt;localedir를&lt;/em&gt; 생략하거나한다 &lt;code&gt;None&lt;/code&gt; 다음 바인딩 현재 &lt;em&gt;도메인이&lt;/em&gt; 반환된다. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dfea24b57f7d4e4b61af9826d1014c7238d0a2c5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then a new lock object is created to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object then that will be used to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then access to the returned object will not be automatically protected by a lock, so it will not necessarily be &amp;ldquo;process-safe&amp;rdquo;.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; (기본) 다음 새 잠금 객체는 값으로 동기화 액세스에 생성됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; A는 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 값으로 동기화 액세스하는 데 사용됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 은 반드시 &quot;공정 안전&quot;이되지 않도록 반환 된 객체에 다음 액세스가 자동으로 잠금으로 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fb5a29a93024c0c287ced20dc12603ed825400c5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default) then a new recursive lock object is created to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object then that will be used to synchronize access to the value. If &lt;em&gt;lock&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then access to the returned object will not be automatically protected by a lock, so it will not necessarily be &amp;ldquo;process-safe&amp;rdquo;.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; (기본) 다음 새 재귀 락 객체는 값으로 동기화 액세스에 생성됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; A는 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 값으로 동기화 액세스하는 데 사용됩니다. 경우 &lt;em&gt;잠금&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 은 반드시 &quot;공정 안전&quot;이되지 않도록 반환 된 객체에 다음 액세스가 자동으로 잠금으로 보호되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2602fc87b0876ba602ab00278259ea7a79f410d1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is specified then it should be a &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object from &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;lock&lt;/em&gt; 을 지정 하면 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체 여야 합니다 .</target>
        </trans-unit>
        <trans-unit id="bab9a02062082eb583249e7a6e16be3658394be6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;lock&lt;/em&gt; is supplied then it should be a proxy for a &lt;a href=&quot;threading#threading.Lock&quot;&gt;&lt;code&gt;threading.Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;threading#threading.RLock&quot;&gt;&lt;code&gt;threading.RLock&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;lock&lt;/em&gt; 이 제공 되면 &lt;a href=&quot;threading#threading.Lock&quot;&gt; &lt;code&gt;threading.Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;threading#threading.RLock&quot;&gt; &lt;code&gt;threading.RLock&lt;/code&gt; &lt;/a&gt; 객체 의 프록시 여야 합니다.</target>
        </trans-unit>
        <trans-unit id="590cdff25c02f75a07edf4cd1b5590e71db1db65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; is used for getting current loop.</source>
          <target state="translated">경우 &lt;em&gt;루프는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 전류 루프를 얻기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="937d955e2d780cdb674a48ea2b8300a8b1629db0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt; function is used to get the current loop.</source>
          <target state="translated">경우 &lt;em&gt;루프가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 상기 &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; 함수는 전류 루프를 얻기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="c63129023a997a153b9588c1c5afcfaec61cc024" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;&lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; is used to get the current loop.</source>
          <target state="translated">&lt;em&gt;loop&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 는 현재 루프를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="34f3c105305570e37994220800780f4e1998f389" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;max_length&lt;/em&gt; is nonnegative, returns at most &lt;em&gt;max_length&lt;/em&gt; bytes of decompressed data. If this limit is reached and further output can be produced, the &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;False&lt;/code&gt;. In this case, the next call to &lt;a href=&quot;#bz2.BZ2Decompressor.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; may provide &lt;em&gt;data&lt;/em&gt; as &lt;code&gt;b''&lt;/code&gt; to obtain more of the output.</source>
          <target state="translated">&lt;em&gt;max_length&lt;/em&gt; 가 음수가 아닌 경우 최대 &lt;em&gt;max_length&lt;/em&gt; 바이트의 압축 해제 된 데이터를 반환 합니다. 이 한계에 도달하고 추가 출력을 생성 할 수 있으면 &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성이 &lt;code&gt;False&lt;/code&gt; 로 설정됩니다 . 이 경우, &lt;a href=&quot;#bz2.BZ2Decompressor.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출은 더 많은 출력을 얻기 위해 &lt;code&gt;b''&lt;/code&gt; 로 &lt;em&gt;데이터&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe10ae05e553743d5c3d20d35ac3316877086f58" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;max_length&lt;/em&gt; is nonnegative, returns at most &lt;em&gt;max_length&lt;/em&gt; bytes of decompressed data. If this limit is reached and further output can be produced, the &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;False&lt;/code&gt;. In this case, the next call to &lt;a href=&quot;#lzma.LZMADecompressor.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; may provide &lt;em&gt;data&lt;/em&gt; as &lt;code&gt;b''&lt;/code&gt; to obtain more of the output.</source>
          <target state="translated">&lt;em&gt;max_length&lt;/em&gt; 가 음수가 아닌 경우 최대 &lt;em&gt;max_length&lt;/em&gt; 바이트의 압축 해제 된 데이터를 반환 합니다. 이 한계에 도달하고 추가 출력을 생성 할 수 있으면 &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성이 &lt;code&gt;False&lt;/code&gt; 로 설정됩니다 . 이 경우, &lt;a href=&quot;#lzma.LZMADecompressor.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출은 더 많은 출력을 얻기 위해 &lt;code&gt;b''&lt;/code&gt; 로 &lt;em&gt;데이터&lt;/em&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10be81d98bdd051152d5d0719d26439da8df03a1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxheaderlen&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, refold any header lines that are longer than &lt;em&gt;maxheaderlen&lt;/em&gt;, or if &lt;code&gt;0&lt;/code&gt;, do not rewrap any headers. If &lt;em&gt;manheaderlen&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), wrap headers and other message lines according to the &lt;em&gt;policy&lt;/em&gt; settings.</source>
          <target state="translated">&lt;em&gt;maxheaderlen&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;em&gt;maxheaderlen&lt;/em&gt; 보다 긴 헤더 행을 다시 접 거나 &lt;code&gt;0&lt;/code&gt; 이면 헤더를 다시 &lt;em&gt;랩핑&lt;/em&gt; 하지 마십시오. 경우 &lt;em&gt;manheaderlen는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; (기본값), 랩 헤더와에 따라 다른 메시지 라인 &lt;em&gt;정책&lt;/em&gt; 설정은.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="422ba7aa2a79e6f2f30ccbe4d45f0fb30ec13a07" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxlen&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, deques may grow to an arbitrary length. Otherwise, the deque is bounded to the specified maximum length. Once a bounded length deque is full, when new items are added, a corresponding number of items are discarded from the opposite end. Bounded length deques provide functionality similar to the &lt;code&gt;tail&lt;/code&gt; filter in Unix. They are also useful for tracking transactions and other pools of data where only the most recent activity is of interest.</source>
          <target state="translated">경우 &lt;em&gt;MAXLEN가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; , deques는 임의의 길이로 성장할 수 있습니다. 그렇지 않으면, deque는 지정된 최대 길이로 제한됩니다. 제한된 길이의 디크가 가득 차면 새 항목이 추가 될 때 해당하는 수의 항목이 반대쪽 끝에서 삭제됩니다. 경계 길이 디케는 Unix 의 &lt;code&gt;tail&lt;/code&gt; 필터 와 유사한 기능을 제공합니다 . 또한 가장 최근 활동 만 관심있는 트랜잭션 및 기타 데이터 풀을 추적하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2aec9f480deb51e518e61c9512cb8347bbb35566" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxlength&lt;/em&gt; is specified and the message is longer than &lt;em&gt;maxlength&lt;/em&gt; then &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised and the connection will no longer be readable.</source>
          <target state="translated">경우 &lt;em&gt;최대 길이가&lt;/em&gt; 지정 메시지가보다 더 오래입니다 &lt;em&gt;최대 길이&lt;/em&gt; 다음 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생하지 않습니다 및 연결이 더 이상 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdda2ebb0037d0b6d351503e46dedbec8240b68d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxsize&lt;/em&gt; is less than or equal to zero, the queue size is infinite. If it is an integer greater than &lt;code&gt;0&lt;/code&gt;, then &lt;code&gt;await put()&lt;/code&gt; blocks when the queue reaches &lt;em&gt;maxsize&lt;/em&gt; until an item is removed by &lt;a href=&quot;#asyncio.Queue.get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;MAXSIZE가&lt;/em&gt; 제로와 동일보다 작은 경우, 큐 크기는 무한하다. 그것보다 정수 큰 경우는 &lt;code&gt;0&lt;/code&gt; , 다음 &lt;code&gt;await put()&lt;/code&gt; 블록 큐에 도달 때 &lt;em&gt;maxsize와&lt;/em&gt; 항목이 제거 될 때까지 &lt;a href=&quot;#asyncio.Queue.get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d13e6738c5550a08c08c3e50baa5d941e96c9586" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxsize&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, the LRU feature is disabled and the cache can grow without bound.</source>
          <target state="translated">경우 &lt;em&gt;MAXSIZE가&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; 의 LRU 기능이 비활성화되고 캐시가 경계없이 성장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="476559880ef6db18fddff1363483c9ce4ae594eb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;maxsize&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, the LRU feature is disabled and the cache can grow without bound. The LRU feature performs best when &lt;em&gt;maxsize&lt;/em&gt; is a power-of-two.</source>
          <target state="translated">경우 &lt;em&gt;MAXSIZE가&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; 의 LRU 기능이 비활성화되고 캐시가 경계없이 성장할 수 있습니다. LRU 기능은 &lt;em&gt;maxsize&lt;/em&gt; 가 2의 거듭 제곱 일 때 가장 잘 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="fdb0dec0e620351e0bbd4aec3590e50d3841d53d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;message&lt;/em&gt; is omitted, the new instance is created in a default, empty state. If &lt;em&gt;message&lt;/em&gt; is an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance, its contents are copied; furthermore, any format-specific information is converted insofar as possible if &lt;em&gt;message&lt;/em&gt; is a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance. If &lt;em&gt;message&lt;/em&gt; is a string, a byte string, or a file, it should contain an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant message, which is read and parsed. Files should be open in binary mode, but text mode files are accepted for backward compatibility.</source>
          <target state="translated">경우 &lt;em&gt;메시지가&lt;/em&gt; 생략되고, 새로운 인스턴스는 기본, 빈 상태로 생성됩니다. 경우 &lt;em&gt;메시지가&lt;/em&gt; 입니다 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; 의&lt;/a&gt; 경우, 그 내용이 복사됩니다; 또한, &lt;em&gt;메시지&lt;/em&gt; 가 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스 인 경우 형식 별 정보는 가능한 한 변환됩니다 . 경우 &lt;em&gt;메시지&lt;/em&gt; 문자열, 바이트 문자열, 또는 파일입니다, 그것은 포함해야 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 를 읽고 구문 분석 호환 메시지를. 파일은 이진 모드로 열어야하지만 텍스트 모드 파일은 이전 버전과의 호환성을 위해 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="4cdc2a6c5973e55d431189d76aeebd82bf0b0c31" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;method&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then the default context is returned. Otherwise &lt;em&gt;method&lt;/em&gt; should be &lt;code&gt;'fork'&lt;/code&gt;, &lt;code&gt;'spawn'&lt;/code&gt;, &lt;code&gt;'forkserver'&lt;/code&gt;. &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if the specified start method is not available.</source>
          <target state="translated">경우 &lt;em&gt;방법은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 다음 기본 컨텍스트가 반환됩니다. 그렇지 않으면 &lt;em&gt;메소드&lt;/em&gt; 는 &lt;code&gt;'fork'&lt;/code&gt; , &lt;code&gt;'spawn'&lt;/code&gt; , &lt;code&gt;'forkserver'&lt;/code&gt; 여야 합니다. 지정된 시작 방법을 사용할 수 없으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ea5b1e7d5baff8f354aa38723d8e2f2c3c8b26f4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;missing_ok&lt;/em&gt; is false (the default), &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; is raised if the path does not exist.</source>
          <target state="translated">경우 &lt;em&gt;missing_ok가&lt;/em&gt; false (기본값), &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 는&lt;/a&gt; 경로가 존재하지 않는 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99eaa9a1562cd18740313159312a1e81d02af31f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;missing_ok&lt;/em&gt; is true, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt; exceptions will be ignored (same behavior as the POSIX &lt;code&gt;rm -f&lt;/code&gt; command).</source>
          <target state="translated">경우 &lt;em&gt;missing_ok는&lt;/em&gt; 사실, &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 의&lt;/a&gt; 예외합니다 (POSIX와 같은 행동을 무시됩니다 &lt;code&gt;rm -f&lt;/code&gt; 명령).</target>
        </trans-unit>
        <trans-unit id="ec95478d66e5bfa1b027996891cada38eb37683d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;a href=&quot;#os.P_NOWAIT&quot;&gt;&lt;code&gt;P_NOWAIT&lt;/code&gt;&lt;/a&gt;, this function returns the process id of the new process; if &lt;em&gt;mode&lt;/em&gt; is &lt;a href=&quot;#os.P_WAIT&quot;&gt;&lt;code&gt;P_WAIT&lt;/code&gt;&lt;/a&gt;, returns the process&amp;rsquo;s exit code if it exits normally, or &lt;code&gt;-signal&lt;/code&gt;, where &lt;em&gt;signal&lt;/em&gt; is the signal that killed the process. On Windows, the process id will actually be the process handle, so can be used with the &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 입니다 &lt;a href=&quot;#os.P_NOWAIT&quot;&gt; &lt;code&gt;P_NOWAIT&lt;/code&gt; &lt;/a&gt; ,이 기능은 새로운 프로세스의 프로세스 ID를 반환 경우 &lt;em&gt;모드&lt;/em&gt; 입니다 &lt;a href=&quot;#os.P_WAIT&quot;&gt; &lt;code&gt;P_WAIT&lt;/code&gt; &lt;/a&gt; 정상적으로, 또는 종료하는 경우, 프로세스의 종료 코드를 반환합니다 &lt;code&gt;-signal&lt;/code&gt; 곳, &lt;em&gt;신호가&lt;/em&gt; 프로세스를 죽인 신호입니다. Windows에서 프로세스 ID는 실제로 프로세스 핸들이므로 &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 함수 와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d0375733b9f4f50742e4972b7f050e92927d8849" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt;, the input file may be the concatenation of multiple compressed streams.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'r'&lt;/code&gt; , 입력 파일은 다수의 압축 스트림의 연결 일 수있다.</target>
        </trans-unit>
        <trans-unit id="814277edd95a4cd9bd45db5f9fa454a24e7e3f22" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'w'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, &lt;em&gt;compresslevel&lt;/em&gt; can be an integer between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; specifying the level of compression: &lt;code&gt;1&lt;/code&gt; produces the least compression, and &lt;code&gt;9&lt;/code&gt; (default) produces the most compression.</source>
          <target state="translated">경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'w'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; , &lt;em&gt;compresslevel은&lt;/em&gt; 사이의 정수일 수 &lt;code&gt;1&lt;/code&gt; 및 &lt;code&gt;9&lt;/code&gt; : 압축률을 지정하는 &lt;code&gt;1&lt;/code&gt; 최소 압축을 생성하고, &lt;code&gt;9&lt;/code&gt; (기본값)은 가장 압축을 생성한다.</target>
        </trans-unit>
        <trans-unit id="3992701b4ac0def94c8a1290fc024926c3c7f6d8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, no attempt to find the module will be made. This is obscure, of use mostly in testing doctest itself: if &lt;em&gt;module&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, or is &lt;code&gt;None&lt;/code&gt; but cannot be found automatically, then all objects are considered to belong to the (non-existent) module, so all contained objects will (recursively) be searched for doctests.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 이면 &lt;em&gt;모듈&lt;/em&gt; 을 찾으려고 시도하지 않습니다. 이것은 주로 자체 doctest가 테스트에 사용하기에, 불분명 다음의 경우 &lt;em&gt;모듈&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; , 또는없는 &lt;code&gt;None&lt;/code&gt; 있지만, 자동으로 찾을 수없는, 모든 객체는 (존재하지 않는) 모듈에 속하는 것으로 간주됩니다 그래서 모든 포함 된 개체 것이다 (재귀 적으로) doctest를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="342c503a565a339b191d71f66fedb8027cd7cd94" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module&lt;/em&gt; is defined, the &lt;code&gt;__module__&lt;/code&gt; attribute of the named tuple is set to that value.</source>
          <target state="translated">경우에 &lt;em&gt;모듈이&lt;/em&gt; 정의되어 상기 &lt;code&gt;__module__&lt;/code&gt; 명명 튜플의 속성이 값으로 설정된다.</target>
        </trans-unit>
        <trans-unit id="cf7e207e25f4af78f648134ee99a7b39d012d8fc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, then &lt;em&gt;filename&lt;/em&gt; specifies an OS-specific path. The path may be absolute or relative; relative paths are resolved with respect to the current working directory.</source>
          <target state="translated">경우 &lt;em&gt;module_relative은&lt;/em&gt; 이다 &lt;code&gt;False&lt;/code&gt; , 다음 &lt;em&gt;파일 이름&lt;/em&gt; OS에 특정 경로 지정을. 경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 현재 작업 디렉토리와 관련하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="7f42640a3bf95f21f7a92a899894943811c847d3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, then each filename in &lt;em&gt;paths&lt;/em&gt; specifies an OS-specific path. The path may be absolute or relative; relative paths are resolved with respect to the current working directory.</source>
          <target state="translated">&lt;em&gt;module_relative&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;경로의&lt;/em&gt; 각 파일 이름 은 OS 별 경로를 지정합니다. 경로는 절대적이거나 상대적 일 수 있습니다. 상대 경로는 현재 작업 디렉토리와 관련하여 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="0697d5b67fdf347746c9d5703805474938f31243" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), then &lt;em&gt;filename&lt;/em&gt; specifies an OS-independent module-relative path. By default, this path is relative to the calling module&amp;rsquo;s directory; but if the &lt;em&gt;package&lt;/em&gt; argument is specified, then it is relative to that package. To ensure OS-independence, &lt;em&gt;filename&lt;/em&gt; should use &lt;code&gt;/&lt;/code&gt; characters to separate path segments, and may not be an absolute path (i.e., it may not begin with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;em&gt;module_relative가&lt;/em&gt; 인 &lt;code&gt;True&lt;/code&gt; (디폴트), 다음 &lt;em&gt;파일 이름은&lt;/em&gt; OS에 독립적 인 모듈의 상대 경로를 지정한다. 기본적으로이 경로는 호출 모듈의 디렉토리에 상대적입니다. 그러나 &lt;em&gt;package&lt;/em&gt; 인수가 지정되면 해당 패키지와 관련이 있습니다. OS 독립성을 보장하기 위해 &lt;em&gt;filename&lt;/em&gt; 은 &lt;code&gt;/&lt;/code&gt; 문자를 사용 하여 경로 세그먼트를 구분해야하며 절대 경로가 아닐 수 있습니다 (예 : &lt;code&gt;/&lt;/code&gt; 로 시작하지 않을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="8d02f9fb85e6627d59eb80ccf4ea6b3a9b4d8c95" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;module_relative&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; (the default), then each filename in &lt;em&gt;paths&lt;/em&gt; specifies an OS-independent module-relative path. By default, this path is relative to the calling module&amp;rsquo;s directory; but if the &lt;em&gt;package&lt;/em&gt; argument is specified, then it is relative to that package. To ensure OS-independence, each filename should use &lt;code&gt;/&lt;/code&gt; characters to separate path segments, and may not be an absolute path (i.e., it may not begin with &lt;code&gt;/&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;em&gt;module_relative는&lt;/em&gt; 인 &lt;code&gt;True&lt;/code&gt; (기본)의 각 파일명 &lt;em&gt;경로&lt;/em&gt; 지정하는 OS 독립 모듈 상대 경로. 기본적으로이 경로는 호출 모듈의 디렉토리에 상대적입니다. 그러나 &lt;em&gt;package&lt;/em&gt; 인수가 지정되면 해당 패키지와 관련이 있습니다. OS 독립성을 보장하기 위해 각 파일 이름은 &lt;code&gt;/&lt;/code&gt; 문자를 사용 하여 경로 세그먼트를 구분해야하며 절대 경로가 아닐 수 있습니다 (즉, &lt;code&gt;/&lt;/code&gt; 로 시작하지 않을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="d91389354c01f8abc2286ef2886fcba27cafd30c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;monetary&lt;/em&gt; is true, the conversion uses monetary thousands separator and grouping strings.</source>
          <target state="translated">경우 &lt;em&gt;통화는&lt;/em&gt; 사실, 변환은 통화 천 단위 구분 및 그룹화 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b66af921caa012e5b11170246ad9eb33b73367d2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;mutate_flag&lt;/em&gt; is true (the default), then the buffer is (in effect) passed to the underlying &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt; system call, the latter&amp;rsquo;s return code is passed back to the calling Python, and the buffer&amp;rsquo;s new contents reflect the action of the &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt;. This is a slight simplification, because if the supplied buffer is less than 1024 bytes long it is first copied into a static buffer 1024 bytes long which is then passed to &lt;a href=&quot;#fcntl.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt; and copied back into the supplied buffer.</source>
          <target state="translated">경우 &lt;em&gt;mutate_flag가&lt;/em&gt; true (디폴트), 다음 버퍼가 기본으로 전달 (효과)입니다 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; 시스템 호출의 후자의 리턴 코드가 호출 파이썬 등을 전달하고, 버퍼의 새로운 내용의 액션 반영 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; . 제공된 버퍼의 길이가 1024 바이트 미만인 경우 먼저 정적 버퍼의 길이가 1024 바이트 인 정적 버퍼로 복사 된 다음 &lt;a href=&quot;#fcntl.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; 로 전달되어 제공된 버퍼로 다시 복사 되기 때문에 약간 단순화됩니다 .</target>
        </trans-unit>
        <trans-unit id="9345507ddde308e47622c6e2a66a95ae7670e925" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is a string and is not known, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. If a specific value for &lt;em&gt;name&lt;/em&gt; is not supported by the host system, even if it is included in &lt;code&gt;confstr_names&lt;/code&gt;, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised with &lt;a href=&quot;errno#errno.EINVAL&quot;&gt;&lt;code&gt;errno.EINVAL&lt;/code&gt;&lt;/a&gt; for the error number.</source>
          <target state="translated">경우 &lt;em&gt;이름은&lt;/em&gt; 문자열이며, 알 수없는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 에 대한 특정 값 경우 &lt;em&gt;이름&lt;/em&gt; 이 포함 된 경우에도, 호스트 시스템에서 지원하지 않는 &lt;code&gt;confstr_names&lt;/code&gt; , &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 이&lt;/a&gt; 제기되고 &lt;a href=&quot;errno#errno.EINVAL&quot;&gt; &lt;code&gt;errno.EINVAL&lt;/code&gt; &lt;/a&gt; 오류 번호.</target>
        </trans-unit>
        <trans-unit id="1a2e0516f0e84799e5f5202bef0b9a437f74ac1b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is a string and is not known, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. If a specific value for &lt;em&gt;name&lt;/em&gt; is not supported by the host system, even if it is included in &lt;code&gt;pathconf_names&lt;/code&gt;, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised with &lt;a href=&quot;errno#errno.EINVAL&quot;&gt;&lt;code&gt;errno.EINVAL&lt;/code&gt;&lt;/a&gt; for the error number.</source>
          <target state="translated">경우 &lt;em&gt;이름은&lt;/em&gt; 문자열이며, 알 수없는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 에 대한 특정 값 경우 &lt;em&gt;이름&lt;/em&gt; 이 포함 된 경우에도, 호스트 시스템에서 지원하지 않는 &lt;code&gt;pathconf_names&lt;/code&gt; , &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 이&lt;/a&gt; 제기되고 &lt;a href=&quot;errno#errno.EINVAL&quot;&gt; &lt;code&gt;errno.EINVAL&lt;/code&gt; &lt;/a&gt; 오류 번호.</target>
        </trans-unit>
        <trans-unit id="1489759a66ae1aa1d73ef33403aebd13063968d9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it is set as the name of the task using &lt;a href=&quot;#asyncio.Task.set_name&quot;&gt;&lt;code&gt;Task.set_name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#asyncio.Task.set_name&quot;&gt; &lt;code&gt;Task.set_name()&lt;/code&gt; &lt;/a&gt; 사용하여 작업 이름으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="9757d615d57917081da1f9a4bda1c19a2f37a8bd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not found, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;이름이&lt;/em&gt; 발견되지 않는, 돌아 오지 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1f6781895f736e401572500b4ef19d36ece9f67" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;name&lt;/em&gt; is not provided in the constructor, the name returned by &lt;code&gt;tzname(dt)&lt;/code&gt; is generated from the value of the &lt;code&gt;offset&lt;/code&gt; as follows. If &lt;em&gt;offset&lt;/em&gt; is &lt;code&gt;timedelta(0)&lt;/code&gt;, the name is &amp;ldquo;UTC&amp;rdquo;, otherwise it is a string in the format &lt;code&gt;UTC&amp;plusmn;HH:MM&lt;/code&gt;, where &amp;plusmn; is the sign of &lt;code&gt;offset&lt;/code&gt;, HH and MM are two digits of &lt;code&gt;offset.hours&lt;/code&gt; and &lt;code&gt;offset.minutes&lt;/code&gt; respectively.</source>
          <target state="translated">경우 &lt;em&gt;이름&lt;/em&gt; 생성자에 제공되지 않고, 이름에 의해 반환 &lt;code&gt;tzname(dt)&lt;/code&gt; 의 값으로부터 생성 된 &lt;code&gt;offset&lt;/code&gt; 은 다음과 같이. 경우 &lt;em&gt;오프셋 (offset)&lt;/em&gt; 입니다 &lt;code&gt;timedelta(0)&lt;/code&gt; , 이름, 그렇지 않으면 형식의 문자열, &quot;UTC&quot;입니다 &lt;code&gt;UTC&amp;plusmn;HH:MM&lt;/code&gt; &amp;plusmn;가의 부호이며, &lt;code&gt;offset&lt;/code&gt; , HH 및 MM은 두 자리하고 있습니다 &lt;code&gt;offset.hours&lt;/code&gt; 및 &lt;code&gt;offset.minutes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34baedb9fa444a6c6bcfd5a19fda6da4eff56aaf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;new&lt;/em&gt; is omitted, then the target is replaced with an &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt;&lt;code&gt;AsyncMock&lt;/code&gt;&lt;/a&gt; if the patched object is an async function or a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; otherwise. If &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is used as a decorator and &lt;em&gt;new&lt;/em&gt; is omitted, the created mock is passed in as an extra argument to the decorated function. If &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; is used as a context manager the created mock is returned by the context manager.</source>
          <target state="translated">경우 &lt;em&gt;새로운는&lt;/em&gt; 생략하고 대상은으로 치환 &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt; &lt;code&gt;AsyncMock&lt;/code&gt; &lt;/a&gt; 패치 된 객체가 비동기 함수 또는 경우 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; , 그렇지. 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 데코레이터로 사용되는 &lt;em&gt;새로운&lt;/em&gt; 생략, 생성 된 모의은 장식 기능을 추가 인수로 전달됩니다. 경우 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자로서 사용하는 생성 모의는 콘텍스트 관리자로 리턴된다.</target>
        </trans-unit>
        <trans-unit id="bdbb8a0ef01210cf36a93be1fc72449e2c9a07dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;newindex&lt;/em&gt; is specified, sets the combobox value to the element position &lt;em&gt;newindex&lt;/em&gt;. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.</source>
          <target state="translated">경우 &lt;em&gt;와 newIndex가&lt;/em&gt; 지정되어, 소자의 위치에 콤보 값 세트 &lt;em&gt;와 newIndex&lt;/em&gt; . 그렇지 않으면 현재 값의 색인을 리턴하거나 현재 값이 값 목록에없는 경우 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e337316c1e611ca8905f1e941e19e507d1281cae" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;ns&lt;/em&gt; is specified, it must be a 2-tuple of the form &lt;code&gt;(atime_ns, mtime_ns)&lt;/code&gt; where each member is an int expressing nanoseconds.</source>
          <target state="translated">경우 &lt;em&gt;NS가&lt;/em&gt; 지정되어, 상기 형태의 2- 튜플이어야 &lt;code&gt;(atime_ns, mtime_ns)&lt;/code&gt; 각 부재 나노초 표현한 INT이다.</target>
        </trans-unit>
        <trans-unit id="17680ea1c66682ed7ecb735074a91fe5b504f141" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;numeric_owner&lt;/em&gt; is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, the uid and gid numbers from the tarfile are used to set the owner/group for the extracted files. Otherwise, the named values from the tarfile are used.</source>
          <target state="translated">&lt;em&gt;numeric_owner&lt;/em&gt; 가 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 인 경우 tar 파일의 uid 및 gid 번호가 추출 된 파일의 소유자 / 그룹을 설정하는 데 사용됩니다. 그렇지 않으면 tarfile의 명명 된 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27c4c94e6ce3ccf84f7ed2aea1284d8994324b1c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;obj&lt;/em&gt; is neither of the above a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 위의 어느 것도 아닌 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="26791b8e13e2f8fc527c3deabc666fe937e4ae87" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;offset&lt;/em&gt; is given then data is read from that position in &lt;em&gt;buffer&lt;/em&gt;. If &lt;em&gt;size&lt;/em&gt; is given then that many bytes will be read from buffer. Very large buffers (approximately 32 MiB+, though it depends on the OS) may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; exception</source>
          <target state="translated">경우 &lt;em&gt;오프셋&lt;/em&gt; 지정되고있는 데이터의 그 위치로부터 판독되어 &lt;em&gt;버퍼&lt;/em&gt; . 경우 &lt;em&gt;크기가&lt;/em&gt; 지정되고있는 바이트 버퍼에서 읽어됩니다. 매우 큰 버퍼 (OS에 따라 다르지만 대략 32MiB +)에 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 예외가 발생할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1eb1415e8bf69142526ae3a0d79981219d8743ee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;onerror&lt;/em&gt; is provided, it must be a callable that accepts three parameters: &lt;em&gt;function&lt;/em&gt;, &lt;em&gt;path&lt;/em&gt;, and &lt;em&gt;excinfo&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;의 OnError가&lt;/em&gt; : 제공, 그것은 세 개의 매개 변수를 허용하는 호출해야합니다 &lt;em&gt;기능&lt;/em&gt; , &lt;em&gt;경로&lt;/em&gt; 및 &lt;em&gt;excinfo을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="7a54a6cff529e67ad9256b50db56cfc700f1a554" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;outcome&lt;/em&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the subtest succeeded. Otherwise, it failed with an exception where &lt;em&gt;outcome&lt;/em&gt; is a tuple of the form returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;(type, value, traceback)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;결과가&lt;/em&gt; 없습니다 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 하위 검사는 성공했다. 그렇지 않으면 &lt;em&gt;결과&lt;/em&gt; 가 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;(type, value, traceback)&lt;/code&gt; 반환 한 형식의 튜플 인 경우를 제외하고 실패했습니다 .</target>
        </trans-unit>
        <trans-unit id="a3b88cfef8d16d5c39cd9551217cde560b733287" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pad&lt;/em&gt; is true, the input is padded with &lt;code&gt;b'\0'&lt;/code&gt; so its length is a multiple of 4 bytes before encoding.</source>
          <target state="translated">경우에 &lt;em&gt;패드는&lt;/em&gt; 참 입력으로는 패딩 &lt;code&gt;b'\0'&lt;/code&gt; 의 길이 부호화 전의 4 바이트의 배수가되도록.</target>
        </trans-unit>
        <trans-unit id="21c2c919a75ee69d0dcd72db6a0617293d88b398" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;padded&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the first line of a multi-line statement will be padded with spaces to match its original position.</source>
          <target state="translated">&lt;em&gt;padded&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 여러 줄 문의 첫 번째 줄은 원래 위치와 일치하는 공백으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="122ddd43051ad3f6afe1e426367c921264fdf80e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;params&lt;/em&gt; is specified, iterate its &lt;code&gt;items&lt;/code&gt; method and use the resulting &lt;code&gt;(key, value)&lt;/code&gt; pairs to set additional parameters on the &lt;em&gt;Content-Type&lt;/em&gt; header.</source>
          <target state="translated">경우 &lt;em&gt;PARAMS는&lt;/em&gt; 반복, 그 지정 &lt;code&gt;items&lt;/code&gt; 방법 및 결과 사용 &lt;code&gt;(key, value)&lt;/code&gt; 상의 추가 매개 변수를 설정하는 쌍을 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="d2742098af95f156e52d71eb33134930cc5b2d2b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;parents&lt;/em&gt; is false (the default), a missing parent raises &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt;&lt;code&gt;FileNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;부모가&lt;/em&gt; false (기본값), 누락 된 부모 제기 &lt;a href=&quot;exceptions#FileNotFoundError&quot;&gt; &lt;code&gt;FileNotFoundError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c4c366ed6d7e659455c85c50fcab426cfddafe8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;parents&lt;/em&gt; is true, any missing parents of this path are created as needed; they are created with the default permissions without taking &lt;em&gt;mode&lt;/em&gt; into account (mimicking the POSIX &lt;code&gt;mkdir -p&lt;/code&gt; command).</source>
          <target state="translated">경우 &lt;em&gt;부모가&lt;/em&gt; 사실 필요에 따라,이 경로의 누락 부모가 만들어집니다; POSIX &lt;code&gt;mkdir -p&lt;/code&gt; 명령을 모방 한 &lt;em&gt;모드&lt;/em&gt; 를 고려 하지 않고 기본 권한으로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bfb728e63dc4d6becb096af8bffbd3133d9658f2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;path&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the temporary directory is created using &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the context manager raises an exception on error. Otherwise, if &lt;em&gt;path&lt;/em&gt; is specified and cannot be created, only a warning is issued.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; 사용하여 임시 디렉토리가 작성됩니다 . 경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 상황에 맞는 관리자 오류에 예외를 발생시킵니다. 그렇지 않으면 &lt;em&gt;경로&lt;/em&gt; 가 지정되어 작성 될 수없는 경우 경고 만 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="279e8821e221ab83a590df5547bdc8fe83b891ad" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pathname&lt;/em&gt; is a file, the filename must end with &lt;code&gt;.py&lt;/code&gt;, and just the (corresponding &lt;code&gt;*.pyc&lt;/code&gt;) file is added at the top level (no path information). If &lt;em&gt;pathname&lt;/em&gt; is a file that does not end with &lt;code&gt;.py&lt;/code&gt;, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; will be raised. If it is a directory, and the directory is not a package directory, then all the files &lt;code&gt;*.pyc&lt;/code&gt; are added at the top level. If the directory is a package directory, then all &lt;code&gt;*.pyc&lt;/code&gt; are added under the package name as a file path, and if any subdirectories are package directories, all of these are added recursively in sorted order.</source>
          <target state="translated">경우 &lt;em&gt;경로는&lt;/em&gt; 파일이며, 파일 이름이 끝나야 &lt;code&gt;.py&lt;/code&gt; , 단지 (대응 &lt;code&gt;*.pyc&lt;/code&gt; ) 파일은 최상위 (NO 경로 정보)에 부가된다. 경우 &lt;em&gt;경로 이름&lt;/em&gt; 으로 끝나지 않는 파일입니다 &lt;code&gt;.py&lt;/code&gt; 하는 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에이&lt;/a&gt; 발생합니다. 디렉토리이고 디렉토리가 패키지 디렉토리가 아닌 경우 모든 파일 &lt;code&gt;*.pyc&lt;/code&gt; 가 최상위 레벨에 추가됩니다. 디렉토리가 패키지 디렉토리 인 경우, 모든 &lt;code&gt;*.pyc&lt;/code&gt; 는 패키지 이름 아래에 파일 경로로 추가되며, 서브 디렉토리가 패키지 디렉토리 인 경우, 모든 디렉토리는 재귀 적으로 정렬 된 순서로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="41b2681b700b43aa39bbefe5e6b6c8affd770518" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is absolute, the path must be absolute, and the whole path must match:</source>
          <target state="translated">경우 &lt;em&gt;패턴이&lt;/em&gt; 절대 경로는 절대이어야하며, 전체 경로가 일치해야합니다 :</target>
        </trans-unit>
        <trans-unit id="dc3dc34c3e256a8f40643eeec54c50b0a72ef1b0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pattern&lt;/em&gt; is relative, the path can be either relative or absolute, and matching is done from the right:</source>
          <target state="translated">&lt;em&gt;패턴&lt;/em&gt; 이 상대적인 경우 경로는 상대 또는 절대 일 수 있으며 오른쪽에서 일치가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ae4f495484349c434b35e20b4a937b07e53b6277" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;pid&lt;/em&gt; is greater than &lt;code&gt;0&lt;/code&gt;, &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; requests status information for that specific process. If &lt;em&gt;pid&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt;, the request is for the status of any child in the process group of the current process. If &lt;em&gt;pid&lt;/em&gt; is &lt;code&gt;-1&lt;/code&gt;, the request pertains to any child of the current process. If &lt;em&gt;pid&lt;/em&gt; is less than &lt;code&gt;-1&lt;/code&gt;, status is requested for any process in the process group &lt;code&gt;-pid&lt;/code&gt; (the absolute value of &lt;em&gt;pid&lt;/em&gt;).</source>
          <target state="translated">경우 &lt;em&gt;pid는&lt;/em&gt; 보다 큰 &lt;code&gt;0&lt;/code&gt; , &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 특정 프로세스에 대한 상태 정보를 요청합니다. 경우 &lt;em&gt;pid는&lt;/em&gt; 것입니다 &lt;code&gt;0&lt;/code&gt; , 요청은 현재 프로세스의 프로세스 그룹에있는 아이의 상태입니다. 경우 &lt;em&gt;PID가&lt;/em&gt; 있다 &lt;code&gt;-1&lt;/code&gt; , 현재 프로세스의 자식에 대한 요청이 속하는. 경우 &lt;em&gt;, PID는&lt;/em&gt; 11보다 &lt;code&gt;-1&lt;/code&gt; , 상태는 프로세스 그룹의 모든 프로세스에 대해 요구되는 &lt;code&gt;-pid&lt;/code&gt; (의 절대치 &lt;em&gt;PID&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="158f301a96505e39d53ef0b213995b204eb36ca6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, the default policy is restored.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; , 기본 정책이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="a33cda1caeb8620df4cbd866550cefe362b20013" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified (it must be an instance of a &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; class) use the rules it specifies to update and serialize the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy, which maintains backward compatibility with the Python 3.2 version of the email package. For more information see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 지정됩니다 (인스턴스해야 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 이 업데이트 메시지의 표현을 직렬화 지정 규칙을 사용하여 클래스). 경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 있지 않은, 사용 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 전자 메일 패키지의 파이썬 3.2 버전과 이전 버전과의 호환성을 유지 정책을. 자세한 내용은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b06b36408a6fd37b66a32d5d1725489b1aa43b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified use the rules it specifies to update and serialize the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.default&quot;&gt;&lt;code&gt;default&lt;/code&gt;&lt;/a&gt; policy, which follows the rules of the email RFCs except for line endings (instead of the RFC mandated &lt;code&gt;\r\n&lt;/code&gt;, it uses the Python standard &lt;code&gt;\n&lt;/code&gt; line endings). For more information see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책은&lt;/em&gt; 특정 사용이 갱신에 지정하고 메시지의 표현을 직렬화하는 규칙이다. &lt;em&gt;정책&lt;/em&gt; 이 설정되어 있지 않은 경우 RFC 명령 &lt;code&gt;\r\n&lt;/code&gt; 대신 \ n 줄 끝을 제외하고 전자 메일 RFC 규칙을 따르는 &lt;a href=&quot;email.policy#email.policy.default&quot;&gt; &lt;code&gt;default&lt;/code&gt; &lt;/a&gt; 정책 을 사용하십시오. 이는 Python 표준 &lt;code&gt;\n&lt;/code&gt; 줄 끝을 사용합니다 . 자세한 내용은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a6693268834f69640651269a3a6f634c6aa263db" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified use the rules it specifies to update the representation of the message. If &lt;em&gt;policy&lt;/em&gt; is not set, use the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy, which maintains backward compatibility with the Python 3.2 version of the email package and provides &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; as the default factory. All other policies provide &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; as the default &lt;em&gt;_factory&lt;/em&gt;. For more information on what else &lt;em&gt;policy&lt;/em&gt; controls, see the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">경우 &lt;em&gt;정책이&lt;/em&gt; 사용에게 규칙을 지정은 메시지의 표현을 업데이트 지정합니다. 경우 &lt;em&gt;정책이&lt;/em&gt; 설정되어 있지 않은, 사용 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 전자 메일 패키지의 파이썬 3.2 버전과 이전 버전과의 호환성을 유지하고 제공하는 정책, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 기본 공장으로합니다. 다른 모든 정책은 제공 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 을&lt;/a&gt; 기본으로 &lt;em&gt;_factory&lt;/em&gt; . 기타 &lt;em&gt;정책&lt;/em&gt; 제어 에 대한 자세한 내용 은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1b19921a08fb3038055adec87fe883544995964" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified, (defaults to the &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy) it will be passed to &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;정책을&lt;/em&gt; 지정,합니다 (기본값 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; 의&lt;/a&gt; 정책은)는 전달 될 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2399425e522c294a6da30e75c6833061e72088e7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;policy&lt;/em&gt; is specified, use that policy to control message generation. If &lt;em&gt;policy&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), use the policy associated with the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object passed to &lt;code&gt;flatten&lt;/code&gt; to control the message generation. See &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;email.policy&lt;/code&gt;&lt;/a&gt; for details on what &lt;em&gt;policy&lt;/em&gt; controls.</source>
          <target state="translated">경우 &lt;em&gt;정책을&lt;/em&gt; 지정, 제어 메시지 생성에이 정책을 사용합니다. 경우 &lt;em&gt;정책이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; (기본값)에서와 관련된 정책 사용 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 전달 객체를 &lt;code&gt;flatten&lt;/code&gt; 메시지 생성을 제어 할 수 있습니다. &lt;em&gt;정책&lt;/em&gt; 제어 에 대한 자세한 내용 은 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;email.policy&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="234372ba74ab2a1f7e9543f3c025cced7baa0bcd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;preexec_fn&lt;/em&gt; is set to a callable object, this object will be called in the child process just before the child is executed. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;preexec_fn가&lt;/em&gt; 호출 가능한 객체로 설정되어,이 개체는 아이가 실행되기 직전에 자식 프로세스에서 호출됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="e055baae3a89e75ac216cb3b78aecef961d8ea30" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;prefix&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file name will begin with that prefix; otherwise, a default prefix is used. The default is the return value of &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt;&lt;code&gt;gettempprefix()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#tempfile.gettempprefixb&quot;&gt;&lt;code&gt;gettempprefixb()&lt;/code&gt;&lt;/a&gt;, as appropriate.</source>
          <target state="translated">&lt;em&gt;prefix&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일 이름은 해당 접두어로 시작합니다. 그렇지 않으면 기본 접두사가 사용됩니다. 기본값은 &lt;a href=&quot;#tempfile.gettempprefix&quot;&gt; &lt;code&gt;gettempprefix()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#tempfile.gettempprefixb&quot;&gt; &lt;code&gt;gettempprefixb()&lt;/code&gt; &lt;/a&gt; 의 반환 값입니다 .</target>
        </trans-unit>
        <trans-unit id="320d6a341f543a03504526e2053eb17df2ebd864" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;progress&lt;/em&gt; is specified, it must either be &lt;code&gt;None&lt;/code&gt; or a callable object that will be executed at each iteration with three integer arguments, respectively the &lt;em&gt;status&lt;/em&gt; of the last iteration, the &lt;em&gt;remaining&lt;/em&gt; number of pages still to be copied and the &lt;em&gt;total&lt;/em&gt; number of pages.</source>
          <target state="translated">경우 &lt;em&gt;진행이&lt;/em&gt; 지정되어,이 중 하나 여야합니다 &lt;code&gt;None&lt;/code&gt; 또는 세 개의 정수 인수, 각각 각각의 반복에서 실행됩니다 호출 객체 &lt;em&gt;상태&lt;/em&gt; 마지막 반복의 &lt;em&gt;나머지&lt;/em&gt; 여전히 복사 할 페이지 수와 &lt;em&gt;총&lt;/em&gt; 페이지 수.</target>
        </trans-unit>
        <trans-unit id="fd9af5ff1d54bf3dba9ffd1e4521d25aa43c2aa9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and it is not possible to create or change the CWD, an error is raised. Otherwise, only a warning is raised and the original CWD is used.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 과는 CWD를 만들거나 변경할 수 없습니다, 오류가 발생합니다. 그렇지 않으면 경고 만 발생하고 원래 CWD가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="835884060a8a9192218bcab1cde5f47ef1b050ce" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt; (the default), the filenames and other information are printed to standard out. Set to &lt;code&gt;1&lt;/code&gt;, only errors are printed. Set to &lt;code&gt;2&lt;/code&gt;, all output is suppressed.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 또는 &lt;code&gt;0&lt;/code&gt; (기본값), 파일 이름 및 기타 정보를 표준 출력에 인쇄됩니다. &lt;code&gt;1&lt;/code&gt; 로 설정하면 오류 만 인쇄됩니다. &lt;code&gt;2&lt;/code&gt; 로 설정하면 모든 출력이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="8dadb44823dad128ad864c2298313a9d5da71265" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;quiet&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the context manager raises an exception on error. Otherwise, it issues only a warning and keeps the current working directory the same.</source>
          <target state="translated">경우 &lt;em&gt;조용한이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; , 상황에 맞는 관리자 오류에 예외를 발생시킵니다. 그렇지 않으면, 경고 만 발행하고 현재 작업 디렉토리를 동일하게 유지합니다.</target>
        </trans-unit>
        <trans-unit id="e77db954cc02cf6ffcd1e5162b0740633d6c9859" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;r&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, then &lt;em&gt;r&lt;/em&gt; defaults to the length of the &lt;em&gt;iterable&lt;/em&gt; and all possible full-length permutations are generated.</source>
          <target state="translated">경우 &lt;em&gt;연구가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;em&gt;r에&lt;/em&gt; 의 길이에 기본값을 &lt;em&gt;반복 가능한&lt;/em&gt; 모든 가능한 전체 길이 순열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="eb898bae774457e0cd44b1cda07745bfe870b0dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rawdata&lt;/em&gt; is a string, parse it as an &lt;code&gt;HTTP_COOKIE&lt;/code&gt; and add the values found there as &lt;a href=&quot;#http.cookies.Morsel&quot;&gt;&lt;code&gt;Morsel&lt;/code&gt;&lt;/a&gt;s. If it is a dictionary, it is equivalent to:</source>
          <target state="translated">&lt;em&gt;rawdata&lt;/em&gt; 가 문자열 인 경우 이를 &lt;code&gt;HTTP_COOKIE&lt;/code&gt; 로 구문 분석하고 찾은 값을 &lt;a href=&quot;#http.cookies.Morsel&quot;&gt; &lt;code&gt;Morsel&lt;/code&gt; &lt;/a&gt; 로 추가하십시오 . 사전 인 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c178f6125a527b13b9c928333c2db9e291dd9095" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;recursive&lt;/em&gt; is true, the pattern &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo; will match any files and zero or more directories, subdirectories and symbolic links to directories. If the pattern is followed by an &lt;a href=&quot;os#os.sep&quot;&gt;&lt;code&gt;os.sep&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.altsep&quot;&gt;&lt;code&gt;os.altsep&lt;/code&gt;&lt;/a&gt; then files will not match.</source>
          <target state="translated">경우 &lt;em&gt;재귀는&lt;/em&gt; 사실이다, 패턴은 &quot; &lt;code&gt;**&lt;/code&gt; &quot;디렉토리에있는 파일과 0 개 이상의 디렉토리, 하위 디렉토리 및 기호 링크를 일치합니다. 패턴 뒤에 &lt;a href=&quot;os#os.sep&quot;&gt; &lt;code&gt;os.sep&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.altsep&quot;&gt; &lt;code&gt;os.altsep&lt;/code&gt; 가 있으면&lt;/a&gt; 파일이 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="652f42ab0e60e31310c32efc30bfe26cd213dcee" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rename&lt;/em&gt; is true, invalid fieldnames are automatically replaced with positional names. For example, &lt;code&gt;['abc', 'def', 'ghi', 'abc']&lt;/code&gt; is converted to &lt;code&gt;['abc', '_1', 'ghi', '_3']&lt;/code&gt;, eliminating the keyword &lt;code&gt;def&lt;/code&gt; and the duplicate fieldname &lt;code&gt;abc&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;이름 바꾸기가&lt;/em&gt; 참 잘못된 fieldName에 자동으로 위치 이름으로 대체됩니다. 예를 들어, &lt;code&gt;['abc', 'def', 'ghi', 'abc']&lt;/code&gt; 는 &lt;code&gt;['abc', '_1', 'ghi', '_3']&lt;/code&gt; 로 변환되어 키워드 &lt;code&gt;def&lt;/code&gt; 및 중복 필드 이름 &lt;code&gt;abc&lt;/code&gt; 를 제거합니다. .</target>
        </trans-unit>
        <trans-unit id="6b0fc2117fa452e5fb0901602f2e235ae4931393" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;repl&lt;/em&gt; is a function, it is called for every non-overlapping occurrence of &lt;em&gt;pattern&lt;/em&gt;. The function takes a single &lt;a href=&quot;#match-objects&quot;&gt;match object&lt;/a&gt; argument, and returns the replacement string. For example:</source>
          <target state="translated">경우 &lt;em&gt;REPL는&lt;/em&gt; 함수이며, 이는 모든 비 중첩 발생을 호출 &lt;em&gt;패턴&lt;/em&gt; . 이 함수는 단일 &lt;a href=&quot;#match-objects&quot;&gt;일치 오브젝트&lt;/a&gt; 인수를 사용하고 대체 문자열을 리턴합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2a093846d95a069713492d1fd6ead5de8bd55f04" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;replace&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default) the header is moved to the end of the list of headers. If &lt;em&gt;replace&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the header will be updated in place.</source>
          <target state="translated">경우 &lt;em&gt;교체&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; (기본) 헤더는 헤더의 목록의 끝으로 이동합니다. 경우 &lt;em&gt;교체&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 헤더 자리에 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="989522b42bb979106607a604c110fad8c9045475" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;restore_signals&lt;/em&gt; is true (the default) all signals that Python has set to SIG_IGN are restored to SIG_DFL in the child process before the exec. Currently this includes the SIGPIPE, SIGXFZ and SIGXFSZ signals. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;restore_signals이&lt;/em&gt; 참 (기본) 파이썬이 SIG_IGN으로 설정했다고 모든 것을 알리는 간부하기 전에 자식 프로세스에 SIG_DFL로 복원됩니다. 현재 여기에는 SIGPIPE, SIGXFZ 및 SIGXFSZ 신호가 포함됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="eb9630daaf2813c2a4fbd9d5532117273440d21b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;result&lt;/em&gt; is provided, it is returned to the caller when the coroutine completes.</source>
          <target state="translated">경우 &lt;em&gt;결과가&lt;/em&gt; 제공되며, 호출자 때 코 루틴이 완료 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5684052c764729c0f68c3561f034eace258e3a1a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;return_exceptions&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (default), the first raised exception is immediately propagated to the task that awaits on &lt;code&gt;gather()&lt;/code&gt;. Other awaitables in the &lt;em&gt;aws&lt;/em&gt; sequence &lt;strong&gt;won&amp;rsquo;t be cancelled&lt;/strong&gt; and will continue to run.</source>
          <target state="translated">경우 &lt;em&gt;return_exceptions이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본), 첫 번째 발생한 예외가 바로 기다리고있다가하는 작업에 전파 &lt;code&gt;gather()&lt;/code&gt; . 의 다른 awaitables &lt;em&gt;AWS의&lt;/em&gt; 순서는 &lt;strong&gt;취소되지 않습니다&lt;/strong&gt; 및 계속 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6de4a327272d8e394442d6de35dbc10f4156abb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;return_exceptions&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, exceptions are treated the same as successful results, and aggregated in the result list.</source>
          <target state="translated">경우 &lt;em&gt;return_exceptions가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 예외는 성공적인 결과와 동일하게 취급하고 결과 목록에서 집계됩니다.</target>
        </trans-unit>
        <trans-unit id="251118657a646dd1a14d95161e6af339f8202cf4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;return_exceptions&lt;/em&gt; is False, cancelling gather() after it has been marked done won&amp;rsquo;t cancel any submitted awaitables. For instance, gather can be marked done after propagating an exception to the caller, therefore, calling &lt;code&gt;gather.cancel()&lt;/code&gt; after catching an exception (raised by one of the awaitables) from gather won&amp;rsquo;t cancel any other awaitables.</source>
          <target state="translated">&lt;em&gt;return_exceptions&lt;/em&gt; 가 False 인 경우 , 완료로 표시된 후 gather ()를 취소해도 제출 된 awaitable이 취소되지 않습니다. 예를 들어, gather는 호출자에게 예외를 전파 한 후에 완료로 표시 될 수 있으므로 gather 에서 예외 (awaitable 중 하나에 의해 발생 &lt;code&gt;gather.cancel()&lt;/code&gt; 를 포착 한 후 gather.cancel () 을 호출 해도 다른 어떤 대기 가능 항목도 취소되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c43a33c76c7da2f4198988b499c7fcff4ea7e0ba" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rx&lt;/em&gt; is given, its search method is called on the complete path to each file considered for compilation, and if it returns a true value, the file is skipped.</source>
          <target state="translated">경우 &lt;em&gt;RX가&lt;/em&gt; 주어, 그 검색 방법은 편집을 위해 고려 각 파일의 전체 경로라고하며가 true 값을 반환하는 경우, 파일은 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="bceb5a6050a398999357f2debabd55d53448093b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;rx&lt;/em&gt; is given, its search method is passed the full path name to the file being compiled, and if it returns a true value, the file is not compiled and &lt;code&gt;True&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;em&gt;RX가&lt;/em&gt; 주어, 그 검색 방법은 파일의 전체 경로 이름이 컴파일되는 전달하고가 true 값을 반환하는 경우, 파일은 컴파일되지 않고 &lt;code&gt;True&lt;/code&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="11ffb51839f338f99c26b93f469a2ff3e996354c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;s&lt;/em&gt; is an instance of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;charset&lt;/em&gt; is a hint specifying the character set of the characters in the string.</source>
          <target state="translated">경우 &lt;em&gt;들&lt;/em&gt; 의 인스턴스 인 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , 다음 &lt;em&gt;캐릭터 세트는&lt;/em&gt; 문자열에서 문자의 문자 집합을 지정하는 힌트이다.</target>
        </trans-unit>
        <trans-unit id="c4b191218804654e28d488d61d7963e295b8ba38" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is not an existing scheme, &lt;a href=&quot;#sysconfig.get_paths&quot;&gt;&lt;code&gt;get_paths()&lt;/code&gt;&lt;/a&gt; will raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;scheme&lt;/em&gt; 이 기존 &lt;em&gt;체계&lt;/em&gt; 가 아닌 경우 &lt;a href=&quot;#sysconfig.get_paths&quot;&gt; &lt;code&gt;get_paths()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="579ce2501f9bd2e51356cbfaa3d40376b9ab476a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is not provided, will use the default scheme for the current platform.</source>
          <target state="translated">경우 &lt;em&gt;계획이&lt;/em&gt; 제공되지 않으며, 현재 플랫폼의 기본 방식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="dcde2be3fbea710fd434bc34595dec1ea0f24076" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;scheme&lt;/em&gt; is provided, it must be a value from the list returned by &lt;a href=&quot;#sysconfig.get_scheme_names&quot;&gt;&lt;code&gt;get_scheme_names()&lt;/code&gt;&lt;/a&gt;. Otherwise, the default scheme for the current platform is used.</source>
          <target state="translated">경우 &lt;em&gt;방식을&lt;/em&gt; 제공, 그것은에 의해 반환 된 목록에서 값이어야합니다 &lt;a href=&quot;#sysconfig.get_scheme_names&quot;&gt; &lt;code&gt;get_scheme_names()&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면 현재 플랫폼의 기본 체계가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0e383345ed1ffb777fd51335060944d7c8849d95" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;secs&lt;/em&gt; is not provided or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, the current time as returned by &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; is used. &lt;code&gt;ctime(secs)&lt;/code&gt; is equivalent to &lt;code&gt;asctime(localtime(secs))&lt;/code&gt;. Locale information is not used by &lt;a href=&quot;#time.ctime&quot;&gt;&lt;code&gt;ctime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;초이&lt;/em&gt; 제공되지 않거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 반환 된 현재 시간 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 사용되지 않는다. &lt;code&gt;ctime(secs)&lt;/code&gt; 는 &lt;code&gt;asctime(localtime(secs))&lt;/code&gt; . 로케일 정보는 &lt;a href=&quot;#time.ctime&quot;&gt; &lt;code&gt;ctime()&lt;/code&gt; &lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="52127174ed10907e5ff17d5141342c89e06f5f85" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;seed&lt;/em&gt; is given, creates a new instance of the underlying random number generator. This is useful for creating reproducible results, even in a multi-threading context.</source>
          <target state="translated">경우 &lt;em&gt;씨앗이&lt;/em&gt; 주어집니다, 기본 난수 생성기의 새 인스턴스를 만듭니다. 이는 다중 스레딩 컨텍스트에서도 재현 가능한 결과를 생성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4edab34fe0d303f2ab6c480c28b9df03c2bd34c0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then mark it as dead and return the result of calling &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 죽은 것으로 표시하고 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 호출 결과를 반환합니다 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d5cc9d166c3fd7fa9f433e7f26249d72bf951f3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then mark it as dead and return the tuple &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 죽은 것으로 표시하고 튜플 &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt; 반환하십시오 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="d62395a4c8cd7edcdbc400ae85af1063602e83fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;self&lt;/em&gt; is alive then return the tuple &lt;code&gt;(obj, func, args,
kwargs)&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is dead then return &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; 가 살아 있으면 튜플 &lt;code&gt;(obj, func, args, kwargs)&lt;/code&gt; 을 반환하십시오 . &lt;em&gt;self&lt;/em&gt; 가 죽은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c78e910291328954d1c689354013e70073a04fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings (for example, &lt;code&gt;'1,,2'.split(',')&lt;/code&gt; returns &lt;code&gt;['1', '', '2']&lt;/code&gt;). The &lt;em&gt;sep&lt;/em&gt; argument may consist of multiple characters (for example, &lt;code&gt;'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split('&amp;lt;&amp;gt;')&lt;/code&gt; returns &lt;code&gt;['1', '2', '3']&lt;/code&gt;). Splitting an empty string with a specified separator returns &lt;code&gt;['']&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월이&lt;/em&gt; 주어진 연속적인 분리는 그룹화하지 않으며를 단락 비어있는 스트링으로 간주된다 (예를 들어, &lt;code&gt;'1,,2'.split(',')&lt;/code&gt; 를 반환 &lt;code&gt;['1', '', '2']&lt;/code&gt; ). &lt;em&gt;9 월&lt;/em&gt; 인수는 복수의 문자로 구성 될 수있다 (예를 들면, &lt;code&gt;'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split('&amp;lt;&amp;gt;')&lt;/code&gt; 복귀 &lt;code&gt;['1', '2', '3']&lt;/code&gt; ). 지정된 구분 기호로 빈 문자열을 분할하면 &lt;code&gt;['']&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="d32a65d384a22e7aca1e7f72f27cdc388ee1ce1e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; returns &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt;). The &lt;em&gt;sep&lt;/em&gt; argument may consist of a multibyte sequence (for example, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; returns &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt;). Splitting an empty sequence with a specified separator returns &lt;code&gt;[b'']&lt;/code&gt; or &lt;code&gt;[bytearray(b'')]&lt;/code&gt; depending on the type of object being split. The &lt;em&gt;sep&lt;/em&gt; argument may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월이&lt;/em&gt; 주어진다 연속 구분 기호가 함께 그룹화되지 않고, 예, 대한 (를 단락 빈 시퀀스로 간주됩니다 &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; 반환 &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt; ). &lt;em&gt;9 월&lt;/em&gt; 인수는 멀티 바이트 시퀀스로 구성 될 수있다 (예를 들면, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; 복귀 &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt; ) . 지정된 구분 기호로 빈 시퀀스를 분할하면 분할되는 객체 유형에 따라 &lt;code&gt;[b'']&lt;/code&gt; 또는 &lt;code&gt;[bytearray(b'')]&lt;/code&gt; 반환 됩니다. &lt;em&gt;9 월&lt;/em&gt; 인수는있을 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="549838992282f145747633c71b5315b9744fad84" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty subsequences (for example, &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; returns &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt;). The &lt;em&gt;sep&lt;/em&gt; argument may consist of a multibyte sequence (for example, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; returns &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt;). Splitting an empty sequence with a specified separator returns &lt;code&gt;[b'']&lt;/code&gt; or &lt;code&gt;[bytearray(b'')]&lt;/code&gt; depending on the type of object being split. The &lt;em&gt;sep&lt;/em&gt; argument may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월이&lt;/em&gt; 주어진다 연속 구분 기호가 함께 그룹화되지 않고, 예, 대한 (를 단락 빈 시퀀스로 간주됩니다 &lt;code&gt;b'1,,2'.split(b',')&lt;/code&gt; 반환 &lt;code&gt;[b'1', b'', b'2']&lt;/code&gt; ). &lt;em&gt;9 월&lt;/em&gt; 인수는 멀티 바이트 시퀀스로 구성 될 수있다 (예를 들면, &lt;code&gt;b'1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;3'.split(b'&amp;lt;&amp;gt;')&lt;/code&gt; 복귀 &lt;code&gt;[b'1', b'2', b'3']&lt;/code&gt; ) . 지정된 구분 기호로 빈 시퀀스를 분할하면 분할되는 객체 유형에 따라 &lt;code&gt;[b'']&lt;/code&gt; 또는 &lt;code&gt;[bytearray(b'')]&lt;/code&gt; 반환 됩니다. &lt;em&gt;9 월&lt;/em&gt; 인수는있을 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddf21781d7159ff06d30d7d7782c5cadffcfb73e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, a different splitting algorithm is applied: runs of consecutive ASCII whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the sequence has leading or trailing whitespace. Consequently, splitting an empty sequence or a sequence consisting solely of ASCII whitespace without a specified separator returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정되거나 없다되지 않는 &lt;code&gt;None&lt;/code&gt; 하나의 구분으로 간주된다 공백 연속 ASCII의 실행, 그리고 순서가 선행 또는 후행 공백 경우 결과는 시작 또는 끝 부분에 빈 문자열을 포함하지 않습니다 : 다른 분할 알고리즘이 적용됩니다. 결과적으로, 지정된 구분 기호없이 빈 시퀀스 또는 ASCII 공백으로 만 구성된 시퀀스를 분할하면 &lt;code&gt;[]&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="75815e1c039cef44f7ce05b27c1b9d61fa4ea0ed" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is not specified or is &lt;code&gt;None&lt;/code&gt;, a different splitting algorithm is applied: runs of consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace. Consequently, splitting an empty string or a string consisting of just whitespace with a &lt;code&gt;None&lt;/code&gt; separator returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정되거나 없다되지 &lt;code&gt;None&lt;/code&gt; 연속 공백의 실행은 하나의 구분으로 간주하고, 문자열이 선행 또는 후행 공백 경우 결과는 시작 또는 끝 부분에 빈 문자열을 포함하지 않습니다 : 다른 분할 알고리즘이 적용됩니다. 따라서 빈 문자열이나 공백만으로 구성된 문자열을 &lt;code&gt;None&lt;/code&gt; 구분 기호 로 분할하면 &lt;code&gt;[]&lt;/code&gt; 가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="bacd7e201472689d45d2129900593e8ba53a276f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sep&lt;/em&gt; is specified, it must be a single character str or bytes object. It will be inserted in the output after every &lt;em&gt;bytes_per_sep&lt;/em&gt; input bytes. Separator placement is counted from the right end of the output by default, if you wish to count from the left, supply a negative &lt;em&gt;bytes_per_sep&lt;/em&gt; value.</source>
          <target state="translated">경우 &lt;em&gt;9월가&lt;/em&gt; 지정, 단일 문자 STR 또는 객체 바이트 여야합니다. 모든 &lt;em&gt;bytes_per_sep&lt;/em&gt; 입력 바이트 후에 출력에 삽입 됩니다. 구분자 배치는 기본적으로 출력의 오른쪽 끝에서 계산됩니다. 왼쪽에서 계산하려면 음수 &lt;em&gt;bytes_per_sep&lt;/em&gt; 값을 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b2e53523b64aa1ece0f05f00001ffc33c683dfc6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;shallow&lt;/em&gt; is true, files with identical &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; signatures are taken to be equal. Otherwise, the contents of the files are compared.</source>
          <target state="translated">&lt;em&gt;shallow&lt;/em&gt; 가 true 인 경우 동일한 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 서명을 가진 파일은 동일합니다 . 그렇지 않으면 파일의 내용이 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="6a14ade8fc04b529f8c66e54b142b5f11123facc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;shell&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the specified command will be executed through the shell. This can be useful if you are using Python primarily for the enhanced control flow it offers over most system shells and still want convenient access to other shell features such as shell pipes, filename wildcards, environment variable expansion, and expansion of &lt;code&gt;~&lt;/code&gt; to a user&amp;rsquo;s home directory. However, note that Python itself offers implementations of many shell-like features (in particular, &lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;fnmatch#module-fnmatch&quot;&gt;&lt;code&gt;fnmatch&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.walk&quot;&gt;&lt;code&gt;os.walk()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os.path#os.path.expandvars&quot;&gt;&lt;code&gt;os.path.expandvars()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt;&lt;code&gt;os.path.expanduser()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;shutil#module-shutil&quot;&gt;&lt;code&gt;shutil&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;em&gt;쉘&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 지정된 명령은 쉘을 통해 실행됩니다. 이것은 대부분의 시스템 셸에서 제공하는 향상된 제어 흐름을 위해 Python을 주로 사용하면서 셸 파이프, 파일 이름 와일드 카드, 환경 변수 확장 및 사용자의 집 으로 &lt;code&gt;~&lt;/code&gt; 확장과 같은 다른 셸 기능에 편리하게 액세스하려는 경우 유용합니다. 예배 규칙서. 그러나 Python 자체는 많은 쉘과 같은 기능 (특히 &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;fnmatch#module-fnmatch&quot;&gt; &lt;code&gt;fnmatch&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.walk&quot;&gt; &lt;code&gt;os.walk()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os.path#os.path.expandvars&quot;&gt; &lt;code&gt;os.path.expandvars()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt; &lt;code&gt;os.path.expanduser()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;shutil#module-shutil&quot;&gt; &lt;code&gt;shutil&lt;/code&gt; &lt;/a&gt; )의 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c3fabb4f0dfc614531e56476a132b5752f344c2f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;side_effect&lt;/em&gt; is an iterable then each call to the mock will return the next value from the iterable.</source>
          <target state="translated">&lt;em&gt;side_effect&lt;/em&gt; 가 iterable 인 경우 &lt;em&gt;mock&lt;/em&gt; 에 대한 각 호출은 iterable에서 다음 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="32d4906d1c181de707adccc5361aecabb724997b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sigma&lt;/em&gt; is negative, raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;시그마는&lt;/em&gt; 음수, 제기 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84a4b0f24b46c93f18da5c06f6ae94445c0fe2cf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;signalnum&lt;/em&gt; is 0, then no signal is sent, but error checking is still performed; this can be used to check if the target thread is still running.</source>
          <target state="translated">경우 &lt;em&gt;signalnum이&lt;/em&gt; 0, 후 아무런 신호도 전송되지 않고, 오류 검사가 여전히 수행된다; 대상 스레드가 여전히 실행 중인지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8a8c085c8f93c34a62d1f5006e023a789d7f748" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;size&lt;/em&gt; is &lt;code&gt;-1&lt;/code&gt; (the default), an arbitrary number of bytes are returned (more than zero unless EOF is reached).</source>
          <target state="translated">경우 &lt;em&gt;크기&lt;/em&gt; 입니다 &lt;code&gt;-1&lt;/code&gt; (기본), 바이트의 임의의 수는 (EOF 않는 이상 제로에 도달) 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="783061ee6ebe0a3e848628b0e39a754d7f845bd2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;size&lt;/em&gt; is specified, at most &lt;em&gt;size&lt;/em&gt; characters will be read.</source>
          <target state="translated">경우 &lt;em&gt;크기가&lt;/em&gt; 지정되어, 기껏 &lt;em&gt;크기의&lt;/em&gt; 문자를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="847d50bbad63ed5c73adc70a9729f398c1c78b9f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skip_curdir&lt;/em&gt; is true (the default), the current directory is not included in the search. All other parameters are passed to the &lt;a href=&quot;#compileall.compile_dir&quot;&gt;&lt;code&gt;compile_dir()&lt;/code&gt;&lt;/a&gt; function. Note that unlike the other compile functions, &lt;code&gt;maxlevels&lt;/code&gt; defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;skip_curdir가&lt;/em&gt; true (디폴트), 현재 디렉토리는 검색에 포함되지 않습니다. 다른 모든 매개 변수는 &lt;a href=&quot;#compileall.compile_dir&quot;&gt; &lt;code&gt;compile_dir()&lt;/code&gt; &lt;/a&gt; 함수 로 전달됩니다 . 다른 컴파일 함수와 달리 &lt;code&gt;maxlevels&lt;/code&gt; 의 기본값은 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1622612acffaa08ff5b0ba0489c4b9b99e2215a3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skipkeys&lt;/em&gt; is false (the default), then it is a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; to attempt encoding of keys that are not &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;None&lt;/code&gt;. If &lt;em&gt;skipkeys&lt;/em&gt; is true, such items are simply skipped.</source>
          <target state="translated">경우 &lt;em&gt;skipkeys가&lt;/em&gt; false (기본값)이며, 다음은입니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 없는 키의 인코딩을 시도하는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;None&lt;/code&gt; . 경우 &lt;em&gt;skipkeys는&lt;/em&gt; 사실, 같은 항목은 단순히 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="fdad7b18b91cc5adf5f82da39ab59d5d78a1ecfd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;skipkeys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then dict keys that are not of a basic type (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt;) will be skipped instead of raising a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;skipkeys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 기본 유형 (의 아닌 DICT 키 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;None&lt;/code&gt; ) 대신에 양육의 생략됩니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="919e52d14550425c25e9a8891929227e5c2b4b36" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sort_keys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then the output of dictionaries will be sorted by key.</source>
          <target state="translated">경우 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 사전의 출력은 키에 의해 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="141cc93734b2806ef0b422eaafd25c2a3bb5717d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;sort_keys&lt;/em&gt; is true (default: &lt;code&gt;False&lt;/code&gt;), then the output of dictionaries will be sorted by key; this is useful for regression tests to ensure that JSON serializations can be compared on a day-to-day basis.</source>
          <target state="translated">경우 &lt;em&gt;sort_keys이&lt;/em&gt; 참 (기본 : 인 &lt;code&gt;False&lt;/code&gt; ), 다음 사전의 출력은 키에 의해 정렬됩니다; 이는 JSON 직렬화를 매일 비교할 수 있도록 회귀 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0ec4d3670001eb4630add8e5d77a6b7f8a38307e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;source&lt;/em&gt; is a directory, this will create an archive from the contents of &lt;em&gt;source&lt;/em&gt;. If &lt;em&gt;source&lt;/em&gt; is a file, it should be an archive, and it will be copied to the target archive (or the contents of its shebang line will be displayed if the &amp;ndash;info option is specified).</source>
          <target state="translated">경우 &lt;em&gt;소스&lt;/em&gt; 디렉토리이며,이 내용에서 아카이브 만듭니다 &lt;em&gt;소스를&lt;/em&gt; . 경우 &lt;em&gt;소스&lt;/em&gt; 파일이, 그것은 보관해야하며합니다 (-info 옵션이 지정된 경우 표시됩니다 또는 오두막 라인의 내용) 대상 아카이브에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="dd866a51c1af75263cc3da023ee73b4ff52a8f3f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec&lt;/em&gt; is an object (rather than a list of strings) then &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt;&lt;code&gt;__class__&lt;/code&gt;&lt;/a&gt; returns the class of the spec object. This allows mocks to pass &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; tests.</source>
          <target state="translated">&lt;em&gt;spec&lt;/em&gt; 이 문자열 목록이 아닌 객체 인 경우 &lt;a href=&quot;stdtypes#instance.__class__&quot;&gt; &lt;code&gt;__class__&lt;/code&gt; &lt;/a&gt; 는 spec 객체의 클래스를 반환합니다. 이를 통해 모의가 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 테스트 를 통과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e430ec45184814b7e3a5423aaa67762e8ff2ee26" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec_set&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; then attempting to set attributes that don&amp;rsquo;t exist on the spec object will raise an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;spec_set&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 spec 객체에없는 속성을 설정하려고하면 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="afed44ee7ef600b461a700a3398505683d4ea66e" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;spec_set&lt;/em&gt; is true then only attributes on the spec can be set.</source>
          <target state="translated">경우 &lt;em&gt;spec_set는&lt;/em&gt; 사실 만 사양을 설정할 수 있습니다에 속성.</target>
        </trans-unit>
        <trans-unit id="e7a8ce63e7abc528992721347309573385b89984" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;start&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then iteration starts at zero. If &lt;em&gt;step&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, then the step defaults to one.</source>
          <target state="translated">경우 &lt;em&gt;시작은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음 반복은 0에서 시작. 경우 &lt;em&gt;단계는&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 하나 다음 단계로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="24863e0f029a6a7992cca82f7b21086bad27e744" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;start_new_session&lt;/em&gt; is true the setsid() system call will be made in the child process prior to the execution of the subprocess. (POSIX only)</source>
          <target state="translated">경우 &lt;em&gt;start_new_session는&lt;/em&gt; 사실이다 setsid () 시스템 호출은 서브 프로세스의 실행 이전에 자식 프로세스에서 이루어집니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="dae10e2b8108370fbc36f3fb951b2b6fcfa7ee03" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;state&lt;/em&gt; is specified, it is expected to be a sequence of one or more states. If the &lt;em&gt;default&lt;/em&gt; argument is set, it is used as a fallback value in case no specification for option is found.</source>
          <target state="translated">경우 &lt;em&gt;상태가&lt;/em&gt; 지정되어, 하나 개 이상의 상태의 순서가 될 것으로 예상된다. 경우 &lt;em&gt;기본&lt;/em&gt; 인수를 설정, 그것은 옵션에 대한 사양을 찾을 수없는 경우에 대체 값으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="03eb4116ba9791728aa443f40f34198f5e04395f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and host bits are set in the supplied address, then &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. Otherwise, the host bits are masked out to determine the appropriate network address.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; 호스트 비트가 제공된 주소를 설정 한 다음 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 발생합니다. 그렇지 않으면 호스트 비트가 마스킹되어 적절한 네트워크 주소를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="973cfc980a368126ab372341f5a82f90bd2ace1b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, information will be added to list of standard types, else to the list of non-standard types.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 정보는 다른 표준이 아닌 유형의 목록에 표준 유형의 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="c63d58de5c2b785bb280134953605f32b3e0b06f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, information will be added to the list of standard types, else to the list of non-standard types.</source>
          <target state="translated">경우 &lt;em&gt;엄격한가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 정보는 다른 표준이 아닌 유형의 목록에 표준 유형의 목록에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="59fa67b55f66822993cd529b9e43d4b11387a896" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;strict&lt;/em&gt; is false (&lt;code&gt;True&lt;/code&gt; is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0&amp;ndash;31 range, including &lt;code&gt;'\t'&lt;/code&gt; (tab), &lt;code&gt;'\n'&lt;/code&gt;, &lt;code&gt;'\r'&lt;/code&gt; and &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;strict&lt;/em&gt; 가 false 인 경우 ( &lt;code&gt;True&lt;/code&gt; 가 기본값 임) 문자열 내에서 제어 문자가 허용됩니다. 이 컨텍스트에서 제어 문자는 &lt;code&gt;'\t'&lt;/code&gt; (탭), &lt;code&gt;'\n'&lt;/code&gt; , &lt;code&gt;'\r'&lt;/code&gt; 및 &lt;code&gt;'\0'&lt;/code&gt; 포함하여 0-31 범위의 문자 코드가있는 제어 문자입니다 .</target>
        </trans-unit>
        <trans-unit id="00bb41b8d4ff338b7ff04695279e77d2e3c93ebd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;suffix&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the file name will end with that suffix, otherwise there will be no suffix. &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt; does not put a dot between the file name and the suffix; if you need one, put it at the beginning of &lt;em&gt;suffix&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;접미사&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 파일 이름은 해당 접미사로 끝나고 그렇지 않으면 접미사가 없습니다. &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; 는 파일 이름과 접미사 사이에 점을 넣지 않습니다. 필요한 경우 &lt;em&gt;접미사&lt;/em&gt; 시작 부분에 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="13150c99ab21ad6513149f3afd00516abf1afabf" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;symlinks&lt;/em&gt; is true, symbolic links in the source tree are represented as symbolic links in the new tree and the metadata of the original links will be copied as far as the platform allows; if false or omitted, the contents and metadata of the linked files are copied to the new tree.</source>
          <target state="translated">경우 &lt;em&gt;심볼릭 링크는&lt;/em&gt; 사실, 소스 트리의 심볼릭 링크는 플랫폼이 허용까지 복사 될 새 트리 원래 링크의 메타 데이터에 심볼릭 링크로 표시됩니다; false이거나 생략되면 링크 된 파일의 내용 및 메타 데이터가 새 트리에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="790a7891dbe26c0d182cc188c6888155d0da69dc" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;t&lt;/em&gt; is not provided, the current time as returned by &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; is used. Locale information is not used by &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하면 &lt;em&gt;t가&lt;/em&gt; 제공되지 않고, 반환 된 현재 시간 &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 사용된다. 로케일 정보는 &lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt; 사용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02d5c93f7a324aa5bde0984e4ba37a751a5f3a3c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tests&lt;/em&gt; is given, it must be an iterable of individual test cases or other test suites that will be used to build the suite initially. Additional methods are provided to add test cases and suites to the collection later on.</source>
          <target state="translated">경우 &lt;em&gt;테스트가&lt;/em&gt; 주어집니다, 그것은 처음 제품군을 구축하는 데 사용됩니다 개별 테스트 케이스 또는 다른 테스트 스위트의 반복 가능한해야합니다. 나중에 테스트 케이스 및 스위트를 콜렉션에 추가하기위한 추가 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb23f5faf7c3355639ee77c0a34b931b944acce" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;text&lt;/em&gt; is specified and true, the file is opened in text mode. Otherwise, (the default) the file is opened in binary mode.</source>
          <target state="translated">경우 &lt;em&gt;텍스트를&lt;/em&gt; 지정하고 진실되고, 파일은 텍스트 모드에서 열립니다. 그렇지 않으면 (기본값) 파일이 바이너리 모드로 열립니다.</target>
        </trans-unit>
        <trans-unit id="32cd3e51c090a1bc9065f8c1d01729be7286d1ed" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;text&lt;/em&gt; is specified, it indicates whether to open the file in binary mode (the default) or text mode. On some platforms, this makes no difference.</source>
          <target state="translated">경우 &lt;em&gt;텍스트가&lt;/em&gt; 지정되어, 그것은 바이너리 모드 (기본값) 또는 텍스트 모드에서 파일을 열 수 있는지 여부를 나타냅니다. 일부 플랫폼에서는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a4559c7dea064e6ee3c47db167d23f484bc1c7d3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;themename&lt;/em&gt; is not given, returns the theme in use. Otherwise, sets the current theme to &lt;em&gt;themename&lt;/em&gt;, refreshes all widgets and emits a &amp;lt;&amp;lt;ThemeChanged&amp;gt;&amp;gt; event.</source>
          <target state="translated">경우 &lt;em&gt;THEMENAME가&lt;/em&gt; 주어지지 않는, 사용중인 테마를 반환합니다. 그렇지 않으면 현재 테마를 &lt;em&gt;themename으로&lt;/em&gt; 설정하고 모든 위젯을 새로 고치고 &amp;lt;&amp;lt; ThemeChanged &amp;gt;&amp;gt; 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ba360f6f7820bc6cf274624bc159ffe1e870fd90" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;time&lt;/em&gt; is non-zero, this function requests that a &lt;a href=&quot;#signal.SIGALRM&quot;&gt;&lt;code&gt;SIGALRM&lt;/code&gt;&lt;/a&gt; signal be sent to the process in &lt;em&gt;time&lt;/em&gt; seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If &lt;em&gt;time&lt;/em&gt; is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled.</source>
          <target state="translated">경우 &lt;em&gt;시간은&lt;/em&gt; 비 - 제로하는 것이이 기능 요청 인 &lt;a href=&quot;#signal.SIGALRM&quot;&gt; &lt;code&gt;SIGALRM&lt;/code&gt; 의&lt;/a&gt; 신호의 처리로 보낼 수 &lt;em&gt;시간&lt;/em&gt; 초. 이전에 예약 된 모든 알람이 취소됩니다 (한 번에 하나의 알람 만 예약 할 수 있음). 반환 된 값은 이전에 설정된 알람이 전달되기까지의 시간 (초)입니다. 경우 &lt;em&gt;시간&lt;/em&gt; 제로, 더 알람이 예정되지 않으며, 예약 된 알람이 취소됩니다. 반환 값이 0이면 현재 예약 된 알람이없는 것입니다.</target>
        </trans-unit>
        <trans-unit id="28532016ce2dec2f43f2440bb50823bc42171d6a" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;time&lt;/em&gt; is non-zero, this function requests that a &lt;code&gt;SIGALRM&lt;/code&gt; signal be sent to the process in &lt;em&gt;time&lt;/em&gt; seconds. Any previously scheduled alarm is canceled (only one alarm can be scheduled at any time). The returned value is then the number of seconds before any previously set alarm was to have been delivered. If &lt;em&gt;time&lt;/em&gt; is zero, no alarm is scheduled, and any scheduled alarm is canceled. If the return value is zero, no alarm is currently scheduled.</source>
          <target state="translated">경우 &lt;em&gt;시간은&lt;/em&gt; 비 - 제로하는 것이이 기능 요청 인 &lt;code&gt;SIGALRM&lt;/code&gt; 의 신호의 처리로 보낼 수 &lt;em&gt;시간&lt;/em&gt; 초. 이전에 예약 된 알람은 취소됩니다 (언제든지 하나의 알람 만 예약 할 수 있음). 반환 된 값은 이전에 설정된 알람이 전달되기 전의 시간 (초)입니다. 경우 &lt;em&gt;시간&lt;/em&gt; 제로, 더 알람이 예정되지 않으며, 예약 된 알람이 취소됩니다. 반환 값이 0이면 현재 예약 된 알람이 없습니다.</target>
        </trans-unit>
        <trans-unit id="497079b5b5c0bcfc850eb270a835cdeff89fcdd1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;timeout&lt;/em&gt; is not specified then it will return immediately. If &lt;em&gt;timeout&lt;/em&gt; is a number then this specifies the maximum time in seconds to block. If &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; then an infinite timeout is used.</source>
          <target state="translated">경우 &lt;em&gt;타임 아웃이&lt;/em&gt; 지정되지 즉시 반환합니다. 경우 &lt;em&gt;타임 아웃&lt;/em&gt; 후 수 초 블록이 지정되는 최대 시간이다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 후 무한 시간 제한이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38330b7243617ce7e169c4b1ec03b6f57cadf500" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;times&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;em&gt;ns&lt;/em&gt; is unspecified, this is equivalent to specifying &lt;code&gt;ns=(atime_ns, mtime_ns)&lt;/code&gt; where both times are the current time.</source>
          <target state="translated">경우 &lt;em&gt;시간이&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; 및 &lt;em&gt;NS를&lt;/em&gt; 지정하고,이 지정에 해당 &lt;code&gt;ns=(atime_ns, mtime_ns)&lt;/code&gt; 두 시간은 현재 시간이다.</target>
        </trans-unit>
        <trans-unit id="8db77a303cd49acf6960de74cc642fc8c3611507" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;times&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be a 2-tuple of the form &lt;code&gt;(atime, mtime)&lt;/code&gt; where each member is an int or float expressing seconds.</source>
          <target state="translated">&lt;em&gt;times&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 각 멤버가 int 또는 float 표현 초인 2 개의 형식 &lt;code&gt;(atime, mtime)&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="347e1c7b8f66668341af1aa8af2cae34d5219df5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;typed&lt;/em&gt; is set to true, function arguments of different types will be cached separately. For example, &lt;code&gt;f(3)&lt;/code&gt; and &lt;code&gt;f(3.0)&lt;/code&gt; will be treated as distinct calls with distinct results.</source>
          <target state="translated">&lt;em&gt;typed&lt;/em&gt; 가 true로 설정 되면 다른 유형의 함수 인수가 별도로 캐시됩니다. 예를 들어, &lt;code&gt;f(3)&lt;/code&gt; 및 &lt;code&gt;f(3.0)&lt;/code&gt; 은 별개의 결과를 가진 별개의 호출로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="35713c7d2a1b17f3adfee94e67fe51913e45bad5" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tz&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and the current date and time are converted to &lt;em&gt;tz&lt;/em&gt;&amp;rsquo;s time zone.</source>
          <target state="translated">&lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 현재 날짜와 시간이 &lt;em&gt;tz&lt;/em&gt; 의 시간대 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="260c901c4e473510ed15a11c2c9dd83021ee8189" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;tz&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, it must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and the timestamp is converted to &lt;em&gt;tz&lt;/em&gt;&amp;rsquo;s time zone.</source>
          <target state="translated">&lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 타임 스탬프는 &lt;em&gt;tz&lt;/em&gt; 의 시간대 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="671abd2eb30c7f4417a4a9a96ff13ac2bb83e4e0" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;umask&lt;/em&gt; is not negative, the umask() system call will be made in the child process prior to the execution of the subprocess.</source>
          <target state="translated">&lt;em&gt;umask&lt;/em&gt; 가 음수가 아닌 경우 하위 프로세스를 실행하기 전에 하위 프로세스에서 umask () 시스템 호출이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8a43748fde1efea83cc1d49bf1dde82fa0eb165d" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;unixfrom&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, print the envelope header delimiter used by the Unix mailbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt;) before the first of the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; headers of the root message object. If the root object has no envelope header, craft a standard one. The default is &lt;code&gt;False&lt;/code&gt;. Note that for subparts, no envelope header is ever printed.</source>
          <target state="translated">경우 &lt;em&gt;unixfrom가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 유닉스 사서함 형식 (참조가 사용하는 봉투 헤더 구분 기호 인쇄 &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 의 첫 번째 전) &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 루트 메시지 개체의 헤더를. 루트 개체에 봉투 헤더가 없으면 표준 헤더를 만듭니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 하위 부품의 경우 봉투 헤더가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09ee2106f178148b8593077159fed634361f4c90" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;unixfrom&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, print the envelope header delimiter used by the Unix mailbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt;) before the first of the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; headers of the root message object. If the root object has no envelope header, craft a standard one. The default is &lt;code&gt;False&lt;/code&gt;. Note that for subparts, no envelope header is ever printed.</source>
          <target state="translated">경우 &lt;em&gt;unixfrom가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 유닉스 사서함 형식 (참조가 사용하는 봉투 헤더 구분 기호 인쇄 &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 의 첫 번째 전) &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 루트 메시지 개체의 헤더를. 루트 개체에 봉투 헤더가 없으면 표준 헤더를 만듭니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 하위 부품의 경우 봉투 헤더가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="564c391e2eea7b00e0d4511879cbcfaf5a4d8d17" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;uri&lt;/em&gt; is true, &lt;em&gt;database&lt;/em&gt; is interpreted as a URI. This allows you to specify options. For example, to open a database in read-only mode you can use:</source>
          <target state="translated">경우 &lt;em&gt;URI는&lt;/em&gt; 사실, &lt;em&gt;데이터베이스&lt;/em&gt; 는 URI로 해석됩니다. 옵션을 지정할 수 있습니다. 예를 들어, 데이터베이스를 읽기 전용 모드로 열려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92ee0e1dd0fe08e277eb2f16cc058b3ac9c272b9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; contains a fragment identifier, return a modified version of &lt;em&gt;url&lt;/em&gt; with no fragment identifier, and the fragment identifier as a separate string. If there is no fragment identifier in &lt;em&gt;url&lt;/em&gt;, return &lt;em&gt;url&lt;/em&gt; unmodified and an empty string.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 부분 식별자를 포함, 수정 된 버전의 반환 &lt;em&gt;URL을&lt;/em&gt; 어떤 조각 식별자, 별도의 문자열로 조각 식별자. &lt;em&gt;url에&lt;/em&gt; 조각 식별자가 없으면 수정되지 않은 &lt;em&gt;url&lt;/em&gt; 과 빈 문자열을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="e5f91bc86de3ed1dffc056104c7cbb413cf49813" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; is an absolute URL (that is, it starts with &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;scheme://&lt;/code&gt;), the &lt;em&gt;url&lt;/em&gt;&amp;rsquo;s hostname and/or scheme will be present in the result. For example:</source>
          <target state="translated">경우 &lt;em&gt;URL은&lt;/em&gt; 절대 URL입니다 (즉, 그것은 시작 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;scheme://&lt;/code&gt; )는 &lt;em&gt;URL&lt;/em&gt; 의 호스트 이름 및 / 또는 방식이 결과에있을 것입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="35a93d83feb3c7efc87442bcc3ea9ca48667e136" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;url&lt;/em&gt; is an absolute URL (that is, starting with &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;scheme://&lt;/code&gt;), the &lt;em&gt;url&lt;/em&gt;&amp;rsquo;s host name and/or scheme will be present in the result. For example:</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; (로 시작이며, 절대 URL입니다 &lt;code&gt;//&lt;/code&gt; 또는 &lt;code&gt;scheme://&lt;/code&gt; )에 &lt;em&gt;URL이&lt;/em&gt; 의 호스트 이름 및 / 또는 방식은 결과에있을 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d52da6544fdd2712a853ec73945e433591662e8f" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;use_builtin_types&lt;/em&gt; is true (the default) binary data will be returned as instances of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, otherwise it is returned as instances of &lt;a href=&quot;#plistlib.Data&quot;&gt;&lt;code&gt;Data&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;use_builtin_types이&lt;/em&gt; 참 (기본) 바이너리 데이터의 인스턴스로 반환됩니다 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 그렇지 않으면 인스턴스로 반환됩니다, &lt;a href=&quot;#plistlib.Data&quot;&gt; &lt;code&gt;Data&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="981f67d5d84b9f07425940203d6eec1b5f6b9559" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;user&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, the setreuid() system call will be made in the child process prior to the execution of the subprocess. If the provided value is a string, it will be looked up via &lt;a href=&quot;pwd#pwd.getpwnam&quot;&gt;&lt;code&gt;pwd.getpwnam()&lt;/code&gt;&lt;/a&gt; and the value in &lt;code&gt;pw_uid&lt;/code&gt; will be used. If the value is an integer, it will be passed verbatim. (POSIX only)</source>
          <target state="translated">&lt;em&gt;사용자&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 하위 프로세스를 실행하기 전에 자식 프로세스에서 setreuid () 시스템 호출이 수행됩니다. 제공된 값이 문자열이면 &lt;a href=&quot;pwd#pwd.getpwnam&quot;&gt; &lt;code&gt;pwd.getpwnam()&lt;/code&gt; &lt;/a&gt; 통해 조회 되며 &lt;code&gt;pw_uid&lt;/code&gt; 의 값 이 사용됩니다. 값이 정수이면 그대로 전달됩니다. (POSIX 만 해당)</target>
        </trans-unit>
        <trans-unit id="6a9f1ac8559eac5c86eefcea83c87b1263668062" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;user_function&lt;/em&gt; is specified, it must be a callable. This allows the &lt;em&gt;lru_cache&lt;/em&gt; decorator to be applied directly to a user function, leaving the &lt;em&gt;maxsize&lt;/em&gt; at its default value of 128:</source>
          <target state="translated">경우 &lt;em&gt;user_function가&lt;/em&gt; 지정되어, 그것은 호출해야합니다. 이를 통해 &lt;em&gt;lru_cache&lt;/em&gt; 데코레이터를 사용자 함수에 직접 적용 할 수 있으며 &lt;em&gt;maxsize&lt;/em&gt; 의 기본값은 128입니다.</target>
        </trans-unit>
        <trans-unit id="a9352d72ddc99ca448cdec42d9f75b91943270d1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;validate&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default), characters that are neither in the normal base-64 alphabet nor the alternative alphabet are discarded prior to the padding check. If &lt;em&gt;validate&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, these non-alphabet characters in the input result in a &lt;a href=&quot;binascii#binascii.Error&quot;&gt;&lt;code&gt;binascii.Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;유효성 검사가&lt;/em&gt; 있습니다 &lt;code&gt;False&lt;/code&gt; (기본), 일반베이스 (64) 알파벳이나 다른 알파벳에 어느 쪽도없는 문자는 패딩 검사 이전에 삭제됩니다. &lt;em&gt;validate&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 입력에서 알파벳이 아닌 문자는 &lt;a href=&quot;binascii#binascii.Error&quot;&gt; &lt;code&gt;binascii.Error&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="041b397f09c0fc84d045447fef90474b85a692b7" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;, the binary floating point value is losslessly converted to its exact decimal equivalent. This conversion can often require 53 or more digits of precision. For example, &lt;code&gt;Decimal(float('1.1'))&lt;/code&gt; converts to &lt;code&gt;Decimal('1.100000000000000088817841970012523233890533447265625')&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;값이&lt;/em&gt; A는 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; , 이진 부동 소수점 값은 손실없이 정확한 진수 동등한로 변환됩니다. 이 변환에는 종종 53 자리 이상의 정밀도가 필요할 수 있습니다. 예를 들어, &lt;code&gt;Decimal(float('1.1'))&lt;/code&gt; 은 &lt;code&gt;Decimal('1.100000000000000088817841970012523233890533447265625')&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="16a5fca024ec28b87ad8022c2ff864fdc8a9edce" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is a &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;, it should have three components, a sign (&lt;code&gt;0&lt;/code&gt; for positive or &lt;code&gt;1&lt;/code&gt; for negative), a &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; of digits, and an integer exponent. For example, &lt;code&gt;Decimal((0, (1, 4, 1, 4), -3))&lt;/code&gt; returns &lt;code&gt;Decimal('1.414')&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;값&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; , 그 세 가지 구성 요소 (부호 있어야 &lt;code&gt;0&lt;/code&gt; 포지티브 또는 &lt;code&gt;1&lt;/code&gt; 네거티브)하는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 숫자 및 정수 지수. 예를 들어 &lt;code&gt;Decimal((0, (1, 4, 1, 4), -3))&lt;/code&gt; 은 &lt;code&gt;Decimal('1.414')&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a26098b49583f3821ec64d052c3aa7592a7689" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;value&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, this function prints &lt;code&gt;repr(value)&lt;/code&gt; to &lt;code&gt;sys.stdout&lt;/code&gt;, and saves &lt;em&gt;value&lt;/em&gt; in &lt;code&gt;builtins._&lt;/code&gt;. If &lt;code&gt;repr(value)&lt;/code&gt; is not encodable to &lt;code&gt;sys.stdout.encoding&lt;/code&gt; with &lt;code&gt;sys.stdout.errors&lt;/code&gt; error handler (which is probably &lt;code&gt;'strict'&lt;/code&gt;), encode it to &lt;code&gt;sys.stdout.encoding&lt;/code&gt; with &lt;code&gt;'backslashreplace'&lt;/code&gt; error handler.</source>
          <target state="translated">경우 &lt;em&gt;값은&lt;/em&gt; 아니다되지 &lt;code&gt;None&lt;/code&gt; 이 함수를 인쇄 &lt;code&gt;repr(value)&lt;/code&gt; 에 &lt;code&gt;sys.stdout&lt;/code&gt; 는 한 저장 &lt;em&gt;값&lt;/em&gt; 에 &lt;code&gt;builtins._&lt;/code&gt; . 경우 &lt;code&gt;repr(value)&lt;/code&gt; 에 encodable하지 &lt;code&gt;sys.stdout.encoding&lt;/code&gt; 와 &lt;code&gt;sys.stdout.errors&lt;/code&gt; 의 (아마 인 오류 처리기 &lt;code&gt;'strict'&lt;/code&gt; 에, 인코딩을) &lt;code&gt;sys.stdout.encoding&lt;/code&gt; 와 &lt;code&gt;'backslashreplace'&lt;/code&gt; 오류 처리기가.</target>
        </trans-unit>
        <trans-unit id="b6c068a3fde871a0618297833b8d4828d3974011" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;vars&lt;/em&gt; is provided, it must be a dictionary of variables that will update the dictionary return by &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt;&lt;code&gt;get_config_vars()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;vars&lt;/em&gt; 가 제공되는 경우 &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt; &lt;code&gt;get_config_vars()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 사전을 업데이트 할 변수의 사전이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a8460fba468dd9bc7ed1d9f47454b97a770706f8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;vars&lt;/em&gt; is provided, it must be a dictionary of variables that will update the dictionary used to expand the paths.</source>
          <target state="translated">&lt;em&gt;vars&lt;/em&gt; 가 제공되는 경우 경로를 확장하는 데 사용되는 사전을 업데이트하는 변수의 사전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="65259ad55e207c66c56ade920231ad288fcf9123" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;verbosity&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;doctest#doctest.testmod&quot;&gt;&lt;code&gt;doctest.testmod()&lt;/code&gt;&lt;/a&gt; is run with verbosity set to &lt;a href=&quot;#test.support.verbose&quot;&gt;&lt;code&gt;verbose&lt;/code&gt;&lt;/a&gt;. Otherwise, it is run with verbosity set to &lt;code&gt;None&lt;/code&gt;. &lt;em&gt;optionflags&lt;/em&gt; is passed as &lt;code&gt;optionflags&lt;/code&gt; to &lt;a href=&quot;doctest#doctest.testmod&quot;&gt;&lt;code&gt;doctest.testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;em&gt;상세가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , &lt;a href=&quot;doctest#doctest.testmod&quot;&gt; &lt;code&gt;doctest.testmod()&lt;/code&gt; &lt;/a&gt; 에 상세 설정으로 실행됩니다 &lt;a href=&quot;#test.support.verbose&quot;&gt; &lt;code&gt;verbose&lt;/code&gt; &lt;/a&gt; . 그렇지 않으면, 상세가 &lt;code&gt;None&lt;/code&gt; 으로 설정된 상태로 실행됩니다 . &lt;em&gt;optionflags&lt;/em&gt; 는 &lt;code&gt;optionflags&lt;/code&gt; 로 &lt;a href=&quot;doctest#doctest.testmod&quot;&gt; &lt;code&gt;doctest.testmod()&lt;/code&gt; &lt;/a&gt; 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="942606e11a16e77c16cf6f2083e90d213368e12c" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;wait&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; then this method will not return until all the pending futures are done executing and the resources associated with the executor have been freed. If &lt;em&gt;wait&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; then this method will return immediately and the resources associated with the executor will be freed when all pending futures are done executing. Regardless of the value of &lt;em&gt;wait&lt;/em&gt;, the entire Python program will not exit until all pending futures are done executing.</source>
          <target state="translated">경우 &lt;em&gt;대기가&lt;/em&gt; 있다 &lt;code&gt;True&lt;/code&gt; 모든 보류중인 미래가 실행 완료 및 집행과 관련된 자원이 해제 될 때까지이 메서드는 반환하지 않습니다. 경우 &lt;em&gt;대기가&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 이 메소드는 즉시 반환하고 대기중인 모든 선물 실행이 완료되면 집행자와 관련된 자원이 해제됩니다. &lt;em&gt;wait&lt;/em&gt; 값에 관계없이 모든 보류중인 선물이 실행을 완료 할 때까지 전체 Python 프로그램이 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c093aaca359d099d06e48dc626af24bc9190ff1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;write_through&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, calls to &lt;code&gt;write()&lt;/code&gt; are guaranteed not to be buffered: any data written on the &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt; object is immediately handled to its underlying binary &lt;em&gt;buffer&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;write_through&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;write()&lt;/code&gt; 호출 은 버퍼링되지 않습니다. &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 객체 에 작성된 모든 데이터 는 즉시 기본 이진 &lt;em&gt;버퍼로&lt;/em&gt; 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="89941db7dc37fa051d978feefe492a3b2d60c160" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is a NaN (not a number), return &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;X는&lt;/em&gt; NaN의 (숫자), 반환입니다 &lt;em&gt;X&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fbd4a3eed4c5fc90391439bed8e6c3cdba1f0223" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is a positive infinity, return &lt;em&gt;x&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;X는&lt;/em&gt; 양의 무한대, 반환입니다 &lt;em&gt;X는&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="bf5e9e1b1ced1ef52b23a71fc8faa47dd2371ade" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is equal to &lt;em&gt;y&lt;/em&gt;, return &lt;em&gt;y&lt;/em&gt;.</source>
          <target state="translated">경우 &lt;em&gt;, X는&lt;/em&gt; 동일하다 &lt;em&gt;Y&lt;/em&gt; 반환 &lt;em&gt;Y를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4f2027938d5b7550dde99cbf6a67846b4b5839b2" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is equal to the largest positive representable float, return the value of the least significant bit of &lt;em&gt;x&lt;/em&gt;, such that the first float smaller than &lt;em&gt;x&lt;/em&gt; is &lt;code&gt;x - ulp(x)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;X는&lt;/em&gt; 정의 최대 표현 가능한 플로트와 같은지의 최하위 비트의 값이 반환 &lt;em&gt;X를&lt;/em&gt; 예보다 작은 제 플로트 것을 &lt;em&gt;X&lt;/em&gt; IS &lt;code&gt;x - ulp(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73659e25dc030b5fc23225d81923aa74c8ea28c1" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is equal to zero, return the smallest positive &lt;em&gt;denormalized&lt;/em&gt; representable float (smaller than the minimum positive &lt;em&gt;normalized&lt;/em&gt; float, &lt;a href=&quot;sys#sys.float_info&quot;&gt;&lt;code&gt;sys.float_info.min&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우에 &lt;em&gt;x는&lt;/em&gt; 0 인, 작은 양의 복귀가 &lt;em&gt;정규화&lt;/em&gt; (최소값보다 작은 긍정적 표현할 플로트 &lt;em&gt;정규화&lt;/em&gt; 플로트 &lt;a href=&quot;sys#sys.float_info&quot;&gt; &lt;code&gt;sys.float_info.min&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c535ae7c392d25365cbc29e7cb109ff9af4fc6e6" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is negative, return &lt;code&gt;ulp(-x)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;x가&lt;/em&gt; 부의 경우, 반환 &lt;code&gt;ulp(-x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4eabe5555eb349dd57c749df6fcb8345ed8d6ff8" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is not a number or if &lt;em&gt;base&lt;/em&gt; is given, then &lt;em&gt;x&lt;/em&gt; must be a string, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; instance representing an &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#integers&quot;&gt;integer literal&lt;/a&gt; in radix &lt;em&gt;base&lt;/em&gt;. Optionally, the literal can be preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; (or &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt;) having values 10 to 35. The default &lt;em&gt;base&lt;/em&gt; is 10. The allowed values are 0 and 2&amp;ndash;36. Base-2, -8, and -16 literals can be optionally prefixed with &lt;code&gt;0b&lt;/code&gt;/&lt;code&gt;0B&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt;/&lt;code&gt;0O&lt;/code&gt;, or &lt;code&gt;0x&lt;/code&gt;/&lt;code&gt;0X&lt;/code&gt;, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that &lt;code&gt;int('010', 0)&lt;/code&gt; is not legal, while &lt;code&gt;int('010')&lt;/code&gt; is, as well as &lt;code&gt;int('010', 8)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;x는&lt;/em&gt; 숫자가 아닌 경우, 또는 &lt;em&gt;기초가&lt;/em&gt; 지정되고있는 경우, &lt;em&gt;x는&lt;/em&gt; 문자열이어야합니다, &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 인스턴스는 나타내는 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#integers&quot;&gt;정수 리터럴&lt;/a&gt; 의 기수 &lt;em&gt;기반을&lt;/em&gt; . 선택적으로 리터럴 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; (공백 없음)가 있고 공백으로 둘러 쌀 수 있습니다. 베이스-N 리터럴와, N-1에있는 숫자 0 구성 에 &lt;code&gt;z&lt;/code&gt; (또는 에 &lt;code&gt;Z&lt;/code&gt; 기본 10 (35))을 갖는 값을 &lt;em&gt;기지&lt;/em&gt; 허용되는 값은 0이다 10. 2-36이다. Base-2, -8 및 -16 리터럴은 선택적으로 &lt;code&gt;0b&lt;/code&gt; 접두어를 붙일 수 있습니다 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;A&lt;/code&gt; &lt;em&gt;&lt;/em&gt;코드의 정수 리터럴과 마찬가지로 / &lt;code&gt;0B&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; / &lt;code&gt;0O&lt;/code&gt; 또는 &lt;code&gt;0x&lt;/code&gt; / &lt;code&gt;0X&lt;/code&gt; 밑수 0은 코드 리터럴로 정확하게 해석하여 실제 밑 수가 2, 8, 10 또는 16이고 &lt;code&gt;int('010', 0)&lt;/code&gt; 가 유효하지 않고 &lt;code&gt;int('010')&lt;/code&gt; 가 뿐만 아니라 &lt;code&gt;int('010', 8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00d4afdbff112153e973e5a044420332986c19dd" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;x&lt;/em&gt; is not a number or if &lt;em&gt;base&lt;/em&gt; is given, then &lt;em&gt;x&lt;/em&gt; must be a string, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; instance representing an &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#integers&quot;&gt;integer literal&lt;/a&gt; in radix &lt;em&gt;base&lt;/em&gt;. Optionally, the literal can be preceded by &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (with no space in between) and surrounded by whitespace. A base-n literal consists of the digits 0 to n-1, with &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;z&lt;/code&gt; (or &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;Z&lt;/code&gt;) having values 10 to 35. The default &lt;em&gt;base&lt;/em&gt; is 10. The allowed values are 0 and 2&amp;ndash;36. Base-2, -8, and -16 literals can be optionally prefixed with &lt;code&gt;0b&lt;/code&gt;/&lt;code&gt;0B&lt;/code&gt;, &lt;code&gt;0o&lt;/code&gt;/&lt;code&gt;0O&lt;/code&gt;, or &lt;code&gt;0x&lt;/code&gt;/&lt;code&gt;0X&lt;/code&gt;, as with integer literals in code. Base 0 means to interpret exactly as a code literal, so that the actual base is 2, 8, 10, or 16, and so that &lt;code&gt;int('010', 0)&lt;/code&gt; is not legal, while &lt;code&gt;int('010')&lt;/code&gt; is, as well as &lt;code&gt;int('010', 8)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;em&gt;x는&lt;/em&gt; 숫자가 아닌 경우, 또는 &lt;em&gt;기초가&lt;/em&gt; 지정되고있는 경우, &lt;em&gt;x는&lt;/em&gt; 문자열이어야합니다, &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 인스턴스는 나타내는 &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#integers&quot;&gt;정수 리터럴&lt;/a&gt; 의 기수 &lt;em&gt;기반을&lt;/em&gt; . 선택적으로 리터럴 앞에 &lt;code&gt;+&lt;/code&gt; 또는 &lt;code&gt;-&lt;/code&gt; (사이에 공백 없음)를 추가하고 공백으로 묶을 수 있습니다. base-n 리터럴은 0에서 n-1까지의 숫자로 구성되며 &lt;code&gt;a&lt;/code&gt; 에서 &lt;code&gt;z&lt;/code&gt; (또는 &lt;code&gt;A&lt;/code&gt; 에서 &lt;code&gt;Z&lt;/code&gt; )는 10에서 35까지의 값을 갖습니다. 기본 &lt;em&gt;기본&lt;/em&gt; 은 10입니다. 허용되는 값은 0과 2-36입니다. Base-2, -8 및 -16 리터럴은 선택적으로 &lt;code&gt;0b&lt;/code&gt; 접두사를 붙일 수 있습니다./ &lt;code&gt;0B&lt;/code&gt; , &lt;code&gt;0o&lt;/code&gt; / &lt;code&gt;0O&lt;/code&gt; , 또는 &lt;code&gt;0x&lt;/code&gt; / &lt;code&gt;0X&lt;/code&gt; , 코드의 정수 리터럴과 같습니다. 기본 0은 코드 리터럴로 정확히 해석하여 실제 기본이 2, 8, 10 또는 16이고 &lt;code&gt;int('010', 0)&lt;/code&gt; 은 유효하지 않은 반면 &lt;code&gt;int('010')&lt;/code&gt; 는 다음과 같습니다. 뿐만 아니라 &lt;code&gt;int('010', 8)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ca00c56cdce0b10d4e7ca75f4203a4d4dbe4b3" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;y&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;x&lt;/em&gt; must be a pair of coordinates or a &lt;a href=&quot;#turtle.Vec2D&quot;&gt;&lt;code&gt;Vec2D&lt;/code&gt;&lt;/a&gt; (e.g. as returned by &lt;a href=&quot;#turtle.pos&quot;&gt;&lt;code&gt;pos()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경우 &lt;em&gt;y는&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , &lt;em&gt;X는&lt;/em&gt; 좌표의 쌍 또는이어야 &lt;a href=&quot;#turtle.Vec2D&quot;&gt; &lt;code&gt;Vec2D&lt;/code&gt; &lt;/a&gt; (예에 의해 반환되는 &lt;a href=&quot;#turtle.pos&quot;&gt; &lt;code&gt;pos()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fdae1f0f9315700b86b3f53ba94aa3d7efe1b994" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;zdict&lt;/em&gt; is a mutable object (such as a &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;), you must not modify its contents between the call to &lt;a href=&quot;#zlib.decompressobj&quot;&gt;&lt;code&gt;decompressobj()&lt;/code&gt;&lt;/a&gt; and the first call to the decompressor&amp;rsquo;s &lt;code&gt;decompress()&lt;/code&gt; method.</source>
          <target state="translated">경우 &lt;em&gt;zdict는&lt;/em&gt; (예 :로 변경 가능한 객체 인 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ), 당신은 호출 사이에 그 내용을 수정해서는 안 &lt;a href=&quot;#zlib.decompressobj&quot;&gt; &lt;code&gt;decompressobj()&lt;/code&gt; &lt;/a&gt; 와 압축의 첫 번째 호출 &lt;code&gt;decompress()&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="98b6444e6bf4fa2e7a824739c1040724489b08e5" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;name&lt;/strong&gt; has no leading dots, then &lt;strong&gt;name&lt;/strong&gt; is simply returned. This allows for usage such as &lt;code&gt;importlib.util.resolve_name('sys', __package__)&lt;/code&gt; without doing a check to see if the &lt;strong&gt;package&lt;/strong&gt; argument is needed.</source>
          <target state="translated">경우 &lt;strong&gt;이름은&lt;/strong&gt; 선두에 도트가 없습니다, 다음 &lt;strong&gt;이름은&lt;/strong&gt; 단순히 반환됩니다. 이를 통해 &lt;strong&gt;package&lt;/strong&gt; 인수가 필요한지 확인하지 않고도 &lt;code&gt;importlib.util.resolve_name('sys', __package__)&lt;/code&gt; 과 같은 사용이 가능 합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4184d0852443b8deb67c16f50527b5c78f15fd7" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;name&lt;/strong&gt; is for a submodule (contains a dot), the parent module is automatically imported.</source>
          <target state="translated">&lt;strong&gt;이름&lt;/strong&gt; 이 하위 모듈의 &lt;strong&gt;이름 인&lt;/strong&gt; 경우 (점 포함) 상위 모듈을 자동으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a96ea5a5013dd3fe9b6e8602e6df4e7d733e2d24" translate="yes" xml:space="preserve">
          <source>If EOF is reached before the complete separator is found, an &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError&quot;&gt;&lt;code&gt;IncompleteReadError&lt;/code&gt;&lt;/a&gt; exception is raised, and the internal buffer is reset. The &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError.partial&quot;&gt;&lt;code&gt;IncompleteReadError.partial&lt;/code&gt;&lt;/a&gt; attribute may contain a portion of the separator.</source>
          <target state="translated">완전한 분리 기호를 찾기 전에 EOF에 도달하면 &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError&quot;&gt; &lt;code&gt;IncompleteReadError&lt;/code&gt; &lt;/a&gt; 예외가 발생하고 내부 버퍼가 재설정됩니다. &lt;a href=&quot;asyncio-exceptions#asyncio.IncompleteReadError.partial&quot;&gt; &lt;code&gt;IncompleteReadError.partial&lt;/code&gt; 의&lt;/a&gt; 특성은 세퍼레이터의 일부를 포함 할 수있다.</target>
        </trans-unit>
        <trans-unit id="64966df5aaf0fe93384998cc74db09b1b1e0908b" translate="yes" xml:space="preserve">
          <source>If EOF is received and &lt;code&gt;\n&lt;/code&gt; was not found, the method returns partially read data.</source>
          <target state="translated">EOF가 수신되고 &lt;code&gt;\n&lt;/code&gt; 을 찾을 수 없으면이 메소드는 부분적으로 읽은 데이터를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="37ccc310a3c93f0e5b0c94cdc94d47902bd4a292" translate="yes" xml:space="preserve">
          <source>If EOF is received and the internal buffer is empty, return an empty &lt;code&gt;bytes&lt;/code&gt; object.</source>
          <target state="translated">EOF가 수신되고 내부 버퍼가 비어 있으면 빈 &lt;code&gt;bytes&lt;/code&gt; 오브젝트를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="b333fc07ff7677c5890283c373e9cd05a53e6b15" translate="yes" xml:space="preserve">
          <source>If EOF was received and the internal buffer is empty, return an empty &lt;code&gt;bytes&lt;/code&gt; object.</source>
          <target state="translated">EOF가 수신되고 내부 버퍼가 비어 있으면 빈 &lt;code&gt;bytes&lt;/code&gt; 오브젝트를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="565904950e6bb3477bfa33cb4d9c35fc162ea0d1" translate="yes" xml:space="preserve">
          <source>If IDLE is started with the -n command line switch it will run in a single process and will not create the subprocess which runs the RPC Python execution server. This can be useful if Python cannot create the subprocess or the RPC socket interface on your platform. However, in this mode user code is not isolated from IDLE itself. Also, the environment is not restarted when Run/Run Module (F5) is selected. If your code has been modified, you must reload() the affected modules and re-import any specific items (e.g. from foo import baz) if the changes are to take effect. For these reasons, it is preferable to run IDLE with the default subprocess if at all possible.</source>
          <target state="translated">IDLE이 -n 명령 줄 스위치로 시작되면 단일 프로세스에서 실행되며 RPC Python 실행 서버를 실행하는 하위 프로세스를 만들지 않습니다. Python이 플랫폼에서 하위 프로세스 또는 RPC 소켓 인터페이스를 만들 수없는 경우에 유용 할 수 있습니다. 그러나이 모드에서 사용자 코드는 IDLE 자체와 분리되지 않습니다. 또한 Run / Run Module (F5)을 선택하면 환경이 다시 시작되지 않습니다. 코드가 수정 된 경우 변경 사항을 적용하려면 영향을받는 모듈을 다시로드 ()하고 특정 항목 (예 : foo import baz)을 다시 가져와야합니다. 이러한 이유로 가능한 경우 기본 서브 프로세스로 IDLE을 실행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4b89fe059f09f502735b8f9ac90a0efcb1f4144f" translate="yes" xml:space="preserve">
          <source>If IDLE quits with no message, and it was not started from a console, try starting from a console (&lt;code&gt;python -m idlelib&lt;/code&gt;) and see if a message appears.</source>
          <target state="translated">IDLE이 메시지없이 종료되고 콘솔에서 시작되지 않은 경우 콘솔 ( &lt;code&gt;python -m idlelib&lt;/code&gt; ) 에서 시작 하여 메시지가 나타나는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4e02c39cf406d0755b61de585d444500dd611ac8" translate="yes" xml:space="preserve">
          <source>If IDLE quits with no message, and it was not started from a console, try starting it from a console or terminal (&lt;code&gt;python -m idlelib&lt;/code&gt;) and see if this results in an error message.</source>
          <target state="translated">IDLE이 메시지없이 종료되고 콘솔에서 시작되지 않은 경우 콘솔 또는 터미널 ( &lt;code&gt;python -m idlelib&lt;/code&gt; )에서 시작하여 오류 메시지가 나타나는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6da326dbc2e0f620d5b3562ac4003336f6c4fcbf" translate="yes" xml:space="preserve">
          <source>If Python is configured &amp;ndash;with-pydebug, it also performs some expensive internal consistency checks.</source>
          <target state="translated">Python이 &amp;ndash;with-pydebug로 구성되면 값 비싼 내부 일관성 검사도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7e8ad6a5bf4b4e800e3d3c07556ce745ad232c22" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt; (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt;) continue from the next instruction. TOS is popped.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이면 ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 다음 명령어부터 계속합니다. TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="4cf9fa5811d78e12561243fd40b78efba546d577" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt; or an integer (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt;&lt;code&gt;CALL_FINALLY&lt;/code&gt;&lt;/a&gt;) it is popped from the stack.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이거나 정수 ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt; &lt;code&gt;CALL_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 된 ) 인 경우 스택에서 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="f48c5490bf7b7f8935f8dee66c02900d2c4ab8df" translate="yes" xml:space="preserve">
          <source>If TOS is &lt;code&gt;NULL&lt;/code&gt;, calls &lt;code&gt;SECOND(None, None, None)&lt;/code&gt;, removes the function from the stack, leaving TOS, and pushes &lt;code&gt;None&lt;/code&gt; to the stack. Otherwise calls &lt;code&gt;SEVENTH(TOP, SECOND, THIRD)&lt;/code&gt;, shifts the bottom 3 values of the stack down, replaces the empty spot with &lt;code&gt;NULL&lt;/code&gt; and pushes TOS. Finally pushes the result of the call.</source>
          <target state="translated">TOS가 &lt;code&gt;NULL&lt;/code&gt; 이면 &lt;code&gt;SECOND(None, None, None)&lt;/code&gt; 호출 하고 스택에서 함수를 제거하고 TOS를 남겨두고 &lt;code&gt;None&lt;/code&gt; 을 스택으로 푸시 합니다. 그렇지 않으면 &lt;code&gt;SEVENTH(TOP, SECOND, THIRD)&lt;/code&gt; 호출 하고 스택의 맨 아래 3 값을 아래로 이동하고 빈 자리를 &lt;code&gt;NULL&lt;/code&gt; 로 바꾸고 TOS를 푸시합니다. 마지막으로 통화 결과를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="abb8b40f1da2f2b2347978a298ac651c1725f8e8" translate="yes" xml:space="preserve">
          <source>If TOS is an exception type (pushed when an exception has been raised) 6 values are popped from the stack, the first three popped values are used to re-raise the exception and the last three popped values are used to restore the exception state. An exception handler block is removed from the block stack.</source>
          <target state="translated">TOS가 예외 유형 (예외가 발생했을 때 푸시 됨) 인 경우 스택에서 6 개의 값이 팝되고 처음 3 개의 팝된 값이 예외를 다시 발생시키는 데 사용되고 마지막 3 개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="2302c4982e8b01f632b216292ea649801c6c0d96" translate="yes" xml:space="preserve">
          <source>If TOS is an exception type (pushed when an exception has been raised) 6 values are popped from the stack, the last three popped values are used to restore the exception state. An exception handler block is removed from the block stack.</source>
          <target state="translated">TOS가 예외 유형 인 경우 (예외가 발생하면 푸시 됨) 스택에서 6 개의 값이 팝되고 마지막 3 개의 팝된 값이 예외 상태를 복원하는 데 사용됩니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="fd2cf047c9942e0f550e6077fa8d21cb90b76cb7" translate="yes" xml:space="preserve">
          <source>If TOS is an integer (pushed by &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt;&lt;code&gt;CALL_FINALLY&lt;/code&gt;&lt;/a&gt;), sets the bytecode counter to TOS. TOS is popped.</source>
          <target state="translated">TOS가 정수인 경우 ( &lt;a href=&quot;#opcode-CALL_FINALLY&quot;&gt; &lt;code&gt;CALL_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 바이트 코드 카운터를 TOS로 설정합니다. TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="f6c824aa2841edf27744c99adfaeb683cc13ab98" translate="yes" xml:space="preserve">
          <source>If TOS is false, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt; and leaves TOS on the stack. Otherwise (TOS is true), TOS is popped.</source>
          <target state="translated">TOS가 false이면 바이트 코드 카운터를 &lt;em&gt;대상으로&lt;/em&gt; 설정 하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS는 true) TOS가 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="38d252fb2c0b51db170eaaf60178e5958dde0da6" translate="yes" xml:space="preserve">
          <source>If TOS is false, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt;. TOS is popped.</source>
          <target state="translated">TOS가 false 인 경우 바이트 코드 카운터를 &lt;em&gt;target으로&lt;/em&gt; 설정하십시오 . TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="4d11fcb64b49991d5e23ff5378876664a570eb06" translate="yes" xml:space="preserve">
          <source>If TOS is true, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt; and leaves TOS on the stack. Otherwise (TOS is false), TOS is popped.</source>
          <target state="translated">TOS가 true이면 바이트 코드 카운터를 &lt;em&gt;대상으로&lt;/em&gt; 설정 하고 스택에 TOS를 남겨 둡니다. 그렇지 않으면 (TOS가 false 임) TOS가 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="8563156513d08688acbcc0dcf86ef18bbf609716" translate="yes" xml:space="preserve">
          <source>If TOS is true, sets the bytecode counter to &lt;em&gt;target&lt;/em&gt;. TOS is popped.</source>
          <target state="translated">TOS가 true이면 바이트 코드 카운터를 &lt;em&gt;target으로&lt;/em&gt; 설정합니다 . TOS가 팝업됩니다.</target>
        </trans-unit>
        <trans-unit id="7cc1fd538beeedcb8c3c03d14bb5f0c903b80416" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#asyncio.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#asyncio.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;#asyncio.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#asyncio.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="0f22d8dc16cef20350827c1688943ea1d51e1b6e" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; specifies a &lt;code&gt;default_factory&lt;/code&gt;, it is called with zero arguments when a default value for the field is needed. For example, to create a new instance of a list, use:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;default_factory&lt;/code&gt; 를 지정 하면 필드 의 기본값이 필요할 때 인수없이 0으로 호출됩니다. 예를 들어, 목록의 새 인스턴스를 만들려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="88fb56a53222e7bda82191727d7975a25a26bcde" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#queue.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#queue.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="8738b4c21d7c83839b7de0b30dc8bf54b691da48" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;asyncio-future#asyncio.Future.set_exception&quot;&gt;&lt;code&gt;Future.set_exception()&lt;/code&gt;&lt;/a&gt; is called but the Future object is never awaited on, the exception would never be propagated to the user code. In this case, asyncio would emit a log message when the Future object is garbage collected.</source>
          <target state="translated">경우 &lt;a href=&quot;asyncio-future#asyncio.Future.set_exception&quot;&gt; &lt;code&gt;Future.set_exception()&lt;/code&gt; &lt;/a&gt; 호출하지만 미래의 객체가 기다려온 결코 예외는 사용자 코드에 전달되지 않을 것입니다. 이 경우 Future 객체가 가비지 수집 될 때 asyncio가 로그 메시지를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8e4d1e78b745e52d4ebe30db3c57ec62db32a37b" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;queue#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; is currently blocking, it will resume when all items have been processed (meaning that a &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; call was received for every item that had been &lt;a href=&quot;#multiprocessing.Queue.put&quot;&gt;&lt;code&gt;put()&lt;/code&gt;&lt;/a&gt; into the queue).</source>
          <target state="translated">A는 경우 &lt;a href=&quot;queue#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 현재 차단하고 모든 항목 (A 것을 의미 처리 된 때, 그것은 다시 시작됩니다 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 호출이 있었다 모든 항목에 대해받은 &lt;a href=&quot;#multiprocessing.Queue.put&quot;&gt; &lt;code&gt;put()&lt;/code&gt; &lt;/a&gt; 큐에).</target>
        </trans-unit>
        <trans-unit id="d195caefdbc4c716fdba586aa4513e02d88af028" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;venv#venv-def&quot;&gt;virtual environment&lt;/a&gt; is in effect, this value will be changed in &lt;code&gt;site.py&lt;/code&gt; to point to the virtual environment. The value for the Python installation will still be available, via &lt;a href=&quot;#sys.base_exec_prefix&quot;&gt;&lt;code&gt;base_exec_prefix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;venv#venv-def&quot;&gt;가상 환경에&lt;/a&gt; 적용되는 경우,이 값은 변경 될 &lt;code&gt;site.py&lt;/code&gt; 가상 환경 포인트. Python 설치 값은 &lt;a href=&quot;#sys.base_exec_prefix&quot;&gt; &lt;code&gt;base_exec_prefix&lt;/code&gt; &lt;/a&gt; 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cadf44283b95910d5b7d617daadb92f12ea1588c" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;venv#venv-def&quot;&gt;virtual environment&lt;/a&gt; is in effect, this value will be changed in &lt;code&gt;site.py&lt;/code&gt; to point to the virtual environment. The value for the Python installation will still be available, via &lt;a href=&quot;#sys.base_prefix&quot;&gt;&lt;code&gt;base_prefix&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;venv#venv-def&quot;&gt;가상 환경에&lt;/a&gt; 적용되는 경우,이 값은 변경 될 &lt;code&gt;site.py&lt;/code&gt; 가상 환경 포인트. Python 설치 값은 &lt;a href=&quot;#sys.base_prefix&quot;&gt; &lt;code&gt;base_prefix&lt;/code&gt; &lt;/a&gt; 를 통해 계속 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fe39842fffdbab07a3dcbd6ca0ebfc6e8ddea4e" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;func&lt;/em&gt; call raises an exception, then that exception will be raised when its value is retrieved from the iterator.</source>
          <target state="translated">경우 &lt;em&gt;FUNC의&lt;/em&gt; 호출이 예외가 발생 값이 반복자에서 검색 할 때, 그 예외가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="514035568d6c1e520c43a7a94949e224b330525e" translate="yes" xml:space="preserve">
          <source>If a &lt;em&gt;weights&lt;/em&gt; sequence is specified, selections are made according to the relative weights. Alternatively, if a &lt;em&gt;cum_weights&lt;/em&gt; sequence is given, the selections are made according to the cumulative weights (perhaps computed using &lt;a href=&quot;itertools#itertools.accumulate&quot;&gt;&lt;code&gt;itertools.accumulate()&lt;/code&gt;&lt;/a&gt;). For example, the relative weights &lt;code&gt;[10, 5, 30, 5]&lt;/code&gt; are equivalent to the cumulative weights &lt;code&gt;[10, 15, 45, 50]&lt;/code&gt;. Internally, the relative weights are converted to cumulative weights before making selections, so supplying the cumulative weights saves work.</source>
          <target state="translated">경우 &lt;em&gt;가중치&lt;/em&gt; 시퀀스를 지정하고, 선택은 상대 가중치에 따라 제조된다. 또는 &lt;em&gt;cum_weights&lt;/em&gt; 시퀀스가 제공되면 누적 가중치에 따라 선택됩니다 (아마 &lt;a href=&quot;itertools#itertools.accumulate&quot;&gt; &lt;code&gt;itertools.accumulate()&lt;/code&gt; &lt;/a&gt; 사용하여 계산 ). 예를 들어, 상대 가중치 &lt;code&gt;[10, 5, 30, 5]&lt;/code&gt; 는 누적 가중치 &lt;code&gt;[10, 15, 45, 50]&lt;/code&gt; . 내부적으로 상대 가중치는 선택하기 전에 누적 가중치로 변환되므로 누적 가중치를 제공하면 작업이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="4f41fb59be7ba020951a7118cd7f719bcea2d8d7" translate="yes" xml:space="preserve">
          <source>If a DOM implementation supports modification of the document, the &lt;code&gt;NodeList&lt;/code&gt; implementation must also support the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delitem__&quot;&gt;&lt;code&gt;__delitem__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">DOM 구현이 문서 수정을 지원하는 경우 &lt;code&gt;NodeList&lt;/code&gt; 구현은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__delitem__&quot;&gt; &lt;code&gt;__delitem__()&lt;/code&gt; &lt;/a&gt; 메소드 도 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="64bf7c7fc48cc78730527a733ed22e3d79475ac8" translate="yes" xml:space="preserve">
          <source>If a DOM implementation supports modification of the document, the &lt;code&gt;NodeList&lt;/code&gt; implementation must also support the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setitem__&quot;&gt;&lt;code&gt;__setitem__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__delitem__&quot;&gt;&lt;code&gt;__delitem__()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">DOM 구현이 문서 수정을 지원하는 경우 &lt;code&gt;NodeList&lt;/code&gt; 구현은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setitem__&quot;&gt; &lt;code&gt;__setitem__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__delitem__&quot;&gt; &lt;code&gt;__delitem__()&lt;/code&gt; &lt;/a&gt; 메서드 도 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5a7b9e9c072e9d7f0dad90957cde9dde1a308b30" translate="yes" xml:space="preserve">
          <source>If a Python build or implementation cannot reasonably compute this information, &lt;a href=&quot;#sys.getallocatedblocks&quot;&gt;&lt;code&gt;getallocatedblocks()&lt;/code&gt;&lt;/a&gt; is allowed to return 0 instead.</source>
          <target state="translated">Python 빌드 또는 구현에서이 정보를 합리적으로 계산할 수없는 경우 &lt;a href=&quot;#sys.getallocatedblocks&quot;&gt; &lt;code&gt;getallocatedblocks()&lt;/code&gt; &lt;/a&gt; 대신 0을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60da62d17196410fef26f1732934782af59026ed" translate="yes" xml:space="preserve">
          <source>If a bytes object is specified as first argument, the buffer is made one item larger than its length so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the bytes should not be used.</source>
          <target state="translated">bytes 객체가 첫 번째 인수로 지정되면 버퍼의 길이보다 한 항목을 크게하여 배열의 마지막 요소가 NUL 종료 문자가되도록합니다. 바이트 길이를 사용하지 않아야 할 경우 배열의 크기를 지정할 수있는 정수를 두 번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0a9df58cde01c85e3e361479c2eaa47542a1d1e" translate="yes" xml:space="preserve">
          <source>If a class is used as a spec then the return value of the mock (the instance of the class) will have the same spec. You can use a class as the spec for an instance object by passing &lt;code&gt;instance=True&lt;/code&gt;. The returned mock will only be callable if instances of the mock are callable.</source>
          <target state="translated">클래스가 스펙으로 사용되면 모의 리턴 값 (클래스의 인스턴스)은 동일한 스펙을 갖습니다. &lt;code&gt;instance=True&lt;/code&gt; 를 전달하여 클래스를 인스턴스 객체의 사양으로 사용할 수 있습니다 . 반환 된 mock은 mock의 인스턴스가 호출 가능한 경우에만 호출 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b4f43db4f49808e0e46033f11efdb30feae93504" translate="yes" xml:space="preserve">
          <source>If a client certificate is needed for the connection, it can be added with &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">연결에 클라이언트 인증서가 필요한 경우 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; 으로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="58b445a457d97e0f901bef2a89a3d771923959d7" translate="yes" xml:space="preserve">
          <source>If a combination of Flag members is not named, the &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; will include all named flags and all named combinations of flags that are in the value:</source>
          <target state="translated">Flag 멤버 조합의 이름이 지정되지 않은 경우 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에는 이름이 지정된 모든 플래그 및 값에있는 플래그의 모든 이름 지정된 조합이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec6b65a6b4e8ded11a923539e5e70636ccd0baa" translate="yes" xml:space="preserve">
          <source>If a derived class does not wish to comply with this requirement, all of the special methods supported by this class will need to be overridden; please consult the sources for information about the methods which need to be provided in that case.</source>
          <target state="translated">파생 클래스가이 요구 사항을 준수하지 않으려면이 클래스에서 지원하는 모든 특수 메서드를 재정의해야합니다. 이 경우 제공해야하는 방법에 대한 정보는 소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="06eec7a5cb652201659973dd7752b18166617a4a" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;a href=&quot;#gettext.npgettext&quot;&gt;&lt;code&gt;npgettext()&lt;/code&gt;&lt;/a&gt; to the fallback. Otherwise, return the translated message. Overridden in derived classes.</source>
          <target state="translated">&lt;a href=&quot;#gettext.npgettext&quot;&gt; &lt;code&gt;npgettext()&lt;/code&gt; &lt;/a&gt; 설정된 경우 npgettext () 를 폴백으로 전달하십시오. 그렇지 않으면 번역 된 메시지를 반환하십시오. 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="dc269c958946b76f1994096408ccbb977101ec26" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;a href=&quot;#gettext.pgettext&quot;&gt;&lt;code&gt;pgettext()&lt;/code&gt;&lt;/a&gt; to the fallback. Otherwise, return the translated message. Overridden in derived classes.</source>
          <target state="translated">&lt;a href=&quot;#gettext.pgettext&quot;&gt; &lt;code&gt;pgettext()&lt;/code&gt; &lt;/a&gt; 설정된 경우 pgettext () 를 폴백으로 전달하십시오. 그렇지 않으면 번역 된 메시지를 반환하십시오. 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="31061e62016f356b1c4c0fbc4aa1f88db7f71ad7" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;code&gt;gettext()&lt;/code&gt; to the fallback. Otherwise, return &lt;em&gt;message&lt;/em&gt;. Overridden in derived classes.</source>
          <target state="translated">폴 백이 설정된 경우 &lt;code&gt;gettext()&lt;/code&gt; 를 폴백으로 전달하십시오. 그렇지 않으면 &lt;em&gt;message를&lt;/em&gt; 반환하십시오 . 파생 클래스에서 재정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="1742c3486fc827c0e30b5e6a8b02073a52c6f50e" translate="yes" xml:space="preserve">
          <source>If a fallback has been set, forward &lt;code&gt;ngettext()&lt;/code&gt; to the fallback. Otherwise, return &lt;em&gt;singular&lt;/em&gt; if &lt;em&gt;n&lt;/em&gt; is 1; return &lt;em&gt;plural&lt;/em&gt; otherwise. Overridden in derived classes.</source>
          <target state="translated">&lt;code&gt;ngettext()&lt;/code&gt; 백이 설정된 경우 ngettext () 를 폴백으로 전달하십시오. 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 이면 &lt;em&gt;특이&lt;/em&gt; 값을 반환합니다 . 반환 &lt;em&gt;복수&lt;/em&gt; 그렇지. 파생 클래스에서 재정의되었습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8d7b45636976cf2d05c5fad71555cb6ec8a500e2" translate="yes" xml:space="preserve">
          <source>If a field is excluded from &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;init=False&lt;/code&gt;) and the field also specifies &lt;code&gt;default_factory&lt;/code&gt;, then the default factory function will always be called from the generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; function. This happens because there is no other way to give the field an initial value.</source>
          <target state="translated">필드가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 에서 제외되고 ( &lt;code&gt;init=False&lt;/code&gt; 사용 ) 필드도 &lt;code&gt;default_factory&lt;/code&gt; 를 지정 하면 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 함수 에서 기본 팩토리 함수가 항상 호출됩니다 . 이는 필드에 초기 값을 제공 할 다른 방법이 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b816e391be58835aacea83280a02125eac7068b2" translate="yes" xml:space="preserve">
          <source>If a field is excluded from &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; (using &lt;code&gt;init=False&lt;/code&gt;) and the field also specifies &lt;code&gt;default_factory&lt;/code&gt;, then the default factory function will always be called from the generated &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; function. This happens because there is no other way to give the field an initial value.</source>
          <target state="translated">필드가 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 에서 제외되고 ( &lt;code&gt;init=False&lt;/code&gt; 사용 ) 필드가 &lt;code&gt;default_factory&lt;/code&gt; 도 지정 하면 기본 팩토리 함수는 항상 생성 된 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 함수에서 호출됩니다. 이는 필드에 초기 값을 제공하는 다른 방법이 없기 때문에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="565807013493930067f8f17afe47ed0e67b8a0c2" translate="yes" xml:space="preserve">
          <source>If a field represents an uploaded file, accessing the value via the &lt;code&gt;value&lt;/code&gt; attribute or the &lt;code&gt;getvalue()&lt;/code&gt; method reads the entire file in memory as bytes. This may not be what you want. You can test for an uploaded file by testing either the &lt;code&gt;filename&lt;/code&gt; attribute or the &lt;code&gt;file&lt;/code&gt; attribute. You can then read the data from the &lt;code&gt;file&lt;/code&gt; attribute before it is automatically closed as part of the garbage collection of the &lt;code&gt;FieldStorage&lt;/code&gt; instance (the &lt;a href=&quot;io#io.RawIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt; methods will return bytes):</source>
          <target state="translated">필드가 업로드 된 파일을 나타내는 경우 &lt;code&gt;value&lt;/code&gt; 속성 또는 &lt;code&gt;getvalue()&lt;/code&gt; 메소드 를 통해 값에 액세스하면 메모리에서 전체 파일을 바이트로 읽습니다. 이것은 당신이 원하는 것이 아닐 수도 있습니다. 당신이 중 하나를 테스트하여 업로드 된 파일을 테스트 할 수 있습니다 &lt;code&gt;filename&lt;/code&gt; 특성 또는 &lt;code&gt;file&lt;/code&gt; 속성을. 그런 다음 &lt;code&gt;FieldStorage&lt;/code&gt; 인스턴스 의 가비지 콜렉션의 일부로 &lt;code&gt;file&lt;/code&gt; 속성이 자동으로 닫히기 전에 파일 속성 에서 데이터를 읽을 수 있습니다 ( &lt;a href=&quot;io#io.RawIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; 메소드는 바이트를 리턴 함).</target>
        </trans-unit>
        <trans-unit id="2ac00aa24d225f2a25916402cc6d54632f003730" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;.pdbrc&lt;/code&gt; exists in the user&amp;rsquo;s home directory or in the current directory, it is read in and executed as if it had been typed at the debugger prompt. This is particularly useful for aliases. If both files exist, the one in the home directory is read first and aliases defined there can be overridden by the local file.</source>
          <target state="translated">&lt;code&gt;.pdbrc&lt;/code&gt; 파일 이 사용자의 홈 디렉토리 또는 현재 디렉토리에 존재하면 마치 디버거 프롬프트에서 입력 한 것처럼 파일을 읽고 실행합니다. 별명에 특히 유용합니다. 두 파일이 모두 존재하면 홈 디렉토리에있는 파일을 먼저 읽고 별명을 정의하여 로컬 파일로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5448f252b6aeff14276e99301e4c6e612a601743" translate="yes" xml:space="preserve">
          <source>If a file named &amp;ldquo;pyvenv.cfg&amp;rdquo; exists one directory above sys.executable, sys.prefix and sys.exec_prefix are set to that directory and it is also checked for site-packages (sys.base_prefix and sys.base_exec_prefix will always be the &amp;ldquo;real&amp;rdquo; prefixes of the Python installation). If &amp;ldquo;pyvenv.cfg&amp;rdquo; (a bootstrap configuration file) contains the key &amp;ldquo;include-system-site-packages&amp;rdquo; set to anything other than &amp;ldquo;true&amp;rdquo; (case-insensitive), the system-level prefixes will not be searched for site-packages; otherwise they will.</source>
          <target state="translated">&amp;ldquo;pyvenv.cfg&amp;rdquo;라는 파일이 sys. executable 위에 하나의 디렉토리가 존재하면 sys.prefix 및 sys.exec_prefix가 해당 디렉토리로 설정되고 사이트 패키지도 검사됩니다 (sys.base_prefix 및 sys.base_exec_prefix는 항상 Python 설치의 &quot;실제&quot;접두사). &quot;pyvenv.cfg&quot;(부트 스트랩 구성 파일)에 &quot;true&quot;(대소 문자 구분) 이외의 것으로 설정된 &quot;include-system-site-packages&quot;키가 포함되어 있으면 시스템 수준 접두사에서 사이트를 검색하지 않습니다. 패키지; 그렇지 않으면 그들은 할 것이다.</target>
        </trans-unit>
        <trans-unit id="b1c78860034600d414c83db7d32c54bb73e1ecd7" translate="yes" xml:space="preserve">
          <source>If a file named &lt;em&gt;filename&lt;/em&gt; is not found, the function first checks for a &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;&lt;code&gt;__loader__&lt;/code&gt; in &lt;em&gt;module_globals&lt;/em&gt;. If there is such a loader and it defines a &lt;code&gt;get_source&lt;/code&gt; method, then that determines the source lines (if &lt;code&gt;get_source()&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, then &lt;code&gt;''&lt;/code&gt; is returned). Finally, if &lt;em&gt;filename&lt;/em&gt; is a relative filename, it is looked up relative to the entries in the module search path, &lt;code&gt;sys.path&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일을&lt;/em&gt; 찾을 수 없으면, 함수는 먼저 &lt;code&gt;__loader__&lt;/code&gt; 에서 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt; __loader__ 를 &lt;em&gt;확인&lt;/em&gt; 합니다. 그러한 로더가 있고 &lt;code&gt;get_source&lt;/code&gt; 메소드를 정의 하면 소스 라인을 판별합니다 ( &lt;code&gt;get_source()&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 을 리턴 하면 &lt;code&gt;''&lt;/code&gt; 가 리턴 됨). 마지막으로 &lt;em&gt;filename&lt;/em&gt; 이 상대 파일 이름 인 경우 모듈 검색 경로 ( &lt;code&gt;sys.path&lt;/code&gt; ) 의 항목을 기준으로 조회 됩니다.</target>
        </trans-unit>
        <trans-unit id="f21e40fc27ce27eb35a61db85ca27f562b3c3c39" translate="yes" xml:space="preserve">
          <source>If a file object is specified for &lt;em&gt;source&lt;/em&gt; or &lt;em&gt;target&lt;/em&gt;, it is the caller&amp;rsquo;s responsibility to close it after calling create_archive.</source>
          <target state="translated">&lt;em&gt;source&lt;/em&gt; 또는 &lt;em&gt;target에&lt;/em&gt; 파일 객체가 지정된 경우 create_archive를 호출 한 후 파일 객체 를 닫는 것은 호출자의 책임입니다.</target>
        </trans-unit>
        <trans-unit id="b9fb12c7a74ac666cff163edc7c96b0feb897a76" translate="yes" xml:space="preserve">
          <source>If a formatter is specified, it is used to format the record. The record is then written to the stream followed by &lt;a href=&quot;#logging.StreamHandler.terminator&quot;&gt;&lt;code&gt;terminator&lt;/code&gt;&lt;/a&gt;. If exception information is present, it is formatted using &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt;&lt;code&gt;traceback.print_exception()&lt;/code&gt;&lt;/a&gt; and appended to the stream.</source>
          <target state="translated">포맷터가 지정되면 레코드를 포맷하는 데 사용됩니다. 그런 다음 레코드가 스트림에 기록되고 그 뒤에 &lt;a href=&quot;#logging.StreamHandler.terminator&quot;&gt; &lt;code&gt;terminator&lt;/code&gt; &lt;/a&gt; 옵니다 . 예외 정보가있는 경우 &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt; &lt;code&gt;traceback.print_exception()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 스트림에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3207350b9a94fa842bcda66334617cd920267c5" translate="yes" xml:space="preserve">
          <source>If a formatter is specified, it is used to format the record. The record is then written to the stream with a terminator. If exception information is present, it is formatted using &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt;&lt;code&gt;traceback.print_exception()&lt;/code&gt;&lt;/a&gt; and appended to the stream.</source>
          <target state="translated">포맷터가 지정된 경우 레코드를 포맷하는 데 사용됩니다. 그런 다음 레코드는 종결 자와 함께 스트림에 기록됩니다. 예외 정보가있는 경우 &lt;a href=&quot;traceback#traceback.print_exception&quot;&gt; &lt;code&gt;traceback.print_exception()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 스트림에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="76e26d9c99665021cd2747cf34bdb27b0c694a2b" translate="yes" xml:space="preserve">
          <source>If a generator code directly or indirectly raises &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt;, it is converted into a &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; (retaining the &lt;a href=&quot;#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; as the new exception&amp;rsquo;s cause).</source>
          <target state="translated">생성기 코드가 직접 또는 간접적으로 &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; 을&lt;/a&gt; 발생시키는 경우, &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 ( &lt;a href=&quot;#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 을 새 예외의 원인으로 유지함 ).</target>
        </trans-unit>
        <trans-unit id="93d34f8fd817c6e0f1345b2e762a4c72177524ff" translate="yes" xml:space="preserve">
          <source>If a group matches multiple times, only the last match is accessible:</source>
          <target state="translated">그룹이 여러 번 일치하면 마지막 일치 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cbbe58498c91a0c4d108c85bbbabc900782816b" translate="yes" xml:space="preserve">
          <source>If a member filename is an absolute path, a drive/UNC sharepoint and leading (back)slashes will be stripped, e.g.: &lt;code&gt;///foo/bar&lt;/code&gt; becomes &lt;code&gt;foo/bar&lt;/code&gt; on Unix, and &lt;code&gt;C:\foo\bar&lt;/code&gt; becomes &lt;code&gt;foo\bar&lt;/code&gt; on Windows. And all &lt;code&gt;&quot;..&quot;&lt;/code&gt; components in a member filename will be removed, e.g.: &lt;code&gt;../../foo../../ba..r&lt;/code&gt; becomes &lt;code&gt;foo../ba..r&lt;/code&gt;. On Windows illegal characters (&lt;code&gt;:&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;&quot;&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt;) replaced by underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">: 멤버 이름 절대 경로, 드라이브 / UNC 셰어 선도 (뒷면) 슬래시 경우, 예를 들어 제거한다 &lt;code&gt;///foo/bar&lt;/code&gt; 해진다 &lt;code&gt;foo/bar&lt;/code&gt; 유닉스 및 &lt;code&gt;C:\foo\bar&lt;/code&gt; 된다 &lt;code&gt;foo\bar&lt;/code&gt; Windows에서. 그리고 멤버 파일 이름의 모든 &lt;code&gt;&quot;..&quot;&lt;/code&gt; 구성 요소가 제거됩니다. 예 : &lt;code&gt;../../foo../../ba..r&lt;/code&gt; 은 &lt;code&gt;foo../ba..r&lt;/code&gt; 됩니다. Windows에서 잘못된 문자 ( &lt;code&gt;:&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;&quot;&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; )는 밑줄 ( &lt;code&gt;_&lt;/code&gt; ) 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="503137eb198604b87efeb2bcd433e998e37317d8" translate="yes" xml:space="preserve">
          <source>If a member occurs more than once in the archive, its last occurrence is assumed to be the most up-to-date version.</source>
          <target state="translated">아카이브에서 멤버가 두 번 이상 발생하면 마지막 발생이 최신 버전 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="f787e74c446e2990e618d08579803f817ebdb5cc" translate="yes" xml:space="preserve">
          <source>If a mock instance with a name or a spec is assigned to an attribute it won&amp;rsquo;t be considered in the sealing chain. This allows one to prevent seal from fixing part of the mock object.</source>
          <target state="translated">이름이나 사양을 가진 모의 인스턴스가 속성에 할당되면 실링 체인에서 고려되지 않습니다. 이것은 실이 모의 물체의 일부를 고정시키는 것을 방지 할 수있게한다.</target>
        </trans-unit>
        <trans-unit id="392fa48383638f6ca8f0993f37a1ecb79cf4aca5" translate="yes" xml:space="preserve">
          <source>If a module imports objects from another module using &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; &amp;hellip;, calling &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; for the other module does not redefine the objects imported from it &amp;mdash; one way around this is to re-execute the &lt;code&gt;from&lt;/code&gt; statement, another is to use &lt;code&gt;import&lt;/code&gt; and qualified names (&lt;em&gt;module.name&lt;/em&gt;) instead.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; &amp;hellip;를 사용하여 모듈이 다른 모듈에서 객체를 가져 오는 경우 다른 모듈 에 대해 &lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; &lt;/a&gt; 를 호출 해도 가져온 모듈은 다시 정의되지 않습니다.이 중 한 가지 방법은 &lt;code&gt;from&lt;/code&gt; 문 을 다시 실행하는 것이고 , 다른 하나는 &lt;code&gt;import&lt;/code&gt; 및 정규화 된 이름 ( &lt;em&gt;module.name&lt;/em&gt; )을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e0fbd5416d4fb25d2ad3b48282765b7c4ee154b5" translate="yes" xml:space="preserve">
          <source>If a module imports objects from another module using &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt;&lt;code&gt;from&lt;/code&gt;&lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; &amp;hellip;, calling &lt;a href=&quot;#importlib.reload&quot;&gt;&lt;code&gt;reload()&lt;/code&gt;&lt;/a&gt; for the other module does not redefine the objects imported from it &amp;mdash; one way around this is to re-execute the &lt;code&gt;from&lt;/code&gt; statement, another is to use &lt;code&gt;import&lt;/code&gt; and qualified names (&lt;em&gt;module.name&lt;/em&gt;) instead.</source>
          <target state="translated">모듈이 &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#from&quot;&gt; &lt;code&gt;from&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; &amp;hellip;를 사용하여 다른 모듈에서 객체를 가져 오는 경우 다른 모듈 에 대해 &lt;a href=&quot;#importlib.reload&quot;&gt; &lt;code&gt;reload()&lt;/code&gt; &lt;/a&gt; 를 호출 해도 해당 모듈에서 가져온 객체가 재정의되지 않습니다. 한 가지 방법은 &lt;code&gt;from&lt;/code&gt; 문 을 다시 실행하는 것이고 다른 하나는 &lt;code&gt;import&lt;/code&gt; 및 대신 정규화 된 이름 ( &lt;em&gt;module.name&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="b76b30a9fc3685533f4941dde34b064d15308902" translate="yes" xml:space="preserve">
          <source>If a module instantiates instances of a class, reloading the module that defines the class does not affect the method definitions of the instances &amp;mdash; they continue to use the old class definition. The same is true for derived classes.</source>
          <target state="translated">모듈이 클래스의 인스턴스를 인스턴스화하는 경우 클래스를 정의하는 모듈을 다시로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다. 이전 클래스 정의는 계속 사용됩니다. 파생 클래스에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c7274841cd2a6c4fb6fc0a1fd5f00a02812a3cd7" translate="yes" xml:space="preserve">
          <source>If a module provides a &lt;code&gt;load_tests&lt;/code&gt; function it will be called to load the tests. This allows modules to customize test loading. This is the &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests protocol&lt;/a&gt;. The &lt;em&gt;pattern&lt;/em&gt; argument is passed as the third argument to &lt;code&gt;load_tests&lt;/code&gt;.</source>
          <target state="translated">모듈이 &lt;code&gt;load_tests&lt;/code&gt; 함수를 제공 하면 테스트를로드하기 위해 호출됩니다. 이를 통해 모듈은 테스트로드를 사용자 정의 할 수 있습니다. 이것이 &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests 프로토콜&lt;/a&gt; 입니다. &lt;em&gt;패턴&lt;/em&gt; 인수는 세 번째 인수로 전달됩니다 &lt;code&gt;load_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9967a7e9f61023ca795710b85aa3fd3437d08d6a" translate="yes" xml:space="preserve">
          <source>If a mutable buffer is passed, then the behaviour is determined by the value of the &lt;em&gt;mutate_flag&lt;/em&gt; parameter.</source>
          <target state="translated">변경 가능한 버퍼가 전달되면 &lt;em&gt;mutate_flag&lt;/em&gt; 매개 변수 의 값에 의해 동작이 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6c9bf31eba484225f370bea56998b125d4165981" translate="yes" xml:space="preserve">
          <source>If a mutable mapping is not available or if space-efficient key sharing is desired, an effect similar to &lt;a href=&quot;#functools.cached_property&quot;&gt;&lt;code&gt;cached_property()&lt;/code&gt;&lt;/a&gt; can be achieved by a stacking &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property()&lt;/code&gt;&lt;/a&gt; on top of &lt;a href=&quot;#functools.cache&quot;&gt;&lt;code&gt;cache()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">변경 가능한 매핑을 사용할 수 없거나 공간 효율적인 키 공유가 필요한 경우 &lt;a href=&quot;#functools.cache&quot;&gt; &lt;code&gt;cache()&lt;/code&gt; &lt;/a&gt; 상단의 &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property()&lt;/code&gt; &lt;/a&gt; 스택을 통해 &lt;a href=&quot;#functools.cached_property&quot;&gt; &lt;code&gt;cached_property()&lt;/code&gt; &lt;/a&gt; 와 유사한 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1fc9fb74f4ebf143daf34473be06e5da4ab833c" translate="yes" xml:space="preserve">
          <source>If a new seeding method is added, then a backward compatible seeder will be offered.</source>
          <target state="translated">새로운 파종 방법이 추가되면 이전 버전과 호환되는 파종기가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="133e9d936cb0cf3ade6b9637c210b91b2ab80815" translate="yes" xml:space="preserve">
          <source>If a package (a directory containing a file named &lt;code&gt;__init__.py&lt;/code&gt;) is found, the package will be checked for a &lt;code&gt;load_tests&lt;/code&gt; function. If this exists then it will be called &lt;code&gt;package.load_tests(loader, tests, pattern)&lt;/code&gt;. Test discovery takes care to ensure that a package is only checked for tests once during an invocation, even if the load_tests function itself calls &lt;code&gt;loader.discover&lt;/code&gt;.</source>
          <target state="translated">패키지 ( &lt;code&gt;__init__.py&lt;/code&gt; 라는 파일을 포함하는 디렉토리 )가 발견되면 패키지는 &lt;code&gt;load_tests&lt;/code&gt; 함수를 검사 합니다. 이것이 존재하면 &lt;code&gt;package.load_tests(loader, tests, pattern)&lt;/code&gt; 합니다. &lt;code&gt;loader.discover&lt;/code&gt; 함수 자체가 loader.discover를 호출하더라도 호출 중에 패키지가 테스트에 대해 한 번만 검사되도록 테스트 감지가주의를 기울 입니다.</target>
        </trans-unit>
        <trans-unit id="de4d246a31d1c98bfbbe12597b38a1577e9dcbc3" translate="yes" xml:space="preserve">
          <source>If a part has a &lt;em&gt;Content-Disposition&lt;/em&gt; header, only consider the part a candidate match if the value of the header is &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">파트에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가있는 경우 헤더 값이 &lt;code&gt;inline&lt;/code&gt; 인 경우에만 해당 파트가 후보 일치 항목으로 간주하십시오 .</target>
        </trans-unit>
        <trans-unit id="08bdb3b5117fe753e55ab3386000a7b11f147e33" translate="yes" xml:space="preserve">
          <source>If a particular application uses this pattern a lot, it can be simplified even further by means of a small helper class:</source>
          <target state="translated">특정 응용 프로그램에서이 패턴을 많이 사용하면 작은 도우미 클래스를 사용하여 훨씬 더 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca72e817de266e57decb5a9ba95638d41c318561" translate="yes" xml:space="preserve">
          <source>If a pointer points to an array, its elements can be read and written using standard subscript and slice accesses. Pointer objects have no size, so &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. Negative subscripts will read from the memory &lt;em&gt;before&lt;/em&gt; the pointer (as in C), and out-of-range subscripts will probably crash with an access violation (if you&amp;rsquo;re lucky).</source>
          <target state="translated">포인터가 배열을 가리키는 경우 표준 첨자 및 슬라이스 액세스를 사용하여 해당 요소를 읽고 쓸 수 있습니다. 포인터 객체는 크기가 없으므로 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 음수 첨자는 포인터 &lt;em&gt;앞&lt;/em&gt; 의 메모리에서 읽으며 (C에서와 같이) 범위를 벗어난 첨자는 액세스 위반으로 인해 충돌 할 수 있습니다 (행운이있는 경우).</target>
        </trans-unit>
        <trans-unit id="eed381cd380722df57d19d1544f97f6af790e234" translate="yes" xml:space="preserve">
          <source>If a process is killed using &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.kill&quot;&gt;&lt;code&gt;os.kill()&lt;/code&gt;&lt;/a&gt; while it is trying to use a &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt;, then the data in the queue is likely to become corrupted. This may cause any other process to get an exception when it tries to use the queue later on.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 를 사용하려고 시도하는 동안 &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.kill&quot;&gt; &lt;code&gt;os.kill()&lt;/code&gt; &lt;/a&gt; 을 사용하여 프로세스가 종료 되면 큐의 데이터가 손상 될 수 있습니다. 이로 인해 나중에 큐를 사용하려고 할 때 다른 프로세스에서 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56d1f01d3ec2d55cce1c8cf716b703713495099e" translate="yes" xml:space="preserve">
          <source>If a process is killed while it is trying to read or write to a pipe then the data in the pipe is likely to become corrupted, because it may become impossible to be sure where the message boundaries lie.</source>
          <target state="translated">파이프를 읽거나 쓰려고 시도하는 동안 프로세스가 종료되면 파이프의 데이터가 손상 될 수 있습니다. 메시지 경계가 어디에 있는지 확신 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ee27c621c4af454357253732e654ec550abd9b30" translate="yes" xml:space="preserve">
          <source>If a regular expression ends with a greedy match (such as &lt;code&gt;.*&lt;/code&gt;) or if more than one expression can match the same input, the results are non-deterministic, and may depend on the I/O timing.</source>
          <target state="translated">정규식이 욕심 일치 (예 : &lt;code&gt;.*&lt;/code&gt; ) 로 끝나 거나 둘 이상의식이 동일한 입력과 일치 할 수있는 경우 결과는 결정적이지 않으며 I / O 타이밍에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f18a5c5319b593cf33dfdbccb25dc47d86b19fc" translate="yes" xml:space="preserve">
          <source>If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by &lt;em&gt;restkey&lt;/em&gt; (which defaults to &lt;code&gt;None&lt;/code&gt;). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">행에 fieldnames보다 많은 필드가있는 경우 나머지 데이터는 목록에 저장되고 &lt;em&gt;restkey에&lt;/em&gt; 의해 지정된 fieldname (기본값은 &lt;code&gt;None&lt;/code&gt; )으로 저장됩니다. 공백이 아닌 행에 fieldnames보다 적은 수의 필드가 있으면 결 측값은 &lt;code&gt;None&lt;/code&gt; 으로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="3dd35a6c80f7f0600c8d0aa1d7f3052ebfaabfee" translate="yes" xml:space="preserve">
          <source>If a row has more fields than fieldnames, the remaining data is put in a list and stored with the fieldname specified by &lt;em&gt;restkey&lt;/em&gt; (which defaults to &lt;code&gt;None&lt;/code&gt;). If a non-blank row has fewer fields than fieldnames, the missing values are filled-in with the value of &lt;em&gt;restval&lt;/em&gt; (which defaults to &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">행에 fieldnames보다 많은 필드가있는 경우 나머지 데이터는 목록에 배치되고 &lt;em&gt;restkey로&lt;/em&gt; 지정된 fieldname (기본값은 &lt;code&gt;None&lt;/code&gt; )으로 저장됩니다. 비어 있지 않은 행에 fieldnames보다 적은 수의 필드가있는 경우 누락 된 값은 &lt;em&gt;restval&lt;/em&gt; 값으로 &lt;em&gt;채워집니다&lt;/em&gt; (기본값은 &lt;code&gt;None&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="005f4f5ea8b5cbe5aac64333d420adc456c1595c" translate="yes" xml:space="preserve">
          <source>If a second argument is present, it is an expression which must evaluate to true before the breakpoint is honored.</source>
          <target state="translated">두 번째 인수가 있으면 중단 점이 적용되기 전에 true로 평가되어야하는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="8557dead7893ee28dc4312dd3fbd82bd7ef26377" translate="yes" xml:space="preserve">
          <source>If a sequence of events takes longer to run than the time available before the next event, the scheduler will simply fall behind. No events will be dropped; the calling code is responsible for canceling events which are no longer pertinent.</source>
          <target state="translated">일련의 이벤트가 다음 이벤트 이전에 사용 가능한 시간보다 실행하는 데 시간이 오래 걸리면 스케줄러가 단순히 뒤처집니다. 이벤트가 삭제되지 않습니다. 호출 코드는 더 이상 관련이없는 이벤트를 취소합니다.</target>
        </trans-unit>
        <trans-unit id="a04337ee52a07d55c116e62a9138163aca040133" translate="yes" xml:space="preserve">
          <source>If a string is returned, the string should be interpreted as the name of a global variable. It should be the object&amp;rsquo;s local name relative to its module; the pickle module searches the module namespace to determine the object&amp;rsquo;s module. This behaviour is typically useful for singletons.</source>
          <target state="translated">문자열이 반환되면 문자열을 전역 변수의 이름으로 해석해야합니다. 모듈과 관련된 객체의 로컬 이름이어야합니다. 피클 모듈은 모듈 네임 스페이스를 검색하여 객체의 모듈을 결정합니다. 이 동작은 일반적으로 싱글 톤에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b77fc0289dcb779f53a98f0301822ac00449bb60" translate="yes" xml:space="preserve">
          <source>If a string is specified as first argument, the buffer is made one item larger than the length of the string so that the last element in the array is a NUL termination character. An integer can be passed as second argument which allows specifying the size of the array if the length of the string should not be used.</source>
          <target state="translated">문자열이 첫 번째 인수로 지정된 경우, 배열의 마지막 요소가 NUL 종료 문자가되도록 버퍼는 문자열 길이보다 하나의 항목을 크게 만듭니다. 문자열의 길이를 사용하지 않아야 할 경우 배열의 크기를 지정할 수있는 정수를 두 번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21c6bea79d147aa97afcd362c1b240007ff84d93" translate="yes" xml:space="preserve">
          <source>If a string of characters is typed, the ACW selection will jump to the entry most closely matching those characters. Entering a</source>
          <target state="translated">문자열을 입력하면 ACW 선택 항목이 해당 문자와 ​​가장 일치하는 항목으로 이동합니다. 입력</target>
        </trans-unit>
        <trans-unit id="1ad7ab62792840cafd5c6a7e7c21e711f92ec2c4" translate="yes" xml:space="preserve">
          <source>If a subclass of dict defines a method &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;key&lt;/em&gt; is not present, the &lt;code&gt;d[key]&lt;/code&gt; operation calls that method with the key &lt;em&gt;key&lt;/em&gt; as argument. The &lt;code&gt;d[key]&lt;/code&gt; operation then returns or raises whatever is returned or raised by the &lt;code&gt;__missing__(key)&lt;/code&gt; call. No other operations or methods invoke &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is not defined, &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; must be a method; it cannot be an instance variable:</source>
          <target state="translated">dict의 서브 클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 메소드를 정의 하고 &lt;em&gt;키&lt;/em&gt; 가없는 경우 &lt;code&gt;d[key]&lt;/code&gt; 조작은 키 &lt;em&gt;키&lt;/em&gt; 를 인수로 사용하여 해당 메소드를 호출합니다 . 그런 다음 &lt;code&gt;d[key]&lt;/code&gt; 작업은 &lt;code&gt;__missing__(key)&lt;/code&gt; 호출에 의해 반환되거나 발생한 것을 반환하거나 발생 시킵니다 . 다른 작업이나 메서드는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 . 경우 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 정의되지 않은, &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 은 메서드 여야합니다. 인스턴스 변수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="424b2b429c597fc703ea743529e362c1e6d5508f" translate="yes" xml:space="preserve">
          <source>If a subclass of dict defines a method &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; and &lt;em&gt;key&lt;/em&gt; is not present, the &lt;code&gt;d[key]&lt;/code&gt; operation calls that method with the key &lt;em&gt;key&lt;/em&gt; as argument. The &lt;code&gt;d[key]&lt;/code&gt; operation then returns or raises whatever is returned or raised by the &lt;code&gt;__missing__(key)&lt;/code&gt; call. No other operations or methods invoke &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is not defined, &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised. &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; must be a method; it cannot be an instance variable:</source>
          <target state="translated">dict의 하위 클래스가 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 메서드를 정의 하고 &lt;em&gt;key&lt;/em&gt; 가없는 경우 &lt;code&gt;d[key]&lt;/code&gt; 작업은 키 &lt;em&gt;키&lt;/em&gt; 를 인수로 사용하여 해당 메서드를 호출합니다 . 그런 다음 &lt;code&gt;d[key]&lt;/code&gt; 연산은 &lt;code&gt;__missing__(key)&lt;/code&gt; 호출에 의해 반환되거나 발생한 모든 것을 반환하거나 발생 시킵니다 . 다른 작업이나 메서드는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 호출하지 않습니다 . 경우 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 정의되지 않은, &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 은 메소드 여야합니다. 인스턴스 변수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f05a402a563718610b92e3f5ebab6bc115c75aff" translate="yes" xml:space="preserve">
          <source>If a subclass overrides the constructor, it must make sure it invokes the base class constructor (&lt;code&gt;Process.__init__()&lt;/code&gt;) before doing anything else to the process.</source>
          <target state="translated">서브 클래스가 생성자를 대체하는 경우 &lt;code&gt;Process.__init__()&lt;/code&gt; 다른 작업을 수행하기 전에 기본 클래스 생성자 ( Process .__ init __ () )를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7167bd01592177c6831e227c0f96cfa70f5703f6" translate="yes" xml:space="preserve">
          <source>If a test is dependent on a specific condition of the operating system then verify the condition already exists before attempting the test.</source>
          <target state="translated">테스트가 운영 체제의 특정 조건에 종속 된 경우 테스트를 시도하기 전에 조건이 이미 존재하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fdb64156356707d7f00a7d8b9a96bfe1ba13d7ee" translate="yes" xml:space="preserve">
          <source>If a test module defines &lt;code&gt;load_tests&lt;/code&gt; it will be called by &lt;a href=&quot;#unittest.TestLoader.loadTestsFromModule&quot;&gt;&lt;code&gt;TestLoader.loadTestsFromModule()&lt;/code&gt;&lt;/a&gt; with the following arguments:</source>
          <target state="translated">테스트 모듈을 정의하는 경우 &lt;code&gt;load_tests&lt;/code&gt; 가 호출됩니다 &lt;a href=&quot;#unittest.TestLoader.loadTestsFromModule&quot;&gt; &lt;code&gt;TestLoader.loadTestsFromModule()&lt;/code&gt; &lt;/a&gt; 다음 인수와 함께 :</target>
        </trans-unit>
        <trans-unit id="7b41e613a791d1534ee88b6d5457f6ce5e983848" translate="yes" xml:space="preserve">
          <source>If a test using &lt;a href=&quot;#test.support.SHORT_TIMEOUT&quot;&gt;&lt;code&gt;SHORT_TIMEOUT&lt;/code&gt;&lt;/a&gt; starts to fail randomly on slow buildbots, use &lt;a href=&quot;#test.support.LONG_TIMEOUT&quot;&gt;&lt;code&gt;LONG_TIMEOUT&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;a href=&quot;#test.support.SHORT_TIMEOUT&quot;&gt; &lt;code&gt;SHORT_TIMEOUT&lt;/code&gt; 을&lt;/a&gt; 사용하는 테스트 가 느린 &lt;a href=&quot;#test.support.LONG_TIMEOUT&quot;&gt; &lt;code&gt;LONG_TIMEOUT&lt;/code&gt; &lt;/a&gt; 에서 무작위로 실패하기 시작하면 대신 LONG_TIMEOUT을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="56a75cd42f01b47ed5b176576dca9593b3d7d4ee" translate="yes" xml:space="preserve">
          <source>If a timeout occurs, it cancels the task and raises &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt;&lt;code&gt;asyncio.TimeoutError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간 초과가 발생하면 작업이 취소되고 &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt; &lt;code&gt;asyncio.TimeoutError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="4894447c60737f3d9dbafbd5dd46efa9b16f3b36" translate="yes" xml:space="preserve">
          <source>If a timestamp stored in SQLite has a fractional part longer than 6 numbers, its value will be truncated to microsecond precision by the timestamp converter.</source>
          <target state="translated">SQLite에 저장된 타임 스탬프가 6보다 긴 소수 부분을 가진 경우 타임 스탬프 변환기에서 해당 값이 마이크로 초 정밀도로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="5ac42206d9872e5d1063a9d182b043d77e4d7069" translate="yes" xml:space="preserve">
          <source>If a valid &lt;em&gt;align&lt;/em&gt; value is specified, it can be preceded by a &lt;em&gt;fill&lt;/em&gt; character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (&amp;ldquo;&lt;code&gt;{&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;}&lt;/code&gt;&amp;rdquo;) as the &lt;em&gt;fill&lt;/em&gt; character in a &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;formatted string literal&lt;/a&gt; or when using the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn&amp;rsquo;t affect the &lt;a href=&quot;functions#format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">유효한 &lt;em&gt;정렬&lt;/em&gt; 값이 지정되면 임의의 문자가 될 수 있는 &lt;em&gt;채우기&lt;/em&gt; 문자가 앞에 올 수 있으며 생략하면 기본값이 공백이됩니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;포맷 된 문자열 리터럴에서&lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 메소드 를 사용할 때 리터럴 중괄호 (&amp;ldquo; &lt;code&gt;{&lt;/code&gt; &amp;rdquo;또는&amp;ldquo; &lt;code&gt;}&lt;/code&gt; &amp;rdquo;)를 &lt;em&gt;채우기&lt;/em&gt; 문자로 사용할 수 없습니다 . 그러나 중첩 된 대체 필드와 함께 중괄호를 삽입 할 수 있습니다. 이 제한은 &lt;a href=&quot;functions#format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 함수에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="209e528a468007cdf3064daca793d8a4165d42e3" translate="yes" xml:space="preserve">
          <source>If a valid &lt;em&gt;align&lt;/em&gt; value is specified, it can be preceded by a &lt;em&gt;fill&lt;/em&gt; character that can be any character and defaults to a space if omitted. It is not possible to use a literal curly brace (&amp;ldquo;&lt;code&gt;{&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;}&lt;/code&gt;&amp;rdquo;) as the &lt;em&gt;fill&lt;/em&gt; character in a &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#f-strings&quot;&gt;formatted string literal&lt;/a&gt; or when using the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; method. However, it is possible to insert a curly brace with a nested replacement field. This limitation doesn&amp;rsquo;t affect the &lt;a href=&quot;functions#format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">유효한 &lt;em&gt;정렬&lt;/em&gt; 값이 지정되면 임의의 문자가 될 수 있는 &lt;em&gt;채우기&lt;/em&gt; 문자가 앞에 올 수 있으며 생략하면 공백이 기본값으로 사용됩니다. &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#f-strings&quot;&gt;형식화 된 문자열 리터럴&lt;/a&gt; 에서 &lt;em&gt;채우기&lt;/em&gt; 문자로 또는 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 메서드 를 사용할 때 리터럴 중괄호 ( &quot; &lt;code&gt;{&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;}&lt;/code&gt; &quot;)를 사용할 수 없습니다 . 그러나 중첩 된 대체 필드와 함께 중괄호를 삽입 할 수 있습니다. 이 제한은 &lt;a href=&quot;functions#format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 함수에 영향을주지 않습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c00602bdfa725779b622a293e31f264d4ee274c" translate="yes" xml:space="preserve">
          <source>If a warning is reported and doesn&amp;rsquo;t match any registered filter then the &amp;ldquo;default&amp;rdquo; action is applied (hence its name).</source>
          <target state="translated">경고가보고되고 등록 된 필터와 일치하지 않으면 &quot;기본&quot;작업이 적용됩니다 (따라서 이름).</target>
        </trans-unit>
        <trans-unit id="cb0337d207d18ad7007727b229c1af4d0cd626a1" translate="yes" xml:space="preserve">
          <source>If a welcome message is not received, then &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt;&lt;code&gt;AuthenticationError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">환영 메시지가 수신되지 않으면 &lt;a href=&quot;#multiprocessing.AuthenticationError&quot;&gt; &lt;code&gt;AuthenticationError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8fcc1d5a91e23de43d9a5dc52b88297e33f33bba" translate="yes" xml:space="preserve">
          <source>If all awaitables are completed successfully, the result is an aggregate list of returned values. The order of result values corresponds to the order of awaitables in &lt;em&gt;aws&lt;/em&gt;.</source>
          <target state="translated">모든 대기 가능 항목이 성공적으로 완료되면 결과는 전체 반환 값 목록입니다. 결과 값의 순서는 &lt;em&gt;aws&lt;/em&gt; 의 대기 가능 순서와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="2547834e994630d32d2037a19c05c10c7d6ee975" translate="yes" xml:space="preserve">
          <source>If all of the input data was decompressed and returned (either because this was less than &lt;em&gt;max_length&lt;/em&gt; bytes, or because &lt;em&gt;max_length&lt;/em&gt; was negative), the &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">모든 입력 데이터가 압축 해제되어 리턴 된 경우 (이 값이 &lt;em&gt;max_length&lt;/em&gt; 바이트 미만 이거나 &lt;em&gt;max_length&lt;/em&gt; 가 음수 이기 때문에 ) &lt;a href=&quot;#bz2.BZ2Decompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e121cbdbd9c19e9656d52cccebd105f837012c9" translate="yes" xml:space="preserve">
          <source>If all of the input data was decompressed and returned (either because this was less than &lt;em&gt;max_length&lt;/em&gt; bytes, or because &lt;em&gt;max_length&lt;/em&gt; was negative), the &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt;&lt;code&gt;needs_input&lt;/code&gt;&lt;/a&gt; attribute will be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">모든 입력 데이터가 압축 해제되어 리턴 된 경우 (이 값이 &lt;em&gt;max_length&lt;/em&gt; 바이트 미만 이거나 &lt;em&gt;max_length&lt;/em&gt; 가 음수 이기 때문에 ) &lt;a href=&quot;#lzma.LZMADecompressor.needs_input&quot;&gt; &lt;code&gt;needs_input&lt;/code&gt; &lt;/a&gt; 속성은 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d829aa8e2300eed8aa97b16a76abdddadb851327" translate="yes" xml:space="preserve">
          <source>If all you want is a unique ID, you should probably call &lt;a href=&quot;#uuid.uuid1&quot;&gt;&lt;code&gt;uuid1()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uuid.uuid4&quot;&gt;&lt;code&gt;uuid4()&lt;/code&gt;&lt;/a&gt;. Note that &lt;a href=&quot;#uuid.uuid1&quot;&gt;&lt;code&gt;uuid1()&lt;/code&gt;&lt;/a&gt; may compromise privacy since it creates a UUID containing the computer&amp;rsquo;s network address. &lt;a href=&quot;#uuid.uuid4&quot;&gt;&lt;code&gt;uuid4()&lt;/code&gt;&lt;/a&gt; creates a random UUID.</source>
          <target state="translated">원하는 것이 고유 ID이면 &lt;a href=&quot;#uuid.uuid1&quot;&gt; &lt;code&gt;uuid1()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uuid.uuid4&quot;&gt; &lt;code&gt;uuid4()&lt;/code&gt; &lt;/a&gt; 호출해야합니다 . 참고 &lt;a href=&quot;#uuid.uuid1&quot;&gt; &lt;code&gt;uuid1()&lt;/code&gt; &lt;/a&gt; 는 컴퓨터의 네트워크 주소를 포함하는 UUID를 생성하기 때문에 개인 정보를 손상시킬 수 있습니다. &lt;a href=&quot;#uuid.uuid4&quot;&gt; &lt;code&gt;uuid4()&lt;/code&gt; &lt;/a&gt; 는 임의의 UUID를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a1f1d33458f6e961931c3b1a1e541c58fb116cf6" translate="yes" xml:space="preserve">
          <source>If an &lt;em&gt;action&lt;/em&gt; was provided to the constructor, one of the threads will have called it prior to being released. Should this call raise an error, the barrier is put into the broken state.</source>
          <target state="translated">생성자에 &lt;em&gt;조치&lt;/em&gt; 가 제공된 경우 스레드 중 하나가 해제되기 전에이를 호출했을 것입니다. 이 호출로 오류가 발생하면 장벽이 끊어진 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="299a160b2857a2e046717940313b837ea0255ecb" translate="yes" xml:space="preserve">
          <source>If an address of &amp;lsquo;0.0.0.0&amp;rsquo; is used, the address will not be a connectable end point on Windows. If you require a connectable end-point, you should use &amp;lsquo;127.0.0.1&amp;rsquo;.</source>
          <target state="translated">주소가 '0.0.0.0'인 경우 주소는 Windows에서 연결 가능한 엔드 포인트가 아닙니다. 연결 가능한 엔드 포인트가 필요한 경우 '127.0.0.1'을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="fafdef20b0392cfa5094409aaee99cd26f4d16c3" translate="yes" xml:space="preserve">
          <source>If an ancestor is found with a level other than NOTSET, then that ancestor&amp;rsquo;s level is treated as the effective level of the logger where the ancestor search began, and is used to determine how a logging event is handled.</source>
          <target state="translated">조상이 NOTSET 이외의 레벨로 발견되면 해당 조상의 레벨은 조상 검색이 시작된 로거의 유효 레벨로 처리되며 로깅 이벤트 처리 방법을 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="042dca6beb53678ea3404d9d765bfdcb1778c211" translate="yes" xml:space="preserve">
          <source>If an application archive has a shebang line, it may have the executable bit set on POSIX systems, to allow it to be executed directly.</source>
          <target state="translated">응용 프로그램 아카이브에 shebang 라인이있는 경우 POSIX 시스템에 실행 가능 비트가 설정되어이를 직접 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="256f4fa29f36d441db33ab5876bc2ec311be265f" translate="yes" xml:space="preserve">
          <source>If an application does not care about tracking significance, it is easy to remove the exponent and trailing zeroes, losing significance, but keeping the value unchanged:</source>
          <target state="translated">응용 프로그램이 유의성 추적을 신경 쓰지 않으면 지수와 후행 0을 쉽게 제거하고 유의성을 잃지 만 값은 변경하지 않고 유지합니다.</target>
        </trans-unit>
        <trans-unit id="adadff191e4f3cff9fafee17cbdf1b2c0fa260d7" translate="yes" xml:space="preserve">
          <source>If an argument outside those ranges is given, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">해당 범위 밖의 인수가 제공되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac5211f8f4fad0b439f05ba8bae6b1f51d4b9857" translate="yes" xml:space="preserve">
          <source>If an argument outside those ranges is given, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. All default to &lt;code&gt;0&lt;/code&gt; except &lt;em&gt;tzinfo&lt;/em&gt;, which defaults to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해당 범위 밖의 인수가 제공되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;tzinfo를&lt;/em&gt; 제외한 모든 기본값은 &lt;code&gt;0&lt;/code&gt; 이며 기본값은 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cf8ab7a4f610ae0e91814539a3ad269a9742c39" translate="yes" xml:space="preserve">
          <source>If an attempt is made to change any object in a way that is not permitted with regard to the &lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;Namespaces in XML&lt;/a&gt; recommendation, this exception is raised.</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/REC-xml-names/&quot;&gt;XML&lt;/a&gt; 권장 사항 의 네임 스페이스 와 관련하여 허용되지 않는 방식으로 오브젝트를 변경하려고 시도하면 이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="53d8a1b202b136b96256c5d5d6a53d98a6548fc9" translate="yes" xml:space="preserve">
          <source>If an error is encountered during configuration, this function will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; with a suitably descriptive message. The following is a (possibly incomplete) list of conditions which will raise an error:</source>
          <target state="translated">구성 중에 오류가 발생하면이 함수는 적절한 설명 메시지와 함께 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다. 다음은 오류가 발생할 수있는 조건 목록입니다 (아마도 불완전한 목록).</target>
        </trans-unit>
        <trans-unit id="4574f822c008c1deacbc94bbf73252f1957961ce" translate="yes" xml:space="preserve">
          <source>If an error is encountered when obtaining the contents of an uploaded file (for example, when the user interrupts the form submission by clicking on a Back or Cancel button) the &lt;code&gt;done&lt;/code&gt; attribute of the object for the field will be set to the value -1.</source>
          <target state="translated">업로드 된 파일의 내용을 가져올 때 오류가 발생하는 경우 (예 : 사용자가 뒤로 또는 취소 단추를 클릭하여 양식 제출을 중단 한 경우) 필드에 대한 오브젝트 의 &lt;code&gt;done&lt;/code&gt; 속성은 값 -1로 설정됩니다. .</target>
        </trans-unit>
        <trans-unit id="f60eea2b32259323dba912ba5d7f1dfbdfc71476" translate="yes" xml:space="preserve">
          <source>If an exception is raised by the call, then is re-raised by &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;. If some other exception is raised in the manager&amp;rsquo;s process then this is converted into a &lt;code&gt;RemoteError&lt;/code&gt; exception and is raised by &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출로 예외가 발생하면 &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 의해 다시 발생합니다 . 관리자 프로세스에서 다른 예외가 발생하면 &lt;code&gt;RemoteError&lt;/code&gt; 예외 로 변환되고 &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 의해 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="f85bdbc54de505eec7f8ff1f7bab9e90300754e6" translate="yes" xml:space="preserve">
          <source>If an exception is raised by the decorated method and a module was added to &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;, then the module will be removed to prevent a partially initialized module from being in left in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt;. If the module was already in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; then it is left alone.</source>
          <target state="translated">데코 레이팅 된 메소드에 의해 예외가 발생하고 모듈이 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에 추가 된 경우 , 부분적으로 초기화 된 모듈이 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; 에 남아 있지 않도록 모듈이 제거됩니다 . 모듈이 이미 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 있으면 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="a7bc6eb7f643b6c0eaaabf73ac57b62236f71065" translate="yes" xml:space="preserve">
          <source>If an exception is raised during a &lt;code&gt;setUpClass&lt;/code&gt; then the tests in the class are not run and the &lt;code&gt;tearDownClass&lt;/code&gt; is not run. Skipped classes will not have &lt;code&gt;setUpClass&lt;/code&gt; or &lt;code&gt;tearDownClass&lt;/code&gt; run. If the exception is a &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; exception then the class will be reported as having been skipped instead of as an error.</source>
          <target state="translated">&lt;code&gt;setUpClass&lt;/code&gt; 중에 예외가 발생 하면 클래스의 테스트 가 실행되지 않고 &lt;code&gt;tearDownClass&lt;/code&gt; 가 실행되지 않습니다. 건너 뛴 클래스에는 &lt;code&gt;setUpClass&lt;/code&gt; 또는 &lt;code&gt;tearDownClass&lt;/code&gt; 가 실행 되지 않습니다 . 예외가 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 예외 인 경우 클래스는 오류 대신 건너 뛴 것으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="4533ac88ecc0c7c6a8780ebbf4203e5ab1429294" translate="yes" xml:space="preserve">
          <source>If an exception is raised during execution of the exit handlers, a traceback is printed (unless &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; is raised) and the exception information is saved. After all exit handlers have had a chance to run the last exception to be raised is re-raised.</source>
          <target state="translated">예외가 종료 핸들러의 실행 중에 발생하는 경우, 역 추적은 (하지 않는 한 인쇄 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 없이이&lt;/a&gt; 발생) 및 예외 정보가 저장됩니다. 모든 엑시트 핸들러가 마지막 예외를 실행할 수있는 기회를 얻은 후 다시 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7d998d88a8ce16f7be9ebac1b439bf842f586529" translate="yes" xml:space="preserve">
          <source>If an exception is raised from the &lt;em&gt;sni_callback&lt;/em&gt; function the TLS connection will terminate with a fatal TLS alert message &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;sni_callback&lt;/em&gt; 함수 에서 예외가 발생 하면 치명적인 TLS 경고 메시지 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_HANDSHAKE_FAILURE&lt;/code&gt; &lt;/a&gt; 와 함께 TLS 연결이 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a43dea4c94d3c2af36ea8264f982c5356cb01f9" translate="yes" xml:space="preserve">
          <source>If an exception is raised in a &lt;code&gt;setUpModule&lt;/code&gt; then none of the tests in the module will be run and the &lt;code&gt;tearDownModule&lt;/code&gt; will not be run. If the exception is a &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; exception then the module will be reported as having been skipped instead of as an error.</source>
          <target state="translated">&lt;code&gt;setUpModule&lt;/code&gt; 에서 예외가 발생 하면 모듈의 테스트가 실행 되지 않으며 &lt;code&gt;tearDownModule&lt;/code&gt; 이 실행되지 않습니다. 예외가 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 예외 인 경우 모듈은 오류 대신 건너 뛴 것으로보고됩니다.</target>
        </trans-unit>
        <trans-unit id="dd703abca148b756a14a9c781a44d9f0b2ac0696" translate="yes" xml:space="preserve">
          <source>If an exception is raised in the coroutine, the returned Future will be notified. It can also be used to cancel the task in the event loop:</source>
          <target state="translated">코 루틴에서 예외가 발생하면 반환 된 미래에 통지됩니다. 또한 이벤트 루프에서 작업을 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69318769e5465805a618fdb34321a2c144def90e" translate="yes" xml:space="preserve">
          <source>If an implementation registered to &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-abstract-base-class&quot;&gt;abstract base class&lt;/a&gt;, virtual subclasses will be dispatched to that implementation:</source>
          <target state="translated">구현이 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스에&lt;/a&gt; 등록 된 경우 가상 하위 클래스가 해당 구현으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0153b7e6f09b5f4cdeeae21ebab69aa25ec08be0" translate="yes" xml:space="preserve">
          <source>If an implementation wishes to retain compatibility with the existing email package policies, &lt;em&gt;name&lt;/em&gt; should be the case preserved name (all characters up to the &amp;lsquo;&lt;code&gt;:&lt;/code&gt;&amp;rsquo; separator), while &lt;em&gt;value&lt;/em&gt; should be the unfolded value (all line separator characters removed, but whitespace kept intact), stripped of leading whitespace.</source>
          <target state="translated">구현시 기존 전자 메일 패키지 정책과의 호환성을 유지하려면 &lt;em&gt;name&lt;/em&gt; 은 대소 문자를 유지 한 이름 ( ' &lt;code&gt;:&lt;/code&gt; '구분 기호 까지의 모든 문자 ) 이어야 하고 &lt;em&gt;value&lt;/em&gt; 는 펼친 값이어야합니다 (모든 행 구분 기호 문자는 제거되지만 공백은 유지됨) 그대로), 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e6cd0b0b3afc2fba0e7fc3c8402c2b5436592af6" translate="yes" xml:space="preserve">
          <source>If an implementation wishes to retain compatibility with the existing email package policies, the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; should be strings or string subclasses that do not change the content of the passed in arguments.</source>
          <target state="translated">구현시 기존 이메일 패키지 정책과의 호환성을 유지하려면 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 은 전달 된 인수의 내용을 변경하지 않는 문자열 또는 문자열 서브 클래스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="473758267eec1e5950bafaa348a2308deafd8f71" translate="yes" xml:space="preserve">
          <source>If an iterable of key names is passed to the &lt;code&gt;only_keys&lt;/code&gt; parameter, only the specified keys will be removed from the cache. Keys passed to &lt;code&gt;only_keys&lt;/code&gt; but not found in the cache are ignored.</source>
          <target state="translated">반복 가능한 키 이름이 &lt;code&gt;only_keys&lt;/code&gt; 매개 변수에 전달 되면 지정된 키만 캐시에서 제거됩니다. &lt;code&gt;only_keys&lt;/code&gt; 에 전달 되었지만 캐시에없는 키 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cbad0f63bdd9fa84f8130dbeeb23dc3b6cbb508" translate="yes" xml:space="preserve">
          <source>If an object containing an unsupported type was marshalled with &lt;a href=&quot;#marshal.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#marshal.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; will substitute &lt;code&gt;None&lt;/code&gt; for the unmarshallable type.</source>
          <target state="translated">지원되지 않는 유형을 포함하는 객체가 &lt;a href=&quot;#marshal.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 로 마샬링 된 경우 &lt;a href=&quot;#marshal.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 는 정렬 할 수없는 유형을 &lt;code&gt;None&lt;/code&gt; 으로 대체 합니다.</target>
        </trans-unit>
        <trans-unit id="4d67c470c08505e21fcfb4046a1dfce4ba755fea" translate="yes" xml:space="preserve">
          <source>If any Task or Future from the &lt;em&gt;aws&lt;/em&gt; sequence is &lt;em&gt;cancelled&lt;/em&gt;, it is treated as if it raised &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; &amp;ndash; the &lt;code&gt;gather()&lt;/code&gt; call is &lt;strong&gt;not&lt;/strong&gt; cancelled in this case. This is to prevent the cancellation of one submitted Task/Future to cause other Tasks/Futures to be cancelled.</source>
          <target state="translated">로부터 어떤 작업 또는 미래의 경우 &lt;em&gt;AWS의&lt;/em&gt; 순서가되어 &lt;em&gt;취소&lt;/em&gt; 가 제기처럼 처리된다 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; 을&lt;/a&gt; - &lt;code&gt;gather()&lt;/code&gt; 호출되어 &lt;strong&gt;있지&lt;/strong&gt; ,이 경우 취소했다. 이는 제출 된 하나의 작업 / 미래가 취소되어 다른 작업 / 미래가 취소되지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="05fdb3a1d8014df423fd4d720c0c1096b43f8291" translate="yes" xml:space="preserve">
          <source>If any argument is a float and there are fractional microseconds, the fractional microseconds left over from all arguments are combined and their sum is rounded to the nearest microsecond using round-half-to-even tiebreaker. If no argument is a float, the conversion and normalization processes are exact (no information is lost).</source>
          <target state="translated">어떤 인수가 부동 소수점이고 소수 마이크로 초가있는 경우 모든 인수에서 남은 소수 마이크로 초가 합산되고 그 반은 반에서 11까지의 타이 브레이커를 사용하여 가장 가까운 마이크로 초로 반올림됩니다. 부동 소수점이없는 경우 변환 및 정규화 프로세스가 정확합니다 (정보 손실 없음).</target>
        </trans-unit>
        <trans-unit id="9d56491638c3d7ac65a56ae607e299d4de0401c5" translate="yes" xml:space="preserve">
          <source>If any awaitable in &lt;em&gt;aws&lt;/em&gt; is a coroutine, it is automatically scheduled as a Task.</source>
          <target state="translated">&lt;em&gt;aws&lt;/em&gt; 에서 대기 가능한 항목이 코 루틴 인 경우 작업으로 자동 예약됩니다.</target>
        </trans-unit>
        <trans-unit id="81778e138b261a1b662e58bf1322d9bab8e64c16" translate="yes" xml:space="preserve">
          <source>If any cycle is detected, &lt;a href=&quot;#graphlib.CycleError&quot;&gt;&lt;code&gt;CycleError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">사이클이 감지되면 &lt;a href=&quot;#graphlib.CycleError&quot;&gt; &lt;code&gt;CycleError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c5aebf3c75452198e6c5d279e23fde1e5f1cf025" translate="yes" xml:space="preserve">
          <source>If any members of the iterable are exceptions they will be raised instead of returned:</source>
          <target state="translated">iterable의 멤버가 예외 인 경우 반환되는 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="27863231d65cea126a57b6d24dbf17c8f2a32c4a" translate="yes" xml:space="preserve">
          <source>If any of &lt;em&gt;suffix&lt;/em&gt;, &lt;em&gt;prefix&lt;/em&gt;, and &lt;em&gt;dir&lt;/em&gt; are not &lt;code&gt;None&lt;/code&gt;, they must be the same type. If they are bytes, the returned name will be bytes instead of str. If you want to force a bytes return value with otherwise default behavior, pass &lt;code&gt;suffix=b''&lt;/code&gt;.</source>
          <target state="translated">어떤 경우 &lt;em&gt;접미사&lt;/em&gt; , &lt;em&gt;접두사&lt;/em&gt; 및 &lt;em&gt;디렉토리가&lt;/em&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; , 그들은 같은 유형이어야합니다. 이들이 바이트 인 경우 반환되는 이름은 str 대신 바이트입니다. 기본 동작이 아닌 바이트 반환 값을 강제로 적용하려면 &lt;code&gt;suffix=b''&lt;/code&gt; 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="907ec62b4e5199551950ce42a0c4c3bcd986262a" translate="yes" xml:space="preserve">
          <source>If any option is given, the script will exit with one of these values: &lt;code&gt;0&lt;/code&gt; if the user site-packages directory is enabled, &lt;code&gt;1&lt;/code&gt; if it was disabled by the user, &lt;code&gt;2&lt;/code&gt; if it is disabled for security reasons or by an administrator, and a value greater than 2 if there is an error.</source>
          <target state="translated">옵션이 제공되면 스크립트는 다음 값 중 하나로 종료됩니다. &lt;code&gt;0&lt;/code&gt; 사용자 사이트 패키지 디렉토리가 활성화 된 경우 , &lt;code&gt;1&lt;/code&gt; 사용자가 비활성화 한 경우 , &lt;code&gt;2&lt;/code&gt; 보안상의 이유로 또는 관리자가 비활성화 한 경우, 오류가있는 경우 2보다 큰 값</target>
        </trans-unit>
        <trans-unit id="24d1e1e82f1f2ee9e1949816fed45d7ac33121d6" translate="yes" xml:space="preserve">
          <source>If any precondition isn&amp;rsquo;t met (e.g. not TLS 1.3, PHA not enabled), an &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">사전 조건이 충족되지 않으면 (예 : TLS 1.3이 아닌 PHA가 활성화되지 않은 경우) &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="37276ee5d3e42e8336da18222c175ce80e212073" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; is given, &lt;em&gt;object&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; (e.g. &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;). In this case, if &lt;em&gt;object&lt;/em&gt; is a &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) object, then &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; is equivalent to &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt;&lt;/a&gt;. Otherwise, the bytes object underlying the buffer object is obtained before calling &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#binaryseq&quot;&gt;Binary Sequence Types &amp;mdash; bytes, bytearray, memoryview&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt; for information on buffer objects.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 중 적어도 하나 가 제공되면 &lt;em&gt;object&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 오브젝트&lt;/a&gt; (예 : &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 여야합니다 . 이 경우 &lt;em&gt;object&lt;/em&gt; 가 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 객체 인 경우 &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; 는 &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt; &lt;/a&gt; . 그렇지 않은 경우, &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 버퍼 객체의 기본이되는 bytes 객체가 취득 됩니다. 버퍼 객체에 대한 내용 은 &lt;a href=&quot;#binaryseq&quot;&gt;이진 시퀀스 유형-바이트, 바이트 배열, 메모리 뷰&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="03bda2a56d81b4318fc811314de9ec490f7f7bc7" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; is given, &lt;em&gt;object&lt;/em&gt; should be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; (e.g. &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;). In this case, if &lt;em&gt;object&lt;/em&gt; is a &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;) object, then &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; is equivalent to &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt;&lt;/a&gt;. Otherwise, the bytes object underlying the buffer object is obtained before calling &lt;a href=&quot;#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;#binaryseq&quot;&gt;Binary Sequence Types &amp;mdash; bytes, bytearray, memoryview&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt; for information on buffer objects.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 중 하나 이상 이 제공되면 &lt;em&gt;객체&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; (예 : &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 여야합니다 . 이 경우 &lt;em&gt;object&lt;/em&gt; 가 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 객체이면 &lt;code&gt;str(bytes, encoding, errors)&lt;/code&gt; 는 &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode(encoding, errors)&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 그렇지 않으면, &lt;a href=&quot;#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 버퍼 객체의 기본이되는 bytes 객체를 얻습니다 . 참조 &lt;a href=&quot;#binaryseq&quot;&gt;바이트 된 ByteArray, memoryview - 바이너리 시퀀스 유형&lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜&lt;/a&gt; 버퍼 오브젝트에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="a08ad24a4b377d2b7fc4af8b136e23de7adba584" translate="yes" xml:space="preserve">
          <source>If authentication is requested but no authentication key is specified then the return value of &lt;code&gt;current_process().authkey&lt;/code&gt; is used (see &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt;). This value will be automatically inherited by any &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; object that the current process creates. This means that (by default) all processes of a multi-process program will share a single authentication key which can be used when setting up connections between themselves.</source>
          <target state="translated">인증이 요청되었지만 인증 키가 지정되지 않은 경우 &lt;code&gt;current_process().authkey&lt;/code&gt; 의 반환 값 이 사용됩니다 ( &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 참조 ). 이 값은 현재 프로세스가 생성 한 모든 &lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 객체에 의해 자동으로 상속됩니다 . 즉, 기본적으로 다중 프로세스 프로그램의 모든 프로세스는 단일 인증 키를 공유하며이 키는 서로간에 연결을 설정할 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e20a8216bd741a08c72ea1c6ed3561d4c0175953" translate="yes" xml:space="preserve">
          <source>If backslashes immediately precede a double quotation mark, every pair of backslashes is interpreted as a literal backslash. If the number of backslashes is odd, the last backslash escapes the next double quotation mark as described in rule 3.</source>
          <target state="translated">백 슬래시가 큰 따옴표 앞에 즉시 있으면 모든 백 슬래시 쌍은 리터럴 백 슬래시로 해석됩니다. 백 슬래시 수가 홀수이면 규칙 3에 설명 된대로 마지막 백 슬래시는 다음 큰 따옴표를 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="c7810826d744dce10312fc8b927b0de025784f99" translate="yes" xml:space="preserve">
          <source>If both &lt;em&gt;cancel_futures&lt;/em&gt; and &lt;em&gt;wait&lt;/em&gt; are &lt;code&gt;True&lt;/code&gt;, all futures that the executor has started running will be completed prior to this method returning. The remaining futures are cancelled.</source>
          <target state="translated">두 경우 &lt;em&gt;cancel_futures&lt;/em&gt; 과 &lt;em&gt;대기가&lt;/em&gt; 있는 &lt;code&gt;True&lt;/code&gt; , 집행 인 실행이 시작되었음을 모든 선물은 반환이 방법 이전에 완료됩니다. 나머지 선물은 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="c7232d0f35717aeee89b7f01e116b1ce15ef033a" translate="yes" xml:space="preserve">
          <source>If both are aware and have different &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, &lt;code&gt;a-b&lt;/code&gt; acts as if &lt;em&gt;a&lt;/em&gt; and &lt;em&gt;b&lt;/em&gt; were first converted to naive UTC datetimes first. The result is &lt;code&gt;(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None)
- b.utcoffset())&lt;/code&gt; except that the implementation never overflows.</source>
          <target state="translated">둘 다 인식하고 다른 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 , &lt;code&gt;a-b&lt;/code&gt; 는 &lt;em&gt;a&lt;/em&gt; 와 &lt;em&gt;b&lt;/em&gt; 가 처음으로 순진한 UTC 날짜 시간으로 먼저 변환 된 것처럼 작동 &lt;em&gt;합니다&lt;/em&gt; . 결과는 &lt;code&gt;(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())&lt;/code&gt; 이며 구현이 오버플로되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="21414aeb047eb522c66140299d9c38360d32d811" translate="yes" xml:space="preserve">
          <source>If both are naive, or both are aware and have the same &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes are ignored, and the result is a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object &lt;em&gt;t&lt;/em&gt; such that &lt;code&gt;datetime2 + t == datetime1&lt;/code&gt;. No time zone adjustments are done in this case.</source>
          <target state="translated">모두 순진, 또는 두 가지 모두가 인식하고 같은 경우 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; 의&lt;/a&gt; 1, 속성을 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성이 무시되고 결과가있다 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 객체 &lt;em&gt;t&lt;/em&gt; 그러한 &lt;code&gt;datetime2 + t == datetime1&lt;/code&gt; . 이 경우 시간대 조정이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a6f9d2935f72f29d54f2f1f7b010c9d2226c8c57" translate="yes" xml:space="preserve">
          <source>If both callbacks signal EOF then &lt;em&gt;spawn&lt;/em&gt; will probably never return, unless &lt;em&gt;select&lt;/em&gt; throws an error on your platform when passed three empty lists. This is a bug, documented in &lt;a href=&quot;https://bugs.python.org/issue26228&quot;&gt;issue 26228&lt;/a&gt;.</source>
          <target state="translated">두 콜백 모두 EOF 신호를 보내면 빈 목록이 세 개 전달 될 때 &lt;em&gt;select&lt;/em&gt; 에서 플랫폼에 오류가 발생 하지 않는 한 &lt;em&gt;스폰&lt;/em&gt; 은 절대 반환되지 않습니다 . 이것은 &lt;a href=&quot;https://bugs.python.org/issue26228&quot;&gt;이슈 26228에&lt;/a&gt; 설명 된 버그 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b4e1f0c2a028fb50a27b3609c4d3827918db65a" translate="yes" xml:space="preserve">
          <source>If both comparands are aware, and have the same &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the common &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute is ignored and the base datetimes are compared. If both comparands are aware and have different &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, the comparands are first adjusted by subtracting their UTC offsets (obtained from &lt;code&gt;self.utcoffset()&lt;/code&gt;).</source>
          <target state="translated">두 비교자가 모두 인식하고 동일한 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 공통 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성은 무시되고 기본 날짜 시간이 비교됩니다. 두 비교자가 모두 인식하고 다른 &lt;a href=&quot;#datetime.datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 비교는 먼저 UTC 오프셋을 &lt;code&gt;self.utcoffset()&lt;/code&gt; 에서 획득 함 ) 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="d641321a92c1f78e2ea9102fa10acde0aa020cab" translate="yes" xml:space="preserve">
          <source>If both comparands are aware, and have the same &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute, the common &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attribute is ignored and the base times are compared. If both comparands are aware and have different &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; attributes, the comparands are first adjusted by subtracting their UTC offsets (obtained from &lt;code&gt;self.utcoffset()&lt;/code&gt;). In order to stop mixed-type comparisons from falling back to the default comparison by object address, when a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object is compared to an object of a different type, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised unless the comparison is &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;. The latter cases return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, respectively.</source>
          <target state="translated">두 비교자가 모두 인식하고 동일한 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 공통 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성은 무시되고 기본 시간이 비교됩니다. 두 비교자가 모두 인식하고 다른 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 속성을 갖는 경우 비교는 먼저 UTC 오프셋을 &lt;code&gt;self.utcoffset()&lt;/code&gt; 에서 획득 함 ) 조정됩니다. 혼합 유형 비교가 객체 주소 별 기본 비교로 돌아 가지 않도록 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체를 다른 유형의 객체와 비교할 때 비교가 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 가 아니면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . 후자의 경우 각각 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="640348c16c27f575031545c2822c834b44553bb0" translate="yes" xml:space="preserve">
          <source>If both options are given, user base and user site will be printed (always in this order), separated by &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 옵션이 모두 제공되면 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로&lt;/a&gt; 구분되어 사용자 기반과 사용자 사이트가 항상 순서대로 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="5636d444bb3185b61c96a8708aabc4aa7259b873" translate="yes" xml:space="preserve">
          <source>If both the &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt;&lt;code&gt;dispatch_table&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; are defined, then &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt;&lt;code&gt;reducer_override()&lt;/code&gt;&lt;/a&gt; method takes priority.</source>
          <target state="translated">양쪽 경우 &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt; &lt;code&gt;dispatch_table&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 정의되고, 다음 &lt;a href=&quot;#pickle.Pickler.reducer_override&quot;&gt; &lt;code&gt;reducer_override()&lt;/code&gt; &lt;/a&gt; 메소드가 우선한다.</target>
        </trans-unit>
        <trans-unit id="0084a482d9be8fc3608c4a7c65006f2f65fc3c35" translate="yes" xml:space="preserve">
          <source>If called for &lt;em&gt;text&lt;/em&gt; that doesn&amp;rsquo;t include a period character (&lt;code&gt;'.'&lt;/code&gt;), it will complete from names currently defined in &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; and keywords (as defined by the &lt;a href=&quot;keyword#module-keyword&quot;&gt;&lt;code&gt;keyword&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">마침표 문자 ( &lt;code&gt;'.'&lt;/code&gt; )를 포함하지 않는 &lt;em&gt;텍스트&lt;/em&gt; 를 호출하면 현재 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; 에&lt;/a&gt; 정의 된 이름 , &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 및 키워드 ( &lt;a href=&quot;keyword#module-keyword&quot;&gt; &lt;code&gt;keyword&lt;/code&gt; &lt;/a&gt; 모듈에 의해 정의 됨 )에서 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="9c41c5f7a69443087f2a6c12e1c09cf638abbcdd" translate="yes" xml:space="preserve">
          <source>If called for a dotted name, it will try to evaluate anything without obvious side-effects (functions will not be evaluated, but it can generate calls to &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;) up to the last part, and find matches for the rest via the &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; function. Any exception raised during the evaluation of the expression is caught, silenced and &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">점으로 구분 된 이름을 요구하는 경우는 명백한 부작용없이 어떤 평가하려고합니다 (기능 평가되지 않습니다,하지만 그것은 호출을 생성 할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; )를 마지막 부분에, 그리고를 통해 나머지 일치를 찾을 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 기능. 식을 평가하는 동안 발생한 예외는 포착되고, 침묵되며, &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="171e72faae12dc9ef9de58a438c5f686dc15f91c" translate="yes" xml:space="preserve">
          <source>If called for a dotted name, it will try to evaluate anything without obvious side-effects (functions will not be evaluated, but it can generate calls to &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;) up to the last part, and find matches for the rest via the &lt;a href=&quot;functions#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; function. Any exception raised during the evaluation of the expression is caught, silenced and &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">점으로 구분 된 이름을 요청하면 명백한 부작용없이 모든 것을 평가하려고 시도합니다 (함수는 평가되지 않지만 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 호출을 생성 할 수 있음 ) 마지막 부분까지 &lt;a href=&quot;functions#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 통해 나머지에 대한 일치를 찾습니다. () 기능. 식을 평가하는 동안 발생한 모든 예외가 포착되고 침묵되며 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="071a888c3aee29315903d24cf15d5cd34fe41222" translate="yes" xml:space="preserve">
          <source>If called multiple times with the same node argument, the set of dependencies will be the union of all dependencies passed in.</source>
          <target state="translated">동일한 노드 인수를 사용하여 여러 번 호출하면 종속성 집합이 전달 된 모든 종속성의 합집합이됩니다.</target>
        </trans-unit>
        <trans-unit id="1db8ca82fb7c38924ab71e87dc3d3f1a74a4cf1e" translate="yes" xml:space="preserve">
          <source>If called without arguments (or with &lt;code&gt;tz=None&lt;/code&gt;) the system local timezone is assumed for the target timezone. The &lt;code&gt;.tzinfo&lt;/code&gt; attribute of the converted datetime instance will be set to an instance of &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; with the zone name and offset obtained from the OS.</source>
          <target state="translated">인수없이 (또는 &lt;code&gt;tz=None&lt;/code&gt; 으로 ) 호출 하면 대상 시간대에 대해 시스템 로컬 시간대가 사용됩니다. 변환 된 datetime 인스턴스 의 &lt;code&gt;.tzinfo&lt;/code&gt; 속성은 OS에서 가져온 영역 이름 및 오프셋을 가진 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 인스턴스로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed2cd04e51ea2f7f1214c3f95faf0caa16f6b695" translate="yes" xml:space="preserve">
          <source>If calling &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; raises an exception this exception is propagated unchanged.</source>
          <target state="translated">&lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; 를&lt;/a&gt; 호출 하면 예외가 발생하면이 예외는 변경되지 않고 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="52f86dd4dc687753a2bf5577502ab4b99d7efacd" translate="yes" xml:space="preserve">
          <source>If completion is enabled, completing commands will be done automatically, and completing of commands args is done by calling &lt;code&gt;complete_foo()&lt;/code&gt; with arguments &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;line&lt;/em&gt;, &lt;em&gt;begidx&lt;/em&gt;, and &lt;em&gt;endidx&lt;/em&gt;. &lt;em&gt;text&lt;/em&gt; is the string prefix we are attempting to match: all returned matches must begin with it. &lt;em&gt;line&lt;/em&gt; is the current input line with leading whitespace removed, &lt;em&gt;begidx&lt;/em&gt; and &lt;em&gt;endidx&lt;/em&gt; are the beginning and ending indexes of the prefix text, which could be used to provide different completion depending upon which position the argument is in.</source>
          <target state="translated">완료가 사용 가능한 경우 명령 완료가 자동으로 수행되며 인수 &lt;em&gt;text&lt;/em&gt; , &lt;em&gt;line&lt;/em&gt; , &lt;em&gt;begidx&lt;/em&gt; 및 &lt;em&gt;endidx&lt;/em&gt; 와 함께 &lt;code&gt;complete_foo()&lt;/code&gt; 를 호출하여 명령 완료가 완료됩니다 . &lt;em&gt;text&lt;/em&gt; 는 일치시키려는 문자열 접두사입니다. 반환 된 모든 일치 항목은 시작해야합니다. &lt;em&gt;line&lt;/em&gt; 은 선행 공백이 제거 된 현재 입력 라인이고 &lt;em&gt;begidx&lt;/em&gt; 및 &lt;em&gt;endidx&lt;/em&gt; 는 접두사 텍스트의 시작 및 끝 인덱스이며 인수의 위치에 따라 다른 완성을 제공하는 데 사용될 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0fec01fc70889d001a5e5d5e76ebae2d730e863d" translate="yes" xml:space="preserve">
          <source>If cookie has the named cookie-attribute, return its value. Otherwise, return &lt;em&gt;default&lt;/em&gt;.</source>
          <target state="translated">cookie에 이름이 cookie-attribute 인 경우 해당 값을 리턴하십시오. 그렇지 않으면 &lt;em&gt;default를&lt;/em&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="67343970e1a1e7fd355a02bf76406a533d9720d9" translate="yes" xml:space="preserve">
          <source>If defined, &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;persistent_load()&lt;/code&gt;&lt;/a&gt; should return the object specified by the persistent ID &lt;em&gt;pid&lt;/em&gt;. If an invalid persistent ID is encountered, an &lt;a href=&quot;#pickle.UnpicklingError&quot;&gt;&lt;code&gt;UnpicklingError&lt;/code&gt;&lt;/a&gt; should be raised.</source>
          <target state="translated">정의 된 경우 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;persistent_load()&lt;/code&gt; &lt;/a&gt; 는 지속적 ID &lt;em&gt;pid로&lt;/em&gt; 지정된 오브젝트를 리턴해야합니다 . 유효하지 않은 영구 ID가 발견되면 &lt;a href=&quot;#pickle.UnpicklingError&quot;&gt; &lt;code&gt;UnpicklingError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6474a9f723b4362b908bfb9818eb48e3ccd80f58" translate="yes" xml:space="preserve">
          <source>If discovery is started in a directory containing a package, either from the command line or by calling &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt;&lt;code&gt;TestLoader.discover()&lt;/code&gt;&lt;/a&gt;, then the package &lt;code&gt;__init__.py&lt;/code&gt; will be checked for &lt;code&gt;load_tests&lt;/code&gt;. If that function does not exist, discovery will recurse into the package as though it were just another directory. Otherwise, discovery of the package&amp;rsquo;s tests will be left up to &lt;code&gt;load_tests&lt;/code&gt; which is called with the following arguments:</source>
          <target state="translated">발견은 명령 줄에서 또는 전화로하거나, 패키지를 포함하는 디렉토리에 시작되는 경우 &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt; &lt;code&gt;TestLoader.discover()&lt;/code&gt; &lt;/a&gt; , 다음 패키지 &lt;code&gt;__init__.py&lt;/code&gt; 가 검사됩니다 &lt;code&gt;load_tests&lt;/code&gt; . 해당 기능이 존재하지 않으면 검색은 마치 다른 디렉토리 인 것처럼 패키지로 재귀됩니다. 그렇지 않으면 패키지 테스트의 발견은 다음 인수로 호출되는 &lt;code&gt;load_tests&lt;/code&gt; 로 남습니다 .</target>
        </trans-unit>
        <trans-unit id="f3d282be498a158600c18b4f9266fe30d1c639ff" translate="yes" xml:space="preserve">
          <source>If echo free input is unavailable getpass() falls back to printing a warning message to &lt;em&gt;stream&lt;/em&gt; and reading from &lt;code&gt;sys.stdin&lt;/code&gt; and issuing a &lt;a href=&quot;#getpass.GetPassWarning&quot;&gt;&lt;code&gt;GetPassWarning&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반향없는 입력을 사용할 수없는 경우 getpass ()는 &lt;code&gt;sys.stdin&lt;/code&gt; 에서 &lt;em&gt;스트림&lt;/em&gt; 및 읽기 위한 경고 메시지 인쇄 및 &lt;a href=&quot;#getpass.GetPassWarning&quot;&gt; &lt;code&gt;GetPassWarning&lt;/code&gt; &lt;/a&gt; 발행으로 대체 됩니다.</target>
        </trans-unit>
        <trans-unit id="f9040a07fe9c1bf05ab58e880006a37bf7aba0a3" translate="yes" xml:space="preserve">
          <source>If either &lt;a href=&quot;exceptions#BrokenPipeError&quot;&gt;&lt;code&gt;BrokenPipeError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#ConnectionResetError&quot;&gt;&lt;code&gt;ConnectionResetError&lt;/code&gt;&lt;/a&gt; exception is raised when writing &lt;em&gt;input&lt;/em&gt; into &lt;em&gt;stdin&lt;/em&gt;, the exception is ignored. This condition occurs when the process exits before all data are written into &lt;em&gt;stdin&lt;/em&gt;.</source>
          <target state="translated">어느 경우 &lt;a href=&quot;exceptions#BrokenPipeError&quot;&gt; &lt;code&gt;BrokenPipeError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#ConnectionResetError&quot;&gt; &lt;code&gt;ConnectionResetError&lt;/code&gt; &lt;/a&gt; 기록 할 때 예외가 발생 &lt;em&gt;입력&lt;/em&gt; 에 &lt;em&gt;표준 입력을&lt;/em&gt; , 예외는 무시됩니다. 이 조건은 모든 데이터가 &lt;em&gt;stdin에&lt;/em&gt; 기록되기 전에 프로세스가 종료 될 때 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="be4f44baf0b306a7dfcbf05bf212b256e0623d5a" translate="yes" xml:space="preserve">
          <source>If either format string is not supported by the &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module, then the objects will always compare as unequal (even if the format strings and buffer contents are identical):</source>
          <target state="translated">&lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 모듈에서 형식 문자열을 지원하지 않으면 형식 문자열과 버퍼 내용이 동일한 경우에도 객체가 항상 동일하지 않은 것으로 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="2b8cf100d8fc5cb58fc7dd2777bc293a42ecb2c2" translate="yes" xml:space="preserve">
          <source>If end of file is found and no bytes were read, raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;. Otherwise, when nothing matches, return &lt;code&gt;(-1, None, data)&lt;/code&gt; where &lt;em&gt;data&lt;/em&gt; is the bytes received so far (may be empty bytes if a timeout happened).</source>
          <target state="translated">파일 끝이 발견되고 바이트가 읽히지 않으면 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 를 발생 시키십시오&lt;/a&gt; . 그렇지 않으면 때 아무것도 일치, 반환 &lt;code&gt;(-1, None, data)&lt;/code&gt; &lt;em&gt;데이터&lt;/em&gt; (시간 초과가 발생하는 경우 빈 바이트 수 있음) 지금까지받은 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="2e0604802c9b1772457ef4937546641bbade8d20" translate="yes" xml:space="preserve">
          <source>If exception(s) occur, an &lt;a href=&quot;#shutil.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised with a list of reasons.</source>
          <target state="translated">예외 가 발생하면 이유 목록과 함께 &lt;a href=&quot;#shutil.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="71e75d563ccaca9a7a7e9ebdc073bdb50eae3f53" translate="yes" xml:space="preserve">
          <source>If fullname contains a &amp;lsquo;.&amp;rsquo;, the finders will be for the package containing fullname, otherwise they will be all registered top level finders (i.e. those on both sys.meta_path and sys.path_hooks).</source>
          <target state="translated">fullname에 '.'이 포함되어 있으면 파인더는 fullname을 포함하는 패키지에 대한 것이며, 그렇지 않으면 모든 등록 된 최상위 레벨 파인더입니다 (예 : sys.meta_path 및 sys.path_hooks에있는 것).</target>
        </trans-unit>
        <trans-unit id="01110f1d67d6e9a5355fb7676557e4a50b926762" translate="yes" xml:space="preserve">
          <source>If given a list or string, the initializer is passed to the new array&amp;rsquo;s &lt;a href=&quot;#array.array.fromlist&quot;&gt;&lt;code&gt;fromlist()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#array.array.frombytes&quot;&gt;&lt;code&gt;frombytes()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#array.array.fromunicode&quot;&gt;&lt;code&gt;fromunicode()&lt;/code&gt;&lt;/a&gt; method (see below) to add initial items to the array. Otherwise, the iterable initializer is passed to the &lt;a href=&quot;#array.array.extend&quot;&gt;&lt;code&gt;extend()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">목록이나 문자열이 제공되면 초기화 프로그램은 새 배열의 &lt;a href=&quot;#array.array.fromlist&quot;&gt; &lt;code&gt;fromlist()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#array.array.frombytes&quot;&gt; &lt;code&gt;frombytes()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#array.array.fromunicode&quot;&gt; &lt;code&gt;fromunicode()&lt;/code&gt; &lt;/a&gt; 메소드 (아래 참조)로 전달되어 배열에 초기 항목을 추가합니다. 그렇지 않으면, 반복 가능한 이니셜 라이저가 &lt;a href=&quot;#array.array.extend&quot;&gt; &lt;code&gt;extend()&lt;/code&gt; &lt;/a&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2af680c07fb1f88b58852d1a71d38f2be07b2607" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;compress_type&lt;/em&gt; overrides the value given for the &lt;em&gt;compression&lt;/em&gt; parameter to the constructor for the new entry, or in the &lt;em&gt;zinfo_or_arcname&lt;/em&gt; (if that is a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance). Similarly, &lt;em&gt;compresslevel&lt;/em&gt; will override the constructor if given.</source>
          <target state="translated">주어진 경우, &lt;em&gt;compress_type&lt;/em&gt; 은 &lt;em&gt;압축&lt;/em&gt; 매개 변수에 제공된 값을 새 항목의 생성자 또는 &lt;em&gt;zinfo_or_arcname&lt;/em&gt; ( &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 인 경우) 으로 대체 합니다. 마찬가지로, &lt;em&gt;압축&lt;/em&gt; 레벨은 주어진 경우 생성자를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="609f14a5d88e9d16549cb48055d0b9bddf3d600e" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;default&lt;/em&gt; will be returned if the object does not provide means to retrieve the size. Otherwise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">주어진 경우, 객체가 크기를 검색하는 수단을 제공하지 않으면 &lt;em&gt;기본값&lt;/em&gt; 이 반환됩니다. 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9f38935e27047cadfc0462ecbb2dd5665952c0eb" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;doc&lt;/em&gt; will be the docstring of the property attribute. Otherwise, the property will copy &lt;em&gt;fget&lt;/em&gt;&amp;rsquo;s docstring (if it exists). This makes it possible to create read-only properties easily using &lt;a href=&quot;#property&quot;&gt;&lt;code&gt;property()&lt;/code&gt;&lt;/a&gt; as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt;:</source>
          <target state="translated">주어진 경우, &lt;em&gt;doc&lt;/em&gt; 은 속성 속성의 docstring이됩니다. 그렇지 않으면이 속성은 &lt;em&gt;fget&lt;/em&gt; 의 docstring (있는 경우)을 복사 합니다. &lt;a href=&quot;#property&quot;&gt; &lt;code&gt;property()&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 로 사용하여 읽기 전용 속성을 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="057ea557c800c9d2cad77504cc427d0666f2d7db" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;doc&lt;/em&gt; will be the docstring of the property attribute. Otherwise, the property will copy &lt;em&gt;fget&lt;/em&gt;&amp;rsquo;s docstring (if it exists). This makes it possible to create read-only properties easily using &lt;a href=&quot;#property&quot;&gt;&lt;code&gt;property()&lt;/code&gt;&lt;/a&gt; as a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt;:</source>
          <target state="translated">주어진 경우 &lt;em&gt;doc&lt;/em&gt; 는 속성 속성의 독 스트링이됩니다. 그렇지 않으면 속성은 &lt;em&gt;fget&lt;/em&gt; 의 &lt;em&gt;독 스트링&lt;/em&gt; (존재하는 경우) 을 복사 합니다. 이렇게하면 &lt;a href=&quot;#property&quot;&gt; &lt;code&gt;property()&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-decorator&quot;&gt;데코레이터&lt;/a&gt; 로 사용하여 읽기 전용 속성을 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47874343de9186efbf845a71e131f69e43d9eafd" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;extra_args&lt;/em&gt; is a sequence of &lt;code&gt;(name, value)&lt;/code&gt; pairs that will be used as extra keywords arguments when the archiver callable is used.</source>
          <target state="translated">지정된 경우 &lt;em&gt;extra_args&lt;/em&gt; 는 아카이버 호출 가능을 사용할 때 추가 키워드 인수로 사용되는 일련의 &lt;code&gt;(name, value)&lt;/code&gt; 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="fa087efbf7689c1c4adc26135d774f6bca7fd2e9" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;level&lt;/em&gt; should be either a numeric logging level or its string equivalent (for example either &lt;code&gt;&quot;ERROR&quot;&lt;/code&gt; or &lt;code&gt;logging.ERROR&lt;/code&gt;). The default is &lt;code&gt;logging.INFO&lt;/code&gt;.</source>
          <target state="translated">주어진 경우, &lt;em&gt;level&lt;/em&gt; 은 숫자 로깅 레벨이거나 이에 상응하는 문자열이어야합니다 (예 : &lt;code&gt;&quot;ERROR&quot;&lt;/code&gt; 또는 &lt;code&gt;logging.ERROR&lt;/code&gt; ). 기본값은 &lt;code&gt;logging.INFO&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00080200be66b5d6036d730a780ead8b97d4a8db" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;logger&lt;/em&gt; should be a &lt;a href=&quot;logging#logging.Logger&quot;&gt;&lt;code&gt;logging.Logger&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; giving the name of a logger. The default is the root logger, which will catch all messages that were not blocked by a non-propagating descendent logger.</source>
          <target state="translated">주어진 경우 &lt;em&gt;logger&lt;/em&gt; 는 &lt;a href=&quot;logging#logging.Logger&quot;&gt; &lt;code&gt;logging.Logger&lt;/code&gt; &lt;/a&gt; 객체이거나 로거의 이름을 제공 하는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 이어야합니다 . 기본값은 루트 로거이며 전파되지 않는 하위 로거에 의해 차단되지 않은 모든 메시지를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="6742a72866173acc4c64ea3543dda8799bca224e" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;logger&lt;/em&gt; should be a &lt;a href=&quot;logging#logging.Logger&quot;&gt;&lt;code&gt;logging.Logger&lt;/code&gt;&lt;/a&gt; object or a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; giving the name of a logger. The default is the root logger, which will catch all messages.</source>
          <target state="translated">주어진 &lt;em&gt;로거&lt;/em&gt; 는 &lt;a href=&quot;logging#logging.Logger&quot;&gt; &lt;code&gt;logging.Logger&lt;/code&gt; &lt;/a&gt; 객체 또는 로거의 이름을 지정 하는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 이어야합니다 . 기본값은 루트 로거이며 모든 메시지를 포착합니다.</target>
        </trans-unit>
        <trans-unit id="5d1743db3a55e3d1d851253caed66fb63e4ec4ba" translate="yes" xml:space="preserve">
          <source>If given, &lt;em&gt;startupinfo&lt;/em&gt; will be a &lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt;&lt;code&gt;STARTUPINFO&lt;/code&gt;&lt;/a&gt; object, which is passed to the underlying &lt;code&gt;CreateProcess&lt;/code&gt; function. &lt;em&gt;creationflags&lt;/em&gt;, if given, can be one or more of the following flags:</source>
          <target state="translated">주어진 경우 &lt;em&gt;startupinfo&lt;/em&gt; 는 &lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt; &lt;code&gt;STARTUPINFO&lt;/code&gt; &lt;/a&gt; 객체가되며 기본 &lt;code&gt;CreateProcess&lt;/code&gt; 함수에 전달됩니다 . &lt;em&gt;creationflags&lt;/em&gt; 는 지정된 경우 다음 플래그 중 하나 이상일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44cb0cd8c45e437d22c4b42cdbed99611a31b48c" translate="yes" xml:space="preserve">
          <source>If greater than zero, specifies how much space, in character widths, to allocate for the text label, if less than zero, specifies a minimum width. If zero or unspecified, the natural width of the text label is used.</source>
          <target state="translated">0보다 큰 경우 문자 너비로 텍스트 레이블에 할당 할 공간을 지정합니다 (0보다 작은 경우). 최소 너비를 지정합니다. 0으로 지정하거나 지정하지 않으면 텍스트 레이블의 자연 너비가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="718d9d10f66de628c1bab6c410a233a3ac12213c" translate="yes" xml:space="preserve">
          <source>If importing a module fails, for example due to a syntax error, then this will be recorded as a single error and discovery will continue. If the import failure is due to &lt;a href=&quot;#unittest.SkipTest&quot;&gt;&lt;code&gt;SkipTest&lt;/code&gt;&lt;/a&gt; being raised, it will be recorded as a skip instead of an error.</source>
          <target state="translated">예를 들어 구문 오류로 인해 모듈 가져 오기에 실패하면 단일 오류로 기록되고 검색이 계속됩니다. 가져 오기 실패로 인해 &lt;a href=&quot;#unittest.SkipTest&quot;&gt; &lt;code&gt;SkipTest&lt;/code&gt; &lt;/a&gt; 가 발생하면 오류 대신 건너 뛰기로 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="79f23909838ce6528a57771817116435f2739054" translate="yes" xml:space="preserve">
          <source>If input is a number greater than 10 or smaller than 0.5, speed is set to 0. Speedstrings are mapped to speedvalues as follows:</source>
          <target state="translated">입력 값이 10보다 크거나 0.5보다 작은 경우 속도는 0으로 설정됩니다. 스피드 스트링은 다음과 같이 속도 값에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="5989f9c468e2d22d579475f78ddf414d62121f7d" translate="yes" xml:space="preserve">
          <source>If invalid arguments are passed in, it will issue an error:</source>
          <target state="translated">잘못된 인수가 전달되면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="93a952190c9333e02d422078312ba6dfe53a93fe" translate="yes" xml:space="preserve">
          <source>If invoked without arguments, clear all cookies. If given a single argument, only cookies belonging to that &lt;em&gt;domain&lt;/em&gt; will be removed. If given two arguments, cookies belonging to the specified &lt;em&gt;domain&lt;/em&gt; and URL &lt;em&gt;path&lt;/em&gt; are removed. If given three arguments, then the cookie with the specified &lt;em&gt;domain&lt;/em&gt;, &lt;em&gt;path&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; is removed.</source>
          <target state="translated">인수없이 호출 된 경우 모든 쿠키를 지우십시오. 단일 인수가 제공되면 해당 &lt;em&gt;도메인에&lt;/em&gt; 속한 쿠키 만 제거됩니다. 두 개의 인수가 제공되면 지정된 &lt;em&gt;도메인&lt;/em&gt; 및 URL &lt;em&gt;경로에&lt;/em&gt; 속하는 쿠키 가 제거됩니다. 세 개의 인수가 제공되면 지정된 &lt;em&gt;도메인&lt;/em&gt; , &lt;em&gt;경로&lt;/em&gt; 및 &lt;em&gt;이름을&lt;/em&gt; 가진 쿠키 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="00314545be4a33bc05a395af1ac6499955ea39c3" translate="yes" xml:space="preserve">
          <source>If it falls back to the boilerplate, there are no more possible methods to try, so this is where the default implementation should live.</source>
          <target state="translated">상용구로 넘어 가면 더 이상 시도 할 수있는 방법이 없으므로 기본 구현이 적용되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="967a860c70a7b59392bb2e73d01133edf0c97f92" translate="yes" xml:space="preserve">
          <source>If it is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, unescaped non-ASCII characters in &lt;em&gt;string&lt;/em&gt; are encoded into UTF-8 bytes.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 인 경우 &lt;em&gt;문자열&lt;/em&gt; 에서 이스케이프되지 않은 비 ASCII 문자는 UTF-8 바이트로 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="cb04b7e71c45bcf4eca27bc7c2fbd2f0873fc977" translate="yes" xml:space="preserve">
          <source>If it is a &lt;em&gt;string&lt;/em&gt;, you must also give the &lt;em&gt;encoding&lt;/em&gt; (and optionally, &lt;em&gt;errors&lt;/em&gt;) parameters; &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray()&lt;/code&gt;&lt;/a&gt; then converts the string to bytes using &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그것은 경우 &lt;em&gt;문자열이&lt;/em&gt; , 당신은 또한 제공해야합니다 &lt;em&gt;인코딩&lt;/em&gt; (및 선택적 &lt;em&gt;오류&lt;/em&gt; ) 매개 변수; 그런 다음 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 사용하여 문자열을 바이트로 변환합니다 .</target>
        </trans-unit>
        <trans-unit id="2e5fd905d7cb634eab36e5f7022d541dd08678a8" translate="yes" xml:space="preserve">
          <source>If it is an &lt;em&gt;integer&lt;/em&gt;, the array will have that size and will be initialized with null bytes.</source>
          <target state="translated">그것이이면 &lt;em&gt;정수&lt;/em&gt; 어레이는 그 크기를 가질 것이며, 널 바이트로 초기화한다.</target>
        </trans-unit>
        <trans-unit id="ddd8748ceb366423912a917b053d73ddd49a2edd" translate="yes" xml:space="preserve">
          <source>If it is an &lt;em&gt;iterable&lt;/em&gt;, it must be an iterable of integers in the range &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt;, which are used as the initial contents of the array.</source>
          <target state="translated">그것이 있다면 &lt;em&gt;반복 가능을&lt;/em&gt; , 상기 범위 내에서 정수의 반복 가능한이어야 &lt;code&gt;0 &amp;lt;= x &amp;lt; 256&lt;/code&gt; 어레이의 초기 내용으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="2af15e7e8ced9c0a8f7a9019fcb44881f1e7e0b3" translate="yes" xml:space="preserve">
          <source>If it is an object conforming to the &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt;, a read-only buffer of the object will be used to initialize the bytes array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 인터페이스를&lt;/a&gt; 준수하는 객체 인 경우 객체 의 읽기 전용 버퍼가 바이트 배열을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b3634a5c7e10c7f8808e49a74bf8a6b4e7fd50a4" translate="yes" xml:space="preserve">
          <source>If it is an object conforming to the &lt;em&gt;buffer&lt;/em&gt; interface, a read-only buffer of the object will be used to initialize the bytes array.</source>
          <target state="translated">&lt;em&gt;버퍼&lt;/em&gt; 인터페이스를 준수하는 객체 인 경우 객체 의 읽기 전용 버퍼를 사용하여 바이트 배열을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9cdca5ec79b73d99eb39c2ec4e51e31cb8a1c732" translate="yes" xml:space="preserve">
          <source>If it is an open file object, the archive will be written to that file object, which must be open for writing in bytes mode.</source>
          <target state="translated">열린 파일 객체 인 경우 해당 파일 객체에 아카이브가 기록되며 바이트 모드로 쓰기 위해 열려야합니다.</target>
        </trans-unit>
        <trans-unit id="44706e24cce0d97822e15cc2cdd3d9f22b0e7993" translate="yes" xml:space="preserve">
          <source>If it is called without arguments, it will print the contents of &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; on the standard output, followed by the value of &lt;a href=&quot;#site.USER_BASE&quot;&gt;&lt;code&gt;USER_BASE&lt;/code&gt;&lt;/a&gt; and whether the directory exists, then the same thing for &lt;a href=&quot;#site.USER_SITE&quot;&gt;&lt;code&gt;USER_SITE&lt;/code&gt;&lt;/a&gt;, and finally the value of &lt;a href=&quot;#site.ENABLE_USER_SITE&quot;&gt;&lt;code&gt;ENABLE_USER_SITE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 인자가없이 호출되면, 그것의 내용을 인쇄합니다 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에을&lt;/a&gt; 의 값에 의해 다음, 표준 출력에 &lt;a href=&quot;#site.USER_BASE&quot;&gt; &lt;code&gt;USER_BASE&lt;/code&gt; &lt;/a&gt; 및 디렉토리가 존재하는지, 다음에 같은 일 &lt;a href=&quot;#site.USER_SITE&quot;&gt; &lt;code&gt;USER_SITE&lt;/code&gt; &lt;/a&gt; , 그리고 마지막으로 값 &lt;a href=&quot;#site.ENABLE_USER_SITE&quot;&gt; &lt;code&gt;ENABLE_USER_SITE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e4f1f075612bafa0ec058bfc6d0d37706417e13" translate="yes" xml:space="preserve">
          <source>If it is desired to completely ignore cancellation (not recommended) the &lt;code&gt;shield()&lt;/code&gt; function should be combined with a try/except clause, as follows:</source>
          <target state="translated">취소 (권장하지 않음)를 완전히 무시하려면 &lt;code&gt;shield()&lt;/code&gt; 함수를 다음과 같이 try / except 절과 결합해야합니다.</target>
        </trans-unit>
        <trans-unit id="01192a9f95f76e2eb7be7dea65299a6baa4bc2ab" translate="yes" xml:space="preserve">
          <source>If it is desired to send data to the process&amp;rsquo; &lt;em&gt;stdin&lt;/em&gt;, the process needs to be created with &lt;code&gt;stdin=PIPE&lt;/code&gt;. Similarly, to get anything other than &lt;code&gt;None&lt;/code&gt; in the result tuple, the process has to be created with &lt;code&gt;stdout=PIPE&lt;/code&gt; and/or &lt;code&gt;stderr=PIPE&lt;/code&gt; arguments.</source>
          <target state="translated">프로세스의 &lt;em&gt;stdin으로&lt;/em&gt; 데이터를 보내려면 &lt;code&gt;stdin=PIPE&lt;/code&gt; 로 프로세스를 작성해야합니다 . 마찬가지로 결과 튜플에서 &lt;code&gt;None&lt;/code&gt; 이외의 값을 얻으려면 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 / 또는 &lt;code&gt;stderr=PIPE&lt;/code&gt; 인수를 사용 하여 프로세스를 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="36e5b58797559e7d7360ba24eec2865eada11f86" translate="yes" xml:space="preserve">
          <source>If it is false, the buffer&amp;rsquo;s mutability is ignored and behaviour is as for a read-only buffer, except that the 1024 byte limit mentioned above is avoided &amp;ndash; so long as the buffer you pass is at least as long as what the operating system wants to put there, things should work.</source>
          <target state="translated">False 인 경우 버퍼의 변경 가능성은 무시되고 동작은 읽기 전용 버퍼와 동일합니다. 단, 위에서 언급 한 1024 바이트 제한을 피해야합니다. 전달하는 버퍼가 운영 체제에서 원하는만큼 거기에 넣으려면 일이 잘되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f61ccb0d5046c26bcd78e1f1f830264ae4214727" translate="yes" xml:space="preserve">
          <source>If it is temporary or not.</source>
          <target state="translated">일시적인지 아닌지.</target>
        </trans-unit>
        <trans-unit id="04ea50b1d44dcb9e42bb0e15073254ec5d646ca9" translate="yes" xml:space="preserve">
          <source>If it is the name of a file, or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, the archive will be written to that file.</source>
          <target state="translated">파일 이름이거나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체&lt;/a&gt; 인 경우 아카이브가 해당 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="7bd6548196bed46b55e5764fa2387dba5c9f7a2e" translate="yes" xml:space="preserve">
          <source>If it is the name of a file, or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;, the archive will be written to that file.</source>
          <target state="translated">파일의 이름이거나 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 객체&lt;/a&gt; 인 경우 아카이브가 해당 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="b445164335a5373b51d2219b8df35ac044c9a899" translate="yes" xml:space="preserve">
          <source>If it must be ignored the next N times.</source>
          <target state="translated">다음 N 번 무시해야하는 경우</target>
        </trans-unit>
        <trans-unit id="9df4a0ab1dcaed9052df14308a45b7732b61c521" translate="yes" xml:space="preserve">
          <source>If it was set via line number, it checks if &lt;code&gt;b.line&lt;/code&gt; is the same as the one in the frame also passed as argument. If the breakpoint was set via function name, we have to check we are in the right frame (the right function) and if we are in its first executable line.</source>
          <target state="translated">행 번호를 통해 설정된 경우 &lt;code&gt;b.line&lt;/code&gt; 이 인수로 전달 된 프레임의 b.line 과 동일한 지 확인합니다 . 함수 이름을 통해 중단 점이 설정 되었다면, 오른쪽 프레임 (오른쪽 기능)에 있는지 그리고 첫 번째 실행 가능한 행에 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="d92fb59232d64b94f33278f3d1f5a387b837f8fe" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, the keyword arguments and their values are added to the dictionary created from the positional argument. If a key being added is already present, the value from the keyword argument replaces the value from the positional argument.</source>
          <target state="translated">키워드 인수가 제공되면 키워드 인수 및 해당 값이 위치 인수에서 작성된 사전에 추가됩니다. 추가되는 키가 이미 존재하면 키워드 인수의 값이 위치 인수의 값을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="298d4ffd5a1a153665fe65937860d394e9ce55c5" translate="yes" xml:space="preserve">
          <source>If line is blank, delete it, otherwise clear to end of line.</source>
          <target state="translated">줄이 비어 있으면 삭제하고 그렇지 않으면 줄 끝을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="e5b5e5077dcfb2543cd16c5eaa3971bdfe538b2b" translate="yes" xml:space="preserve">
          <source>If modifying your production classes to add defaults isn&amp;rsquo;t to your liking then there are more options. One of these is simply to use an instance as the spec rather than the class. The other is to create a subclass of the production class and add the defaults to the subclass without affecting the production class. Both of these require you to use an alternative object as the spec. Thankfully &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; supports this - you can simply pass the alternative object as the &lt;em&gt;autospec&lt;/em&gt; argument:</source>
          <target state="translated">프로덕션 클래스를 수정하여 기본값을 추가하는 것이 마음에 들지 않으면 더 많은 옵션이 있습니다. 이 중 하나는 단순히 클래스가 아닌 스펙으로 인스턴스를 사용하는 것입니다. 다른 하나는 프로덕션 클래스의 서브 클래스를 작성하고 프로덕션 클래스에 영향을주지 않고 기본값을 서브 클래스에 추가하는 것입니다. 이 두 가지 모두 스펙으로 대체 오브젝트를 사용해야합니다. 고맙게도 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 이것을 지원합니다. &lt;em&gt;autospec&lt;/em&gt; 인수 로 대체 객체를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17ae7629605c78f2ad74ec604b851cab4b9b9b18" translate="yes" xml:space="preserve">
          <source>If multiple directive comments are used for a single example, then they are combined:</source>
          <target state="translated">단일 지시문에 여러 지시문 주석이 사용 된 경우 다음과 같이 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="7453bc4e224cf54a5aeef5110e30a59fe07fd075" translate="yes" xml:space="preserve">
          <source>If multiple files are found, later files are used as fallbacks for earlier ones. To allow setting the fallback, &lt;a href=&quot;copy#copy.copy&quot;&gt;&lt;code&gt;copy.copy()&lt;/code&gt;&lt;/a&gt; is used to clone each translation object from the cache; the actual instance data is still shared with the cache.</source>
          <target state="translated">여러 파일이 발견되면 이후 파일은 이전 파일에 대한 폴백으로 사용됩니다. 폴백을 설정하기 위해 &lt;a href=&quot;copy#copy.copy&quot;&gt; &lt;code&gt;copy.copy()&lt;/code&gt; &lt;/a&gt; 를 사용하여 캐시에서 각 변환 객체를 복제합니다. 실제 인스턴스 데이터는 여전히 캐시와 공유됩니다.</target>
        </trans-unit>
        <trans-unit id="8452349a938b29d0b36774ae51c5edbf888f2236" translate="yes" xml:space="preserve">
          <source>If multiple items are maximal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as &lt;code&gt;sorted(iterable, key=keyfunc, reverse=True)[0]&lt;/code&gt; and &lt;code&gt;heapq.nlargest(1, iterable, key=keyfunc)&lt;/code&gt;.</source>
          <target state="translated">여러 항목이 최대 인 경우이 함수는 처음 발생한 항목을 반환합니다. 이는 &lt;code&gt;sorted(iterable, key=keyfunc, reverse=True)[0]&lt;/code&gt; 및 &lt;code&gt;heapq.nlargest(1, iterable, key=keyfunc)&lt;/code&gt; 와 같은 다른 정렬 안정성 보존 도구와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="c3c9e3d0380e3afc1d3245499ca493b8cdbe62b9" translate="yes" xml:space="preserve">
          <source>If multiple items are minimal, the function returns the first one encountered. This is consistent with other sort-stability preserving tools such as &lt;code&gt;sorted(iterable, key=keyfunc)[0]&lt;/code&gt; and &lt;code&gt;heapq.nsmallest(1,
iterable, key=keyfunc)&lt;/code&gt;.</source>
          <target state="translated">여러 항목이 최소 인 경우이 함수는 처음 발생한 항목을 반환합니다. 이는 &lt;code&gt;sorted(iterable, key=keyfunc)[0]&lt;/code&gt; 및 &lt;code&gt;heapq.nsmallest(1, iterable, key=keyfunc)&lt;/code&gt; 와 같은 다른 정렬 안정성 보존 도구와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="f562be4d3070268fdf6e36d18ca74512853d9784" translate="yes" xml:space="preserve">
          <source>If multiple processes are enqueuing objects, it is possible for the objects to be received at the other end out-of-order. However, objects enqueued by the same process will always be in the expected order with respect to each other.</source>
          <target state="translated">여러 프로세스가 개체를 큐에 넣는 경우 다른 쪽 끝에서 순서가 잘못된 개체를받을 수 있습니다. 그러나 동일한 프로세스에 의해 대기열에 포함 된 객체는 항상 서로에 대해 예상되는 순서로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b636cc065ec6ef42100c3456eb6185694bc5d4f7" translate="yes" xml:space="preserve">
          <source>If name is not given, this examines the available implementations to find one with the required feature set. If no implementation can be found, raise an &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt;. The features list must be a sequence of &lt;code&gt;(feature,
version)&lt;/code&gt; pairs which are passed to the &lt;code&gt;hasFeature()&lt;/code&gt; method on available &lt;code&gt;DOMImplementation&lt;/code&gt; objects.</source>
          <target state="translated">이름을 지정하지 않으면 사용 가능한 구현을 검사하여 필요한 기능 세트가있는 구현을 찾습니다. 구현을 찾을 수 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 기능 목록은 사용 가능한 &lt;code&gt;DOMImplementation&lt;/code&gt; 오브젝트 에서 &lt;code&gt;hasFeature()&lt;/code&gt; 메소드 로 전달되는 일련의 &lt;code&gt;(feature, version)&lt;/code&gt; 쌍 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="26b2ddfd53b925d6fed2be41cbcc44c6bb590446" translate="yes" xml:space="preserve">
          <source>If neither &lt;em&gt;encoding&lt;/em&gt; nor &lt;em&gt;errors&lt;/em&gt; is given, &lt;code&gt;str(object)&lt;/code&gt; returns &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;object.__str__()&lt;/code&gt;&lt;/a&gt;, which is the &amp;ldquo;informal&amp;rdquo; or nicely printable string representation of &lt;em&gt;object&lt;/em&gt;. For string objects, this is the string itself. If &lt;em&gt;object&lt;/em&gt; does not have a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; method, then &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; falls back to returning &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr(object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어느 경우 &lt;em&gt;인코딩&lt;/em&gt; 이나 &lt;em&gt;오류가&lt;/em&gt; 주어진다, &lt;code&gt;str(object)&lt;/code&gt; 반환 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;object.__str__()&lt;/code&gt; &lt;/a&gt; 의 &quot;비공식&quot;또는 잘 인쇄 문자열 표현, &lt;em&gt;개체를&lt;/em&gt; . 문자열 객체의 경우 문자열 자체입니다. 경우 &lt;em&gt;개체가&lt;/em&gt; 이없는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 다음 메서드를 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 복귀로 다시 떨어질 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr(object)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3eaa6c4bd2b94ab28cee529eb78a1fa8fef6b4" translate="yes" xml:space="preserve">
          <source>If neither &lt;em&gt;encoding&lt;/em&gt; nor &lt;em&gt;errors&lt;/em&gt; is given, &lt;code&gt;str(object)&lt;/code&gt; returns &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;object.__str__()&lt;/code&gt;&lt;/a&gt;, which is the &amp;ldquo;informal&amp;rdquo; or nicely printable string representation of &lt;em&gt;object&lt;/em&gt;. For string objects, this is the string itself. If &lt;em&gt;object&lt;/em&gt; does not have a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; method, then &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; falls back to returning &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr(object)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 도 &lt;em&gt;오류&lt;/em&gt; 도 주어 지지 않으면 &lt;code&gt;str(object)&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;object.__str__()&lt;/code&gt; &lt;/a&gt; 반환 합니다 . 이는 &quot;비공식적&quot;이거나 &lt;em&gt;object의&lt;/em&gt; 멋지게 인쇄 가능한 문자열 표현입니다 . 문자열 객체의 경우 이것은 문자열 자체입니다. 경우 &lt;em&gt;개체가&lt;/em&gt; 이없는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 다음 메서드를 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 복귀로 다시 떨어질 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr(object)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="54d4d7ea65c7bad4af575a43659f61752244563a" translate="yes" xml:space="preserve">
          <source>If neither &lt;em&gt;weights&lt;/em&gt; nor &lt;em&gt;cum_weights&lt;/em&gt; are specified, selections are made with equal probability. If a weights sequence is supplied, it must be the same length as the &lt;em&gt;population&lt;/em&gt; sequence. It is a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; to specify both &lt;em&gt;weights&lt;/em&gt; and &lt;em&gt;cum_weights&lt;/em&gt;.</source>
          <target state="translated">어느 경우 &lt;em&gt;무게&lt;/em&gt; 도 &lt;em&gt;cum_weights가&lt;/em&gt; 지정, 선택은 동일한 확률로 만들어집니다. 무게 시퀀스가 공급되는 경우, 같은 길이이어야 &lt;em&gt;인구&lt;/em&gt; 순서. &lt;em&gt;weights&lt;/em&gt; 와 &lt;em&gt;cum_weights를&lt;/em&gt; 모두 지정 하는 것은 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="23e71f0816a9280c7a878c8d86eb0dc6fc13142c" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;.mo&lt;/code&gt; file is found, this function raises &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;fallback&lt;/em&gt; is false (which is the default), and returns a &lt;a href=&quot;#gettext.NullTranslations&quot;&gt;&lt;code&gt;NullTranslations&lt;/code&gt;&lt;/a&gt; instance if &lt;em&gt;fallback&lt;/em&gt; is true.</source>
          <target state="translated">&lt;code&gt;.mo&lt;/code&gt; 파일이 없으면 이 함수 는 &lt;a href=&quot;#gettext.NullTranslations&quot;&gt; &lt;code&gt;NullTranslations&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 백이&lt;/em&gt; false 인 경우 (기본값) &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 발생 시키고 폴&lt;em&gt; 백이&lt;/em&gt; true 인 경우 NullTranslations 인스턴스를 반환 합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b5fa475a3d6271ad07e3d7908a4b54063aef9110" translate="yes" xml:space="preserve">
          <source>If no &lt;em&gt;Content-Length&lt;/em&gt; header was supplied, urlretrieve can not check the size of the data it has downloaded, and just returns it. In this case you just have to assume that the download was successful.</source>
          <target state="translated">어떤 경우 &lt;em&gt;콘텐츠 길이&lt;/em&gt; 헤더가 제공되지 않았던, urlretrieve는 다운로드 한 데이터의 크기를 확인하고 그 값을 돌려줍니다 수 없습니다. 이 경우 다운로드가 성공했다고 가정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="b66b107ef18a6ec29206237c3b1968db398d135d" translate="yes" xml:space="preserve">
          <source>If no argument is given, &lt;code&gt;0.0&lt;/code&gt; is returned.</source>
          <target state="translated">인수가 제공되지 않으면 &lt;code&gt;0.0&lt;/code&gt; 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="46157783a038d57f5604740e6a9b616a64d86cd0" translate="yes" xml:space="preserve">
          <source>If no arguments are given, return current (canvaswidth, canvasheight). Else resize the canvas the turtles are drawing on. Do not alter the drawing window. To observe hidden parts of the canvas, use the scrollbars. With this method, one can make visible those parts of a drawing which were outside the canvas before.</source>
          <target state="translated">인수가 제공되지 않으면 current (canvaswidth, canvasheight)를 반환합니다. 그렇지 않으면 거북이가 그리는 캔버스의 크기를 조정하십시오. 도면 창을 변경하지 마십시오. 캔버스의 숨겨진 부분을 보려면 스크롤 막대를 사용하십시오. 이 방법을 사용하면 이전에 캔버스 외부에 있던 도면 부분을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e52dc62f51669f668a33bf460b7f8bf82543a15" translate="yes" xml:space="preserve">
          <source>If no arguments are specified, it defaults to:</source>
          <target state="translated">인수가 지정되지 않은 경우 기본값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c7d031f77de40c273fcdef1ad3809784776686" translate="yes" xml:space="preserve">
          <source>If no blocks match, this returns &lt;code&gt;(alo, blo, 0)&lt;/code&gt;.</source>
          <target state="translated">일치하는 블록이 없으면 &lt;code&gt;(alo, blo, 0)&lt;/code&gt; 이 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="fce8e5571f9d4e61cf90e90a33029b4a46f9fdae" translate="yes" xml:space="preserve">
          <source>If no encoding is specified, then the default of &lt;code&gt;'utf-8'&lt;/code&gt; will be returned.</source>
          <target state="translated">인코딩을 지정하지 않으면 기본값 &lt;code&gt;'utf-8'&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d0b220a8961aa756600716c9da500833111cb46e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the result will be: &lt;code&gt;abs(a-b) &amp;lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)&lt;/code&gt;.</source>
          <target state="translated">오류가 발생하지 않으면 결과는 &lt;code&gt;abs(a-b) &amp;lt;= max(rel_tol * max(abs(a), abs(b)), abs_tol)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ad242d3e56bb64a3f42863144cd33fbe0e3221f2" translate="yes" xml:space="preserve">
          <source>If no exception is being handled anywhere on the stack, a tuple containing three &lt;code&gt;None&lt;/code&gt; values is returned. Otherwise, the values returned are &lt;code&gt;(type, value, traceback)&lt;/code&gt;. Their meaning is: &lt;em&gt;type&lt;/em&gt; gets the type of the exception being handled (a subclass of &lt;a href=&quot;exceptions#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;); &lt;em&gt;value&lt;/em&gt; gets the exception instance (an instance of the exception type); &lt;em&gt;traceback&lt;/em&gt; gets a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#traceback-objects&quot;&gt;traceback object&lt;/a&gt; which encapsulates the call stack at the point where the exception originally occurred.</source>
          <target state="translated">스택의 어느 곳에서도 예외가 처리되지 않으면 3 개의 &lt;code&gt;None&lt;/code&gt; 값을 포함하는 튜플 이 반환됩니다. 그렇지 않으면 리턴 된 값은 &lt;code&gt;(type, value, traceback)&lt;/code&gt; 입니다. 의미는 다음과 같습니다. &lt;em&gt;type&lt;/em&gt; 은 처리중인 예외 유형 ( &lt;a href=&quot;exceptions#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 의 서브 클래스)을 가져옵니다 . &lt;em&gt;value&lt;/em&gt; 는 예외 인스턴스 (예외 유형의 인스턴스)를 가져옵니다. &lt;em&gt;traceback&lt;/em&gt; 은 예외가 원래 발생한 지점에서 호출 스택을 캡슐화 하는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#traceback-objects&quot;&gt;traceback 객체&lt;/a&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="88436f65e40ce29110257b5101c9f174bd5fe58f" translate="yes" xml:space="preserve">
          <source>If no exception is being handled anywhere on the stack, a tuple containing three &lt;code&gt;None&lt;/code&gt; values is returned. Otherwise, the values returned are &lt;code&gt;(type, value, traceback)&lt;/code&gt;. Their meaning is: &lt;em&gt;type&lt;/em&gt; gets the type of the exception being handled (a subclass of &lt;a href=&quot;exceptions#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;); &lt;em&gt;value&lt;/em&gt; gets the exception instance (an instance of the exception type); &lt;em&gt;traceback&lt;/em&gt; gets a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#traceback-objects&quot;&gt;traceback object&lt;/a&gt; which encapsulates the call stack at the point where the exception originally occurred.</source>
          <target state="translated">스택의 어느 곳에서도 예외가 처리되지 않으면 3 개의 &lt;code&gt;None&lt;/code&gt; 값을 포함하는 튜플 이 반환됩니다. 그렇지 않으면 반환되는 값은 &lt;code&gt;(type, value, traceback)&lt;/code&gt; 입니다. 그 의미는 다음과 같습니다. &lt;em&gt;type&lt;/em&gt; 은 처리되는 예외의 유형을 가져옵니다 ( &lt;a href=&quot;exceptions#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 ). &lt;em&gt;value&lt;/em&gt; 는 예외 인스턴스 (예외 유형의 인스턴스)를 가져옵니다. &lt;em&gt;traceback&lt;/em&gt; 은 예외가 원래 발생한 지점에서 호출 스택을 캡슐화 하는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#traceback-objects&quot;&gt;traceback 객체&lt;/a&gt; 를 가져 옵니다.</target>
        </trans-unit>
        <trans-unit id="34d9b732c3afcc7950723fecbb0bb73802acc5f0" translate="yes" xml:space="preserve">
          <source>If no file matching &lt;code&gt;key&lt;/code&gt; is found, the constructor will raise &lt;a href=&quot;#zoneinfo.ZoneInfoNotFoundError&quot;&gt;&lt;code&gt;ZoneInfoNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일과 일치하는 &lt;code&gt;key&lt;/code&gt; 가 없으면 생성자는 &lt;a href=&quot;#zoneinfo.ZoneInfoNotFoundError&quot;&gt; &lt;code&gt;ZoneInfoNotFoundError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="a41e77f992af07e40b87a473294e5a8dd6509be1" translate="yes" xml:space="preserve">
          <source>If no free slot is immediately available, raise &lt;a href=&quot;#asyncio.QueueFull&quot;&gt;&lt;code&gt;QueueFull&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용 가능한 슬롯이 즉시 &lt;a href=&quot;#asyncio.QueueFull&quot;&gt; &lt;code&gt;QueueFull&lt;/code&gt; &lt;/a&gt; 올리 십시오 .</target>
        </trans-unit>
        <trans-unit id="a4ced0a7f5ac900ff7845bee14185b70154aab39" translate="yes" xml:space="preserve">
          <source>If no module name is specified, all top level finders are produced.</source>
          <target state="translated">모듈 이름을 지정하지 않으면 모든 최상위 파인더가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="24caaa893d53e123c1924dd2370cf821d291d32b" translate="yes" xml:space="preserve">
          <source>If no name has been explicitly assigned to the Task, the default asyncio Task implementation generates a default name during instantiation.</source>
          <target state="translated">작업에 이름이 명시 적으로 지정되지 않은 경우 기본 asyncio 작업 구현은 인스턴스화 중에 기본 이름을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="476aa611f101edc0bc9619df18f523a41ebd1c82" translate="yes" xml:space="preserve">
          <source>If no options are given, a dict with options/values for the item is returned. If &lt;em&gt;option&lt;/em&gt; is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values as given by &lt;em&gt;kw&lt;/em&gt;.</source>
          <target state="translated">옵션이 제공되지 않으면 항목에 대한 옵션 / 값이 포함 된 dict가 반환됩니다. &lt;em&gt;option&lt;/em&gt; 이 지정 되면 해당 옵션의 값이 반환됩니다. 그렇지 않은 경우 옵션을 &lt;em&gt;kw&lt;/em&gt; 로 지정된 해당 값으로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="bea50889454379e91f30a2f42fee654aa7de3fcf" translate="yes" xml:space="preserve">
          <source>If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.</source>
          <target state="translated">위치 인수가 제공되지 않으면 빈 사전이 작성됩니다. 위치 인수가 제공되고 맵핑 오브젝트 인 경우 맵핑 오브젝트와 동일한 키-값 쌍으로 사전이 작성됩니다. 그렇지 않으면 위치 인수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 객체 여야 합니다. iterable의 각 항목 자체는 정확히 두 개의 오브젝트가있는 iterable이어야합니다. 각 항목의 첫 번째 개체는 새 사전에서 키가되고 두 ​​번째 개체는 해당 값이됩니다. 키가 두 번 이상 나타나면 해당 키의 마지막 값이 새 사전의 해당 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="6cb6e711d11502051b84da987dc6857a45dcdf68" translate="yes" xml:space="preserve">
          <source>If no positional argument is given, an empty dictionary is created. If a positional argument is given and it is a mapping object, a dictionary is created with the same key-value pairs as the mapping object. Otherwise, the positional argument must be an &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; object. Each item in the iterable must itself be an iterable with exactly two objects. The first object of each item becomes a key in the new dictionary, and the second object the corresponding value. If a key occurs more than once, the last value for that key becomes the corresponding value in the new dictionary.</source>
          <target state="translated">위치 인수가 제공되지 않으면 빈 사전이 생성됩니다. 위치 인수가 제공되고 매핑 개체 인 경우 매핑 개체와 동일한 키-값 쌍을 사용하여 사전이 만들어집니다. 그렇지 않으면 위치 인수는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 객체 여야 합니다. 이터 러블의 각 항목은 정확히 두 개의 객체가있는 이터 러블이어야합니다. 각 항목의 첫 번째 개체는 새 사전의 키가되고 두 ​​번째 개체는 해당 값이됩니다. 키가 두 번 이상 발생하면 해당 키의 마지막 값이 새 사전의 해당 값이됩니다.</target>
        </trans-unit>
        <trans-unit id="a3c12853377a0fdf751ae91320dcc270d07f4698" translate="yes" xml:space="preserve">
          <source>If no signature is defined for the method, a non-array value is returned. In Python this means that the type of the returned value will be something other than list.</source>
          <target state="translated">메소드에 서명이 정의되지 않은 경우 배열이 아닌 값이 리턴됩니다. 파이썬에서 이것은 반환 된 값의 유형이 list 이외의 것이 될 것임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="20bea7147a663550bf73fbd6aa35936ec0f1727f" translate="yes" xml:space="preserve">
          <source>If no such message exists, a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception is raised if the method was called as &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#mailbox.Mailbox.__delitem__&quot;&gt;&lt;code&gt;__delitem__()&lt;/code&gt;&lt;/a&gt; but no exception is raised if the method was called as &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt;. The behavior of &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt; may be preferred if the underlying mailbox format supports concurrent modification by other processes.</source>
          <target state="translated">이러한 메시지가 존재하지 않으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 방법과 같이 호출 한 경우 예외가 발생 &lt;a href=&quot;#mailbox.Mailbox.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 하거나 &lt;a href=&quot;#mailbox.Mailbox.__delitem__&quot;&gt; &lt;code&gt;__delitem__()&lt;/code&gt; &lt;/a&gt; 그러나이 방법으로 호출 된 경우, 예외가 발생되지 않는 &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; . 기본 사서함 형식이 다른 프로세스에 의한 동시 수정을 지원하는 경우 &lt;a href=&quot;#mailbox.Mailbox.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 동작이 선호 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e9812c267ec3985a1625ec9046fbcadc9ebd5a" translate="yes" xml:space="preserve">
          <source>If no target widget is found, then the target object is None</source>
          <target state="translated">대상 위젯이 없으면 대상 개체는 없음입니다.</target>
        </trans-unit>
        <trans-unit id="3cd75852ba66a942e3ef9da043c72d0616bb9860" translate="yes" xml:space="preserve">
          <source>If none of the above match, repeat all of the checks above for each of the types in the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; (&lt;code&gt;typ.__mro__&lt;/code&gt;). Finally, if no other key yields a handler, check for a handler for the key &lt;code&gt;None&lt;/code&gt;. If there is no handler for &lt;code&gt;None&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; for the fully qualified name of the type.</source>
          <target state="translated">위와 일치하는 것이 없으면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; 의 각 유형에 대해 위의 모든 검사를 반복하십시오 ( &lt;code&gt;typ.__mro__&lt;/code&gt; ). 마지막으로, 다른 키가 핸들러를 생성하지 않으면 &lt;code&gt;None&lt;/code&gt; 키에 대한 핸들러를 확인하십시오 . 에 대한 핸들러가없는 경우 &lt;code&gt;None&lt;/code&gt; , 인상 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를&lt;/a&gt; 유형의 정규화 된 이름을.</target>
        </trans-unit>
        <trans-unit id="a4dfb5341e97fb222600b0bf937e30412692a3d4" translate="yes" xml:space="preserve">
          <source>If none of the above match, repeat all of the checks above for each of the types in the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; (&lt;code&gt;typ.__mro__&lt;/code&gt;). Finally, if no other key yields a handler, check for a handler for the key &lt;code&gt;None&lt;/code&gt;. If there is no handler for &lt;code&gt;None&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; for the fully qualified name of the type.</source>
          <target state="translated">위와 일치하는 항목이 없으면 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mro&quot;&gt;MRO&lt;/a&gt; 의 각 유형에 대해 위의 모든 검사를 반복합니다 ( &lt;code&gt;typ.__mro__&lt;/code&gt; ). 마지막으로 핸들러를 생성하는 다른 키가 없으면 &lt;code&gt;None&lt;/code&gt; 키에 대한 핸들러를 확인하십시오 . &lt;code&gt;None&lt;/code&gt; 에 대한 처리기가 없으면 형식의 정규화 된 이름에 대해 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6ab966a0bae68c566e4582d75c7e75e79ff60df0" translate="yes" xml:space="preserve">
          <source>If none of the candidates matches any of the preferences in &lt;em&gt;preferencelist&lt;/em&gt;, return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">후보자의 아무도의 환경 설정의 일치하지 않는 경우 &lt;em&gt;preferencelist을&lt;/em&gt; 반환하지 않습니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0af9b04d52a06016027c04f7762d012d26364887" translate="yes" xml:space="preserve">
          <source>If none of the matrix elements are given, return the transformation matrix as a tuple of 4 elements. Otherwise set the given elements and transform the turtleshape according to the matrix consisting of first row t11, t12 and second row t21, 22. The determinant t11 * t22 - t12 * t21 must not be zero, otherwise an error is raised. Modify stretchfactor, shearfactor and tiltangle according to the given matrix.</source>
          <target state="translated">행렬 요소가 제공되지 않으면 변환 행렬을 4 개 요소의 튜플로 반환합니다. 그렇지 않으면 주어진 요소를 설정하고 첫 번째 행 t11, t12 및 두 번째 행 t21, 22로 구성된 행렬에 따라 거북이 모양을 변환합니다. 결정자 t11 * t22-t12 * t21은 0이 아니어야합니다. 그렇지 않으면 오류가 발생합니다. 주어진 행렬에 따라 신축 계수, 전단 계수 및 경사 각도를 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="d022ff617a119c979b5be13e4ac716aea9e10a76" translate="yes" xml:space="preserve">
          <source>If none of the named files exist, the &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; instance will contain an empty dataset. An application which requires initial values to be loaded from a file should load the required file or files using &lt;a href=&quot;#configparser.ConfigParser.read_file&quot;&gt;&lt;code&gt;read_file()&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; for any optional files:</source>
          <target state="translated">명명 된 파일이 없으면 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 인스턴스에 빈 데이터 집합이 포함됩니다. 파일에서 초기 값을로드해야하는 응용 프로그램은 선택적 파일에 대해 &lt;a href=&quot;#configparser.ConfigParser.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;#configparser.ConfigParser.read_file&quot;&gt; &lt;code&gt;read_file()&lt;/code&gt; &lt;/a&gt; 사용하여 필요한 파일을로드해야 합니다.</target>
        </trans-unit>
        <trans-unit id="d63f28fd05ae33a3c995e80b7d7ac4d24283f9a6" translate="yes" xml:space="preserve">
          <source>If none of these keys produce a handler, raise a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; for the full MIME type.</source>
          <target state="translated">이러한 키가 핸들러를 생성하지 않으면 전체 MIME 유형에 대해 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="c4b559d6709f523acb559ebc9de05a632f179410" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, &lt;em&gt;daemon&lt;/em&gt; explicitly sets whether the thread is daemonic. If &lt;code&gt;None&lt;/code&gt; (the default), the daemonic property is inherited from the current thread.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , &lt;em&gt;daemon&lt;/em&gt; 은 스레드가 &lt;em&gt;데몬&lt;/em&gt; 인지 여부를 명시 적으로 설정합니다. 경우 &lt;code&gt;None&lt;/code&gt; (기본값) 악마의 속성은 현재 스레드에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c475ada572eb526f097538d76dc4f24e8fb21ac" translate="yes" xml:space="preserve">
          <source>If not passed as a parameter when creating the object, this attribute is initialized upon first access or when the first record is read from the file.</source>
          <target state="translated">객체를 생성 할 때 매개 변수로 전달되지 않으면이 속성은 처음 액세스 할 때 또는 파일에서 첫 번째 레코드를 읽을 때 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b0f653097180825fd4fc47faf0827556509908" translate="yes" xml:space="preserve">
          <source>If not specified, the directory to serve is the current working directory.</source>
          <target state="translated">지정되지 않은 경우 제공 할 디렉토리는 현재 작업 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="46415929d11820d8c6bb9f358d9a2092933c6fcf" translate="yes" xml:space="preserve">
          <source>If one comparand is naive and the other is aware, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised if an order comparison is attempted. For equality comparisons, naive instances are never equal to aware instances.</source>
          <target state="translated">하나의 비교가 순진하고 다른 하나가 인식 하는 경우 주문 비교를 시도하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 동등 비교의 경우, 순진 인스턴스는 인식 인스턴스와 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f586af1a41a07ac3dcc0f4d3f82539d6176c3e4c" translate="yes" xml:space="preserve">
          <source>If one of the iterables is potentially infinite, then the &lt;a href=&quot;#itertools.zip_longest&quot;&gt;&lt;code&gt;zip_longest()&lt;/code&gt;&lt;/a&gt; function should be wrapped with something that limits the number of calls (for example &lt;a href=&quot;#itertools.islice&quot;&gt;&lt;code&gt;islice()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#itertools.takewhile&quot;&gt;&lt;code&gt;takewhile()&lt;/code&gt;&lt;/a&gt;). If not specified, &lt;em&gt;fillvalue&lt;/em&gt; defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">iterable 중 하나가 잠재적으로 무한한 경우, &lt;a href=&quot;#itertools.zip_longest&quot;&gt; &lt;code&gt;zip_longest()&lt;/code&gt; &lt;/a&gt; 함수는 호출 횟수를 제한하는 무언가로 랩핑되어야합니다 (예 : &lt;a href=&quot;#itertools.islice&quot;&gt; &lt;code&gt;islice()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#itertools.takewhile&quot;&gt; &lt;code&gt;takewhile()&lt;/code&gt; &lt;/a&gt; ). 지정하지 않으면 &lt;em&gt;fillvalue의&lt;/em&gt; 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fed106ddf387a9f27caba16b43370e63282aec73" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned.</source>
          <target state="translated">하나의 위치 인수가 제공되면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능&lt;/a&gt; 해야합니다 . iterable에서 가장 큰 항목이 반환됩니다. 둘 이상의 위치 인수가 제공되면 가장 큰 위치 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="cd31c867fd89a7c1d95f7f40da4f4f0882fa7af1" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned.</source>
          <target state="translated">하나의 위치 인수가 제공되면 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능&lt;/a&gt; 해야합니다 . iterable에서 가장 작은 항목이 반환됩니다. 둘 이상의 위치 인수가 제공되면 가장 작은 위치 인수가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="11f5d7571b209076fb198c26e5bd96ac847a230a" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The largest item in the iterable is returned. If two or more positional arguments are provided, the largest of the positional arguments is returned.</source>
          <target state="translated">하나의 위치 인수가 제공되는 경우 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; 이어야합니다 . iterable에서 가장 큰 항목이 반환됩니다. 두 개 이상의 위치 인수가 제공되면 가장 큰 위치 인수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="59628cf0daf40f1b0bef9a91cb696904b200b43b" translate="yes" xml:space="preserve">
          <source>If one positional argument is provided, it should be an &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt;. The smallest item in the iterable is returned. If two or more positional arguments are provided, the smallest of the positional arguments is returned.</source>
          <target state="translated">위치 인수가 하나 제공되면 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; 이어야합니다 . 이터 러블에서 가장 작은 항목이 반환됩니다. 두 개 이상의 위치 인수가 제공되면 가장 작은 위치 인수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b1237f29843fb6e1241d53edd8dcf105508a566f" translate="yes" xml:space="preserve">
          <source>If one wants more information about all matches of a pattern than the matched text, &lt;a href=&quot;#re.finditer&quot;&gt;&lt;code&gt;finditer()&lt;/code&gt;&lt;/a&gt; is useful as it provides &lt;a href=&quot;#match-objects&quot;&gt;match objects&lt;/a&gt; instead of strings. Continuing with the previous example, if a writer wanted to find all of the adverbs &lt;em&gt;and their positions&lt;/em&gt; in some text, they would use &lt;a href=&quot;#re.finditer&quot;&gt;&lt;code&gt;finditer()&lt;/code&gt;&lt;/a&gt; in the following manner:</source>
          <target state="translated">일치하는 텍스트보다 패턴의 모든 일치에 대한 자세한 정보를 원하는 경우 &lt;a href=&quot;#re.finditer&quot;&gt; &lt;code&gt;finditer()&lt;/code&gt; &lt;/a&gt; 는 문자열 대신 &lt;a href=&quot;#match-objects&quot;&gt;일치 객체&lt;/a&gt; 를 제공하므로 유용합니다 . 앞의 예제를 계속하여 작가가 모든 부사 &lt;em&gt;와 그 위치&lt;/em&gt; 를 텍스트 로 찾으 려면 &lt;a href=&quot;#re.finditer&quot;&gt; &lt;code&gt;finditer()&lt;/code&gt; &lt;/a&gt; 를 다음과 같이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f1347dbe4680d59bafdc6451d2e8d67e574fff02" translate="yes" xml:space="preserve">
          <source>If one wants to customize pickling of some classes without disturbing any other code which depends on pickling, then one can create a pickler with a private dispatch table.</source>
          <target state="translated">피클 링에 의존하는 다른 코드를 방해하지 않고 일부 클래스의 피클 링을 사용자 정의하려면 개인 디스패치 테이블을 사용하여 피커를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37a72b7770c6c17e2466572d1f613dd461295e35" translate="yes" xml:space="preserve">
          <source>If only some components are abstract, only those components need to be updated to create a concrete property in a subclass:</source>
          <target state="translated">일부 컴포넌트 만 추상적 인 경우 서브 클래스에서 구체적 특성을 작성하려면 해당 컴포넌트 만 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1c740863730ebbf14b847aaee2c1d18d2436d45e" translate="yes" xml:space="preserve">
          <source>If only the &lt;em&gt;exception&lt;/em&gt; and possibly the &lt;em&gt;msg&lt;/em&gt; arguments are given, return a context manager so that the code under test can be written inline rather than as a function:</source>
          <target state="translated">단지 경우 &lt;em&gt;를 제외&lt;/em&gt; 하고는 아마도 &lt;em&gt;MSG의&lt;/em&gt; 인수가 주어 테스트중인 코드가 아니라 함수로보다 인라인 기록 될 수 있도록하는 컨텍스트 관리자를 반환 :</target>
        </trans-unit>
        <trans-unit id="7753140c3a7be41fbf94278880c58bc397646c99" translate="yes" xml:space="preserve">
          <source>If only the &lt;em&gt;warning&lt;/em&gt; and possibly the &lt;em&gt;msg&lt;/em&gt; arguments are given, return a context manager so that the code under test can be written inline rather than as a function:</source>
          <target state="translated">단지 경우 &lt;em&gt;경고&lt;/em&gt; 와는 가능성이 &lt;em&gt;MSG의&lt;/em&gt; 인수가 주어 테스트중인 코드가 아니라 함수로보다 인라인 기록 될 수 있도록하는 컨텍스트 관리자를 반환 :</target>
        </trans-unit>
        <trans-unit id="daaad11308bf3ecc56da6270a84c953330e34e9b" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;charset&lt;/em&gt; is specified, the parameter will be encoded according to &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;. Optional &lt;em&gt;language&lt;/em&gt; specifies the RFC 2231 language, defaulting to the empty string. Both &lt;em&gt;charset&lt;/em&gt; and &lt;em&gt;language&lt;/em&gt; should be strings.</source>
          <target state="translated">선택적 &lt;em&gt;문자 집합&lt;/em&gt; 이 지정된 경우 매개 변수는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; 에 따라 인코딩됩니다 . 선택적 &lt;em&gt;언어&lt;/em&gt; 는 RFC 2231 &lt;em&gt;언어를&lt;/em&gt; 지정하며 기본값은 빈 문자열입니다. 두 &lt;em&gt;캐릭터 세트&lt;/em&gt; 와 &lt;em&gt;언어는&lt;/em&gt; 문자열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="30e460f7c1de270b9a5d3d19b52510be2728dbac" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;mangle_from_&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, put a &lt;code&gt;&amp;gt;&lt;/code&gt; character in front of any line in the body that starts with the exact string &lt;code&gt;&quot;From &quot;&lt;/code&gt;, that is &lt;code&gt;From&lt;/code&gt; followed by a space at the beginning of a line. &lt;em&gt;mangle_from_&lt;/em&gt; defaults to the value of the &lt;a href=&quot;email.policy#email.policy.Policy.mangle_from_&quot;&gt;&lt;code&gt;mangle_from_&lt;/code&gt;&lt;/a&gt; setting of the &lt;em&gt;policy&lt;/em&gt; (which is &lt;code&gt;True&lt;/code&gt; for the &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt; policy and &lt;code&gt;False&lt;/code&gt; for all others). &lt;em&gt;mangle_from_&lt;/em&gt; is intended for use when messages are stored in unix mbox format (see &lt;a href=&quot;mailbox#module-mailbox&quot;&gt;&lt;code&gt;mailbox&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://www.jwz.org/doc/content-length.html&quot;&gt;WHY THE CONTENT-LENGTH FORMAT IS BAD&lt;/a&gt;).</source>
          <target state="translated">선택적인 &lt;em&gt;mangle_from_&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 본문에서 정확한 문자열 &lt;code&gt;&quot;From &quot;&lt;/code&gt; 시작하는 줄 앞에 &lt;code&gt;&amp;gt;&lt;/code&gt; 문자를 입력하십시오. 즉 , &lt;code&gt;From&lt;/code&gt; 다음에 줄 시작 부분에 공백 &lt;em&gt;이옵니다&lt;/em&gt; . &lt;em&gt;mangle_from_의&lt;/em&gt; 기본값 은 &lt;em&gt;정책&lt;/em&gt; 의 &lt;a href=&quot;email.policy#email.policy.Policy.mangle_from_&quot;&gt; &lt;code&gt;mangle_from_&lt;/code&gt; &lt;/a&gt; 설정 값입니다 ( &lt;a href=&quot;email.policy#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 정책의 경우 &lt;code&gt;True&lt;/code&gt; , 다른 모든 경우 &lt;code&gt;False&lt;/code&gt; ). &lt;em&gt;mangle_from_&lt;/em&gt; 은 메시지가 유닉스 mbox 형식으로 저장 될 때 사용하기위한 것입니다 ( &lt;a href=&quot;mailbox#module-mailbox&quot;&gt; &lt;code&gt;mailbox&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://www.jwz.org/doc/content-length.html&quot;&gt;컨텐츠 길이 형식이 나쁜 이유&lt;/a&gt; 참조 ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3c8605e1fe87239a6939ac038c36a1310db420f6" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;rest&lt;/em&gt; is given, a &lt;code&gt;REST&lt;/code&gt; command is sent to the server, passing &lt;em&gt;rest&lt;/em&gt; as an argument. &lt;em&gt;rest&lt;/em&gt; is usually a byte offset into the requested file, telling the server to restart sending the file&amp;rsquo;s bytes at the requested offset, skipping over the initial bytes. Note however that &lt;a href=&quot;https://tools.ietf.org/html/rfc959.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 959&lt;/strong&gt;&lt;/a&gt; requires only that &lt;em&gt;rest&lt;/em&gt; be a string containing characters in the printable range from ASCII code 33 to ASCII code 126. The &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; method, therefore, converts &lt;em&gt;rest&lt;/em&gt; to a string, but no check is performed on the string&amp;rsquo;s contents. If the server does not recognize the &lt;code&gt;REST&lt;/code&gt; command, an &lt;a href=&quot;#ftplib.error_reply&quot;&gt;&lt;code&gt;error_reply&lt;/code&gt;&lt;/a&gt; exception will be raised. If this happens, simply call &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; without a &lt;em&gt;rest&lt;/em&gt; argument.</source>
          <target state="translated">선택적 &lt;em&gt;rest&lt;/em&gt; 가 제공되면 &lt;code&gt;REST&lt;/code&gt; 명령이 서버로 전송되어 &lt;em&gt;rest&lt;/em&gt; 를 인수로 전달합니다. &lt;em&gt;rest&lt;/em&gt; 는 일반적으로 요청 된 파일에 대한 바이트 오프셋으로, 서버가 요청 된 오프셋에서 파일 바이트 전송을 다시 시작하고 초기 바이트를 건너 뛰도록 서버에 지시합니다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc959.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 959&lt;/strong&gt;&lt;/a&gt; 는 &lt;em&gt;rest&lt;/em&gt; 가 ASCII 코드 33에서 ASCII 코드 126까지 인쇄 가능한 범위의 문자를 포함하는 문자열이어야 한다는 점에 유의하십시오 . 따라서 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;em&gt;rest&lt;/em&gt; 를 문자열 로 변환 하지만 문자열의 내용을 점검하지는 않습니다. . 서버가 &lt;code&gt;REST&lt;/code&gt; 명령을 인식하지 못하면 &lt;a href=&quot;#ftplib.error_reply&quot;&gt; &lt;code&gt;error_reply&lt;/code&gt; &lt;/a&gt;예외가 발생합니다. 이런 일이 발생 하면 &lt;em&gt;rest&lt;/em&gt; 인수 없이 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d94c1f68a1301d564a3fd1e1a26bde153039ac4c" translate="yes" xml:space="preserve">
          <source>If optional &lt;em&gt;rest&lt;/em&gt; is given, a &lt;code&gt;REST&lt;/code&gt; command is sent to the server, passing &lt;em&gt;rest&lt;/em&gt; as an argument. &lt;em&gt;rest&lt;/em&gt; is usually a byte offset into the requested file, telling the server to restart sending the file&amp;rsquo;s bytes at the requested offset, skipping over the initial bytes. Note however that the &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; method converts &lt;em&gt;rest&lt;/em&gt; to a string with the &lt;em&gt;encoding&lt;/em&gt; parameter specified at initialization, but no check is performed on the string&amp;rsquo;s contents. If the server does not recognize the &lt;code&gt;REST&lt;/code&gt; command, an &lt;a href=&quot;#ftplib.error_reply&quot;&gt;&lt;code&gt;error_reply&lt;/code&gt;&lt;/a&gt; exception will be raised. If this happens, simply call &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt;&lt;code&gt;transfercmd()&lt;/code&gt;&lt;/a&gt; without a &lt;em&gt;rest&lt;/em&gt; argument.</source>
          <target state="translated">선택적 &lt;em&gt;rest&lt;/em&gt; 가 제공되면 &lt;code&gt;REST&lt;/code&gt; 명령이 서버로 전송되어 &lt;em&gt;나머지&lt;/em&gt; 를 인수로 전달합니다. &lt;em&gt;rest&lt;/em&gt; 는 일반적으로 요청 된 파일에 대한 바이트 오프셋으로, 서버에 요청 된 오프셋에서 파일의 바이트 전송을 다시 시작하고 초기 바이트를 건너 뛰도록 지시합니다. 그러나 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 메서드는 초기화시 &lt;em&gt;인코딩&lt;/em&gt; 매개 변수가 지정된 문자열 로 &lt;em&gt;나머지&lt;/em&gt; 를 변환 하지만 문자열의 내용에 대한 검사는 수행되지 않습니다. 서버가 &lt;code&gt;REST&lt;/code&gt; 명령을 인식하지 못하면 &lt;a href=&quot;#ftplib.error_reply&quot;&gt; &lt;code&gt;error_reply&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 경우 단순히 &lt;a href=&quot;#ftplib.FTP.transfercmd&quot;&gt; &lt;code&gt;transfercmd()&lt;/code&gt; &lt;/a&gt; 를 호출 하지 않고&lt;em&gt;&lt;/em&gt;&lt;em&gt;나머지&lt;/em&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="12e5876c996fe3ce7e5f11f23f2acba47a2002c2" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; or not specified, the triple for a directory is generated before the triples for any of its subdirectories (directories are generated top-down). If &lt;em&gt;topdown&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the triple for a directory is generated after the triples for all of its subdirectories (directories are generated bottom-up). No matter the value of &lt;em&gt;topdown&lt;/em&gt;, the list of subdirectories is retrieved before the tuples for the directory and its subdirectories are generated.</source>
          <target state="translated">선택적 인수 &lt;em&gt;topdown&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 이거나 지정되지 않은 경우 디렉토리의 트리플이 서브 디렉토리의 트리플보다 먼저 생성됩니다 (디렉토리는 하향식으로 생성됨). &lt;em&gt;topdown&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우 모든 하위 디렉토리의 트리플이 끝난 후 디렉토리의 트리플이 생성됩니다 (디렉토리는 상향식으로 생성됨). &lt;em&gt;topdown&lt;/em&gt; 값에 관계없이 디렉토리 및 서브 디렉토리의 튜플이 생성되기 전에 서브 디렉토리 목록이 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="c43cb00d5fc16bd54dc39ceae5b45c2ffe796cc5" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;tz&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; or not specified, this is like &lt;a href=&quot;#datetime.datetime.today&quot;&gt;&lt;code&gt;today()&lt;/code&gt;&lt;/a&gt;, but, if possible, supplies more precision than can be gotten from going through a &lt;a href=&quot;time#time.time&quot;&gt;&lt;code&gt;time.time()&lt;/code&gt;&lt;/a&gt; timestamp (for example, this may be possible on platforms supplying the C &lt;code&gt;gettimeofday()&lt;/code&gt; function).</source>
          <target state="translated">선택적 인수 &lt;em&gt;tz&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이거나 지정되지 않은 경우 이는 &lt;a href=&quot;#datetime.datetime.today&quot;&gt; &lt;code&gt;today()&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 가능하면 &lt;a href=&quot;time#time.time&quot;&gt; &lt;code&gt;time.time()&lt;/code&gt; &lt;/a&gt; 타임 스탬프를 통과하는 것보다 더 정확한 정밀도를 제공합니다 (예 : 플랫폼을 제공하는 플랫폼에서 가능할 수 있음) C &lt;code&gt;gettimeofday()&lt;/code&gt; 함수).</target>
        </trans-unit>
        <trans-unit id="8ebb578f00d1c7fad8844f4eebad620649156c22" translate="yes" xml:space="preserve">
          <source>If optional argument &lt;em&gt;verbose&lt;/em&gt; is true, output is generated even if there are no failures. By default, output is generated only in case of an example failure.</source>
          <target state="translated">선택적 인수 &lt;em&gt;verbose&lt;/em&gt; 가 true이면 실패가없는 경우에도 출력이 생성됩니다. 기본적으로 출력은 예제 실패의 경우에만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="8ffdd4e7b5895f1e0d5dff890e02c15a4800f31a" translate="yes" xml:space="preserve">
          <source>If optional keyword argument &lt;em&gt;initial_response_ok&lt;/em&gt; is true, &lt;code&gt;authobject()&lt;/code&gt; will be called first with no argument. It can return the &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 4954&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;initial response&amp;rdquo; ASCII &lt;code&gt;str&lt;/code&gt; which will be encoded and sent with the &lt;code&gt;AUTH&lt;/code&gt; command as below. If the &lt;code&gt;authobject()&lt;/code&gt; does not support an initial response (e.g. because it requires a challenge), it should return &lt;code&gt;None&lt;/code&gt; when called with &lt;code&gt;challenge=None&lt;/code&gt;. If &lt;em&gt;initial_response_ok&lt;/em&gt; is false, then &lt;code&gt;authobject()&lt;/code&gt; will not be called first with &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">선택적 키워드 인수 &lt;em&gt;initial_response_ok&lt;/em&gt; 가 true 인 경우, 인수 &lt;code&gt;authobject()&lt;/code&gt; 가 먼저 호출됩니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4954.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 4954&lt;/strong&gt;&lt;/a&gt; &amp;ldquo;초기 응답&amp;rdquo;ASCII &lt;code&gt;str&lt;/code&gt; 을 반환 할 수 있으며 , 아래와 같이 &lt;code&gt;AUTH&lt;/code&gt; 명령으로 인코딩 및 전송 됩니다. &lt;code&gt;authobject()&lt;/code&gt; 가 초기 응답을 지원하지 않는 경우 (예 : 인증 요청이 필요한 경우) &lt;code&gt;challenge=None&lt;/code&gt; 으로 호출하면 &lt;code&gt;None&lt;/code&gt; 을 반환해야합니다 . 경우 &lt;em&gt;initial_response_ok은&lt;/em&gt; 거짓, 다음 &lt;code&gt;authobject()&lt;/code&gt; 처음으로 호출되지 않습니다 &lt;code&gt;None&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae29e2c8c341be783838f132ff21d9ab34d97fc" translate="yes" xml:space="preserve">
          <source>If passed an object that is not a context manager, this method assumes it is a callback with the same signature as a context manager&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method and adds it directly to the callback stack.</source>
          <target state="translated">컨텍스트 관리자가 아닌 객체를 전달한 경우이 메서드는 컨텍스트 관리자의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드와 동일한 서명을 가진 콜백 인 것으로 가정 하여 콜백 스택에 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2255fce40f35cd4e01f62b3f7cb6658b67441be6" translate="yes" xml:space="preserve">
          <source>If passed an object that is not a context manager, this method assumes it is a callback with the same signature as a context manager&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method and adds it directly to the callback stack.</source>
          <target state="translated">컨텍스트 관리자가 아닌 객체가 전달 된 경우이 메서드는 컨텍스트 관리자의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드와 동일한 서명을 가진 콜백이라고 가정 하고 콜백 스택에 직접 추가합니다.</target>
        </trans-unit>
        <trans-unit id="38619f38fb2e8ea83cef76fefbe9fa418722ab8f" translate="yes" xml:space="preserve">
          <source>If policy allows (ie. the &lt;code&gt;rfc2965&lt;/code&gt; and &lt;code&gt;hide_cookie2&lt;/code&gt; attributes of the &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; instance are true and false respectively), the &lt;em&gt;Cookie2&lt;/em&gt; header is also added when appropriate.</source>
          <target state="translated">정책 (예. 허용하는 경우 &lt;code&gt;rfc2965&lt;/code&gt; 및 &lt;code&gt;hide_cookie2&lt;/code&gt; 의 속성 &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인스턴스는 진정한 각각 거짓)의 &lt;em&gt;Cookie2를의&lt;/em&gt; 헤더는 또한 적절한 경우 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d11ebbe292ed1e1ee178b91b1ecd2889a70e4116" translate="yes" xml:space="preserve">
          <source>If precision is &lt;code&gt;N&lt;/code&gt;, the output is truncated to &lt;code&gt;N&lt;/code&gt; characters.</source>
          <target state="translated">정밀도가 &lt;code&gt;N&lt;/code&gt; 인 경우 출력은 &lt;code&gt;N&lt;/code&gt; 자로 잘립니다 .</target>
        </trans-unit>
        <trans-unit id="443ece5632be703c310845263c3ce1e3e31a1c39" translate="yes" xml:space="preserve">
          <source>If prefix &amp;ldquo;0b&amp;rdquo; is desired or not, you can use either of the following ways.</source>
          <target state="translated">접두사 &quot;0b&quot;가 필요한지 여부는 다음 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4ce265a9ea589b84bb1ae1a723bd20e1e88bd3e" translate="yes" xml:space="preserve">
          <source>If present and greater than zero, specified the desired width of the pane area (not including internal padding). Otherwise, the maximum width of all panes is used.</source>
          <target state="translated">존재하고 0보다 큰 경우, 원하는 페인 영역 너비를 지정하십시오 (내부 패딩 제외). 그렇지 않으면 모든 창의 최대 너비가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b03a80e9a562cf9b1589a814197ce3243d92bcb" translate="yes" xml:space="preserve">
          <source>If present and greater than zero, specifies the desired height of the pane area (not including internal padding or tabs). Otherwise, the maximum height of all panes is used.</source>
          <target state="translated">존재하고 0보다 큰 경우, 분할 영역의 원하는 높이를 지정합니다 (내부 패딩 또는 탭 제외). 그렇지 않으면 모든 창의 최대 높이가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4545dbeee8dafb95a5bd0e1db8e7852d40b3ad54" translate="yes" xml:space="preserve">
          <source>If provided, &lt;em&gt;tz&lt;/em&gt; must be an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass, and its &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.datetime.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; methods must not return &lt;code&gt;None&lt;/code&gt;. If &lt;em&gt;self&lt;/em&gt; is naive, it is presumed to represent time in the system timezone.</source>
          <target state="translated">제공되는 경우 &lt;em&gt;tz&lt;/em&gt; 는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 여야하며 utcoffset &lt;a href=&quot;#datetime.datetime.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.datetime.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;code&gt;None&lt;/code&gt; 을 리턴하지 않아야합니다 . &lt;em&gt;self&lt;/em&gt; 가 순진한 경우 시스템 시간대의 시간을 나타내는 것으로 추정됩니다.</target>
        </trans-unit>
        <trans-unit id="70f41e2c7bc507b15fffa53f66966c258b97643a" translate="yes" xml:space="preserve">
          <source>If returning a tuple doesn&amp;rsquo;t suffice and you want name-based access to columns, you should consider setting &lt;a href=&quot;#sqlite3.Connection.row_factory&quot;&gt;&lt;code&gt;row_factory&lt;/code&gt;&lt;/a&gt; to the highly-optimized &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;sqlite3.Row&lt;/code&gt;&lt;/a&gt; type. &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; provides both index-based and case-insensitive name-based access to columns with almost no memory overhead. It will probably be better than your own custom dictionary-based approach or even a db_row based solution.</source>
          <target state="translated">튜플을 반환해도 충분하지 않고 열에 대한 이름 기반 액세스를 &lt;a href=&quot;#sqlite3.Connection.row_factory&quot;&gt; &lt;code&gt;row_factory&lt;/code&gt; &lt;/a&gt; 를 최적화 된 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;sqlite3.Row&lt;/code&gt; &lt;/a&gt; 유형으로 설정하는 것을 고려해야합니다 . &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 는 메모리 오버 헤드가 거의없이 열에 대한 인덱스 기반 및 대소 문자 구분이없는 이름 기반 액세스를 제공합니다. 아마도 사용자 정의 사전 기반 접근 방식 또는 심지어 db_row 기반 솔루션보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="fb1cc245a11320da1db54ed5268d026fb86fcc00" translate="yes" xml:space="preserve">
          <source>If set to 1, causes the element and all of its descendants to be treated as a single element for the purposes of &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt; et al. It&amp;rsquo;s used for things like scrollbar thumbs with grips.</source>
          <target state="translated">1로 설정하면 &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; 등 의 목적으로 요소와 모든 하위 항목이 단일 요소로 처리됩니다 . 그립이있는 스크롤 막대 엄지 손가락과 같은 것들에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8e4c1e34442088e1b288c391bdce23a843d942a1" translate="yes" xml:space="preserve">
          <source>If set to a non-zero integer, the parser will report only those attributes which were specified in the document instance and not those which were derived from attribute declarations. Applications which set this need to be especially careful to use what additional information is available from the declarations as needed to comply with the standards for the behavior of XML processors. By default, this attribute is false; it may be changed at any time.</source>
          <target state="translated">0이 아닌 정수로 설정하면 구문 분석기는 문서 인스턴스에 지정된 속성 만보고하고 속성 선언에서 파생 된 속성은보고하지 않습니다. 이를 설정 한 응용 프로그램은 XML 프로세서의 동작에 대한 표준을 준수하기 위해 선언에서 사용 가능한 추가 정보를 사용할 때 특히주의해야합니다. 기본적으로이 속성은 false입니다. 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ee3f2b48192a68f3a6682ab4100a180bef3319f" translate="yes" xml:space="preserve">
          <source>If set to true &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt;&lt;code&gt;stop()&lt;/code&gt;&lt;/a&gt; will be called on the first failure or error, halting the test run.</source>
          <target state="translated">true로 설정 하면 첫 번째 실패 또는 오류시 &lt;a href=&quot;#unittest.TestResult.stop&quot;&gt; &lt;code&gt;stop()&lt;/code&gt; &lt;/a&gt; 이 호출되어 테스트 실행이 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="e51e0d8058becfc44eb0b15e9fbb655eff6ca1d8" translate="yes" xml:space="preserve">
          <source>If set to true then local variables will be shown in tracebacks.</source>
          <target state="translated">true로 설정하면 지역 변수가 역 추적으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="64b6f3bafe48fa6aa11d7a7bedca0dc485936902" translate="yes" xml:space="preserve">
          <source>If set to true, &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; will be buffered in between &lt;a href=&quot;#unittest.TestResult.startTest&quot;&gt;&lt;code&gt;startTest()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestResult.stopTest&quot;&gt;&lt;code&gt;stopTest()&lt;/code&gt;&lt;/a&gt; being called. Collected output will only be echoed onto the real &lt;code&gt;sys.stdout&lt;/code&gt; and &lt;code&gt;sys.stderr&lt;/code&gt; if the test fails or errors. Any output is also attached to the failure / error message.</source>
          <target state="translated">true로 설정하면 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 이 호출되는 &lt;a href=&quot;#unittest.TestResult.startTest&quot;&gt; &lt;code&gt;startTest()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#unittest.TestResult.stopTest&quot;&gt; &lt;code&gt;stopTest()&lt;/code&gt; &lt;/a&gt; 사이에 버퍼링됩니다 . 수집 된 출력은 테스트가 실패하거나 오류가 발생하는 경우 실제 &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 에만 에코 됩니다. 모든 출력은 실패 / 오류 메시지에도 첨부됩니다.</target>
        </trans-unit>
        <trans-unit id="ecf8c4b33b20be57bc6efdf4b39c10800d750a9d" translate="yes" xml:space="preserve">
          <source>If set, a new dict will be created for the frame&amp;rsquo;s &lt;code&gt;f_locals&lt;/code&gt; when the code object is executed.</source>
          <target state="translated">설정 하면 코드 객체가 실행될 때 프레임의 &lt;code&gt;f_locals&lt;/code&gt; 에 대한 새 dict가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="90c8757d24024109684a25cf5517e4c9f2ec4bd1" translate="yes" xml:space="preserve">
          <source>If set, specifies the index (0-based) of a character to underline in the text string. The underline character is used for mnemonic activation.</source>
          <target state="translated">설정된 경우 텍스트 문자열에서 밑줄을 긋는 문자의 인덱스 (0 기반)를 지정합니다. 밑줄 문자는 니모닉 활성화에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8a6c0ce7a7752011eb06bc4de3089d05ce6f551e" translate="yes" xml:space="preserve">
          <source>If some data was successfully read, it will return the number of bytes read. If no bytes were read, it will return &lt;code&gt;-1&lt;/code&gt; and set errno to &lt;a href=&quot;errno#errno.EAGAIN&quot;&gt;&lt;code&gt;errno.EAGAIN&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 데이터를 읽은 경우 읽은 바이트 수를 반환합니다. 읽은 바이트가 없으면 &lt;code&gt;-1&lt;/code&gt; 을 반환 하고 errno를 &lt;a href=&quot;errno#errno.EAGAIN&quot;&gt; &lt;code&gt;errno.EAGAIN&lt;/code&gt; 으로&lt;/a&gt; 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="8c0a8612344f25e81798fab5bf81643a26a155fd" translate="yes" xml:space="preserve">
          <source>If source code is available, then the method should return the path to the source file, regardless of whether a bytecode was used to load the module.</source>
          <target state="translated">소스 코드가 사용 가능한 경우 메소드는 바이트 코드를 사용하여 모듈을로드했는지 여부에 관계없이 소스 파일의 경로를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e0b6d4c847d28d357f25ee69a7125504c0d6bad" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;default&lt;/em&gt; should be a function that gets called for objects that can&amp;rsquo;t otherwise be serialized. It should return a JSON encodable version of the object or raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If not specified, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 경우 &lt;em&gt;기본값&lt;/em&gt; 은 직렬화 할 수없는 객체를 호출하는 함수 여야합니다. JSON 인코딩 가능한 버전의 객체를 반환하거나 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시켜야합니다 . 지정하지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="59bccf61da6bc8aa73e6b26d9107f86de89d1f17" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;env&lt;/em&gt; must provide any variables required for the program to execute. On Windows, in order to run a &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-by-Side_Assembly&quot;&gt;side-by-side assembly&lt;/a&gt; the specified &lt;em&gt;env&lt;/em&gt;&lt;strong&gt;must&lt;/strong&gt; include a valid &lt;code id=&quot;index-3&quot;&gt;SystemRoot&lt;/code&gt;.</source>
          <target state="translated">지정된 경우 &lt;em&gt;env&lt;/em&gt; 는 프로그램 실행에 필요한 변수를 제공해야합니다. Windows에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Side-by-Side_Assembly&quot;&gt;병렬 어셈블리&lt;/a&gt; 를 실행 하려면 지정된 &lt;em&gt;env&lt;/em&gt; 에 유효한 &lt;code id=&quot;index-3&quot;&gt;SystemRoot&lt;/code&gt; &lt;strong&gt;가&lt;/strong&gt; 포함 &lt;strong&gt;되어야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="55004220c3f31c4448c84db4c687ec30a9bc0a57" translate="yes" xml:space="preserve">
          <source>If specified, &lt;em&gt;separators&lt;/em&gt; should be an &lt;code&gt;(item_separator, key_separator)&lt;/code&gt; tuple. The default is &lt;code&gt;(', ', ': ')&lt;/code&gt; if &lt;em&gt;indent&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;(',', ': ')&lt;/code&gt; otherwise. To get the most compact JSON representation, you should specify &lt;code&gt;(',', ':')&lt;/code&gt; to eliminate whitespace.</source>
          <target state="translated">지정된 경우 &lt;em&gt;구분 기호&lt;/em&gt; 는 &lt;code&gt;(item_separator, key_separator)&lt;/code&gt; 튜플 이어야합니다 . 기본값은 &lt;code&gt;(', ', ': ')&lt;/code&gt; 경우 &lt;em&gt;들여 쓰기가&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;(',', ': ')&lt;/code&gt; 그렇지. 가장 간단한 JSON 표현을 얻으려면 공백을 제거하기 위해 &lt;code&gt;(',', ':')&lt;/code&gt; 을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="51387c50308ba22f05c775c6091c3e23657f8358" translate="yes" xml:space="preserve">
          <source>If specified, this should be an iterable of already created handlers to add to the root logger. Any handlers which don&amp;rsquo;t already have a formatter set will be assigned the default formatter created in this function. Note that this argument is incompatible with &lt;em&gt;filename&lt;/em&gt; or &lt;em&gt;stream&lt;/em&gt; - if both are present, a &lt;code&gt;ValueError&lt;/code&gt; is raised.</source>
          <target state="translated">지정된 경우 루트 로거에 추가하기 위해 이미 작성된 핸들러의 반복 가능해야합니다. 포맷터 세트가없는 핸들러에는이 함수에서 생성 된 기본 포맷터가 할당됩니다. 이 인수는 &lt;em&gt;filename&lt;/em&gt; 또는 &lt;em&gt;stream&lt;/em&gt; 과 호환되지 않습니다. 둘 다 존재하면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2396c9bd05ca934d78b97fe306102f571da9db25" translate="yes" xml:space="preserve">
          <source>If stack information is available, it&amp;rsquo;s appended after the exception information, using &lt;a href=&quot;#logging.Formatter.formatStack&quot;&gt;&lt;code&gt;formatStack()&lt;/code&gt;&lt;/a&gt; to transform it if necessary.</source>
          <target state="translated">스택 정보를 사용할 수 있으면 예외 정보 뒤에 추가되어 &lt;a href=&quot;#logging.Formatter.formatStack&quot;&gt; &lt;code&gt;formatStack()&lt;/code&gt; &lt;/a&gt; 을 사용하여 필요한 경우 변환합니다.</target>
        </trans-unit>
        <trans-unit id="49e5edaf7d45ad995b7d09a564fc8b598f00fc32" translate="yes" xml:space="preserve">
          <source>If standard (non-proxy) &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; objects are contained in a referent, modifications to those mutable values will not be propagated through the manager because the proxy has no way of knowing when the values contained within are modified. However, storing a value in a container proxy (which triggers a &lt;code&gt;__setitem__&lt;/code&gt; on the proxy object) does propagate through the manager and so to effectively modify such an item, one could re-assign the modified value to the container proxy:</source>
          <target state="translated">표준 (프록시가 아닌) &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 오브젝트가 참조에 포함 된 경우 프록시에 포함 된 값이 수정되는시기를 알 수 없으므로 프록시를 통해 해당 변경 가능 값에 대한 수정 사항이 관리자를 통해 전파되지 않습니다. 그러나 컨테이너 프록시에 값을 저장하면 ( 프록시 객체 에서 &lt;code&gt;__setitem__&lt;/code&gt; 트리거 ) 관리자를 통해 전파되므로 이러한 항목을 효과적으로 수정하기 위해 수정 된 값을 컨테이너 프록시에 다시 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af8f87d5d4d9f4f5995cccc6502c2c7f249e6db4" translate="yes" xml:space="preserve">
          <source>If supplied, &lt;em&gt;source_address&lt;/em&gt; must be a 2-tuple &lt;code&gt;(host, port)&lt;/code&gt; for the socket to bind to as its source address before connecting. If host or port are &amp;lsquo;&amp;rsquo; or 0 respectively the OS default behavior will be used.</source>
          <target state="translated">제공된 경우, &lt;em&gt;source_address&lt;/em&gt; 는 소켓이 연결하기 전에 소스 주소로 바인드하기 위해 2- 튜플 &lt;code&gt;(host, port)&lt;/code&gt; 이어야합니다 . 호스트 또는 포트가 각각 ''또는 0 인 경우 OS 기본 동작이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7158776ee648d11018c88143c872cabdaad5856c" translate="yes" xml:space="preserve">
          <source>If text mode is not used, &lt;em&gt;stdin&lt;/em&gt;, &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; will be opened as binary streams. No encoding or line ending conversion is performed.</source>
          <target state="translated">텍스트 모드를 사용하지 않으면 &lt;em&gt;stdin&lt;/em&gt; , &lt;em&gt;stdout&lt;/em&gt; 및 &lt;em&gt;stderr&lt;/em&gt; 이 이진 스트림으로 열립니다. 인코딩 또는 줄 끝 변환이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b647614fdb703e999c4e6277543848afe83dfe6b" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt; attribute is &lt;code&gt;None&lt;/code&gt;, this raises a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception with the &lt;em&gt;key&lt;/em&gt; as argument.</source>
          <target state="translated">는 IF &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; &lt;/a&gt; 속성이 없습니다 &lt;code&gt;None&lt;/code&gt; 이이 제기 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를의&lt;/a&gt; 와 예외 &lt;em&gt;키&lt;/em&gt; 인수로합니다.</target>
        </trans-unit>
        <trans-unit id="5166c50db841216329f470ef00ee35316868399a" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#decimal.FloatOperation&quot;&gt;&lt;code&gt;FloatOperation&lt;/code&gt;&lt;/a&gt; signal is trapped, accidental mixing of decimals and floats in constructors or ordering comparisons raises an exception:</source>
          <target state="translated">경우 &lt;a href=&quot;#decimal.FloatOperation&quot;&gt; &lt;code&gt;FloatOperation&lt;/code&gt; 의&lt;/a&gt; 신호가 갇혀, 생성자 또는 주문 비교에 소수와 수레의 실수로 혼합 예외가 발생 :</target>
        </trans-unit>
        <trans-unit id="9bbeb2f2786191004c4aacbd9b237c32b9a9e470" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag is set, then &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; does not block in these cases, but instead immediately raises &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; 의&lt;/a&gt; 플래그가 설정되어, 다음 &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 이러한 경우에 차단, 대신 즉시 제기하지 않습니다 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e5c2c854be11bcf191a49fa0ebcc698cb65781e" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method raises an exception, &lt;a href=&quot;#threading.excepthook&quot;&gt;&lt;code&gt;threading.excepthook()&lt;/code&gt;&lt;/a&gt; is called to handle it. By default, &lt;a href=&quot;#threading.excepthook&quot;&gt;&lt;code&gt;threading.excepthook()&lt;/code&gt;&lt;/a&gt; ignores silently &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드가 예외를 제기, &lt;a href=&quot;#threading.excepthook&quot;&gt; &lt;code&gt;threading.excepthook()&lt;/code&gt; &lt;/a&gt; 그것을 처리하기 위해 호출됩니다. 기본적으로 &lt;a href=&quot;#threading.excepthook&quot;&gt; &lt;code&gt;threading.excepthook()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; 를&lt;/a&gt; 자동으로 무시합니다 .</target>
        </trans-unit>
        <trans-unit id="e96f8cfc40738bbb062383e1cc52fead6fbf34f8" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; method raises an exception while the test is running, the framework will consider the test to have suffered an error, and the test method will not be executed.</source>
          <target state="translated">는 IF &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 테스트가 실행되는 동안 메소드가 예외를 제기, 프레임 워크는 테스트에 오류가 고통을 생각하며, 시험 방법은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a83922f016248c8cd1e133445c39b06053bf60d4" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt;&lt;code&gt;origin_server&lt;/code&gt;&lt;/a&gt; attribute is set, this attribute&amp;rsquo;s value is used to set the default &lt;code&gt;SERVER_SOFTWARE&lt;/code&gt; WSGI environment variable, and also to set a default &lt;code&gt;Server:&lt;/code&gt; header in HTTP responses. It is ignored for handlers (such as &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;) that are not HTTP origin servers.</source>
          <target state="translated">는 IF &lt;a href=&quot;#wsgiref.handlers.BaseHandler.origin_server&quot;&gt; &lt;code&gt;origin_server&lt;/code&gt; 의&lt;/a&gt; 속성이 설정되어,이 속성의 값은 기본 설정하는 데 사용됩니다 &lt;code&gt;SERVER_SOFTWARE&lt;/code&gt; WSGI 환경 변수를, 또한 기본 설정 &lt;code&gt;Server:&lt;/code&gt; 헤더를 HTTP 응답에. HTTP 오리진 서버가 아닌 핸들러 (예 : &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; )에서는 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e6190ef04b122e93b83bb48591b9a20ea9d1832" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; option &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt; (the default), copy any headers in the original parsed message that have not been modified to the output with any bytes with the high bit set reproduced as in the original, and preserve the non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of any body parts that have them. If &lt;code&gt;cte_type&lt;/code&gt; is &lt;code&gt;7bit&lt;/code&gt;, convert the bytes with the high bit set as needed using an ASCII-compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. That is, transform parts with non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; (&lt;em&gt;Content-Transfer-Encoding: 8bit&lt;/em&gt;) to an ASCII compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;, and encode RFC-invalid non-ASCII bytes in headers using the MIME &lt;code&gt;unknown-8bit&lt;/code&gt; character set, thus rendering them RFC-compliant.</source>
          <target state="translated">는 IF &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 옵션 &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; (기본값), 원래 같이 재현 높은 비트 세트와 어떤 바이트 출력에 수정되지 않은 원래 구문 분석 된 메시지의 모든 헤더를 복사하고, 비 ASCII 보존 &lt;em&gt;된 Content를&lt;/em&gt; 신체 부위가있는 &lt;em&gt;전사 인코딩&lt;/em&gt; . 경우 &lt;code&gt;cte_type&lt;/code&gt; 가 있습니다 &lt;code&gt;7bit&lt;/code&gt; 있는 ASCII 호환 사용하여 필요에 따라, 높은 비트 세트와 바이트를 변환 &lt;em&gt;콘텐츠 전송 인코딩을&lt;/em&gt; . 즉, 비 ASCII &lt;em&gt;컨텐츠 전송 인코딩&lt;/em&gt; ( &lt;em&gt;컨텐츠 전송 인코딩 : 8 비트&lt;/em&gt; )이있는 파트를 ASCII 호환 &lt;em&gt;컨텐츠 전송 인코딩으로 변환하십시오.&lt;/em&gt;MIME &lt;code&gt;unknown-8bit&lt;/code&gt; 문자 집합을 사용하여 헤더에서 RFC 유효하지 않은 비 ASCII 바이트를 인코딩 하여 RFC 호환으로 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="2c701b67912c6e3c4a20fa3bedd65247e3914281" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; option &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;8bit&lt;/code&gt;, generate the message as if the option were set to &lt;code&gt;7bit&lt;/code&gt;. (This is required because strings cannot represent non-ASCII bytes.) Convert any bytes with the high bit set as needed using an ASCII-compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;. That is, transform parts with non-ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; (&lt;em&gt;Content-Transfer-Encoding: 8bit&lt;/em&gt;) to an ASCII compatible &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt;, and encode RFC-invalid non-ASCII bytes in headers using the MIME &lt;code&gt;unknown-8bit&lt;/code&gt; character set, thus rendering them RFC-compliant.</source>
          <target state="translated">는 IF &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 옵션 &lt;a href=&quot;email.policy#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 이&lt;/a&gt; 입니다 &lt;code&gt;8bit&lt;/code&gt; 옵션으로 설정된 것처럼 메시지를 생성하는 &lt;code&gt;7bit&lt;/code&gt; . 문자열은 비 ASCII 바이트를 나타낼 수 없기 때문에 필요합니다. ASCII 호환 &lt;em&gt;Content-Transfer-Encoding을&lt;/em&gt; 사용하여 필요에 따라 높은 비트 세트의 바이트를 변환하십시오 . 즉, 비 ASCII &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; ( &lt;em&gt;Content-Transfer-Encoding : 8bit&lt;/em&gt; )이있는 파트를 ASCII 호환 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 으로 변환하고 MIME &lt;code&gt;unknown-8bit&lt;/code&gt; 를 사용하여 헤더에서 RFC 유효하지 않은 비 ASCII 바이트를 인코딩하십시오. 문자 세트를 사용하여 RFC를 준수합니다.</target>
        </trans-unit>
        <trans-unit id="4257dc89794becc22be3811003a5f35196f494f3" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt; of the class&amp;rsquo; metaclass is present, it will take precedence over the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__class_getitem__&quot;&gt;&lt;code&gt;__class_getitem__()&lt;/code&gt;&lt;/a&gt; defined in the class (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0560&quot; id=&quot;index-54&quot;&gt;&lt;strong&gt;PEP 560&lt;/strong&gt;&lt;/a&gt; for more details).</source>
          <target state="translated">클래스의 메타 클래스 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 이 있으면 클래스에 정의 된 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__class_getitem__&quot;&gt; &lt;code&gt;__class_getitem__()&lt;/code&gt; &lt;/a&gt; 보다 우선합니다 ( 자세한 내용 은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0560&quot; id=&quot;index-54&quot;&gt;&lt;strong&gt;PEP 560&lt;/strong&gt;&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="6705ff167ef2a10be922c82015337dad5632886f" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module is loaded, input will automatically inherit &lt;strong&gt;bash&lt;/strong&gt;-like history-list editing (e.g.</source>
          <target state="translated">는 IF &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈이로드, 입력이 자동으로 상속됩니다 &lt;strong&gt;bash는&lt;/strong&gt; 역사 목록 -like 편집 (예 :</target>
        </trans-unit>
        <trans-unit id="992e16a7eb0c65f78ed4d6b22ea21a69e69f88d9" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module was loaded, then &lt;a href=&quot;#input&quot;&gt;&lt;code&gt;input()&lt;/code&gt;&lt;/a&gt; will use it to provide elaborate line editing and history features.</source>
          <target state="translated">는 IF &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈이로드 한 후 &lt;a href=&quot;#input&quot;&gt; &lt;code&gt;input()&lt;/code&gt; &lt;/a&gt; 정교한 라인 편집과 역사 기능을 제공하는 데 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7f400827c02071e6ef95ee0237e542f0c4ec14fd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;.mo&lt;/code&gt; file&amp;rsquo;s magic number is invalid, the major version number is unexpected, or if other problems occur while reading the file, instantiating a &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt; class can raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;.mo&lt;/code&gt; 의 파일의 매직 번호가 유효하지 않은 인스턴스 파일을 읽는 동안 다른 문제가 발생하면, 주 버전 번호는 예상치 못한, 또는 &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; 에&lt;/a&gt; 올릴 수 클래스를 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="210a0037ce73d1bfc67ee4b4b5e95490df8f8b6b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;INSERT&lt;/code&gt; or &lt;code&gt;REPLACE&lt;/code&gt; statement failed to insert the previous successful rowid is returned.</source>
          <target state="translated">는 IF &lt;code&gt;INSERT&lt;/code&gt; 또는 &lt;code&gt;REPLACE&lt;/code&gt; 문이 이전에 성공한 ROWID를 삽입하는 데 실패 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf74d5b2f54438d18ff96c889c2efdf40add3ab4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;__cleanenv&lt;/code&gt; keyword is set, &lt;em&gt;env_vars&lt;/em&gt; is used as a fresh environment.</source>
          <target state="translated">는 IF &lt;code&gt;__cleanenv&lt;/code&gt; 의 키워드를 설정, &lt;em&gt;env_vars는&lt;/em&gt; 새로운 환경으로 사용된다.</target>
        </trans-unit>
        <trans-unit id="7797779c313c0745d10542dc3e51baa071288853" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;binary_form&lt;/code&gt; parameter is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, and a certificate was received from the peer, this method returns a &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; instance. If the certificate was not validated, the dict is empty. If the certificate was validated, it returns a dict with several keys, amongst them &lt;code&gt;subject&lt;/code&gt; (the principal for which the certificate was issued) and &lt;code&gt;issuer&lt;/code&gt; (the principal issuing the certificate). If a certificate contains an instance of the &lt;em&gt;Subject Alternative Name&lt;/em&gt; extension (see &lt;a href=&quot;https://tools.ietf.org/html/rfc3280.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 3280&lt;/strong&gt;&lt;/a&gt;), there will also be a &lt;code&gt;subjectAltName&lt;/code&gt; key in the dictionary.</source>
          <target state="translated">는 IF &lt;code&gt;binary_form&lt;/code&gt; 의 매개 변수가 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; , 그리고 인증서가 피어로부터받은이 방법은 반환 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 인스턴스를. 인증서의 유효성이 검사되지 않으면 dict가 비어 있습니다. 인증서의 유효성이 검증 된 경우 &lt;code&gt;subject&lt;/code&gt; (인증서가 발행 된 주체 )와 &lt;code&gt;issuer&lt;/code&gt; ( 인증서가 발행 된 주체) 사이에 여러 키가 포함 된 dict를 리턴합니다 . 인증서에 &lt;em&gt;주체 대체 이름&lt;/em&gt; 확장 의 인스턴스가 포함 된 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3280.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 3280&lt;/strong&gt;&lt;/a&gt; 참조 ) 사전에 &lt;code&gt;subjectAltName&lt;/code&gt; 키 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2e0d519216a7d9523337363e10594cf657eace6" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;binary_form&lt;/code&gt; parameter is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, and a certificate was provided, this method returns the DER-encoded form of the entire certificate as a sequence of bytes, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the peer did not provide a certificate. Whether the peer provides a certificate depends on the SSL socket&amp;rsquo;s role:</source>
          <target state="translated">는 IF &lt;code&gt;binary_form&lt;/code&gt; 의 매개 변수가 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; , 그리고 인증서가 제공되었다,이 메소드 리턴한다 바이트 순서, 또는 전체 인증서의 DER로 인코딩 된 형태 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 피어 인증서를 제공하지 않은 경우. 피어가 인증서를 제공하는지 여부는 SSL 소켓의 역할에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7602209fb479da231610b89b7e98c9ce4312d1b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;default&lt;/code&gt; value is a string, the parser parses the value as if it were a command-line argument. In particular, the parser applies any &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; conversion argument, if provided, before setting the attribute on the &lt;a href=&quot;#argparse.Namespace&quot;&gt;&lt;code&gt;Namespace&lt;/code&gt;&lt;/a&gt; return value. Otherwise, the parser uses the value as is:</source>
          <target state="translated">경우 &lt;code&gt;default&lt;/code&gt; 값이 문자열은 명령 줄 인수 것처럼, 파서는 값을 구문 분석합니다. 특히 구문 분석기는 &lt;a href=&quot;#argparse.Namespace&quot;&gt; &lt;code&gt;Namespace&lt;/code&gt; &lt;/a&gt; 리턴 값 에 속성을 설정하기 전에 제공된 경우 모든 &lt;a href=&quot;#type&quot;&gt;유형&lt;/a&gt; 변환 인수를 적용합니다 . 그렇지 않으면 파서는 값을 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="524a418bcb1a0b57bbd955c0618848eef7130b81" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;errcheck&lt;/code&gt; function returns the argument tuple it receives unchanged, &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; continues the normal processing it does on the output parameters. If you want to return a tuple of window coordinates instead of a &lt;code&gt;RECT&lt;/code&gt; instance, you can retrieve the fields in the function and return them instead, the normal processing will no longer take place:</source>
          <target state="translated">경우] &lt;code&gt;errcheck&lt;/code&gt; 의 것이 그대로 수신 튜플 함수는 인수를 반환 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 상기 출력 파라미터는 않는 통상의 처리를 계속한다. &lt;code&gt;RECT&lt;/code&gt; 인스턴스 대신 창 좌표의 튜플을 반환하려는 경우 함수에서 필드를 검색하여 대신 반환 할 수 있으며, 일반적인 처리는 더 이상 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf2573a0870de1e1acad81d1f5302762db9e30a1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;fcntl()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">는 IF &lt;code&gt;fcntl()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed678ab7c2a7ff6be9a99eeaf17a3ebf9fd3c1d0" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;flock()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우] &lt;code&gt;flock()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="a7eec3c89612e0c25a2a5977559eba7c168d3900" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;freeze_support()&lt;/code&gt; line is omitted then trying to run the frozen executable will raise &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;freeze_support()&lt;/code&gt; 라인이 생략 된 후 올릴 냉동 실행 실행하려고 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed2522d782a9625d0947133482aaae29a6c466db" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;ioctl()&lt;/code&gt; fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">경우] &lt;code&gt;ioctl()&lt;/code&gt; 실패 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="0cc2fbe72c3b4ad145fe3964a92c94ac6062f4e1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;maintype&lt;/code&gt; is &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;; otherwise look up a handler function based on the type of &lt;em&gt;obj&lt;/em&gt; (see next paragraph), call &lt;a href=&quot;email.message#email.message.EmailMessage.clear_content&quot;&gt;&lt;code&gt;clear_content()&lt;/code&gt;&lt;/a&gt; on the &lt;em&gt;msg&lt;/em&gt;, and call the handler function, passing through all arguments. The expectation is that the handler will transform and store &lt;em&gt;obj&lt;/em&gt; into &lt;em&gt;msg&lt;/em&gt;, possibly making other changes to &lt;em&gt;msg&lt;/em&gt; as well, such as adding various MIME headers to encode information needed to interpret the stored data.</source>
          <target state="translated">경우 &lt;code&gt;maintype&lt;/code&gt; 가 있다 &lt;code&gt;multipart&lt;/code&gt; , 인상 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 &lt;em&gt;obj&lt;/em&gt; 유형에 따라 핸들러 함수를 찾고 (다음 단락 참조 &lt;a href=&quot;email.message#email.message.EmailMessage.clear_content&quot;&gt; &lt;code&gt;clear_content()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; msg&lt;/em&gt; 에서 clear_content () 를 호출하고 모든 인수를 통해 핸들러 함수를 호출하십시오. 핸들러는 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;msg&lt;/em&gt; 로 변환하고 저장 하여 저장된 데이터를 해석하는 데 필요한 정보를 인코딩하기 위해 다양한 MIME 헤더를 추가하는 등 &lt;em&gt;msg에&lt;/em&gt; 대한 다른 변경도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="01aab64feb734e15541a9ef45d407a359bd7163d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nargs&lt;/code&gt; keyword argument is not provided, the number of arguments consumed is determined by the &lt;a href=&quot;#action&quot;&gt;action&lt;/a&gt;. Generally this means a single command-line argument will be consumed and a single item (not a list) will be produced.</source>
          <target state="translated">는 IF &lt;code&gt;nargs&lt;/code&gt; 키워드 인수가 제공되지 않는 인수의 수에 의해 결정됩니다 소비 &lt;a href=&quot;#action&quot;&gt;행동&lt;/a&gt; . 일반적으로 이는 단일 명령 줄 인수가 사용되고 단일 항목 (목록이 아님)이 생성됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d61c61e67464c67c3680c4713d3809692520d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;policy&lt;/code&gt; defines certain headers to be unique (as the standard policies do), this method may raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when an attempt is made to assign a value to such a header when one already exists. This behavior is intentional for consistency&amp;rsquo;s sake, but do not depend on it as we may choose to make such assignments do an automatic deletion of the existing header in the future.</source>
          <target state="translated">는 IF &lt;code&gt;policy&lt;/code&gt; (표준 정책처럼) 특정 헤더를 고유하게 정의하고,이 방법은 제기 할 수 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를을&lt;/a&gt; 시도가 이미있는 경우 이러한 헤더에 값을 할당하려고 할 때. 이 동작은 일관성을 위해 의도적 인 것이지만, 이러한 할당이 향후 기존 헤더를 자동으로 삭제하도록 선택할 수 있으므로 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b0c4b939b714d8d4621edf9c00758ce14c62b46" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;allow_fragments&lt;/em&gt; argument is false, fragment identifiers are not recognized. Instead, they are parsed as part of the path, parameters or query component, and &lt;code&gt;fragment&lt;/code&gt; is set to the empty string in the return value.</source>
          <target state="translated">는 IF &lt;em&gt;allow_fragments의&lt;/em&gt; 인수가 false, 조각 식별자는 인식되지 않습니다. 대신 경로, 매개 변수 또는 쿼리 구성 요소의 일부로 파싱되고 &lt;code&gt;fragment&lt;/code&gt; 은 반환 값에서 빈 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="07fd1d70e19aeb308ff95aa96b168f877108f2f2" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;data&lt;/em&gt; elements are not comparable, the data can be wrapped in a class that ignores the data item and only compares the priority number:</source>
          <target state="translated">상기 중간 &lt;em&gt;데이터&lt;/em&gt; 요소를 비교하지 않은 데이터는 상기 데이터 항목을 무시하고 우선 순위 번호를 비교하는 클래스로 래핑 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="2ff12e160cec1aee3fa846e0341806c3c002aa1b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;decode_data&lt;/em&gt; constructor keyword is set to &lt;code&gt;True&lt;/code&gt;, the &lt;em&gt;data&lt;/em&gt; argument will be a unicode string. If it is set to &lt;code&gt;False&lt;/code&gt;, it will be a bytes object.</source>
          <target state="translated">는 IF &lt;em&gt;decode_data&lt;/em&gt; 생성자 키워드로 설정되어 &lt;code&gt;True&lt;/code&gt; 의 &lt;em&gt;데이터&lt;/em&gt; 인수는 유니 코드 문자열입니다. &lt;code&gt;False&lt;/code&gt; 로 설정되면 bytes 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="b6fd4d95e538d8f47be51a60097509c8d1f0049b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;globals&lt;/em&gt; dictionary does not contain a value for the key &lt;code&gt;__builtins__&lt;/code&gt;, a reference to the dictionary of the built-in module &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; is inserted under that key. That way you can control what builtins are available to the executed code by inserting your own &lt;code&gt;__builtins__&lt;/code&gt; dictionary into &lt;em&gt;globals&lt;/em&gt; before passing it to &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우] &lt;em&gt;전역의&lt;/em&gt; 딕셔너리는 키 값을 포함하지 않는 &lt;code&gt;__builtins__&lt;/code&gt; , 내장 모듈의 사전 참조 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 해당 키에 삽입된다. 그렇게하면 자신의 &lt;code&gt;__builtins__&lt;/code&gt; 사전을 &lt;em&gt;전역&lt;/em&gt; 에 삽입하여 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 전달 함으로써 실행 된 코드에서 사용 가능한 내장을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="069dacc3747df8898ad29dd490b8b3d318fd8df1" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;lock&lt;/em&gt; argument is given and not &lt;code&gt;None&lt;/code&gt;, it must be a &lt;a href=&quot;#threading.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object, and it is used as the underlying lock. Otherwise, a new &lt;a href=&quot;#threading.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; object is created and used as the underlying lock.</source>
          <target state="translated">경우 &lt;em&gt;잠금&lt;/em&gt; 인수가 주어지지되지 않고 &lt;code&gt;None&lt;/code&gt; , 그것은해야 &lt;a href=&quot;#threading.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체, 그것은 기본 잠금 장치로 사용됩니다. 그렇지 않으면 새 &lt;a href=&quot;#threading.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; &lt;/a&gt; 객체가 만들어져 기본 잠금으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b6ebb4583fd8191695e04b7d39b1f581cf29da7" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;name&lt;/em&gt; argument is provided and not &lt;code&gt;None&lt;/code&gt;, it is set as the name of the task using &lt;a href=&quot;asyncio-task#asyncio.Task.set_name&quot;&gt;&lt;code&gt;Task.set_name()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수가 제공되고 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;a href=&quot;asyncio-task#asyncio.Task.set_name&quot;&gt; &lt;code&gt;Task.set_name()&lt;/code&gt; &lt;/a&gt; 사용하여 작업의 이름으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="944dd20e7d4a05557cec3a977a23d9d4d3f2d8ce" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;names&lt;/em&gt; parameter is given, it must be a sequence containing the names of functions you want to install in the builtins namespace in addition to &lt;code&gt;_()&lt;/code&gt;. Supported names are &lt;code&gt;'gettext'&lt;/code&gt;, &lt;code&gt;'ngettext'&lt;/code&gt;, &lt;code&gt;'pgettext'&lt;/code&gt;, &lt;code&gt;'npgettext'&lt;/code&gt;, &lt;code&gt;'lgettext'&lt;/code&gt;, and &lt;code&gt;'lngettext'&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;em&gt;이름&lt;/em&gt; 매개 변수가 제공되어, 당신이뿐만 아니라 내장 매크로 이름 공간에 설치하려는 함수의 이름을 포함하는 순서해야합니다 &lt;code&gt;_()&lt;/code&gt; . 지원되는 이름은 &lt;code&gt;'gettext'&lt;/code&gt; , &lt;code&gt;'ngettext'&lt;/code&gt; , &lt;code&gt;'pgettext'&lt;/code&gt; , &lt;code&gt;'npgettext'&lt;/code&gt; , &lt;code&gt;'lgettext'&lt;/code&gt; 및 &lt;code&gt;'lngettext'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="158a36858ed9af1b9e9c3d28c384cc021e46769c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;optimize&lt;/em&gt; parameter to &lt;a href=&quot;#zipfile.PyZipFile&quot;&gt;&lt;code&gt;PyZipFile&lt;/code&gt;&lt;/a&gt; was &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;, only files with that optimization level (see &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;) are added to the archive, compiling if necessary.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile&quot;&gt; &lt;code&gt;PyZipFile&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;optimize&lt;/em&gt; 매개 변수 가 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;1&lt;/code&gt; 또는 &lt;code&gt;2&lt;/code&gt; 이면 해당 최적화 레벨 ( &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 참조)을 가진 파일 만 아카이브에 추가되어 필요한 경우 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="7d5c62ff88707e4df1f101083878379244687d02" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;optimize&lt;/em&gt; parameter to &lt;a href=&quot;#zipfile.PyZipFile&quot;&gt;&lt;code&gt;PyZipFile&lt;/code&gt;&lt;/a&gt; was not given or &lt;code&gt;-1&lt;/code&gt;, the corresponding file is a &lt;code&gt;*.pyc&lt;/code&gt; file, compiling if necessary.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile&quot;&gt; &lt;code&gt;PyZipFile&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;em&gt;optimize&lt;/em&gt; 매개 변수 가 제공되지 않거나 &lt;code&gt;-1&lt;/code&gt; 이면 해당 파일은 &lt;code&gt;*.pyc&lt;/code&gt; 파일이며 필요한 경우 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="c7cdfc5e325d7266ce128da3b51f1e8b3f9943d8" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;password&lt;/em&gt; argument is not specified and a password is required, OpenSSL&amp;rsquo;s built-in password prompting mechanism will be used to interactively prompt the user for a password.</source>
          <target state="translated">경우 &lt;em&gt;암호&lt;/em&gt; 인수가 지정되지 않고 암호가 필요합니다, OpenSSL이 내장 된 암호 프롬프트 메커니즘은 암호를 대화 형 프롬프트 사용자에게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="35fcb585a20584b556f4e162e5309c98983b0178" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;path&lt;/em&gt; is a string object (directly or indirectly through a &lt;a href=&quot;#os.PathLike&quot;&gt;&lt;code&gt;PathLike&lt;/code&gt;&lt;/a&gt; interface), the result will also be a string object, and the call may raise a UnicodeDecodeError. If the &lt;em&gt;path&lt;/em&gt; is a bytes object (direct or indirectly), the result will be a bytes object.</source>
          <target state="translated">상기 중간 &lt;em&gt;경로&lt;/em&gt; 캐릭터 오브젝트 (직접 또는 간접적 통해 &lt;a href=&quot;#os.PathLike&quot;&gt; &lt;code&gt;PathLike&lt;/code&gt; 의&lt;/a&gt; 인터페이스), 결과는 문자열 오브젝트 것이고, 통화는 UnicodeDecodeError을 올릴 수있다. 상기 중간 &lt;em&gt;경로&lt;/em&gt; (직접 또는 간접적으로) bytes 객체이며, 그 결과는 개체를 바이트 일 것이다.</target>
        </trans-unit>
        <trans-unit id="8c9066b80c3d8a541423631fefca4e57b368ec7b" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;prompt&lt;/em&gt; argument is present, it is written to standard output without a trailing newline. The function then reads a line from input, converts it to a string (stripping a trailing newline), and returns that. When EOF is read, &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; is raised. Example:</source>
          <target state="translated">경우 &lt;em&gt;프롬프트&lt;/em&gt; 인수가 존재하고, 그것은 뒤에 줄 바꿈하지 않고 표준 출력에 기록됩니다. 그런 다음 함수는 입력에서 행을 읽고 문자열로 변환하여 (마지막 줄 바꿈), 반환합니다. EOF를 읽으면 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 예:</target>
        </trans-unit>
        <trans-unit id="93285696a22411d5d2e8a7f6363aa84855969bd3" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;resetids&lt;/em&gt; argument is &lt;code&gt;True&lt;/code&gt; it will reset the effective UID and GID of the child to the real UID and GID of the parent process. If the argument is &lt;code&gt;False&lt;/code&gt;, then the child retains the effective UID and GID of the parent. In either case, if the set-user-ID and set-group-ID permission bits are enabled on the executable file, their effect will override the setting of the effective UID and GID. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_RESETIDS&lt;/code&gt; flag.</source>
          <target state="translated">는 IF &lt;em&gt;resetids의&lt;/em&gt; 인수가 &lt;code&gt;True&lt;/code&gt; 은 부모 프로세스의 실제 UID와 GID에 아이의 유효 UID와 GID를 재설정합니다. 인수가 &lt;code&gt;False&lt;/code&gt; 인 경우 자식은 부모의 유효 UID 및 GID를 유지합니다. 두 경우 모두, 실행 파일에서 set-user-ID 및 set-group-ID 권한 비트가 활성화 된 경우 유효 UID 및 GID 설정이 무시됩니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_RESETIDS&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="88919bba2afc8f184e2a327acf142c1486867e0d" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;setsid&lt;/em&gt; argument is &lt;code&gt;True&lt;/code&gt;, it will create a new session ID for &lt;code&gt;posix_spawn&lt;/code&gt;. &lt;em&gt;setsid&lt;/em&gt; requires &lt;code&gt;POSIX_SPAWN_SETSID&lt;/code&gt; or &lt;code&gt;POSIX_SPAWN_SETSID_NP&lt;/code&gt; flag. Otherwise, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">는 IF &lt;em&gt;setsid&lt;/em&gt; 인수가 &lt;code&gt;True&lt;/code&gt; , 그것은을위한 새로운 세션 ID 생성합니다 &lt;code&gt;posix_spawn&lt;/code&gt; . &lt;em&gt;setsid&lt;/em&gt; 에는 &lt;code&gt;POSIX_SPAWN_SETSID&lt;/code&gt; 또는 &lt;code&gt;POSIX_SPAWN_SETSID_NP&lt;/code&gt; 플래그 가 필요합니다 . 그렇지 않으면 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d24ec0d17c1f7e1a0a329ec520394941ae2b010" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stderr&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a readable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. Reading from the stream provides error output from the child process. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stderr&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;열려진&lt;/em&gt; 인수였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 판독 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 스트림에서 읽기는 하위 프로세스에서 오류 출력을 제공합니다. 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 오류의&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e6be0106d84be33c234e54aaea99852564b5e3c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stdin&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a writeable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stdin&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;표준 입력&lt;/em&gt; 인자였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 쓰기 가능한 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 입력&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec355cf89b9dc73b02f80f0df2eaf169cc492684" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;stdout&lt;/em&gt; argument was &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is a readable stream object as returned by &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;. Reading from the stream provides output from the child process. If the &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; arguments were specified or the &lt;em&gt;universal_newlines&lt;/em&gt; argument was &lt;code&gt;True&lt;/code&gt;, the stream is a text stream, otherwise it is a byte stream. If the &lt;em&gt;stdout&lt;/em&gt; argument was not &lt;a href=&quot;#subprocess.PIPE&quot;&gt;&lt;code&gt;PIPE&lt;/code&gt;&lt;/a&gt;, this attribute is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;em&gt;표준 출력의&lt;/em&gt; 인수였다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 특성에 의해 반환 판독 스트림 목적 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; . 스트림에서 읽기는 하위 프로세스의 출력을 제공합니다. 경우 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 인수가 지정하거나 한 &lt;em&gt;universal_newlines의&lt;/em&gt; 인수가 있었다 &lt;code&gt;True&lt;/code&gt; , 스트림, 그렇지 않으면 바이트 스트림, 텍스트 스트림입니다. 경우 &lt;em&gt;표준 출력의&lt;/em&gt; 인수가 아니었다 &lt;a href=&quot;#subprocess.PIPE&quot;&gt; &lt;code&gt;PIPE&lt;/code&gt; &lt;/a&gt; ,이 속성은 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60dd2e899bc85f2db36a0109aa802d1a7f4ce7a0" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;url&lt;/em&gt; uses the &lt;code&gt;http:&lt;/code&gt; scheme identifier, the optional &lt;em&gt;data&lt;/em&gt; argument may be given to specify a &lt;code&gt;POST&lt;/code&gt; request (normally the request type is &lt;code&gt;GET&lt;/code&gt;). The &lt;em&gt;data&lt;/em&gt; argument must be a bytes object in standard &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt; format; see the &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 용도 &lt;code&gt;http:&lt;/code&gt; 체계 식별자를, 선택적인 &lt;em&gt;데이터&lt;/em&gt; 인수가 지정받을 수 있습니다 &lt;code&gt;POST&lt;/code&gt; 의 요청 (일반적으로 요청 유형이다 &lt;code&gt;GET&lt;/code&gt; ). &lt;em&gt;데이터&lt;/em&gt; 인수 표준 bytes 객체 여야 &lt;em&gt;을 application / x-www-form-urlencoded 된&lt;/em&gt; 형태; &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="294c59bd568e04803a80acb61e134333ab0b073c" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;url&lt;/em&gt; uses the &lt;code&gt;http:&lt;/code&gt; scheme identifier, the optional &lt;em&gt;data&lt;/em&gt; argument may be given to specify a &lt;code&gt;POST&lt;/code&gt; request (normally the request type is &lt;code&gt;GET&lt;/code&gt;). The &lt;em&gt;data&lt;/em&gt; argument must in standard &lt;em&gt;application/x-www-form-urlencoded&lt;/em&gt; format; see the &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt;&lt;code&gt;urllib.parse.urlencode()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">경우 &lt;em&gt;URL이&lt;/em&gt; 용도 &lt;code&gt;http:&lt;/code&gt; 체계 식별자를, 선택적인 &lt;em&gt;데이터&lt;/em&gt; 인수가 지정받을 수 있습니다 &lt;code&gt;POST&lt;/code&gt; 의 요청 (일반적으로 요청 유형이다 &lt;code&gt;GET&lt;/code&gt; ). &lt;em&gt;데이터&lt;/em&gt; 표준 인자 필수 &lt;em&gt;어플리케이션 / x-www-form-urlencoded를&lt;/em&gt; 포맷; &lt;a href=&quot;urllib.parse#urllib.parse.urlencode&quot;&gt; &lt;code&gt;urllib.parse.urlencode()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9974f7a3aebe3f3ce47175d7359b29d02772cfa6" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;utc&lt;/em&gt; argument is true, times in UTC will be used; otherwise local time is used.</source>
          <target state="translated">경우 &lt;em&gt;UTC&lt;/em&gt; 인수가 true, UTC에서 시간이 사용됩니다; 그렇지 않으면 현지 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b84602b7fa18863b22e6dbcff32969883dda4684" translate="yes" xml:space="preserve">
          <source>If the &lt;em&gt;writeback&lt;/em&gt; parameter is &lt;code&gt;True&lt;/code&gt;, the object will hold a cache of all entries accessed and write them back to the &lt;em&gt;dict&lt;/em&gt; at sync and close times. This allows natural operations on mutable entries, but can consume much more memory and make sync and close take a long time.</source>
          <target state="translated">는 IF &lt;em&gt;쓰기 저장&lt;/em&gt; 매개 변수가 &lt;code&gt;True&lt;/code&gt; 오브젝트 액세스 모든 항목의 캐시를 잡고 다시에 기록됩니다 &lt;em&gt;DICT&lt;/em&gt; 동기화 및 가까운 시간에. 이를 통해 변경 가능한 항목에 대한 자연스러운 작업이 가능하지만 훨씬 더 많은 메모리를 소비하고 동기화 및 닫기에 오랜 시간이 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c144dbd6eb2a2ec5c9464d6a3b5b49fd560d35b3" translate="yes" xml:space="preserve">
          <source>If the &lt;strong&gt;parse&lt;/strong&gt; attribute is omitted, it defaults to &amp;ldquo;xml&amp;rdquo;. The href attribute is required.</source>
          <target state="translated">는 IF &lt;strong&gt;구문 분석&lt;/strong&gt; 속성은 &quot;XML&quot;에, 기본값을 생략하기로한다. href 속성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="651912b3d40236c9ca01d4f642c00c2265e6c0e1" translate="yes" xml:space="preserve">
          <source>If the Future has been &lt;em&gt;cancelled&lt;/em&gt;, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future가 &lt;em&gt;취소 된 경우&lt;/em&gt; ,이 메소드는 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="6620141bffb844ff7e0a325c37437088a6fc0bb4" translate="yes" xml:space="preserve">
          <source>If the Future is &lt;em&gt;done&lt;/em&gt; and has a result set by the &lt;a href=&quot;#asyncio.Future.set_result&quot;&gt;&lt;code&gt;set_result()&lt;/code&gt;&lt;/a&gt; method, the result value is returned.</source>
          <target state="translated">Future가 &lt;em&gt;수행&lt;/em&gt; 되고 &lt;a href=&quot;#asyncio.Future.set_result&quot;&gt; &lt;code&gt;set_result()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 결과가 설정 되면 결과 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e0644b75daac5e15661852c684cb262de9f51c89" translate="yes" xml:space="preserve">
          <source>If the Future is &lt;em&gt;done&lt;/em&gt; and has an exception set by the &lt;a href=&quot;#asyncio.Future.set_exception&quot;&gt;&lt;code&gt;set_exception()&lt;/code&gt;&lt;/a&gt; method, this method raises the exception.</source>
          <target state="translated">Future가 &lt;em&gt;수행&lt;/em&gt; 되고 &lt;a href=&quot;#asyncio.Future.set_exception&quot;&gt; &lt;code&gt;set_exception()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 설정된 예외가있는 경우이 메소드는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1195f6304df98cd2d3bc86ac4e83f5d2f868771a" translate="yes" xml:space="preserve">
          <source>If the Future is already &lt;em&gt;done&lt;/em&gt; or &lt;em&gt;cancelled&lt;/em&gt;, return &lt;code&gt;False&lt;/code&gt;. Otherwise, change the Future&amp;rsquo;s state to &lt;em&gt;cancelled&lt;/em&gt;, schedule the callbacks, and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">미래가 이미 &lt;em&gt;완료&lt;/em&gt; 또는 &lt;em&gt;취소 된&lt;/em&gt; 경우 &lt;code&gt;False&lt;/code&gt; 를 반환하십시오 . 그렇지 않으면 Future 상태를 &lt;em&gt;canceled로&lt;/em&gt; 변경하고 콜백을 예약 한 다음 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="37006e9f079c3accc6d5f6040b789291ba917d94" translate="yes" xml:space="preserve">
          <source>If the Future is already &lt;em&gt;done&lt;/em&gt; when this method is called, the callback is scheduled with &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 메소드가 호출 될 때 Future가 이미 &lt;em&gt;완료된&lt;/em&gt; 경우 콜백은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 예약됩니다 .</target>
        </trans-unit>
        <trans-unit id="cb914681d6d5d5b08170de81c66e21d60e415ba0" translate="yes" xml:space="preserve">
          <source>If the Future isn&amp;rsquo;t &lt;em&gt;done&lt;/em&gt; yet, this method raises an &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future가 아직 &lt;em&gt;완료&lt;/em&gt; 되지 않은 경우,이 메소드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="81ccf8aacb015ef04d4641484c8369a9b1dc7178" translate="yes" xml:space="preserve">
          <source>If the Future&amp;rsquo;s result isn&amp;rsquo;t yet available, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">Future의 결과를 아직 사용할 수없는 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="2b7f6762700d8fee47524d6de578cf0f5d964de0" translate="yes" xml:space="preserve">
          <source>If the IPv4 address string passed to this function is invalid, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised. Note that exactly what is valid depends on the underlying C implementation of &lt;code&gt;inet_aton()&lt;/code&gt;.</source>
          <target state="translated">이 함수에 전달 된 IPv4 주소 문자열이 유효하지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 정확히 유효한 것은 &lt;code&gt;inet_aton()&lt;/code&gt; 의 기본 C 구현에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="560fe43f47d62379a66ce9688e16e4014a73fc5a" translate="yes" xml:space="preserve">
          <source>If the Python installation has SSL support (i.e., if the &lt;a href=&quot;ssl#module-ssl&quot;&gt;&lt;code&gt;ssl&lt;/code&gt;&lt;/a&gt; module can be imported), &lt;a href=&quot;#urllib.request.HTTPSHandler&quot;&gt;&lt;code&gt;HTTPSHandler&lt;/code&gt;&lt;/a&gt; will also be added.</source>
          <target state="translated">Python 설치에 SSL 지원이있는 경우 (예 : &lt;a href=&quot;ssl#module-ssl&quot;&gt; &lt;code&gt;ssl&lt;/code&gt; &lt;/a&gt; 모듈을 가져올 수있는 경우 ) &lt;a href=&quot;#urllib.request.HTTPSHandler&quot;&gt; &lt;code&gt;HTTPSHandler&lt;/code&gt; &lt;/a&gt; 도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3ea0b3ed7f3baf4db7002928837be7003ffe5eb0" translate="yes" xml:space="preserve">
          <source>If the SIGINT signal generated by</source>
          <target state="translated">SIGINT 신호가</target>
        </trans-unit>
        <trans-unit id="ca9dca35c700b2a4f039a704ed976b0b70c0a61f" translate="yes" xml:space="preserve">
          <source>If the Task has been &lt;em&gt;cancelled&lt;/em&gt;, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업이 &lt;em&gt;취소 된&lt;/em&gt; 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="de231fa26bffd71d36d4fadee99f70cdd007208c" translate="yes" xml:space="preserve">
          <source>If the Task is &lt;em&gt;done&lt;/em&gt;, the result of the wrapped coroutine is returned (or if the coroutine raised an exception, that exception is re-raised.)</source>
          <target state="translated">태스크가 &lt;em&gt;완료&lt;/em&gt; 되면 랩핑 된 코 루틴의 결과가 리턴됩니다 (또는 코 루틴이 예외를 발생시킨 경우 해당 예외가 다시 발생합니다).</target>
        </trans-unit>
        <trans-unit id="c6606fc1940874e65aa19f560ba1745a72e10a6e" translate="yes" xml:space="preserve">
          <source>If the Task isn&amp;rsquo;t &lt;em&gt;done&lt;/em&gt; yet, this method raises an &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업이 아직 &lt;em&gt;완료&lt;/em&gt; 되지 않은 경우이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1dc46f1d10f9c96a479d508e9267096933ed6fa6" translate="yes" xml:space="preserve">
          <source>If the Task&amp;rsquo;s result isn&amp;rsquo;t yet available, this method raises a &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt;&lt;code&gt;InvalidStateError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">작업 결과를 아직 사용할 수 없으면이 메서드는 &lt;a href=&quot;asyncio-exceptions#asyncio.InvalidStateError&quot;&gt; &lt;code&gt;InvalidStateError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="0d2428fdf8b60d8010dea0a01f7c47a9ea2e0739" translate="yes" xml:space="preserve">
          <source>If the XML input has &lt;a href=&quot;https://en.wikipedia.org/wiki/XML_namespace&quot;&gt;namespaces&lt;/a&gt;, tags and attributes with prefixes in the form &lt;code&gt;prefix:sometag&lt;/code&gt; get expanded to &lt;code&gt;{uri}sometag&lt;/code&gt; where the &lt;em&gt;prefix&lt;/em&gt; is replaced by the full &lt;em&gt;URI&lt;/em&gt;. Also, if there is a &lt;a href=&quot;https://www.w3.org/TR/xml-names/#defaulting&quot;&gt;default namespace&lt;/a&gt;, that full URI gets prepended to all of the non-prefixed tags.</source>
          <target state="translated">XML 입력에 &lt;a href=&quot;https://en.wikipedia.org/wiki/XML_namespace&quot;&gt;네임 스페이스&lt;/a&gt; 가 있는 경우 &lt;code&gt;prefix:sometag&lt;/code&gt; 양식의 &lt;em&gt;접 &lt;/em&gt;&lt;em&gt;두부&lt;/em&gt; 가 있는 태그 및 속성은 &lt;code&gt;{uri}sometag&lt;/code&gt; 로 확장되며 &lt;em&gt;접 &lt;/em&gt;&lt;em&gt;두부&lt;/em&gt; 가 전체 &lt;em&gt;URI&lt;/em&gt; 로 대체됩니다 . 또한 &lt;a href=&quot;https://www.w3.org/TR/xml-names/#defaulting&quot;&gt;기본 네임 스페이스&lt;/a&gt; 가 있으면 해당 전체 URI가 접두사가없는 모든 태그 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1035788874be82f93e34090a34131ddf3cbc5486" translate="yes" xml:space="preserve">
          <source>If the amount of data read exceeds the configured stream limit, a &lt;a href=&quot;asyncio-exceptions#asyncio.LimitOverrunError&quot;&gt;&lt;code&gt;LimitOverrunError&lt;/code&gt;&lt;/a&gt; exception is raised, and the data is left in the internal buffer and can be read again.</source>
          <target state="translated">읽은 데이터 양이 구성된 스트림 제한을 초과하면 &lt;a href=&quot;asyncio-exceptions#asyncio.LimitOverrunError&quot;&gt; &lt;code&gt;LimitOverrunError&lt;/code&gt; &lt;/a&gt; 예외가 발생하고 데이터가 내부 버퍼에 남아 있으며 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b49e74988c341dbee66d98c70300f05b412e8ad" translate="yes" xml:space="preserve">
          <source>If the application knows the character encoding of the byte stream, it should set it with the setEncoding method.</source>
          <target state="translated">응용 프로그램이 바이트 스트림의 문자 인코딩을 알고 있으면 setEncoding 메소드로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fa82cef5f28606b6fd2a9d2c0bbbdbbb88b6591" translate="yes" xml:space="preserve">
          <source>If the argument &lt;em&gt;alter_sys&lt;/em&gt; is supplied and evaluates to &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;sys.argv[0]&lt;/code&gt; is updated with the value of &lt;code&gt;__file__&lt;/code&gt; and &lt;code&gt;sys.modules[__name__]&lt;/code&gt; is updated with a temporary module object for the module being executed. Both &lt;code&gt;sys.argv[0]&lt;/code&gt; and &lt;code&gt;sys.modules[__name__]&lt;/code&gt; are restored to their original values before the function returns.</source>
          <target state="translated">인수 경우 &lt;em&gt;alter_sys가&lt;/em&gt; 공급되고, 평가되고 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 다음 &lt;code&gt;sys.argv[0]&lt;/code&gt; 의 값으로 갱신된다 &lt;code&gt;__file__&lt;/code&gt; 및 &lt;code&gt;sys.modules[__name__]&lt;/code&gt; 모듈이 실행되는 임시 모듈 오브젝트로 갱신된다. 두 &lt;code&gt;sys.argv[0]&lt;/code&gt; 및 &lt;code&gt;sys.modules[__name__]&lt;/code&gt; 함수 반환되기 전에 원래의 값으로 복원된다.</target>
        </trans-unit>
        <trans-unit id="a5411ed7af975d74d9bde61eea8619af34a7725c" translate="yes" xml:space="preserve">
          <source>If the argument is a &lt;a href=&quot;asyncio-task#coroutine&quot;&gt;coroutine object&lt;/a&gt; it is implicitly scheduled to run as a &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;asyncio.Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수가 &lt;a href=&quot;asyncio-task#coroutine&quot;&gt;코 루틴 오브젝트 인&lt;/a&gt; 경우 암시 적으로 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;asyncio.Task&lt;/code&gt; &lt;/a&gt; 로 실행되도록 스케줄됩니다 .</target>
        </trans-unit>
        <trans-unit id="81ba162b85ef412221638aff281d53793a7875ce" translate="yes" xml:space="preserve">
          <source>If the argument is a string, it should contain a decimal number, optionally preceded by a sign, and optionally embedded in whitespace. The optional sign may be &lt;code&gt;'+'&lt;/code&gt; or &lt;code&gt;'-'&lt;/code&gt;; a &lt;code&gt;'+'&lt;/code&gt; sign has no effect on the value produced. The argument may also be a string representing a NaN (not-a-number), or a positive or negative infinity. More precisely, the input must conform to the following grammar after leading and trailing whitespace characters are removed:</source>
          <target state="translated">인수가 문자열 인 경우 10 진수를 포함해야하며 선택적으로 부호가 앞에오고 선택적으로 공백에 포함됩니다. 선택적 부호는 &lt;code&gt;'+'&lt;/code&gt; 또는 &lt;code&gt;'-'&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;'+'&lt;/code&gt; 기호가 생성되는 값에 영향을주지 않습니다. 인수는 NaN (숫자가 아님)을 나타내는 문자열이거나 양수 또는 음수 무한대 일 수도 있습니다. 더 정확하게 말하면 선행 및 후행 공백 문자가 제거 된 후 입력은 다음 문법을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="e0bf4582d5afa94925ba1fb86d35299839904863" translate="yes" xml:space="preserve">
          <source>If the argument is positive, and the underlying raw stream is not interactive, multiple raw reads may be issued to satisfy the byte count (unless EOF is reached first). But for interactive raw streams, at most one raw read will be issued, and a short result does not imply that EOF is imminent.</source>
          <target state="translated">인수가 양수이고 기본 원시 스트림이 대화식이 아닌 경우 바이트 수를 만족시키기 위해 여러 원시 읽기가 발행 될 수 있습니다 (EOF에 먼저 도달하지 않은 경우). 그러나 대화식 원시 스트림의 경우 최대 하나의 원시 읽기가 발행되며 짧은 결과가 EOF가 임박했음을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bf5c155da4b8b4fe57abec8d0c0e72c648a413c5" translate="yes" xml:space="preserve">
          <source>If the argument to the closure is not an existing directory, &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">클로저에 대한 인수가 기존 디렉토리가 아닌 경우 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e34bdcceb6034130f11958c3ceb8f25313fc52d" translate="yes" xml:space="preserve">
          <source>If the attempt to make the socket connection fails, Idle will notify you. Such failures are sometimes transient, but if persistent, the problem may be either a firewall blocking the connection or misconfiguration of a particular system. Until the problem is fixed, one can run Idle with the -n command line switch.</source>
          <target state="translated">소켓 연결 시도가 실패하면 유휴 상태가 표시됩니다. 이러한 장애는 때때로 일시적이지만, 지속되는 경우 문제는 방화벽이 연결을 차단하거나 특정 시스템의 구성이 잘못되었을 수 있습니다. 문제가 해결 될 때까지 -n 명령 행 스위치를 사용하여 유휴를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a14d9ea3ec7e959887154398109ffeb0809f131" translate="yes" xml:space="preserve">
          <source>If the binary data ends with the &lt;em&gt;suffix&lt;/em&gt; string and that &lt;em&gt;suffix&lt;/em&gt; is not empty, return &lt;code&gt;bytes[:-len(suffix)]&lt;/code&gt;. Otherwise, return a copy of the original binary data:</source>
          <target state="translated">이진 데이터가 &lt;em&gt;접미사&lt;/em&gt; 문자열로 끝나고 해당 &lt;em&gt;접미사&lt;/em&gt; 가 비어 있지 않으면 &lt;code&gt;bytes[:-len(suffix)]&lt;/code&gt; 반환 합니다 . 그렇지 않으면 원본 바이너리 데이터의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6a461ee183aff7f6ef68fb8f009900420db64dbe" translate="yes" xml:space="preserve">
          <source>If the binary data starts with the &lt;em&gt;prefix&lt;/em&gt; string, return &lt;code&gt;bytes[len(prefix):]&lt;/code&gt;. Otherwise, return a copy of the original binary data:</source>
          <target state="translated">이진 데이터가 &lt;em&gt;접두사&lt;/em&gt; 문자열로 시작하면 &lt;code&gt;bytes[len(prefix):]&lt;/code&gt; 반환 합니다 . 그렇지 않으면 원본 바이너리 데이터의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5376fd70393bce3b2627873412a2a120086e43a7" translate="yes" xml:space="preserve">
          <source>If the buffer is too short then a &lt;code&gt;BufferTooShort&lt;/code&gt; exception is raised and the complete message is available as &lt;code&gt;e.args[0]&lt;/code&gt; where &lt;code&gt;e&lt;/code&gt; is the exception instance.</source>
          <target state="translated">버퍼가 너무 짧으면 &lt;code&gt;BufferTooShort&lt;/code&gt; 예외가 발생하고 전체 메시지를 &lt;code&gt;e.args[0]&lt;/code&gt; 으로 사용할 수 있습니다 . 여기서 &lt;code&gt;e&lt;/code&gt; 는 예외 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b55ba6cd680fc7c446defa1148be7f603a8c347a" translate="yes" xml:space="preserve">
          <source>If the buffer size equals the high watermark, &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;pause_writing()&lt;/code&gt;&lt;/a&gt; is not called: the buffer size must go strictly over.</source>
          <target state="translated">버퍼 크기가 높은 워터 마크와 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;pause_writing()&lt;/code&gt; &lt;/a&gt; 이 호출되지 않습니다. 버퍼 크기는 엄격하게 넘어 가야합니다.</target>
        </trans-unit>
        <trans-unit id="c975333ddfdaa3bf375713fbe96ca6198feddace" translate="yes" xml:space="preserve">
          <source>If the byte sequence passed to this function is not exactly 4 bytes in length, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised. &lt;a href=&quot;#socket.inet_ntoa&quot;&gt;&lt;code&gt;inet_ntoa()&lt;/code&gt;&lt;/a&gt; does not support IPv6, and &lt;a href=&quot;#socket.inet_ntop&quot;&gt;&lt;code&gt;inet_ntop()&lt;/code&gt;&lt;/a&gt; should be used instead for IPv4/v6 dual stack support.</source>
          <target state="translated">이 함수에 전달 된 바이트 시퀀스의 길이가 정확히 4 바이트가 아닌 경우 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;a href=&quot;#socket.inet_ntoa&quot;&gt; &lt;code&gt;inet_ntoa()&lt;/code&gt; &lt;/a&gt; 는 IPv6을 지원하지 않으며 IPv4 / v6 이중 스택 지원에는 &lt;a href=&quot;#socket.inet_ntop&quot;&gt; &lt;code&gt;inet_ntop()&lt;/code&gt; &lt;/a&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4080aabef6f9144e191027041093c739d2c1b3bd" translate="yes" xml:space="preserve">
          <source>If the call completed without raising, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">전화를 올리지 않고 완료하면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f83b4efd6f712f456500a47232013459d991539c" translate="yes" xml:space="preserve">
          <source>If the call raised, this method will raise the same exception.</source>
          <target state="translated">호출이 발생하면이 메소드는 동일한 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="98c6607719d86226a4951bc27faa2632178e9837" translate="yes" xml:space="preserve">
          <source>If the call times out, the barrier is put into the broken state.</source>
          <target state="translated">호출 시간이 초과되면 장벽이 끊어진 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="34c6962c614477a6094fef9f3349e26138a51253" translate="yes" xml:space="preserve">
          <source>If the calling task has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 메소드가 호출 될 때 호출 태스크가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8100a6b6af3438279c1efdd3048e83262e4a542c" translate="yes" xml:space="preserve">
          <source>If the character set must be encoded before it can be used in an email header, this attribute will be set to &lt;code&gt;Charset.QP&lt;/code&gt; (for quoted-printable), &lt;code&gt;Charset.BASE64&lt;/code&gt; (for base64 encoding), or &lt;code&gt;Charset.SHORTEST&lt;/code&gt; for the shortest of QP or BASE64 encoding. Otherwise, it will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문자 세트를 이메일 헤더에 사용하기 전에 인코딩해야하는 경우이 속성은 &lt;code&gt;Charset.QP&lt;/code&gt; (따옴표로 인쇄 가능), &lt;code&gt;Charset.BASE64&lt;/code&gt; (base64 인코딩) 또는 &lt;code&gt;Charset.SHORTEST&lt;/code&gt; ( 가장 짧은 것)로 설정됩니다 . QP 또는 BASE64 인코딩 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="6e8caac2adb6bf9423fea6039c1be36f8bc7d75e" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5173bdebec1086940c7a8a6c5f27b3d81d48ed3a" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8cb1399398df7c668ff6210d8b504532d3b5fe53" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 이미 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5945c15a8568d448fdb75e585a76c1b4841617db" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="320b0db4c9292986c143110a9901c88cf4b081b4" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8523a502465aa7a7af85ffbc4a99e870d9713c23" translate="yes" xml:space="preserve">
          <source>If the class already defines &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt;, this parameter is ignored.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; 정의한 경우이 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e40f424d0a60fa1524e20d8b1ff8a462f2310e" translate="yes" xml:space="preserve">
          <source>If the class already defines any of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; 중 하나를 정의하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5e877c2db467eb6d0727341a6964f7d1ce158c0c" translate="yes" xml:space="preserve">
          <source>If the class already defines any of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;, then &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">클래스가 이미 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; 중 하나를 정의하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="18d54afc52e2190ab5698bf62a007d327a0d9532" translate="yes" xml:space="preserve">
          <source>If the class is instantiated multiple times you could use &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; to return a new mock each time. Alternatively you can set the &lt;em&gt;return_value&lt;/em&gt; to be anything you want.</source>
          <target state="translated">클래스가 여러 번 인스턴스화되면 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 사용하여 매번 새 모의를 반환 할 수 있습니다 . 또는 &lt;em&gt;return_value&lt;/em&gt; 를 원하는 것으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0844b2f1f4f28f1d3c7e82725d649a65558d8346" translate="yes" xml:space="preserve">
          <source>If the cmd argument to popen2 functions is a string, the command is executed through /bin/sh. If it is a list, the command is directly executed.</source>
          <target state="translated">popen2 함수에 대한 cmd 인수가 문자열이면 / bin / sh를 통해 명령이 실행됩니다. 목록 인 경우 명령이 직접 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0b487b3fa1bfe238daee50939a9f3547d743abdb" translate="yes" xml:space="preserve">
          <source>If the code has a jump target and &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;#dis.stack_effect&quot;&gt;&lt;code&gt;stack_effect()&lt;/code&gt;&lt;/a&gt; will return the stack effect of jumping. If &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, it will return the stack effect of not jumping. And if &lt;em&gt;jump&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (default), it will return the maximal stack effect of both cases.</source>
          <target state="translated">코드에 점프 대상이 있고 &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;#dis.stack_effect&quot;&gt; &lt;code&gt;stack_effect()&lt;/code&gt; &lt;/a&gt; 는 점프의 스택 효과를 반환합니다. &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 이면 &lt;em&gt;점프&lt;/em&gt; 하지 않는 스택 효과를 반환합니다. 그리고 &lt;em&gt;jump&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 두 경우의 최대 스택 효과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4f49dfb1d7b288c0f309278b39f37d05e88304b1" translate="yes" xml:space="preserve">
          <source>If the configuration value specified by &lt;em&gt;name&lt;/em&gt; isn&amp;rsquo;t defined, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;em&gt;name&lt;/em&gt; 으로 지정된 구성 값 이 정의되지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0290d581f118be47fbc672209c5237cf2ee347a" translate="yes" xml:space="preserve">
          <source>If the connection is interrupted by a signal, the method waits until the connection completes, or raise a &lt;a href=&quot;#socket.timeout&quot;&gt;&lt;code&gt;socket.timeout&lt;/code&gt;&lt;/a&gt; on timeout, if the signal handler doesn&amp;rsquo;t raise an exception and the socket is blocking or has a timeout. For non-blocking sockets, the method raises an &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt; exception if the connection is interrupted by a signal (or the exception raised by the signal handler).</source>
          <target state="translated">신호에 의해 연결이 중단 된 경우 신호 처리기가 예외를 발생시키지 않고 소켓이 차단되거나 시간 초과 된 경우 연결이 완료 될 때까지 대기하거나 시간 &lt;a href=&quot;#socket.timeout&quot;&gt; &lt;code&gt;socket.timeout&lt;/code&gt; &lt;/a&gt; 을 발생시킵니다. 비 블로킹 소켓의 경우,이 메소드 는 연결이 신호 (또는 신호 처리기에서 발생한 예외)에 의해 중단되면 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="1ccfc1df4a51fc69641651224aae9f0339a11398" translate="yes" xml:space="preserve">
          <source>If the connection to the server is lost while waiting for the reply, &lt;a href=&quot;#smtplib.SMTPServerDisconnected&quot;&gt;&lt;code&gt;SMTPServerDisconnected&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">응답을 기다리는 동안 서버와의 연결이 끊어지면 &lt;a href=&quot;#smtplib.SMTPServerDisconnected&quot;&gt; &lt;code&gt;SMTPServerDisconnected&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ad155938abd6bd816f11164daa5559b5b6f8335" translate="yes" xml:space="preserve">
          <source>If the containing toplevel&amp;rsquo;s position was specified relative to the right or bottom of the screen (e.g. &amp;hellip;.), the &lt;code&gt;Sizegrip&lt;/code&gt; widget will not resize the window.</source>
          <target state="translated">포함하는 최상위 레벨의 위치가 화면의 오른쪽 또는 아래쪽을 기준으로 지정된 경우 (예 :&amp;hellip;.) &lt;code&gt;Sizegrip&lt;/code&gt; 위젯은 창 크기를 조정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43dd941fcd2c8ec7d6f5b3b06bac3aa6c32162ba" translate="yes" xml:space="preserve">
          <source>If the context&amp;rsquo;s trap enabler is set for the signal, then the condition causes a Python exception to be raised. For example, if the &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; trap is set, then a &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt; exception is raised upon encountering the condition.</source>
          <target state="translated">컨텍스트의 트랩 인 에이 블러가 신호에 대해 설정된 경우이 조건으로 인해 Python 예외가 발생합니다. 예를 들어, &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 트랩이 설정된 경우 조건이 발생 하면 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22595aef4892c0871cfe75e3e28f828bb007ef0c" translate="yes" xml:space="preserve">
          <source>If the converter needs to access the state of the parser, it can be implemented as a method on a config parser subclass. If the name of this method starts with &lt;code&gt;get&lt;/code&gt;, it will be available on all section proxies, in the dict-compatible form (see the &lt;code&gt;getdecimal()&lt;/code&gt; example above).</source>
          <target state="translated">변환기가 구문 분석기의 상태에 액세스해야하는 경우 구성 구문 분석기 서브 클래스에서 메소드로 구현 될 수 있습니다. 이 메소드의 이름이 &lt;code&gt;get&lt;/code&gt; 로 시작 하면 모든 섹션 프록시에서 dict 호환 형식으로 사용할 수 있습니다 &lt;code&gt;getdecimal()&lt;/code&gt; 위 의 getdecimal () 예제 참조).</target>
        </trans-unit>
        <trans-unit id="8b3d3dc34b0d0bf1c8c7d4897bc704963dd23f37" translate="yes" xml:space="preserve">
          <source>If the cursor is over an output line, squeeze all the output between the code above and the prompt below down to a &amp;lsquo;Squeezed text&amp;rsquo; label.</source>
          <target state="translated">커서가 출력 행 위에 있으면 위 코드와 아래 프롬프트 사이의 모든 출력을 '압착 된 텍스트'레이블로 꽉 쥐십시오.</target>
        </trans-unit>
        <trans-unit id="a84ed8f0fda6ec2ae9ca1bc860b4c3906be5fb5d" translate="yes" xml:space="preserve">
          <source>If the data being deserialized is not a valid JSON document, a &lt;a href=&quot;#json.JSONDecodeError&quot;&gt;&lt;code&gt;JSONDecodeError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">직렬화 해제중인 데이터가 유효한 JSON 문서가 아닌 경우 &lt;a href=&quot;#json.JSONDecodeError&quot;&gt; &lt;code&gt;JSONDecodeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="722e3f031b5abfe9b3484e64e6d2902f708fa4b0" translate="yes" xml:space="preserve">
          <source>If the data is ordinal (supports order operations) but not numeric (doesn&amp;rsquo;t support addition), consider using &lt;a href=&quot;#statistics.median_low&quot;&gt;&lt;code&gt;median_low()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#statistics.median_high&quot;&gt;&lt;code&gt;median_high()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">데이터가 순 &lt;a href=&quot;#statistics.median_low&quot;&gt; &lt;code&gt;median_low()&lt;/code&gt; &lt;/a&gt; 순서 연산 지원)이지만 숫자가 아닌 (더하기를 지원하지 않는) 경우 median_low () 또는 &lt;a href=&quot;#statistics.median_high&quot;&gt; &lt;code&gt;median_high()&lt;/code&gt; &lt;/a&gt; 대신 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="154822805c12d2aab70f1b641202eb990335ef91" translate="yes" xml:space="preserve">
          <source>If the database file already exists, the &lt;a href=&quot;#dbm.whichdb&quot;&gt;&lt;code&gt;whichdb()&lt;/code&gt;&lt;/a&gt; function is used to determine its type and the appropriate module is used; if it does not exist, the first module listed above that can be imported is used.</source>
          <target state="translated">데이터베이스 파일이 이미 존재하면 &lt;a href=&quot;#dbm.whichdb&quot;&gt; &lt;code&gt;whichdb()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 유형을 판별하고 적절한 모듈이 사용됩니다. 존재하지 않으면 위에 나열된 첫 번째 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b118369699b7fc02d2c91e666ca503503b584356" translate="yes" xml:space="preserve">
          <source>If the debugger should stop at this exception, invokes the &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt;&lt;code&gt;user_exception()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt;&lt;code&gt;user_exception()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 예외에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt; &lt;code&gt;user_exception()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_exception&quot;&gt; &lt;code&gt;user_exception()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="d65f4eae2712c33680ab9efbc1f19062565841d8" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on the current line, invoke the &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt;&lt;code&gt;user_line()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt;&lt;code&gt;user_line()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가 현재 행에서 중지되어야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt; &lt;code&gt;user_line()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_line&quot;&gt; &lt;code&gt;user_line()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f1c7df4d0adf08d6f3c7e84cf0ae146dc6be7d64" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on this function call, invoke the &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt;&lt;code&gt;user_call()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt;&lt;code&gt;user_call()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 함수 호출에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt; &lt;code&gt;user_call()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_call&quot;&gt; &lt;code&gt;user_call()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="be5272f439cf1bb932bed5ba2fa9705c6449082c" translate="yes" xml:space="preserve">
          <source>If the debugger should stop on this function return, invoke the &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt;&lt;code&gt;user_return()&lt;/code&gt;&lt;/a&gt; method (which should be overridden in subclasses). Raise a &lt;a href=&quot;#bdb.BdbQuit&quot;&gt;&lt;code&gt;BdbQuit&lt;/code&gt;&lt;/a&gt; exception if the &lt;code&gt;Bdb.quitting&lt;/code&gt; flag is set (which can be set from &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt;&lt;code&gt;user_return()&lt;/code&gt;&lt;/a&gt;). Return a reference to the &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt;&lt;code&gt;trace_dispatch()&lt;/code&gt;&lt;/a&gt; method for further tracing in that scope.</source>
          <target state="translated">디버거가이 함수 리턴에서 중지해야하는 경우 &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt; &lt;code&gt;user_return()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 ( 서브 클래스에서 대체되어야 함). 인상 &lt;a href=&quot;#bdb.BdbQuit&quot;&gt; &lt;code&gt;BdbQuit&lt;/code&gt; 의&lt;/a&gt; 경우 생성 예외 &lt;code&gt;Bdb.quitting&lt;/code&gt; 의 플래그가 설정 (설정 될 수 &lt;a href=&quot;#bdb.Bdb.user_return&quot;&gt; &lt;code&gt;user_return()&lt;/code&gt; &lt;/a&gt; ). 해당 범위에서 추가 추적을 위해 &lt;a href=&quot;#bdb.Bdb.trace_dispatch&quot;&gt; &lt;code&gt;trace_dispatch()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 참조를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="201fc8099c1ec49d0ede598d1afe842c5aadcbab" translate="yes" xml:space="preserve">
          <source>If the default value of a field is specified by a call to &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt;, then the class attribute for this field will be replaced by the specified &lt;code&gt;default&lt;/code&gt; value. If no &lt;code&gt;default&lt;/code&gt; is provided, then the class attribute will be deleted. The intent is that after the &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator runs, the class attributes will all contain the default values for the fields, just as if the default value itself were specified. For example, after:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 호출하여 필드의 &lt;code&gt;default&lt;/code&gt; 지정하면이 필드의 클래스 속성이 지정된 기본값 으로 바뀝니다 . &lt;code&gt;default&lt;/code&gt; 이 제공 되지 않으면 클래스 속성이 삭제됩니다. 의도는 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 데코레이터가 실행 된 후 , 기본값 자체가 지정된 것처럼 클래스 속성이 모두 필드의 기본값을 포함한다는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5ae4681cafc2df817b63559ac73e2e01d8b7ddf0" translate="yes" xml:space="preserve">
          <source>If the destination is an existing directory, then &lt;em&gt;src&lt;/em&gt; is moved inside that directory. If the destination already exists but is not a directory, it may be overwritten depending on &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; semantics.</source>
          <target state="translated">대상이 기존 디렉토리 인 경우 &lt;em&gt;src&lt;/em&gt; 는 해당 디렉토리 내로 이동합니다. 대상이 이미 존재하지만 디렉토리가 아닌 경우 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 의미 에 따라 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90a483529ef380acfabb4df595aa7f9eedaacd18" translate="yes" xml:space="preserve">
          <source>If the destination is on the current filesystem, then &lt;a href=&quot;os#os.rename&quot;&gt;&lt;code&gt;os.rename()&lt;/code&gt;&lt;/a&gt; is used. Otherwise, &lt;em&gt;src&lt;/em&gt; is copied to &lt;em&gt;dst&lt;/em&gt; using &lt;em&gt;copy_function&lt;/em&gt; and then removed. In case of symlinks, a new symlink pointing to the target of &lt;em&gt;src&lt;/em&gt; will be created in or as &lt;em&gt;dst&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; will be removed.</source>
          <target state="translated">대상이 현재 파일 시스템에 있으면 &lt;a href=&quot;os#os.rename&quot;&gt; &lt;code&gt;os.rename()&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 그렇지 않으면, &lt;em&gt;src&lt;/em&gt; 는 &lt;em&gt;copy_function을&lt;/em&gt; 사용하여 &lt;em&gt;dst에&lt;/em&gt; 복사 된 후 제거됩니다. 심볼릭 링크의 경우, &lt;em&gt;src&lt;/em&gt; 대상을 가리키는 새로운 심볼릭 링크 가 &lt;em&gt;dst에&lt;/em&gt; 생성되거나 &lt;em&gt;dst&lt;/em&gt; 와 &lt;em&gt;src&lt;/em&gt; 가 제거됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e7f148091df358050d8bcfaf1e96d8acba5a8a3d" translate="yes" xml:space="preserve">
          <source>If the directory already exists, &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">디렉토리가 이미 존재하면 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f4bf018015908f2a980d2821276c417e78ee5737" translate="yes" xml:space="preserve">
          <source>If the directory contains files starting with &lt;code&gt;.&lt;/code&gt; they won&amp;rsquo;t be matched by default. For example, consider a directory containing &lt;code&gt;card.gif&lt;/code&gt; and &lt;code&gt;.card.gif&lt;/code&gt;:</source>
          <target state="translated">디렉토리로 시작하는 파일에 포함되어있는 경우 &lt;code&gt;.&lt;/code&gt; 기본적으로 일치하지 않습니다. 예를 들어, &lt;code&gt;card.gif&lt;/code&gt; 및 &lt;code&gt;.card.gif&lt;/code&gt; 를 포함하는 디렉토리를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ced573f72ad49106a583ae064c2db74e18bb9c9" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code id=&quot;index-0&quot;&gt;BROWSER&lt;/code&gt; exists, it is interpreted as the &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;-separated list of browsers to try ahead of the platform defaults. When the value of a list part contains the string &lt;code&gt;%s&lt;/code&gt;, then it is interpreted as a literal browser command line to be used with the argument URL substituted for &lt;code&gt;%s&lt;/code&gt;; if the part does not contain &lt;code&gt;%s&lt;/code&gt;, it is simply interpreted as the name of the browser to launch. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">환경 변수 &lt;code id=&quot;index-0&quot;&gt;BROWSER&lt;/code&gt; 가 존재하면 이는 플랫폼 기본값보다 먼저 시도하기 위해 &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; 로 구분 된&lt;/a&gt; 브라우저 목록으로 해석됩니다 . 목록 부분의 값에 문자열 &lt;code&gt;%s&lt;/code&gt; 가 포함 된 경우 &lt;code&gt;%s&lt;/code&gt; 대신 인수 URL과 함께 사용되는 리터럴 브라우저 명령 행으로 해석됩니다 . 부품에 &lt;code&gt;%s&lt;/code&gt; 가 포함되어 있지 않으면 단순히 시작할 브라우저의 이름으로 해석됩니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4992ba0add3e62936beba1abed0141fdfe5937a4" translate="yes" xml:space="preserve">
          <source>If the environment variable &lt;code&gt;REQUEST_METHOD&lt;/code&gt; is set, which usually indicates your script is running in a CGI environment, the environment variable &lt;code&gt;HTTP_PROXY&lt;/code&gt; (uppercase &lt;code&gt;_PROXY&lt;/code&gt;) will be ignored. This is because that variable can be injected by a client using the &amp;ldquo;Proxy:&amp;rdquo; HTTP header. If you need to use an HTTP proxy in a CGI environment, either use &lt;code&gt;ProxyHandler&lt;/code&gt; explicitly, or make sure the variable name is in lowercase (or at least the &lt;code&gt;_proxy&lt;/code&gt; suffix).</source>
          <target state="translated">스크립트가 CGI 환경에서 실행 중임을 나타내는 환경 변수 &lt;code&gt;REQUEST_METHOD&lt;/code&gt; 가 설정되면 환경 변수 &lt;code&gt;HTTP_PROXY&lt;/code&gt; (대문자 &lt;code&gt;_PROXY&lt;/code&gt; )가 무시됩니다. 이는 클라이언트가&amp;ldquo;Proxy :&amp;rdquo;HTTP 헤더를 사용하여 해당 변수를 주입 할 수 있기 때문입니다. CGI 환경에서 HTTP 프록시를 사용해야하는 경우 &lt;code&gt;ProxyHandler&lt;/code&gt; 를 명시 적으로 사용 하거나 변수 이름이 소문자 (또는 &lt;code&gt;_proxy&lt;/code&gt; 접미어 이상)인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="733c3f8ae616712998ec582c7dc9418f60036c61" translate="yes" xml:space="preserve">
          <source>If the event is set, return &lt;code&gt;True&lt;/code&gt; immediately. Otherwise block until another task calls &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이벤트가 설정되면 즉시 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 그렇지 않으면 다른 작업이 &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 호출 할 때까지 차단하십시오 .</target>
        </trans-unit>
        <trans-unit id="378c9e1cdfb8344fd77c512889f953f89cb90508" translate="yes" xml:space="preserve">
          <source>If the exact value is unimportant you can use &lt;a href=&quot;#enum.auto&quot;&gt;&lt;code&gt;auto&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정확한 값이 중요하지 않은 경우 &lt;a href=&quot;#enum.auto&quot;&gt; &lt;code&gt;auto&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="80196981eb3b8cd3185224864fb45d685edece2b" translate="yes" xml:space="preserve">
          <source>If the expansion fails or if the path does not begin with a tilde, the path is returned unchanged.</source>
          <target state="translated">확장이 실패하거나 경로가 물결표로 시작하지 않으면 경로는 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="25581f556094bf0f7a3af63df730aedc4bbc5af1" translate="yes" xml:space="preserve">
          <source>If the exponent of the second operand is larger than that of the first then rounding may be necessary. In this case, the rounding mode is determined by the &lt;code&gt;rounding&lt;/code&gt; argument if given, else by the given &lt;code&gt;context&lt;/code&gt; argument; if neither argument is given the rounding mode of the current thread&amp;rsquo;s context is used.</source>
          <target state="translated">두 번째 피연산자의 지수가 첫 번째 피연산자의 지수보다 크면 반올림이 필요할 수 있습니다. 이 경우 반올림 모드는 &lt;code&gt;rounding&lt;/code&gt; 인수에 의해 결정되며 , 그렇지 않으면 주어진 &lt;code&gt;context&lt;/code&gt; 인수에 의해 결정됩니다 . 인수에 현재 스레드 컨텍스트의 반올림 모드가 제공되지 않은 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f40d8b7c76b10f8d6afc27ed43238ec343c52d0a" translate="yes" xml:space="preserve">
          <source>If the fast-copy operation fails and no data was written in the destination file then shutil will silently fallback on using less efficient &lt;a href=&quot;#shutil.copyfileobj&quot;&gt;&lt;code&gt;copyfileobj()&lt;/code&gt;&lt;/a&gt; function internally.</source>
          <target state="translated">빠른 복사 작업이 실패하고 대상 파일에 데이터가 기록되지 않은 경우 shutil은 내부적으로 덜 효율적인 &lt;a href=&quot;#shutil.copyfileobj&quot;&gt; &lt;code&gt;copyfileobj()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 자동으로 폴백됩니다 .</target>
        </trans-unit>
        <trans-unit id="7904f5dd4c3c1ff4fa7eecbfcee0078bf02fe590" translate="yes" xml:space="preserve">
          <source>If the file descriptor is not connected to a terminal, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">파일 디스크립터가 터미널에 연결되어 있지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="204d5c0bddce0bad70b8e8384a949257afd035f7" translate="yes" xml:space="preserve">
          <source>If the file is created with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt; and then &lt;a href=&quot;#zipfile.ZipFile.close&quot;&gt;&lt;code&gt;closed&lt;/code&gt;&lt;/a&gt; without adding any files to the archive, the appropriate ZIP structures for an empty archive will be written to the file.</source>
          <target state="translated">파일이 &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 작성된 후 파일을 아카이브에 추가하지 않고 &lt;a href=&quot;#zipfile.ZipFile.close&quot;&gt; &lt;code&gt;closed&lt;/code&gt; &lt;/a&gt; 빈 아카이브에 대한 적절한 ZIP 구조가 파일에 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="e0b3807f55b2bb553078d84e9b4f290c46390447" translate="yes" xml:space="preserve">
          <source>If the first character is not one of these, &lt;code&gt;'@'&lt;/code&gt; is assumed.</source>
          <target state="translated">첫 번째 문자가 이들 중 하나가 아닌 경우 &lt;code&gt;'@'&lt;/code&gt; 이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="ecd2158e2f17566a6c9110f348c8d34a00d129fc" translate="yes" xml:space="preserve">
          <source>If the first character of the option string is &lt;code&gt;'+'&lt;/code&gt;, or if the environment variable &lt;code id=&quot;index-0&quot;&gt;POSIXLY_CORRECT&lt;/code&gt; is set, then option processing stops as soon as a non-option argument is encountered.</source>
          <target state="translated">옵션 문자열의 첫 문자가 &lt;code&gt;'+'&lt;/code&gt; 이거나 환경 변수 &lt;code id=&quot;index-0&quot;&gt;POSIXLY_CORRECT&lt;/code&gt; 가 설정된 경우 비 옵션 인수가 발생하자마자 옵션 처리가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="c76146671826ba2b4412a62fe7631ca797af78d5" translate="yes" xml:space="preserve">
          <source>If the floating-point &lt;em&gt;timeout&lt;/em&gt; argument is present and positive, it specifies the maximum wait time in seconds before returning. A negative &lt;em&gt;timeout&lt;/em&gt; argument specifies an unbounded wait. You cannot specify a &lt;em&gt;timeout&lt;/em&gt; if &lt;em&gt;waitflag&lt;/em&gt; is zero.</source>
          <target state="translated">부동 소수점 &lt;em&gt;시간 종료&lt;/em&gt; 인수가 존재하고 양수인 경우 리턴하기 전에 최대 대기 시간 (초)을 지정합니다. 음의 &lt;em&gt;시간 초과&lt;/em&gt; 인수는 무제한 대기를 지정합니다. &lt;em&gt;waitflag&lt;/em&gt; 가 0 이면 &lt;em&gt;시간 종료를&lt;/em&gt; 지정할 수 없습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="71f137ca45f1f4315df5ce3a53742f74127f3689" translate="yes" xml:space="preserve">
          <source>If the function also supports &lt;em&gt;dir_fd&lt;/em&gt; or &lt;em&gt;follow_symlinks&lt;/em&gt; arguments, it&amp;rsquo;s an error to specify one of those when supplying &lt;em&gt;path&lt;/em&gt; as a file descriptor.</source>
          <target state="translated">함수가 &lt;em&gt;dir_fd&lt;/em&gt; 또는 &lt;em&gt;follow_symlinks&lt;/em&gt; 인수 도 지원 하는 경우 &lt;em&gt;경로&lt;/em&gt; 를 파일 디스크립터로 제공 할 때 이들 중 하나를 지정하는 것은 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="9e255e0f89d3c1037cfd2af8f07b7a7b9b651a55" translate="yes" xml:space="preserve">
          <source>If the function fails, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">기능이 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5356d77e205569cd60b75101b731b99c07bcf65d" translate="yes" xml:space="preserve">
          <source>If the future has already completed or been cancelled, &lt;em&gt;fn&lt;/em&gt; will be called immediately.</source>
          <target state="translated">미래가 이미 완료되었거나 취소 된 경우 &lt;em&gt;fn&lt;/em&gt; 이 즉시 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="d7602bbb5410a8b437816b287f32e8aba7e81abc" translate="yes" xml:space="preserve">
          <source>If the future is cancelled before completing then &lt;a href=&quot;#concurrent.futures.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">완료하기 전에 미래가 취소되면 &lt;a href=&quot;#concurrent.futures.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22d45851562f9f10333edeb0961c986bb8146cb1" translate="yes" xml:space="preserve">
          <source>If the given &lt;em&gt;section&lt;/em&gt; exists, and contains the given &lt;em&gt;option&lt;/em&gt;, return &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;; otherwise return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. If the specified &lt;em&gt;section&lt;/em&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; or an empty string, DEFAULT is assumed.</source>
          <target state="translated">주어진 &lt;em&gt;섹션&lt;/em&gt; 이 존재하고 주어진 &lt;em&gt;옵션이&lt;/em&gt; 포함되어 있으면 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 그렇지 않으면 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환 합니다. 지정된 &lt;em&gt;섹션&lt;/em&gt; 이 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이거나 빈 문자열이면 DEFAULT로 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="1285768fc63d1e86280e3cad6887bc85265a423a" translate="yes" xml:space="preserve">
          <source>If the given encoding is not known, the function defaults to the default encoding for the locale code just like &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 인코딩이 알려지지 않은 경우, 함수는 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 과 같이 로케일 코드의 기본 인코딩으로 기본 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="5e03a404aa9f2043079442bcf94d4ec5e79efc91" translate="yes" xml:space="preserve">
          <source>If the given section exists, set the given option to the specified value; otherwise raise &lt;a href=&quot;#configparser.NoSectionError&quot;&gt;&lt;code&gt;NoSectionError&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;option&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; must be strings; if not, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">주어진 섹션이 존재하면 주어진 옵션을 지정된 값으로 설정하십시오. 그렇지 않으면 &lt;a href=&quot;#configparser.NoSectionError&quot;&gt; &lt;code&gt;NoSectionError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . &lt;em&gt;옵션&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 은 문자열이어야합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1402525cf09cdaaddadb10846e26316cab80e378" translate="yes" xml:space="preserve">
          <source>If the given section exists, set the given option to the specified value; otherwise raise &lt;a href=&quot;#configparser.NoSectionError&quot;&gt;&lt;code&gt;NoSectionError&lt;/code&gt;&lt;/a&gt;. While it is possible to use &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt;&lt;code&gt;RawConfigParser&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; with &lt;em&gt;raw&lt;/em&gt; parameters set to true) for &lt;em&gt;internal&lt;/em&gt; storage of non-string values, full functionality (including interpolation and output to files) can only be achieved using string values.</source>
          <target state="translated">주어진 섹션이 존재하면 주어진 옵션을 지정된 값으로 설정하십시오. 그렇지 않으면 &lt;a href=&quot;#configparser.NoSectionError&quot;&gt; &lt;code&gt;NoSectionError&lt;/code&gt; 를 발생시킵니다&lt;/a&gt; . 그것이 가능하지만 사용 &lt;a href=&quot;#configparser.RawConfigParser&quot;&gt; &lt;code&gt;RawConfigParser&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; 를&lt;/a&gt; 가진 &lt;em&gt;원료&lt;/em&gt; 를 true로 설정된 파라미터) &lt;em&gt;의 내부&lt;/em&gt; 문자열이 아닌 값 (파일 출력 보간을 포함한) 전체 기능만을 저장 문자열 값을 사용하여 달성 될 수있다.</target>
        </trans-unit>
        <trans-unit id="25fbf997b0a78ead811d3ad55217a116fa50d909" translate="yes" xml:space="preserve">
          <source>If the handle is already closed, no error is raised.</source>
          <target state="translated">핸들이 이미 닫혀 있으면 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="641b7d4d28be7e1599a1dccf300ba61a3ce1d4ca" translate="yes" xml:space="preserve">
          <source>If the header value can be recognized as a valid date of one form or another, this attribute will contain a &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance representing that date. If the timezone of the input date is specified as &lt;code&gt;-0000&lt;/code&gt; (indicating it is in UTC but contains no information about the source timezone), then &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; will be a naive &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;. If a specific timezone offset is found (including &lt;code&gt;+0000&lt;/code&gt;), then &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; will contain an aware &lt;code&gt;datetime&lt;/code&gt; that uses &lt;a href=&quot;datetime#datetime.timezone&quot;&gt;&lt;code&gt;datetime.timezone&lt;/code&gt;&lt;/a&gt; to record the timezone offset.</source>
          <target state="translated">헤더 값이 한 양식 또는 다른 양식의 유효한 날짜로 인식 될 수있는 경우이 속성에는 해당 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 를 나타내는 datetime 인스턴스 가 포함 됩니다. 입력 날짜의 시간대가 &lt;code&gt;-0000&lt;/code&gt; 으로 지정 되면 (UTC이지만 소스 시간대에 대한 정보가 없음을 나타냄) &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 은 순진한 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 입니다. 오프셋 특정 시간대가 (포함 발견되면 &lt;code&gt;+0000&lt;/code&gt; ), 다음 &lt;a href=&quot;#email.headerregistry.DateHeader.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의식적 포함 &lt;code&gt;datetime&lt;/code&gt; 용도는 것을 &lt;a href=&quot;datetime#datetime.timezone&quot;&gt; &lt;code&gt;datetime.timezone&lt;/code&gt; &lt;/a&gt; 오프셋 시간대를 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a777ed5d38b562baf8f3d74ea5382e00d35e44" translate="yes" xml:space="preserve">
          <source>If the higher-level protocol supports its own compression mechanism, you can use &lt;a href=&quot;#ssl.OP_NO_COMPRESSION&quot;&gt;&lt;code&gt;OP_NO_COMPRESSION&lt;/code&gt;&lt;/a&gt; to disable SSL-level compression.</source>
          <target state="translated">상위 레벨 프로토콜이 자체 압축 메커니즘을 지원하는 경우 &lt;a href=&quot;#ssl.OP_NO_COMPRESSION&quot;&gt; &lt;code&gt;OP_NO_COMPRESSION&lt;/code&gt; &lt;/a&gt; 을 사용하여 SSL 레벨 압축을 사용 안함 으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52c8f2ad85aead8b4995e491e22aafadac0261c9" translate="yes" xml:space="preserve">
          <source>If the index or keyword refers to an item that does not exist, then an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; should be raised.</source>
          <target state="translated">인덱스 또는 키워드가 존재하지 않는 항목을 참조하면 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생해야합니다.</target>
        </trans-unit>
        <trans-unit id="c788569ddd7977c4b0bf996b77dcb6e2c7a3c442" translate="yes" xml:space="preserve">
          <source>If the initial response check returns &lt;code&gt;None&lt;/code&gt;, or if &lt;em&gt;initial_response_ok&lt;/em&gt; is false, &lt;code&gt;authobject()&lt;/code&gt; will be called to process the server&amp;rsquo;s challenge response; the &lt;em&gt;challenge&lt;/em&gt; argument it is passed will be a &lt;code&gt;bytes&lt;/code&gt;. It should return ASCII &lt;code&gt;str&lt;/code&gt;&lt;em&gt;data&lt;/em&gt; that will be base64 encoded and sent to the server.</source>
          <target state="translated">초기 응답 확인이 &lt;code&gt;None&lt;/code&gt; 을 반환 하거나 &lt;em&gt;initial_response_ok&lt;/em&gt; 가 false 인 경우 서버의 인증 확인 응답을 처리하기 위해 &lt;code&gt;authobject()&lt;/code&gt; 가 호출됩니다. &lt;em&gt;도전&lt;/em&gt; 이 전달되는 인수가 될 것입니다 &lt;code&gt;bytes&lt;/code&gt; . base64로 인코딩되어 서버로 전송 될 ASCII &lt;code&gt;str&lt;/code&gt; &lt;em&gt;데이터&lt;/em&gt; 를 반환해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dab9d8717f742399cb738b981063ba490b7eb6fd" translate="yes" xml:space="preserve">
          <source>If the input path is not a list (as is the case for frozen packages) it is returned unchanged. The input path is not modified; an extended copy is returned. Items are only appended to the copy at the end.</source>
          <target state="translated">입력 경로가 목록이 아닌 경우 (냉동 패키지의 경우와 같이) 변경되지 않은 상태로 반환됩니다. 입력 경로는 수정되지 않습니다. 확장 사본이 리턴됩니다. 항목은 마지막에 사본에만 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="b943d29ac87cd73e259d10ec9f1b9fd2ca008d7c" translate="yes" xml:space="preserve">
          <source>If the insertion would cause a bounded deque to grow beyond &lt;em&gt;maxlen&lt;/em&gt;, an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">삽입이 제한된 양단 큐를 넘어 성장하는 원인이 경우 &lt;em&gt;MAXLEN&lt;/em&gt; , &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ed6b40b45f9572155a78f6d589785061f5e1cae3" translate="yes" xml:space="preserve">
          <source>If the instance &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; is shadowed by another member (for example a property) then this function will be unable to find instance members.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 인스턴스 가 다른 멤버 (예 : 속성)에 의해 음영 처리 되면 이 함수는 인스턴스 멤버를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bb4531fcea1f06a7582067573022ca8343fb967f" translate="yes" xml:space="preserve">
          <source>If the integer &lt;em&gt;waitflag&lt;/em&gt; argument is present, the action depends on its value: if it is zero, the lock is only acquired if it can be acquired immediately without waiting, while if it is nonzero, the lock is acquired unconditionally as above.</source>
          <target state="translated">정수 &lt;em&gt;waitflag&lt;/em&gt; 인수가 존재하는 경우 조치는 해당 값에 따라 다릅니다. 값이 0 인 경우 대기하지 않고 즉시 획득 할 수있는 경우에만 잠금이 획득되지만 0이 아닌 경우 잠금은 위와 같이 무조건적으로 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="205ca1ee8e670ddfe86eb319c90becb94497b60e" translate="yes" xml:space="preserve">
          <source>If the internal counter is greater than zero, decrement it by one and return &lt;code&gt;True&lt;/code&gt; immediately. If it is zero, wait until a &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; is called and return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">내부 카운터가 0보다 크면 1 씩 감소시키고 즉시 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다. 값이 0이면 &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 가 호출 될 때까지 기다렸다가 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9198aebf4f31811d32099cd373d77078c5c73698" translate="yes" xml:space="preserve">
          <source>If the internal counter is larger than zero on entry, decrement it by one and return &lt;code&gt;True&lt;/code&gt; immediately.</source>
          <target state="translated">입력시 내부 카운터가 0보다 크면 1 씩 감소시키고 즉시 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="21e399ee49393f3430f9b48c05c804f297ac4618" translate="yes" xml:space="preserve">
          <source>If the internal counter is zero on entry, block until awoken by a call to &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;. Once awoken (and the counter is greater than 0), decrement the counter by 1 and return &lt;code&gt;True&lt;/code&gt;. Exactly one thread will be awoken by each call to &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt;. The order in which threads are awoken should not be relied on.</source>
          <target state="translated">시작시 내부 카운터가 0이면 &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출로 깨울 때까지 차단하십시오 . 일단 깨어 나면 (그리고 카운터가 0보다 큰 경우), 카운터를 1 씩 줄이고 &lt;code&gt;True&lt;/code&gt; 를 반환하십시오 . &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 할 때마다 정확히 하나의 스레드가 해제 됩니다. 스레드가 깨어 난 순서는 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae60cc570833d155b59d2cc8b8afcbadf08444b" translate="yes" xml:space="preserve">
          <source>If the internal limits of the C version are exceeded, constructing a decimal raises &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">C 버전의 내부 한계를 초과하면 10 진수를 구성하면 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; 이 발생합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ffeab8a7c96e27484e303216d68be0fc6343fa6" translate="yes" xml:space="preserve">
          <source>If the interpreter would have been started with &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the sample would have printed &lt;code&gt;c_long(1)&lt;/code&gt;, or &lt;code&gt;c_long(2)&lt;/code&gt; if &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-oo&quot;&gt;&lt;code&gt;-OO&lt;/code&gt;&lt;/a&gt; would have been specified.</source>
          <target state="translated">인터프리터가 시작되었을 것입니다 경우 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , 샘플 인쇄 한 것 &lt;code&gt;c_long(1)&lt;/code&gt; , 또는 &lt;code&gt;c_long(2)&lt;/code&gt; 경우 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-oo&quot;&gt; &lt;code&gt;-OO&lt;/code&gt; 가&lt;/a&gt; 지정되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="fd1ebc0356b70021a18986beb6098d967d806f05" translate="yes" xml:space="preserve">
          <source>If the interpreter would have been started with &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt;, the sample would have printed &lt;code&gt;c_long(1)&lt;/code&gt;, or &lt;code&gt;c_long(2)&lt;/code&gt; if &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-oo&quot;&gt;&lt;code&gt;-OO&lt;/code&gt;&lt;/a&gt; would have been specified.</source>
          <target state="translated">인터프리터가 시작되었을 것입니다 경우 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; , 샘플 인쇄 한 것 &lt;code&gt;c_long(1)&lt;/code&gt; , 또는 &lt;code&gt;c_long(2)&lt;/code&gt; 경우 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-oo&quot;&gt; &lt;code&gt;-OO&lt;/code&gt; 가&lt;/a&gt; 지정되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ef843c9a43f59994d3da2c5e8418b405453ca10" translate="yes" xml:space="preserve">
          <source>If the key already exists, this function opens the existing key.</source>
          <target state="translated">키가 이미 존재하면이 기능은 기존 키를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="509b60b16f13bbedfe1f6d9e50bffcd673298294" translate="yes" xml:space="preserve">
          <source>If the key is not on the reflection list, the function succeeds but has no effect. Disabling reflection for a key does not affect reflection of any subkeys.</source>
          <target state="translated">키가 리플렉션 목록에 없으면 기능은 성공하지만 아무런 효과가 없습니다. 키에 대한 반사를 비활성화해도 하위 키의 반사에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="930e9f6ed338a6954d9cbd0e2a7335e5749df5c2" translate="yes" xml:space="preserve">
          <source>If the key specified by the &lt;em&gt;sub_key&lt;/em&gt; parameter does not exist, the SetValue function creates it.</source>
          <target state="translated">&lt;em&gt;sub_key&lt;/em&gt; 매개 변수로 지정된 키 가 없으면 SetValue 함수가이를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7f0fd305b3a1c159e43727b6d7cbb51944be9b83" translate="yes" xml:space="preserve">
          <source>If the listener object uses a socket then &lt;em&gt;backlog&lt;/em&gt; (1 by default) is passed to the &lt;a href=&quot;socket#socket.socket.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; method of the socket once it has been bound.</source>
          <target state="translated">리스너 객체가 소켓을 사용하는 경우 &lt;em&gt;백 로그&lt;/em&gt; (기본적으로 1)는 바인드 된 소켓 의 &lt;a href=&quot;socket#socket.socket.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="4fcbb3ff56b47c3934c001b5fdf01a88c7f7abf9" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;em&gt;unlocked&lt;/em&gt;, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">잠금이 &lt;em&gt;잠금 해제&lt;/em&gt; 되면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cd48a8f0e050bbf8d1af3c021ed42cd478aed78" translate="yes" xml:space="preserve">
          <source>If the locking flags &lt;a href=&quot;os#os.O_SHLOCK&quot;&gt;&lt;code&gt;O_SHLOCK&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#os.O_EXLOCK&quot;&gt;&lt;code&gt;O_EXLOCK&lt;/code&gt;&lt;/a&gt; are present in the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module (on BSD only), the &lt;a href=&quot;os#os.open&quot;&gt;&lt;code&gt;os.open()&lt;/code&gt;&lt;/a&gt; function provides an alternative to the &lt;a href=&quot;#fcntl.lockf&quot;&gt;&lt;code&gt;lockf()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#fcntl.flock&quot;&gt;&lt;code&gt;flock()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">잠금 플래그 &lt;a href=&quot;os#os.O_SHLOCK&quot;&gt; &lt;code&gt;O_SHLOCK&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os#os.O_EXLOCK&quot;&gt; &lt;code&gt;O_EXLOCK&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈에있는 경우 (BSD에만 해당) &lt;a href=&quot;os#os.open&quot;&gt; &lt;code&gt;os.open()&lt;/code&gt; &lt;/a&gt; 함수는 &lt;a href=&quot;#fcntl.lockf&quot;&gt; &lt;code&gt;lockf()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#fcntl.flock&quot;&gt; &lt;code&gt;flock()&lt;/code&gt; &lt;/a&gt; 함수에 대한 대안을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="266c606d27bf00d6844ea3d600920e9ed72976cd" translate="yes" xml:space="preserve">
          <source>If the message id for &lt;em&gt;context&lt;/em&gt; is not found in the catalog, and a fallback is specified, the request is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.npgettext&quot;&gt;&lt;code&gt;npgettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, when &lt;em&gt;n&lt;/em&gt; is 1 &lt;em&gt;singular&lt;/em&gt; is returned, and &lt;em&gt;plural&lt;/em&gt; is returned in all other cases.</source>
          <target state="translated">&lt;em&gt;컨텍스트에&lt;/em&gt; 대한 메시지 ID 가 카탈로그에없고 &lt;a href=&quot;#gettext.npgettext&quot;&gt; &lt;code&gt;npgettext()&lt;/code&gt; &lt;/a&gt; 백이 지정된 경우 요청은 폴 백의 npgettext () 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 일 때 &lt;em&gt;단수&lt;/em&gt; 를 반환 하고 다른 모든 경우에는 &lt;em&gt;복수&lt;/em&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="83b4d9a88e07f7820cdb0b2639ae3a66c2f8ddbd" translate="yes" xml:space="preserve">
          <source>If the message id is not found in the catalog, and a fallback is specified, the request is forwarded to the fallback&amp;rsquo;s &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt;&lt;code&gt;ngettext()&lt;/code&gt;&lt;/a&gt; method. Otherwise, when &lt;em&gt;n&lt;/em&gt; is 1 &lt;em&gt;singular&lt;/em&gt; is returned, and &lt;em&gt;plural&lt;/em&gt; is returned in all other cases.</source>
          <target state="translated">카탈로그에서 메시지 ID를 찾을 수없고 &lt;a href=&quot;#gettext.NullTranslations.ngettext&quot;&gt; &lt;code&gt;ngettext()&lt;/code&gt; &lt;/a&gt; 백이 지정된 경우 요청은 폴 백의 ngettext () 메소드로 전달됩니다 . 그렇지 않으면 &lt;em&gt;n&lt;/em&gt; 이 1 일 때 &lt;em&gt;단수&lt;/em&gt; 를 반환 하고 다른 모든 경우에는 &lt;em&gt;복수&lt;/em&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="84aa620a75940f54a9d2650b7be09bf90a61d67a" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/alternative&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt; or &lt;code&gt;multipart/related&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_alternative&quot;&gt;&lt;code&gt;make_alternative()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If the message is any other type of &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/alternative&lt;/code&gt; 인 경우 새 메시지 객체를 작성하고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메소드에 전달한 후 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; 또는 &lt;code&gt;multipart/related&lt;/code&gt; 인 경우 &lt;a href=&quot;#email.message.EmailMessage.make_alternative&quot;&gt; &lt;code&gt;make_alternative()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 메시지가 다른 유형의 &lt;code&gt;multipart&lt;/code&gt; 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b6c62590a9b06138d696cdbccce215f1bf1d175" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/mixed&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt;, &lt;code&gt;multipart/related&lt;/code&gt;, or &lt;code&gt;multipart/alternative&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_mixed&quot;&gt;&lt;code&gt;make_mixed()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;. If the added part has no &lt;em&gt;Content-Disposition&lt;/em&gt; header, add one with the value &lt;code&gt;attachment&lt;/code&gt;. This method can be used both for explicit attachments (&lt;em&gt;Content-Disposition: attachment&lt;/em&gt;) and &lt;code&gt;inline&lt;/code&gt; attachments (&lt;em&gt;Content-Disposition: inline&lt;/em&gt;), by passing appropriate options to the &lt;code&gt;content_manager&lt;/code&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/mixed&lt;/code&gt; 인 경우 새 메시지 객체를 작성하고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메소드에 전달한 후 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; , &lt;code&gt;multipart/related&lt;/code&gt; 또는 &lt;code&gt;multipart/alternative&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;#email.message.EmailMessage.make_mixed&quot;&gt; &lt;code&gt;make_mixed()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; . 추가 된 부품에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가 없으면 값이 &lt;code&gt;attachment&lt;/code&gt; 된 부품을 추가 하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;. 이 메소드는 적절한 옵션을 &lt;code&gt;content_manager&lt;/code&gt; 에 전달 하여 명시 적 첨부 파일 ( &lt;em&gt;Content-Disposition : attachment&lt;/em&gt; ) 및 &lt;code&gt;inline&lt;/code&gt; 첨부 파일 ( &lt;em&gt;Content-Disposition : inline&lt;/em&gt; ) 모두에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="242ebb9aa3a221a1cc2e7cc02579fdb6a91649b7" translate="yes" xml:space="preserve">
          <source>If the message is a &lt;code&gt;multipart/related&lt;/code&gt;, create a new message object, pass all of the arguments to its &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method, and &lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt;&lt;code&gt;attach()&lt;/code&gt;&lt;/a&gt; it to the &lt;code&gt;multipart&lt;/code&gt;. If the message is a non-&lt;code&gt;multipart&lt;/code&gt;, call &lt;a href=&quot;#email.message.EmailMessage.make_related&quot;&gt;&lt;code&gt;make_related()&lt;/code&gt;&lt;/a&gt; and then proceed as above. If the message is any other type of &lt;code&gt;multipart&lt;/code&gt;, raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;content_manager&lt;/em&gt; is not specified, use the &lt;code&gt;content_manager&lt;/code&gt; specified by the current &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;. If the added part has no &lt;em&gt;Content-Disposition&lt;/em&gt; header, add one with the value &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">메시지가 &lt;code&gt;multipart/related&lt;/code&gt; 인 경우 새 메시지 객체를 만들고 모든 인수를 &lt;a href=&quot;#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 메서드에 전달한 다음 &lt;code&gt;multipart&lt;/code&gt; 에&lt;a href=&quot;email.compat32-message#email.message.Message.attach&quot;&gt; &lt;code&gt;attach()&lt;/code&gt; &lt;/a&gt; . 메시지가 &lt;code&gt;multipart&lt;/code&gt; 가 아닌 경우 &lt;a href=&quot;#email.message.EmailMessage.make_related&quot;&gt; &lt;code&gt;make_related()&lt;/code&gt; &lt;/a&gt; 호출 한 다음 위와 같이 진행하십시오. 메시지가 다른 유형의 &lt;code&gt;multipart&lt;/code&gt; 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 경우 &lt;em&gt;CONTENT_MANAGER가&lt;/em&gt; 지정되지 않은, 사용 &lt;code&gt;content_manager&lt;/code&gt; 전류에 의해 지정된 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; . 추가 된 부품에 &lt;em&gt;Content-Disposition&lt;/em&gt; 헤더 가없는 경우 값이 &lt;code&gt;inline&lt;/code&gt; 인 부품을 추가하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9c9d1deafb768d7777ddc466b02dc8f72673a7cf" translate="yes" xml:space="preserve">
          <source>If the message object contains binary data that is not encoded according to RFC standards, the non-compliant data will be replaced by unicode &amp;ldquo;unknown character&amp;rdquo; code points. (See also &lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">메시지 객체에 RFC 표준에 따라 인코딩되지 않은 이진 데이터가 포함 된 경우 비 호환 데이터는 유니 코드 &quot;알 수없는 문자&quot;코드 포인트로 대체됩니다. ( &lt;a href=&quot;#email.message.Message.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="1d471d00aa6a8fd988a0ba607f8c74c947b07502" translate="yes" xml:space="preserve">
          <source>If the method returns &lt;code&gt;False&lt;/code&gt; then the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; was cancelled, i.e. &lt;a href=&quot;#concurrent.futures.Future.cancel&quot;&gt;&lt;code&gt;Future.cancel()&lt;/code&gt;&lt;/a&gt; was called and returned &lt;code&gt;True&lt;/code&gt;. Any threads waiting on the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; completing (i.e. through &lt;a href=&quot;#concurrent.futures.as_completed&quot;&gt;&lt;code&gt;as_completed()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#concurrent.futures.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;) will be woken up.</source>
          <target state="translated">메소드가 &lt;code&gt;False&lt;/code&gt; 를 리턴 하면 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 가 취소됩니다. 즉 &lt;a href=&quot;#concurrent.futures.Future.cancel&quot;&gt; &lt;code&gt;Future.cancel()&lt;/code&gt; &lt;/a&gt; 이 호출되어 &lt;code&gt;True&lt;/code&gt; 를 리턴했습니다 . &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 완료 대기중인 스레드 (예 : &lt;a href=&quot;#concurrent.futures.as_completed&quot;&gt; &lt;code&gt;as_completed()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#concurrent.futures.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; )는 깨어납니다.</target>
        </trans-unit>
        <trans-unit id="3cec9785f35a66b9250f6994cb4b5ad2f020d3b4" translate="yes" xml:space="preserve">
          <source>If the method returns &lt;code&gt;True&lt;/code&gt; then the &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; was not cancelled and has been put in the running state, i.e. calls to &lt;a href=&quot;#concurrent.futures.Future.running&quot;&gt;&lt;code&gt;Future.running()&lt;/code&gt;&lt;/a&gt; will return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">메소드가 &lt;code&gt;True&lt;/code&gt; 를 반환 하면 &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 는 취소되지 않고 실행 상태가됩니다. 즉 &lt;a href=&quot;#concurrent.futures.Future.running&quot;&gt; &lt;code&gt;Future.running()&lt;/code&gt; &lt;/a&gt; 호출 은 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="fbff94a7b3ccf99de926f202b3c2b1024530b6b5" translate="yes" xml:space="preserve">
          <source>If the method succeeds, the entire key, including all of its values, is removed. If the method fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">메소드가 성공하면 모든 값을 포함하여 전체 키가 제거됩니다. 메소드가 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0c7e815087343f8292c99aab7ab0f093f5891323" translate="yes" xml:space="preserve">
          <source>If the method succeeds, the server&amp;rsquo;s response is returned. If the server refuses posting, a &lt;a href=&quot;#nntplib.NNTPReplyError&quot;&gt;&lt;code&gt;NNTPReplyError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">메소드가 성공하면 서버의 응답이 리턴됩니다. 서버가 게시를 거부하면 &lt;a href=&quot;#nntplib.NNTPReplyError&quot;&gt; &lt;code&gt;NNTPReplyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7153563f652430df4d79eea119afe5c6dc69a83e" translate="yes" xml:space="preserve">
          <source>If the mock has an explicit &lt;em&gt;return_value&lt;/em&gt; set then calls are not passed to the wrapped object and the &lt;em&gt;return_value&lt;/em&gt; is returned instead.</source>
          <target state="translated">모형에 명시적인 &lt;em&gt;return_value가&lt;/em&gt; 설정 되어 있으면 래핑 된 객체에 호출이 전달되지 않고 대신 &lt;em&gt;return_value&lt;/em&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45919ac1b7a80b5e3b67f287a2f90644613d8e96" translate="yes" xml:space="preserve">
          <source>If the module or package is accessible via the normal import mechanism, a wrapper around the relevant part of that machinery is returned. Returns &lt;code&gt;None&lt;/code&gt; if the module cannot be found or imported. If the named module is not already imported, its containing package (if any) is imported, in order to establish the package &lt;code&gt;__path__&lt;/code&gt;.</source>
          <target state="translated">일반 가져 오기 메커니즘을 통해 모듈 또는 패키지에 액세스 할 수있는 경우 해당 기계의 관련 부분에 대한 랩퍼가 리턴됩니다. 모듈을 찾거나 가져올 수 없으면 &lt;code&gt;None&lt;/code&gt; 반환 합니다. 명명 된 모듈을 아직 가져 오지 않은 경우 &lt;code&gt;__path__&lt;/code&gt; 패키지를 설정하기 위해 포함 된 패키지 (있는 경우)를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="51e5842707c11d94e17db137bb67b47236a037bf" translate="yes" xml:space="preserve">
          <source>If the name is used as the target of a function or class statement, this will be true.</source>
          <target state="translated">이름이 함수 또는 클래스 문의 대상으로 사용되는 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="cc0362f1195e807cb7d35fcee8c326c2a06bfad6" translate="yes" xml:space="preserve">
          <source>If the named module is in a package, that package is imported as a side effect of invoking this function.</source>
          <target state="translated">명명 된 모듈이 패키지에있는 경우이 기능을 호출하면 부작용으로 해당 패키지를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9189c0d6152e209a08169bddf71ad00af16f14e9" translate="yes" xml:space="preserve">
          <source>If the new limit is too low at the current recursion depth, a &lt;a href=&quot;exceptions#RecursionError&quot;&gt;&lt;code&gt;RecursionError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">현재 재귀 수준에서 새 제한이 너무 낮 으면 &lt;a href=&quot;exceptions#RecursionError&quot;&gt; &lt;code&gt;RecursionError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8460feb89a7b7829874aae5225965d9b87e2ad34" translate="yes" xml:space="preserve">
          <source>If the normalized value of days lies outside the indicated range, &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">정규화 된 일 수 값이 표시된 범위를 벗어나면 &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="588410c54abe56967f1464e64a03d18c20cd3967" translate="yes" xml:space="preserve">
          <source>If the object does not provide &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, the function tries its best to gather information from the object&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute, if defined, and from its type object. The resulting list is not necessarily complete, and may be inaccurate when the object has a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 제공하지 않으면 함수는 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성 (정의 된 경우) 및 유형 객체에서 정보를 수집하기 위해 최선을 다합니다 . 결과 목록이 반드시 완전하지는 않으며 객체에 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 이있는 경우 정확하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05bbe2559834e2f6af2c3f6c9eb444fb9f753c6a" translate="yes" xml:space="preserve">
          <source>If the object does not provide &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, the function tries its best to gather information from the object&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute, if defined, and from its type object. The resulting list is not necessarily complete, and may be inaccurate when the object has a custom &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">객체가 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 제공하지 않으면 함수는 정의 된 경우 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성과 유형 객체에서 정보를 수집하기 위해 최선을 다합니다 . 결과 목록이 반드시 완전하지는 않으며 객체에 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 이있는 경우 정확하지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="00cb3870e9b06174890128e7e72fbdcdb2084f55" translate="yes" xml:space="preserve">
          <source>If the object has a method named &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, this method will be called and must return the list of attributes. This allows objects that implement a custom &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; function to customize the way &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; reports their attributes.</source>
          <target state="translated">객체에 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 이라는 메소드가있는 경우이 메소드가 호출되며 속성 목록을 리턴해야합니다. 이를 통해 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 함수를 구현하는 객체는 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 이 속성을보고 하는 방식을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90be18a105f4b897e5b361feac130f50b2b05c2c" translate="yes" xml:space="preserve">
          <source>If the object has a method named &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, this method will be called and must return the list of attributes. This allows objects that implement a custom &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; function to customize the way &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; reports their attributes.</source>
          <target state="translated">객체에 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; 이라는 메서드가있는 경우이 메서드가 호출되고 속성 목록을 반환해야합니다. 이를 통해 사용자 정의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 함수를 구현하는 객체가 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 이 속성을보고 하는 방식을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6efa5f83d57e360fb04084d7429ce45f6b697027" translate="yes" xml:space="preserve">
          <source>If the object is a module object, the list contains the names of the module&amp;rsquo;s attributes.</source>
          <target state="translated">객체가 모듈 객체 인 경우 목록에 모듈 속성의 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7573a086962ae326425c85210e2af2f83614b6a3" translate="yes" xml:space="preserve">
          <source>If the object is a type or class object, the list contains the names of its attributes, and recursively of the attributes of its bases.</source>
          <target state="translated">객체가 유형 또는 클래스 객체 인 경우 목록에는 해당 속성의 이름과 기본 속성의 재귀 적으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2997ac7e88144e3d7c1c1886f52b5f3da5581222" translate="yes" xml:space="preserve">
          <source>If the optional &lt;code&gt;infile&lt;/code&gt; and &lt;code&gt;outfile&lt;/code&gt; arguments are not specified, &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; will be used respectively:</source>
          <target state="translated">선택적 &lt;code&gt;infile&lt;/code&gt; 및 &lt;code&gt;outfile&lt;/code&gt; 인수가 지정되지 않은 경우 &lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 이 각각 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="549e746dc68c5d98d85de52964752ff8fe6a8117" translate="yes" xml:space="preserve">
          <source>If the optional &lt;em&gt;allow_dotted_names&lt;/em&gt; argument is true and the instance does not have a &lt;code&gt;_dispatch()&lt;/code&gt; method, then if the requested method name contains periods, each component of the method name is searched for individually, with the effect that a simple hierarchical search is performed. The value found from this search is then called with the parameters from the request, and the return value is passed back to the client.</source>
          <target state="translated">선택적인 &lt;em&gt;allow_dotted_names&lt;/em&gt; 인수가 true이고 인스턴스에 &lt;code&gt;_dispatch()&lt;/code&gt; 메소드 가없는 경우 요청 된 메소드 이름에 마침표가 포함되어 있으면 간단한 계층 구조 검색이 수행되는 방식으로 요청 된 메소드 이름에 개별 컴포넌트가 검색됩니다. 그런 다음이 검색에서 찾은 값이 요청의 매개 변수와 함께 호출되고 리턴 값이 클라이언트로 다시 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="77cf8956342ad1c505b15b2821104ecf26fa5b1d" translate="yes" xml:space="preserve">
          <source>If the optional &lt;em&gt;graph&lt;/em&gt; argument is provided it must be a dictionary representing a directed acyclic graph where the keys are nodes and the values are iterables of all predecessors of that node in the graph (the nodes that have edges that point to the value in the key). Additional nodes can be added to the graph using the &lt;a href=&quot;#graphlib.TopologicalSorter.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;그래프&lt;/em&gt; 인수가 제공되는 경우 키가 노드이고 값이 그래프에서 해당 노드의 모든 선행 항목 (키의 값을 가리키는 간선이있는 노드)의 반복 가능한 방향 비순환 그래프를 나타내는 사전이어야합니다. ). &lt;a href=&quot;#graphlib.TopologicalSorter.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 그래프에 추가 노드를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf594fe9f1e866693d0d56f18167c8228362f08" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;exclude_empty&lt;/em&gt; is false, then &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt;&lt;code&gt;DocTestFinder.find()&lt;/code&gt;&lt;/a&gt; will include tests for objects with empty docstrings.</source>
          <target state="translated">선택적 인수 &lt;em&gt;exclude_empty&lt;/em&gt; 가 false 인 경우 &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt; &lt;code&gt;DocTestFinder.find()&lt;/code&gt; &lt;/a&gt; 는 빈 docstring이있는 객체에 대한 테스트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4dda0a6681904db033d6436f3b4c07ed02a5cd5c" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;recurse&lt;/em&gt; is false, then &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt;&lt;code&gt;DocTestFinder.find()&lt;/code&gt;&lt;/a&gt; will only examine the given object, and not any contained objects.</source>
          <target state="translated">선택적 인수 &lt;em&gt;재귀&lt;/em&gt; 가 false 인 경우 &lt;a href=&quot;#doctest.DocTestFinder.find&quot;&gt; &lt;code&gt;DocTestFinder.find()&lt;/code&gt; &lt;/a&gt; 는 포함 된 개체가 아닌 지정된 개체 만 검사합니다.</target>
        </trans-unit>
        <trans-unit id="87f9d738288c72fc56cefc596ae3035e04fd6c01" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;em&gt;timeout&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; (the default), the method blocks until the process whose &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; method is called terminates. If &lt;em&gt;timeout&lt;/em&gt; is a positive number, it blocks at most &lt;em&gt;timeout&lt;/em&gt; seconds. Note that the method returns &lt;code&gt;None&lt;/code&gt; if its process terminates or if the method times out. Check the process&amp;rsquo;s &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt;&lt;code&gt;exitcode&lt;/code&gt;&lt;/a&gt; to determine if it terminated.</source>
          <target state="translated">선택적 인수 &lt;em&gt;timeout&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 메서드가 호출 된 프로세스가 종료 될 때까지 메서드가 차단 됩니다. 경우 &lt;em&gt;제한 시간은&lt;/em&gt; 최대 양수, 차단입니다 &lt;em&gt;시간 제한&lt;/em&gt; 초. 프로세스가 종료되거나 메소드가 시간 종료되면 메소드는 &lt;code&gt;None&lt;/code&gt; 리턴 합니다. 프로세스 종료 &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt; &lt;code&gt;exitcode&lt;/code&gt; &lt;/a&gt; 를 확인하여 프로세스가 종료되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="907e323a441ade6004f0f9b1d15889b1a6cbc0b5" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;em&gt;max_length&lt;/em&gt; is non-zero then the return value will be no longer than &lt;em&gt;max_length&lt;/em&gt;. This may mean that not all of the compressed input can be processed; and unconsumed data will be stored in the attribute &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt;&lt;code&gt;unconsumed_tail&lt;/code&gt;&lt;/a&gt;. This bytestring must be passed to a subsequent call to &lt;a href=&quot;#zlib.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; if decompression is to continue. If &lt;em&gt;max_length&lt;/em&gt; is zero then the whole input is decompressed, and &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt;&lt;code&gt;unconsumed_tail&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">선택적 매개 변수 &lt;em&gt;max_length&lt;/em&gt; 가 0이 아니면 리턴 값은 &lt;em&gt;max_length&lt;/em&gt; 보다 길지 않습니다 . 이는 모든 압축 입력을 처리 할 수있는 것은 아닙니다. 및 사용되지 않은 데이터는 속성에 저장 될 &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt; &lt;code&gt;unconsumed_tail&lt;/code&gt; &lt;/a&gt; . 압축 해제를 계속 하려면이 바이트 문자열을 후속 &lt;a href=&quot;#zlib.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 호출로 전달해야합니다 . 경우 &lt;em&gt;MAX_LENGTH은&lt;/em&gt; 다음 제로 전체 입력이 압축 해제되어 &lt;a href=&quot;#zlib.Decompress.unconsumed_tail&quot;&gt; &lt;code&gt;unconsumed_tail&lt;/code&gt; 는&lt;/a&gt; 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1a61b6065550962e0f197aa4aa509c70c359be" translate="yes" xml:space="preserve">
          <source>If the optional second argument &lt;em&gt;mu&lt;/em&gt; is given, it is typically the mean of the &lt;em&gt;data&lt;/em&gt;. It can also be used to compute the second moment around a point that is not the mean. If it is missing or &lt;code&gt;None&lt;/code&gt; (the default), the arithmetic mean is automatically calculated.</source>
          <target state="translated">선택적 두 번째 인수 &lt;em&gt;mu&lt;/em&gt; 가 제공되면 일반적으로 &lt;em&gt;데이터&lt;/em&gt; 의 평균입니다 . 또한 평균이 아닌 지점을 기준으로 두 번째 모멘트를 계산하는 데 사용할 수도 있습니다. 누락되거나 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 산술 평균이 자동으로 계산됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
