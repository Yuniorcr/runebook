<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="c5d7f93d05e067d985113c87a6fa6e68ff758987" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; statements.</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 문을.</target>
        </trans-unit>
        <trans-unit id="ec504929a2fb2ce3901b05f7e84e725f7539dce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; objects in &lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt;&lt;code&gt;Mock.call_args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt;&lt;code&gt;Mock.call_args_list&lt;/code&gt;&lt;/a&gt; are two-tuples of (positional args, keyword args) whereas the &lt;code&gt;call&lt;/code&gt; objects in &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;Mock.mock_calls&lt;/code&gt;&lt;/a&gt;, along with ones you construct yourself, are three-tuples of (name, positional args, keyword args).</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt; &lt;code&gt;Mock.call_args&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt; &lt;code&gt;Mock.call_args_list&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;call&lt;/code&gt; 객체 는 (위치 args, 키워드 args)의 두 튜플이지만 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;Mock.mock_calls&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;call&lt;/code&gt; 객체는 사용자가 구성하는 것과 함께 (이름, 위치 args, 키워드 인수).</target>
        </trans-unit>
        <trans-unit id="f0095fb07694807b7d7160a1ed193f2c7fb50cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;class&lt;/code&gt; entry indicates the handler&amp;rsquo;s class (as determined by &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace). The &lt;code&gt;level&lt;/code&gt; is interpreted as for loggers, and &lt;code&gt;NOTSET&lt;/code&gt; is taken to mean &amp;lsquo;log everything&amp;rsquo;.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 항목 (의 결정에 따라 핸들러의 클래스를 나타내는 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;logging&lt;/code&gt; 패키지의 이름 공간). &lt;code&gt;level&lt;/code&gt; 로거로 해석하고, &lt;code&gt;NOTSET&lt;/code&gt; 는 '로그 모든 것을'의미 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8f7bfa816dd3504e8292223adda9c4361b672f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;class&lt;/code&gt; entry is optional. It indicates the name of the formatter&amp;rsquo;s class (as a dotted module and class name.) This option is useful for instantiating a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; subclass. Subclasses of &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; can present exception tracebacks in an expanded or condensed format.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 항목은 선택 사항입니다. 포맷터 클래스 이름 (점으로 구분 된 모듈 및 클래스 이름)을 나타냅니다.이 옵션은 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스 를 인스턴스화하는 데 유용합니다 . &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스 는 확장 또는 압축 형식으로 예외 추적을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ec22605f4896ed5a3fbb6991cb3daa62a8dc30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close()&lt;/code&gt; method is not implemented, &lt;a href=&quot;#contextlib.AsyncExitStack.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; must be used instead.</source>
          <target state="translated">&lt;code&gt;close()&lt;/code&gt; 메소드가 실행되지 않는다 &lt;a href=&quot;#contextlib.AsyncExitStack.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 대신에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="baf71b295297eb68de3b61fbcfcaf38f3dced956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method returns &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the subprocess exited successfully, or the subprocess&amp;rsquo;s return code if there was an error. On POSIX systems, if the return code is positive it represents the return value of the process left-shifted by one byte. If the return code is negative, the process was terminated by the signal given by the negated value of the return code. (For example, the return value might be &lt;code&gt;- signal.SIGKILL&lt;/code&gt; if the subprocess was killed.) On Windows systems, the return value contains the signed integer return code from the child process.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 방법은 반환 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에러가 발생했을 경우 서브 프로세스가 성공적으로 종료, 또는 하위 프로세스의 리턴 코드합니다. POSIX 시스템에서 리턴 코드가 양수이면 1 바이트 왼쪽으로 시프트 된 프로세스의 리턴 값을 나타냅니다. 리턴 코드가 음수이면, 리턴 코드의 부정 된 값에 의해 주어진 신호에 의해 프로세스가 종료되었습니다. (예를 들어, 서브 프로세스가 종료 된 경우 리턴 값은 &lt;code&gt;- signal.SIGKILL&lt;/code&gt; 일 수 있습니다 .) Windows 시스템에서 리턴 값에는 하위 프로세스의 부호있는 정수 리턴 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3738771cfde745973ee9e9e6e59d483c5c69d30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code&lt;/code&gt; module provides facilities to implement read-eval-print loops in Python. Two classes and convenience functions are included which can be used to build applications which provide an interactive interpreter prompt.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 모듈은 파이썬에서 읽기 평가 후면 인쇄 루프를 구현하는 기능을 제공합니다. 대화식 통역사 프롬프트를 제공하는 응용 프로그램을 빌드하는 데 사용할 수있는 두 개의 클래스와 편의 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f8a5f6cdeeb43455302373902fc6f690cfea1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;colon&lt;/code&gt; attribute may also be set on a per-instance basis.</source>
          <target state="translated">&lt;code&gt;colon&lt;/code&gt; 속성은 또한 인스턴스마다 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="7fa8bb90452b238e4231410cf712c3c51172e7e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concurrent&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;concurrent&lt;/code&gt; 패키지</target>
        </trans-unit>
        <trans-unit id="47958b98a21f02493afe011d1fe7fd47b89e4221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is used to hold constant values that are not read from the command line but are required for the various &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; actions. The two most common uses of it are:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;const&lt;/code&gt; 인수 는 명령 줄에서 읽지 않지만 다양한 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 작업에 필요한 상수 값을 보유하는 데 사용됩니다 . 가장 일반적인 두 가지 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c1a6767fe12e172b4870adf50fb52b7ad98ffb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create&lt;/code&gt; method of the &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; class illustrates the hooks available for subclass customization:</source>
          <target state="translated">&lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;code&gt;create&lt;/code&gt; 메소드는 서브 클래스 사용자 정의에 사용 가능한 후크를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2d03fa71ebb6e231d59aa9390e871246c5344d6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctypes.util&lt;/code&gt; module provides a function which can help to determine the library to load.</source>
          <target state="translated">&lt;code&gt;ctypes.util&lt;/code&gt; 모듈은 부하에 라이브러리를 결정하는 데 도움을 줄 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7496909f52e59e234f12e33f691492d0ff1051aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctypes.wintypes&lt;/code&gt; module provides quite some other Windows specific data types, for example &lt;code&gt;HWND&lt;/code&gt;, &lt;code&gt;WPARAM&lt;/code&gt;, or &lt;code&gt;DWORD&lt;/code&gt;. Some useful structures like &lt;code&gt;MSG&lt;/code&gt; or &lt;code&gt;RECT&lt;/code&gt; are also defined.</source>
          <target state="translated">&lt;code&gt;ctypes.wintypes&lt;/code&gt; 의 모듈은 예를 들어, 꽤 다른 Windows 특정 데이터 유형을 제공 &lt;code&gt;HWND&lt;/code&gt; , &lt;code&gt;WPARAM&lt;/code&gt; , 또는 &lt;code&gt;DWORD&lt;/code&gt; . &lt;code&gt;MSG&lt;/code&gt; 또는 &lt;code&gt;RECT&lt;/code&gt; 와 같은 유용한 구조 도 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4762e5a3dafdaba2c58c248e6d2ff0abbc78c9e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decoded&lt;/code&gt; value of the header is determined by formatting the &lt;code&gt;datetime&lt;/code&gt; according to the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; rules; that is, it is set to:</source>
          <target state="translated">헤더 의 &lt;code&gt;decoded&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 규칙 에 따라 &lt;code&gt;datetime&lt;/code&gt; 을 포맷함으로써 결정되며 ; 즉, 다음과 같이 설정됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bf7c8f5ef57293f4a035c7235afdf736241c388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decoded&lt;/code&gt; value of the header will have all encoded words decoded to unicode. &lt;a href=&quot;codecs#module-encodings.idna&quot;&gt;&lt;code&gt;idna&lt;/code&gt;&lt;/a&gt; encoded domain names are also decoded to unicode. The &lt;code&gt;decoded&lt;/code&gt; value is set by &lt;a href=&quot;stdtypes#str.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;ing the &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; value of the elements of the &lt;code&gt;groups&lt;/code&gt; attribute with &lt;code&gt;',
'&lt;/code&gt;.</source>
          <target state="translated">헤더 의 &lt;code&gt;decoded&lt;/code&gt; 값은 모든 인코딩 된 단어를 유니 코드로 디코딩 할 것이다. &lt;a href=&quot;codecs#module-encodings.idna&quot;&gt; &lt;code&gt;idna&lt;/code&gt; 로&lt;/a&gt; 인코딩 된 도메인 이름도 유니 코드로 디코딩됩니다. &lt;code&gt;decoded&lt;/code&gt; 하여 설정 값은 &lt;a href=&quot;stdtypes#str.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; ING를 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 요소의 값이 &lt;code&gt;groups&lt;/code&gt; 으로 속성 &lt;code&gt;', '&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3869f5fd68f571b36a23c4e50f6ef01300c04746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defusedxml&lt;/code&gt; Package</source>
          <target state="translated">&lt;code&gt;defusedxml&lt;/code&gt; 패키지</target>
        </trans-unit>
        <trans-unit id="1fa89fca3d85626b155af4cfba20357d4cc96830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defusedxml&lt;/code&gt; and &lt;code&gt;defusedexpat&lt;/code&gt; Packages</source>
          <target state="translated">&lt;code&gt;defusedxml&lt;/code&gt; 및 &lt;code&gt;defusedexpat&lt;/code&gt; 패키지</target>
        </trans-unit>
        <trans-unit id="dfc2ee4946a057f25375d575b48219960fa9f49b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dircmp&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;dircmp&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="8ffc245c6775a61d7871af9ec0f8704fe5eef1cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discover&lt;/code&gt; sub-command has the following options:</source>
          <target state="translated">는 &lt;code&gt;discover&lt;/code&gt; 하위 명령은 다음과 같은 옵션이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="648875dd3e0111333c4afffc1af11bfc7a4a6c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_name&lt;/code&gt; of the group. If it is &lt;code&gt;None&lt;/code&gt; and there is exactly one &lt;code&gt;Address&lt;/code&gt; in &lt;code&gt;addresses&lt;/code&gt;, then the &lt;code&gt;Group&lt;/code&gt; represents a single address that is not in a group.</source>
          <target state="translated">그룹 의 &lt;code&gt;display_name&lt;/code&gt; 입니다. 이없는 경우 &lt;code&gt;None&lt;/code&gt; 하나 개 정확히이 &lt;code&gt;Address&lt;/code&gt; 의 &lt;code&gt;addresses&lt;/code&gt; 다음 &lt;code&gt;Group&lt;/code&gt; 그룹에 포함되지 않은 하나의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7b171073f1958b4ddf2620702c25cb5e7487c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_GET()&lt;/code&gt; and &lt;code&gt;do_HEAD()&lt;/code&gt; functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the &lt;code&gt;cgi_directories&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;do_GET()&lt;/code&gt; 및 &lt;code&gt;do_HEAD()&lt;/code&gt; 함수는 요청 리드 경우 아래 어딘가에 대신 파일을 제공의 출력을 CGI 스크립트를 실행하고 봉사하는 수정 &lt;code&gt;cgi_directories&lt;/code&gt; 의 경로.</target>
        </trans-unit>
        <trans-unit id="c3677fc05242ea4075af857b2c902b5aceeacc42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;domain&lt;/code&gt; portion of the address.</source>
          <target state="translated">주소 의 &lt;code&gt;domain&lt;/code&gt; 부분.</target>
        </trans-unit>
        <trans-unit id="705f2d3bcf70b0357b08a41f5d6b8adc484dd65b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry_points()&lt;/code&gt; function returns a dictionary of all entry points, keyed by group. Entry points are represented by &lt;code&gt;EntryPoint&lt;/code&gt; instances; each &lt;code&gt;EntryPoint&lt;/code&gt; has a &lt;code&gt;.name&lt;/code&gt;, &lt;code&gt;.group&lt;/code&gt;, and &lt;code&gt;.value&lt;/code&gt; attributes and a &lt;code&gt;.load()&lt;/code&gt; method to resolve the value.</source>
          <target state="translated">&lt;code&gt;entry_points()&lt;/code&gt; 함수는 그룹에 의해 키가 모든 진입 점의 사전을 반환합니다. 진입 점은 &lt;code&gt;EntryPoint&lt;/code&gt; 인스턴스 로 표시됩니다 . 각 &lt;code&gt;EntryPoint&lt;/code&gt; 에는 값을 확인하기위한 &lt;code&gt;.name&lt;/code&gt; , &lt;code&gt;.group&lt;/code&gt; 및 &lt;code&gt;.value&lt;/code&gt; 속성과 &lt;code&gt;.load()&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d7abc5df7386f19020e2b09081108666a375618" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry_points()&lt;/code&gt; function returns a dictionary of all entry points, keyed by group. Entry points are represented by &lt;code&gt;EntryPoint&lt;/code&gt; instances; each &lt;code&gt;EntryPoint&lt;/code&gt; has a &lt;code&gt;.name&lt;/code&gt;, &lt;code&gt;.group&lt;/code&gt;, and &lt;code&gt;.value&lt;/code&gt; attributes and a &lt;code&gt;.load()&lt;/code&gt; method to resolve the value. There are also &lt;code&gt;.module&lt;/code&gt;, &lt;code&gt;.attr&lt;/code&gt;, and &lt;code&gt;.extras&lt;/code&gt; attributes for getting the components of the &lt;code&gt;.value&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;code&gt;entry_points()&lt;/code&gt; 함수는 그룹에 의해 키가 모든 진입 점의 사전을 반환합니다. 진입 점은 &lt;code&gt;EntryPoint&lt;/code&gt; 인스턴스 로 표시됩니다 . 각 &lt;code&gt;EntryPoint&lt;/code&gt; 에는 &lt;code&gt;.name&lt;/code&gt; , &lt;code&gt;.group&lt;/code&gt; 및 &lt;code&gt;.value&lt;/code&gt; 속성과 값을 확인하기 위한 &lt;code&gt;.load()&lt;/code&gt; 메서드가 있습니다. 이 또한 &lt;code&gt;.module&lt;/code&gt; , &lt;code&gt;.attr&lt;/code&gt; 및 &lt;code&gt;.extras&lt;/code&gt; 는 의 구성 요소 가져 오기위한 속성 &lt;code&gt;.value&lt;/code&gt; 속성 :</target>
        </trans-unit>
        <trans-unit id="470247d84f91b5ace4b798cb71b48d89f4faa7c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; module has the following attributes:</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 모듈은 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9b83f601ca71c62648a67d0ae21f05a3c4105c9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method can return any of the types supported by SQLite: bytes, str, int, float and &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 바이트, STR, INT, 플로트와 : 방법은 SQLite는 지원하는 유형의 반환 할 수 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27b6f5afd09e8d42f8ef61e3e33d7e1326356e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find*()&lt;/code&gt; routines might look a bit funny at first sight. They are primarily meant to do echo cancellation. A reasonably fast way to do this is to pick the most energetic piece of the output sample, locate that in the input sample and subtract the whole output sample from the input sample:</source>
          <target state="translated">&lt;code&gt;find*()&lt;/code&gt; 루틴은 첫눈에 재미 좀 볼 수 있습니다. 주로 에코 제거를 수행합니다. 이렇게하는 가장 빠른 방법은 출력 샘플 중 가장 에너지가 많은 부분을 선택하고 입력 샘플에서 해당 샘플을 찾아 입력 샘플에서 전체 출력 샘플을 빼는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cabfb6998c66a156b607518aa9258a73d1121858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; entry is the overall format string, and the &lt;code&gt;datefmt&lt;/code&gt; entry is the &lt;code&gt;strftime()&lt;/code&gt;-compatible date/time format string. If empty, the package substitutes something which is almost equivalent to specifying the date format string &lt;code&gt;'%Y-%m-%d %H:%M:%S'&lt;/code&gt;. This format also specifies milliseconds, which are appended to the result of using the above format string, with a comma separator. An example time in this format is &lt;code&gt;2003-01-23 00:29:50,411&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 항목은 전체 형식 문자열이며, &lt;code&gt;datefmt&lt;/code&gt; 의 항목은이다 &lt;code&gt;strftime()&lt;/code&gt; 호환 날짜 / 시간 형식 문자열입니다. 비어있는 경우 패키지는 날짜 형식 문자열 &lt;code&gt;'%Y-%m-%d %H:%M:%S'&lt;/code&gt; 를 지정하는 것과 거의 동일한 것을 대체합니다 . 이 형식은 또한 밀리 초를 지정합니다. 밀리 초는 위 형식 문자열을 사용한 결과에 쉼표 구분 기호와 함께 추가됩니다. 이 형식의 예제 시간은 &lt;code&gt;2003-01-23 00:29:50,411&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17356f2f06eb5423af82d8f66e100cef27b9c151" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;formatter&lt;/code&gt; entry indicates the key name of the formatter for this handler. If blank, a default formatter (&lt;code&gt;logging._defaultFormatter&lt;/code&gt;) is used. If a name is specified, it must appear in the &lt;code&gt;[formatters]&lt;/code&gt; section and have a corresponding section in the configuration file.</source>
          <target state="translated">&lt;code&gt;formatter&lt;/code&gt; 항목이 핸들러에 대한 포맷터의 키 이름을 나타냅니다. 비어 있으면 기본 포맷터 ( &lt;code&gt;logging._defaultFormatter&lt;/code&gt; )가 사용됩니다. 이름이 지정되면 &lt;code&gt;[formatters]&lt;/code&gt; 섹션에 나타나고 구성 파일에 해당 섹션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e965f45c045d1ea3947a47df71b810d8c5eccba9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;formatweekday()&lt;/code&gt; and &lt;code&gt;formatmonthname()&lt;/code&gt; methods of these two classes temporarily change the current locale to the given &lt;em&gt;locale&lt;/em&gt;. Because the current locale is a process-wide setting, they are not thread-safe.</source>
          <target state="translated">이 두 클래스 의 &lt;code&gt;formatweekday()&lt;/code&gt; 및 &lt;code&gt;formatmonthname()&lt;/code&gt; 메소드는 현재 로케일을 주어진 &lt;em&gt;로케일&lt;/em&gt; 로 임시 변경합니다 . 현재 로캘은 프로세스 전체 설정이므로 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f09d559d6b736bafa34f34c899e2feab29c13e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromfile_prefix_chars=&lt;/code&gt; argument defaults to &lt;code&gt;None&lt;/code&gt;, meaning that arguments will never be treated as file references.</source>
          <target state="translated">&lt;code&gt;fromfile_prefix_chars=&lt;/code&gt; 에 인수 기본값 &lt;code&gt;None&lt;/code&gt; 이 인수 의미는, 파일 참조로 취급되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bcf5a62d2a2e681c287c6f1f5850707bfd9e6e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; are arbitrary values defined by the package author and usually a client will wish to resolve all entry points for a particular group. Read &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;the setuptools docs&lt;/a&gt; for more information on entry points, their definition, and usage.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 과 &lt;code&gt;name&lt;/code&gt; 패키지 작성자가 정의한 임의의 값이며, 일반적으로 클라이언트가 특정 그룹에 대한 모든 진입 점을 해결하고자하는 것입니다. 진입 점, 정의 및 사용법에 대한 자세한 정보 &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;는 setuptools 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="66ce82075ae6e82092c56a7bcf7aa3f519092869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; are arbitrary values defined by the package author and usually a client will wish to resolve all entry points for a particular group. Read &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;the setuptools docs&lt;/a&gt; for more information on entrypoints, their definition, and usage.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 과 &lt;code&gt;name&lt;/code&gt; 패키지 작성자가 정의한 임의의 값이며, 일반적으로 클라이언트가 특정 그룹에 대한 모든 진입 점을 해결하고자하는 것입니다. 진입 점, 정의 및 사용법에 대한 자세한 정보 &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;는 setuptools 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="734b8ef87e08eaf3f6a91d381e68a3ec5afe96cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle_request()&lt;/code&gt; method is called once all relevant input has been marshalled, after setting the channel terminator to &lt;code&gt;None&lt;/code&gt; to ensure that any extraneous data sent by the web client are ignored.</source>
          <target state="translated">&lt;code&gt;handle_request()&lt;/code&gt; 관련된 모든 입력 채널에 터미네이터를 설정 한 후, 정렬 화 된 후에 방법이라고 &lt;code&gt;None&lt;/code&gt; 웹 클라이언트에 의해 전송 된 외부 데이터는 무시되도록.</target>
        </trans-unit>
        <trans-unit id="cc968396993a8b75be630e29fb2af6f69b3b6185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handlers&lt;/code&gt; entry is a comma-separated list of handler names, which must appear in the &lt;code&gt;[handlers]&lt;/code&gt; section. These names must appear in the &lt;code&gt;[handlers]&lt;/code&gt; section and have corresponding sections in the configuration file.</source>
          <target state="translated">&lt;code&gt;handlers&lt;/code&gt; 항목이 표시되어야 핸들러 이름 쉼표로 구분이다 &lt;code&gt;[handlers]&lt;/code&gt; 부. 이러한 이름은 &lt;code&gt;[handlers]&lt;/code&gt; 섹션에 나타나고 구성 파일에 해당 섹션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d0bdbe8053135d93602cf27febee65acb6f80d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help&lt;/code&gt; strings can include various format specifiers to avoid repetition of things like the program name or the argument &lt;a href=&quot;#default&quot;&gt;default&lt;/a&gt;. The available specifiers include the program name, &lt;code&gt;%(prog)s&lt;/code&gt; and most keyword arguments to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;%(default)s&lt;/code&gt;, &lt;code&gt;%(type)s&lt;/code&gt;, etc.:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 문자열은 프로그램 이름이나 인수 같은 것들의 반복을 피하기 위해 다양한 형식 지정자를 포함 할 수 있습니다 &lt;a href=&quot;#default&quot;&gt;기본&lt;/a&gt; . 사용 가능한 지정자에는 프로그램 이름, &lt;code&gt;%(prog)s&lt;/code&gt; 및 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 대한 대부분의 키워드 인수가 포함 됩니다 ( 예 : &lt;code&gt;%(default)s&lt;/code&gt; , &lt;code&gt;%(type)s&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="8376e018657c4b93a09c801a30a071868534e6e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help&lt;/code&gt; value is a string containing a brief description of the argument. When a user requests help (usually by using &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; at the command line), these &lt;code&gt;help&lt;/code&gt; descriptions will be displayed with each argument:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 값은 인수에 대한 간략한 설명을 포함하는 문자열입니다. 사용자가 도움말을 요청하면 (일반적으로 명령 행에서 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 를 사용하여 ) 다음과 같은 &lt;code&gt;help&lt;/code&gt; 설명이 각 인수와 함께 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e141e9805f4250470f88de20907a8951788930fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;not in&lt;/code&gt; operations have the same priorities as the comparison operations. The &lt;code&gt;+&lt;/code&gt; (concatenation) and &lt;code&gt;*&lt;/code&gt; (repetition) operations have the same priority as the corresponding numeric operations. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;not in&lt;/code&gt; 작업은 비교 연산과 같은 우선 순위를 가지고있다. &lt;code&gt;+&lt;/code&gt; (연결) 및 &lt;code&gt;*&lt;/code&gt; (반복) 조작 대응 수치 연산과 동일한 우선 순위를 갖는다. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0b655cd42857e8528e98d4299eb623e5c52d30d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; parameter sets the name of the zone for the purposes of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 파라미터는 상기의 목적을위한 영역의 이름으로 설정 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b5250a5eeb7f9d4c6ad580919cbbcca70c30999a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;handlers&lt;/code&gt; entries are interpreted as for the root logger, except that if a non-root logger&amp;rsquo;s level is specified as &lt;code&gt;NOTSET&lt;/code&gt;, the system consults loggers higher up the hierarchy to determine the effective level of the logger. The &lt;code&gt;propagate&lt;/code&gt; entry is set to 1 to indicate that messages must propagate to handlers higher up the logger hierarchy from this logger, or 0 to indicate that messages are &lt;strong&gt;not&lt;/strong&gt; propagated to handlers up the hierarchy. The &lt;code&gt;qualname&lt;/code&gt; entry is the hierarchical channel name of the logger, that is to say the name used by the application to get the logger.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 및 &lt;code&gt;handlers&lt;/code&gt; 비 루트 로거의 레벨로 지정된 경우 항목은 제외하고, 루트 로거로 해석됩니다 &lt;code&gt;NOTSET&lt;/code&gt; , 최대 시스템 문의 할 로거 높은 계층 로거의 유효 수준을 결정합니다. &lt;code&gt;propagate&lt;/code&gt; 항목은 그 메시지가이 로거에서 높은 로거 계층까지 핸들러에 전파해야하며, 0이 메시지를 표시하기 위해 표시하기 위해 1로 설정되어 &lt;strong&gt;있지&lt;/strong&gt; 계층까지 핸들러에 전달. &lt;code&gt;qualname&lt;/code&gt; 의 항목은 로거를 얻기 위해 응용 프로그램에서 사용하는 이름을 말을하는 것입니다 로거의 계층 채널 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a1cc2815c38730b635f4df6ea065b320e9beb19c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;level&lt;/code&gt; entry can be one of &lt;code&gt;DEBUG, INFO, WARNING, ERROR, CRITICAL&lt;/code&gt; or &lt;code&gt;NOTSET&lt;/code&gt;. For the root logger only, &lt;code&gt;NOTSET&lt;/code&gt; means that all messages will be logged. Level values are &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;uated in the context of the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 항목 중 하나가 될 수 있습니다 &lt;code&gt;DEBUG, INFO, WARNING, ERROR, CRITICAL&lt;/code&gt; 또는 &lt;code&gt;NOTSET&lt;/code&gt; . 루트 로거의 경우에만 &lt;code&gt;NOTSET&lt;/code&gt; 은 모든 메시지가 기록됨을 의미합니다. 레벨 값은 &lt;code&gt;logging&lt;/code&gt; 패키지의 네임 스페이스 컨텍스트에서 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="20549cb4258c041928c1d53bc24856087374a8f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logical_and()&lt;/code&gt;, &lt;code&gt;logical_invert()&lt;/code&gt;, &lt;code&gt;logical_or()&lt;/code&gt;, and &lt;code&gt;logical_xor()&lt;/code&gt; methods expect their arguments to be &lt;em&gt;logical operands&lt;/em&gt;. A &lt;em&gt;logical operand&lt;/em&gt; is a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance whose exponent and sign are both zero, and whose digits are all either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;logical_and()&lt;/code&gt; , &lt;code&gt;logical_invert()&lt;/code&gt; , &lt;code&gt;logical_or()&lt;/code&gt; , 및 &lt;code&gt;logical_xor()&lt;/code&gt; 메소드는 인수가 될 것으로 기대 &lt;em&gt;논리적 피연산자&lt;/em&gt; . &lt;em&gt;논리적 피연산자&lt;/em&gt; A는 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 그 지수 및 기호 양쪽 모두 0이고, 그 중 모든 숫자이다 인스턴스 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2894cd9ca319bdc7c0ff6fb46276e37f22647d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; arguments may have been modified or inferred from the original call.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 인수를 수정하거나 원래 통화에서 추정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17efeea07dfaa7e18f0e4f49edec6a634a2254b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; attributes can be set using keyword-only arguments to the constructor. When set they represent the name of the module that was attempted to be imported and the path to any file which triggered the exception, respectively.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;path&lt;/code&gt; 속성은 생성자에 키워드 전용 인수를 사용하여 설정할 수 있습니다. 설정되면 가져 오려고 시도한 모듈의 이름과 각각 예외를 트리거 한 파일의 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44ec035ffa5b84f633e8a9db377a08d7cf3735fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; is potentially a period-separated hierarchical value, like &lt;code&gt;foo.bar.baz&lt;/code&gt; (though it could also be just plain &lt;code&gt;foo&lt;/code&gt;, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of &lt;code&gt;foo&lt;/code&gt;, loggers with names of &lt;code&gt;foo.bar&lt;/code&gt;, &lt;code&gt;foo.bar.baz&lt;/code&gt;, and &lt;code&gt;foo.bam&lt;/code&gt; are all descendants of &lt;code&gt;foo&lt;/code&gt;. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt;. That&amp;rsquo;s because in a module, &lt;code&gt;__name__&lt;/code&gt; is the module&amp;rsquo;s name in the Python package namespace.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 잠재적으로 같은 기간으로 구분 계층 값이다 &lt;code&gt;foo.bar.baz&lt;/code&gt; (또한 평범한 일 수 있지만 &lt;code&gt;foo&lt;/code&gt; 는 예를 들어,). 계층 목록에서 더 아래에있는 로거는 목록에서 더 높은 로거의 하위입니다. 예를 들어, 이름이 &lt;code&gt;foo&lt;/code&gt; 인 로거가 주어지면 이름이 &lt;code&gt;foo.bar&lt;/code&gt; , &lt;code&gt;foo.bar.baz&lt;/code&gt; 및 &lt;code&gt;foo.bam&lt;/code&gt; 인 로거 는 모두 &lt;code&gt;foo&lt;/code&gt; 의 자손입니다 . 로거 이름 계층은 Python 패키지 계층과 유사하며 권장되는 구성 &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt; 사용하여 모듈별로 로거를 구성하는 경우와 동일합니다 . 모듈에서 &lt;code&gt;__name__&lt;/code&gt; 은 Python 패키지 네임 스페이스의 모듈 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c463374771af257aa19a3e7470848bbe19caa8c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p1.stdout.close()&lt;/code&gt; call after starting the p2 is important in order for p1 to receive a SIGPIPE if p2 exits before p1.</source>
          <target state="translated">&lt;code&gt;p1.stdout.close()&lt;/code&gt; P2 카드를 시작한 후 호출 P1 전에 P2 종료 만약 SIGPIPE를받을 P1 위해서는 중요하다.</target>
        </trans-unit>
        <trans-unit id="6c5afe3f20d08659f0801d09a465c4f246d3ab30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pickle&lt;/code&gt; module &lt;strong&gt;is not secure&lt;/strong&gt;. Only unpickle data you trust.</source>
          <target state="translated">&lt;code&gt;pickle&lt;/code&gt; 모듈은 &lt;strong&gt;안전하지 않습니다&lt;/strong&gt; . 신뢰할 수있는 데이터 만 피클 링하십시오.</target>
        </trans-unit>
        <trans-unit id="4f25fd4a79428a7a734c8203ffa74cdc9ffac57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll()&lt;/code&gt; system call, supported on most Unix systems, provides better scalability for network servers that service many, many clients at the same time. &lt;code&gt;poll()&lt;/code&gt; scales better because the system call only requires listing the file descriptors of interest, while &lt;code&gt;select()&lt;/code&gt; builds a bitmap, turns on bits for the fds of interest, and then afterward the whole bitmap has to be linearly scanned again. &lt;code&gt;select()&lt;/code&gt; is O(highest file descriptor), while &lt;code&gt;poll()&lt;/code&gt; is O(number of file descriptors).</source>
          <target state="translated">&lt;code&gt;poll()&lt;/code&gt; 대부분의 유닉스 시스템에서 지원 시스템 호출은 네트워크 서버에 대한 더 나은 확장 성을 제공하는 동시에 서비스 많은, 많은 클라이언트가. 시스템 호출은 관심있는 파일 설명자를 나열하기 만하면되기 때문에 &lt;code&gt;poll()&lt;/code&gt; 은 더 잘 확장됩니다. &lt;code&gt;select()&lt;/code&gt; 는 비트 맵을 빌드하고 관심있는 fd에 대한 비트를 설정 한 후 전체 비트 맵을 다시 선형으로 스캔해야하기 때문에 더 잘 확장됩니다. &lt;code&gt;select()&lt;/code&gt; 는 O (가장 높은 파일 디스크립터)이고 &lt;code&gt;poll()&lt;/code&gt; 은 O (파일 디스크립터 수)입니다.</target>
        </trans-unit>
        <trans-unit id="3adfcd2af06573abb2087db55784b60bbc3f041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popitem()&lt;/code&gt; method of &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; has a different signature. It accepts an optional argument to specify which item is popped.</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;popitem()&lt;/code&gt; 메소드는 서명이 다릅니다. 팝되는 항목을 지정하는 선택적 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f26b175564211cc5d95f4799adf4280e32941448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix_chars=&lt;/code&gt; argument defaults to &lt;code&gt;'-'&lt;/code&gt;. Supplying a set of characters that does not include &lt;code&gt;-&lt;/code&gt; will cause &lt;code&gt;-f/--foo&lt;/code&gt; options to be disallowed.</source>
          <target state="translated">&lt;code&gt;prefix_chars=&lt;/code&gt; 에 인수 기본값 &lt;code&gt;'-'&lt;/code&gt; . 포함하지 않는 문자 집합 공급 &lt;code&gt;-&lt;/code&gt; 원인이됩니다 &lt;code&gt;-f/--foo&lt;/code&gt; 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6cbc1096c67f757db14d69db3e5c36cba803f269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pyexpat&lt;/code&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pyexpat&lt;/code&gt; 의 모듈은 악의적으로 구성된 데이터에 대한 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56906a2e6d9db176d17fb2b6647596ea13b54940" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quantize()&lt;/code&gt; method rounds a number to a fixed exponent. This method is useful for monetary applications that often round results to a fixed number of places:</source>
          <target state="translated">&lt;code&gt;quantize()&lt;/code&gt; 메소드는 고정 지수의 숫자 반올림. 이 방법은 종종 고정 된 수의 장소로 결과를 반올림하는 통화 애플리케이션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="48b01acd0241a2442ff5b4aae7c3e1806b139057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read()&lt;/code&gt; (when called with a positive argument), &lt;code&gt;readinto()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; methods on this class will only make one system call.</source>
          <target state="translated">이 클래스 의 &lt;code&gt;read()&lt;/code&gt; (양의 인수로 호출 된 경우), &lt;code&gt;readinto()&lt;/code&gt; 및 &lt;code&gt;write()&lt;/code&gt; 메소드는 하나의 시스템 호출 만 수행합니다.</target>
        </trans-unit>
        <trans-unit id="56f3c5d9f151c39458862c4187286a2e030ef45f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register()&lt;/code&gt; attribute returns the undecorated function which enables decorator stacking, pickling, as well as creating unit tests for each variant independently:</source>
          <target state="translated">&lt;code&gt;register()&lt;/code&gt; 속성 산세뿐만 아니라, 각각 독립적 변종 단위 테스트를 만드는 장식 적층을 가능하게 장식되지 않은 기능을 리턴</target>
        </trans-unit>
        <trans-unit id="3dc67ec796044fe79c20baf27688a12b0b165186" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; function is used for interactive echo of expression values. It returns an altered version of the input string in which control codes, some BMP codepoints, and all non-BMP codepoints are replaced with escape codes. As demonstrated above, it allows one to identify the characters in a string, regardless of how they are displayed.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 기능 발현 값 대화식 에코에 대해 이용된다. 제어 코드, 일부 BMP ​​코드 포인트 및 BMP 이외의 모든 코드 포인트가 이스케이프 코드로 대체되는 변경된 버전의 입력 문자열을 리턴합니다. 위에서 설명했듯이 문자열의 표시 방법에 관계없이 문자열의 문자를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6694efe52e7d12ce180dcca2b71b57be3eda6fae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reverse()&lt;/code&gt; method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.</source>
          <target state="translated">&lt;code&gt;reverse()&lt;/code&gt; 대형 서열을 역전 할 때 방법은 공간을 절약하기 위하여 그 순서를 변경한다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 반대 순서를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70d611f664da4872758f6cac2500dc6d64789f50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rfile&lt;/code&gt; attributes of both classes support the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; readable interface, and &lt;code&gt;DatagramRequestHandler.wfile&lt;/code&gt; supports the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; writable interface.</source>
          <target state="translated">&lt;code&gt;rfile&lt;/code&gt; 의 두 클래스의 속성은 지원 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 읽을 수있는 인터페이스를하고 &lt;code&gt;DatagramRequestHandler.wfile&lt;/code&gt; 는 지지대 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 쓰기 가능한 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="2e5a1e0c9ba618171130cb7735890718c55a68eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run*&lt;/code&gt; functions and &lt;a href=&quot;#pdb.set_trace&quot;&gt;&lt;code&gt;set_trace()&lt;/code&gt;&lt;/a&gt; are aliases for instantiating the &lt;a href=&quot;#pdb.Pdb&quot;&gt;&lt;code&gt;Pdb&lt;/code&gt;&lt;/a&gt; class and calling the method of the same name. If you want to access further features, you have to do this yourself:</source>
          <target state="translated">&lt;code&gt;run*&lt;/code&gt; 기능과 &lt;a href=&quot;#pdb.set_trace&quot;&gt; &lt;code&gt;set_trace()&lt;/code&gt; &lt;/a&gt; 인스턴스화하는 앨리어스 (alias) &lt;a href=&quot;#pdb.Pdb&quot;&gt; &lt;code&gt;Pdb&lt;/code&gt; &lt;/a&gt; 클래스와 같은 이름의 메소드를 호출. 추가 기능에 액세스하려면 직접 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0c7daa1f0bf95ee399648b399e3569e912a4226" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sentinel&lt;/code&gt; object provides a convenient way of providing unique objects for your tests.</source>
          <target state="translated">&lt;code&gt;sentinel&lt;/code&gt; 목적은 당신의 검사 결과에 대해 고유 한 개체를 제공하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f2b8b9e54da55b5343a0feb08a9e06383efbd02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shake_128()&lt;/code&gt; and &lt;code&gt;shake_256()&lt;/code&gt; algorithms provide variable length digests with length_in_bits//2 up to 128 or 256 bits of security. As such, their digest methods require a length. Maximum length is not limited by the SHAKE algorithm.</source>
          <target state="translated">&lt;code&gt;shake_128()&lt;/code&gt; 및 &lt;code&gt;shake_256()&lt;/code&gt; 알고리즘은 보안의 128 또는 256 비트 length_in_bits // 2쪽으로 가변 길이 분해물을 제공한다. 따라서 다이제스트 방법에는 길이가 필요합니다. 최대 길이는 SHAKE 알고리즘에 의해 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2679ce48058db1acf0cd9c304d5a336da90caf62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;side_effect&lt;/code&gt; can also be any iterable object. Repeated calls to the mock will return values from the iterable (until the iterable is exhausted and a &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; is raised):</source>
          <target state="translated">&lt;code&gt;side_effect&lt;/code&gt; 은 또한 어떤 반복자 객체가 될 수 있습니다. mock에 대한 반복 호출은 iterable에서 값을 반환합니다 (iterable이 소진되고 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 이 발생할 때까지 ).</target>
        </trans-unit>
        <trans-unit id="bbc828704026e73a7132d7861c1f6ea3b2c9c718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sort&lt;/code&gt; command is a variant of &lt;code&gt;search&lt;/code&gt; with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; 명령의 변형입니다 &lt;code&gt;search&lt;/code&gt; 결과에 대한 의미를 정렬과 함께. 반환 된 데이터는 공백으로 구분 된 일치하는 메시지 번호 목록을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5e876713b1b58ed7e57cd0a3c49de12c593470a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; value of a &lt;code&gt;Group&lt;/code&gt; is formatted according to &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, but with no Content Transfer Encoding of any non-ASCII characters. If &lt;code&gt;display_name&lt;/code&gt; is none and there is a single &lt;code&gt;Address&lt;/code&gt; in the &lt;code&gt;addresses&lt;/code&gt; list, the &lt;code&gt;str&lt;/code&gt; value will be the same as the &lt;code&gt;str&lt;/code&gt; of that single &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Group&lt;/code&gt; 의 &lt;code&gt;str&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 에 따라 형식화 되지만 비 ASCII 문자의 컨텐츠 전송 인코딩은 없습니다. 경우 &lt;code&gt;display_name&lt;/code&gt; 포함되지 않은 하나의 존재 &lt;code&gt;Address&lt;/code&gt; 에서 &lt;code&gt;addresses&lt;/code&gt; 목록의 &lt;code&gt;str&lt;/code&gt; 값과 동일합니다 &lt;code&gt;str&lt;/code&gt; 그 하나의 &lt;code&gt;Address&lt;/code&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b50753b2718f1b5d3b1b08f7d48365835500f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; value of the object is the address quoted according to &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; rules, but with no Content Transfer Encoding of any non-ASCII characters.</source>
          <target state="translated">오브젝트 의 &lt;code&gt;str&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 규칙 에 따라 인용 된 주소 이지만 ASCII가 아닌 문자의 컨텐츠 전송 인코딩은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5863a575332c9bfbc7b8eeb262ad8abeefba260f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strptime()&lt;/code&gt; method can parse years in the full [1, 9999] range, but years &amp;lt; 1000 must be zero-filled to 4-digit width.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드는 전체 [1, 9999] 범위 년 분석 할 수 있지만, 세 &amp;lt;1000 4 자리 폭으로 제로 - 채워 져야한다.</target>
        </trans-unit>
        <trans-unit id="f40fa8d24afda44ef7ba1b9017535f589e255937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subject&lt;/code&gt; and &lt;code&gt;issuer&lt;/code&gt; fields are tuples containing the sequence of relative distinguished names (RDNs) given in the certificate&amp;rsquo;s data structure for the respective fields, and each RDN is a sequence of name-value pairs. Here is a real-world example:</source>
          <target state="translated">&lt;code&gt;subject&lt;/code&gt; 및 &lt;code&gt;issuer&lt;/code&gt; 필드는 각 필드에 대한 인증서의 데이터 구조에 대하여 소정의 식별 명 (RDN으로)의 서열을 포함하는 튜플이다 각 RDN은 이름 - 값 쌍들의 시퀀스이다. 실제 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2194956f69bee54fac6e836086327379d0dac748" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; attribute connot be of class &lt;a href=&quot;#ast.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.List&quot;&gt;&lt;code&gt;List&lt;/code&gt;&lt;/a&gt;, unlike the targets of &lt;a href=&quot;#ast.Assign&quot;&gt;&lt;code&gt;Assign&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 속성은 클래스의 수 connot &lt;a href=&quot;#ast.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ast.List&quot;&gt; &lt;code&gt;List&lt;/code&gt; &lt;/a&gt; 의 목표와는 달리 &lt;a href=&quot;#ast.Assign&quot;&gt; &lt;code&gt;Assign&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="48bc15cd70ec89240e8c5077ca67cca8ab36280e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thread&lt;/code&gt; command is a variant of &lt;code&gt;search&lt;/code&gt; with threading semantics for the results. Returned data contains a space separated list of thread members.</source>
          <target state="translated">&lt;code&gt;thread&lt;/code&gt; 명령의 변형 인 &lt;code&gt;search&lt;/code&gt; 결과에 대한 의미를 스레딩. 리턴 된 데이터는 공백으로 구분 된 스레드 멤버 목록을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c5c5ea850cd1efa343ff1614dddf878ebb3ae06f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to&lt;/code&gt; parameter must be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt; of strings or &lt;a href=&quot;os#os.PathLike&quot;&gt;&lt;code&gt;os.PathLike&lt;/code&gt;&lt;/a&gt; and not a string, all of which must be absolute paths. &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if something other than an absolute path is passed.</source>
          <target state="translated">&lt;code&gt;to&lt;/code&gt; 파라미터가 있어야 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-sequence&quot;&gt;시퀀스&lt;/a&gt; 문자열 또는 &lt;a href=&quot;os#os.PathLike&quot;&gt; &lt;code&gt;os.PathLike&lt;/code&gt; &lt;/a&gt; 절대 경로 여야 모두 아닌 문자열. 절대 경로 이외의 것이 전달 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="95c4f2f11ca60f7337a0bd2dddfc357c898cff74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Combobox&lt;/code&gt; widget combines a text field with a pop-down list of values. This widget is a subclass of &lt;code&gt;Entry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Combobox&lt;/code&gt; 값의 팝 다운 목록이있는 텍스트 필드를 결합 위젯. 이 위젯은 &lt;code&gt;Entry&lt;/code&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="352dd537bd626bd414d868a36dd17e8367456400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Progressbar&lt;/code&gt; widget shows the status of a long-running operation. It can operate in two modes: 1) the determinate mode which shows the amount completed relative to the total amount of work to be done and 2) the indeterminate mode which provides an animated display to let the user know that work is progressing.</source>
          <target state="translated">&lt;code&gt;ttk.Progressbar&lt;/code&gt; 는 쇼에게 장기 실행 작업의 상태를 위젯. 1) 수행 할 총 작업량과 관련하여 완료된 양을 표시하는 결정 모드와 2) 작업이 진행 중임을 사용자에게 알리는 애니메이션 표시를 제공하는 결정되지 않은 모드입니다.</target>
        </trans-unit>
        <trans-unit id="251bfa8f490dc70c8808050862bc83c86fb9d1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Separator&lt;/code&gt; widget displays a horizontal or vertical separator bar.</source>
          <target state="translated">&lt;code&gt;ttk.Separator&lt;/code&gt; 는 디스플레이를 수평 또는 수직 분리기 바 위젯.</target>
        </trans-unit>
        <trans-unit id="f758b0179e7d65969a79f1e77fd20a0943975f0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Sizegrip&lt;/code&gt; widget (also known as a grow box) allows the user to resize the containing toplevel window by pressing and dragging the grip.</source>
          <target state="translated">&lt;code&gt;ttk.Sizegrip&lt;/code&gt; 의 (도 성장한다 상자라고도 함) 위젯은 사용자가 누르고 그립을 끌어 포함하는 최상위 창 크기를 조정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f7c9dc42acbbb7afe7822de5598582a08914264" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Spinbox&lt;/code&gt; widget is a &lt;code&gt;ttk.Entry&lt;/code&gt; enhanced with increment and decrement arrows. It can be used for numbers or lists of string values. This widget is a subclass of &lt;code&gt;Entry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Spinbox&lt;/code&gt; A는 위젯 &lt;code&gt;ttk.Entry&lt;/code&gt; 증가 및 감소 화살표 향상. 숫자 또는 문자열 값 목록에 사용할 수 있습니다. 이 위젯은 &lt;code&gt;Entry&lt;/code&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="e6fc76a70719682fd79d2ebe3a3918e54edb387f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Treeview&lt;/code&gt; widget displays a hierarchical collection of items. Each item has a textual label, an optional image, and an optional list of data values. The data values are displayed in successive columns after the tree label.</source>
          <target state="translated">&lt;code&gt;ttk.Treeview&lt;/code&gt; 는 표시를 항목의 계층 적 모음 위젯. 각 항목에는 텍스트 레이블, 선택적 이미지 및 선택적 데이터 값 목록이 있습니다. 데이터 값은 트리 레이블 다음에 연속 열에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e2919d156958c0ab2b6cf34ca6fec36edfad34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;username&lt;/code&gt; portion of the address, with all quoting removed.</source>
          <target state="translated">모든 인용 부호가 제거 된 주소 의 &lt;code&gt;username&lt;/code&gt; 부분.</target>
        </trans-unit>
        <trans-unit id="7462f687d399e631ee022aa8a0c1be3259a71d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;username@domain&lt;/code&gt; portion of the address, correctly quoted for use as a bare address (the second form shown above). This attribute is not mutable.</source>
          <target state="translated">주소 의 &lt;code&gt;username@domain&lt;/code&gt; 부분으로 베어 주소 (위의 두 번째 형식)로 사용하기 위해 올바르게 인용됩니다. 이 속성은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e04165a0b7839d9196d963a9d99b152be548425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verify&lt;/code&gt; argument, if specified, should be a callable which should verify whether bytes received across the socket are valid and should be processed. This could be done by encrypting and/or signing what is sent across the socket, such that the &lt;code&gt;verify&lt;/code&gt; callable can perform signature verification and/or decryption. The &lt;code&gt;verify&lt;/code&gt; callable is called with a single argument - the bytes received across the socket - and should return the bytes to be processed, or &lt;code&gt;None&lt;/code&gt; to indicate that the bytes should be discarded. The returned bytes could be the same as the passed in bytes (e.g. when only verification is done), or they could be completely different (perhaps if decryption were performed).</source>
          <target state="translated">&lt;code&gt;verify&lt;/code&gt; 인수 지정된 경우, 소켓에 걸쳐 수신 된 바이트가 유효하고 처리할지 여부를 확인해야하는 호출 가능해야한다. 이것은 소켓을 통해 전송 된 것을 암호화 및 / 또는 서명함으로써 수행 될 수 있어서, &lt;code&gt;verify&lt;/code&gt; 호출 가능이 서명 검증 및 / 또는 복호화를 수행 할 수있다. 는 &lt;code&gt;verify&lt;/code&gt; 소켓 통해받은 바이트 - - 호출이 하나의 인자로 호출되고, 바이트 처리로 복귀한다, 또는 &lt;code&gt;None&lt;/code&gt; 바이트가 폐기되어야 함을 나타 내기 않음. 반환 된 바이트는 전달 된 바이트 수와 같거나 (예 : 확인 만 수행 된 경우) 완전히 다를 수 있습니다 (아마도 해독이 수행 된 경우).</target>
        </trans-unit>
        <trans-unit id="2bfd67854453b9508617bc5ecb87d6bf83b9e2f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version()&lt;/code&gt; function is the quickest way to get a distribution&amp;rsquo;s version number, as a string:</source>
          <target state="translated">&lt;code&gt;version()&lt;/code&gt; 함수는 문자열로, 분배의 버전 번호를 얻을 수있는 가장 빠른 방법입니다 :</target>
        </trans-unit>
        <trans-unit id="9457eb2c5daeb61cce915fa460df6791a47eebc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop checking for the application&amp;rsquo;s condition is necessary because &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; can return after an arbitrary long time, and the condition which prompted the &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; call may no longer hold true. This is inherent to multi-threaded programming. The &lt;a href=&quot;#threading.Condition.wait_for&quot;&gt;&lt;code&gt;wait_for()&lt;/code&gt;&lt;/a&gt; method can be used to automate the condition checking, and eases the computation of timeouts:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 때문에 응용 프로그램의 조건에 대해 루프 검사는 필요하지 않습니다 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 임의의 긴 시간 이후에 반환 할 수 있으며, 프롬프트 상태 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 호출이 성립 더 이상 할 수 있습니다. 이것은 다중 스레드 프로그래밍에 내재되어 있습니다. &lt;a href=&quot;#threading.Condition.wait_for&quot;&gt; &lt;code&gt;wait_for()&lt;/code&gt; &lt;/a&gt; 메소드는 조건 검사를 자동화하는 데 사용하고, 제한 시간의 계산을 용이하게 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="68b060fff3c4e153991c4ede204ad1db0712fced" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with&lt;/code&gt; block logs on &lt;em&gt;logger&lt;/em&gt; with minimum &lt;em&gt;level&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록에 기록 &lt;em&gt;로거&lt;/em&gt; 최소 &lt;em&gt;수준&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56866341ae5f26fd967e18a99077bcc3d2af97d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zoneinfo&lt;/code&gt; module does not directly provide time zone data, and instead pulls time zone information from the system time zone database or the first-party PyPI package &lt;a href=&quot;https://pypi.org/project/tzdata/&quot;&gt;tzdata&lt;/a&gt;, if available. Some systems, including notably Windows systems, do not have an IANA database available, and so for projects targeting cross-platform compatibility that require time zone data, it is recommended to declare a dependency on tzdata. If neither system data nor tzdata are available, all calls to &lt;a href=&quot;#zoneinfo.ZoneInfo&quot;&gt;&lt;code&gt;ZoneInfo&lt;/code&gt;&lt;/a&gt; will raise &lt;a href=&quot;#zoneinfo.ZoneInfoNotFoundError&quot;&gt;&lt;code&gt;ZoneInfoNotFoundError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;zoneinfo&lt;/code&gt; 모듈은 직접 시간대 데이터를 제공하고, 대신 시스템 시간대 데이터베이스 또는 제 1 사 PyPI 패키지에서 표준 시간대 정보를 가져옵니다하지 않는 &lt;a href=&quot;https://pypi.org/project/tzdata/&quot;&gt;tzdata를&lt;/a&gt; 사용할 수있는 경우. 특히 Windows 시스템을 포함한 일부 시스템에는 IANA 데이터베이스를 사용할 수 없으므로 시간대 데이터가 필요한 교차 플랫폼 호환성을 대상으로하는 프로젝트의 경우 tzdata에 대한 종속성을 선언하는 것이 좋습니다. 시스템 데이터도 tzdata도 사용할 수없는 경우 &lt;a href=&quot;#zoneinfo.ZoneInfo&quot;&gt; &lt;code&gt;ZoneInfo&lt;/code&gt; 에&lt;/a&gt; 대한 모든 호출 은 &lt;a href=&quot;#zoneinfo.ZoneInfoNotFoundError&quot;&gt; &lt;code&gt;ZoneInfoNotFoundError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="9356ea9fa5513a007b3e1c50146086929d32ee69" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Content-Length&lt;/em&gt; is treated as a lower bound: if there&amp;rsquo;s more data to read, urlretrieve reads more data, but if less data is available, it raises the exception.</source>
          <target state="translated">&lt;em&gt;콘텐츠 길이는&lt;/em&gt; 낮은 바운드로 처리됩니다 읽을 수있는 더 많은 데이터가 있다면, urlretrieve는 더 많은 데이터를 읽지 만 적은 데이터를 사용할 수있는 경우는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="5c8116d7ade8349a345be3650d95303855936cd6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;DndHandler&lt;/em&gt; class handles drag-and-drop events tracking Motion and ButtonRelease events on the root of the event widget.</source>
          <target state="translated">&lt;em&gt;DndHandler&lt;/em&gt; 이벤트 위젯의 루트에 모션 및 ButtonRelease 이벤트를 추적 클래스 핸들 드래그 앤 드롭 이벤트.</target>
        </trans-unit>
        <trans-unit id="a0fdb4923aa98d7d944fbee512e9d4d1baf28cd0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Emin&lt;/em&gt; and &lt;em&gt;Emax&lt;/em&gt; fields are integers specifying the outer limits allowable for exponents. &lt;em&gt;Emin&lt;/em&gt; must be in the range [&lt;a href=&quot;#decimal.MIN_EMIN&quot;&gt;&lt;code&gt;MIN_EMIN&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0&lt;/code&gt;], &lt;em&gt;Emax&lt;/em&gt; in the range [&lt;code&gt;0&lt;/code&gt;, &lt;a href=&quot;#decimal.MAX_EMAX&quot;&gt;&lt;code&gt;MAX_EMAX&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">&lt;em&gt;에민&lt;/em&gt; 과 &lt;em&gt;EMAX&lt;/em&gt; 필드는 지수에 대한 허용 바깥 쪽 한계를 지정하는 정수입니다. &lt;em&gt;Emin&lt;/em&gt; 은 [ &lt;a href=&quot;#decimal.MIN_EMIN&quot;&gt; &lt;code&gt;MIN_EMIN&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0&lt;/code&gt; ] 범위에 있고 &lt;em&gt;Emax&lt;/em&gt; 는 [ &lt;code&gt;0&lt;/code&gt; , &lt;a href=&quot;#decimal.MAX_EMAX&quot;&gt; &lt;code&gt;MAX_EMAX&lt;/code&gt; &lt;/a&gt; ] 범위 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="bace9f7d44c69a04a22a9a85d648d4395af511b9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;FileDialog&lt;/em&gt; class should be subclassed for custom event handling and behaviour.</source>
          <target state="translated">&lt;em&gt;의 FileDialog의&lt;/em&gt; 클래스는 사용자 정의 이벤트 처리 및 행동 서브 클래스해야합니다.</target>
        </trans-unit>
        <trans-unit id="099de42faf0f0b2a0cf8ddac8528d10fd5f74ec0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;allow_fragments&lt;/em&gt; argument has the same meaning and default as for &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;allow_fragments의&lt;/em&gt; 인수와 동일한 의미와 기본이 &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e831ae773ee2dd264b6b78cde7feab2044ba27e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;arg&lt;/em&gt; parameter depends on the previous event.</source>
          <target state="translated">&lt;em&gt;, 인수&lt;/em&gt; 매개 변수는 이전 이벤트에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="e8e08e0c1e7cb5d08ab5c2d641f0e97d0a518bb3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; argument as it was passed to &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; &amp;ndash; a sequence of program arguments or else a single string.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 에 전달 된 &lt;em&gt;args&lt;/em&gt; 인수 &amp;ndash; 프로그램 인수 시퀀스 또는 단일 문자열.</target>
        </trans-unit>
        <trans-unit id="1d3a577fd674bcea3227fd720956de76ed22bd4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; argument has the following attributes:</source>
          <target state="translated">&lt;em&gt;인수의&lt;/em&gt; 인수는 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fd13acf025140fb6639151e4ed9a4f868af627a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; parameter is set to the list of positional arguments to &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;, and the &lt;em&gt;kwargs&lt;/em&gt; parameter is set to the dictionary of keyword arguments.</source>
          <target state="translated">&lt;em&gt;인수&lt;/em&gt; 에 위치 인수 목록에 설정되어있는 파라미터 &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 및 &lt;em&gt;kwargs로&lt;/em&gt; 키워드 인자의 사전 설정된 파라미터.</target>
        </trans-unit>
        <trans-unit id="cbfbb46472247d0b887aaa75774bf8ab442ab41a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;argv&lt;/em&gt; argument can be a list of options passed to the program, with the first element being the program name. If not specified or &lt;code&gt;None&lt;/code&gt;, the values of &lt;a href=&quot;sys#sys.argv&quot;&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/a&gt; are used.</source>
          <target state="translated">&lt;em&gt;을 argv&lt;/em&gt; 인수는 첫 번째 요소는 프로그램 이름 인으로, 프로그램에 전달 옵션의 목록이 될 수 있습니다. 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;sys#sys.argv&quot;&gt; &lt;code&gt;sys.argv&lt;/code&gt; &lt;/a&gt; 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ec32e6f4f4f8b36e57871ee960b991c016f1627d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;aws&lt;/em&gt; iterable must not be empty.</source>
          <target state="translated">&lt;em&gt;AWS는&lt;/em&gt; 반복자는 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0cc005a8dd1192de2426a343f6644b9f34b41bf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;blacklist&lt;/em&gt; argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise.</source>
          <target state="translated">&lt;em&gt;블랙리스트&lt;/em&gt; 인수는 자신의 이름이 다르게 표시에도 공개 API의 일부로 취급해서는 안 이름의 집합이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d472fb09d267545549f54dfcd1448efdf7d1a71a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffering&lt;/em&gt; argument is ignored. Its use is deprecated since Python 3.0.</source>
          <target state="translated">&lt;em&gt;버퍼링&lt;/em&gt; 인수는 무시됩니다. 파이썬 3.0부터는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b5ef68ccd955c5bc87fad98f76a98a1362f7808" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;byteorder&lt;/em&gt; argument determines the byte order used to represent the integer. If &lt;em&gt;byteorder&lt;/em&gt; is &lt;code&gt;&quot;big&quot;&lt;/code&gt;, the most significant byte is at the beginning of the byte array. If &lt;em&gt;byteorder&lt;/em&gt; is &lt;code&gt;&quot;little&quot;&lt;/code&gt;, the most significant byte is at the end of the byte array. To request the native byte order of the host system, use &lt;a href=&quot;sys#sys.byteorder&quot;&gt;&lt;code&gt;sys.byteorder&lt;/code&gt;&lt;/a&gt; as the byte order value.</source>
          <target state="translated">&lt;em&gt;바이트 순서의&lt;/em&gt; 인수는 정수를 나타내는데 사용하는 바이트 순서를 결정한다. 경우 &lt;em&gt;바이트 순서가&lt;/em&gt; 있다 &lt;code&gt;&quot;big&quot;&lt;/code&gt; , 가장 중요한 바이트가 바이트 배열의 시작 부분입니다. 경우 &lt;em&gt;바이트 순서가&lt;/em&gt; 있다 &lt;code&gt;&quot;little&quot;&lt;/code&gt; , 최상위 바이트는 바이트 배열의 끝에서입니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 &lt;a href=&quot;sys#sys.byteorder&quot;&gt; &lt;code&gt;sys.byteorder&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe4c096e9d46ef87c6014cc8115884999f9571d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cadata&lt;/em&gt; object, if present, is either an ASCII string of one or more PEM-encoded certificates or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of DER-encoded certificates. Like with &lt;em&gt;capath&lt;/em&gt; extra lines around PEM-encoded certificates are ignored but at least one certificate must be present.</source>
          <target state="translated">&lt;em&gt;cadata의&lt;/em&gt; 오브젝트가 존재하는 경우, 어느 하나 이상의 PEM 인코딩 인증서 또는의 ASCII 문자열이다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 형 객체&lt;/a&gt; DER 인코딩 인증서. &lt;em&gt;캡틴&lt;/em&gt; 과 마찬가지로 PEM으로 인코딩 된 인증서 주변의 추가 라인은 무시되지만 하나 이상의 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1c5641e82f797cb25e6aee8b0aa51d313722eb3c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cadata&lt;/em&gt; object, if present, is either an ASCII string of one or more PEM-encoded certificates or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of DER-encoded certificates. Like with &lt;em&gt;capath&lt;/em&gt; extra lines around PEM-encoded certificates are ignored but at least one certificate must be present.</source>
          <target state="translated">&lt;em&gt;cadata의&lt;/em&gt; 오브젝트가 존재하는 경우, 어느 하나 이상의 PEM 인코딩 인증서 또는의 ASCII 문자열이다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트 형 객체&lt;/a&gt; DER 인코딩 인증서. &lt;em&gt;capath&lt;/em&gt; 와 마찬가지로 PEM 인코딩 인증서 주변의 추가 줄은 무시되지만 인증서가 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa644494d39e4ababa095081c9e901ded5d4e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cadefault&lt;/em&gt; parameter is ignored.</source>
          <target state="translated">&lt;em&gt;cadefault의&lt;/em&gt; 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17c8b195b094fb49ee9de35d0bdf391b2aeafc14" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cafile&lt;/em&gt; string, if present, is the path to a file of concatenated CA certificates in PEM format. See the discussion of &lt;a href=&quot;#ssl-certificates&quot;&gt;Certificates&lt;/a&gt; for more information about how to arrange the certificates in this file.</source>
          <target state="translated">&lt;em&gt;cafile에서의&lt;/em&gt; 문자열이 존재하는 경우, PEM 형식으로 연결된 CA 인증서 파일의 경로입니다. 이 파일에서 인증서를 배열하는 방법에 대한 자세한 정보 는 &lt;a href=&quot;#ssl-certificates&quot;&gt;인증서&lt;/a&gt; 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15c7daa6e069448b8e979e9ffc5f343170589a8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;callback&lt;/em&gt; callable must be thread-safe.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 호출 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f39a130157f612057b2a04830330e09fc1bb8b9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;callback&lt;/em&gt; is called with the Future object as its only argument.</source>
          <target state="translated">&lt;em&gt;콜백은&lt;/em&gt; 유일한 인수로 향후 개체라고합니다.</target>
        </trans-unit>
        <trans-unit id="7b7825c54e612df4242ae324acc59aa178b0a8be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capath&lt;/em&gt; string, if present, is the path to a directory containing several CA certificates in PEM format, following an &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html&quot;&gt;OpenSSL specific layout&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;capath에의&lt;/em&gt; 캐릭터 라인은, 현재의 경우, 다음 PEM 형식의 여러 CA 인증서를 포함하는 디렉토리의 경로 &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html&quot;&gt;에서 OpenSSL 특정 레이아웃을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0d6c3c720e62f41c129079fa155f95ad67efe5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capitals&lt;/em&gt; field is either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; (the default). If set to &lt;code&gt;1&lt;/code&gt;, exponents are printed with a capital &lt;code&gt;E&lt;/code&gt;; otherwise, a lowercase &lt;code&gt;e&lt;/code&gt; is used: &lt;code&gt;Decimal('6.02e+23')&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;자본의&lt;/em&gt; 필드 중 하나입니다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; (기본값). &lt;code&gt;1&lt;/code&gt; 로 설정하면 지수는 대문자 &lt;code&gt;E&lt;/code&gt; 로 인쇄됩니다 . 그렇지 않으면 소문자 &lt;code&gt;e&lt;/code&gt; 가 사용됩니다 : &lt;code&gt;Decimal('6.02e+23')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4471e81f460554b6a4cbdc7f3ddf8327b0a009" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capturestderr&lt;/em&gt; argument is replaced with the &lt;em&gt;stderr&lt;/em&gt; argument.</source>
          <target state="translated">&lt;em&gt;capturestderr의&lt;/em&gt; 인수는 대체됩니다 &lt;em&gt;열려진&lt;/em&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="82b367b59ab20936a4abae0ec9731b9670a88c72" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cb_type&lt;/em&gt; parameter allow selection of the desired channel binding type. Valid channel binding types are listed in the &lt;a href=&quot;#ssl.CHANNEL_BINDING_TYPES&quot;&gt;&lt;code&gt;CHANNEL_BINDING_TYPES&lt;/code&gt;&lt;/a&gt; list. Currently only the &amp;lsquo;tls-unique&amp;rsquo; channel binding, defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc5929.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5929&lt;/strong&gt;&lt;/a&gt;, is supported. &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if an unsupported channel binding type is requested.</source>
          <target state="translated">&lt;em&gt;cb_type의&lt;/em&gt; 파라미터는 원하는 채널 바인딩 타입의 선택을 허용한다. 유효한 채널 바인딩 유형은 &lt;a href=&quot;#ssl.CHANNEL_BINDING_TYPES&quot;&gt; &lt;code&gt;CHANNEL_BINDING_TYPES&lt;/code&gt; &lt;/a&gt; 목록에 나열되어 있습니다. 현재 &lt;a href=&quot;https://tools.ietf.org/html/rfc5929.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5929에&lt;/strong&gt;&lt;/a&gt; 의해 정의 된 'tls-unique'채널 바인딩 만 지원됩니다. 지원되지 않는 채널 바인딩 유형이 요청 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2ddc504d7b79bdd1162c0d5bd7b50a0a1521922" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;chars&lt;/em&gt; argument indicates the number of decoded code points or bytes to return. The &lt;a href=&quot;#codecs.StreamReader.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; method will never return more data than requested, but it might return less, if there is not enough available.</source>
          <target state="translated">&lt;em&gt;문자의&lt;/em&gt; 인수는 디코딩 코드 포인트의 수를 표시하거나 반환하는 바이트. &lt;a href=&quot;#codecs.StreamReader.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 메소드는 요청보다 더 많은 데이터를 반환하지 않습니다,하지만 충분한 존재하지 않는 경우는, 덜 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88197343169a15c41919f107e9bccf7f75352518" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;check&lt;/em&gt; argument specifies the type of integrity check to include in the compressed data. This check is used when decompressing, to ensure that the data has not been corrupted. Possible values are:</source>
          <target state="translated">&lt;em&gt;체크&lt;/em&gt; 인수 지정 무결성 검사의 유형 압축 데이터에 포함한다. 이 검사는 압축을 풀 때 데이터가 손상되지 않았는지 확인하는 데 사용됩니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3687dc03dd8946b6e5590e6e04cde893b863caa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;check_hostname&lt;/em&gt; parameter is also deprecated; the &lt;a href=&quot;ssl#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;ssl.SSLContext.check_hostname&lt;/code&gt;&lt;/a&gt; attribute of &lt;em&gt;context&lt;/em&gt; should be used instead.</source>
          <target state="translated">&lt;em&gt;check_hostname의&lt;/em&gt; 매개 변수는 사용되지 않습니다; &lt;em&gt;컨텍스트&lt;/em&gt; 의 &lt;a href=&quot;ssl#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;ssl.SSLContext.check_hostname&lt;/code&gt; &lt;/a&gt; 속성을 대신 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb93343e76b87a0f171f91290f48a421c682e6a1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;chunksize&lt;/em&gt; argument is the same as the one used by the &lt;a href=&quot;#multiprocessing.pool.Pool.map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method. For very long iterables using a large value for &lt;em&gt;chunksize&lt;/em&gt; can make the job complete &lt;strong&gt;much&lt;/strong&gt; faster than using the default value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;chunksize 영역의&lt;/em&gt; 인수에 의해 사용 된 것과 동일 &lt;a href=&quot;#multiprocessing.pool.Pool.map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 방법. &lt;em&gt;chunksize에&lt;/em&gt; 큰 값을 사용하는 iterable이 매우 긴 경우 기본값 &lt;code&gt;1&lt;/code&gt; 을 사용하는 것보다 작업을 &lt;strong&gt;훨씬&lt;/strong&gt; 빠르게 완료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcdd385b6dc12a6a9473a0c033d73137d50d5433" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;clamp&lt;/em&gt; field is either &lt;code&gt;0&lt;/code&gt; (the default) or &lt;code&gt;1&lt;/code&gt;. If set to &lt;code&gt;1&lt;/code&gt;, the exponent &lt;code&gt;e&lt;/code&gt; of a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance representable in this context is strictly limited to the range &lt;code&gt;Emin - prec + 1 &amp;lt;= e &amp;lt;= Emax - prec + 1&lt;/code&gt;. If &lt;em&gt;clamp&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt; then a weaker condition holds: the adjusted exponent of the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance is at most &lt;code&gt;Emax&lt;/code&gt;. When &lt;em&gt;clamp&lt;/em&gt; is &lt;code&gt;1&lt;/code&gt;, a large normal number will, where possible, have its exponent reduced and a corresponding number of zeros added to its coefficient, in order to fit the exponent constraints; this preserves the value of the number but loses information about significant trailing zeros. For example:</source>
          <target state="translated">&lt;em&gt;클램프&lt;/em&gt; 분야 중 하나입니다 &lt;code&gt;0&lt;/code&gt; (기본값) 또는 &lt;code&gt;1&lt;/code&gt; . &lt;code&gt;1&lt;/code&gt; 로 설정하면 이 컨텍스트에서 표현할 수 있는 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스 의 지수 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;Emin - prec + 1 &amp;lt;= e &amp;lt;= Emax - prec + 1&lt;/code&gt; 범위로 엄격하게 제한됩니다 . 경우 &lt;em&gt;클램프&lt;/em&gt; 인 &lt;code&gt;0&lt;/code&gt; 후 약한 상태가 원하는 분야의 조정 지수 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스는 많아야이다 &lt;code&gt;Emax&lt;/code&gt; . 경우 &lt;em&gt;클램프&lt;/em&gt; 인 &lt;code&gt;1&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;, 지수 제약 조건에 맞추기 위해, 가능한 경우, 큰 정규수는 지수가 감소되고 계수에 대응하는 수의 제로가 추가 될 것이다; 이렇게하면 숫자 값은 유지되지만 후행 0에 대한 정보는 손실됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7d326f4fcf7f161639b74c69e8c84eea6966131" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;client_connected_cb&lt;/em&gt; callback is called whenever a new client connection is established. It receives a &lt;code&gt;(reader, writer)&lt;/code&gt; pair as two arguments, instances of the &lt;a href=&quot;#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">&lt;em&gt;client_connected_cb의&lt;/em&gt; 새 클라이언트 연결이 설정 될 때마다 콜백이 호출됩니다. &lt;a href=&quot;#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 인 두 개의 인수로 &lt;code&gt;(reader, writer)&lt;/code&gt; 쌍을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a778098245593126ac70d38e2feddb7c5b0931" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;comment_factory&lt;/em&gt; and &lt;em&gt;pi_factory&lt;/em&gt; functions, when given, should behave like the &lt;a href=&quot;#xml.etree.ElementTree.Comment&quot;&gt;&lt;code&gt;Comment()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.etree.ElementTree.ProcessingInstruction&quot;&gt;&lt;code&gt;ProcessingInstruction()&lt;/code&gt;&lt;/a&gt; functions to create comments and processing instructions. When not given, the default factories will be used. When &lt;em&gt;insert_comments&lt;/em&gt; and/or &lt;em&gt;insert_pis&lt;/em&gt; is true, comments/pis will be inserted into the tree if they appear within the root element (but not outside of it).</source>
          <target state="translated">&lt;em&gt;comment_factory&lt;/em&gt; 및 &lt;em&gt;pi_factory&lt;/em&gt; 기능은 주어진 때처럼 행동한다 &lt;a href=&quot;#xml.etree.ElementTree.Comment&quot;&gt; &lt;code&gt;Comment()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.etree.ElementTree.ProcessingInstruction&quot;&gt; &lt;code&gt;ProcessingInstruction()&lt;/code&gt; &lt;/a&gt; 주석 및 처리 지침을 작성하는 기능을합니다. 지정하지 않으면 기본 팩토리가 사용됩니다. 때 &lt;em&gt;insert_comments&lt;/em&gt; 및 / 또는 &lt;em&gt;insert_pis이&lt;/em&gt; 사실 그들은 루트 요소 (그러나 밖에서의) 내에 표시하는 경우, 의견 / PIS가 트리에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="ae46dd7b8b3f0c9dff74383b81f0b0b055f15c1b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;completekey&lt;/em&gt;, &lt;em&gt;stdin&lt;/em&gt; and &lt;em&gt;stdout&lt;/em&gt; arguments are passed to the underlying &lt;a href=&quot;cmd#cmd.Cmd&quot;&gt;&lt;code&gt;cmd.Cmd&lt;/code&gt;&lt;/a&gt; class; see the description there.</source>
          <target state="translated">&lt;em&gt;completekey는&lt;/em&gt; , &lt;em&gt;표준 입력&lt;/em&gt; 과 &lt;em&gt;표준 출력&lt;/em&gt; 인수는 기본에 전달되는 &lt;a href=&quot;cmd#cmd.Cmd&quot;&gt; &lt;code&gt;cmd.Cmd&lt;/code&gt; 의&lt;/a&gt; 클래스; 거기에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1f18b255019414a78bdbbdc091b232a1484516" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from 0 to 9, as for the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인자는에 대해, 0 내지 9의 정수이고 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; 으로의&lt;/a&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="a61f0cb9aa11a7de1821e1143b80646c4fdd247d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from 1 to 9, as for the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인자는에 대해, 1 내지 9의 정수이고 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; 의&lt;/a&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="851d04e3fb4b234e2a60f5e3589b15db66360cf7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; controlling the level of compression; &lt;code&gt;1&lt;/code&gt; is fastest and produces the least compression, and &lt;code&gt;9&lt;/code&gt; is slowest and produces the most compression. &lt;code&gt;0&lt;/code&gt; is no compression. The default is &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인수의 정수이고 &lt;code&gt;0&lt;/code&gt; 행 &lt;code&gt;9&lt;/code&gt; 압축률을 제어하는 단계; &lt;code&gt;1&lt;/code&gt; 이 가장 빠르며 압축률 이 가장 낮고 &lt;code&gt;9&lt;/code&gt; 가 가장 느리고 압축률이 가장 높습니다. &lt;code&gt;0&lt;/code&gt; 은 압축이 없습니다. 기본값은 &lt;code&gt;9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e585639f4143e42300f1705d50d3747d42a1ad7b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; parameter became keyword-only.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 매개 변수는 키워드 전용되었다.</target>
        </trans-unit>
        <trans-unit id="c73bf8969ac57945539c860056209cac0643be6c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; parameter controls the compression level to use when writing files to the archive. When using &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt;&lt;code&gt;ZIP_STORED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#zipfile.ZIP_LZMA&quot;&gt;&lt;code&gt;ZIP_LZMA&lt;/code&gt;&lt;/a&gt; it has no effect. When using &lt;a href=&quot;#zipfile.ZIP_DEFLATED&quot;&gt;&lt;code&gt;ZIP_DEFLATED&lt;/code&gt;&lt;/a&gt; integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; are accepted (see &lt;a href=&quot;zlib#zlib.compressobj&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; for more information). When using &lt;a href=&quot;#zipfile.ZIP_BZIP2&quot;&gt;&lt;code&gt;ZIP_BZIP2&lt;/code&gt;&lt;/a&gt; integers &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; are accepted (see &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 아카이브에 파일을 기록 할 때 매개 변수 컨트롤은 압축 수준을 사용합니다. &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt; &lt;code&gt;ZIP_STORED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#zipfile.ZIP_LZMA&quot;&gt; &lt;code&gt;ZIP_LZMA&lt;/code&gt; 를&lt;/a&gt; 사용할 때는 효과가 없습니다. &lt;a href=&quot;#zipfile.ZIP_DEFLATED&quot;&gt; &lt;code&gt;ZIP_DEFLATED&lt;/code&gt; 를&lt;/a&gt; 사용 하는 경우 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; 까지의 정수 가 허용됩니다 ( 자세한 내용 은 &lt;a href=&quot;zlib#zlib.compressobj&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 참조 ). 사용시 &lt;a href=&quot;#zipfile.ZIP_BZIP2&quot;&gt; &lt;code&gt;ZIP_BZIP2&lt;/code&gt; &lt;/a&gt; 정수 &lt;code&gt;1&lt;/code&gt; 내지 &lt;code&gt;9&lt;/code&gt; 접수를 (참조 &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="ddb13b39623dcafcf4f44aec9717c0167926fdf6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;context&lt;/em&gt; precision does not affect how many digits are stored. That is determined exclusively by the number of digits in &lt;em&gt;value&lt;/em&gt;. For example, &lt;code&gt;Decimal('3.00000')&lt;/code&gt; records all five zeros even if the context precision is only three.</source>
          <target state="translated">&lt;em&gt;상황에 맞는&lt;/em&gt; 정밀도는 저장 얼마나 많은 숫자에 영향을주지 않습니다. 이는 &lt;em&gt;값&lt;/em&gt; 의 자릿수에 의해서만 결정됩니다 . 예를 들어, &lt;code&gt;Decimal('3.00000')&lt;/code&gt; 은 컨텍스트 정밀도가 3에 불과하더라도 5 개의 0을 모두 기록합니다.</target>
        </trans-unit>
        <trans-unit id="d5e6fbc8c11370385eb242760b9740f5836b90d3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;conversion&lt;/em&gt; field causes a type coercion before formatting. Normally, the job of formatting a value is done by the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt; method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt;, the normal formatting logic is bypassed.</source>
          <target state="translated">&lt;em&gt;변환&lt;/em&gt; 필드 포맷하기 전에 유형 강제 변환됩니다. 일반적으로 값을 형식화하는 작업은 값 자체 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 수행 됩니다. 그러나 경우에 따라 형식을 문자열 형식으로 지정하여 형식에 대한 자체 정의를 재정의하는 것이 바람직합니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 값을 문자열로 변환하면 일반 형식 지정 논리가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4aba90ac1ebe706d09c9254e33b29e5df1b60774" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;conversion&lt;/em&gt; field causes a type coercion before formatting. Normally, the job of formatting a value is done by the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt; method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt;, the normal formatting logic is bypassed.</source>
          <target state="translated">&lt;em&gt;변환&lt;/em&gt; 필드 포맷하기 전에 유형 강제 변환됩니다. 일반적으로 값을 포맷하는 작업은 값 자체 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 수행 됩니다. 그러나 어떤 경우에는 형식에 대한 자체 정의를 재정 의하여 형식을 문자열로 강제로 지정하는 것이 바람직합니다. &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 값을 문자열로 변환하면 일반 형식화 논리가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2cdc701e2c81ec997648e61d22b6adb27be68cf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;d&lt;/em&gt;&amp;rsquo;th day (0 &amp;lt;= &lt;em&gt;d&lt;/em&gt; &amp;lt;= 6) of week &lt;em&gt;n&lt;/em&gt; of month &lt;em&gt;m&lt;/em&gt; of the year (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 5, 1 &amp;lt;= &lt;em&gt;m&lt;/em&gt; &amp;lt;= 12, where week 5 means &amp;ldquo;the last &lt;em&gt;d&lt;/em&gt; day in month &lt;em&gt;m&lt;/em&gt;&amp;rdquo; which may occur in either the fourth or the fifth week). Week 1 is the first week in which the &lt;em&gt;d&lt;/em&gt;&amp;rsquo;th day occurs. Day zero is a Sunday.</source>
          <target state="translated">&lt;em&gt;D&lt;/em&gt; '일째 (0 &amp;lt;= &lt;em&gt;D&lt;/em&gt; &amp;lt;= 6) 주 &lt;em&gt;N&lt;/em&gt; 개월의 &lt;em&gt;m&lt;/em&gt; 올 (1 &amp;lt;= &lt;em&gt;N&lt;/em&gt; &amp;lt;= 5, 1 &amp;lt;= &lt;em&gt;m&lt;/em&gt; &amp;lt;= 12, 여기서 주 5 수단 &quot;마지막 &lt;em&gt;차원&lt;/em&gt; 날 개월 &lt;em&gt;m&lt;/em&gt; &amp;rdquo;) (4 번째 또는 5 번째 주에 발생할 수 있음). 1 주차는 &lt;em&gt;d&lt;/em&gt; 번째 날 이 발생한 첫 주입니다 . 0 일은 일요일입니다.</target>
        </trans-unit>
        <trans-unit id="9036429e9d7f5146bc247599a86f71fa7486b2b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; argument can be whatever the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function supports (i.e. string or bytes). The &lt;em&gt;path&lt;/em&gt; argument should be the &amp;ldquo;path&amp;rdquo; to where the source code originated from, which can be an abstract concept (e.g. location in a zip file).</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 인수는 무엇이든 할 수있다 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 기능 지원 (예 : 문자열 또는 바이트). &lt;em&gt;경로&lt;/em&gt; 인수는 소스 코드는 추상적 인 개념 (zip 파일의 예를 들어 위치)가 될 수있는, 어디에서 유래에 &quot;경로&quot;이어야한다.</target>
        </trans-unit>
        <trans-unit id="8e21c5c2ac1fec214edb5720c17f5f7ed3424d7e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; can be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; and should consist of values that can be converted to type &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;data&lt;/em&gt; does not contain at least two elements, raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; because it takes at least one point to estimate a central value and at least two points to estimate dispersion.</source>
          <target state="translated">&lt;em&gt;데이터는&lt;/em&gt; 임의의 것일 수있는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 및 유형으로 변환 할 수있는 값으로 구성되어야 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;데이터가&lt;/em&gt; 적어도 두 개의 요소를 포함하지 않는 상승 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 을&lt;/a&gt; 그 중심 값과 추정 된 분산에 적어도 두 점을 추정하는 적어도 하나의 포인트 걸리므.</target>
        </trans-unit>
        <trans-unit id="688e1646a7e1acbf93ea4a901e56df5c1326f757" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; can be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; and should consist of values that can be converted to type &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;data&lt;/em&gt; does not contain at least two elements, raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; because it takes at least one point to estimate a central value and at least two points to estimate dispersion.</source>
          <target state="translated">&lt;em&gt;데이터는&lt;/em&gt; 임의의 것일 수있는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 및 유형으로 변환 할 수있는 값으로 구성되어야 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;데이터가&lt;/em&gt; 적어도 두 개의 요소를 포함하지 않는 상승 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 을&lt;/a&gt; 그 중심 값과 추정 된 분산에 적어도 두 점을 추정하는 적어도 하나의 포인트 걸리므.</target>
        </trans-unit>
        <trans-unit id="0b832475cfa8a9dd77d9b1b927964df35f6bb322" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; can be any iterable containing sample data. For meaningful results, the number of data points in &lt;em&gt;data&lt;/em&gt; should be larger than &lt;em&gt;n&lt;/em&gt;. Raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; if there are not at least two data points.</source>
          <target state="translated">&lt;em&gt;데이터는&lt;/em&gt; 어떠한 반복 가능 함유 샘플 데이터 일 수있다. 의미있는 결과를 들면, 데이터 포인트의 개수 &lt;em&gt;데이터&lt;/em&gt; 보다 커야 &lt;em&gt;N&lt;/em&gt; . 발생시킵니다 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 는&lt;/a&gt; 적어도 두 개의 데이터 포인트가없는 경우.</target>
        </trans-unit>
        <trans-unit id="d46475fe7beb032a1dde9b71f62e7b60ff7cca66" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; parameter will be the entire contents of the declaration inside the &lt;code&gt;&amp;lt;![...]&amp;gt;&lt;/code&gt; markup. It is sometimes useful to be overridden by a derived class. The base class implementation does nothing.</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 파라미터는 내부 선언의 전체 내용이 될 것이다 &lt;code&gt;&amp;lt;![...]&amp;gt;&lt;/code&gt; 태그. 파생 클래스로 재정의하는 것이 유용한 경우가 있습니다. 기본 클래스 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd72e401bf63a75fade8457ee5eccda856af08af" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;debug_override&lt;/em&gt; parameter is deprecated and can be used to override the system&amp;rsquo;s value for &lt;code&gt;__debug__&lt;/code&gt;. A &lt;code&gt;True&lt;/code&gt; value is the equivalent of setting &lt;em&gt;optimization&lt;/em&gt; to the empty string. A &lt;code&gt;False&lt;/code&gt; value is the same as setting &lt;em&gt;optimization&lt;/em&gt; to &lt;code&gt;1&lt;/code&gt;. If both &lt;em&gt;debug_override&lt;/em&gt; an &lt;em&gt;optimization&lt;/em&gt; are not &lt;code&gt;None&lt;/code&gt; then &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;debug_override의&lt;/em&gt; 매개 변수는 사용되지 않으며위한 시스템의 값을 대체하는 데 사용할 수 있습니다 &lt;code&gt;__debug__&lt;/code&gt; 을 . &lt;code&gt;True&lt;/code&gt; 값을 설정하는 것과 동일 &lt;em&gt;최적화를&lt;/em&gt; 빈 문자열로. &lt;code&gt;False&lt;/code&gt; 값을 설정하는 것과 같습니다 &lt;em&gt;최적화&lt;/em&gt; 에 &lt;code&gt;1&lt;/code&gt; . 두 경우 &lt;em&gt;debug_override &lt;/em&gt;&lt;em&gt;최적화&lt;/em&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 다음 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99e0c356da751dd166a63e978dc2a39c5eedc1fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;decl&lt;/em&gt; parameter will be the entire contents of the declaration inside the &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; markup (e.g. &lt;code&gt;'DOCTYPE html'&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;자명 한 일 입니의&lt;/em&gt; 매개 변수는 내부의 선언의 전체 내용이 될 것입니다 &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; 마크 업 (예를 들어 &lt;code&gt;'DOCTYPE html'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ef3824e032cf9a741f848cb50c2d7646000b316" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;defaultTest&lt;/em&gt; argument is either the name of a single test or an iterable of test names to run if no test names are specified via &lt;em&gt;argv&lt;/em&gt;. If not specified or &lt;code&gt;None&lt;/code&gt; and no test names are provided via &lt;em&gt;argv&lt;/em&gt;, all tests found in &lt;em&gt;module&lt;/em&gt; are run.</source>
          <target state="translated">&lt;em&gt;defaultTest&lt;/em&gt; 인수는 하나 하나 테스트의 이름이나 더 테스트 이름을 통해 지정되지 않은 경우 실행 테스트 이름의 반복자입니다 &lt;em&gt;ARGV&lt;/em&gt; . &lt;em&gt;argv&lt;/em&gt; 를 통해 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이고 테스트 이름이 제공되지 않으면 &lt;em&gt;모듈&lt;/em&gt; 에서 찾은 모든 테스트 가 실행됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d19d5ca4548580938d6b4d9329d9a62bbfc3144" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;defects&lt;/em&gt; attribute contains a list of all the problems found when parsing this message. See &lt;a href=&quot;email.errors#module-email.errors&quot;&gt;&lt;code&gt;email.errors&lt;/code&gt;&lt;/a&gt; for a detailed description of the possible parsing defects.</source>
          <target state="translated">&lt;em&gt;결함의&lt;/em&gt; 속성은이 메시지를 구문 분석 할 때 발견 된 모든 문제의 목록이 포함되어 있습니다. 가능한 구문 분석 결함에 대한 자세한 설명은 &lt;a href=&quot;email.errors#module-email.errors&quot;&gt; &lt;code&gt;email.errors&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3f2596b66bd7ed716cf9dba1109e5f24389e006" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dict_type&lt;/em&gt; is the type used for dictionaries that are read from the plist file.</source>
          <target state="translated">&lt;em&gt;dict_type는&lt;/em&gt; PLIST 파일에서 읽어 사전에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4e0020d0746abd869d54f08c307ddd6914e84e24" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dir&lt;/em&gt;, &lt;em&gt;prefix&lt;/em&gt; and &lt;em&gt;suffix&lt;/em&gt; parameters have the same meaning and defaults as with &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;DIR&lt;/em&gt; , &lt;em&gt;접두사&lt;/em&gt; 와 &lt;em&gt;접미사&lt;/em&gt; 매개 변수와 동일한 의미와 기본값이 &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678377d21d95b5da2eccbd2ed6a5bf79dc5f7822" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;domain&lt;/em&gt; argument allows overriding the NIS domain used for the lookup. If unspecified, lookup is in the default NIS domain.</source>
          <target state="translated">&lt;em&gt;도메인&lt;/em&gt; 인수는 조회에 사용되는 NIS 도메인을 무시 허용한다. 지정하지 않으면 조회가 기본 NIS 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="541a21c0d12fc17803562f97e87bab04e8920e68" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;doraise&lt;/em&gt; and &lt;em&gt;quiet&lt;/em&gt; arguments determine how errors are handled while compiling file. If &lt;em&gt;quiet&lt;/em&gt; is 0 or 1, and &lt;em&gt;doraise&lt;/em&gt; is false, the default behaviour is enabled: an error string is written to &lt;code&gt;sys.stderr&lt;/code&gt;, and the function returns &lt;code&gt;None&lt;/code&gt; instead of a path. If &lt;em&gt;doraise&lt;/em&gt; is true, a &lt;a href=&quot;#py_compile.PyCompileError&quot;&gt;&lt;code&gt;PyCompileError&lt;/code&gt;&lt;/a&gt; is raised instead. However if &lt;em&gt;quiet&lt;/em&gt; is 2, no message is written, and &lt;em&gt;doraise&lt;/em&gt; has no effect.</source>
          <target state="translated">&lt;em&gt;doraise&lt;/em&gt; 과 &lt;em&gt;조용한&lt;/em&gt; 인수 파일을 컴파일하는 동안 오류를 처리하는 방법을 결정합니다. 경우 &lt;em&gt;조용한는&lt;/em&gt; 0 또는 1이고, &lt;em&gt;doraise는&lt;/em&gt; 오류 문자열에 기록됩니다 거짓, 기본 동작이 활성화되지 &lt;code&gt;sys.stderr&lt;/code&gt; 를 하고, 함수 반환 &lt;code&gt;None&lt;/code&gt; 대신 경로. 경우 &lt;em&gt;doraise는&lt;/em&gt; 사실이다하는 &lt;a href=&quot;#py_compile.PyCompileError&quot;&gt; &lt;code&gt;PyCompileError&lt;/code&gt; 가&lt;/a&gt; 대신 발생합니다. 그러나 &lt;em&gt;quiet&lt;/em&gt; 가 2이면 메시지가 작성 되지 않으며 &lt;em&gt;doraise&lt;/em&gt; 가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f45beba9ae9b99fd6eddff1254b265a6b06ccf7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dt&lt;/em&gt; argument is ignored. The return value is a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; instance equal to the difference between the local time and UTC.</source>
          <target state="translated">&lt;em&gt;DT의&lt;/em&gt; 인수는 무시됩니다. 반환 값은 현지 시간과 UTC의 차이와 동일한 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7ed9f309122fc25ff8178610e7f4da0a59231fe1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encode&lt;/em&gt; and &lt;em&gt;decode&lt;/em&gt; arguments must adhere to the &lt;code&gt;Codec&lt;/code&gt; interface. &lt;em&gt;Reader&lt;/em&gt; and &lt;em&gt;Writer&lt;/em&gt; must be factory functions or classes providing objects of the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; interface respectively.</source>
          <target state="translated">&lt;em&gt;인 코드&lt;/em&gt; 및 &lt;em&gt;디코드&lt;/em&gt; 인수는 준수해야 &lt;code&gt;Codec&lt;/code&gt; 인터페이스를 제공합니다. &lt;em&gt;Reader&lt;/em&gt; 와 &lt;em&gt;Writer&lt;/em&gt; 는 각각 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 인터페이스의 객체를 제공하는 팩토리 함수 또는 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="29e7c348a1628ee9dd37b6150c94cd6ec0cfbf2a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encode_chunked&lt;/em&gt; argument is only relevant if Transfer-Encoding is specified in &lt;em&gt;headers&lt;/em&gt;. If &lt;em&gt;encode_chunked&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the HTTPConnection object assumes that all encoding is handled by the calling code. If it is &lt;code&gt;True&lt;/code&gt;, the body will be chunk-encoded.</source>
          <target state="translated">&lt;em&gt;encode_chunked&lt;/em&gt; 전송 인코딩이 지정되면 인수는 관련이 &lt;em&gt;헤더&lt;/em&gt; . 경우 &lt;em&gt;encode_chunked이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 의 HttpConnection에 객체는 모든 인코딩이 호출 코드에 의해 처리되어 있다고 가정합니다. 이 경우 &lt;code&gt;True&lt;/code&gt; , 몸은 덩어리 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c325607a7de886abde53f31697d71ac0d9b3a43d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; arguments define the character encoding to be used for reading or writing the archive and how conversion errors are going to be handled. The default settings will work for most users. See section &lt;a href=&quot;#tar-unicode&quot;&gt;Unicode issues&lt;/a&gt; for in-depth information.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 인수는 문자 인코딩 읽거나 아카이브를 작성하는 방법과 변환 오류 처리 할 예정에 사용되는 정의합니다. 기본 설정은 대부분의 사용자에게 적용됩니다. 자세한 정보는 &lt;a href=&quot;#tar-unicode&quot;&gt;유니 코드 문제&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c14540e9d5e02ef282d24989bc0560f5d43b74be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encoding&lt;/em&gt; argument behaves like the corresponding argument of &lt;a href=&quot;#xml.dom.minidom.Node.toxml&quot;&gt;&lt;code&gt;toxml()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;코딩&lt;/em&gt; 의 대응하는 인자처럼 행동한다 인수 &lt;a href=&quot;#xml.dom.minidom.Node.toxml&quot;&gt; &lt;code&gt;toxml()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="77ab38b7127187e79b77fe535f5b759fb3f1914b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encoding&lt;/em&gt; argument behaves like the corresponding argument of &lt;code&gt;toxml()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;코딩&lt;/em&gt; 의 대응하는 인자처럼 행동한다 인수 &lt;code&gt;toxml()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5ea8da7e93711f96576b90a0535523be394058" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epilogue&lt;/em&gt; attribute acts the same way as the &lt;em&gt;preamble&lt;/em&gt; attribute, except that it contains text that appears between the last boundary and the end of the message.</source>
          <target state="translated">&lt;em&gt;에필로그&lt;/em&gt; 속성은 같은 방식으로 작동 &lt;em&gt;프리앰블&lt;/em&gt; 은 텍스트가 포함 된 것을 제외하고, 속성을 그 마지막 경계와 메시지의 끝 사이가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="922c64a430cac350255517325dcc4e95110a3128" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epilogue&lt;/em&gt; attribute acts the same way as the &lt;em&gt;preamble&lt;/em&gt; attribute, except that it contains text that appears between the last boundary and the end of the message. As with the &lt;a href=&quot;#email.message.EmailMessage.preamble&quot;&gt;&lt;code&gt;preamble&lt;/code&gt;&lt;/a&gt;, if there is no epilog text this attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;에필로그&lt;/em&gt; 속성은 같은 방식으로 작동 &lt;em&gt;프리앰블&lt;/em&gt; 은 텍스트가 포함 된 것을 제외하고, 속성을 그 마지막 경계와 메시지의 끝 사이가 나타납니다. &lt;a href=&quot;#email.message.EmailMessage.preamble&quot;&gt; &lt;code&gt;preamble&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 에필로그 텍스트가없는 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07e6075314e49857e472236bdfa91c705e2f0813" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epoch&lt;/em&gt; is the point where the time starts, and is platform dependent. For Unix, the epoch is January 1, 1970, 00:00:00 (UTC). To find out what the epoch is on a given platform, look at &lt;code&gt;time.gmtime(0)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;시대는&lt;/em&gt; 시간이 시작되는 지점이며, 플랫폼에 따라 달라집니다. 유닉스의 시대는 1970 년 1 월 1 일 00:00:00 (UTC)입니다. 주어진 플랫폼에서 신기원이 무엇인지 알아 보려면 &lt;code&gt;time.gmtime(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3738dcf310d32e085451a3c93f9bf3c820ec7a6b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument defines how characters are treated that cannot be converted. Possible values are listed in section &lt;a href=&quot;codecs#error-handlers&quot;&gt;Error Handlers&lt;/a&gt;. The default scheme is &lt;code&gt;'surrogateescape'&lt;/code&gt; which Python also uses for its file system calls, see &lt;a href=&quot;os#os-filenames&quot;&gt;File Names, Command Line Arguments, and Environment Variables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 문자는 변환 할 수없는 것을 처리하는 방법을 인수 정의합니다. 가능한 값은 &lt;a href=&quot;codecs#error-handlers&quot;&gt;오류 처리기&lt;/a&gt; 섹션에 나열되어 있습니다 . 기본 체계는 파이썬이 파일 시스템 호출에 사용하는 &lt;code&gt;'surrogateescape'&lt;/code&gt; 입니다 ( &lt;a href=&quot;os#os-filenames&quot;&gt;파일 이름, 명령 줄 인수 및 환경 변수 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="accd6ed2c4add06dcc82825a5c29164b4aa44ad7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument defines the error handling to apply. It defaults to &lt;code&gt;'strict'&lt;/code&gt; handling.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 적용 오류 처리를 정의합니다. 기본값은 &lt;code&gt;'strict'&lt;/code&gt; 처리입니다.</target>
        </trans-unit>
        <trans-unit id="417c35e3c3489ecae455dfd7cc1fdfb4272d8a54" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0193b2731a3bc5048c2a96e0d3333506018910d7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07408f3978c0e16f152e5b37f0839ea36889cf01" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 특성에 할당하면 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56664efc67b073b3b091d3fb8068398e69c0cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 객체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdb2e9827a01e7259645dad2c2d3343a896529f4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;exec_body&lt;/em&gt; argument is a callback that is used to populate the freshly created class namespace. It should accept the class namespace as its sole argument and update the namespace directly with the class contents. If no callback is provided, it has the same effect as passing in &lt;code&gt;lambda ns: ns&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;exec_body&lt;/em&gt; 인수는 새로 생성 된 클래스 네임 스페이스를 채우는 데 사용되는 콜백입니다. 클래스 네임 스페이스를 유일한 인수로 허용하고 클래스 컨텐츠로 네임 스페이스를 직접 업데이트해야합니다. 콜백이 제공되지 않으면 &lt;code&gt;lambda ns: ns&lt;/code&gt; 를 전달하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c7ca7eb02e1ac631fb9b49acf3b5fa4fbcaaa0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executable&lt;/em&gt; argument specifies a replacement program to execute. It is very seldom needed. When &lt;code&gt;shell=False&lt;/code&gt;, &lt;em&gt;executable&lt;/em&gt; replaces the program to execute specified by &lt;em&gt;args&lt;/em&gt;. However, the original &lt;em&gt;args&lt;/em&gt; is still passed to the program. Most programs treat the program specified by &lt;em&gt;args&lt;/em&gt; as the command name, which can then be different from the program actually executed. On POSIX, the &lt;em&gt;args&lt;/em&gt; name becomes the display name for the executable in utilities such as &lt;strong&gt;ps&lt;/strong&gt;. If &lt;code&gt;shell=True&lt;/code&gt;, on POSIX the &lt;em&gt;executable&lt;/em&gt; argument specifies a replacement shell for the default &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;실행&lt;/em&gt; 인수는 실행할 대체 프로그램을 지정합니다. 거의 필요하지 않습니다. &lt;code&gt;shell=False&lt;/code&gt; 일 때 &lt;em&gt;실행 파일&lt;/em&gt; 은 &lt;em&gt;args로&lt;/em&gt; 지정된 실행 프로그램을 대체합니다 . 그러나 원래 &lt;em&gt;인수&lt;/em&gt; 는 여전히 프로그램으로 전달됩니다. 대부분의 프로그램은 &lt;em&gt;args&lt;/em&gt; 로 지정된 프로그램을 명령 이름으로 취급하므로 실제로 실행되는 프로그램과 다를 수 있습니다. POSIX에서 &lt;em&gt;args&lt;/em&gt; 이름은 &lt;strong&gt;ps&lt;/strong&gt; 와 같은 유틸리티에서 실행 파일의 표시 이름이됩니다 . &lt;code&gt;shell=True&lt;/code&gt; 인 경우 POSIX에서 &lt;em&gt;실행 가능&lt;/em&gt; 인수는 기본 &lt;code&gt;/bin/sh&lt;/code&gt; 의 대체 쉘을 지정합니다..</target>
        </trans-unit>
        <trans-unit id="a2283b4e58ae37a66ef528c3791a1b7ee66c3708" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; argument should be an &lt;a href=&quot;concurrent.futures#concurrent.futures.Executor&quot;&gt;&lt;code&gt;concurrent.futures.Executor&lt;/code&gt;&lt;/a&gt; instance. The default executor is used if &lt;em&gt;executor&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;실행 프로그램&lt;/em&gt; 인수는해야 &lt;a href=&quot;concurrent.futures#concurrent.futures.Executor&quot;&gt; &lt;code&gt;concurrent.futures.Executor&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다. &lt;em&gt;실행 프로그램&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 경우 기본 실행 프로그램이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc0182bbf1f5e1c0e30b3cb44d4050e6085c5147" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;expression&lt;/em&gt; argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; dictionaries as global and local namespace. If the &lt;em&gt;globals&lt;/em&gt; dictionary is present and does not contain a value for the key &lt;code&gt;__builtins__&lt;/code&gt;, a reference to the dictionary of the built-in module &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; is inserted under that key before &lt;em&gt;expression&lt;/em&gt; is parsed. This means that &lt;em&gt;expression&lt;/em&gt; normally has full access to the standard &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; module and restricted environments are propagated. If the &lt;em&gt;locals&lt;/em&gt; dictionary is omitted it defaults to the &lt;em&gt;globals&lt;/em&gt; dictionary. If both dictionaries are omitted, the expression is executed with the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; in the environment where &lt;a href=&quot;#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; is called. Note, &lt;em&gt;eval()&lt;/em&gt; does not have access to the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;nested scopes&lt;/a&gt; (non-locals) in the enclosing environment.</source>
          <target state="translated">&lt;em&gt;식&lt;/em&gt; 인수는 구문 분석하고 사용하며 (기술적 조건 목록을 말하기) 파이썬 표현으로 평가 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역 주민의&lt;/em&gt; 글로벌 및 로컬 네임 스페이스로 사전을. 경우] &lt;em&gt;전역의&lt;/em&gt; 사전 존재하고, 키의 값이 포함되지 않는 &lt;code&gt;__builtins__&lt;/code&gt; , 내장 모듈의 사전 참조 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 전에 키에 삽입되어 &lt;em&gt;발현&lt;/em&gt; 해석된다. 이는 &lt;em&gt;표현식이&lt;/em&gt; 일반적으로 표준 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 모듈에 대한 전체 액세스 권한을 가지며 제한된 환경이 전파됨을 의미합니다. &lt;em&gt;지역&lt;/em&gt; 사전이 생략 되면 기본값은&lt;em&gt;글로벌&lt;/em&gt; 사전. 두 사전을 모두 생략하면 &lt;a href=&quot;#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 이 호출 되는 환경에서 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역&lt;/em&gt; 을 사용하여 표현식이 실행됩니다 . 참고 &lt;em&gt;평가는 ()&lt;/em&gt; 에 액세스 할 수 없습니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;중첩 된 범위를&lt;/a&gt; 둘러싸고있는 환경에서 (비 지역 주민).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd377d1fc4e40dff60ddc4d4c18d876a2a66f0b7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;expression&lt;/em&gt; argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; dictionaries as global and local namespace. If the &lt;em&gt;globals&lt;/em&gt; dictionary is present and does not contain a value for the key &lt;code&gt;__builtins__&lt;/code&gt;, a reference to the dictionary of the built-in module &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; is inserted under that key before &lt;em&gt;expression&lt;/em&gt; is parsed. This means that &lt;em&gt;expression&lt;/em&gt; normally has full access to the standard &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; module and restricted environments are propagated. If the &lt;em&gt;locals&lt;/em&gt; dictionary is omitted it defaults to the &lt;em&gt;globals&lt;/em&gt; dictionary. If both dictionaries are omitted, the expression is executed with the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; in the environment where &lt;a href=&quot;#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; is called. Note, &lt;em&gt;eval()&lt;/em&gt; does not have access to the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-nested-scope&quot;&gt;nested scopes&lt;/a&gt; (non-locals) in the enclosing environment.</source>
          <target state="translated">&lt;em&gt;식&lt;/em&gt; 인수는 구문 분석하고 사용하며 (기술적 조건 목록을 말하기) 파이썬 표현으로 평가 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역 주민의&lt;/em&gt; 글로벌 및 로컬 네임 스페이스로 사전을. 경우] &lt;em&gt;전역의&lt;/em&gt; 사전 존재하고, 키의 값이 포함되지 않는 &lt;code&gt;__builtins__&lt;/code&gt; , 내장 모듈의 사전 참조 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 전에 키에 삽입되어 &lt;em&gt;발현&lt;/em&gt; 해석된다. 이는 &lt;em&gt;표현식이&lt;/em&gt; 일반적으로 표준 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 모듈에 대한 전체 액세스 권한을 가지며 제한된 환경이 전파됨을 의미합니다. &lt;em&gt;지역&lt;/em&gt; 사전이 생략 되면 기본값은&lt;em&gt;전역&lt;/em&gt; 사전. 두 사전을 모두 생략하면 &lt;a href=&quot;#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 이 호출 되는 환경에서 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역&lt;/em&gt; 을 사용하여 표현식이 실행됩니다 . 참고 &lt;em&gt;평가는 ()&lt;/em&gt; 에 액세스 할 수 없습니다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-nested-scope&quot;&gt;중첩 된 범위를&lt;/a&gt; 둘러싸고있는 환경에서 (비 지역 주민).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c27bdb65636017d6b3ff59ca63cf0593fdd5b0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;extra&lt;/em&gt; argument can be a set of names that wouldn&amp;rsquo;t otherwise be automatically detected as &amp;ldquo;public&amp;rdquo;, like objects without a proper &lt;code&gt;__module__&lt;/code&gt; attribute. If provided, it will be added to the automatically detected ones.</source>
          <target state="translated">&lt;em&gt;추가&lt;/em&gt; 인수는 적절한없이 객체와 같은 그렇지 않으면 자동으로 &quot;공개&quot;로 감지되지 않을 것이다 이름의 설정을 할 수 있습니다 &lt;code&gt;__module__&lt;/code&gt; 의 속성. 제공되는 경우 자동 감지 된 항목에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a08cf90e834703ae213fd12223835ee5ad8adf15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;failfast&lt;/em&gt;, &lt;em&gt;catchbreak&lt;/em&gt; and &lt;em&gt;buffer&lt;/em&gt; parameters have the same effect as the same-name &lt;a href=&quot;#command-line-options&quot;&gt;command-line options&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;페일 패스트&lt;/em&gt; , &lt;em&gt;catchbreak&lt;/em&gt; 및 &lt;em&gt;버퍼&lt;/em&gt; 파라미터와 동일한 이름과 동일한 효과가 &lt;a href=&quot;#command-line-options&quot;&gt;명령 행 옵션&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="874e26c7407b8380f904f71fc4795a0f8587333f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;proto&lt;/em&gt; arguments can be optionally specified in order to narrow the list of addresses returned. Passing zero as a value for each of these arguments selects the full range of results. The &lt;em&gt;flags&lt;/em&gt; argument can be one or several of the &lt;code&gt;AI_*&lt;/code&gt; constants, and will influence how results are computed and returned. For example, &lt;code&gt;AI_NUMERICHOST&lt;/code&gt; will disable domain name resolution and will raise an error if &lt;em&gt;host&lt;/em&gt; is a domain name.</source>
          <target state="translated">&lt;em&gt;가족&lt;/em&gt; , &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;프로토&lt;/em&gt; 인수는 선택적으로 반환 주소 목록을 축소하기 위해 지정 될 수 있습니다. 이러한 각 인수의 값으로 0을 전달하면 전체 범위의 결과가 선택됩니다. &lt;em&gt;플래그&lt;/em&gt; 인수는 하나 또는 여러 될 수 있습니다 &lt;code&gt;AI_*&lt;/code&gt; 상수 및 결과를 계산하고 반환하는 방법에 영향을 미칠 것이다. 예를 들어 &lt;code&gt;AI_NUMERICHOST&lt;/code&gt; 는 도메인 이름 확인을 비활성화하고 &lt;em&gt;호스트&lt;/em&gt; 가 도메인 이름 인 경우 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f85bfe90a7abfa4522d7aec6379ca2959433acc1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;field_name&lt;/em&gt; itself begins with an &lt;em&gt;arg_name&lt;/em&gt; that is either a number or a keyword. If it&amp;rsquo;s a number, it refers to a positional argument, and if it&amp;rsquo;s a keyword, it refers to a named keyword argument. If the numerical arg_names in a format string are 0, 1, 2, &amp;hellip; in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, &amp;hellip; will be automatically inserted in that order. Because &lt;em&gt;arg_name&lt;/em&gt; is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings &lt;code&gt;'10'&lt;/code&gt; or &lt;code&gt;':-]'&lt;/code&gt;) within a format string. The &lt;em&gt;arg_name&lt;/em&gt; can be followed by any number of index or attribute expressions. An expression of the form &lt;code&gt;'.name'&lt;/code&gt; selects the named attribute using &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt;, while an expression of the form &lt;code&gt;'[index]'&lt;/code&gt; does an index lookup using &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;FIELD_NAME&lt;/em&gt; 자체는 시작 &lt;em&gt;arg_name&lt;/em&gt; 숫자 나 키워드 중 하나입니다. 숫자 인 경우 위치 인수를 나타내고 키워드 인 경우 명명 된 키워드 인수를 나타냅니다. 형식 문자열의 숫자 arg_name이 순서대로 0, 1, 2,&amp;hellip; 인 경우 모두 생략 할 수 있으며 숫자 0, 1, 2,&amp;hellip;가 자동으로 순서대로 삽입됩니다. 때문에 &lt;em&gt;arg_name가&lt;/em&gt; 구분 인용되지 않으며, 이는 임의의 키를 사전에 특정 할 수 없다 (예를 들어, 문자열 &lt;code&gt;'10'&lt;/code&gt; 또는 &lt;code&gt;':-]'&lt;/code&gt; ) 형식 문자열 내의. &lt;em&gt;arg_name은&lt;/em&gt; 인덱스 또는 속성 표현의 수에 따라 할 수있다. &lt;code&gt;'.name'&lt;/code&gt; 형식의 표현식&lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 사용하여 이름 지정된 속성을 선택하고 &lt;code&gt;'[index]'&lt;/code&gt; 양식의 표현식은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 사용하여 색인을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="90f39f5920e4b70dcd2efd9d3e40a321fc16dc4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;field_name&lt;/em&gt; itself begins with an &lt;em&gt;arg_name&lt;/em&gt; that is either a number or a keyword. If it&amp;rsquo;s a number, it refers to a positional argument, and if it&amp;rsquo;s a keyword, it refers to a named keyword argument. If the numerical arg_names in a format string are 0, 1, 2, &amp;hellip; in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, &amp;hellip; will be automatically inserted in that order. Because &lt;em&gt;arg_name&lt;/em&gt; is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings &lt;code&gt;'10'&lt;/code&gt; or &lt;code&gt;':-]'&lt;/code&gt;) within a format string. The &lt;em&gt;arg_name&lt;/em&gt; can be followed by any number of index or attribute expressions. An expression of the form &lt;code&gt;'.name'&lt;/code&gt; selects the named attribute using &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt;, while an expression of the form &lt;code&gt;'[index]'&lt;/code&gt; does an index lookup using &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;FIELD_NAME&lt;/em&gt; 자체는 시작 &lt;em&gt;arg_name&lt;/em&gt; 숫자 나 키워드 중 하나입니다. 숫자이면 위치 인수를, 키워드이면 명명 된 키워드 인수를 나타냅니다. 형식 문자열의 숫자 arg_names가 순서대로 0, 1, 2,&amp;hellip;이면 모두 생략 할 수 있으며 (일부뿐 아니라) 숫자 0, 1, 2,&amp;hellip;이 해당 순서로 자동 삽입됩니다. 때문에 &lt;em&gt;arg_name가&lt;/em&gt; 구분 인용되지 않으며, 이는 임의의 키를 사전에 특정 할 수없는 (예를 들어, 문자열 &lt;code&gt;'10'&lt;/code&gt; 또는 &lt;code&gt;':-]'&lt;/code&gt; ) 형식 문자열 내의. &lt;em&gt;arg_name은&lt;/em&gt; 인덱스 또는 속성 표현의 수에 따라 할 수있다. &lt;code&gt;'.name'&lt;/code&gt; 형식의 표현식&lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 사용하여 명명 된 속성을 선택하는 반면 &lt;code&gt;'[index]'&lt;/code&gt; 형식의 표현식은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 사용하여 인덱스 조회를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="c6d4fb8370566360de6f478e25e82c7c55877045" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;field_names&lt;/em&gt; are a sequence of strings such as &lt;code&gt;['x', 'y']&lt;/code&gt;. Alternatively, &lt;em&gt;field_names&lt;/em&gt; can be a single string with each fieldname separated by whitespace and/or commas, for example &lt;code&gt;'x y'&lt;/code&gt; or &lt;code&gt;'x, y'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;FIELD_NAMES가&lt;/em&gt; 같은 문자열의 시퀀스이다 &lt;code&gt;['x', 'y']&lt;/code&gt; . 또는 &lt;em&gt;field_names&lt;/em&gt; 는 각 필드 이름이 공백 및 / 또는 쉼표로 구분 된 단일 문자열 일 수 있습니다 (예 : &lt;code&gt;'x y'&lt;/code&gt; 또는 &lt;code&gt;'x, y'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac35b9bd55fdc804fb4c9bb3bd701f67c7d5c57d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fieldnames&lt;/em&gt; parameter is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt;. If &lt;em&gt;fieldnames&lt;/em&gt; is omitted, the values in the first row of file &lt;em&gt;f&lt;/em&gt; will be used as the fieldnames. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering.</source>
          <target state="translated">&lt;em&gt;fieldName에의&lt;/em&gt; 파라미터는 인 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-sequence&quot;&gt;시퀀스&lt;/a&gt; . 필드 &lt;em&gt;이름&lt;/em&gt; 을 생략하면 파일 &lt;em&gt;f&lt;/em&gt; 의 첫 번째 행에있는 값 이 필드 이름으로 사용됩니다. 필드 이름이 어떻게 결정되는지에 관계없이 사전은 원래 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ef84d61b49143906b402edc190aa09cf41450ecf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fieldnames&lt;/em&gt; parameter is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt;. If &lt;em&gt;fieldnames&lt;/em&gt; is omitted, the values in the first row of file &lt;em&gt;f&lt;/em&gt; will be used as the fieldnames. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering.</source>
          <target state="translated">&lt;em&gt;fieldName에의&lt;/em&gt; 파라미터는 인 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-sequence&quot;&gt;시퀀스&lt;/a&gt; . 경우 &lt;em&gt;fieldName에가&lt;/em&gt; 생략되어, 파일의 첫 번째 행의 값 &lt;em&gt;F는&lt;/em&gt; fieldName에로 사용될 것이다. 필드 이름이 결정되는 방법에 관계없이 사전은 원래 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="86a8ce72332326de2cfebbc785262328b5fe47c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument is an I/O stream to which the output is written; by default output is written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수 출력이 기록되는에 I / O 스트림이고; 기본적으로 출력은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 에&lt;/a&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6040de02499cbcc78ffe2e6448ad957eea44c1ad" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument must be an object with a &lt;code&gt;write(string)&lt;/code&gt; method; if it is not present or &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; will be used. Since printed arguments are converted to text strings, &lt;a href=&quot;#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; cannot be used with binary mode file objects. For these, use &lt;code&gt;file.write(...)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수는 가진 객체 여야 &lt;code&gt;write(string)&lt;/code&gt; 방법; 존재하지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 인쇄 된 인수는 텍스트 문자열로 변환되므로 &lt;a href=&quot;#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 는 이진 모드 파일 객체와 함께 사용할 수 없습니다. 이를 위해 대신 &lt;code&gt;file.write(...)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa19d5965537594f6e3e44281d687c4aee5dfebd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument must have a write() method that accepts a single bytes argument. It can thus be an on-disk file opened for binary writing, an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; instance, or any other custom object that meets this interface.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수는 단일 바이트 인수를 받아들이는 쓰기 () 메소드가 있어야합니다. 따라서 이진 쓰기를 위해 열린 온 디스크 파일, &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 인스턴스 또는이 인터페이스를 충족하는 다른 사용자 지정 개체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201c087ccb99a58c31b45c2b8d49929eddafdd3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the fault handler is disabled: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일은&lt;/em&gt; 결함 핸들러가 비활성화 될 때까지 개방 유지해야한다 : 참조 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d824b624f53e9446bead5d0c937eff0e8b3123" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the signal is unregistered by &lt;a href=&quot;#faulthandler.unregister&quot;&gt;&lt;code&gt;unregister()&lt;/code&gt;&lt;/a&gt;: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일이&lt;/em&gt; 신호가 등록 해제 될 때까지 개방 유지해야 &lt;a href=&quot;#faulthandler.unregister&quot;&gt; &lt;code&gt;unregister()&lt;/code&gt; &lt;/a&gt; : 참조 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c60c6ff1b28a53b914ece79a1a14de1b66fed36f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the traceback is dumped or &lt;a href=&quot;#faulthandler.cancel_dump_traceback_later&quot;&gt;&lt;code&gt;cancel_dump_traceback_later()&lt;/code&gt;&lt;/a&gt; is called: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일을&lt;/em&gt; 역 추적이 덤프 될 때까지 또는 개방 유지해야 &lt;a href=&quot;#faulthandler.cancel_dump_traceback_later&quot;&gt; &lt;code&gt;cancel_dump_traceback_later()&lt;/code&gt; &lt;/a&gt; 참조하십시오라고 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a5d02926f630f9388faa40b312c84ee98f366aa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file_actions&lt;/em&gt; argument may be a sequence of tuples describing actions to take on specific file descriptors in the child process between the C library implementation&amp;rsquo;s &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; steps. The first item in each tuple must be one of the three type indicator listed below describing the remaining tuple elements:</source>
          <target state="translated">&lt;em&gt;file_actions의&lt;/em&gt; 인수는 C 라이브러리 구현 사이의 자식 프로세스의 특정 파일 디스크립터에 수행 할 동작을 설명하는 튜플들의 시퀀스 일 수있다 &lt;code&gt;fork()&lt;/code&gt; 와 &lt;code&gt;exec()&lt;/code&gt; 단계. 각 튜플의 첫 번째 항목은 나머지 튜플 요소를 설명하는 아래에 나열된 세 가지 유형 표시기 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="574ad47a01d4d5dcdc30c910d4f1c794203d0425" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument can be an actual filename (a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object), or an existing file object to read from or write to.</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 인수는 실제 파일 이름 (A 할 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체), 또는 나 쓰기에 읽을 수있는 기존 파일 개체를.</target>
        </trans-unit>
        <trans-unit id="f033d031375597aa29c16f1a2c2f915020115b6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument can be either an actual file name (given as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object), in which case the named file is opened, or it can be an existing file object to read from or write to.</source>
          <target state="translated">&lt;em&gt;파일명&lt;/em&gt; 인수 할 수 있습니다 (A로서 주어진 실제 파일 이름 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은&lt;/a&gt; ,이 경우에 지정된 파일을 열 또는 그것으로부터 또는 기록을 판독 기존 파일 오브젝트 일 수 오브젝트).</target>
        </trans-unit>
        <trans-unit id="0c479c05efc5b2dddea76faf2b1ab73e6034d128" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument can be either an actual file name (given as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object), in which case the named file is opened, or it can be an existing file object to read from or write to.</source>
          <target state="translated">&lt;em&gt;파일명&lt;/em&gt; 인수 할 수 있습니다 (A로서 주어진 실제 파일 이름 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;경로와 같은&lt;/a&gt; ,이 경우에 지정된 파일을 열 또는 그것으로부터 또는 기록을 판독 기존 파일 오브젝트 일 수 오브젝트).</target>
        </trans-unit>
        <trans-unit id="0545d354ccd3ed5753d4a3cb4b6a2b0b028f6ed5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument should give the file from which the code was read; pass some recognizable value if it wasn&amp;rsquo;t read from a file (&lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; is commonly used).</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 인수는 코드를 읽은있는 파일을 제공해야합니다; 파일에서 읽지 않은 경우 인식 가능한 값을 전달하십시오 ( &lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; 이 일반적으로 사용됨).</target>
        </trans-unit>
        <trans-unit id="79131f6c9ec73987bfeb48e4342c755777c193ff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filters&lt;/em&gt; argument (if provided) should be a filter chain specifier. See &lt;a href=&quot;#filter-chain-specs&quot;&gt;Specifying custom filter chains&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;필터&lt;/em&gt; 인수 (있는 경우)의 필터 체인 지정해야한다. 자세한 내용은 &lt;a href=&quot;#filter-chain-specs&quot;&gt;사용자 정의 필터 체인 지정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="408e886918eee46fcb78729db9d3758b4414e533" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filters&lt;/em&gt; argument specifies the filter chain that was used to create the stream being decompressed. This argument is required if &lt;em&gt;format&lt;/em&gt; is &lt;code&gt;FORMAT_RAW&lt;/code&gt;, but should not be used for other formats. See &lt;a href=&quot;#filter-chain-specs&quot;&gt;Specifying custom filter chains&lt;/a&gt; for more information about filter chains.</source>
          <target state="translated">&lt;em&gt;필터&lt;/em&gt; 인수 압축되는 스트림을 생성하는데 사용 된 필터 체인을 지정한다. &lt;em&gt;format&lt;/em&gt; 이 &lt;code&gt;FORMAT_RAW&lt;/code&gt; 인 경우이 인수가 필요 하지만 다른 형식에는 사용하지 않아야합니다. &lt;a href=&quot;#filter-chain-specs&quot;&gt;필터 체인에&lt;/a&gt; 대한 자세한 내용은 사용자 지정 필터 체인 지정을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f878d73c0efd98476dfc7a9b6cd6ad2c5b1de9d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;firstline&lt;/em&gt; flag indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines.</source>
          <target state="translated">&lt;em&gt;firstLine의&lt;/em&gt; 플래그는 나중에 라인 디코딩 오류가있는 경우에만, 첫 번째 행을 반환하기에 충분 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac4ac00687930f48d3d074bf948c94183e0fde15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;flags&lt;/em&gt; entry shows that the rational approximation to &lt;code&gt;Pi&lt;/code&gt; was rounded (digits beyond the context precision were thrown away) and that the result is inexact (some of the discarded digits were non-zero).</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 항목의 합리적인 근사 것을 보여준다 &lt;code&gt;Pi&lt;/code&gt; 반올림 (컨텍스트 정밀도 이후 자리 폐기 하였다), 그 결과가 정확하지 않은 것을 (폐기 된 숫자 중 일부는 비 - 제로였다).</target>
        </trans-unit>
        <trans-unit id="6d6f6e39e403984a4847eaa33b4050de83b8f060" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fmt&lt;/em&gt; argument specifies the format of the plist file and can be one of the following values:</source>
          <target state="translated">&lt;em&gt;FMT의&lt;/em&gt; 인수는 PLIST 파일의 형식을 지정하고 다음 값 중 하나 일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="082a80c3e67542d38e417ef51374d4c86db647c6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fmt&lt;/em&gt; is the format of the file and the following values are valid:</source>
          <target state="translated">&lt;em&gt;FMT는&lt;/em&gt; 파일의 형식이며 다음 값이 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="734f781d1046d3f0c2a738be36757146bb995a3f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; argument specifies the container format that should be used. The default is &lt;code&gt;FORMAT_AUTO&lt;/code&gt;, which can decompress both &lt;code&gt;.xz&lt;/code&gt; and &lt;code&gt;.lzma&lt;/code&gt; files. Other possible values are &lt;code&gt;FORMAT_XZ&lt;/code&gt;, &lt;code&gt;FORMAT_ALONE&lt;/code&gt;, and &lt;code&gt;FORMAT_RAW&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 인수를 사용해야 컨테이너 형식을 지정합니다. 기본값은 &lt;code&gt;FORMAT_AUTO&lt;/code&gt; 이며 &lt;code&gt;.xz&lt;/code&gt; 및 &lt;code&gt;.lzma&lt;/code&gt; 파일을 모두 압축 해제 할 수 있습니다. 다른 가능한 값은 &lt;code&gt;FORMAT_XZ&lt;/code&gt; , &lt;code&gt;FORMAT_ALONE&lt;/code&gt; 및 &lt;code&gt;FORMAT_RAW&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d0e2b25e206ba418847ddd00bd26fd5a6a4f7db" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; argument specifies what container format should be used. Possible values are:</source>
          <target state="translated">&lt;em&gt;포맷&lt;/em&gt; 어떤 컨테이너 형식 인수 지정을 사용해야합니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04f2de35ac0704ac281d73b5042b2f29f702dc28" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; parameter uses the same directives as those used by &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;; it defaults to &lt;code&gt;&quot;%a %b %d %H:%M:%S %Y&quot;&lt;/code&gt; which matches the formatting returned by &lt;a href=&quot;#time.ctime&quot;&gt;&lt;code&gt;ctime()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;string&lt;/em&gt; cannot be parsed according to &lt;em&gt;format&lt;/em&gt;, or if it has excess data after parsing, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. The default values used to fill in any missing data when more accurate values cannot be inferred are &lt;code&gt;(1900, 1, 1, 0, 0, 0, 0, 1, -1)&lt;/code&gt;. Both &lt;em&gt;string&lt;/em&gt; and &lt;em&gt;format&lt;/em&gt; must be strings.</source>
          <target state="translated">&lt;em&gt;포맷&lt;/em&gt; 파라미터에 의해 사용되는 것과 같은 사용 지시문 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; ; 기본값은 &lt;code&gt;&quot;%a %b %d %H:%M:%S %Y&quot;&lt;/code&gt; 이며 &lt;a href=&quot;#time.ctime&quot;&gt; &lt;code&gt;ctime()&lt;/code&gt; &lt;/a&gt; 반환 한 형식과 일치합니다 . 경우 &lt;em&gt;문자열&lt;/em&gt; 에 따라 구문 분석 할 수없는 &lt;em&gt;형식&lt;/em&gt; 은 구문 분석 후 초과 데이터가있는 경우, 또는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 더 정확한 값을 유추 할 수없는 경우 누락 된 데이터를 채우는 데 사용되는 기본값은 &lt;code&gt;(1900, 1, 1, 0, 0, 0, 0, 1, -1)&lt;/code&gt; 입니다. &lt;em&gt;문자열&lt;/em&gt; 과 &lt;em&gt;형식&lt;/em&gt; 은 모두 &lt;em&gt;문자열&lt;/em&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4acae6593e4e526e2dd1506dcee311e81a8b65fb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format_spec&lt;/em&gt; field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own &amp;ldquo;formatting mini-language&amp;rdquo; or interpretation of the &lt;em&gt;format_spec&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;format_spec&lt;/em&gt; 필드는 값이 너무 필드 폭, 정렬, 패딩, 소수점 정밀도와 같은 세부 사항을 포함, 제시 방법의 사양이 포함되어 있습니다. 각 값 유형은 자체 &quot;포맷 미니 언어&quot;또는 &lt;em&gt;format_spec&lt;/em&gt; 해석을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d65dc8f14d94c0d358e1bb13b0be3cd77bc040c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;from_addr&lt;/em&gt; and &lt;em&gt;to_addrs&lt;/em&gt; parameters are used to construct the message envelope used by the transport agents. &lt;code&gt;sendmail&lt;/code&gt; does not modify the message headers in any way.</source>
          <target state="translated">&lt;em&gt;from_addr&lt;/em&gt; 및 &lt;em&gt;to_addrs&lt;/em&gt; 파라미터 전송 에이전트에 의해 사용되는 메시지 엔벨로프를 구성하는 데 사용된다. &lt;code&gt;sendmail&lt;/code&gt; 은 어떤 방식 으로든 메시지 헤더를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f0efc2987cba5877b55bc8427e0a05d7b5359a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fullname&lt;/em&gt; argument is a fully resolved name of the module the loader is to handle. The &lt;em&gt;path&lt;/em&gt; argument is the path to the file for the module.</source>
          <target state="translated">&lt;em&gt;전체 이름의&lt;/em&gt; 인수는 로더가 처리 할 수있는 모듈의 완전히 확인 된 이름입니다. &lt;em&gt;경로&lt;/em&gt; 인수는 모듈 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e3b5b1e7f6306fdfed32d8aa3e48723c730e25bb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fullname&lt;/em&gt; argument specifies the name of the module the loader is to support. The &lt;em&gt;path&lt;/em&gt; argument is the path to the extension module&amp;rsquo;s file.</source>
          <target state="translated">&lt;em&gt;전체 이름의&lt;/em&gt; 인수는 로더가 지원하는 모듈의 이름을 지정합니다. &lt;em&gt;경로&lt;/em&gt; 인수는 확장 모듈의 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="945b0cd999a4b800654797e3d0ae5eddc4b8534c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handler&lt;/em&gt; is called with two arguments: the signal number and the current stack frame (&lt;code&gt;None&lt;/code&gt; or a frame object; for a description of frame objects, see the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame-objects&quot;&gt;description in the type hierarchy&lt;/a&gt; or see the attribute descriptions in the &lt;a href=&quot;inspect#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">&lt;em&gt;핸들러&lt;/em&gt; 개의 인자로 호출 상기 신호 번호와 현재 스택 프레임 ( &lt;code&gt;None&lt;/code&gt; 또는 프레임 객체, 프레임 객체에 대한 설명 참조 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame-objects&quot;&gt;타입 계층 구조에서 설명&lt;/a&gt; 하거나 안으로 특성 설명을 참조 &lt;a href=&quot;inspect#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈).</target>
        </trans-unit>
        <trans-unit id="9b15c4ee384b0706ae1265715fc5409c2d764a22" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handler&lt;/em&gt; is called with two arguments: the signal number and the current stack frame (&lt;code&gt;None&lt;/code&gt; or a frame object; for a description of frame objects, see the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#frame-objects&quot;&gt;description in the type hierarchy&lt;/a&gt; or see the attribute descriptions in the &lt;a href=&quot;inspect#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">&lt;em&gt;핸들러&lt;/em&gt; 개의 인자로 호출 상기 신호 번호와 현재 스택 프레임 ( &lt;code&gt;None&lt;/code&gt; 또는 프레임 객체, 프레임 객체에 대한 설명 참조 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#frame-objects&quot;&gt;타입 계층 구조에서 설명&lt;/a&gt; 하거나 안으로 특성 설명을 참조 &lt;a href=&quot;inspect#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈).</target>
        </trans-unit>
        <trans-unit id="5c0d1f32a3c5ced96c19803c4ef9d22ef4513b71" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;headers&lt;/em&gt; argument should be a mapping of extra HTTP headers to send with the request.</source>
          <target state="translated">&lt;em&gt;헤더&lt;/em&gt; 인수는 요청과 함께 보낼 수있는 별도의 HTTP 헤더의 매핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a6eea28dbdb86941e4e47c17df323a2b65db50f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;host&lt;/em&gt; parameter can be set to several types which determine where the server would be listening:</source>
          <target state="translated">&lt;em&gt;호스트&lt;/em&gt; 매개 변수는 서버가 수신 될 위치를 결정하는 여러 종류로 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3567013f4ba803cbc03a19e951935ba9875d379e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;input&lt;/em&gt; argument is passed to &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt; and thus to the subprocess&amp;rsquo;s stdin. If used it must be a byte sequence, or a string if &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; is specified or &lt;em&gt;text&lt;/em&gt; is true. When used, the internal &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; object is automatically created with &lt;code&gt;stdin=PIPE&lt;/code&gt;, and the &lt;em&gt;stdin&lt;/em&gt; argument may not be used as well.</source>
          <target state="translated">&lt;em&gt;입력&lt;/em&gt; 인수로 전달된다 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; 따라서 서브 프로세스의 표준 입력. 사용되는 경우 바이트 시퀀스이거나 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 가 지정되거나 &lt;em&gt;텍스트&lt;/em&gt; 가 true 인 경우 문자열이어야 합니다. 사용되는 경우, 내부 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 목적은 자동으로 생성되는 &lt;code&gt;stdin=PIPE&lt;/code&gt; 및 &lt;em&gt;표준 입력의&lt;/em&gt; 인수가 아니라 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="309add7406369c9e13cbbe07f0abac084c4aeac9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interpreter&lt;/em&gt; argument specifies the name of the Python interpreter with which the archive will be executed. It is written as a &amp;ldquo;shebang&amp;rdquo; line at the start of the archive. On POSIX, this will be interpreted by the OS, and on Windows it will be handled by the Python launcher. Omitting the &lt;em&gt;interpreter&lt;/em&gt; results in no shebang line being written. If an interpreter is specified, and the target is a filename, the executable bit of the target file will be set.</source>
          <target state="translated">&lt;em&gt;통역&lt;/em&gt; 인수는 아카이브가 실행됩니다있는 파이썬 인터프리터의 이름을 지정합니다. 아카이브 시작시 &quot;shebang&quot;행으로 작성됩니다. POSIX에서는 OS가이를 해석하고 Windows에서는 Python 런처가이를 처리합니다. &lt;em&gt;인터프리터를&lt;/em&gt; 생략하면 Shebang 줄이 작성되지 않습니다. 인터프리터가 지정되고 대상이 파일 이름 인 경우 대상 파일의 실행 가능 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc413367ebb6cea357fcef201d058874ef7a2cd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;keyencoding&lt;/em&gt; parameter is the encoding used to encode keys before they are used with the underlying dict.</source>
          <target state="translated">&lt;em&gt;keyencoding&lt;/em&gt; 파라미터들이 기본 딕셔너리로 사용되기 전에 인코딩 키로 사용 된 인코딩이다.</target>
        </trans-unit>
        <trans-unit id="3e344c69f7b03d28b5ecf255f27851cd1ec1b42a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;limit&lt;/em&gt; argument is passed to &lt;a href=&quot;#asyncio.Task.get_stack&quot;&gt;&lt;code&gt;get_stack()&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">&lt;em&gt;제한&lt;/em&gt; 인수로 전달됩니다 &lt;a href=&quot;#asyncio.Task.get_stack&quot;&gt; &lt;code&gt;get_stack()&lt;/code&gt; &lt;/a&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="03da4d795bd5e7eacf03e419e5465b47a81aab14" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;limit&lt;/em&gt; argument sets the buffer limit for &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; wrappers for &lt;code&gt;Process.stdout&lt;/code&gt; and &lt;code&gt;Process.stderr&lt;/code&gt; (if &lt;a href=&quot;subprocess#subprocess.PIPE&quot;&gt;&lt;code&gt;subprocess.PIPE&lt;/code&gt;&lt;/a&gt; is passed to &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; arguments).</source>
          <target state="translated">&lt;em&gt;제한&lt;/em&gt; 인자에 대한 버퍼 제한 세트 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 래퍼 &lt;code&gt;Process.stdout&lt;/code&gt; 및 &lt;code&gt;Process.stderr&lt;/code&gt; 를 IF ( &lt;a href=&quot;subprocess#subprocess.PIPE&quot;&gt; &lt;code&gt;subprocess.PIPE&lt;/code&gt; 이&lt;/a&gt; 에 전달되는 &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러&lt;/em&gt; 인자).</target>
        </trans-unit>
        <trans-unit id="129e7c784b9b3ee51082a82585d3133b4d781544" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loader_details&lt;/em&gt; argument is a variable number of 2-item tuples each containing a loader and a sequence of file suffixes the loader recognizes. The loaders are expected to be callables which accept two arguments of the module&amp;rsquo;s name and the path to the file found.</source>
          <target state="translated">&lt;em&gt;loader_details의&lt;/em&gt; 인수는 2 항목 가변 개수는 로더 파일의 시퀀스를 포함하는 각각의 로더 인식 접미사 튜플이다. 로더는 호출 할 수 있어야하며 모듈 이름의 두 인수와 찾은 파일의 경로를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c4075eb186f5064895077ca769fb8de129e00f4c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loop&lt;/em&gt; argument is optional and can always be determined automatically when this function is awaited from a coroutine.</source>
          <target state="translated">&lt;em&gt;루프&lt;/em&gt; 인수는 선택 사항이며,이 기능이 코 루틴에서 기다리고 때 항상 자동으로 결정될 수있다.</target>
        </trans-unit>
        <trans-unit id="73a8039d019649d2ee4bb760661a133481fe2941" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loop&lt;/em&gt; argument is optional and can always be determined automatically when this method is awaited from a coroutine.</source>
          <target state="translated">&lt;em&gt;루프&lt;/em&gt; 인수는 선택 사항이며이 방법은 코 루틴에서 기다리고 때 항상 자동으로 결정될 수있다.</target>
        </trans-unit>
        <trans-unit id="c152814f2f36109416e46a812106fb4bb59ade66" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;main&lt;/em&gt; argument specifies the name of a callable which will be used as the main program for the archive. It can only be specified if the source is a directory, and the source does not already contain a &lt;code&gt;__main__.py&lt;/code&gt; file. The &lt;em&gt;main&lt;/em&gt; argument should take the form &amp;ldquo;pkg.module:callable&amp;rdquo; and the archive will be run by importing &amp;ldquo;pkg.module&amp;rdquo; and executing the given callable with no arguments. It is an error to omit &lt;em&gt;main&lt;/em&gt; if the source is a directory and does not contain a &lt;code&gt;__main__.py&lt;/code&gt; file, as otherwise the resulting archive would not be executable.</source>
          <target state="translated">&lt;em&gt;주요&lt;/em&gt; 인수는 아카이브의 메인 프로그램으로 사용됩니다 호출의 이름을 지정합니다. 소스가 디렉토리이고 소스에 &lt;code&gt;__main__.py&lt;/code&gt; 파일 이없는 경우에만 지정할 수 있습니다 . &lt;em&gt;주&lt;/em&gt; &quot;: 호출 pkg.module&quot;아카이브는 인수없이 주어진 호출을 &quot;pkg.module을&quot;가져 오기 및 실행하여 실행됩니다 인수 형태를 취한다. 소스가 디렉토리이고 &lt;code&gt;__main__.py&lt;/code&gt; 파일을 포함하지 않는 경우 &lt;em&gt;main&lt;/em&gt; 을 생략하면 오류가 발생합니다. 그렇지 않으면 결과 아카이브가 실행 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a792d7ef7a7c58a9f18c32feedd94d015e4b0544" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;map&lt;/em&gt; parameter is a dictionary whose items are the channels to watch. As channels are closed they are deleted from their map. If &lt;em&gt;map&lt;/em&gt; is omitted, a global map is used. Channels (instances of &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt;&lt;code&gt;asynchat.async_chat&lt;/code&gt;&lt;/a&gt; and subclasses thereof) can freely be mixed in the map.</source>
          <target state="translated">&lt;em&gt;맵&lt;/em&gt; 매개 변수는 항목을 볼 수있는 채널이 사전이다. 채널이 닫히면지도에서 삭제됩니다. 경우 &lt;em&gt;지도가&lt;/em&gt; 생략, 글로벌 맵이 사용된다. 채널 ( &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt; &lt;code&gt;asynchat.async_chat&lt;/code&gt; &lt;/a&gt; 및 해당 서브 클래스의 인스턴스 )을 맵에서 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de3df102b5a039ab9487bee97ffa75b5ffdf2c3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;maxlevels&lt;/em&gt; parameter is used to limit the depth of the recursion; it defaults to &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;maxlevels의&lt;/em&gt; 파라미터는 재귀의 깊이를 제한하는데 사용된다; 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b1e7f8bf782873ab6877666a267652d65709837" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;maxlevels&lt;/em&gt; parameter is used to limit the depth of the recursion; it defaults to &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;maxlevels의&lt;/em&gt; 파라미터는 재귀의 깊이를 제한하는데 사용된다; 기본값은 &lt;code&gt;sys.getrecursionlimit()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb182bf741586c60f69a2721098eca2297c8d83d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;memLevel&lt;/em&gt; argument controls the amount of memory used for the internal compression state. Valid values range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;. Higher values use more memory, but are faster and produce smaller output.</source>
          <target state="translated">&lt;em&gt;memLevel의&lt;/em&gt; 인수는 내부의 압축 상태를 위해 사용되는 메모리의 양을 제어한다. 유효한 값의 범위 &lt;code&gt;1&lt;/code&gt; 에 &lt;code&gt;9&lt;/code&gt; . 값이 클수록 더 많은 메모리를 사용하지만 더 빠르고 더 작은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="472e6487f68d04bf8fdb5f7c1716adfc521275a9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;memlimit&lt;/em&gt; argument specifies a limit (in bytes) on the amount of memory that the decompressor can use. When this argument is used, decompression will fail with an &lt;a href=&quot;#lzma.LZMAError&quot;&gt;&lt;code&gt;LZMAError&lt;/code&gt;&lt;/a&gt; if it is not possible to decompress the input within the given memory limit.</source>
          <target state="translated">&lt;em&gt;MEMLIMIT의&lt;/em&gt; 인자는 압축 해 제기가 사용할 수있는 메모리의 양 (바이트) 한계를 지정한다. 이 인수를 사용 하면 주어진 메모리 한계 내에서 입력을 압축 해제 할 수없는 경우 &lt;a href=&quot;#lzma.LZMAError&quot;&gt; &lt;code&gt;LZMAError&lt;/code&gt; &lt;/a&gt; 와 함께 압축 해제에 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="5ed4f7ee0127a5c81a5c5fe6eca67c71e17a81c7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;message_set&lt;/em&gt; options to commands below is a string specifying one or more messages to be acted upon. It may be a simple message number (&lt;code&gt;'1'&lt;/code&gt;), a range of message numbers (&lt;code&gt;'2:4'&lt;/code&gt;), or a group of non-contiguous ranges separated by commas (&lt;code&gt;'1:3,6:9'&lt;/code&gt;). A range can contain an asterisk to indicate an infinite upper bound (&lt;code&gt;'3:*'&lt;/code&gt;).</source>
          <target state="translated">아래의 명령에 대한 &lt;em&gt;message_set&lt;/em&gt; 옵션은 수행 할 하나 이상의 메시지를 지정하는 문자열입니다. 간단한 메시지 번호 ( &lt;code&gt;'1'&lt;/code&gt; ), 메시지 번호 범위 ( &lt;code&gt;'2:4'&lt;/code&gt; ) 또는 쉼표로 구분 된 비 연속 범위 그룹 ( &lt;code&gt;'1:3,6:9'&lt;/code&gt; ) 일 수 있습니다. 범위에는 무한한 상한을 나타내는 별표가 포함될 수 있습니다 ( &lt;code&gt;'3:*'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1ac518a8261cd76e3d572450cd69c2da8d19e734" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;method&lt;/em&gt; for computing quantiles can be varied depending on whether the &lt;em&gt;data&lt;/em&gt; includes or excludes the lowest and highest possible values from the population.</source>
          <target state="translated">&lt;em&gt;방법&lt;/em&gt; 컴퓨팅 분위수 대한이 있는지에 따라 변경 될 수 &lt;em&gt;데이터가&lt;/em&gt; 포함 또는 모집단에서 제외 최저 및 최고 가능한 값.</target>
        </trans-unit>
        <trans-unit id="8ecb6288199428438fe4ea40f2513dfb74080c75" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mock&lt;/em&gt; argument is the mock object to configure. If &lt;code&gt;None&lt;/code&gt; (the default) then a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; will be created for you, with the API limited to methods or attributes available on standard file handles.</source>
          <target state="translated">&lt;em&gt;모의&lt;/em&gt; 인수는 구성 할 수있는 모의 객체입니다. 경우 &lt;code&gt;None&lt;/code&gt; 다음 (기본값) &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; 이&lt;/a&gt; API를 사용하면 생성됩니다이 방법으로 제한하거나 표준 파일 핸들에 사용할 수 속성.</target>
        </trans-unit>
        <trans-unit id="895803f0fac68124dcdbdc694aeabdf8d07767b7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mod_name&lt;/em&gt; argument should be an absolute module name. If the module name refers to a package rather than a normal module, then that package is imported and the &lt;code&gt;__main__&lt;/code&gt; submodule within that package is then executed and the resulting module globals dictionary returned.</source>
          <target state="translated">&lt;em&gt;mod_name의&lt;/em&gt; 인수는 절대 모듈 이름이어야한다. 모듈 이름이 일반 모듈이 아닌 패키지를 참조하면 해당 패키지를 가져오고 해당 패키지 내의 &lt;code&gt;__main__&lt;/code&gt; 하위 모듈이 실행되고 결과 모듈 전역 사전이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a6df0bfcf373c1c06747418e51fd35f70f7733a3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;rb&quot;&lt;/code&gt;, &lt;code&gt;&quot;w&quot;&lt;/code&gt;, &lt;code&gt;&quot;wb&quot;&lt;/code&gt;, &lt;code&gt;&quot;x&quot;&lt;/code&gt;, &lt;code&gt;&quot;xb&quot;&lt;/code&gt;, &lt;code&gt;&quot;a&quot;&lt;/code&gt; or &lt;code&gt;&quot;ab&quot;&lt;/code&gt; for binary mode, or &lt;code&gt;&quot;rt&quot;&lt;/code&gt;, &lt;code&gt;&quot;wt&quot;&lt;/code&gt;, &lt;code&gt;&quot;xt&quot;&lt;/code&gt;, or &lt;code&gt;&quot;at&quot;&lt;/code&gt; for text mode. The default is &lt;code&gt;&quot;rb&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수있다 &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;rb&quot;&lt;/code&gt; , &lt;code&gt;&quot;w&quot;&lt;/code&gt; , &lt;code&gt;&quot;wb&quot;&lt;/code&gt; , &lt;code&gt;&quot;x&quot;&lt;/code&gt; , &lt;code&gt;&quot;xb&quot;&lt;/code&gt; , &lt;code&gt;&quot;a&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 이진 모드, 또는 &lt;code&gt;&quot;rt&quot;&lt;/code&gt; , &lt;code&gt;&quot;wt&quot;&lt;/code&gt; 텍스트 모드 인 경우 &lt;code&gt;&quot;xt&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;at&quot;&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;&quot;rb&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d1ad98a2dd540caaea8a1f22878e9101d4e6629" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'xb'&lt;/code&gt; for binary mode, or &lt;code&gt;'rt'&lt;/code&gt;, &lt;code&gt;'at'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, or &lt;code&gt;'xt'&lt;/code&gt; for text mode. The default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'xb'&lt;/code&gt; 바이너리 모드 또는 &lt;code&gt;'rt'&lt;/code&gt; , &lt;code&gt;'at'&lt;/code&gt; 텍스트 모드의 경우 &lt;code&gt;'wt'&lt;/code&gt; 또는 &lt;code&gt;'xt'&lt;/code&gt; 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4e823bc32f269eed5bbc36974b6041d7caeefce7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'xb'&lt;/code&gt;, depending on whether the file will be read or written. The default is the mode of &lt;em&gt;fileobj&lt;/em&gt; if discernible; otherwise, the default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'xb'&lt;/code&gt; 파일이 판독 또는 기록되는지 여부에 따라, . 식별 가능한 경우 기본값은 &lt;em&gt;fileobj&lt;/em&gt; 의 모드입니다 . 그렇지 않으면 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01e888834025d34e45dccf64510222906c9508c3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt;, &lt;code&gt;'ab'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, or &lt;code&gt;'xb'&lt;/code&gt;, depending on whether the file will be read or written. The default is the mode of &lt;em&gt;fileobj&lt;/em&gt; if discernible; otherwise, the default is &lt;code&gt;'rb'&lt;/code&gt;. In future Python releases the mode of &lt;em&gt;fileobj&lt;/em&gt; will not be used. It is better to always specify &lt;em&gt;mode&lt;/em&gt; for writing.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; , &lt;code&gt;'ab'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , 또는 &lt;code&gt;'xb'&lt;/code&gt; 파일을 읽거나 기록 할 것인지 여부에 따라, . 기본값은 식별 가능한 경우 &lt;em&gt;fileobj&lt;/em&gt; 의 모드입니다 . 그렇지 않으면 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다. 향후 Python 릴리스에서는 &lt;em&gt;fileobj&lt;/em&gt; 모드 가 사용되지 않습니다. 항상 쓰기 &lt;em&gt;모드&lt;/em&gt; 를 지정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="05f2a9cda1e91039c7b1edb582c41248bba08bd5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be any of &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, &lt;code&gt;'xb'&lt;/code&gt;, &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'ab'&lt;/code&gt; for binary mode, or &lt;code&gt;'rt'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'xt'&lt;/code&gt;, or &lt;code&gt;'at'&lt;/code&gt; for text mode. The default is &lt;code&gt;'rb'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수 중 하나 일 수 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; , &lt;code&gt;'xb'&lt;/code&gt; , &lt;code&gt;'a'&lt;/code&gt; 또는 &lt;code&gt;'ab'&lt;/code&gt; 바이너리 모드 또는 &lt;code&gt;'rt'&lt;/code&gt; , &lt;code&gt;'wt'&lt;/code&gt; 텍스트 모드의 경우 &lt;code&gt;'xt'&lt;/code&gt; 또는 &lt;code&gt;'at'&lt;/code&gt; 입니다. 기본값은 &lt;code&gt;'rb'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f4dcb1c4c38de2058990b6b6c09d3880a922fe2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be either &lt;code&gt;&quot;r&quot;&lt;/code&gt; for reading (default), &lt;code&gt;&quot;w&quot;&lt;/code&gt; for overwriting, &lt;code&gt;&quot;x&quot;&lt;/code&gt; for exclusive creation, or &lt;code&gt;&quot;a&quot;&lt;/code&gt; for appending. These can equivalently be given as &lt;code&gt;&quot;rb&quot;&lt;/code&gt;, &lt;code&gt;&quot;wb&quot;&lt;/code&gt;, &lt;code&gt;&quot;xb&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab&quot;&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수가 될 수 있습니다 &lt;code&gt;&quot;r&quot;&lt;/code&gt; (기본값)를 읽기위한 &lt;code&gt;&quot;w&quot;&lt;/code&gt; , 덮어 쓰기위한 &lt;code&gt;&quot;x&quot;&lt;/code&gt; 독점 창조를 위해, 또는 &lt;code&gt;&quot;a&quot;&lt;/code&gt; 추가합니다. 이들은 각각 &lt;code&gt;&quot;rb&quot;&lt;/code&gt; , &lt;code&gt;&quot;wb&quot;&lt;/code&gt; , &lt;code&gt;&quot;xb&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;ab&quot;&lt;/code&gt; 로 주어질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3bbeddbe7940e4c0cf370c80c9188d583fa75ae" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument can be either &lt;code&gt;'r'&lt;/code&gt; for reading (default), &lt;code&gt;'w'&lt;/code&gt; for overwriting, &lt;code&gt;'x'&lt;/code&gt; for exclusive creation, or &lt;code&gt;'a'&lt;/code&gt; for appending. These can equivalently be given as &lt;code&gt;'rb'&lt;/code&gt;, &lt;code&gt;'wb'&lt;/code&gt;, &lt;code&gt;'xb'&lt;/code&gt; and &lt;code&gt;'ab'&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 인수가 될 수 있습니다 &lt;code&gt;'r'&lt;/code&gt; (기본값)를 읽기 위해 &lt;code&gt;'w'&lt;/code&gt; , 덮어 쓰기 &lt;code&gt;'x'&lt;/code&gt; 를 독점 창조를 위해, 또는 &lt;code&gt;'a'&lt;/code&gt; 추가하십시오. 이들은 각각 &lt;code&gt;'rb'&lt;/code&gt; , &lt;code&gt;'wb'&lt;/code&gt; , &lt;code&gt;'xb'&lt;/code&gt; 및 &lt;code&gt;'ab'&lt;/code&gt; 로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e63d1cb834b1ab465f8f51a8d33b391f5ded1c0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; argument specifies what kind of code must be compiled; it can be &lt;code&gt;'exec'&lt;/code&gt; if &lt;em&gt;source&lt;/em&gt; consists of a sequence of statements, &lt;code&gt;'eval'&lt;/code&gt; if it consists of a single expression, or &lt;code&gt;'single'&lt;/code&gt; if it consists of a single interactive statement (in the latter case, expression statements that evaluate to something other than &lt;code&gt;None&lt;/code&gt; will be printed).</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 컴파일해야하는 코드의 종류를 인수 지정; 그것은 할 수있다 &lt;code&gt;'exec'&lt;/code&gt; 경우 &lt;em&gt;소스가&lt;/em&gt; 문장의 순서로 구성되어 &lt;code&gt;'eval'&lt;/code&gt; 는 하나의 표현, 또는 구성하는 경우 &lt;code&gt;'single'&lt;/code&gt; 후자의 경우는 단일 대화 형 문장으로 구성되어있는 경우 (표현 문은 뭔가 평가하는 &lt;code&gt;None&lt;/code&gt; 이외 는 인쇄됩니다).</target>
        </trans-unit>
        <trans-unit id="ef0505b4bacc6ef52a11195116452b65f0988586" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; can be &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt; for reading (default), writing, exclusive creation or appending. The file will be created if it doesn&amp;rsquo;t exist when opened for writing or appending; it will be truncated when opened for writing. &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised if it already exists when opened for creating. Opening a file for creating implies writing, so this mode behaves in a similar way to &lt;code&gt;'w'&lt;/code&gt;. Add a &lt;code&gt;'+'&lt;/code&gt; to the mode to allow simultaneous reading and writing.</source>
          <target state="translated">&lt;em&gt;모드는&lt;/em&gt; 할 수있다 &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; (기본값) 읽기 전용 생성을 작성하거나 추가하십시오. 파일을 쓰거나 추가 할 때 파일이 존재하지 않으면 파일이 작성됩니다. 쓰기 위해 열면 잘립니다. &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 는 생성을 위해 열었을 때 이미 존재하면 발생합니다. 작성하기 위해 파일을 여는 것은 쓰기를 의미하므로이 모드는 &lt;code&gt;'w'&lt;/code&gt; 와 유사한 방식으로 작동 합니다. 읽기와 쓰기를 동시에하려면 모드에 &lt;code&gt;'+'&lt;/code&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="c36342d9b2cd8356ce1d1833db576291385536ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter can be used to specify how the library is loaded. For details, consult the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen(3)&lt;/a&gt;&lt;/em&gt; manpage. On Windows, &lt;em&gt;mode&lt;/em&gt; is ignored. On posix systems, RTLD_NOW is always added, and is not configurable.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수는 라이브러리를로드하는 방법을 지정하는 데 사용할 수 있습니다. 자세한 내용은 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/dlopen(3)&quot;&gt;dlopen (3)&lt;/a&gt;&lt;/em&gt; 맨 페이지를 참조하십시오 . Windows에서는 &lt;em&gt;모드&lt;/em&gt; 가 무시됩니다. posix 시스템에서 RTLD_NOW는 항상 추가되며 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f9fa2d230db8cbbf537de152e5285ab6acbcd9db" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter defaults to &lt;code&gt;'w+b'&lt;/code&gt; so that the file created can be read and written without being closed. Binary mode is used so that it behaves consistently on all platforms without regard for the data that is stored. &lt;em&gt;buffering&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt; and &lt;em&gt;newline&lt;/em&gt; are interpreted as for &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 에 디폴트 파라미터 &lt;code&gt;'w+b'&lt;/code&gt; 너무없이 읽고 쓸 수 작성된 파일은 폐쇄되고있다. 이진 모드는 저장된 데이터에 관계없이 모든 플랫폼에서 일관되게 작동하도록 사용됩니다. &lt;em&gt;buffering&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; 및 &lt;em&gt;newline&lt;/em&gt; 은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 로 해석됩니다 .</target>
        </trans-unit>
        <trans-unit id="12a05a95436429873a1482da4eed5e970b00fe32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter is passed to &lt;a href=&quot;#os.mkdir&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; for creating the leaf directory; see &lt;a href=&quot;#mkdir-modebits&quot;&gt;the mkdir() description&lt;/a&gt; for how it is interpreted. To set the file permission bits of any newly-created parent directories you can set the umask before invoking &lt;a href=&quot;#os.makedirs&quot;&gt;&lt;code&gt;makedirs()&lt;/code&gt;&lt;/a&gt;. The file permission bits of existing parent directories are not changed.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수로 전달됩니다 &lt;a href=&quot;#os.mkdir&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; 잎 디렉토리를 생성; 해석 방법에 &lt;a href=&quot;#mkdir-modebits&quot;&gt;대해서는 mkdir () 설명&lt;/a&gt; 을 참조하십시오 . 새로 작성된 상위 디렉토리의 파일 권한 비트를 설정하려면 &lt;a href=&quot;#os.makedirs&quot;&gt; &lt;code&gt;makedirs()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 umask를 설정할 수 있습니다 . 기존 상위 디렉토리의 파일 권한 비트는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d337cbd57242ea9761dc2650a1be72d8a8a94e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mode&lt;/em&gt; parameter should be &lt;code&gt;'r'&lt;/code&gt; to read an existing file, &lt;code&gt;'w'&lt;/code&gt; to truncate and write a new file, &lt;code&gt;'a'&lt;/code&gt; to append to an existing file, or &lt;code&gt;'x'&lt;/code&gt; to exclusively create and write a new file. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'x'&lt;/code&gt; and &lt;em&gt;file&lt;/em&gt; refers to an existing file, a &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; will be raised. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'a'&lt;/code&gt; and &lt;em&gt;file&lt;/em&gt; refers to an existing ZIP file, then additional files are added to it. If &lt;em&gt;file&lt;/em&gt; does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file (such as &lt;code&gt;python.exe&lt;/code&gt;). If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'a'&lt;/code&gt; and the file does not exist at all, it is created. If &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, the file should be seekable.</source>
          <target state="translated">&lt;em&gt;모드&lt;/em&gt; 매개 변수는해야한다 &lt;code&gt;'r'&lt;/code&gt; , 기존 파일을 읽기 위해 &lt;code&gt;'w'&lt;/code&gt; 잘라 내기에 새 파일 작성 &lt;code&gt;'a'&lt;/code&gt; 기존 파일에 추가 할를, 또는 &lt;code&gt;'x'&lt;/code&gt; 에 독점적으로 만들고 새 파일을 작성합니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'x'&lt;/code&gt; 와 &lt;em&gt;파일이&lt;/em&gt; 기존 파일을 참조하는 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'a'&lt;/code&gt; 와 &lt;em&gt;파일이&lt;/em&gt; 기존의 ZIP 파일을 참조하고 추가 파일은 추가됩니다. &lt;em&gt;파일 인&lt;/em&gt; 경우&lt;em&gt;&lt;/em&gt;ZIP 파일을 참조하지 않으면 새 ZIP 아카이브가 파일에 추가됩니다. 이는 ZIP 아카이브를 다른 파일 (예 : &lt;code&gt;python.exe&lt;/code&gt; ) 에 추가하기위한 것 입니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'a'&lt;/code&gt; 전혀 존재하지 않고 파일이 작성됩니다. 경우 &lt;em&gt;모드&lt;/em&gt; 인 &lt;code&gt;'r'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 파일이 시크해야한다.</target>
        </trans-unit>
        <trans-unit id="cd48b9ded8ca0d722432b92316f5d1e26f89e9e8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;module&lt;/em&gt; and &lt;em&gt;name&lt;/em&gt; arguments are the same as for function &lt;a href=&quot;#doctest.testsource&quot;&gt;&lt;code&gt;testsource()&lt;/code&gt;&lt;/a&gt; above. The synthesized Python script for the named object&amp;rsquo;s docstring is written to a temporary file, and then that file is run under the control of the Python debugger, &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 및 &lt;em&gt;이름&lt;/em&gt; 인수 함수와 동일 &lt;a href=&quot;#doctest.testsource&quot;&gt; &lt;code&gt;testsource()&lt;/code&gt; &lt;/a&gt; 위에서. 명명 된 객체의 docstring에 대해 합성 된 Python 스크립트는 임시 파일에 기록 된 다음 해당 파일은 Python 디버거 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 의 제어하에 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="517f12b7316c7403a28c06c48d710faa268ca17d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;module&lt;/em&gt; argument takes a module that will be used instead of the module returned when you import &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; whose filter will be protected. This argument exists primarily for testing the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module itself.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 인수 대신 가져올 때 반환 된 모듈로 사용되는 모듈 걸리는 &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 그 필터 보호됩니다. 이 인수는 주로 &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈 자체 를 테스트하기 위해 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="d00f6e8f367001c13e02ed8c348b2926151b62a6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;mtime&lt;/em&gt; argument is an optional numeric timestamp to be written to the last modification time field in the stream when compressing. It should only be provided in compression mode. If omitted or &lt;code&gt;None&lt;/code&gt;, the current time is used. See the &lt;a href=&quot;#gzip.GzipFile.mtime&quot;&gt;&lt;code&gt;mtime&lt;/code&gt;&lt;/a&gt; attribute for more details.</source>
          <target state="translated">&lt;em&gt;에 mtime의&lt;/em&gt; 인수는 압축 할 때 스트림의 마지막 수정 시간 필드에 기록 할 선택적 숫자 소인입니다. 압축 모드에서만 제공해야합니다. 생략되거나 &lt;code&gt;None&lt;/code&gt; 이면 현재 시간이 사용됩니다. 자세한 내용은 &lt;a href=&quot;#gzip.GzipFile.mtime&quot;&gt; &lt;code&gt;mtime&lt;/code&gt; &lt;/a&gt; 속성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1d5693119572560e6e6dbcbc1051d1f559f7129" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; argument is optional. If specified it must be a string that will be used as the value returned by the &lt;a href=&quot;#datetime.datetime.tzname&quot;&gt;&lt;code&gt;datetime.tzname()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수는 선택 사항입니다. 지정된 경우, &lt;a href=&quot;#datetime.datetime.tzname&quot;&gt; &lt;code&gt;datetime.tzname()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 한 값으로 사용될 문자열이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="fa307273ebb313531c87777abdad301164d885b3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; argument specifies the database name that will be copied: it must be a string containing either &lt;code&gt;&quot;main&quot;&lt;/code&gt;, the default, to indicate the main database, &lt;code&gt;&quot;temp&quot;&lt;/code&gt; to indicate the temporary database or the name specified after the &lt;code&gt;AS&lt;/code&gt; keyword in an &lt;code&gt;ATTACH DATABASE&lt;/code&gt; statement for an attached database.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 인수는 복사 할 데이터베이스 이름을 지정합니다 :이 중 하나를 포함하는 문자열이어야합니다 &lt;code&gt;&quot;main&quot;&lt;/code&gt; 기본 데이터베이스를 나타 내기 위해, 기본 &lt;code&gt;&quot;temp&quot;&lt;/code&gt; 애프터 지정된 임시 데이터베이스 또는 이름을 표시하기 위해 &lt;code&gt;AS&lt;/code&gt; 의 에 키워드를 연결된 데이터베이스에 대한 &lt;code&gt;ATTACH DATABASE&lt;/code&gt; 문</target>
        </trans-unit>
        <trans-unit id="bfc8b3c755aaf4e07d8b3ad9aeb11f0bb28a5cf0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; can be one of two things:</source>
          <target state="translated">&lt;em&gt;이름은&lt;/em&gt; 두 가지 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fecd24072b185fb1c044fa851a04b4bb4c15cc73" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type as a &lt;code&gt;(uri,
localname)&lt;/code&gt; tuple, the &lt;em&gt;qname&lt;/em&gt; parameter contains the raw XML 1.0 name used in the source document, and the &lt;em&gt;attrs&lt;/em&gt; parameter holds an instance of the &lt;code&gt;AttributesNS&lt;/code&gt; interface (see &lt;a href=&quot;xml.sax.reader#attributes-ns-objects&quot;&gt;The AttributesNS Interface&lt;/a&gt;) containing the attributes of the element. If no namespace is associated with the element, the &lt;em&gt;uri&lt;/em&gt; component of &lt;em&gt;name&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;. The object passed as &lt;em&gt;attrs&lt;/em&gt; may be re-used by the parser; holding on to a reference to it is not a reliable way to keep a copy of the attributes. To keep a copy of the attributes, use the &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; method of the &lt;em&gt;attrs&lt;/em&gt; object.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 같은 요소 유형의 이름이 포함 &lt;code&gt;(uri, localname)&lt;/code&gt; 튜플 상기 &lt;em&gt;의 QName&lt;/em&gt; 파라미터는 원시 XML 1.0 소스 문서에 사용 된 이름 및 포함 &lt;em&gt;attrs에&lt;/em&gt; 의 인스턴스 보유 파라미터 &lt;code&gt;AttributesNS&lt;/code&gt; 의 인터페이스 (참조 &lt;a href=&quot;xml.sax.reader#attributes-ns-objects&quot;&gt;AttributesNS 인터페이스&lt;/a&gt; )에 요소의 속성이 포함되어 있습니다. 더 네임 스페이스 요소와 연관되지 않은 경우, &lt;em&gt;URI&lt;/em&gt; 의 구성 요소 &lt;em&gt;이름은&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; . &lt;em&gt;attrs로&lt;/em&gt; 전달 된 객체 는 파서에 의해 재사용 될 수 있습니다. 그것에 대한 참조를 유지하는 것은 속성의 사본을 유지하는 신뢰할 수있는 방법이 아닙니다. 속성의 사본을 유지하려면&lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt;&lt;em&gt;attrs&lt;/em&gt; 객체의 copy () 메서드</target>
        </trans-unit>
        <trans-unit id="5686dcac020c22f354bee25b44d2e503d24cea05" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type, just as with the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt;&lt;code&gt;startElement()&lt;/code&gt;&lt;/a&gt; event.</source>
          <target state="translated">&lt;em&gt;이름&lt;/em&gt; 매개 변수는 단지와 마찬가지로 요소 유형의 이름을 포함 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt; &lt;code&gt;startElement()&lt;/code&gt; &lt;/a&gt; 이벤트.</target>
        </trans-unit>
        <trans-unit id="4e221dbdf5f7dd9b982f8886d4d96d71dfbcb1e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the name of the element type, just as with the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElementNS&quot;&gt;&lt;code&gt;startElementNS()&lt;/code&gt;&lt;/a&gt; method, likewise the &lt;em&gt;qname&lt;/em&gt; parameter.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 단지와 같은 요소 유형의 이름을 포함 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElementNS&quot;&gt; &lt;code&gt;startElementNS()&lt;/code&gt; &lt;/a&gt; 에있어서, 마찬가지로 &lt;em&gt;본인 QName&lt;/em&gt; 파라미터.</target>
        </trans-unit>
        <trans-unit id="c5dd95780a96ed373c7c08723087bc92012499d7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name&lt;/em&gt; parameter contains the raw XML 1.0 name of the element type as a string and the &lt;em&gt;attrs&lt;/em&gt; parameter holds an object of the &lt;code&gt;Attributes&lt;/code&gt; interface (see &lt;a href=&quot;xml.sax.reader#attributes-objects&quot;&gt;The Attributes Interface&lt;/a&gt;) containing the attributes of the element. The object passed as &lt;em&gt;attrs&lt;/em&gt; may be re-used by the parser; holding on to a reference to it is not a reliable way to keep a copy of the attributes. To keep a copy of the attributes, use the &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; method of the &lt;em&gt;attrs&lt;/em&gt; object.</source>
          <target state="translated">&lt;em&gt;네임&lt;/em&gt; 파라미터는 문자열 요소 유형과의 원시 XML 1.0 명 포함 &lt;em&gt;attrs에&lt;/em&gt; 의 객체 파라미터 보유 &lt;code&gt;Attributes&lt;/code&gt; 인터페이스 (참조 : &lt;a href=&quot;xml.sax.reader#attributes-objects&quot;&gt;(가) Attributes 인터페이스&lt;/a&gt; 요소의 속성을 포함). &lt;em&gt;attrs로&lt;/em&gt; 전달 된 객체 는 파서에 의해 재사용 될 수 있습니다. 그것에 대한 참조를 유지하는 것은 속성의 사본을 유지하는 신뢰할 수있는 방법이 아닙니다. 속성의 사본을 유지하려면 &lt;em&gt;attrs&lt;/em&gt; 객체 의 &lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e827cc072d58a9231eccc94d7418aeb0f39c07c9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;name_of_module&lt;/em&gt; argument can specify (as a string or tuple thereof) what module(s) an API could be defined in order to be detected as a public API. One case for this is when &lt;em&gt;module&lt;/em&gt; imports part of its public API from other modules, possibly a C backend (like &lt;code&gt;csv&lt;/code&gt; and its &lt;code&gt;_csv&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;name_of_module의&lt;/em&gt; 인수는 API가 공개 API로 감지하기 위해 정의 될 수있는 것을 모듈 (들) (그 문자열이나 튜플)를 지정할 수있다. 이에 대한 한 가지 사례는 &lt;em&gt;모듈&lt;/em&gt; 이 다른 모듈에서 C 백엔드 (예 : &lt;code&gt;csv&lt;/code&gt; 및 &lt;code&gt;_csv&lt;/code&gt; ) 에서 공용 API의 일부를 가져 오는 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="6a1f53a033eeb2f5efeb8e128aa8a34ec6956a47" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;new_callable&lt;/em&gt; argument is useful where you want to use an alternative class to the default &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; for the created mock. For example, if you wanted a &lt;a href=&quot;#unittest.mock.NonCallableMock&quot;&gt;&lt;code&gt;NonCallableMock&lt;/code&gt;&lt;/a&gt; to be used:</source>
          <target state="translated">&lt;em&gt;new_callable&lt;/em&gt; 기본에 다른 클래스를 사용하려는 인수가 유용 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 생성 된 모의를 위해. 예를 들어 &lt;a href=&quot;#unittest.mock.NonCallableMock&quot;&gt; &lt;code&gt;NonCallableMock&lt;/code&gt; &lt;/a&gt; 을 사용 하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="2800104a4a73839c0a83410200ad71ab927a214b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;newline&lt;/em&gt; argument works like that of &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;, except that when writing output to the stream, if &lt;em&gt;newline&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, newlines are written as &lt;code&gt;\n&lt;/code&gt; on all platforms.</source>
          <target state="translated">&lt;em&gt;줄 바꿈&lt;/em&gt; 의 같은 인수 작업 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; , 스트림에 출력을 기록 할 때 경우, 점을 제외하고 &lt;em&gt;줄 바꿈이&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; , 줄 바꿈과 같이 기록 된 &lt;code&gt;\n&lt;/code&gt; 모든 플랫폼에서.</target>
        </trans-unit>
        <trans-unit id="1c928def7d6f7fec2025663bfc3a4700caf1d2a7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;newline&lt;/em&gt; argument works like that of &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;. The default is to consider only &lt;code&gt;\n&lt;/code&gt; characters as ends of lines and to do no newline translation. If &lt;em&gt;newline&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt;, newlines are written as &lt;code&gt;\n&lt;/code&gt; on all platforms, but universal newline decoding is still performed when reading.</source>
          <target state="translated">&lt;em&gt;줄 바꿈&lt;/em&gt; 인수의처럼 작동 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; . 디폴트는 &lt;code&gt;\n&lt;/code&gt; 문자 만을 행의 끝 으로 간주 하고 개행 변환을 수행하지 않는 것입니다. &lt;em&gt;줄 바꿈&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 으로 설정 되면 모든 플랫폼에서 줄 바꿈이 &lt;code&gt;\n&lt;/code&gt; 으로 작성 되지만 범용 줄 바꿈 디코딩은 여전히 ​​읽을 때 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd8453f1fdcfd787ce338a47e0ea718dd8b6c75" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object-or-type&lt;/em&gt; determines the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-method-resolution-order&quot;&gt;method resolution order&lt;/a&gt; to be searched. The search starts from the class right after the &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;객체 또는 형&lt;/em&gt; 결정 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-method-resolution-order&quot;&gt;방법 확인 순서&lt;/a&gt; 검색 할있다. &lt;em&gt;유형&lt;/em&gt; 바로 다음에 클래스에서 검색이 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="c8745db3ba48731d82b6e52007d4d9530b1b01ca" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object-or-type&lt;/em&gt; determines the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-method-resolution-order&quot;&gt;method resolution order&lt;/a&gt; to be searched. The search starts from the class right after the &lt;em&gt;type&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;객체 또는 형&lt;/em&gt; 결정 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-method-resolution-order&quot;&gt;방법 확인 순서&lt;/a&gt; 검색 할있다. 검색은 &lt;em&gt;유형&lt;/em&gt; 바로 다음에 클래스에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad83ccab5379d93ec053e2b163a548ae3d4e6b98" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;object_pairs_hook&lt;/em&gt; parameter can be used to alter this behavior.</source>
          <target state="translated">&lt;em&gt;object_pairs_hook의&lt;/em&gt; 매개 변수는이 동작을 변경하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="835096ab0ab29d4008ca14710ddfaea3d6d22ec4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;offset&lt;/em&gt; argument must be specified as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object representing the difference between the local time and UTC. It must be strictly between &lt;code&gt;-timedelta(hours=24)&lt;/code&gt; and &lt;code&gt;timedelta(hours=24)&lt;/code&gt;, otherwise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;오프셋&lt;/em&gt; 인자는로서 지정해야 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 현지 시간과 UTC의 차이를 나타내는 개체. 이것은 엄격 사이 여야 &lt;code&gt;-timedelta(hours=24)&lt;/code&gt; 및 &lt;code&gt;timedelta(hours=24)&lt;/code&gt; 그렇지 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를가&lt;/a&gt; 상승한다.</target>
        </trans-unit>
        <trans-unit id="ddd25287fdb9896e097a9db9e3706fae6e9da314" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;opener&lt;/em&gt; parameter was added.</source>
          <target state="translated">&lt;em&gt;오프너&lt;/em&gt; 매개 변수는 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="03b092d93249375bcb0323a6702343bfbe9ceae6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;openhook&lt;/em&gt;, when given, must be a function that takes two arguments, &lt;em&gt;filename&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt;, and returns an accordingly opened file-like object. You cannot use &lt;em&gt;inplace&lt;/em&gt; and &lt;em&gt;openhook&lt;/em&gt; together.</source>
          <target state="translated">&lt;em&gt;openhook는&lt;/em&gt; , 주어 졌을 때, 두 개의 인수를 취하는 함수이어야 &lt;em&gt;파일 이름&lt;/em&gt; 과 &lt;em&gt;모드&lt;/em&gt; 및 그에 따라 열린 파일과 같은 개체를 반환합니다. &lt;em&gt;Inplace&lt;/em&gt; 와 &lt;em&gt;Openhook을&lt;/em&gt; 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e5eb496e4b2c0fde320c695eb452f9ff1a917c58" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;optimization&lt;/em&gt; parameter is used to specify the optimization level of the bytecode file. An empty string represents no optimization, so &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; with an &lt;em&gt;optimization&lt;/em&gt; of &lt;code&gt;''&lt;/code&gt; will result in a bytecode path of &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; causes the interpreter&amp;rsquo;s optimization level to be used. Any other value&amp;rsquo;s string representation is used, so &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; with an &lt;em&gt;optimization&lt;/em&gt; of &lt;code&gt;2&lt;/code&gt; will lead to the bytecode path of &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc&lt;/code&gt;. The string representation of &lt;em&gt;optimization&lt;/em&gt; can only be alphanumeric, else &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;최적화&lt;/em&gt; 매개 변수는 바이트 코드 파일의 최적화 레벨을 지정하는 데 사용됩니다. 그래서 빈 문자열, 더 최적화를 표시하지 &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; 와 &lt;em&gt;최적화&lt;/em&gt; 의이 &lt;code&gt;''&lt;/code&gt; 의 바이트 코드 경로가 발생합니다 &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.pyc&lt;/code&gt; . &lt;code&gt;None&lt;/code&gt; 은 인터프리터의 최적화 수준을 사용하도록합니다. 그래서 다른 값의 문자열 표현이 사용되는 &lt;code&gt;/foo/bar/baz.py&lt;/code&gt; 와 &lt;em&gt;최적화&lt;/em&gt; 의 &lt;code&gt;2&lt;/code&gt; 의 바이트 코드 경로로 이어질 것입니다 &lt;code&gt;/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc&lt;/code&gt; . &lt;em&gt;최적화&lt;/em&gt; 의 문자열 표현&lt;em&gt;&lt;/em&gt;영숫자 만 가능하며, 그렇지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aeab2b3e4c0bce06083aef5c507ae9b49420eb23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;password&lt;/em&gt; argument may be a function to call to get the password for decrypting the private key. It will only be called if the private key is encrypted and a password is necessary. It will be called with no arguments, and it should return a string, bytes, or bytearray. If the return value is a string it will be encoded as UTF-8 before using it to decrypt the key. Alternatively a string, bytes, or bytearray value may be supplied directly as the &lt;em&gt;password&lt;/em&gt; argument. It will be ignored if the private key is not encrypted and no password is needed.</source>
          <target state="translated">&lt;em&gt;암호&lt;/em&gt; 인수는 함수가 개인 키를 해독하는 암호를 얻기 위해 호출 할 수 있습니다. 개인 키가 암호화되어 있고 암호가 필요한 경우에만 호출됩니다. 인수없이 호출되며 문자열, 바이트 또는 바이트 배열을 반환해야합니다. 리턴 값이 문자열 인 경우이를 사용하여 키를 해독하기 전에 UTF-8로 인코딩됩니다. 또는 문자열, 바이트 또는 바이트 배열 값이 &lt;em&gt;암호&lt;/em&gt; 인수 로 직접 제공 될 수 있습니다 . 개인 키가 암호화되지 않고 암호가 필요하지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5894a49d9fd67c04eb2502774f6b556f37efb59f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; argument is the directory for which the finder is in charge of searching.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 인수는 찾기가 검색을 담당하고있는 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="5a0b8f2bc9289b37bab8872fee5877c84de68db7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; parameter is the path to the executable file. The &lt;em&gt;path&lt;/em&gt; should contain a directory. Use &lt;a href=&quot;#os.posix_spawnp&quot;&gt;&lt;code&gt;posix_spawnp()&lt;/code&gt;&lt;/a&gt; to pass an executable file without directory.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 매개 변수는 실행 파일의 경로입니다. &lt;em&gt;경로&lt;/em&gt; 디렉토리를 포함해야합니다. &lt;a href=&quot;#os.posix_spawnp&quot;&gt; &lt;code&gt;posix_spawnp()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 디렉토리없이 실행 파일을 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3b64714cf1d89975545a84417ebd84d5e337d0a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;path&lt;/em&gt; parameter is the path to the executable file.The &lt;em&gt;path&lt;/em&gt; should contain a directory.Use &lt;a href=&quot;#os.posix_spawnp&quot;&gt;&lt;code&gt;posix_spawnp()&lt;/code&gt;&lt;/a&gt; to pass an executable file without directory.</source>
          <target state="translated">&lt;em&gt;경로&lt;/em&gt; 매개 변수는 실행] 파일의 경로입니다 &lt;em&gt;경로&lt;/em&gt; directory.Use에 포함해야 &lt;a href=&quot;#os.posix_spawnp&quot;&gt; &lt;code&gt;posix_spawnp()&lt;/code&gt; &lt;/a&gt; 디렉토리없이 실행 파일을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="9c46f81dad7b34554c6c2af6f64f9d65570f63a5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;pax_headers&lt;/em&gt; argument is an optional dictionary of strings which will be added as a pax global header if &lt;em&gt;format&lt;/em&gt; is &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;pax_headers의&lt;/em&gt; 인수는 경우 팍스 글로벌 헤더로 추가됩니다 문자열의 선택적 사전입니다 &lt;em&gt;형식&lt;/em&gt; 입니다 &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; 가&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="385c9a120811afd54baa69bd7076c1e6f5593f01" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;payload&lt;/em&gt; is either a string or bytes object, in the case of simple message objects, or a list of &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects, for MIME container documents such as &lt;em&gt;multipart/*&lt;/em&gt; and &lt;em&gt;message/rfc822&lt;/em&gt; message objects.</source>
          <target state="translated">&lt;em&gt;페이로드&lt;/em&gt; 중 문자열 또는 단순한 메시지 객체의 경우, 객체 바이트 또는 목록 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 는&lt;/a&gt; 같은 MIME 컨테이너 문서 객체 &lt;em&gt;다중 / *&lt;/em&gt; 및 &lt;em&gt;메시지 / RFC822의&lt;/em&gt; 메시지 오브젝트.</target>
        </trans-unit>
        <trans-unit id="ea70b7df974c3fb9e6c0547260aae38aa155e773" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preamble&lt;/em&gt; attribute contains this leading extra-armor text for MIME documents. When the &lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; discovers some text after the headers but before the first boundary string, it assigns this text to the message&amp;rsquo;s &lt;em&gt;preamble&lt;/em&gt; attribute. When the &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is writing out the plain text representation of a MIME message, and it finds the message has a &lt;em&gt;preamble&lt;/em&gt; attribute, it will write this text in the area between the headers and the first boundary. See &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;email.generator&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;프리앰블&lt;/em&gt; 속성은 MIME 문서에 대해이 최고의 여분 갑옷 텍스트를 포함합니다. &lt;a href=&quot;email.parser#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 는 헤더 뒤에서 첫 번째 경계 문자열 이전에 일부 텍스트를 발견 하면 이 텍스트를 메시지의 &lt;em&gt;프리앰블&lt;/em&gt; 속성에 할당 합니다. 때 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 는 MIME 메시지의 일반 텍스트 표현을 쓰고, 그것이 메시지가있다 발견 &lt;em&gt;프리앰블&lt;/em&gt; 속성을이 헤더와 첫 번째 경계 사이의 영역에서이 텍스트를 작성합니다. 참조 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;email.generator&lt;/code&gt; &lt;/a&gt; 자세한 내용을.</target>
        </trans-unit>
        <trans-unit id="1a54fdfb6b6943ecad12822e748b19740f664e27" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;precision&lt;/em&gt; is a decimal number indicating how many digits should be displayed after the decimal point for a floating point value formatted with &lt;code&gt;'f'&lt;/code&gt; and &lt;code&gt;'F'&lt;/code&gt;, or before and after the decimal point for a floating point value formatted with &lt;code&gt;'g'&lt;/code&gt; or &lt;code&gt;'G'&lt;/code&gt;. For non-number types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The &lt;em&gt;precision&lt;/em&gt; is not allowed for integer values.</source>
          <target state="translated">&lt;em&gt;정밀도&lt;/em&gt; 로 포맷 된 부동 소수점 값의 소수점 후에 표시되어야하는 숫자를 나타내는 진수 인 &lt;code&gt;'f'&lt;/code&gt; 와 &lt;code&gt;'F'&lt;/code&gt; , 또는 전으로 포맷 된 부동 소수점 값의 소수점 이후 &lt;code&gt;'g'&lt;/code&gt; 또는 &lt;code&gt;'G'&lt;/code&gt; . 숫자가 아닌 유형의 경우이 필드는 최대 필드 크기, 즉 필드 내용에서 사용될 문자 수를 나타냅니다. 정수 값 에는 &lt;em&gt;정밀도&lt;/em&gt; 가 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a42059a7398e0076eb8d110fcba8360dfcfb871" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preexec_fn&lt;/em&gt; parameter is not safe to use in the presence of threads in your application. The child process could deadlock before exec is called. If you must use it, keep it trivial! Minimize the number of libraries you call into.</source>
          <target state="translated">&lt;em&gt;preexec_fn&lt;/em&gt; 매개 변수는 응용 프로그램에서 스레드의 존재에 사용하는 것이 안전하지 않습니다. exec가 호출되기 전에 자식 프로세스가 교착 상태에 빠질 수 있습니다. 반드시 사용해야한다면 사소한 것이 좋습니다! 호출하는 라이브러리 수를 최소화하십시오.</target>
        </trans-unit>
        <trans-unit id="2117709fb8c29d93d11cbcd71421f2390c22da8d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prefix&lt;/em&gt; may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;접두어는&lt;/em&gt; 어떤 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c2cc6abdc0befc2720b7ccef1d9ae061ce483f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;prefix&lt;/em&gt;, &lt;em&gt;suffix&lt;/em&gt;, and &lt;em&gt;dir&lt;/em&gt; arguments are the same as for &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;접두사&lt;/em&gt; , &lt;em&gt;접미사&lt;/em&gt; 및 &lt;em&gt;DIR의&lt;/em&gt; 인자와 동일 &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02180b4f716501a7667649b1f96c422fcb8aa64b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;preset&lt;/em&gt; argument (if provided) should be an integer between &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;9&lt;/code&gt; (inclusive), optionally OR-ed with the constant &lt;code&gt;PRESET_EXTREME&lt;/code&gt;. If neither &lt;em&gt;preset&lt;/em&gt; nor &lt;em&gt;filters&lt;/em&gt; are given, the default behavior is to use &lt;code&gt;PRESET_DEFAULT&lt;/code&gt; (preset level &lt;code&gt;6&lt;/code&gt;). Higher presets produce smaller output, but make the compression process slower.</source>
          <target state="translated">&lt;em&gt;소정&lt;/em&gt; 인수 (있는 경우)의 정수이어야 &lt;code&gt;0&lt;/code&gt; 및 &lt;code&gt;9&lt;/code&gt; (포함), 상수를 가진 임의 OR 혼성 &lt;code&gt;PRESET_EXTREME&lt;/code&gt; . &lt;em&gt;사전 설정&lt;/em&gt; 이나 &lt;em&gt;필터&lt;/em&gt; 가 제공 되지 않은 경우 기본 동작은 &lt;code&gt;PRESET_DEFAULT&lt;/code&gt; (사전 설정 레벨 &lt;code&gt;6&lt;/code&gt; )를 사용하는 것입니다. 프리셋이 높을수록 출력은 작아 지지만 압축 프로세스는 느려집니다.</target>
        </trans-unit>
        <trans-unit id="9895acc66c3f18475ff9f0db5201b4c6a71ff0e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol_factory&lt;/em&gt; must be a callable returning a subclass of the &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt;&lt;code&gt;SubprocessProtocol&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;em&gt;protocol_factory는&lt;/em&gt; 의 서브 클래스 반환하는 호출해야합니다 &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt; &lt;code&gt;SubprocessProtocol&lt;/code&gt; 의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="f711c66569fb5d19645c5457dbc47d4d07d6d7c3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;protocol_factory&lt;/em&gt; must be a callable returning a subclass of the &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt;&lt;code&gt;asyncio.SubprocessProtocol&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;em&gt;protocol_factory는&lt;/em&gt; 의 서브 클래스 반환하는 호출해야합니다 &lt;a href=&quot;asyncio-protocol#asyncio.SubprocessProtocol&quot;&gt; &lt;code&gt;asyncio.SubprocessProtocol&lt;/code&gt; 의&lt;/a&gt; 클래스를.</target>
        </trans-unit>
        <trans-unit id="401443787918a85da5a18eb500ca9cde85fb13e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;purpose&lt;/em&gt; flag specifies what kind of CA certificates are loaded. The default settings &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt;&lt;code&gt;Purpose.SERVER_AUTH&lt;/code&gt;&lt;/a&gt; loads certificates, that are flagged and trusted for TLS web server authentication (client side sockets). &lt;a href=&quot;#ssl.Purpose.CLIENT_AUTH&quot;&gt;&lt;code&gt;Purpose.CLIENT_AUTH&lt;/code&gt;&lt;/a&gt; loads CA certificates for client certificate verification on the server side.</source>
          <target state="translated">&lt;em&gt;목적의&lt;/em&gt; 어떤 종류의 CA 인증서의 플래그 지정이로드됩니다. 기본 설정 &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt; &lt;code&gt;Purpose.SERVER_AUTH&lt;/code&gt; &lt;/a&gt; 는 TLS 웹 서버 인증 (클라이언트 측 소켓)에 대해 플래그가 지정되고 신뢰할 수있는 인증서를로드합니다. &lt;a href=&quot;#ssl.Purpose.CLIENT_AUTH&quot;&gt; &lt;code&gt;Purpose.CLIENT_AUTH&lt;/code&gt; &lt;/a&gt; 는 서버 측에서 클라이언트 인증서 확인을 위해 CA 인증서를로드합니다.</target>
        </trans-unit>
        <trans-unit id="4dc1ae68be8c928ff8ced55af039b97dee0f266d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;readrc&lt;/em&gt; argument defaults to true and controls whether Pdb will load .pdbrc files from the filesystem.</source>
          <target state="translated">&lt;em&gt;readrc의&lt;/em&gt; 인수 디폴트는 true와 제어한다 Pdb는 파일 시스템에서 파일을 .pdbrc로드할지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="46e14dc3cbadaa634897551ddab605eacd0ed865" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; argument is as documented for &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt;&lt;code&gt;return_ok()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 인수로 문서화되어 &lt;a href=&quot;#http.cookiejar.CookiePolicy.return_ok&quot;&gt; &lt;code&gt;return_ok()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5524c970b27a1790f26c76be61a832fdb402cb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; object (usually a &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt;&lt;code&gt;urllib.request.Request&lt;/code&gt;&lt;/a&gt; instance) must support the methods &lt;code&gt;get_full_url()&lt;/code&gt;, &lt;code&gt;get_host()&lt;/code&gt;, &lt;code&gt;get_type()&lt;/code&gt;, &lt;code&gt;unverifiable()&lt;/code&gt;, &lt;code&gt;has_header()&lt;/code&gt;, &lt;code&gt;get_header()&lt;/code&gt;, &lt;code&gt;header_items()&lt;/code&gt;, &lt;code&gt;add_unredirected_header()&lt;/code&gt; and &lt;code&gt;origin_req_host&lt;/code&gt; attribute as documented by &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 개체 (일반적 &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt; &lt;code&gt;urllib.request.Request&lt;/code&gt; &lt;/a&gt; 인스턴스) 방법을 지원한다 &lt;code&gt;get_full_url()&lt;/code&gt; , &lt;code&gt;get_host()&lt;/code&gt; , &lt;code&gt;get_type()&lt;/code&gt; , &lt;code&gt;unverifiable()&lt;/code&gt; , &lt;code&gt;has_header()&lt;/code&gt; , &lt;code&gt;get_header()&lt;/code&gt; , &lt;code&gt;header_items()&lt;/code&gt; , &lt;code&gt;add_unredirected_header()&lt;/code&gt; 및 &lt;code&gt;origin_req_host&lt;/code&gt; 을&lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; 에&lt;/a&gt; 의해 문서화 된 속성 .</target>
        </trans-unit>
        <trans-unit id="6076db6f2a9e32f368a89ef0cd834117df42f630" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; object (usually a &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt;&lt;code&gt;urllib.request.Request&lt;/code&gt;&lt;/a&gt; instance) must support the methods &lt;code&gt;get_full_url()&lt;/code&gt;, &lt;code&gt;get_host()&lt;/code&gt;, &lt;code&gt;unverifiable()&lt;/code&gt;, and &lt;code&gt;origin_req_host&lt;/code&gt; attribute, as documented by &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;. The request is used to set default values for cookie-attributes as well as for checking that the cookie is allowed to be set.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 개체 (일반적 &lt;a href=&quot;urllib.request#urllib.request.Request&quot;&gt; &lt;code&gt;urllib.request.Request&lt;/code&gt; &lt;/a&gt; 인스턴스) 방법을 지원한다 &lt;code&gt;get_full_url()&lt;/code&gt; , &lt;code&gt;get_host()&lt;/code&gt; , &lt;code&gt;unverifiable()&lt;/code&gt; 및 &lt;code&gt;origin_req_host&lt;/code&gt; 의 속성에 의해 설명 된대로 &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; &lt;/a&gt; . 요청은 쿠키 속성의 기본값을 설정하고 쿠키를 설정할 수 있는지 확인하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e2f1c2f586a7c581cf5d92cb55cc5d4a2a88d0cd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;request&lt;/em&gt; parameter is limited to values that can fit in 32-bits. Additional constants of interest for use as the &lt;em&gt;request&lt;/em&gt; argument can be found in the &lt;a href=&quot;termios#module-termios&quot;&gt;&lt;code&gt;termios&lt;/code&gt;&lt;/a&gt; module, under the same names as used in the relevant C header files.</source>
          <target state="translated">&lt;em&gt;요청&lt;/em&gt; 파라미터는 32 비트에 들어갈 수있는 값으로 제한된다. &lt;em&gt;요청&lt;/em&gt; 인수 로 사용할 추가 상수 는 관련 C 헤더 파일에 사용 된 것과 동일한 이름으로 &lt;a href=&quot;termios#module-termios&quot;&gt; &lt;code&gt;termios&lt;/code&gt; &lt;/a&gt; 모듈 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="249de6ab2421958fe5451ea48601c9e94f9750cb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;response&lt;/em&gt; object (usually the result of a call to &lt;a href=&quot;urllib.request#urllib.request.urlopen&quot;&gt;&lt;code&gt;urllib.request.urlopen()&lt;/code&gt;&lt;/a&gt;, or similar) should support an &lt;code&gt;info()&lt;/code&gt; method, which returns an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;em&gt;응답&lt;/em&gt; 객체 (전화의 일반적 결과는합니다 &lt;a href=&quot;urllib.request#urllib.request.urlopen&quot;&gt; &lt;code&gt;urllib.request.urlopen()&lt;/code&gt; &lt;/a&gt; 지원해야한다, 또는 유사한) &lt;code&gt;info()&lt;/code&gt; 반환 방법, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; 의&lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="04ce21268d40bc71f1f9a9083f103f2659796911" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;response&lt;/em&gt; that is returned as the first item in the return tuple of almost all methods is the server&amp;rsquo;s response: a string beginning with a three-digit code. If the server&amp;rsquo;s response indicates an error, the method raises one of the above exceptions.</source>
          <target state="translated">&lt;em&gt;응답&lt;/em&gt; 거의 모든 메소드의 반환 튜플의 첫 번째 항목으로 반환되는 서버의 응답입니다 : 문자열이 세 자리 코드로 시작. 서버의 응답에 오류가 있으면 위의 예외 중 하나가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a08f6a3c82a95e392e1e6e160bcc0d359886a5e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;rounding&lt;/em&gt; option is one of the constants listed in the section &lt;a href=&quot;#rounding-modes&quot;&gt;Rounding Modes&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;반올림&lt;/em&gt; 옵션은 섹션에 나열된 상수 중 하나입니다 &lt;a href=&quot;#rounding-modes&quot;&gt;반올림 모드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6d46553ec93f51e386c82746a812fbd9cb5fc2e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;safe&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, and &lt;em&gt;errors&lt;/em&gt; parameters are passed down to &lt;em&gt;quote_via&lt;/em&gt; (the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters are only passed when a query element is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;em&gt;안전하고&lt;/em&gt; , &lt;em&gt;인코딩&lt;/em&gt; 하고, &lt;em&gt;에러&lt;/em&gt; 파라미터에 전해진다 &lt;em&gt;quote_via&lt;/em&gt; 합니다 ( &lt;em&gt;부호화&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 질의 요소가있는 경우에만 파라미터가 전달되는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="45c6ec6d33577622f7757d14f0820e4e75833046" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scheduler&lt;/em&gt; argument must be a tuple containing the (optional) scheduler policy and an instance of &lt;a href=&quot;#os.sched_param&quot;&gt;&lt;code&gt;sched_param&lt;/code&gt;&lt;/a&gt; with the scheduler parameters. A value of &lt;code&gt;None&lt;/code&gt; in the place of the scheduler policy indicates that is not being provided. This argument is a combination of the C library &lt;code&gt;POSIX_SPAWN_SETSCHEDPARAM&lt;/code&gt; and &lt;code&gt;POSIX_SPAWN_SETSCHEDULER&lt;/code&gt; flags.</source>
          <target state="translated">&lt;em&gt;스케줄러&lt;/em&gt; 인수는 (선택) 스케줄러 정책과의 인스턴스가 포함 된 튜플해야 &lt;a href=&quot;#os.sched_param&quot;&gt; &lt;code&gt;sched_param&lt;/code&gt; &lt;/a&gt; 스케줄러 매개 변수를. 스케줄러 정책 대신 &lt;code&gt;None&lt;/code&gt; 값은 제공되지 않음을 나타냅니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSCHEDPARAM&lt;/code&gt; 및 &lt;code&gt;POSIX_SPAWN_SETSCHEDULER&lt;/code&gt; 플래그 의 조합입니다 .</target>
        </trans-unit>
        <trans-unit id="7ec1f6a11cc0295f4e6de025d3da51e89252d526" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;scheme&lt;/em&gt; argument gives the default addressing scheme, to be used only if the URL does not specify one. It should be the same type (text or bytes) as &lt;em&gt;urlstring&lt;/em&gt;, except that the default value &lt;code&gt;''&lt;/code&gt; is always allowed, and is automatically converted to &lt;code&gt;b''&lt;/code&gt; if appropriate.</source>
          <target state="translated">&lt;em&gt;체계의&lt;/em&gt; 인수는 기본 주소 체계를 제공하는 URL이 하나를 지정하지 않는 경우에만 사용되어야한다. 기본값 &lt;code&gt;''&lt;/code&gt; 이 항상 허용되고 필요한 경우 자동으로 &lt;code&gt;b''&lt;/code&gt; 로 변환 된다는 점을 제외하고 &lt;em&gt;urlstring&lt;/em&gt; 과 동일한 유형 (텍스트 또는 바이트) &lt;em&gt;이어야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9c3d14f8574339300c0dd4daab37b014b3b42911" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;server_name_callback&lt;/em&gt; callback passed to &lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt;&lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt;&lt;/a&gt; will get an &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance instead of a &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; instance as its first parameter.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.set_servername_callback&quot;&gt; &lt;code&gt;SSLContext.set_servername_callback()&lt;/code&gt; &lt;/a&gt; 전달 된 &lt;em&gt;server_name_callback&lt;/em&gt; 콜백 은 첫 번째 매개 변수로 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 인스턴스 대신 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="9490a29cd2edeaa045d35fc7cad654528add8e39" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;server_side&lt;/em&gt;, &lt;em&gt;server_hostname&lt;/em&gt; and &lt;em&gt;session&lt;/em&gt; parameters have the same meaning as in &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;server_side&lt;/em&gt; , &lt;em&gt;server_hostname&lt;/em&gt; 및 &lt;em&gt;세션&lt;/em&gt; 파라미터와 동일한 의미를 갖는다 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a673e1ab33e5fd9a4b186a8ac8f33a5a9fa4ca7b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;setpgroup&lt;/em&gt; argument will set the process group of the child to the value specified. If the value specified is 0, the child&amp;rsquo;s process group ID will be made the same as its process ID. If the value of &lt;em&gt;setpgroup&lt;/em&gt; is not set, the child will inherit the parent&amp;rsquo;s process group ID. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETPGROUP&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;setpgroup의&lt;/em&gt; 인수는 지정된 값으로 자녀의 프로세스 그룹을 설정합니다. 지정된 값이 0이면 하위 프로세스 그룹 ID는 프로세스 ID와 동일하게됩니다. &lt;em&gt;setpgroup&lt;/em&gt; 의 값이 설정되지 않으면 하위 프로세스는 상위 프로세스 그룹 ID를 상속합니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETPGROUP&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="ff1d457cea9007b652c10d501e50abc8a21daa32" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;setsigmask&lt;/em&gt; argument will set the signal mask to the signal set specified. If the parameter is not used, then the child inherits the parent&amp;rsquo;s signal mask. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETSIGMASK&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;setsigmask의&lt;/em&gt; 인수 지정 신호 세트의 신호 마스크를 설정한다. 매개 변수를 사용하지 않으면 자식은 부모의 신호 마스크를 상속합니다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSIGMASK&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="a24d31ceaa7c092d726d770a0cf41f125d0aebf5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shallow&lt;/em&gt; parameter has the same meaning and default value as for &lt;a href=&quot;#filecmp.cmp&quot;&gt;&lt;code&gt;filecmp.cmp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;얕은의&lt;/em&gt; 매개 변수와 동일한 의미와 기본 값이 &lt;a href=&quot;#filecmp.cmp&quot;&gt; &lt;code&gt;filecmp.cmp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a80e01db550d1bd3a7bd6ebc74b18d968e849fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shell&lt;/em&gt; argument (which defaults to &lt;code&gt;False&lt;/code&gt;) specifies whether to use the shell as the program to execute. If &lt;em&gt;shell&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, it is recommended to pass &lt;em&gt;args&lt;/em&gt; as a string rather than as a sequence.</source>
          <target state="translated">&lt;em&gt;쉘&lt;/em&gt; 인수 (기본값은 &lt;code&gt;False&lt;/code&gt; ) 실행할 수있는 프로그램으로 쉘을 사용할지 여부를 지정합니다. 경우 &lt;em&gt;쉘&lt;/em&gt; 입니다 &lt;code&gt;True&lt;/code&gt; , 그것을 통과하는 것이 좋습니다 &lt;em&gt;인수를&lt;/em&gt; 문자열로보다는 시퀀스로.</target>
        </trans-unit>
        <trans-unit id="64685938fa2858e93dc0ebb23445efd4d0c5e167" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sigdef&lt;/em&gt; argument will reset the disposition of all signals in the set specified. This argument corresponds to the C library &lt;code&gt;POSIX_SPAWN_SETSIGDEF&lt;/code&gt; flag.</source>
          <target state="translated">&lt;em&gt;sigdef의&lt;/em&gt; 인수는 지정된 세트의 모든 신호의 처리를 다시한다. 이 인수는 C 라이브러리 &lt;code&gt;POSIX_SPAWN_SETSIGDEF&lt;/code&gt; 플래그에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="6cab8b73313d2d8e8c5f669a403b631d6f400e9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sign&lt;/em&gt; option is only valid for number types, and can be one of the following:</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 옵션은 숫자 유형에만 유효하며, 다음 중 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a1b57cb9c563c9860f94c21c54bbaa756fd93cb9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;signed&lt;/em&gt; argument determines whether two&amp;rsquo;s complement is used to represent the integer. If &lt;em&gt;signed&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; and a negative integer is given, an &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt; is raised. The default value for &lt;em&gt;signed&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 인수는 2의 보수는 정수를 나타내는 데 사용 여부를 결정합니다. 경우 &lt;em&gt;서명이&lt;/em&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 과 음의 정수가 주어, &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. &lt;em&gt;signed&lt;/em&gt; 의 기본값 은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="371f7246c775e34157c3af19c7e256b43858f6a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;signed&lt;/em&gt; argument indicates whether two&amp;rsquo;s complement is used to represent the integer.</source>
          <target state="translated">&lt;em&gt;서명&lt;/em&gt; 인수는 2의 보수는 정수를 나타내는 데 사용됩니다 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c1af8aa11bb01ff7639b96a4988e666df7acd3f2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; argument indicates the approximate maximum number of encoded bytes or code points to read for decoding. The decoder can modify this setting as appropriate. The default value -1 indicates to read and decode as much as possible. This parameter is intended to prevent having to decode huge files in one step.</source>
          <target state="translated">&lt;em&gt;크기&lt;/em&gt; 인자는 디코딩 읽을 부호화 바이트 코드 포인트의 대략 최대 수를 나타낸다. 디코더는이 설정을 적절하게 수정할 수 있습니다. 기본값 -1은 가능한 많이 읽고 디코딩 함을 나타냅니다. 이 매개 변수는 한 번에 많은 파일을 디코딩하지 않도록하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="d355dd9c76833b2b080632c6620ca9de793f66dc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;size&lt;/em&gt; argument is normally passed to the decorated test method as an extra argument. If &lt;em&gt;dry_run&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt;, the value passed to the test method may be less than the requested value. If &lt;em&gt;dry_run&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, it means the test doesn&amp;rsquo;t support dummy runs when &lt;code&gt;-M&lt;/code&gt; is not specified.</source>
          <target state="translated">&lt;em&gt;크기&lt;/em&gt; 인수는 일반적으로 별도의 인수로 장식 된 시험 방법에 전달됩니다. &lt;em&gt;dry_run&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 테스트 메소드에 전달 된 값이 요청 된 값보다 작을 수 있습니다. 경우 &lt;em&gt;dry_run이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; ,이 때 테스트 더미 실행을 지원하지 않습니다 의미 &lt;code&gt;-M&lt;/code&gt; 이 지정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="151dde5b0ba7cb1869ce8877b126a35442579a25" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;skip&lt;/em&gt; argument, if given, must be an iterable of glob-style module name patterns. The debugger will not step into frames that originate in a module that matches one of these patterns. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;스킵&lt;/em&gt; 인수는, 주어진 경우, 글로브 스타일의 모듈 이름 패턴의 반복 가능한해야합니다. 디버거는 이러한 패턴 중 하나와 일치하는 모듈에서 시작되는 프레임으로 들어 가지 않습니다. &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c97b4a14038331f376db5a76543fd70a20e5addc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;skip&lt;/em&gt; argument, if given, must be an iterable of glob-style module name patterns. The debugger will not step into frames that originate in a module that matches one of these patterns. Whether a frame is considered to originate in a certain module is determined by the &lt;code&gt;__name__&lt;/code&gt; in the frame globals.</source>
          <target state="translated">&lt;em&gt;스킵&lt;/em&gt; 인수는, 주어진 경우, 글로브 스타일의 모듈 이름 패턴의 반복 가능한해야합니다. 디버거는 이러한 패턴 중 하나와 일치하는 모듈에서 시작되는 프레임으로 들어 가지 않습니다. 프레임이 특정 모듈에서 시작된 것으로 간주되는지 여부는 프레임 전역 의 &lt;code&gt;__name__&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d44decd9d7b523509313fc74a2d69d1a2b290502" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sleep&lt;/em&gt; argument specifies the number of seconds to sleep by between successive attempts to backup remaining pages, can be specified either as an integer or a floating point value.</source>
          <target state="translated">&lt;em&gt;수면&lt;/em&gt; 인수 지정은 백업 나머지 페이지에 연속 시도 사이에 의해 잠을 초 단위는 정수 또는 부동 소수점 값 중 하나를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166a331e704e3a141fa3c371379efa856fe7128c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sni_callback&lt;/em&gt; function must return &lt;code&gt;None&lt;/code&gt; to allow the TLS negotiation to continue. If a TLS failure is required, a constant &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_*&lt;/code&gt;&lt;/a&gt; can be returned. Other return values will result in a TLS fatal error with &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt;&lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;sni_callback의&lt;/em&gt; 기능은 반환하지합니다 &lt;code&gt;None&lt;/code&gt; TLS 협상을 계속 할 수 있도록합니다. TLS 실패가 필요한 경우 상수 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_*&lt;/code&gt; &lt;/a&gt; 가 리턴 될 수 있습니다. 다른 반환 값은 &lt;a href=&quot;#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR&quot;&gt; &lt;code&gt;ALERT_DESCRIPTION_INTERNAL_ERROR&lt;/code&gt; &lt;/a&gt; 와 함께 TLS 치명적인 오류가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="955cb7b76408c61d468a2564832812df5fa5e51a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter is a sound association name from the registry. If the registry contains no such name, play the system default sound unless &lt;a href=&quot;#winsound.SND_NODEFAULT&quot;&gt;&lt;code&gt;SND_NODEFAULT&lt;/code&gt;&lt;/a&gt; is also specified. If no default sound is registered, raise &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt;. Do not use with &lt;a href=&quot;#winsound.SND_FILENAME&quot;&gt;&lt;code&gt;SND_FILENAME&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;사운드&lt;/em&gt; 매개 변수는 레지스트리에서 사운드 연결 이름입니다. 레지스트리에 이러한 이름이 없으면 &lt;a href=&quot;#winsound.SND_NODEFAULT&quot;&gt; &lt;code&gt;SND_NODEFAULT&lt;/code&gt; &lt;/a&gt; 도 지정 하지 않은 한 시스템 기본 사운드를 재생하십시오 . 기본 사운드가 등록되어 있지 않으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. &lt;a href=&quot;#winsound.SND_FILENAME&quot;&gt; &lt;code&gt;SND_FILENAME&lt;/code&gt; &lt;/a&gt; 과 함께 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="b134798684044ca68a3fcd2a983ed363cbdb1b27" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter is the name of a WAV file. Do not use with &lt;a href=&quot;#winsound.SND_ALIAS&quot;&gt;&lt;code&gt;SND_ALIAS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;사운드&lt;/em&gt; 매개 변수는 WAV 파일의 이름입니다. &lt;a href=&quot;#winsound.SND_ALIAS&quot;&gt; &lt;code&gt;SND_ALIAS&lt;/code&gt; &lt;/a&gt; 와 함께 사용하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="494b12ba5734dc2ca9617a8112a2a9a15dd567ac" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter to &lt;a href=&quot;#winsound.PlaySound&quot;&gt;&lt;code&gt;PlaySound()&lt;/code&gt;&lt;/a&gt; is a memory image of a WAV file, as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#winsound.PlaySound&quot;&gt; &lt;code&gt;PlaySound()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;사운드&lt;/em&gt; 매개 변수 는 WAV 파일의 메모리 이미지이며 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31a00f465debea4adb9d62708c108f58155f4a53" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sound&lt;/em&gt; parameter to &lt;a href=&quot;#winsound.PlaySound&quot;&gt;&lt;code&gt;PlaySound()&lt;/code&gt;&lt;/a&gt; is a memory image of a WAV file, as a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#winsound.PlaySound&quot;&gt; &lt;code&gt;PlaySound()&lt;/code&gt; &lt;/a&gt; 대한 &lt;em&gt;사운드&lt;/em&gt; 매개 변수 는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체 인&lt;/a&gt; WAV 파일의 메모리 이미지입니다 .</target>
        </trans-unit>
        <trans-unit id="03f6dce2a0c575617067c550aeaa2aeb5a0a02ea" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;spawn&lt;/em&gt; and &lt;em&gt;forkserver&lt;/em&gt; start methods</source>
          <target state="translated">&lt;em&gt;산란&lt;/em&gt; 및 &lt;em&gt;forkserver는&lt;/em&gt; 방법을 시작합니다</target>
        </trans-unit>
        <trans-unit id="812f74adf35e9bd9c0a7d57ac0e4adfe7af57bde" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;spec&lt;/em&gt; and &lt;em&gt;spec_set&lt;/em&gt; keyword arguments are passed to the &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; if patch is creating one for you.</source>
          <target state="translated">&lt;em&gt;사양&lt;/em&gt; 및 &lt;em&gt;spec_set&lt;/em&gt; 인수가 전달됩니다 키워드 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 패치가 당신을 위해 하나를 만드는 경우.</target>
        </trans-unit>
        <trans-unit id="bd76eed69117ffe302594bd904142e1af0f14d91" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stacklevel&lt;/em&gt; parameter is passed from code calling the &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt; and other APIs. If greater than 1, the excess is used to skip stack frames before determining the values to be returned. This will generally be useful when calling logging APIs from helper/wrapper code, so that the information in the event log refers not to the helper/wrapper code, but to the code that calls it.</source>
          <target state="translated">&lt;em&gt;stacklevel의&lt;/em&gt; 매개 변수는 호출 코드에서 전달되는 &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 등의 API를. 1보다 크면 초과는 반환 될 값을 결정하기 전에 스택 프레임을 건너 뛰는 데 사용됩니다. 이는 일반적으로 헬퍼 / 래퍼 코드에서 로깅 API를 호출 할 때 유용하므로 이벤트 로그의 정보는 헬퍼 / 래퍼 코드가 아니라이를 호출하는 코드를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="49def39631fd237e8361aefad23b30365e03cf85" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;standalone&lt;/em&gt; argument behaves exactly as in &lt;code&gt;writexml()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;독립&lt;/em&gt; 인수가 정확히 같이 작동 &lt;code&gt;writexml()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee7bb5e1f93d0aa7def4b926657f815b96ba449" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;start_serving&lt;/em&gt; keyword-only parameter to &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt;&lt;code&gt;asyncio.start_server()&lt;/code&gt;&lt;/a&gt; allows creating a Server object that is not accepting connections initially. In this case &lt;code&gt;Server.start_serving()&lt;/code&gt;, or &lt;a href=&quot;#asyncio.Server.serve_forever&quot;&gt;&lt;code&gt;Server.serve_forever()&lt;/code&gt;&lt;/a&gt; can be used to make the Server start accepting connections.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt; &lt;code&gt;asyncio.start_server()&lt;/code&gt; &lt;/a&gt; 대한 &lt;em&gt;start_serving&lt;/em&gt; 키워드 전용 매개 변수를 사용하면 처음에 연결을 수락하지 않는 서버 오브젝트를 작성할 수 있습니다. 이 경우 &lt;code&gt;Server.start_serving()&lt;/code&gt; 또는 &lt;a href=&quot;#asyncio.Server.serve_forever&quot;&gt; &lt;code&gt;Server.serve_forever()&lt;/code&gt; &lt;/a&gt; 를 사용하여 서버가 연결을 수락하도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff845514b67e263cd929598b99bd6da9b00014a1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stmt&lt;/em&gt; and &lt;em&gt;setup&lt;/em&gt; parameters can also take objects that are callable without arguments. This will embed calls to them in a timer function that will then be executed by &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;. Note that the timing overhead is a little larger in this case because of the extra function calls.</source>
          <target state="translated">&lt;em&gt;STMT&lt;/em&gt; 및 &lt;em&gt;설정&lt;/em&gt; 매개 변수는 인수없이 호출 할 수있는 개체를 취할 수 있습니다. 타이머 함수에 호출을 포함시킨 다음 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 의해 실행됩니다 . 이 경우 추가 함수 호출로 인해 타이밍 오버 헤드가 약간 더 커집니다.</target>
        </trans-unit>
        <trans-unit id="d459734c7b70a35885ce8138ec50017c8cb4923e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object open for reading text or binary data, as appropriate for the specific codec.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 특정 코덱에 적절한 텍스트 또는 이진 데이터를 읽는 파일 - 류의 객체 개방을해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9421205ba92f1959114a601b65062efde304270" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object open for writing text or binary data, as appropriate for the specific codec.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 파일 - 류의 객체 개방 특정 코덱에 적절한 텍스트 또는 이진 데이터를 작성하기위한해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4f9796f885c7ccb144d9aef721b442954ff6936" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stream&lt;/em&gt; argument must be a file-like object.</source>
          <target state="translated">&lt;em&gt;스트림&lt;/em&gt; 인수는 파일 - 류의 객체 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e23660071587e149c908f2b1a9eb0b91e48c3be1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;strict_timestamps&lt;/em&gt; argument, when set to &lt;code&gt;False&lt;/code&gt;, allows to zip files older than 1980-01-01 at the cost of setting the timestamp to 1980-01-01. Similar behavior occurs with files newer than 2107-12-31, the timestamp is also set to the limit.</source>
          <target state="translated">는 &lt;em&gt;strict_timestamps&lt;/em&gt; 로 설정 인수, &lt;code&gt;False&lt;/code&gt; 1980년 1월 1일에 타임 스탬프를 설정하는 비용 1980년 1월 1일 이전의 압축 파일을 수 있습니다. 2107-12-31보다 새로운 파일에서도 비슷한 동작이 발생하며 타임 스탬프도 한계로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="65a8ac3a449de8cf3f20f75dbe64dad0275a8b03" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;stripdir&lt;/em&gt;, &lt;em&gt;prependdir&lt;/em&gt; and &lt;em&gt;limit_sl_dest&lt;/em&gt; arguments correspond to the &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-p&lt;/code&gt; and &lt;code&gt;-e&lt;/code&gt; options described above. They may be specified as &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;bytes&lt;/code&gt; or &lt;a href=&quot;os#os.PathLike&quot;&gt;&lt;code&gt;os.PathLike&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;stripdir&lt;/em&gt; , &lt;em&gt;prependdir&lt;/em&gt; 및 &lt;em&gt;limit_sl_dest&lt;/em&gt; 인수는 대응 &lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-p&lt;/code&gt; 와 &lt;code&gt;-e&lt;/code&gt; 옵션 상술. &lt;code&gt;str&lt;/code&gt; , &lt;code&gt;bytes&lt;/code&gt; 또는 &lt;a href=&quot;os#os.PathLike&quot;&gt; &lt;code&gt;os.PathLike&lt;/code&gt; &lt;/a&gt; 로 지정 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4bd056fc144b78ef948e2d71b7ab2d9023d675c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;style&lt;/em&gt; parameter can be one of &amp;lsquo;%&amp;rsquo;, &amp;lsquo;{&amp;lsquo; or &amp;lsquo;$&amp;rsquo; and determines how the format string will be merged with its data: using one of %-formatting, &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#formatting-styles&quot;&gt;Using particular formatting styles throughout your application&lt;/a&gt; for more information on using {- and $-formatting for log messages.</source>
          <target state="translated">&lt;em&gt;스타일의&lt;/em&gt; 매개 변수는 '{', '%'중 하나가 될 수 있습니다 또는 '$'과는 형식 문자열은 데이터와 통합되는 방법을 결정 %의 -formatting, 중 하나를 사용하여 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; 을&lt;/a&gt; . 로그 메시지에 {-및 $ -formatting을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/howto/logging-cookbook.html#formatting-styles&quot;&gt;응용 프로그램 전체에서 특정 서식 스타일 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="980dc29e4498aad66835fc503d747dd8233e2d1d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;style&lt;/em&gt; parameter can be one of &amp;lsquo;%&amp;rsquo;, &amp;lsquo;{&amp;lsquo; or &amp;lsquo;$&amp;rsquo; and determines how the format string will be merged with its data: using one of %-formatting, &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;string#string.Template&quot;&gt;&lt;code&gt;string.Template&lt;/code&gt;&lt;/a&gt;. This only applies to the format string &lt;em&gt;fmt&lt;/em&gt; (e.g. &lt;code&gt;'%(message)s'&lt;/code&gt; or &lt;code&gt;{message}&lt;/code&gt;), not to the actual log messages passed to &lt;code&gt;Logger.debug&lt;/code&gt; etc; see &lt;a href=&quot;https://docs.python.org/3.9/howto/logging-cookbook.html#formatting-styles&quot;&gt;Using particular formatting styles throughout your application&lt;/a&gt; for more information on using {- and $-formatting for log messages.</source>
          <target state="translated">&lt;em&gt;스타일의&lt;/em&gt; 매개 변수는 '{', '%'중 하나가 될 수 있습니다 또는 '$'과는 형식 문자열은 데이터와 통합되는 방법을 결정 %의 -formatting, 중 하나를 사용하여 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;string#string.Template&quot;&gt; &lt;code&gt;string.Template&lt;/code&gt; 을&lt;/a&gt; . 이는 형식 문자열 &lt;em&gt;fmt&lt;/em&gt; (예 : &lt;code&gt;'%(message)s'&lt;/code&gt; 또는 &lt;code&gt;{message}&lt;/code&gt; ) 에만 적용 되며 &lt;code&gt;Logger.debug&lt;/code&gt; 등에 전달 된 실제 로그 메시지에는 적용되지 않습니다 . 로그 메시지에 {-및 $-형식을 사용하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.9/howto/logging-cookbook.html#formatting-styles&quot;&gt;애플리케이션 전체에서 특정 형식 지정 스타일 사용을&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="818f61b3c97b7797753f6e70a4b3d69d5f55ff63" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;suffix&lt;/em&gt; may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;접미사는&lt;/em&gt; 어떤 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f91bb789f435e7bbe9d7a96d06995f3f8d43b2f7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;symbol&lt;/em&gt; argument determines whether &lt;em&gt;source&lt;/em&gt; is compiled as a statement (&lt;code&gt;'single'&lt;/code&gt;, the default) or as an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-expression&quot;&gt;expression&lt;/a&gt; (&lt;code&gt;'eval'&lt;/code&gt;). Any other value will cause &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to be raised.</source>
          <target state="translated">&lt;em&gt;심볼&lt;/em&gt; 인수 여부를 결정 &lt;em&gt;소스가&lt;/em&gt; 성명 (로 컴파일되어 &lt;code&gt;'single'&lt;/code&gt; 기본) 또는 같은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-expression&quot;&gt;표현&lt;/a&gt; ( &lt;code&gt;'eval'&lt;/code&gt; ). 다른 값을 사용하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c69204d8b0b6fda613e8713bf735181dfac834c6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;symbol&lt;/em&gt; argument determines whether &lt;em&gt;source&lt;/em&gt; is compiled as a statement (&lt;code&gt;'single'&lt;/code&gt;, the default), as a sequence of statements (&lt;code&gt;'exec'&lt;/code&gt;) or as an &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-expression&quot;&gt;expression&lt;/a&gt; (&lt;code&gt;'eval'&lt;/code&gt;). Any other value will cause &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to be raised.</source>
          <target state="translated">&lt;em&gt;심볼&lt;/em&gt; 인수 여부를 결정 &lt;em&gt;소스가&lt;/em&gt; 성명 (로 컴파일되어 &lt;code&gt;'single'&lt;/code&gt; 문장의 순서 (로, 기본) &lt;code&gt;'exec'&lt;/code&gt; ) 또는 같은 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-expression&quot;&gt;표현&lt;/a&gt; ( &lt;code&gt;'eval'&lt;/code&gt; ). 다른 값은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e44c727c722cd091526a9f92fdf653d13be39f3c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;table&lt;/em&gt; argument must be one of the predefined tables in the MSI schema, e.g. &lt;code&gt;'Feature'&lt;/code&gt;, &lt;code&gt;'File'&lt;/code&gt;, &lt;code&gt;'Component'&lt;/code&gt;, &lt;code&gt;'Dialog'&lt;/code&gt;, &lt;code&gt;'Control'&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;em&gt;테이블&lt;/em&gt; 인수는 MSI 스키마 예에서 미리 정의 된 테이블 중 하나 여야합니다 &lt;code&gt;'Feature'&lt;/code&gt; , &lt;code&gt;'File'&lt;/code&gt; , &lt;code&gt;'Component'&lt;/code&gt; , &lt;code&gt;'Dialog'&lt;/code&gt; , &lt;code&gt;'Control'&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="43e5dbf1eb2f65e62249791eebe2af8f0a85e617" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; argument is the name of the tag converted to lower case.</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 인수는 태그의 이름을 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="678ee0b27d4f67663dcfba5935b84a5a9919a39f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; argument is the name of the tag converted to lower case. The &lt;em&gt;attrs&lt;/em&gt; argument is a list of &lt;code&gt;(name, value)&lt;/code&gt; pairs containing the attributes found inside the tag&amp;rsquo;s &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; brackets. The &lt;em&gt;name&lt;/em&gt; will be translated to lower case, and quotes in the &lt;em&gt;value&lt;/em&gt; have been removed, and character and entity references have been replaced.</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 인수는 태그의 이름을 소문자로 변환됩니다. &lt;em&gt;의 attrs&lt;/em&gt; 인수의 목록 &lt;code&gt;(name, value)&lt;/code&gt; 의 특성을 포함하는 쌍을 태그의 내부에 발견 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 괄호. &lt;em&gt;이름은&lt;/em&gt; 소문자로 변환됩니다,와의 따옴표 &lt;em&gt;값이&lt;/em&gt; 제거 된, 문자 엔티티 참조는 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="8055f97fb11a0ac404880fc21479eb1700734e23" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tag&lt;/em&gt; values are strings, with these meanings:</source>
          <target state="translated">&lt;em&gt;태그&lt;/em&gt; 값이 의미로, 문자열 :</target>
        </trans-unit>
        <trans-unit id="b20f83bb0150a6498b1b44a47a57fb80da5c5a8a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;target&lt;/em&gt; argument determines where the resulting archive will be written:</source>
          <target state="translated">&lt;em&gt;대상&lt;/em&gt; 인수는 결과 아카이브가 작성 될 위치를 결정합니다 :</target>
        </trans-unit>
        <trans-unit id="1e10c168e7e125b3ad9c496694fc6cf4572a554e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tarinfo&lt;/em&gt; argument can be used to replace the default &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; class with a different one.</source>
          <target state="translated">&lt;em&gt;tarinfo의&lt;/em&gt; 인수는 기본 대체 할 수 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; 의&lt;/a&gt; 다른 하나 클래스를.</target>
        </trans-unit>
        <trans-unit id="526fb955ea344b7381f36e74d15dd0727d123ce0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;testLoader&lt;/em&gt; argument has to be a &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; instance, and defaults to &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt;&lt;code&gt;defaultTestLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;testLoader의&lt;/em&gt; 인수는되어야한다 &lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; 의&lt;/a&gt; 인스턴스 및 기본값 &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt; &lt;code&gt;defaultTestLoader&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ee5fd830ce393d63a0fedec8d6d4ba56b87e218" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;testRunner&lt;/em&gt; argument can either be a test runner class or an already created instance of it. By default &lt;code&gt;main&lt;/code&gt; calls &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; with an exit code indicating success or failure of the tests run.</source>
          <target state="translated">&lt;em&gt;의 TestRunner&lt;/em&gt; 인수 중 하나를 테스트 러너 클래스 또는 그것의 이미 생성 된 인스턴스가 될 수 있습니다. 기본적으로 &lt;code&gt;main&lt;/code&gt; 은 테스트 실행의 성공 또는 실패를 나타내는 종료 코드와 함께 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="f1d67f40b7914af3788448149baeacbe91461387" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;timeout&lt;/em&gt; argument is passed to &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt;. If the timeout expires, the child process will be killed and waited for. The &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt;&lt;code&gt;TimeoutExpired&lt;/code&gt;&lt;/a&gt; exception will be re-raised after the child process has terminated.</source>
          <target state="translated">&lt;em&gt;타임 아웃&lt;/em&gt; 인수가 전달됩니다 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; . 제한 시간이 만료되면 하위 프로세스가 종료되고 대기합니다. &lt;a href=&quot;#subprocess.TimeoutExpired&quot;&gt; &lt;code&gt;TimeoutExpired&lt;/code&gt; 의&lt;/a&gt; 예외는 자식 프로세스가 종료 된 후 다시이-발생합니다.</target>
        </trans-unit>
        <trans-unit id="7b693b5b8037c056a4f62f7c7c759475e832507e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;transport&lt;/em&gt; argument is the transport representing the connection. The protocol is responsible for storing the reference to its transport.</source>
          <target state="translated">&lt;em&gt;전송&lt;/em&gt; 인수는 연결을 나타내는 전송합니다. 프로토콜은 전송에 대한 참조를 저장합니다.</target>
        </trans-unit>
        <trans-unit id="53c2a3e3b3eb98863bde5d4305376d1fa9980862" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;traps&lt;/em&gt; and &lt;em&gt;flags&lt;/em&gt; fields list any signals to be set. Generally, new contexts should only set traps and leave the flags clear.</source>
          <target state="translated">&lt;em&gt;트랩&lt;/em&gt; 및 &lt;em&gt;플래그&lt;/em&gt; 필드는 어떤 신호가 설정 될 나열. 일반적으로 새 컨텍스트는 트랩을 설정하고 플래그를 비워 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c741294182b97a2d1aa5f08589cea85a0af5c1d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;tuple&lt;/em&gt; should be &lt;code&gt;(nchannels, sampwidth, framerate, nframes, comptype,
compname)&lt;/code&gt;, with values valid for the &lt;code&gt;set*()&lt;/code&gt; methods. Sets all parameters.</source>
          <target state="translated">&lt;em&gt;튜플&lt;/em&gt; 이어야 &lt;code&gt;(nchannels, sampwidth, framerate, nframes, comptype, compname)&lt;/code&gt; 유효한 값으로 &lt;code&gt;set*()&lt;/code&gt; 메소드. 모든 매개 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b7ee36144f195c06ce56a0eda12cbb5df2802992" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;type&lt;/em&gt; of an enumeration member is the enumeration it belongs to:</source>
          <target state="translated">열거 형 멤버 의 &lt;em&gt;유형&lt;/em&gt; 은 다음과 같은 열거 &lt;em&gt;형&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="31f48dd378c2469953b274b9fc49aab7aa53a5d5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;unraisable&lt;/em&gt; argument has the following attributes:</source>
          <target state="translated">&lt;em&gt;unraisable&lt;/em&gt; 인수는 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="08cc62e6a77cc57a42acffe8d231f2d3231ee2b4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use_errno&lt;/em&gt; parameter, when set to true, enables a ctypes mechanism that allows accessing the system &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; error number in a safe way. &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; maintains a thread-local copy of the systems &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; variable; if you call foreign functions created with &lt;code&gt;use_errno=True&lt;/code&gt; then the &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value before the function call is swapped with the ctypes private copy, the same happens immediately after the function call.</source>
          <target state="translated">&lt;em&gt;use_errno의&lt;/em&gt; true로 설정하면 매개 변수는 시스템에 액세스 할 수 있도록하는 ctypes 메커니즘 수 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 안전한 방법으로 오류 번호. &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 시스템 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 변수 의 스레드 로컬 사본을 유지 합니다. &lt;code&gt;use_errno=True&lt;/code&gt; 로 작성된 외부 함수를 호출 하면 함수 호출 전의 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 값이 ctypes 개인용 사본으로 교체되며 함수 호출 직후에도 동일하게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="86cfed265a7f536800ec9f3650cbd08a05b9bc49" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;use_last_error&lt;/em&gt; parameter, when set to true, enables the same mechanism for the Windows error code which is managed by the &lt;a href=&quot;#ctypes.GetLastError&quot;&gt;&lt;code&gt;GetLastError()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;SetLastError()&lt;/code&gt; Windows API functions; &lt;a href=&quot;#ctypes.get_last_error&quot;&gt;&lt;code&gt;ctypes.get_last_error()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.set_last_error&quot;&gt;&lt;code&gt;ctypes.set_last_error()&lt;/code&gt;&lt;/a&gt; are used to request and change the ctypes private copy of the windows error code.</source>
          <target state="translated">&lt;em&gt;use_last_error의&lt;/em&gt; true로 설정하면 매개 변수는에 의해 관리되는 Windows 오류 코드에 대한 동일한 메커니즘 수 &lt;a href=&quot;#ctypes.GetLastError&quot;&gt; &lt;code&gt;GetLastError()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;SetLastError()&lt;/code&gt; Windows API 함수를; &lt;a href=&quot;#ctypes.get_last_error&quot;&gt; &lt;code&gt;ctypes.get_last_error()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.set_last_error&quot;&gt; &lt;code&gt;ctypes.set_last_error()&lt;/code&gt; &lt;/a&gt; 는 Windows 오류 코드의 ctypes 개인용 사본을 요청하고 변경하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5423d3d6187ddeee811ab8af8e82496d2df3fc15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;value&lt;/em&gt; argument can be any object, which is then converted to a string.</source>
          <target state="translated">&lt;em&gt;값&lt;/em&gt; 인수가 문자열로 변환되는 모든 객체가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae0ea92bd8512288395f2eac3ca31db0455c95fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;verbose&lt;/em&gt; argument is unused and deprecated.</source>
          <target state="translated">&lt;em&gt;자세한&lt;/em&gt; 인수는 사용되지 않고 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a3d598de8cb43d84c851a82d72602df8acab107" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;version&lt;/em&gt; argument indicates the data format that &lt;code&gt;dump&lt;/code&gt; should use (see below).</source>
          <target state="translated">&lt;em&gt;버전&lt;/em&gt; 인수하는 데이터 형식을 나타냅니다 &lt;code&gt;dump&lt;/code&gt; (아래 참조)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="915638ef494048f3a2b93140ef40d6b653d16e99" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;version&lt;/em&gt; argument indicates the data format that &lt;code&gt;dumps&lt;/code&gt; should use (see below).</source>
          <target state="translated">&lt;em&gt;버전&lt;/em&gt; 인수하는 데이터 형식을 나타냅니다 &lt;code&gt;dumps&lt;/code&gt; (아래 참조)을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff231d54e756958842b7640abbcd92fef9fd13fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;warnings&lt;/em&gt; argument specifies the &lt;a href=&quot;warnings#warning-filter&quot;&gt;warning filter&lt;/a&gt; that should be used while running the tests. If it&amp;rsquo;s not specified, it will remain &lt;code&gt;None&lt;/code&gt; if a &lt;code&gt;-W&lt;/code&gt; option is passed to &lt;strong&gt;python&lt;/strong&gt; (see &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;Warning control&lt;/a&gt;), otherwise it will be set to &lt;code&gt;'default'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;경고의&lt;/em&gt; 인수는 지정 &lt;a href=&quot;warnings#warning-filter&quot;&gt;경고 필터&lt;/a&gt; 테스트를 실행하는 동안 사용되어야한다. 지정하지 않으면 &lt;code&gt;-W&lt;/code&gt; 옵션이 &lt;strong&gt;python에&lt;/strong&gt; 전달 되면 &lt;code&gt;None&lt;/code&gt; 으로 유지 되고 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;경고 제어&lt;/a&gt; 참조 ) 그렇지 않으면 &lt;code&gt;'default'&lt;/code&gt; 로 설정됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f7df7c34b80f15610fb6fcd42b9f8468c9f8eac2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;warnings&lt;/em&gt; argument specifies the &lt;a href=&quot;warnings#warning-filter&quot;&gt;warning filter&lt;/a&gt; that should be used while running the tests. If it&amp;rsquo;s not specified, it will remain &lt;code&gt;None&lt;/code&gt; if a &lt;code&gt;-W&lt;/code&gt; option is passed to &lt;strong&gt;python&lt;/strong&gt; (see &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#using-on-warnings&quot;&gt;Warning control&lt;/a&gt;), otherwise it will be set to &lt;code&gt;'default'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;경고의&lt;/em&gt; 인수는 지정 &lt;a href=&quot;warnings#warning-filter&quot;&gt;경고 필터&lt;/a&gt; 테스트를 실행하는 동안 사용되어야한다. 지정되지 않은 경우 &lt;code&gt;-W&lt;/code&gt; 옵션이 &lt;strong&gt;python에&lt;/strong&gt; 전달 되면 &lt;code&gt;None&lt;/code&gt; ( &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#using-on-warnings&quot;&gt;경고 제어&lt;/a&gt; 참조 )이 유지되고, 그렇지 않으면 &lt;code&gt;'default'&lt;/code&gt; 로 설정됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8821b03c739e7bb5a0c16c56cf4b025ee726fecf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; argument controls the size of the history buffer (or the &amp;ldquo;window size&amp;rdquo;) used when compressing data, and whether a header and trailer is included in the output. It can take several ranges of values, defaulting to &lt;code&gt;15&lt;/code&gt; (MAX_WBITS):</source>
          <target state="translated">&lt;em&gt;wbits의&lt;/em&gt; 인자를 제어 이력 버퍼의 크기 (또는 &quot;창 크기&quot;) 데이터를 압축 할 때 사용되며, 헤더와 트레일러의 여부는 출력에 포함된다. 여러 범위의 값을 사용할 수 있으며 기본값은 &lt;code&gt;15&lt;/code&gt; (MAX_WBITS)입니다.</target>
        </trans-unit>
        <trans-unit id="588d73b4848378951d405715f75f323ade2906e3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; parameter controls the size of the history buffer (or &amp;ldquo;window size&amp;rdquo;), and what header and trailer format is expected. It is similar to the parameter for &lt;a href=&quot;#zlib.compressobj&quot;&gt;&lt;code&gt;compressobj()&lt;/code&gt;&lt;/a&gt;, but accepts more ranges of values:</source>
          <target state="translated">&lt;em&gt;wbits&lt;/em&gt; 제어 매개 변수 히스토리 버퍼의 크기 (또는 &quot;창 크기&quot;), 어떤 헤더와 트레일러 형식이 예상된다. &lt;a href=&quot;#zlib.compressobj&quot;&gt; &lt;code&gt;compressobj()&lt;/code&gt; &lt;/a&gt; 의 매개 변수와 유사 하지만 더 많은 범위의 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="56f7b96f1606c2648c328d526d73fc9a757e342f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;wbits&lt;/em&gt; parameter controls the size of the history buffer (or the &amp;ldquo;window size&amp;rdquo;), and what header and trailer format is expected. It has the same meaning as &lt;a href=&quot;#decompress-wbits&quot;&gt;described for decompress()&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;wbits&lt;/em&gt; 제어 매개 변수 히스토리 버퍼의 크기 (또는 &quot;창 크기&quot;), 어떤 헤더와 트레일러 형식이 예상된다. &lt;a href=&quot;#decompress-wbits&quot;&gt;decompress ()에 대해 설명한&lt;/a&gt; 것과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="a39abfdff05160cffd980e736dec49577cf18f65" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;weightA&lt;/em&gt; and &lt;em&gt;weightB&lt;/em&gt; arguments are parameters for a simple digital filter and default to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;weightA&lt;/em&gt; 및 &lt;em&gt;weightB&lt;/em&gt; 인수에 간이 형 디지털 필터에 대한 디폴트 파라미터들이다 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;0&lt;/code&gt; 을 각각.</target>
        </trans-unit>
        <trans-unit id="0f15ad7e8083bdb44b330eb9ab06069b23b0308f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;weights&lt;/em&gt; or &lt;em&gt;cum_weights&lt;/em&gt; can use any numeric type that interoperates with the &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values returned by &lt;a href=&quot;#module-random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; (that includes integers, floats, and fractions but excludes decimals). Behavior is undefined if any weight is negative. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if all weights are zero.</source>
          <target state="translated">&lt;em&gt;가중치&lt;/em&gt; 또는 &lt;em&gt;cum_weights가&lt;/em&gt; 와 상호 임의 숫자 형식을 사용하여 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값에 의해 반환 된 &lt;a href=&quot;#module-random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; (정수, 수레 분수하지만 제외 소수를 포함). 가중치가 음수이면 동작이 정의되지 않습니다. &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 모든 웨이트가 제로의 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f53b362c6070875065143332b6ab04bce22e663" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;weights&lt;/em&gt; or &lt;em&gt;cum_weights&lt;/em&gt; can use any numeric type that interoperates with the &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; values returned by &lt;a href=&quot;#module-random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; (that includes integers, floats, and fractions but excludes decimals). Weights are assumed to be non-negative.</source>
          <target state="translated">&lt;em&gt;가중치&lt;/em&gt; 또는 &lt;em&gt;cum_weights가&lt;/em&gt; 와 상호 임의 숫자 형식을 사용하여 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 값에 의해 반환 된 &lt;a href=&quot;#module-random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; (정수, 수레 분수하지만 제외 소수를 포함). 가중치는 음이 아닌 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="3c17783948cbf0dc9055cd0a70b59a79f07178e5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;winmode&lt;/em&gt; parameter is used on Windows to specify how the library is loaded (since &lt;em&gt;mode&lt;/em&gt; is ignored). It takes any value that is valid for the Win32 API &lt;code&gt;LoadLibraryEx&lt;/code&gt; flags parameter. When omitted, the default is to use the flags that result in the most secure DLL load to avoiding issues such as DLL hijacking. Passing the full path to the DLL is the safest way to ensure the correct library and dependencies are loaded.</source>
          <target state="translated">&lt;em&gt;winmode의&lt;/em&gt; 매개 변수 (이후 라이브러리를로드하는 방법을 지정하려면 Windows에서 사용되는 &lt;em&gt;모드가&lt;/em&gt; 무시됩니다). Win32 API &lt;code&gt;LoadLibraryEx&lt;/code&gt; 플래그 매개 변수에 유효한 값을 갖습니다 . 생략하면 기본값은 DLL 하이재킹과 같은 문제를 피하기 위해 가장 안전한 DLL로드를 초래하는 플래그를 사용하는 것입니다. DLL에 대한 전체 경로를 전달하는 것이 올바른 라이브러리 및 종속성이로드되도록하는 가장 안전한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d4c56f152b380a49d2010425932c120b11eb953a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;year&lt;/em&gt;, &lt;em&gt;month&lt;/em&gt; and &lt;em&gt;day&lt;/em&gt; arguments are required. &lt;em&gt;tzinfo&lt;/em&gt; may be &lt;code&gt;None&lt;/code&gt;, or an instance of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass. The remaining arguments must be integers in the following ranges:</source>
          <target state="translated">&lt;em&gt;연도&lt;/em&gt; , &lt;em&gt;월&lt;/em&gt; 및 &lt;em&gt;일&lt;/em&gt; 인수가 필요합니다. &lt;em&gt;tzinfo&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 이거나 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 일 수 있습니다 . 나머지 인수는 다음 범위의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d7cce18ab3585b4f15d60b0009c7d580585e27b7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;zdict&lt;/em&gt; parameter specifies a predefined compression dictionary. If provided, this must be the same dictionary as was used by the compressor that produced the data that is to be decompressed.</source>
          <target state="translated">&lt;em&gt;zdict&lt;/em&gt; 파라미터를 지정하는 소정의 압축 사전. 제공되는 경우 압축 해제 할 데이터를 생성 한 압축기에서 사용한 것과 동일한 사전이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fcf90de0cf7d5a594641c5c96a73337eebf219b6" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;preferred&lt;/strong&gt; function to get the running event loop.</source>
          <target state="translated">&lt;strong&gt;선호하는&lt;/strong&gt; 기능은 실행중인 이벤트 루프를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f60d956207da8637154e9bb57b31087cb2d4d778" translate="yes" xml:space="preserve">
          <source>The ABC &lt;code&gt;MyIterable&lt;/code&gt; defines the standard iterable method, &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;, as an abstract method. The implementation given here can still be called from subclasses. The &lt;code&gt;get_iterator()&lt;/code&gt; method is also part of the &lt;code&gt;MyIterable&lt;/code&gt; abstract base class, but it does not have to be overridden in non-abstract derived classes.</source>
          <target state="translated">ABC &lt;code&gt;MyIterable&lt;/code&gt; 은 표준 반복 가능 메소드 인 &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 를 추상 메소드로 정의합니다 . 여기에 제공된 구현은 여전히 ​​서브 클래스에서 호출 될 수 있습니다. &lt;code&gt;get_iterator()&lt;/code&gt; 메소드는 또한의 일부입니다 &lt;code&gt;MyIterable&lt;/code&gt; 추상 기본 클래스 만이 아닌 추상적 인 파생 클래스에서 재정의 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="faa22bc6bce0a5e04681e2a974e7cae8acce023c" translate="yes" xml:space="preserve">
          <source>The ADPCM coders have never been tried against other ADPCM coders, only against themselves. It could well be that I misinterpreted the standards in which case they will not be interoperable with the respective standards.</source>
          <target state="translated">ADPCM 코더는 다른 ADPCM 코더에 대해 시도 된 적이 없으며 자신에 대해서만 시도되었습니다. 표준을 잘못 해석 한 경우 해당 표준과 상호 운용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8528587fd89e0952d7a00dbb0e05d60038f18b25" translate="yes" xml:space="preserve">
          <source>The AF_* and SOCK_* constants are now &lt;code&gt;AddressFamily&lt;/code&gt; and &lt;code&gt;SocketKind&lt;/code&gt;&lt;a href=&quot;enum#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; collections.</source>
          <target state="translated">AF_ * 및 SOCK_ * 상수는 이제 &lt;code&gt;AddressFamily&lt;/code&gt; 및 &lt;code&gt;SocketKind&lt;/code&gt; &lt;a href=&quot;enum#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; &lt;/a&gt; 컬렉션입니다.</target>
        </trans-unit>
        <trans-unit id="1afb49999cdc36f38970839ccf0a7b7f6b8216b2" translate="yes" xml:space="preserve">
          <source>The API below differs from textbook heap algorithms in two aspects: (a) We use zero-based indexing. This makes the relationship between the index for a node and the indexes for its children slightly less obvious, but is more suitable since Python uses zero-based indexing. (b) Our pop method returns the smallest item, not the largest (called a &amp;ldquo;min heap&amp;rdquo; in textbooks; a &amp;ldquo;max heap&amp;rdquo; is more common in texts because of its suitability for in-place sorting).</source>
          <target state="translated">아래의 API는 두 가지 측면에서 교과서 힙 알고리즘과 다릅니다. (a) 우리는 0부터 시작하는 색인을 사용합니다. 이것은 노드의 인덱스와 자식의 인덱스 사이의 관계를 조금 덜 분명하게 만들지 만, 파이썬이 0부터 시작하는 인덱스를 사용하기 때문에 더 적합합니다. (b) pop 메소드는 가장 큰 항목이 아닌 가장 작은 항목을 반환합니다 (교과서에서는 &quot;최소 힙&quot;이라고하며 &quot;제자리 정렬에 적합하기 때문에 텍스트에서&quot;최대 힙 &quot;이 더 일반적입니다).</target>
        </trans-unit>
        <trans-unit id="76f3b439a545c7eb9ff445a4bdd93b428bc75166" translate="yes" xml:space="preserve">
          <source>The API provided by this module is likely to change in future releases; such changes may not be backward compatible.</source>
          <target state="translated">이 모듈에서 제공하는 API는 향후 릴리스에서 변경 될 수 있습니다. 이러한 변경 사항은 이전 버전과 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e322260aafb4a2f2a2ca6cdac3c65b6a2316bc3a" translate="yes" xml:space="preserve">
          <source>The Any type</source>
          <target state="translated">모든 유형</target>
        </trans-unit>
        <trans-unit id="e1f06186c630db765adc5cb7fa1d1a7415bae3ea" translate="yes" xml:space="preserve">
          <source>The AutoCompleteWindow (ACW) will open after a predefined delay (default is two seconds) after a &amp;lsquo;.&amp;rsquo; or (in a string) an os.sep is typed. If after one of those characters (plus zero or more other characters) a tab is typed the ACW will open immediately if a possible continuation is found.</source>
          <target state="translated">자동 완성 창 (ACW)은 '.'다음에 사전 정의 된 지연 (기본값은 2 초) 후에 열립니다. 또는 (문자열에서) os.sep가 입력됩니다. 해당 문자 중 하나 (및 0 개 이상의 다른 문자) 뒤에 탭이 입력되면 가능한 연속이 발견되면 ACW가 즉시 열립니다.</target>
        </trans-unit>
        <trans-unit id="b2041194f9f02b3ffb833c005cb8c357700fb19a" translate="yes" xml:space="preserve">
          <source>The BCJ filters are intended to be applied to machine code. They convert relative branches, calls and jumps in the code to use absolute addressing, with the aim of increasing the redundancy that can be exploited by the compressor. These filters support one option, &lt;code&gt;start_offset&lt;/code&gt;. This specifies the address that should be mapped to the beginning of the input data. The default is 0.</source>
          <target state="translated">BCJ 필터는 기계 코드에 적용됩니다. 이들은 컴프레서가 이용할 수있는 중복성을 높이기 위해 절대 주소 지정을 사용하도록 코드에서 상대 분기, 호출 및 점프를 변환합니다. 이 필터는 &lt;code&gt;start_offset&lt;/code&gt; 옵션을 지원 합니다. 입력 데이터의 시작 부분에 매핑되어야하는 주소를 지정합니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c2e8e2dc67f7620982af31145da08c3a0edd2e25" translate="yes" xml:space="preserve">
          <source>The BSD name for &lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt;&lt;code&gt;RLIMIT_NOFILE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#resource.RLIMIT_NOFILE&quot;&gt; &lt;code&gt;RLIMIT_NOFILE&lt;/code&gt; &lt;/a&gt; 의 BSD 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="8bd75df7a2ed31b671b15ba9f2a6053a27354cf7" translate="yes" xml:space="preserve">
          <source>The C API version for this interpreter. Programmers may find this useful when debugging version conflicts between Python and extension modules.</source>
          <target state="translated">이 인터프리터의 C API 버전입니다. 프로그래머는 Python과 확장 모듈 간의 버전 충돌을 디버깅 할 때이 기능이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e54c0cca00a30bb23c9c25454179867adcaae900" translate="yes" xml:space="preserve">
          <source>The C code was partly rewritten for Python by &lt;em&gt;Christian Heimes&lt;/em&gt;.</source>
          <target state="translated">C 코드는 &lt;em&gt;Christian Heimes에&lt;/em&gt; 의해 부분적으로 파이썬 용으로 다시 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3987a1d7761e1a27305f1fc4189f71d26993d320" translate="yes" xml:space="preserve">
          <source>The C standard defines the locale as a program-wide property that may be relatively expensive to change. On top of that, some implementation are broken in such a way that frequent locale changes may cause core dumps. This makes the locale somewhat painful to use correctly.</source>
          <target state="translated">C 표준은 로캘을 변경하는 데 비교적 비싼 프로그램 전체 속성으로 정의합니다. 또한 로케일을 자주 변경하면 코어 덤프가 발생할 수있는 방식으로 일부 구현이 중단됩니다. 이것은 로케일을 올바르게 사용하기에 다소 고통 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="8d971f33fa3546c84e58c819f6dfcf232e9c699b" translate="yes" xml:space="preserve">
          <source>The CSS class for a weekday occurring in the previous or coming month.</source>
          <target state="translated">이전 달 또는 다음 달에 발생하는 요일의 CSS 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="504a86218f68cab32113c8eb840de3669681f12d" translate="yes" xml:space="preserve">
          <source>The CSS class for the table head for the whole year (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt;&lt;code&gt;formatyear()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;year&quot;&lt;/code&gt;.</source>
          <target state="translated">일년 내내 테이블 헤드의 CSS 클래스 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt; &lt;code&gt;formatyear()&lt;/code&gt; &lt;/a&gt; ). 기본값은 &lt;code&gt;&quot;year&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1ee09fe1f5481a133063a3d6ee9e619dcd1e87e5" translate="yes" xml:space="preserve">
          <source>The CSS class for the whole month&amp;rsquo;s table (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatmonth&quot;&gt;&lt;code&gt;formatmonth()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;month&quot;&lt;/code&gt;.</source>
          <target state="translated">한 달 전체 테이블의 CSS 클래스입니다 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatmonth&quot;&gt; &lt;code&gt;formatmonth()&lt;/code&gt; &lt;/a&gt; ). 기본값은 &lt;code&gt;&quot;month&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="772191c229f3b2e05ab1df0d074ffe18b8d47d83" translate="yes" xml:space="preserve">
          <source>The CSS class for the whole year&amp;rsquo;s table of tables (used by &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt;&lt;code&gt;formatyear()&lt;/code&gt;&lt;/a&gt;). The default value is &lt;code&gt;&quot;year&quot;&lt;/code&gt;.</source>
          <target state="translated">전체 연도 테이블에 대한 CSS 클래스 ( &lt;a href=&quot;#calendar.HTMLCalendar.formatyear&quot;&gt; &lt;code&gt;formatyear()&lt;/code&gt; &lt;/a&gt; 의해 사용됨 ). 기본값은 &lt;code&gt;&quot;year&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7103ea431534ee4b79f98427b6116337e9dc5615" translate="yes" xml:space="preserve">
          <source>The Catalog constructor</source>
          <target state="translated">카탈로그 생성자</target>
        </trans-unit>
        <trans-unit id="96cf03cbb4d0932be4497cf99cf72eade4d3bc41" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 recommendation defines a single exception, &lt;a href=&quot;#xml.dom.DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt;, and a number of constants that allow applications to determine what sort of error occurred. &lt;a href=&quot;#xml.dom.DOMException&quot;&gt;&lt;code&gt;DOMException&lt;/code&gt;&lt;/a&gt; instances carry a &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; attribute that provides the appropriate value for the specific exception.</source>
          <target state="translated">DOM 레벨 2 권장 사항은 단일 예외 인 &lt;a href=&quot;#xml.dom.DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 및 애플리케이션이 어떤 종류의 오류가 발생했는지 판별 할 수있는 여러 상수를 정의합니다 . &lt;a href=&quot;#xml.dom.DOMException&quot;&gt; &lt;code&gt;DOMException&lt;/code&gt; &lt;/a&gt; 인스턴스 에는 특정 예외에 적절한 값을 제공 하는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="947495ed5aa7070a06069dcaba8341b2fcdc9d42" translate="yes" xml:space="preserve">
          <source>The DOM Level 2 recommendation defines one method and one attribute for these objects:</source>
          <target state="translated">DOM 레벨 2 권장 사항은 이러한 오브젝트에 대한 하나의 메소드와 하나의 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b5ba2f5f1b68b0824d76ea1829d1ce34696f29a6" translate="yes" xml:space="preserve">
          <source>The DOM is extremely useful for random-access applications. SAX only allows you a view of one bit of the document at a time. If you are looking at one SAX element, you have no access to another. If you are looking at a text node, you have no access to a containing element. When you write a SAX application, you need to keep track of your program&amp;rsquo;s position in the document somewhere in your own code. SAX does not do it for you. Also, if you need to look ahead in the XML document, you are just out of luck.</source>
          <target state="translated">DOM은 랜덤 액세스 응용 프로그램에 매우 유용합니다. SAX에서는 한 번에 한 비트의 문서 만 볼 수 있습니다. 하나의 SAX 요소를보고 있다면 다른 SAX 요소에 액세스 할 수 없습니다. 텍스트 노드를보고 있으면 포함 요소에 액세스 할 수 없습니다. SAX 응용 프로그램을 작성할 때는 문서에서 프로그램의 위치를 ​​자신의 코드 어딘가에 추적해야합니다. SAX는 당신을 위해 그것을하지 않습니다. 또한 XML 문서를 미리보아야한다면 운이 나쁘다.</target>
        </trans-unit>
        <trans-unit id="6f03607955e97fbc57d05556b36ae065c2787ae3" translate="yes" xml:space="preserve">
          <source>The Document Object Model is being defined by the W3C in stages, or &amp;ldquo;levels&amp;rdquo; in their terminology. The Python mapping of the API is substantially based on the DOM Level 2 recommendation.</source>
          <target state="translated">문서 객체 모델은 W3C에 의해 단계적으로 또는 용어 &quot;수준&quot;으로 정의됩니다. API의 Python 매핑은 실질적으로 DOM Level 2 권장 사항을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="3e5ece1120688047118eff8518636d6814ff5e85" translate="yes" xml:space="preserve">
          <source>The Document Object Model, or &amp;ldquo;DOM,&amp;rdquo; is a cross-language API from the World Wide Web Consortium (W3C) for accessing and modifying XML documents. A DOM implementation presents an XML document as a tree structure, or allows client code to build such a structure from scratch. It then gives access to the structure through a set of objects which provided well-known interfaces.</source>
          <target state="translated">Document Object Model 또는 &quot;DOM&quot;은 XML 문서에 액세스하고 수정하기위한 W3C (World Wide Web Consortium)의 언어 간 API입니다. DOM 구현은 XML 문서를 트리 구조로 나타내거나 클라이언트 코드가 처음부터 이러한 구조를 빌드 할 수 있도록합니다. 그런 다음 잘 알려진 인터페이스를 제공 한 개체 집합을 통해 구조에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce2ab8c2362dbe23653589b17cfaf7def8ffd50" translate="yes" xml:space="preserve">
          <source>The ElementInclude module replaces the &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; element with the root element from the &lt;strong&gt;source.xml&lt;/strong&gt; document. The result might look something like this:</source>
          <target state="translated">ElementInclude 모듈은 &lt;code&gt;{http://www.w3.org/2001/XInclude}include&lt;/code&gt; 요소를 &lt;strong&gt;source.xml&lt;/strong&gt; 문서 의 루트 요소로 바꿉니다 . 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9af5016a363dd95d607deaf0cfed0a4507aba7fa" translate="yes" xml:space="preserve">
          <source>The Ellipsis Object</source>
          <target state="translated">줄임표 개체</target>
        </trans-unit>
        <trans-unit id="f32c4d6597786d2d5b11af91f776181bf1e19cc5" translate="yes" xml:space="preserve">
          <source>The Enum members. This can be a whitespace or comma separated string (values will start at 1 unless otherwise specified):</source>
          <target state="translated">Enum 멤버. 공백 또는 쉼표로 구분 된 문자열 일 수 있습니다 (지정하지 않는 한 값은 1부터 시작 함).</target>
        </trans-unit>
        <trans-unit id="9ea9c857f769b13c24616d563b892a00d4487c4a" translate="yes" xml:space="preserve">
          <source>The Expat XML Parser</source>
          <target state="translated">국외 XML 파서</target>
        </trans-unit>
        <trans-unit id="87d6d8f851f8a21b755e3b2015fc0f3520bceff4" translate="yes" xml:space="preserve">
          <source>The FAQ for the &lt;strong&gt;fetchmail&lt;/strong&gt; POP/IMAP client collects information on POP3 server variations and RFC noncompliance that may be useful if you need to write an application based on the POP protocol.</source>
          <target state="translated">&lt;strong&gt;fetchmail&lt;/strong&gt; POP / IMAP 클라이언트에 대한 FAQ는 POP3 기반 변형 및 RFC 비준수에 대한 정보를 수집하며 이는 POP 프로토콜을 기반으로 애플리케이션을 작성해야하는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b7b076070cfeaac7ce8d6b6005200d5cc7bf13d" translate="yes" xml:space="preserve">
          <source>The FIPS 180-2 publication on Secure Hash Algorithms.</source>
          <target state="translated">Secure Hash 알고리즘에 관한 FIPS 180-2 발행물.</target>
        </trans-unit>
        <trans-unit id="a740e018f19ed6fd64cc21ac3ef422a76d04f855" translate="yes" xml:space="preserve">
          <source>The Future object was designed to mimic &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt;&lt;code&gt;concurrent.futures.Future&lt;/code&gt;&lt;/a&gt;. Key differences include:</source>
          <target state="translated">Future 객체는 &lt;a href=&quot;concurrent.futures#concurrent.futures.Future&quot;&gt; &lt;code&gt;concurrent.futures.Future&lt;/code&gt; &lt;/a&gt; 를 모방하도록 설계되었습니다 . 주요 차이점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f8b73749b9403577a859cf4146436530c3030907" translate="yes" xml:space="preserve">
          <source>The GC classifies objects into three generations depending on how many collection sweeps they have survived. New objects are placed in the youngest generation (generation &lt;code&gt;0&lt;/code&gt;). If an object survives a collection it is moved into the next older generation. Since generation &lt;code&gt;2&lt;/code&gt; is the oldest generation, objects in that generation remain there after a collection. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds &lt;em&gt;threshold0&lt;/em&gt;, collection starts. Initially only generation &lt;code&gt;0&lt;/code&gt; is examined. If generation &lt;code&gt;0&lt;/code&gt; has been examined more than &lt;em&gt;threshold1&lt;/em&gt; times since generation &lt;code&gt;1&lt;/code&gt; has been examined, then generation &lt;code&gt;1&lt;/code&gt; is examined as well. Similarly, &lt;em&gt;threshold2&lt;/em&gt; controls the number of collections of generation &lt;code&gt;1&lt;/code&gt; before collecting generation &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">GC는 얼마나 많은 수집 스위프가 살아남 았는지에 따라 객체를 3 세대로 분류합니다. 가장 어린 세대 ( &lt;code&gt;0&lt;/code&gt; 세대)에 새 개체가 배치됩니다 . 개체가 컬렉션을 유지하면 다음 세대로 이동합니다. &lt;code&gt;2&lt;/code&gt; 세대 가 가장 오래된 세대이므로 해당 세대의 개체는 수집 후에도 남아 있습니다. 실행시기를 결정하기 위해 콜렉터는 마지막 콜렉션 이후의 오브젝트 할당 및 할당 해제 수를 추적합니다. 할당 수에서 할당 취소 수를 뺀 &lt;em&gt;값&lt;/em&gt; 이 &lt;em&gt;threshold0을&lt;/em&gt; 초과하면 수집이 시작됩니다. 처음에는 &lt;code&gt;0&lt;/code&gt; 세대 만 검사합니다. 생성 &lt;code&gt;0&lt;/code&gt; 이 &lt;em&gt;임계 값 1&lt;/em&gt; 이상으로 검사 된 &lt;em&gt;경우&lt;/em&gt; &lt;code&gt;1&lt;/code&gt; 세대 이후로 여러 번 검사 된 다음 &lt;code&gt;1&lt;/code&gt; 세대 도 검사됩니다. 마찬가지로, &lt;em&gt;threshold2&lt;/em&gt; 는 생성 &lt;code&gt;2&lt;/code&gt; 를 수집하기 전에 생성 &lt;code&gt;1&lt;/code&gt; 의 수집 수를 제어합니다 .</target>
        </trans-unit>
        <trans-unit id="d7291b8c8289f762ff278427161e9bf1949a8b43" translate="yes" xml:space="preserve">
          <source>The GC classifies objects into three generations depending on how many collection sweeps they have survived. New objects are placed in the youngest generation (generation &lt;code&gt;0&lt;/code&gt;). If an object survives a collection it is moved into the next older generation. Since generation &lt;code&gt;2&lt;/code&gt; is the oldest generation, objects in that generation remain there after a collection. In order to decide when to run, the collector keeps track of the number object allocations and deallocations since the last collection. When the number of allocations minus the number of deallocations exceeds &lt;em&gt;threshold0&lt;/em&gt;, collection starts. Initially only generation &lt;code&gt;0&lt;/code&gt; is examined. If generation &lt;code&gt;0&lt;/code&gt; has been examined more than &lt;em&gt;threshold1&lt;/em&gt; times since generation &lt;code&gt;1&lt;/code&gt; has been examined, then generation &lt;code&gt;1&lt;/code&gt; is examined as well. With the third generation, things are a bit more complicated, see &lt;a href=&quot;https://devguide.python.org/garbage_collector/#collecting-the-oldest-generation&quot;&gt;Collecting the oldest generation&lt;/a&gt; for more information.</source>
          <target state="translated">GC는 개체가 살아남은 수집 스윕 수에 따라 개체를 3 세대로 분류합니다. 새 개체는 가장 어린 세대 ( &lt;code&gt;0&lt;/code&gt; 세대)에 배치됩니다 . 개체가 컬렉션에서 살아남 으면 다음 이전 세대로 이동합니다. &lt;code&gt;2&lt;/code&gt; 세대 는 가장 오래된 세대이므로 해당 세대의 개체는 수집 후에도 남아 있습니다. 실행시기를 결정하기 위해 수집기는 마지막 수집 이후 개체 할당 및 할당 취소 수를 추적합니다. 할당 수에서 할당 취소 수를 뺀 &lt;em&gt;값&lt;/em&gt; 이 &lt;em&gt;threshold0을&lt;/em&gt; 초과하면 수집이 시작됩니다. 처음에는 &lt;code&gt;0&lt;/code&gt; 세대 만 검사합니다. &lt;code&gt;0&lt;/code&gt; 세대 가 &lt;em&gt;threshold1&lt;/em&gt; 보다 많이 검사 된 &lt;em&gt;경우&lt;/em&gt; &lt;code&gt;1&lt;/code&gt; 세대를 검사 한 이후 &lt;code&gt;1&lt;/code&gt; 세대 도 검사합니다. 3 세대에서는 상황이 좀 더 복잡해집니다 . 자세한 내용 &lt;a href=&quot;https://devguide.python.org/garbage_collector/#collecting-the-oldest-generation&quot;&gt;은 가장 오래된 세대 수집&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="1ae2bdc70c1e8e7581209a0a31a94868a49311af" translate="yes" xml:space="preserve">
          <source>The GNU tar format (&lt;a href=&quot;#tarfile.GNU_FORMAT&quot;&gt;&lt;code&gt;GNU_FORMAT&lt;/code&gt;&lt;/a&gt;). It supports long filenames and linknames, files bigger than 8 GiB and sparse files. It is the de facto standard on GNU/Linux systems. &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; fully supports the GNU tar extensions for long names, sparse file support is read-only.</source>
          <target state="translated">GNU tar 형식 ( &lt;a href=&quot;#tarfile.GNU_FORMAT&quot;&gt; &lt;code&gt;GNU_FORMAT&lt;/code&gt; &lt;/a&gt; ) 긴 파일 이름 및 링크 이름, 8 GiB보다 큰 파일 및 스파 스 파일을 지원합니다. 이것은 GNU / Linux 시스템에서 사실상 표준입니다. &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 은 긴 이름에 대한 GNU tar 확장명을 완전히 지원하며 스파 스 파일 지원은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="112e6111d5aee2deded99838bec29a35f5e5765a" translate="yes" xml:space="preserve">
          <source>The HKEY object implements &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; and thus supports the context protocol for the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">HKEY 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 을 구현하므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 컨텍스트 프로토콜을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="353c9d21e7aafdea603b2defaa25e8d5b51b3663" translate="yes" xml:space="preserve">
          <source>The HKEY object implements &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; and thus supports the context protocol for the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">HKEY 객체는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 를 구현하므로 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 대한 컨텍스트 프로토콜을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c71c33c40ba7395c73110a285fefd5bc28a566e0" translate="yes" xml:space="preserve">
          <source>The HTML rendering, and some liberal editing, was produced from a FrameMaker version by Ken Manheimer.</source>
          <target state="translated">HTML 렌더링 및 일부 자유로운 편집은 Ken Manheimer의 FrameMaker 버전에서 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="895c87c33e6e85565a15be7d071b5d53c67b0b24" translate="yes" xml:space="preserve">
          <source>The HTTP headers used for error responses. This should be a list of WSGI response headers (&lt;code&gt;(name, value)&lt;/code&gt; tuples), as described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt;. The default list just sets the content type to &lt;code&gt;text/plain&lt;/code&gt;.</source>
          <target state="translated">오류 응답에 사용되는 HTTP 헤더입니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;PEP 3333에&lt;/strong&gt;&lt;/a&gt; 설명 된대로 WSGI 응답 헤더 ( &lt;code&gt;(name, value)&lt;/code&gt; 튜플) 의 목록이어야합니다 . 기본 목록은 컨텐츠 유형을 &lt;code&gt;text/plain&lt;/code&gt; 으로 설정합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc84f6a14e073ef0781e89812bc11bcc21df30a7" translate="yes" xml:space="preserve">
          <source>The HTTP request method to use. By default its value is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, which means that &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt;&lt;code&gt;get_method()&lt;/code&gt;&lt;/a&gt; will do its normal computation of the method to be used. Its value can be set (thus overriding the default computation in &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt;&lt;code&gt;get_method()&lt;/code&gt;&lt;/a&gt;) either by providing a default value by setting it at the class level in a &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; subclass, or by passing a value in to the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; constructor via the &lt;em&gt;method&lt;/em&gt; argument.</source>
          <target state="translated">사용할 HTTP 요청 방법. 기본적으로 값은 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이며, &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt; &lt;code&gt;get_method()&lt;/code&gt; &lt;/a&gt; 는 사용될 메소드의 정상적인 계산을 수행합니다. &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 서브 클래스의 클래스 레벨에서 값을 설정 하거나 &lt;em&gt;메소드&lt;/em&gt; 인수 를 통해 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 생성자에 값을 전달하여 기본값을 제공하여 값을 설정할 수 있습니다 (따라서 &lt;a href=&quot;#urllib.request.Request.get_method&quot;&gt; &lt;code&gt;get_method()&lt;/code&gt; &lt;/a&gt; 의 기본 계산을 재정의 함 ) .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="102e26b238faccf8b9327c868bff78cb340168c8" translate="yes" xml:space="preserve">
          <source>The HTTP response headers for the HTTP request that caused the &lt;a href=&quot;#urllib.error.HTTPError&quot;&gt;&lt;code&gt;HTTPError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#urllib.error.HTTPError&quot;&gt; &lt;code&gt;HTTPError&lt;/code&gt; &lt;/a&gt; 를 일으킨 HTTP 요청에 대한 HTTP 응답 헤더입니다 .</target>
        </trans-unit>
        <trans-unit id="875aaefb3d305183b3f017feb60dceacc6899535" translate="yes" xml:space="preserve">
          <source>The HTTP status used for error responses. This should be a status string as defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt;; it defaults to a 500 code and message.</source>
          <target state="translated">오류 응답에 사용 된 HTTP 상태입니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;PEP 3333에&lt;/strong&gt;&lt;/a&gt; 정의 된 상태 문자열이어야합니다 . 기본값은 500 코드 및 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="7ec9df72f5c095b2cb5ecc4f03530853db502b81" translate="yes" xml:space="preserve">
          <source>The I/O mode for the file, either &lt;code&gt;&quot;r&quot;&lt;/code&gt;, &lt;code&gt;&quot;rw&quot;&lt;/code&gt;, or &lt;code&gt;&quot;w&quot;&lt;/code&gt;.</source>
          <target state="translated">는 I / O 파일의 모드 중 하나 &lt;code&gt;&quot;r&quot;&lt;/code&gt; , &lt;code&gt;&quot;rw&quot;&lt;/code&gt; , 또는 &lt;code&gt;&quot;w&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b613d88a17aac3a0fe826d3aec8b07e41aebbb46" translate="yes" xml:space="preserve">
          <source>The ID is a 4-byte string which identifies the type of chunk.</source>
          <target state="translated">ID는 청크 유형을 식별하는 4 바이트 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="221f6efb5eebf643c4c6862eda19d65b5773f066" translate="yes" xml:space="preserve">
          <source>The ID of the integrity check used by the input stream. This may be &lt;code&gt;CHECK_UNKNOWN&lt;/code&gt; until enough of the input has been decoded to determine what integrity check it uses.</source>
          <target state="translated">입력 스트림이 사용하는 무결성 검사의 ID입니다. 사용되는 무결성 검사를 결정하기 위해 충분한 입력이 디코딩 될 때까지 &lt;code&gt;CHECK_UNKNOWN&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d699dfb29e673ac9b34d385b78f0cb6477d087f" translate="yes" xml:space="preserve">
          <source>The IDL definitions do not fully embody the requirements of the W3C DOM API, such as the notion of certain objects, such as the return value of &lt;code&gt;getElementsByTagName()&lt;/code&gt;, being &amp;ldquo;live&amp;rdquo;. The Python DOM API does not require implementations to enforce such requirements.</source>
          <target state="translated">IDL 정의는 &lt;code&gt;getElementsByTagName()&lt;/code&gt; 의 반환 값과 같은 특정 객체의 개념과 같이 W3C DOM API의 요구 사항을 완전히 구현하지 않습니다 . Python DOM API는 이러한 요구 사항을 적용하기 위해 구현이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73534adea22ef371fa587b81eb62e33afe03dae6" translate="yes" xml:space="preserve">
          <source>The IDL types used in the DOM specification are mapped to Python types according to the following table.</source>
          <target state="translated">DOM 사양에 사용 된 IDL 유형은 다음 표에 따라 Python 유형에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="9e8e9b8afe37760ceaad6d8ab19fbe4d24ba22a6" translate="yes" xml:space="preserve">
          <source>The IDLE code running in the execution process adds frames to the call stack that would not be there otherwise. IDLE wraps &lt;code&gt;sys.getrecursionlimit&lt;/code&gt; and &lt;code&gt;sys.setrecursionlimit&lt;/code&gt; to reduce the effect of the additional stack frames.</source>
          <target state="translated">실행 프로세스에서 실행중인 IDLE 코드는 그렇지 않은 프레임을 호출 스택에 추가합니다. IDLE은 &lt;code&gt;sys.getrecursionlimit&lt;/code&gt; 및 &lt;code&gt;sys.setrecursionlimit&lt;/code&gt; 를 래핑 하여 추가 스택 프레임의 영향을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="4f9a8214de2797a406bbc420c4dc6181a8c731c9" translate="yes" xml:space="preserve">
          <source>The IEEE 754 binary16 &amp;ldquo;half precision&amp;rdquo; type was introduced in the 2008 revision of the &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008&quot;&gt;IEEE 754 standard&lt;/a&gt;. It has a sign bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), and can represent numbers between approximately &lt;code&gt;6.1e-05&lt;/code&gt; and &lt;code&gt;6.5e+04&lt;/code&gt; at full precision. This type is not widely supported by C compilers: on a typical machine, an unsigned short can be used for storage, but not for math operations. See the Wikipedia page on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-precision_floating-point_format&quot;&gt;half-precision floating-point format&lt;/a&gt; for more information.</source>
          <target state="translated">IEEE 754 binary16 &quot;반 정밀도&quot;유형은 2008 년 &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_floating_point#IEEE_754-2008&quot;&gt;IEEE 754 표준&lt;/a&gt; 개정판에 도입되었습니다 . 부호 비트, 5 비트 지수 및 11 비트 정밀도 (10 비트가 명시 적으로 저장 됨)를 가지며 전체 정밀도에서 대략 &lt;code&gt;6.1e-05&lt;/code&gt; 와 &lt;code&gt;6.5e+04&lt;/code&gt; 사이의 숫자를 나타낼 수 있습니다 . 이 유형은 C 컴파일러에서 널리 지원되지 않습니다. 일반적인 컴퓨터에서는 부호없는 short를 저장에 사용할 수 있지만 수학 연산에는 사용할 수 없습니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Half-precision_floating-point_format&quot;&gt;반 정밀도 부동 소수점 형식&lt;/a&gt; 의 Wikipedia 페이지 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b24db9631befbb1d797b6887700ff491fc6cb519" translate="yes" xml:space="preserve">
          <source>The IEEE 754 special values of &lt;code&gt;NaN&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, and &lt;code&gt;-inf&lt;/code&gt; will be handled according to IEEE rules. Specifically, &lt;code&gt;NaN&lt;/code&gt; is not considered close to any other value, including &lt;code&gt;NaN&lt;/code&gt;. &lt;code&gt;inf&lt;/code&gt; and &lt;code&gt;-inf&lt;/code&gt; are only considered close to themselves.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 의 IEEE 754 특수 값은 IEEE 규칙에 따라 처리됩니다. 특히 &lt;code&gt;NaN&lt;/code&gt; 은 &lt;code&gt;NaN&lt;/code&gt; 을 포함하여 다른 값에 근접한 것으로 간주되지 않습니다 . &lt;code&gt;inf&lt;/code&gt; 및 &lt;code&gt;-inf&lt;/code&gt; 는 자신과 가까운 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2623b34e7e6ad22abb7cc5f224cc233ff2421da0" translate="yes" xml:space="preserve">
          <source>The ISO calendar is a widely used variant of the Gregorian calendar. &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">ISO 달력은 널리 사용되는 그레고리력 달력입니다. &lt;a href=&quot;#id7&quot; id=&quot;id3&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e5ad6d935091f9e83d009d71f64cd300714d7ea" translate="yes" xml:space="preserve">
          <source>The ISO year consists of 52 or 53 full weeks, and where a week starts on a Monday and ends on a Sunday. The first week of an ISO year is the first (Gregorian) calendar week of a year containing a Thursday. This is called week number 1, and the ISO year of that Thursday is the same as its Gregorian year.</source>
          <target state="translated">ISO 연도는 52 주 또는 53 주로 구성되며주는 월요일에 시작하여 일요일에 끝납니다. ISO 연도의 첫주는 목요일을 포함하는 연도의 첫 번째 (그레고리오)입니다. 이것을 1 주차라고하며 그 목요일의 ISO 연도는 Gregorian 연도와 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f9f1f2433b85fce4cb660f34278dfa1065ffa23" translate="yes" xml:space="preserve">
          <source>The JSON document being parsed.</source>
          <target state="translated">구문 분석중인 JSON 문서</target>
        </trans-unit>
        <trans-unit id="9334515a214a3518850a43c548ab10b96e20d520" translate="yes" xml:space="preserve">
          <source>The JSON file to be validated or pretty-printed:</source>
          <target state="translated">검증되거나 인쇄 될 JSON 파일 :</target>
        </trans-unit>
        <trans-unit id="cb1b5cf7601644b9782c510e837b5298f18e72db" translate="yes" xml:space="preserve">
          <source>The JSON format is specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; and by &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;ECMA-404&lt;/a&gt;. This section details this module&amp;rsquo;s level of compliance with the RFC. For simplicity, &lt;a href=&quot;#json.JSONEncoder&quot;&gt;&lt;code&gt;JSONEncoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#json.JSONDecoder&quot;&gt;&lt;code&gt;JSONDecoder&lt;/code&gt;&lt;/a&gt; subclasses, and parameters other than those explicitly mentioned, are not considered.</source>
          <target state="translated">JSON 형식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7159.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 7159&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;http://www.ecma-international.org/publications/standards/Ecma-404.htm&quot;&gt;ECMA-404에&lt;/a&gt; 의해 지정됩니다 . 이 섹션에서는이 모듈의 RFC 준수 수준에 대해 자세히 설명합니다. 편의상 &lt;a href=&quot;#json.JSONEncoder&quot;&gt; &lt;code&gt;JSONEncoder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#json.JSONDecoder&quot;&gt; &lt;code&gt;JSONDecoder&lt;/code&gt; &lt;/a&gt; 서브 클래스 및 명시 적으로 언급 된 것 이외의 매개 변수는 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="876e1c3c101a9ec9b7e2f177815520f974d7df87" translate="yes" xml:space="preserve">
          <source>The Julian day &lt;em&gt;n&lt;/em&gt; (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). Leap days are not counted, so in all years February 28 is day 59 and March 1 is day 60.</source>
          <target state="translated">율리우스 날 &lt;em&gt;n&lt;/em&gt; (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). 윤일은 계산되지 않으므로 모든 연도 2 월 28 일은 59 일이고 3 월 1 일은 60 일입니다.</target>
        </trans-unit>
        <trans-unit id="e536171d6fc7a17689f9e357f627d94a3ea3655f" translate="yes" xml:space="preserve">
          <source>The LMTP protocol, which is very similar to ESMTP, is heavily based on the standard SMTP client. It&amp;rsquo;s common to use Unix sockets for LMTP, so our &lt;code&gt;connect()&lt;/code&gt; method must support that as well as a regular host:port server. The optional arguments local_hostname and source_address have the same meaning as they do in the &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; class. To specify a Unix socket, you must use an absolute path for &lt;em&gt;host&lt;/em&gt;, starting with a &amp;lsquo;/&amp;rsquo;.</source>
          <target state="translated">ESMTP와 매우 유사한 LMTP 프로토콜은 표준 SMTP 클라이언트를 기반으로합니다. LMTP에 Unix 소켓을 사용하는 것이 일반적이므로 &lt;code&gt;connect()&lt;/code&gt; 메소드는 일반 호스트 : 포트 서버뿐만 아니라이를 지원해야합니다. 선택적 인수 local_hostname 및 source_address는 &lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; &lt;/a&gt; 클래스 에서와 동일한 의미를 갖습니다 . 유닉스 소켓을 지정하려면 '/'로 시작하는 &lt;em&gt;host&lt;/em&gt; 의 절대 경로를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d3fba6ce34a94ace0a97a85e907800f74b784af9" translate="yes" xml:space="preserve">
          <source>The LogRecord has a number of attributes, most of which are derived from the parameters to the constructor. (Note that the names do not always correspond exactly between the LogRecord constructor parameters and the LogRecord attributes.) These attributes can be used to merge data from the record into the format string. The following table lists (in alphabetical order) the attribute names, their meanings and the corresponding placeholder in a %-style format string.</source>
          <target state="translated">LogRecord에는 많은 속성이 있으며 대부분 속성에서 매개 변수에서 생성자로 파생됩니다. 이름이 항상 LogRecord 생성자 매개 변수와 LogRecord 속성간에 정확히 일치하는 것은 아닙니다. 이러한 속성을 사용하여 레코드의 데이터를 형식 문자열로 병합 할 수 있습니다. 다음 표는 속성 이름, 의미 및 해당 자리 표시자를 % 스타일 형식 문자열로 알파벳순으로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="b7fd284826bbd625b7ac5342e8ef0b2f60f602e7" translate="yes" xml:space="preserve">
          <source>The Maildir specification requires the use of a colon (&lt;code&gt;':'&lt;/code&gt;) in certain message file names. However, some operating systems do not permit this character in file names, If you wish to use a Maildir-like format on such an operating system, you should specify another character to use instead. The exclamation point (&lt;code&gt;'!'&lt;/code&gt;) is a popular choice. For example:</source>
          <target state="translated">Maildir 스펙은 특정 메시지 파일 이름에 콜론 ( &lt;code&gt;':'&lt;/code&gt; )을 사용해야 합니다. 그러나 일부 운영 체제에서는 파일 이름으로이 문자를 사용할 수 없습니다. 이러한 운영 체제에서 Maildir과 유사한 형식을 사용하려면 대신 사용할 다른 문자를 지정해야합니다. 느낌표 ( &lt;code&gt;'!'&lt;/code&gt; )가 인기있는 선택입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2ca8704e898feadac45b47aecee721d7345b424d" translate="yes" xml:space="preserve">
          <source>The Mock Class</source>
          <target state="translated">모의 클래스</target>
        </trans-unit>
        <trans-unit id="155fcae67f36b1120104c28ff0aa6a2ca6ef2a6c" translate="yes" xml:space="preserve">
          <source>The Namespace object</source>
          <target state="translated">네임 스페이스 객체</target>
        </trans-unit>
        <trans-unit id="c244a1998ff5b9fbc3c32a89fe8abcf93cbcfce5" translate="yes" xml:space="preserve">
          <source>The Netscape protocol with the bugs fixed. Uses &lt;em&gt;Set-Cookie2&lt;/em&gt; in place of &lt;em&gt;Set-Cookie&lt;/em&gt;. Not widely used.</source>
          <target state="translated">버그가 수정 된 Netscape 프로토콜. &lt;em&gt;Set-Cookie&lt;/em&gt; 대신 &lt;em&gt;Set-Cookie2&lt;/em&gt; 를 사용합니다 . 널리 사용되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e811022cd0aac44894b0fa01dda129f51245480" translate="yes" xml:space="preserve">
          <source>The NotImplemented Object</source>
          <target state="translated">구현되지 않은 객체</target>
        </trans-unit>
        <trans-unit id="2d88e55940ba65789bd478289ba5ef66aaa6476b" translate="yes" xml:space="preserve">
          <source>The Null Object</source>
          <target state="translated">널 객체</target>
        </trans-unit>
        <trans-unit id="d8d19c38b56784ca153a1dfbfff3704006a6f7d7" translate="yes" xml:space="preserve">
          <source>The Numeric Python extension (NumPy) defines another array type; see &lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt; for further information about Numerical Python.</source>
          <target state="translated">Numeric Python 확장 (NumPy)은 다른 배열 유형을 정의합니다. Numerical Python에 대한 자세한 내용 은 &lt;a href=&quot;http://www.numpy.org/&quot;&gt;http://www.numpy.org/&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a9e2cd6058ec976a36128b743cd36be50deb3c81" translate="yes" xml:space="preserve">
          <source>The Numerical Python Documentation</source>
          <target state="translated">숫자 파이썬 문서</target>
        </trans-unit>
        <trans-unit id="29a8f4d932090adf9fba37b9d15fe98be224e869" translate="yes" xml:space="preserve">
          <source>The PEP to add the import hooks that help this module work.</source>
          <target state="translated">이 모듈의 작동에 도움이되는 가져 오기 후크를 추가하는 PEP.</target>
        </trans-unit>
        <trans-unit id="cd4be1c13c5613f15135d4c42fb4d6960f2b081a" translate="yes" xml:space="preserve">
          <source>The POP3 TOP command this method uses, unlike the RETR command, doesn&amp;rsquo;t set the message&amp;rsquo;s seen flag; unfortunately, TOP is poorly specified in the RFCs and is frequently broken in off-brand servers. Test this method by hand against the POP3 servers you will use before trusting it.</source>
          <target state="translated">RETR 명령과 달리이 방법이 사용하는 POP3 TOP 명령은 메시지의 표시 플래그를 설정하지 않습니다. 불행히도 TOP은 RFC에 제대로 지정되지 않았으며 종종 브랜드 외부 서버에서 손상됩니다. 이 방법을 신뢰하기 전에 사용할 POP3 서버에 대해이 방법을 직접 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c8a2773313a96e78dc753d28c768a2fee670d084" translate="yes" xml:space="preserve">
          <source>The POSIX.1-1988 ustar format (&lt;a href=&quot;#tarfile.USTAR_FORMAT&quot;&gt;&lt;code&gt;USTAR_FORMAT&lt;/code&gt;&lt;/a&gt;). It supports filenames up to a length of at best 256 characters and linknames up to 100 characters. The maximum file size is 8 GiB. This is an old and limited but widely supported format.</source>
          <target state="translated">POSIX.1-1988 ustar 형식 ( &lt;a href=&quot;#tarfile.USTAR_FORMAT&quot;&gt; &lt;code&gt;USTAR_FORMAT&lt;/code&gt; &lt;/a&gt; ). 최대 256 자 길이의 파일 이름과 최대 100 자 링크 이름을 지원합니다. 최대 파일 크기는 8 GiB입니다. 이것은 오래되고 제한적이지만 널리 지원되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="3a2b7ddf5592736fae745667d84bd41548545653" translate="yes" xml:space="preserve">
          <source>The POSIX.1-2001 pax format (&lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;). It is the most flexible format with virtually no limits. It supports long filenames and linknames, large files and stores pathnames in a portable way. Modern tar implementations, including GNU tar, bsdtar/libarchive and star, fully support extended &lt;em&gt;pax&lt;/em&gt; features; some old or unmaintained libraries may not, but should treat &lt;em&gt;pax&lt;/em&gt; archives as if they were in the universally-supported &lt;em&gt;ustar&lt;/em&gt; format. It is the current default format for new archives.</source>
          <target state="translated">POSIX.1-2001 pax 형식 ( &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; &lt;/a&gt; ). 사실상 제한이없는 가장 유연한 형식입니다. 긴 파일 이름과 링크 이름, 큰 파일을 지원하며 경로 이름을 이식 가능한 방식으로 저장합니다. GNU tar, bsdtar / libarchive 및 star를 포함한 최신 tar 구현은 확장 된 &lt;em&gt;pax&lt;/em&gt; 기능을 완전히 지원 합니다. 일부 오래된 라이브러리 나 유지 관리되지 않은 라이브러리는 &lt;em&gt;pax&lt;/em&gt; 아카이브를 마치 보편적으로 지원되는 &lt;em&gt;ustar&lt;/em&gt; 형식 인 것처럼 취급해야 합니다. 새 아카이브의 현재 기본 형식입니다.</target>
        </trans-unit>
        <trans-unit id="48f55ddcf8c21fcd18b7aab7a650f356e579978f" translate="yes" xml:space="preserve">
          <source>The Packer</source>
          <target state="translated">패커</target>
        </trans-unit>
        <trans-unit id="4d3cbd26cc18d883fce3423f3e8a2d5ef0540f3d" translate="yes" xml:space="preserve">
          <source>The Parser will call this method to report each chunk of character data. SAX parsers may return all contiguous character data in a single chunk, or they may split it into several chunks; however, all of the characters in any single event must come from the same external entity so that the Locator provides useful information.</source>
          <target state="translated">파서는이 방법을 호출하여 각 문자 데이터 청크를보고합니다. SAX 파서는 연속 된 모든 문자 데이터를 단일 청크로 반환하거나 여러 청크로 분할 할 수 있습니다. 그러나 로케이터가 유용한 정보를 제공 할 수 있도록 단일 이벤트의 모든 문자는 동일한 외부 엔티티에서 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="4ae9d67de63ced48ddf55430725d32dedbe9dfd5" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method once for each entity skipped. Non-validating processors may skip entities if they have not seen the declarations (because, for example, the entity was declared in an external DTD subset). All processors may skip external entities, depending on the values of the &lt;code&gt;feature_external_ges&lt;/code&gt; and the &lt;code&gt;feature_external_pes&lt;/code&gt; properties.</source>
          <target state="translated">파서는 각 엔티티를 건너 뛸 때 마다이 메소드를 한 번 호출합니다. 유효성을 검사하지 않는 프로세서는 선언을 보지 않으면 엔터티를 건너 뛸 수 있습니다 (예 : 엔터티가 외부 DTD 하위 집합에서 선언 되었기 때문에). &lt;code&gt;feature_external_ges&lt;/code&gt; 및 &lt;code&gt;feature_external_pes&lt;/code&gt; 특성 의 값에 따라 모든 프로세서가 외부 엔티티를 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc97f14d1c6ed34640e855f6a0e48fc1a501ede" translate="yes" xml:space="preserve">
          <source>The Parser will invoke this method once for each processing instruction found: note that processing instructions may occur before or after the main document element.</source>
          <target state="translated">파서는 발견 된 각 처리 명령에 대해이 메소드를 한 번 호출합니다. 처리 명령은 기본 문서 요소 전후에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76bb55a33805478d33597a12af8474cc775cdba2" translate="yes" xml:space="preserve">
          <source>The Plural formula is taken from the catalog header. It is a C or Python expression that has a free variable &lt;em&gt;n&lt;/em&gt;; the expression evaluates to the index of the plural in the catalog. See &lt;a href=&quot;https://www.gnu.org/software/gettext/manual/gettext.html&quot;&gt;the GNU gettext documentation&lt;/a&gt; for the precise syntax to be used in &lt;code&gt;.po&lt;/code&gt; files and the formulas for a variety of languages.</source>
          <target state="translated">복수 공식은 카탈로그 헤더에서 가져옵니다. 자유 변수 &lt;em&gt;n&lt;/em&gt; 을 갖는 C 또는 Python 표현식입니다 . 이 표현은 카탈로그에서 복수의 인덱스로 평가됩니다. &lt;code&gt;.po&lt;/code&gt; 파일 에서 사용되는 정확한 구문 과 다양한 언어의 공식에 대해서는 &lt;a href=&quot;https://www.gnu.org/software/gettext/manual/gettext.html&quot;&gt;GNU gettext 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d85809a7ab1199bed21e4d02a17dc8bc8a8d5f44" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module by default issues a &lt;code&gt;BEGIN&lt;/code&gt; statement implicitly before a Data Modification Language (DML) statement (i.e. &lt;code&gt;INSERT&lt;/code&gt;/&lt;code&gt;UPDATE&lt;/code&gt;/&lt;code&gt;DELETE&lt;/code&gt;/&lt;code&gt;REPLACE&lt;/code&gt;).</source>
          <target state="translated">Python &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈은 기본적으로 DML (Data Modification Language) 명령문 앞에 묵시적 으로 &lt;code&gt;BEGIN&lt;/code&gt; 문을 발행합니다 (예 : &lt;code&gt;INSERT&lt;/code&gt; / &lt;code&gt;UPDATE&lt;/code&gt; / &lt;code&gt;DELETE&lt;/code&gt; / &lt;code&gt;REPLACE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f50658b2df65ef37c2e5e3a28feec3af7c6b2de4" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;global interpreter lock&lt;/a&gt; is released before calling any function exported by these libraries, and reacquired afterwards.</source>
          <target state="translated">이 라이브러리에서 내 보낸 함수를 호출하기 전에 Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;전역 인터프리터 잠금&lt;/a&gt; 이 해제되고 나중에 다시 확보됩니다.</target>
        </trans-unit>
        <trans-unit id="aaf00a982b5185fc219976f2e0f2d91ce1140a6d" translate="yes" xml:space="preserve">
          <source>The Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-global-interpreter-lock&quot;&gt;global interpreter lock&lt;/a&gt; is released before calling any function exported by these libraries, and reacquired afterwards.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-global-interpreter-lock&quot;&gt;전역 인터프리터 잠금&lt;/a&gt; 은 이러한 라이브러리에서 내 보낸 함수를 호출하기 전에 해제되고 나중에 다시 획득됩니다.</target>
        </trans-unit>
        <trans-unit id="2e3b3878e6b1514addea56227281a773c6e515ca" translate="yes" xml:space="preserve">
          <source>The Python DOM API, however, &lt;em&gt;does&lt;/em&gt; require that normal attribute access work. This means that the typical surrogates generated by Python IDL compilers are not likely to work, and wrapper objects may be needed on the client if the DOM objects are accessed via CORBA. While this does require some additional consideration for CORBA DOM clients, the implementers with experience using DOM over CORBA from Python do not consider this a problem. Attributes that are declared &lt;code&gt;readonly&lt;/code&gt; may not restrict write access in all DOM implementations.</source>
          <target state="translated">그러나 Python DOM API 에는 일반 속성 액세스 작업 &lt;em&gt;이&lt;/em&gt; 필요합니다. 이것은 파이썬 IDL 컴파일러에 의해 생성 된 일반적인 대리가 작동하지 않을 수 있으며 DOM 객체가 CORBA를 통해 액세스되는 경우 래퍼 객체가 클라이언트에 필요할 수 있음을 의미합니다. 여기에는 CORBA DOM 클라이언트에 대한 추가 고려 사항이 필요하지만 Python에서 CORBA를 통해 DOM을 사용한 경험이있는 구현자는이 문제를 고려하지 않습니다. &lt;code&gt;readonly&lt;/code&gt; 으로 선언 된 속성 은 모든 DOM 구현에서 쓰기 액세스를 제한하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a206098364b484165e8287cb349dce95f61567a5" translate="yes" xml:space="preserve">
          <source>The Python DOM interface provides the constants, but also expands the set of exceptions so that a specific exception exists for each of the exception codes defined by the DOM. The implementations must raise the appropriate specific exception, each of which carries the appropriate value for the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">Python DOM 인터페이스는 상수를 제공하지만 예외 세트를 확장하여 DOM에 의해 정의 된 각 예외 코드에 대해 특정 예외가 존재하도록합니다. 구현시 적절한 특정 예외를 발생시켜야하며 각 예외는 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 속성에 적절한 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ff06059e8081fc663e82b8eee56da2ac2048ebbe" translate="yes" xml:space="preserve">
          <source>The Python Development Mode does not enable the &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module by default, because the overhead cost (to performance and memory) would be too large. Enabling the &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module provides additional information on the origin of some errors. For example, &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; logs the traceback where the resource was allocated, and a buffer overflow error logs the traceback where the memory block was allocated.</source>
          <target state="translated">Python 개발 모드는 기본적으로 &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈을 활성화하지 않습니다. 성능 및 메모리에 대한 오버 헤드 비용이 너무 클 수 있기 때문입니다. &lt;a href=&quot;tracemalloc#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈을 활성화하면 일부 오류의 원인에 대한 추가 정보가 제공됩니다. 예를 들어 &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 은 리소스가 할당 된 트레이스 백을 기록하고 버퍼 오버플로 오류는 메모리 블록이 할당 된 트레이스 백을 기록합니다.</target>
        </trans-unit>
        <trans-unit id="4a4a45dbf7be9619ba4c52ac7c38ca433cb07dd4" translate="yes" xml:space="preserve">
          <source>The Python Development Mode does not prevent the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; command line option from removing &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#assert&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; statements nor from setting &lt;a href=&quot;constants#__debug__&quot;&gt;&lt;code&gt;__debug__&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Python 개발 모드는 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션이 &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#assert&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; 문 을 제거 하거나 &lt;a href=&quot;constants#__debug__&quot;&gt; &lt;code&gt;__debug__&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정 하는 것을 방지하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0eaf9f3b95a141a2cdfebe0564a255b7acfde4d5" translate="yes" xml:space="preserve">
          <source>The Python Development Mode introduces additional runtime checks that are too expensive to be enabled by default. It should not be more verbose than the default if the code is correct; new warnings are only emitted when an issue is detected.</source>
          <target state="translated">Python 개발 모드는 기본적으로 활성화하기에는 너무 많은 추가 런타임 검사를 도입합니다. 코드가 올 바르면 기본값보다 더 자세하지 않아야합니다. 새로운 경고는 문제가 감지 된 경우에만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f5039de57801a391facd6174cbaed212a98ba5e4" translate="yes" xml:space="preserve">
          <source>The Python Development Mode shows a &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; and logs a &amp;ldquo;Bad file descriptor&amp;rdquo; error when finalizing the file object:</source>
          <target state="translated">Python 개발 모드는 &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; 을&lt;/a&gt; 표시 하고 파일 객체를 마무리 할 때 &quot;잘못된 파일 설명자&quot;오류를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="3623e9f5502ae30e63b6ff1528d1650f4f52886f" translate="yes" xml:space="preserve">
          <source>The Python Enhancement Proposal which proposed this addition to Python.</source>
          <target state="translated">파이썬에이 추가 기능을 제안한 Python Enhancement Proposal.</target>
        </trans-unit>
        <trans-unit id="16a4aad38a3322fd0c7f6a1a39fbd8541bd549de" translate="yes" xml:space="preserve">
          <source>The Python Profilers</source>
          <target state="translated">파이썬 프로파일 러</target>
        </trans-unit>
        <trans-unit id="68c54fa443db89d7ca0f9bbdbd9b7297be40a028" translate="yes" xml:space="preserve">
          <source>The Python Testing Tools Taxonomy</source>
          <target state="translated">파이썬 테스트 도구 분류법</target>
        </trans-unit>
        <trans-unit id="a80a8e5314f2596cc8e38aeb9211edeb47d6195d" translate="yes" xml:space="preserve">
          <source>The Python Tkinter Topic Guide provides a great deal of information on using Tk from Python and links to other sources of information on Tk.</source>
          <target state="translated">Python Tkinter 주제 안내서는 Python에서 Tk를 사용하는 방법에 대한 많은 정보를 제공하고 Tk의 다른 정보 소스에 대한 링크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fc0b7656660df44baec5ab40803f65464e6222e3" translate="yes" xml:space="preserve">
          <source>The Python Zip Application Archive Format</source>
          <target state="translated">Python Zip 응용 프로그램 아카이브 형식</target>
        </trans-unit>
        <trans-unit id="24305685b310d869a7c6bf7e92bb45e946c72628" translate="yes" xml:space="preserve">
          <source>The Python byte compiler can be invoked on an ST object to produce code objects which can be used as part of a call to the built-in &lt;a href=&quot;functions#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; functions. This function provides the interface to the compiler, passing the internal parse tree from &lt;em&gt;st&lt;/em&gt; to the parser, using the source file name specified by the &lt;em&gt;filename&lt;/em&gt; parameter. The default value supplied for &lt;em&gt;filename&lt;/em&gt; indicates that the source was an ST object.</source>
          <target state="translated">ST 오브젝트에서 Python 바이트 컴파일러를 호출하여 내장 &lt;a href=&quot;functions#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 함수 호출의 일부로 사용할 수있는 코드 오브젝트를 생성 할 수 있습니다 . 이 함수는 &lt;em&gt;filename&lt;/em&gt; 매개 변수로 지정된 소스 파일 이름을 사용하여 내부 구문 분석 트리를 &lt;em&gt;st&lt;/em&gt; 에서 구문 분석기로 전달하여 컴파일러에 인터페이스를 제공합니다 . &lt;em&gt;filename에&lt;/em&gt; 제공된 기본값 은 소스가 ST 오브젝트임을 나타냅니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9aed821ec2313afc84ef94ac17cfa17e343147d7" translate="yes" xml:space="preserve">
          <source>The Python compiler currently generates the following bytecode instructions.</source>
          <target state="translated">Python 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="84bb1ebb68c17bfe88d2ed5dd2f381d99feff246" translate="yes" xml:space="preserve">
          <source>The Python files which contain certificates can contain a sequence of certificates, sometimes called a &lt;em&gt;certificate chain&lt;/em&gt;. This chain should start with the specific certificate for the principal who &amp;ldquo;is&amp;rdquo; the client or server, and then the certificate for the issuer of that certificate, and then the certificate for the issuer of &lt;em&gt;that&lt;/em&gt; certificate, and so on up the chain till you get to a certificate which is &lt;em&gt;self-signed&lt;/em&gt;, that is, a certificate which has the same subject and issuer, sometimes called a &lt;em&gt;root certificate&lt;/em&gt;. The certificates should just be concatenated together in the certificate file. For example, suppose we had a three certificate chain, from our server certificate to the certificate of the certification authority that signed our server certificate, to the root certificate of the agency which issued the certification authority&amp;rsquo;s certificate:</source>
          <target state="translated">인증서를 포함하는 Python 파일에는 &lt;em&gt;인증서 체인&lt;/em&gt; 이라고하는 일련의 인증서가 포함될 수 있습니다 . 이 체인은 클라이언트 또는 서버 및 해당 인증서 발급자에 대한 인증서, 다음의 발행자에 대한 인증서 &quot;는&quot;원금에 대한 특정 인증서로 시작해야 &lt;em&gt;하는&lt;/em&gt; 인증서 등 당신까지 체인까지 않은 인증서에 도착 &lt;em&gt;자체 서명&lt;/em&gt; 이다, 동일한 주제와 발급자가 인증서, 때로는라는 &lt;em&gt;루트 인증서&lt;/em&gt;. 인증서는 인증서 파일에서 함께 연결되어야합니다. 예를 들어, 서버 인증서에서 서버 인증서에 서명 한 인증 기관의 인증서, 인증 기관의 인증서를 발급 한 기관의 루트 인증서에 이르기까지 3 개의 인증서 체인이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d668df70b1012a771ce85c79c768bca15d3a2ee7" translate="yes" xml:space="preserve">
          <source>The Python installers for the Windows platform usually include the entire standard library and often also include many additional components. For Unix-like operating systems Python is normally provided as a collection of packages, so it may be necessary to use the packaging tools provided with the operating system to obtain some or all of the optional components.</source>
          <target state="translated">Windows 플랫폼 용 Python 설치 프로그램에는 일반적으로 전체 표준 라이브러리가 포함되며 종종 추가 구성 요소가 많이 포함됩니다. 유닉스 계열 운영 체제의 경우 일반적으로 Python은 패키지 모음으로 제공되므로 운영 체제와 함께 제공되는 패키징 도구를 사용하여 선택적 구성 요소의 일부 또는 전부를 구해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39381baeb675becc61bfe651b0384d01c0ecc02" translate="yes" xml:space="preserve">
          <source>The Python interface is a straightforward transliteration of the Unix system call and library interface for sockets to Python&amp;rsquo;s object-oriented style: the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function returns a &lt;em&gt;socket object&lt;/em&gt; whose methods implement the various socket system calls. Parameter types are somewhat higher-level than in the C interface: as with &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; operations on Python files, buffer allocation on receive operations is automatic, and buffer length is implicit on send operations.</source>
          <target state="translated">Python 인터페이스는 Unix 시스템 호출과 소켓의 라이브러리 인터페이스를 Python의 객체 지향 스타일로 간단하게 음역합니다. &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수는 메소드가 다양한 소켓 시스템 호출을 구현 하는 &lt;em&gt;소켓 객체&lt;/em&gt; 를 반환 합니다. 매개 변수 유형은 C 인터페이스보다 다소 높은 수준 입니다. Python 파일의 &lt;code&gt;read()&lt;/code&gt; 및 &lt;code&gt;write()&lt;/code&gt; 작업 과 마찬가지로 수신 작업의 버퍼 할당은 자동이며 전송 작업에는 버퍼 길이가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="a0c4a529f0722167f2c4ba898392f0015bfae784" translate="yes" xml:space="preserve">
          <source>The Python interpreter has a number of functions and types built into it that are always available. They are listed here in alphabetical order.</source>
          <target state="translated">파이썬 인터프리터에는 항상 사용 가능한 많은 함수와 유형이 내장되어 있습니다. 알파벳 순서로 여기에 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="9326ea45f498d239e80ceb0e3060d4907816c0fb" translate="yes" xml:space="preserve">
          <source>The Python module providing secure hash functions.</source>
          <target state="translated">안전한 해시 함수를 제공하는 Python 모듈.</target>
        </trans-unit>
        <trans-unit id="69ec84e4a26a013077dff8474060c5d8050964a0" translate="yes" xml:space="preserve">
          <source>The Python runtime does not enforce &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-annotation&quot;&gt;type annotations&lt;/a&gt;. This extends to generic types and their type parameters. When creating an object from a &lt;code&gt;GenericAlias&lt;/code&gt;, container elements are not checked against their type. For example, the following code is discouraged, but will run without errors:</source>
          <target state="translated">Python 런타임은 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-annotation&quot;&gt;유형 주석을&lt;/a&gt; 적용하지 않습니다 . 이는 제네릭 유형 및 해당 유형 매개 변수로 확장됩니다. &lt;code&gt;GenericAlias&lt;/code&gt; 에서 개체를 만들 때 컨테이너 요소는 해당 유형에 대해 확인되지 않습니다. 예를 들어 다음 코드는 권장되지 않지만 오류없이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5c70b76112bff8f234c081d6c7a3acbb6832303b" translate="yes" xml:space="preserve">
          <source>The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.</source>
          <target state="translated">Python 런타임은 함수 및 변수 유형 주석을 시행하지 않습니다. 유형 검사기, IDE, 린터 등과 같은 타사 도구에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e932146154996d93ed84e9bb70077634ce4a18" translate="yes" xml:space="preserve">
          <source>The Python standard library provides two different implementations of the same profiling interface:</source>
          <target state="translated">Python 표준 라이브러리는 동일한 프로파일 링 인터페이스의 두 가지 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00c57304482cc2aeefdb4600f8e3ef9b77b1caa7" translate="yes" xml:space="preserve">
          <source>The RFC does not explicitly forbid JSON strings which contain byte sequences that don&amp;rsquo;t correspond to valid Unicode characters (e.g. unpaired UTF-16 surrogates), but it does note that they may cause interoperability problems. By default, this module accepts and outputs (when present in the original &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) code points for such sequences.</source>
          <target state="translated">RFC는 유효한 유니 코드 문자 (예 : 짝이없는 UTF-16 서로 게이트)에 해당하지 않는 바이트 시퀀스를 포함하는 JSON 문자열을 명시 적으로 금지하지는 않지만 상호 운용성 문제를 일으킬 수 있습니다. 기본적으로이 모듈은 해당 시퀀스에 대한 코드 포인트 ( 원래 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 에있는 경우)를 받아들이고 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="a21611c1abaea76578ca01231f4e34f3cea77291" translate="yes" xml:space="preserve">
          <source>The RFC does not permit the representation of infinite or NaN number values. Despite that, by default, this module accepts and outputs &lt;code&gt;Infinity&lt;/code&gt;, &lt;code&gt;-Infinity&lt;/code&gt;, and &lt;code&gt;NaN&lt;/code&gt; as if they were valid JSON number literal values:</source>
          <target state="translated">RFC는 무한 또는 NaN 숫자 값의 표현을 허용하지 않습니다. 그럼에도 불구하고 기본적으로이 모듈은 &lt;code&gt;Infinity&lt;/code&gt; , &lt;code&gt;-Infinity&lt;/code&gt; 및 &lt;code&gt;NaN&lt;/code&gt; 을 유효한 JSON 숫자 리터럴 값인 것처럼 받아들이고 출력 합니다.</target>
        </trans-unit>
        <trans-unit id="1d56e81c90cade5d7a8cd14714bd520f16d520a4" translate="yes" xml:space="preserve">
          <source>The RFC prohibits adding a byte order mark (BOM) to the start of a JSON text, and this module&amp;rsquo;s serializer does not add a BOM to its output. The RFC permits, but does not require, JSON deserializers to ignore an initial BOM in their input. This module&amp;rsquo;s deserializer raises a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; when an initial BOM is present.</source>
          <target state="translated">RFC는 JSON 텍스트의 시작에 BOM (byte order mark)을 추가하는 것을 금지하며이 모듈의 직렬 변환기는 출력에 BOM을 추가하지 않습니다. RFC는 JSON 디시리얼라이저가 입력에서 초기 BOM을 무시하도록 허용하지만 필수는 아닙니다. 이 모듈의 디시리얼라이저 는 초기 BOM이있을 때 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="28a0c061baaa6d098aea953c60411ddd94747207" translate="yes" xml:space="preserve">
          <source>The RFC requires that JSON be represented using either UTF-8, UTF-16, or UTF-32, with UTF-8 being the recommended default for maximum interoperability.</source>
          <target state="translated">RFC에서는 JSON이 UTF-8, UTF-16 또는 UTF-32를 사용하여 표현되어야하며 상호 운용성을 최대화하기 위해 UTF-8이 권장되는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="23658f6ac2fddbb213f90b08b1d920e9ec72edc0" translate="yes" xml:space="preserve">
          <source>The RFC specifies that the names within a JSON object should be unique, but does not mandate how repeated names in JSON objects should be handled. By default, this module does not raise an exception; instead, it ignores all but the last name-value pair for a given name:</source>
          <target state="translated">RFC는 JSON 객체 내의 이름이 고유해야한다고 지정하지만 JSON 객체의 반복되는 이름을 처리하는 방법을 요구하지는 않습니다. 기본적으로이 모듈은 예외를 발생시키지 않습니다. 대신, 주어진 이름의 성-값 쌍을 제외한 모든 것을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="ebb53a0bf22d95c16083195b220ed98dcd13adc1" translate="yes" xml:space="preserve">
          <source>The Rmail manual, with some information on Babyl semantics.</source>
          <target state="translated">Babyl 의미에 대한 정보가 포함 된 Rmail 설명서.</target>
        </trans-unit>
        <trans-unit id="1e7b89846a8ae03eb96b19c9bea0cacf3c76d698" translate="yes" xml:space="preserve">
          <source>The SAX API defines four kinds of handlers: content handlers, DTD handlers, error handlers, and entity resolvers. Applications normally only need to implement those interfaces whose events they are interested in; they can implement the interfaces in a single object or in multiple objects. Handler implementations should inherit from the base classes provided in the module &lt;a href=&quot;#module-xml.sax.handler&quot;&gt;&lt;code&gt;xml.sax.handler&lt;/code&gt;&lt;/a&gt;, so that all methods get default implementations.</source>
          <target state="translated">SAX API는 컨텐츠 핸들러, DTD 핸들러, 오류 핸들러 및 엔티티 분석기의 네 가지 핸들러를 정의합니다. 응용 프로그램은 일반적으로 이벤트에 관심이있는 인터페이스 만 구현하면됩니다. 단일 객체 또는 여러 객체에서 인터페이스를 구현할 수 있습니다. 핸들러 구현은 모든 메소드가 기본 구현을 갖도록 모듈 &lt;a href=&quot;#module-xml.sax.handler&quot;&gt; &lt;code&gt;xml.sax.handler&lt;/code&gt; 에&lt;/a&gt; 제공된 기본 클래스에서 상속해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8e45a78d79d0524145dc4edd32e06f22f85cede3" translate="yes" xml:space="preserve">
          <source>The SAX parser will ignore this if there is also a character stream specified, but it will use a byte stream in preference to opening a URI connection itself.</source>
          <target state="translated">문자 스트림도 지정된 경우 SAX 구문 분석기는이를 무시하지만 URI 연결 자체를 여는 것보다 바이트 스트림을 우선적으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="707dc789f59e976c73fe4ffebb33bc0207ccae0c" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, and it will be the last method invoked during the parse. The parser shall not invoke this method until it has either abandoned parsing (because of an unrecoverable error) or reached the end of input.</source>
          <target state="translated">SAX 구문 분석기는이 메소드를 한 번만 호출하며 구문 분석 중에 마지막으로 호출 된 메소드가됩니다. 구문 분석기는 구문 분석을 포기했거나 (복구 할 수없는 오류로 인해) 입력 끝에 도달 할 때까지이 메소드를 호출하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="12f3a1297e14e9b828efc8bdfb73d80a8d01bec8" translate="yes" xml:space="preserve">
          <source>The SAX parser will invoke this method only once, before any other methods in this interface or in DTDHandler (except for &lt;a href=&quot;#xml.sax.handler.ContentHandler.setDocumentLocator&quot;&gt;&lt;code&gt;setDocumentLocator()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">SAX 구문 분석기는이 인터페이스 또는 DTDHandler의 다른 메소드 ( &lt;a href=&quot;#xml.sax.handler.ContentHandler.setDocumentLocator&quot;&gt; &lt;code&gt;setDocumentLocator()&lt;/code&gt; &lt;/a&gt; 제외)에서이 메소드를 한 번만 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7e8e8330c21b74043b8205ded9ff9a5829bf01f2" translate="yes" xml:space="preserve">
          <source>The SKIP flag can also be used for temporarily &amp;ldquo;commenting out&amp;rdquo; examples.</source>
          <target state="translated">SKIP 플래그는 또한 일시적으로 &quot;주석 작성&quot;예제에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4390f432eb2ffe2df3a4d9609866a7b2b82664d" translate="yes" xml:space="preserve">
          <source>The SMTP server refused to accept the message data.</source>
          <target state="translated">SMTP 서버가 메시지 데이터 수락을 거부했습니다.</target>
        </trans-unit>
        <trans-unit id="963f7e97b0fccc8fe8ffa791fe316f759f135cf9" translate="yes" xml:space="preserve">
          <source>The SQLite web page; the documentation describes the syntax and the available data types for the supported SQL dialect.</source>
          <target state="translated">SQLite 웹 페이지; 이 문서는 지원되는 SQL 언어에 대한 구문 및 사용 가능한 데이터 유형에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="beffeb6dadecb40fadf90c17df812ca7ad08d63c" translate="yes" xml:space="preserve">
          <source>The SSL context created above will only allow TLSv1.2 and later (if supported by your system) connections to a server. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; implies certificate validation and hostname checks by default. You have to load certificates into the context.</source>
          <target state="translated">위에서 만든 SSL 컨텍스트는 TLSv1.2 이상 (시스템에서 지원하는 경우) 만 서버에 연결하도록 허용합니다. &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; &lt;/a&gt; 는 기본적으로 인증서 유효성 검사 및 호스트 이름 확인을 의미합니다. 컨텍스트에 인증서를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="a0e2d72a60f11662a8e29849a7b2b192660b7e39" translate="yes" xml:space="preserve">
          <source>The SSL handshake itself will be non-blocking: the &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; method has to be retried until it returns successfully. Here is a synopsis using &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/a&gt; to wait for the socket&amp;rsquo;s readiness:</source>
          <target state="translated">SSL 핸드 셰이크 자체는 차단되지 않습니다. &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 메소드는 성공적으로 리턴 될 때까지 재 시도해야합니다. 다음은 &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 소켓의 준비 상태를 기다리는 개요입니다 .</target>
        </trans-unit>
        <trans-unit id="7fb047f21fae24e28383d98ea942a6e80e264d6c" translate="yes" xml:space="preserve">
          <source>The SSL version to use (defaults to &lt;a href=&quot;ssl#ssl.PROTOCOL_SSLv23&quot;&gt;&lt;code&gt;ssl.PROTOCOL_SSLv23&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">사용할 SSL 버전 (기본값은 &lt;a href=&quot;ssl#ssl.PROTOCOL_SSLv23&quot;&gt; &lt;code&gt;ssl.PROTOCOL_SSLv23&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="4c7e282a13558a44891e2e101c6cf6d12c13e561" translate="yes" xml:space="preserve">
          <source>The ST objects are not required to support the functionality of this module, but are provided for three purposes: to allow an application to amortize the cost of processing complex parse trees, to provide a parse tree representation which conserves memory space when compared to the Python list or tuple representation, and to ease the creation of additional modules in C which manipulate parse trees. A simple &amp;ldquo;wrapper&amp;rdquo; class may be created in Python to hide the use of ST objects.</source>
          <target state="translated">ST 오브젝트는이 모듈의 기능을 지원할 필요는 없지만 세 가지 목적으로 제공됩니다. 애플리케이션이 복잡한 구문 분석 트리 처리 비용을 상각 할 수 있도록하고, 파이썬과 비교할 때 메모리 공간을 절약하는 구문 분석 트리 표현을 제공합니다. 목록 또는 튜플 표현, 구문 분석 트리를 조작하는 C에서 추가 모듈 작성을 용이하게합니다. ST 객체의 사용을 숨기기 위해 간단한 &quot;래퍼&quot;클래스를 파이썬으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c355f4b21e15033d897535af6a95e51399ced7" translate="yes" xml:space="preserve">
          <source>The Shell window also has an output squeezing facility explained in the &lt;em&gt;Python Shell window&lt;/em&gt; subsection below.</source>
          <target state="translated">Shell 창에는 아래 의 &lt;em&gt;Python Shell 창&lt;/em&gt; 하위 섹션에 설명 된 출력 압착 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea690a46ecf07b29fe276979038395655dc2267" translate="yes" xml:space="preserve">
          <source>The Signature object represents the call signature of a callable object and its return annotation. To retrieve a Signature object, use the &lt;a href=&quot;#inspect.signature&quot;&gt;&lt;code&gt;signature()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Signature 객체는 호출 가능한 객체의 호출 서명과 반환 주석을 나타냅니다. Signature 객체를 검색하려면 &lt;a href=&quot;#inspect.signature&quot;&gt; &lt;code&gt;signature()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f14d6f9e95b7ec47f48e2395c9457f82042675cb" translate="yes" xml:space="preserve">
          <source>The Solaris OS has a &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; timer that attempts to use an optimal hardware source, and may give close to nanosecond resolution. &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; is the nonadjustable, high-resolution clock.</source>
          <target state="translated">Solaris OS에는 최적의 하드웨어 소스를 사용하려고 하는 &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; 타이머가 있으며 나노초 해상도에 가깝습니다. &lt;code&gt;CLOCK_HIGHRES&lt;/code&gt; 는 조정 불가능한 고해상도 클록입니다.</target>
        </trans-unit>
        <trans-unit id="cc3eb93ee8c21fc37dd86535f775f5eb431b9c88" translate="yes" xml:space="preserve">
          <source>The Solaris operating system defines its own binary &lt;code&gt;.mo&lt;/code&gt; file format, but since no documentation can be found on this format, it is not supported at this time.</source>
          <target state="translated">Solaris 운영 체제는 자체 바이너리 &lt;code&gt;.mo&lt;/code&gt; 파일 형식을 정의 하지만이 형식에 대한 문서를 찾을 수 없으므로 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0ac37e8315bdb7114c046319dce82f883d628c8" translate="yes" xml:space="preserve">
          <source>The SunOS tar extended format. This format is a variant of the POSIX.1-2001 pax format, but is not compatible.</source>
          <target state="translated">SunOS tar 확장 형식 이 형식은 POSIX.1-2001 pax 형식의 변형이지만 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aae4bcef34361e87d65094c443ec2ddf605108ac" translate="yes" xml:space="preserve">
          <source>The TZ search path can also be configured at runtime using the &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt;&lt;code&gt;reset_tzpath()&lt;/code&gt;&lt;/a&gt; function. This is generally not an advisable operation, though it is reasonable to use it in test functions that require the use of a specific time zone path (or require disabling access to the system time zones).</source>
          <target state="translated">TZ 검색 경로는 &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt; &lt;code&gt;reset_tzpath()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 런타임에 구성 할 수도 있습니다 . 특정 시간대 경로를 사용해야하는 (또는 시스템 시간대에 대한 액세스를 비활성화해야하는) 테스트 기능에서 사용하는 것이 합리적이지만 일반적으로 권장되는 작업은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="4c6064fcd51da76a4b8688cbb79d85ed3cbe6902" translate="yes" xml:space="preserve">
          <source>The Task is &lt;em&gt;cancelled&lt;/em&gt; when the cancellation was requested with &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;cancel()&lt;/code&gt;&lt;/a&gt; and the wrapped coroutine propagated the &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception thrown into it.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;cancel()&lt;/code&gt; &lt;/a&gt; 사용하여 취소가 요청되고 랩핑 된 코 루틴이 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외를 전달하면 작업이 &lt;em&gt;취소&lt;/em&gt; 됩니다 .</target>
        </trans-unit>
        <trans-unit id="c832c625e27d27b2df4a2f2747f5f1ffb11ed665" translate="yes" xml:space="preserve">
          <source>The Time Zone Database (often called tz, tzdata or zoneinfo) contains code and data that represent the history of local time for many representative locations around the globe. It is updated periodically to reflect changes made by political bodies to time zone boundaries, UTC offsets, and daylight-saving rules.</source>
          <target state="translated">표준 시간대 데이터베이스 (종종 tz, tzdata 또는 zoneinfo라고 함)에는 전세계 여러 대표 위치의 현지 시간 기록을 나타내는 코드와 데이터가 포함되어 있습니다. 정치 기관이 시간대 경계, UTC 오프셋 및 일광 절약 규칙에 대한 변경 사항을 반영하도록 정기적으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="90e26b26d9a0af28886fde0a18d530daf10ace98" translate="yes" xml:space="preserve">
          <source>The Tk part of the Tk Widgets implement the final mapping to &amp;hellip;</source>
          <target state="translated">Tk 위젯의 Tk 부분은 다음에 대한 최종 매핑을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a8035c8d4a76baa8e0c5f30604affaf05adf9c98" translate="yes" xml:space="preserve">
          <source>The Tk/Tcl development is largely taking place at ActiveState.</source>
          <target state="translated">Tk / Tcl 개발은 주로 ActiveState에서 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="bb2e0c5b0d8a8fbb506b26541482bf9fad625ee9" translate="yes" xml:space="preserve">
          <source>The Treeview widget generates the following virtual events.</source>
          <target state="translated">Treeview 위젯은 다음과 같은 가상 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="197ec35dbcf1ac2c21896fa47f315993bf446dd5" translate="yes" xml:space="preserve">
          <source>The Treeview widget supports horizontal and vertical scrolling, according to the options described in &lt;a href=&quot;#scrollable-widget-options&quot;&gt;Scrollable Widget Options&lt;/a&gt; and the methods &lt;a href=&quot;#tkinter.ttk.Treeview.xview&quot;&gt;&lt;code&gt;Treeview.xview()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Treeview.yview&quot;&gt;&lt;code&gt;Treeview.yview()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Treeview 위젯은 &lt;a href=&quot;#scrollable-widget-options&quot;&gt;스크롤 가능한 위젯 옵션&lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Treeview.xview&quot;&gt; &lt;code&gt;Treeview.xview()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Treeview.yview&quot;&gt; &lt;code&gt;Treeview.yview()&lt;/code&gt; &lt;/a&gt; 메소드에 설명 된 옵션에 따라 가로 및 세로 스크롤을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c6114ecf3800a7be16c1cceda8f0ef24d4070d2d" translate="yes" xml:space="preserve">
          <source>The URI authority, typically a host, but may also contain a port separated by a colon.</source>
          <target state="translated">URI 권한, 일반적으로 호스트이지만 콜론으로 구분 된 포트를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b94c4c5d2f79c9e8d639c6cdb0ef5a62f7c53c" translate="yes" xml:space="preserve">
          <source>The URI of the XHTML namespace as defined by &lt;a href=&quot;https://www.w3.org/TR/xhtml1/&quot;&gt;XHTML 1.0: The Extensible HyperText Markup Language&lt;/a&gt; (section 3.1.1).</source>
          <target state="translated">&lt;a href=&quot;https://www.w3.org/TR/xhtml1/&quot;&gt;XHTML 1.0 : Extensible HyperText Markup Language&lt;/a&gt; (섹션 3.1.1)에 의해 정의 된 XHTML 네임 스페이스의 URI .</target>
        </trans-unit>
        <trans-unit id="46e2b896a8750fe169be7a5ca65a3f1110bc2ba4" translate="yes" xml:space="preserve">
          <source>The URI or URL that triggered the error.</source>
          <target state="translated">오류를 트리거 한 URI 또는 ​​URL입니다.</target>
        </trans-unit>
        <trans-unit id="675c281e0cb1795bfbcb6b86336646e2a1113c23" translate="yes" xml:space="preserve">
          <source>The URI path. If the &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; uses a proxy, then selector will be the full URL that is passed to the proxy.</source>
          <target state="translated">URI 경로 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 이 프록시를 사용하는 경우 선택기는 프록시로 전달되는 전체 URL이됩니다.</target>
        </trans-unit>
        <trans-unit id="f2c63ee71e5d56e82a263265f0b8cfef06ac654b" translate="yes" xml:space="preserve">
          <source>The URI scheme.</source>
          <target state="translated">URI 체계.</target>
        </trans-unit>
        <trans-unit id="4a032d6b5843fa436cc4c90b072280e903ed7533" translate="yes" xml:space="preserve">
          <source>The URL parsing functions focus on splitting a URL string into its components, or on combining URL components into a URL string.</source>
          <target state="translated">URL 구문 분석 기능은 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다.</target>
        </trans-unit>
        <trans-unit id="0da793b6172e55a10633bab2dfb6db89e488f43e" translate="yes" xml:space="preserve">
          <source>The URL parsing functions were originally designed to operate on character strings only. In practice, it is useful to be able to manipulate properly quoted and encoded URLs as sequences of ASCII bytes. Accordingly, the URL parsing functions in this module all operate on &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; objects in addition to &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">URL 구문 분석 기능은 원래 문자열에서만 작동하도록 설계되었습니다. 실제로 올바르게 인용되고 인코딩 된 URL을 ASCII 바이트 시퀀스로 조작 할 수 있으면 유용합니다. &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 모듈의 URL 구문 분석 기능은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체 외에도 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 바이트 배열 객체에서 모두 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="767746494e5992b19ee4215ca1c553ccc7ef02b6" translate="yes" xml:space="preserve">
          <source>The URL quoting functions focus on taking program data and making it safe for use as URL components by quoting special characters and appropriately encoding non-ASCII text. They also support reversing these operations to recreate the original data from the contents of a URL component if that task isn&amp;rsquo;t already covered by the URL parsing functions above.</source>
          <target state="translated">URL 인용 기능은 특수 문자를 인용하고 비 ASCII 텍스트를 적절하게 인코딩하여 프로그램 데이터를 가져 와서 URL 구성 요소로 안전하게 사용할 수 있도록하는 데 중점을 둡니다. 또한 해당 작업이 위의 URL 구문 분석 기능으로 처리되지 않은 경우 URL 구성 요소의 내용에서 원래 데이터를 다시 작성하기 위해 이러한 작업을 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54066892316ef33a7c80c7cc0ef79d07ebc23fea" translate="yes" xml:space="preserve">
          <source>The UTC timezone, &lt;code&gt;timezone(timedelta(0))&lt;/code&gt;.</source>
          <target state="translated">UTC 시간대, &lt;code&gt;timezone(timedelta(0))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="230fce554aaa73006fcdc744072561d1b035264b" translate="yes" xml:space="preserve">
          <source>The UUID as a 128-bit integer.</source>
          <target state="translated">128 비트 정수인 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="ada1c18a51eb3eac79e65818a624c02eaee85742" translate="yes" xml:space="preserve">
          <source>The UUID as a 16-byte string (containing the six integer fields in big-endian byte order).</source>
          <target state="translated">16 바이트 문자열로 된 UUID (빅 엔디안 바이트 순서로 6 개의 정수 필드 포함).</target>
        </trans-unit>
        <trans-unit id="2381ab9006b77ecac0111ea046ff0cb7e8dfd5d1" translate="yes" xml:space="preserve">
          <source>The UUID as a 16-byte string (with &lt;em&gt;time_low&lt;/em&gt;, &lt;em&gt;time_mid&lt;/em&gt;, and &lt;em&gt;time_hi_version&lt;/em&gt; in little-endian byte order).</source>
          <target state="translated">16 바이트 문자열로 UUID입니다 ( little-endian 바이트 순서 로 &lt;em&gt;time_low&lt;/em&gt; , &lt;em&gt;time_mid&lt;/em&gt; 및 &lt;em&gt;time_hi_version 사용&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c6aa8c5331e6dfe4b2198d9e5600b8c7ebfc894" translate="yes" xml:space="preserve">
          <source>The UUID as a 32-character hexadecimal string.</source>
          <target state="translated">32 자 16 진 문자열 인 UUID입니다.</target>
        </trans-unit>
        <trans-unit id="177533cf244a77a50c952f3fbe78b63c34c13f4c" translate="yes" xml:space="preserve">
          <source>The UUID as a URN as specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4122&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc4122.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 4122에&lt;/strong&gt;&lt;/a&gt; 지정된 URND로서의 UUID .</target>
        </trans-unit>
        <trans-unit id="4ce88db58d1bd2cff41f02584142c4d5b6236bbd" translate="yes" xml:space="preserve">
          <source>The UUID variant, which determines the internal layout of the UUID. This will be one of the constants &lt;a href=&quot;#uuid.RESERVED_NCS&quot;&gt;&lt;code&gt;RESERVED_NCS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#uuid.RFC_4122&quot;&gt;&lt;code&gt;RFC_4122&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#uuid.RESERVED_MICROSOFT&quot;&gt;&lt;code&gt;RESERVED_MICROSOFT&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#uuid.RESERVED_FUTURE&quot;&gt;&lt;code&gt;RESERVED_FUTURE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">UUID 변형은 UUID의 내부 레이아웃을 결정합니다. 이것은 &lt;a href=&quot;#uuid.RESERVED_NCS&quot;&gt; &lt;code&gt;RESERVED_NCS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#uuid.RFC_4122&quot;&gt; &lt;code&gt;RFC_4122&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#uuid.RESERVED_MICROSOFT&quot;&gt; &lt;code&gt;RESERVED_MICROSOFT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uuid.RESERVED_FUTURE&quot;&gt; &lt;code&gt;RESERVED_FUTURE&lt;/code&gt; &lt;/a&gt; 상수 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="c342fe24c4cbcb0d257de674ff4759e57b22adbe" translate="yes" xml:space="preserve">
          <source>The UUID version number (1 through 5, meaningful only when the variant is &lt;a href=&quot;#uuid.RFC_4122&quot;&gt;&lt;code&gt;RFC_4122&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">UUID 버전 번호 (1-5, 변형이 &lt;a href=&quot;#uuid.RFC_4122&quot;&gt; &lt;code&gt;RFC_4122&lt;/code&gt; 인&lt;/a&gt; 경우에만 의미가 있음 )</target>
        </trans-unit>
        <trans-unit id="a51363554bd414c12851cae7faea9edf2a962fd9" translate="yes" xml:space="preserve">
          <source>The UUID was generated by the platform in a multiprocessing-safe way.</source>
          <target state="translated">UUID는 플랫폼에 의해 다중 처리 안전 방식으로 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="47a9a2e59e442cbdb8a457590010b0cf856f5044" translate="yes" xml:space="preserve">
          <source>The UUID was not generated in a multiprocessing-safe way.</source>
          <target state="translated">UUID는 안전한 다중 처리 방식으로 생성되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2a47f74b6e550e89792615dcf5953a8088aa9f2e" translate="yes" xml:space="preserve">
          <source>The Unicode standard defines various normalization forms of a Unicode string, based on the definition of canonical equivalence and compatibility equivalence. In Unicode, several characters can be expressed in various way. For example, the character U+00C7 (LATIN CAPITAL LETTER C WITH CEDILLA) can also be expressed as the sequence U+0043 (LATIN CAPITAL LETTER C) U+0327 (COMBINING CEDILLA).</source>
          <target state="translated">유니 코드 표준은 표준 동등성 및 호환성 동등성 정의를 기반으로 유니 코드 문자열의 다양한 정규화 형식을 정의합니다. 유니 코드에서는 여러 문자를 다양한 방식으로 표현할 수 있습니다. 예를 들어, 문자 U + 00C7 (CEDILLA가있는 라틴 대문자 C)은 시퀀스 U + 0043 (라틴 대문자 C) U + 0327 (복합 CEDILLA)로 표현 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04d63dca6dbfa35a8eb332fbd0e71599ed04307" translate="yes" xml:space="preserve">
          <source>The Unix man page for &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit(2)&lt;/a&gt;&lt;/em&gt; lists the available resources. Note that not all systems use the same symbol or same value to denote the same resource. This module does not attempt to mask platform differences &amp;mdash; symbols not defined for a platform will not be available from this module on that platform.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit (2)&lt;/a&gt;&lt;/em&gt; 의 유닉스 매뉴얼 페이지에 사용 가능한 자원이 나열됩니다. 모든 시스템이 동일한 자원을 나타 내기 위해 동일한 기호 또는 동일한 값을 사용하는 것은 아닙니다. 이 모듈은 플랫폼 차이를 가리려고하지 않습니다. 플랫폼에 대해 정의되지 않은 기호는 해당 플랫폼의이 모듈에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a7c44388893db174e9ea999556cdbef90f21c4a" translate="yes" xml:space="preserve">
          <source>The W3C recommendation for the DOM supported by &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 에서&lt;/a&gt; 지원하는 DOM에 대한 W3C 권장 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="12834e293d8b743cd66ae767c77319fb9cdda8c3" translate="yes" xml:space="preserve">
          <source>The W3C recommendation for the DOM supported by &lt;a href=&quot;xml.dom.minidom#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;xml.dom.minidom#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 에서&lt;/a&gt; 지원하는 DOM에 대한 W3C 권장 사항입니다 .</target>
        </trans-unit>
        <trans-unit id="31da42b88e14c17335b5f3c69d5530c7bbb076fe" translate="yes" xml:space="preserve">
          <source>The W3C recommendation upon which the Python DOM API is based.</source>
          <target state="translated">Python DOM API의 기반이되는 W3C 권장 사항입니다.</target>
        </trans-unit>
        <trans-unit id="7f9e002ad4780ba707a87e87fd969fb608c7c36f" translate="yes" xml:space="preserve">
          <source>The Warnings Filter</source>
          <target state="translated">경고 필터</target>
        </trans-unit>
        <trans-unit id="10331ee2cc67db663d1588e865683c3ef36476ce" translate="yes" xml:space="preserve">
          <source>The Web Server Gateway Interface (WSGI) is a standard interface between web server software and web applications written in Python. Having a standard interface makes it easy to use an application that supports WSGI with a number of different web servers.</source>
          <target state="translated">WSGI (Web Server Gateway Interface)는 웹 서버 소프트웨어와 Python으로 작성된 웹 응용 프로그램 간의 표준 인터페이스입니다. 표준 인터페이스가 있으면 여러 웹 서버에서 WSGI를 지원하는 응용 프로그램을 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae5961df21f86344f6e296a655c0d9ff73bdfd3" translate="yes" xml:space="preserve">
          <source>The Window Manager</source>
          <target state="translated">창 관리자</target>
        </trans-unit>
        <trans-unit id="65c6ce80c74663bba1681b82368d9ef75309faf6" translate="yes" xml:space="preserve">
          <source>The XML format for plist files.</source>
          <target state="translated">plist 파일의 XML 형식입니다.</target>
        </trans-unit>
        <trans-unit id="fc2e75c413853f6e04459cc96ca7e162e334c720" translate="yes" xml:space="preserve">
          <source>The XML handling submodules are:</source>
          <target state="translated">XML 처리 서브 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee22895916a9fd9bfc78eca970b52547580e8558" translate="yes" xml:space="preserve">
          <source>The XML modules are not secure against erroneous or maliciously constructed data. If you need to parse untrusted or unauthenticated data see the &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt; and &lt;a href=&quot;#defused-packages&quot;&gt;The defusedxml and defusedexpat Packages&lt;/a&gt; sections.</source>
          <target state="translated">XML 모듈은 잘못되었거나 악의적으로 구성된 데이터로부터 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML 취약성&lt;/a&gt; 및 &lt;a href=&quot;#defused-packages&quot;&gt;defusedxml 및 defusedexpat 패키지&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f858c2f3f477a724c30f050829c83421c11efe4f" translate="yes" xml:space="preserve">
          <source>The XML modules are not secure against erroneous or maliciously constructed data. If you need to parse untrusted or unauthenticated data see the &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt; and &lt;a href=&quot;#defusedxml-package&quot;&gt;The defusedxml Package&lt;/a&gt; sections.</source>
          <target state="translated">XML 모듈은 오류가 있거나 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;#xml-vulnerabilities&quot;&gt;XML 취약성&lt;/a&gt; 및 &lt;a href=&quot;#defusedxml-package&quot;&gt;defusedxml 패키지&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c0f2cf621a14c2bbdbfa819908f6b587d931318" translate="yes" xml:space="preserve">
          <source>The XML processing modules are not secure against maliciously constructed data. An attacker can abuse XML features to carry out denial of service attacks, access local files, generate network connections to other machines, or circumvent firewalls.</source>
          <target state="translated">XML 처리 모듈은 악의적으로 구성된 데이터로부터 안전하지 않습니다. 공격자는 XML 기능을 악용하여 서비스 거부 공격을 수행하고 로컬 파일에 액세스하며 다른 컴퓨터에 대한 네트워크 연결을 생성하거나 방화벽을 우회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="252486bd245ee68d35a40ade01a5e1d9f61f7038" translate="yes" xml:space="preserve">
          <source>The ZIP file format does not support timestamps before 1980.</source>
          <target state="translated">ZIP 파일 형식은 1980 년 이전의 타임 스탬프를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c63b3aee37e3a038e39805f29c23907870ffa3ea" translate="yes" xml:space="preserve">
          <source>The ZIP file format is a common archive and compression standard. This module provides tools to create, read, write, append, and list a ZIP file. Any advanced use of this module will require an understanding of the format, as defined in &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP Application Note&lt;/a&gt;.</source>
          <target state="translated">ZIP 파일 형식은 일반적인 아카이브 및 압축 표준입니다. 이 모듈은 ZIP 파일을 작성, 읽기, 쓰기, 추가 및 나열하는 도구를 제공합니다. 이 모듈을 고급으로 사용하려면 &lt;a href=&quot;https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT&quot;&gt;PKZIP 애플리케이션 노트에&lt;/a&gt; 정의 된대로 형식을 이해해야합니다. .</target>
        </trans-unit>
        <trans-unit id="442d8cccd431e779c9116f151ef53c174751f57b" translate="yes" xml:space="preserve">
          <source>The ZIP file format specification has included support for bzip2 compression since 2001, and for LZMA compression since 2006. However, some tools (including older Python releases) do not support these compression methods, and may either refuse to process the ZIP file altogether, or fail to extract individual files.</source>
          <target state="translated">ZIP 파일 형식 사양에는 2001 년 이후 bzip2 압축 지원과 2006 년 이후 LZMA 압축 지원이 포함되어 있습니다. 그러나 일부 도구 (이전 Python 릴리스 포함)는 이러한 압축 방법을 지원하지 않으며 ZIP 파일 처리를 완전히 거부하거나 개별 파일을 추출하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="98199ae838f2d5784421f8c9d0b795a0bb8b257d" translate="yes" xml:space="preserve">
          <source>The above &lt;a href=&quot;#module-bisect&quot;&gt;&lt;code&gt;bisect()&lt;/code&gt;&lt;/a&gt; functions are useful for finding insertion points but can be tricky or awkward to use for common searching tasks. The following five functions show how to transform them into the standard lookups for sorted lists:</source>
          <target state="translated">위의 &lt;a href=&quot;#module-bisect&quot;&gt; &lt;code&gt;bisect()&lt;/code&gt; &lt;/a&gt; 함수는 삽입 점을 찾는 데 유용하지만 일반적인 검색 작업에 사용하기 까다 롭거나 어색 할 수 있습니다. 다음 5 가지 함수는 정렬 된 목록에 대한 표준 조회로 변환하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="407e21ba6d5dd1ee8eee311341a7ab707eb91302" translate="yes" xml:space="preserve">
          <source>The above YAML snippet defines three formatters. The first, with id &lt;code&gt;brief&lt;/code&gt;, is a standard &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;logging.Formatter&lt;/code&gt;&lt;/a&gt; instance with the specified format string. The second, with id &lt;code&gt;default&lt;/code&gt;, has a longer format and also defines the time format explicitly, and will result in a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;logging.Formatter&lt;/code&gt;&lt;/a&gt; initialized with those two format strings. Shown in Python source form, the &lt;code&gt;brief&lt;/code&gt; and &lt;code&gt;default&lt;/code&gt; formatters have configuration sub-dictionaries:</source>
          <target state="translated">위의 YAML 스 니펫은 세 가지 포맷터를 정의합니다. 첫 번째 는 &lt;code&gt;brief&lt;/code&gt; 이며 지정된 형식 문자열을 가진 표준 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;logging.Formatter&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. 두 번째는 id &lt;code&gt;default&lt;/code&gt; 이며 더 긴 형식을 가지며 시간 형식을 명시 적으로 정의하며 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;logging.Formatter&lt;/code&gt; &lt;/a&gt; 이 발생 합니다. 두 개의 형식 문자열로 초기화 된 포맷터 입니다. Python 소스 형식으로 표시되는 &lt;code&gt;brief&lt;/code&gt; 및 &lt;code&gt;default&lt;/code&gt; 포맷터에는 구성 하위 사전이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e62cbf4b6548b919e4fdec7b561bc7cfed74c41b" translate="yes" xml:space="preserve">
          <source>The above action would run &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and print profile results like the following:</source>
          <target state="translated">위의 작업은 &lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 실행 하고 다음과 같은 프로파일 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="cb5b571b0f55359c686525ade99c560ac76753ed" translate="yes" xml:space="preserve">
          <source>The above code print a series of &lt;code&gt;0 0&lt;/code&gt; lines, because the array contents is initialized to zeros.</source>
          <target state="translated">위의 코드 는 배열 내용이 0으로 초기화되기 때문에 일련의 &lt;code&gt;0 0&lt;/code&gt; 행을 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="61e4b2d674d629816be9e5499f8d6280a73b0d50" translate="yes" xml:space="preserve">
          <source>The above constants are available on Unix and Windows.</source>
          <target state="translated">위의 상수는 Unix 및 Windows에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f7cdc222bbf8c590edefed4e2c6e102f38a77a0" translate="yes" xml:space="preserve">
          <source>The above constants are extensions and not present if they are not defined by the C library.</source>
          <target state="translated">위 상수는 확장이며 C 라이브러리에 의해 정의되지 않은 경우 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2f9edc72b7c0f0352c1e5c0fd791c1214095743" translate="yes" xml:space="preserve">
          <source>The above constants are only available on Unix.</source>
          <target state="translated">위의 상수는 Unix에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26b1ca703884f216a942e677e3510315043cacee" translate="yes" xml:space="preserve">
          <source>The above constants are only available on Windows.</source>
          <target state="translated">위의 상수는 Windows에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed3f8c425e1cebe6ddfe02fdc52e00207f48926" translate="yes" xml:space="preserve">
          <source>The above example defines a read-only property; you can also define a read-write abstract property by appropriately marking one or more of the underlying methods as abstract:</source>
          <target state="translated">위의 예제는 읽기 전용 속성을 정의합니다. 하나 이상의 기본 메소드를 추상으로 적절하게 표시하여 읽기-쓰기 추상 특성을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="05d7f78147c227eb5aae0acc97674a01a9ebf658" translate="yes" xml:space="preserve">
          <source>The above examples show the most commonly used &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; features which are sufficient to meet many everyday testing needs. The remainder of the documentation explores the full feature set from first principles.</source>
          <target state="translated">위의 예는 가장 일반적으로 사용되는 단위 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 보여줍니다 많은 일상적인 테스트 요구 사항을 충족하기에 충분한 기능을. 이 문서의 나머지 부분에서는 첫 번째 원칙의 모든 기능을 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="bc890161681692d39ad0a02051269ccf8961c8a2" translate="yes" xml:space="preserve">
          <source>The above implicitly extends to text files, since the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function will wrap a buffered object inside a &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;. This includes standard streams and therefore affects the built-in &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function as well.</source>
          <target state="translated">&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수가 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 내부에 버퍼링 된 객체를 래핑하기 때문에 위의 내용은 암시 적으로 텍스트 파일로 확장됩니다 . 여기에는 표준 스트림이 포함되므로 내장 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수에도 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="74957a5b993467a874f6d190c9036f6da0f9c8fd" translate="yes" xml:space="preserve">
          <source>The above implicitly extends to text files, since the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function will wrap a buffered object inside a &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;. This includes standard streams and therefore affects the built-in function &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; as well.</source>
          <target state="translated">&lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수는 버퍼링 된 객체를 &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 안에 래핑하기 때문에 위의 내용은 텍스트 파일로 암시 적으로 확장됩니다 . 여기에는 표준 스트림이 포함되므로 내장 함수 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 에 영향을줍니다. 에도 .</target>
        </trans-unit>
        <trans-unit id="ef1df1ceccbb344550c1134611aa680a6ca57474" translate="yes" xml:space="preserve">
          <source>The above module-level convenience functions, which delegate to the root logger, call &lt;a href=&quot;#logging.basicConfig&quot;&gt;&lt;code&gt;basicConfig()&lt;/code&gt;&lt;/a&gt; to ensure that at least one handler is available. Because of this, they should &lt;em&gt;not&lt;/em&gt; be used in threads, in versions of Python earlier than 2.7.1 and 3.2, unless at least one handler has been added to the root logger &lt;em&gt;before&lt;/em&gt; the threads are started. In earlier versions of Python, due to a thread safety shortcoming in &lt;a href=&quot;#logging.basicConfig&quot;&gt;&lt;code&gt;basicConfig()&lt;/code&gt;&lt;/a&gt;, this can (under rare circumstances) lead to handlers being added multiple times to the root logger, which can in turn lead to multiple messages for the same event.</source>
          <target state="translated">루트 로거에 위임하는 위의 모듈 수준 편의 기능은 &lt;a href=&quot;#logging.basicConfig&quot;&gt; &lt;code&gt;basicConfig()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 하나 이상의 핸들러를 사용할 수 있도록합니다. 이 때문에 스레드가 시작 &lt;em&gt;되기 전에&lt;/em&gt; 적어도 하나의 핸들러가 루트 로거에 추가되지 않은 경우, 2.7.1 및 3.2 이전 버전의 Python에서는 스레드에서 사용 해서는 &lt;em&gt;안됩니다&lt;/em&gt; . 이전 버전의 Python에서는 &lt;a href=&quot;#logging.basicConfig&quot;&gt; &lt;code&gt;basicConfig()&lt;/code&gt; &lt;/a&gt; 의 스레드 안전성 부족으로 인해 드문 경우 이기는 하지만 처리기가 루트 로거에 여러 번 추가되어 동일한 이벤트에 대해 여러 메시지가 발생할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d8d492094673232d29c1078b172cdc265b56e9a" translate="yes" xml:space="preserve">
          <source>The above snippet indicates that logger named &lt;code&gt;foo.bar.baz&lt;/code&gt; should have two handlers attached to it, which are described by the handler ids &lt;code&gt;h1&lt;/code&gt; and &lt;code&gt;h2&lt;/code&gt;. The formatter for &lt;code&gt;h1&lt;/code&gt; is that described by id &lt;code&gt;brief&lt;/code&gt;, and the formatter for &lt;code&gt;h2&lt;/code&gt; is that described by id &lt;code&gt;precise&lt;/code&gt;.</source>
          <target state="translated">위의 스 니펫은 &lt;code&gt;foo.bar.baz&lt;/code&gt; 라는 로거에 두 개의 핸들러가 첨부되어 있어야하며 핸들러 ID에 의해 설명됩니다. &lt;code&gt;h1&lt;/code&gt; 및 &lt;code&gt;h2&lt;/code&gt; 있습니다. 포맷터 &lt;code&gt;h1&lt;/code&gt; ID의 설명이다 &lt;code&gt;brief&lt;/code&gt; 및 포맷터 &lt;code&gt;h2&lt;/code&gt; 그 ID가 기재되어 &lt;code&gt;precise&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="434241b2ca1f428e5d843d599082aaac24ecf848" translate="yes" xml:space="preserve">
          <source>The above three functions provide dialogs that prompt the user to enter a value of the desired type.</source>
          <target state="translated">위의 세 가지 기능은 사용자에게 원하는 유형의 값을 입력하라는 대화 상자를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="03e6b648fca66ed81d2e30bf11726d8cc4ccb34b" translate="yes" xml:space="preserve">
          <source>The above two classes provide native dialog windows for saving and loading files.</source>
          <target state="translated">위의 두 클래스는 파일 저장 및로드를위한 기본 대화 창을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7964aebd001d43335a90b9bdf71dbd85e19014d8" translate="yes" xml:space="preserve">
          <source>The above two functions create an &lt;a href=&quot;#tkinter.filedialog.Open&quot;&gt;&lt;code&gt;Open&lt;/code&gt;&lt;/a&gt; dialog and return the opened file object(s) in read-only mode.</source>
          <target state="translated">위의 두 함수는 &lt;a href=&quot;#tkinter.filedialog.Open&quot;&gt; &lt;code&gt;Open&lt;/code&gt; &lt;/a&gt; 대화 상자를 만들고 읽기 전용 모드에서 열린 파일 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f872c4361e9eb16fb1403436c69ad42e32ef3dec" translate="yes" xml:space="preserve">
          <source>The above two functions create an &lt;a href=&quot;#tkinter.filedialog.Open&quot;&gt;&lt;code&gt;Open&lt;/code&gt;&lt;/a&gt; dialog and return the selected filename(s) that correspond to existing file(s).</source>
          <target state="translated">위의 두 함수는 &lt;a href=&quot;#tkinter.filedialog.Open&quot;&gt; &lt;code&gt;Open&lt;/code&gt; &lt;/a&gt; 대화 상자를 만들고 기존 파일에 해당하는 선택한 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5afdd19ff2762aaad15324735d06fbba48a09f88" translate="yes" xml:space="preserve">
          <source>The above will add a header that looks like this:</source>
          <target state="translated">위는 다음과 같은 헤더를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f25ebcb4ed21c461f51c70e01467241e07cea134" translate="yes" xml:space="preserve">
          <source>The above will execute &lt;code&gt;somefile.py&lt;/code&gt; and generate annotated listings of all Python modules imported during the execution into the current directory.</source>
          <target state="translated">위는 &lt;code&gt;somefile.py&lt;/code&gt; 를 실행 하고 실행 중에 현재 디렉토리로 가져온 모든 Python 모듈의 주석이 달린 목록을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ce5bd96b918301cb95de685eaccadac99a16c5c7" translate="yes" xml:space="preserve">
          <source>The abstract base class defining the interface of finder objects on &lt;a href=&quot;#sys.meta_path&quot;&gt;&lt;code&gt;meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.meta_path&quot;&gt; &lt;code&gt;meta_path&lt;/code&gt; &lt;/a&gt; 에 파인더 객체의 인터페이스를 정의하는 추상 기본 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="cd5f23b2d3c373fb28eef9fa8f1f6d899e6031e2" translate="yes" xml:space="preserve">
          <source>The abstract base class for all I/O classes, acting on streams of bytes. There is no public constructor.</source>
          <target state="translated">바이트 스트림에 작용하는 모든 I / O 클래스의 추상 기본 클래스입니다. 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c659b88cd8236075a43a087f99d1f6f299c2eadd" translate="yes" xml:space="preserve">
          <source>The abstract base classes also provide default implementations of some methods in order to help implementation of concrete stream classes. For example, &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; provides unoptimized implementations of &lt;code&gt;readinto()&lt;/code&gt; and &lt;a href=&quot;#io.IOBase.readline&quot;&gt;&lt;code&gt;readline()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추상 기본 클래스는 또한 구체적인 스트림 클래스의 구현을 돕기 위해 일부 메소드의 기본 구현을 제공합니다. 예를 들어, &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 는 최적화되지 않은 &lt;code&gt;readinto()&lt;/code&gt; 및 &lt;a href=&quot;#io.IOBase.readline&quot;&gt; &lt;code&gt;readline()&lt;/code&gt; &lt;/a&gt; 구현을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="1f9fe10078c0b0af1e6a6803c79431e9d237a736" translate="yes" xml:space="preserve">
          <source>The abstract base classes making up the numeric tower.</source>
          <target state="translated">숫자 탑을 구성하는 추상 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="12970d447a92441a5a1d2b06c8dbb27151950e72" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt;&lt;/a&gt; defines the interface expected of finders by Python&amp;rsquo;s import system. &lt;code&gt;importlib.metadata&lt;/code&gt; extends this protocol by looking for an optional &lt;code&gt;find_distributions&lt;/code&gt; callable on the finders from &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; and presents this extended interface as the &lt;code&gt;DistributionFinder&lt;/code&gt; abstract base class, which defines this abstract method:</source>
          <target state="translated">추상 클래스 &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt; &lt;/a&gt; 는 Python의 가져 오기 시스템에서 파인더에 예상되는 인터페이스를 정의합니다. &lt;code&gt;importlib.metadata&lt;/code&gt; 는 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 의 파인더에서 호출 가능한 선택적 &lt;code&gt;find_distributions&lt;/code&gt; 를 찾아이 프로토콜을 확장하고이 확장 인터페이스를 이 추상 메서드를 정의 하는 &lt;code&gt;DistributionFinder&lt;/code&gt; 추상 기본 클래스로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5433534b54436760d1f4d8f1c5502666c388c4e5" translate="yes" xml:space="preserve">
          <source>The abstract class &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt;&lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt;&lt;/a&gt; defines the interface expected of finders by Python&amp;rsquo;s import system. &lt;code&gt;importlib.metadata&lt;/code&gt; extends this protocol by looking for an optional &lt;code&gt;find_distributions&lt;/code&gt; callable on the finders from &lt;code&gt;sys.meta_path&lt;/code&gt; and presents this extended interface as the &lt;code&gt;DistributionFinder&lt;/code&gt; abstract base class, which defines this abstract method:</source>
          <target state="translated">추상 클래스 &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder&quot;&gt; &lt;code&gt;importlib.abc.MetaPathFinder&lt;/code&gt; &lt;/a&gt; 는 Python의 가져 오기 시스템에서 파인더가 예상하는 인터페이스를 정의합니다. &lt;code&gt;importlib.metadata&lt;/code&gt; 는 선택적 &lt;code&gt;find_distributions&lt;/code&gt; 를 찾아이 프로토콜을 확장합니다. 는 &lt;code&gt;sys.meta_path&lt;/code&gt; 의 파인더에서 호출 확장하고이 확장 된 인터페이스를 &lt;code&gt;DistributionFinder&lt;/code&gt; 추상 기본 클래스로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="997702cd66ff1ee75f7fe9b2315881a481a29682" translate="yes" xml:space="preserve">
          <source>The abstract event loop policy base class is defined as follows:</source>
          <target state="translated">추상 이벤트 루프 정책 기본 클래스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b822e2129fda13f824b88f911238744a0942dfa9" translate="yes" xml:space="preserve">
          <source>The abstract grammar is currently defined as follows:</source>
          <target state="translated">추상 문법은 현재 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="22685ed5927596fd28d7ba1c6153d574f910d052" translate="yes" xml:space="preserve">
          <source>The abstract method returns an iterable of no items.</source>
          <target state="translated">abstract 메소드는 항목이없는 iterable을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2d8da79b65eb77d7ab2dbbc1e796e48b7e1aa054" translate="yes" xml:space="preserve">
          <source>The abstract methods defined by this class are to add optional bytecode file support. Not implementing these optional methods (or causing them to raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;) causes the loader to only work with source code. Implementing the methods allows the loader to work with source &lt;em&gt;and&lt;/em&gt; bytecode files; it does not allow for &lt;em&gt;sourceless&lt;/em&gt; loading where only bytecode is provided. Bytecode files are an optimization to speed up loading by removing the parsing step of Python&amp;rsquo;s compiler, and so no bytecode-specific API is exposed.</source>
          <target state="translated">이 클래스에 의해 정의 된 추상 메소드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이 선택적 메소드를 구현하지 않으면 (또는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 발생) 로더가 소스 코드로만 작동합니다. 메소드를 구현하면 로더가 소스 &lt;em&gt;및&lt;/em&gt; 바이트 코드 파일 로 작업 할 수 있습니다. 그것은 &lt;em&gt;소스리스를&lt;/em&gt; 허용하지 않습니다&lt;em&gt;&lt;/em&gt;바이트 코드 만 제공되는 로드는 . 바이트 코드 파일은 Python 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기위한 최적화이므로 바이트 코드 별 API가 노출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bac918bfaa9fbf1f60536a1f9a285735540a9661" translate="yes" xml:space="preserve">
          <source>The actual messages are inspected to determine which labels exist in the mailbox rather than consulting the list of labels in the Babyl options section, but the Babyl section is updated whenever the mailbox is modified.</source>
          <target state="translated">Babyl 옵션 섹션의 레이블 목록을 참조하지 않고 사서함에 존재하는 레이블을 확인하기 위해 실제 메시지를 검사하지만 사서함을 수정할 때마다 Babyl 섹션이 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ec59d57f13dbc7f6e8f220cf7108a96c7845d01c" translate="yes" xml:space="preserve">
          <source>The actual representation of values is determined by the machine architecture (strictly speaking, by the C implementation). The actual size can be accessed through the &lt;code&gt;itemsize&lt;/code&gt; attribute.</source>
          <target state="translated">실제 값 표현은 머신 아키텍처에 의해 결정됩니다 (엄격히 말하면 C 구현에 의해 결정됨). 실제 크기는 &lt;code&gt;itemsize&lt;/code&gt; 를 통해 액세스 할 수 있습니다 속성을 .</target>
        </trans-unit>
        <trans-unit id="8bbd67fedc62d6744e578e383acd313d41f0348f" translate="yes" xml:space="preserve">
          <source>The add_argument() method</source>
          <target state="translated">add_argument () 메소드</target>
        </trans-unit>
        <trans-unit id="6162253165783060c2db0f1fb8a4141706505e29" translate="yes" xml:space="preserve">
          <source>The addition of new required attributes must go through the normal PEP process. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">새로운 필수 속성을 추가하려면 일반 PEP 프로세스를 거쳐야합니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-15&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9b41a5938a7e2614a804f163135567243094cedf" translate="yes" xml:space="preserve">
          <source>The addition of new required attributes must go through the normal PEP process. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">새로운 필수 속성 추가는 일반 PEP 프로세스를 거쳐야합니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0421&quot; id=&quot;index-16&quot;&gt;&lt;strong&gt;PEP 421&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="55a0169a9941fb11dafda49bd2ffe19ca9ee69cc" translate="yes" xml:space="preserve">
          <source>The address (&lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt;) without network information.</source>
          <target state="translated">네트워크 정보가없는 주소 ( &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="341c8834b822a019f9534dcafa2d84b7b101ecd9" translate="yes" xml:space="preserve">
          <source>The address format required by a particular socket object is automatically selected based on the address family specified when the socket object was created. Socket addresses are represented as follows:</source>
          <target state="translated">특정 소켓 객체에 필요한 주소 형식은 소켓 객체가 생성 될 때 지정된 주소 패밀리를 기반으로 자동 선택됩니다. 소켓 주소는 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4cb6e2569f1a198791a025941f4508602c56ffb5" translate="yes" xml:space="preserve">
          <source>The address from which the last accepted connection came. If this is unavailable then it is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">마지막으로 수락 한 연결이 발생한 주소입니다. 이것이 사용 불가능하면 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9eb11849699377b31e52eceb4abebe16ec4ad447" translate="yes" xml:space="preserve">
          <source>The address of an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket bound to a file system node is represented as a string, using the file system encoding and the &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt;). An address in Linux&amp;rsquo;s abstract namespace is returned as a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; with an initial null byte; note that sockets in this namespace can communicate with normal file system sockets, so programs intended to run on Linux may need to deal with both types of address. A string or bytes-like object can be used for either type of address when passing it as an argument.</source>
          <target state="translated">파일 시스템 노드에 바인드 된 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓 의 주소는 파일 시스템 인코딩 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 핸들러를 사용하여 문자열로 표시됩니다 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; 참조 ). Linux의 추상 네임 스페이스에있는 주소는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 로 반환됩니다. 는 초기 널 바이트를 가진 로 ; 이 네임 스페이스의 소켓은 일반 파일 시스템 소켓과 통신 할 수 있으므로 Linux에서 실행되는 프로그램은 두 가지 유형의 주소를 모두 처리해야합니다. 문자열 또는 바이트와 유사한 객체를 인수로 전달할 때 주소 유형에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d7567a509be70cd97cbefca60944e55dd85a17e" translate="yes" xml:space="preserve">
          <source>The address of an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket bound to a file system node is represented as a string, using the file system encoding and the &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler (see &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt;). An address in Linux&amp;rsquo;s abstract namespace is returned as a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; with an initial null byte; note that sockets in this namespace can communicate with normal file system sockets, so programs intended to run on Linux may need to deal with both types of address. A string or bytes-like object can be used for either type of address when passing it as an argument.</source>
          <target state="translated">파일 시스템 노드에 바인딩 된 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓 의 주소는 파일 시스템 인코딩 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기를 사용하여 문자열로 표시됩니다 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; 참조 ). Linux의 추상 네임 스페이스에있는 주소 는 초기 널 바이트가 있는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 로 반환됩니다 . 이 네임 스페이스의 소켓은 일반 파일 시스템 소켓과 통신 할 수 있으므로 Linux에서 실행하려는 프로그램은 두 유형의 주소를 모두 처리해야 할 수 있습니다. 문자열 또는 바이트와 유사한 객체는 인수로 전달할 때 두 주소 유형에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77c6e2e4aa0afd9f0da731748d6868e43cbbddde" translate="yes" xml:space="preserve">
          <source>The address on which the server is listening. The format of addresses varies depending on the protocol family; see the documentation for the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module for details. For Internet protocols, this is a tuple containing a string giving the address, and an integer port number: &lt;code&gt;('127.0.0.1', 80)&lt;/code&gt;, for example.</source>
          <target state="translated">서버가 청취중인 주소입니다. 주소 형식은 프로토콜 제품군에 따라 다릅니다. 자세한 내용은 &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조 하십시오. 인터넷 프로토콜의 경우, 이는 주소를 제공하는 문자열과 정수 포트 번호 &lt;code&gt;('127.0.0.1', 80)&lt;/code&gt; 포함하는 튜플 입니다.</target>
        </trans-unit>
        <trans-unit id="caadcf5c749441fdfeb412491158e95d616c65f2" translate="yes" xml:space="preserve">
          <source>The address used by the manager.</source>
          <target state="translated">관리자가 사용하는 주소입니다.</target>
        </trans-unit>
        <trans-unit id="48fc7614dc7d8c1c17cef309edaa19277c62a924" translate="yes" xml:space="preserve">
          <source>The address which is being used by the Listener object.</source>
          <target state="translated">리스너 오브젝트가 사용중인 주소입니다.</target>
        </trans-unit>
        <trans-unit id="0a2d1ad99859dd0fa1ab93fa74d153ed148b3f11" translate="yes" xml:space="preserve">
          <source>The advanced API revolves around two container classes, which are used to store the interactive examples extracted from doctest cases:</source>
          <target state="translated">고급 API는 doctest 사례에서 추출한 대화식 예제를 저장하는 데 사용되는 두 개의 컨테이너 클래스를 중심으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="0fc8b7f68557d45d430eb3ca143cc623a95cbbb8" translate="yes" xml:space="preserve">
          <source>The advantage of the &lt;a href=&quot;#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; type over a regular &lt;a href=&quot;#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; is that a &lt;a href=&quot;#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt; and &lt;code&gt;step&lt;/code&gt; values, calculating individual items and subranges as needed).</source>
          <target state="translated">의 장점 &lt;a href=&quot;#range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 일반 위에 타입 &lt;a href=&quot;#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 이다 &lt;a href=&quot;#range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 에만 점포로 객체가 항상 (더가 나타내는 범위의 크기 문제, 동일한 메모리 (소) 시간이 걸릴 것 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; 및 &lt;code&gt;step&lt;/code&gt; 값을 필요에 따라 개별 항목 및 하위 범위를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9d8f4a6fe7a31398136778071ccf8af380a56654" translate="yes" xml:space="preserve">
          <source>The advantage over the standard traceback is that source lines in the compiled template will be displayed. The optional &lt;em&gt;file&lt;/em&gt; argument directs where the traceback is sent; it defaults to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 역 추적에 비해 장점은 컴파일 된 템플릿의 소스 행이 표시된다는 것입니다. 선택적 &lt;em&gt;파일&lt;/em&gt; 인수는 트레이스 백이 전송되는 위치를 지시합니다. 기본값은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="389d9047d4c01bea441e0465f8bdadf31d1765e6" translate="yes" xml:space="preserve">
          <source>The aggregate class must implement a &lt;code&gt;step&lt;/code&gt; method, which accepts the number of parameters &lt;em&gt;num_params&lt;/em&gt; (if &lt;em&gt;num_params&lt;/em&gt; is -1, the function may take any number of arguments), and a &lt;code&gt;finalize&lt;/code&gt; method which will return the final result of the aggregate.</source>
          <target state="translated">집계 클래스는 &lt;em&gt;num_params&lt;/em&gt; 매개 변수의 수 ( &lt;em&gt;num_params&lt;/em&gt; 가 -1 인 경우 함수가 여러 인수 를 사용할 수 있음)를 허용 하는 &lt;code&gt;step&lt;/code&gt; 메소드 와 집계의 최종 결과를 리턴 하는 &lt;code&gt;finalize&lt;/code&gt; 메소드를 구현해야합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c81a91b366c2ca5f6e3514aebee395b76c6e737f" translate="yes" xml:space="preserve">
          <source>The algorithm uses a simple language-independent definition of a word as groups of consecutive letters. The definition works in many contexts but it means that apostrophes in contractions and possessives form word boundaries, which may not be the desired result:</source>
          <target state="translated">이 알고리즘은 단어의 간단한 언어 독립적 정의를 연속 문자 그룹으로 사용합니다. 이 정의는 많은 상황에서 작동하지만 수축과 소유주의 아포스트로피는 단어 경계를 형성하며 이는 원하는 결과가 아닐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea76dcb40c4b9fd7e68dc2ee0f71417668bf322" translate="yes" xml:space="preserve">
          <source>The algorithm&amp;rsquo;s accuracy depends on IEEE-754 arithmetic guarantees and the typical case where the rounding mode is half-even. On some non-Windows builds, the underlying C library uses extended precision addition and may occasionally double-round an intermediate sum causing it to be off in its least significant bit.</source>
          <target state="translated">알고리즘의 정확도는 IEEE-754 산술 보증과 반올림 모드가 반도 인 일반적인 경우에 따라 다릅니다. 일부 비 Windows 빌드에서 기본 C 라이브러리는 확장 된 정밀도 추가를 사용하며 중간 합계를 두 배 반올림하여 최소 중요 비트에서 해제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5606a01152f52f4dc81a70ca0b1f2ca9568376be" translate="yes" xml:space="preserve">
          <source>The alternate form causes a leading &lt;code&gt;'0x'&lt;/code&gt; or &lt;code&gt;'0X'&lt;/code&gt; (depending on whether the &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'X'&lt;/code&gt; format was used) to be inserted before the first digit.</source>
          <target state="translated">대체 형식은 첫 번째 숫자 앞에 선행 &lt;code&gt;'0x'&lt;/code&gt; 또는 &lt;code&gt;'0X'&lt;/code&gt; ( &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'X'&lt;/code&gt; 형식 사용 여부에 따라 다름 )가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="d42a4d8ad1a3383ee5320a3a16eb31b75813d0d6" translate="yes" xml:space="preserve">
          <source>The alternate form causes a leading octal specifier (&lt;code&gt;'0o'&lt;/code&gt;) to be inserted before the first digit.</source>
          <target state="translated">대체 형식은 선행 8 진 지정자 ( &lt;code&gt;'0o'&lt;/code&gt; )가 첫 번째 숫자 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="14d9acf2bea379bd058e7c06b2fff1c83daa4669" translate="yes" xml:space="preserve">
          <source>The alternate form causes the result to always contain a decimal point, and trailing zeroes are not removed as they would otherwise be.</source>
          <target state="translated">대체 형식은 결과에 항상 소수점을 포함하며 후행 0은 다른 방식으로 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a98cf5f39210ac846eda4b14e995b3862902ef83" translate="yes" xml:space="preserve">
          <source>The alternate form causes the result to always contain a decimal point, even if no digits follow it.</source>
          <target state="translated">대체 형식은 뒤에 숫자가 없더라도 결과에 항상 소수점이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2b2e794a1178ef7414daa6fc5f835215e754345d" translate="yes" xml:space="preserve">
          <source>The ancient V7 format. This is the first tar format from Unix Seventh Edition, storing only regular files and directories. Names must not be longer than 100 characters, there is no user/group name information. Some archives have miscalculated header checksums in case of fields with non-ASCII characters.</source>
          <target state="translated">고대 V7 형식. 이것은 일반 파일과 디렉토리 만 저장하는 Unix Seventh Edition의 첫 번째 tar 형식입니다. 이름은 100 자 이하 여야합니다. 사용자 / 그룹 이름 정보는 없습니다. ASCII가 아닌 문자가있는 필드의 경우 일부 아카이브에서 헤더 체크섬이 잘못 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="10c51d8f800517ca58ba2468a6c02fd8a7104b3b" translate="yes" xml:space="preserve">
          <source>The annotation for the parameter. If the parameter has no annotation, this attribute is set to &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt;&lt;code&gt;Parameter.empty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수의 주석입니다. 매개 변수에 주석이없는 경우이 속성은 &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt; &lt;code&gt;Parameter.empty&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="33bada18ff53849b6ee3f7316070d7ee69b27b87" translate="yes" xml:space="preserve">
          <source>The appropriate version number: &lt;code&gt;4&lt;/code&gt; for IPv4, &lt;code&gt;6&lt;/code&gt; for IPv6.</source>
          <target state="translated">적절한 버전 번호 : IPv4의 경우 &lt;code&gt;4&lt;/code&gt; , IPv6의 경우 &lt;code&gt;6&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e8292e76576f5b761b335d8aabbcc591cdfb09e" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;bytes&lt;/em&gt; must either be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an iterable producing bytes.</source>
          <target state="translated">인수 &lt;em&gt;bytes&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 반복 가능한 생성 바이트 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="30287e735ebad313fd7a2d00ad83f7bf645bcee9" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;bytes&lt;/em&gt; must either be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an iterable producing bytes.</source>
          <target state="translated">인수 &lt;em&gt;바이트&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 반복 가능한 생성 바이트 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="d8890dbba084fa181e02072ab15efd96356246f1" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;file&lt;/em&gt; must have three methods, a read() method that takes an integer argument, a readinto() method that takes a buffer argument and a readline() method that requires no arguments, as in the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; interface. Thus &lt;em&gt;file&lt;/em&gt; can be an on-disk file opened for binary reading, an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; object, or any other custom object that meets this interface.</source>
          <target state="translated">인수 &lt;em&gt;파일&lt;/em&gt; 에는 정수 인수를 사용하는 read () 메소드, 버퍼 인수를 사용하는 readinto () 메소드 및 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 인터페이스 에서와 같이 인수가 필요없는 readline () 메소드의 세 가지 메소드가 있어야합니다 . 따라서 &lt;em&gt;파일&lt;/em&gt; 은 이진 읽기, &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 개체 또는이 인터페이스를 충족하는 다른 사용자 지정 개체를 위해 열린 디스크상의 &lt;em&gt;파일 일&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41dee21e7ee0cafe46125a9e6fc36855c2f04d0a" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;optimize&lt;/em&gt; specifies the optimization level of the compiler; the default value of &lt;code&gt;-1&lt;/code&gt; selects the optimization level of the interpreter as given by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; options. Explicit levels are &lt;code&gt;0&lt;/code&gt; (no optimization; &lt;code&gt;__debug__&lt;/code&gt; is true), &lt;code&gt;1&lt;/code&gt; (asserts are removed, &lt;code&gt;__debug__&lt;/code&gt; is false) or &lt;code&gt;2&lt;/code&gt; (docstrings are removed too).</source>
          <target state="translated">&lt;em&gt;optimize&lt;/em&gt; 인수 는 컴파일러의 최적화 수준을 지정합니다. 기본값 &lt;code&gt;-1&lt;/code&gt; 은 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 옵션에 의해 제공된대로 인터프리터의 최적화 레벨을 선택합니다 . 명시 적 레벨은 &lt;code&gt;0&lt;/code&gt; (최적화 없음; &lt;code&gt;__debug__&lt;/code&gt; 이 참), &lt;code&gt;1&lt;/code&gt; (어설 션이 제거됨, &lt;code&gt;__debug__&lt;/code&gt; 가 거짓 임) 또는 &lt;code&gt;2&lt;/code&gt; (docstring도 제거됨)입니다.</target>
        </trans-unit>
        <trans-unit id="c22acf730072d8dbfb0242d9248f26491f463abe" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;optimize&lt;/em&gt; specifies the optimization level of the compiler; the default value of &lt;code&gt;-1&lt;/code&gt; selects the optimization level of the interpreter as given by &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt;&lt;code&gt;-O&lt;/code&gt;&lt;/a&gt; options. Explicit levels are &lt;code&gt;0&lt;/code&gt; (no optimization; &lt;code&gt;__debug__&lt;/code&gt; is true), &lt;code&gt;1&lt;/code&gt; (asserts are removed, &lt;code&gt;__debug__&lt;/code&gt; is false) or &lt;code&gt;2&lt;/code&gt; (docstrings are removed too).</source>
          <target state="translated">&lt;em&gt;optimize&lt;/em&gt; 인수 는 컴파일러의 최적화 수준을 지정합니다. 기본값 &lt;code&gt;-1&lt;/code&gt; 은 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-o&quot;&gt; &lt;code&gt;-O&lt;/code&gt; &lt;/a&gt; 옵션에 의해 제공된 인터프리터의 최적화 레벨을 선택합니다 . 명시 적 수준은 &lt;code&gt;0&lt;/code&gt; (최적화 없음, &lt;code&gt;__debug__&lt;/code&gt; 이 참), &lt;code&gt;1&lt;/code&gt; (어설 션이 제거되고 &lt;code&gt;__debug__&lt;/code&gt; 이 거짓) 또는 &lt;code&gt;2&lt;/code&gt; ( 독 스트링 도 제거됨)입니다.</target>
        </trans-unit>
        <trans-unit id="3deabf3aa9abdc670f9e79ed2b9d15db402ea8d0" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;workers&lt;/em&gt; specifies how many workers are used to compile files in parallel. The default is to not use multiple workers. If the platform can&amp;rsquo;t use multiple workers and &lt;em&gt;workers&lt;/em&gt; argument is given, then sequential compilation will be used as a fallback. If &lt;em&gt;workers&lt;/em&gt; is 0, the number of cores in the system is used. If &lt;em&gt;workers&lt;/em&gt; is lower than &lt;code&gt;0&lt;/code&gt;, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="translated">&lt;em&gt;worker&lt;/em&gt; 인수 는 파일을 병렬로 컴파일하는 데 사용되는 &lt;em&gt;작업자 수를&lt;/em&gt; 지정합니다. 기본값은 여러 작업자를 사용하지 않는 것입니다. 플랫폼이 여러 워커를 사용할 수없고 &lt;em&gt;워커&lt;/em&gt; 인수가 제공되면 순차 컴파일이 폴백으로 사용됩니다. 경우 &lt;em&gt;근로자는&lt;/em&gt; 0, 시스템의 코어 수를 사용한다. 경우 &lt;em&gt;근로자&lt;/em&gt; 보다 낮은 &lt;code&gt;0&lt;/code&gt; 하는 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="be43a16008bbf7f5842dd3fda9c5c730dc968fa1" translate="yes" xml:space="preserve">
          <source>The argument is either an exception object or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;. The latter means a regular EOF is received, or the connection was aborted or closed by this side of the connection.</source>
          <target state="translated">인수는 예외 객체이거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 입니다. 후자는 일반적인 EOF가 수신되었거나 연결의이 쪽에서 연결이 중단 또는 종료되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6a211995914e53c0ffa8f7f501f1d50e2819dbbf" translate="yes" xml:space="preserve">
          <source>The arguments &lt;em&gt;server_side&lt;/em&gt;, &lt;em&gt;do_handshake_on_connect&lt;/em&gt;, and &lt;em&gt;suppress_ragged_eofs&lt;/em&gt; have the same meaning as &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;server_side&lt;/em&gt; , &lt;em&gt;do_handshake_on_connect&lt;/em&gt; 및 &lt;em&gt;suppress_ragged_eofs&lt;/em&gt; 인수 는 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="9c66f3eebc3d176e9c1b552e8a8c2895de8a2a96" translate="yes" xml:space="preserve">
          <source>The arguments are a string and optional globals and locals. If provided, &lt;em&gt;globals&lt;/em&gt; must be a dictionary. If provided, &lt;em&gt;locals&lt;/em&gt; can be any mapping object.</source>
          <target state="translated">인수는 문자열이며 선택적 전역 및 지역입니다. 제공되는 경우 &lt;em&gt;전역&lt;/em&gt; 은 사전이어야합니다. 제공되는 경우 &lt;em&gt;로컬&lt;/em&gt; 은 모든 매핑 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c69cfb296a29db62964592dbb716832142521412" translate="yes" xml:space="preserve">
          <source>The arguments are an object and a string. The result is &lt;code&gt;True&lt;/code&gt; if the string is the name of one of the object&amp;rsquo;s attributes, &lt;code&gt;False&lt;/code&gt; if not. (This is implemented by calling &lt;code&gt;getattr(object, name)&lt;/code&gt; and seeing whether it raises an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; or not.)</source>
          <target state="translated">인수는 객체와 문자열입니다. 문자열이 객체 속성 중 하나의 이름이면 결과는 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다. ( &lt;code&gt;getattr(object, name)&lt;/code&gt; 을 호출 하여 &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 가 발생하는지 여부를 확인하여 구현됩니다 .)</target>
        </trans-unit>
        <trans-unit id="be56149bda6c7546999f067085edf5b3a937c31c" translate="yes" xml:space="preserve">
          <source>The arguments are the components that make up a class definition header: the class name, the base classes (in order) and the keyword arguments (such as &lt;code&gt;metaclass&lt;/code&gt;).</source>
          <target state="translated">인수는 클래스 정의 헤더를 구성하는 구성 요소입니다 (클래스 이름, 기본 클래스 (순서대로) 및 키워드 인수 (예 : &lt;code&gt;metaclass&lt;/code&gt; )).</target>
        </trans-unit>
        <trans-unit id="cf499ded5fc70830e3d43eddf2d6cc8d63297fa7" translate="yes" xml:space="preserve">
          <source>The arguments for a function.</source>
          <target state="translated">함수에 대한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="e7c93246599d96c035a94a1928bc7c60c28e3fdf" translate="yes" xml:space="preserve">
          <source>The arguments for the logging message.</source>
          <target state="translated">로깅 메시지의 인수</target>
        </trans-unit>
        <trans-unit id="fa6396e70f630f892434a48120296055f84dd5e2" translate="yes" xml:space="preserve">
          <source>The arguments for this method are the same as those for the &lt;a href=&quot;#difflib.HtmlDiff.make_file&quot;&gt;&lt;code&gt;make_file()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 메소드의 인수는 &lt;a href=&quot;#difflib.HtmlDiff.make_file&quot;&gt; &lt;code&gt;make_file()&lt;/code&gt; &lt;/a&gt; 메소드 의 인수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="fed5e86f10a7fbd166030f1e196e3f269c1fcfc8" translate="yes" xml:space="preserve">
          <source>The arguments must be types and there must be at least one.</source>
          <target state="translated">인수는 유형이어야하고 하나 이상 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f69c3cdc02ca8f80c2baba13a605a2fbc228eaa5" translate="yes" xml:space="preserve">
          <source>The arguments must have numeric types. With mixed operand types, the coercion rules for binary arithmetic operators apply. For &lt;a href=&quot;#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; operands, the result has the same type as the operands (after coercion) unless the second argument is negative; in that case, all arguments are converted to float and a float result is delivered. For example, &lt;code&gt;10**2&lt;/code&gt; returns &lt;code&gt;100&lt;/code&gt;, but &lt;code&gt;10**-2&lt;/code&gt; returns &lt;code&gt;0.01&lt;/code&gt;.</source>
          <target state="translated">인수는 숫자 유형이어야합니다. 피연산자 유형이 혼합 된 경우 이진 산술 연산자에 대한 강제 규칙이 적용됩니다. 들면 &lt;a href=&quot;#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 피연산자 결과 (강제 한 후) 피연산자 번째 인자가 음수가 아니면 같은 형태를 가진다; 이 경우 모든 인수가 float로 변환되고 float 결과가 전달됩니다. 예를 들어, &lt;code&gt;10**2&lt;/code&gt; 는 &lt;code&gt;100&lt;/code&gt; 을 반환 하지만 &lt;code&gt;10**-2&lt;/code&gt; 는 &lt;code&gt;0.01&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="ae91bd9ff1ecbb16b6d067052bf6873482f52192" translate="yes" xml:space="preserve">
          <source>The arguments provided (if any) can be used to limit the list down to the significant entries. Initially, the list is taken to be the complete set of profiled functions. Each restriction is either an integer (to select a count of lines), or a decimal fraction between 0.0 and 1.0 inclusive (to select a percentage of lines), or a string that will interpreted as a regular expression (to pattern match the standard name that is printed). If several restrictions are provided, then they are applied sequentially. For example:</source>
          <target state="translated">제공된 인수 (있는 경우)를 사용하여 목록을 중요한 항목으로 제한 할 수 있습니다. 처음에는 목록이 전체 프로파일 링 된 기능 세트로 간주됩니다. 각 제한은 정수 (줄 수 선택) 또는 0.0에서 1.0 사이의 소수 (줄 백분율 선택) 또는 정규식으로 해석되는 문자열 (표준 이름과 패턴 일치)입니다. 인쇄됩니다). 여러 제한 사항이 제공되면 순차적으로 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87f25b82b9642ea89296265907e6ccc346f4cbea" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely some common ones. The full function signature is largely the same as that of &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; - most arguments are passed directly through to that interface. However, explicitly passing &lt;code&gt;input=None&lt;/code&gt; to inherit the parent&amp;rsquo;s standard input file handle is not supported.</source>
          <target state="translated">위에 표시된 주장은 단지 몇 가지 일반적인 주장입니다. 전체 함수 시그니처는 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의 시그니처와 거의 동일합니다. 대부분의 인수는 해당 인터페이스로 직접 전달됩니다. 그러나 명시 적으로 전달 &lt;code&gt;input=None&lt;/code&gt; 부모의 표준 입력 파일 핸들을 상속하기 위해 input = None 을 것은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2043e37b5d3a7c056dc2f3ac3ded2b83680185c6" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely some common ones. The full function signature is the same as that of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor - this function passes all supplied arguments other than &lt;em&gt;timeout&lt;/em&gt; directly through to that interface.</source>
          <target state="translated">위에 표시된 주장은 단지 몇 가지 일반적인 주장입니다. 전체 기능 서명은 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 의 서명과 동일합니다 생성자 이 함수는 &lt;em&gt;제한 시간&lt;/em&gt; 이외의 모든 제공된 인수 를 해당 인터페이스로 직접 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f78dbd2fcda8d7db784dd89d094ca5c7188a12e9" translate="yes" xml:space="preserve">
          <source>The arguments shown above are merely the most common ones, described below in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; (hence the use of keyword-only notation in the abbreviated signature). The full function signature is largely the same as that of the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor - most of the arguments to this function are passed through to that interface. (&lt;em&gt;timeout&lt;/em&gt;, &lt;em&gt;input&lt;/em&gt;, &lt;em&gt;check&lt;/em&gt;, and &lt;em&gt;capture_output&lt;/em&gt; are not.)</source>
          <target state="translated">위에 표시된 인수는 아래에서 &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용되는 인수&lt;/a&gt; (따라서 약식 서명에 키워드 전용 표기법 사용)에 설명 된 가장 일반적인 인수 입니다. 전체 함수 시그니처는 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 생성자 의 시그니처와 거의 동일 합니다.이 함수에 대한 대부분의 인수는 해당 인터페이스로 전달됩니다. ( &lt;em&gt;타임 아웃&lt;/em&gt; , &lt;em&gt;입력&lt;/em&gt; , &lt;em&gt;확인&lt;/em&gt; 및&lt;em&gt; capture_output&lt;/em&gt; 이 아닙니다.)</target>
        </trans-unit>
        <trans-unit id="a8d3dbfa6a2a64fda3f1f33232ef56b7a73086d5" translate="yes" xml:space="preserve">
          <source>The arguments to the range constructor must be integers (either built-in &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; or any object that implements the &lt;code&gt;__index__&lt;/code&gt; special method). If the &lt;em&gt;step&lt;/em&gt; argument is omitted, it defaults to &lt;code&gt;1&lt;/code&gt;. If the &lt;em&gt;start&lt;/em&gt; argument is omitted, it defaults to &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;step&lt;/em&gt; is zero, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">범위 생성자에 대한 인수는 정수 여야합니다 (내장 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;__index__&lt;/code&gt; 특수 메소드 를 구현하는 오브젝트 ). 는 IF &lt;em&gt;단계&lt;/em&gt; 인수에 기본값을 생략 &lt;code&gt;1&lt;/code&gt; . 는 IF &lt;em&gt;시작&lt;/em&gt; 인수에 기본값을 생략 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;em&gt;단계는&lt;/em&gt; 제로의 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="392a22c741f2ff789b1aa5cfae6c8530e0bcedb5" translate="yes" xml:space="preserve">
          <source>The arguments used to launch the process. This may be a list or a string.</source>
          <target state="translated">프로세스를 시작하는 데 사용되는 인수 이것은 목록 또는 문자열 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eaf471383801c20f082c922e184753ba6eeb675" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the data divided by the number of data points. It is commonly called &amp;ldquo;the average&amp;rdquo;, although it is only one of many different mathematical averages. It is a measure of the central location of the data.</source>
          <target state="translated">산술 평균은 데이터의 합을 데이터 포인트 수로 나눈 값입니다. 많은 수학적 평균 중 하나 일 뿐이지 만 일반적으로 &quot;평균&quot;이라고합니다. 데이터의 중앙 위치를 측정 한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a4efce9426389d16ea55fb24f2a2130bb207613" translate="yes" xml:space="preserve">
          <source>The assert passes if the mock has &lt;em&gt;ever&lt;/em&gt; been called, unlike &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt; that only pass if the call is the most recent one, and in the case of &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt; it must also be the only call.</source>
          <target state="translated">모의를 한 경우 어설 통과 &lt;em&gt;이제까지&lt;/em&gt; 와는 달리 호출 된 &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; 만 호출이 가장 최근 인 경우 통과, 그리고 경우에 있음을&lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; 그것은 또한 유일한 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="55baf18423476bc2f5cb22bc735bf84833a2ded6" translate="yes" xml:space="preserve">
          <source>The associated child window will be displayed, and the previously-selected window (if different) is unmapped. If &lt;em&gt;tab_id&lt;/em&gt; is omitted, returns the widget name of the currently selected pane.</source>
          <target state="translated">연결된 자식 창이 표시되고 이전에 선택한 창이 다른 경우 매핑이 해제됩니다. 만약&lt;em&gt; tab_id가&lt;/em&gt; 생략, 현재 선택 창 위젯의 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ebc6759ec468be9cd5ca8641b23467e5c0dcc16" translate="yes" xml:space="preserve">
          <source>The asynchronous execution can be performed with threads, using &lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt;, or separate processes, using &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt;. Both implement the same interface, which is defined by the abstract &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;ThreadPoolExecutor&lt;/code&gt; 를&lt;/a&gt; 사용하는 스레드 또는 &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 를&lt;/a&gt; 사용하는 별도의 프로세스를 사용하여 비동기 실행을 수행 할 수 있습니다 . 둘 다 추상으로 정의 된 동일한 인터페이스를 구현합니다.&lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 클래스에.</target>
        </trans-unit>
        <trans-unit id="3ccad3e454a2b6bbe8bd6d9030a1c9f1ee44f789" translate="yes" xml:space="preserve">
          <source>The asynchronous input buffer size (default &lt;code&gt;4096&lt;/code&gt;).</source>
          <target state="translated">비동기 입력 버퍼 크기 (기본값 &lt;code&gt;4096&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="648cf457811b8fb2322a6e0f67989021d19d68db" translate="yes" xml:space="preserve">
          <source>The asynchronous output buffer size (default &lt;code&gt;4096&lt;/code&gt;).</source>
          <target state="translated">비동기 출력 버퍼 크기 (기본값 &lt;code&gt;4096&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1b3cd46b2d23224528d0f92919781b3cb4fb638a" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;httponly&lt;/code&gt; specifies that the cookie is only transferred in HTTP requests, and is not accessible through JavaScript. This is intended to mitigate some forms of cross-site scripting.</source>
          <target state="translated">&lt;code&gt;httponly&lt;/code&gt; 속성 은 쿠키가 HTTP 요청에서만 전송되고 JavaScript를 통해 액세스 할 수 지정합니다. 이는 일부 형태의 크로스 사이트 스크립팅을 완화하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="8edf79b23d57e5bcd86427cee16457915983e577" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;samesite&lt;/code&gt; specifies that the browser is not allowed to send the cookie along with cross-site requests. This helps to mitigate CSRF attacks. Valid values for this attribute are &amp;ldquo;Strict&amp;rdquo; and &amp;ldquo;Lax&amp;rdquo;.</source>
          <target state="translated">&lt;code&gt;samesite&lt;/code&gt; 속성 은 브라우저가 사이트 간 요청과 함께 쿠키를 보낼 수 지정합니다. 이것은 CSRF 공격을 완화하는 데 도움이됩니다. 이 속성의 유효한 값은&amp;ldquo;Strict&amp;rdquo;및&amp;ldquo;Lax&amp;rdquo;입니다.</target>
        </trans-unit>
        <trans-unit id="f6ce7ef8307bed2a756ba73ac5ba362e481ae023" translate="yes" xml:space="preserve">
          <source>The attribute &lt;code&gt;sys.float_info.dig&lt;/code&gt; needs further explanation. If &lt;code&gt;s&lt;/code&gt; is any string representing a decimal number with at most &lt;code&gt;sys.float_info.dig&lt;/code&gt; significant digits, then converting &lt;code&gt;s&lt;/code&gt; to a float and back again will recover a string representing the same decimal value:</source>
          <target state="translated">&lt;code&gt;sys.float_info.dig&lt;/code&gt; 속성에 대한 추가 설명이 필요합니다. 경우 &lt;code&gt;s&lt;/code&gt; 대부분에서와 진수 나타내는 문자열입니다 &lt;code&gt;sys.float_info.dig&lt;/code&gt; , 다음 변환 유효 숫자 &lt;code&gt;s&lt;/code&gt; 같은 진수 값을 나타내는 문자열을 회복 다시 float로하고 :</target>
        </trans-unit>
        <trans-unit id="80c36253735c07d920791417fa7a7a1a529dab82" translate="yes" xml:space="preserve">
          <source>The attribute name. In a namespace-using document it may include a colon.</source>
          <target state="translated">속성 이름 네임 스페이스를 사용하는 문서에는 콜론이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34c7c2faa30f7bd05bfb9c7041417be557d23784" translate="yes" xml:space="preserve">
          <source>The attribute of every character in the window is changed to the new background attribute.</source>
          <target state="translated">창의 모든 문자 속성이 새 배경 속성으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="07392340727348ac2f4a66a50ef8232a5df7f9aa" translate="yes" xml:space="preserve">
          <source>The attributes &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt;&lt;code&gt;maximum_version&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.SSLContext.minimum_version&quot;&gt;&lt;code&gt;minimum_version&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;SSLContext.options&lt;/code&gt;&lt;/a&gt; all affect the supported SSL and TLS versions of the context. The implementation does not prevent invalid combination. For example a context with &lt;a href=&quot;#ssl.OP_NO_TLSv1_2&quot;&gt;&lt;code&gt;OP_NO_TLSv1_2&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt;&lt;code&gt;options&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt;&lt;code&gt;maximum_version&lt;/code&gt;&lt;/a&gt; set to &lt;a href=&quot;#ssl.TLSVersion.TLSv1_2&quot;&gt;&lt;code&gt;TLSVersion.TLSv1_2&lt;/code&gt;&lt;/a&gt; will not be able to establish a TLS 1.2 connection.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt; &lt;code&gt;maximum_version&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.SSLContext.minimum_version&quot;&gt; &lt;code&gt;minimum_version&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;SSLContext.options&lt;/code&gt; &lt;/a&gt; 속성은 모두 지원되는 컨텍스트의 SSL 및 TLS 버전에 영향을 줍니다 . 구현은 잘못된 조합을 방지하지 않습니다. 예를 들어 &lt;a href=&quot;#ssl.SSLContext.options&quot;&gt; &lt;code&gt;options&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#ssl.OP_NO_TLSv1_2&quot;&gt; &lt;code&gt;OP_NO_TLSv1_2&lt;/code&gt; &lt;/a&gt; 가 있고 &lt;a href=&quot;#ssl.SSLContext.maximum_version&quot;&gt; &lt;code&gt;maximum_version&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;#ssl.TLSVersion.TLSv1_2&quot;&gt; &lt;code&gt;TLSVersion.TLSv1_2&lt;/code&gt; 로&lt;/a&gt; 설정된 컨텍스트 에서 TLS 1.2 연결을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d2a6e5c3540f613e4a515b7af1ff266b0046448" translate="yes" xml:space="preserve">
          <source>The attributes &lt;code&gt;Color.RED&lt;/code&gt;, &lt;code&gt;Color.GREEN&lt;/code&gt;, etc., are &lt;em&gt;enumeration members&lt;/em&gt; (or &lt;em&gt;enum members&lt;/em&gt;) and are functionally constants.</source>
          <target state="translated">&lt;code&gt;Color.RED&lt;/code&gt; , &lt;code&gt;Color.GREEN&lt;/code&gt; 등 의 속성 은 &lt;em&gt;열거 형 멤버&lt;/em&gt; (또는 &lt;em&gt;열거 형 멤버)입니다.&lt;/em&gt; )이며 기능상 상수입니다.</target>
        </trans-unit>
        <trans-unit id="91a4811aba038c398e725d4c575b44d92daff913" translate="yes" xml:space="preserve">
          <source>The audio device objects returned by &lt;a href=&quot;#ossaudiodev.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; define the following methods and (read-only) attributes:</source>
          <target state="translated">&lt;a href=&quot;#ossaudiodev.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 오디오 장치 객체 는 다음과 같은 메서드와 (읽기 전용) 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="98de9a021c35453cb0dd0fe7c3d9218d4cd603d9" translate="yes" xml:space="preserve">
          <source>The audit event only occurs for direct instantiation of function objects, and is not raised for normal compilation.</source>
          <target state="translated">감사 이벤트는 함수 개체의 직접 인스턴스화에만 발생하며 일반 컴파일에서는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="04d9760b94e9697b28062a4f0fcfb4a6a38d064d" translate="yes" xml:space="preserve">
          <source>The authors strongly suggest getting a copy of the Tk man pages. Specifically, the man pages in the &lt;code&gt;manN&lt;/code&gt; directory are most useful. The &lt;code&gt;man3&lt;/code&gt; man pages describe the C interface to the Tk library and thus are not especially helpful for script writers.</source>
          <target state="translated">저자는 Tk 매뉴얼 페이지의 사본을 얻는 것이 좋습니다. 특히 &lt;code&gt;manN&lt;/code&gt; 디렉토리 의 매뉴얼 페이지 가 가장 유용합니다. &lt;code&gt;man3&lt;/code&gt; 사람이 페이지는 Tk의 라이브러리에 C 인터페이스를 설명하고, 따라서 스크립트 작성자에게 특히 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64330833d6daf7d99e3cc896f57c75f2eeab2fd3" translate="yes" xml:space="preserve">
          <source>The available exception and functions in this module are:</source>
          <target state="translated">이 모듈에서 사용 가능한 예외 및 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="45e4ec41244c100fe61e74f34e82a254e2fcc455" translate="yes" xml:space="preserve">
          <source>The available integer presentation types are:</source>
          <target state="translated">사용 가능한 정수 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9c8d6e8588482313d7f2606674509cd39c2ade3" translate="yes" xml:space="preserve">
          <source>The available presentation types for floating point and decimal values are:</source>
          <target state="translated">부동 소수점 및 10 진수 값에 사용 가능한 프리젠 테이션 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf7e6f76bb90144b319d33f3985485d202d127c2" translate="yes" xml:space="preserve">
          <source>The available string presentation types are:</source>
          <target state="translated">사용 가능한 문자열 표시 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e1cc522ce200b02d1be94463c7dbc8f36cdd953e" translate="yes" xml:space="preserve">
          <source>The barrier can be reused any number of times for the same number of threads.</source>
          <target state="translated">배리어는 동일한 수의 스레드에 대해 여러 번 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d64881eda8fb439140210f929f502081dc3c6e3" translate="yes" xml:space="preserve">
          <source>The base &lt;code&gt;Codec&lt;/code&gt; class defines these methods which also define the function interfaces of the stateless encoder and decoder:</source>
          <target state="translated">기본 &lt;code&gt;Codec&lt;/code&gt; 클래스는 상태 비 저장 인코더 및 디코더의 기능 인터페이스를 정의하는 이러한 메서드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="d36539260f7d520c14f309593d9749c7167bf7a1" translate="yes" xml:space="preserve">
          <source>The base class for all built-in exceptions. It is not meant to be directly inherited by user-defined classes (for that, use &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;). If &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; is called on an instance of this class, the representation of the argument(s) to the instance are returned, or the empty string when there were no arguments.</source>
          <target state="translated">모든 내장 예외의 기본 클래스입니다. 사용자 정의 클래스에 의해 직접 상속되는 것은 아닙니다 (그러므로 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 사용 ). 경우 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 이 클래스의 인스턴스에서 호출 인수가 없었다 경우, 인스턴스에 인수 (들)의 표현은 반환 또는 빈 문자열된다.</target>
        </trans-unit>
        <trans-unit id="f6b603a8cfad88dbda8b243486bb16f6a7a25762" translate="yes" xml:space="preserve">
          <source>The base class for custom dialogs.</source>
          <target state="translated">사용자 정의 대화 상자의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="37d870854fd3e6d86ede1e5e4056a04f59674dcc" translate="yes" xml:space="preserve">
          <source>The base class for implementing datagram (UDP) protocols.</source>
          <target state="translated">데이터 그램 (UDP) 프로토콜을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e6edb4bd859a927d0a782f77b29c7e76d77dfc75" translate="yes" xml:space="preserve">
          <source>The base class for implementing protocols communicating with child processes (unidirectional pipes).</source>
          <target state="translated">자식 프로세스 (단방향 파이프)와 통신하는 프로토콜을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="037876c88a29da839e41f411005cef5212fc3b7d" translate="yes" xml:space="preserve">
          <source>The base class for implementing streaming protocols (TCP, Unix sockets, etc).</source>
          <target state="translated">스트리밍 프로토콜 (TCP, Unix 소켓 등)을 구현하기위한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="720a5bb3a4d291051b191f1d34b8551facac8967" translate="yes" xml:space="preserve">
          <source>The base class for the exceptions that are raised when a key or index used on a mapping or sequence is invalid: &lt;a href=&quot;#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt;. This can be raised directly by &lt;a href=&quot;codecs#codecs.lookup&quot;&gt;&lt;code&gt;codecs.lookup()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키 또는 인덱스 매핑 또는 시퀀스에서 사용할 때 발생하는 예외의 기본 클래스가 잘못되었습니다 : &lt;a href=&quot;#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; 를&lt;/a&gt; . 이것은 &lt;a href=&quot;codecs#codecs.lookup&quot;&gt; &lt;code&gt;codecs.lookup()&lt;/code&gt; &lt;/a&gt; 의해 직접 제기 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d91f7435686fb107d68c4bacb73c9970d4f18e58" translate="yes" xml:space="preserve">
          <source>The base class for those built-in exceptions that are raised for various arithmetic errors: &lt;a href=&quot;#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ZeroDivisionError&quot;&gt;&lt;code&gt;ZeroDivisionError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#FloatingPointError&quot;&gt;&lt;code&gt;FloatingPointError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다양한 산술 오류 ( &lt;a href=&quot;#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ZeroDivisionError&quot;&gt; &lt;code&gt;ZeroDivisionError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#FloatingPointError&quot;&gt; &lt;code&gt;FloatingPointError&lt;/code&gt; )에&lt;/a&gt; 대해 발생하는 기본 제공 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="5be1b03a2559b8dbbf5e82b0787d6c7a0613ed82" translate="yes" xml:space="preserve">
          <source>The base class of all &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">모든 &lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 예외 의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="0d598c1c31072f1d5bb7fce71b965147de8b6233" translate="yes" xml:space="preserve">
          <source>The base class of the other exceptions in this module. It is a subclass of &lt;a href=&quot;exceptions#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에있는 다른 예외의 기본 클래스입니다. &lt;a href=&quot;exceptions#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="e9d7127298b4ff6be01bcb830aa1f5c9b7b8e1ea" translate="yes" xml:space="preserve">
          <source>The base exception class. &lt;a href=&quot;#xdrlib.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; has a single public attribute &lt;code&gt;msg&lt;/code&gt; containing the description of the error.</source>
          <target state="translated">기본 예외 클래스 &lt;a href=&quot;#xdrlib.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 설명이 포함 된 단일 공용 속성 &lt;code&gt;msg&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="478754849bb693c84213dee13796bc23b118363e" translate="yes" xml:space="preserve">
          <source>The base implementation formats the record to merge the message, arguments, and exception information, if present. It also removes unpickleable items from the record in-place.</source>
          <target state="translated">기본 구현은 레코드를 형식화하여 메시지, 인수 및 예외 정보가있는 경우이를 병합합니다. 또한 레코드에서 피클 링 불가능한 항목을 제자리에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="e08426a91a7035e4c2d72c85c9c7b7cd719829df" translate="yes" xml:space="preserve">
          <source>The base implementation uses &lt;code&gt;get()&lt;/code&gt;. You may want to override this method if you want to use timeouts or work with custom queue implementations.</source>
          <target state="translated">기본 구현은 &lt;code&gt;get()&lt;/code&gt; 사용합니다 . 시간 종료를 사용하거나 사용자 정의 큐 구현에 대해 작업하려는 경우이 메소드를 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb9a116b8103bca120218fe5a882926ba73692a3" translate="yes" xml:space="preserve">
          <source>The based class for all other module-specific exceptions.</source>
          <target state="translated">다른 모든 모듈 별 예외에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d4f200fcdf75b7beb6b2c030a2febabba55c0a7d" translate="yes" xml:space="preserve">
          <source>The basic API is a simple wrapper that&amp;rsquo;s intended to make doctest easy to use. It is fairly flexible, and should meet most users&amp;rsquo; needs; however, if you require more fine-grained control over testing, or wish to extend doctest&amp;rsquo;s capabilities, then you should use the advanced API.</source>
          <target state="translated">기본 API는 doctest를 사용하기 쉽게 만드는 간단한 래퍼입니다. 상당히 유연하며 대부분의 사용자 요구를 충족시켜야합니다. 그러나 테스트에 대한보다 세밀한 제어가 필요하거나 doctest의 기능을 확장하려면 고급 API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c46a98898a854487d370b50e8f5e79d547a5abf6" translate="yes" xml:space="preserve">
          <source>The basic building blocks of unit testing are &lt;em&gt;test cases&lt;/em&gt; &amp;mdash; single scenarios that must be set up and checked for correctness. In &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt;, test cases are represented by &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt; instances. To make your own test cases you must write subclasses of &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; or use &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt;&lt;code&gt;FunctionTestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단위 테스트의 기본 구성 요소는 &lt;em&gt;테스트 사례입니다&lt;/em&gt; . 단일 시나리오로 설정하고 정확성을 검사해야합니다. 에서 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; , 테스트 케이스는로 표현됩니다 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; 의&lt;/a&gt; 인스턴스. 자체 테스트 사례를 만들려면 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; 의&lt;/a&gt; 서브 클래스를 작성 하거나 &lt;a href=&quot;#unittest.FunctionTestCase&quot;&gt; &lt;code&gt;FunctionTestCase&lt;/code&gt; 를&lt;/a&gt; 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1631527b4d4b04ac30516c30c03bdc201a159063" translate="yes" xml:space="preserve">
          <source>The basic classes defined by the module, together with their functions, are listed below.</source>
          <target state="translated">모듈에서 정의한 기본 클래스와 해당 기능이 아래에 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0621714f64d694606df173391b93313eeac34756" translate="yes" xml:space="preserve">
          <source>The basic data compression module needed to support the &lt;strong&gt;gzip&lt;/strong&gt; file format.</source>
          <target state="translated">기본 데이터 압축 모듈은 &lt;strong&gt;gzip&lt;/strong&gt; 파일 형식 을 지원해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="f3ea23849e09db81b8cf44483296cfa966e4cf09" translate="yes" xml:space="preserve">
          <source>The basic idea behind both modules is to create one or more network &lt;em&gt;channels&lt;/em&gt;, instances of class &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt;&lt;code&gt;asynchat.async_chat&lt;/code&gt;&lt;/a&gt;. Creating the channels adds them to a global map, used by the &lt;a href=&quot;#asyncore.loop&quot;&gt;&lt;code&gt;loop()&lt;/code&gt;&lt;/a&gt; function if you do not provide it with your own &lt;em&gt;map&lt;/em&gt;.</source>
          <target state="translated">두 모듈의 기본 개념은 하나 이상의 네트워크 &lt;em&gt;채널&lt;/em&gt; , &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt; &lt;code&gt;asynchat.async_chat&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 를 만드는 것 입니다. 채널을 만들면 자신의 &lt;em&gt;map을&lt;/em&gt; 제공하지 않으면 &lt;a href=&quot;#asyncore.loop&quot;&gt; &lt;code&gt;loop()&lt;/code&gt; &lt;/a&gt; 함수가 사용하는 전역 맵에 채널이 추가 &lt;em&gt;됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ffd84d87aba9b9e8fc01342a423d56d02dd44a" translate="yes" xml:space="preserve">
          <source>The basic idea for &lt;a href=&quot;#module-tkinter.ttk&quot;&gt;&lt;code&gt;tkinter.ttk&lt;/code&gt;&lt;/a&gt; is to separate, to the extent possible, the code implementing a widget&amp;rsquo;s behavior from the code implementing its appearance.</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.ttk&quot;&gt; &lt;code&gt;tkinter.ttk&lt;/code&gt; &lt;/a&gt; 의 기본 아이디어 는 위젯의 동작을 구현하는 코드와 모양을 구현하는 코드를 가능한 한 분리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e9e78405f309044c1b7fe1bffdce4599a86f91" translate="yes" xml:space="preserve">
          <source>The basic principle is that you patch where an object is &lt;em&gt;looked up&lt;/em&gt;, which is not necessarily the same place as where it is defined. A couple of examples will help to clarify this.</source>
          <target state="translated">기본 원칙은 객체를 &lt;em&gt;찾는&lt;/em&gt; 곳을 패치하는 것인데, 반드시 정의 된 곳과 반드시 ​​같은 곳은 아닙니다. 몇 가지 예가이를 명확히하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="35a19f280d80a953c16e49e081b424d6cbff98c0" translate="yes" xml:space="preserve">
          <source>The basic type used for binary data read from or written to a file is &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Other &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are accepted as method arguments too. Text I/O classes work with &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data.</source>
          <target state="translated">파일에서 읽거나 파일에 쓰는 이진 데이터에 사용되는 기본 유형은 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 입니다. 다른 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 도 메소드 인수로 허용됩니다. 텍스트 I / O 클래스는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터 와 함께 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="232d526053763da166d71f7d5a980e0adc829266" translate="yes" xml:space="preserve">
          <source>The basic type used for binary data read from or written to a file is &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Other &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are accepted as method arguments too. Text I/O classes work with &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data.</source>
          <target state="translated">The basic type used for binary data read from or written to a file is &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt;. Other &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are accepted as method arguments too. Text I/O classes work with &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; data.</target>
        </trans-unit>
        <trans-unit id="1a0089a139acba0f4ef316c21fe484b7943e9402" translate="yes" xml:space="preserve">
          <source>The behavior is same as &lt;a href=&quot;#urllib.request.HTTPErrorProcessor.http_response&quot;&gt;&lt;code&gt;http_response()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동작은 &lt;a href=&quot;#urllib.request.HTTPErrorProcessor.http_response&quot;&gt; &lt;code&gt;http_response()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="509167a2d22d3e262915b45c8a13aa32c0c6f112" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#mailbox.Mailbox.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; is unlike that of dictionaries, which iterate over keys.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 의 동작은 키를 반복하는 사전 의 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7ed5e3c6e5fccac07bc7e1871b7a1d111d3de3c4" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt; for floats can be surprising: for example, &lt;code&gt;round(2.675, 2)&lt;/code&gt; gives &lt;code&gt;2.67&lt;/code&gt; instead of the expected &lt;code&gt;2.68&lt;/code&gt;. This is not a bug: it&amp;rsquo;s a result of the fact that most decimal fractions can&amp;rsquo;t be represented exactly as a float. See &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt; for more information.</source>
          <target state="translated">float에 대한 &lt;a href=&quot;#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; 의 동작은 놀랍습니다. 예를 들어 &lt;code&gt;round(2.675, 2)&lt;/code&gt; 는 예상 &lt;code&gt;2.68&lt;/code&gt; 대신 &lt;code&gt;2.67&lt;/code&gt; 을 제공합니다 . 이것은 버그가 아닙니다. 대부분의 소수는 정확히 부동 소수점으로 표현할 수 없다는 사실의 결과입니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;부동 소수점 산술 : 문제 및 제한 사항&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63f8382284018272eb13a971d55c56571d63b667" translate="yes" xml:space="preserve">
          <source>The behavior of &lt;a href=&quot;#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt; for floats can be surprising: for example, &lt;code&gt;round(2.675, 2)&lt;/code&gt; gives &lt;code&gt;2.67&lt;/code&gt; instead of the expected &lt;code&gt;2.68&lt;/code&gt;. This is not a bug: it&amp;rsquo;s a result of the fact that most decimal fractions can&amp;rsquo;t be represented exactly as a float. See &lt;a href=&quot;https://docs.python.org/3.9/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt; for more information.</source>
          <target state="translated">The behavior of &lt;a href=&quot;#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; for floats can be surprising: for example, &lt;code&gt;round(2.675, 2)&lt;/code&gt; gives &lt;code&gt;2.67&lt;/code&gt; instead of the expected &lt;code&gt;2.68&lt;/code&gt; . This is not a bug: it&amp;rsquo;s a result of the fact that most decimal fractions can&amp;rsquo;t be represented exactly as a float. See &lt;a href=&quot;https://docs.python.org/3.9/tutorial/floatingpoint.html#tut-fp-issues&quot;&gt;Floating Point Arithmetic: Issues and Limitations&lt;/a&gt; for more information.</target>
        </trans-unit>
        <trans-unit id="c9031477af7e15d083a487073bb2d0a4eb97e4c9" translate="yes" xml:space="preserve">
          <source>The behavior of Python&amp;rsquo;s comparison operators can be a little surprising where a &lt;code&gt;NaN&lt;/code&gt; is involved. A test for equality where one of the operands is a quiet or signaling &lt;code&gt;NaN&lt;/code&gt; always returns &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; (even when doing &lt;code&gt;Decimal('NaN')==Decimal('NaN')&lt;/code&gt;), while a test for inequality always returns &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt;. An attempt to compare two Decimals using any of the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;gt;=&lt;/code&gt; operators will raise the &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt; signal if either operand is a &lt;code&gt;NaN&lt;/code&gt;, and return &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; if this signal is not trapped. Note that the General Decimal Arithmetic specification does not specify the behavior of direct comparisons; these rules for comparisons involving a &lt;code&gt;NaN&lt;/code&gt; were taken from the IEEE 854 standard (see Table 3 in section 5.7). To ensure strict standards-compliance, use the &lt;code&gt;compare()&lt;/code&gt; and &lt;code&gt;compare-signal()&lt;/code&gt; methods instead.</source>
          <target state="translated">&lt;code&gt;NaN&lt;/code&gt; 이 관련된 곳에서 파이썬의 비교 연산자의 동작은 약간 놀랍습니다 . 피연산자 중 하나가 조용한 또는 신호 &lt;code&gt;NaN&lt;/code&gt; 인 동등성 검정은 항상 &lt;code&gt;Decimal('NaN')==Decimal('NaN')&lt;/code&gt; 수행하는 경우에도 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환 하지만 부등식 검정은 항상 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;gt;=&lt;/code&gt; 연산자 중 하나를 사용하여 두 Decimal을 비교하려고 하면 피연산자가 &lt;code&gt;NaN&lt;/code&gt; 인 경우 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt; 신호를 발생 시키고 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환합니다.이 신호가 갇히지 않으면 일반 십진 산술 스펙은 직접 비교의 동작을 지정하지 않습니다. &lt;code&gt;NaN&lt;/code&gt; 과 관련된 비교 규칙 은 IEEE 854 표준에서 취해졌습니다 (섹션 5.7의 표 3 참조). 엄격한 표준 준수를 보장하려면 대신 &lt;code&gt;compare()&lt;/code&gt; 및 &lt;code&gt;compare-signal()&lt;/code&gt; 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="89a6bf36e0e2f9919f25455cc22845313051bcc0" translate="yes" xml:space="preserve">
          <source>The behavior of a &lt;code&gt;ZoneInfo&lt;/code&gt; file depends on how it was constructed:</source>
          <target state="translated">The behavior of a &lt;code&gt;ZoneInfo&lt;/code&gt; file depends on how it was constructed:</target>
        </trans-unit>
        <trans-unit id="2cc2a05a47982852d6024377eba4e6d10a25ebe4" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is-not&quot;&gt;&lt;code&gt;is not&lt;/code&gt;&lt;/a&gt; operators cannot be customized; also they can be applied to any two objects and never raise an exception.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is-not&quot;&gt; &lt;code&gt;is not&lt;/code&gt; &lt;/a&gt; 연산자 의 동작은 사용자 정의 할 수 없습니다. 또한 두 객체에 적용 할 수 있으며 예외를 발생시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83e631b5b7132abea66dbccd9fe12d6e92d08ebc" translate="yes" xml:space="preserve">
          <source>The behavior of the &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is-not&quot;&gt;&lt;code&gt;is not&lt;/code&gt;&lt;/a&gt; operators cannot be customized; also they can be applied to any two objects and never raise an exception.</source>
          <target state="translated">The behavior of the &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is-not&quot;&gt; &lt;code&gt;is not&lt;/code&gt; &lt;/a&gt; operators cannot be customized; also they can be applied to any two objects and never raise an exception.</target>
        </trans-unit>
        <trans-unit id="544260a58eab8deefccf4a61698b8f81198ba13f" translate="yes" xml:space="preserve">
          <source>The behavior of the call is dependent on the value of &lt;em&gt;how&lt;/em&gt;, as follows.</source>
          <target state="translated">호출 동작은 다음과 같이 &lt;em&gt;how&lt;/em&gt; 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="40956b4e017ec60e6e630696961357aedfdf755a" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be overridden by an earlier call to the &lt;a href=&quot;https://docs.python.org/3.8/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt;&lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt;&lt;/a&gt;, however, it should always be considered interchangeable with &lt;code&gt;open(path, 'rb')&lt;/code&gt;. Overriding the behavior is intended for additional validation or preprocessing of the file.</source>
          <target state="translated">이 함수의 동작은 &lt;a href=&quot;https://docs.python.org/3.8/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt; &lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt; &lt;/a&gt; 에 대한 이전 호출로 재정의 될 수 있지만 항상 &lt;code&gt;open(path, 'rb')&lt;/code&gt; 와 상호 교환 가능한 것으로 간주되어야합니다 . 비헤이비어 재정의는 파일의 추가 유효성 검사 또는 사전 처리를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d32237fe6c13dd58c30fefde2fa89b66a6a1e1e" translate="yes" xml:space="preserve">
          <source>The behavior of this function may be overridden by an earlier call to the &lt;a href=&quot;https://docs.python.org/3.9/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt;&lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt;&lt;/a&gt;. However, assuming that &lt;code&gt;path&lt;/code&gt; is a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and an absolute path, &lt;code&gt;open_code(path)&lt;/code&gt; should always behave the same as &lt;code&gt;open(path, 'rb')&lt;/code&gt;. Overriding the behavior is intended for additional validation or preprocessing of the file.</source>
          <target state="translated">The behavior of this function may be overridden by an earlier call to the &lt;a href=&quot;https://docs.python.org/3.9/c-api/file.html#c.PyFile_SetOpenCodeHook&quot;&gt; &lt;code&gt;PyFile_SetOpenCodeHook()&lt;/code&gt; &lt;/a&gt;. However, assuming that &lt;code&gt;path&lt;/code&gt; is a &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; and an absolute path, &lt;code&gt;open_code(path)&lt;/code&gt; should always behave the same as &lt;code&gt;open(path, 'rb')&lt;/code&gt; . Overriding the behavior is intended for additional validation or preprocessing of the file.</target>
        </trans-unit>
        <trans-unit id="b73eb81df2ab1d8f8cce0693e52a357a71025f62" translate="yes" xml:space="preserve">
          <source>The behaviour described in this section applies only to the URL parsing functions. The URL quoting functions use their own rules when producing or consuming byte sequences as detailed in the documentation of the individual URL quoting functions.</source>
          <target state="translated">이 섹션에서 설명하는 동작은 URL 구문 분석 기능에만 적용됩니다. URL 인용 함수는 개별 URL 인용 함수의 문서에 설명 된대로 바이트 시퀀스를 생성하거나 사용할 때 자체 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="870d091adef72b6c80ca5010f416ba0fc8d77382" translate="yes" xml:space="preserve">
          <source>The below classes are used for creating file/directory windows from scratch. These do not emulate the native look-and-feel of the platform.</source>
          <target state="translated">The below classes are used for creating file/directory windows from scratch. These do not emulate the native look-and-feel of the platform.</target>
        </trans-unit>
        <trans-unit id="8730e9a7b67874ca6652e03dde7ce57808dbc4ad" translate="yes" xml:space="preserve">
          <source>The below functions when called create a modal, native look-and-feel dialog, wait for the user&amp;rsquo;s selection, then return the selected value(s) or &lt;code&gt;None&lt;/code&gt; to the caller.</source>
          <target state="translated">The below functions when called create a modal, native look-and-feel dialog, wait for the user&amp;rsquo;s selection, then return the selected value(s) or &lt;code&gt;None&lt;/code&gt; to the caller.</target>
        </trans-unit>
        <trans-unit id="fccb0864af618f1eda4209875389b23fdd17be04" translate="yes" xml:space="preserve">
          <source>The best (no more than &lt;em&gt;n&lt;/em&gt;) matches among the possibilities are returned in a list, sorted by similarity score, most similar first.</source>
          <target state="translated">가능성 중 최고 ( &lt;em&gt;n 이하&lt;/em&gt; ) 일치 항목이 유사성 점수로 정렬되어 목록에서 반환되며 가장 유사합니다.</target>
        </trans-unit>
        <trans-unit id="6e16ef4c7892d882d4fb24850f803bc72293e9c1" translate="yes" xml:space="preserve">
          <source>The binary data encapsulated by the &lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt;&lt;code&gt;Binary&lt;/code&gt;&lt;/a&gt; instance. The data is provided as a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.client.Binary&quot;&gt; &lt;code&gt;Binary&lt;/code&gt; &lt;/a&gt; 인스턴스로 캡슐화 된 이진 데이터 입니다. 데이터는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b2c516a69d7acb2c687bf6c7fbf1597a2d16d23" translate="yes" xml:space="preserve">
          <source>The binary format for plist files</source>
          <target state="translated">plist 파일의 이진 형식</target>
        </trans-unit>
        <trans-unit id="252ee8840198291e490d998e86244d7d8e35b498" translate="yes" xml:space="preserve">
          <source>The binary representation of this address - a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of the appropriate length (most significant octet first). This is 4 bytes for IPv4 and 16 bytes for IPv6.</source>
          <target state="translated">이 주소의 이진 표현- 적절한 길이 의 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 (가장 중요한 옥텟 우선). IPv4의 경우 4 바이트, IPv6의 경우 16 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="0812f781105763b6ad83547e0dd0926227d1acb3" translate="yes" xml:space="preserve">
          <source>The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">제거 할 바이트 값의 이진 시퀀스는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a5de986a8b76cfa8659f1ade0eb9546eb3442d2f" translate="yes" xml:space="preserve">
          <source>The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b1dd26f9df9ca5078794e7b2c1b2ed799938d4d7" translate="yes" xml:space="preserve">
          <source>The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. See &lt;a href=&quot;#bytes.removeprefix&quot;&gt;&lt;code&gt;removeprefix()&lt;/code&gt;&lt;/a&gt; for a method that will remove a single prefix string rather than all of a set of characters. For example:</source>
          <target state="translated">The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. See &lt;a href=&quot;#bytes.removeprefix&quot;&gt; &lt;code&gt;removeprefix()&lt;/code&gt; &lt;/a&gt; for a method that will remove a single prefix string rather than all of a set of characters. For example:</target>
        </trans-unit>
        <trans-unit id="ab528ebc486418a97f34b71250ce80d6bc25202b" translate="yes" xml:space="preserve">
          <source>The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. See &lt;a href=&quot;#bytes.removesuffix&quot;&gt;&lt;code&gt;removesuffix()&lt;/code&gt;&lt;/a&gt; for a method that will remove a single suffix string rather than all of a set of characters. For example:</source>
          <target state="translated">The binary sequence of byte values to remove may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. See &lt;a href=&quot;#bytes.removesuffix&quot;&gt; &lt;code&gt;removesuffix()&lt;/code&gt; &lt;/a&gt; for a method that will remove a single suffix string rather than all of a set of characters. For example:</target>
        </trans-unit>
        <trans-unit id="79985ad5b74e6b2174133e206b38c0aac43f893a" translate="yes" xml:space="preserve">
          <source>The binary stream API is described in detail in the docs of &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이진 스트림 API는 &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4bbdb4bdfe9695f4a095f27b2e5074bc83e4388e" translate="yes" xml:space="preserve">
          <source>The bind method from the widget command allows you to watch for certain events and to have a callback function trigger when that event type occurs. The form of the bind method is:</source>
          <target state="translated">위젯 명령의 바인드 메소드를 사용하면 특정 이벤트를 감시하고 해당 이벤트 유형이 발생할 때 콜백 함수를 트리거 할 수 있습니다. 바인드 메소드의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e93fbed83a2a6d08231b63e0601395b4e1d9ac92" translate="yes" xml:space="preserve">
          <source>The bootstrapping process has side effects on both &lt;code&gt;sys.path&lt;/code&gt; and &lt;code&gt;os.environ&lt;/code&gt;. Invoking the command line interface in a subprocess instead allows these side effects to be avoided.</source>
          <target state="translated">부트 스트랩 프로세스는 &lt;code&gt;sys.path&lt;/code&gt; 및 &lt;code&gt;os.environ&lt;/code&gt; 모두에 부작용이 있습니다 . 서브 프로세스에서 명령 행 인터페이스를 호출하면 이러한 부작용을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f515285eaaa8a5dd687b8c8d9114206f8ad89259" translate="yes" xml:space="preserve">
          <source>The bootstrapping process may install additional modules required by &lt;code&gt;pip&lt;/code&gt;, but other software should not assume those dependencies will always be present by default (as the dependencies may be removed in a future version of &lt;code&gt;pip&lt;/code&gt;).</source>
          <target state="translated">부트 스트랩 프로세스는 &lt;code&gt;pip&lt;/code&gt; 에 필요한 추가 모듈을 설치할 수 있지만 다른 소프트웨어는 이러한 종속성이 기본적으로 항상 존재한다고 가정하지 않아야합니다 (이후 버전의 &lt;code&gt;pip&lt;/code&gt; 에서는 종속성이 제거 될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="c5d92c927226a7e06bd64aa8058a997143922e20" translate="yes" xml:space="preserve">
          <source>The breakpoint hit count.</source>
          <target state="translated">중단 점 적중 횟수</target>
        </trans-unit>
        <trans-unit id="1cba654c3d7f4efba7391fd33ea1f1150e43af8b" translate="yes" xml:space="preserve">
          <source>The breakpoint number.</source>
          <target state="translated">중단 점 번호</target>
        </trans-unit>
        <trans-unit id="53bf604092d847435ec91583c0ecb4652c552bdb" translate="yes" xml:space="preserve">
          <source>The broadcast address for the network. Packets sent to the broadcast address should be received by every host on the network.</source>
          <target state="translated">네트워크의 브로드 캐스트 주소입니다. 브로드 캐스트 주소로 전송 된 패킷은 네트워크의 모든 호스트가 수신해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d40ac1836068b896d22f880fb080c4129bf0cf8" translate="yes" xml:space="preserve">
          <source>The built in configuration would correspond to the following turtle.cfg:</source>
          <target state="translated">내장 구성은 다음 turtle.cfg에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="e7fa923936d6d1b71a2acb45dbdbd4cb369c9d51" translate="yes" xml:space="preserve">
          <source>The built-in &lt;a href=&quot;#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt; function is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal &amp;mdash; this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).</source>
          <target state="translated">내장 &lt;a href=&quot;#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; 함수는 안정적입니다. 동일하게 비교되는 요소의 상대적 순서를 변경하지 않으면 정렬은 안정적입니다. 이는 여러 단계로 정렬하는 데 유용합니다 (예 : 부서별, 급여 등급별).</target>
        </trans-unit>
        <trans-unit id="a0892e50ab43cc568814a6df06313480188876dd" translate="yes" xml:space="preserve">
          <source>The built-in default configuration mimics the appearance and behaviour of the old turtle module in order to retain best possible compatibility with it.</source>
          <target state="translated">내장 된 기본 구성은 기존 거북이 모듈의 모양과 동작을 모방하여 최상의 호환성을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="eb1483a41a7a356efe8918b5b9cc6c72b5b93268" translate="yes" xml:space="preserve">
          <source>The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; class or one of its subclasses, and not from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. More information on defining exceptions is available in the Python Tutorial under &lt;a href=&quot;https://docs.python.org/3.8/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt;.</source>
          <target state="translated">내장 예외 클래스는 새로운 예외를 정의하기 위해 서브 클래 싱 될 수 있습니다. 프로그래머는 &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; 이&lt;/a&gt; 아닌 &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; 클래스 또는 해당 서브 클래스 중 하나 에서 새 예외를 파생시키는 것이 좋습니다 . 예외 정의에 대한 자세한 내용은 Python Tutorial의 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt; 아래에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df6d30505531c427957e36648253a107979af802" translate="yes" xml:space="preserve">
          <source>The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the &lt;a href=&quot;#Exception&quot;&gt;&lt;code&gt;Exception&lt;/code&gt;&lt;/a&gt; class or one of its subclasses, and not from &lt;a href=&quot;#BaseException&quot;&gt;&lt;code&gt;BaseException&lt;/code&gt;&lt;/a&gt;. More information on defining exceptions is available in the Python Tutorial under &lt;a href=&quot;https://docs.python.org/3.9/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt;.</source>
          <target state="translated">The built-in exception classes can be subclassed to define new exceptions; programmers are encouraged to derive new exceptions from the &lt;a href=&quot;#Exception&quot;&gt; &lt;code&gt;Exception&lt;/code&gt; &lt;/a&gt; class or one of its subclasses, and not from &lt;a href=&quot;#BaseException&quot;&gt; &lt;code&gt;BaseException&lt;/code&gt; &lt;/a&gt;. More information on defining exceptions is available in the Python Tutorial under &lt;a href=&quot;https://docs.python.org/3.9/tutorial/errors.html#tut-userexceptions&quot;&gt;User-defined Exceptions&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3828a20aa9a305e843887279463a549fc13bad92" translate="yes" xml:space="preserve">
          <source>The built-in exceptions listed below can be generated by the interpreter or built-in functions. Except where mentioned, they have an &amp;ldquo;associated value&amp;rdquo; indicating the detailed cause of the error. This may be a string or a tuple of several items of information (e.g., an error code and a string explaining the code). The associated value is usually passed as arguments to the exception class&amp;rsquo;s constructor.</source>
          <target state="translated">아래에 나열된 내장 예외는 인터프리터 또는 내장 함수에 의해 생성 될 수 있습니다. 언급 된 경우를 제외하고, 오류의 자세한 원인을 나타내는 &quot;연관된 값&quot;이 있습니다. 이것은 여러 정보 항목의 문자열 또는 튜플 일 수 있습니다 (예 : 오류 코드 및 코드를 설명하는 문자열). 연관된 값은 일반적으로 예외 클래스의 생성자에 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="ce16b2d882c9465a0733bec038b7dbc1af59c9ba" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;a href=&quot;functions#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt; invokes the online help system in the interactive interpreter, which uses &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; to generate its documentation as text on the console. The same text documentation can also be viewed from outside the Python interpreter by running &lt;strong&gt;pydoc&lt;/strong&gt; as a script at the operating system&amp;rsquo;s command prompt. For example, running</source>
          <target state="translated">내장 함수 &lt;a href=&quot;functions#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 는 대화식 인터프리터에서 &lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; &lt;/a&gt; 을 사용하여 문서를 콘솔에서 텍스트로 텍스트로 생성 하는 온라인 도움말 시스템을 호출합니다 . 운영 체제의 명령 프롬프트에서 &lt;strong&gt;pydoc&lt;/strong&gt; 을 스크립트로 실행하여 Python 인터프리터 외부에서 동일한 텍스트 문서를 볼 수도 있습니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="2032bd3ab7af47f02c71e038cf4e4ffa2d3f7fc7" translate="yes" xml:space="preserve">
          <source>The built-in functions &lt;a href=&quot;#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; return the current global and local dictionary, respectively, which may be useful to pass around for use as the second and third argument to &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 함수 &lt;a href=&quot;#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 는 현재 전역 및 로컬 사전을 각각 리턴하므로 &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 의 두 번째 및 세 번째 인수로 사용하기 위해 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad5e8010d0807348a7e3e895536079ec4ac5755b" translate="yes" xml:space="preserve">
          <source>The built-in string class provides the ability to do complex variable substitutions and value formatting via the &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; method described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3101&lt;/strong&gt;&lt;/a&gt;. The &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; class in the &lt;a href=&quot;#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; module allows you to create and customize your own string formatting behaviors using the same implementation as the built-in &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;format()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">내장 문자열 클래스는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3101&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3101에&lt;/strong&gt;&lt;/a&gt; 설명 된 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 메소드 를 통해 복잡한 변수 대체 및 값 형식화를 수행하는 기능을 제공합니다 . &lt;a href=&quot;#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 클래스를 사용하면 내장 &lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;format()&lt;/code&gt; &lt;/a&gt; 메서드 와 동일한 구현을 사용하여 고유 한 문자열 형식 동작을 만들고 사용자 지정할 수 있습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="afc06e18bc2379dac4ffc9d5696c4410f8337b35" translate="yes" xml:space="preserve">
          <source>The builtin functions &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#issubclass&quot;&gt;&lt;code&gt;issubclass()&lt;/code&gt;&lt;/a&gt; do not accept &lt;code&gt;GenericAlias&lt;/code&gt; types for their second argument:</source>
          <target state="translated">The builtin functions &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;functions#issubclass&quot;&gt; &lt;code&gt;issubclass()&lt;/code&gt; &lt;/a&gt; do not accept &lt;code&gt;GenericAlias&lt;/code&gt; types for their second argument:</target>
        </trans-unit>
        <trans-unit id="7779d62430e6d828e7796b70c889aebdd5d5b2a7" translate="yes" xml:space="preserve">
          <source>The bytearray version of this method does &lt;em&gt;not&lt;/em&gt; operate in place - it always produces a new object, even if no changes were made.</source>
          <target state="translated">이 메소드의 바이트 배열 버전은 제자리에서 작동 하지 &lt;em&gt;않습니다&lt;/em&gt; . 변경 사항이 없더라도 항상 새 객체를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="825f32039ec2b8c6f1ad7632fe9653dd855a0a80" translate="yes" xml:space="preserve">
          <source>The bytecode analysis API allows pieces of Python code to be wrapped in a &lt;a href=&quot;#dis.Bytecode&quot;&gt;&lt;code&gt;Bytecode&lt;/code&gt;&lt;/a&gt; object that provides easy access to details of the compiled code.</source>
          <target state="translated">바이트 코드 분석 API를 사용 하면 컴파일 된 코드의 세부 정보에 쉽게 액세스 할 수 있는 &lt;a href=&quot;#dis.Bytecode&quot;&gt; &lt;code&gt;Bytecode&lt;/code&gt; &lt;/a&gt; 객체 에 Python 코드 조각을 래핑 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4e72ff3f77625381d6ebb85da38770f77d7d8d2" translate="yes" xml:space="preserve">
          <source>The bytes contained in &lt;em&gt;fp&lt;/em&gt; must be formatted as a block of &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; (or, if &lt;code&gt;utf8&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt;) style headers and header continuation lines, optionally preceded by an envelope header. The header block is terminated either by the end of the data or by a blank line. Following the header block is the body of the message (which may contain MIME-encoded subparts, including subparts with a &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; of &lt;code&gt;8bit&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;fp에&lt;/em&gt; 포함 된 바이트 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; (또는 &lt;code&gt;utf8&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; ) 스타일 헤더 및 헤더 연속 행 의 블록으로 형식화되어야하며 , 선택적으로 봉투 헤더가 앞에옵니다. 헤더 블록은 데이터 끝이나 빈 줄로 종료됩니다. 헤더 블록 다음에는 메시지 본문이 있습니다 (여기에는 &lt;code&gt;8bit&lt;/code&gt; 의 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 이 있는 서브 파트를 포함하여 MIME로 인코딩 된 서브 파트가 포함될 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="72979803b3b76ceaedcd3e763678e9c5bdfe19e9" translate="yes" xml:space="preserve">
          <source>The bytes which represent the bytecode version number. If you need help with loading/writing bytecode then consider &lt;a href=&quot;#importlib.abc.SourceLoader&quot;&gt;&lt;code&gt;importlib.abc.SourceLoader&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">바이트 코드 버전 번호를 나타내는 바이트입니다. 바이트 코드로드 / 쓰기에 도움이 필요하면 &lt;a href=&quot;#importlib.abc.SourceLoader&quot;&gt; &lt;code&gt;importlib.abc.SourceLoader&lt;/code&gt; &lt;/a&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="63b8460a5fd05daeaaaaeca07ed037cc843d40ae" translate="yes" xml:space="preserve">
          <source>The cache (or part of it) can be cleared manually if a rescan of &lt;a href=&quot;sys#sys.path_hooks&quot;&gt;&lt;code&gt;sys.path_hooks&lt;/code&gt;&lt;/a&gt; is necessary.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.path_hooks&quot;&gt; &lt;code&gt;sys.path_hooks&lt;/code&gt; 를&lt;/a&gt; 다시 스캔 해야하는 경우 캐시 (또는 캐시의 일부)를 수동으로 지울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed9c68f517e26b2e6a3625184bdd623a5e8c02e6" translate="yes" xml:space="preserve">
          <source>The caching feature of &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; has been disabled until someone finds the time to hack proper processing of Expiration time headers.</source>
          <target state="translated">누군가가 만료 시간 헤더의 적절한 처리를 해킹 할 시간을 찾을 때까지 &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 의 캐싱 기능 이 비활성화되었습니다.</target>
        </trans-unit>
        <trans-unit id="4c502152227f3ef8521b4fb7861c4b965c780d96" translate="yes" xml:space="preserve">
          <source>The calculated size of the struct (and hence of the bytes object produced by the &lt;a href=&quot;#struct.pack&quot;&gt;&lt;code&gt;pack()&lt;/code&gt;&lt;/a&gt; method) corresponding to &lt;a href=&quot;functions#format&quot;&gt;&lt;code&gt;format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#format&quot;&gt; &lt;code&gt;format&lt;/code&gt; 에&lt;/a&gt; 해당하는 struct (및 &lt;a href=&quot;#struct.pack&quot;&gt; &lt;code&gt;pack()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 생성 된 bytes 객체)의 계산 된 크기입니다 .</target>
        </trans-unit>
        <trans-unit id="c83bb87cd08de64e758cd798a710959973f92aa3" translate="yes" xml:space="preserve">
          <source>The callback function will be called with three arguments; the first being the &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt;, the second is a string that represents the server name that the client is intending to communicate (or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the TLS Client Hello does not contain a server name) and the third argument is the original &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt;. The server name argument is text. For internationalized domain name, the server name is an IDN A-label (&lt;code&gt;&quot;xn--pythn-mua.org&quot;&lt;/code&gt;).</source>
          <target state="translated">콜백 함수는 세 개의 인수로 호출됩니다. 첫 번째는 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt; 이고, 두 번째는 클라이언트가 통신하려는 서버 이름을 나타내는 문자열입니다 (또는 TLS 클라이언트 Hello에 서버 이름이 포함되어 있지 않은 경우 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; ). 세 번째 인수는 원래 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 입니다. 서버 이름 인수는 텍스트입니다. 국제화 된 도메인 이름의 경우 서버 이름은 IDN A 레이블 ( &lt;code&gt;&quot;xn--pythn-mua.org&quot;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="cd8e655e9eed9b74bde977375823ab681334e73c" translate="yes" xml:space="preserve">
          <source>The callback will be invoked by &lt;em&gt;loop&lt;/em&gt;, along with other queued callbacks and runnable coroutines of that event loop. Unlike signal handlers registered using &lt;a href=&quot;signal#signal.signal&quot;&gt;&lt;code&gt;signal.signal()&lt;/code&gt;&lt;/a&gt;, a callback registered with this function is allowed to interact with the event loop.</source>
          <target state="translated">콜백은 대기중인 다른 콜백 및 해당 이벤트 루프의 실행 가능한 코 루틴과 함께 &lt;em&gt;loop&lt;/em&gt; 에 의해 호출됩니다 . &lt;a href=&quot;signal#signal.signal&quot;&gt; &lt;code&gt;signal.signal()&lt;/code&gt; &lt;/a&gt; 사용하여 등록 된 신호 처리기와 달리이 함수로 등록 된 콜백은 이벤트 루프와 상호 작용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22bd53399975bb33fc06872aa0715a547b88ac9e" translate="yes" xml:space="preserve">
          <source>The caller may release or mutate &lt;em&gt;b&lt;/em&gt; after this method returns, so the implementation should only access &lt;em&gt;b&lt;/em&gt; during the method call.</source>
          <target state="translated">호출자는 이 메소드가 리턴 된 후 &lt;em&gt;b를&lt;/em&gt; 해제하거나 변경할 수 있으므로 구현은 메소드 호출 중 &lt;em&gt;b&lt;/em&gt; 에만 액세스해야합니다 .</target>
        </trans-unit>
        <trans-unit id="84f728122cbc2164626d67a5c5bfe8cd2b6d9334" translate="yes" xml:space="preserve">
          <source>The calltip consists of the function&amp;rsquo;s signature and docstring up to the latter&amp;rsquo;s first blank line or the fifth non-blank line. (Some builtin functions lack an accessible signature.) A &amp;lsquo;/&amp;rsquo; or &amp;lsquo;*&amp;rsquo; in the signature indicates that the preceding or following arguments are passed by position or name (keyword) only. Details are subject to change.</source>
          <target state="translated">The calltip consists of the function&amp;rsquo;s signature and docstring up to the latter&amp;rsquo;s first blank line or the fifth non-blank line. (Some builtin functions lack an accessible signature.) A &amp;lsquo;/&amp;rsquo; or &amp;lsquo;*&amp;rsquo; in the signature indicates that the preceding or following arguments are passed by position or name (keyword) only. Details are subject to change.</target>
        </trans-unit>
        <trans-unit id="eff6d403c84e9dd6cfb7f05890938d3f3448560b" translate="yes" xml:space="preserve">
          <source>The canonical form of the filename which contains the frame.</source>
          <target state="translated">프레임을 포함하는 파일 이름의 표준 형식입니다.</target>
        </trans-unit>
        <trans-unit id="c8533238eda8a62e9128958e4776c77a39312314" translate="yes" xml:space="preserve">
          <source>The canonical name of this HMAC, always lowercase, e.g. &lt;code&gt;hmac-md5&lt;/code&gt;.</source>
          <target state="translated">이 HMAC의 정식 이름은 항상 소문자입니다 (예 : &lt;code&gt;hmac-md5&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="ff8c6491e39ff96156d9120d3205f0365e5d01cf" translate="yes" xml:space="preserve">
          <source>The canonical name of this hash, always lowercase and always suitable as a parameter to &lt;a href=&quot;#hashlib.new&quot;&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/a&gt; to create another hash of this type.</source>
          <target state="translated">이 해시의 정식 이름은 항상 소문자이며 항상 이 유형의 다른 해시를 작성하기위한 &lt;a href=&quot;#hashlib.new&quot;&gt; &lt;code&gt;new()&lt;/code&gt; &lt;/a&gt; 의 매개 변수로 적합 합니다.</target>
        </trans-unit>
        <trans-unit id="86383e1461d35f27675e6567047706ab486a7820" translate="yes" xml:space="preserve">
          <source>The casefolding algorithm is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">케이스 폴딩 알고리즘은 유니 코드 표준의 3.13 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09bc2e18042eda7d06b3a19559cc299378be13d8" translate="yes" xml:space="preserve">
          <source>The ceiling for the process&amp;rsquo;s nice level (calculated as 20 - rlim_cur).</source>
          <target state="translated">프로세스의 적정 수준의 상한 (20-rlim_cur로 계산).</target>
        </trans-unit>
        <trans-unit id="8ce6ab2c12963a27ddd741a54afdd9198d059d94" translate="yes" xml:space="preserve">
          <source>The ceiling of the real-time priority.</source>
          <target state="translated">실시간 우선 순위의 한도.</target>
        </trans-unit>
        <trans-unit id="639203ac4f7750e330cf2cd16c6fd78a1b956598" translate="yes" xml:space="preserve">
          <source>The central class in the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package is the &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class, imported from the &lt;a href=&quot;#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt; module. It is the base class for the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; object model. &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the core functionality for setting and querying header fields, for accessing message bodies, and for creating or modifying structured messages.</source>
          <target state="translated">에서 중앙 클래스 &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는이다 &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 으로부터 수입 클래스, &lt;a href=&quot;#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 의&lt;/a&gt; 모듈. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 객체 모델 의 기본 클래스입니다 . &lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 는 헤더 필드 설정 및 조회, 메시지 본문 액세스 및 구조화 된 메시지 작성 또는 수정을위한 핵심 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4e36386588c7d08f4857bc3785fb1d4d5c17d9fa" translate="yes" xml:space="preserve">
          <source>The central component of the package is an &amp;ldquo;object model&amp;rdquo; that represents email messages. An application interacts with the package primarily through the object model interface defined in the &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;message&lt;/code&gt;&lt;/a&gt; sub-module. The application can use this API to ask questions about an existing email, to construct a new email, or to add or remove email subcomponents that themselves use the same object model interface. That is, following the nature of email messages and their MIME subcomponents, the email object model is a tree structure of objects that all provide the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; API.</source>
          <target state="translated">패키지의 핵심 구성 요소는 전자 메일 메시지를 나타내는 &quot;개체 모델&quot;입니다. 응용 프로그램은 주로 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;message&lt;/code&gt; &lt;/a&gt; 하위 모듈에 정의 된 개체 모델 인터페이스를 통해 패키지와 상호 작용 합니다. 애플리케이션은이 API를 사용하여 기존 이메일에 대한 질문을하거나 새 이메일을 작성하거나 동일한 오브젝트 모델 인터페이스를 사용하는 이메일 하위 구성 요소를 추가 또는 제거 할 수 있습니다. 즉, 전자 메일 메시지 및 해당 MIME 하위 구성 요소의 특성에 따라 전자 메일 개체 모델은 모두 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; API를 제공하는 개체의 트리 구조입니다 .</target>
        </trans-unit>
        <trans-unit id="b8ad1ef8b31c9d3d4272c53dd49dd5587dde6ea9" translate="yes" xml:space="preserve">
          <source>The channel continues to collect data forever</source>
          <target state="translated">채널은 계속해서 데이터를 수집합니다</target>
        </trans-unit>
        <trans-unit id="990b5a1da94f1bd10326a2f8f9f4f2d725871e25" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search path components (as in &lt;code id=&quot;index-44&quot;&gt;PATH&lt;/code&gt;), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 또는 &lt;code&gt;';'&lt;/code&gt; &lt;code&gt;':'&lt;/code&gt; 경우 ':' 와 같이 검색 경로 구성 요소를 분리하기 위해 운영 체제에서 일반적으로 사용하는 문자입니다 ( &lt;code id=&quot;index-44&quot;&gt;PATH&lt;/code&gt; 와 같이) . Windows 용. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="716210fcc9aa0e92a7aeddcad3baa26c435be48c" translate="yes" xml:space="preserve">
          <source>The character conventionally used by the operating system to separate search path components (as in &lt;code id=&quot;index-46&quot;&gt;PATH&lt;/code&gt;), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The character conventionally used by the operating system to separate search path components (as in &lt;code id=&quot;index-46&quot;&gt;PATH&lt;/code&gt; ), such as &lt;code&gt;':'&lt;/code&gt; for POSIX or &lt;code&gt;';'&lt;/code&gt; for Windows. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3d99da8fe6d18c618150889ebc5804acc1de27a2" translate="yes" xml:space="preserve">
          <source>The character encoding is platform-dependent. Non-Windows platforms use the locale encoding (see &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt;&lt;code&gt;locale.getpreferredencoding()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자 인코딩은 플랫폼에 따라 다릅니다. Windows 이외의 플랫폼은 로케일 인코딩을 사용합니다 ( &lt;a href=&quot;locale#locale.getpreferredencoding&quot;&gt; &lt;code&gt;locale.getpreferredencoding()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="bfc93a686eda7c49ec3507891da13ae0c98e36c9" translate="yes" xml:space="preserve">
          <source>The character set, &lt;a href=&quot;string#string.ascii_letters&quot;&gt;&lt;code&gt;string.ascii_letters&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;string#string.digits&quot;&gt;&lt;code&gt;string.digits&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;!#$%&amp;amp;'*+-.^_`|~:&lt;/code&gt; denote the set of valid characters allowed by this module in Cookie name (as &lt;a href=&quot;#http.cookies.Morsel.key&quot;&gt;&lt;code&gt;key&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">문자 세트, &lt;a href=&quot;string#string.ascii_letters&quot;&gt; &lt;code&gt;string.ascii_letters&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;string#string.digits&quot;&gt; &lt;code&gt;string.digits&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;!#$%&amp;amp;'*+-.^_`|~:&lt;/code&gt; 는 쿠키 이름에서이 모듈이 허용하는 유효한 문자 세트를 &lt;a href=&quot;#http.cookies.Morsel.key&quot;&gt; &lt;code&gt;key&lt;/code&gt; &lt;/a&gt; 이름으로 나타냅니다 ( 키로 ).</target>
        </trans-unit>
        <trans-unit id="f3c8562e2db6ea59a857d6692fcd05b5595aad09" translate="yes" xml:space="preserve">
          <source>The character used by the operating system to separate pathname components. This is &lt;code&gt;'/'&lt;/code&gt; for POSIX and &lt;code&gt;'\\'&lt;/code&gt; for Windows. Note that knowing this is not sufficient to be able to parse or concatenate pathnames &amp;mdash; use &lt;a href=&quot;os.path#os.path.split&quot;&gt;&lt;code&gt;os.path.split()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt; &amp;mdash; but it is occasionally useful. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로 이름 구성 요소를 구분하기 위해 운영 체제에서 사용하는 문자입니다. 이다 &lt;code&gt;'/'&lt;/code&gt; POSIX 및 대한 &lt;code&gt;'\\'&lt;/code&gt; Windows 용. 이것을 아는 것만으로는 경로명을 구문 분석하거나 연결하기에 충분하지 않습니다 &lt;a href=&quot;os.path#os.path.split&quot;&gt; &lt;code&gt;os.path.split()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; . 때때로 유용합니다. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="309bb84393dbc6c91d360c133c257980087f7321" translate="yes" xml:space="preserve">
          <source>The character used to draw separator lines under the help-message headers. If empty, no ruler line is drawn. It defaults to &lt;code&gt;'='&lt;/code&gt;.</source>
          <target state="translated">도움말 메시지 헤더 아래에 구분선을 그리는 데 사용되는 문자입니다. 비어 있으면 눈금자 선이 그려지지 않습니다. 기본값은 &lt;code&gt;'='&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ea51325acbd5404b45bf3a9645468bed81b871e" translate="yes" xml:space="preserve">
          <source>The character which separates the base filename from the extension; for example, the &lt;code&gt;'.'&lt;/code&gt; in &lt;code&gt;os.py&lt;/code&gt;. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 파일 이름을 확장자와 구분하는 문자입니다. 예를 들어 &lt;code&gt;'.'&lt;/code&gt; 에 &lt;code&gt;os.py&lt;/code&gt; . &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="f625dcb310956d459da71c49e55907d5aaf7c87f" translate="yes" xml:space="preserve">
          <source>The child process is not killed if the timeout expires, so in order to cleanup properly a well-behaved application should kill the child process and finish communication:</source>
          <target state="translated">제한 시간이 만료되면 하위 프로세스가 종료되지 않으므로 올바르게 정리하려면 올바르게 작동하는 응용 프로그램이 하위 프로세스를 종료하고 통신을 완료해야합니다.</target>
        </trans-unit>
        <trans-unit id="6548909ff9d18497967c143ac6e0f73e274ac502" translate="yes" xml:space="preserve">
          <source>The child return code, set by &lt;a href=&quot;#subprocess.Popen.poll&quot;&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#subprocess.Popen.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; (and indirectly by &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;communicate()&lt;/code&gt;&lt;/a&gt;). A &lt;code&gt;None&lt;/code&gt; value indicates that the process hasn&amp;rsquo;t terminated yet.</source>
          <target state="translated">설정 한 자식 리턴 코드, &lt;a href=&quot;#subprocess.Popen.poll&quot;&gt; &lt;code&gt;poll()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#subprocess.Popen.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; (간접적으로 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;communicate()&lt;/code&gt; &lt;/a&gt; ). &lt;code&gt;None&lt;/code&gt; 값은 프로세스가 아직 종료되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="249b5d2d494ab6f926a71d2362ead22383753022" translate="yes" xml:space="preserve">
          <source>The child&amp;rsquo;s exit code. This will be &lt;code&gt;None&lt;/code&gt; if the process has not yet terminated. A negative value &lt;em&gt;-N&lt;/em&gt; indicates that the child was terminated by signal &lt;em&gt;N&lt;/em&gt;.</source>
          <target state="translated">자녀의 종료 코드. 이 없을 것 &lt;code&gt;None&lt;/code&gt; 프로세스가 아직 종료되지 않은 경우. 음수 값 &lt;em&gt;-N&lt;/em&gt; 은 자식이 신호 &lt;em&gt;N에&lt;/em&gt; 의해 종료되었음을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9af0a298b9377133612268a925c4f34815a13348" translate="yes" xml:space="preserve">
          <source>The children are yielded in arbitrary order, and the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are not included. If a file is removed from or added to the directory after creating the iterator, whether an path object for that file be included is unspecified.</source>
          <target state="translated">The children are yielded in arbitrary order, and the special entries &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;'..'&lt;/code&gt; are not included. If a file is removed from or added to the directory after creating the iterator, whether an path object for that file be included is unspecified.</target>
        </trans-unit>
        <trans-unit id="0c7e9fdca9f228eaff4bb459dac6747ec6ddefb6" translate="yes" xml:space="preserve">
          <source>The choice of which database package will be used (such as &lt;a href=&quot;dbm#module-dbm.ndbm&quot;&gt;&lt;code&gt;dbm.ndbm&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;dbm#module-dbm.gnu&quot;&gt;&lt;code&gt;dbm.gnu&lt;/code&gt;&lt;/a&gt;) depends on which interface is available. Therefore it is not safe to open the database directly using &lt;a href=&quot;dbm#module-dbm&quot;&gt;&lt;code&gt;dbm&lt;/code&gt;&lt;/a&gt;. The database is also (unfortunately) subject to the limitations of &lt;a href=&quot;dbm#module-dbm&quot;&gt;&lt;code&gt;dbm&lt;/code&gt;&lt;/a&gt;, if it is used &amp;mdash; this means that (the pickled representation of) the objects stored in the database should be fairly small, and in rare cases key collisions may cause the database to refuse updates.</source>
          <target state="translated">사용할 데이터베이스 패키지 ( &lt;a href=&quot;dbm#module-dbm.ndbm&quot;&gt; &lt;code&gt;dbm.ndbm&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;dbm#module-dbm.gnu&quot;&gt; &lt;code&gt;dbm.gnu&lt;/code&gt; 등&lt;/a&gt; )의 선택은 사용 가능한 인터페이스에 따라 다릅니다. 따라서 &lt;a href=&quot;dbm#module-dbm&quot;&gt; &lt;code&gt;dbm&lt;/code&gt; 을&lt;/a&gt; 사용하여 데이터베이스를 직접 여는 것은 안전하지 않습니다 . 데이터베이스는 (불행히도) &lt;a href=&quot;dbm#module-dbm&quot;&gt; &lt;code&gt;dbm&lt;/code&gt; &lt;/a&gt; 이 사용되는 경우 제한 사항에 종속 됩니다. 이는 데이터베이스에 저장된 객체의 (선택된 표현)이 상당히 작아야하며 드물게 키 충돌로 인해 데이터베이스가 손상 될 수 있음을 의미합니다. 업데이트를 거부합니다.</target>
        </trans-unit>
        <trans-unit id="641b5aed9850d067945c10edf2925a45f43bfb8b" translate="yes" xml:space="preserve">
          <source>The chronological synopsis of the underlying operation is as follows:</source>
          <target state="translated">기본 조작의 시간순으로 시놉시스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5e64182f2236479d6838cc99f8595dca788e504" translate="yes" xml:space="preserve">
          <source>The class &lt;a href=&quot;#msilib.CAB&quot;&gt;&lt;code&gt;CAB&lt;/code&gt;&lt;/a&gt; represents a CAB file. During MSI construction, files will be added simultaneously to the &lt;code&gt;Files&lt;/code&gt; table, and to a CAB file. Then, when all files have been added, the CAB file can be written, then added to the MSI file.</source>
          <target state="translated">&lt;a href=&quot;#msilib.CAB&quot;&gt; &lt;code&gt;CAB&lt;/code&gt; &lt;/a&gt; 클래스 는 CAB 파일을 나타냅니다. MSI 구성 중에 파일은 &lt;code&gt;Files&lt;/code&gt; 테이블과 CAB 파일 에 동시에 추가 됩니다. 그런 다음 모든 파일이 추가되면 CAB 파일을 작성한 다음 MSI 파일에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc389f3d71edbec0527ca0760a3cd2d7c5166d0" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;Color&lt;/code&gt; is an &lt;em&gt;enumeration&lt;/em&gt; (or &lt;em&gt;enum&lt;/em&gt;)</source>
          <target state="translated">&lt;code&gt;Color&lt;/code&gt; 클래스 는 &lt;em&gt;열거 형입니다&lt;/em&gt; (또는 &lt;em&gt;열거 형&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="f9d013c76081da9c5c270257f29700914efbf655" translate="yes" xml:space="preserve">
          <source>The class attribute &lt;code&gt;C.z&lt;/code&gt; will be &lt;code&gt;10&lt;/code&gt;, the class attribute &lt;code&gt;C.t&lt;/code&gt; will be &lt;code&gt;20&lt;/code&gt;, and the class attributes &lt;code&gt;C.x&lt;/code&gt; and &lt;code&gt;C.y&lt;/code&gt; will not be set.</source>
          <target state="translated">클래스 속성 &lt;code&gt;C.z&lt;/code&gt; 는 &lt;code&gt;10&lt;/code&gt; 이고 클래스 속성 &lt;code&gt;C.t&lt;/code&gt; 는 &lt;code&gt;20&lt;/code&gt; 이며 클래스 속성 &lt;code&gt;C.x&lt;/code&gt; 및 &lt;code&gt;C.y&lt;/code&gt; 는 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35421f70e067873d5f1e6c9a350a9cd53c04e5f2" translate="yes" xml:space="preserve">
          <source>The class can be used to simulate nested scopes and is useful in templating.</source>
          <target state="translated">이 클래스는 중첩 범위를 시뮬레이션하는 데 사용할 수 있으며 템플릿에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="36961ba5b73fc5b81b86c2c4a82a8030e61ec555" translate="yes" xml:space="preserve">
          <source>The class for reading and writing ZIP files. See section &lt;a href=&quot;#zipfile-objects&quot;&gt;ZipFile Objects&lt;/a&gt; for constructor details.</source>
          <target state="translated">ZIP 파일을 읽고 쓰는 클래스입니다. 생성자 세부 사항은 &lt;a href=&quot;#zipfile-objects&quot;&gt;ZipFile 객체&lt;/a&gt; 섹션을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="0307e59dd4313119463d297b8087437a252b55eb" translate="yes" xml:space="preserve">
          <source>The class has one attribute:</source>
          <target state="translated">The class has one attribute:</target>
        </trans-unit>
        <trans-unit id="d13bab7dac8afe400af05e5ac5c428448bda17c6" translate="yes" xml:space="preserve">
          <source>The class hierarchy for built-in exceptions is:</source>
          <target state="translated">내장 예외의 클래스 계층 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f62ddfd2faaa7f84859ae34b4dabf08d739e4525" translate="yes" xml:space="preserve">
          <source>The class hierarchy looks complicated, but in actual practice, application programmers almost always refer to the classes at the very bottom of the hierarchy.</source>
          <target state="translated">클래스 계층 구조는 복잡해 보이지만 실제로는 응용 프로그램 프로그래머는 거의 항상 계층 구조의 맨 아래에있는 클래스를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="11acc8f9993621da6ab27b43e0137b38b7b7a4a1" translate="yes" xml:space="preserve">
          <source>The class implementing primitive lock objects. Once a thread has acquired a lock, subsequent attempts to acquire it block, until it is released; any thread may release it.</source>
          <target state="translated">기본 잠금 객체를 구현하는 클래스입니다. 스레드가 잠금을 획득하면 이후에 해제 될 때까지 해당 블록을 확보하려고 시도합니다. 실이 풀릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef66003d51e216bb78a2d8467a0936166bacf799" translate="yes" xml:space="preserve">
          <source>The class is designed to easily support parallel processing of the nodes as they become ready. For instance:</source>
          <target state="translated">The class is designed to easily support parallel processing of the nodes as they become ready. For instance:</target>
        </trans-unit>
        <trans-unit id="97d60cfb78fc29a2188c1e8e530bba513612e7fc" translate="yes" xml:space="preserve">
          <source>The class must define one of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;. In addition, the class should supply an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt; 중 하나를 정의해야합니다 . 또한 클래스는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 메서드를 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a862b9e810d8086555b97234b47771d59ab40bb0" translate="yes" xml:space="preserve">
          <source>The class must define one of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;__lt__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt;&lt;code&gt;__le__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt;&lt;code&gt;__gt__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt;&lt;code&gt;__ge__()&lt;/code&gt;&lt;/a&gt;. In addition, the class should supply an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">The class must define one of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;__lt__()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__le__&quot;&gt; &lt;code&gt;__le__()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__gt__&quot;&gt; &lt;code&gt;__gt__()&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ge__&quot;&gt; &lt;code&gt;__ge__()&lt;/code&gt; &lt;/a&gt;. In addition, the class should supply an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; method.</target>
        </trans-unit>
        <trans-unit id="a554b687dbf11ba71cc8de41c11ea71e511af98b" translate="yes" xml:space="preserve">
          <source>The class of the original traceback.</source>
          <target state="translated">원래 역 추적의 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6f41a7aa24987af381eb3cfdc36177bde5d48ab8" translate="yes" xml:space="preserve">
          <source>The class of the result returned by &lt;a href=&quot;#multiprocessing.pool.Pool.apply_async&quot;&gt;&lt;code&gt;Pool.apply_async()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.pool.Pool.map_async&quot;&gt;&lt;code&gt;Pool.map_async()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool.apply_async&quot;&gt; &lt;code&gt;Pool.apply_async()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.pool.Pool.map_async&quot;&gt; &lt;code&gt;Pool.map_async()&lt;/code&gt; &lt;/a&gt; 반환 한 결과의 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f996acfc2842340ff19f3be54d9a7bbdc048eb8b" translate="yes" xml:space="preserve">
          <source>The class provides the following concrete implementations of the abstract methods of &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 의 추상 메소드를 다음과 같이 구체적으로 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5dccf24c2a64fd1d1642a87c5b4ceefbc8b4548b" translate="yes" xml:space="preserve">
          <source>The class setting can be overridden in individual test methods by assigning an instance attribute, self.longMessage, to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; before calling the assert methods.</source>
          <target state="translated">assert 메소드를 호출하기 전에 인스턴스 속성 self.longMessage를 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 에 지정하여 개별 테스트 메소드에서 클래스 설정을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4fb7f174a74b65f3dd94a096df16ea30953a0068" translate="yes" xml:space="preserve">
          <source>The class setting gets reset before each test call.</source>
          <target state="translated">클래스 설정은 각 테스트 호출 전에 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9f589d651376efd47cd3c71b4a534513e314e255" translate="yes" xml:space="preserve">
          <source>The class to which a class instance belongs.</source>
          <target state="translated">클래스 인스턴스가 속한 클래스</target>
        </trans-unit>
        <trans-unit id="355cb42d141ca89adac71b050c3ab2434b32b6ee" translate="yes" xml:space="preserve">
          <source>The class used to represent an address group. The general form of an address group is:</source>
          <target state="translated">주소 그룹을 나타내는 데 사용되는 클래스입니다. 주소 그룹의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e4a0b7dcb2051eb55138851ecdd24023ca364443" translate="yes" xml:space="preserve">
          <source>The class used to represent an email address. The general form of an address is:</source>
          <target state="translated">이메일 주소를 나타내는 데 사용되는 클래스입니다. 주소의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bfa706500f9a8aaf4d9b36f7e8cf2f4edccd139d" translate="yes" xml:space="preserve">
          <source>The class which implements the sequence behavior provided by the module is available for subclassing as well:</source>
          <target state="translated">모듈이 제공하는 시퀀스 동작을 구현하는 클래스는 서브 클래 싱에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aae6ed8b229fce1c1f5a84dd0061e129c39af6d2" translate="yes" xml:space="preserve">
          <source>The class will however, run the CGI script, instead of serving it as a file, if it guesses it to be a CGI script. Only directory-based CGI are used &amp;mdash; the other common server configuration is to treat special extensions as denoting CGI scripts.</source>
          <target state="translated">그러나 클래스는 CGI 스크립트라고 생각되면 파일로 제공하는 대신 CGI 스크립트를 실행합니다. 디렉토리 기반 CGI 만 사용됩니다. 다른 일반적인 서버 구성은 특수 확장을 CGI 스크립트를 나타내는 것으로 취급하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14895e9455625ea3905a043291b8d94e88a9a62c" translate="yes" xml:space="preserve">
          <source>The class, &lt;a href=&quot;#collections.UserDict&quot;&gt;&lt;code&gt;UserDict&lt;/code&gt;&lt;/a&gt; acts as a wrapper around dictionary objects. The need for this class has been partially supplanted by the ability to subclass directly from &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt;; however, this class can be easier to work with because the underlying dictionary is accessible as an attribute.</source>
          <target state="translated">&lt;a href=&quot;#collections.UserDict&quot;&gt; &lt;code&gt;UserDict&lt;/code&gt; &lt;/a&gt; 클래스는 사전 개체 주위의 래퍼 역할을합니다. 이 클래스의 필요성은 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 에서 직접 서브 클래스 할 수있는 기능으로 부분적으로 대체되었습니다 . 그러나 기본 사전에 속성으로 액세스 할 수 있으므로이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d174a1d7f851da4b93f967fb6954b8658cb60437" translate="yes" xml:space="preserve">
          <source>The class, &lt;a href=&quot;#collections.UserString&quot;&gt;&lt;code&gt;UserString&lt;/code&gt;&lt;/a&gt; acts as a wrapper around string objects. The need for this class has been partially supplanted by the ability to subclass directly from &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;; however, this class can be easier to work with because the underlying string is accessible as an attribute.</source>
          <target state="translated">&lt;a href=&quot;#collections.UserString&quot;&gt; &lt;code&gt;UserString&lt;/code&gt; &lt;/a&gt; 클래스는 문자열 객체의 래퍼 역할을합니다. 이 클래스에 대한 요구는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 에서 직접 서브 클래스 할 수있는 기능으로 부분적으로 대체되었습니다 . 그러나 기본 문자열을 속성으로 액세스 할 수 있으므로이 클래스를 사용하면 작업하기가 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5500c02e097010b4c8f6204fff9a65578fc826eb" translate="yes" xml:space="preserve">
          <source>The class-based API of the &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module gives you more flexibility and greater convenience than the GNU &lt;strong&gt;gettext&lt;/strong&gt; API. It is the recommended way of localizing your Python applications and modules. &lt;code&gt;gettext&lt;/code&gt; defines a &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt; class which implements the parsing of GNU &lt;code&gt;.mo&lt;/code&gt; format files, and has methods for returning strings. Instances of this class can also install themselves in the built-in namespace as the function &lt;code&gt;_()&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈 의 클래스 기반 API 는 GNU &lt;strong&gt;gettext&lt;/strong&gt; API 보다 더 많은 유연성과 편리 성을 제공합니다 . Python 응용 프로그램 및 모듈을 지역화하는 것이 좋습니다. &lt;code&gt;gettext&lt;/code&gt; 는 GNU &lt;code&gt;.mo&lt;/code&gt; 형식 파일 의 구문 분석을 구현하고 문자열을 리턴하는 메소드가 있는 &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; &lt;/a&gt; 클래스를 정의합니다 . 이 클래스의 인스턴스는 내장 네임 스페이스에 &lt;code&gt;_()&lt;/code&gt; 함수로 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c13471f17673e1d2e66bc6085c5a5e90090a6bc9" translate="yes" xml:space="preserve">
          <source>The client code for the preceding server:</source>
          <target state="translated">이전 서버의 클라이언트 코드 :</target>
        </trans-unit>
        <trans-unit id="b1f854376f85fdbc545caa4175dd50a74dcba07c" translate="yes" xml:space="preserve">
          <source>The client gets the image and saves it to a file:</source>
          <target state="translated">클라이언트는 이미지를 가져 와서 파일로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="4ab7c3dd55c07004f21171421d1885b6e9798e35" translate="yes" xml:space="preserve">
          <source>The client that interacts with the above server is included in &lt;code&gt;Lib/xmlrpc/client.py&lt;/code&gt;:</source>
          <target state="translated">위의 서버와 상호 작용하는 클라이언트는 &lt;code&gt;Lib/xmlrpc/client.py&lt;/code&gt; 에 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="608024e3b56c218bd3b7db1f81cc2c4367596096" translate="yes" xml:space="preserve">
          <source>The clipboard functions are also available in context menus.</source>
          <target state="translated">클립 보드 기능은 상황에 맞는 메뉴에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60463a3de47534f196bb050046587ea8de1a88f2" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.combinations&quot;&gt;&lt;code&gt;combinations()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.permutations&quot;&gt;&lt;code&gt;permutations()&lt;/code&gt;&lt;/a&gt; after filtering entries where the elements are not in sorted order (according to their position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.combinations&quot;&gt; &lt;code&gt;combinations()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 요소가 정렬 된 순서가 아닌 항목을 필터링 한 후 (입력 풀의 위치에 따라 &lt;a href=&quot;#itertools.permutations&quot;&gt; &lt;code&gt;permutations()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42d5eab0dfe9ab9a1feea6f7f8bc6b66cd010c25" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.combinations_with_replacement&quot;&gt;&lt;code&gt;combinations_with_replacement()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; after filtering entries where the elements are not in sorted order (according to their position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.combinations_with_replacement&quot;&gt; &lt;code&gt;combinations_with_replacement()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 요소가 정렬 된 순서가 아닌 항목을 필터링 한 후 (입력 풀의 위치에 따라 &lt;a href=&quot;#itertools.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d24621b4d5417bdfdf2582fa71fca0ab60793e2" translate="yes" xml:space="preserve">
          <source>The code for &lt;a href=&quot;#itertools.permutations&quot;&gt;&lt;code&gt;permutations()&lt;/code&gt;&lt;/a&gt; can be also expressed as a subsequence of &lt;a href=&quot;#itertools.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt;, filtered to exclude entries with repeated elements (those from the same position in the input pool):</source>
          <target state="translated">&lt;a href=&quot;#itertools.permutations&quot;&gt; &lt;code&gt;permutations()&lt;/code&gt; &lt;/a&gt; 대한 코드 는 &lt;a href=&quot;#itertools.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 의 하위 시퀀스로 표현 될 수 있으며 반복되는 요소가있는 항목을 제외하도록 필터링됩니다 (입력 풀의 동일한 위치에있는 항목).</target>
        </trans-unit>
        <trans-unit id="703d509dc902a2797f32a1cd580178bc07de8485" translate="yes" xml:space="preserve">
          <source>The code for the sample CGI used in the above example is:</source>
          <target state="translated">위 예제에서 사용한 샘플 CGI 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85fb1e301318f4a3be03adcd9de36da57823dfa5" translate="yes" xml:space="preserve">
          <source>The code handling the FTP protocol cannot differentiate between a file and a directory. This can lead to unexpected behavior when attempting to read a URL that points to a file that is not accessible. If the URL ends in a &lt;code&gt;/&lt;/code&gt;, it is assumed to refer to a directory and will be handled accordingly. But if an attempt to read a file leads to a 550 error (meaning the URL cannot be found or is not accessible, often for permission reasons), then the path is treated as a directory in order to handle the case when a directory is specified by a URL but the trailing &lt;code&gt;/&lt;/code&gt; has been left off. This can cause misleading results when you try to fetch a file whose read permissions make it inaccessible; the FTP code will try to read it, fail with a 550 error, and then perform a directory listing for the unreadable file. If fine-grained control is needed, consider using the &lt;a href=&quot;ftplib#module-ftplib&quot;&gt;&lt;code&gt;ftplib&lt;/code&gt;&lt;/a&gt; module, subclassing &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt;, or changing &lt;em&gt;_urlopener&lt;/em&gt; to meet your needs.</source>
          <target state="translated">FTP 프로토콜을 처리하는 코드는 파일과 디렉토리를 구별 할 수 없습니다. 액세스 할 수없는 파일을 가리키는 URL을 읽으려고하면 예기치 않은 동작이 발생할 수 있습니다. URL이 &lt;code&gt;/&lt;/code&gt; 로 끝나는 경우 디렉토리를 참조하는 것으로 간주되어 그에 따라 처리됩니다. 그러나 파일을 읽으려고 시도 할 때 550 오류가 발생하는 경우 (URL을 찾을 수 없거나 액세스 권한이없는 경우가 많음) 디렉토리가 지정된 경우를 처리하기 위해 경로가 디렉토리로 처리됩니다. URL을 제외한 후행 &lt;code&gt;/&lt;/code&gt; 중단되었습니다. 읽기 권한이있는 파일을 가져올 수없는 경우 잘못된 결과가 발생할 수 있습니다. FTP 코드가이를 읽으려고 시도하고 550 오류와 함께 실패한 다음 읽을 수없는 파일에 대한 디렉토리 목록을 수행합니다. 세분화 된 제어가 필요한 경우 &lt;a href=&quot;ftplib#module-ftplib&quot;&gt; &lt;code&gt;ftplib&lt;/code&gt; &lt;/a&gt; 모듈 사용, &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 서브 클래 싱 또는 &lt;em&gt;_urlopener&lt;/em&gt; 변경을 &lt;em&gt;고려&lt;/em&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="4fd6893c62a4fe9dae88f1c3b04f9d6d6548dc2b" translate="yes" xml:space="preserve">
          <source>The code object has a variable keyword parameter (&lt;code&gt;**kwargs&lt;/code&gt;-like).</source>
          <target state="translated">코드 객체에는 변수 키워드 매개 변수 ( &lt;code&gt;**kwargs&lt;/code&gt; -like)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0979e7acdfaef407b5b5097fc26f4a26bcb8cdf1" translate="yes" xml:space="preserve">
          <source>The code object has a variable positional parameter (&lt;code&gt;*args&lt;/code&gt;-like).</source>
          <target state="translated">코드 객체에는 가변 위치 매개 변수 ( &lt;code&gt;*args&lt;/code&gt; -like)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="080cac35a0f36ed235e2876fd22854eef029be12" translate="yes" xml:space="preserve">
          <source>The code object is optimized, using fast locals.</source>
          <target state="translated">코드 객체는 빠른 로컬을 사용하여 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="47a377ea1cb4376dfc822cfb1e3d5bc1d7585dd2" translate="yes" xml:space="preserve">
          <source>The code supports &lt;a href=&quot;https://tools.ietf.org/html/rfc5321.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5321&lt;/strong&gt;&lt;/a&gt;, plus the &lt;a href=&quot;https://tools.ietf.org/html/rfc1870.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1870&lt;/strong&gt;&lt;/a&gt; SIZE and &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; SMTPUTF8 extensions.</source>
          <target state="translated">이 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5321.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5321&lt;/strong&gt;&lt;/a&gt; 과 &lt;a href=&quot;https://tools.ietf.org/html/rfc1870.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1870&lt;/strong&gt;&lt;/a&gt; SIZE 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; SMTPUTF8 확장을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="4817874f40ce2ab856a7cb1cf5cd601ddcb8bfd6" translate="yes" xml:space="preserve">
          <source>The collections module offers the following &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;ABCs&lt;/a&gt;:</source>
          <target state="translated">컬렉션 모듈은 다음 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;ABC를&lt;/a&gt; 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b5c5836457aa5e87fb87c4d5e999582100548205" translate="yes" xml:space="preserve">
          <source>The collections module offers the following &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-abstract-base-class&quot;&gt;ABCs&lt;/a&gt;:</source>
          <target state="translated">The collections module offers the following &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-abstract-base-class&quot;&gt;ABCs&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="3e84acb27476c2c05eba0a4f4a824cd8ec501c13" translate="yes" xml:space="preserve">
          <source>The column corresponding to &lt;em&gt;pos&lt;/em&gt; (may be &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 열입니다 ( &lt;code&gt;None&lt;/code&gt; 일 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="a56243341a69d0e12d71b0d910747be9b8112c7b" translate="yes" xml:space="preserve">
          <source>The column corresponding to &lt;em&gt;pos&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;pos에&lt;/em&gt; 해당하는 열 입니다.</target>
        </trans-unit>
        <trans-unit id="20a73c1901f7e6b3d6e485b823b0e3a3a85d3b98" translate="yes" xml:space="preserve">
          <source>The combination tuples are emitted in lexicographic ordering according to the order of the input &lt;em&gt;iterable&lt;/em&gt;. So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the combination tuples will be produced in sorted order.</source>
          <target state="translated">The combination tuples are emitted in lexicographic ordering according to the order of the input &lt;em&gt;iterable&lt;/em&gt;. So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the combination tuples will be produced in sorted order.</target>
        </trans-unit>
        <trans-unit id="52291400b098238a6b1adf88eaf1c290f1adcf33" translate="yes" xml:space="preserve">
          <source>The combobox widgets generates a &lt;strong&gt;&amp;lt;&amp;lt;ComboboxSelected&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user selects an element from the list of values.</source>
          <target state="translated">콤보 박스 위젯 은 사용자가 값 목록에서 요소를 선택할 때 &lt;strong&gt;&amp;lt;&amp;lt; ComboboxSelected &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="0a0ffc5780ada254563235dcef8afc5b94088687" translate="yes" xml:space="preserve">
          <source>The command line can also be used for test discovery, for running all of the tests in a project or just a subset.</source>
          <target state="translated">명령 줄은 프로젝트에서 또는 모든 하위 집합에서 모든 테스트를 실행하기 위해 테스트 검색에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d6a9ddd026e421ebebeb4fd4a12d14a163fea6c" translate="yes" xml:space="preserve">
          <source>The command line interface is invoked using the interpreter&amp;rsquo;s &lt;code&gt;-m&lt;/code&gt; switch.</source>
          <target state="translated">명령 행 인터페이스는 인터프리터의 &lt;code&gt;-m&lt;/code&gt; 스위치를 사용하여 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="0ad815c39bd5fc01a37786842578018d08d7a616" translate="yes" xml:space="preserve">
          <source>The command or option attempted is not supported by the server.</source>
          <target state="translated">시도한 명령 또는 옵션이 서버에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b2372b300214e5a9d80b5b465939fec489d9cce" translate="yes" xml:space="preserve">
          <source>The command, if run with &lt;code&gt;-h&lt;/code&gt;, will show the available options:</source>
          <target state="translated">&lt;code&gt;-h&lt;/code&gt; 와 함께 실행하면 명령에 사용 가능한 옵션이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6e345e636adf7e9a665df637497de8ab138640b2" translate="yes" xml:space="preserve">
          <source>The commands recognized by the debugger are listed below. Most commands can be abbreviated to one or two letters as indicated; e.g. &lt;code&gt;h(elp)&lt;/code&gt; means that either &lt;code&gt;h&lt;/code&gt; or &lt;code&gt;help&lt;/code&gt; can be used to enter the help command (but not &lt;code&gt;he&lt;/code&gt; or &lt;code&gt;hel&lt;/code&gt;, nor &lt;code&gt;H&lt;/code&gt; or &lt;code&gt;Help&lt;/code&gt; or &lt;code&gt;HELP&lt;/code&gt;). Arguments to commands must be separated by whitespace (spaces or tabs). Optional arguments are enclosed in square brackets (&lt;code&gt;[]&lt;/code&gt;) in the command syntax; the square brackets must not be typed. Alternatives in the command syntax are separated by a vertical bar (&lt;code&gt;|&lt;/code&gt;).</source>
          <target state="translated">디버거가 인식하는 명령은 다음과 같습니다. 대부분의 명령은 표시된대로 한두 글자로 축약 될 수 있습니다. 예를 들어 &lt;code&gt;h(elp)&lt;/code&gt; 는 &lt;code&gt;h&lt;/code&gt; 또는 &lt;code&gt;help&lt;/code&gt; 를 사용하여 help 명령을 입력 할 수 있음을 의미합니다 (단 , &lt;code&gt;he&lt;/code&gt; 또는 &lt;code&gt;hel&lt;/code&gt; 또는 &lt;code&gt;H&lt;/code&gt; 또는 &lt;code&gt;Help&lt;/code&gt; 또는 &lt;code&gt;HELP&lt;/code&gt; 는 아님). 명령에 대한 인수는 공백 (공백 또는 탭)으로 구분해야합니다. 선택적 인수는 명령 구문에서 대괄호 ( &lt;code&gt;[]&lt;/code&gt; )로 묶습니다 . 대괄호는 입력하지 않아야합니다. 명령 구문의 대안은 세로 막대 ( &lt;code&gt;|&lt;/code&gt; ) 로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="1b0c4e95df2cc092cf548fbafd773a5feced6509" translate="yes" xml:space="preserve">
          <source>The comment associated with the ZIP file as a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. If assigning a comment to a &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; instance created with mode &lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt; or &lt;code&gt;'a'&lt;/code&gt;, it should be no longer than 65535 bytes. Comments longer than this will be truncated.</source>
          <target state="translated">ZIP 파일과 연관된 주석은 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체입니다. &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 또는 &lt;code&gt;'a'&lt;/code&gt; 모드로 작성된 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; &lt;/a&gt; 인스턴스에 주석을 지정하는 경우 65535 바이트를 넘지 않아야합니다. 이보다 긴 주석은 잘립니다.</target>
        </trans-unit>
        <trans-unit id="c3d4ab182c2db8443dd330fa9a538692f30951a8" translate="yes" xml:space="preserve">
          <source>The comparison between expected outputs and actual outputs is done by an &lt;a href=&quot;#doctest.OutputChecker&quot;&gt;&lt;code&gt;OutputChecker&lt;/code&gt;&lt;/a&gt;. This comparison may be customized with a number of option flags; see section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt; for more information. If the option flags are insufficient, then the comparison may also be customized by passing a subclass of &lt;a href=&quot;#doctest.OutputChecker&quot;&gt;&lt;code&gt;OutputChecker&lt;/code&gt;&lt;/a&gt; to the constructor.</source>
          <target state="translated">예상 출력과 실제 출력 간의 비교는 &lt;a href=&quot;#doctest.OutputChecker&quot;&gt; &lt;code&gt;OutputChecker&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 . 이 비교는 많은 옵션 플래그로 사용자 정의 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션 을 참조하십시오. 옵션 플래그가 충분하지 않은 경우 &lt;a href=&quot;#doctest.OutputChecker&quot;&gt; &lt;code&gt;OutputChecker&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 생성자 에 전달하여 비교를 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79c38cc9654a2b0cf446da2a3b3b6ba57617ee75" translate="yes" xml:space="preserve">
          <source>The comparisons &lt;code&gt;==&lt;/code&gt; or &lt;code&gt;!=&lt;/code&gt;&lt;em&gt;always&lt;/em&gt; return a &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;, no matter the type of the compared object:</source>
          <target state="translated">비교 &lt;code&gt;==&lt;/code&gt; 또는 &lt;code&gt;!=&lt;/code&gt; 는 비교 객체의 유형에 관계없이 &lt;em&gt;항상 &lt;/em&gt;&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; 을&lt;/a&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8f4b16d657cdc57fcbb86894a1bc1965b3eac791" translate="yes" xml:space="preserve">
          <source>The compiled code object.</source>
          <target state="translated">컴파일 된 코드 객체</target>
        </trans-unit>
        <trans-unit id="cffbd898eeee4166206889c430a7c4f2732ae94c" translate="yes" xml:space="preserve">
          <source>The compiled versions of the most recent format strings passed to &lt;a href=&quot;#struct.Struct&quot;&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;/a&gt; and the module-level functions are cached, so programs that use only a few format strings needn&amp;rsquo;t worry about reusing a single &lt;a href=&quot;#struct.Struct&quot;&gt;&lt;code&gt;Struct&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#struct.Struct&quot;&gt; &lt;code&gt;Struct&lt;/code&gt; 에&lt;/a&gt; 전달 된 최신 형식 문자열 과 모듈 수준 함수 의 컴파일 된 버전 이 캐시되므로 몇 가지 형식 문자열 만 사용하는 프로그램은 단일 &lt;a href=&quot;#struct.Struct&quot;&gt; &lt;code&gt;Struct&lt;/code&gt; &lt;/a&gt; 인스턴스의 재사용에 대해 걱정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="ab52247f4c90217fe220c0e00be40b43bc3d4ecb" translate="yes" xml:space="preserve">
          <source>The compiled versions of the most recent patterns passed to &lt;a href=&quot;#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and the module-level matching functions are cached, so programs that use only a few regular expressions at a time needn&amp;rsquo;t worry about compiling regular expressions.</source>
          <target state="translated">&lt;a href=&quot;#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 전달 된 가장 최근 패턴의 컴파일 된 버전 과 모듈 수준 일치 함수가 캐시되므로 한 번에 몇 개의 정규 표현식 만 사용하는 프로그램은 정규 표현식 컴파일에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a86d93007da3d0cb6dd563da533af1864349897" translate="yes" xml:space="preserve">
          <source>The complete signature is:</source>
          <target state="translated">완전한 서명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="52f0ad2782ff79ba1413d52ccaa72b70245608bf" translate="yes" xml:space="preserve">
          <source>The complex type is described in &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;Numeric Types &amp;mdash; int, float, complex&lt;/a&gt;.</source>
          <target state="translated">복합 유형은 &lt;a href=&quot;stdtypes#typesnumeric&quot;&gt;숫자 유형-int, float, complex에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8423b10aee34a14219c852ad4786792dda570ef3" translate="yes" xml:space="preserve">
          <source>The compression settings can be specified either as a preset compression level (with the &lt;em&gt;preset&lt;/em&gt; argument), or in detail as a custom filter chain (with the &lt;em&gt;filters&lt;/em&gt; argument).</source>
          <target state="translated">압축 설정은 사전 설정 압축 수준 ( &lt;em&gt;사전 설정&lt;/em&gt; 인수 포함) 또는 사용자 정의 필터 체인 ( &lt;em&gt;필터&lt;/em&gt; 인수 사용) 으로 자세히 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aa97a83ece05b5a0a5d5b194b33927d529e0027e" translate="yes" xml:space="preserve">
          <source>The compressor cannot be used after this method has been called.</source>
          <target state="translated">이 메소드를 호출 한 후에는 압축기를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0f2141b3d65ba701015cb35367a7f27ebd2455cf" translate="yes" xml:space="preserve">
          <source>The compressor object may not be used after this method has been called.</source>
          <target state="translated">이 메소드를 호출 한 후에는 압축기 객체를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="64c7be1f9a57000f18a2a61a8fefda7d5860289a" translate="yes" xml:space="preserve">
          <source>The concatenation of the &lt;a href=&quot;#string.ascii_lowercase&quot;&gt;&lt;code&gt;ascii_lowercase&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#string.ascii_uppercase&quot;&gt;&lt;code&gt;ascii_uppercase&lt;/code&gt;&lt;/a&gt; constants described below. This value is not locale-dependent.</source>
          <target state="translated">아래에 설명 된 &lt;a href=&quot;#string.ascii_lowercase&quot;&gt; &lt;code&gt;ascii_lowercase&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#string.ascii_uppercase&quot;&gt; &lt;code&gt;ascii_uppercase&lt;/code&gt; &lt;/a&gt; 상수 의 연결 이 값은 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ca85ed6988e6d21605f779695c181fffd7ea4c90" translate="yes" xml:space="preserve">
          <source>The concatenation of the drive and root:</source>
          <target state="translated">드라이브와 루트의 연결 :</target>
        </trans-unit>
        <trans-unit id="e092972f0114d0d2ff37172e3be9c56bde7107c7" translate="yes" xml:space="preserve">
          <source>The conceptual model provided by a &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; object is that of an ordered dictionary of headers with additional methods for accessing both specialized information from the headers, for accessing the payload, for generating a serialized version of the message, and for recursively walking over the object tree. Note that duplicate headers are supported but special methods must be used to access them.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 객체가 제공하는 개념적 모델 은 헤더에서 특수화 된 정보에 액세스하고, 페이로드에 액세스하고, 메시지의 직렬화 된 버전을 생성하고, 객체 트리를 재귀 적으로 탐색하기위한 추가 방법이있는 정렬 된 헤더 사전 모델입니다. . 중복 헤더는 지원되지만 특별한 방법을 사용하여 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="aa9fdff52eeada3a2000fe3606dc76d6f1a9438c" translate="yes" xml:space="preserve">
          <source>The conceptual model provided by an &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is that of an ordered dictionary of headers coupled with a &lt;em&gt;payload&lt;/em&gt; that represents the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; body of the message, which might be a list of sub-&lt;code&gt;EmailMessage&lt;/code&gt; objects. In addition to the normal dictionary methods for accessing the header names and values, there are methods for accessing specialized information from the headers (for example the MIME content type), for operating on the payload, for generating a serialized version of the message, and for recursively walking over the object tree.</source>
          <target state="translated">&lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체가 제공하는 개념적 모델 은 메시지 의 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 본문 을 나타내는 &lt;em&gt;페이로드&lt;/em&gt; 와 연결된 헤더의 정렬 된 사전 사전 모델이며 , 하위 &lt;code&gt;EmailMessage&lt;/code&gt; 객체 목록 일 수 있습니다 . 헤더 이름과 값에 액세스하기위한 일반적인 사전 방법 외에도 페이로드에서 작동하고 메시지의 직렬화 된 버전을 생성하기 위해 헤더에서 특수 정보 (예 : MIME 컨텐츠 유형)에 액세스하는 방법이 있습니다. 객체 트리를 재귀 적으로 걷습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a7ce1e8829b2baa1cee35ef7caa7def938910c0" translate="yes" xml:space="preserve">
          <source>The concrete class which &lt;a href=&quot;importlib#importlib.abc.MetaPathFinder.find_spec&quot;&gt;&lt;code&gt;find_spec()&lt;/code&gt;&lt;/a&gt; should return instances of.</source>
          <target state="translated">&lt;a href=&quot;importlib#importlib.abc.MetaPathFinder.find_spec&quot;&gt; &lt;code&gt;find_spec()&lt;/code&gt; &lt;/a&gt; 의 구체적인 클래스 는 인스턴스를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b47d19d847be464de32c419aa4cb13a86a81fe9" translate="yes" xml:space="preserve">
          <source>The concurrent package</source>
          <target state="translated">동시 패키지</target>
        </trans-unit>
        <trans-unit id="570b777eec02b54837ba5c38cb8c956eb69457cf" translate="yes" xml:space="preserve">
          <source>The condition that causes a break.</source>
          <target state="translated">휴식을 일으키는 조건.</target>
        </trans-unit>
        <trans-unit id="12bf8455ae3938296c7e397895720025d423f807" translate="yes" xml:space="preserve">
          <source>The configuration &lt;em&gt;options&lt;/em&gt; are as follows:</source>
          <target state="translated">구성 &lt;em&gt;옵션&lt;/em&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59c7bb6eed19501d87b1a0d7f39e43f6d3d05ab2" translate="yes" xml:space="preserve">
          <source>The configuration file for &lt;code&gt;libedit&lt;/code&gt; is different from that of GNU readline. If you programmatically load configuration strings you can check for the text &amp;ldquo;libedit&amp;rdquo; in &lt;code&gt;readline.__doc__&lt;/code&gt; to differentiate between GNU readline and libedit.</source>
          <target state="translated">&lt;code&gt;libedit&lt;/code&gt; 의 구성 파일 은 GNU readline 의 구성 파일과 다릅니다 . 프로그래밍 방식으로 구성 문자열을로드하는 경우 &lt;code&gt;readline.__doc__&lt;/code&gt; 에서&amp;ldquo;libedit&amp;rdquo;텍스트를 확인하여 GNU readline과 libedit를 구별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53b52acbb2a777e6ab327fff01a2fbdb919c5154" translate="yes" xml:space="preserve">
          <source>The configuration file format understood by &lt;a href=&quot;#logging.config.fileConfig&quot;&gt;&lt;code&gt;fileConfig()&lt;/code&gt;&lt;/a&gt; is based on &lt;a href=&quot;configparser#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; functionality. The file must contain sections called &lt;code&gt;[loggers]&lt;/code&gt;, &lt;code&gt;[handlers]&lt;/code&gt; and &lt;code&gt;[formatters]&lt;/code&gt; which identify by name the entities of each type which are defined in the file. For each such entity, there is a separate section which identifies how that entity is configured. Thus, for a logger named &lt;code&gt;log01&lt;/code&gt; in the &lt;code&gt;[loggers]&lt;/code&gt; section, the relevant configuration details are held in a section &lt;code&gt;[logger_log01]&lt;/code&gt;. Similarly, a handler called &lt;code&gt;hand01&lt;/code&gt; in the &lt;code&gt;[handlers]&lt;/code&gt; section will have its configuration held in a section called &lt;code&gt;[handler_hand01]&lt;/code&gt;, while a formatter called &lt;code&gt;form01&lt;/code&gt; in the &lt;code&gt;[formatters]&lt;/code&gt; section will have its configuration specified in a section called &lt;code&gt;[formatter_form01]&lt;/code&gt;. The root logger configuration must be specified in a section called &lt;code&gt;[logger_root]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#logging.config.fileConfig&quot;&gt; &lt;code&gt;fileConfig()&lt;/code&gt; &lt;/a&gt; 가 이해하는 구성 파일 형식은 구성 프로그램 기능을 기반으로 &lt;a href=&quot;configparser#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; . 파일에는 파일 에 정의 된 각 유형의 엔티티를 이름으로 식별하는 &lt;code&gt;[loggers]&lt;/code&gt; , &lt;code&gt;[handlers]&lt;/code&gt; 및 &lt;code&gt;[formatters]&lt;/code&gt; 섹션이 포함되어야합니다 . 이러한 각 엔터티에는 해당 엔터티 구성 방법을 식별하는 별도의 섹션이 있습니다. 따라서 &lt;code&gt;[loggers]&lt;/code&gt; 섹션 에서 이름이 &lt;code&gt;log01&lt;/code&gt; 인로거의 경우 관련 구성 세부 사항은 &lt;code&gt;[logger_log01]&lt;/code&gt; 섹션에 보유됩니다 . 마찬가지로 &lt;code&gt;[handlers]&lt;/code&gt; 에서 &lt;code&gt;hand01&lt;/code&gt; 이라는 핸들러섹션 구성이라는 부에 유지 한 것이다 &lt;code&gt;[handler_hand01]&lt;/code&gt; 포맷터 호출 동안 &lt;code&gt;form01&lt;/code&gt; 에서 &lt;code&gt;[formatters]&lt;/code&gt; 구성라는 절에 명시된 것 부 &lt;code&gt;[formatter_form01]&lt;/code&gt; . 루트 로거 구성은 &lt;code&gt;[logger_root]&lt;/code&gt; 라는 섹션에 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9b651af8db79babcce4e20eeaec528de157decc" translate="yes" xml:space="preserve">
          <source>The configuration options in Tk are given in lists of hyphened tags followed by values. In Tkinter, options are specified as keyword-arguments in the instance constructor, and keyword-args for configure calls or as instance indices, in dictionary style, for established instances. See section &lt;a href=&quot;#tkinter-setting-options&quot;&gt;Setting Options&lt;/a&gt; on setting options.</source>
          <target state="translated">Tk의 구성 옵션은 하이픈 태그 목록과 값이 제공됩니다. Tkinter에서 옵션은 인스턴스 생성자에서 키워드 인수로 지정되고, 구성된 호출의 경우 키워드 인수로 설정되거나, 설정된 인스턴스의 경우 사전 스타일로 사전 색인으로 키워드 인덱스로 지정됩니다. &lt;a href=&quot;#tkinter-setting-options&quot;&gt;옵션 설정&lt;/a&gt; 에 대한 설정 옵션 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c1a61b4a52925d6e4ff824c49fb0c8d7e73702dc" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for keys &lt;code&gt;format&lt;/code&gt; and &lt;code&gt;datefmt&lt;/code&gt; (with defaults of &lt;code&gt;None&lt;/code&gt;) and these are used to construct a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">구성 dict는 키 &lt;code&gt;format&lt;/code&gt; 및 &lt;code&gt;datefmt&lt;/code&gt; (기본값은 &lt;code&gt;None&lt;/code&gt; )를 검색하며 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 인스턴스 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="05ad2ef2a6dd6a0426dfded13d5ea25a19a75ea1" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for the following keys:</source>
          <target state="translated">구성 dict에서 다음 키를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d6070b1488ec8a72afe1a4161755ca71fa01d4f9" translate="yes" xml:space="preserve">
          <source>The configuring dict is searched for the key &lt;code&gt;name&lt;/code&gt; (defaulting to the empty string) and this is used to construct a &lt;a href=&quot;logging#logging.Filter&quot;&gt;&lt;code&gt;logging.Filter&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">구성 dict에서 키 &lt;code&gt;name&lt;/code&gt; (기본값은 빈 문자열)을 검색하고 &lt;a href=&quot;logging#logging.Filter&quot;&gt; &lt;code&gt;logging.Filter&lt;/code&gt; &lt;/a&gt; 인스턴스 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="22098bdd88d261e748ed7287ce44dd49d82e7d6e" translate="yes" xml:space="preserve">
          <source>The connection is established and a &lt;a href=&quot;asyncio-protocol#asyncio-transport&quot;&gt;transport&lt;/a&gt; is created for it.</source>
          <target state="translated">연결이 설정되고 &lt;a href=&quot;asyncio-protocol#asyncio-transport&quot;&gt;전송&lt;/a&gt; 이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ad28af9c1892c375346d6b75312ea79291b1c88f" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the current directory. This is &lt;code&gt;'.'&lt;/code&gt; for Windows and POSIX. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제에서 현재 디렉토리를 참조하기 위해 사용하는 상수 문자열. 이것은 &lt;code&gt;'.'&lt;/code&gt; 입니다Windows 및 POSIX의 경우. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="83f1f1fda282af44b7cfb075ada1e9aaf0f04e93" translate="yes" xml:space="preserve">
          <source>The constant string used by the operating system to refer to the parent directory. This is &lt;code&gt;'..'&lt;/code&gt; for Windows and POSIX. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">운영 체제에서 상위 디렉토리를 참조하기 위해 사용하는 상수 문자열. 이다 &lt;code&gt;'..'&lt;/code&gt; Windows 및 POSIX 위해. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="01770734e88c7a4ab5e6980d5f00daa7ef0c1c5f" translate="yes" xml:space="preserve">
          <source>The constants defined in this module are:</source>
          <target state="translated">이 모듈에 정의 된 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b08a2e82bd5dc334f732ff6ab5b3f9da3808da16" translate="yes" xml:space="preserve">
          <source>The constants in the model type group are:</source>
          <target state="translated">모델 유형 그룹의 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9ddd636a4f621e05ed2865944f1e483ab09fd535" translate="yes" xml:space="preserve">
          <source>The constants in the quantifier group are:</source>
          <target state="translated">수량 자 그룹의 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a15e83ade8de633314e05199e3e1378b4c6379a" translate="yes" xml:space="preserve">
          <source>The constants in this section are only relevant for the C module. They are also included in the pure Python version for compatibility.</source>
          <target state="translated">이 섹션의 상수는 C 모듈에만 관련이 있습니다. 호환성을 위해 순수 Python 버전에도 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cb2fb40748577c1742ac7584db3943ced5d2257" translate="yes" xml:space="preserve">
          <source>The constructor accepts any object with a truth value.</source>
          <target state="translated">생성자는 true 값을 가진 모든 개체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="de65c1ef0adbf85286791da99438ac61fbc8f3c0" translate="yes" xml:space="preserve">
          <source>The constructor builds a list whose items are the same and in the same order as &lt;em&gt;iterable&lt;/em&gt;&amp;rsquo;s items. &lt;em&gt;iterable&lt;/em&gt; may be either a sequence, a container that supports iteration, or an iterator object. If &lt;em&gt;iterable&lt;/em&gt; is already a list, a copy is made and returned, similar to &lt;code&gt;iterable[:]&lt;/code&gt;. For example, &lt;code&gt;list('abc')&lt;/code&gt; returns &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; and &lt;code&gt;list( (1, 2, 3) )&lt;/code&gt; returns &lt;code&gt;[1, 2, 3]&lt;/code&gt;. If no argument is given, the constructor creates a new empty list, &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">생성자는 &lt;em&gt;반복 가능한&lt;/em&gt; 항목 과 순서가 동일한 항목을 가진 목록을 작성 합니다. &lt;em&gt;iterable&lt;/em&gt; 은 시퀀스, 반복을 지원하는 컨테이너 또는 반복자 객체 일 수 있습니다. 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 이미 목록, 사본이 만들어지고, 유사 반환 &lt;code&gt;iterable[:]&lt;/code&gt; . 예를 들어 &lt;code&gt;list('abc')&lt;/code&gt; 는 &lt;code&gt;['a', 'b', 'c']&lt;/code&gt; 반환 하고 &lt;code&gt;list( (1, 2, 3) )&lt;/code&gt; 는 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 반환합니다 . 인수가 제공되지 않으면 생성자는 비어있는 새 목록 &lt;code&gt;[]&lt;/code&gt; 을 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="29519469d10505e3d049e63dd290612ed49fc46c" translate="yes" xml:space="preserve">
          <source>The constructor builds a tuple whose items are the same and in the same order as &lt;em&gt;iterable&lt;/em&gt;&amp;rsquo;s items. &lt;em&gt;iterable&lt;/em&gt; may be either a sequence, a container that supports iteration, or an iterator object. If &lt;em&gt;iterable&lt;/em&gt; is already a tuple, it is returned unchanged. For example, &lt;code&gt;tuple('abc')&lt;/code&gt; returns &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; and &lt;code&gt;tuple( [1, 2, 3] )&lt;/code&gt; returns &lt;code&gt;(1, 2, 3)&lt;/code&gt;. If no argument is given, the constructor creates a new empty tuple, &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">생성자는 &lt;em&gt;반복 가능한&lt;/em&gt; 항목 과 항목이 동일한 순서로 튜플을 만듭니다 . &lt;em&gt;iterable&lt;/em&gt; 은 시퀀스, 반복을 지원하는 컨테이너 또는 반복자 객체 일 수 있습니다. 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 이미 터플, 그것은 변화가 반환됩니다. 예를 들어 &lt;code&gt;tuple('abc')&lt;/code&gt; 은 &lt;code&gt;('a', 'b', 'c')&lt;/code&gt; &lt;code&gt;tuple( [1, 2, 3] )&lt;/code&gt; 반환 하고 tuple ([1, 2, 3]) 은 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 반환합니다 . 인수를 지정하지 않으면 생성자는 비어있는 새 튜플 &lt;code&gt;()&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c9dd0eda3540f657a7e0a9a4a8c77a6032885080" translate="yes" xml:space="preserve">
          <source>The constructor creates a &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt; for the given readable &lt;em&gt;raw&lt;/em&gt; stream and &lt;em&gt;buffer_size&lt;/em&gt;. If &lt;em&gt;buffer_size&lt;/em&gt; is omitted, &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">생성자 는 지정된 읽을 수있는 &lt;em&gt;원시&lt;/em&gt; 스트림 및 &lt;em&gt;buffer_size에&lt;/em&gt; 대한 &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; 를 작성합니다 . 경우 &lt;em&gt;BUFFER_SIZE은&lt;/em&gt; 생략 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; 가&lt;/a&gt; 사용된다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ff054c7924dc7261d0aed35f217835da758c86" translate="yes" xml:space="preserve">
          <source>The constructor creates a &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt; for the given writeable &lt;em&gt;raw&lt;/em&gt; stream. If the &lt;em&gt;buffer_size&lt;/em&gt; is not given, it defaults to &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자 는 지정된 쓰기 가능한 &lt;em&gt;원시&lt;/em&gt; 스트림에 대해 &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; 를 작성 합니다. 경우 &lt;em&gt;BUFFER_SIZE는&lt;/em&gt; , 디폴트 주어지지하는 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; &lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6dbdbc1d7bc6e3588721a37331f619e648a20ac7" translate="yes" xml:space="preserve">
          <source>The constructor creates a reader and writer for a seekable raw stream, given in the first argument. If the &lt;em&gt;buffer_size&lt;/em&gt; is omitted it defaults to &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자는 첫 번째 인수에서 주어진 탐색 가능한 원시 스트림에 대한 리더 및 라이터를 작성합니다. &lt;em&gt;buffer_size&lt;/em&gt; 가 생략 되면 기본값은 &lt;a href=&quot;#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;DEFAULT_BUFFER_SIZE&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09fba04fdb03d601e27ad6e5c1a62a7c6837bb41" translate="yes" xml:space="preserve">
          <source>The constructor for this class is:</source>
          <target state="translated">이 클래스의 생성자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="27d963a1efe9374acd799a7437355a7f128b6742" translate="yes" xml:space="preserve">
          <source>The constructor of a class &lt;code&gt;ast.T&lt;/code&gt; parses its arguments as follows:</source>
          <target state="translated">&lt;code&gt;ast.T&lt;/code&gt; 클래스의 생성자는 다음과 같이 인수를 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="bd786e1e93280b6a0e5b1a1fd99c22ce347e8d8f" translate="yes" xml:space="preserve">
          <source>The constructor of a policy class can be passed various keyword arguments. The arguments that may be specified are any non-method properties on this class, plus any additional non-method properties on the concrete class. A value specified in the constructor will override the default value for the corresponding attribute.</source>
          <target state="translated">정책 클래스의 생성자에는 다양한 키워드 인수가 전달 될 수 있습니다. 지정할 수있는 인수는이 클래스의 메소드 이외의 프로퍼티, 그리고 구체적 클래스의 메소드 이외의 프로퍼티입니다. 생성자에 지정된 값은 해당 속성의 기본값을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="3ee2574b5d9e6bcc9b944e93fc5b27e68e52b42e" translate="yes" xml:space="preserve">
          <source>The constructor often actually returns a subclass of &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;, as described in &lt;a href=&quot;#os-exceptions&quot;&gt;OS exceptions&lt;/a&gt; below. The particular subclass depends on the final &lt;a href=&quot;#OSError.errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value. This behaviour only occurs when constructing &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; directly or via an alias, and is not inherited when subclassing.</source>
          <target state="translated">생성자는 종종 아래 &lt;a href=&quot;#os-exceptions&quot;&gt;OS 예외에&lt;/a&gt; 설명 된대로 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 실제로 반환 합니다. 특정 서브 클래스는 최종 &lt;a href=&quot;#OSError.errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 값 에 따라 다릅니다 . 이 동작은 &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 직접 또는 별명을 통해 구성 할 때만 발생 하며 서브 클래 싱시 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34da053fc68df3d3c1c7315428ce28358a25e31e" translate="yes" xml:space="preserve">
          <source>The constructor parameters have the same meaning as for &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt;, with the exception of &lt;em&gt;return_value&lt;/em&gt; and &lt;em&gt;side_effect&lt;/em&gt; which have no meaning on a non-callable mock.</source>
          <target state="translated">생성자 매개 변수는 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 과 같은 의미를 지니지 만&lt;em&gt; return_value&lt;/em&gt; 및 &lt;em&gt;side_effect&lt;/em&gt; 를 제외하고는 호출 할 수없는 모의에 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="92a4c4d75e4bbfdb57df8a0f0ff2b7e566c251f3" translate="yes" xml:space="preserve">
          <source>The constructor parameters have the same meaning as for &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자 매개 변수는 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="2a6b7b5892a6a7371b6a7eb794526e89b84a8ce7" translate="yes" xml:space="preserve">
          <source>The constructor sets this attribute to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">생성자는이 속성을 &lt;code&gt;True&lt;/code&gt; 로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="82938dfd4d3b4884cceee3e3895d3aed984dc32f" translate="yes" xml:space="preserve">
          <source>The constructor should always be called with keyword arguments. &lt;em&gt;group&lt;/em&gt; should always be &lt;code&gt;None&lt;/code&gt;; it exists solely for compatibility with &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;target&lt;/em&gt; is the callable object to be invoked by the &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method. It defaults to &lt;code&gt;None&lt;/code&gt;, meaning nothing is called. &lt;em&gt;name&lt;/em&gt; is the process name (see &lt;a href=&quot;#multiprocessing.Process.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; for more details). &lt;em&gt;args&lt;/em&gt; is the argument tuple for the target invocation. &lt;em&gt;kwargs&lt;/em&gt; is a dictionary of keyword arguments for the target invocation. If provided, the keyword-only &lt;em&gt;daemon&lt;/em&gt; argument sets the process &lt;a href=&quot;#multiprocessing.Process.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt; flag to &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt; (the default), this flag will be inherited from the creating process.</source>
          <target state="translated">생성자는 항상 키워드 인수로 호출해야합니다. &lt;em&gt;그룹&lt;/em&gt; 은 항상 &lt;code&gt;None&lt;/code&gt; 이어야합니다 . &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 와의 호환성을 위해서만 존재합니다 . &lt;em&gt;target&lt;/em&gt; 은 &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 호출 될 호출 가능 객체 입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 아무 것도 호출되지 않습니다. &lt;em&gt;name&lt;/em&gt; 은 프로세스 이름입니다 ( 자세한 내용 은 &lt;a href=&quot;#multiprocessing.Process.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 참조). &lt;em&gt;args&lt;/em&gt; 는 대상 호출에 대한 인수 튜플입니다. &lt;em&gt;kwargs&lt;/em&gt; 는 대상 호출을위한 키워드 인수 사전입니다. 제공된 경우 키워드 전용 &lt;em&gt;데몬&lt;/em&gt; 인수는 프로세스 &lt;a href=&quot;#multiprocessing.Process.daemon&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 플래그를 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; . 경우 &lt;code&gt;None&lt;/code&gt; (기본값),이 플래그는 프로세스 작성에서 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="32a46ef7f69310a283260ddb83ad03cfa971b3e1" translate="yes" xml:space="preserve">
          <source>The constructor takes a single argument which is the template string.</source>
          <target state="translated">생성자는 템플릿 문자열 인 단일 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="85fb777e8dbaf45dd04245b451b4e3b6e600f758" translate="yes" xml:space="preserve">
          <source>The constructor takes a statement to be timed, an additional statement used for setup, and a timer function. Both statements default to &lt;code&gt;'pass'&lt;/code&gt;; the timer function is platform-dependent (see the module doc string). &lt;em&gt;stmt&lt;/em&gt; and &lt;em&gt;setup&lt;/em&gt; may also contain multiple statements separated by &lt;code&gt;;&lt;/code&gt; or newlines, as long as they don&amp;rsquo;t contain multi-line string literals. The statement will by default be executed within timeit&amp;rsquo;s namespace; this behavior can be controlled by passing a namespace to &lt;em&gt;globals&lt;/em&gt;.</source>
          <target state="translated">생성자는 시간을 지정할 명령문, 설정에 사용되는 추가 명령문 및 타이머 함수를 사용합니다. 두 명령문 모두 기본값은 &lt;code&gt;'pass'&lt;/code&gt; 입니다 . 타이머 기능은 플랫폼에 따라 다릅니다 (모듈 문서 문자열 참조). &lt;em&gt;stmt&lt;/em&gt; 및 &lt;em&gt;setup&lt;/em&gt; 에는 여러 개의 명령문이 포함되어있을 수도 있습니다 &lt;code&gt;;&lt;/code&gt; 여러 줄 문자열 리터럴을 포함하지 않는 한 줄 바꿈. 명령문은 기본적으로 timeit의 네임 스페이스 내에서 실행됩니다. 네임 스페이스를 &lt;em&gt;전역&lt;/em&gt; 에 전달하여이 동작을 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e82026a9486f07bedd914a704cc5bdb81ae8b863" translate="yes" xml:space="preserve">
          <source>The constructors &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;functions#complex&quot;&gt;&lt;code&gt;complex()&lt;/code&gt;&lt;/a&gt; can be used to produce numbers of a specific type.</source>
          <target state="translated">The constructors &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float()&lt;/code&gt; &lt;/a&gt;, and &lt;a href=&quot;functions#complex&quot;&gt; &lt;code&gt;complex()&lt;/code&gt; &lt;/a&gt; can be used to produce numbers of a specific type.</target>
        </trans-unit>
        <trans-unit id="faeaf3d519344bfb81584ecfbe3e2e030553ca32" translate="yes" xml:space="preserve">
          <source>The constructors for both classes work the same:</source>
          <target state="translated">두 클래스의 생성자는 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="16bddd8e166a7aa3664f7fc3cb9f30d4b8d6972f" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;script&lt;/code&gt; and &lt;code&gt;style&lt;/code&gt; elements is returned as is, without further parsing:</source>
          <target state="translated">&lt;code&gt;script&lt;/code&gt; 및 &lt;code&gt;style&lt;/code&gt; 요소 의 내용은 추가 구문 분석없이 그대로 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b885742c99fa8fa5d295658e3b1e7a351b43c4b6" translate="yes" xml:space="preserve">
          <source>The content of Internet Explorer conditional comments (condcoms) will also be sent to this method, so, for &lt;code&gt;&amp;lt;!--[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]--&amp;gt;&lt;/code&gt;, this method will receive &lt;code&gt;'[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]'&lt;/code&gt;.</source>
          <target state="translated">Internet Explorer 조건부 주석 (condcom)의 내용도이 방법으로 전송되므로 &lt;code&gt;&amp;lt;!--[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]--&amp;gt;&lt;/code&gt; 의 경우이 방법은 &lt;code&gt;'[if IE 9]&amp;gt;IE9-specific content&amp;lt;![endif]'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ffbbe2070577e91a7c0b3ac8a7f6a190c051ef3" translate="yes" xml:space="preserve">
          <source>The content of the comment as a string. The attribute contains all characters between the leading &lt;code&gt;&amp;lt;!-&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; and trailing &lt;code&gt;-&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;, but does not include them.</source>
          <target state="translated">주석의 내용을 문자열로 표시합니다. 이 속성은 선도적 인 사이의 모든 문자가 포함 된 &lt;code&gt;&amp;lt;!-&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; 및 후행 &lt;code&gt;-&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; 하지만, 그들을 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23414cbc9467ed1198fa805e0f5a50cf39d17661" translate="yes" xml:space="preserve">
          <source>The content of the processing instruction following the first whitespace character.</source>
          <target state="translated">첫 번째 공백 문자 다음에 오는 처리 명령의 내용입니다.</target>
        </trans-unit>
        <trans-unit id="c57db44960c79dd27aae70094f1d2c24fd86db14" translate="yes" xml:space="preserve">
          <source>The content of the processing instruction up to the first whitespace character. This is a read-only attribute.</source>
          <target state="translated">첫 번째 공백 문자까지 처리 명령의 내용입니다. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="462b31a1bee4d3987ae97dfe20b6bb46bc905084" translate="yes" xml:space="preserve">
          <source>The content of the text node as a string.</source>
          <target state="translated">텍스트 노드의 내용을 문자열로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="43ad9f96468af5b1c07ea10a5a72713aa31ff0be" translate="yes" xml:space="preserve">
          <source>The content type string, in the form &lt;code&gt;maintype/subtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;maintype/subtype&lt;/code&gt; 형식의 컨텐츠 유형 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="a3b150ca1eb633d638b6149b49714354917314a8" translate="yes" xml:space="preserve">
          <source>The contents of this dictionary should not be modified; changes may not affect the values of local and free variables used by the interpreter.</source>
          <target state="translated">이 사전의 내용은 수정해서는 안됩니다. 변경 사항은 인터프리터가 사용하는 로컬 및 자유 변수의 값에 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d72744048e2ef7304cd545255ca3e4d86637d15" translate="yes" xml:space="preserve">
          <source>The context diff format normally has a header for filenames and modification times. Any or all of these may be specified using strings for &lt;em&gt;fromfile&lt;/em&gt;, &lt;em&gt;tofile&lt;/em&gt;, &lt;em&gt;fromfiledate&lt;/em&gt;, and &lt;em&gt;tofiledate&lt;/em&gt;. The modification times are normally expressed in the ISO 8601 format. If not specified, the strings default to blanks.</source>
          <target state="translated">컨텍스트 diff 형식에는 일반적으로 파일 이름 및 수정 시간에 대한 헤더가 있습니다. &lt;em&gt;fromfile&lt;/em&gt; , &lt;em&gt;tofile&lt;/em&gt; , &lt;em&gt;fromfiledate&lt;/em&gt; 및 &lt;em&gt;tofiledate의&lt;/em&gt; 문자열을 사용하여 이들 중 일부 또는 전부를 지정할 수 있습니다 . 수정 시간은 일반적으로 ISO 8601 형식으로 표시됩니다. 지정하지 않으면 문자열이 공백으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ae74fa43390909c47e9bab374fdc0e7d65c183ae" translate="yes" xml:space="preserve">
          <source>The context flag is set whenever the condition is encountered. After the computation, flags may be checked for informational purposes (for instance, to determine whether a computation was exact). After checking the flags, be sure to clear all flags before starting the next computation.</source>
          <target state="translated">컨텍스트 플래그는 조건이 발생할 때마다 설정됩니다. 계산 후에, 정보 목적을 위해 (예를 들어, 계산이 정확한지를 결정하기 위해) 플래그를 검사 할 수있다. 플래그를 확인한 후 다음 계산을 시작하기 전에 모든 플래그를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="09eded2e636fd012ef76bbb3909bd7a364dad9e0" translate="yes" xml:space="preserve">
          <source>The context for arithmetic is an environment specifying precision, rounding rules, limits on exponents, flags indicating the results of operations, and trap enablers which determine whether signals are treated as exceptions. Rounding options include &lt;a href=&quot;#decimal.ROUND_CEILING&quot;&gt;&lt;code&gt;ROUND_CEILING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_DOWN&quot;&gt;&lt;code&gt;ROUND_DOWN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_FLOOR&quot;&gt;&lt;code&gt;ROUND_FLOOR&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_DOWN&quot;&gt;&lt;code&gt;ROUND_HALF_DOWN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt;&lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt;&lt;code&gt;ROUND_HALF_UP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.ROUND_UP&quot;&gt;&lt;code&gt;ROUND_UP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#decimal.ROUND_05UP&quot;&gt;&lt;code&gt;ROUND_05UP&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">산술의 맥락은 정밀도, 반올림 규칙, 지수 제한, 연산 결과를 나타내는 플래그 및 신호가 예외로 처리되는지 여부를 결정하는 트랩 인 에이 블러를 지정하는 환경입니다. 반올림 옵션에는 &lt;a href=&quot;#decimal.ROUND_CEILING&quot;&gt; &lt;code&gt;ROUND_CEILING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_DOWN&quot;&gt; &lt;code&gt;ROUND_DOWN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_FLOOR&quot;&gt; &lt;code&gt;ROUND_FLOOR&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_DOWN&quot;&gt; &lt;code&gt;ROUND_HALF_DOWN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt; &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_HALF_UP&quot;&gt; &lt;code&gt;ROUND_HALF_UP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.ROUND_UP&quot;&gt; &lt;code&gt;ROUND_UP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.ROUND_05UP&quot;&gt; &lt;code&gt;ROUND_05UP&lt;/code&gt; 이&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="bafd7adbe3cc9b05aa5e0e3dcce674dac350bfa8" translate="yes" xml:space="preserve">
          <source>The context management protocol can be used for a similar effect, using the &lt;code&gt;with&lt;/code&gt; statement:</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 문을 사용하여 컨텍스트 관리 프로토콜을 비슷한 효과로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba17141915382244ea967ecdf5422870a5b2122" translate="yes" xml:space="preserve">
          <source>The context manager creates a temporary directory in the current directory with name &lt;em&gt;name&lt;/em&gt; before temporarily changing the current working directory. If &lt;em&gt;name&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the temporary directory is created using &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt;&lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">컨텍스트 관리자 는 현재 작업 디렉토리를 임시로 변경하기 전에 이름 &lt;em&gt;이름으로&lt;/em&gt; 현재 디렉토리에 임시 디렉토리를 작성합니다 . 경우 &lt;em&gt;이름이&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 임시 디렉토리를 사용하여 만들어집니다 &lt;a href=&quot;tempfile#tempfile.mkdtemp&quot;&gt; &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6e83b5b1e4a02d60f54d38e4c14284f0b9e0c2f5" translate="yes" xml:space="preserve">
          <source>The context manager is designed to be used like this:</source>
          <target state="translated">컨텍스트 관리자는 다음과 같이 사용되도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="c93372b7d432a94a90013fda0f1e81f91883d191" translate="yes" xml:space="preserve">
          <source>The context manager will store the caught exception object in its &lt;code&gt;exception&lt;/code&gt; attribute. This can be useful if the intention is to perform additional checks on the exception raised:</source>
          <target state="translated">컨텍스트 관리자는 포착 된 예외 오브젝트를 &lt;code&gt;exception&lt;/code&gt; 속성 에 저장 합니다. 이는 발생한 예외에 대해 추가 검사를 수행하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8a527687a59be5f54b43bf5cdbcd3a25dd1f0a6" translate="yes" xml:space="preserve">
          <source>The context manager will store the caught warning object in its &lt;code&gt;warning&lt;/code&gt; attribute, and the source line which triggered the warnings in the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;lineno&lt;/code&gt; attributes. This can be useful if the intention is to perform additional checks on the warning caught:</source>
          <target state="translated">컨텍스트 관리자는 포착 된 경고 오브젝트를 &lt;code&gt;warning&lt;/code&gt; 속성 에 저장하고 경고 를 트리거 한 소스 행을 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;lineno&lt;/code&gt; 속성에 저장합니다. 이것은 잡힌 경고에 대해 추가 점검을 수행하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6527b1864910862f2bd57bbab086cffc836efcd7" translate="yes" xml:space="preserve">
          <source>The context must be adapted for exact arbitrary precision arithmetic. &lt;code&gt;Emin&lt;/code&gt; and &lt;code&gt;Emax&lt;/code&gt; should always be set to the maximum values, &lt;code&gt;clamp&lt;/code&gt; should always be 0 (the default). Setting &lt;code&gt;prec&lt;/code&gt; requires some care.</source>
          <target state="translated">The context must be adapted for exact arbitrary precision arithmetic. &lt;code&gt;Emin&lt;/code&gt; and &lt;code&gt;Emax&lt;/code&gt; should always be set to the maximum values, &lt;code&gt;clamp&lt;/code&gt; should always be 0 (the default). Setting &lt;code&gt;prec&lt;/code&gt; requires some care.</target>
        </trans-unit>
        <trans-unit id="b1be860097b2ea275b23bb066160fdd50362d1e4" translate="yes" xml:space="preserve">
          <source>The control component is the &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; module. Every &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;, every &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;, and every &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; has an associated &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; object that controls its behavior. Usually an application only needs to specify the policy when an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; is created, either by directly instantiating an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; to create a new email, or by parsing an input stream using a &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt;. But the policy can be changed when the message is serialized using a &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;. This allows, for example, a generic email message to be parsed from disk, but to serialize it using standard SMTP settings when sending it to an email server.</source>
          <target state="translated">제어 구성 요소는 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 모듈입니다. 모든 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; , 모든 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 및 모든 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 에는 해당 동작을 제어 하는 관련 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 개체가 있습니다. 일반적으로 응용 프로그램은 단지 때 정책을 지정해야합니다 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 직접 인스턴스로 인해서 만들어집니다 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 을&lt;/a&gt; 새 전자 메일을 만들거나 사용하여 입력 스트림을 구문 분석하는 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; . 그러나 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 사용하여 메시지를 직렬화하면 정책을 변경할 수 있습니다 . 예를 들어 일반적인 전자 메일 메시지는 디스크에서 파싱되지만 전자 메일 서버로 보낼 때 표준 SMTP 설정을 사용하여 직렬화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ea8900935978cab09e01ef7e63ae696b49a52ac" translate="yes" xml:space="preserve">
          <source>The control-c handling signal handler attempts to remain compatible with code or tests that install their own &lt;a href=&quot;signal#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; handler. If the &lt;code&gt;unittest&lt;/code&gt; handler is called but &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; the installed &lt;a href=&quot;signal#signal.SIGINT&quot;&gt;&lt;code&gt;signal.SIGINT&lt;/code&gt;&lt;/a&gt; handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need &lt;code&gt;unittest&lt;/code&gt; control-c handling disabled the &lt;a href=&quot;#unittest.removeHandler&quot;&gt;&lt;code&gt;removeHandler()&lt;/code&gt;&lt;/a&gt; decorator can be used.</source>
          <target state="translated">The control-c handling signal handler attempts to remain compatible with code or tests that install their own &lt;a href=&quot;signal#signal.SIGINT&quot;&gt; &lt;code&gt;signal.SIGINT&lt;/code&gt; &lt;/a&gt; handler. If the &lt;code&gt;unittest&lt;/code&gt; handler is called but &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; the installed &lt;a href=&quot;signal#signal.SIGINT&quot;&gt; &lt;code&gt;signal.SIGINT&lt;/code&gt; &lt;/a&gt; handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need &lt;code&gt;unittest&lt;/code&gt; control-c handling disabled the &lt;a href=&quot;#unittest.removeHandler&quot;&gt; &lt;code&gt;removeHandler()&lt;/code&gt; &lt;/a&gt; decorator can be used.</target>
        </trans-unit>
        <trans-unit id="42d9a5e0285e83ad97753c1affe2e30fd3b5c598" translate="yes" xml:space="preserve">
          <source>The control-c handling signal handler attempts to remain compatible with code or tests that install their own &lt;code&gt;signal.SIGINT&lt;/code&gt; handler. If the &lt;code&gt;unittest&lt;/code&gt; handler is called but &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; the installed &lt;code&gt;signal.SIGINT&lt;/code&gt; handler, i.e. it has been replaced by the system under test and delegated to, then it calls the default handler. This will normally be the expected behavior by code that replaces an installed handler and delegates to it. For individual tests that need &lt;code&gt;unittest&lt;/code&gt; control-c handling disabled the &lt;a href=&quot;#unittest.removeHandler&quot;&gt;&lt;code&gt;removeHandler()&lt;/code&gt;&lt;/a&gt; decorator can be used.</source>
          <target state="translated">제어-C 처리 신호 처리기 시도 코드 또는 자신의 설치 검사와 호환성을 유지하는 &lt;code&gt;signal.SIGINT&lt;/code&gt; 의 핸들러를. 는 IF &lt;code&gt;unittest&lt;/code&gt; 핸들러가 호출되지만 &lt;em&gt;아닙니다&lt;/em&gt; 설치된 &lt;code&gt;signal.SIGINT&lt;/code&gt; 의 핸들러는,이 테스트중인 시스템으로 대체하고, 다음 기본 핸들러 호출에 위임 된 즉. 이것은 일반적으로 설치된 핸들러를 대체하고 위임하는 코드에 의해 예상되는 동작입니다. &lt;code&gt;unittest&lt;/code&gt; control-c 처리를 비활성화 해야하는 개별 테스트의 경우 &lt;a href=&quot;#unittest.removeHandler&quot;&gt; &lt;code&gt;removeHandler()&lt;/code&gt; &lt;/a&gt; 데코레이터를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0fec426b51ce6460abf94b5b235156f847e881d" translate="yes" xml:space="preserve">
          <source>The convenience functions are:</source>
          <target state="translated">편의 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56531a899db00e70169892fd06fed6a16f80619f" translate="yes" xml:space="preserve">
          <source>The convention has been adopted that subclasses defining &lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; or &lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; methods are named &lt;code&gt;*Processor&lt;/code&gt;; all others are named &lt;code&gt;*Handler&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;lt;protocol&amp;gt;_request()&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;protocol&amp;gt;_response()&lt;/code&gt; 메소드를 정의하는 서브 클래스의 이름은 &lt;code&gt;*Processor&lt;/code&gt; 라는 규칙이 채택되었습니다 . 다른 모든 이름은 &lt;code&gt;*Handler&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04aed1935d025bbe545d917616fb5a05a7966b05" translate="yes" xml:space="preserve">
          <source>The convention of allowing a special section of default values for other sections or interpolation purposes is a powerful concept of this library, letting users create complex declarative configurations. This section is normally called &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; but this can be customized to point to any other valid section name. Some typical values include: &lt;code&gt;&quot;general&quot;&lt;/code&gt; or &lt;code&gt;&quot;common&quot;&lt;/code&gt;. The name provided is used for recognizing default sections when reading from any source and is used when writing configuration back to a file. Its current value can be retrieved using the &lt;code&gt;parser_instance.default_section&lt;/code&gt; attribute and may be modified at runtime (i.e. to convert files from one format to another).</source>
          <target state="translated">다른 섹션 또는 보간 목적으로 특정 기본값 섹션을 허용하는 규칙은이 라이브러리의 강력한 개념으로, 사용자는 복잡한 선언적 구성을 만들 수 있습니다. 이 섹션은 일반적으로 &lt;code&gt;&quot;DEFAULT&quot;&lt;/code&gt; 라고 하지만 다른 유효한 섹션 이름을 가리 키도록 사용자 정의 할 수 있습니다. 일부 일반적인 값은 &lt;code&gt;&quot;general&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;common&quot;&lt;/code&gt; 입니다. 제공된 이름은 모든 소스에서 읽을 때 기본 섹션을 인식하는 데 사용되며 구성을 파일에 다시 쓸 때 사용됩니다. 현재 값은 &lt;code&gt;parser_instance.default_section&lt;/code&gt; 속성을 사용하여 검색 할 수 있으며 런타임시 수정 될 수 있습니다 (예 : 파일을 한 형식에서 다른 형식으로 변환).</target>
        </trans-unit>
        <trans-unit id="04f50c40567ef791799d2985a7c9a953f20d7dc2" translate="yes" xml:space="preserve">
          <source>The conversion flag characters are:</source>
          <target state="translated">변환 플래그 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7662277ad21af100a1d5f044a71168e6f8c38a0" translate="yes" xml:space="preserve">
          <source>The conversion is exact. Raise OverflowError on infinities and ValueError on NaNs.</source>
          <target state="translated">변환은 정확합니다. 인피니티에서는 OverflowError를, NaN에서는 ValueError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9a0858db8166719a0548328bc9ef5c570f7cfad8" translate="yes" xml:space="preserve">
          <source>The conversion types are:</source>
          <target state="translated">변환 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="105b71d0f8e9a7689ed5c98aeb32a3a6cbc24366" translate="yes" xml:space="preserve">
          <source>The conversion will be zero padded for numeric values.</source>
          <target state="translated">숫자 값의 경우 변환이 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7703cc3d251bd654ea393b2b50dea7fa2568320d" translate="yes" xml:space="preserve">
          <source>The converted value is left adjusted (overrides the &lt;code&gt;'0'&lt;/code&gt; conversion if both are given).</source>
          <target state="translated">변환 된 값은 조정 된 상태로 유지됩니다 ( 둘 다 제공되는 경우 &lt;code&gt;'0'&lt;/code&gt; 변환을 무시 함 ).</target>
        </trans-unit>
        <trans-unit id="232d6e721f1a28fd8262831489f11e15ce117ac5" translate="yes" xml:space="preserve">
          <source>The core built-in types for manipulating binary data are &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;. They are supported by &lt;a href=&quot;#memoryview&quot;&gt;&lt;code&gt;memoryview&lt;/code&gt;&lt;/a&gt; which uses the &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; to access the memory of other binary objects without needing to make a copy.</source>
          <target state="translated">이진 데이터를 조작하기위한 기본 내장 유형은 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 입니다. 이들은 지원하는 &lt;a href=&quot;#memoryview&quot;&gt; &lt;code&gt;memoryview&lt;/code&gt; &lt;/a&gt; 용도 &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜을&lt;/a&gt; 복사 할 필요없이, 다른 개체의 이진 메모리에 액세스.</target>
        </trans-unit>
        <trans-unit id="aff399bd4a4dfbace4eb3d199a751459af713c7e" translate="yes" xml:space="preserve">
          <source>The core built-in types for manipulating binary data are &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;. They are supported by &lt;a href=&quot;#memoryview&quot;&gt;&lt;code&gt;memoryview&lt;/code&gt;&lt;/a&gt; which uses the &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; to access the memory of other binary objects without needing to make a copy.</source>
          <target state="translated">The core built-in types for manipulating binary data are &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; and &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt;. They are supported by &lt;a href=&quot;#memoryview&quot;&gt; &lt;code&gt;memoryview&lt;/code&gt; &lt;/a&gt; which uses the &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; to access the memory of other binary objects without needing to make a copy.</target>
        </trans-unit>
        <trans-unit id="dc4d92fe7f0a481b0cfb48417959be4f39e5294d" translate="yes" xml:space="preserve">
          <source>The coroutine then has a chance to clean up or even deny the request by suppressing the exception with a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &amp;hellip; &lt;code&gt;except CancelledError&lt;/code&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block. Therefore, unlike &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt;&lt;code&gt;Future.cancel()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;Task.cancel()&lt;/code&gt;&lt;/a&gt; does not guarantee that the Task will be cancelled, although suppressing cancellation completely is not common and is actively discouraged.</source>
          <target state="translated">코 루틴은 다음과 예외를 억제하여 요청을 정리하거나 거부 할 수있는 기회가 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; ... &lt;code&gt;except CancelledError&lt;/code&gt; ... &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 차단합니다. 따라서, 달리 &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt; &lt;code&gt;Future.cancel()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;Task.cancel()&lt;/code&gt; &lt;/a&gt; 완전히 취소를 억제하는 것이 일반적인하지 않고 적극적으로 권장하지 않습니다 있지만 작업이 취소되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2dbd7b5d35ba022537e75df5de5c69f4ba45b31a" translate="yes" xml:space="preserve">
          <source>The coroutine then has a chance to clean up or even deny the request by suppressing the exception with a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt; &amp;hellip; &amp;hellip; &lt;code&gt;except CancelledError&lt;/code&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; block. Therefore, unlike &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt;&lt;code&gt;Future.cancel()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt;&lt;code&gt;Task.cancel()&lt;/code&gt;&lt;/a&gt; does not guarantee that the Task will be cancelled, although suppressing cancellation completely is not common and is actively discouraged.</source>
          <target state="translated">The coroutine then has a chance to clean up or even deny the request by suppressing the exception with a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &amp;hellip; &lt;code&gt;except CancelledError&lt;/code&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; block. Therefore, unlike &lt;a href=&quot;asyncio-future#asyncio.Future.cancel&quot;&gt; &lt;code&gt;Future.cancel()&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;#asyncio.Task.cancel&quot;&gt; &lt;code&gt;Task.cancel()&lt;/code&gt; &lt;/a&gt; does not guarantee that the Task will be cancelled, although suppressing cancellation completely is not common and is actively discouraged.</target>
        </trans-unit>
        <trans-unit id="bc1b5bbe66f8d0dac7e549cc0180896743986591" translate="yes" xml:space="preserve">
          <source>The corresponding error message, as provided by the operating system. It is formatted by the C functions &lt;code&gt;perror()&lt;/code&gt; under POSIX, and &lt;code&gt;FormatMessage()&lt;/code&gt; under Windows.</source>
          <target state="translated">운영 체제에서 제공 한 해당 오류 메시지 POSIX 에서 C 함수 &lt;code&gt;perror()&lt;/code&gt; 로, Windows에서 &lt;code&gt;FormatMessage()&lt;/code&gt; 로 형식이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="70d5450d9e84a7624d246a14f8334e480e6ee9b1" translate="yes" xml:space="preserve">
          <source>The corresponding simplest possible writing example is:</source>
          <target state="translated">가장 간단한 가능한 쓰기 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="99ba8850b932395d55f5c7b65d46a83173ec0e7a" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer calls &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;queue#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자가 &lt;a href=&quot;#multiprocessing.JoinableQueue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 모든 작업이 완료되었음을 나타내면 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;queue#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="b83253d660a4a6f7f73e5535fc2a5ea3481eca66" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer coroutine calls &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;#asyncio.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자 코 루틴이 &lt;a href=&quot;#asyncio.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 해당 항목에 대한 모든 작업이 완료되었음을 나타내면 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;#asyncio.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="39ba1f2977ddb0979cf75b4e181dad95efd3edcb" translate="yes" xml:space="preserve">
          <source>The count of unfinished tasks goes up whenever an item is added to the queue. The count goes down whenever a consumer thread calls &lt;a href=&quot;#queue.Queue.task_done&quot;&gt;&lt;code&gt;task_done()&lt;/code&gt;&lt;/a&gt; to indicate that the item was retrieved and all work on it is complete. When the count of unfinished tasks drops to zero, &lt;a href=&quot;#queue.Queue.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt; unblocks.</source>
          <target state="translated">완료되지 않은 작업의 수는 항목이 대기열에 추가 될 때마다 증가합니다. 소비자 스레드가 &lt;a href=&quot;#queue.Queue.task_done&quot;&gt; &lt;code&gt;task_done()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 항목이 검색되었고 해당 항목에 대한 모든 작업이 완료되었음을 나타낼 때마다 카운트가 줄어 듭니다 . 완료되지 않은 작업 수가 0으로 떨어지면 &lt;a href=&quot;#queue.Queue.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 차단이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="e08e1d045e84c6cb3e0262a5e1278aaaa956caeb" translate="yes" xml:space="preserve">
          <source>The created &lt;code&gt;pyvenv.cfg&lt;/code&gt; file also includes the &lt;code&gt;include-system-site-packages&lt;/code&gt; key, set to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;venv&lt;/code&gt; is run with the &lt;code&gt;--system-site-packages&lt;/code&gt; option, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">생성 된 &lt;code&gt;pyvenv.cfg&lt;/code&gt; 파일에는 &lt;code&gt;include-system-site-packages&lt;/code&gt; 키 도 포함되어 있으며 --ven &lt;code&gt;--system-site-packages&lt;/code&gt; 옵션으로 &lt;code&gt;venv&lt;/code&gt; 를 실행 하면 &lt;code&gt;true&lt;/code&gt; 로 설정되고 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4361350e28309ad8fede5d4bbb572c800f97e105" translate="yes" xml:space="preserve">
          <source>The created transport is an implementation-dependent bidirectional stream.</source>
          <target state="translated">생성 된 전송은 구현에 따른 양방향 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="b42a75b2b3e3e154cd9c1ea1403f52e8177428d0" translate="yes" xml:space="preserve">
          <source>The crux of each test is a call to &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt; to check for an expected result; &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt;&lt;code&gt;assertTrue()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt;&lt;code&gt;assertFalse()&lt;/code&gt;&lt;/a&gt; to verify a condition; or &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; to verify that a specific exception gets raised. These methods are used instead of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; statement so the test runner can accumulate all test results and produce a report.</source>
          <target state="translated">각 테스트의 핵심은 예상 결과를 확인하기 위해 &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것입니다. &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt; &lt;code&gt;assertTrue()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt; &lt;code&gt;assertFalse()&lt;/code&gt; &lt;/a&gt; 를 사용하여 조건을 확인합니다. 또는 &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 를 사용하여 특정 예외가 발생했는지 확인하십시오. 이러한 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#assert&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; 문 대신 사용 되므로 테스트 실행자는 모든 테스트 결과를 누적하고 보고서를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a391d77ae3244434edc4f526bb86bccb44f9dea6" translate="yes" xml:space="preserve">
          <source>The crux of each test is a call to &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt; to check for an expected result; &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt;&lt;code&gt;assertTrue()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt;&lt;code&gt;assertFalse()&lt;/code&gt;&lt;/a&gt; to verify a condition; or &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt; to verify that a specific exception gets raised. These methods are used instead of the &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#assert&quot;&gt;&lt;code&gt;assert&lt;/code&gt;&lt;/a&gt; statement so the test runner can accumulate all test results and produce a report.</source>
          <target state="translated">The crux of each test is a call to &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; to check for an expected result; &lt;a href=&quot;#unittest.TestCase.assertTrue&quot;&gt; &lt;code&gt;assertTrue()&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;#unittest.TestCase.assertFalse&quot;&gt; &lt;code&gt;assertFalse()&lt;/code&gt; &lt;/a&gt; to verify a condition; or &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; to verify that a specific exception gets raised. These methods are used instead of the &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#assert&quot;&gt; &lt;code&gt;assert&lt;/code&gt; &lt;/a&gt; statement so the test runner can accumulate all test results and produce a report.</target>
        </trans-unit>
        <trans-unit id="029b9273dbb02b6ea7417a3252afee02f4033d0b" translate="yes" xml:space="preserve">
          <source>The current algorithm has an early-out when it encounters a zero in the input. This means that the subsequent inputs are not tested for validity. (This behavior may change in the future.)</source>
          <target state="translated">현재 알고리즘은 입력에서 0을 만나면 조기 종료됩니다. 이는 후속 입력이 유효성을 테스트하지 않았 음을 의미합니다. (이 동작은 나중에 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="3d8bb9e42cfd6a06200a85ffbadb0aae65550388" translate="yes" xml:space="preserve">
          <source>The current implementation wakes up exactly &lt;em&gt;n&lt;/em&gt; threads, if at least &lt;em&gt;n&lt;/em&gt; threads are waiting. However, it&amp;rsquo;s not safe to rely on this behavior. A future, optimized implementation may occasionally wake up more than &lt;em&gt;n&lt;/em&gt; threads.</source>
          <target state="translated">최소한 &lt;em&gt;n 개의&lt;/em&gt; 스레드가 대기중인 경우 현재 구현은 정확히 &lt;em&gt;n 개의&lt;/em&gt; 스레드를 깨 웁니다 . 그러나이 동작에 의존하는 것은 안전하지 않습니다. 미래에 최적화 된 구현은 때때로 &lt;em&gt;n&lt;/em&gt; 개 이상의 스레드를 깨울 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="52a436678a1020bde214c0d97cdeb64bf8a1589a" translate="yes" xml:space="preserve">
          <source>The current internal state of the generator can also be queried. This is mostly useful for testing purposes, to ensure that internal state is being updated as expected:</source>
          <target state="translated">발전기의 현재 내부 상태도 쿼리 할 수 ​​있습니다. 이는 내부 상태가 예상대로 업데이트되도록 테스트 목적으로 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b161fdbf8f8dfdde9548c335694aae4ea27b9243" translate="yes" xml:space="preserve">
          <source>The current line in the current frame is indicated by &lt;code&gt;-&amp;gt;&lt;/code&gt;. If an exception is being debugged, the line where the exception was originally raised or propagated is indicated by &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, if it differs from the current line.</source>
          <target state="translated">현재 프레임의 현재 라인은 &lt;code&gt;-&amp;gt;&lt;/code&gt; 로 표시됩니다 . 예외를 디버깅하는 경우 예외가 원래 발생했거나 전파 된 행은 현재 행과 다른 경우 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="68241a388af98feb65b13ec5fad01a05b24e1abb" translate="yes" xml:space="preserve">
          <source>The current process is replaced immediately. Open file objects and descriptors are not flushed, so if there may be data buffered on these open files, you should flush them using &lt;code&gt;sys.stdout.flush()&lt;/code&gt; or &lt;a href=&quot;#os.fsync&quot;&gt;&lt;code&gt;os.fsync()&lt;/code&gt;&lt;/a&gt; before calling an &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">현재 프로세스가 즉시 교체됩니다. 열린 파일 객체 및 설명자는 플러시되지 않으므로 이러한 열린 파일에 데이터가 버퍼링 될 수있는 경우 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt; 함수를 호출하기 전에 &lt;code&gt;sys.stdout.flush()&lt;/code&gt; 또는 &lt;a href=&quot;#os.fsync&quot;&gt; &lt;code&gt;os.fsync()&lt;/code&gt; &lt;/a&gt; 를 사용하여 플러시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="dc9aa1e766143ced63bf297199daa209252dd44e" translate="yes" xml:space="preserve">
          <source>The current value of the progress bar. In &amp;ldquo;determinate&amp;rdquo; mode, this represents the amount of work completed. In &amp;ldquo;indeterminate&amp;rdquo; mode, it is interpreted as modulo &lt;em&gt;maximum&lt;/em&gt;; that is, the progress bar completes one &amp;ldquo;cycle&amp;rdquo; when its value increases by &lt;em&gt;maximum&lt;/em&gt;.</source>
          <target state="translated">진행률 표시 줄의 현재 값입니다. &quot;결정&quot;모드에서 완료된 작업량을 나타냅니다. &quot;불확정&quot;모드에서는 모듈로 &lt;em&gt;최대 값으로&lt;/em&gt; 해석됩니다 . 즉, 진행률 표시 줄의 값이 &lt;em&gt;최대&lt;/em&gt; 증가하면 하나의 &quot;사이클&quot;이 완료됩니다 .</target>
        </trans-unit>
        <trans-unit id="44c920e93ea8d45fdfebab1da8fb98b10091f105" translate="yes" xml:space="preserve">
          <source>The current-value setting of some widgets (like text entry widgets) can be connected directly to application variables by using special options. These options are &lt;code&gt;variable&lt;/code&gt;, &lt;code&gt;textvariable&lt;/code&gt;, &lt;code&gt;onvalue&lt;/code&gt;, &lt;code&gt;offvalue&lt;/code&gt;, and &lt;code&gt;value&lt;/code&gt;. This connection works both ways: if the variable changes for any reason, the widget it&amp;rsquo;s connected to will be updated to reflect the new value.</source>
          <target state="translated">텍스트 입력 위젯과 같은 일부 위젯의 현재 값 설정은 특수 옵션을 사용하여 애플리케이션 변수에 직접 연결할 수 있습니다. 이러한 옵션은 &lt;code&gt;variable&lt;/code&gt; , &lt;code&gt;textvariable&lt;/code&gt; , &lt;code&gt;onvalue&lt;/code&gt; , &lt;code&gt;offvalue&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 입니다. 이 연결은 두 가지 방식으로 작동합니다. 어떤 이유로 변수가 변경되면 연결된 위젯이 새 값을 반영하도록 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="a44b4e7cf28e49605dc244254c36f226b6f6a70e" translate="yes" xml:space="preserve">
          <source>The curses library does &amp;ldquo;line-breakout optimization&amp;rdquo; by looking for typeahead periodically while updating the screen. If input is found, and it is coming from a tty, the current update is postponed until refresh or doupdate is called again, allowing faster response to commands typed in advance. This function allows specifying a different file descriptor for typeahead checking.</source>
          <target state="translated">curses 라이브러리는 화면을 업데이트하는 동안 정기적으로 자동 검색 기능을 찾아&amp;ldquo;라인 브레이크 아웃 최적화&amp;rdquo;를 수행합니다. 입력이 발견되고 tty에서 오는 경우 새로 고침 또는 doupdate가 다시 호출 될 때까지 현재 업데이트가 연기되어 미리 입력 된 명령에 더 빠르게 응답 할 수 있습니다. 이 기능을 사용하면 자동 검색을 위해 다른 파일 설명자를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b01dfa066d22cfd22c2fff03df93dd7ff0910062" translate="yes" xml:space="preserve">
          <source>The cursor method accepts a single optional parameter &lt;em&gt;factory&lt;/em&gt;. If supplied, this must be a callable returning an instance of &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; or its subclasses.</source>
          <target state="translated">커서 메소드는 단일 선택적 매개 변수 &lt;em&gt;팩토리를&lt;/em&gt; 허용합니다 . 제공되는 경우 이는 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 해당 서브 클래스를 리턴하는 호출 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b06811008992340fc2dc7c59bbd5693bc9ce0ee4" translate="yes" xml:space="preserve">
          <source>The cursor will be unusable from this point forward; a &lt;a href=&quot;#sqlite3.ProgrammingError&quot;&gt;&lt;code&gt;ProgrammingError&lt;/code&gt;&lt;/a&gt; exception will be raised if any operation is attempted with the cursor.</source>
          <target state="translated">이 시점부터 커서를 사용할 수 없습니다. &lt;a href=&quot;#sqlite3.ProgrammingError&quot;&gt; &lt;code&gt;ProgrammingError&lt;/code&gt; 의&lt;/a&gt; 모든 작업이 커서 시도하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2adfa03e9423251347d2ddec72ca24f15adda1d8" translate="yes" xml:space="preserve">
          <source>The cut points are linearly interpolated from the two nearest data points. For example, if a cut point falls one-third of the distance between two sample values, &lt;code&gt;100&lt;/code&gt; and &lt;code&gt;112&lt;/code&gt;, the cut-point will evaluate to &lt;code&gt;104&lt;/code&gt;.</source>
          <target state="translated">컷 포인트는 가장 가까운 두 개의 데이터 포인트에서 선형 보간됩니다. 예를 들어, 컷 포인트가 두 샘플 값 &lt;code&gt;100&lt;/code&gt; 과 &lt;code&gt;112&lt;/code&gt; 사이의 거리의 1/3에 해당 하면 컷 포인트는 &lt;code&gt;104&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="e3acee39c7abbab9115fc8f08a2afc5d777a683e" translate="yes" xml:space="preserve">
          <source>The data compression is provided by the &lt;a href=&quot;zlib#module-zlib&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">데이터 압축은 &lt;a href=&quot;zlib#module-zlib&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 모듈에서 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="4732c01492e63cdd9d7c665f57a987ee799fc855" translate="yes" xml:space="preserve">
          <source>The data format used by &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; is Python-specific. This has the advantage that there are no restrictions imposed by external standards such as JSON or XDR (which can&amp;rsquo;t represent pointer sharing); however it means that non-Python programs may not be able to reconstruct pickled Python objects.</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 이 사용하는 데이터 형식 은 Python에 따라 다릅니다. 이는 JSON 또는 XDR (포인터 공유를 나타낼 수 없음)과 같은 외부 표준에 의해 부과 된 제한이 없다는 장점이 있습니다. 그러나 이것은 비 파이썬 프로그램이 피클 링 된 파이썬 객체를 재구성하지 못할 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad490902b06ce6c474539cea2f88c4d882fde489" translate="yes" xml:space="preserve">
          <source>The data read is buffered in memory, so do not use this method if the data size is large or unlimited.</source>
          <target state="translated">읽은 데이터는 메모리에 버퍼링되므로 데이터 크기가 크거나 무제한 인 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="381273eadd2ef918438fcbe00869dea87bc7b0ee" translate="yes" xml:space="preserve">
          <source>The data returned by &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; is the raw data returned by the server. This may be binary data (such as an image), plain text or (for example) HTML. The HTTP protocol provides type information in the reply header, which can be inspected by looking at the &lt;em&gt;Content-Type&lt;/em&gt; header. If the returned data is HTML, you can use the module &lt;a href=&quot;html.parser#module-html.parser&quot;&gt;&lt;code&gt;html.parser&lt;/code&gt;&lt;/a&gt; to parse it.</source>
          <target state="translated">반환하는 데이터 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 서버에 의해 반환 된 원시 데이터이다. 이진 데이터 (예 : 이미지), 일반 텍스트 또는 HTML (예 : HTML) 일 수 있습니다. HTTP 프로토콜은 응답 헤더에 유형 정보를 제공하며 이는 &lt;em&gt;Content-Type&lt;/em&gt; 헤더를 보고 검사 할 수 있습니다 . 반환 된 데이터가 HTML 인 경우 &lt;a href=&quot;html.parser#module-html.parser&quot;&gt; &lt;code&gt;html.parser&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 구문 분석 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb6758afc9485fe5a6fb81c1866b77aa22d9b3e5" translate="yes" xml:space="preserve">
          <source>The data you&amp;rsquo;ve saved is persistent and is available in subsequent sessions:</source>
          <target state="translated">저장 한 데이터는 영구적이며 다음 세션에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07798be371fad61c3fb93bf3ac316396b61294ce" translate="yes" xml:space="preserve">
          <source>The database will contain just the schema and the validation records when this function returns.</source>
          <target state="translated">이 함수가 반환되면 데이터베이스에는 스키마와 유효성 검사 레코드 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d274876e4079ca20009328bf8e5cde4e56d7abf9" translate="yes" xml:space="preserve">
          <source>The debugger is extensible &amp;ndash; it is actually defined as the class &lt;a href=&quot;#pdb.Pdb&quot;&gt;&lt;code&gt;Pdb&lt;/code&gt;&lt;/a&gt;. This is currently undocumented but easily understood by reading the source. The extension interface uses the modules &lt;a href=&quot;bdb#module-bdb&quot;&gt;&lt;code&gt;bdb&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;cmd#module-cmd&quot;&gt;&lt;code&gt;cmd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">디버거는 확장 가능합니다. 실제로는 &lt;a href=&quot;#pdb.Pdb&quot;&gt; &lt;code&gt;Pdb&lt;/code&gt; &lt;/a&gt; 클래스로 정의됩니다 . 이것은 현재 문서화되어 있지 않지만 소스를 읽으면 쉽게 이해할 수 있습니다. 확장 인터페이스는 &lt;a href=&quot;bdb#module-bdb&quot;&gt; &lt;code&gt;bdb&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;cmd#module-cmd&quot;&gt; &lt;code&gt;cmd&lt;/code&gt; &lt;/a&gt; 모듈을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="095b5670be6e411b1e73958df31e2f6ac1da2d0c" translate="yes" xml:space="preserve">
          <source>The debugger supports &lt;a href=&quot;#debugger-aliases&quot;&gt;aliases&lt;/a&gt;. Aliases can have parameters which allows one a certain level of adaptability to the context under examination.</source>
          <target state="translated">디버거는 &lt;a href=&quot;#debugger-aliases&quot;&gt;별칭을&lt;/a&gt; 지원 합니다 . 별칭에는 검사중인 컨텍스트에 특정 수준의 적응성을 허용하는 매개 변수가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6427247e8f8887424311f6b6d15aa4b617225615" translate="yes" xml:space="preserve">
          <source>The debugger&amp;rsquo;s prompt is &lt;code&gt;(Pdb)&lt;/code&gt;. Typical usage to run a program under control of the debugger is:</source>
          <target state="translated">디버거의 프롬프트는 &lt;code&gt;(Pdb)&lt;/code&gt; 입니다. 디버거의 제어하에 프로그램을 실행하는 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5def3aa4d7a228de01c175df183f95bac9ef0b71" translate="yes" xml:space="preserve">
          <source>The debugging flags necessary for the collector to print information about a leaking program (equal to &lt;code&gt;DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE |
DEBUG_SAVEALL&lt;/code&gt;).</source>
          <target state="translated">콜렉터가 누출 프로그램에 대한 정보를 인쇄하는 데 필요한 디버깅 플래그 ( &lt;code&gt;DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL&lt;/code&gt; 과 동일 ).</target>
        </trans-unit>
        <trans-unit id="90287af497864716aa30b5d7a8cbe1542d08cbc7" translate="yes" xml:space="preserve">
          <source>The decimal module incorporates a notion of significant places so that &lt;code&gt;1.30
+ 1.20&lt;/code&gt; is &lt;code&gt;2.50&lt;/code&gt;. The trailing zero is kept to indicate significance. This is the customary presentation for monetary applications. For multiplication, the &amp;ldquo;schoolbook&amp;rdquo; approach uses all the figures in the multiplicands. For instance, &lt;code&gt;1.3 * 1.2&lt;/code&gt; gives &lt;code&gt;1.56&lt;/code&gt; while &lt;code&gt;1.30 *
1.20&lt;/code&gt; gives &lt;code&gt;1.5600&lt;/code&gt;.</source>
          <target state="translated">10 진수 모듈은 &lt;code&gt;1.30 + 1.20&lt;/code&gt; 이 &lt;code&gt;2.50&lt;/code&gt; 이 되도록 중요한 장소 개념을 통합합니다 . 후행 0은 유의성을 나타 내기 위해 유지됩니다. 이것은 화폐 응용 프로그램을위한 일반적인 프레젠테이션입니다. 곱셈을 위해,&amp;ldquo;schoolbook&amp;rdquo;접근법은 곱셈의 모든 숫자를 사용합니다. 예를 들어 &lt;code&gt;1.3 * 1.2&lt;/code&gt; 는 &lt;code&gt;1.56&lt;/code&gt; , &lt;code&gt;1.30 * 1.20&lt;/code&gt; 은 &lt;code&gt;1.5600&lt;/code&gt; 을 제공 합니다 .</target>
        </trans-unit>
        <trans-unit id="bc5331a4ec577ee10bc6dc4f46c2d0c2800f6ff8" translate="yes" xml:space="preserve">
          <source>The decimal module was designed to support &amp;ldquo;without prejudice, both exact unrounded decimal arithmetic (sometimes called fixed-point arithmetic) and rounded floating-point arithmetic.&amp;rdquo; &amp;ndash; excerpt from the decimal arithmetic specification.</source>
          <target state="translated">decimal 모듈은 &quot;정확한 반올림 십진 산술 (때로는 고정 소수점 산술) 및 둥근 부동 소수점 산술&quot;을 모두 편견없이 지원하도록 설계되었습니다. &amp;ndash; 십진 산술 스펙에서 발췌.</target>
        </trans-unit>
        <trans-unit id="fcd953820c180c8fd51fd721bc40a9145788703c" translate="yes" xml:space="preserve">
          <source>The decoder must be able to handle zero length input and return an empty object of the output object type in this situation.</source>
          <target state="translated">이 상황에서 디코더는 길이가 0 인 입력을 처리하고 출력 객체 유형의 빈 객체를 반환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4370c4771bb3ea3eff3bcc09178bfbdc4274e2bd" translate="yes" xml:space="preserve">
          <source>The decorated method will take in the &lt;strong&gt;name&lt;/strong&gt; of the module to be loaded as expected for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;. If the module is not found in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; then a new one is constructed. Regardless of where the module came from, &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__loader__&quot;&gt;&lt;code&gt;__loader__&lt;/code&gt;&lt;/a&gt; set to &lt;strong&gt;self&lt;/strong&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt; is set based on what &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt;&lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt;&lt;/a&gt; returns (if available). These attributes are set unconditionally to support reloading.</source>
          <target state="translated">데코 레이팅 된 메소드는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더에&lt;/a&gt; 필요한대로로드 될 모듈 의 &lt;strong&gt;이름&lt;/strong&gt; 을 받습니다. &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 모듈이 없으면 새 모듈 이 구성됩니다. 에 관계없이 모듈은, 어디에서 왔는지의 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__loader__&quot;&gt; &lt;code&gt;__loader__&lt;/code&gt; &lt;/a&gt; 로 설정 &lt;strong&gt;자기&lt;/strong&gt; 와 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; 가&lt;/a&gt; 무엇을 기반으로 세트되어 &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt; &lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt; &lt;/a&gt; (사용 가능한 경우)으로 돌아갑니다. 이러한 속성은 무조건 재로드를 지원하도록 설정됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b24c82180702500e76309b022bd08cdb12282f6b" translate="yes" xml:space="preserve">
          <source>The decorated method will take in the &lt;strong&gt;name&lt;/strong&gt; of the module to be loaded as expected for a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;. If the module is not found in &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; then a new one is constructed. Regardless of where the module came from, &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__loader__&quot;&gt;&lt;code&gt;__loader__&lt;/code&gt;&lt;/a&gt; set to &lt;strong&gt;self&lt;/strong&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt; is set based on what &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt;&lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt;&lt;/a&gt; returns (if available). These attributes are set unconditionally to support reloading.</source>
          <target state="translated">The decorated method will take in the &lt;strong&gt;name&lt;/strong&gt; of the module to be loaded as expected for a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt;. If the module is not found in &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; &lt;/a&gt; then a new one is constructed. Regardless of where the module came from, &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__loader__&quot;&gt; &lt;code&gt;__loader__&lt;/code&gt; &lt;/a&gt; set to &lt;strong&gt;self&lt;/strong&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; &lt;/a&gt; is set based on what &lt;a href=&quot;#importlib.abc.InspectLoader.is_package&quot;&gt; &lt;code&gt;importlib.abc.InspectLoader.is_package()&lt;/code&gt; &lt;/a&gt; returns (if available). These attributes are set unconditionally to support reloading.</target>
        </trans-unit>
        <trans-unit id="5cffc98a45b4b4fc8fac139e7a5b9aef8a25d0d4" translate="yes" xml:space="preserve">
          <source>The decorator also provides a &lt;code&gt;cache_clear()&lt;/code&gt; function for clearing or invalidating the cache.</source>
          <target state="translated">데코레이터는 캐시를 지우거나 무효화하기위한 &lt;code&gt;cache_clear()&lt;/code&gt; 함수 도 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="9241d41c4f3d0d35ed609d927b5431512d3a0115" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; mechanism behaves differently with different types of objects, as it attempts to produce the most relevant, rather than complete, information:</source>
          <target state="translated">기본 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 메커니즘은 완전한 정보가 아닌 가장 관련성 높은 정보를 생성하려고 시도하므로 다른 유형의 객체와 다르게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d84a97fb732f65d135a8de533f5d2309e5002866" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; iterator iterates over message representations, not keys as the default dictionary iterator does. Moreover, modification of a mailbox during iteration is safe and well-defined. Messages added to the mailbox after an iterator is created will not be seen by the iterator. Messages removed from the mailbox before the iterator yields them will be silently skipped, though using a key from an iterator may result in a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception if the corresponding message is subsequently removed.</source>
          <target state="translated">기본 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 반복기는 기본 사전 반복기와 달리 키가 아니라 메시지 표현을 반복합니다. 또한 반복하는 동안 사서함을 수정하는 것이 안전하고 명확합니다. 반복자가 작성된 후 메일함에 추가 된 메시지는 반복자가 볼 수 없습니다. 반복자가 생성하기 전에 메일 함에서 제거 된 메시지는 자동으로 건너 뛰지 만 반복기에서 키를 사용 하면 해당 메시지가 제거되면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7023b4c42786b06e66d2c26c5b1ab41a4737daa9" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#random.random&quot;&gt;&lt;code&gt;random()&lt;/code&gt;&lt;/a&gt; returns multiples of 2⁻⁵&amp;sup3; in the range &lt;em&gt;0.0 &amp;le; x &amp;lt; 1.0&lt;/em&gt;. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, &lt;code&gt;0.05954861408025609&lt;/code&gt; isn&amp;rsquo;t an integer multiple of 2⁻⁵&amp;sup3;.</source>
          <target state="translated">The default &lt;a href=&quot;#random.random&quot;&gt; &lt;code&gt;random()&lt;/code&gt; &lt;/a&gt; returns multiples of 2⁻⁵&amp;sup3; in the range &lt;em&gt;0.0 &amp;le; x &amp;lt; 1.0&lt;/em&gt;. All such numbers are evenly spaced and are exactly representable as Python floats. However, many other representable floats in that interval are not possible selections. For example, &lt;code&gt;0.05954861408025609&lt;/code&gt; isn&amp;rsquo;t an integer multiple of 2⁻⁵&amp;sup3;.</target>
        </trans-unit>
        <trans-unit id="e15110f55746d7dd1c750929856c5c1b270b72ba" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; includes several common deployment locations for the time zone database (except on Windows, where there are no &amp;ldquo;well-known&amp;rdquo; locations for time zone data). On POSIX systems, downstream distributors and those building Python from source who know where their system time zone data is deployed may change the default time zone path by specifying the compile-time option &lt;code&gt;TZPATH&lt;/code&gt; (or, more likely, the &lt;code&gt;configure&lt;/code&gt; flag &lt;code&gt;--with-tzpath&lt;/code&gt;), which should be a string delimited by &lt;a href=&quot;os#os.pathsep&quot;&gt;&lt;code&gt;os.pathsep&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The default &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; &lt;/a&gt; includes several common deployment locations for the time zone database (except on Windows, where there are no &amp;ldquo;well-known&amp;rdquo; locations for time zone data). On POSIX systems, downstream distributors and those building Python from source who know where their system time zone data is deployed may change the default time zone path by specifying the compile-time option &lt;code&gt;TZPATH&lt;/code&gt; (or, more likely, the &lt;code&gt;configure&lt;/code&gt; flag &lt;code&gt;--with-tzpath&lt;/code&gt; ), which should be a string delimited by &lt;a href=&quot;os#os.pathsep&quot;&gt; &lt;code&gt;os.pathsep&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="236a0e626d5c5d12c8775257081e57eb6e890e38" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt;&lt;code&gt;TZPATH&lt;/code&gt;&lt;/a&gt; when not otherwise specified can be configured at &lt;a href=&quot;#zoneinfo-data-compile-time-config&quot;&gt;compile time&lt;/a&gt;.</source>
          <target state="translated">The default &lt;a href=&quot;#zoneinfo.TZPATH&quot;&gt; &lt;code&gt;TZPATH&lt;/code&gt; &lt;/a&gt; when not otherwise specified can be configured at &lt;a href=&quot;#zoneinfo-data-compile-time-config&quot;&gt;compile time&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="9f6bd331cdd8851c589608705300fea060ae29b3" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;PathFinder&lt;/code&gt; for Python includes a hook that calls into &lt;code&gt;importlib.metadata.MetadataPathFinder&lt;/code&gt; for finding distributions loaded from typical file-system-based paths.</source>
          <target state="translated">Python 의 기본 &lt;code&gt;PathFinder&lt;/code&gt; 에는 일반적인 파일 시스템 기반 경로에서로드 된 배포를 찾기 위해 &lt;code&gt;importlib.metadata.MetadataPathFinder&lt;/code&gt; 를 호출하는 후크가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e08f1b8ed360aa3fdbcb31fe8c46e2aefb98f856" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;format_spec&lt;/em&gt; is an empty string which usually gives the same effect as calling &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str(value)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;em&gt;format_spec&lt;/em&gt; 은 빈 문자열이며 일반적으로 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str(value)&lt;/code&gt; &lt;/a&gt; 호출과 동일한 효과를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="916e4b68347b1b5b55f8b8dfbbfb3aa9f77bde33" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;locals&lt;/em&gt; act as described for function &lt;a href=&quot;#locals&quot;&gt;&lt;code&gt;locals()&lt;/code&gt;&lt;/a&gt; below: modifications to the default &lt;em&gt;locals&lt;/em&gt; dictionary should not be attempted. Pass an explicit &lt;em&gt;locals&lt;/em&gt; dictionary if you need to see effects of the code on &lt;em&gt;locals&lt;/em&gt; after function &lt;a href=&quot;#exec&quot;&gt;&lt;code&gt;exec()&lt;/code&gt;&lt;/a&gt; returns.</source>
          <target state="translated">기본 &lt;em&gt;지역은&lt;/em&gt; 아래의 &lt;a href=&quot;#locals&quot;&gt; &lt;code&gt;locals()&lt;/code&gt; &lt;/a&gt; 함수에 대해 설명 된대로 작동 합니다. 기본 &lt;em&gt;지역&lt;/em&gt; 사전을 수정 하지 마십시오. &lt;a href=&quot;#exec&quot;&gt; &lt;code&gt;exec()&lt;/code&gt; &lt;/a&gt; 함수가 반환 된 후 코드가 &lt;em&gt;로컬&lt;/em&gt; 에 미치는 영향을 보려면 명시 적 &lt;em&gt;로컬&lt;/em&gt; 사전을 전달하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fcc1fc4b3a3ae0a82e1e9c7f968eba8efba69cd8" translate="yes" xml:space="preserve">
          <source>The default &lt;em&gt;method&lt;/em&gt; is &amp;ldquo;exclusive&amp;rdquo; and is used for data sampled from a population that can have more extreme values than found in the samples. The portion of the population falling below the &lt;em&gt;i-th&lt;/em&gt; of &lt;em&gt;m&lt;/em&gt; sorted data points is computed as &lt;code&gt;i / (m + 1)&lt;/code&gt;. Given nine sample values, the method sorts them and assigns the following percentiles: 10%, 20%, 30%, 40%, 50%, 60%, 70%, 80%, 90%.</source>
          <target state="translated">기본 &lt;em&gt;방법&lt;/em&gt; 은 &quot;배타적&quot;이며 표본에서 찾은 것보다 더 극단적 인 값을 가질 수있는 모집단에서 샘플링 된 데이터에 사용됩니다. 아래 떨어지는 인구 부분 &lt;em&gt;의 i 번째&lt;/em&gt; 의 &lt;em&gt;m은&lt;/em&gt; 데이터 포인트가 계산된다 정렬 같은 &lt;code&gt;i / (m + 1)&lt;/code&gt; . 9 개의 표본 값이 주어지면이 방법은 값을 정렬하고 10 %, 20 %, 30 %, 40 %, 50 %, 60 %, 70 %, 80 %, 90 % 백분위 수를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="cc26c9794d7c7424fc9e7bc14e214666252c9274" translate="yes" xml:space="preserve">
          <source>The default asyncio event loop implementation on &lt;strong&gt;Windows&lt;/strong&gt; does not support subprocesses. Subprocesses are available for Windows if a &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; is used. See &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;Subprocess Support on Windows&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Windows&lt;/strong&gt; 에서 기본 asyncio 이벤트 루프 구현은 하위 프로세스를 지원하지 않습니다. &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 가 사용되는 경우 서브 프로세스는 Windows 에 사용 가능합니다. 자세한 내용 &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;은 Windows의 하위 프로세스 지원을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="73f9f71a010dfccdb59de7aba2ccdae124aedfba" translate="yes" xml:space="preserve">
          <source>The default asyncio event loop on &lt;strong&gt;Windows&lt;/strong&gt; does not support subprocesses. See &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;Subprocess Support on Windows&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;Windows&lt;/strong&gt; 의 기본 asyncio 이벤트 루프는 하위 프로세스를 지원하지 않습니다. 자세한 내용 &lt;a href=&quot;asyncio-platforms#asyncio-windows-subprocess&quot;&gt;은 Windows의 하위 프로세스 지원을&lt;/a&gt; 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="320d764d5f91986c0ce197a99b5dafc84e75fdbe" translate="yes" xml:space="preserve">
          <source>The default asyncio policy. Uses &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; on Unix and &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">기본 비동기 정책입니다. Unix에서는 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용 하고 Windows에서는 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="99843d8504993a7ac9fb3c4008f6662e1e83ea6f" translate="yes" xml:space="preserve">
          <source>The default category for &lt;a href=&quot;#warnings.warn&quot;&gt;&lt;code&gt;warn()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#warnings.warn&quot;&gt; &lt;code&gt;warn()&lt;/code&gt; &lt;/a&gt; 의 기본 카테고리입니다 .</target>
        </trans-unit>
        <trans-unit id="32f43bb65b67ab4e0064d8679c4a8ed6f5c74251" translate="yes" xml:space="preserve">
          <source>The default character encoding: &lt;code&gt;'utf-8'&lt;/code&gt; on Windows, the value returned by &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">기본 문자 인코딩 : Windows의 경우 &lt;code&gt;'utf-8'&lt;/code&gt; , 그렇지 않으면 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 값</target>
        </trans-unit>
        <trans-unit id="699b9c61ff10c5e5fb972c7c169896f4dd36a566" translate="yes" xml:space="preserve">
          <source>The default converters are registered under the name &amp;ldquo;date&amp;rdquo; for &lt;a href=&quot;datetime#datetime.date&quot;&gt;&lt;code&gt;datetime.date&lt;/code&gt;&lt;/a&gt; and under the name &amp;ldquo;timestamp&amp;rdquo; for &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 컨버터의 이름 &quot;날짜&quot;에 등록되어 &lt;a href=&quot;datetime#datetime.date&quot;&gt; &lt;code&gt;datetime.date&lt;/code&gt; &lt;/a&gt; 와의 이름 &quot;타임 스탬프&quot;에서 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2494a42ce8bba5dc27f841ef5b2c492ffdeada25" translate="yes" xml:space="preserve">
          <source>The default encoding is UTF-8, following &lt;a href=&quot;https://tools.ietf.org/html/rfc2640.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2640&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">The default encoding is UTF-8, following &lt;a href=&quot;https://tools.ietf.org/html/rfc2640.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2640&lt;/strong&gt;&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="3141ba81acf49f8773568f9b1b5765ab02702638" translate="yes" xml:space="preserve">
          <source>The default environment variables to be included in every request&amp;rsquo;s WSGI environment. By default, this is a copy of &lt;code&gt;os.environ&lt;/code&gt; at the time that &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt;&lt;code&gt;wsgiref.handlers&lt;/code&gt;&lt;/a&gt; was imported, but subclasses can either create their own at the class or instance level. Note that the dictionary should be considered read-only, since the default value is shared between multiple classes and instances.</source>
          <target state="translated">모든 요청의 WSGI 환경에 포함될 기본 환경 변수 기본적 으로 이는 &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt; &lt;code&gt;wsgiref.handlers&lt;/code&gt; &lt;/a&gt; 를 가져올 때 &lt;code&gt;os.environ&lt;/code&gt; 의 사본 이지만 서브 클래스는 클래스 또는 인스턴스 레벨에서 자체적으로 작성할 수 있습니다. 기본값은 여러 클래스와 인스턴스간에 공유되므로 사전은 읽기 전용으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="767891311ec1c9837f1ed84b97b20ded10b66b5a" translate="yes" xml:space="preserve">
          <source>The default exception handler implementation.</source>
          <target state="translated">기본 예외 처리기 구현</target>
        </trans-unit>
        <trans-unit id="3d5425253eafabfc0e77cfbd292665f236078454" translate="yes" xml:space="preserve">
          <source>The default for &lt;em&gt;start&lt;/em&gt; is 0, which means to start at the beginning of the file. The default for &lt;em&gt;len&lt;/em&gt; is 0 which means to lock to the end of the file. The default for &lt;em&gt;whence&lt;/em&gt; is also 0.</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 의 기본값 은 0이며 이는 파일의 시작 부분에서 시작 함을 의미합니다. &lt;em&gt;len&lt;/em&gt; 의 기본값 은 0이며 파일의 끝에 고정됩니다. &lt;em&gt;whence&lt;/em&gt; 의 기본값 도 0입니다.</target>
        </trans-unit>
        <trans-unit id="abe205ba756ba81b25d657d298d23ad7a01daa01" translate="yes" xml:space="preserve">
          <source>The default format for creating archives. This is currently &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt;&lt;code&gt;PAX_FORMAT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아카이브를 만들기위한 기본 형식입니다. 이것은 현재 &lt;a href=&quot;#tarfile.PAX_FORMAT&quot;&gt; &lt;code&gt;PAX_FORMAT&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c9c328c8250ee7fbc742006787cb7e770c62bb77" translate="yes" xml:space="preserve">
          <source>The default hook formats &lt;em&gt;err_msg&lt;/em&gt; and &lt;em&gt;object&lt;/em&gt; as: &lt;code&gt;f'{err_msg}: {object!r}'&lt;/code&gt;; use &amp;ldquo;Exception ignored in&amp;rdquo; error message if &lt;em&gt;err_msg&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기본 후크는 &lt;em&gt;err_msg&lt;/em&gt; 및 &lt;em&gt;오브젝트&lt;/em&gt; 를 다음 과 같이 형식화 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;f'{err_msg}: {object!r}'&lt;/code&gt; ; &lt;em&gt;err_msg&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우&amp;ldquo;예외 무시 됨&amp;rdquo;오류 메시지를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1589b3dd1729a28688aa3d39f228898b217d6cf6" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.errors&quot;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.errors&quot;&gt; &lt;code&gt;errors&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="b56f4f78eb0697ad959e9a5452169aa756143e2d" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.expectedFailures&quot;&gt;&lt;code&gt;expectedFailures&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.expectedFailures&quot;&gt; &lt;code&gt;expectedFailures&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="21d58dd74e7a05377422bda965cebdafd7e57ccd" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, formatted_err)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.failures&quot;&gt;&lt;code&gt;failures&lt;/code&gt;&lt;/a&gt; attribute, where &lt;em&gt;formatted_err&lt;/em&gt; is a formatted traceback derived from &lt;em&gt;err&lt;/em&gt;.</source>
          <target state="translated">기본 구현은 튜플 &lt;code&gt;(test, formatted_err)&lt;/code&gt; 을 인스턴스의 &lt;a href=&quot;#unittest.TestResult.failures&quot;&gt; &lt;code&gt;failures&lt;/code&gt; &lt;/a&gt; 속성에 추가합니다. 여기서 &lt;em&gt;formatted_err&lt;/em&gt; 은 &lt;em&gt;err&lt;/em&gt; 에서 파생 된 형식화 된 역 추적 입니다.</target>
        </trans-unit>
        <trans-unit id="43823f6cabcd0ef79ab62b973c7aee77f8f732d4" translate="yes" xml:space="preserve">
          <source>The default implementation appends a tuple &lt;code&gt;(test, reason)&lt;/code&gt; to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.skipped&quot;&gt;&lt;code&gt;skipped&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">기본 구현 은 인스턴스의 &lt;a href=&quot;#unittest.TestResult.skipped&quot;&gt; &lt;code&gt;skipped&lt;/code&gt; &lt;/a&gt; 속성에 튜플 &lt;code&gt;(test, reason)&lt;/code&gt; 을 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="a68c1418f74a6200967462b2f59268c9e36ca435" translate="yes" xml:space="preserve">
          <source>The default implementation appends the test to the instance&amp;rsquo;s &lt;a href=&quot;#unittest.TestResult.unexpectedSuccesses&quot;&gt;&lt;code&gt;unexpectedSuccesses&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">기본 구현은 테스트를 인스턴스의 &lt;a href=&quot;#unittest.TestResult.unexpectedSuccesses&quot;&gt; &lt;code&gt;unexpectedSuccesses&lt;/code&gt; &lt;/a&gt; 속성에 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="85209bebc3f90535b12a5ecb3ddcc009e82c4607" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &amp;lsquo;namer&amp;rsquo; attribute of the handler, if it&amp;rsquo;s callable, passing the default name to it. If the attribute isn&amp;rsquo;t callable (the default is &lt;code&gt;None&lt;/code&gt;), the name is returned unchanged.</source>
          <target state="translated">기본 구현은 핸들러의 'namer'속성을 호출 할 수있는 경우 기본 이름을 전달하여 처리기의 'namer'속성을 호출합니다. 속성을 호출 할 수없는 경우 (기본값은 &lt;code&gt;None&lt;/code&gt; ) 이름은 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7fe6b93c4fa5530304a79d65cec6508761d9ab" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &amp;lsquo;rotator&amp;rsquo; attribute of the handler, if it&amp;rsquo;s callable, passing the source and dest arguments to it. If the attribute isn&amp;rsquo;t callable (the default is &lt;code&gt;None&lt;/code&gt;), the source is simply renamed to the destination.</source>
          <target state="translated">기본 구현은 핸들러의 'rotator'속성을 호출 가능하면 소스 및 대상 인수를 전달하여 호출합니다. 속성을 호출 할 수없는 경우 (기본값은 &lt;code&gt;None&lt;/code&gt; ) 소스의 이름 만 대상으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="8abbab4876bdfe46805a30d39840791095f498ce" translate="yes" xml:space="preserve">
          <source>The default implementation calls the &lt;code&gt;append&lt;/code&gt; method of the &lt;code&gt;defects&lt;/code&gt; attribute of &lt;em&gt;obj&lt;/em&gt;. When the email package calls &lt;a href=&quot;#email.policy.Policy.handle_defect&quot;&gt;&lt;code&gt;handle_defect&lt;/code&gt;&lt;/a&gt;, &lt;em&gt;obj&lt;/em&gt; will normally have a &lt;code&gt;defects&lt;/code&gt; attribute that has an &lt;code&gt;append&lt;/code&gt; method. Custom object types used with the email package (for example, custom &lt;code&gt;Message&lt;/code&gt; objects) should also provide such an attribute, otherwise defects in parsed messages will raise unexpected errors.</source>
          <target state="translated">기본 구현 은 &lt;em&gt;obj&lt;/em&gt; 의 &lt;code&gt;defects&lt;/code&gt; 속성의 &lt;code&gt;append&lt;/code&gt; 메소드를 호출합니다 . 전자 메일 패키지가 &lt;a href=&quot;#email.policy.Policy.handle_defect&quot;&gt; &lt;code&gt;handle_defect&lt;/code&gt; 를&lt;/a&gt; 호출 하면 &lt;em&gt;obj&lt;/em&gt; 는 일반적으로 &lt;code&gt;append&lt;/code&gt; 메소드 가있는 &lt;code&gt;defects&lt;/code&gt; 속성을 갖습니다 . 전자 메일 패키지와 함께 사용되는 사용자 정의 개체 유형 (예 : 사용자 정의 &lt;code&gt;Message&lt;/code&gt; 개체)도 그러한 속성을 제공해야합니다. 그렇지 않으면 구문 분석 된 메시지의 결함으로 인해 예기치 않은 오류가 발생합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd2beae2a9d6bd5ba6ba29d1fa217c82f8717685" translate="yes" xml:space="preserve">
          <source>The default implementation checks the &lt;a href=&quot;#email.policy.Policy.raise_on_defect&quot;&gt;&lt;code&gt;raise_on_defect&lt;/code&gt;&lt;/a&gt; flag. If it is &lt;code&gt;True&lt;/code&gt;, &lt;em&gt;defect&lt;/em&gt; is raised as an exception. If it is &lt;code&gt;False&lt;/code&gt; (the default), &lt;em&gt;obj&lt;/em&gt; and &lt;em&gt;defect&lt;/em&gt; are passed to &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt;&lt;code&gt;register_defect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#email.policy.Policy.raise_on_defect&quot;&gt; &lt;code&gt;raise_on_defect&lt;/code&gt; &lt;/a&gt; 플래그를 확인합니다 . 이 경우 &lt;code&gt;True&lt;/code&gt; , &lt;em&gt;결함은&lt;/em&gt; 예외로 발생합니다. 이 경우 &lt;code&gt;False&lt;/code&gt; (기본), &lt;em&gt;OBJ&lt;/em&gt; 및 &lt;em&gt;결함&lt;/em&gt; 에 전달되는 &lt;a href=&quot;#email.policy.Policy.register_defect&quot;&gt; &lt;code&gt;register_defect()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4694874ec5c0e9b8375091742765ef75ea74e946" translate="yes" xml:space="preserve">
          <source>The default implementation decides how to dispatch a frame, depending on the type of event (passed as a string) that is about to be executed. &lt;em&gt;event&lt;/em&gt; can be one of the following:</source>
          <target state="translated">기본 구현은 실행하려고하는 이벤트 유형 (문자열로 전달됨)에 따라 프레임을 디스패치하는 방법을 결정합니다. &lt;em&gt;event&lt;/em&gt; 는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61b526d9bcd0fde98e256c446b3ae46e0b58b532" translate="yes" xml:space="preserve">
          <source>The default implementation defers to &lt;a href=&quot;#io.RawIOBase.readall&quot;&gt;&lt;code&gt;readall()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.RawIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#io.RawIOBase.readall&quot;&gt; &lt;code&gt;readall()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.RawIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 연기합니다 .</target>
        </trans-unit>
        <trans-unit id="30e7acef377f89e7b6c8ef2a0dae31deb9d115cc" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing when the outcome is a success, and records subtest failures as normal failures.</source>
          <target state="translated">기본 구현은 결과가 성공한 경우 아무 작업도 수행하지 않으며 하위 테스트 실패를 일반 실패로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="917b792910290b9f104f9e9bb1c1c376f6e62a1b" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67df62e256ec06c97f02e23b90b57d437ba78502" translate="yes" xml:space="preserve">
          <source>The default implementation first consults the environment variable &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-2&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;. If that is set to &lt;code&gt;&quot;0&quot;&lt;/code&gt; then this function returns immediately; i.e. it is a no-op. If the environment variable is not set, or is set to the empty string, &lt;code&gt;pdb.set_trace()&lt;/code&gt; is called. Otherwise this variable should name a function to run, using Python&amp;rsquo;s dotted-import nomenclature, e.g. &lt;code&gt;package.subpackage.module.function&lt;/code&gt;. In this case, &lt;code&gt;package.subpackage.module&lt;/code&gt; would be imported and the resulting module must have a callable named &lt;code&gt;function()&lt;/code&gt;. This is run, passing in &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt;, and whatever &lt;code&gt;function()&lt;/code&gt; returns, &lt;code&gt;sys.breakpointhook()&lt;/code&gt; returns to the built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">기본 구현은 먼저 환경 변수 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-2&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 를 참조&lt;/a&gt; 합니다. 이것이 &lt;code&gt;&quot;0&quot;&lt;/code&gt; 으로 설정되면 이 함수는 즉시 리턴합니다. 즉, 그것은 no-op입니다. 환경 변수가 설정되지 않거나 빈 문자열로 설정된 경우 &lt;code&gt;pdb.set_trace()&lt;/code&gt; 가 호출됩니다. 그렇지 않으면이 변수는 Python의 점으로 불러 오기 된 명명법 (예 : &lt;code&gt;package.subpackage.module.function&lt;/code&gt; )을 사용하여 실행할 함수의 이름을 지정해야 합니다 . 이 경우 &lt;code&gt;package.subpackage.module&lt;/code&gt; 을 가져오고 결과 모듈에는 호출 가능한 이름이 지정된 &lt;code&gt;function()&lt;/code&gt; 이 있어야합니다 . &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kws&lt;/code&gt; 를 전달하여 실행되며 &lt;code&gt;function()&lt;/code&gt; 반환하는 모든 것이 &lt;code&gt;sys.breakpointhook()&lt;/code&gt; 은 내장 &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 함수로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="a9acce94f55cfc47e4713699518ed5d331490110" translate="yes" xml:space="preserve">
          <source>The default implementation first consults the environment variable &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;. If that is set to &lt;code&gt;&quot;0&quot;&lt;/code&gt; then this function returns immediately; i.e. it is a no-op. If the environment variable is not set, or is set to the empty string, &lt;code&gt;pdb.set_trace()&lt;/code&gt; is called. Otherwise this variable should name a function to run, using Python&amp;rsquo;s dotted-import nomenclature, e.g. &lt;code&gt;package.subpackage.module.function&lt;/code&gt;. In this case, &lt;code&gt;package.subpackage.module&lt;/code&gt; would be imported and the resulting module must have a callable named &lt;code&gt;function()&lt;/code&gt;. This is run, passing in &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt;, and whatever &lt;code&gt;function()&lt;/code&gt; returns, &lt;code&gt;sys.breakpointhook()&lt;/code&gt; returns to the built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">The default implementation first consults the environment variable &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; &lt;/a&gt;. If that is set to &lt;code&gt;&quot;0&quot;&lt;/code&gt; then this function returns immediately; i.e. it is a no-op. If the environment variable is not set, or is set to the empty string, &lt;code&gt;pdb.set_trace()&lt;/code&gt; is called. Otherwise this variable should name a function to run, using Python&amp;rsquo;s dotted-import nomenclature, e.g. &lt;code&gt;package.subpackage.module.function&lt;/code&gt; . In this case, &lt;code&gt;package.subpackage.module&lt;/code&gt; would be imported and the resulting module must have a callable named &lt;code&gt;function()&lt;/code&gt; . This is run, passing in &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt; , and whatever &lt;code&gt;function()&lt;/code&gt; returns, &lt;code&gt;sys.breakpointhook()&lt;/code&gt; returns to the built-in &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; function.</target>
        </trans-unit>
        <trans-unit id="f74656a8a819a518271e05ab776cc077ee5133d3" translate="yes" xml:space="preserve">
          <source>The default implementation for both functions will read and return up to 1024 bytes each time the function is called. The &lt;em&gt;master_read&lt;/em&gt; callback is passed the pseudoterminal&amp;rsquo;s master file descriptor to read output from the child process, and &lt;em&gt;stdin_read&lt;/em&gt; is passed file descriptor 0, to read from the parent process&amp;rsquo;s standard input.</source>
          <target state="translated">두 함수의 기본 구현은 함수가 호출 될 때마다 최대 1024 바이트를 읽고 반환합니다. &lt;em&gt;master_read의&lt;/em&gt; 콜백 자식 프로세스의 출력을 읽을 수있는 의사 터의 마스터 파일 기술자를 전달하고, &lt;em&gt;stdin_read는&lt;/em&gt; 부모 프로세스의 표준 입력에서 읽고, 파일 기술자 0을 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b33ae6a6fa76317fab7538fb2a3cca4c005e4023" translate="yes" xml:space="preserve">
          <source>The default implementation just uses the &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_status&quot;&gt;&lt;code&gt;error_status&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_headers&quot;&gt;&lt;code&gt;error_headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_body&quot;&gt;&lt;code&gt;error_body&lt;/code&gt;&lt;/a&gt; attributes to generate an output page. Subclasses can override this to produce more dynamic error output.</source>
          <target state="translated">기본 구현은 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_status&quot;&gt; &lt;code&gt;error_status&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_headers&quot;&gt; &lt;code&gt;error_headers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.BaseHandler.error_body&quot;&gt; &lt;code&gt;error_body&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 출력 페이지를 생성합니다. 서브 클래스가이를 대체하여보다 동적 인 오류 출력을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a3901aebe023145f5de84c1fe64e79959585c1" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt;&lt;code&gt;dst()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo.dst&quot;&gt; &lt;code&gt;dst()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="16085cdaef9820e3e043c1b7e4309f2a7ae3234c" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.tzname&quot;&gt;&lt;code&gt;tzname()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo.tzname&quot;&gt; &lt;code&gt;tzname()&lt;/code&gt; &lt;/a&gt; 의 기본 구현 은 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="eaa2ded4dfd4b8b4517a84086b0a0546ef2a859e" translate="yes" xml:space="preserve">
          <source>The default implementation of &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt;&lt;code&gt;utcoffset()&lt;/code&gt;&lt;/a&gt; raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 기본 구현 &lt;a href=&quot;#datetime.tzinfo.utcoffset&quot;&gt; &lt;code&gt;utcoffset()&lt;/code&gt; &lt;/a&gt; 제기 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82debffda06a601a8240a52d0811cf0e418c2167" translate="yes" xml:space="preserve">
          <source>The default implementation of this method does not strictly follow &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2616&lt;/strong&gt;&lt;/a&gt;, which says that 301 and 302 responses to &lt;code&gt;POST&lt;/code&gt; requests must not be automatically redirected without confirmation by the user. In reality, browsers do allow automatic redirection of these responses, changing the POST to a &lt;code&gt;GET&lt;/code&gt;, and the default implementation reproduces this behavior.</source>
          <target state="translated">이 방법의 기본 구현은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2616을&lt;/strong&gt;&lt;/a&gt; 엄격하게 따르지 않으며 , 이는 &lt;code&gt;POST&lt;/code&gt; 요청에 대한 301 및 302 응답 이 사용자의 확인없이 자동으로 리디렉션되지 않아야 한다고 말합니다 . 실제로 브라우저는 이러한 응답의 자동 리디렉션을 허용하여 POST를 &lt;code&gt;GET&lt;/code&gt; 으로 변경 하며 기본 구현은이 동작을 재현합니다.</target>
        </trans-unit>
        <trans-unit id="13b55b955e1b08c46172d6efc871c03e0099cb57" translate="yes" xml:space="preserve">
          <source>The default implementation returns &lt;code&gt;None&lt;/code&gt; for all header names.</source>
          <target state="translated">기본 구현은 모든 헤더 이름에 대해 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="725d6d53b5cf3c3613770adb4e50064aa80e4e7a" translate="yes" xml:space="preserve">
          <source>The default implementation used by &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt;. It enables values to contain format strings which refer to other values in the same section, or values in the special default section &lt;a href=&quot;#id14&quot; id=&quot;id9&quot;&gt;1&lt;/a&gt;. Additional default values can be provided on initialization.</source>
          <target state="translated">&lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; 가&lt;/a&gt; 사용하는 기본 구현 입니다. 동일한 섹션의 다른 값 또는 특수 기본 섹션 &lt;a href=&quot;#id14&quot; id=&quot;id9&quot;&gt;1의&lt;/a&gt; 값을 참조하는 형식 문자열을 값에 포함 할 수 있습니다 . 초기화시 추가 기본값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd0ce3c256ee146bb362a470cd49483296837acf" translate="yes" xml:space="preserve">
          <source>The default is &amp;ldquo;tree headings&amp;rdquo;, i.e., show all elements.</source>
          <target state="translated">기본값은 &quot;트리 제목&quot;입니다. 즉, 모든 요소를 ​​표시합니다.</target>
        </trans-unit>
        <trans-unit id="4a764b527c8c39c412a231d74d381ecae9e42fbc" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;True&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b02b629dda45d997c18db19eedefdbf65477e98" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;long&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;long&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6adf493e6a470999107813b5f58c8e48e3d6d25" translate="yes" xml:space="preserve">
          <source>The default locale directory is system dependent; for example, on RedHat Linux it is &lt;code&gt;/usr/share/locale&lt;/code&gt;, but on Solaris it is &lt;code&gt;/usr/lib/locale&lt;/code&gt;. The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module does not try to support these system dependent defaults; instead its default is &lt;code&gt;&lt;em&gt;sys.base_prefix&lt;/em&gt;/share/locale&lt;/code&gt; (see &lt;a href=&quot;sys#sys.base_prefix&quot;&gt;&lt;code&gt;sys.base_prefix&lt;/code&gt;&lt;/a&gt;). For this reason, it is always best to call &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt;&lt;code&gt;bindtextdomain()&lt;/code&gt;&lt;/a&gt; with an explicit absolute path at the start of your application.</source>
          <target state="translated">The default locale directory is system dependent; for example, on RedHat Linux it is &lt;code&gt;/usr/share/locale&lt;/code&gt; , but on Solaris it is &lt;code&gt;/usr/lib/locale&lt;/code&gt; . The &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; module does not try to support these system dependent defaults; instead its default is &lt;code&gt;&lt;em&gt;sys.base_prefix&lt;/em&gt;/share/locale&lt;/code&gt; (see &lt;a href=&quot;sys#sys.base_prefix&quot;&gt; &lt;code&gt;sys.base_prefix&lt;/code&gt; &lt;/a&gt;). For this reason, it is always best to call &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt; &lt;code&gt;bindtextdomain()&lt;/code&gt; &lt;/a&gt; with an explicit absolute path at the start of your application.</target>
        </trans-unit>
        <trans-unit id="814a9a510f2c1120c69400a1ceca8ba606beab6f" translate="yes" xml:space="preserve">
          <source>The default locale directory is system dependent; for example, on RedHat Linux it is &lt;code&gt;/usr/share/locale&lt;/code&gt;, but on Solaris it is &lt;code&gt;/usr/lib/locale&lt;/code&gt;. The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module does not try to support these system dependent defaults; instead its default is &lt;code&gt;&lt;em&gt;sys.prefix&lt;/em&gt;/share/locale&lt;/code&gt; (see &lt;a href=&quot;sys#sys.prefix&quot;&gt;&lt;code&gt;sys.prefix&lt;/code&gt;&lt;/a&gt;). For this reason, it is always best to call &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt;&lt;code&gt;bindtextdomain()&lt;/code&gt;&lt;/a&gt; with an explicit absolute path at the start of your application.</source>
          <target state="translated">기본 로케일 디렉토리는 시스템에 따라 다릅니다. 예를 들어 RedHat Linux에서는 &lt;code&gt;/usr/share/locale&lt;/code&gt; 이지만 Solaris에서는 &lt;code&gt;/usr/lib/locale&lt;/code&gt; 입니다. &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈은 이러한 시스템에 의존 기본값을 지원하지 않습니다 대신 기본값은 &lt;code&gt;&lt;em&gt;sys.prefix&lt;/em&gt;/share/locale&lt;/code&gt; 입니다 ( &lt;a href=&quot;sys#sys.prefix&quot;&gt; &lt;code&gt;sys.prefix&lt;/code&gt; &lt;/a&gt; 참조 ). 따라서 항상 응용 프로그램 시작시 명시 적 절대 경로를 사용하여 &lt;a href=&quot;#gettext.bindtextdomain&quot;&gt; &lt;code&gt;bindtextdomain()&lt;/code&gt; &lt;/a&gt; 을 호출하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="794f48952ceef8edd0efaf6e7f1edca546f6b6ec" translate="yes" xml:space="preserve">
          <source>The default log level is &lt;code&gt;logging.INFO&lt;/code&gt;, which can be easily adjusted:</source>
          <target state="translated">기본 로그 레벨은 &lt;code&gt;logging.INFO&lt;/code&gt; 이며 쉽게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c10a46682ece55208f06ff3244ee92307d192950" translate="yes" xml:space="preserve">
          <source>The default mappings are:</source>
          <target state="translated">기본 매핑은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf79d526fbfe64d1c7da84c2d5bc4927946eb59b" translate="yes" xml:space="preserve">
          <source>The default message can be overridden with the &lt;code&gt;usage=&lt;/code&gt; keyword argument:</source>
          <target state="translated">기본 메시지는 &lt;code&gt;usage=&lt;/code&gt; 키워드 인수 로 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="141a3d8b5d2695d6fbe0a56d367c38aab3863374" translate="yes" xml:space="preserve">
          <source>The default mode is &lt;code&gt;'r'&lt;/code&gt; (open for reading text, synonym of &lt;code&gt;'rt'&lt;/code&gt;). Modes &lt;code&gt;'w+'&lt;/code&gt; and &lt;code&gt;'w+b'&lt;/code&gt; open and truncate the file. Modes &lt;code&gt;'r+'&lt;/code&gt; and &lt;code&gt;'r+b'&lt;/code&gt; open the file with no truncation.</source>
          <target state="translated">기본 모드는 &lt;code&gt;'r'&lt;/code&gt; (텍스트를 읽기 위해 열리고 &lt;code&gt;'rt'&lt;/code&gt; 와 동의어 임 )입니다. &lt;code&gt;'w+'&lt;/code&gt; 및 &lt;code&gt;'w+b'&lt;/code&gt; 모드 는 파일을 열고 자릅니다. &lt;code&gt;'r+'&lt;/code&gt; 및 &lt;code&gt;'r+b'&lt;/code&gt; 모드 는 파일을 자르지 않고 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="03390741ae3195ccf5b5eb50f31c643c59a729d2" translate="yes" xml:space="preserve">
          <source>The default mode which is used to load shared libraries. On OSX 10.3, this is &lt;em&gt;RTLD_GLOBAL&lt;/em&gt;, otherwise it is the same as &lt;em&gt;RTLD_LOCAL&lt;/em&gt;.</source>
          <target state="translated">공유 라이브러리를로드하는 데 사용되는 기본 모드입니다. OSX 10.3에서는 &lt;em&gt;RTLD_GLOBAL&lt;/em&gt; 이고, 그렇지 않으면 &lt;em&gt;RTLD_LOCAL&lt;/em&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="73d6ea81836b7e091d9707bef84bfc523b16338a" translate="yes" xml:space="preserve">
          <source>The default opener raises an &lt;a href=&quot;sys#auditing&quot;&gt;auditing event&lt;/a&gt;&lt;code&gt;urllib.Request&lt;/code&gt; with arguments &lt;code&gt;fullurl&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt;, &lt;code&gt;headers&lt;/code&gt;, &lt;code&gt;method&lt;/code&gt; taken from the request object.</source>
          <target state="translated">기본 오프너 는 인수 &lt;code&gt;fullurl&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;headers&lt;/code&gt; , 요청 객체에서 가져온 &lt;code&gt;method&lt;/code&gt; 와 함께 &lt;code&gt;urllib.Request&lt;/code&gt; &lt;a href=&quot;sys#auditing&quot;&gt;감사 이벤트를 발생 &lt;/a&gt;시킵니다 .</target>
        </trans-unit>
        <trans-unit id="39acba55dd14c83398ea0bbfc6e7d2a50c30c9e7" translate="yes" xml:space="preserve">
          <source>The default ordering of tests created by the unittest test loaders is to group all tests from the same modules and classes together. This will lead to &lt;code&gt;setUpClass&lt;/code&gt; / &lt;code&gt;setUpModule&lt;/code&gt; (etc) being called exactly once per class and module. If you randomize the order, so that tests from different modules and classes are adjacent to each other, then these shared fixture functions may be called multiple times in a single test run.</source>
          <target state="translated">unittest 테스트 로더에 의해 생성 된 테스트의 기본 순서는 동일한 모듈과 클래스의 모든 테스트를 그룹화하는 것입니다. 이로 인해 클래스와 모듈 당 &lt;code&gt;setUpClass&lt;/code&gt; / &lt;code&gt;setUpModule&lt;/code&gt; 등이 정확히 한 번만 호출됩니다. 다른 모듈과 클래스의 테스트가 서로 인접하도록 순서를 무작위로 지정하면 단일 테스트 실행에서 이러한 공유 설비 기능을 여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a58a0491ff3eb550980796cd579ce9dfd157abf1" translate="yes" xml:space="preserve">
          <source>The default port for the HTTP protocol (always &lt;code&gt;80&lt;/code&gt;).</source>
          <target state="translated">HTTP 프로토콜의 기본 포트입니다 (항상 &lt;code&gt;80&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="425beadae2e2f6a2971a75d3712f9625b055af90" translate="yes" xml:space="preserve">
          <source>The default port for the HTTPS protocol (always &lt;code&gt;443&lt;/code&gt;).</source>
          <target state="translated">HTTPS 프로토콜의 기본 포트 (항상 &lt;code&gt;443&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="30751022518c3e586bbf05c4dc10e57e1471f76b" translate="yes" xml:space="preserve">
          <source>The default return value is a mock object and you can configure it in the normal way:</source>
          <target state="translated">기본 반환 값은 모의 객체이며 일반적인 방식으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24a346496310974b8e67170483456ec9392111fd" translate="yes" xml:space="preserve">
          <source>The default scheduling policy.</source>
          <target state="translated">기본 스케줄링 정책.</target>
        </trans-unit>
        <trans-unit id="c002f3ffcf614b415ab0107e01446f36339d947d" translate="yes" xml:space="preserve">
          <source>The default search path used by &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*p*&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*p*&lt;/code&gt;&lt;/a&gt; if the environment doesn&amp;rsquo;t have a &lt;code&gt;'PATH'&lt;/code&gt; key. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환경에 &lt;code&gt;'PATH'&lt;/code&gt; 키 가없는 경우 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*p*&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*p*&lt;/code&gt; &lt;/a&gt; 사용하는 기본 검색 경로 입니다. &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="3efa5b275105c170638fc7b7f17c83558f25e9f6" translate="yes" xml:space="preserve">
          <source>The default selector class, using the most efficient implementation available on the current platform. This should be the default choice for most users.</source>
          <target state="translated">현재 플랫폼에서 사용 가능한 가장 효율적인 구현을 사용하는 기본 선택기 클래스입니다. 대부분의 사용자에게 이것이 기본 선택입니다.</target>
        </trans-unit>
        <trans-unit id="3ca70f786f3be38669a0f5f13987139bc5f61d99" translate="yes" xml:space="preserve">
          <source>The default setting is determined by calling &lt;a href=&quot;#locale.getdefaultlocale&quot;&gt;&lt;code&gt;getdefaultlocale()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;category&lt;/em&gt; defaults to &lt;a href=&quot;#locale.LC_ALL&quot;&gt;&lt;code&gt;LC_ALL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 설정은 &lt;a href=&quot;#locale.getdefaultlocale&quot;&gt; &lt;code&gt;getdefaultlocale()&lt;/code&gt; &lt;/a&gt; 을 호출하여 결정됩니다 . &lt;em&gt;카테고리의&lt;/em&gt; 기본값은 &lt;a href=&quot;#locale.LC_ALL&quot;&gt; &lt;code&gt;LC_ALL&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="043146855b6cd351175d4c3c050e9e53a9299fde" translate="yes" xml:space="preserve">
          <source>The default timer, which is always &lt;a href=&quot;time#time.perf_counter&quot;&gt;&lt;code&gt;time.perf_counter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 타이머는 항상 &lt;a href=&quot;time#time.perf_counter&quot;&gt; &lt;code&gt;time.perf_counter()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e880a55fe07fce5b685fc9b8ca7365567a017ce2" translate="yes" xml:space="preserve">
          <source>The default traceback display code shows these chained exceptions in addition to the traceback for the exception itself. An explicitly chained exception in &lt;code&gt;__cause__&lt;/code&gt; is always shown when present. An implicitly chained exception in &lt;code&gt;__context__&lt;/code&gt; is shown only if &lt;code&gt;__cause__&lt;/code&gt; is &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;__suppress_context__&lt;/code&gt; is false.</source>
          <target state="translated">기본 역 추적 표시 코드는 예외 자체에 대한 역 추적 외에도 이러한 체인 예외를 표시합니다. &lt;code&gt;__cause__&lt;/code&gt; 에 명시 적으로 연결된 예외 는 항상 존재합니다. &lt;code&gt;__context__&lt;/code&gt; 의 암시 적으로 연결된 예외는 &lt;code&gt;__cause__&lt;/code&gt; 가 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;__suppress_context__&lt;/code&gt; 가 false 인 경우에만 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7a3e28e031082803bf5f54778e88107b6b7e3956" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;a href=&quot;#email.policy.Policy.message_factory&quot;&gt;&lt;code&gt;message_factory&lt;/code&gt;&lt;/a&gt; attribute is &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#email.policy.Policy.message_factory&quot;&gt; &lt;code&gt;message_factory&lt;/code&gt; &lt;/a&gt; 속성 의 기본값 은 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1e2dbad85c6df37fd7251dd032bd384d20f99676" translate="yes" xml:space="preserve">
          <source>The default value for the &lt;em&gt;policy&lt;/em&gt; keyword for the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; classes and the parser convenience functions &lt;strong&gt;will be changing&lt;/strong&gt; in a future version of Python. Therefore you should &lt;strong&gt;always specify explicitly which policy you want to use&lt;/strong&gt; when calling any of the classes and functions described in the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;em&gt;정책&lt;/em&gt; 키워드 및 파서 편의 함수 의 기본값 은 이후 버전의 Python에서 &lt;strong&gt;변경 될 예정&lt;/strong&gt; 입니다. 따라서 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈에 설명 된 클래스와 함수를 호출 할 때 &lt;strong&gt;항상 사용할 정책을 명시 적으로 지정&lt;/strong&gt; 해야 합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="144a7dcfe8a056320c86d88ccef9dfb777d3754c" translate="yes" xml:space="preserve">
          <source>The default value for the parameter. If the parameter has no default value, this attribute is set to &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt;&lt;code&gt;Parameter.empty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수의 기본값입니다. 매개 변수에 기본값이 없으면이 속성은 &lt;a href=&quot;#inspect.Parameter.empty&quot;&gt; &lt;code&gt;Parameter.empty&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="aa35640f1a27bf8e96f3301b8c8fd0e1450703e6" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt; if the environment variable &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt;&lt;/a&gt; is set to a non-empty string, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">환경 변수 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt; &lt;/a&gt; 가 비어 있지 않은 문자열로 설정 되면 기본값은 &lt;code&gt;True&lt;/code&gt; 이고 , &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="3603eee73c330b9a1bef1d08c127271a7b88a7a7" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt; if the environment variable &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt;&lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt;&lt;/a&gt; is set to a non-empty string, &lt;code&gt;False&lt;/code&gt; otherwise.</source>
          <target state="translated">The default value is &lt;code&gt;True&lt;/code&gt; if the environment variable &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONASYNCIODEBUG&quot; id=&quot;index-5&quot;&gt; &lt;code&gt;PYTHONASYNCIODEBUG&lt;/code&gt; &lt;/a&gt; is set to a non-empty string, &lt;code&gt;False&lt;/code&gt; otherwise.</target>
        </trans-unit>
        <trans-unit id="9336faf1c603958f822c42cea3dc2d15a071eee3" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt;. If Python is compiled &lt;code&gt;--without-decimal-contextvar&lt;/code&gt;, the C version uses a thread-local rather than a coroutine-local context and the value is &lt;code&gt;False&lt;/code&gt;. This is slightly faster in some nested context scenarios.</source>
          <target state="translated">The default value is &lt;code&gt;True&lt;/code&gt; . If Python is compiled &lt;code&gt;--without-decimal-contextvar&lt;/code&gt; , the C version uses a thread-local rather than a coroutine-local context and the value is &lt;code&gt;False&lt;/code&gt; . This is slightly faster in some nested context scenarios.</target>
        </trans-unit>
        <trans-unit id="ca3fe88381a2828f01851afbbbb72484af83f4b3" translate="yes" xml:space="preserve">
          <source>The default value is &lt;code&gt;True&lt;/code&gt;. If Python is compiled without threads, the C version automatically disables the expensive thread local context machinery. In this case, the value is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;True&lt;/code&gt; 입니다. 파이썬이 스레드없이 컴파일되면 C 버전은 자동으로 비싼 스레드 로컬 컨텍스트 기계를 비활성화합니다. 이 경우 값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e1de354cd457579854e47a6cc794e8c9ac39320" translate="yes" xml:space="preserve">
          <source>The default values are &lt;code&gt;prec&lt;/code&gt;=&lt;code&gt;28&lt;/code&gt;, &lt;code&gt;rounding&lt;/code&gt;=&lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt;&lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt;&lt;/a&gt;, and enabled traps for &lt;a href=&quot;#decimal.Overflow&quot;&gt;&lt;code&gt;Overflow&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt;&lt;code&gt;DivisionByZero&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;prec&lt;/code&gt; = &lt;code&gt;28&lt;/code&gt; , &lt;code&gt;rounding&lt;/code&gt; = &lt;a href=&quot;#decimal.ROUND_HALF_EVEN&quot;&gt; &lt;code&gt;ROUND_HALF_EVEN&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;#decimal.Overflow&quot;&gt; &lt;code&gt;Overflow&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#decimal.DivisionByZero&quot;&gt; &lt;code&gt;DivisionByZero&lt;/code&gt; 에&lt;/a&gt; 대해 활성화 된 트랩입니다 .</target>
        </trans-unit>
        <trans-unit id="7299c60092b16e730787f8b6c4a0d4d274cb1509" translate="yes" xml:space="preserve">
          <source>The defaults are implementation-specific. If only the high watermark is given, the low watermark defaults to an implementation-specific value less than or equal to the high watermark. Setting &lt;em&gt;high&lt;/em&gt; to zero forces &lt;em&gt;low&lt;/em&gt; to zero as well, and causes &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;pause_writing()&lt;/code&gt;&lt;/a&gt; to be called whenever the buffer becomes non-empty. Setting &lt;em&gt;low&lt;/em&gt; to zero causes &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt;&lt;code&gt;resume_writing()&lt;/code&gt;&lt;/a&gt; to be called only once the buffer is empty. Use of zero for either limit is generally sub-optimal as it reduces opportunities for doing I/O and computation concurrently.</source>
          <target state="translated">기본값은 구현에 따라 다릅니다. 상위 워터 마크 만 제공되는 경우 하위 워터 마크는 기본적으로 상위 워터 마크 이하의 구현 별 값으로 설정됩니다. &lt;em&gt;high&lt;/em&gt; 를 0으로 설정하면 &lt;em&gt;low&lt;/em&gt; 도 0이되고 버퍼가 비어 있지 않을 때마다 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;pause_writing()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. &lt;em&gt;low&lt;/em&gt; 로 0으로 설정 하면 버퍼가 비었을 때만 &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt; &lt;code&gt;resume_writing()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. I / O 및 계산을 동시에 수행 할 수있는 기회가 줄어들 기 때문에 어느 한 한계에 0을 사용하는 것은 일반적으로 차선책입니다.</target>
        </trans-unit>
        <trans-unit id="221847e9edd5eaa3b267e4d1c2549650caad5b6f" translate="yes" xml:space="preserve">
          <source>The definition of the DOM API for Python is given as part of the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; module documentation. This section lists the differences between the API and &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 용 DOM API의 정의는 &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 모듈 문서의 일부로 제공됩니다 . 이 섹션에는 API와 &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 의 차이점이 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="943baea73b814dec74b8d72bb621d33b0bfe1d54" translate="yes" xml:space="preserve">
          <source>The definitive documentation for the DOM is the DOM specification from the W3C.</source>
          <target state="translated">DOM에 대한 결정적인 문서는 W3C의 DOM 사양입니다.</target>
        </trans-unit>
        <trans-unit id="5e673798c7b447103357a31e16119d6dac467057" translate="yes" xml:space="preserve">
          <source>The delta filter stores the differences between bytes, producing more repetitive input for the compressor in certain circumstances. It supports one option, &lt;code&gt;dist&lt;/code&gt;. This indicates the distance between bytes to be subtracted. The default is 1, i.e. take the differences between adjacent bytes.</source>
          <target state="translated">델타 필터는 바이트 간 차이를 저장하여 특정 상황에서 압축기에 대한 반복적 인 입력을 생성합니다. 하나의 옵션 인 &lt;code&gt;dist&lt;/code&gt; 를 지원합니다 . 빼야 할 바이트 사이의 거리를 나타냅니다. 기본값은 1입니다. 즉, 인접 바이트 간 차이를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="0b079df41b809fa4419856c946739f02648c68a2" translate="yes" xml:space="preserve">
          <source>The demo scripts are:</source>
          <target state="translated">데모 스크립트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="72a1f3568dcde909669b4dded97dc9ed9fa432f0" translate="yes" xml:space="preserve">
          <source>The deprecated types will be removed from the &lt;a href=&quot;#module-typing&quot;&gt;&lt;code&gt;typing&lt;/code&gt;&lt;/a&gt; module in the first Python version released 5 years after the release of Python 3.9.0. See details in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0585&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 585&lt;/strong&gt;&lt;/a&gt;&amp;mdash;&lt;em&gt;Type Hinting Generics In Standard Collections&lt;/em&gt;.</source>
          <target state="translated">The deprecated types will be removed from the &lt;a href=&quot;#module-typing&quot;&gt; &lt;code&gt;typing&lt;/code&gt; &lt;/a&gt; module in the first Python version released 5 years after the release of Python 3.9.0. See details in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0585&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 585&lt;/strong&gt;&lt;/a&gt;&amp;mdash;&lt;em&gt;Type Hinting Generics In Standard Collections&lt;/em&gt;.</target>
        </trans-unit>
        <trans-unit id="cf9ee77bb8cddcf823d4f4ddb3095b093bcd8b4a" translate="yes" xml:space="preserve">
          <source>The descriptors returned by these functions are instances of Function and Class classes. Users are not expected to create instances of these classes.</source>
          <target state="translated">이 함수들에 의해 리턴 된 디스크립터는 Function 및 Class 클래스의 인스턴스입니다. 사용자는 이러한 클래스의 인스턴스를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0da76bef1aa2212782aa0ff026cf66c2f179b048" translate="yes" xml:space="preserve">
          <source>The design is such that one can use the factory functions returned by the &lt;a href=&quot;#codecs.lookup&quot;&gt;&lt;code&gt;lookup()&lt;/code&gt;&lt;/a&gt; function to construct the instance.</source>
          <target state="translated">디자인은 &lt;a href=&quot;#codecs.lookup&quot;&gt; &lt;code&gt;lookup()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 팩토리 함수를 사용 하여 인스턴스를 구성 할 수 있도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e304666702c62ac9c3cf811c3a927f2350dc8077" translate="yes" xml:space="preserve">
          <source>The design of all built-in operating system dependent modules of Python is such that as long as the same functionality is available, it uses the same interface; for example, the function &lt;code&gt;os.stat(path)&lt;/code&gt; returns stat information about &lt;em&gt;path&lt;/em&gt; in the same format (which happens to have originated with the POSIX interface).</source>
          <target state="translated">내장 된 모든 운영 체제 의존적 파이썬 모듈의 설계는 동일한 기능을 사용할 수있는 한 동일한 인터페이스를 사용합니다. 예를 들어, &lt;code&gt;os.stat(path)&lt;/code&gt; 함수 는 POSIX 인터페이스에서 시작된 동일한 형식의 &lt;em&gt;경로&lt;/em&gt; 에 대한 통계 정보를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="906a6d45a451c5d5583451af0ec9ab63f8309bb8" translate="yes" xml:space="preserve">
          <source>The design of this module is loosely based on Java&amp;rsquo;s threading model. However, where Java makes locks and condition variables basic behavior of every object, they are separate objects in Python. Python&amp;rsquo;s &lt;a href=&quot;#threading.Thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; class supports a subset of the behavior of Java&amp;rsquo;s Thread class; currently, there are no priorities, no thread groups, and threads cannot be destroyed, stopped, suspended, resumed, or interrupted. The static methods of Java&amp;rsquo;s Thread class, when implemented, are mapped to module-level functions.</source>
          <target state="translated">이 모듈의 디자인은 Java의 스레딩 모델을 기반으로합니다. 그러나 Java가 잠금 및 조건 변수를 모든 객체의 기본 동작으로 만드는 경우 Python에서 별도의 객체입니다. Python의 &lt;a href=&quot;#threading.Thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 클래스는 Java의 Thread 클래스 동작의 하위 세트를 지원합니다. 현재 우선 순위가없고 스레드 그룹이 없으며 스레드를 삭제, 중지, 일시 중단, 재개 또는 중단 할 수 없습니다. Java 스레드 클래스의 정적 메소드는 구현시 모듈 레벨 함수에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="c00c1643f45af0e7e9eae104f3f428178b879e63" translate="yes" xml:space="preserve">
          <source>The destination format is restricted to a single element native format in &lt;a href=&quot;struct#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; syntax. One of the formats must be a byte format (&amp;lsquo;B&amp;rsquo;, &amp;lsquo;b&amp;rsquo; or &amp;lsquo;c&amp;rsquo;). The byte length of the result must be the same as the original length.</source>
          <target state="translated">대상 형식은 &lt;a href=&quot;struct#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 구문 에서 단일 요소 기본 형식으로 제한됩니다 . 형식 중 하나는 바이트 형식이어야합니다 ( 'B', 'b'또는 'c'). 결과의 바이트 길이는 원래 길이와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="853310cf1caf3d9ea6dbb0a860eb9bb473765452" translate="yes" xml:space="preserve">
          <source>The destination location must be writable; otherwise, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception will be raised. If &lt;em&gt;dst&lt;/em&gt; already exists, it will be replaced. Special files such as character or block devices and pipes cannot be copied with this function.</source>
          <target state="translated">대상 위치는 쓰기 가능해야합니다. 그렇지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 경우 &lt;em&gt;DST가&lt;/em&gt; 이미 존재, 그것은 대체됩니다. 문자 또는 블록 장치 및 파이프와 같은 특수 파일은이 기능으로 복사 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="12a01ce48953ff6624ef00113b65baf1192d859c" translate="yes" xml:space="preserve">
          <source>The detailed specification, implementation details and examples.</source>
          <target state="translated">자세한 사양, 구현 세부 사항 및 예</target>
        </trans-unit>
        <trans-unit id="a567d6a1a9be2c908411e43745159c73a975ef4b" translate="yes" xml:space="preserve">
          <source>The details of character conversion in &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; are controlled by the &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; keyword arguments of the &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 의 문자 변환에 대한 세부 사항은 &lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 키워드 인수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="c38c8475bca1181e5dbbe41548c5059c93a7fb35" translate="yes" xml:space="preserve">
          <source>The details of the syntax:</source>
          <target state="translated">The details of the syntax:</target>
        </trans-unit>
        <trans-unit id="34da012fa9dff8518788c0b3d7cb092045825a91" translate="yes" xml:space="preserve">
          <source>The details of this function differ on Unix and Windows.</source>
          <target state="translated">이 기능의 세부 사항은 Unix와 Windows에서 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4ded0604d98dde6a19acf451fe014b9c6c68f10c" translate="yes" xml:space="preserve">
          <source>The detected cycle can be accessed via the second element in the &lt;code&gt;args&lt;/code&gt; attribute of the exception instance and consists in a list of nodes, such that each node is, in the graph, an immediate predecessor of the next node in the list. In the reported list, the first and the last node will be the same, to make it clear that it is cyclic.</source>
          <target state="translated">The detected cycle can be accessed via the second element in the &lt;code&gt;args&lt;/code&gt; attribute of the exception instance and consists in a list of nodes, such that each node is, in the graph, an immediate predecessor of the next node in the list. In the reported list, the first and the last node will be the same, to make it clear that it is cyclic.</target>
        </trans-unit>
        <trans-unit id="a14d6055539d17fe330c28c0379041872d8cb00d" translate="yes" xml:space="preserve">
          <source>The determination whether to issue a warning message is controlled by the &lt;a href=&quot;#warning-filter&quot;&gt;warning filter&lt;/a&gt;, which is a sequence of matching rules and actions. Rules can be added to the filter by calling &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt; and reset to its default state by calling &lt;a href=&quot;#warnings.resetwarnings&quot;&gt;&lt;code&gt;resetwarnings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경고 메시지를 발행할지 여부 는 규칙 및 조치와 일치하는 &lt;a href=&quot;#warning-filter&quot;&gt;경고 필터에&lt;/a&gt; 의해 제어됩니다 . 규칙 호출하여 필터에 추가 할 수 있습니다 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 하고 호출하여 기본 상태로 재설정 &lt;a href=&quot;#warnings.resetwarnings&quot;&gt; &lt;code&gt;resetwarnings()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73dca0bcff737d2d3b02394f5fe723496528dac5" translate="yes" xml:space="preserve">
          <source>The dictionary passed to &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; must contain the following keys:</source>
          <target state="translated">&lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 전달 된 사전 에는 다음 키가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a309b10a0ef1998ea5956b5985c47332b3ca7484" translate="yes" xml:space="preserve">
          <source>The difference between shallow and deep copying is only relevant for compound objects (objects that contain other objects, like lists or class instances):</source>
          <target state="translated">얕은 복사와 깊은 복사의 차이점은 복합 객체 (목록 또는 클래스 인스턴스와 같은 다른 객체를 포함하는 객체)에만 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="f13a9d0f0f57f180befad466255cd497424b6d22" translate="yes" xml:space="preserve">
          <source>The difference is that the &lt;code&gt;readline()&lt;/code&gt; call in the second handler will call &lt;code&gt;recv()&lt;/code&gt; multiple times until it encounters a newline character, while the single &lt;code&gt;recv()&lt;/code&gt; call in the first handler will just return what has been sent from the client in one &lt;code&gt;sendall()&lt;/code&gt; call.</source>
          <target state="translated">차이점은 두 번째 핸들러 의 &lt;code&gt;readline()&lt;/code&gt; 호출은 개행 문자가 발생할 때까지 &lt;code&gt;recv()&lt;/code&gt; 여러 번 호출 하는 반면 첫 번째 핸들러 의 단일 &lt;code&gt;recv()&lt;/code&gt; 호출은 클라이언트에서 보낸 것을 하나만 반환한다는 것입니다. &lt;code&gt;sendall()&lt;/code&gt; 호출.</target>
        </trans-unit>
        <trans-unit id="2fc273f694debf0a788d27b77d44aa4b6ce63e71" translate="yes" xml:space="preserve">
          <source>The different font weights and slants are:</source>
          <target state="translated">The different font weights and slants are:</target>
        </trans-unit>
        <trans-unit id="7f4ce614fc3c5ce47e342e7509a9fcd6e2263cba" translate="yes" xml:space="preserve">
          <source>The dircmp class</source>
          <target state="translated">dircmp 클래스</target>
        </trans-unit>
        <trans-unit id="5b186c9536ac444951a67e97a0ba165a32d7d506" translate="yes" xml:space="preserve">
          <source>The directories are allowed to exist (for when an existing environment is being upgraded).</source>
          <target state="translated">기존 환경을 업그레이드 할 때 디렉토리가 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3ed7571611b51b5a7d9d0b2c98a40156f70c51d5" translate="yes" xml:space="preserve">
          <source>The directory &lt;em&gt;a&lt;/em&gt;.</source>
          <target state="translated">디렉토리 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="39cd511f81d10b80603aff273f9c039527add995" translate="yes" xml:space="preserve">
          <source>The directory &lt;em&gt;b&lt;/em&gt;.</source>
          <target state="translated">디렉토리 &lt;em&gt;b&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2d510cfc449c5e8636e56f356ec78fb5d4b7cfca" translate="yes" xml:space="preserve">
          <source>The directory can be explicitly cleaned up by calling the &lt;code&gt;cleanup()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;cleanup()&lt;/code&gt; 메소드를 호출하여 디렉토리를 명시 적으로 정리할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6990eba23c2a267e829ead12a6b14c528cdac3d4" translate="yes" xml:space="preserve">
          <source>The directory is opaque when viewed through a union stack.</source>
          <target state="translated">통합 스택을 통해 볼 때 디렉토리가 불투명합니다.</target>
        </trans-unit>
        <trans-unit id="2357d402069095a1d69201172b2c12576d482c6c" translate="yes" xml:space="preserve">
          <source>The directory name can be retrieved from the &lt;code&gt;name&lt;/code&gt; attribute of the returned object. When the returned object is used as a context manager, the &lt;code&gt;name&lt;/code&gt; will be assigned to the target of the &lt;code&gt;as&lt;/code&gt; clause in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, if there is one.</source>
          <target state="translated">리턴 된 오브젝트 의 &lt;code&gt;name&lt;/code&gt; 속성 에서 디렉토리 이름을 검색 할 수 있습니다 . 리턴 된 오브젝트가 컨텍스트 관리자로 사용될 때, &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 &lt;code&gt;as&lt;/code&gt; 절의 대상에 &lt;code&gt;name&lt;/code&gt; 이 지정됩니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="269d29dfe20e61d331f6adfa1c133446ae5fa004" translate="yes" xml:space="preserve">
          <source>The directory name can be retrieved from the &lt;code&gt;name&lt;/code&gt; attribute of the returned object. When the returned object is used as a context manager, the &lt;code&gt;name&lt;/code&gt; will be assigned to the target of the &lt;code&gt;as&lt;/code&gt; clause in the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, if there is one.</source>
          <target state="translated">The directory name can be retrieved from the &lt;code&gt;name&lt;/code&gt; attribute of the returned object. When the returned object is used as a context manager, the &lt;code&gt;name&lt;/code&gt; will be assigned to the target of the &lt;code&gt;as&lt;/code&gt; clause in the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; statement, if there is one.</target>
        </trans-unit>
        <trans-unit id="b35f56c191faad6472c0141b116290aca2391a78" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-1&quot;&gt;TMPDIR&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-1&quot;&gt;TMPDIR&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="29814fe7aa509a2b063de5230c93f3cba90feca2" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-2&quot;&gt;TEMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-2&quot;&gt;TEMP&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="4f86539184fc4d2d2f0f9bffd91b762cb482c710" translate="yes" xml:space="preserve">
          <source>The directory named by the &lt;code id=&quot;index-3&quot;&gt;TMP&lt;/code&gt; environment variable.</source>
          <target state="translated">&lt;code id=&quot;index-3&quot;&gt;TMP&lt;/code&gt; 환경 변수에 의해 명명 된 디렉토리 .</target>
        </trans-unit>
        <trans-unit id="bd4aec7dd167f631c8a4341121b8d6994d521f9b" translate="yes" xml:space="preserve">
          <source>The disadvantage of a self-signed certificate is that it is its own root certificate, and no one else will have it in their cache of known (and trusted) root certificates.</source>
          <target state="translated">자체 서명 된 인증서의 단점은 자체 루트 인증서이며 다른 누구도 알려진 (및 신뢰할 수있는) 루트 인증서의 캐시에 인증서를 가지고 있지 않다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e4d43bffa96f6204d6ae5629ccd514e5d9ce5afe" translate="yes" xml:space="preserve">
          <source>The disassembly is written as text to the supplied &lt;em&gt;file&lt;/em&gt; argument if provided and to &lt;code&gt;sys.stdout&lt;/code&gt; otherwise.</source>
          <target state="translated">디스 어셈블리는 제공된 경우 제공된 &lt;em&gt;파일&lt;/em&gt; 인수 및 다른 경우 에는 &lt;code&gt;sys.stdout&lt;/code&gt; 에 텍스트로 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b60e6af892f070f5741292c864890daf4177c61" translate="yes" xml:space="preserve">
          <source>The disk balancing algorithms which are current, nowadays, are more annoying than clever, and this is a consequence of the seeking capabilities of the disks. On devices which cannot seek, like big tape drives, the story was quite different, and one had to be very clever to ensure (far in advance) that each tape movement will be the most effective possible (that is, will best participate at &amp;ldquo;progressing&amp;rdquo; the merge). Some tapes were even able to read backwards, and this was also used to avoid the rewinding time. Believe me, real good tape sorts were quite spectacular to watch! From all times, sorting has always been a Great Art! :-)</source>
          <target state="translated">요즘 최신 디스크 밸런싱 알고리즘은 영리한 것보다 더 성가 시며 이는 디스크의 탐색 기능의 결과입니다. 큰 테이프 드라이브와 같이 구할 수없는 장치에서는 그 이야기가 상당히 달랐으며 각 테이프 움직임이 가장 효과적 일 것임을 보장하기 위해 (훨씬 미리) 매우 똑똑해야했습니다. 진행 중&amp;rdquo;). 일부 테이프는 뒤로 읽을 수도 있었으며 되감기 시간을 피하기 위해 사용되었습니다. 믿어, 진짜 좋은 테이프 종류는 볼 매우 훌륭했습니다! 항상 정렬은 항상 위대한 예술이었습니다! :-)</target>
        </trans-unit>
        <trans-unit id="de4509458b5999b814732a12ee716e1291daa74d" translate="yes" xml:space="preserve">
          <source>The display name portion of the address, if any, with all quoting removed. If the address does not have a display name, this attribute will be an empty string.</source>
          <target state="translated">모든 인용 부호가 제거 된 주소의 표시 이름 부분입니다 (있는 경우). 주소에 표시 이름이 없으면이 속성은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b3ffe664da088c28c4dfb305539a430b26d2cd27" translate="yes" xml:space="preserve">
          <source>The distinction between aware and naive doesn&amp;rsquo;t apply to &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">인식과 순진의 구별은 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 에는 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a88b02874a2183ab63db978cb3d089c5c1c77714" translate="yes" xml:space="preserve">
          <source>The docstrings of the functions which are derived from methods have a modified form:</source>
          <target state="translated">메소드에서 파생 된 함수의 docstring은 수정 된 형식을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="15a57359f59d33fd95cd9fd1878284e1c5612b40" translate="yes" xml:space="preserve">
          <source>The doctest command line accepts the option &lt;code&gt;-f&lt;/code&gt; as a shorthand for &lt;code&gt;-o
FAIL_FAST&lt;/code&gt;.</source>
          <target state="translated">doctest가 명령 줄 옵션 받아 &lt;code&gt;-f&lt;/code&gt; 위한 속기로 &lt;code&gt;-o FAIL_FAST&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7edc27c9b251af25f08e439a5fa1ae563449aee" translate="yes" xml:space="preserve">
          <source>The document attempted to remove the namespace declaration associated with a prefix.</source>
          <target state="translated">문서가 접 두부와 연관된 네임 스페이스 선언을 제거하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="10a2ff25b70c156c1132e77ce7ede7c43d4ef115" translate="yes" xml:space="preserve">
          <source>The document contained no document element at all.</source>
          <target state="translated">문서에는 문서 요소가 전혀 없습니다.</target>
        </trans-unit>
        <trans-unit id="8b1d05974dee6ddfa33f763e960cb8596c6c89b6" translate="yes" xml:space="preserve">
          <source>The document contains no elements (XML requires all documents to contain exactly one top-level element)..</source>
          <target state="translated">문서에 요소가 없습니다 (XML에는 모든 문서에 정확히 하나의 최상위 요소가 포함되어야 함).</target>
        </trans-unit>
        <trans-unit id="0e022fadcd6ebdd4dce2b1340fd4cc2d36f4effa" translate="yes" xml:space="preserve">
          <source>The document encoding is not supported by Expat.</source>
          <target state="translated">Expat에서는 문서 인코딩을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="45eb94f8f738860eeb2b172bec8e84ce78dc6574" translate="yes" xml:space="preserve">
          <source>The documentation for &lt;a href=&quot;https://pypi.org/project/defusedxml/&quot;&gt;defusedxml&lt;/a&gt; on PyPI has further information about all known attack vectors with examples and references.</source>
          <target state="translated">PyPI의 &lt;a href=&quot;https://pypi.org/project/defusedxml/&quot;&gt;defusedxml&lt;/a&gt; 에 대한 설명서 에는 예제와 참조가 포함 된 모든 알려진 공격 경로에 대한 자세한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="52d6ee35bc489f9c966545e9c6e4189b68230cec" translate="yes" xml:space="preserve">
          <source>The documentation for the &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;xml.sax#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; packages are the definition of the Python bindings for the DOM and SAX interfaces.</source>
          <target state="translated">에 대한 문서 &lt;a href=&quot;xml.dom#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;xml.sax#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; &lt;/a&gt; 패키지는 DOM과 SAX 인터페이스에 대한 파이썬 바인딩의 정의입니다.</target>
        </trans-unit>
        <trans-unit id="98dc23305981bc90fc36fd9227d9b674c345d97d" translate="yes" xml:space="preserve">
          <source>The earlier SAX 1 interface provided by the Python XML Special Interest Group used a more Java-like interface for this method. Since most parsers used from Python did not take advantage of the older interface, the simpler signature was chosen to replace it. To convert old code to the new interface, use &lt;em&gt;content&lt;/em&gt; instead of slicing content with the old &lt;em&gt;offset&lt;/em&gt; and &lt;em&gt;length&lt;/em&gt; parameters.</source>
          <target state="translated">Python XML Special Interest Group에서 제공하는 이전 SAX 1 인터페이스는이 메소드에 대해 더 Java와 유사한 인터페이스를 사용했습니다. 파이썬에서 사용되는 대부분의 파서는 구식 인터페이스를 이용하지 않았기 때문에 더 간단한 서명을 선택했습니다. 새 인터페이스로 이전 코드를 변환하려면, 사용 &lt;em&gt;내용&lt;/em&gt; 대신 이전에 슬라이스 콘텐츠는 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;길이&lt;/em&gt; 매개 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="76ec6d13cceb3b560d2ffecdd1e137e7f039d3d4" translate="yes" xml:space="preserve">
          <source>The earliest representable &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;datetime(MINYEAR, 1, 1,
tzinfo=None)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;datetime(MINYEAR, 1, 1, tzinfo=None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9003e875acf880f08070ec4d1db25f2fc4aa782b" translate="yes" xml:space="preserve">
          <source>The earliest representable &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;time(0, 0, 0, 0)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;time(0, 0, 0, 0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47c650a99a648604cd819bc36b58ac25362286da" translate="yes" xml:space="preserve">
          <source>The earliest representable date, &lt;code&gt;date(MINYEAR, 1, 1)&lt;/code&gt;.</source>
          <target state="translated">가장 빠른 표현 가능한 날짜 &lt;code&gt;date(MINYEAR, 1, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05430a852b21c5e9152499419cfcc1dedc4dbcad" translate="yes" xml:space="preserve">
          <source>The easiest approach for trying out bignum arithmetic is to use the maximum value for &lt;code&gt;prec&lt;/code&gt; as well &lt;a href=&quot;#id5&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;:</source>
          <target state="translated">The easiest approach for trying out bignum arithmetic is to use the maximum value for &lt;code&gt;prec&lt;/code&gt; as well &lt;a href=&quot;#id5&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt;:</target>
        </trans-unit>
        <trans-unit id="bef193c5f3fa08733d4d4cd070fcd5c19da9c977" translate="yes" xml:space="preserve">
          <source>The easiest way to create a binary stream is with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;'b'&lt;/code&gt; in the mode string:</source>
          <target state="translated">이진 스트림을 만드는 가장 쉬운 방법 은 모드 문자열에서 &lt;code&gt;'b'&lt;/code&gt; 와 함께 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1d8d451e096581c982d771f39ecd4c6c3d239d0" translate="yes" xml:space="preserve">
          <source>The easiest way to create a text stream is with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, optionally specifying an encoding:</source>
          <target state="translated">텍스트 스트림을 만드는 가장 쉬운 방법은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 사용하여 선택적으로 인코딩을 지정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="78c60cbccd7a51f00d2d498ba443cdd533a6176c" translate="yes" xml:space="preserve">
          <source>The easiest way to provide your own policy is to override this class and call its methods in your overridden implementations before adding your own additional checks:</source>
          <target state="translated">자체 정책을 제공하는 가장 쉬운 방법은 자체 검사를 추가하기 전에이 클래스를 재정의하고 재정의 된 구현에서 해당 메서드를 호출하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c33291f3e651294d4ee970ee9b4832d9009fad1" translate="yes" xml:space="preserve">
          <source>The editing features described in previous subsections work when entering code interactively. IDLE&amp;rsquo;s Shell window also responds to the following keys.</source>
          <target state="translated">이전 하위 섹션에서 설명한 편집 기능은 대화식으로 코드를 입력 할 때 작동합니다. IDLE의 쉘 창은 다음 키에도 반응합니다.</target>
        </trans-unit>
        <trans-unit id="08a9deab57a6e87ba13c9cef116a534a382e5487" translate="yes" xml:space="preserve">
          <source>The effects of round-off error can be amplified by the addition or subtraction of nearly offsetting quantities resulting in loss of significance. Knuth provides two instructive examples where rounded floating point arithmetic with insufficient precision causes the breakdown of the associative and distributive properties of addition:</source>
          <target state="translated">반올림 오차의 효과는 거의 상쇄되는 양을 더하거나 빼서 증폭되어 유의미한 손실을 초래할 수 있습니다. Knuth는 정밀도가 불충분 한 둥근 부동 소수점 산술로 인해 연관성과 분배 특성이 추가되는 두 가지 유용한 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af646cedcd480fc2845b3a6b4f0d2380953bd50c" translate="yes" xml:space="preserve">
          <source>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. &lt;em&gt;parent&lt;/em&gt; is the parent element. &lt;em&gt;tag&lt;/em&gt; is the subelement name. &lt;em&gt;attrib&lt;/em&gt; is an optional dictionary, containing element attributes. &lt;em&gt;extra&lt;/em&gt; contains additional attributes, given as keyword arguments. Returns an element instance.</source>
          <target state="translated">요소 이름, 속성 이름 및 속성 값은 바이트 문자열 또는 유니 코드 문자열 일 수 있습니다. &lt;em&gt;parent&lt;/em&gt; 는 부모 요소입니다. &lt;em&gt;tag&lt;/em&gt; 는 하위 요소 이름입니다. &lt;em&gt;attrib&lt;/em&gt; 는 요소 속성을 포함하는 선택적 사전입니다. &lt;em&gt;extra&lt;/em&gt; 는 키워드 인수로 제공된 추가 속성을 포함합니다. 요소 인스턴스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3d0be1524ec53ac85afea89617259f2a7e5f14e4" translate="yes" xml:space="preserve">
          <source>The element name, attribute names, and attribute values can be either bytestrings or Unicode strings. &lt;em&gt;tag&lt;/em&gt; is the element name. &lt;em&gt;attrib&lt;/em&gt; is an optional dictionary, containing element attributes. &lt;em&gt;extra&lt;/em&gt; contains additional attributes, given as keyword arguments.</source>
          <target state="translated">요소 이름, 속성 이름 및 속성 값은 바이트 문자열 또는 유니 코드 문자열 일 수 있습니다. &lt;em&gt;태그&lt;/em&gt; 는 요소 이름입니다. &lt;em&gt;attrib&lt;/em&gt; 는 요소 속성을 포함하는 선택적 사전입니다. &lt;em&gt;extra&lt;/em&gt; 는 키워드 인수로 제공된 추가 속성을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="cdb4dcd901151ab5c9a7f2175c497daa8c2b36c5" translate="yes" xml:space="preserve">
          <source>The element named by the model name was declared to have a content model of &lt;code&gt;ANY&lt;/code&gt;.</source>
          <target state="translated">모델 이름으로 명명 된 요소는 &lt;code&gt;ANY&lt;/code&gt; 의 컨텐츠 모델을 갖도록 선언되었습니다 .</target>
        </trans-unit>
        <trans-unit id="534871b2bf6d13b459184db326339923a278d5b6" translate="yes" xml:space="preserve">
          <source>The element type name. In a namespace-using document it may have colons in it. The value is a string.</source>
          <target state="translated">요소 유형 이름 네임 스페이스를 사용하는 문서에는 콜론이있을 수 있습니다. 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="34e66592bc4e2c1b0614156015fd164a4e4c8c82" translate="yes" xml:space="preserve">
          <source>The email package calls this method with a list of strings, each string ending with the line separation characters found in the source being parsed. The first line includes the field header name and separator. All whitespace in the source is preserved. The method should return the &lt;code&gt;(name, value)&lt;/code&gt; tuple that is to be stored in the &lt;code&gt;Message&lt;/code&gt; to represent the parsed header.</source>
          <target state="translated">전자 메일 패키지는 문자열 목록과 함께이 메서드를 호출하며 각 문자열은 구문 분석중인 소스에서 줄 구분 문자로 끝납니다. 첫 번째 줄에는 필드 헤더 이름과 구분 기호가 포함됩니다. 소스의 모든 공백이 유지됩니다. 메소드는 구문 분석 된 헤더를 나타 내기 위해 &lt;code&gt;Message&lt;/code&gt; 에 저장 될 &lt;code&gt;(name, value)&lt;/code&gt; 튜플을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="3438c25b441b90b95233d8048c7ba543c03b2ff7" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; currently stored in the &lt;code&gt;Message&lt;/code&gt; for a given header. The method should return a string that represents that header &amp;ldquo;folded&amp;rdquo; correctly (according to the policy settings) by composing the &lt;em&gt;name&lt;/em&gt; with the &lt;em&gt;value&lt;/em&gt; and inserting &lt;a href=&quot;#email.policy.Policy.linesep&quot;&gt;&lt;code&gt;linesep&lt;/code&gt;&lt;/a&gt; characters at the appropriate places. See &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; for a discussion of the rules for folding email headers.</source>
          <target state="translated">전자 메일 패키지 는 지정된 헤더에 대해 현재 &lt;code&gt;Message&lt;/code&gt; 에 저장된 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 으로이 메서드를 호출합니다 . 이 방법은 &lt;em&gt;이름&lt;/em&gt; 을 &lt;em&gt;값&lt;/em&gt; 으로 구성 하고 적절한 위치에 &lt;a href=&quot;#email.policy.Policy.linesep&quot;&gt; &lt;code&gt;linesep&lt;/code&gt; &lt;/a&gt; 문자를 삽입 하여 정책 설정에 따라 헤더가 올바르게 &quot;접힌&quot;것을 나타내는 문자열을 반환해야 합니다. 이메일 헤더 접기 규칙에 대한 설명은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bb63a95898c5c4fb4763a2febdcbf523de818d32" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the &lt;em&gt;name&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; currently stored in the &lt;code&gt;Message&lt;/code&gt; when that header is requested by the application program, and whatever the method returns is what is passed back to the application as the value of the header being retrieved. Note that there may be more than one header with the same name stored in the &lt;code&gt;Message&lt;/code&gt;; the method is passed the specific name and value of the header destined to be returned to the application.</source>
          <target state="translated">전자 메일 패키지 는 응용 프로그램이 해당 헤더를 요청할 때 &lt;code&gt;Message&lt;/code&gt; 현재 저장된 &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;값&lt;/em&gt; 으로이 메서드를 호출 하며, 메서드가 반환하는 것은 검색되는 헤더의 값으로 응용 프로그램에 다시 전달되는 것입니다. &lt;code&gt;Message&lt;/code&gt; 에 같은 이름의 헤더가 두 개 이상 저장되어있을 수 있습니다 . 이 메소드에는 애플리케이션으로 리턴 될 헤더의 특정 이름과 값이 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b640d8f2580ab201b636d35ed547ad20d6e09b6b" translate="yes" xml:space="preserve">
          <source>The email package calls this method with the name and value provided by the application program when the application program is modifying a &lt;code&gt;Message&lt;/code&gt; programmatically (as opposed to a &lt;code&gt;Message&lt;/code&gt; created by a parser). The method should return the &lt;code&gt;(name, value)&lt;/code&gt; tuple that is to be stored in the &lt;code&gt;Message&lt;/code&gt; to represent the header.</source>
          <target state="translated">전자 메일 패키지는 응용 프로그램이 &lt;code&gt;Message&lt;/code&gt; 프로그래밍 방식으로 수정하는 경우 (파서가 만든 &lt;code&gt;Message&lt;/code&gt; 아닌) 응용 프로그램이 제공 한 이름과 값으로이 메서드를 호출합니다 . 메소드는 헤더를 나타 내기 위해 &lt;code&gt;Message&lt;/code&gt; 에 저장 될 &lt;code&gt;(name, value)&lt;/code&gt; 튜플을 리턴해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8f240002ee824e034224951554eb1c96d1d49a99" translate="yes" xml:space="preserve">
          <source>The email package does its best to hide the details of the various governing RFCs from the application. Conceptually the application should be able to treat the email message as a structured tree of unicode text and binary attachments, without having to worry about how these are represented when serialized. In practice, however, it is often necessary to be aware of at least some of the rules governing MIME messages and their structure, specifically the names and nature of the MIME &amp;ldquo;content types&amp;rdquo; and how they identify multipart documents. For the most part this knowledge should only be required for more complex applications, and even then it should only be the high level structure in question, and not the details of how those structures are represented. Since MIME content types are used widely in modern internet software (not just email), this will be a familiar concept to many programmers.</source>
          <target state="translated">이메일 패키지는 애플리케이션에서 다양한 관리 RFC의 세부 사항을 숨기도록 최선을 다합니다. 개념적으로 응용 프로그램은 전자 메일 메시지를 직렬화 할 때 어떻게 표현되는지에 대해 걱정할 필요없이 구조화 된 유니 코드 텍스트 및 이진 첨부 파일 트리로 처리 할 수 ​​있어야합니다. 그러나 실제로는 MIME 메시지와 그 구조, 특히 MIME&amp;ldquo;컨텐츠 유형&amp;rdquo;의 이름과 특성, 그리고 여러 부분으로 된 문서를 식별하는 방법을 관리하는 규칙 중 적어도 일부를 알고 있어야합니다. 대부분의 경우이 지식은보다 복잡한 응용 프로그램에만 필요하며, 심지어 이러한 구조가 어떻게 표현되는지에 대한 세부 사항이 아니라 문제가되는 높은 수준의 구조 여야합니다. MIME 콘텐츠 유형은 최신 인터넷 소프트웨어 (이메일뿐만 아니라)에서 널리 사용되므로이것은 많은 프로그래머에게 친숙한 개념이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="101c5ba6b37aa8005a49597770b8d1f23548c119" translate="yes" xml:space="preserve">
          <source>The encoded data will have newlines every 76 characters as per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html#section-6.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2045 section 6.8&lt;/strong&gt;&lt;/a&gt;, which was the de facto standard base64 specification when the XML-RPC spec was written.</source>
          <target state="translated">인코딩 된 데이터는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html#section-6.8&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2045 섹션 6.8에&lt;/strong&gt;&lt;/a&gt; 따라 76 자마다 줄 바꿈이 있으며 이는 XML-RPC 사양이 작성 될 때 사실상 표준 base64 사양이었습니다.</target>
        </trans-unit>
        <trans-unit id="79fd1f20636ced312cd94cdc52fdef0b7a8bfe16" translate="yes" xml:space="preserve">
          <source>The encoded value of the cookie &amp;mdash; this is what should be sent.</source>
          <target state="translated">쿠키의 인코딩 된 값 &amp;mdash; 전송해야합니다.</target>
        </trans-unit>
        <trans-unit id="96b435363fcdcb22ea2d43ea881834604e657ced" translate="yes" xml:space="preserve">
          <source>The encoder must be able to handle zero length input and return an empty object of the output object type in this situation.</source>
          <target state="translated">이 상황에서 인코더는 길이가 0 인 입력을 처리하고 출력 객체 유형의 빈 객체를 반환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="1631cb3d0d8698dbeb4af6cf19ae8b8843f6321c" translate="yes" xml:space="preserve">
          <source>The encoding attribute of the &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; is ignored if the &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt;&lt;code&gt;InputSource&lt;/code&gt;&lt;/a&gt; also contains a character stream.</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 에 문자 스트림도 포함되어 있으면 &lt;a href=&quot;#xml.sax.xmlreader.InputSource&quot;&gt; &lt;code&gt;InputSource&lt;/code&gt; &lt;/a&gt; 의 인코딩 속성 이 무시됩니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
