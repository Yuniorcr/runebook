<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="36b9e17d7f2e8503ed3820ee72a6419f06a8992e" translate="yes" xml:space="preserve">
          <source>The original underlying function is accessible through the &lt;code&gt;__wrapped__&lt;/code&gt; attribute. This is useful for introspection, for bypassing the cache, or for rewrapping the function with a different cache.</source>
          <target state="translated">원래의 기본 기능은 &lt;code&gt;__wrapped__&lt;/code&gt; 속성을 통해 액세스 할 수 있습니다 . 이것은 검사, 캐시 우회 또는 다른 캐시로 함수를 다시 랩핑하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1f5e734ae157beef9dabb5ce27cc3a21d3922b13" translate="yes" xml:space="preserve">
          <source>The other advantage of weakref based finalizers is that they can be used to register finalizers for classes where the definition is controlled by a third party, such as running code when a module is unloaded:</source>
          <target state="translated">weakref 기반 종료 자의 다른 장점은 모듈이 언로드 될 때 코드 실행과 같이 타사에서 정의를 제어하는 ​​클래스에 대해 종료자를 등록하는 데 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b23f8bd154c8799ba585c5a6902590dd8594933" translate="yes" xml:space="preserve">
          <source>The other arguments have the same meaning as in &lt;a href=&quot;#json.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt;, except &lt;em&gt;encoding&lt;/em&gt; which is ignored and deprecated since Python 3.1.</source>
          <target state="translated">다른 인수는 파이썬 3.1부터 무시되고 더 이상 사용되지 않는 &lt;em&gt;인코딩&lt;/em&gt; 을 제외하고 &lt;a href=&quot;#json.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 와 동일한 의미를 갖습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b337aa996882c3dc160c6dda566678dd0a76e3c0" translate="yes" xml:space="preserve">
          <source>The other arguments have the same meaning as in &lt;a href=&quot;#json.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 인수는 &lt;a href=&quot;#json.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 에서와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="138f5861a4612c6b38089cf45c9e62492b64b7d1" translate="yes" xml:space="preserve">
          <source>The other place where &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; inspects a type annotation is to determine if a field is an init-only variable. It does this by seeing if the type of a field is of type &lt;code&gt;dataclasses.InitVar&lt;/code&gt;. If a field is an &lt;code&gt;InitVar&lt;/code&gt;, it is considered a pseudo-field called an init-only field. As it is not a true field, it is not returned by the module-level &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; function. Init-only fields are added as parameters to the generated &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, and are passed to the optional &lt;code&gt;__post_init__()&lt;/code&gt; method. They are not otherwise used by dataclasses.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 가 형식 주석을 검사하는 다른 곳 은 필드가 초기화 전용 변수인지 확인하는 것입니다. 필드 유형이 &lt;code&gt;dataclasses.InitVar&lt;/code&gt; 유형 인지 확인하여이를 수행 합니다. 필드가 &lt;code&gt;InitVar&lt;/code&gt; 인 경우 필드는 init-only 필드라고하는 의사 필드로 간주됩니다. 실제 필드가 아니므로 모듈 레벨 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되지 않습니다 . 초기화 전용 필드는 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메서드에 매개 변수로 추가되며 선택적 &lt;code&gt;__post_init__()&lt;/code&gt; 메서드에 전달됩니다 . 데이터 클래스에서는 달리 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6860e124312deb3f4aee6c46ceeb9a533224aad0" translate="yes" xml:space="preserve">
          <source>The other place where &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; inspects a type annotation is to determine if a field is an init-only variable. It does this by seeing if the type of a field is of type &lt;code&gt;dataclasses.InitVar&lt;/code&gt;. If a field is an &lt;code&gt;InitVar&lt;/code&gt;, it is considered a pseudo-field called an init-only field. As it is not a true field, it is not returned by the module-level &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; function. Init-only fields are added as parameters to the generated &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; method, and are passed to the optional &lt;code&gt;__post_init__()&lt;/code&gt; method. They are not otherwise used by dataclasses.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 가 타입 어노테이션을 검사하는 다른 곳 은 필드가 초기화 전용 변수인지 확인하는 것입니다. 필드 유형이 &lt;code&gt;dataclasses.InitVar&lt;/code&gt; 유형 인지 확인하여이를 수행 합니다. 필드가 &lt;code&gt;InitVar&lt;/code&gt; 인 경우 init 전용 필드라고하는 의사 필드로 간주됩니다. 실제 필드가 아니므로 모듈 수준 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 함수에서 반환하지 않습니다 . 초기화 전용 필드는 생성 된 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 메서드에 매개 변수로 추가되고 선택적 &lt;code&gt;__post_init__()&lt;/code&gt; 메서드에 전달됩니다 . 그렇지 않으면 데이터 클래스에서 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c9ecdabaffb0595d8282336914bda13ba527fef0" translate="yes" xml:space="preserve">
          <source>The other possibility is to create a function that converts the type to the string representation and register the function with &lt;a href=&quot;#sqlite3.register_adapter&quot;&gt;&lt;code&gt;register_adapter()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다른 방법은 유형을 문자열 표현으로 변환하고 &lt;a href=&quot;#sqlite3.register_adapter&quot;&gt; &lt;code&gt;register_adapter()&lt;/code&gt; &lt;/a&gt; 함수를 등록 하는 함수를 작성하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="c30689f9b028ecc7b44927b0201ecc1a0e446de9" translate="yes" xml:space="preserve">
          <source>The other six arguments are functions that are called to turn argument names, &lt;code&gt;*&lt;/code&gt; argument name, &lt;code&gt;**&lt;/code&gt; argument name, default values, return annotation and individual annotations into strings, respectively.</source>
          <target state="translated">다른 6 개의 인수는 인수 이름, &lt;code&gt;*&lt;/code&gt; 인수 이름, &lt;code&gt;**&lt;/code&gt; 인수 이름, 기본값, 주석 및 개별 주석을 각각 문자열로 변환 하기 위해 호출되는 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="4e3374bba6da9adf05084b50cb70cf9e7a79cdd4" translate="yes" xml:space="preserve">
          <source>The other two major components of the package are the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;email.generator#module-email.generator&quot;&gt;&lt;code&gt;generator&lt;/code&gt;&lt;/a&gt;. The parser takes the serialized version of an email message (a stream of bytes) and converts it into a tree of &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; objects. The generator takes an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; and turns it back into a serialized byte stream. (The parser and generator also handle streams of text characters, but this usage is discouraged as it is too easy to end up with messages that are not valid in one way or another.)</source>
          <target state="translated">패키지의 다른 두 가지 주요 구성 요소는 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;email.generator#module-email.generator&quot;&gt; &lt;code&gt;generator&lt;/code&gt; &lt;/a&gt; 입니다. 파서는 일련의 전자 메일 메시지 버전 (바이트 스트림)을 가져와 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체 의 트리로 변환 합니다. 생성기는 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 를&lt;/a&gt; 가져 와서 직렬화 된 바이트 스트림으로 되돌립니다. 파서 및 생성기는 텍스트 문자 스트림도 처리하지만이 방법은 유효하지 않은 메시지로 끝나기가 너무 어렵 기 때문에 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5fbb08d4859f74e5eef6222cbab680f88900b022" translate="yes" xml:space="preserve">
          <source>The outermost leading and trailing &lt;em&gt;chars&lt;/em&gt; argument values are stripped from the string. Characters are removed from the leading end until reaching a string character that is not contained in the set of characters in &lt;em&gt;chars&lt;/em&gt;. A similar action takes place on the trailing end. For example:</source>
          <target state="translated">가장 바깥 쪽 선행 및 후행 &lt;em&gt;문자&lt;/em&gt; 인수 값이 문자열에서 제거됩니다. 문자의 문자 세트에 포함되지 않은 문자열 문자에 도달 할 때까지 선두에서 제거됩니다 &lt;em&gt;문자를&lt;/em&gt; . 후행에서도 비슷한 동작이 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68b11bf8863fb6840e03133afb634060c59d806f" translate="yes" xml:space="preserve">
          <source>The output for the example would look similar to this:</source>
          <target state="translated">예제의 출력은 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="027ddcfdff1a1014a29cd604d7a77e89ff8b8dd8" translate="yes" xml:space="preserve">
          <source>The output from this program is:</source>
          <target state="translated">이 프로그램의 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa760c1b26947d513cac59dff953b219b32f781c" translate="yes" xml:space="preserve">
          <source>The output is either a string (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) or binary (&lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;). This is controlled by the &lt;em&gt;encoding&lt;/em&gt; argument. If &lt;em&gt;encoding&lt;/em&gt; is &lt;code&gt;&quot;unicode&quot;&lt;/code&gt;, the output is a string; otherwise, it&amp;rsquo;s binary. Note that this may conflict with the type of &lt;em&gt;file&lt;/em&gt; if it&amp;rsquo;s an open &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;; make sure you do not try to write a string to a binary stream and vice versa.</source>
          <target state="translated">출력은 문자열 ( &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ) 또는 이진 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )입니다. 이것은 &lt;em&gt;인코딩&lt;/em&gt; 인수에 의해 제어됩니다 . 경우 &lt;em&gt;인코딩&lt;/em&gt; 인 &lt;code&gt;&quot;unicode&quot;&lt;/code&gt; , 출력은 문자열이며; 그렇지 않으면 이진입니다. 열린 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 인&lt;/a&gt; 경우 &lt;em&gt;파일&lt;/em&gt; 형식과 충돌 할 수 있습니다 . 문자열을 이진 스트림에 쓰거나 그 반대로 쓰려고하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ed4655e21ba76ccdca5d35c96a83b67eb7de7515" translate="yes" xml:space="preserve">
          <source>The output is either a string (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) or binary (&lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;). This is controlled by the &lt;em&gt;encoding&lt;/em&gt; argument. If &lt;em&gt;encoding&lt;/em&gt; is &lt;code&gt;&quot;unicode&quot;&lt;/code&gt;, the output is a string; otherwise, it&amp;rsquo;s binary. Note that this may conflict with the type of &lt;em&gt;file&lt;/em&gt; if it&amp;rsquo;s an open &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;; make sure you do not try to write a string to a binary stream and vice versa.</source>
          <target state="translated">출력은 문자열 ( &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ) 또는 이진 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )입니다. 이는 &lt;em&gt;인코딩&lt;/em&gt; 인수에 의해 제어됩니다 . 경우 &lt;em&gt;인코딩&lt;/em&gt; 인 &lt;code&gt;&quot;unicode&quot;&lt;/code&gt; , 출력은 문자열이며; 그렇지 않으면 바이너리입니다. 열린 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체 인&lt;/a&gt; 경우 &lt;em&gt;파일&lt;/em&gt; 유형과 충돌 할 수 있습니다 . 바이너리 스트림에 문자열을 쓰지 않도록하고 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="dcf5a38c006f26f008c99b2661299c3869a84556" translate="yes" xml:space="preserve">
          <source>The output is intended to be &lt;em&gt;human readable&lt;/em&gt; rather than machine parseable. It may look different on different platforms and this is intended.</source>
          <target state="translated">출력은 기계 구문 분석이 &lt;em&gt;가능&lt;/em&gt; 하지 않고 &lt;em&gt;사람이 읽을 수&lt;/em&gt; 있도록 만들어졌습니다 . 플랫폼마다 다르게 보일 수 있으며 이는 의도 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="019e47670eca13a96ca67c6acb10c4429918c123" translate="yes" xml:space="preserve">
          <source>The output of a CGI script should consist of two sections, separated by a blank line. The first section contains a number of headers, telling the client what kind of data is following. Python code to generate a minimal header section looks like this:</source>
          <target state="translated">CGI 스크립트의 출력은 빈 줄로 구분 된 두 섹션으로 구성되어야합니다. 첫 번째 섹션에는 클라이언트가 어떤 종류의 데이터를 추적하는지 알려주는 많은 헤더가 포함되어 있습니다. 최소 헤더 섹션을 생성하는 Python 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9372d8280e154ef7bd8cce1cb9067cf0ac6b897" translate="yes" xml:space="preserve">
          <source>The output of each example is checked using the &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s output checker, and the results are formatted by the &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; methods.</source>
          <target state="translated">각 예제 의 출력 은 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 의 출력 검사기를 사용하여 확인 되며 결과는 &lt;code&gt;DocTestRunner.report_*()&lt;/code&gt; 메소드 로 형식화됩니다 .</target>
        </trans-unit>
        <trans-unit id="585c88899418582ad73321158b0178e16e458068" translate="yes" xml:space="preserve">
          <source>The output of the example should look exactly like for the TCP server example.</source>
          <target state="translated">예제의 출력은 TCP 서버 예제와 정확히 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="00ef8f2fda1209e9f49161aa09f6645d996d526e" translate="yes" xml:space="preserve">
          <source>The output of the example should look something like this:</source>
          <target state="translated">예제의 결과는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="2ddac9a02ca6d6738022c8b8534a979f5593d7ce" translate="yes" xml:space="preserve">
          <source>The output string will &lt;em&gt;not&lt;/em&gt; include time zone information, regardless of whether the input is aware or naive.</source>
          <target state="translated">출력 문자열 에는 입력 인식 여부와 상관없이 시간대 정보가 포함 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6fc487de6f88b00ecc2f348b90e17727ccc9ccff" translate="yes" xml:space="preserve">
          <source>The output will then be:</source>
          <target state="translated">출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30e8eaae13d1dea954788334f3c9bd5becb2d6c6" translate="yes" xml:space="preserve">
          <source>The overall structure of the email package can be divided into three major components, plus a fourth component that controls the behavior of the other components.</source>
          <target state="translated">전자 메일 패키지의 전체 구조는 세 가지 주요 구성 요소와 다른 구성 요소의 동작을 제어하는 ​​네 번째 구성 요소로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ce355a2a46493371466043965a6b586867e0a7c" translate="yes" xml:space="preserve">
          <source>The pack() method can be called with keyword-option/value pairs that control where the widget is to appear within its container, and how it is to behave when the main application window is resized. Here are some examples:</source>
          <target state="translated">pack () 메서드는 컨테이너 내에서 위젯이 표시되는 위치와 기본 응용 프로그램 창의 크기를 조정할 때의 동작 방식을 제어하는 ​​키워드 옵션 / 값 쌍으로 호출 할 수 있습니다. 여기 몇 가지 예가 있어요.</target>
        </trans-unit>
        <trans-unit id="43d505e6a2e7c36776ba82d594697f730f5d036e" translate="yes" xml:space="preserve">
          <source>The package contents can be roughly split into four parts: low-level CAB routines, low-level MSI routines, higher-level MSI routines, and standard table structures.</source>
          <target state="translated">패키지 내용은 크게 저수준 CAB 루틴, 저수준 MSI 루틴, 고수준 MSI 루틴 및 표준 테이블 구조의 네 부분으로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e085f5fbf738e12557a40f2cfd7aded4c065ac" translate="yes" xml:space="preserve">
          <source>The packer is one of Tk&amp;rsquo;s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of the positioning of widgets within their container - their mutual &lt;em&gt;master&lt;/em&gt;. In contrast to the more cumbersome &lt;em&gt;placer&lt;/em&gt; (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - &lt;em&gt;above&lt;/em&gt;, &lt;em&gt;to the left of&lt;/em&gt;, &lt;em&gt;filling&lt;/em&gt;, etc - and works everything out to determine the exact placement coordinates for you.</source>
          <target state="translated">패커는 Tk의 지오메트리 관리 메커니즘 중 하나입니다. 지오메트리 관리자는 컨테이너 내에서 위젯의 위치를 ​​상호 &lt;em&gt;마스터&lt;/em&gt; 로 지정하는 상대적 위치를 지정하는 데 사용됩니다 . 패커는 좀 더 성가신 &lt;em&gt;플레이 서&lt;/em&gt; (일반적으로 덜 사용되며 여기서 다루지 않음)와 달리 &lt;em&gt;위의&lt;/em&gt; , &lt;em&gt;왼쪽의&lt;/em&gt; , &lt;em&gt;채우기&lt;/em&gt; 등과 &lt;em&gt;같은&lt;/em&gt; 정 성적 관계 사양을 취하여 정확한 배치 좌표를 결정하기 위해 모든 것을 작동시킵니다. 당신을 위해.</target>
        </trans-unit>
        <trans-unit id="d00bfaddba4b6a311bea1718f0f6923a76662ed2" translate="yes" xml:space="preserve">
          <source>The packer is one of Tk&amp;rsquo;s geometry-management mechanisms. Geometry managers are used to specify the relative positioning of widgets within their container - their mutual &lt;em&gt;master&lt;/em&gt;. In contrast to the more cumbersome &lt;em&gt;placer&lt;/em&gt; (which is used less commonly, and we do not cover here), the packer takes qualitative relationship specification - &lt;em&gt;above&lt;/em&gt;, &lt;em&gt;to the left of&lt;/em&gt;, &lt;em&gt;filling&lt;/em&gt;, etc - and works everything out to determine the exact placement coordinates for you.</source>
          <target state="translated">패커는 Tk의 기하학 관리 메커니즘 중 하나입니다. 지오메트리 관리자는 컨테이너 내에서 위젯의 상대적 위치 (상호 &lt;em&gt;마스터)&lt;/em&gt; 를 지정하는 데 사용됩니다 . 덜 일반적으로 사용되며 여기서 다루지 않는 보다 성가신 &lt;em&gt;placer&lt;/em&gt; 와 달리 패커는 &lt;em&gt;위&lt;/em&gt; , &lt;em&gt;왼쪽&lt;/em&gt; , &lt;em&gt;채우기&lt;/em&gt; 등 &lt;em&gt;의&lt;/em&gt; 정 성적 관계 사양을 취하고 모든 작업을 수행하여 정확한 배치 좌표를 결정합니다. 당신을 위해.</target>
        </trans-unit>
        <trans-unit id="253cb8189b2936e9dc31ecb164b214955e29b52e" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;do_handshake_on_connect&lt;/code&gt; specifies whether to do the SSL handshake automatically after doing a &lt;code&gt;socket.connect()&lt;/code&gt;, or whether the application program will call it explicitly, by invoking the &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; method. Calling &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt;&lt;/a&gt; explicitly gives the program control over the blocking behavior of the socket I/O involved in the handshake.</source>
          <target state="translated">&lt;code&gt;do_handshake_on_connect&lt;/code&gt; 매개 변수 는 &lt;code&gt;socket.connect()&lt;/code&gt; 수행 한 후 SSL 핸드 셰이크를 자동으로 수행 할지 또는 애플리케이션 프로그램이 &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 명시 적으로 호출할지 여부를 지정합니다 . &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;SSLSocket.do_handshake()&lt;/code&gt; &lt;/a&gt; 호출 하면 핸드 셰이크에 관련된 소켓 I / O의 블로킹 동작을 프로그램이 명시 적으로 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e2325d973c251eaad6d5fa92d991f2af2611734" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;server_side&lt;/code&gt; is a boolean which identifies whether server-side or client-side behavior is desired from this socket.</source>
          <target state="translated">&lt;code&gt;server_side&lt;/code&gt; 매개 변수 는이 소켓에서 서버 측 또는 클라이언트 측 동작을 원하는지 식별하는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="823e6e4ffdf11c7805d8ae352770d5ed2e9f8a18" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;suppress_ragged_eofs&lt;/code&gt; specifies how the &lt;code&gt;SSLSocket.recv()&lt;/code&gt; method should signal unexpected EOF from the other end of the connection. If specified as &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; (the default), it returns a normal EOF (an empty bytes object) in response to unexpected EOF errors raised from the underlying socket; if &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, it will raise the exceptions back to the caller.</source>
          <target state="translated">&lt;code&gt;suppress_ragged_eofs&lt;/code&gt; 매개 변수 는 &lt;code&gt;SSLSocket.recv()&lt;/code&gt; 메소드가 연결의 다른 쪽 끝에서 예기치 않은 EOF 신호를 보내는 방법을 지정합니다 . &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; (기본값) 로 지정 되면 기본 소켓에서 발생한 예기치 않은 EOF 오류에 대한 응답으로 일반 EOF (빈 바이트 개체)를 반환합니다. &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 인 경우 예외를 호출자에게 다시 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="425f1ffaff5f611531ca4dc03dbc5808560f4199" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;arg&lt;/em&gt; can be one of an integer, an object supporting the read-only buffer interface (like &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) or an object supporting the read-write buffer interface (like &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">매개 변수 &lt;em&gt;arg&lt;/em&gt; 는 정수, 읽기 전용 버퍼 인터페이스를 지원하는 객체 (예 : &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; ) 또는 읽기 / 쓰기 버퍼 인터페이스를 지원하는 객체 (예 : &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; ) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="07f0e19bb360bd19a1a80e689ce45296940e8971" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;reuse_address&lt;/em&gt; is no longer supported, as using &lt;code&gt;SO_REUSEADDR&lt;/code&gt; poses a significant security concern for UDP. Explicitly passing &lt;code&gt;reuse_address=True&lt;/code&gt; will raise an exception.</source>
          <target state="translated">&lt;code&gt;SO_REUSEADDR&lt;/code&gt; 을 사용 하면 UDP에 중요한 보안 문제 가 발생 &lt;em&gt;하므로 reuse_address&lt;/em&gt; 매개 변수 는 더 이상 지원되지 않습니다 . &lt;code&gt;reuse_address=True&lt;/code&gt; 를 명시 적으로 전달 하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e3d9bf8f3c1e1166d31d759e64e3dbeea2b50d58" translate="yes" xml:space="preserve">
          <source>The parameter interpretation recognizes local and global variable names, constant values, branch targets, and compare operators.</source>
          <target state="translated">매개 변수 해석은 로컬 및 글로벌 변수 이름, 상수 값, 분기 대상 및 비교 연산자를 인식합니다.</target>
        </trans-unit>
        <trans-unit id="4364023a096cfc76a5aaccc26d05253c492b0d07" translate="yes" xml:space="preserve">
          <source>The parameters are as for &lt;code&gt;FileHandler&lt;/code&gt;. The attributes are:</source>
          <target state="translated">매개 변수는 &lt;code&gt;FileHandler&lt;/code&gt; 와 같습니다 . 속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="328fb050a12d6f49d22d231e4d9497b6bf6996e1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 의 매개 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4121375e3f99104ec54ea4f3d41c8050dcbed2d1" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;a href=&quot;#dataclasses.field&quot;&gt;&lt;code&gt;field()&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.field&quot;&gt; &lt;code&gt;field()&lt;/code&gt; &lt;/a&gt; 대한 매개 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b0533de393e7b886a40041244b0c1cf85c2921d" translate="yes" xml:space="preserve">
          <source>The parameters to the constructor are the same as those for &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">생성자의 매개 변수는 &lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt; 의 매개 변수와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="3db46ab8cdee19add4d74116b81d433cfd3167ac" translate="yes" xml:space="preserve">
          <source>The parent of the current node, or &lt;code&gt;None&lt;/code&gt; for the document node. The value is always a &lt;code&gt;Node&lt;/code&gt; object or &lt;code&gt;None&lt;/code&gt;. For &lt;code&gt;Element&lt;/code&gt; nodes, this will be the parent element, except for the root element, in which case it will be the &lt;code&gt;Document&lt;/code&gt; object. For &lt;code&gt;Attr&lt;/code&gt; nodes, this is always &lt;code&gt;None&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">현재 노드의 부모이거나 문서 노드의 경우 &lt;code&gt;None&lt;/code&gt; 값은 항상 &lt;code&gt;Node&lt;/code&gt; 객체이거나 &lt;code&gt;None&lt;/code&gt; 입니다. 위해 &lt;code&gt;Element&lt;/code&gt; 노드,이는 것이 경우 루트 요소를 제외하고, 부모 요소가됩니다 &lt;code&gt;Document&lt;/code&gt; 객체입니다. 들어 &lt;code&gt;Attr&lt;/code&gt; 의 노드, 이것은 항상 없다 &lt;code&gt;None&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="3a3afdd265cba6fd880178e4866ef40903b31ca4" translate="yes" xml:space="preserve">
          <source>The parent package for the module/package. If the module is top-level then it has a value of the empty string. The &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt;&lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt;&lt;/a&gt; decorator can handle the details for &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt;&lt;code&gt;__package__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈 / 패키지의 상위 패키지. 모듈이 최상위 레벨이면 빈 문자열 값을 갖습니다. &lt;a href=&quot;#importlib.util.module_for_loader&quot;&gt; &lt;code&gt;importlib.util.module_for_loader()&lt;/code&gt; &lt;/a&gt; 데코레이터에 대한 세부 처리 할 수 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__package__&quot;&gt; &lt;code&gt;__package__&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1adae70f45cb1346a91a2a0f4115caab6117d269" translate="yes" xml:space="preserve">
          <source>The parent process starts a fresh python interpreter process. The child process will only inherit those resources necessary to run the process objects &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method. In particular, unnecessary file descriptors and handles from the parent process will not be inherited. Starting a process using this method is rather slow compared to using &lt;em&gt;fork&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt;.</source>
          <target state="translated">부모 프로세스는 새로운 파이썬 인터프리터 프로세스를 시작합니다. 하위 프로세스는 프로세스 오브젝트 &lt;a href=&quot;#multiprocessing.Process.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드 를 실행하는 데 필요한 자원 만 상속합니다 . 특히, 상위 프로세스의 불필요한 파일 디스크립터 및 핸들은 상속되지 않습니다. 이 방법을 사용하여 프로세스를 시작하면 &lt;em&gt;fork&lt;/em&gt; 또는 &lt;em&gt;forkserver&lt;/em&gt; 를 사용하는 것보다 속도가 느립니다 .</target>
        </trans-unit>
        <trans-unit id="369b3db27e2ba62379ec6c6f36a1ad6fef163ee0" translate="yes" xml:space="preserve">
          <source>The parent process uses &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;os.fork()&lt;/code&gt;&lt;/a&gt; to fork the Python interpreter. The child process, when it begins, is effectively identical to the parent process. All resources of the parent are inherited by the child process. Note that safely forking a multithreaded process is problematic.</source>
          <target state="translated">부모 프로세스는 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;os.fork()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 Python 인터프리터를 포크합니다. 자식 프로세스는 시작할 때 부모 프로세스와 사실상 동일합니다. 부모의 모든 리소스는 자식 프로세스에 의해 상속됩니다. 멀티 스레드 프로세스를 안전하게 분기하는 것은 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="595e02418163451e1abf531e59bf4de57ad3c4ec" translate="yes" xml:space="preserve">
          <source>The parse_args() method</source>
          <target state="translated">parse_args () 메소드</target>
        </trans-unit>
        <trans-unit id="1370400415985cb2cf13a044f34b42c6fd02cbfa" translate="yes" xml:space="preserve">
          <source>The parser determined that the document was not &amp;ldquo;standalone&amp;rdquo; though it declared itself to be in the XML declaration, and the &lt;code&gt;NotStandaloneHandler&lt;/code&gt; was set and returned &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">파서는 문서 자체가 XML 선언으로 선언되었지만 문서가 &quot;독립형&quot;이 아니라는 것을 확인했으며 &lt;code&gt;NotStandaloneHandler&lt;/code&gt; 가 설정되어 &lt;code&gt;0&lt;/code&gt; 을 반환했습니다 .</target>
        </trans-unit>
        <trans-unit id="45abc8da4046f26f9e15931202a6cfb3bb8736a5" translate="yes" xml:space="preserve">
          <source>The parser for the binary format raises &lt;code&gt;InvalidFileException&lt;/code&gt; when the file cannot be parsed.</source>
          <target state="translated">파일을 구문 분석 할 수없는 경우 이진 형식의 구문 분석기가 &lt;code&gt;InvalidFileException&lt;/code&gt; 을 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="315804a5fe161d8d161d75f269b0b17d66a550b3" translate="yes" xml:space="preserve">
          <source>The parser module defines a single exception, but may also pass other built-in exceptions from other portions of the Python runtime environment. See each function for information about the exceptions it can raise.</source>
          <target state="translated">파서 모듈은 단일 예외를 정의하지만 Python 런타임 환경의 다른 부분에서 다른 기본 제공 예외를 전달할 수도 있습니다. 발생할 수있는 예외에 대한 정보는 각 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4451c261ab34fa6d68e139583b9b8883047b5ca2" translate="yes" xml:space="preserve">
          <source>The parser module is deprecated and will be removed in future versions of Python. For the majority of use cases you can leverage the Abstract Syntax Tree (AST) generation and compilation stage, using the &lt;a href=&quot;ast#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">파서 모듈은 더 이상 사용되지 않으며 향후 Python 버전에서 제거 될 예정입니다. 대부분의 사용 사례에서 &lt;a href=&quot;ast#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 AST (추상 구문 트리) 생성 및 컴파일 단계를 활용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47584cab28c64372ee0a66e9d6a85d1c121c012c" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; following the colon if there is one, else the entire &lt;code&gt;tagName&lt;/code&gt;. The value is a string.</source>
          <target state="translated">의 부분 &lt;code&gt;tagName&lt;/code&gt; 콜론 다음은 하나, 다른 사람 전체가있는 경우 &lt;code&gt;tagName&lt;/code&gt; . 값은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="775fe3289edf96d060db49b7c4beddb50812e922" translate="yes" xml:space="preserve">
          <source>The part of the &lt;code&gt;tagName&lt;/code&gt; preceding the colon if there is one, else the empty string. The value is a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">콜론 앞에 있는 &lt;code&gt;tagName&lt;/code&gt; 부분 (있는 경우), 그렇지 않으면 빈 문자열. 값은 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="301b1af6ca20a6249a998cf35ee08045545a44b5" translate="yes" xml:space="preserve">
          <source>The part of the name following the colon if there is one, else the entire name. This is a read-only attribute.</source>
          <target state="translated">콜론 뒤에있는 이름의 일부 (있는 경우), 그렇지 않으면 전체 이름. 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="4b6ccf0c7b353e7f2cec6eae5206ddd756cf2a42" translate="yes" xml:space="preserve">
          <source>The part of the name preceding the colon if there is one, else the empty string.</source>
          <target state="translated">콜론 앞에있는 이름 부분 (있는 경우), 그렇지 않으면 빈 문자열.</target>
        </trans-unit>
        <trans-unit id="037c9a3ec1e20519c87dbc77e141395c51a490ab" translate="yes" xml:space="preserve">
          <source>The particular order that is returned may depend on the specific order in which the items were inserted in the graph. For example:</source>
          <target state="translated">반환되는 특정 순서는 항목이 그래프에 삽입 된 특정 순서에 따라 달라질 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="62c63b165c6cabcf3fb6d0c615994fd200d6b0b6" translate="yes" xml:space="preserve">
          <source>The particular values &lt;code&gt;sys.hash_info.inf&lt;/code&gt;, &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; and &lt;code&gt;sys.hash_info.nan&lt;/code&gt; are used as hash values for positive infinity, negative infinity, or nans (respectively). (All hashable nans have the same hash value.)</source>
          <target state="translated">특정 값 &lt;code&gt;sys.hash_info.inf&lt;/code&gt; , &lt;code&gt;-sys.hash_info.inf&lt;/code&gt; 및 &lt;code&gt;sys.hash_info.nan&lt;/code&gt; 은 양의 무한대, 음의 무한대 또는 nan (각각)의 해시 값으로 사용됩니다. (해시 가능한 모든 nan은 해시 값이 동일합니다.)</target>
        </trans-unit>
        <trans-unit id="946eb4b10e46d85a90cbba3ce04154b4eb521ecd" translate="yes" xml:space="preserve">
          <source>The passed in callback is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">전달 된 콜백은 함수에서 반환되므로이 메소드를 함수 데코레이터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d752ee7919317c8ef5e1cf67a53020b721a4c8d" translate="yes" xml:space="preserve">
          <source>The passed in object is returned from the function, allowing this method to be used as a function decorator.</source>
          <target state="translated">전달 된 객체는 함수에서 반환되므로이 메소드를 함수 데코레이터로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80f6bc83b260a46ac7e550138dc8f3532aa793b1" translate="yes" xml:space="preserve">
          <source>The patch decorators are used for patching objects only within the scope of the function they decorate. They automatically handle the unpatching for you, even if exceptions are raised. All of these functions can also be used in with statements or as class decorators.</source>
          <target state="translated">패치 데코레이터는 장식하는 기능 범위 내에서만 객체를 패치하는 데 사용됩니다. 예외가 발생하더라도 자동으로 패치 해제를 처리합니다. 이러한 함수는 모두 문장이나 클래스 데코레이터로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7081c6361ff2f82dac43fc3e7d1619bac7f3e3f" translate="yes" xml:space="preserve">
          <source>The patchers</source>
          <target state="translated">패처</target>
        </trans-unit>
        <trans-unit id="befdf46d9ff3d7a1dab0edf47f0724094bd9b1cc" translate="yes" xml:space="preserve">
          <source>The path the finder will search in.</source>
          <target state="translated">파인더가 검색 할 경로입니다.</target>
        </trans-unit>
        <trans-unit id="74622e717d8bc0ccf71b94541baf057d565c1905" translate="yes" xml:space="preserve">
          <source>The path to the bytecode file.</source>
          <target state="translated">바이트 코드 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="35ba4af1a78250ec64c0e2392522fa5eb8e9cfe4" translate="yes" xml:space="preserve">
          <source>The path to the source file.</source>
          <target state="translated">소스 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="33a48412e2e67c67c7e92a4715e6b43be0fd6d15" translate="yes" xml:space="preserve">
          <source>The path to where a compiled version of the module is/should be stored (not set when the attribute would be inappropriate).</source>
          <target state="translated">컴파일 된 버전의 모듈이 저장되는 경로입니다 (속성이 부적절하면 설정되지 않음).</target>
        </trans-unit>
        <trans-unit id="7a8d3812438de73c08083ea24db7366309aa89e4" translate="yes" xml:space="preserve">
          <source>The path to where the module data is stored (not set for built-in modules).</source>
          <target state="translated">모듈 데이터가 저장되는 경로입니다 (내장 모듈에 설정되지 않음).</target>
        </trans-unit>
        <trans-unit id="6d3422ae55b1cae3c297fd0d2a7bb36e7dde778d" translate="yes" xml:space="preserve">
          <source>The pattern is deliberately not stored as a loader attribute so that packages can continue discovery themselves. &lt;em&gt;top_level_dir&lt;/em&gt; is stored so &lt;code&gt;load_tests&lt;/code&gt; does not need to pass this argument in to &lt;code&gt;loader.discover()&lt;/code&gt;.</source>
          <target state="translated">패턴은 의도적으로 로더 속성으로 저장되지 않으므로 패키지가 계속해서 발견을 계속할 수 있습니다. &lt;em&gt;top_level_dir이&lt;/em&gt; 때문에 저장 &lt;code&gt;load_tests&lt;/code&gt; 이 에이 인수를 전달할 필요가 없습니다 &lt;code&gt;loader.discover()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d752d1425dfb41387a9c85ad6aa7411b1b12149" translate="yes" xml:space="preserve">
          <source>The pattern may be a string or a &lt;a href=&quot;#re-objects&quot;&gt;pattern object&lt;/a&gt;.</source>
          <target state="translated">패턴은 문자열 또는 &lt;a href=&quot;#re-objects&quot;&gt;패턴 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4198abc6596ed451fcb1e4b11283fe46e47a9bdd" translate="yes" xml:space="preserve">
          <source>The pattern string from which the pattern object was compiled.</source>
          <target state="translated">패턴 객체가 컴파일 된 패턴 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ffa1bd1e5a895a32634127debbd4d54e90aadf39" translate="yes" xml:space="preserve">
          <source>The permutation tuples are emitted in lexicographic ordering according to the order of the input &lt;em&gt;iterable&lt;/em&gt;. So, if the input &lt;em&gt;iterable&lt;/em&gt; is sorted, the combination tuples will be produced in sorted order.</source>
          <target state="translated">순열 튜플은 입력 &lt;em&gt;iterable&lt;/em&gt; 의 순서에 따라 사전 식 순서로 방출됩니다 . 따라서 입력 &lt;em&gt;iterable&lt;/em&gt; 이 정렬되면 조합 튜플이 정렬 된 순서로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f91ca744d391bb72b78aa2afd81f096934a681" translate="yes" xml:space="preserve">
          <source>The philosophy and structure of the two classes is otherwise the same.</source>
          <target state="translated">두 클래스의 철학과 구조는 다른 방식으로 동일합니다.</target>
        </trans-unit>
        <trans-unit id="896181308dbe91750b43d1e225e480bee0e585e6" translate="yes" xml:space="preserve">
          <source>The platform does not provide information on whether the UUID was generated safely or not.</source>
          <target state="translated">플랫폼은 UUID가 안전하게 생성되었는지 여부에 대한 정보를 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ebc22381e3d1840239ccd9e5f1d63077ee7dfbb" translate="yes" xml:space="preserve">
          <source>The position of the sign (for positive resp. negative values), see below.</source>
          <target state="translated">부호의 위치 (양의 음수 값)는 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59952542e7942305c827d02265033fc6e9dbe5db" translate="yes" xml:space="preserve">
          <source>The positional argument pattern matches that of &lt;a href=&quot;stdtypes#range&quot;&gt;&lt;code&gt;range()&lt;/code&gt;&lt;/a&gt;. Keyword arguments should not be used because the function may use them in unexpected ways.</source>
          <target state="translated">위치 인수 패턴은 &lt;a href=&quot;stdtypes#range&quot;&gt; &lt;code&gt;range()&lt;/code&gt; &lt;/a&gt; 패턴과 일치합니다 . 함수가 예상치 못한 방식으로 키워드를 사용할 수 있으므로 키워드 인수를 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="112fe2d97f81ed80cec8656f5adddd507c3ca3eb" translate="yes" xml:space="preserve">
          <source>The positional-only arguments &lt;em&gt;path&lt;/em&gt;, &lt;em&gt;args&lt;/em&gt;, and &lt;em&gt;env&lt;/em&gt; are similar to &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위치 전용 인수 &lt;em&gt;path&lt;/em&gt; , &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;env&lt;/em&gt; 는 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="fe3e48c18afdb606d8cb78f91a0899ad96906f15" translate="yes" xml:space="preserve">
          <source>The possible values for &lt;code&gt;'p_sign_posn'&lt;/code&gt; and &lt;code&gt;'n_sign_posn'&lt;/code&gt; are given below.</source>
          <target state="translated">&lt;code&gt;'p_sign_posn'&lt;/code&gt; 및 &lt;code&gt;'n_sign_posn'&lt;/code&gt; 에 가능한 값 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f6833954936c8ae7c88396b0dc8d3e749d41eb23" translate="yes" xml:space="preserve">
          <source>The precise rules are as follows: suppose that the result formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt; would have exponent &lt;code&gt;exp&lt;/code&gt;. Then, if &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is -4 for floats and -6 for &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;Decimals&lt;/code&gt;&lt;/a&gt;, the number is formatted with presentation type &lt;code&gt;'f'&lt;/code&gt; and precision &lt;code&gt;p-1-exp&lt;/code&gt;. Otherwise, the number is formatted with presentation type &lt;code&gt;'e'&lt;/code&gt; and precision &lt;code&gt;p-1&lt;/code&gt;. In both cases insignificant trailing zeros are removed from the significand, and the decimal point is also removed if there are no remaining digits following it, unless the &lt;code&gt;'#'&lt;/code&gt; option is used.</source>
          <target state="translated">정확한 규칙은 다음과 같습니다. 프리젠 테이션 유형 &lt;code&gt;'e'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1&lt;/code&gt; 로 형식화 된 결과에 지수 &lt;code&gt;exp&lt;/code&gt; 가 있다고 가정하십시오 . 그런 다음 &lt;code&gt;m &amp;lt;= exp &amp;lt; p&lt;/code&gt; , 여기서 &lt;code&gt;m&lt;/code&gt; 은 float의 경우 -4이고 &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;Decimals&lt;/code&gt; 의&lt;/a&gt; 경우 -6 이면 숫자는 프리젠 테이션 유형 &lt;code&gt;'f'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1-exp&lt;/code&gt; 로 형식이 지정됩니다 . 그렇지 않으면 숫자는 프리젠 테이션 유형 &lt;code&gt;'e'&lt;/code&gt; 및 정밀도 &lt;code&gt;p-1&lt;/code&gt; 로 형식이 지정됩니다 . 두 경우 모두 중요하지 않은 후행 0은 유의점에서 제거되고 &lt;code&gt;'#'&lt;/code&gt; 옵션을 사용 하지 않는 한 그 뒤에 남은 자릿수가 없으면 소수점도 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="41fdd41826344d0be40e07a7c74ff491f514c5f0" translate="yes" xml:space="preserve">
          <source>The precision determines the number of digits after the decimal point and defaults to 6.</source>
          <target state="translated">정밀도는 소수점 뒤의 자릿수를 결정하며 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="9b79033d293b6c31c75ffa5814aa5c087d000b3d" translate="yes" xml:space="preserve">
          <source>The precision determines the number of significant digits before and after the decimal point and defaults to 6.</source>
          <target state="translated">정밀도는 소수점 전후의 유효 자릿수를 결정하며 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="3cd6b8e24856e292a10d35639bc3c6b06da2cd2f" translate="yes" xml:space="preserve">
          <source>The precision of the various real-time functions may be less than suggested by the units in which their value or argument is expressed. E.g. on most Unix systems, the clock &amp;ldquo;ticks&amp;rdquo; only 50 or 100 times a second.</source>
          <target state="translated">다양한 실시간 함수의 정밀도는 값이나 인수가 표현되는 단위에서 제안한 것보다 적을 수 있습니다. 예를 들어 대부분의 유닉스 시스템에서 클럭은 초당 50 또는 100 회만 &quot;틱&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="31605b7764d8a03a7877d08fc669e90605f06565" translate="yes" xml:space="preserve">
          <source>The predicate must be a callable which result will be interpreted as a boolean value. The final value is the return value.</source>
          <target state="translated">술어는 호출 가능해야하며 결과는 부울 값으로 해석됩니다. 최종 값은 반환 값입니다.</target>
        </trans-unit>
        <trans-unit id="399c6b1dfd67b2c650301b9195aaff4a7832e1a5" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Condition is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">Condition을 사용하는 기본 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="7d88a730e18917a56485cbcfcd85f3d8377fab9c" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Condition is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">Condition을 사용하는 기본 방법은 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="9ee67a620d44fb1681005258c0c62d822ecd2282" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Lock is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">잠금을 사용하는 선호되는 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="72c98823a0ffab256e4ec15370f0e5edc89e30b8" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Lock is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">Lock을 사용하는 선호하는 방법은 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="9bf6315de2d03fd0877883f3226ad7bcb258a563" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Semaphore is an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">세마포어를 사용하는 기본 방법은 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="73cfcf54cb5d398dd23695dfb914f4aa72e6e417" translate="yes" xml:space="preserve">
          <source>The preferred way to use a Semaphore is an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt;&lt;code&gt;async with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">Semaphore를 사용하는 선호하는 방법은 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-with&quot;&gt; &lt;code&gt;async with&lt;/code&gt; &lt;/a&gt; 문입니다.</target>
        </trans-unit>
        <trans-unit id="fe4a24206790bdb6dfb50de90139956972f17d56" translate="yes" xml:space="preserve">
          <source>The prefix defines the number of leading bits in an address that are compared to determine whether or not an address is part of a network.</source>
          <target state="translated">접두사는 주소가 네트워크의 일부인지 여부를 판별하기 위해 비교되는 주소의 선행 비트 수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e953212a6913d9281232d06868614a71454e1b60" translate="yes" xml:space="preserve">
          <source>The prefix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접두사는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​비슷한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a361ce2a67573642097e5871616b5630b23a5c9" translate="yes" xml:space="preserve">
          <source>The prefix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접두사는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e690cd09d2161493928c7ed836c69440297a338" translate="yes" xml:space="preserve">
          <source>The previous section explains how to read CGI form data using the &lt;code&gt;FieldStorage&lt;/code&gt; class. This section describes a higher level interface which was added to this class to allow one to do it in a more readable and intuitive way. The interface doesn&amp;rsquo;t make the techniques described in previous sections obsolete &amp;mdash; they are still useful to process file uploads efficiently, for example.</source>
          <target state="translated">이전 섹션에서는 &lt;code&gt;FieldStorage&lt;/code&gt; 클래스를 사용하여 CGI 양식 데이터를 읽는 방법에 대해 설명합니다 . 이 섹션에서는이 클래스에 추가되어보다 읽기 쉽고 직관적 인 방식으로 수행 할 수있는 고급 인터페이스에 대해 설명합니다. 이 인터페이스는 이전 섹션에서 설명한 기술을 쓸모 없게 만들지 않습니다. 예를 들어 파일 업로드를 효율적으로 처리하는 데 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7523173e59a7046859cb60342d5e26f6d306040f" translate="yes" xml:space="preserve">
          <source>The primary API method. It takes a format string and an arbitrary set of positional and keyword arguments. It is just a wrapper that calls &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 API 메소드 형식 문자열과 임의의 위치 및 키워드 인수 집합을 사용합니다. &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 을 호출하는 래퍼 일뿐 입니다.</target>
        </trans-unit>
        <trans-unit id="4d20207a32c469b27878eb965894ae9e5054d063" translate="yes" xml:space="preserve">
          <source>The primary entry point is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="translated">기본 진입 점은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9632d79faa271090d54fe68aba8e08af8dd702cf" translate="yes" xml:space="preserve">
          <source>The primary entry point is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;:</source>
          <target state="translated">기본 진입 점은 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;생성기입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99dba641bcba4143cddc64727faefe6f987cf349" translate="yes" xml:space="preserve">
          <source>The primary information is passed in &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;args&lt;/code&gt;, which are combined using &lt;code&gt;msg % args&lt;/code&gt; to create the &lt;code&gt;message&lt;/code&gt; field of the record.</source>
          <target state="translated">기본 정보는 &lt;code&gt;msg&lt;/code&gt; 및 &lt;code&gt;args&lt;/code&gt; 로 전달되며 msg &lt;code&gt;msg % args&lt;/code&gt; 를 사용하여 결합 되어 레코드 의 &lt;code&gt;message&lt;/code&gt; 필드 를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="7bfbe0efc6318910175e0591c9d489213ef2eebb" translate="yes" xml:space="preserve">
          <source>The primary use case for &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; is the one given in the class documentation: supporting a variable number of context managers and other cleanup operations in a single &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The variability may come from the number of context managers needed being driven by user input (such as opening a user specified collection of files), or from some of the context managers being optional:</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 의 기본 유스 케이스 는 클래스 문서에 제공된 것입니다 . 단일 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 으로 가변 수의 컨텍스트 관리자 및 기타 정리 작업 을 지원 합니다. 변수는 사용자 입력 (예 : 사용자 지정 파일 모음 열기)에 의해 구동되어야하는 컨텍스트 관리자의 수 또는 선택적 컨텍스트 관리자 중 일부에서 비롯 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dbb93a98c46da8ad3ba58b1529253e2426f9275b" translate="yes" xml:space="preserve">
          <source>The primary use case for &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; is the one given in the class documentation: supporting a variable number of context managers and other cleanup operations in a single &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. The variability may come from the number of context managers needed being driven by user input (such as opening a user specified collection of files), or from some of the context managers being optional:</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 의 주요 사용 사례 는 클래스 문서에 제공된 것입니다 . 단일 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 다양한 수의 컨텍스트 관리자 및 기타 정리 작업 을 지원 합니다. 가변성은 사용자 입력 (예 : 사용자 지정 파일 모음 열기)에 의해 구동되어야하는 컨텍스트 관리자의 수 또는 선택 사항 인 일부 컨텍스트 관리자에서 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29e9483a317900afadce553033a91cd1d47b9bcf" translate="yes" xml:space="preserve">
          <source>The principal built-in types are numerics, sequences, mappings, classes, instances and exceptions.</source>
          <target state="translated">기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다.</target>
        </trans-unit>
        <trans-unit id="53a56e829c4ee5d3a496f807f49d36341548a22a" translate="yes" xml:space="preserve">
          <source>The printing of warning messages is done by calling &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt;, which may be overridden; the default implementation of this function formats the message by calling &lt;a href=&quot;#warnings.formatwarning&quot;&gt;&lt;code&gt;formatwarning()&lt;/code&gt;&lt;/a&gt;, which is also available for use by custom implementations.</source>
          <target state="translated">경고 메시지의 인쇄는 재정의 될 수있는 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 을 호출하여 수행됩니다 . 이 함수의 기본 구현은 &lt;a href=&quot;#warnings.formatwarning&quot;&gt; &lt;code&gt;formatwarning()&lt;/code&gt; &lt;/a&gt; 을 호출하여 메시지를 형식화하며 , 이는 사용자 정의 구현에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="825b7993e09a5012896880aa81ed2189c1fc5fc3" translate="yes" xml:space="preserve">
          <source>The priorities of the binary bitwise operations are all lower than the numeric operations and higher than the comparisons; the unary operation &lt;code&gt;~&lt;/code&gt; has the same priority as the other unary numeric operations (&lt;code&gt;+&lt;/code&gt; and &lt;code&gt;-&lt;/code&gt;).</source>
          <target state="translated">이진 비트 단위 연산의 우선 순위는 모두 숫자 연산보다 낮고 비교보다 높습니다. 단항 연산 &lt;code&gt;~&lt;/code&gt; 는 다른 단항 숫자 연산 ( &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;-&lt;/code&gt; ) 과 동일한 우선 순위를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="5bf0a8ae599a694d8728a80398296f63055fcd91" translate="yes" xml:space="preserve">
          <source>The probability distribution function is:</source>
          <target state="translated">확률 분포 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f4b0a33ec009f539e41f7c7861882fe3861eb27" translate="yes" xml:space="preserve">
          <source>The problem is more important with &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; than with the lower-overhead &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;. For this reason, &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; provides a means of calibrating itself for a given platform so that this error can be probabilistically (on the average) removed. After the profiler is calibrated, it will be more accurate (in a least square sense), but it will sometimes produce negative numbers (when call counts are exceptionally low, and the gods of probability work against you :-). ) Do &lt;em&gt;not&lt;/em&gt; be alarmed by negative numbers in the profile. They should &lt;em&gt;only&lt;/em&gt; appear if you have calibrated your profiler, and the results are actually better than without calibration.</source>
          <target state="translated">문제는 오버 헤드가 낮은 &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt; 보다 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 더 중요 합니다 . 이러한 이유로, &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 은 특정 플랫폼에 대해 자체 교정 방법을 제공하므로이 오류를 확률 적으로 (평균적으로) 제거 할 수 있습니다. 프로파일 러가 보정 된 후에는 더 정확할 것입니다 (최소한 제곱의 의미에서). 그러나 때로는 음수를 생성합니다 (통화 횟수가 예외적으로 낮고 확률의 신들이 당신을 상대로 :-). )는 마십시오 &lt;em&gt;하지&lt;/em&gt; 프로필의 음수 놀라지. 그들은해야 &lt;em&gt;에만&lt;/em&gt; 당신이 당신의 프로파일 러를 보정 한 경우 표시되며 결과는 실제로 교정이없는 것보다 낫다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a7bf59022d95e063a71d9d155d556fa687e8151c" translate="yes" xml:space="preserve">
          <source>The problem with the code is that you should never expect that a client will provide valid input to your scripts. For example, if a curious user appends another &lt;code&gt;user=foo&lt;/code&gt; pair to the query string, then the script would crash, because in this situation the &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; method call returns a list instead of a string. Calling the &lt;a href=&quot;stdtypes#str.upper&quot;&gt;&lt;code&gt;upper()&lt;/code&gt;&lt;/a&gt; method on a list is not valid (since lists do not have a method of this name) and results in an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">코드의 문제점은 클라이언트가 스크립트에 유효한 입력을 제공 할 것이라고 기 대해서는 안된다는 것입니다. 예를 들어, 궁금한 사용자가 다른 &lt;code&gt;user=foo&lt;/code&gt; 쌍을 쿼리 문자열에 추가 하면 &lt;code&gt;getvalue(&quot;user&quot;)&lt;/code&gt; 메서드 호출이 문자열 대신 목록을 반환 하기 때문에 스크립트가 중단 됩니다. 리스트 에서 &lt;a href=&quot;stdtypes#str.upper&quot;&gt; &lt;code&gt;upper()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하는 것은 유효하지 않으며 (리스트에이 이름의 메소드가 없기 때문에) &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="96fdb4e91d747f7b382ca34963ea4e97a833f290" translate="yes" xml:space="preserve">
          <source>The procedural interface provides functions which are derived from the methods of the classes &lt;a href=&quot;#turtle.Screen&quot;&gt;&lt;code&gt;Screen&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#turtle.Turtle&quot;&gt;&lt;code&gt;Turtle&lt;/code&gt;&lt;/a&gt;. They have the same names as the corresponding methods. A screen object is automatically created whenever a function derived from a Screen method is called. An (unnamed) turtle object is automatically created whenever any of the functions derived from a Turtle method is called.</source>
          <target state="translated">절차 적 인터페이스는 &lt;a href=&quot;#turtle.Screen&quot;&gt; &lt;code&gt;Screen&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#turtle.Turtle&quot;&gt; &lt;code&gt;Turtle&lt;/code&gt; &lt;/a&gt; 클래스의 메소드에서 파생 된 함수를 제공합니다 . 해당 메소드와 이름이 같습니다. Screen 객체는 Screen 메서드에서 파생 된 함수가 호출 될 때마다 자동으로 만들어집니다. Turtle 메소드에서 파생 된 함수가 호출 될 때마다 (이름이없는) turtle 객체가 자동으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2e489b4dd7453fa49df07a28774b20b3ff3ca536" translate="yes" xml:space="preserve">
          <source>The process ID of the child process.</source>
          <target state="translated">하위 프로세스의 프로세스 ID</target>
        </trans-unit>
        <trans-unit id="150de663b2d1dfe4e98950a0d814ed1d1e220721" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s authentication key (a byte string).</source>
          <target state="translated">프로세스의 인증 키 (바이트 문자열)</target>
        </trans-unit>
        <trans-unit id="17a501bfd01684f2b434b6e89089168e44514201" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s daemon flag, a Boolean value. This must be set before &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">프로세스의 데몬 플래그, 부울 값 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 를 호출 하기 전에 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="06c818f8e2a507968c04b9b39e1decda880a5cf5" translate="yes" xml:space="preserve">
          <source>The process&amp;rsquo;s name. The name is a string used for identification purposes only. It has no semantics. Multiple processes may be given the same name.</source>
          <target state="translated">프로세스 이름 이름은 식별 목적으로 만 사용되는 문자열입니다. 의미가 없습니다. 여러 프로세스에 동일한 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9c95a490df7fa30b946fe0f7a64b2a77f6f669a" translate="yes" xml:space="preserve">
          <source>The produced code string will not necessarily be equal to the original code that generated the &lt;a href=&quot;#ast.AST&quot;&gt;&lt;code&gt;ast.AST&lt;/code&gt;&lt;/a&gt; object (without any compiler optimizations, such as constant tuples/frozensets).</source>
          <target state="translated">생성 된 코드 문자열이 &lt;a href=&quot;#ast.AST&quot;&gt; &lt;code&gt;ast.AST&lt;/code&gt; &lt;/a&gt; 개체 를 생성 한 원래 코드와 반드시 같지는 않습니다 (상수 튜플 / 고정 집합과 같은 컴파일러 최적화없이).</target>
        </trans-unit>
        <trans-unit id="b2ae1e6a3ccabf77f11a716a76fae3c85a9de04b" translate="yes" xml:space="preserve">
          <source>The profiler modules are designed to provide an execution profile for a given program, not for benchmarking purposes (for that, there is &lt;a href=&quot;timeit#module-timeit&quot;&gt;&lt;code&gt;timeit&lt;/code&gt;&lt;/a&gt; for reasonably accurate results). This particularly applies to benchmarking Python code against C code: the profilers introduce overhead for Python code, but not for C-level functions, and so the C code would seem faster than any Python one.</source>
          <target state="translated">프로파일 러 모듈은 벤치마킹 목적이 아닌 주어진 프로그램에 대한 실행 프로파일을 제공하도록 설계되었습니다 ( &lt;a href=&quot;timeit#module-timeit&quot;&gt; &lt;code&gt;timeit&lt;/code&gt; &lt;/a&gt; 정확한 결과를 얻을 수있는 시간이 있습니다). 이것은 특히 C 코드에 대한 Python 코드 벤치마킹에 적용됩니다. 프로파일 러는 Python 코드에 대한 오버 헤드를 도입하지만 C 레벨 함수에는 오버 헤드를 도입하지 않으므로 C 코드는 Python 코드보다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="1ad274b67435cbea4d0f0022c9cb8f04c789c28d" translate="yes" xml:space="preserve">
          <source>The profiler of the &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; module subtracts a constant from each event handling time to compensate for the overhead of calling the time function, and socking away the results. By default, the constant is 0. The following procedure can be used to obtain a better constant for a given platform (see &lt;a href=&quot;#profile-limitations&quot;&gt;Limitations&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 모듈 의 프로파일 러는 각 이벤트 처리 시간에서 상수를 빼서 시간 함수 호출의 오버 헤드를 보상하고 결과를 숨 깁니다. 기본적으로 상수는 0입니다. 주어진 플랫폼에 대해 더 나은 상수를 얻기 위해 다음 절차를 사용할 수 있습니다 ( &lt;a href=&quot;#profile-limitations&quot;&gt;제한 사항&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="c57ccc0f47b6d649d42fac7c15dd4c76568d4399" translate="yes" xml:space="preserve">
          <source>The prompt issued to solicit input.</source>
          <target state="translated">입력을 요청하는 프롬프트가 발행되었습니다.</target>
        </trans-unit>
        <trans-unit id="83875c7800a2b76dd59acb9bb82a7881a37ecba4" translate="yes" xml:space="preserve">
          <source>The property list (&lt;code&gt;.plist&lt;/code&gt;) file format is a simple serialization supporting basic object types, like dictionaries, lists, numbers and strings. Usually the top level object is a dictionary.</source>
          <target state="translated">속성 목록 ( &lt;code&gt;.plist&lt;/code&gt; ) 파일 형식은 사전, 목록, 숫자 및 문자열과 같은 기본 개체 유형을 지원하는 간단한 직렬화입니다. 일반적으로 최상위 개체는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="a692e4b23f49571c480a6608de6502020e3e6363" translate="yes" xml:space="preserve">
          <source>The proposal and rationale for this feature, including links to earlier implementations and information about similar features in other languages.</source>
          <target state="translated">이전 구현에 대한 링크 및 다른 언어의 유사한 기능에 대한 정보를 포함하여이 기능에 대한 제안 및 근거.</target>
        </trans-unit>
        <trans-unit id="d3279c37a3d4b93f2763c17e116a163fb04d69c0" translate="yes" xml:space="preserve">
          <source>The proposal which described this feature for inclusion in the Python standard library.</source>
          <target state="translated">Python 표준 라이브러리에 포함하기 위해이 기능을 설명한 제안입니다.</target>
        </trans-unit>
        <trans-unit id="6aad5f6edb9228644868ffcfbe2652bf80458149" translate="yes" xml:space="preserve">
          <source>The protocol instance is coupled with the transport by calling its &lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt;&lt;code&gt;connection_made()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">프로토콜 인스턴스는 &lt;a href=&quot;asyncio-protocol#asyncio.BaseProtocol.connection_made&quot;&gt; &lt;code&gt;connection_made()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 전송과 연결 됩니다.</target>
        </trans-unit>
        <trans-unit id="5bcebb7947c21cec173aaf44168e072aa830c96e" translate="yes" xml:space="preserve">
          <source>The protocol version chosen when constructing the context. This attribute is read-only.</source>
          <target state="translated">컨텍스트를 구성 할 때 선택한 프로토콜 버전입니다. 이 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="4b8e37987302667a8c6a5a30086ea70af54f58fc" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed.</source>
          <target state="translated">피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="304bb59bee6afe03568f30f120fa0b442a6c61e2" translate="yes" xml:space="preserve">
          <source>The protocol version of the pickle is detected automatically, so no protocol argument is needed. Bytes past the pickled representation of the object are ignored.</source>
          <target state="translated">피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인수가 필요하지 않습니다. 피클 링 된 객체 표현 이후의 바이트는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="27bd7c4faffc395f3247caddbe9693091c3dd829" translate="yes" xml:space="preserve">
          <source>The protocol, options, cipher and other settings may change to more restrictive values anytime without prior deprecation. The values represent a fair balance between compatibility and security.</source>
          <target state="translated">프로토콜, 옵션, 암호 및 기타 설정은 사전 사용 중단없이 언제든지 더 제한적인 값으로 변경 될 수 있습니다. 이 값은 호환성과 보안 간의 적절한 균형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9bb42a552b302f1dbded8b49b736ac990615d6f9" translate="yes" xml:space="preserve">
          <source>The proxy types in &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; do nothing to support comparisons by value. So, for instance, we have:</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 의 프록시 유형은 값별 비교를 지원하지 않습니다. 예를 들어 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef765547ec364b540a8f16063c0fa31ef2bb74cb" translate="yes" xml:space="preserve">
          <source>The pseudo-random generators of this module should not be used for security purposes. For security or cryptographic uses, see the &lt;a href=&quot;secrets#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이 모듈의 의사 난수 발생기는 보안 목적으로 사용해서는 안됩니다. 보안 또는 암호화 사용에 대해서는 &lt;a href=&quot;secrets#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a7da2517da5604deefcd3b219dc6bc72a5207e5e" translate="yes" xml:space="preserve">
          <source>The public identifier for the external subset of the document type definition. This will be a string or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문서 유형 정의의 외부 서브 세트에 대한 공용 식별자. 이것은 문자열이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4cc24cc4f00882f93419ab13bd6a8c64685b3f66" translate="yes" xml:space="preserve">
          <source>The public methods of the Screen and Turtle classes are documented extensively via docstrings. So these can be used as online-help via the Python help facilities:</source>
          <target state="translated">Screen 및 Turtle 클래스의 공개 메소드는 문서화 문자열을 통해 광범위하게 문서화됩니다. 파이썬 도움말 기능을 통해 온라인 도움말로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bed0ab16eca2867630c9e7cc4d96b74b1c2265f" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;a href=&quot;#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; package is two-fold. One is to provide the implementation of the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement (and thus, by extension, the &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function) in Python source code. This provides an implementation of &lt;code&gt;import&lt;/code&gt; which is portable to any Python interpreter. This also provides an implementation which is easier to comprehend than one implemented in a programming language other than Python.</source>
          <target state="translated">&lt;a href=&quot;#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 패키지 의 목적 은 두 가지입니다. 하나는 파이썬 소스 코드에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문 (따라서 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수) 의 구현을 제공하는 것입니다 . 이것은 모든 파이썬 인터프리터에 이식 가능한 &lt;code&gt;import&lt;/code&gt; 구현을 제공합니다 . 또한 파이썬 이외의 프로그래밍 언어로 구현 된 것보다 이해하기 쉬운 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c5af7de07ad25b8b16b26a5eec475ceb8c25175a" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;a href=&quot;#module-importlib&quot;&gt;&lt;code&gt;importlib&lt;/code&gt;&lt;/a&gt; package is two-fold. One is to provide the implementation of the &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement (and thus, by extension, the &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function) in Python source code. This provides an implementation of &lt;code&gt;import&lt;/code&gt; which is portable to any Python interpreter. This also provides an implementation which is easier to comprehend than one implemented in a programming language other than Python.</source>
          <target state="translated">&lt;a href=&quot;#module-importlib&quot;&gt; &lt;code&gt;importlib&lt;/code&gt; &lt;/a&gt; 패키지 의 목적 은 두 가지입니다. 하나는 파이썬 소스 코드에서 &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문 (즉, &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수) 의 구현을 제공하는 것입니다 . 이것은 모든 파이썬 인터프리터에 이식 가능한 &lt;code&gt;import&lt;/code&gt; 구현을 제공합니다 . 이것은 또한 Python 이외의 프로그래밍 언어로 구현 된 것보다 이해하기 쉬운 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b16dd66cb16f34ace27bac31206afc6d4d2fe723" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;find_library()&lt;/code&gt; function is to locate a library in a way similar to what the compiler or runtime loader does (on platforms with several versions of a shared library the most recent should be loaded), while the ctypes library loaders act like when a program is run, and call the runtime loader directly.</source>
          <target state="translated">&lt;code&gt;find_library()&lt;/code&gt; 함수 의 목적은 컴파일러 또는 런타임 로더가 수행하는 것과 유사한 방식으로 라이브러리를 찾는 것입니다 (최근에로드해야하는 여러 버전의 공유 라이브러리가있는 플랫폼에서). ctypes 라이브러리 로더는 다음과 같이 작동합니다. 프로그램이 실행될 때 런타임 로더를 직접 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="fa702db0cff6f2f3895045c3752a9fbb38f37c5c" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;em&gt;context&lt;/em&gt; argument is determining what to do if &lt;em&gt;value&lt;/em&gt; is a malformed string. If the context traps &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt;&lt;code&gt;InvalidOperation&lt;/code&gt;&lt;/a&gt;, an exception is raised; otherwise, the constructor returns a new Decimal with the value of &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;컨텍스트&lt;/em&gt; 인수 의 목적은 &lt;em&gt;값&lt;/em&gt; 이 조작 된 문자열 인 경우 수행 할 작업을 결정하는 것 입니다. 컨텍스트가 &lt;a href=&quot;#decimal.InvalidOperation&quot;&gt; &lt;code&gt;InvalidOperation&lt;/code&gt; 을&lt;/a&gt; 트랩 하면 예외가 발생합니다. 그렇지 않으면 생성자는 &lt;code&gt;NaN&lt;/code&gt; 값을 가진 새 Decimal을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1d7470421cad5575eb47710dc31f2ce6a15d669a" translate="yes" xml:space="preserve">
          <source>The pysqlite web page &amp;ndash; sqlite3 is developed externally under the name &amp;ldquo;pysqlite&amp;rdquo;.</source>
          <target state="translated">pysqlite 웹 페이지 &amp;ndash; sqlite3은&amp;ldquo;pysqlite&amp;rdquo;라는 이름으로 외부에서 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="df0d2d334ee13950a07c31e697402c72d3e65e9f" translate="yes" xml:space="preserve">
          <source>The quoting is compatible with UNIX shells and with &lt;a href=&quot;#shlex.split&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">인용은 UNIX 쉘 및 &lt;a href=&quot;#shlex.split&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 과 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ce58c924d511abccc91112f9868301eab2a2623" translate="yes" xml:space="preserve">
          <source>The range really is &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;61&lt;/code&gt;; value &lt;code&gt;60&lt;/code&gt; is valid in timestamps representing &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt; and value &lt;code&gt;61&lt;/code&gt; is supported for historical reasons.</source>
          <target state="translated">범위는 실제로 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;61&lt;/code&gt; 입니다 . 값 &lt;code&gt;60&lt;/code&gt; 은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;윤초를&lt;/a&gt; 나타내는 타임 스탬프에서 유효 하며 값 &lt;code&gt;61&lt;/code&gt; 은 역사적 이유로 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd421df5dc2685a581e00c1459b24396ed076e6" translate="yes" xml:space="preserve">
          <source>The raw stream API is described in detail in the docs of &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">원시 스트림 API는 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92473e24fa37abfabba3bd84c199a20643551ee1" translate="yes" xml:space="preserve">
          <source>The raw version number of the OpenSSL library, as a single integer:</source>
          <target state="translated">OpenSSL 라이브러리의 원시 버전 번호 (단일 정수) :</target>
        </trans-unit>
        <trans-unit id="f5f4e5aa79fcae7b1a4aee5bb988c8d392ca329d" translate="yes" xml:space="preserve">
          <source>The reason for defaulting to &lt;code&gt;1&lt;/code&gt; as the starting number and not &lt;code&gt;0&lt;/code&gt; is that &lt;code&gt;0&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; in a boolean sense, but enum members all evaluate to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 이 아닌 시작 번호로 기본값을 &lt;code&gt;1&lt;/code&gt; 로 설정하는 이유 는 &lt;code&gt;0&lt;/code&gt; 이 부울 의미에서 &lt;code&gt;False&lt;/code&gt; 이지만 열거 형 멤버가 모두 &lt;code&gt;True&lt;/code&gt; 로 평가되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="8b8da247393cb3f901f4c9827fb1c55335da705f" translate="yes" xml:space="preserve">
          <source>The reason for this error. It can be a message string or another exception instance.</source>
          <target state="translated">이 오류의 이유입니다. 메시지 문자열 또는 다른 예외 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cdf1c2c1cd73bb92ad5a97181b39bc3deca2b0b" translate="yes" xml:space="preserve">
          <source>The reason the attributes exist is to save you having to subclass - you can use the same callables for instances of &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;&lt;/a&gt;. If either the namer or rotator callable raises an exception, this will be handled in the same way as any other exception during an &lt;code&gt;emit()&lt;/code&gt; call, i.e. via the &lt;code&gt;handleError()&lt;/code&gt; method of the handler.</source>
          <target state="translated">속성이 존재하는 이유는 서브 클래스 를 &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt; &lt;code&gt;TimedRotatingFileHandler&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt; &lt;code&gt;RotatingFileHandler&lt;/code&gt; &lt;/a&gt; 및 TimedRotatingFileHandler 인스턴스에 대해 동일한 콜 러블 을 사용할 수 있습니다 . namer 또는 rotator callable에서 예외가 발생하면 &lt;code&gt;emit()&lt;/code&gt; 호출 중에 다른 예외와 같은 방식으로 처리됩니다 ( 예 : 핸들러 의 &lt;code&gt;handleError()&lt;/code&gt; 메소드를 통해 ) .</target>
        </trans-unit>
        <trans-unit id="3b9780bd4e28d18b6c6eb957a0c871c293f95ffa" translate="yes" xml:space="preserve">
          <source>The recipe is conceptually equivalent to an algorithm that chooses from all the multiples of 2⁻&amp;sup1;⁰⁷⁴ in the range &lt;em&gt;0.0 &amp;le; x &amp;lt; 1.0&lt;/em&gt;. All such numbers are evenly spaced, but most have to be rounded down to the nearest representable Python float. (The value 2⁻&amp;sup1;⁰⁷⁴ is the smallest positive unnormalized float and is equal to &lt;code&gt;math.ulp(0.0)&lt;/code&gt;.)</source>
          <target state="translated">레시피는 개념적으로 &lt;em&gt;0.0 &amp;le; x &amp;lt;1.0&lt;/em&gt; 범위에있는 2⁻&amp;sup1;⁰⁷⁴의 모든 배수에서 선택하는 알고리즘과 동일합니다 . 이러한 모든 숫자는 균등 한 간격으로 배치되지만 대부분은 가장 가까운 표현 가능한 Python 부동 소수점으로 내림해야합니다. (값 2⁻&amp;sup1;⁰⁷⁴은 가장 작은 양의 비정규 화 부동 소수점이며 &lt;code&gt;math.ulp(0.0)&lt;/code&gt; 와 같습니다 .)</target>
        </trans-unit>
        <trans-unit id="89d87c844ed2c3d32ca4dbf0d2608b75aaafce69" translate="yes" xml:space="preserve">
          <source>The recommended &lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt; installer runs all &lt;code&gt;setup.py&lt;/code&gt; scripts with &lt;code&gt;setuptools&lt;/code&gt;, even if the script itself only imports &lt;code&gt;distutils&lt;/code&gt;. Refer to the &lt;a href=&quot;https://packaging.python.org&quot;&gt;Python Packaging User Guide&lt;/a&gt; for more information.</source>
          <target state="translated">권장되는 &lt;a href=&quot;https://pip.pypa.io/&quot;&gt;pip&lt;/a&gt; 설치 프로그램은 스크립트 자체가 &lt;code&gt;distutils&lt;/code&gt; 만 가져 오더라도 &lt;code&gt;setuptools&lt;/code&gt; 를 사용하여 모든 &lt;code&gt;setup.py&lt;/code&gt; 스크립트를 실행합니다 . 자세한 내용은 &lt;a href=&quot;https://packaging.python.org&quot;&gt;Python Packaging 사용자 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3708eceef9e8fc9b657fbd262aa2dd3c8c9e05c" translate="yes" xml:space="preserve">
          <source>The recommended approach to invoking subprocesses is to use the &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; function for all use cases it can handle. For more advanced use cases, the underlying &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; interface can be used directly.</source>
          <target state="translated">서브 프로세스 호출에 권장되는 접근 방식 은 처리 할 수있는 모든 사용 사례에 대해 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것입니다. 고급 사용 사례의 경우 기본 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 인터페이스를 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd6e5d6a0931f68dfa7a32f3cada332bb112bb51" translate="yes" xml:space="preserve">
          <source>The recommended way to create a custom action is to extend &lt;a href=&quot;#argparse.Action&quot;&gt;&lt;code&gt;Action&lt;/code&gt;&lt;/a&gt;, overriding the &lt;code&gt;__call__&lt;/code&gt; method and optionally the &lt;code&gt;__init__&lt;/code&gt; and &lt;code&gt;format_usage&lt;/code&gt; methods.</source>
          <target state="translated">사용자 지정 작업을 만드는 데 권장되는 방법은 &lt;a href=&quot;#argparse.Action&quot;&gt; &lt;code&gt;Action&lt;/code&gt; &lt;/a&gt; 을 확장 하여 &lt;code&gt;__call__&lt;/code&gt; 메서드와 선택적으로 &lt;code&gt;__init__&lt;/code&gt; 및 &lt;code&gt;format_usage&lt;/code&gt; 메서드를 재정의 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ccb4dc482b74e7926d22ef923199ab80c945bb99" translate="yes" xml:space="preserve">
          <source>The recommended way to create array types is by multiplying a data type with a positive integer:</source>
          <target state="translated">배열 유형을 만드는 권장 방법은 데이터 유형에 양의 정수를 곱하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="66efc06bb3809b5e55afbd1288c458d0d954c17a" translate="yes" xml:space="preserve">
          <source>The recommended way to create concrete array types is by multiplying any &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; data type with a positive integer. Alternatively, you can subclass this type and define &lt;a href=&quot;#ctypes.Array._length_&quot;&gt;&lt;code&gt;_length_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.Array._type_&quot;&gt;&lt;code&gt;_type_&lt;/code&gt;&lt;/a&gt; class variables. Array elements can be read and written using standard subscript and slice accesses; for slice reads, the resulting object is &lt;em&gt;not&lt;/em&gt; itself an &lt;a href=&quot;#ctypes.Array&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구체적인 배열 유형을 만드는 권장 방법은 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 데이터 유형에 양의 정수 를 곱하는 것 입니다. 또는이 유형을 서브 클래 싱하고 &lt;a href=&quot;#ctypes.Array._length_&quot;&gt; &lt;code&gt;_length_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.Array._type_&quot;&gt; &lt;code&gt;_type_&lt;/code&gt; &lt;/a&gt; 클래스 변수를 정의 할 수 있습니다 . 표준 첨자 및 슬라이스 액세스를 사용하여 배열 요소를 읽고 쓸 수 있습니다. 슬라이스 읽기의 경우 결과 객체 자체는 &lt;a href=&quot;#ctypes.Array&quot;&gt; &lt;code&gt;Array&lt;/code&gt; &lt;/a&gt; 가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="db258e380ae1e9f11acb7ecd11189586c81b75b9" translate="yes" xml:space="preserve">
          <source>The reconstructed script is returned as a single string. The result is guaranteed to tokenize back to match the input so that the conversion is lossless and round-trips are assured. The guarantee applies only to the token type and token string as the spacing between tokens (column positions) may change.</source>
          <target state="translated">재구성 된 스크립트는 단일 문자열로 반환됩니다. 결과는 입력과 일치하도록 토큰 화하여 변환에 손실이없고 왕복이 보장됩니다. 토큰 (열 위치) 사이의 간격이 변경 될 수 있으므로 보증은 토큰 유형과 토큰 문자열에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="57acf8c8e12eab6d4b3a3f62dbb9d6a2820d0c9c" translate="yes" xml:space="preserve">
          <source>The reconstructor (the &lt;code&gt;_reconstruct&lt;/code&gt; class method) returns the buffer&amp;rsquo;s providing object if it has the right type. This is an easy way to simulate zero-copy behaviour on this toy example.</source>
          <target state="translated">재구성 자 ( &lt;code&gt;_reconstruct&lt;/code&gt; 클래스 메소드)는 버퍼의 제공 오브젝트에 올바른 유형이있는 경우이를 제공합니다. 이 장난감 예제에서 무 복사 동작을 시뮬레이션하는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6832c932800d1e21134679897c1c0c648c46cac9" translate="yes" xml:space="preserve">
          <source>The record is formatted, and then sent to the syslog server. If exception information is present, it is &lt;em&gt;not&lt;/em&gt; sent to the server.</source>
          <target state="translated">레코드가 포맷 된 다음 syslog 서버로 전송됩니다. 예외 정보가 있으면 서버로 전송 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="0b70780ad8c59629bb44ba0ecc4d77b4f436096b" translate="yes" xml:space="preserve">
          <source>The record&amp;rsquo;s attribute dictionary is used as the operand to a string formatting operation. Returns the resulting string. Before formatting the dictionary, a couple of preparatory steps are carried out. The &lt;em&gt;message&lt;/em&gt; attribute of the record is computed using &lt;em&gt;msg&lt;/em&gt; % &lt;em&gt;args&lt;/em&gt;. If the formatting string contains &lt;code&gt;'(asctime)'&lt;/code&gt;, &lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt;&lt;code&gt;formatTime()&lt;/code&gt;&lt;/a&gt; is called to format the event time. If there is exception information, it is formatted using &lt;a href=&quot;#logging.Formatter.formatException&quot;&gt;&lt;code&gt;formatException()&lt;/code&gt;&lt;/a&gt; and appended to the message. Note that the formatted exception information is cached in attribute &lt;em&gt;exc_text&lt;/em&gt;. This is useful because the exception information can be pickled and sent across the wire, but you should be careful if you have more than one &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; subclass which customizes the formatting of exception information. In this case, you will have to clear the cached value after a formatter has done its formatting, so that the next formatter to handle the event doesn&amp;rsquo;t use the cached value but recalculates it afresh.</source>
          <target state="translated">레코드의 속성 사전은 문자열 형식화 조작의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 사전을 형식화하기 전에 몇 가지 준비 단계가 수행됩니다. 레코드 의 &lt;em&gt;메시지&lt;/em&gt; 속성은 &lt;em&gt;msg&lt;/em&gt; % &lt;em&gt;args를&lt;/em&gt; 사용하여 계산됩니다 . 서식 문자열이 포함되어있는 경우 &lt;code&gt;'(asctime)'&lt;/code&gt; , &lt;a href=&quot;#logging.Formatter.formatTime&quot;&gt; &lt;code&gt;formatTime()&lt;/code&gt; &lt;/a&gt; 이벤트 시간을 포맷이라고합니다. 예외 정보가 있으면 &lt;a href=&quot;#logging.Formatter.formatException&quot;&gt; &lt;code&gt;formatException()&lt;/code&gt; &lt;/a&gt; 사용하여 형식이 지정 되고 메시지에 추가됩니다. 형식화 된 예외 정보는 &lt;em&gt;exc_text&lt;/em&gt; 속성에 캐시됩니다.&lt;em&gt;&lt;/em&gt;. 이는 예외 정보를 유선으로 전달하고 전송할 수 있기 때문에 유용하지만 예외 정보의 형식을 사용자 정의하는 둘 이상의 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스가있는 경우주의해야합니다 . 이 경우, 포매터가 형식화를 완료 한 후 캐시 된 값을 지워야 이벤트를 처리 할 다음 포매터가 캐시 된 값을 사용하지 않고 새로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7b68d4f5f80393667485b695f7d4fbe0d86fa20c" translate="yes" xml:space="preserve">
          <source>The recorder object also has a &lt;code&gt;reset()&lt;/code&gt; method, which clears the warnings list.</source>
          <target state="translated">레코더 개체에는 &lt;code&gt;reset()&lt;/code&gt; 메서드도있어 경고 목록을 지 웁니다.</target>
        </trans-unit>
        <trans-unit id="b626a485d54404ebb0e667a8827f0bc2ce4565e1" translate="yes" xml:space="preserve">
          <source>The redundant types are deprecated as of Python 3.9 but no deprecation warnings will be issued by the interpreter. It is expected that type checkers will flag the deprecated types when the checked program targets Python 3.9 or newer.</source>
          <target state="translated">중복 유형은 Python 3.9에서 더 이상 사용되지 않지만 인터프리터에서 사용 중지 경고가 발생하지 않습니다. 검사 프로그램이 Python 3.9 이상을 대상으로 할 때 유형 검사기가 더 이상 사용되지 않는 유형에 플래그를 지정할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="23f5a856010edc6634a1b395d6da029a99f96511" translate="yes" xml:space="preserve">
          <source>The regex matching flags. This is a combination of the flags given to &lt;a href=&quot;#re.compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;, any &lt;code&gt;(?...)&lt;/code&gt; inline flags in the pattern, and implicit flags such as &lt;code&gt;UNICODE&lt;/code&gt; if the pattern is a Unicode string.</source>
          <target state="translated">정규식 일치 플래그. 이것은 주어진 플래그의 조합입니다 &lt;a href=&quot;#re.compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; , 어떤 &lt;code&gt;(?...)&lt;/code&gt; 과 같은 패턴의 인라인 플래그 및 암시 적 플래그 &lt;code&gt;UNICODE&lt;/code&gt; 패턴이 유니 코드 문자열 인 경우.</target>
        </trans-unit>
        <trans-unit id="4908905268dd161df8905009999a17db351541c3" translate="yes" xml:space="preserve">
          <source>The regular &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; was designed to be very good at mapping operations. Tracking insertion order was secondary.</source>
          <target state="translated">일반적인 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 은 매핑 작업에 매우 적합하도록 설계되었습니다. 게재 신청서 추적이 부차적이었습니다.</target>
        </trans-unit>
        <trans-unit id="7968a2059eb096a9ad928a6d8fa459e62e306418" translate="yes" xml:space="preserve">
          <source>The regular expression pattern.</source>
          <target state="translated">정규식 패턴.</target>
        </trans-unit>
        <trans-unit id="338a44466ba170ea38b197685c29de265d361a96" translate="yes" xml:space="preserve">
          <source>The relationships among these processing classes are summarized in the following diagram:</source>
          <target state="translated">이러한 처리 클래스 간의 관계는 다음 다이어그램에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="93eb7f8ce0f82ca28e08352f3f3171f042ffdf18" translate="yes" xml:space="preserve">
          <source>The relative likelihood is computed as the probability of a sample occurring in a narrow range divided by the width of the range (hence the word &amp;ldquo;density&amp;rdquo;). Since the likelihood is relative to other points, its value can be greater than &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">상대적 가능성은 좁은 범위에서 샘플이 발생할 수있는 확률을 범위의 너비 (따라서&amp;ldquo;밀도&amp;rdquo;)로 나눈 값으로 계산됩니다. 가능성은 다른 점과 관련이 있으므로 값은 &lt;code&gt;1.0&lt;/code&gt; 보다 클 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe576e550a29800997b9d6a2e646402dca141123" translate="yes" xml:space="preserve">
          <source>The remainder is computed as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object. (3)</source>
          <target state="translated">나머지는 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 로 계산됩니다 . (삼)</target>
        </trans-unit>
        <trans-unit id="0340c584ccb1afc4873c12a1e31a9be1bffa4f35" translate="yes" xml:space="preserve">
          <source>The remaining &lt;a href=&quot;#email.policy.Policy&quot;&gt;&lt;code&gt;Policy&lt;/code&gt;&lt;/a&gt; methods are called by the email package code, and are not intended to be called by an application using the email package. A custom policy must implement all of these methods.</source>
          <target state="translated">나머지 &lt;a href=&quot;#email.policy.Policy&quot;&gt; &lt;code&gt;Policy&lt;/code&gt; &lt;/a&gt; 방법은 전자 메일 패키지 코드로 호출되며 전자 메일 패키지를 사용하는 응용 프로그램에서는 호출되지 않습니다. 사용자 지정 정책은 이러한 모든 방법을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="73a6d6e6fac3d7be26a7b43db8daf15d992cd3a7" translate="yes" xml:space="preserve">
          <source>The remaining challenges revolve around finding a pending task and making changes to its priority or removing it entirely. Finding a task can be done with a dictionary pointing to an entry in the queue.</source>
          <target state="translated">나머지 과제는 보류중인 작업을 찾고 우선 순위를 변경하거나 완전히 제거하는 것과 관련이 있습니다. 대기열에서 항목을 가리키는 사전을 사용하여 작업을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bc691bd9a1784a04f10810950f779a9ee15eb0" translate="yes" xml:space="preserve">
          <source>The remaining functions are part of the legacy (&lt;code&gt;Compat32&lt;/code&gt;) email API. There is no need to directly use these with the new API, since the parsing and formatting they provide is done automatically by the header parsing machinery of the new API.</source>
          <target state="translated">나머지 기능은 레거시 ( &lt;code&gt;Compat32&lt;/code&gt; ) 이메일 API의 일부입니다 . 이들이 제공하는 파싱 및 포맷팅은 새로운 API의 헤더 파싱 메카니즘에 의해 자동으로 수행되므로, 새로운 API와 함께 직접 사용할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="e9e96d5ad53b78651123f0aa48586b15b8bc8356" translate="yes" xml:space="preserve">
          <source>The remaining methods are specific to audio mixing:</source>
          <target state="translated">나머지 방법은 오디오 믹싱에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3bfb848b5ec87a5a815658edfcfabd10bf0be1cc" translate="yes" xml:space="preserve">
          <source>The remaining methods will raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; if called after the &lt;a href=&quot;#chunk.Chunk.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method has been called. Before Python 3.3, they used to raise &lt;a href=&quot;exceptions#IOError&quot;&gt;&lt;code&gt;IOError&lt;/code&gt;&lt;/a&gt;, now an alias of &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#chunk.Chunk.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 된 후 호출되면 나머지 메소드는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다. Python 3.3 이전 에는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 의 별명 인 &lt;a href=&quot;exceptions#IOError&quot;&gt; &lt;code&gt;IOError&lt;/code&gt; 를 발생&lt;/a&gt;시켰습니다 .</target>
        </trans-unit>
        <trans-unit id="ab4081a709186f53a0d01adb9c1f82670e77f305" translate="yes" xml:space="preserve">
          <source>The remaining text in this section is the original documentation of the module.</source>
          <target state="translated">이 섹션의 나머지 텍스트는 모듈의 원본 문서입니다.</target>
        </trans-unit>
        <trans-unit id="df76983d86e7fd3680429e5d80b3f6559c176cdc" translate="yes" xml:space="preserve">
          <source>The representation of bytearray objects uses the bytes literal format (&lt;code&gt;bytearray(b'...')&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt;. You can always convert a bytearray object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">bytearray 객체의 표현은 바이트 리터럴 형식 ( &lt;code&gt;bytearray(b'...')&lt;/code&gt; )을 사용합니다. &lt;code&gt;bytearray([46, 46, 46])&lt;/code&gt; 보다 종종 유용하기 때문 입니다. &lt;code&gt;list(b)&lt;/code&gt; 사용하여 바이트 배열 객체를 항상 정수 목록으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1d120b288aa1f00756fb3a349cf99f1b0ed62ed4" translate="yes" xml:space="preserve">
          <source>The representation of bytes objects uses the literal format (&lt;code&gt;b'...'&lt;/code&gt;) since it is often more useful than e.g. &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt;. You can always convert a bytes object into a list of integers using &lt;code&gt;list(b)&lt;/code&gt;.</source>
          <target state="translated">bytes 객체의 표현은 리터럴 형식 ( &lt;code&gt;b'...'&lt;/code&gt; )을 사용하는데, 이는 종종 &lt;code&gt;bytes([46, 46, 46])&lt;/code&gt; 보다 유용하기 때문 입니다. &lt;code&gt;list(b)&lt;/code&gt; 사용하여 bytes 객체를 항상 정수 목록으로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="934e4823813e26310eba11e448f6edb5ad9e263d" translate="yes" xml:space="preserve">
          <source>The request is mapped to a local file by interpreting the request as a path relative to the current working directory.</source>
          <target state="translated">요청은 현재 작업 디렉토리에 상대적인 경로로 요청을 해석하여 로컬 파일에 맵핑됩니다.</target>
        </trans-unit>
        <trans-unit id="d1e30ca94027546a99c4c247aa7bc532aac9585a" translate="yes" xml:space="preserve">
          <source>The request will not work as expected if the data object is unable to deliver its content more than once (e.g. a file or an iterable that can produce the content only once) and the request is retried for HTTP redirects or authentication. The &lt;em&gt;data&lt;/em&gt; is sent to the HTTP server right away after the headers. There is no support for a 100-continue expectation in the library.</source>
          <target state="translated">데이터 오브젝트가 컨텐츠를 두 번 이상 (예 : 컨텐츠를 한 번만 생성 할 수있는 파일 또는 반복 가능) 컨텐츠를 전달할 수없고 요청이 HTTP 경로 재 지정 또는 인증을 위해 재 시도되는 경우 요청이 예상대로 작동하지 않습니다. &lt;em&gt;데이터는&lt;/em&gt; 바로 헤더 후 HTTP 서버로 전송됩니다. 라이브러리에서 100- 연속 예상을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d08fb6e54b0bef7db4806e25ba06216ddf869486" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a parser which was finished parsing input, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">요청 된 작업이 구문 분석 입력을 완료했지만 허용되지 않는 구문 분석기에서 수행되었습니다. 여기에는 추가 입력을 제공하거나 파서를 중지하려는 시도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6be492a00d95d8c38d0f08df00ba5cd76c54a3e2" translate="yes" xml:space="preserve">
          <source>The requested operation was made on a suspended parser, but isn&amp;rsquo;t allowed. This includes attempts to provide additional input or to stop the parser.</source>
          <target state="translated">요청한 작업이 일시 중지 된 파서에서 수행되었지만 허용되지 않습니다. 여기에는 추가 입력을 제공하거나 파서를 중지하려는 시도가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e7da8efaff05d5a67bdc583cf83ab65e3004c869" translate="yes" xml:space="preserve">
          <source>The requested read operation did not complete fully.</source>
          <target state="translated">요청한 읽기 작업이 완전히 완료되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f8cfa9ce8db124d500cff91c25e3e50bf494e54" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;name&lt;/em&gt; parameter is used for introspection and debug purposes.</source>
          <target state="translated">필수 &lt;em&gt;이름&lt;/em&gt; 매개 변수는 내부 검사 및 디버그 목적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c25d69b77c16629632ad85bd39c5b60853e6161" translate="yes" xml:space="preserve">
          <source>The required &lt;em&gt;value&lt;/em&gt; argument is the new value for the context variable.</source>
          <target state="translated">필수 &lt;em&gt;값&lt;/em&gt; 인수는 컨텍스트 변수의 새 값입니다.</target>
        </trans-unit>
        <trans-unit id="902699a10c395c34229cad66f2a25386f0e788eb" translate="yes" xml:space="preserve">
          <source>The reset_mock method resets all the call attributes on a mock object:</source>
          <target state="translated">reset_mock 메소드는 모의 객체의 모든 호출 속성을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="ddf13e446d1b8be7a43739f2d543a173cf27e006" translate="yes" xml:space="preserve">
          <source>The resolution of such persistent IDs is not defined by the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module; it will delegate this resolution to the user-defined methods on the pickler and unpickler, &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt;&lt;code&gt;persistent_id()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt;&lt;code&gt;persistent_load()&lt;/code&gt;&lt;/a&gt; respectively.</source>
          <target state="translated">이러한 영구 ID의 분석은 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈에 의해 정의되지 않습니다 . 그것은 피클 러와 unpickler에 사용자 정의 방식이 해상도를 위임 할 것이다 &lt;a href=&quot;#pickle.Pickler.persistent_id&quot;&gt; &lt;code&gt;persistent_id()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.Unpickler.persistent_load&quot;&gt; &lt;code&gt;persistent_load()&lt;/code&gt; &lt;/a&gt; 각각.</target>
        </trans-unit>
        <trans-unit id="dad2579aacf71b8f66ffcb466c20321d81397aa7" translate="yes" xml:space="preserve">
          <source>The resolution of the monotonic clock on Windows is usually around 15.6 msec. The best resolution is 0.5 msec. The resolution depends on the hardware (availability of &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET&lt;/a&gt;) and on the Windows configuration.</source>
          <target state="translated">Windows에서 단조로운 시계의 해상도는 일반적으로 약 15.6msec입니다. 최상의 해상도는 0.5msec입니다. 해결 방법은 하드웨어 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/High_Precision_Event_Timer&quot;&gt;HPET&lt;/a&gt; 사용 가능 여부 ) 및 Windows 구성에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="23afb147c8179b8f68c17fd58f357125e59e0db0" translate="yes" xml:space="preserve">
          <source>The response of the server if available, as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">사용 가능한 경우 서버의 응답으로 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="95b4a5945a9d59be88563c27320b9c7635065496" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 인수는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="052ba8628ec266d089850d398e2dffdd0e02362b" translate="yes" xml:space="preserve">
          <source>The rest of the arguments are passed directly to &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">나머지 인수는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 직접 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="9ca5b530f7beb3fc6b574e16895459606aeaf92d" translate="yes" xml:space="preserve">
          <source>The result can be limited to a certain &lt;em&gt;depth&lt;/em&gt; (ellipsis is used for deeper contents):</source>
          <target state="translated">결과는 특정 &lt;em&gt;깊이&lt;/em&gt; 로 제한 될 수 있습니다 (더 깊은 내용에는 줄임표가 사용됨).</target>
        </trans-unit>
        <trans-unit id="a9012bf262281e6649bca6a62eaca3e50309e056" translate="yes" xml:space="preserve">
          <source>The result has the following attributes:</source>
          <target state="translated">결과는 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d5ea300b3c43932c2e9cb889e33cb6a294bf5718" translate="yes" xml:space="preserve">
          <source>The result is a new handle to the specified key.</source>
          <target state="translated">결과는 지정된 키에 대한 새로운 핸들입니다.</target>
        </trans-unit>
        <trans-unit id="9024c97c37bab6f072465e9e7695a1952461ee28" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 2 items:</source>
          <target state="translated">결과는 2 개의 항목으로 구성된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="1a572ad972b418d4c59e22b81a05b05d111a4914" translate="yes" xml:space="preserve">
          <source>The result is a tuple of 3 items:</source>
          <target state="translated">결과는 3 개의 항목으로 구성된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="f4bcd3a97a994995588bc014bbbc763f7890e121" translate="yes" xml:space="preserve">
          <source>The result is an integer that holds the value of the handle before it is detached. If the handle is already detached or closed, this will return zero.</source>
          <target state="translated">결과는 핸들이 분리되기 전에 핸들 값을 보유하는 정수입니다. 핸들이 이미 분리 또는 닫혀 있으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bc91a99e93e2fcc5cbfe344c6e0c71fb2ef0bf7a" translate="yes" xml:space="preserve">
          <source>The result is an iterator yielding named tuples, exactly like &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt;. It does not yield an &lt;a href=&quot;token#token.ENCODING&quot;&gt;&lt;code&gt;ENCODING&lt;/code&gt;&lt;/a&gt; token.</source>
          <target state="translated">결과적으로 &lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 와 같은 이름의 튜플을 생성하는 반복자가 생성 됩니다. &lt;a href=&quot;token#token.ENCODING&quot;&gt; &lt;code&gt;ENCODING&lt;/code&gt; &lt;/a&gt; 토큰을 생성하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3227fd92d80664a7f623acd9fc4b4f80817cf727" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; along with &lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt;&lt;code&gt;stat.S_ISDIR()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 객체에 캐시되며 &lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 에 대한 별도의 캐시가 있습니다. &lt;a href=&quot;stat#stat.S_ISDIR&quot;&gt; &lt;code&gt;stat.S_ISDIR()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 과 함께 os.stat () 를 호출 하여 최신 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4473ea6bd1dfef0f8e5256127ece39f3a793c098" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object, with a separate cache for &lt;em&gt;follow_symlinks&lt;/em&gt;&lt;code&gt;True&lt;/code&gt; and &lt;code&gt;False&lt;/code&gt;. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 객체에 캐시되며 &lt;em&gt;follow_symlinks &lt;/em&gt; &lt;code&gt;True&lt;/code&gt; 및 &lt;code&gt;False&lt;/code&gt; 에 대한 별도의 캐시가 있습니다. 최신 정보를 가져 오려면 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="abbcee36b5dc7353a13842e21fc33ea3c7933bbe" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Caching, system calls made, and exceptions raised are as per &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt;&lt;code&gt;is_dir()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 캐싱, 시스템 호출 및 예외 발생은 &lt;a href=&quot;#os.DirEntry.is_dir&quot;&gt; &lt;code&gt;is_dir()&lt;/code&gt; &lt;/a&gt; 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3192c8c4ca27941d16ad2ca7a7e1edfbad87bea5" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Call &lt;a href=&quot;os.path#os.path.islink&quot;&gt;&lt;code&gt;os.path.islink()&lt;/code&gt;&lt;/a&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 최신 정보를 가져 오려면 &lt;a href=&quot;os.path#os.path.islink&quot;&gt; &lt;code&gt;os.path.islink()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="7ec4d3f1d1936a6194d9445a29e0390f42b8ffe0" translate="yes" xml:space="preserve">
          <source>The result is cached on the &lt;code&gt;os.DirEntry&lt;/code&gt; object. Use &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; to fetch up-to-date information.</source>
          <target state="translated">결과는 &lt;code&gt;os.DirEntry&lt;/code&gt; 오브젝트 에 캐시됩니다 . 사용 &lt;code&gt;os.stat(entry.path, follow_symlinks=False).st_ino&lt;/code&gt; 최신 정보를 가져 오기 위해.</target>
        </trans-unit>
        <trans-unit id="5690da7531945b23a6747716ed812a15a6963db0" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: &lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt;&lt;code&gt;Statistic.size&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt;&lt;code&gt;Statistic.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">: 결과는 가장 큰에서에 의해 최소로 정렬됩니다 &lt;a href=&quot;#tracemalloc.Statistic.size&quot;&gt; &lt;code&gt;Statistic.size&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt; 다음으로 &lt;a href=&quot;#tracemalloc.Statistic.traceback&quot;&gt; &lt;code&gt;Statistic.traceback&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e30839178f92f01b4544ae6c03a099b48de5230b" translate="yes" xml:space="preserve">
          <source>The result is sorted from the biggest to the smallest by: absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt;&lt;code&gt;StatisticDiff.size_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt;&lt;code&gt;StatisticDiff.size&lt;/code&gt;&lt;/a&gt;, absolute value of &lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt;&lt;code&gt;StatisticDiff.count_diff&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt;&lt;code&gt;Statistic.count&lt;/code&gt;&lt;/a&gt; and then by &lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt;&lt;code&gt;StatisticDiff.traceback&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 절대 값 : 결과는 최대에서 최소로하여 정렬 &lt;a href=&quot;#tracemalloc.StatisticDiff.size_diff&quot;&gt; &lt;code&gt;StatisticDiff.size_diff&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.StatisticDiff.size&quot;&gt; &lt;code&gt;StatisticDiff.size&lt;/code&gt; &lt;/a&gt; 의 절대치 &lt;a href=&quot;#tracemalloc.StatisticDiff.count_diff&quot;&gt; &lt;code&gt;StatisticDiff.count_diff&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tracemalloc.Statistic.count&quot;&gt; &lt;code&gt;Statistic.count&lt;/code&gt; &lt;/a&gt; 다음으로 &lt;a href=&quot;#tracemalloc.StatisticDiff.traceback&quot;&gt; &lt;code&gt;StatisticDiff.traceback&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50b5cd74dc096919d1c4da6da20c54e0531391ea" translate="yes" xml:space="preserve">
          <source>The result looks like &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;'Sun, 06 Nov 1994 08:49:37 GMT'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad2b0ea3374869382c5626a60af95e870167d18d" translate="yes" xml:space="preserve">
          <source>The result might look something like:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d4f8c61300cb280ac5d234b75011a45b9bc1479" translate="yes" xml:space="preserve">
          <source>The result objects from the &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt;&lt;code&gt;urlsplit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt;&lt;code&gt;urldefrag()&lt;/code&gt;&lt;/a&gt; functions are subclasses of the &lt;a href=&quot;stdtypes#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; type. These subclasses add the attributes listed in the documentation for those functions, the encoding and decoding support described in the previous section, as well as an additional method:</source>
          <target state="translated">&lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#urllib.parse.urlsplit&quot;&gt; &lt;code&gt;urlsplit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.parse.urldefrag&quot;&gt; &lt;code&gt;urldefrag()&lt;/code&gt; &lt;/a&gt; 함수 의 결과 객체 는 &lt;a href=&quot;stdtypes#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 유형의 하위 클래스입니다 . 이 서브 클래스는 해당 함수에 대한 문서에 나열된 속성, 이전 섹션에서 설명한 인코딩 및 디코딩 지원 및 추가 방법을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9496af6babd167973be214aba8ba07e03e05847c" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;mock()&lt;/code&gt; is an async function which will have the outcome of &lt;code&gt;side_effect&lt;/code&gt; or &lt;code&gt;return_value&lt;/code&gt; after it has been awaited:</source>
          <target state="translated">&lt;code&gt;mock()&lt;/code&gt; 의 결과 는 비동기 함수이며 &lt;code&gt;side_effect&lt;/code&gt; 또는 &lt;code&gt;return_value&lt;/code&gt; 가 기다린 후에 결과를 얻게됩니다 .</target>
        </trans-unit>
        <trans-unit id="3bc1a9c58cb8683698d580da1969870f58ded608" translate="yes" xml:space="preserve">
          <source>The result of the manipulations is treated as a filename, and returned as the first component of the tuple, with &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; called on it to yield the second component. (Note: this is the reverse of the order of arguments in instance initialization!)</source>
          <target state="translated">조작 결과는 파일 이름으로 처리되고 튜플의 첫 번째 구성 요소로 반환되며 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 호출되어 두 번째 구성 요소가 생성됩니다. (참고 : 이것은 인스턴스 초기화의 인수 순서와 반대입니다!)</target>
        </trans-unit>
        <trans-unit id="c4e4c6d23f69a76d21bae775427f415590d0980e" translate="yes" xml:space="preserve">
          <source>The result of this method remains unchanged if passed back through the original parsing function:</source>
          <target state="translated">이 방법의 결과는 원래 구문 분석 기능을 통해 다시 전달 된 경우 변경되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b224f9d4a8e2657de972e24ed3a8dcad279caaed" translate="yes" xml:space="preserve">
          <source>The result of this search is cached, see the description of &lt;a href=&quot;#tempfile.tempdir&quot;&gt;&lt;code&gt;tempdir&lt;/code&gt;&lt;/a&gt; below.</source>
          <target state="translated">이 검색 결과가 캐시 됩니다. 아래 &lt;a href=&quot;#tempfile.tempdir&quot;&gt; &lt;code&gt;tempdir&lt;/code&gt; 에&lt;/a&gt; 대한 설명을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="01be55a0c09b1d115faa58cff213ed7e949d0a99" translate="yes" xml:space="preserve">
          <source>The result:</source>
          <target state="translated">결과:</target>
        </trans-unit>
        <trans-unit id="8adfe478f190ec97428a206efe4a03294cd0ba54" translate="yes" xml:space="preserve">
          <source>The resulting archive contains:</source>
          <target state="translated">결과 아카이브에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="90e2c6b6dcb04800642e191cd676cfaeabfba943" translate="yes" xml:space="preserve">
          <source>The resulting class has an extra attribute &lt;code&gt;__annotations__&lt;/code&gt; giving a dict that maps the field names to the field types. (The field names are in the &lt;code&gt;_fields&lt;/code&gt; attribute and the default values are in the &lt;code&gt;_field_defaults&lt;/code&gt; attribute both of which are part of the namedtuple API.)</source>
          <target state="translated">결과 클래스에는 필드 이름을 필드 유형에 매핑하는 dict를 제공 하는 추가 속성 &lt;code&gt;__annotations__&lt;/code&gt; 이 있습니다. (필드 이름은 &lt;code&gt;_fields&lt;/code&gt; 속성에 있고 기본값은 &lt;code&gt;_field_defaults&lt;/code&gt; 속성에 있으며 둘 다 명명 된 튜플 API의 일부입니다.)</target>
        </trans-unit>
        <trans-unit id="ac591da9469504c2f08a211e0607aa5095412244" translate="yes" xml:space="preserve">
          <source>The resulting file has one additional method, &lt;code&gt;rollover()&lt;/code&gt;, which causes the file to roll over to an on-disk file regardless of its size.</source>
          <target state="translated">결과 파일에는 추가 방법 인 &lt;code&gt;rollover()&lt;/code&gt; 가있어 파일 크기에 관계없이 파일을 디스크상의 파일로 롤오버합니다.</target>
        </trans-unit>
        <trans-unit id="7a519c498f72663eddb55617af16d07f81874708" translate="yes" xml:space="preserve">
          <source>The resulting launcher uses the &amp;ldquo;Limited ABI&amp;rdquo;, so it will run unchanged with any version of Python 3.x. All it needs is for Python (&lt;code&gt;python3.dll&lt;/code&gt;) to be on the user&amp;rsquo;s &lt;code&gt;PATH&lt;/code&gt;.</source>
          <target state="translated">결과 런처는&amp;ldquo;제한된 ABI&amp;rdquo;를 사용하므로 모든 버전의 Python 3.x에서 변경없이 실행됩니다. Python ( &lt;code&gt;python3.dll&lt;/code&gt; )이 사용자의 &lt;code&gt;PATH&lt;/code&gt; 에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="041df9dbd79b18f129d74bcb4f756b61fc62aae3" translate="yes" xml:space="preserve">
          <source>The resulting list is sorted alphabetically. For example:</source>
          <target state="translated">결과 목록은 알파벳순으로 정렬됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11ae1369bb9e6629cc72ed8a767763bea61545dd" translate="yes" xml:space="preserve">
          <source>The resulting object can be used as a context manager (see &lt;a href=&quot;#tempfile-examples&quot;&gt;Examples&lt;/a&gt;). On completion of the context or destruction of the file object the temporary file will be removed from the filesystem.</source>
          <target state="translated">결과 객체는 컨텍스트 관리자로 사용할 수 있습니다 ( &lt;a href=&quot;#tempfile-examples&quot;&gt;예&lt;/a&gt; 참조 ). 컨텍스트가 완료되거나 파일 객체가 손상되면 임시 파일이 파일 시스템에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b846db5f32c3790b53bc4bb912c408d3783cc876" translate="yes" xml:space="preserve">
          <source>The resulting profiler will then call &lt;code&gt;your_time_func&lt;/code&gt;. Depending on whether you are using &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;profile.Profile&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;cProfile.Profile&lt;/code&gt;, &lt;code&gt;your_time_func&lt;/code&gt;&amp;rsquo;s return value will be interpreted differently:</source>
          <target state="translated">결과 프로파일 러는 &lt;code&gt;your_time_func&lt;/code&gt; 를 호출 합니다 . 사용 여부에 따라 &lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;profile.Profile&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;cProfile.Profile&lt;/code&gt; 을 , &lt;code&gt;your_time_func&lt;/code&gt; 의 반환 값은 다르게 해석됩니다 :</target>
        </trans-unit>
        <trans-unit id="9db83e41267f4a8fdf365bc69918d1db78163746" translate="yes" xml:space="preserve">
          <source>The resulting string is a series of &lt;code&gt;key=value&lt;/code&gt; pairs separated by &lt;code&gt;'&amp;amp;'&lt;/code&gt; characters, where both &lt;em&gt;key&lt;/em&gt; and &lt;em&gt;value&lt;/em&gt; are quoted using the &lt;em&gt;quote_via&lt;/em&gt; function. By default, &lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt;&lt;code&gt;quote_plus()&lt;/code&gt;&lt;/a&gt; is used to quote the values, which means spaces are quoted as a &lt;code&gt;'+'&lt;/code&gt; character and &amp;lsquo;/&amp;rsquo; characters are encoded as &lt;code&gt;%2F&lt;/code&gt;, which follows the standard for GET requests (&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;). An alternate function that can be passed as &lt;em&gt;quote_via&lt;/em&gt; is &lt;a href=&quot;#urllib.parse.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;, which will encode spaces as &lt;code&gt;%20&lt;/code&gt; and not encode &amp;lsquo;/&amp;rsquo; characters. For maximum control of what is quoted, use &lt;code&gt;quote&lt;/code&gt; and specify a value for &lt;em&gt;safe&lt;/em&gt;.</source>
          <target state="translated">결과 문자열은 &lt;code&gt;'&amp;amp;'&lt;/code&gt; 문자로 구분 된 일련의 &lt;code&gt;key=value&lt;/code&gt; 쌍 이며, 여기서 &lt;em&gt;key&lt;/em&gt; 와 &lt;em&gt;value&lt;/em&gt; 는 &lt;em&gt;quote_via&lt;/em&gt; 함수를 사용하여 인용 됩니다. 기본적으로 &lt;a href=&quot;#urllib.parse.quote_plus&quot;&gt; &lt;code&gt;quote_plus()&lt;/code&gt; &lt;/a&gt; 는 값을 인용하는 데 사용됩니다. 공백은 &lt;code&gt;'+'&lt;/code&gt; 문자 로 인용 되고 '/'문자는 &lt;code&gt;%2F&lt;/code&gt; 로 인코딩되어 GET 요청에 대한 표준을 따릅니다 ( &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; ). &lt;em&gt;quote_via&lt;/em&gt; 로 전달할 수있는 대체 함수 는 &lt;a href=&quot;#urllib.parse.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 이며 공백을 &lt;code&gt;%20&lt;/code&gt; 으로 인코딩합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;'/'문자를 인코딩하지 마십시오. 인용되는 내용을 최대한 제어하려면 &lt;code&gt;quote&lt;/code&gt; 를 사용하고 &lt;em&gt;safe&lt;/em&gt; 값을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="134dbdf4e5b3e8f4c11ac5b7031c7464a782c4b0" translate="yes" xml:space="preserve">
          <source>The results printed are</source>
          <target state="translated">인쇄 된 결과는</target>
        </trans-unit>
        <trans-unit id="40b9c6b5f8f1f52e60312075db0d81f7e179965d" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;SSLContext.wrap_bio()&lt;/code&gt; &lt;/a&gt; 의 반환 유형은 기본적으로 &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 서브 클래스를 리턴하기 위해 클래스 인스턴스에서 속성을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89dd3bf6bf7ac8497c6fbc6d05c26cdd36021e83" translate="yes" xml:space="preserve">
          <source>The return type of &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;, defaults to &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;. The attribute can be overridden on instance of class in order to return a custom subclass of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 의 반환 유형은 기본적으로 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 의 사용자 정의 서브 클래스를 리턴하기 위해 클래스 인스턴스에서 속성을 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f9ec2a98ecd14904d5d3e12031555d453b9272e4" translate="yes" xml:space="preserve">
          <source>The return value and side effect of child mocks can be set in the same way, using dotted notation. As you can&amp;rsquo;t use dotted names directly in a call you have to create a dictionary and unpack it using &lt;code&gt;**&lt;/code&gt;:</source>
          <target state="translated">자식 모의 반환 값과 부작용은 점 표기법을 사용하여 같은 방식으로 설정할 수 있습니다. 호출에서 직접 점으로 구분 된 이름을 사용할 수 없으므로 &lt;code&gt;**&lt;/code&gt; 를 사용하여 사전을 작성하고 압축을 풀어야합니다 .</target>
        </trans-unit>
        <trans-unit id="cfba5477b25ec732aaec2f8665d9842e6b57be0f" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;'fork'&lt;/code&gt;, &lt;code&gt;'spawn'&lt;/code&gt;, &lt;code&gt;'forkserver'&lt;/code&gt; or &lt;code&gt;None&lt;/code&gt;. &lt;code&gt;'fork'&lt;/code&gt; is the default on Unix, while &lt;code&gt;'spawn'&lt;/code&gt; is the default on Windows.</source>
          <target state="translated">반환 값은 &lt;code&gt;'fork'&lt;/code&gt; , &lt;code&gt;'spawn'&lt;/code&gt; , &lt;code&gt;'forkserver'&lt;/code&gt; 또는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;'fork'&lt;/code&gt; 는 Unix의 기본값이고 &lt;code&gt;'spawn'&lt;/code&gt; 은 Windows의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="223d2d76ad021d8b529310c6405479566a8c8808" translate="yes" xml:space="preserve">
          <source>The return value can be used to decide whether to use &lt;code&gt;sys.ps1&lt;/code&gt; or &lt;code&gt;sys.ps2&lt;/code&gt; to prompt the next line.</source>
          <target state="translated">반환 값은 &lt;code&gt;sys.ps1&lt;/code&gt; 또는 &lt;code&gt;sys.ps2&lt;/code&gt; 중 어느 것을 사용 하여 다음 행을 프롬프트 할지를 결정하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82c5f5dea7de57114b406e5a2d10e9c9e968c10c" translate="yes" xml:space="preserve">
          <source>The return value consists of two elements: the first is a list of &lt;code&gt;(option,
value)&lt;/code&gt; pairs; the second is the list of program arguments left after the option list was stripped (this is a trailing slice of &lt;em&gt;args&lt;/em&gt;). Each option-and-value pair returned has the option as its first element, prefixed with a hyphen for short options (e.g., &lt;code&gt;'-x'&lt;/code&gt;) or two hyphens for long options (e.g., &lt;code&gt;'--long-option'&lt;/code&gt;), and the option argument as its second element, or an empty string if the option has no argument. The options occur in the list in the same order in which they were found, thus allowing multiple occurrences. Long and short options may be mixed.</source>
          <target state="translated">반환 값은 두 가지 요소로 구성됩니다. 첫 번째는 &lt;code&gt;(option, value)&lt;/code&gt; 쌍 의 목록입니다 . 두 번째는 옵션 목록이 제거 된 후 남은 프로그램 인수 목록입니다 (이것은 후행 &lt;em&gt;args&lt;/em&gt; 조각입니다 ). 반환 된 각 옵션과 값 쌍에는 첫 번째 요소로 옵션이 있으며 짧은 옵션 (예 : &lt;code&gt;'-x'&lt;/code&gt; ) 에는 하이픈이 붙어 있고 긴 옵션 (예 : &lt;code&gt;'--long-option'&lt;/code&gt; )에는 두 개의 하이픈이 붙어 있습니다. 옵션 인자를 두 번째 요소로, 옵션에 인자가없는 경우 빈 문자열 옵션은 찾은 순서대로 목록에서 발생하므로 여러 번 발생할 수 있습니다. 길고 짧은 옵션이 혼합되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b318dc5ec8c485015ebb1f6e03ac8abd47ac343" translate="yes" xml:space="preserve">
          <source>The return value from &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;, representing a process that has finished.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 의 반환 값으로 , 완료된 프로세스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="195dd48fbab413248bb85b38523fd13efbbb7f22" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not (for example if the &lt;em&gt;timeout&lt;/em&gt; expired).</source>
          <target state="translated">잠금이 성공적으로 획득되면 리턴 값은 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False입니다 (예 : &lt;em&gt;시간 종료가&lt;/em&gt; 만료 된 경우).</target>
        </trans-unit>
        <trans-unit id="eda0a021ff1189c021e62f957666234bdf263951" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; if the lock is acquired successfully, &lt;code&gt;False&lt;/code&gt; if not.</source>
          <target state="translated">잠금이 성공적으로 획득되면 리턴 값은 &lt;code&gt;True&lt;/code&gt; 이고, &lt;code&gt;False&lt;/code&gt; 않으면 False 입니다.</target>
        </trans-unit>
        <trans-unit id="e8808521af7a00af7e8d52a0e5473a4b0b4e5fac" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;True&lt;/code&gt; unless a given &lt;em&gt;timeout&lt;/em&gt; expired, in which case it is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;em&gt;시간 초과가&lt;/em&gt; 만료 되지 않으면 반환 값은 &lt;code&gt;True&lt;/code&gt; 이며,이 경우 &lt;code&gt;False&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e4ae8192eff447288a99dac0e9794231ef6500ec" translate="yes" xml:space="preserve">
          <source>The return value is a 3-tuple: &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt;</source>
          <target state="translated">리턴 값은 3 개의 튜플입니다 : &lt;code&gt;metaclass, namespace, kwds&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b945fb04db6f2dc42f9466e62c23e6c77c03488" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(data, ancdata, msg_flags,
address)&lt;/code&gt;. The &lt;em&gt;data&lt;/em&gt; item is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the non-ancillary data received. The &lt;em&gt;ancdata&lt;/em&gt; item is a list of zero or more tuples &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; representing the ancillary data (control messages) received: &lt;em&gt;cmsg_level&lt;/em&gt; and &lt;em&gt;cmsg_type&lt;/em&gt; are integers specifying the protocol level and protocol-specific type respectively, and &lt;em&gt;cmsg_data&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object holding the associated data. The &lt;em&gt;msg_flags&lt;/em&gt; item is the bitwise OR of various flags indicating conditions on the received message; see your system documentation for details. If the receiving socket is unconnected, &lt;em&gt;address&lt;/em&gt; is the address of the sending socket, if available; otherwise, its value is unspecified.</source>
          <target state="translated">리턴 값은 4 개의 튜플입니다 : &lt;code&gt;(data, ancdata, msg_flags, address)&lt;/code&gt; . &lt;em&gt;데이터&lt;/em&gt; 항목은 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 수신되지 않은 보조 데이터를 보유하는 개체. &lt;em&gt;ancdata&lt;/em&gt; 항목은 0 개 이상의 튜플들의 목록이다 &lt;code&gt;(cmsg_level, cmsg_type, cmsg_data)&lt;/code&gt; 보조 데이터 (제어 메시지) 수신 나타내는 : &lt;em&gt;cmsg_level&lt;/em&gt; 및 &lt;em&gt;cmsg_type는&lt;/em&gt; 각각 프로토콜 레벨 및 특정 프로토콜 타입을 지정하는 정수이고, 그리고 &lt;em&gt;cmsg_data는&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 관련 데이터를 보유합니다. &lt;em&gt;msg_flags&lt;/em&gt;item은 수신 된 메시지의 조건을 나타내는 다양한 플래그의 비트 단위 OR이며; 자세한 내용은 시스템 설명서를 참조하십시오. 수신 소켓이 연결되지 않은 경우 &lt;em&gt;address&lt;/em&gt; 는 사용 가능한 경우 송신 소켓의 주소입니다. 그렇지 않으면 해당 값이 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ec52b14196aa8b67fb13e7dd77583943a73c711f" translate="yes" xml:space="preserve">
          <source>The return value is a 4-tuple: &lt;code&gt;(nbytes, ancdata, msg_flags,
address)&lt;/code&gt;, where &lt;em&gt;nbytes&lt;/em&gt; is the total number of bytes of non-ancillary data written into the buffers, and &lt;em&gt;ancdata&lt;/em&gt;, &lt;em&gt;msg_flags&lt;/em&gt; and &lt;em&gt;address&lt;/em&gt; are the same as for &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">리턴 값은 4 개의 튜플입니다 : &lt;code&gt;(nbytes, ancdata, msg_flags, address)&lt;/code&gt; 여기서 &lt;em&gt;nbytes&lt;/em&gt; 는 버퍼에 기록 된 비 보조 데이터의 총 바이트 수이며, &lt;em&gt;ancdata&lt;/em&gt; , &lt;em&gt;msg_flags&lt;/em&gt; 및 &lt;em&gt;address&lt;/em&gt; 는 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a3679d1ebda849b521be84cc43353121c8bf475" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, its items can be accessed by index or as named attributes:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 tuple&lt;/a&gt; 이며, 해당 항목은 색인 또는 명명 된 속성으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a21f880bf0c221fb7bd28fe3925cdefb842fe84c" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, which means that its items can be accessed by index or as named attributes, which are:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 tuple&lt;/a&gt; 이며, 인덱스 또는 명명 된 속성으로 해당 항목에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dcc2832db4e1520ff1937a113e6ceacec019f27" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, its items can be accessed by index or as named attributes:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;명명 된 tuple&lt;/a&gt; 이며 항목은 인덱스 또는 명명 된 속성으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9a675db84959f2871c29882a80f8a41acc95b6f" translate="yes" xml:space="preserve">
          <source>The return value is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;, which means that its items can be accessed by index or as named attributes, which are:</source>
          <target state="translated">반환 값은 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 입니다. 즉, 인덱스 또는 명명 된 속성으로 항목에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f79bebb781377c88d2426bd2e892f766e40af986" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline and some containing internal newlines. &lt;a href=&quot;#traceback.print_exception&quot;&gt;&lt;code&gt;print_exception()&lt;/code&gt;&lt;/a&gt; is a wrapper around this method which just prints the lines to a file.</source>
          <target state="translated">반환 값은 각각 줄 바꿈으로 끝나고 일부는 내부 줄 바꿈으로 끝나는 문자열 생성기입니다. &lt;a href=&quot;#traceback.print_exception&quot;&gt; &lt;code&gt;print_exception()&lt;/code&gt; &lt;/a&gt; 은 파일에 행을 인쇄하는이 메소드의 랩퍼입니다.</target>
        </trans-unit>
        <trans-unit id="a39f9ba7b42bdef3242d2a6379c62a27fc8940a4" translate="yes" xml:space="preserve">
          <source>The return value is a generator of strings, each ending in a newline.</source>
          <target state="translated">리턴 값은 각각 줄 바꾸기로 끝나는 문자열 생성기입니다.</target>
        </trans-unit>
        <trans-unit id="2aa307fb21c6adc415c25262d44c8b663f654493" translate="yes" xml:space="preserve">
          <source>The return value is a string suitable for passing as the &lt;em&gt;salt&lt;/em&gt; argument to &lt;a href=&quot;#module-crypt&quot;&gt;&lt;code&gt;crypt()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 값은 &lt;em&gt;salt&lt;/em&gt; 인수로 &lt;a href=&quot;#module-crypt&quot;&gt; &lt;code&gt;crypt()&lt;/code&gt; &lt;/a&gt; 에 전달하기에 적합한 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="fb4d092528f9e91105a3ac157c24fdb4bd62ec35" translate="yes" xml:space="preserve">
          <source>The return value is a triple of lists of objects that are ready: subsets of the first three arguments. When the time-out is reached without a file descriptor becoming ready, three empty lists are returned.</source>
          <target state="translated">리턴 값은 준비된 오브젝트 목록의 세 가지 즉, 처음 세 인수의 서브 세트입니다. 파일 디스크립터가 준비되지 않고 시간 종료에 도달하면 세 개의 빈 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b21ee42cf5b7e0115206de0a971aa7059c5ad292" translate="yes" xml:space="preserve">
          <source>The return value is a tuple &lt;code&gt;(type, encoding)&lt;/code&gt; where &lt;em&gt;type&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt; if the type can&amp;rsquo;t be guessed (missing or unknown suffix) or a string of the form &lt;code&gt;'type/subtype'&lt;/code&gt;, usable for a MIME &lt;em&gt;content-type&lt;/em&gt; header.</source>
          <target state="translated">리턴 값은 튜플 &lt;code&gt;(type, encoding)&lt;/code&gt; 이며 , 유형을 추측 할 수 없거나 (접미사를 알 수 없거나 알 수없는) MIME &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더에 사용할 수있는 &lt;code&gt;'type/subtype'&lt;/code&gt; 형식 의 문자열 인 경우 &lt;em&gt;유형&lt;/em&gt; 은 &lt;code&gt;None&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f4a573600a626a8f185b96ba9102f89d318696f0" translate="yes" xml:space="preserve">
          <source>The return value is an integer in the range 0 to &lt;em&gt;parties&lt;/em&gt; &amp;ndash; 1, different for each thread. This can be used to select a thread to do some special housekeeping, e.g.:</source>
          <target state="translated">리턴 값은 각 스레드마다 다른 0- &lt;em&gt;당사자&lt;/em&gt; &amp;ndash; 1 범위의 정수입니다 . 이것은 특별한 하우스 키핑을위한 스레드를 선택하는데 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="68775830b95659615877cbf5628aaf0c84b66aa7" translate="yes" xml:space="preserve">
          <source>The return value is an object representing the data contained in the &lt;code&gt;siginfo_t&lt;/code&gt; structure, namely: &lt;code&gt;si_signo&lt;/code&gt;, &lt;code&gt;si_code&lt;/code&gt;, &lt;code&gt;si_errno&lt;/code&gt;, &lt;code&gt;si_pid&lt;/code&gt;, &lt;code&gt;si_uid&lt;/code&gt;, &lt;code&gt;si_status&lt;/code&gt;, &lt;code&gt;si_band&lt;/code&gt;.</source>
          <target state="translated">리턴 값은 &lt;code&gt;siginfo_t&lt;/code&gt; 구조에 포함 된 데이터 , 즉 &lt;code&gt;si_signo&lt;/code&gt; , &lt;code&gt;si_code&lt;/code&gt; , &lt;code&gt;si_errno&lt;/code&gt; , &lt;code&gt;si_pid&lt;/code&gt; , &lt;code&gt;si_uid&lt;/code&gt; , &lt;code&gt;si_status&lt;/code&gt; , &lt;code&gt;si_band&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1dd4f172a531526aa876355a2856ad8c9907382d" translate="yes" xml:space="preserve">
          <source>The return value is the amount of bytes copied. This could be less than the amount requested.</source>
          <target state="translated">리턴 값은 복사 된 바이트의 양입니다. 요청한 금액보다 적을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="234b77eb5ef9ce8e2fcd0cab178d38c7fe6e2fca" translate="yes" xml:space="preserve">
          <source>The return value is the handle of the opened key. If the function fails, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">리턴 값은 열린 키의 핸들입니다. 함수가 실패하면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dc2557edef7b13a49741617f01fcdba9c83af0ab" translate="yes" xml:space="preserve">
          <source>The return value is the number of bytes written, which is always equal to the length of &lt;em&gt;buf&lt;/em&gt;.</source>
          <target state="translated">리턴 값은 쓴 바이트 수이며, 항상 &lt;em&gt;buf&lt;/em&gt; 길이와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="62cbe2d5893b50a026494fd6fee07e88125f71a2" translate="yes" xml:space="preserve">
          <source>The return value is the result of the evaluated expression. Syntax errors are reported as exceptions. Example:</source>
          <target state="translated">리턴 값은 평가 된 표현식의 결과입니다. 구문 오류는 예외로보고됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="9b569673d77a40a394325206915c8d678591e80f" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;MagicMock.__iter__()&lt;/code&gt; can be any iterable object and isn&amp;rsquo;t required to be an iterator:</source>
          <target state="translated">&lt;code&gt;MagicMock.__iter__()&lt;/code&gt; 의 반환 값은 반복 가능한 객체 일 수 있으며 반복자 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="6d324367f598aa028770dca0838f66177648fed1" translate="yes" xml:space="preserve">
          <source>The return value.</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="c335b6a081673631849b8c4210800ac50f8d01b4" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; has an additional property named &lt;code&gt;exact_type&lt;/code&gt; that contains the exact operator type for &lt;a href=&quot;token#token.OP&quot;&gt;&lt;code&gt;OP&lt;/code&gt;&lt;/a&gt; tokens. For all other token types &lt;code&gt;exact_type&lt;/code&gt; equals the named tuple &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">반환 된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 에는 &lt;a href=&quot;token#token.OP&quot;&gt; &lt;code&gt;OP&lt;/code&gt; &lt;/a&gt; 토큰에 대한 정확한 연산자 유형을 포함하는 &lt;code&gt;exact_type&lt;/code&gt; 이라는 추가 속성 이 있습니다 . 다른 모든 토큰 유형의 경우 &lt;code&gt;exact_type&lt;/code&gt; 은 명명 된 튜플 &lt;code&gt;type&lt;/code&gt; 필드 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="495f48621e32e7509fedd99ab5f78e8a65d4cf9e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; has an additional property named &lt;code&gt;exact_type&lt;/code&gt; that contains the exact operator type for &lt;a href=&quot;token#token.OP&quot;&gt;&lt;code&gt;OP&lt;/code&gt;&lt;/a&gt; tokens. For all other token types &lt;code&gt;exact_type&lt;/code&gt; equals the named tuple &lt;code&gt;type&lt;/code&gt; field.</source>
          <target state="translated">반환 된 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 에는 &lt;a href=&quot;token#token.OP&quot;&gt; &lt;code&gt;OP&lt;/code&gt; &lt;/a&gt; 토큰에 대한 정확한 연산자 유형을 포함하는 &lt;code&gt;exact_type&lt;/code&gt; 이라는 추가 속성 이 있습니다 . 다른 모든 토큰 유형의 경우 &lt;code&gt;exact_type&lt;/code&gt; 은 명명 된 튜플 &lt;code&gt;type&lt;/code&gt; 필드 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="218f49d63286506033a67a8dba86f5940020dd19" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs each doctest in the module. If any of the doctests fail, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">반환 된 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 는 unittest 프레임 워크에 의해 실행되며 모듈에서 각 doctest를 실행합니다. doctest 중 하나라도 실패하면, 합성 된 단위 테스트가 실패하고, 테스트를 포함하는 파일 이름과 (때로는 대략적인) 줄 번호를 나타내는 &lt;code&gt;failureException&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="618fad8d525738d877dbb6063471d43125b8556e" translate="yes" xml:space="preserve">
          <source>The returned &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; is to be run by the unittest framework and runs the interactive examples in each file. If an example in any file fails, then the synthesized unit test fails, and a &lt;code&gt;failureException&lt;/code&gt; exception is raised showing the name of the file containing the test and a (sometimes approximate) line number.</source>
          <target state="translated">리턴 된 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 는 unittest 프레임 워크에 의해 실행되며 각 파일에서 대화식 예제를 실행합니다. 파일의 예제가 실패하면 합성 단위 테스트가 실패 하고 테스트를 포함하는 파일 이름과 (때로는 대략적인) 행 번호를 표시 하는 &lt;code&gt;failureException&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8b0b6693ed01480a4045d1615145e7f1cf427145" translate="yes" xml:space="preserve">
          <source>The returned &lt;em&gt;reader&lt;/em&gt; and &lt;em&gt;writer&lt;/em&gt; objects are instances of &lt;a href=&quot;#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">반환 된 &lt;em&gt;판독기&lt;/em&gt; 및 &lt;em&gt;기록기&lt;/em&gt; 개체는 &lt;a href=&quot;#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="1f96113d2cc534f7b7ef202bb144452bc5b31520" translate="yes" xml:space="preserve">
          <source>The returned env-builder is an object which has a method, &lt;code&gt;create&lt;/code&gt;:</source>
          <target state="translated">반환 된 env-builder는 &lt;code&gt;create&lt;/code&gt; 메소드를 가진 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="9970c84bf057aeac8a4c0b64f98b2bef0c7395a9" translate="yes" xml:space="preserve">
          <source>The returned finder is cached in &lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt;&lt;code&gt;sys.path_importer_cache&lt;/code&gt;&lt;/a&gt; if it was newly created by a path hook.</source>
          <target state="translated">리턴 된 파인더는 경로 후크에 의해 새로 작성된 경우 &lt;a href=&quot;sys#sys.path_importer_cache&quot;&gt; &lt;code&gt;sys.path_importer_cache&lt;/code&gt; 에&lt;/a&gt; 캐시됩니다 .</target>
        </trans-unit>
        <trans-unit id="7674772aaa7c3d69c9b57697d013a9667cfcd482" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the Python calling convention. The function will &lt;em&gt;not&lt;/em&gt; release the GIL during the call.</source>
          <target state="translated">반환 된 함수 프로토 타입은 Python 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 호출 중에 GIL을 해제 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="73c626017b30388a1c8db06167f7d17be6ca7ee7" translate="yes" xml:space="preserve">
          <source>The returned function prototype creates functions that use the standard C calling convention. The function will release the GIL during the call. If &lt;em&gt;use_errno&lt;/em&gt; is set to true, the ctypes private copy of the system &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; variable is exchanged with the real &lt;a href=&quot;errno#module-errno&quot;&gt;&lt;code&gt;errno&lt;/code&gt;&lt;/a&gt; value before and after the call; &lt;em&gt;use_last_error&lt;/em&gt; does the same for the Windows error code.</source>
          <target state="translated">반환 된 함수 프로토 타입은 표준 C 호출 규칙을 사용하는 함수를 만듭니다. 이 기능은 호출 중에 GIL을 해제합니다. 경우 &lt;em&gt;use_errno가&lt;/em&gt; true로 설정되어 시스템의 개인 복사하는 ctypes &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 변수가 실제와 교환 &lt;a href=&quot;errno#module-errno&quot;&gt; &lt;code&gt;errno&lt;/code&gt; &lt;/a&gt; 이전과 통화 후 값; &lt;em&gt;use_last_error&lt;/em&gt; 는 Windows 오류 코드에 대해서도 동일합니다.</target>
        </trans-unit>
        <trans-unit id="eb4feb485235fe9256f397550a46a3fa39024fdd" translate="yes" xml:space="preserve">
          <source>The returned group is itself an iterator that shares the underlying iterable with &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt;. Because the source is shared, when the &lt;a href=&quot;#itertools.groupby&quot;&gt;&lt;code&gt;groupby()&lt;/code&gt;&lt;/a&gt; object is advanced, the previous group is no longer visible. So, if that data is needed later, it should be stored as a list:</source>
          <target state="translated">리턴 된 그룹 자체는 기본 iterable을 &lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt; 와 공유하는 반복자입니다 . 소스가 공유되므로 &lt;a href=&quot;#itertools.groupby&quot;&gt; &lt;code&gt;groupby()&lt;/code&gt; &lt;/a&gt; 객체가 고급화되면 이전 그룹이 더 이상 표시되지 않습니다. 따라서 해당 데이터가 나중에 필요한 경우 목록으로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="a343865b66bc184e10fbb10b32f697cc0caef5f8" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">리턴 된 삽입 점 &lt;em&gt;i&lt;/em&gt; 는 배열 &lt;em&gt;a&lt;/em&gt; 를 두 개의 반으로 분할하여 왼쪽에 대해 &lt;code&gt;all(val &amp;lt; x for val in a[lo:i])&lt;/code&gt; 대해 &lt;code&gt;all(val &amp;gt;= x for val in a[i:hi])&lt;/code&gt; 오른쪽에.</target>
        </trans-unit>
        <trans-unit id="669ff275cf0c181691c08c67e29ac61182ca5faf" translate="yes" xml:space="preserve">
          <source>The returned insertion point &lt;em&gt;i&lt;/em&gt; partitions the array &lt;em&gt;a&lt;/em&gt; into two halves so that &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; for the left side and &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; for the right side.</source>
          <target state="translated">리턴 된 삽입 점 &lt;em&gt;i&lt;/em&gt; 는 배열 &lt;em&gt;a&lt;/em&gt; 를 두 개의 반으로 분할하여 왼쪽에 대해 &lt;code&gt;all(val &amp;lt;= x for val in a[lo:i])&lt;/code&gt; &lt;code&gt;all(val &amp;gt; x for val in a[i:hi])&lt;/code&gt; 오른쪽에.</target>
        </trans-unit>
        <trans-unit id="53fe3542ff9fe12d2d3e1cb75fec1f427d2042d1" translate="yes" xml:space="preserve">
          <source>The returned instance is a proxy object with methods that can be used to invoke corresponding RPC calls on the remote server. If the remote server supports the introspection API, the proxy can also be used to query the remote server for the methods it supports (service discovery) and fetch other server-associated metadata.</source>
          <target state="translated">리턴 된 인스턴스는 원격 서버에서 해당 RPC 호출을 호출하는 데 사용할 수있는 메소드가있는 프록시 오브젝트입니다. 원격 서버가 자체 검사 API를 지원하는 경우 프록시를 사용하여 원격 서버에서 지원하는 방법 (서비스 검색)을 쿼리하고 다른 서버 관련 메타 데이터를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7288877f11459f6ab28ff785ec24351c4aa442e" translate="yes" xml:space="preserve">
          <source>The returned iterator raises a &lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt;&lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; is called and the result isn&amp;rsquo;t available after &lt;em&gt;timeout&lt;/em&gt; seconds from the original call to &lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt;&lt;code&gt;Executor.map()&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;timeout&lt;/em&gt; can be an int or a float. If &lt;em&gt;timeout&lt;/em&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, there is no limit to the wait time.</source>
          <target state="translated">반환 된 반복자는 &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 가 호출되고 &lt;a href=&quot;#concurrent.futures.Executor.map&quot;&gt; &lt;code&gt;Executor.map()&lt;/code&gt; &lt;/a&gt; 대한 원래 호출에서 &lt;em&gt;시간 초과&lt;/em&gt; 후 초 결과를 사용할 수없는 경우 &lt;a href=&quot;#concurrent.futures.TimeoutError&quot;&gt; &lt;code&gt;concurrent.futures.TimeoutError&lt;/code&gt; &lt;/a&gt;.futures.TimeoutError를 발생 시킵니다 . &lt;em&gt;타임 아웃&lt;/em&gt; 은 int 또는 float 일 수 있습니다. 경우 &lt;em&gt;시간 제한이&lt;/em&gt; 지정되지되지 않거나 &lt;code&gt;None&lt;/code&gt; , 대기 시간에 제한이 없습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d24b35f2954c9d4ccee793a3bacdf330b843c26a" translate="yes" xml:space="preserve">
          <source>The returned list will be sorted in the order they appeared in the original header list or were added to this instance, and may contain duplicates. Any fields deleted and re-inserted are always appended to the header list. If no fields exist with the given name, returns an empty list.</source>
          <target state="translated">반환 된 목록은 원래 헤더 목록에 표시되거나이 인스턴스에 추가 된 순서대로 정렬되며 중복 항목을 포함 할 수 있습니다. 삭제하고 다시 삽입 한 모든 필드는 항상 헤더 목록에 추가됩니다. 지정된 이름의 필드가 없으면 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3cf77cc7d995685ae1853fc00d68172f80697726" translate="yes" xml:space="preserve">
          <source>The returned object can only be used as a foreign function call parameter. It behaves similar to &lt;code&gt;pointer(obj)&lt;/code&gt;, but the construction is a lot faster.</source>
          <target state="translated">리턴 된 오브젝트는 외부 함수 호출 매개 변수로만 사용할 수 있습니다. &lt;code&gt;pointer(obj)&lt;/code&gt; 와 비슷하게 동작 하지만 구성이 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="944d9677c5e06b68735cee6e1214d92d8f721c2f" translate="yes" xml:space="preserve">
          <source>The returned object is a file-like object whose &lt;code&gt;_file&lt;/code&gt; attribute is either an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; object (depending on whether binary or text &lt;em&gt;mode&lt;/em&gt; was specified) or a true file object, depending on whether &lt;code&gt;rollover()&lt;/code&gt; has been called. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="translated">반환 된 객체는 &lt;code&gt;_file&lt;/code&gt; 속성이 &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 객체 (바이너리 또는 텍스트 &lt;em&gt;모드의&lt;/em&gt; 지정 여부에 따라 다름 ) 또는 &lt;code&gt;rollover()&lt;/code&gt; 호출 여부에 따라 실제 파일 객체 인 파일과 유사한 객체입니다 . 이 파일과 유사한 객체는 일반 파일과 마찬가지로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="63b21c5c69819c1c91c200a05cc8559e27dc6d81" translate="yes" xml:space="preserve">
          <source>The returned object is a file-like object whose &lt;code&gt;_file&lt;/code&gt; attribute is either an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt; object (depending on whether binary or text &lt;em&gt;mode&lt;/em&gt; was specified) or a true file object, depending on whether &lt;code&gt;rollover()&lt;/code&gt; has been called. This file-like object can be used in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, just like a normal file.</source>
          <target state="translated">반환 된 객체는 &lt;code&gt;_file&lt;/code&gt; 속성이 &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; &lt;/a&gt; 객체 (바이너리 또는 텍스트 &lt;em&gt;모드&lt;/em&gt; 가 지정 되었는지 여부에 따라 다름 ) 또는 &lt;code&gt;rollover()&lt;/code&gt; 호출 여부에 따라 실제 파일 객체 인 파일 류 객체 입니다. 이 파일 류 객체는 일반 파일처럼 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ba4ccce7e74dabed802bdff9234a1122b0c4107" translate="yes" xml:space="preserve">
          <source>The returned object is a true file object on POSIX platforms. On other platforms, it is a file-like object whose &lt;code&gt;file&lt;/code&gt; attribute is the underlying true file object.</source>
          <target state="translated">리턴 된 오브젝트는 POSIX 플랫폼에서 실제 파일 오브젝트입니다. 다른 플랫폼에서는 &lt;code&gt;file&lt;/code&gt; 속성이 기본 실제 파일 객체 인 파일 과 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="2d61336daabebc08319a6841656673dafcebf7ab" translate="yes" xml:space="preserve">
          <source>The returned property object also has the attributes &lt;code&gt;fget&lt;/code&gt;, &lt;code&gt;fset&lt;/code&gt;, and &lt;code&gt;fdel&lt;/code&gt; corresponding to the constructor arguments.</source>
          <target state="translated">반환 된 속성 객체 에는 생성자 인수에 해당하는 속성 &lt;code&gt;fget&lt;/code&gt; , &lt;code&gt;fset&lt;/code&gt; 및 &lt;code&gt;fdel&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1078216c97fc2cb54c2f472e356bef009039e6ee" translate="yes" xml:space="preserve">
          <source>The returned string includes the currency symbol if &lt;em&gt;symbol&lt;/em&gt; is true, which is the default. If &lt;em&gt;grouping&lt;/em&gt; is true (which is not the default), grouping is done with the value. If &lt;em&gt;international&lt;/em&gt; is true (which is not the default), the international currency symbol is used.</source>
          <target state="translated">반환 된 문자열은 &lt;em&gt;symbol&lt;/em&gt; 이 true 인 경우 통화 기호를 포함하며 이것이 기본값입니다. 경우 &lt;em&gt;그룹화&lt;/em&gt; (기본하지 않은) 사실, 값으로 이루어집니다 그룹화합니다. 경우 &lt;em&gt;국제가&lt;/em&gt; (기본값은하지 않은) 사실, 국제 통화 기호가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bfd8c08933483893f75b8b7fdb1a5319adb8fe8b" translate="yes" xml:space="preserve">
          <source>The returned value is shell-escaped to protect against injection vulnerabilities (see &lt;a href=&quot;#shlex.quote&quot;&gt;&lt;code&gt;quote()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">주입 된 취약점으로부터 보호하기 위해 반환 된 값은 셸 이스케이프 처리됩니다 ( &lt;a href=&quot;#shlex.quote&quot;&gt; &lt;code&gt;quote()&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f6e2d49d3bb8bfbea2c5c7323f9693333c6fa08d" translate="yes" xml:space="preserve">
          <source>The returned value will be a copy of the result of the call or a proxy to a new shared object &amp;ndash; see documentation for the &lt;em&gt;method_to_typeid&lt;/em&gt; argument of &lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt;&lt;code&gt;BaseManager.register()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 호출 결과 또는 새 공유 객체에 대한 프록시의 사본입니다 . &lt;a href=&quot;#multiprocessing.managers.BaseManager.register&quot;&gt; &lt;code&gt;BaseManager.register()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;method_to_typeid&lt;/em&gt; 인수에 대한 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb70bf1a9ac2dc854c2a93668773c6b77481b4f9" translate="yes" xml:space="preserve">
          <source>The root item may not be deleted.</source>
          <target state="translated">루트 항목은 삭제되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3890ffaf0a29880883c4c861690ab01939538879" translate="yes" xml:space="preserve">
          <source>The root item may not be detached.</source>
          <target state="translated">루트 아이템은 분리되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8724776bb36627ef8324ed2cee8596adf2c111ef" translate="yes" xml:space="preserve">
          <source>The root logger must specify a level and a list of handlers. An example of a root logger section is given below.</source>
          <target state="translated">루트 로거는 레벨 및 핸들러 목록을 지정해야합니다. 루트 로거 섹션의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8aa0536a231f439ca03f4c8eab15fc8b24452be" translate="yes" xml:space="preserve">
          <source>The root of the numeric hierarchy. If you just want to check if an argument &lt;em&gt;x&lt;/em&gt; is a number, without caring what kind, use &lt;code&gt;isinstance(x, Number)&lt;/code&gt;.</source>
          <target state="translated">숫자 계층의 근 인수 &lt;em&gt;x&lt;/em&gt; 가 숫자인지 확인하려면 어떤 종류를 신경 쓰지 않고 &lt;code&gt;isinstance(x, Number)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b3ac7015fd4390c4695675d6ffe8261b0a5c14" translate="yes" xml:space="preserve">
          <source>The routine takes time proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">루틴은 &lt;code&gt;len(fragment)&lt;/code&gt; 비례하여 시간이 걸립니다 .</target>
        </trans-unit>
        <trans-unit id="c458d0b0fe448ae2d0a4d83d7ec4609f7e529b08" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to never expose Future objects in user-facing APIs, and the recommended way to create a Future object is to call &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt;&lt;code&gt;loop.create_future()&lt;/code&gt;&lt;/a&gt;. This way alternative event loop implementations can inject their own optimized implementations of a Future object.</source>
          <target state="translated">경험상, 사용자 대상 API에서 Future 객체를 노출하지 않는 것이 좋습니다. Future 객체를 만드는 권장 방법은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_future&quot;&gt; &lt;code&gt;loop.create_future()&lt;/code&gt; &lt;/a&gt; 를 호출하는 것 입니다. 이런 식으로 대체 이벤트 루프 구현은 자체 최적화 된 Future 객체 구현을 주입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9d329adbb453311cb1f83021747ba8fe74b77e2" translate="yes" xml:space="preserve">
          <source>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, etc.), descriptors (methods are also descriptors), and variable names listed in &lt;code&gt;_ignore_&lt;/code&gt;.</source>
          <target state="translated">허용되는 규칙은 다음과 같습니다. 단일 밑줄로 시작하고 끝나는 이름은 열거 형으로 예약되어 사용할 수 없습니다. 열거 내에 정의 된 다른 모든 속성은 특수 메소드 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 등), 설명자 (메소드도 설명자) 및 &lt;code&gt;_ignore_&lt;/code&gt; 에 나열된 변수 이름을 제외하고이 열거의 멤버가 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe703515002487a2b0312a4527a4116966e227c" translate="yes" xml:space="preserve">
          <source>The rules for what is allowed are as follows: names that start and end with a single underscore are reserved by enum and cannot be used; all other attributes defined within an enumeration will become members of this enumeration, with the exception of special methods (&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt;&lt;code&gt;__add__()&lt;/code&gt;&lt;/a&gt;, etc.), descriptors (methods are also descriptors), and variable names listed in &lt;code&gt;_ignore_&lt;/code&gt;.</source>
          <target state="translated">허용되는 규칙은 다음과 같습니다. 단일 밑줄로 시작하고 끝나는 이름은 열거 형으로 예약되어 사용할 수 없습니다. 특수 메서드 ( &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__add__&quot;&gt; &lt;code&gt;__add__()&lt;/code&gt; &lt;/a&gt; 등), 설명자 (메서드도 설명자) 및 &lt;code&gt;_ignore_&lt;/code&gt; 에 나열된 변수 이름을 제외하고 열거 형 내에 정의 된 다른 모든 속성은이 열거 형의 구성원이 됩니다 .</target>
        </trans-unit>
        <trans-unit id="61698b0a1acd1e3ec12a3341214499d204a64941" translate="yes" xml:space="preserve">
          <source>The same &lt;code&gt;fallback&lt;/code&gt; argument can be used with the &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt;&lt;code&gt;getint()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt;&lt;code&gt;getfloat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt; methods, for example:</source>
          <target state="translated">동일한 &lt;code&gt;fallback&lt;/code&gt; 인수를 &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt; &lt;code&gt;getint()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt; &lt;code&gt;getfloat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt; 메소드 와 함께 사용할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fe0ad54a153c9c16fc953f6457e2a08391e6ddfd" translate="yes" xml:space="preserve">
          <source>The same applies to writing in something other than the system default encoding: specify the encoding argument when opening the output file.</source>
          <target state="translated">시스템 기본 인코딩 이외의 다른 방식으로 쓰기에도 동일하게 적용됩니다. 출력 파일을 열 때 인코딩 인수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee42da4190d9eab8ed782585f2b56ceaaa52fe60" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt;&lt;code&gt;cte_type&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;7bit&lt;/code&gt;, except that the returned value is bytes.</source>
          <target state="translated">같은 &lt;a href=&quot;#email.policy.EmailPolicy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; 경우 &lt;a href=&quot;#email.policy.Policy.cte_type&quot;&gt; &lt;code&gt;cte_type&lt;/code&gt; 가&lt;/a&gt; 인 &lt;code&gt;7bit&lt;/code&gt; 리턴 값은 바이트 인 것을 제외.</target>
        </trans-unit>
        <trans-unit id="d0e9d4a97e7a8c08a403fe0b581fce1bbbca7af2" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#email.policy.Policy.fold&quot;&gt;&lt;code&gt;fold()&lt;/code&gt;&lt;/a&gt;, except that the returned value should be a bytes object rather than a string.</source>
          <target state="translated">동일한는 &lt;a href=&quot;#email.policy.Policy.fold&quot;&gt; &lt;code&gt;fold()&lt;/code&gt; &lt;/a&gt; , 리턴 값은 바이트 스트링 아닌 객체가 될 것을 제외한다.</target>
        </trans-unit>
        <trans-unit id="d6e3c5f083440fe9bbf887c7f88bf5f04da824a4" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; except that the ordering of the results from the returned iterator should be considered arbitrary. (Only when there is only one worker process is the order guaranteed to be &amp;ldquo;correct&amp;rdquo;.)</source>
          <target state="translated">같은 &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt; 로부터의 결과의 순서는 임의 반복자 고려되어야한다는 점을 제외하고 반환. (작업자 프로세스가 하나만있는 경우에만 주문이 &quot;올바르게&quot;보장됩니다.)</target>
        </trans-unit>
        <trans-unit id="4f0e693b02ea181bbef1c28375701342551141cd" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt;&lt;code&gt;RawArray()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes array.</source>
          <target state="translated">동일하게 &lt;a href=&quot;#multiprocessing.sharedctypes.RawArray&quot;&gt; &lt;code&gt;RawArray()&lt;/code&gt; &lt;/a&gt; 의 값에 의존한다는 점을 제외하고 &lt;em&gt;잠금&lt;/em&gt; 프로세스 안전한 동기화 래퍼 대신 원시하는 ctypes 어레이 반환 될 수있다.</target>
        </trans-unit>
        <trans-unit id="6cfb2c05572cc99d847c223df250f30149473f05" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt;&lt;code&gt;RawValue()&lt;/code&gt;&lt;/a&gt; except that depending on the value of &lt;em&gt;lock&lt;/em&gt; a process-safe synchronization wrapper may be returned instead of a raw ctypes object.</source>
          <target state="translated">&lt;em&gt;잠금&lt;/em&gt; 값에 따라 원시 ctypes 오브젝트 대신 프로세스 안전 동기화 랩퍼가 리턴 될 수 있다는 점을 제외하면 &lt;a href=&quot;#multiprocessing.sharedctypes.RawValue&quot;&gt; &lt;code&gt;RawValue()&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f1a01b84361f53398479056f09464345f02bd043" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;found&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 'found'응답이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="750e1ad255c0e380db439ef1dab8b7f8f0852e72" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;see other&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 'see other'응답이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49feac63317adae6711e747adbff6e95df411957" translate="yes" xml:space="preserve">
          <source>The same as &lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt;&lt;code&gt;http_error_301()&lt;/code&gt;&lt;/a&gt;, but called for the &amp;lsquo;temporary redirect&amp;rsquo; response.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.HTTPRedirectHandler.http_error_301&quot;&gt; &lt;code&gt;http_error_301()&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 '임시 리디렉션'응답이 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="8230ae470e5c59b6f3c4881b2a39dc38aedffae8" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'d'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'d'&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="916ed3638cece914ee2fc8b1652dfd07c219904b" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;'s'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'s'&lt;/code&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="829e5aa2fdb08ee46435ea6cf88e99987eb1e392" translate="yes" xml:space="preserve">
          <source>The same as &lt;code&gt;SMTP&lt;/code&gt; except that &lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;True&lt;/code&gt;. Useful for serializing messages to a message store without using encoded words in the headers. Should only be used for SMTP transmission if the sender or recipient addresses have non-ASCII characters (the &lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt;&lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt;&lt;/a&gt; method handles this automatically).</source>
          <target state="translated">&lt;a href=&quot;#email.policy.EmailPolicy.utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;True&lt;/code&gt; 인 것을 제외하고는 &lt;code&gt;SMTP&lt;/code&gt; 와 동일 합니다. 헤더에서 인코딩 된 단어를 사용하지 않고 메시지를 메시지 저장소로 직렬화하는 데 유용합니다. 발신자 또는 수신자 주소에 ASCII가 아닌 문자가있는 경우에만 SMTP 전송에 사용해야합니다 ( &lt;a href=&quot;smtplib#smtplib.SMTP.send_message&quot;&gt; &lt;code&gt;smtplib.SMTP.send_message()&lt;/code&gt; &lt;/a&gt; 메소드에서 자동으로 처리).</target>
        </trans-unit>
        <trans-unit id="532039e29cf202190420d4e6121e0b76b86ef2f9" translate="yes" xml:space="preserve">
          <source>The same as the ellipsis literal &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;. Special value used mostly in conjunction with extended slicing syntax for user-defined container data types.</source>
          <target state="translated">줄임표 리터럴 &quot; &lt;code&gt;...&lt;/code&gt; &quot; 과 동일합니다 . 사용자 정의 컨테이너 데이터 유형에 대한 확장 슬라이싱 구문과 함께 주로 사용되는 특수 값입니다.</target>
        </trans-unit>
        <trans-unit id="b854b52ef7bd2ccfd324aed6049a603fc8fb7751" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#timeit.Timer&quot;&gt;&lt;code&gt;Timer&lt;/code&gt;&lt;/a&gt; class and its methods:</source>
          <target state="translated">&lt;a href=&quot;#timeit.Timer&quot;&gt; &lt;code&gt;Timer&lt;/code&gt; &lt;/a&gt; 클래스와 해당 메서드를 사용하여 동일한 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4760c18be62a9d7dec114efc1c14ea346862762" translate="yes" xml:space="preserve">
          <source>The same can be done using the &lt;a href=&quot;#zipapp.create_archive&quot;&gt;&lt;code&gt;create_archive()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#zipapp.create_archive&quot;&gt; &lt;code&gt;create_archive()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 동일하게 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b0e747134e643ee7b418317f6324c54e529d2a3" translate="yes" xml:space="preserve">
          <source>The same effect may be had by simply calling the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 인스턴스 를 호출하는 것만으로도 같은 효과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ee95343967fc42163ec543a6a7c5d8e1c5cae20" translate="yes" xml:space="preserve">
          <source>The same example using the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 사용한 동일한 예제 :</target>
        </trans-unit>
        <trans-unit id="3136db70fec32537a20098587fa73ba76fdb2570" translate="yes" xml:space="preserve">
          <source>The same example using the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문을 사용한 동일한 예 :</target>
        </trans-unit>
        <trans-unit id="f21bc4fc65a842a8845b57c261870ced2cf68832" translate="yes" xml:space="preserve">
          <source>The same pattern can be used for other similar decorators: &lt;code&gt;staticmethod&lt;/code&gt;, &lt;code&gt;abstractmethod&lt;/code&gt;, and others.</source>
          <target state="translated">&lt;code&gt;staticmethod&lt;/code&gt; , &lt;code&gt;abstractmethod&lt;/code&gt; 등의 다른 유사한 데코레이터에도 동일한 패턴을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f3dc1e5cb29f2f7aa6277b41a35ebe97be0cfb65" translate="yes" xml:space="preserve">
          <source>The same thing can be achieved in the constructor call to mocks:</source>
          <target state="translated">mock에 대한 생성자 호출에서 동일한 것을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9af275e54fe0509a959d2873010a1018b8c67266" translate="yes" xml:space="preserve">
          <source>The same, in reverse, has to be applied when converting from 8 to 16, 24 or 32 bit width samples.</source>
          <target state="translated">8 비트에서 16 비트, 24 비트 또는 32 비트 폭의 샘플을 변환 할 때는 반대로 적용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c88a256e1b82c972fc3255b212954b50fdc69e36" translate="yes" xml:space="preserve">
          <source>The sample mean gives an unbiased estimate of the true population mean, so that when taken on average over all the possible samples, &lt;code&gt;mean(sample)&lt;/code&gt; converges on the true mean of the entire population. If &lt;em&gt;data&lt;/em&gt; represents the entire population rather than a sample, then &lt;code&gt;mean(data)&lt;/code&gt; is equivalent to calculating the true population mean &amp;mu;.</source>
          <target state="translated">표본 평균은 실제 모집단 평균의 편견없는 추정값을 제공하므로 가능한 모든 표본에 대해 평균적으로 계산할 때 &lt;code&gt;mean(sample)&lt;/code&gt; 은 전체 모집단의 실제 평균에 수렴됩니다. &lt;em&gt;데이터&lt;/em&gt; 가 표본이 아닌 전체 모집단을 나타내는 경우 &lt;code&gt;mean(data)&lt;/code&gt; 은 실제 모집단 평균 &amp;mu;를 계산하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b6d6ef4afe2bb1824ced5480b576fe34f8770f0" translate="yes" xml:space="preserve">
          <source>The scheduling priority for a scheduling policy.</source>
          <target state="translated">스케줄링 정책의 스케줄링 우선 순위.</target>
        </trans-unit>
        <trans-unit id="a789b28f90e6a13336b5a43d081ce2c14e0e32bb" translate="yes" xml:space="preserve">
          <source>The schema describes a set of logging objects - loggers, handlers, formatters, filters - which are connected to each other in an object graph. Thus, the schema needs to represent connections between the objects. For example, say that, once configured, a particular logger has attached to it a particular handler. For the purposes of this discussion, we can say that the logger represents the source, and the handler the destination, of a connection between the two. Of course in the configured objects this is represented by the logger holding a reference to the handler. In the configuration dict, this is done by giving each destination object an id which identifies it unambiguously, and then using the id in the source object&amp;rsquo;s configuration to indicate that a connection exists between the source and the destination object with that id.</source>
          <target state="translated">스키마는 로거, 핸들러, 포맷터, 필터 등의 로깅 오브젝트 세트를 설명하며, 이는 오브젝트 그래프에서 서로 연결됩니다. 따라서 스키마는 객체 간의 연결을 나타내야합니다. 예를 들어, 일단 구성된 로거가 특정 로거에 특정 핸들러를 첨부했다고 가정하십시오. 이 논의의 목적 상, 로거는 둘 사이의 연결의 소스 및 핸들러를 목적지로 나타냅니다. 물론 구성된 객체에서 이것은 핸들러에 대한 참조를 보유한 로거로 표시됩니다. 구성 명령에서 이는 각 대상 객체에이를 명확하게 식별하는 id를 제공 한 다음 소스 객체 구성의 id를 사용하여 해당 id를 가진 소스와 대상 객체 사이에 연결이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="357034175b5af2bba561f08e5abd996027ed8d5a" translate="yes" xml:space="preserve">
          <source>The schema supports user-defined objects for handlers, filters and formatters. (Loggers do not need to have different types for different instances, so there is no support in this configuration schema for user-defined logger classes.)</source>
          <target state="translated">이 스키마는 처리기, 필터 및 포맷터에 대한 사용자 정의 개체를 지원합니다. 로거는 인스턴스마다 다른 유형을 가질 필요가 없으므로이 구성 스키마에서는 사용자 정의 로거 클래스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5cf05c8728d612453b8e5fe6be79e83aec4e76a" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; in the Python source distribution is a GUI tool for test discovery and execution. This is intended largely for ease of use for those new to unit testing. For production environments it is recommended that tests be driven by a continuous integration system such as &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; or &lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson&lt;/a&gt;.</source>
          <target state="translated">Python 소스 배포판의 &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; 스크립트 는 테스트 검색 및 실행을위한 GUI 도구입니다. 이것은 단위 테스트에 익숙하지 않은 사람들을 위해 사용하기 쉽도록 만들어졌습니다. 프로덕션 환경의 경우 &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt; , &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; 또는 &lt;a href=&quot;http://hudson-ci.org/&quot;&gt;Hudson&lt;/a&gt; 과 같은 지속적인 통합 시스템으로 테스트를 수행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c4d31cf92666ad824bb699fb1bd45276cded366b" translate="yes" xml:space="preserve">
          <source>The script &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; in the Python source distribution is a GUI tool for test discovery and execution. This is intended largely for ease of use for those new to unit testing. For production environments it is recommended that tests be driven by a continuous integration system such as &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt;, &lt;a href=&quot;https://jenkins.io/&quot;&gt;Jenkins&lt;/a&gt; or &lt;a href=&quot;https://travis-ci.com&quot;&gt;Travis-CI&lt;/a&gt;, or &lt;a href=&quot;https://www.appveyor.com/&quot;&gt;AppVeyor&lt;/a&gt;.</source>
          <target state="translated">Python 소스 배포의 &lt;code&gt;Tools/unittestgui/unittestgui.py&lt;/code&gt; 스크립트 는 테스트 검색 및 실행을위한 GUI 도구입니다. 이것은 주로 단위 테스트를 처음 접하는 사람들이 쉽게 사용할 수 있도록하기위한 것입니다. 제조 환경에서는 그 시험과 같은 연속적인 통합 시스템에 의해 구동 될 것을 권장 &lt;a href=&quot;https://buildbot.net/&quot;&gt;Buildbot&lt;/a&gt; , &lt;a href=&quot;https://jenkins.io/&quot;&gt;젠킨스&lt;/a&gt; 또는 &lt;a href=&quot;https://travis-ci.com&quot;&gt;트래비스 - CI&lt;/a&gt; 또는 &lt;a href=&quot;https://www.appveyor.com/&quot;&gt;AppVeyor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="590472629c42696a37ed0e6a09a2aa0815298d38" translate="yes" xml:space="preserve">
          <source>The script &lt;strong&gt;webbrowser&lt;/strong&gt; can be used as a command-line interface for the module. It accepts a URL as the argument. It accepts the following optional parameters: &lt;code&gt;-n&lt;/code&gt; opens the URL in a new browser window, if possible; &lt;code&gt;-t&lt;/code&gt; opens the URL in a new browser page (&amp;ldquo;tab&amp;rdquo;). The options are, naturally, mutually exclusive. Usage example:</source>
          <target state="translated">스크립트 &lt;strong&gt;웹 브라우저&lt;/strong&gt; 는 모듈의 명령 행 인터페이스로 사용될 수 있습니다. URL을 인수로 사용합니다. 다음과 같은 선택적 매개 변수를 승인합니다. &lt;code&gt;-n&lt;/code&gt; 가능한 경우 새 브라우저 창에서 URL을 엽니 다. &lt;code&gt;-t&lt;/code&gt; 는 새 브라우저 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 URL을 엽니 다. 옵션은 당연히 상호 배타적입니다. 사용 예 :</target>
        </trans-unit>
        <trans-unit id="09613d977f5c11ceb44df4f71da6d33551c96b71" translate="yes" xml:space="preserve">
          <source>The script does not close the file explicitly. By default, Python does not emit any warning. Example using README.txt, which has 269 lines:</source>
          <target state="translated">스크립트는 파일을 명시 적으로 닫지 않습니다. 기본적으로 Python은 경고를 표시하지 않습니다. 269 ​​행이있는 README.txt를 사용한 예 :</target>
        </trans-unit>
        <trans-unit id="7abc03b295e1e06c729bb0d780860fe53a6dc23c" translate="yes" xml:space="preserve">
          <source>The script that is going to get analyzed later on (bacon.py):</source>
          <target state="translated">나중에 분석 할 스크립트 (bacon.py) :</target>
        </trans-unit>
        <trans-unit id="ee5b7d667b6a893a07a7bd795cbb225c3559dadb" translate="yes" xml:space="preserve">
          <source>The script that will output the report of bacon.py:</source>
          <target state="translated">bacon.py의 보고서를 출력 할 스크립트 :</target>
        </trans-unit>
        <trans-unit id="5c61673a55b5a1642add6c59c9e42d35514177fa" translate="yes" xml:space="preserve">
          <source>The script&amp;rsquo;s input is connected to the client too, and sometimes the form data is read this way; at other times the form data is passed via the &amp;ldquo;query string&amp;rdquo; part of the URL. This module is intended to take care of the different cases and provide a simpler interface to the Python script. It also provides a number of utilities that help in debugging scripts, and the latest addition is support for file uploads from a form (if your browser supports it).</source>
          <target state="translated">스크립트의 입력은 클라이언트에도 연결되며 때로는 양식 데이터를 이런 식으로 읽습니다. 다른 경우에는 양식 데이터가 URL의 &quot;쿼리 문자열&quot;부분을 통해 전달됩니다. 이 모듈은 다른 경우를 처리하고 Python 스크립트에 대한 간단한 인터페이스를 제공하기위한 것입니다. 또한 스크립트 디버깅에 도움이되는 많은 유틸리티를 제공하며 최신 추가 기능은 양식에서 파일 업로드를 지원합니다 (브라우저에서 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="441a890d73099fc8af230e1050ed5b9319ec7466" translate="yes" xml:space="preserve">
          <source>The scroll bar widget.</source>
          <target state="translated">스크롤 바 위젯.</target>
        </trans-unit>
        <trans-unit id="0b2bbe283f6190e08707f30471c6201f3310ca5a" translate="yes" xml:space="preserve">
          <source>The second argument is the &lt;em&gt;source&lt;/em&gt; of enumeration member names. It can be a whitespace-separated string of names, a sequence of names, a sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary) of names to values. The last two options enable assigning arbitrary values to enumerations; the others auto-assign increasing integers starting with 1 (use the &lt;code&gt;start&lt;/code&gt; parameter to specify a different starting value). A new class derived from &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is returned. In other words, the above assignment to &lt;code&gt;Animal&lt;/code&gt; is equivalent to:</source>
          <target state="translated">두 번째 인수는 열거 멤버 이름 의 &lt;em&gt;소스&lt;/em&gt; 입니다. 공백으로 구분 된 이름 문자열, 이름 시퀀스, 키 / 값 쌍이있는 2 개의 튜플 시퀀스 또는 이름을 값에 매핑 (예 : 사전) 할 수 있습니다. 마지막 두 옵션은 임의의 값을 열거에 할당 할 수있게합니다. 나머지는 1부터 시작하여 증가하는 정수를 자동 할당합니다 ( &lt;code&gt;start&lt;/code&gt; 매개 변수를 사용하여 다른 시작 값을 지정하십시오). &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 에서 파생 된 새 클래스 가 반환됩니다. 다시 말해, 위의 &lt;code&gt;Animal&lt;/code&gt; 할당 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3efff11fbd76f900b41de117b028cbaa28815d1e" translate="yes" xml:space="preserve">
          <source>The second argument, if present, specifies the file location to copy to (if absent, the location will be a tempfile with a generated name). The third argument, if present, is a callable that will be called once on establishment of the network connection and once after each block read thereafter. The callable will be passed three arguments; a count of blocks transferred so far, a block size in bytes, and the total size of the file. The third argument may be &lt;code&gt;-1&lt;/code&gt; on older FTP servers which do not return a file size in response to a retrieval request.</source>
          <target state="translated">두 번째 인수 (있는 경우)는 복사 할 파일 위치를 지정합니다 (없는 경우 위치는 생성 된 이름을 가진 임시 파일입니다). 존재하는 경우, 세 번째 인수는 네트워크 연결이 설정 될 때 한 번 호출되고 그 이후에 각 블록이 읽은 후에 한 번 호출되는 호출 가능입니다. 콜 러블에는 세 가지 인수가 전달됩니다. 지금까지 전송 된 블록 수, 블록 크기 (바이트) 및 파일의 전체 크기 검색 요청에 대한 응답으로 파일 크기를 반환하지 않는 구형 FTP 서버에서 세 번째 인수는 &lt;code&gt;-1&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc342d27fa2c9d42507affce95a9a6a6d772b584" translate="yes" xml:space="preserve">
          <source>The second case may be used on Mac OS X and FreeBSD where &lt;em&gt;headers&lt;/em&gt; and &lt;em&gt;trailers&lt;/em&gt; are arbitrary sequences of buffers that are written before and after the data from &lt;em&gt;in&lt;/em&gt; is written. It returns the same as the first case.</source>
          <target state="translated">두 번째 경우는 맥 OS X와 FreeBSD에 사용될 수있다 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;트레일러&lt;/em&gt; 의 데이터 전후의 기록 버퍼의 임의의 서열이다 &lt;em&gt;에&lt;/em&gt; 기입된다. 첫 번째 경우와 동일하게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dc9ed3bf0e51e74a14ebf33737b710029623e678" translate="yes" xml:space="preserve">
          <source>The second case may be used on Mac OS X and FreeBSD where &lt;em&gt;headers&lt;/em&gt; and &lt;em&gt;trailers&lt;/em&gt; are arbitrary sequences of buffers that are written before and after the data from &lt;em&gt;in_fd&lt;/em&gt; is written. It returns the same as the first case.</source>
          <target state="translated">두 번째 경우는 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;트레일러&lt;/em&gt; 가 &lt;em&gt;in_fd&lt;/em&gt; 의 데이터가 기록되기 전후에 기록되는 임의의 버퍼 시퀀스 인 Mac OS X 및 FreeBSD에서 사용될 수 있습니다 . 첫 번째 경우와 동일하게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f15a93322f7f76be0339398712074ec97be438ed" translate="yes" xml:space="preserve">
          <source>The second form of the constructor sets the corresponding attributes, described below. The attributes default to &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not specified. For backwards compatibility, if three arguments are passed, the &lt;a href=&quot;#BaseException.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; attribute contains only a 2-tuple of the first two constructor arguments.</source>
          <target state="translated">생성자의 두 번째 형식은 아래에 설명 된 해당 속성을 설정합니다. 지정하지 않으면 속성은 기본적으로 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 설정 됩니다. 이전 버전과의 호환성을 위해 세 개의 인수가 전달되면 &lt;a href=&quot;#BaseException.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 속성에는 처음 두 생성자 인수 중 2 개만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="34296b7537391f3024117b10f7c3a5ff4dd5b9d8" translate="yes" xml:space="preserve">
          <source>The second group of options controls how test failures are reported:</source>
          <target state="translated">두 번째 옵션 그룹은 테스트 실패보고 방법을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="a82684db899d668b167ed8174dc94a018b1dcbae" translate="yes" xml:space="preserve">
          <source>The second issue is more general to mocking. If you refactor some of your code, rename members and so on, any tests for code that is still using the &lt;em&gt;old api&lt;/em&gt; but uses mocks instead of the real objects will still pass. This means your tests can all pass even though your code is broken.</source>
          <target state="translated">두 번째 문제는 조롱에 더 일반적입니다. 일부 코드를 리팩터링하고 멤버 이름 등을 변경하면 여전히 &lt;em&gt;이전 API를&lt;/em&gt; 사용하지만 실제 객체 대신 모의 객체를 사용하는 코드 테스트가 계속 됩니다. 즉, 코드가 손상 되어도 테스트를 모두 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e61c328cb69d5d01b94c637cb52d86809c1a81f" translate="yes" xml:space="preserve">
          <source>The second optional keyword argument is &lt;em&gt;stack_info&lt;/em&gt;, which defaults to &lt;code&gt;False&lt;/code&gt;. If true, stack information is added to the logging message, including the actual logging call. Note that this is not the same stack information as that displayed through specifying &lt;em&gt;exc_info&lt;/em&gt;: The former is stack frames from the bottom of the stack up to the logging call in the current thread, whereas the latter is information about stack frames which have been unwound, following an exception, while searching for exception handlers.</source>
          <target state="translated">두 번째 선택적 키워드 인수는 &lt;em&gt;stack_info&lt;/em&gt; 이며 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. true 인 경우 실제 로깅 호출을 포함하여 스택 정보가 로깅 메시지에 추가됩니다. 이것은 &lt;em&gt;exc_info&lt;/em&gt; 지정을 통해 표시되는 것과 동일한 스택 정보는 아닙니다 . 전자는 스택의 맨 아래부터 현재 스레드의 로깅 호출까지 스택 프레임이지만, 후자는 풀린 스택 프레임에 대한 정보입니다. 예외 처리기를 검색하는 동안 예외를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2e4c730e515ea8c7e6ed22283aa940b7c170b41b" translate="yes" xml:space="preserve">
          <source>The second problem is that it &amp;ldquo;takes a while&amp;rdquo; from when an event is dispatched until the profiler&amp;rsquo;s call to get the time actually &lt;em&gt;gets&lt;/em&gt; the state of the clock. Similarly, there is a certain lag when exiting the profiler event handler from the time that the clock&amp;rsquo;s value was obtained (and then squirreled away), until the user&amp;rsquo;s code is once again executing. As a result, functions that are called many times, or call many functions, will typically accumulate this error. The error that accumulates in this fashion is typically less than the accuracy of the clock (less than one clock tick), but it &lt;em&gt;can&lt;/em&gt; accumulate and become very significant.</source>
          <target state="translated">두 번째 문제는 이벤트가 시간이 실제로 얻을 수있는 프로파일 러의 호출까지 전달 될 때부터 &quot;잠시 소요&quot;이다 &lt;em&gt;얻는다&lt;/em&gt; 시계의 상태를. 마찬가지로, 사용자의 코드가 다시 한번 실행될 때까지 시계 값이 획득 된 시점부터 다람쥐가 사라지는 시점부터 프로파일 러 이벤트 핸들러를 종료 할 때 특정 지연이 발생합니다. 결과적으로 여러 번 호출되거나 많은 함수를 호출하는 함수는 일반적으로이 오류를 누적합니다. 이러한 방식으로 누적되는 오류는 일반적으로 클럭 정확도 (1 클럭 미만)보다 적지 만 누적되어 매우 중요해질 &lt;em&gt;수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d32a81f75e96772b4383da9bf4edd54a00fffcf6" translate="yes" xml:space="preserve">
          <source>The second section is usually HTML, which allows the client software to display nicely formatted text with header, in-line images, etc. Here&amp;rsquo;s Python code that prints a simple piece of HTML:</source>
          <target state="translated">두 번째 섹션은 일반적으로 HTML이며, 클라이언트 소프트웨어는 헤더, 인라인 이미지 등으로 멋진 형식의 텍스트를 표시 할 수 있습니다. 다음은 간단한 HTML을 인쇄하는 Python 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3983ca9591946a2e35ceee565ce274efeaded338" translate="yes" xml:space="preserve">
          <source>The second subclass allows for connections created by a child process:</source>
          <target state="translated">두 번째 서브 클래스는 하위 프로세스로 작성된 연결을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="5434750abc7b69faf1ffb090ae9381c4aab45452" translate="yes" xml:space="preserve">
          <source>The second use case is to support cooperative multiple inheritance in a dynamic execution environment. This use case is unique to Python and is not found in statically compiled languages or languages that only support single inheritance. This makes it possible to implement &amp;ldquo;diamond diagrams&amp;rdquo; where multiple base classes implement the same method. Good design dictates that this method have the same calling signature in every case (because the order of calls is determined at runtime, because that order adapts to changes in the class hierarchy, and because that order can include sibling classes that are unknown prior to runtime).</source>
          <target state="translated">두 번째 사용 사례는 동적 실행 환경에서 협업 다중 상속을 지원하는 것입니다. 이 유스 케이스는 Python에 고유하며 정적으로 컴파일 된 언어 또는 단일 상속 만 지원하는 언어에는 없습니다. 이를 통해 여러 기본 클래스가 동일한 메소드를 구현하는 &quot;다이아몬드 다이어그램&quot;을 구현할 수 있습니다. 좋은 설계는이 메소드가 모든 경우에 동일한 호출 서명을 갖도록 지시합니다 (이 호출 순서는 클래스 계층 구조의 변경에 적응하고 런타임에 알려지지 않은 형제 클래스를 포함 할 수 있기 때문에 런타임에 호출 순서가 결정되기 때문입니다) ).</target>
        </trans-unit>
        <trans-unit id="817bae41c43a2fdb49bd2ccee3ff54cd1276a64e" translate="yes" xml:space="preserve">
          <source>The sections below first document the header base classes and their attributes, followed by the API for modifying the behavior of &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt;&lt;code&gt;HeaderRegistry&lt;/code&gt;&lt;/a&gt;, and finally the support classes used to represent the data parsed from structured headers.</source>
          <target state="translated">아래 섹션은 먼저 헤더 기본 클래스와 해당 속성, &lt;a href=&quot;#email.headerregistry.HeaderRegistry&quot;&gt; &lt;code&gt;HeaderRegistry&lt;/code&gt; &lt;/a&gt; 의 동작을 수정하기위한 API 및 구조화 된 헤더에서 구문 분석 된 데이터를 나타내는 데 사용되는 지원 클래스에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="fb511a5d628d8dbbb4b6bf34bfa204b91e9c7783" translate="yes" xml:space="preserve">
          <source>The semantics of this API resemble &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple&lt;/code&gt;&lt;/a&gt;. The first argument of the call to &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is the name of the enumeration.</source>
          <target state="translated">이 API의 시맨틱은 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple&lt;/code&gt; &lt;/a&gt; 과 유사 합니다. &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 호출의 첫 번째 인수는 열거 의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="070609838b02b470a8593f64b9dca1e4232bafbd" translate="yes" xml:space="preserve">
          <source>The separator to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 분리자는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a1f8c4e94dd9abb089388f1b1ab583d5c673046" translate="yes" xml:space="preserve">
          <source>The separator to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 구분 기호는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a15dc4df39babea8600cb0111121e4e21f2adba" translate="yes" xml:space="preserve">
          <source>The sequence</source>
          <target state="translated">순서</target>
        </trans-unit>
        <trans-unit id="82ce3ee65d071578dc915ee005e2223c40e5f9b4" translate="yes" xml:space="preserve">
          <source>The sequence has an undefined order. Use the &lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt;&lt;code&gt;Snapshot.statistics()&lt;/code&gt;&lt;/a&gt; method to get a sorted list of statistics.</source>
          <target state="translated">순서는 정의되지 않은 순서입니다. 정렬 된 통계 목록을 가져 오려면 &lt;a href=&quot;#tracemalloc.Snapshot.statistics&quot;&gt; &lt;code&gt;Snapshot.statistics()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e213b00d5ff7dbdcab5c0f7b3a984b54b08ecc6" translate="yes" xml:space="preserve">
          <source>The server classes support the following class variables:</source>
          <target state="translated">서버 클래스는 다음 클래스 변수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2786e902b7d48dcd206d583f8d5ed7f8b2845e8e" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the &lt;em&gt;from_addr&lt;/em&gt;.</source>
          <target state="translated">서버가 &lt;em&gt;from_addr을&lt;/em&gt; 승인하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="56dd79533db4c4efca4e68373ada164e963dde44" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t accept the username/password combination.</source>
          <target state="translated">서버가 사용자 이름 / 암호 조합을 수락하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="4911a0a87661df881e8634adaa418fd9f284c0c2" translate="yes" xml:space="preserve">
          <source>The server didn&amp;rsquo;t reply properly to the &lt;code&gt;HELO&lt;/code&gt; greeting.</source>
          <target state="translated">서버가 &lt;code&gt;HELO&lt;/code&gt; 인사말에 제대로 응답하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="5e0a6b36ffd22e5731e4b5053ab3b1d2dd12a232" translate="yes" xml:space="preserve">
          <source>The server does not support the STARTTLS extension.</source>
          <target state="translated">서버가 STARTTLS 확장을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69216622a0765e77ffc28455a50eaf3e224cceab" translate="yes" xml:space="preserve">
          <source>The server is closed asynchronously, use the &lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt;&lt;code&gt;wait_closed()&lt;/code&gt;&lt;/a&gt; coroutine to wait until the server is closed.</source>
          <target state="translated">서버가 비동기 적으로 닫힙니다. &lt;a href=&quot;#asyncio.Server.wait_closed&quot;&gt; &lt;code&gt;wait_closed()&lt;/code&gt; &lt;/a&gt; 코 루틴을 사용 하여 서버가 닫힐 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="24fe7057b721b26d1b1fa4ea7e7e689979456761" translate="yes" xml:space="preserve">
          <source>The server refused our &lt;code&gt;HELO&lt;/code&gt; message.</source>
          <target state="translated">서버가 &lt;code&gt;HELO&lt;/code&gt; 메시지를 거부했습니다 .</target>
        </trans-unit>
        <trans-unit id="fa1ff148e95189ffe6cc323c779c0d739606eede" translate="yes" xml:space="preserve">
          <source>The server replied with an unexpected error code (other than a refusal of a recipient).</source>
          <target state="translated">서버가 예기치 않은 오류 코드 (수신자 거부 제외)로 응답했습니다.</target>
        </trans-unit>
        <trans-unit id="34d989e84ddbda8dd5a139555512942415e2023b" translate="yes" xml:space="preserve">
          <source>The set of &lt;em&gt;accessible&lt;/em&gt; functions depends on what modules have been imported into the user process, including those imported by Idle itself, and what definitions have been run, all since the last restart.</source>
          <target state="translated">&lt;em&gt;액세스 가능한&lt;/em&gt; 기능 세트는 유휴 자체에서 가져온 모듈을 포함하여 사용자 프로세스로 가져온 모듈과 마지막 재시작 이후에 실행 된 정의에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="48c2643a6d821c9e78c60b17ecf9140e016a1333" translate="yes" xml:space="preserve">
          <source>The set of all exceptions (as a tuple) that methods of &lt;a href=&quot;#ftplib.FTP&quot;&gt;&lt;code&gt;FTP&lt;/code&gt;&lt;/a&gt; instances may raise as a result of problems with the FTP connection (as opposed to programming errors made by the caller). This set includes the four exceptions listed above as well as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">FTP 연결의 문제점으로 인해 호출자가 작성한 프로그래밍 오류가 아닌 &lt;a href=&quot;#ftplib.FTP&quot;&gt; &lt;code&gt;FTP&lt;/code&gt; &lt;/a&gt; 인스턴스의 메소드가 발생할 수 있는 모든 예외 세트 (튜플)입니다 . 이 세트에는 위에 나열된 네 가지 예외와 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="081bb73a699c6efaecd1c8a3d733213e189df822" translate="yes" xml:space="preserve">
          <source>The set of allowed values can be extended by registering a new named error handler:</source>
          <target state="translated">새로운 명명 된 오류 처리기를 등록하여 허용되는 값 집합을 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bdaaae3a7f0eacb814dd25f88847cfdd23e3933" translate="yes" xml:space="preserve">
          <source>The set of allowed values for the &lt;em&gt;errors&lt;/em&gt; argument can be extended with &lt;a href=&quot;#codecs.register_error&quot;&gt;&lt;code&gt;register_error()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;errors&lt;/em&gt; 인수 에 허용되는 값 세트는 &lt;a href=&quot;#codecs.register_error&quot;&gt; &lt;code&gt;register_error()&lt;/code&gt; &lt;/a&gt; 로 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e65a0797dbedaa6af76d1a9826a2a818a37cd72e" translate="yes" xml:space="preserve">
          <source>The settings are: &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt;&lt;code&gt;OP_NO_SSLv2&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt;&lt;code&gt;OP_NO_SSLv3&lt;/code&gt;&lt;/a&gt; with high encryption cipher suites without RC4 and without unauthenticated cipher suites. Passing &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt;&lt;code&gt;SERVER_AUTH&lt;/code&gt;&lt;/a&gt; as &lt;em&gt;purpose&lt;/em&gt; sets &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and either loads CA certificates (when at least one of &lt;em&gt;cafile&lt;/em&gt;, &lt;em&gt;capath&lt;/em&gt; or &lt;em&gt;cadata&lt;/em&gt; is given) or uses &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt; to load default CA certificates.</source>
          <target state="translated">설정은 RC4가없고 인증되지 않은 암호 스위트가없는 높은 암호화 암호 스위트가있는 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt; &lt;code&gt;OP_NO_SSLv2&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.OP_NO_SSLv3&quot;&gt; &lt;code&gt;OP_NO_SSLv3&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#ssl.Purpose.SERVER_AUTH&quot;&gt; &lt;code&gt;SERVER_AUTH&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;목적으로&lt;/em&gt; 전달하면 &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; 로&lt;/a&gt; 설정 하고 CA 인증서를로드하거나 ( &lt;em&gt;cafile&lt;/em&gt; , &lt;em&gt;capath&lt;/em&gt; 또는 &lt;em&gt;cadata&lt;/em&gt; 중 하나 이상 이 제공 될 때) &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 기본 CA 인증서를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="5cb18ec6e44e05a517a8cfdcf1bf458112bc1e30" translate="yes" xml:space="preserve">
          <source>The short form of the address representation, with leading zeroes in groups omitted and the longest sequence of groups consisting entirely of zeroes collapsed to a single empty group.</source>
          <target state="translated">그룹에서 선행 0을 생략하고 주소가 0으로 구성된 짧은 형식의 주소 표현은 완전히 0으로 구성되는 가장 긴 그룹 시퀀스가 ​​하나의 빈 그룹으로 축소되었습니다.</target>
        </trans-unit>
        <trans-unit id="f805bdc410d66fc8341d2186ebae9680f77ff29d" translate="yes" xml:space="preserve">
          <source>The sign of the result, if non-zero, is the same as that of the original dividend.</source>
          <target state="translated">0이 아닌 경우 결과의 부호는 원래 배당금의 부호와 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab3c6eb2972d1f89e19cb7d944ab96116d4e6c57" translate="yes" xml:space="preserve">
          <source>The sign should follow the value and currency symbol.</source>
          <target state="translated">부호는 값과 통화 기호를 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="70ec6f78774cba196da7610b04897fe7592363d5" translate="yes" xml:space="preserve">
          <source>The sign should immediately follow the value.</source>
          <target state="translated">부호는 즉시 값을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="919da334d12a2fc5f18dd4ceab7e1aada7a25231" translate="yes" xml:space="preserve">
          <source>The sign should immediately precede the value.</source>
          <target state="translated">부호는 값 바로 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="1ee0667d587bb1414e44874e7413805eb554c41c" translate="yes" xml:space="preserve">
          <source>The sign should precede the value and currency symbol.</source>
          <target state="translated">부호는 값과 통화 기호 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="7ea136642c5a17d8b5d39f8f1b4e4126da0bc289" translate="yes" xml:space="preserve">
          <source>The signal corresponding to the</source>
          <target state="translated">에 해당하는 신호</target>
        </trans-unit>
        <trans-unit id="fafae547732d3513c2c8c57b95879cfa52d4ca03" translate="yes" xml:space="preserve">
          <source>The signature of this function is dependent on what it calls. For example, the default binding (e.g. &lt;code&gt;pdb.set_trace()&lt;/code&gt;) expects no arguments, but you might bind it to a function that expects additional arguments (positional and/or keyword). The built-in &lt;code&gt;breakpoint()&lt;/code&gt; function passes its &lt;code&gt;*args&lt;/code&gt; and &lt;code&gt;**kws&lt;/code&gt; straight through. Whatever &lt;code&gt;breakpointhooks()&lt;/code&gt; returns is returned from &lt;code&gt;breakpoint()&lt;/code&gt;.</source>
          <target state="translated">이 함수의 서명은 그것이 호출하는 것에 의존합니다. 예를 들어, 기본 바인딩 (예 : &lt;code&gt;pdb.set_trace()&lt;/code&gt; )에는 인수가 필요하지 않지만 추가 인수 (위치 및 / 또는 키워드)가 필요한 함수에 바인딩 할 수 있습니다. 내장 된 &lt;code&gt;breakpoint()&lt;/code&gt; 함수는 &lt;code&gt;*args&lt;/code&gt; 및 &lt;code&gt;**kws&lt;/code&gt; 를 직선으로 전달합니다. 무엇이든 &lt;code&gt;breakpointhooks()&lt;/code&gt; 반환하는 것은에서 반환 &lt;code&gt;breakpoint()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a5369a3811941d7b19f88daec4a5ed4519eb65c" translate="yes" xml:space="preserve">
          <source>The signed zeros can result from calculations that underflow. They keep the sign that would have resulted if the calculation had been carried out to greater precision. Since their magnitude is zero, both positive and negative zeros are treated as equal and their sign is informational.</source>
          <target state="translated">부호가있는 0은 언더 플로 계산에서 발생할 수 있습니다. 그들은 계산이 더 정밀하게 수행되었을 때 발생했을 부호를 유지합니다. 크기가 0이므로 양수 및 음수 0은 동일하게 취급되며 부호는 정보 용입니다.</target>
        </trans-unit>
        <trans-unit id="b5a379b2046ce18280ecfda42b964c9631b600d9" translate="yes" xml:space="preserve">
          <source>The significance of a new Decimal is determined solely by the number of digits input. Context precision and rounding only come into play during arithmetic operations.</source>
          <target state="translated">새로운 Decimal의 중요성은 입력 한 자릿수에 의해서만 결정됩니다. 상황 정밀도와 반올림은 산술 연산 중에 만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5c480e405fd8149079611892ee8838388cee67f5" translate="yes" xml:space="preserve">
          <source>The simplest &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; subclass will simply implement a test method (i.e. a method whose name starts with &lt;code&gt;test&lt;/code&gt;) in order to perform specific testing code:</source>
          <target state="translated">가장 간단한 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 서브 클래스는 특정 테스트 코드를 수행하기 위해 단순히 테스트 메소드 (즉, 이름이 &lt;code&gt;test&lt;/code&gt; 로 시작하는 메소드)를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="6ef8da768f5e2727f7736cc3454383ef6bb831f4" translate="yes" xml:space="preserve">
          <source>The simplest example of reading a CSV file:</source>
          <target state="translated">CSV 파일을 읽는 가장 간단한 예 :</target>
        </trans-unit>
        <trans-unit id="9b3118dc14604e79ea95cac54e20a71a059c73c8" translate="yes" xml:space="preserve">
          <source>The simplest possible invocation is:</source>
          <target state="translated">가능한 가장 간단한 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a713cae0a63f36592c0cdcb2740d27248af6066e" translate="yes" xml:space="preserve">
          <source>The simplest text encoding (called &lt;code&gt;'latin-1'&lt;/code&gt; or &lt;code&gt;'iso-8859-1'&lt;/code&gt;) maps the code points 0&amp;ndash;255 to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;, which means that a string object that contains code points above &lt;code&gt;U+00FF&lt;/code&gt; can&amp;rsquo;t be encoded with this codec. Doing so will raise a &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt;&lt;code&gt;UnicodeEncodeError&lt;/code&gt;&lt;/a&gt; that looks like the following (although the details of the error message may differ): &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in
position 3: ordinal not in range(256)&lt;/code&gt;.</source>
          <target state="translated">가장 간단한 텍스트 인코딩 ( &lt;code&gt;'latin-1'&lt;/code&gt; 또는 &lt;code&gt;'iso-8859-1'&lt;/code&gt; )은 코드 포인트 0-255를 바이트 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; 에 매핑합니다. 즉, &lt;code&gt;U+00FF&lt;/code&gt; 보다 높은 코드 포인트를 포함하는 문자열 객체 는 ' 이 코덱으로 인코딩하지 마십시오. 이렇게하면 다음과 같은 &lt;a href=&quot;exceptions#UnicodeEncodeError&quot;&gt; &lt;code&gt;UnicodeEncodeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 (오류 메시지의 세부 사항이 다를 수 있음). &lt;code&gt;UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234' in position 3: ordinal not in range(256)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1521438669cce749a2e881659e485a36336dd6cd" translate="yes" xml:space="preserve">
          <source>The simplest way to make a mock raise an exception when called is to make &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; an exception class or instance:</source>
          <target state="translated">호출 될 때 모의가 예외를 발생시키는 가장 간단한 방법은 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 예외 클래스 또는 인스턴스 로 만드는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="881f0a260df9ba8efbf5efc927ddd30e7cae61c4" translate="yes" xml:space="preserve">
          <source>The simplest way to start using doctest (but not necessarily the way you&amp;rsquo;ll continue to do it) is to end each module &lt;code&gt;M&lt;/code&gt; with:</source>
          <target state="translated">doctest 사용을 시작하는 가장 간단한 방법은 (그러나 반드시 계속할 필요는 없음) 각 모듈 &lt;code&gt;M&lt;/code&gt; 을 다음과 같이 끝내는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="8b54b057c8ffc4d06da8fb7b215fbfa86896bff1" translate="yes" xml:space="preserve">
          <source>The single address encoded by the header value. If the header value actually contains more than one address (which would be a violation of the RFC under the default &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt;), accessing this attribute will result in a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">헤더 값으로 인코딩 된 단일 주소입니다. 헤더 값에 실제로 둘 이상의 주소가 포함 된 경우 (기본 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 에서 RFC 위반 )이 속성에 액세스하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="509bf276c918b44de715498fbc395a90c417d509" translate="yes" xml:space="preserve">
          <source>The size field (a 32-bit value, encoded using big-endian byte order) gives the size of the chunk data, not including the 8-byte header.</source>
          <target state="translated">크기 필드 (빅 엔디안 바이트 순서를 사용하여 인코딩 된 32 비트 값)는 8 바이트 헤더를 포함하지 않고 청크 데이터의 크기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e201cfab01f0ab4e9096a6984beacdf66e54219" translate="yes" xml:space="preserve">
          <source>The size in bytes of each element of the memoryview:</source>
          <target state="translated">memoryview의 각 요소의 크기 (바이트) :</target>
        </trans-unit>
        <trans-unit id="266d615bc372b351e64c4e77ca0efca9ec569184" translate="yes" xml:space="preserve">
          <source>The size of any &lt;em&gt;master&lt;/em&gt; widget is determined by the size of the &amp;ldquo;slave widgets&amp;rdquo; inside. The packer is used to control where slave widgets appear inside the master into which they are packed. You can pack widgets into frames, and frames into other frames, in order to achieve the kind of layout you desire. Additionally, the arrangement is dynamically adjusted to accommodate incremental changes to the configuration, once it is packed.</source>
          <target state="translated">임의의 크기 &lt;em&gt;주인&lt;/em&gt; 은 &quot;슬레이브 위젯&quot;내부의 크기에 의해 결정된다 위젯. 패커는 슬레이브 위젯이 패키징 된 마스터 내부에 표시되는 위치를 제어하는 ​​데 사용됩니다. 원하는 종류의 레이아웃을 얻기 위해 위젯을 프레임으로 묶고 다른 프레임으로 묶을 수 있습니다. 또한, 구성은 일단 포장되면 구성의 증분 변경을 수용하도록 동적으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="0ffb029747b436ca658b1039a56350ec7fac8bf4" translate="yes" xml:space="preserve">
          <source>The size of the buffer used when &lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt;&lt;code&gt;buffer_text&lt;/code&gt;&lt;/a&gt; is true. A new buffer size can be set by assigning a new integer value to this attribute. When the size is changed, the buffer will be flushed.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.xmlparser.buffer_text&quot;&gt; &lt;code&gt;buffer_text&lt;/code&gt; &lt;/a&gt; 가 true 일 때 사용되는 버퍼의 크기입니다 . 이 속성에 새로운 정수 값을 할당하여 새로운 버퍼 크기를 설정할 수 있습니다. 크기가 변경되면 버퍼가 플러시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae18b13f964bb5f503e73d7da58605cb96240f81" translate="yes" xml:space="preserve">
          <source>The size of the request queue. If it takes a long time to process a single request, any requests that arrive while the server is busy are placed into a queue, up to &lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt;&lt;code&gt;request_queue_size&lt;/code&gt;&lt;/a&gt; requests. Once the queue is full, further requests from clients will get a &amp;ldquo;Connection denied&amp;rdquo; error. The default value is usually 5, but this can be overridden by subclasses.</source>
          <target state="translated">요청 큐의 크기입니다. 단일 요청을 처리하는 데 시간이 오래 걸리면 서버가 사용 중일 때 도착한 모든 요청은 최대 &lt;a href=&quot;#socketserver.BaseServer.request_queue_size&quot;&gt; &lt;code&gt;request_queue_size&lt;/code&gt; &lt;/a&gt; 요청 까지 대기열에 배치됩니다 . 대기열이 가득 차면 클라이언트의 추가 요청에 &quot;연결 거부&quot;오류가 발생합니다. 기본값은 일반적으로 5이지만 서브 클래스로 대체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afeaf7758b49b0bcc1c2c4a7eb27cb9ef94f1147" translate="yes" xml:space="preserve">
          <source>The size of the resulting HMAC digest in bytes.</source>
          <target state="translated">결과 HMAC 다이제스트의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="13040a9b4dff3237ab2d730c7d05724f985824ba" translate="yes" xml:space="preserve">
          <source>The size of the resulting hash in bytes.</source>
          <target state="translated">결과 해시의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="b22005a99782de0058b087c6cd11f9d2f0afc9c5" translate="yes" xml:space="preserve">
          <source>The slash operator helps create child paths, similarly to &lt;a href=&quot;os.path#os.path.join&quot;&gt;&lt;code&gt;os.path.join()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">슬래시 연산자는 &lt;a href=&quot;os.path#os.path.join&quot;&gt; &lt;code&gt;os.path.join()&lt;/code&gt; &lt;/a&gt; 과 유사하게 하위 경로를 만드는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="57467a0e7d5bab9bfe84eafe9f1864e336216635" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; is defined as the sequence of items with index &lt;em&gt;k&lt;/em&gt; such that &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; is greater than &lt;code&gt;len(s)&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;0&lt;/code&gt;. If &lt;em&gt;j&lt;/em&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, use &lt;code&gt;len(s)&lt;/code&gt;. If &lt;em&gt;i&lt;/em&gt; is greater than or equal to &lt;em&gt;j&lt;/em&gt;, the slice is empty.</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; 에서 &lt;em&gt;j&lt;/em&gt; 까지 의 &lt;em&gt;s&lt;/em&gt; 슬라이스는 &lt;code&gt;i &amp;lt;= k &amp;lt; j&lt;/code&gt; 되도록 인덱스 &lt;em&gt;k&lt;/em&gt; 가있는 항목 시퀀스로 정의됩니다 . 경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J는&lt;/em&gt; 보다 큰 &lt;code&gt;len(s)&lt;/code&gt; , 사용하는 &lt;code&gt;len(s)&lt;/code&gt; . 경우 &lt;em&gt;i가&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; 사용할 &lt;code&gt;0&lt;/code&gt; . 경우 &lt;em&gt;J는&lt;/em&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; 사용할 &lt;code&gt;len(s)&lt;/code&gt; . 경우 &lt;em&gt;나&lt;/em&gt; 이상인 경우 &lt;em&gt;J&lt;/em&gt; 슬라이스는 비어있다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db14a0b504a58a7eab89d8facc7e4bc4aeddf239" translate="yes" xml:space="preserve">
          <source>The slice of &lt;em&gt;s&lt;/em&gt; from &lt;em&gt;i&lt;/em&gt; to &lt;em&gt;j&lt;/em&gt; with step &lt;em&gt;k&lt;/em&gt; is defined as the sequence of items with index &lt;code&gt;x = i + n*k&lt;/code&gt; such that &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt;. In other words, the indices are &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;i+k&lt;/code&gt;, &lt;code&gt;i+2*k&lt;/code&gt;, &lt;code&gt;i+3*k&lt;/code&gt; and so on, stopping when &lt;em&gt;j&lt;/em&gt; is reached (but never including &lt;em&gt;j&lt;/em&gt;). When &lt;em&gt;k&lt;/em&gt; is positive, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s)&lt;/code&gt; if they are greater. When &lt;em&gt;k&lt;/em&gt; is negative, &lt;em&gt;i&lt;/em&gt; and &lt;em&gt;j&lt;/em&gt; are reduced to &lt;code&gt;len(s) - 1&lt;/code&gt; if they are greater. If &lt;em&gt;i&lt;/em&gt; or &lt;em&gt;j&lt;/em&gt; are omitted or &lt;code&gt;None&lt;/code&gt;, they become &amp;ldquo;end&amp;rdquo; values (which end depends on the sign of &lt;em&gt;k&lt;/em&gt;). Note, &lt;em&gt;k&lt;/em&gt; cannot be zero. If &lt;em&gt;k&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, it is treated like &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">의 조각 &lt;em&gt;들&lt;/em&gt; 로부터 &lt;em&gt;I&lt;/em&gt; 까지 &lt;em&gt;J&lt;/em&gt; 단계와 &lt;em&gt;K는&lt;/em&gt; 인덱스 항목들의 시퀀스로 정의되고 &lt;code&gt;x = i + n*k&lt;/code&gt; 이되도록 &lt;code&gt;0 &amp;lt;= n &amp;lt; (j-i)/k&lt;/code&gt; . 즉, 인덱스는 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;i+k&lt;/code&gt; , &lt;code&gt;i+2*k&lt;/code&gt; , &lt;code&gt;i+3*k&lt;/code&gt; 때 등, 정지 &lt;em&gt;J가&lt;/em&gt; 도달 할 때 (하지만 결코 포함되지 &lt;em&gt;J&lt;/em&gt; ). 경우 &lt;em&gt;K는&lt;/em&gt; 양수, &lt;em&gt;I&lt;/em&gt; 및 &lt;em&gt;J는&lt;/em&gt; 감소된다 &lt;code&gt;len(s)&lt;/code&gt; 가 큰 경우. &lt;em&gt;K가&lt;/em&gt; 마이너스이고, &lt;em&gt;I&lt;/em&gt; 및 &lt;em&gt;J&lt;/em&gt;더 큰 경우 &lt;code&gt;len(s) - 1&lt;/code&gt; 로 줄어 듭니다 . 경우에 &lt;em&gt;I&lt;/em&gt; 또는 &lt;em&gt;J가&lt;/em&gt; 생략되어 있거나 &lt;code&gt;None&lt;/code&gt; , 그들은 &quot;END&quot;값 (의 부호에 의존하는 단부가 &lt;em&gt;K&lt;/em&gt; ). 참고 &lt;em&gt;k는&lt;/em&gt; 제로가 될 수 없습니다. 경우 &lt;em&gt;K가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 이를처럼 취급 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afdb447ab4240dc7c528e0d82c283987648888fa" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 의 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="90720b6f330c793f876d3bf1fd81961094e9877c" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;, although note that arithmetic on &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects is not supported.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 인 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 가능한 가장 작은 차이는 있지만 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 에 대한 산술 은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="afa9031721d8fc24f5ec4d17be75903371aa9acc" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; objects, &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 객체 &lt;code&gt;timedelta(microseconds=1)&lt;/code&gt; 가능한 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="a8b267b31e001c792ef50cc23ab663368acac284" translate="yes" xml:space="preserve">
          <source>The smallest possible difference between non-equal date objects, &lt;code&gt;timedelta(days=1)&lt;/code&gt;.</source>
          <target state="translated">같지 않은 날짜 객체 인 &lt;code&gt;timedelta(days=1)&lt;/code&gt; 가능한 가장 작은 차이 입니다.</target>
        </trans-unit>
        <trans-unit id="0564cff39070c9ab1eb076afb4a73ed5e6110583" translate="yes" xml:space="preserve">
          <source>The smallest year number allowed in a &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object. &lt;a href=&quot;#datetime.MINYEAR&quot;&gt;&lt;code&gt;MINYEAR&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 개체에 허용되는 가장 작은 연도 번호 입니다. &lt;a href=&quot;#datetime.MINYEAR&quot;&gt; &lt;code&gt;MINYEAR&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac827978185abe9e1d5f1031d46773536abfd304" translate="yes" xml:space="preserve">
          <source>The snapshot does not include memory blocks allocated before the &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module started to trace memory allocations.</source>
          <target state="translated">&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; &lt;/a&gt; 모듈이 메모리 할당 추적을 시작 하기 전에 할당 된 메모리 블록은 스냅 샷에 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3518947197e510fbdae4f25cd9160d2281238301" translate="yes" xml:space="preserve">
          <source>The so-called CSV (Comma Separated Values) format is the most common import and export format for spreadsheets and databases. CSV format was used for many years prior to attempts to describe the format in a standardized way in &lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt;. The lack of a well-defined standard means that subtle differences often exist in the data produced and consumed by different applications. These differences can make it annoying to process CSV files from multiple sources. Still, while the delimiters and quoting characters vary, the overall format is similar enough that it is possible to write a single module which can efficiently manipulate such data, hiding the details of reading and writing the data from the programmer.</source>
          <target state="translated">이른바 CSV (쉼표로 구분 된 값) 형식은 스프레드 시트 및 데이터베이스에 가장 일반적인 가져 오기 및 내보내기 형식입니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc4180.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 4180&lt;/strong&gt;&lt;/a&gt; 에서 표준화 된 형식으로 형식을 설명하기 전에 수년 동안 CSV 형식이 사용되었습니다 . 잘 정의 된 표준이 없다는 것은 서로 다른 응용 프로그램에서 생성하고 소비하는 데이터에 미묘한 차이가 있음을 의미합니다. 이러한 차이로 인해 여러 소스에서 CSV 파일을 처리하는 것이 성 가실 수 있습니다. 그럼에도 불구하고 구분 기호와 인용 문자는 다양하지만 전체 형식은 프로그래머가 데이터를 읽고 쓰는 세부 정보를 숨기고 이러한 데이터를 효율적으로 조작 할 수있는 단일 모듈을 작성할 수있을 정도로 유사합니다.</target>
        </trans-unit>
        <trans-unit id="b36cc9ba1945c3f902c1340bc4df70ac928ebe63" translate="yes" xml:space="preserve">
          <source>The socket always appears &amp;lsquo;ready&amp;rsquo; and excess packets are dropped. An &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;errno&lt;/code&gt; set to &lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt;&lt;code&gt;errno.ENOBUFS&lt;/code&gt;&lt;/a&gt; may or may not be raised; if it is raised, it will be reported to &lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt;&lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt;&lt;/a&gt; but otherwise ignored.</source>
          <target state="translated">소켓은 항상 '준비'로 나타나고 초과 패킷이 삭제됩니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;errno&lt;/code&gt; 를 로 설정 &lt;a href=&quot;errno#errno.ENOBUFS&quot;&gt; &lt;code&gt;errno.ENOBUFS&lt;/code&gt; 는&lt;/a&gt; 또는 제기되지 않을 수있다 발생하면 &lt;a href=&quot;#asyncio.DatagramProtocol.error_received&quot;&gt; &lt;code&gt;DatagramProtocol.error_received()&lt;/code&gt; &lt;/a&gt; 에보고 되지만 그렇지 않으면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="580375be802eccfa86b27c314a834daee2716ca5" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt; depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">소켓 패밀리는 &lt;em&gt;호스트&lt;/em&gt; (또는 제공된 경우 &lt;em&gt;패밀리&lt;/em&gt; 인수) 에 따라 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fb23c07f91f47b0410aeac381022de5cc7bbffa6" translate="yes" xml:space="preserve">
          <source>The socket family can be either &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;, depending on &lt;em&gt;host&lt;/em&gt; (or the &lt;em&gt;family&lt;/em&gt; argument, if provided).</source>
          <target state="translated">소켓 패밀리는 &lt;em&gt;호스트&lt;/em&gt; (또는 제공된 경우 &lt;em&gt;패밀리&lt;/em&gt; 인수) 에 따라 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;socket#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07fedf17c5be40a26d98bb4e876e8380b9555b75" translate="yes" xml:space="preserve">
          <source>The socket family will be &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt;; socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 패밀리는 &lt;a href=&quot;socket#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; 입니다&lt;/a&gt; . 소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b011b1d05810914e76faef6742cb676cbb631c4d" translate="yes" xml:space="preserve">
          <source>The socket family.</source>
          <target state="translated">소켓 패밀리</target>
        </trans-unit>
        <trans-unit id="9d7aba26239da54cf438e8cc238babf966b10025" translate="yes" xml:space="preserve">
          <source>The socket must be bound to an address and listening for connections. The return value is a pair &lt;code&gt;(conn, address)&lt;/code&gt; where &lt;em&gt;conn&lt;/em&gt; is a &lt;em&gt;new&lt;/em&gt; socket object usable to send and receive data on the connection, and &lt;em&gt;address&lt;/em&gt; is the address bound to the socket on the other end of the connection.</source>
          <target state="translated">소켓은 주소에 연결되어 있고 연결을 수신 대기해야합니다. 리턴 값은 쌍 &lt;code&gt;(conn, address)&lt;/code&gt; 이며, &lt;em&gt;conn&lt;/em&gt; 은 연결에서 데이터를 송수신하는 데 사용할 수 있는 &lt;em&gt;새&lt;/em&gt; 소켓 오브젝트이며 &lt;em&gt;address&lt;/em&gt; 는 연결 의 다른 쪽 끝에있는 소켓에 바인드 된 &lt;em&gt;주소&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="638e4e32be2380339f29cabd9e12ac1b0fe0dcf2" translate="yes" xml:space="preserve">
          <source>The socket must be in blocking mode; it can have a timeout, but the file object&amp;rsquo;s internal buffer may end up in an inconsistent state if a timeout occurs.</source>
          <target state="translated">소켓은 차단 모드에 있어야합니다. 시간 초과가있을 수 있지만 시간 초과가 발생하면 파일 객체의 내부 버퍼가 일관성이없는 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d9b4b9003d10f23e4489c6bcfd88b97fc92ec67" translate="yes" xml:space="preserve">
          <source>The socket object on which the server will listen for incoming requests.</source>
          <target state="translated">서버가 들어오는 요청을 청취 할 소켓 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="26023ee861897f5dc0dfc453c9dcce20c871b174" translate="yes" xml:space="preserve">
          <source>The socket protocol.</source>
          <target state="translated">소켓 프로토콜.</target>
        </trans-unit>
        <trans-unit id="e2c94f7721fba4bae8a8259834b5d12fe4ec41fc" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4389e8f1de40e8b0d84b0639d44300ab08f5992c" translate="yes" xml:space="preserve">
          <source>The socket type will be &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">소켓 유형은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="76aee9ff5ed1acb81a710cf6c05b57b815c4d8f6" translate="yes" xml:space="preserve">
          <source>The socket type.</source>
          <target state="translated">소켓 타입.</target>
        </trans-unit>
        <trans-unit id="887f45826cd1154d00bb13afc1d5d24e35e6e8ea" translate="yes" xml:space="preserve">
          <source>The sockets that represent existing incoming client connections are left open.</source>
          <target state="translated">기존 수신 클라이언트 연결을 나타내는 소켓이 열려 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa5477e7dba26b484b00fa654ca357c05ecf60e" translate="yes" xml:space="preserve">
          <source>The sole value of the type &lt;code&gt;NoneType&lt;/code&gt;. &lt;code&gt;None&lt;/code&gt; is frequently used to represent the absence of a value, as when default arguments are not passed to a function. Assignments to &lt;code&gt;None&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;NoneType&lt;/code&gt; 유형의 유일한 값입니다 . 기본 인수가 함수에 전달되지 않을 때와 같이 &lt;code&gt;None&lt;/code&gt; 은 값이 없음 을 나타내는 데 자주 사용됩니다. &lt;code&gt;None&lt;/code&gt; 으로의 할당 은 불법이며 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="85af829c0490dff673d58821b4d8b8d4f6478909" translate="yes" xml:space="preserve">
          <source>The solution is either to increase precision or to force rounding of inputs using the unary plus operation:</source>
          <target state="translated">해결책은 단항 더하기 연산을 사용하여 정밀도를 높이거나 입력 반올림을 강제하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="07e7971104c97772932547de9d78450a15b11c66" translate="yes" xml:space="preserve">
          <source>The solution is safe but it has a significant overhead when handling a big number of processes (&lt;em&gt;O(n)&lt;/em&gt; each time a &lt;code&gt;SIGCHLD&lt;/code&gt; is received).</source>
          <target state="translated">솔루션은 안전하지만 많은 프로세스를 처리 할 때 상당한 오버 헤드가 있습니다 ( &lt;code&gt;SIGCHLD&lt;/code&gt; 가 수신 될 때마다 &lt;em&gt;O (n)&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="d4ae167e2456ec13e75cf55d1b00b0bdde55b895" translate="yes" xml:space="preserve">
          <source>The solution is to use Python&amp;rsquo;s raw string notation for regular expression patterns; backslashes are not handled in any special way in a string literal prefixed with &lt;code&gt;'r'&lt;/code&gt;. So &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; is a two-character string containing &lt;code&gt;'\'&lt;/code&gt; and &lt;code&gt;'n'&lt;/code&gt;, while &lt;code&gt;&quot;\n&quot;&lt;/code&gt; is a one-character string containing a newline. Usually patterns will be expressed in Python code using this raw string notation.</source>
          <target state="translated">해결책은 정규 표현식 패턴에 Python의 원시 문자열 표기법을 사용하는 것입니다. 백 슬래시는 &lt;code&gt;'r'&lt;/code&gt; 접두사가 붙은 문자열 리터럴에서 특별한 방식으로 처리되지 않습니다 . 따라서 &lt;code&gt;r&quot;\n&quot;&lt;/code&gt; 은 &lt;code&gt;'\'&lt;/code&gt; 및 &lt;code&gt;'n'&lt;/code&gt; 을 포함하는 두 문자 문자열 이고 &lt;code&gt;&quot;\n&quot;&lt;/code&gt; 은 줄 바꾸기를 포함하는 한 문자 문자열입니다. 일반적으로 패턴은이 원시 문자열 표기법을 사용하여 Python 코드로 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="630211a218ed284023e80ddd9d174a4ffb85cd53" translate="yes" xml:space="preserve">
          <source>The source code for &lt;code&gt;asyncio.run()&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib/asyncio/runners.py&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;asyncio.run()&lt;/code&gt; 의 소스 코드 는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/runners.py&quot;&gt;Lib / asyncio / runners.py&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20ad04c27726a886512a55970c3c9a2ccf70d8b8" translate="yes" xml:space="preserve">
          <source>The source code for &lt;code&gt;asyncio.run()&lt;/code&gt; can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/runners.py&quot;&gt;Lib/asyncio/runners.py&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;asyncio.run()&lt;/code&gt; 의 소스 코드 는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/runners.py&quot;&gt;Lib / asyncio / runners.py&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b7c7008356b1938d975233f6572bb32b9d0c6037" translate="yes" xml:space="preserve">
          <source>The source code for asyncio can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib/asyncio/&lt;/a&gt;.</source>
          <target state="translated">asyncio의 소스 코드는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/&quot;&gt;Lib / asyncio /&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cfde801a2f8277858a1333b9a5702f14671cb49a" translate="yes" xml:space="preserve">
          <source>The source code for asyncio can be found in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/&quot;&gt;Lib/asyncio/&lt;/a&gt;.</source>
          <target state="translated">asyncio의 소스 코드는 &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/&quot;&gt;Lib / asyncio /&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4afea0ea275bb3d4fffc9ec00b2df6d074be239a" translate="yes" xml:space="preserve">
          <source>The sp_namp and sp_pwdp items are strings, all others are integers. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">sp_namp 및 sp_pwdp 항목은 문자열이고 다른 항목은 모두 정수입니다. 요청한 항목을 찾을 수 없으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3d8373511020db5acc21c29f54afacf07efb1307" translate="yes" xml:space="preserve">
          <source>The spec also applies to instantiated classes (i.e. the return value of specced mocks):</source>
          <target state="translated">이 스펙은 인스턴스화 된 클래스 (즉, 지정된 모의 반환 값)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="958f1bbb6de4a402e06c21a9ae860adbb3f32eb3" translate="yes" xml:space="preserve">
          <source>The spec only applies to the mock itself, so we still have the same issue with any methods on the mock:</source>
          <target state="translated">이 스펙은 모의 자체에만 적용되므로 모의 메소드와 관련하여 여전히 동일한 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10e3e2928198f4f7fc663290ec0cccc17419f3f" translate="yes" xml:space="preserve">
          <source>The special attribute &lt;code&gt;__members__&lt;/code&gt; is a read-only ordered mapping of names to members. It includes all names defined in the enumeration, including the aliases:</source>
          <target state="translated">특수 속성 &lt;code&gt;__members__&lt;/code&gt; 는 이름을 멤버에 읽기 전용 순서로 매핑 한 것입니다. 별명을 포함하여 열거에 정의 된 모든 이름이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="e8125b61331573562956037df84be471f1f84f34" translate="yes" xml:space="preserve">
          <source>The special behaviour of the console can be overridden by setting the environment variable PYTHONLEGACYWINDOWSSTDIO before starting Python. In that case, the console codepages are used as for any other character device.</source>
          <target state="translated">Python을 시작하기 전에 환경 변수 PYTHONLEGACYWINDOWSSTDIO를 설정하여 콘솔의 특수 동작을 무시할 수 있습니다. 이 경우 콘솔 코드 페이지는 다른 문자 장치처럼 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d6872f052fa8d0d34b453f09198a77148fe33e51" translate="yes" xml:space="preserve">
          <source>The special characters are:</source>
          <target state="translated">특수 문자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7a5ee27573a32396d3ae3dc89046e9d91aa80669" translate="yes" xml:space="preserve">
          <source>The special global variables &lt;code&gt;__name__&lt;/code&gt;, &lt;code&gt;__spec__&lt;/code&gt;, &lt;code&gt;__file__&lt;/code&gt;, &lt;code&gt;__cached__&lt;/code&gt;, &lt;code&gt;__loader__&lt;/code&gt; and &lt;code&gt;__package__&lt;/code&gt; are set in the globals dictionary before the module code is executed (Note that this is a minimal set of variables - other variables may be set implicitly as an interpreter implementation detail).</source>
          <target state="translated">특수 전역 변수 &lt;code&gt;__name__&lt;/code&gt; , &lt;code&gt;__spec__&lt;/code&gt; , &lt;code&gt;__file__&lt;/code&gt; , &lt;code&gt;__cached__&lt;/code&gt; , &lt;code&gt;__loader__&lt;/code&gt; 및 &lt;code&gt;__package__&lt;/code&gt; 는 모듈 코드가 실행되기 전에 전역 사전에 설정됩니다 (이것은 최소 변수 집합입니다. 다른 변수는 해석기 구현 세부 사항으로 암시 적으로 설정 될 수 있습니다) .</target>
        </trans-unit>
        <trans-unit id="9467123089d6aa38d3e2e72ebf08b05d73247208" translate="yes" xml:space="preserve">
          <source>The special sequences consist of &lt;code&gt;'\'&lt;/code&gt; and a character from the list below. If the ordinary character is not an ASCII digit or an ASCII letter, then the resulting RE will match the second character. For example, &lt;code&gt;\$&lt;/code&gt; matches the character &lt;code&gt;'$'&lt;/code&gt;.</source>
          <target state="translated">특수 시퀀스는 &lt;code&gt;'\'&lt;/code&gt; 와 아래 목록의 문자 로 구성 됩니다. 일반 문자가 ASCII 숫자 나 ASCII 문자가 아닌 경우 결과 RE는 두 번째 문자와 일치합니다. 예를 들어, &lt;code&gt;\$&lt;/code&gt; 는 문자 &lt;code&gt;'$'&lt;/code&gt; 와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1dcbe5116b95cd6dc7867c87774d04cf7173a3e1" translate="yes" xml:space="preserve">
          <source>The specific resources that can be limited are system dependent. They are described in the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit(2)&lt;/a&gt;&lt;/em&gt; man page. The resources listed below are supported when the underlying operating system supports them; resources which cannot be checked or controlled by the operating system are not defined in this module for those platforms.</source>
          <target state="translated">제한 될 수있는 특정 리소스는 시스템에 따라 다릅니다. &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/getrlimit(2)&quot;&gt;getrlimit (2)&lt;/a&gt;&lt;/em&gt; 매뉴얼 페이지에 설명되어 있습니다. 아래에 나열된 리소스는 기본 운영 체제에서 지원할 때 지원됩니다. 운영 체제에서 점검하거나 제어 할 수없는 자원은 해당 플랫폼에 대해이 모듈에서 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="679e621b066d4106ebdb3517733d1d8a6e844edc" translate="yes" xml:space="preserve">
          <source>The specification of the original Netscape cookie protocol. Though this is still the dominant protocol, the &amp;lsquo;Netscape cookie protocol&amp;rsquo; implemented by all the major browsers (and &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt;) only bears a passing resemblance to the one sketched out in &lt;code&gt;cookie_spec.html&lt;/code&gt;.</source>
          <target state="translated">원래 Netscape 쿠키 프로토콜의 사양. 이것이 여전히 지배적 인 프로토콜이지만 모든 주요 브라우저 (및 &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; )에 의해 구현 된 'Netscape 쿠키 프로토콜' 은 &lt;code&gt;cookie_spec.html&lt;/code&gt; 에 스케치 된 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a5ef525a4f38d6c8baa2c8948ff2da032e2bfc" translate="yes" xml:space="preserve">
          <source>The specification provided by the W3C defines the DOM API for Java, ECMAScript, and OMG IDL. The Python mapping defined here is based in large part on the IDL version of the specification, but strict compliance is not required (though implementations are free to support the strict mapping from IDL). See section &lt;a href=&quot;#dom-conformance&quot;&gt;Conformance&lt;/a&gt; for a detailed discussion of mapping requirements.</source>
          <target state="translated">W3C에서 제공하는 사양은 Java, ECMAScript 및 OMG IDL 용 DOM API를 정의합니다. 여기에 정의 된 Python 매핑은 대부분 IDL 버전 사양을 기반으로하지만 엄격한 준수는 필요하지 않습니다 (구현은 IDL의 엄격한 매핑을 자유롭게 지원할 수 있음). 매핑 요구 사항에 대한 자세한 내용은 &lt;a href=&quot;#dom-conformance&quot;&gt;적합성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5a54865c96e9fc0cf2ce3bd609a52643dbb3a5d" translate="yes" xml:space="preserve">
          <source>The specification, background, and examples for the Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 대한 사양, 배경 및 예</target>
        </trans-unit>
        <trans-unit id="0dbc88255d5b29447d25f2517106794b852b1e4a" translate="yes" xml:space="preserve">
          <source>The specification, background, and examples for the Python &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 대한 사양, 배경 및 예제입니다 .</target>
        </trans-unit>
        <trans-unit id="d53ba21dee295896d8c0fc9de128483f4c1f4d26" translate="yes" xml:space="preserve">
          <source>The specified loggers will be configured according to the level, propagation, filters and handlers specified.</source>
          <target state="translated">지정된 로거는 지정된 레벨, 전파, 필터 및 핸들러에 따라 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="e0612ec14e7221d85b8658075b6926be56ede2bc" translate="yes" xml:space="preserve">
          <source>The specifier &lt;em&gt;name&lt;/em&gt; is a &amp;ldquo;dotted name&amp;rdquo; that may resolve either to a module, a test case class, a test method within a test case class, a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance, or a callable object which returns a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; instance. These checks are applied in the order listed here; that is, a method on a possible test case class will be picked up as &amp;ldquo;a test method within a test case class&amp;rdquo;, rather than &amp;ldquo;a callable object&amp;rdquo;.</source>
          <target state="translated">지정자 &lt;em&gt;이름&lt;/em&gt; 은 모듈, 테스트 케이스 클래스, 테스트 케이스 클래스 내의 테스트 메소드, &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 또는 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 를 리턴하는 호출 가능 오브젝트로 해석 될 수있는 &quot;점 이름&quot;입니다 . 이러한 점검은 여기에 나열된 순서대로 적용됩니다. 즉, 가능한 테스트 케이스 클래스의 메소드는 &quot;호출 가능한 오브젝트&quot;가 아닌 &quot;테스트 케이스 클래스 내의 테스트 메소드&quot;로 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="8327e74724788e9fd23faafae57d70e63b944955" translate="yes" xml:space="preserve">
          <source>The spinbox widget generates an &lt;strong&gt;&amp;lt;&amp;lt;Increment&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Up&amp;gt;, and a &lt;strong&gt;&amp;lt;&amp;lt;Decrement&amp;gt;&amp;gt;&lt;/strong&gt; virtual event when the user presses &amp;lt;Down&amp;gt;.</source>
          <target state="translated">스핀 박스 위젯 은 사용자가 &amp;lt;Up&amp;gt;을 누르면 &lt;strong&gt;&amp;lt;&amp;lt; Increment &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성 하고 사용자가 &amp;lt;Down&amp;gt;을 누르면 &lt;strong&gt;&amp;lt;&amp;lt; Decrement &amp;gt;&amp;gt;&lt;/strong&gt; 가상 이벤트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="51a445c74beda03ed7a0326a9352f92f1dd4d706" translate="yes" xml:space="preserve">
          <source>The sqlite3 module is not built with loadable extension support by default, because some platforms (notably Mac OS X) have SQLite libraries which are compiled without this feature. To get loadable extension support, you must pass &amp;ndash;enable-loadable-sqlite-extensions to configure.</source>
          <target state="translated">일부 플랫폼 (특히 Mac OS X)에는이 기능없이 컴파일 된 SQLite 라이브러리가 있기 때문에 sqlite3 모듈은 기본적으로로드 가능한 확장 지원 기능으로 빌드되지 않습니다. 로드 가능한 확장 지원을 받으려면 &amp;ndash;enable-loadable-sqlite-extensions를 전달하여 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="2c357cdf2607bac2f5dbe1953aebb35c44af932e" translate="yes" xml:space="preserve">
          <source>The sqlite3 module was written by Gerhard H&amp;auml;ring. It provides a SQL interface compliant with the DB-API 2.0 specification described by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">sqlite3 모듈은 Gerhard H&amp;auml;ring이 작성했습니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0249&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 249에&lt;/strong&gt;&lt;/a&gt; 설명 된 DB-API 2.0 사양을 준수하는 SQL 인터페이스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="bac169ab637e97d8d04b333be4d5b9e88d67748b" translate="yes" xml:space="preserve">
          <source>The standalone backport of this module provides more information on &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;using importlib.resources&lt;/a&gt; and &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;migrating from pkg_resources to importlib.resources&lt;/a&gt;.</source>
          <target state="translated">이 모듈의 독립형 백 포트는 &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;importlib.resources 사용&lt;/a&gt; 및 &lt;a href=&quot;http://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;pkg_resources에서 importlib.resources로 마이그레이션&lt;/a&gt; 에 대한 자세한 정보를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="06778d950dffa2e34c723ac6c1722f494998929c" translate="yes" xml:space="preserve">
          <source>The standalone backport of this module provides more information on &lt;a href=&quot;https://importlib-resources.readthedocs.io/en/latest/using.html&quot;&gt;using importlib.resources&lt;/a&gt; and &lt;a href=&quot;https://importlib-resources.readthedocs.io/en/latest/migration.html&quot;&gt;migrating from pkg_resources to importlib.resources&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b77674a95bf51acfb62957a46af0656c170047b7" translate="yes" xml:space="preserve">
          <source>The standard Python IMAP module.</source>
          <target state="translated">표준 Python IMAP 모듈.</target>
        </trans-unit>
        <trans-unit id="68889788aae8ae70cfc40e3231e1f8e78cb10352" translate="yes" xml:space="preserve">
          <source>The standard X cursor names from &lt;code&gt;cursorfont.h&lt;/code&gt; can be used, without the &lt;code&gt;XC_&lt;/code&gt; prefix. For example to get a hand cursor (&lt;code&gt;XC_hand2&lt;/code&gt;), use the string &lt;code&gt;&quot;hand2&quot;&lt;/code&gt;. You can also specify a bitmap and mask file of your own. See page 179 of Ousterhout&amp;rsquo;s book.</source>
          <target state="translated">에서 표준 X 커서 이름 &lt;code&gt;cursorfont.h&lt;/code&gt; 이 를 빼고, 사용할 수 &lt;code&gt;XC_&lt;/code&gt; 의 접두사. 예를 들어 손 모양 커서 ( &lt;code&gt;XC_hand2&lt;/code&gt; ) 를 얻으려면 &lt;code&gt;&quot;hand2&quot;&lt;/code&gt; 문자열을 사용하십시오 . 자신 만의 비트 맵 및 마스크 파일을 지정할 수도 있습니다. Ousterhout의 179 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="48c570e26b992a39c9c6ac01d765d07ba873d695" translate="yes" xml:space="preserve">
          <source>The standard error device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">표준 오류 장치 처음에는 활성 콘솔 화면 버퍼 인 &lt;code&gt;CONOUT$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="838902f3ab46b04d98965c4728b7b35218852253" translate="yes" xml:space="preserve">
          <source>The standard format of the &lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; environment variable is (whitespace added for clarity):</source>
          <target state="translated">&lt;code id=&quot;index-17&quot;&gt;TZ&lt;/code&gt; 환경 변수 의 표준 형식은 다음 과 같습니다 (명 백성을 위해 추가 된 공백).</target>
        </trans-unit>
        <trans-unit id="cb7f906caa68565a322b0c38155c9958a70af129" translate="yes" xml:space="preserve">
          <source>The standard input device. Initially, this is the console input buffer, &lt;code&gt;CONIN$&lt;/code&gt;.</source>
          <target state="translated">표준 입력 장치 처음에는 콘솔 입력 버퍼 인 &lt;code&gt;CONIN$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9fe9bf76be36079397d2cae51a3b2aece1a0ca0" translate="yes" xml:space="preserve">
          <source>The standard module &lt;a href=&quot;stat#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; defines functions and constants that are useful for extracting information from a &lt;code&gt;stat&lt;/code&gt; structure. (On Windows, some items are filled with dummy values.)</source>
          <target state="translated">표준 모듈 &lt;a href=&quot;stat#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;stat&lt;/code&gt; 구조 에서 정보를 추출하는 데 유용한 함수와 상수를 정의합니다 . (Windows에서는 일부 항목이 더미 값으로 채워집니다.)</target>
        </trans-unit>
        <trans-unit id="6cdc8bfcbf49383bc1e73500c1b4de14a0e0fed5" translate="yes" xml:space="preserve">
          <source>The standard output and standard error streams are buffered during the test run. Output during a passing test is discarded. Output is echoed normally on test fail or error and is added to the failure messages.</source>
          <target state="translated">표준 출력 및 표준 오류 스트림은 테스트 실행 중에 버퍼링됩니다. 통과 테스트 중 출력이 삭제됩니다. 테스트 실패 또는 오류시 출력이 정상적으로 에코되고 실패 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7cf066e8af540cf727db7cac24accf30ce076f" translate="yes" xml:space="preserve">
          <source>The standard output device. Initially, this is the active console screen buffer, &lt;code&gt;CONOUT$&lt;/code&gt;.</source>
          <target state="translated">표준 출력 장치 처음에는 활성 콘솔 화면 버퍼 인 &lt;code&gt;CONOUT$&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bedde387bc6937840daa67ab375a6cae23a47eb7" translate="yes" xml:space="preserve">
          <source>The standard way to exit is &lt;code&gt;sys.exit(n)&lt;/code&gt;. &lt;a href=&quot;#os._exit&quot;&gt;&lt;code&gt;_exit()&lt;/code&gt;&lt;/a&gt; should normally only be used in the child process after a &lt;a href=&quot;#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">종료하는 표준 방법은 &lt;code&gt;sys.exit(n)&lt;/code&gt; 입니다. &lt;a href=&quot;#os._exit&quot;&gt; &lt;code&gt;_exit()&lt;/code&gt; &lt;/a&gt; 은 일반적으로 &lt;a href=&quot;#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 다음의 자식 프로세스에서만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a3ee6195d1060ec2a3f2616df734ae62aafdf49e" translate="yes" xml:space="preserve">
          <source>The standard way to open files for reading and writing with Python.</source>
          <target state="translated">파이썬으로 읽고 쓰는 파일을 여는 표준 방법.</target>
        </trans-unit>
        <trans-unit id="68d5384e54c19f936c634b6d988aedf31c295bf3" translate="yes" xml:space="preserve">
          <source>The start index of &lt;em&gt;doc&lt;/em&gt; where parsing failed.</source>
          <target state="translated">구문 분석에 실패한 &lt;em&gt;doc&lt;/em&gt; 의 시작 색인입니다 .</target>
        </trans-unit>
        <trans-unit id="85b13200690d7aa62326c7849f57cc6925206c71" translate="yes" xml:space="preserve">
          <source>The starting column doesn&amp;rsquo;t matter:</source>
          <target state="translated">시작 열은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de2b727684bc631a4d8eca489abadd7633848760" translate="yes" xml:space="preserve">
          <source>The stateless encoding and decoding functions. These must be functions or methods which have the same interface as the &lt;a href=&quot;#codecs.Codec.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.Codec.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; methods of Codec instances (see &lt;a href=&quot;#codec-objects&quot;&gt;Codec Interface&lt;/a&gt;). The functions or methods are expected to work in a stateless mode.</source>
          <target state="translated">상태 비 저장 인코딩 및 디코딩 기능. 이들은 코덱 인스턴스 의 &lt;a href=&quot;#codecs.Codec.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.Codec.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 인터페이스를 가진 함수 또는 메소드 여야합니다 ( &lt;a href=&quot;#codec-objects&quot;&gt;코덱 인터페이스&lt;/a&gt; 참조 ). 함수 또는 메소드는 상태 비 저장 모드에서 작동 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="fc37fae53ad3d2cf8bbbb3fbc6970158d324b500" translate="yes" xml:space="preserve">
          <source>The statement &lt;code&gt;import spam.ham&lt;/code&gt; results in this call:</source>
          <target state="translated">&lt;code&gt;import spam.ham&lt;/code&gt; 문 은 다음 호출을 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="57343ca400818c99d89cc954bac7f25bd563f12b" translate="yes" xml:space="preserve">
          <source>The statement:</source>
          <target state="translated">진술 :</target>
        </trans-unit>
        <trans-unit id="5f7f5bd7cdc067527c840f51d511b9f3a881789d" translate="yes" xml:space="preserve">
          <source>The static type checker will treat the new type as if it were a subclass of the original type. This is useful in helping catch logical errors:</source>
          <target state="translated">정적 유형 검사기는 새 유형을 원래 유형의 서브 클래스 인 것처럼 취급합니다. 이것은 논리적 오류를 포착하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="acb7f81b54e59ac66887405065b4bf032855f1db" translate="yes" xml:space="preserve">
          <source>The stdlib implementation is based on &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; module. It was written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt; based on C implementation written by &lt;em&gt;Samuel Neves&lt;/em&gt;. The documentation was copied from &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; and written by &lt;em&gt;Dmitry Chestnykh&lt;/em&gt;.</source>
          <target state="translated">stdlib 구현은 &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; 모듈을 기반으로 합니다. &lt;em&gt;Samuel Neves가&lt;/em&gt; 작성한 C 구현을 기반으로 &lt;em&gt;Dmitry Chestnykh&lt;/em&gt; 가 작성했습니다 . 이 문서는 &lt;a href=&quot;https://pythonhosted.org/pyblake2/&quot;&gt;pyblake2&lt;/a&gt; 에서 복사 되었으며 &lt;em&gt;Dmitry Chestnykh가&lt;/em&gt; 작성했습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a6771d7c766fdf223fc75b578682b8b43ecb7225" translate="yes" xml:space="preserve">
          <source>The steps to create a standalone archive are as follows:</source>
          <target state="translated">독립형 아카이브를 작성하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b08826ba03bafb388c1bd5be0f5d0ef0f9774b35" translate="yes" xml:space="preserve">
          <source>The straightforward translation into ctypes code would be this, but it does not work:</source>
          <target state="translated">ctypes 코드로의 간단한 변환은 다음과 같지만 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3bbd18af7e807a1ecde8e654eeae316aad16083d" translate="yes" xml:space="preserve">
          <source>The strange invariant above is meant to be an efficient memory representation for a tournament. The numbers below are &lt;em&gt;k&lt;/em&gt;, not &lt;code&gt;a[k]&lt;/code&gt;:</source>
          <target state="translated">위의 이상한 불변은 토너먼트에 효율적인 메모리 표현을 의미합니다. 아래 번호는 &lt;em&gt;K&lt;/em&gt; 아닌 &lt;code&gt;a[k]&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f3f83287161100c9dc848427c687a8403242c4e" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'01234567'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'01234567'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="081b65b640d4fd9a1348073d2be076165e5d402b" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'0123456789'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4dc062e91d1dfe0b46d43e731a7d26c8429acd1c" translate="yes" xml:space="preserve">
          <source>The string &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt;.</source>
          <target state="translated">문자열 &lt;code&gt;'0123456789abcdefABCDEF'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e169e91e10e1724d8d6b7fcde6b5762907d6051" translate="yes" xml:space="preserve">
          <source>The string &lt;em&gt;hash_name&lt;/em&gt; is the desired name of the hash digest algorithm for HMAC, e.g. &amp;lsquo;sha1&amp;rsquo; or &amp;lsquo;sha256&amp;rsquo;. &lt;em&gt;password&lt;/em&gt; and &lt;em&gt;salt&lt;/em&gt; are interpreted as buffers of bytes. Applications and libraries should limit &lt;em&gt;password&lt;/em&gt; to a sensible length (e.g. 1024). &lt;em&gt;salt&lt;/em&gt; should be about 16 or more bytes from a proper source, e.g. &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;hash_name&lt;/em&gt; 은 원하는 HMAC에 대한 해시 다이제스트 알고리즘의 이름입니다 (예 : 'sha1'또는 'sha256'). &lt;em&gt;비밀번호&lt;/em&gt; 와 &lt;em&gt;솔트&lt;/em&gt; 는 바이트 버퍼로 해석됩니다. 응용 프로그램 및 라이브러리는 &lt;em&gt;암호&lt;/em&gt; 를 적절한 길이 (예 : 1024)로 제한해야합니다 . &lt;em&gt;salt&lt;/em&gt; 는 적절한 소스에서 약 16 바이트 이상이어야합니다 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 예 : os.urandom ()) .</target>
        </trans-unit>
        <trans-unit id="974fbe45930e6c9f7ed0ba945f3ca1dfc34eddbd" translate="yes" xml:space="preserve">
          <source>The string of characters accepted for the command prefix.</source>
          <target state="translated">명령 접두사에 허용되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="218df02f3b43ffd3271f33dc44503b415fe71878" translate="yes" xml:space="preserve">
          <source>The string of characters that are recognized as comment beginners. All characters from the comment beginner to end of line are ignored. Includes just &lt;code&gt;'#'&lt;/code&gt; by default.</source>
          <target state="translated">주석 초보자로 인식되는 문자열입니다. 주석 초보자부터 줄 끝까지의 모든 문자는 무시됩니다. 기본적으로 &lt;code&gt;'#'&lt;/code&gt; 만 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="08ac626721e1a485bd3af4b431e4c2809aea979e" translate="yes" xml:space="preserve">
          <source>The string of characters that will accumulate into multi-character tokens. By default, includes all ASCII alphanumerics and underscore. In POSIX mode, the accented characters in the Latin-1 set are also included. If &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt;&lt;code&gt;punctuation_chars&lt;/code&gt;&lt;/a&gt; is not empty, the characters &lt;code&gt;~-./*?=&lt;/code&gt;, which can appear in filename specifications and command line parameters, will also be included in this attribute, and any characters which appear in &lt;code&gt;punctuation_chars&lt;/code&gt; will be removed from &lt;code&gt;wordchars&lt;/code&gt; if they are present there. If &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt;&lt;code&gt;whitespace_split&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;True&lt;/code&gt;, this will have no effect.</source>
          <target state="translated">다중 문자 토큰에 누적 될 문자열입니다. 기본적으로 모든 ASCII 영숫자와 밑줄이 포함됩니다. POSIX 모드에서는 라틴 -1 세트의 악센트 부호 문자도 포함됩니다. 경우 &lt;a href=&quot;#shlex.shlex.punctuation_chars&quot;&gt; &lt;code&gt;punctuation_chars&lt;/code&gt; 가&lt;/a&gt; 비어 있지 않은, 문자 &lt;code&gt;~-./*?=&lt;/code&gt; , 파일 이름 사양 및 명령 줄 매개 변수에 나타날 수 있습니다, 또한이 속성에 포함되며,에 나타나는 문자 &lt;code&gt;punctuation_chars&lt;/code&gt; 가 에서 제거됩니다 &lt;code&gt;wordchars&lt;/code&gt; 가있는 경우 거기에 선물하십시오. &lt;a href=&quot;#shlex.shlex.whitespace_split&quot;&gt; &lt;code&gt;whitespace_split&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4659a50925d6df425ac6596dfc8a23084e3a4010" translate="yes" xml:space="preserve">
          <source>The string passed to &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열이 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5d5d7729b640e49a8b83a3c394f3b0662bfab3da" translate="yes" xml:space="preserve">
          <source>The string representation in dotted decimal notation. Leading zeroes are never included in the representation.</source>
          <target state="translated">점으로 구분 된 십진 표기법의 문자열 표현입니다. 선행 0은 표현에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36dad8efe406905d6d09a273705ad1e8e58e3f5c" translate="yes" xml:space="preserve">
          <source>The string representation of a path is the raw filesystem path itself (in native form, e.g. with backslashes under Windows), which you can pass to any function taking a file path as a string:</source>
          <target state="translated">경로의 문자열 표현은 원시 파일 시스템 경로 자체 (예 : Windows에서 백 슬래시 등)로 파일 경로를 문자열로 사용하는 모든 함수에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="323edf4f9c5d0894188d9673d9f925fd1eae3209" translate="yes" xml:space="preserve">
          <source>The string representation returned when calling &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; on a &lt;a href=&quot;#zoneinfo.ZoneInfo&quot;&gt;&lt;code&gt;ZoneInfo&lt;/code&gt;&lt;/a&gt; object defaults to using the &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt;&lt;code&gt;ZoneInfo.key&lt;/code&gt;&lt;/a&gt; attribute (see the note on usage in the attribute documentation):</source>
          <target state="translated">&lt;a href=&quot;#zoneinfo.ZoneInfo&quot;&gt; &lt;code&gt;ZoneInfo&lt;/code&gt; &lt;/a&gt; 객체 에서 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 을 호출 할 때 반환되는 문자열 표현은 기본적으로 &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt; &lt;code&gt;ZoneInfo.key&lt;/code&gt; &lt;/a&gt; 속성 을 사용하는 것 입니다 (속성 문서의 사용법에 대한 참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="e2c60d280d907f21f86f32a46a5575681700d147" translate="yes" xml:space="preserve">
          <source>The string that the test was extracted from, or &lt;code&gt;None&lt;/code&gt; if the string is unavailable, or if the test was not extracted from a string.</source>
          <target state="translated">테스트가 추출 된 문자열 또는 문자열을 사용할 수 없거나 테스트가 문자열에서 추출되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e3d2b7a50a86f575f6fd45d43bbe5cf13d19875c" translate="yes" xml:space="preserve">
          <source>The string to be used to terminate lines in serialized output. The default is &lt;code&gt;\n&lt;/code&gt; because that&amp;rsquo;s the internal end-of-line discipline used by Python, though &lt;code&gt;\r\n&lt;/code&gt; is required by the RFCs.</source>
          <target state="translated">직렬화 된 출력에서 ​​라인을 종료하는 데 사용되는 문자열입니다. RFC에는 &lt;code&gt;\r\n&lt;/code&gt; 이 필요 하지만 파이썬에서 사용하는 내부 줄 끝 규칙이기 때문에 기본값은 &lt;code&gt;\n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0a2ea49d3d095e008ddabf5c5d79618ebc583572" translate="yes" xml:space="preserve">
          <source>The string used to separate (or, rather, terminate) lines on the current platform. This may be a single character, such as &lt;code&gt;'\n'&lt;/code&gt; for POSIX, or multiple characters, for example, &lt;code&gt;'\r\n'&lt;/code&gt; for Windows. Do not use &lt;em&gt;os.linesep&lt;/em&gt; as a line terminator when writing files opened in text mode (the default); use a single &lt;code&gt;'\n'&lt;/code&gt; instead, on all platforms.</source>
          <target state="translated">현재 플랫폼에서 행을 분리 (또는 오히려 종료)하는 데 사용되는 문자열입니다. POSIX의 경우 &lt;code&gt;'\n'&lt;/code&gt; 과 같은 단일 문자 이거나 Windows의 경우 &lt;code&gt;'\r\n'&lt;/code&gt; 과 같은 여러 문자 일 수 있습니다. 텍스트 모드에서 열린 파일을 쓸 때 &lt;em&gt;os.linesep&lt;/em&gt; 를 줄 종결 &lt;em&gt;자로&lt;/em&gt; 사용하지 마십시오 (기본값). 모든 플랫폼 에서 단일 &lt;code&gt;'\n'&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8ea85089ca50f62fa2ade25bca0d6a593de3d007" translate="yes" xml:space="preserve">
          <source>The string used to terminate lines produced by the &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt;. It defaults to &lt;code&gt;'\r\n'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 생성 한 행을 종료하는 데 사용되는 문자열 입니다. 기본값은 &lt;code&gt;'\r\n'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9cf8db53ba3ecf1804cef93b7a3f29860b461c29" translate="yes" xml:space="preserve">
          <source>The structure of INI files is described &lt;a href=&quot;#supported-ini-file-structure&quot;&gt;in the following section&lt;/a&gt;. Essentially, the file consists of sections, each of which contains keys with values. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; classes can read and write such files. Let&amp;rsquo;s start by creating the above configuration file programmatically.</source>
          <target state="translated">INI 파일의 구조 &lt;a href=&quot;#supported-ini-file-structure&quot;&gt;는 다음 섹션에서&lt;/a&gt; 설명 합니다 . 기본적으로 파일은 섹션으로 구성되며 각 섹션에는 값이있는 키가 포함됩니다. &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 클래스는 이러한 파일을 읽고 쓸 수 있습니다. 프로그래밍 방식으로 위의 구성 파일을 만들어 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="57ac7e21799c7f677af76b9cfb1a314919d92910" translate="yes" xml:space="preserve">
          <source>The subclass shown above sets &lt;code&gt;__slots__&lt;/code&gt; to an empty tuple. This helps keep memory requirements low by preventing the creation of instance dictionaries.</source>
          <target state="translated">위에 표시된 서브 클래스는 &lt;code&gt;__slots__&lt;/code&gt; 를 빈 튜플로 설정합니다 . 이를 통해 인스턴스 사전 작성을 방지하여 메모리 요구 사항을 낮게 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1049894083da3d6136643ae40107b301d4f0a75b" translate="yes" xml:space="preserve">
          <source>The subnets that join to make the current network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be increased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the subnets; it must be larger than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns an iterator of network objects.</source>
          <target state="translated">인수 값에 따라 현재 네트워크 정의를 만들기 위해 참여하는 서브넷. &lt;em&gt;prefixlen_diff&lt;/em&gt; 는 접두사 길이를 늘려야하는 양입니다. &lt;em&gt;new_prefix&lt;/em&gt; 는 서브넷의 원하는 새 접두사입니다. 접두사보다 커야합니다. &lt;em&gt;prefixlen_diff&lt;/em&gt; 및 &lt;em&gt;new_prefix&lt;/em&gt; 중 하나만 설정해야합니다. 네트워크 객체의 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9437b122f21ab7e79496b92a68b7f9e5eeaac2be" translate="yes" xml:space="preserve">
          <source>The subpath within the ZIP file where modules are searched. This is the empty string for zipimporter objects which point to the root of the ZIP file.</source>
          <target state="translated">모듈이 검색되는 ZIP 파일 내의 서브 패스. ZIP 파일의 루트를 가리키는 zipimporter 객체의 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="326ec51a05e2c8d6e7c26dd0d96fea0857cfc5e7" translate="yes" xml:space="preserve">
          <source>The subprocess is created by th &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">서브 프로세스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="830a5ed8adcd9cd5ec5ebf36f7cf9f4fb4e3e294" translate="yes" xml:space="preserve">
          <source>The subprocess is created by the &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">서브 프로세스는 &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 함수에 의해 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="8ea72797f0c5407f3306ccc7a80e8f6b73c93b68" translate="yes" xml:space="preserve">
          <source>The subprocess is created by the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">하위 프로세스는 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 메서드에 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="195b42e9196a41c00a54c69540f8c3689b081015" translate="yes" xml:space="preserve">
          <source>The subscription syntax must always be used with exactly two values: the argument list and the return type. The argument list must be a list of types or an ellipsis; the return type must be a single type.</source>
          <target state="translated">구독 구문은 항상 정확히 두 개의 값, 즉 인수 목록과 반환 유형과 함께 사용해야합니다. 인수 목록은 유형 또는 줄임표 목록이어야합니다. 리턴 유형은 단일 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="6a7c51bccf2dda395b8edfb0931dfbbc3947a4fd" translate="yes" xml:space="preserve">
          <source>The subsequence to search for and its replacement may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 서브 시퀀스와 그 대체는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 유사 오브젝트&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e98c3e1145a59f2632009395f0542a0deeafc636" translate="yes" xml:space="preserve">
          <source>The subsequence to search for and its replacement may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 하위 시퀀스와 그 대체는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f20be2f3a12314bdd168b8b8dc36ec5a219e64be" translate="yes" xml:space="preserve">
          <source>The subsequence to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an integer in the range 0 to 255.</source>
          <target state="translated">검색 할 서브 시퀀스는 임의의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 유사 오브젝트&lt;/a&gt; 이거나 0-255 범위의 정수일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f0f61cfe406164bd2b1bc218bfd4e6e5b9b5cc" translate="yes" xml:space="preserve">
          <source>The subsequence to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or an integer in the range 0 to 255.</source>
          <target state="translated">검색 할 하위 시퀀스는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 0에서 255 사이의 정수일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="733f0146d975374d445236d55e27c28b82ab24a4" translate="yes" xml:space="preserve">
          <source>The subset and equality comparisons do not generalize to a total ordering function. For example, any two nonempty disjoint sets are not equal and are not subsets of each other, so &lt;em&gt;all&lt;/em&gt; of the following return &lt;code&gt;False&lt;/code&gt;: &lt;code&gt;a&amp;lt;b&lt;/code&gt;, &lt;code&gt;a==b&lt;/code&gt;, or &lt;code&gt;a&amp;gt;b&lt;/code&gt;.</source>
          <target state="translated">부분 집합과 동등 비교는 전체 순서 함수로 일반화되지 않습니다. 예를 들어, 비어 있지 않은 임의의 두 개의 분리 된 세트들은, 동일하지 않은 서로의 서브 세트되지 않도록 &lt;em&gt;모든&lt;/em&gt; 다음 리턴의 &lt;code&gt;False&lt;/code&gt; : &lt;code&gt;a&amp;lt;b&lt;/code&gt; , &lt;code&gt;a==b&lt;/code&gt; 또는 &lt;code&gt;a&amp;gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d313acbcf2f63dafe9fec9edee3d8cece85e3a5f" translate="yes" xml:space="preserve">
          <source>The suffix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접미사는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​비슷한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d6b552f61d9fa84179bef81d55a59ca4effe2dd9" translate="yes" xml:space="preserve">
          <source>The suffix(es) to search for may be any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;.</source>
          <target state="translated">검색 할 접미사는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc8de5ade168ce8d52e288779f29cce661700e1e" translate="yes" xml:space="preserve">
          <source>The suggested launcher above uses the Python embedding API. This means that in your application, &lt;code&gt;sys.executable&lt;/code&gt; will be your application, and &lt;em&gt;not&lt;/em&gt; a conventional Python interpreter. Your code and its dependencies need to be prepared for this possibility. For example, if your application uses the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; module, it will need to call &lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt;&lt;code&gt;multiprocessing.set_executable()&lt;/code&gt;&lt;/a&gt; to let the module know where to find the standard Python interpreter.</source>
          <target state="translated">위의 제안 된 런처는 Python 임베딩 API를 사용합니다. 이것은 응용 프로그램에서 &lt;code&gt;sys.executable&lt;/code&gt; 이 일반적인 Python 인터프리터가 &lt;em&gt;아닌&lt;/em&gt; 응용 프로그램임을 의미합니다 . 이 가능성에 대비하여 코드와 해당 종속성을 준비해야합니다. 예를 들어, 애플리케이션이 &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈을 사용하는 경우 multiprocessing.set_ &lt;a href=&quot;multiprocessing#multiprocessing.set_executable&quot;&gt; &lt;code&gt;multiprocessing.set_executable()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 모듈에 표준 Python 인터프리터를 찾을 수있는 위치를 알려야합니다.</target>
        </trans-unit>
        <trans-unit id="4ca94cda6ea6ac6e5a70ea1ff1f1c7c7cd83fb8d" translate="yes" xml:space="preserve">
          <source>The supernet containing this network definition, depending on the argument values. &lt;em&gt;prefixlen_diff&lt;/em&gt; is the amount our prefix length should be decreased by. &lt;em&gt;new_prefix&lt;/em&gt; is the desired new prefix of the supernet; it must be smaller than our prefix. One and only one of &lt;em&gt;prefixlen_diff&lt;/em&gt; and &lt;em&gt;new_prefix&lt;/em&gt; must be set. Returns a single network object.</source>
          <target state="translated">인수 값에 따라이 네트워크 정의를 포함하는 슈퍼 넷. &lt;em&gt;prefixlen_diff&lt;/em&gt; 는 접두사 길이를 &lt;em&gt;줄여야&lt;/em&gt; 하는 양입니다. &lt;em&gt;new_prefix&lt;/em&gt; 는 수퍼 넷의 원하는 새 접두사입니다. 접두사보다 작아야합니다. &lt;em&gt;prefixlen_diff&lt;/em&gt; 및 &lt;em&gt;new_prefix&lt;/em&gt; 중 하나만 설정해야합니다. 단일 네트워크 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="652b878f95e736a80f9fc3181efc0a97692d08cf" translate="yes" xml:space="preserve">
          <source>The symbol module is deprecated and will be removed in future versions of Python.</source>
          <target state="translated">기호 모듈은 더 이상 사용되지 않으며 향후 Python 버전에서 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="1d3a132475eefbff651be1e9f60f5a01256ac706" translate="yes" xml:space="preserve">
          <source>The symbolic &lt;code&gt;LOG_&lt;/code&gt; values are defined in &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; and mirror the values defined in the &lt;code&gt;sys/syslog.h&lt;/code&gt; header file.</source>
          <target state="translated">기호 &lt;code&gt;LOG_&lt;/code&gt; 값은 &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; 에&lt;/a&gt; 정의되어 있으며 &lt;code&gt;sys/syslog.h&lt;/code&gt; 헤더 파일에 정의 된 값을 미러링 합니다.</target>
        </trans-unit>
        <trans-unit id="2855402ac7e633af0e756490916e4b0509c9ee96" translate="yes" xml:space="preserve">
          <source>The symbolic constants for the telnet commands are: IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO (Abort output), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</source>
          <target state="translated">텔넷 명령의 기호 상수는 IAC, DONT, DO, WONT, WILL, SE (Subnegotiation End), NOP (No Operation), DM (Data Mark), BRK (Break), IP (Interrupt process), AO ( 출력 중단), AYT (Are You There), EC (Erase Character), EL (Erase Line), GA (Go Ahead), SB (Subnegotiation Begin).</target>
        </trans-unit>
        <trans-unit id="f8ce1d87c905659a0bf890b9cf481e55b1edc39a" translate="yes" xml:space="preserve">
          <source>The system handle used to access the library.</source>
          <target state="translated">라이브러리에 액세스하는 데 사용되는 시스템 핸들.</target>
        </trans-unit>
        <trans-unit id="6fc6b22d1825c9f09c313587868ef00b4493d95a" translate="yes" xml:space="preserve">
          <source>The system identifier for the external subset of the document type definition. This will be a URI as a string, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">문서 유형 정의의 외부 서브 세트에 대한 시스템 ID. 이것은 문자열로서의 URI이거나 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="44d450cf187b52bfa50e049a62fae0de2e42ee87" translate="yes" xml:space="preserve">
          <source>The system is a domain controller.</source>
          <target state="translated">시스템은 도메인 컨트롤러입니다.</target>
        </trans-unit>
        <trans-unit id="40e3a3638774f49e1f39d0e71a7abdae17b2e149" translate="yes" xml:space="preserve">
          <source>The system is a server, but not a domain controller.</source>
          <target state="translated">시스템은 서버이지만 도메인 컨트롤러는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7c73a5e107d91be1df5f93f12cd8765ccebb12ce" translate="yes" xml:space="preserve">
          <source>The system is a workstation.</source>
          <target state="translated">시스템은 워크 스테이션입니다.</target>
        </trans-unit>
        <trans-unit id="f71c2f2dbbdfd4c5e6a5631f52c2bebfb1487e55" translate="yes" xml:space="preserve">
          <source>The system must have a current leap second table in order for this to give the correct answer. PTP or NTP software can maintain a leap second table.</source>
          <target state="translated">이것이 정답을 제공하려면 시스템에 현재 윤초 테이블이 있어야합니다. PTP 또는 NTP 소프트웨어는 윤초 테이블을 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55ae6ebbe2e07465f0616803ac45ed0fa6855ad1" translate="yes" xml:space="preserve">
          <source>The system will save old log files by appending extensions to the filename. The extensions are date-and-time based, using the strftime format &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; or a leading portion thereof, depending on the rollover interval.</source>
          <target state="translated">시스템은 파일 이름에 확장자를 추가하여 이전 로그 파일을 저장합니다. 확장은 롤오버 간격에 따라 strftime 형식 &lt;code&gt;%Y-%m-%d_%H-%M-%S&lt;/code&gt; 또는 그 앞 부분을 사용하여 날짜 및 시간을 기준으로 합니다.</target>
        </trans-unit>
        <trans-unit id="179fc435688f8e8cc38d18cd776581a529b4d5f3" translate="yes" xml:space="preserve">
          <source>The tab will not be displayed, but the associated window remains managed by the notebook and its configuration remembered. Hidden tabs may be restored with the &lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt; command.</source>
          <target state="translated">탭은 표시되지 않지만 관련 창은 노트북에 의해 관리되고 구성이 기억됩니다. 숨겨진 탭은 &lt;a href=&quot;#tkinter.ttk.Notebook.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 명령 으로 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b061342e7fcb41c80cbeeac10798ba4a35c7df9" translate="yes" xml:space="preserve">
          <source>The tab_id present in several methods of &lt;code&gt;ttk.Notebook&lt;/code&gt; may take any of the following forms:</source>
          <target state="translated">ttk.Notebook의 여러 메소드에 존재하는 &lt;code&gt;ttk.Notebook&lt;/code&gt; 는 다음 형식 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d522d8935e08991d14cdfc081478c07442e166b" translate="yes" xml:space="preserve">
          <source>The table below compares the syntax for creating shared ctypes objects from shared memory with the normal ctypes syntax. (In the table &lt;code&gt;MyStruct&lt;/code&gt; is some subclass of &lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt;&lt;code&gt;ctypes.Structure&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">아래 표는 공유 메모리에서 공유 ctypes 객체를 생성하는 구문과 일반 ctypes 구문을 비교합니다. (표에서 &lt;code&gt;MyStruct&lt;/code&gt; 는 &lt;a href=&quot;ctypes#ctypes.Structure&quot;&gt; &lt;code&gt;ctypes.Structure&lt;/code&gt; 의&lt;/a&gt; 일부 서브 클래스입니다 .)</target>
        </trans-unit>
        <trans-unit id="7bccc06bc889ee84856fdd46b401f47559a82ae4" translate="yes" xml:space="preserve">
          <source>The table below provides a high-level comparison of &lt;code&gt;strftime()&lt;/code&gt; versus &lt;code&gt;strptime()&lt;/code&gt;:</source>
          <target state="translated">아래 표는 &lt;code&gt;strftime()&lt;/code&gt; 과 &lt;code&gt;strptime()&lt;/code&gt; 의 높은 수준의 비교를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="e3dbc221607127a001cdb67dd95041333051b2e0" translate="yes" xml:space="preserve">
          <source>The tar format was originally conceived to make backups on tape drives with the main focus on preserving file system information. Nowadays tar archives are commonly used for file distribution and exchanging archives over networks. One problem of the original format (which is the basis of all other formats) is that there is no concept of supporting different character encodings. For example, an ordinary tar archive created on a &lt;em&gt;UTF-8&lt;/em&gt; system cannot be read correctly on a &lt;em&gt;Latin-1&lt;/em&gt; system if it contains non-&lt;em&gt;ASCII&lt;/em&gt; characters. Textual metadata (like filenames, linknames, user/group names) will appear damaged. Unfortunately, there is no way to autodetect the encoding of an archive. The pax format was designed to solve this problem. It stores non-ASCII metadata using the universal character encoding &lt;em&gt;UTF-8&lt;/em&gt;.</source>
          <target state="translated">tar 형식은 원래 파일 시스템 정보 보존에 중점을 둔 테이프 드라이브에서 백업하기 위해 고안되었습니다. 오늘날 tar 아카이브는 파일 배포 및 네트워크를 통한 아카이브 교환에 일반적으로 사용됩니다. 원래 형식 (다른 모든 형식의 기초)의 한 가지 문제점은 다른 문자 인코딩을 지원한다는 개념이 없다는 것입니다. 예를 들어, &lt;em&gt;UTF-8&lt;/em&gt; 시스템 에서 작성된 일반 tar 아카이브는 &lt;em&gt;ASCII&lt;/em&gt; 가 아닌 경우 &lt;em&gt;라틴 -1&lt;/em&gt; 시스템 에서 올바르게 읽을 수 없습니다.&lt;em&gt;&lt;/em&gt;문자. 파일 이름, 링크 이름, 사용자 / 그룹 이름과 같은 텍스트 메타 데이터가 손상된 것으로 나타납니다. 불행히도, 아카이브 인코딩을 자동 감지하는 방법은 없습니다. pax 형식은이 문제를 해결하도록 설계되었습니다. 범용 문자 인코딩 &lt;em&gt;UTF-8을&lt;/em&gt; 사용하여 비 ASCII 메타 데이터를 저장 합니다.</target>
        </trans-unit>
        <trans-unit id="613dcaffb8c0009159e594bde38781dfcc7c3d20" translate="yes" xml:space="preserve">
          <source>The target path may be absolute or relative. Relative paths are interpreted relative to the current working directory, &lt;em&gt;not&lt;/em&gt; the directory of the Path object.</source>
          <target state="translated">대상 경로는 절대 또는 상대 경로 일 수 있습니다. 상대 경로는 Path 개체의 디렉터리가 &lt;em&gt;아니라&lt;/em&gt; 현재 작업 디렉터리를 기준으로 해석 됩니다.</target>
        </trans-unit>
        <trans-unit id="39109a83b1e6877b05cef869c019b4e8c66ec92a" translate="yes" xml:space="preserve">
          <source>The task is executed in the loop returned by &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised if there is no running loop in current thread.</source>
          <target state="translated">작업은 &lt;a href=&quot;asyncio-eventloop#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 에서 반환 한 루프에서 실행되며 현재 스레드에 실행중인 루프가 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6cd178d789e9c72b2db2b532b1e1730e28430479" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;delegation to the parent&amp;rsquo; means that if a logger has a level of NOTSET, its chain of ancestor loggers is traversed until either an ancestor with a level other than NOTSET is found, or the root is reached.</source>
          <target state="translated">'부모에게 위임'이라는 용어는 로거에 NOTSET 레벨이있는 ​​경우 NOTSET 이외의 레벨을 가진 조상을 찾거나 루트에 도달 할 때까지 상위 로거 체인이 순회 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="146eafd5f201d9458991952860d529510a852604" translate="yes" xml:space="preserve">
          <source>The term &lt;em&gt;seconds since the epoch&lt;/em&gt; refers to the total number of elapsed seconds since the epoch, typically excluding &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;leap seconds&lt;/a&gt;. Leap seconds are excluded from this total on all POSIX-compliant platforms.</source>
          <target state="translated">&lt;em&gt;에포크 이후 초라&lt;/em&gt; 는 용어 는 일반적으로 &lt;a href=&quot;https://en.wikipedia.org/wiki/Leap_second&quot;&gt;윤초를&lt;/a&gt; 제외하고 에포크 이후 경과 된 총 초 수를 나타냅니다 . 모든 POSIX 호환 플랫폼에서 윤초는이 총계에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="e94bbf67fcc1b6bd4b3967baa1ebc9ad25d9c0c5" translate="yes" xml:space="preserve">
          <source>The test code can more easily be separated from shipped code.</source>
          <target state="translated">테스트 코드는 제공된 코드와 쉽게 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="de4938c1a0bc8d676536f4fba441042877342846" translate="yes" xml:space="preserve">
          <source>The test function should return a string describing the image type if the test succeeded, or &lt;code&gt;None&lt;/code&gt; if it failed.</source>
          <target state="translated">테스트 함수는 테스트에 성공한 경우 이미지 유형을 설명하는 문자열을 반환하고 실패한 경우 &lt;code&gt;None&lt;/code&gt; 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="401d59c5ffb4d3b57f5880747f129772c3d55bd5" translate="yes" xml:space="preserve">
          <source>The test module can be run standalone from the command line.</source>
          <target state="translated">테스트 모듈은 명령 행에서 독립형으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060a6930386a9d1574b1aa1b3c3bc2d33784e7a8" translate="yes" xml:space="preserve">
          <source>The test passes if at least one message emitted inside the &lt;code&gt;with&lt;/code&gt; block matches the &lt;em&gt;logger&lt;/em&gt; and &lt;em&gt;level&lt;/em&gt; conditions, otherwise it fails.</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록 내에서 생성 된 하나 이상의 메시지 가 &lt;em&gt;로거&lt;/em&gt; 및 &lt;em&gt;레벨&lt;/em&gt; 조건 과 일치하면 테스트가 통과 되고 그렇지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0c1c8392f06e470e9763ff342c0bf458700b10d0" translate="yes" xml:space="preserve">
          <source>The test runner&amp;rsquo;s display output can be controlled in two ways. First, an output function can be passed to &lt;code&gt;TestRunner.run()&lt;/code&gt;; this function will be called with strings that should be displayed. It defaults to &lt;code&gt;sys.stdout.write&lt;/code&gt;. If capturing the output is not sufficient, then the display output can be also customized by subclassing DocTestRunner, and overriding the methods &lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt;&lt;code&gt;report_start()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt;&lt;code&gt;report_success()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt;&lt;code&gt;report_unexpected_exception()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt;&lt;code&gt;report_failure()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트 러너의 디스플레이 출력은 두 가지 방법으로 제어 할 수 있습니다. 먼저, 출력 함수를 &lt;code&gt;TestRunner.run()&lt;/code&gt; 전달할 수 있습니다 . 이 함수는 표시되어야하는 문자열과 함께 호출됩니다. 기본값은 &lt;code&gt;sys.stdout.write&lt;/code&gt; 입니다. 출력을 캡처하는 데 충분하지 않은 경우 DocTestRunner를 서브 클래 싱하고 &lt;a href=&quot;#doctest.DocTestRunner.report_start&quot;&gt; &lt;code&gt;report_start()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.DocTestRunner.report_success&quot;&gt; &lt;code&gt;report_success()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.DocTestRunner.report_unexpected_exception&quot;&gt; &lt;code&gt;report_unexpected_exception()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#doctest.DocTestRunner.report_failure&quot;&gt; &lt;code&gt;report_failure()&lt;/code&gt; &lt;/a&gt; 메소드를 대체하여 표시 출력을 사용자 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb4a3424a4f1dda3e01eea1f89d1c0f58bff9865" translate="yes" xml:space="preserve">
          <source>The testing code of a &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; instance should be entirely self contained, such that it can be run either in isolation or in arbitrary combination with any number of other test cases.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 인스턴스 의 테스트 코드는 완전히 독립적으로 포함되어 있어야하며, 별도로 테스트하거나 다른 테스트 사례와 임의의 조합으로 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ae3f29483e2ee3ea0f7163c30937acfdb9d4b25" translate="yes" xml:space="preserve">
          <source>The testing suite should exercise all classes, functions, and constants. This includes not just the external API that is to be presented to the outside world but also &amp;ldquo;private&amp;rdquo; code.</source>
          <target state="translated">테스트 스위트는 모든 클래스, 함수 및 상수를 연습해야합니다. 여기에는 외부에 제공되는 외부 API뿐만 아니라 &quot;비공개&quot;코드도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="daaa85794b2e5ea58362f9c215438cdd2e5ff243" translate="yes" xml:space="preserve">
          <source>The text and background colors for the context pane can be configured under the Highlights tab in the Configure IDLE dialog.</source>
          <target state="translated">컨텍스트 창의 텍스트 및 배경색은 IDLE 구성 대화 상자의 하이라이트 탭에서 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4008857746bcc56c1a0c2edaedf3abb5a9bbbdd4" translate="yes" xml:space="preserve">
          <source>The text buffer is discarded when the &lt;a href=&quot;#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">&lt;a href=&quot;#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메서드가 호출 되면 텍스트 버퍼가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="be2ad191eeb4d0bbf960c378232847d949f175e9" translate="yes" xml:space="preserve">
          <source>The text categories are specified with regular expressions. The technique is to combine those into a single master regular expression and to loop over successive matches:</source>
          <target state="translated">텍스트 범주는 정규식으로 지정됩니다. 이 기술은 이들을 단일 마스터 정규 표현식으로 결합하고 연속 일치 항목을 반복하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d833b1a3893c5d6101423fd99ed50cd0a6703e5" translate="yes" xml:space="preserve">
          <source>The text stream API is described in detail in the documentation of &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텍스트 스트림 API는 &lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt; 문서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f2c2cd14f223c08b886437c2b9c2073b05f038" translate="yes" xml:space="preserve">
          <source>The text to display in the column heading.</source>
          <target state="translated">열 머리글에 표시 할 텍스트입니다.</target>
        </trans-unit>
        <trans-unit id="624bc91f26efa2f3c6b7ab6d643f9eaaecd49465" translate="yes" xml:space="preserve">
          <source>The text value of the attribute. This is a synonym for the &lt;code&gt;nodeValue&lt;/code&gt; attribute.</source>
          <target state="translated">속성의 텍스트 값입니다. 이것은 &lt;code&gt;nodeValue&lt;/code&gt; 속성 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="b95c1297303c1f21bf34292066165290d2d2c55f" translate="yes" xml:space="preserve">
          <source>The text widget and scrollbar are packed together in a &lt;code&gt;Frame&lt;/code&gt;, and the methods of the &lt;code&gt;Grid&lt;/code&gt; and &lt;code&gt;Pack&lt;/code&gt; geometry managers are acquired from the &lt;code&gt;Frame&lt;/code&gt; object. This allows the &lt;a href=&quot;#tkinter.scrolledtext.ScrolledText&quot;&gt;&lt;code&gt;ScrolledText&lt;/code&gt;&lt;/a&gt; widget to be used directly to achieve most normal geometry management behavior.</source>
          <target state="translated">텍스트 위젯과 스크롤바는 &lt;code&gt;Frame&lt;/code&gt; 에 함께 압축 되며 &lt;code&gt;Grid&lt;/code&gt; 및 &lt;code&gt;Pack&lt;/code&gt; 지오메트리 관리자 의 메서드 는 &lt;code&gt;Frame&lt;/code&gt; 개체 에서 가져옵니다 . 이렇게하면 &lt;a href=&quot;#tkinter.scrolledtext.ScrolledText&quot;&gt; &lt;code&gt;ScrolledText&lt;/code&gt; &lt;/a&gt; 위젯을 직접 사용하여 대부분의 일반적인 지오메트리 관리 동작을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1d2cdc643f2142769f11e3bf3f5f6639f0d087f" translate="yes" xml:space="preserve">
          <source>The text widget and scrollbar are packed together in a &lt;code&gt;Frame&lt;/code&gt;, and the methods of the &lt;code&gt;Grid&lt;/code&gt; and &lt;code&gt;Pack&lt;/code&gt; geometry managers are acquired from the &lt;code&gt;Frame&lt;/code&gt; object. This allows the &lt;code&gt;ScrolledText&lt;/code&gt; widget to be used directly to achieve most normal geometry management behavior.</source>
          <target state="translated">텍스트 위젯과 스크롤 막대는 &lt;code&gt;Frame&lt;/code&gt; 에 함께 묶여지고 &lt;code&gt;Grid&lt;/code&gt; 및 &lt;code&gt;Pack&lt;/code&gt; 지오메트리 관리자 의 메소드 는 &lt;code&gt;Frame&lt;/code&gt; 객체 에서 얻습니다 . 이를 통해 &lt;code&gt;ScrolledText&lt;/code&gt; 위젯을 직접 사용하여 가장 일반적인 형상 관리 동작을 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781fd46cb32fb2d772f49135a740a4dd6122fbb5" translate="yes" xml:space="preserve">
          <source>The textual label to display for the item.</source>
          <target state="translated">항목에 표시 할 텍스트 레이블입니다.</target>
        </trans-unit>
        <trans-unit id="7e98aa474e18722e2a15841579721066227b8523" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;extra&lt;/em&gt; which can be used to pass a dictionary which is used to populate the __dict__ of the LogRecord created for the logging event with user-defined attributes. These custom attributes can then be used as you like. For example, they could be incorporated into logged messages. For example:</source>
          <target state="translated">세 번째 선택적 키워드 인수는 &lt;em&gt;extra&lt;/em&gt; 이며 이는 로깅 이벤트에 대해 작성된 LogRecord의 __dict__를 사용자 정의 속성으로 채우는 데 사용되는 사전을 전달하는 데 사용할 수 있습니다. 그런 다음이 사용자 정의 속성을 원하는대로 사용할 수 있습니다. 예를 들어, 로그 된 메시지에 통합 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="665f31530d18339b9c188c1b9103b2b958ccad7e" translate="yes" xml:space="preserve">
          <source>The third optional keyword argument is &lt;em&gt;stacklevel&lt;/em&gt;, which defaults to &lt;code&gt;1&lt;/code&gt;. If greater than 1, the corresponding number of stack frames are skipped when computing the line number and function name set in the &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; created for the logging event. This can be used in logging helpers so that the function name, filename and line number recorded are not the information for the helper function/method, but rather its caller. The name of this parameter mirrors the equivalent one in the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">세 번째 선택적 키워드 인수는 &lt;em&gt;stacklevel&lt;/em&gt; 이며 기본값은 &lt;code&gt;1&lt;/code&gt; 입니다. 1보다 크면 로깅 이벤트에 대해 작성된 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; 에&lt;/a&gt; 설정된 행 번호 및 기능 이름을 계산할 때 해당 수의 스택 프레임이 건너 뜁니다 . 이것은 헬퍼 로깅에 사용될 수 있으므로 기록 된 함수 이름, 파일 이름 및 행 번호는 헬퍼 기능 / 방법에 대한 정보가 아니라 호출자에 대한 정보입니다. 이 매개 변수의 이름은 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈 에서 동등한 것을 미러링합니다 .</target>
        </trans-unit>
        <trans-unit id="8eb0c095fa10852ea09d13926b5914515b40f06b" translate="yes" xml:space="preserve">
          <source>The third-party &lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;regex&lt;/a&gt; module, which has an API compatible with the standard library &lt;a href=&quot;#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; module, but offers additional functionality and a more thorough Unicode support.</source>
          <target state="translated">타사 &lt;a href=&quot;https://pypi.org/project/regex/&quot;&gt;정규식&lt;/a&gt; 표준 라이브러리와 호환 API가 모듈, &lt;a href=&quot;#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; &lt;/a&gt; 모듈 만 제공 추가 기능 및보다 철저한 유니 코드 지원.</target>
        </trans-unit>
        <trans-unit id="afb06b3287857cf9d40f49ddb415dd4aae4a33b0" translate="yes" xml:space="preserve">
          <source>The three methods that return the ratio of matching to total characters can give different results due to differing levels of approximation, although &lt;code&gt;quick_ratio()&lt;/code&gt; and &lt;code&gt;real_quick_ratio()&lt;/code&gt; are always at least as large as &lt;code&gt;ratio()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;quick_ratio()&lt;/code&gt; 및 &lt;code&gt;real_quick_ratio()&lt;/code&gt; 는 항상 &lt;code&gt;ratio()&lt;/code&gt; 만큼 크지 만 총 문자에 대한 일치 비율을 반환하는 세 가지 방법은 근사 수준이 다르기 때문에 다른 결과를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="702f3b2e21f5e77bbf53b54dae40e50493de58c9" translate="yes" xml:space="preserve">
          <source>The time and date of the last modification to the archive member. This is a tuple of six values:</source>
          <target state="translated">아카이브 멤버를 마지막으로 수정 한 시간 및 날짜입니다. 이것은 6 가지 값의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="973cda5cc6748314dfb6fc94d1ded91647c97ce5" translate="yes" xml:space="preserve">
          <source>The time is an absolute timestamp, using the same time reference as &lt;a href=&quot;#asyncio.loop.time&quot;&gt;&lt;code&gt;loop.time()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">시간은 &lt;a href=&quot;#asyncio.loop.time&quot;&gt; &lt;code&gt;loop.time()&lt;/code&gt; &lt;/a&gt; 과 동일한 시간 참조를 사용하는 절대 시간 소인 입니다.</target>
        </trans-unit>
        <trans-unit id="a0676e756a3ab92c3f906666f0e732cf57a4078c" translate="yes" xml:space="preserve">
          <source>The time limit (in microseconds) on CPU time that a process can spend under real-time scheduling without making a blocking syscall.</source>
          <target state="translated">프로세스가 syscall을 차단하지 않고 실시간 스케줄링 하에서 소비 할 수있는 CPU 시간의 시간 제한 (마이크로 초).</target>
        </trans-unit>
        <trans-unit id="f49b9982b8903d085f6ab35fedbabd6bf7292265" translate="yes" xml:space="preserve">
          <source>The time taken by this routine is proportional to &lt;code&gt;len(fragment)&lt;/code&gt;.</source>
          <target state="translated">이 루틴에 걸리는 시간은 &lt;code&gt;len(fragment)&lt;/code&gt; 비례합니다 .</target>
        </trans-unit>
        <trans-unit id="f9aa5984100afffa888154716c5fc64965cd814c" translate="yes" xml:space="preserve">
          <source>The time value as returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;, and accepted by &lt;a href=&quot;#time.asctime&quot;&gt;&lt;code&gt;asctime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.mktime&quot;&gt;&lt;code&gt;mktime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;, is a sequence of 9 integers. The return values of &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt; also offer attribute names for individual fields.</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 에서 반환되고 &lt;a href=&quot;#time.asctime&quot;&gt; &lt;code&gt;asctime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.mktime&quot;&gt; &lt;code&gt;mktime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; 에서 허용되는 시간 값 은 9 개의 정수 시퀀스입니다. &lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 의 반환 값은 개별 필드의 속성 이름도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="144ea8db2e1df67dd3e6bba4613f86171460dbd9" translate="yes" xml:space="preserve">
          <source>The timeout is long enough to prevent test failure: it takes into account that the client and the server can run in different threads or even different processes.</source>
          <target state="translated">시간 초과는 테스트 실패를 방지 할 수있을만큼 길다. 클라이언트와 서버가 다른 스레드 또는 다른 프로세스에서 실행될 수 있다는 점을 고려합니다.</target>
        </trans-unit>
        <trans-unit id="ec99df5e279a279e7cacd8a5f4eb9d1cd8f983fa" translate="yes" xml:space="preserve">
          <source>The timeout is short enough to prevent a test to wait for too long if the Internet request is blocked for whatever reason.</source>
          <target state="translated">어떤 이유로 든 인터넷 요청이 차단 된 경우 테스트가 너무 오래 기다리지 않도록 제한 시간이 짧습니다.</target>
        </trans-unit>
        <trans-unit id="fa7943289bae9e7d567106c49f45467d0b1f6837" translate="yes" xml:space="preserve">
          <source>The timeout should be long enough for &lt;a href=&quot;socket#socket.socket.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;socket#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; methods of &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제한 시간은 충분히에 있어야한다 &lt;a href=&quot;socket#socket.socket.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;socket#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;socket#socket.socket.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab441716da6934485838efd0cc96e45a465e34ee" translate="yes" xml:space="preserve">
          <source>The timeout value depends on the regrtest &lt;code&gt;--timeout&lt;/code&gt; command line option.</source>
          <target state="translated">시간 초과 값은 regrtest &lt;code&gt;--timeout&lt;/code&gt; 명령 줄 옵션 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="383501791bf73fad29eacbd1434a825d90dcda3d" translate="yes" xml:space="preserve">
          <source>The title bar contains the name of the file, the full path, and the version of Python and IDLE running the window. The status bar contains the line number (&amp;lsquo;Ln&amp;rsquo;) and column number (&amp;lsquo;Col&amp;rsquo;). Line numbers start with 1; column numbers with 0.</source>
          <target state="translated">제목 표시 줄에는 파일 이름, 전체 경로 및 창을 실행하는 Python 및 IDLE 버전이 포함됩니다. 상태 표시 줄에는 줄 번호 ( 'Ln')와 열 번호 ( 'Col')가 있습니다. 줄 번호는 1로 시작합니다. 열 번호는 0입니다.</target>
        </trans-unit>
        <trans-unit id="eb0ed541e548fb76d9c95f3b320418110775e844" translate="yes" xml:space="preserve">
          <source>The token buffer. It may be useful to examine this when catching exceptions.</source>
          <target state="translated">토큰 버퍼. 예외를 발견 할 때이를 검사하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af5684156d0632efbb688be764db6d9de4886083" translate="yes" xml:space="preserve">
          <source>The token constants are:</source>
          <target state="translated">토큰 상수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6369db38b3c0c1619322ec307a8d31c67ea8b3e6" translate="yes" xml:space="preserve">
          <source>The token is an opaque object (that supports equality testing) identifying the current version of the abstract base class cache for virtual subclasses. The token changes with every call to &lt;a href=&quot;#abc.ABCMeta.register&quot;&gt;&lt;code&gt;ABCMeta.register()&lt;/code&gt;&lt;/a&gt; on any ABC.</source>
          <target state="translated">토큰은 가상 서브 클래스에 대한 추상 기본 클래스 캐시의 현재 버전을 식별하는 불투명 오브젝트 (동일성 테스트를 지원)입니다. 모든 ABC 에서 &lt;a href=&quot;#abc.ABCMeta.register&quot;&gt; &lt;code&gt;ABCMeta.register()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때마다 토큰이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="39df4a005bd76c17fb119282afd8e40603dd44b7" translate="yes" xml:space="preserve">
          <source>The tokenizer produces the following output:</source>
          <target state="translated">토크 나이 저는 다음과 같은 출력을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e1221339de21aeb616c4d21ccf9328f0f362ac4" translate="yes" xml:space="preserve">
          <source>The total number (&lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;) of expected bytes.</source>
          <target state="translated">예상 바이트 의 총 수 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="43f447355b23a2390fda8e4efbaeb61ee2a32abe" translate="yes" xml:space="preserve">
          <source>The total number of addresses in the network.</source>
          <target state="translated">네트워크의 총 주소 수입니다.</target>
        </trans-unit>
        <trans-unit id="533c0b6ab55091223e2fa983b0fc2fb594c66022" translate="yes" xml:space="preserve">
          <source>The total number of bits in the address representation for this version: &lt;code&gt;32&lt;/code&gt; for IPv4, &lt;code&gt;128&lt;/code&gt; for IPv6.</source>
          <target state="translated">이 버전에 대한 주소 표현의 총 비트 수 : IPv4의 경우 &lt;code&gt;32&lt;/code&gt; , IPv6의 경우 &lt;code&gt;128&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0fa2435ac265900a21416de414ab6af83ae21237" translate="yes" xml:space="preserve">
          <source>The total number of tests run so far.</source>
          <target state="translated">지금까지 총 테스트 수입니다.</target>
        </trans-unit>
        <trans-unit id="e85ca4d6aa52bdeda7f809afceddc2f2528db8a5" translate="yes" xml:space="preserve">
          <source>The total number of to be consumed bytes.</source>
          <target state="translated">소비되는 총 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ffa71222143917a1eb6464750e264a1c1dc0389a" translate="yes" xml:space="preserve">
          <source>The trace function is invoked (with &lt;em&gt;event&lt;/em&gt; set to &lt;code&gt;'call'&lt;/code&gt;) whenever a new local scope is entered; it should return a reference to a local trace function to be used for the new scope, or &lt;code&gt;None&lt;/code&gt; if the scope shouldn&amp;rsquo;t be traced.</source>
          <target state="translated">새로운 로컬 범위가 입력 될 때마다 추적 기능이 호출됩니다 ( &lt;em&gt;이벤트&lt;/em&gt; 가 &lt;code&gt;'call'&lt;/code&gt; 로 설정 됨 ). 새 범위에 사용할 로컬 추적 함수에 대한 참조를 반환하거나 범위를 추적하지 않아야하는 경우 &lt;code&gt;None&lt;/code&gt; 을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0276db0e37cffd313334d18dfb0ebfdd11f2c19" translate="yes" xml:space="preserve">
          <source>The traceback header is followed by an optional traceback stack, whose contents are ignored by doctest. The traceback stack is typically omitted, or copied verbatim from an interactive session.</source>
          <target state="translated">역 추적 헤더 다음에는 선택적인 역 추적 스택이 있으며, 그 내용은 doctest에 의해 무시됩니다. 트레이스 백 스택은 일반적으로 생략되거나 대화식 세션에서 그대로 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="2d935d9b67ec8b6f96388a84f36cbe32492b44c2" translate="yes" xml:space="preserve">
          <source>The traceback stack is followed by the most interesting part: the line(s) containing the exception type and detail. This is usually the last line of a traceback, but can extend across multiple lines if the exception has a multi-line detail:</source>
          <target state="translated">트레이스 백 스택 다음에는 가장 흥미로운 부분이 있습니다 : 예외 유형과 세부 사항을 포함하는 라인. 이것은 일반적으로 역 추적의 마지막 행이지만 예외에 여러 행 세부 사항이있는 경우 여러 행으로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b1db494b134e9c8220a976eba1115a13e23b7c" translate="yes" xml:space="preserve">
          <source>The tracemalloc module is a debug tool to trace memory blocks allocated by Python. It provides the following information:</source>
          <target state="translated">tracemalloc 모듈은 Python이 할당 한 메모리 블록을 추적하는 디버그 도구입니다. 다음 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="31a9ce8a876ac0217c1463774c12a24481761b30" translate="yes" xml:space="preserve">
          <source>The traditional method with a 2 character salt and 13 characters of hash. This is the weakest method.</source>
          <target state="translated">2 자 소금과 13 자 해시를 사용하는 전통적인 방법입니다. 이것이 가장 약한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="16acab894e31876506303b91db879f68d418dbb4" translate="yes" xml:space="preserve">
          <source>The transport classes are &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;not thread safe&lt;/a&gt;.</source>
          <target state="translated">전송 클래스는 &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;스레드로부터 안전하지 않습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1d4addb81580c66d88e12e490015db638f34f42" translate="yes" xml:space="preserve">
          <source>The tree area.</source>
          <target state="translated">트리 영역.</target>
        </trans-unit>
        <trans-unit id="63c5e92c4fd607dfc132dae25b1bde5801ce3c8a" translate="yes" xml:space="preserve">
          <source>The tree column has ID #0.</source>
          <target state="translated">트리 열의 ID는 # 0입니다.</target>
        </trans-unit>
        <trans-unit id="a7f4322c232ab22c451a4f904178e963f0c2b60b" translate="yes" xml:space="preserve">
          <source>The true value of the &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; type. Assignments to &lt;code&gt;True&lt;/code&gt; are illegal and raise a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 유형 의 실제 값입니다 . &lt;code&gt;True&lt;/code&gt; 에 대한 할당 은 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 않으며 SyntaxError를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="f1385bf813f5ebaee50787de55cade7aa2ad93e9" translate="yes" xml:space="preserve">
          <source>The tuple of arguments given to the exception constructor. Some built-in exceptions (like &lt;a href=&quot;#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;) expect a certain number of arguments and assign a special meaning to the elements of this tuple, while others are usually called only with a single string giving an error message.</source>
          <target state="translated">예외 생성자에 제공된 인수의 튜플. &lt;a href=&quot;#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 와 같은 일부 내장 예외 는 특정 수의 인수를 예상하고이 튜플의 요소에 특별한 의미를 지정하는 반면, 다른 예외 는 일반적으로 오류 메시지를 제공하는 단일 문자열로만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="539f38dbbfed03502ac81a27a897e9fba44d57ad" translate="yes" xml:space="preserve">
          <source>The tuple of arguments merged into &lt;code&gt;msg&lt;/code&gt; to produce &lt;code&gt;message&lt;/code&gt;, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).</source>
          <target state="translated">인수의 튜플은 &lt;code&gt;msg&lt;/code&gt; 로 병합되어 &lt;code&gt;message&lt;/code&gt; 를 생성 하거나 병합에 사용되는 값을 갖는 dict (한 개의 인수 만 있고 사전 인 경우)입니다.</target>
        </trans-unit>
        <trans-unit id="a56707db067b73f69f1d7eabd20ac87c56e218eb" translate="yes" xml:space="preserve">
          <source>The tuple of base classes of a class object.</source>
          <target state="translated">클래스 객체의 기본 클래스 튜플.</target>
        </trans-unit>
        <trans-unit id="39d9df05b4cf019ab0db7e17a8ec1ef2c24c1ad6" translate="yes" xml:space="preserve">
          <source>The turtle module provides turtle graphics primitives, in both object-oriented and procedure-oriented ways. Because it uses &lt;a href=&quot;tkinter#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; for the underlying graphics, it needs a version of Python installed with Tk support.</source>
          <target state="translated">turtle 모듈은 객체 지향 및 절차 지향 방식으로 거북이 그래픽 프리미티브를 제공합니다. 기본 그래픽에 &lt;a href=&quot;tkinter#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 를 사용하기 때문에 Tk 지원과 함께 설치된 Python 버전이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a905845d53cd321a94fdd9df15627053d06b84e2" translate="yes" xml:space="preserve">
          <source>The two connection objects returned by &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt; represent the two ends of the pipe. Each connection object has &lt;code&gt;send()&lt;/code&gt; and &lt;code&gt;recv()&lt;/code&gt; methods (among others). Note that data in a pipe may become corrupted if two processes (or threads) try to read from or write to the &lt;em&gt;same&lt;/em&gt; end of the pipe at the same time. Of course there is no risk of corruption from processes using different ends of the pipe at the same time.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 두 개의 연결 오브젝트는 파이프 의 두 끝을 나타냅니다. 각 연결 개체에는 &lt;code&gt;send()&lt;/code&gt; 및 &lt;code&gt;recv()&lt;/code&gt; 메서드가 있습니다. 두 프로세스 (또는 스레드)가 &lt;em&gt;동시에&lt;/em&gt; 파이프 의 &lt;em&gt;동일한&lt;/em&gt; 끝 에서 읽거나 쓰려고하면 파이프의 데이터가 손상 될 수 있습니다 . 물론 파이프의 다른 끝을 동시에 사용하는 공정으로 인한 손상의 위험은 없습니다.</target>
        </trans-unit>
        <trans-unit id="33638c8f9ee12ee7ff74956b792e2571ed375108" translate="yes" xml:space="preserve">
          <source>The two equality methods, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt;, are special. They do the default equality comparison on identity, using the &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; attribute, unless you change their return value to return something else:</source>
          <target state="translated">두 개의 등식 메소드 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; 은 특별합니다. 반환 값을 변경하여 다른 것을 반환하지 않는 한 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 동일성에 대한 기본 동등성을 비교 합니다.</target>
        </trans-unit>
        <trans-unit id="a0872f8b41c8731e6a21444642be7996b3a7fda9" translate="yes" xml:space="preserve">
          <source>The two equality methods, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ne__&quot;&gt;&lt;code&gt;__ne__()&lt;/code&gt;&lt;/a&gt;, are special. They do the default equality comparison on identity, using the &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; attribute, unless you change their return value to return something else:</source>
          <target state="translated">두 개의 같음 메서드 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__ne__&quot;&gt; &lt;code&gt;__ne__()&lt;/code&gt; &lt;/a&gt; 은 특별합니다. 다른 것을 반환하도록 반환 값을 변경하지 않는 한 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 ID에 대한 기본 같음 비교를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="272ded31de2db6b1c275e8c03cf46f61287b0fca" translate="yes" xml:space="preserve">
          <source>The two following opening hooks are provided by this module:</source>
          <target state="translated">이 모듈에는 다음과 같은 두 개의 개방 고리가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="aead13a3bf658785dba6c96c3877cce7bfdcf9ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;DOMString&lt;/code&gt; maps to Python strings. &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; supports either bytes or strings, but will normally produce strings. Values of type &lt;code&gt;DOMString&lt;/code&gt; may also be &lt;code&gt;None&lt;/code&gt; where allowed to have the IDL &lt;code&gt;null&lt;/code&gt; value by the DOM specification from the W3C.</source>
          <target state="translated">&lt;code&gt;DOMString&lt;/code&gt; 유형 은 Python 문자열에 맵핑됩니다. &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; &lt;/a&gt; 은 바이트 또는 문자열을 지원하지만 일반적으로 문자열을 생성합니다. &lt;code&gt;DOMString&lt;/code&gt; 유형의 값은 W3C의 DOM 스펙에 의해 IDL &lt;code&gt;null&lt;/code&gt; 값 을 가질 수 있는 경우 &lt;code&gt;None&lt;/code&gt; 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c595e9e60344120fd8650e635fb09cc7f554fb8e" translate="yes" xml:space="preserve">
          <source>The type for cell objects: such objects are used as containers for a function&amp;rsquo;s free variables.</source>
          <target state="translated">셀 객체의 유형 : 이러한 객체는 함수의 자유 변수에 대한 컨테이너로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="71d15bb94ba8cba5ce52cb311ed2945413c1e6a5" translate="yes" xml:space="preserve">
          <source>The type for code objects such as returned by &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 반환 한 것과 같은 코드 객체의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="92c00f883941b35d8d88ec760276dd05ae566ab3" translate="yes" xml:space="preserve">
          <source>The type info for introspection can be accessed via &lt;code&gt;Point2D.__annotations__&lt;/code&gt; and &lt;code&gt;Point2D.__total__&lt;/code&gt;. To allow using this feature with older versions of Python that do not support &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;TypedDict&lt;/code&gt; supports two additional equivalent syntactic forms:</source>
          <target state="translated">검사에 대한 유형 정보는 &lt;code&gt;Point2D.__annotations__&lt;/code&gt; 및 &lt;code&gt;Point2D.__total__&lt;/code&gt; 통해 액세스 할 수 있습니다 . 지원하지 않는 파이썬의 이전 버전에이 기능을 사용할 수 있도록하려면 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-17&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; , &lt;code&gt;TypedDict&lt;/code&gt; 의 지원이 개 추가 상응하는 구문 형태 :</target>
        </trans-unit>
        <trans-unit id="6883894e6bd2bb4b3e1642682cba68f7b9cb4b42" translate="yes" xml:space="preserve">
          <source>The type info for introspection can be accessed via &lt;code&gt;Point2D.__annotations__&lt;/code&gt; and &lt;code&gt;Point2D.__total__&lt;/code&gt;. To allow using this feature with older versions of Python that do not support &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, &lt;code&gt;TypedDict&lt;/code&gt; supports two additional equivalent syntactic forms:</source>
          <target state="translated">Introspection의 유형 정보는 &lt;code&gt;Point2D.__annotations__&lt;/code&gt; 및 &lt;code&gt;Point2D.__total__&lt;/code&gt; 통해 액세스 할 수 있습니다 . 지원하지 않는 파이썬의 이전 버전에이 기능을 사용할 수 있도록하려면 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-25&quot;&gt;&lt;strong&gt;PEP (526)&lt;/strong&gt;&lt;/a&gt; , &lt;code&gt;TypedDict&lt;/code&gt; 의 지원이 개 추가 상응하는 구문 형태 :</target>
        </trans-unit>
        <trans-unit id="bd18bd83b257d2f4e8efd82d8c82ff0e7639a2fe" translate="yes" xml:space="preserve">
          <source>The type is roughly equivalent to the following code:</source>
          <target state="translated">형식은 다음 코드와 대략 동일합니다.</target>
        </trans-unit>
        <trans-unit id="207228c87acec3636f2d576ab4dc507cd348293d" translate="yes" xml:space="preserve">
          <source>The type object for proxies of callable objects.</source>
          <target state="translated">호출 가능한 객체의 프록시에 대한 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e2b65c714818fb9af6dfc2060e17b6ec9e44a466" translate="yes" xml:space="preserve">
          <source>The type object for proxies of objects which are not callable.</source>
          <target state="translated">호출 할 수없는 객체의 프록시에 대한 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="2f87adab9b428d0dbbf82d7c97420fce2530fdb4" translate="yes" xml:space="preserve">
          <source>The type object for weak references objects.</source>
          <target state="translated">약한 참조 객체의 유형 객체입니다.</target>
        </trans-unit>
        <trans-unit id="aa5558fddf17c823ad3cef9043343cc8848a5e60" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt;-iterator objects, created by asynchronous generator functions.</source>
          <target state="translated">비동기 생성기 함수에 의해 작성된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-asynchronous-generator&quot;&gt;비동기 생성기-&lt;/a&gt; 반복자 오브젝트 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="fb3f39049fd95688f70b6d2f5803012a23c782f4" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; objects, created by &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 함수로 생성 된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="c085b6d1256e66aba3e73f22eb8afbb70e8ef9d0" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; returned by the &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function depends on the mode. When &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; is used to open a file in a text mode (&lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'rt'&lt;/code&gt;, etc.), it returns a subclass of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt; (specifically &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;). When used to open a file in a binary mode with buffering, the returned class is a subclass of &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;. The exact class varies: in read binary mode, it returns an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt;; in write binary and append binary modes, it returns an &lt;a href=&quot;io#io.BufferedWriter&quot;&gt;&lt;code&gt;io.BufferedWriter&lt;/code&gt;&lt;/a&gt;, and in read/write mode, it returns an &lt;a href=&quot;io#io.BufferedRandom&quot;&gt;&lt;code&gt;io.BufferedRandom&lt;/code&gt;&lt;/a&gt;. When buffering is disabled, the raw stream, a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 의 유형은 모드에 따라 다릅니다. 때 &lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 텍스트 모드에서 파일을 여는 데 사용됩니다 ( &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'wt'&lt;/code&gt; , &lt;code&gt;'rt'&lt;/code&gt; 등), 그것의 서브 리턴 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; (구체적 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 을&lt;/a&gt; ). 버퍼링을 사용하여 파일을 이진 모드로 여는 데 사용되는 경우 반환되는 클래스는 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 정확한 클래스는 다음과 같습니다. 읽기 이진 모드에서는 &lt;a href=&quot;io#io.BufferedReader&quot;&gt; &lt;code&gt;io.BufferedReader&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 이진 쓰기 및 이진 추가 모드에서는 &lt;a href=&quot;io#io.BufferedWriter&quot;&gt; &lt;code&gt;io.BufferedWriter&lt;/code&gt; 를&lt;/a&gt; 반환하고 읽기 / 쓰기 모드에서는&lt;a href=&quot;io#io.BufferedRandom&quot;&gt; &lt;code&gt;io.BufferedRandom&lt;/code&gt; &lt;/a&gt; . 버퍼링이 비활성화 된 경우, 원료 스트림의 서브 클래스&lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; 가&lt;/a&gt; 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9137c1f6ce5bd7c384224288ce23eb4e33c57845" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator objects, created by generator functions.</source>
          <target state="translated">의 타입 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 생성 기능에 의해 생성 -iterator 개체.</target>
        </trans-unit>
        <trans-unit id="51c3737cac091c710a9cdbbb1a2fd03113a51fe7" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;modules&lt;/a&gt;. Constructor takes the name of the module to be created and optionally its &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module&quot;&gt;모듈&lt;/a&gt; 유형 . 생성자는 만들 모듈의 이름과 선택적으로 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="291d37e4c9887ae702120f0529a3e97ebb306fbd" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-asynchronous-generator&quot;&gt;asynchronous generator&lt;/a&gt;-iterator objects, created by asynchronous generator functions.</source>
          <target state="translated">의 타입 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-asynchronous-generator&quot;&gt;비동기 발전기&lt;/a&gt; 비동기 생성 기능에 의해 생성 -iterator 개체.</target>
        </trans-unit>
        <trans-unit id="20b5b7b182a49432d464ffdc625a8f750463126a" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;coroutine&lt;/a&gt; objects, created by &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt;&lt;code&gt;async def&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#async-def&quot;&gt; &lt;code&gt;async def&lt;/code&gt; &lt;/a&gt; 함수에 의해 생성 된 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-coroutine&quot;&gt;코 루틴&lt;/a&gt; 객체 의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="0962ea0fff94bd2389dc9ecff0d9c99235c182c1" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; returned by the &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function depends on the mode. When &lt;a href=&quot;#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; is used to open a file in a text mode (&lt;code&gt;'w'&lt;/code&gt;, &lt;code&gt;'r'&lt;/code&gt;, &lt;code&gt;'wt'&lt;/code&gt;, &lt;code&gt;'rt'&lt;/code&gt;, etc.), it returns a subclass of &lt;a href=&quot;io#io.TextIOBase&quot;&gt;&lt;code&gt;io.TextIOBase&lt;/code&gt;&lt;/a&gt; (specifically &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;). When used to open a file in a binary mode with buffering, the returned class is a subclass of &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;. The exact class varies: in read binary mode, it returns an &lt;a href=&quot;io#io.BufferedReader&quot;&gt;&lt;code&gt;io.BufferedReader&lt;/code&gt;&lt;/a&gt;; in write binary and append binary modes, it returns an &lt;a href=&quot;io#io.BufferedWriter&quot;&gt;&lt;code&gt;io.BufferedWriter&lt;/code&gt;&lt;/a&gt;, and in read/write mode, it returns an &lt;a href=&quot;io#io.BufferedRandom&quot;&gt;&lt;code&gt;io.BufferedRandom&lt;/code&gt;&lt;/a&gt;. When buffering is disabled, the raw stream, a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;, is returned.</source>
          <target state="translated">&lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수가 반환하는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 의 유형은 모드에 따라 다릅니다. 경우 &lt;a href=&quot;#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 텍스트 모드에서 파일을 열기 위해 사용된다 ( &lt;code&gt;'w'&lt;/code&gt; , &lt;code&gt;'r'&lt;/code&gt; , &lt;code&gt;'wt'&lt;/code&gt; , &lt;code&gt;'rt'&lt;/code&gt; 등), 그것의 서브 리턴 &lt;a href=&quot;io#io.TextIOBase&quot;&gt; &lt;code&gt;io.TextIOBase&lt;/code&gt; &lt;/a&gt; (구체적 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 을&lt;/a&gt; ). 버퍼링이있는 바이너리 모드에서 파일을 여는 데 사용되는 경우 반환 된 클래스는 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 . 정확한 클래스는 다양합니다. 읽기 바이너리 모드에서는 &lt;a href=&quot;io#io.BufferedReader&quot;&gt; &lt;code&gt;io.BufferedReader&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 쓰기 바이너리 및 추가 바이너리 모드에서는 &lt;a href=&quot;io#io.BufferedWriter&quot;&gt; &lt;code&gt;io.BufferedWriter&lt;/code&gt; 를&lt;/a&gt; 반환하고 읽기 / 쓰기 모드에서는&lt;a href=&quot;io#io.BufferedRandom&quot;&gt; &lt;code&gt;io.BufferedRandom&lt;/code&gt; &lt;/a&gt; . 버퍼링이 비활성화되면&lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 인 원시 스트림이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f02c8a5211cfd9d6991973dae5c80b19e6a1c2d8" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generator&lt;/a&gt;-iterator objects, created by generator functions.</source>
          <target state="translated">의 타입 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;발전기&lt;/a&gt; 생성 기능에 의해 생성 -iterator 개체.</target>
        </trans-unit>
        <trans-unit id="ce115de470364ff83b5336167e2e5b10f9e8447a" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module&quot;&gt;modules&lt;/a&gt;. Constructor takes the name of the module to be created and optionally its &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module&quot;&gt;모듈&lt;/a&gt; 유형 . 생성자는 만들 모듈의 이름과 선택적으로 해당 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-docstring&quot;&gt;docstring을 사용&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="80ad83c0160d0aa864e6656bf7e1de1027e52421" translate="yes" xml:space="preserve">
          <source>The type of &lt;a href=&quot;stdtypes#types-genericalias&quot;&gt;parameterized generics&lt;/a&gt; such as &lt;code&gt;list[int]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list[int]&lt;/code&gt; 와 같은 &lt;a href=&quot;stdtypes#types-genericalias&quot;&gt;매개 변수화 된 제네릭&lt;/a&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="851dfab6c777918e2e97801375bfa3600e1be478" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;self.request&lt;/code&gt; is different for datagram or stream services. For stream services, &lt;code&gt;self.request&lt;/code&gt; is a socket object; for datagram services, &lt;code&gt;self.request&lt;/code&gt; is a pair of string and socket.</source>
          <target state="translated">&lt;code&gt;self.request&lt;/code&gt; 의 유형은 데이터 그램 또는 스트림 서비스에 따라 다릅니다. 스트림 서비스의 경우 &lt;code&gt;self.request&lt;/code&gt; 는 소켓 객체입니다. 데이터 그램 서비스의 경우 &lt;code&gt;self.request&lt;/code&gt; 는 문자열과 소켓 쌍입니다.</target>
        </trans-unit>
        <trans-unit id="39ace067e7b8a07177cd07450cb98fd890c32fb2" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;bound&lt;/em&gt; methods of some built-in data types and base classes. For example it is the type of &lt;code&gt;object().__str__&lt;/code&gt;.</source>
          <target state="translated">일부 내장 데이터 유형 및 기본 클래스 의 &lt;em&gt;바인딩 된&lt;/em&gt; 메소드 유형입니다 . 예를 들어, 이것은 &lt;code&gt;object().__str__&lt;/code&gt; 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="054ec7ace9d8f1f81933bf82d68367c2b78aad15" translate="yes" xml:space="preserve">
          <source>The type of &lt;em&gt;unbound&lt;/em&gt; class methods of some built-in data types such as &lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dict.__dict__['fromkeys']&lt;/code&gt; 와 같은 일부 내장 데이터 유형 의 &lt;em&gt;언 바운드&lt;/em&gt; 클래스 메소드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="edc6b284de88d85c6dcdc7c5fb2de19cafa4c532" translate="yes" xml:space="preserve">
          <source>The type of built-in functions like &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt;, and methods of built-in classes. (Here, the term &amp;ldquo;built-in&amp;rdquo; means &amp;ldquo;written in C&amp;rdquo;.)</source>
          <target state="translated">&lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 와 같은 내장 함수의 유형 및 내장 클래스의 메소드. 여기서 &quot;내장&quot;이라는 용어는 &quot;C로 작성 됨&quot;을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e7a3e7e227b15d7de2c5d33d406e0fdb0848b0ef" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;body_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">인코딩 유형 (base64 또는 quoted-printable)은 &lt;em&gt;body_encoding&lt;/em&gt; 속성을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="daa919876c8026bbd456f4980d7d66ce3c1e4e34" translate="yes" xml:space="preserve">
          <source>The type of encoding (base64 or quoted-printable) will be based on the &lt;em&gt;header_encoding&lt;/em&gt; attribute.</source>
          <target state="translated">인코딩 유형 (base64 또는 quoted-printable)은 &lt;em&gt;header_encoding&lt;/em&gt; 속성을 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="5f3fdc1f795bc115fa25d9a7ee9f014076d623a1" translate="yes" xml:space="preserve">
          <source>The type of file objects supported depends on the platform: on Windows, sockets are supported, but not pipes, whereas on Unix, both are supported (some other types may be supported as well, such as fifos or special file devices).</source>
          <target state="translated">지원되는 파일 객체의 유형은 플랫폼에 따라 다릅니다. Windows에서는 소켓이 지원되지만 파이프는 지원되지 않지만 Unix에서는 둘 다 지원됩니다 (fifo 또는 특수 파일 장치와 같은 다른 유형도 지원 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="3596a6e3c65ed88cc1d8e8b7d814d3dabfd3476a" translate="yes" xml:space="preserve">
          <source>The type of frame objects such as found in &lt;code&gt;tb.tb_frame&lt;/code&gt; if &lt;code&gt;tb&lt;/code&gt; is a traceback object.</source>
          <target state="translated">와 같은 프레임 객체의 유형 &lt;code&gt;tb.tb_frame&lt;/code&gt; &lt;code&gt;tb&lt;/code&gt; 가 트레이스 백 객체 인 경우 tb.tb_frame에 있는 .</target>
        </trans-unit>
        <trans-unit id="75460e66c894ac26297c70dd2c59bf341c1ac5d4" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types and base classes such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;object.__init__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;object.__lt__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">내장 데이터 유형 및 기본 클래스 (예 : &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;object.__init__()&lt;/code&gt; &lt;/a&gt; 의 메소드 유형 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;object.__lt__()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="006cc434974d0c712e82a1fc52ff84f562270642" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types and base classes such as &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;object.__init__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt;&lt;code&gt;object.__lt__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일부 내장 데이터 유형 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;object.__init__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__lt__&quot;&gt; &lt;code&gt;object.__lt__()&lt;/code&gt; &lt;/a&gt; 와 같은 기본 클래스의 메소드 유형 .</target>
        </trans-unit>
        <trans-unit id="802b8bb24f2cee63ab7e9a26db85ba1e69bde6fb" translate="yes" xml:space="preserve">
          <source>The type of methods of some built-in data types such as &lt;a href=&quot;stdtypes#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 내장 데이터 유형의 메소드 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="3d0fea4bd572efbc49d1a1be2c36df840b937e1d" translate="yes" xml:space="preserve">
          <source>The type of methods of user-defined class instances.</source>
          <target state="translated">사용자 정의 클래스 인스턴스의 메소드 유형</target>
        </trans-unit>
        <trans-unit id="d85b5663cf70afd56961d534baa36aa27fa3f1e2" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyGetSetDef&lt;/code&gt;, such as &lt;code&gt;FrameType.f_locals&lt;/code&gt; or &lt;code&gt;array.array.typecode&lt;/code&gt;. This type is used as descriptor for object attributes; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">&lt;code&gt;FrameType.f_locals&lt;/code&gt; 또는 &lt;code&gt;array.array.typecode&lt;/code&gt; 와 같이 &lt;code&gt;PyGetSetDef&lt;/code&gt; 를 사용 하여 확장 모듈에 정의 된 객체 유형입니다 . 이 유형은 객체 속성에 대한 설명 자로 사용됩니다. 그것은 같은 목적을 가지고&lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 유형갖지만 확장 모듈에 정의 된 클래스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65d9791079f3a5f0479b8fc1fe7de9de776be32e" translate="yes" xml:space="preserve">
          <source>The type of objects defined in extension modules with &lt;code&gt;PyMemberDef&lt;/code&gt;, such as &lt;code&gt;datetime.timedelta.days&lt;/code&gt;. This type is used as descriptor for simple C data members which use standard conversion functions; it has the same purpose as the &lt;a href=&quot;functions#property&quot;&gt;&lt;code&gt;property&lt;/code&gt;&lt;/a&gt; type, but for classes defined in extension modules.</source>
          <target state="translated">함께 확장 모듈에 정의 된 오브젝트의 유형 &lt;code&gt;PyMemberDef&lt;/code&gt; 같은, &lt;code&gt;datetime.timedelta.days&lt;/code&gt; . 이 유형은 표준 변환 함수를 사용하는 간단한 C 데이터 멤버의 설명 자로 사용됩니다. &lt;a href=&quot;functions#property&quot;&gt; &lt;code&gt;property&lt;/code&gt; &lt;/a&gt; 유형 과 동일한 목적을 갖지만 확장 모듈에 정의 된 클래스에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="af9c2c83b8c60dabd2c034b33bbb7fdb10e6d512" translate="yes" xml:space="preserve">
          <source>The type of socket used by the server; &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;socket.SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; are two common values.</source>
          <target state="translated">서버가 사용하는 소켓의 유형. &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;socket.SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;socket#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;socket.SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 은 두 가지 공통 값입니다.</target>
        </trans-unit>
        <trans-unit id="be204b93125e9374a47e9c0607ad154bb8bb9d7d" translate="yes" xml:space="preserve">
          <source>The type of the connection is determined by &lt;em&gt;family&lt;/em&gt; argument, but this can generally be omitted since it can usually be inferred from the format of &lt;em&gt;address&lt;/em&gt;. (See &lt;a href=&quot;#multiprocessing-address-formats&quot;&gt;Address Formats&lt;/a&gt;)</source>
          <target state="translated">연결 유형은 &lt;em&gt;family&lt;/em&gt; 인수에 의해 결정 되지만 일반적으로 &lt;em&gt;address&lt;/em&gt; 형식에서 유추 할 수 있으므로 일반적으로 생략 할 수 있습니다 . (보다&lt;a href=&quot;#multiprocessing-address-formats&quot;&gt; 주소 형식&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="bd30a5963bbcf91e157911dfc75bf91da7146bda" translate="yes" xml:space="preserve">
          <source>The type of the objects returned by &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#parser.sequence2st&quot;&gt;&lt;code&gt;sequence2st()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parser.sequence2st&quot;&gt; &lt;code&gt;sequence2st()&lt;/code&gt; &lt;/a&gt; 반환 한 객체의 유형 .</target>
        </trans-unit>
        <trans-unit id="2415aa71d53e852131b074eb25a6c6db74a53fb6" translate="yes" xml:space="preserve">
          <source>The type of the return values from the &lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt;&lt;code&gt;ParserCreate()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#xml.parsers.expat.ParserCreate&quot;&gt; &lt;code&gt;ParserCreate()&lt;/code&gt; &lt;/a&gt; 의 반환 값 유형 함수 .</target>
        </trans-unit>
        <trans-unit id="f1e00a1edd876419fe2ebe3767b0aed891735220" translate="yes" xml:space="preserve">
          <source>The type of the time value sequence returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;. It is an object with a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; interface: values can be accessed by index and by attribute name. The following values are present:</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 반환 한 시간 값 시퀀스의 유형입니다 . &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;명명 된 튜플&lt;/a&gt; 인터페이스 가있는 객체입니다. 색인과 속성 이름으로 값에 액세스 할 수 있습니다. 다음과 같은 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="053a7afe80b04d32a06bfff90db5eb35bc914e6d" translate="yes" xml:space="preserve">
          <source>The type of the time value sequence returned by &lt;a href=&quot;#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#time.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#time.strptime&quot;&gt;&lt;code&gt;strptime()&lt;/code&gt;&lt;/a&gt;. It is an object with a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt; interface: values can be accessed by index and by attribute name. The following values are present:</source>
          <target state="translated">&lt;a href=&quot;#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#time.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.strptime&quot;&gt; &lt;code&gt;strptime()&lt;/code&gt; &lt;/a&gt; 반환하는 시간 값 시퀀스의 유형입니다 . 이름이 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-named-tuple&quot;&gt;지정된 튜플&lt;/a&gt; 인터페이스 가있는 객체입니다 . 값은 인덱스 및 속성 이름으로 액세스 할 수 있습니다. 다음 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="17a09ba982dc1f24bfd7bfea4ab6a3ce49113c82" translate="yes" xml:space="preserve">
          <source>The type of traceback objects such as found in &lt;code&gt;sys.exc_info()[2]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sys.exc_info()[2]&lt;/code&gt; 있는 것과 같은 추적 오브젝트의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="14fb1882a83121d6512420b73ddf7c6df4b29e08" translate="yes" xml:space="preserve">
          <source>The type of user-defined functions and functions created by &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#lambda&quot;&gt; &lt;code&gt;lambda&lt;/code&gt; &lt;/a&gt; 식으로 작성된 사용자 정의 함수 및 함수의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="fdf47ff25ed233afa798ad63a4c3d489b4b155fe" translate="yes" xml:space="preserve">
          <source>The type of user-defined functions and functions created by &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#lambda&quot;&gt;&lt;code&gt;lambda&lt;/code&gt;&lt;/a&gt; expressions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#lambda&quot;&gt; &lt;code&gt;lambda&lt;/code&gt; &lt;/a&gt; 식으로 만든 사용자 정의 함수 및 함수의 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="845e42910aebf464f039df10da42d715e332ff1d" translate="yes" xml:space="preserve">
          <source>The type system of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module is extensible in two ways: you can store additional Python types in a SQLite database via object adaptation, and you can let the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module convert SQLite types to different Python types via converters.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 의 타입 시스템은 두 가지 방법으로 확장 할 수 있습니다. 객체 적응을 통해 추가 Python 유형을 SQLite 데이터베이스에 저장하고 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 변환기를 통해 SQLite 유형을 다른 Python 유형으로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3a6af98017fdeff071bf353e1479e07931b4d2f" translate="yes" xml:space="preserve">
          <source>The typecode character used to create the array.</source>
          <target state="translated">배열을 만드는 데 사용되는 형식 코드 문자</target>
        </trans-unit>
        <trans-unit id="0c959abb200e6f216cd6c46680afae3d3493423d" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;short int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, and &lt;code&gt;boolean&lt;/code&gt; all map to Python integer objects.</source>
          <target state="translated">유형 &lt;code&gt;short int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; 및 &lt;code&gt;boolean&lt;/code&gt; 파이썬 정수 객체에 대한 모든지도.</target>
        </trans-unit>
        <trans-unit id="4d560d8f900eca6af7a86605d169b14ce3732718" translate="yes" xml:space="preserve">
          <source>The typical programming style using condition variables uses the lock to synchronize access to some shared state; threads that are interested in a particular change of state call &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; repeatedly until they see the desired state, while threads that modify the state call &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; when they change the state in such a way that it could possibly be a desired state for one of the waiters. For example, the following code is a generic producer-consumer situation with unlimited buffer capacity:</source>
          <target state="translated">조건 변수를 사용하는 일반적인 프로그래밍 스타일은 잠금을 사용하여 일부 공유 상태에 대한 액세스를 동기화합니다. 국가 통화의 특정 변화에 관심이있는 스레드 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 그들이 원하는 상태를 볼 때까지 반복, 상태 호출을 수정 스레드가 동시에 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 그들은 같은 방법으로 상태를 변경하는 때 가능성이 될 수 있다고 웨이터 중 하나에 대한 원하는 상태. 예를 들어 다음 코드는 버퍼 용량이 무제한 인 일반적인 생산자 소비자 상황입니다.</target>
        </trans-unit>
        <trans-unit id="6cce4ca16ef59a2c9a6e26b00995455dbe5b43db" translate="yes" xml:space="preserve">
          <source>The typical usage to break into the debugger from a running program is to insert</source>
          <target state="translated">실행중인 프로그램에서 디버거에 침입하는 일반적인 사용법은 삽입하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="312b8c5e06e9b508c2dc3394df6f8c328dcdd28f" translate="yes" xml:space="preserve">
          <source>The typical usage to inspect a crashed program is:</source>
          <target state="translated">충돌 한 프로그램을 검사하는 일반적인 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="19aaa16d46a9088205f8b111d28555cd6514b9f9" translate="yes" xml:space="preserve">
          <source>The typical use is:</source>
          <target state="translated">일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f88d8816221987271260ee8ea49f5b5d7cf3e10" translate="yes" xml:space="preserve">
          <source>The uid and gid items are integers, all others are strings. &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; is raised if the entry asked for cannot be found.</source>
          <target state="translated">uid 및 gid 항목은 정수이고 다른 항목은 모두 문자열입니다. 요청한 항목을 찾을 수 없으면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1f5c1273b1d4b80fefb18a2d5748785e0ad812ac" translate="yes" xml:space="preserve">
          <source>The underlying &lt;code&gt;sqlite3&lt;/code&gt; library operates in &lt;code&gt;autocommit&lt;/code&gt; mode by default, but the Python &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module by default does not.</source>
          <target state="translated">기본 &lt;code&gt;sqlite3&lt;/code&gt; 라이브러리는 기본적으로 &lt;code&gt;autocommit&lt;/code&gt; 모드 에서 작동 하지만 기본적으로 Python &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="692c81225394c94ff32b84438ec4aa9ac22b33ab" translate="yes" xml:space="preserve">
          <source>The underlying Readline library API may be implemented by the &lt;code&gt;libedit&lt;/code&gt; library instead of GNU readline. On macOS the &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module detects which library is being used at run time.</source>
          <target state="translated">기본 Readline 라이브러리 API는 GNU readline 대신 &lt;code&gt;libedit&lt;/code&gt; 라이브러리 로 구현 될 수 있습니다 . macOS에서 &lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈은 런타임에 사용중인 라이브러리를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="cbd3a217e06ecf1e9ba395c9d3b83ea44a75be37" translate="yes" xml:space="preserve">
          <source>The underlying binary buffer (a &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist in some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; 가&lt;/a&gt; 처리 하는 기본 이진 버퍼 ( &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 인스턴스) 이것은 &lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; 의&lt;/a&gt; 일부가 아닙니다 API의 일부 구현에는 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c099cf6d6c9538690a044409fa62678eb6541891" translate="yes" xml:space="preserve">
          <source>The underlying mappings are stored in a list. That list is public and can be accessed or updated using the &lt;em&gt;maps&lt;/em&gt; attribute. There is no other state.</source>
          <target state="translated">기본 매핑은 목록에 저장됩니다. 이 목록은 공개이며 &lt;em&gt;maps&lt;/em&gt; 속성을 사용하여 액세스하거나 업데이트 할 수 있습니다 . 다른 상태는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c8ed57a843f0b2c56ec32e93f7034f9d564cc770" translate="yes" xml:space="preserve">
          <source>The underlying object of the memoryview:</source>
          <target state="translated">memoryview의 기본 객체 :</target>
        </trans-unit>
        <trans-unit id="74ffc7561de47c1ca7be4db22d58088aa8da9469" translate="yes" xml:space="preserve">
          <source>The underlying process creation and management in this module is handled by the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; class. It offers a lot of flexibility so that developers are able to handle the less common cases not covered by the convenience functions.</source>
          <target state="translated">이 모듈의 기본 프로세스 생성 및 관리는 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 클래스에서. 개발자가 편의 기능으로 다루지 않는 덜 일반적인 경우를 처리 할 수 ​​있도록 유연성이 매우 뛰어납니다.</target>
        </trans-unit>
        <trans-unit id="ba3e655d8ac47240c2d2f5980db91a3ca2ecc86b" translate="yes" xml:space="preserve">
          <source>The underlying raw stream (a &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; instance) that &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; deals with. This is not part of the &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; API and may not exist on some implementations.</source>
          <target state="translated">&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; 가 수행&lt;/a&gt; 하는 기본 원시 스트림 ( &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 인스턴스) 처리이것은 &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; 의&lt;/a&gt; 일부가 아닙니다 API의 일부 구현에는 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1573d571c13d16324a3c741bed96fa34d92b283" translate="yes" xml:space="preserve">
          <source>The unformatted error message.</source>
          <target state="translated">형식화되지 않은 오류 메시지</target>
        </trans-unit>
        <trans-unit id="05f3ae582f0c0636a61039860a85ef0508aa13e0" translate="yes" xml:space="preserve">
          <source>The unittest module can be used from the command line to run tests from modules, classes or even individual test methods:</source>
          <target state="translated">명령 행에서 unittest 모듈을 사용하여 모듈, 클래스 또는 개별 테스트 방법에서 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6dde9ab65dc4b9f7975e19a23a1127cf92b2b035" translate="yes" xml:space="preserve">
          <source>The uppercase letters &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt;. This value is not locale-dependent and will not change.</source>
          <target state="translated">대문자 &lt;code&gt;'ABCDEFGHIJKLMNOPQRSTUVWXYZ'&lt;/code&gt; 입니다. 이 값은 로캘에 따라 다르지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0854cdf9ca6554793143fab76b0e342cda85438d" translate="yes" xml:space="preserve">
          <source>The uppercasing algorithm used is described in section 3.13 of the Unicode Standard.</source>
          <target state="translated">사용 된 대문자 알고리즘은 유니 코드 표준의 3.13 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b9af9c2a1fd50996417214bffd38cd04caabd4" translate="yes" xml:space="preserve">
          <source>The use of &lt;code&gt;%Z&lt;/code&gt; is now deprecated, but the &lt;code&gt;%z&lt;/code&gt; escape that expands to the preferred hour/minute offset is not supported by all ANSI C libraries. Also, a strict reading of the original 1982 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; standard calls for a two-digit year (%y rather than %Y), but practice moved to 4-digit years long before the year 2000. After that, &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; became obsolete and the 4-digit year has been first recommended by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123&lt;/strong&gt;&lt;/a&gt; and then mandated by &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;%Z&lt;/code&gt; 사용은 더 이상 사용되지 않지만 원하는 시간 / 분 오프셋으로 확장 되는 &lt;code&gt;%z&lt;/code&gt; 이스케이프가 모든 ANSI C 라이브러리에서 지원되는 것은 아닙니다. 또한, 엄격한 원래 1982 년 독서 &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 822&lt;/strong&gt;&lt;/a&gt; 두 자리 연도의 표준 호출 (% y를 오히려 % Y에 비해), 그러나 실제로는 그 후 2000 년 전에 4 자리 연도 긴 이동, &lt;a href=&quot;https://tools.ietf.org/html/rfc822.html&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;RFC 822은&lt;/strong&gt;&lt;/a&gt; 폐기되었고, 4 자리 연도는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123.html&quot; id=&quot;index-21&quot;&gt;&lt;strong&gt;RFC 1123에&lt;/strong&gt;&lt;/a&gt; 의해 처음 추천 된 후 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 에 의해 위임되었습니다 .</target>
        </trans-unit>
        <trans-unit id="818e1de1ee279a3d12fd00fd42609c4b0aa39222" translate="yes" xml:space="preserve">
          <source>The use of a &lt;code&gt;CDATASection&lt;/code&gt; node does not indicate that the node represents a complete CDATA marked section, only that the content of the node was part of a CDATA section. A single CDATA section may be represented by more than one node in the document tree. There is no way to determine whether two adjacent &lt;code&gt;CDATASection&lt;/code&gt; nodes represent different CDATA marked sections.</source>
          <target state="translated">&lt;code&gt;CDATASection&lt;/code&gt; 노드를 사용 한다고해서 노드가 완전한 CDATA 표시 섹션을 나타내는 것은 아니며 노드의 컨텐츠가 CDATA 섹션의 일부일뿐입니다. 단일 CDATA 섹션은 문서 트리에서 둘 이상의 노드로 표시 될 수 있습니다. 인접한 두 &lt;code&gt;CDATASection&lt;/code&gt; 노드가 서로 다른 CDATA 표시 섹션을 나타내는 지 여부를 확인할 방법이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="e59fb5d1424421341c7c08cd960ce1c43d8cae74" translate="yes" xml:space="preserve">
          <source>The use of a bounded semaphore reduces the chance that a programming error which causes the semaphore to be released more than it&amp;rsquo;s acquired will go undetected.</source>
          <target state="translated">제한된 세마포어를 사용하면 세마포어가 획득 한 것보다 더 많이 해제되는 프로그래밍 오류가 감지되지 않을 가능성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="503e039e7a7945e22e53e684cd41c8ddeb2296c8" translate="yes" xml:space="preserve">
          <source>The use of decimal floating point eliminates decimal representation error (making it possible to represent &lt;code&gt;0.1&lt;/code&gt; exactly); however, some operations can still incur round-off error when non-zero digits exceed the fixed precision.</source>
          <target state="translated">10 진수 부동 소수점을 사용하면 10 진수 표현 오류가 제거됩니다 ( &lt;code&gt;0.1&lt;/code&gt; 을 정확하게 나타낼 수 있음). 그러나 0이 아닌 숫자가 고정 정밀도를 초과하면 일부 연산에서 여전히 반올림 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef05d3a555addffe6383bb0c2ceb5c3b10ece3a4" translate="yes" xml:space="preserve">
          <source>The use of dynamic dispatching by &lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt;&lt;code&gt;Repr.repr1()&lt;/code&gt;&lt;/a&gt; allows subclasses of &lt;a href=&quot;#reprlib.Repr&quot;&gt;&lt;code&gt;Repr&lt;/code&gt;&lt;/a&gt; to add support for additional built-in object types or to modify the handling of types already supported. This example shows how special support for file objects could be added:</source>
          <target state="translated">&lt;a href=&quot;#reprlib.Repr.repr1&quot;&gt; &lt;code&gt;Repr.repr1()&lt;/code&gt; &lt;/a&gt; 에서 동적 디스패치를 ​​사용 하면 &lt;a href=&quot;#reprlib.Repr&quot;&gt; &lt;code&gt;Repr&lt;/code&gt; 의&lt;/a&gt; 서브 클래스가 추가 내장 오브젝트 유형에 대한 지원을 추가하거나 이미 지원되는 유형의 처리를 수정할 수 있습니다. 이 예제는 파일 객체에 대한 특별한 지원을 추가하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="52d05a35e93648db761f9430668b0f890705b58d" translate="yes" xml:space="preserve">
          <source>The useful mapping keys in a &lt;a href=&quot;#logging.LogRecord&quot;&gt;&lt;code&gt;LogRecord&lt;/code&gt;&lt;/a&gt; are given in the section on &lt;a href=&quot;#logrecord-attributes&quot;&gt;LogRecord attributes&lt;/a&gt;.</source>
          <target state="translated">유용한 매핑 키 &lt;a href=&quot;#logging.LogRecord&quot;&gt; &lt;code&gt;LogRecord&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;#logrecord-attributes&quot;&gt; LogRecord 속성&lt;/a&gt; 섹션에있습니다.</target>
        </trans-unit>
        <trans-unit id="61191e6c79c749cd7aba4196b38f6b9a262afba8" translate="yes" xml:space="preserve">
          <source>The user does not instantiate a transport directly; they call a utility function, passing it a protocol factory and other information necessary to create the transport and protocol.</source>
          <target state="translated">사용자는 전송을 직접 인스턴스화하지 않습니다. 그들은 유틸리티 기능을 호출하여 프로토콜 팩토리와 전송 및 프로토콜을 작성하는 데 필요한 기타 정보를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="799492a2bc4f8c18e914c5fd6750e59de66fb8b8" translate="yes" xml:space="preserve">
          <source>The user of &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt;&lt;code&gt;mkdtemp()&lt;/code&gt;&lt;/a&gt; is responsible for deleting the temporary directory and its contents when done with it.</source>
          <target state="translated">의 사용자 &lt;a href=&quot;#tempfile.mkdtemp&quot;&gt; &lt;code&gt;mkdtemp()&lt;/code&gt; &lt;/a&gt;임시 디렉토리와 디렉토리 디렉토리의 내용을 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="50e266ba92d8277d2b2353b0363957a1543b30c2" translate="yes" xml:space="preserve">
          <source>The user-exposed type for the &lt;code&gt;GenericAlias&lt;/code&gt; object can be accessed from &lt;a href=&quot;types#types.GenericAlias&quot;&gt;&lt;code&gt;types.GenericAlias&lt;/code&gt;&lt;/a&gt; and used for &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; checks. It can also be used to create &lt;code&gt;GenericAlias&lt;/code&gt; objects directly.</source>
          <target state="translated">&lt;code&gt;GenericAlias&lt;/code&gt; 개체에 대한 사용자 노출 형식 은 &lt;a href=&quot;types#types.GenericAlias&quot;&gt; &lt;code&gt;types.GenericAlias&lt;/code&gt; &lt;/a&gt; 에서 액세스 할 수 있으며 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 검사에 사용할 수 있습니다 . &lt;code&gt;GenericAlias&lt;/code&gt; 개체를 직접 만드는데도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ee129ab0f90820dc953cf701d4d07af6a6196607" translate="yes" xml:space="preserve">
          <source>The user-provided request handler class; an instance of this class is created for each request.</source>
          <target state="translated">사용자 제공 요청 핸들러 클래스. 이 클래스의 인스턴스는 각 요청마다 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="72b7902f1383f94a27baa827eb01bca89cc62cbc" translate="yes" xml:space="preserve">
          <source>The usual &lt;a href=&quot;queue#queue.Empty&quot;&gt;&lt;code&gt;queue.Empty&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;queue#queue.Full&quot;&gt;&lt;code&gt;queue.Full&lt;/code&gt;&lt;/a&gt; exceptions from the standard library&amp;rsquo;s &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; module are raised to signal timeouts.</source>
          <target state="translated">일반적인 &lt;a href=&quot;queue#queue.Empty&quot;&gt; &lt;code&gt;queue.Empty&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 표준 라이브러리 대기열 의 &lt;a href=&quot;queue#queue.Full&quot;&gt; &lt;code&gt;queue.Full&lt;/code&gt; &lt;/a&gt; 예외 모듈 가 발생하여 시간 초과를 .</target>
        </trans-unit>
        <trans-unit id="4fb214e67950bddad6409524a77147f01c797d75" translate="yes" xml:space="preserve">
          <source>The usual approach to working with decimals is to create &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instances and then apply arithmetic operations which take place within the current context for the active thread. An alternative approach is to use context methods for calculating within a specific context. The methods are similar to those for the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; class and are only briefly recounted here.</source>
          <target state="translated">소수 자릿수 작업에 대한 일반적인 접근 방식은 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스를 만든 다음 현재 스레드 내에서 활성 스레드에 대해 수행되는 산술 연산을 적용하는 것입니다. 다른 방법은 특정 컨텍스트 내에서 계산하기 위해 컨텍스트 메소드를 사용하는 것입니다. 방법은 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 과 유사합니다. 클래스 여기서 간단히 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="7e0cd4e412d5835966f4133590beac72566aa7f2" translate="yes" xml:space="preserve">
          <source>The usual dictionary methods are available for &lt;a href=&quot;#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; objects except for two which work differently for counters.</source>
          <target state="translated">&lt;a href=&quot;#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt; 일반적인 사전 방법을 사용할 수 있습니다 대해 다르게 작동하는 두 가지를 제외하고 개체에 .</target>
        </trans-unit>
        <trans-unit id="fc3dad1947c78cee7834b38256f73aa158a2e66a" translate="yes" xml:space="preserve">
          <source>The usual fix is to either await the coroutine or call the &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">일반적인 수정은 코 루틴을 기다리거나 &lt;a href=&quot;asyncio-task#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 호출하는 것입니다. 함수를 .</target>
        </trans-unit>
        <trans-unit id="ab66de48e5569d8b04e6ed1de85c17b699cb8d3c" translate="yes" xml:space="preserve">
          <source>The usual restrictions for pickling apply: picklable enums must be defined in the top level of a module, since unpickling requires them to be importable from that module.</source>
          <target state="translated">피클 링에 대한 일반적인 제한 사항이 적용됩니다. 피클 링 가능 열거 형은 해당 모듈에서 가져올 수 있어야하므로 모듈의 최상위 레벨에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e12393a3161a5ffd9c52bf6911f34c236e2c9953" translate="yes" xml:space="preserve">
          <source>The usual start to using decimals is importing the module, viewing the current context with &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; and, if necessary, setting new values for precision, rounding, or enabled traps:</source>
          <target state="translated">십진수를 사용하는 일반적인 시작은 모듈을 가져오고 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 현재 컨텍스트를보고 필요한 경우 정밀도, 반올림 또는 사용 가능한 트랩에 대한 새 값을 설정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2008881e3db430ce4e534a59aaba96d96406f254" translate="yes" xml:space="preserve">
          <source>The valid options/values are:</source>
          <target state="translated">유효한 옵션 / 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="833f8e1091d762b7c244ed494067360a08b6e65e" translate="yes" xml:space="preserve">
          <source>The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in base 16). &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if &lt;em&gt;i&lt;/em&gt; is outside that range.</source>
          <target state="translated">인수의 유효한 범위는 0-1,114,111입니다 (16 진의 0x10FFFF). &lt;em&gt;i&lt;/em&gt; 가 해당 범위를 벗어나 면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c3f14b8f02287106623bf0b009141cb29a66c076" translate="yes" xml:space="preserve">
          <source>The value &lt;em&gt;n&lt;/em&gt; is an integer, or an object implementing &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;. Zero and negative values of &lt;em&gt;n&lt;/em&gt; clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for &lt;code&gt;s * n&lt;/code&gt; under &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 값 은 정수이거나 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 구현하는 객체 입니다. &lt;em&gt;n의&lt;/em&gt; 0과 음수 값은 시퀀스를 지 웁니다. 시퀀스의 항목은 복사되지 않습니다. &lt;a href=&quot;#typesseq-common&quot;&gt;공통 시퀀스 연산&lt;/a&gt; 에서 &lt;code&gt;s * n&lt;/code&gt; 에 대해 설명 된대로 여러 번 참조 됩니다.</target>
        </trans-unit>
        <trans-unit id="1ba1cd83c4ea949f698df2968249e46ad9293fd5" translate="yes" xml:space="preserve">
          <source>The value &lt;em&gt;n&lt;/em&gt; is an integer, or an object implementing &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt;&lt;code&gt;__index__()&lt;/code&gt;&lt;/a&gt;. Zero and negative values of &lt;em&gt;n&lt;/em&gt; clear the sequence. Items in the sequence are not copied; they are referenced multiple times, as explained for &lt;code&gt;s * n&lt;/code&gt; under &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 값 은 정수이거나 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__index__&quot;&gt; &lt;code&gt;__index__()&lt;/code&gt; &lt;/a&gt; 구현하는 객체 입니다. &lt;em&gt;n의&lt;/em&gt; 0 및 음수 값은 시퀀스를 지 웁니다. 시퀀스의 항목은 복사되지 않습니다. &lt;a href=&quot;#typesseq-common&quot;&gt;Common Sequence Operations&lt;/a&gt; 에서 &lt;code&gt;s * n&lt;/code&gt; 에 대해 설명한대로 여러 번 참조 됩니다.</target>
        </trans-unit>
        <trans-unit id="9f91839dd752530537b6fc14cfb59cfb821e2678" translate="yes" xml:space="preserve">
          <source>The value conversion will use the &amp;ldquo;alternate form&amp;rdquo; (where defined below).</source>
          <target state="translated">값 변환은 &quot;대체 형식&quot;(아래 정의 된 경우)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a2668d51d3a069a8b17be6a5bdb69b22691876de" translate="yes" xml:space="preserve">
          <source>The value is &lt;code&gt;True&lt;/code&gt;. Deprecated, because Python now always has threads.</source>
          <target state="translated">값은 &lt;code&gt;True&lt;/code&gt; 입니다. 이제 Python에는 항상 스레드가 있기 때문에 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dfd7f69b5373d9254a89d97b317bed89c36400a6" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;endpos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string beyond which the RE engine will not go.</source>
          <target state="translated">&lt;a href=&quot;#re-objects&quot;&gt;정규식 객체&lt;/a&gt; 의 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 &lt;em&gt;endpos&lt;/em&gt; 의 값 . 이것은 RE 엔진이 가지 않을 문자열에 대한 색인입니다.</target>
        </trans-unit>
        <trans-unit id="4d524ce944ce6faac364cea7cad2143666016939" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;pos&lt;/em&gt; which was passed to the &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; method of a &lt;a href=&quot;#re-objects&quot;&gt;regex object&lt;/a&gt;. This is the index into the string at which the RE engine started looking for a match.</source>
          <target state="translated">&lt;a href=&quot;#re-objects&quot;&gt;정규식 객체&lt;/a&gt; 의 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 메소드에 전달 된 &lt;em&gt;pos&lt;/em&gt; 의 값 . 이것은 RE 엔진이 일치를 찾기 시작한 문자열의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="2e998dbaff3bb1395e14cf6d02ecba7f97ecf5de" translate="yes" xml:space="preserve">
          <source>The value of each item is either a string, or &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if not present.</source>
          <target state="translated">각 항목의 값은 문자열이거나 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 존재하지 않는 경우 입니다.</target>
        </trans-unit>
        <trans-unit id="894da0d8a1deaf4025187c213b697678d4d8eea2" translate="yes" xml:space="preserve">
          <source>The value of the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; reporting flags in effect before the function was called is returned by the function.</source>
          <target state="translated">&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 의 가치함수가 호출되기 전에 유효한 보고 플래그 함수에 의해 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="f4b6f6af5fd914e4e1977bd8812ad275e173d35e" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;start&lt;/em&gt; parameter (or &lt;code&gt;0&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;시작&lt;/em&gt; 매개 변수 의 값 (또는 &lt;code&gt;0&lt;/code&gt; 매개 변수가 제공되지 않은 경우 )</target>
        </trans-unit>
        <trans-unit id="9ee46e1de13205f2274d5b605d7f91d5eb44066d" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;step&lt;/em&gt; parameter (or &lt;code&gt;1&lt;/code&gt; if the parameter was not supplied)</source>
          <target state="translated">&lt;em&gt;단계&lt;/em&gt; 매개 변수 의 값 (또는 매개 변수가 제공되지 않은 경우 &lt;code&gt;1&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3effb996f3fdf8925f1c3f71f6aef7653bb530e1" translate="yes" xml:space="preserve">
          <source>The value of the &lt;em&gt;stop&lt;/em&gt; parameter</source>
          <target state="translated">&lt;em&gt;정지&lt;/em&gt; 매개 변수 의 값</target>
        </trans-unit>
        <trans-unit id="b6df41c014faa1a95a93823c98dc9147024275f4" translate="yes" xml:space="preserve">
          <source>The value of the cookie.</source>
          <target state="translated">쿠키의 가치.</target>
        </trans-unit>
        <trans-unit id="c946fe7e22930d8d97dd543837147d8b1bce64ca" translate="yes" xml:space="preserve">
          <source>The value of the registry item.</source>
          <target state="translated">레지스트리 항목의 값입니다.</target>
        </trans-unit>
        <trans-unit id="88e44b4995d1d06c008be0ccf6fee3422ea4e070" translate="yes" xml:space="preserve">
          <source>The value of this variable can be changed before calling &lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; and the new value will take effect.</source>
          <target state="translated">이 변수의 값은 &lt;a href=&quot;#xml.dom.pulldom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 변경 될 수 있으며 새 값이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bde8c85afabd3e8125721b1ff7d5b17f9d9dee96" translate="yes" xml:space="preserve">
          <source>The value resulting from &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; is equal to the value that would be obtained by computing &lt;code&gt;(x**y)
% modulo&lt;/code&gt; with unbounded precision, but is computed more efficiently. The exponent of the result is zero, regardless of the exponents of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;modulo&lt;/code&gt;. The result is always exact.</source>
          <target state="translated">인한 값 &lt;code&gt;Context.power(x, y, modulo)&lt;/code&gt; 계산함으로써 획득 될 값과 동일하다 &lt;code&gt;(x**y) % modulo&lt;/code&gt; 바운드 정밀도를하지만, 더 효율적으로 계산된다. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;modulo&lt;/code&gt; 의 지수에 관계없이 결과 지수는 0입니다. 입니다. 결과는 항상 정확합니다.</target>
        </trans-unit>
        <trans-unit id="c59b0eb2c27f951fa0cace7c837f6202b755a295" translate="yes" xml:space="preserve">
          <source>The value returned is a named tuple of type &lt;a href=&quot;os#os.terminal_size&quot;&gt;&lt;code&gt;os.terminal_size&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 값은 &lt;a href=&quot;os#os.terminal_size&quot;&gt; &lt;code&gt;os.terminal_size&lt;/code&gt; &lt;/a&gt; 유형의 명명 된 튜플입니다 .</target>
        </trans-unit>
        <trans-unit id="7bc5693e6a9c72e20f0575057dd4ee5bc74f98db" translate="yes" xml:space="preserve">
          <source>The value returned may be larger than the &lt;em&gt;item&lt;/em&gt; added. If that isn&amp;rsquo;t desired, consider using &lt;a href=&quot;#heapq.heappushpop&quot;&gt;&lt;code&gt;heappushpop()&lt;/code&gt;&lt;/a&gt; instead. Its push/pop combination returns the smaller of the two values, leaving the larger value on the heap.</source>
          <target state="translated">반환 된 값이 추가 된 &lt;em&gt;항목&lt;/em&gt; 보다 클 수 있습니다 . 원하지 않는 경우 &lt;a href=&quot;#heapq.heappushpop&quot;&gt; &lt;code&gt;heappushpop()&lt;/code&gt; &lt;/a&gt; 대신 사용하십시오. 푸시 / 팝 조합은 두 값 중 작은 값을 반환하여 힙에 큰 값을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="d795005d4b340675bfb305f1568f0d0d9ec61967" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multiprocess&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">&lt;code&gt;wsgi.multiprocess&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 에서 기본값은 true입니다 . 이지만 다른 서브 클래스에서 다른 기본값 (또는 생성자가 설정)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90b6e14952af2c1c7e8dc26e1fb8bc2a1a91cdc" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.multithread&lt;/code&gt; environment variable. It defaults to true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but may have a different default (or be set by the constructor) in the other subclasses.</source>
          <target state="translated">&lt;code&gt;wsgi.multithread&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 의&lt;/a&gt; 기본값은 true 이지만 다른 서브 클래스에서 다른 기본값 (또는 생성자가 설정)을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16e4c0519d360e3b8f5f9b274c196a4c6f3d4db2" translate="yes" xml:space="preserve">
          <source>The value to be used for the &lt;code&gt;wsgi.run_once&lt;/code&gt; environment variable. It defaults to false in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt; sets it to true by default.</source>
          <target state="translated">&lt;code&gt;wsgi.run_once&lt;/code&gt; 환경 변수에 사용될 값 입니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; 의&lt;/a&gt; 기본값은 false 이지만 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 는 기본적으로 true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="78bd89035d6220ea534538c62645a0424951cebd" translate="yes" xml:space="preserve">
          <source>The value used to indicate that no namespace is associated with a node in the DOM. This is typically found as the &lt;code&gt;namespaceURI&lt;/code&gt; of a node, or used as the &lt;em&gt;namespaceURI&lt;/em&gt; parameter to a namespaces-specific method.</source>
          <target state="translated">네임 스페이스가 DOM의 노드와 연결되어 있지 않음을 나타내는 데 사용되는 값입니다. 이것은 일반적으로 노드 의 &lt;code&gt;namespaceURI&lt;/code&gt; 로 발견 되거나 &lt;em&gt;namespaceURI&lt;/em&gt; 로 사용됩니다.&lt;em&gt;&lt;/em&gt; 네임 특정 메소드 파라미터.</target>
        </trans-unit>
        <trans-unit id="64a84954e88a246f210c2cf21b6b1dd5abec1148" translate="yes" xml:space="preserve">
          <source>The values are chosen by &lt;code&gt;_generate_next_value_()&lt;/code&gt;, which can be overridden:</source>
          <target state="translated">값은 &lt;code&gt;_generate_next_value_()&lt;/code&gt; 에 의해 선택되며 이는 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9db8f1c845539b8dab56c95400b090e5768cb33d" translate="yes" xml:space="preserve">
          <source>The values in the tuple conceptually represent a span of literal text followed by a single replacement field. If there is no literal text (which can happen if two replacement fields occur consecutively), then &lt;em&gt;literal_text&lt;/em&gt; will be a zero-length string. If there is no replacement field, then the values of &lt;em&gt;field_name&lt;/em&gt;, &lt;em&gt;format_spec&lt;/em&gt; and &lt;em&gt;conversion&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">튜플의 값은 개념적으로 리터럴 텍스트의 범위와 단일 대체 필드를 나타냅니다. 리터럴 텍스트가없는 경우 (두 개의 대체 필드가 ​​연속적으로 발생하는 경우 발생할 수 있음) &lt;em&gt;literal_text&lt;/em&gt; 는 길이가 0 인 문자열입니다. 대체 필드의 다음 값이없는 경우 &lt;em&gt;FIELD_NAME&lt;/em&gt; , &lt;em&gt;format_spec&lt;/em&gt; 및 &lt;em&gt;변환은&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d52d8d3fc67f68d8f2426d8c8de4306ccc1f8e09" translate="yes" xml:space="preserve">
          <source>The values of the first two fields are constants defined in the &lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt;&lt;code&gt;xml.parsers.expat.model&lt;/code&gt;&lt;/a&gt; module. These constants can be collected in two groups: the model type group and the quantifier group.</source>
          <target state="translated">처음 두 필드의 값은 &lt;a href=&quot;#module-xml.parsers.expat.model&quot;&gt; &lt;code&gt;xml.parsers.expat.model&lt;/code&gt; 에&lt;/a&gt; 정의 된 상수입니다. 모듈에 입니다. 이러한 상수는 모델 유형 그룹과 수량 자 그룹의 두 그룹으로 수집 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1cd2108af5c3d292a414e185f45717815413a4" translate="yes" xml:space="preserve">
          <source>The variables below define the flags used in the &lt;a href=&quot;#stat.ST_MODE&quot;&gt;&lt;code&gt;ST_MODE&lt;/code&gt;&lt;/a&gt; field.</source>
          <target state="translated">아래 변수는 &lt;a href=&quot;#stat.ST_MODE&quot;&gt; &lt;code&gt;ST_MODE&lt;/code&gt; &lt;/a&gt; 필드 에서 사용되는 플래그를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="570a00c886bbaa011554650d24fe55f6f0971a79" translate="yes" xml:space="preserve">
          <source>The variables defined in the &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module are:</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 변수 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ee64058d781eef751c586d91741d6ad13c91889d" translate="yes" xml:space="preserve">
          <source>The variants which include a &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝 부분에&amp;ldquo;p&amp;rdquo;가 포함 된 변형 ( &lt;a href=&quot;#os.execlp&quot;&gt; &lt;code&gt;execlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execlpe&quot;&gt; &lt;code&gt;execlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execvp&quot;&gt; &lt;code&gt;execvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execvpe&quot;&gt; &lt;code&gt;execvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-26&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 다음 단락에서 설명 하는 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나를 사용하여 환경을 교체 할 때 새 환경이 &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;execl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execle&quot;&gt; &lt;code&gt;execle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 .&lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="055f633c5b8ba910989ddc0879461a87b09eb587" translate="yes" xml:space="preserve">
          <source>The variants which include a &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.execlp&quot;&gt;&lt;code&gt;execlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execlpe&quot;&gt;&lt;code&gt;execlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execvp&quot;&gt;&lt;code&gt;execvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execvpe&quot;&gt;&lt;code&gt;execvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-29&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;execl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execle&quot;&gt;&lt;code&gt;execle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.execv&quot;&gt;&lt;code&gt;execv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.execve&quot;&gt;&lt;code&gt;execve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-30&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝에 &quot;p&quot;가 포함 된 변종 ( &lt;a href=&quot;#os.execlp&quot;&gt; &lt;code&gt;execlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execlpe&quot;&gt; &lt;code&gt;execlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execvp&quot;&gt; &lt;code&gt;execvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execvpe&quot;&gt; &lt;code&gt;execvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-28&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 환경이 교체 될 때 ( 다음 단락에서 설명 하는 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나 사용 ) 새 환경이 &lt;code id=&quot;index-29&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;execl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execle&quot;&gt; &lt;code&gt;execle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.execv&quot;&gt; &lt;code&gt;execv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.execve&quot;&gt; &lt;code&gt;execve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-30&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 . &lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="9193f1ef76fbd673e45f1225a537e38ac8bf4170" translate="yes" xml:space="preserve">
          <source>The variants which include a second &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝 부분에 두 번째 &quot;p&quot;를 포함하는 변형 ( &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnlpe&quot;&gt; &lt;code&gt;spawnlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnvp&quot;&gt; &lt;code&gt;spawnvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-32&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 환경이 교체 될 때 ( 다음 단락에서 설명 된 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나를 사용하여 ) 새 환경이 &lt;code id=&quot;index-33&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawnl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnle&quot;&gt; &lt;code&gt;spawnle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnv&quot;&gt; &lt;code&gt;spawnv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnve&quot;&gt; &lt;code&gt;spawnve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 . &lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d6d9fa3e86467cc65004fa718f6f51be22a4063" translate="yes" xml:space="preserve">
          <source>The variants which include a second &amp;ldquo;p&amp;rdquo; near the end (&lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnlpe&quot;&gt;&lt;code&gt;spawnlpe()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnvp&quot;&gt;&lt;code&gt;spawnvp()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt;) will use the &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; environment variable to locate the program &lt;em&gt;file&lt;/em&gt;. When the environment is being replaced (using one of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*e&lt;/code&gt;&lt;/a&gt; variants, discussed in the next paragraph), the new environment is used as the source of the &lt;code id=&quot;index-35&quot;&gt;PATH&lt;/code&gt; variable. The other variants, &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawnl()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnle&quot;&gt;&lt;code&gt;spawnle()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.spawnv&quot;&gt;&lt;code&gt;spawnv()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#os.spawnve&quot;&gt;&lt;code&gt;spawnve()&lt;/code&gt;&lt;/a&gt;, will not use the &lt;code id=&quot;index-36&quot;&gt;PATH&lt;/code&gt; variable to locate the executable; &lt;em&gt;path&lt;/em&gt; must contain an appropriate absolute or relative path.</source>
          <target state="translated">끝에 두 번째 &quot;p&quot;가 포함 된 변형 ( &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnlpe&quot;&gt; &lt;code&gt;spawnlpe()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnvp&quot;&gt; &lt;code&gt;spawnvp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; )은 &lt;code id=&quot;index-34&quot;&gt;PATH&lt;/code&gt; 환경 변수를 사용 하여 프로그램 &lt;em&gt;파일&lt;/em&gt; 을 찾습니다 . 환경이 교체 될 때 ( 다음 단락에서 설명 하는 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*e&lt;/code&gt; &lt;/a&gt; 변형 중 하나 사용 ) 새 환경이 &lt;code id=&quot;index-35&quot;&gt;PATH&lt;/code&gt; 변수 의 소스로 사용됩니다 . 다른 변형 인 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawnl()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnle&quot;&gt; &lt;code&gt;spawnle()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.spawnv&quot;&gt; &lt;code&gt;spawnv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnve&quot;&gt; &lt;code&gt;spawnve()&lt;/code&gt; &lt;/a&gt; 는 &lt;code id=&quot;index-36&quot;&gt;PATH&lt;/code&gt; 변수를 사용 하여 실행 파일을 찾지 않습니다 . &lt;em&gt;통로&lt;/em&gt; 적절한 절대 또는 상대 경로를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="f460136362370229598b52a9bcbe0209c61fd006" translate="yes" xml:space="preserve">
          <source>The various &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; functions take a list of arguments for the new program loaded into the process. In each case, the first of these arguments is passed to the new program as its own name rather than as an argument a user may have typed on a command line. For the C programmer, this is the &lt;code&gt;argv[0]&lt;/code&gt; passed to a program&amp;rsquo;s &lt;code&gt;main()&lt;/code&gt;. For example, &lt;code&gt;os.execv('/bin/echo',
['foo', 'bar'])&lt;/code&gt; will only print &lt;code&gt;bar&lt;/code&gt; on standard output; &lt;code&gt;foo&lt;/code&gt; will seem to be ignored.</source>
          <target state="translated">다양한 &lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt; 함수는 프로세스에로드 된 새 프로그램에 대한 인수 목록을 가져옵니다. 각각의 경우, 이러한 인수 중 첫 번째 인수는 사용자가 명령 행에 입력 한 인수가 아닌 자체 이름으로 새 프로그램에 전달됩니다. C 프로그래머의 경우 이는 프로그램의 &lt;code&gt;main()&lt;/code&gt; 전달 된 &lt;code&gt;argv[0]&lt;/code&gt; 입니다. 예를 들어, &lt;code&gt;os.execv('/bin/echo', ['foo', 'bar'])&lt;/code&gt; 는 표준 출력 에서만 &lt;code&gt;bar&lt;/code&gt; 를 인쇄 합니다 . &lt;code&gt;foo&lt;/code&gt; 는 무시되는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="39516d842ad2ebf0ccc0148be3b60ceb8e23f56b" translate="yes" xml:space="preserve">
          <source>The various named parameters found in &lt;em&gt;Set-Cookie&lt;/em&gt; and &lt;em&gt;Set-Cookie2&lt;/em&gt; headers (eg. &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;expires&lt;/code&gt;) are conventionally referred to as &lt;em&gt;attributes&lt;/em&gt;. To distinguish them from Python attributes, the documentation for this module uses the term &lt;em&gt;cookie-attribute&lt;/em&gt; instead.</source>
          <target state="translated">&lt;em&gt;Set-Cookie&lt;/em&gt; 및 &lt;em&gt;Set-Cookie2&lt;/em&gt; 헤더 (예 : &lt;code&gt;domain&lt;/code&gt; 및 &lt;code&gt;expires&lt;/code&gt; )에 있는 다양한 명명 된 매개 변수 는 일반적으로 &lt;em&gt;속성&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . 파이썬 속성과 구별하기 위해이 모듈의 문서는 대신 &lt;em&gt;쿠키 속성&lt;/em&gt; 이라는 용어를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a9102cf75be9fce05b52770c18e9074f93ffc76b" translate="yes" xml:space="preserve">
          <source>The version number as a string, with any whitespace and/or comments removed.</source>
          <target state="translated">공백 및 / 또는 주석이 제거 된 문자열의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="609eb97fd5216df593e456b08820fbdecce59af0" translate="yes" xml:space="preserve">
          <source>The version number encoded as a single integer. This is guaranteed to increase with each version, including proper support for non-production releases. For example, to test that the Python interpreter is at least version 1.5.2, use:</source>
          <target state="translated">단일 정수로 인코딩 된 버전 번호입니다. 이것은 비 프로덕션 릴리스에 대한 적절한 지원을 포함하여 각 버전마다 증가 할 것입니다. 예를 들어 Python 인터프리터가 버전 1.5.2 이상인지 테스트하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d8b4cf55cc9ba4af98dcfd2188bb39d0808a2000" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a string.</source>
          <target state="translated">런타임 SQLite 라이브러리의 버전 번호입니다 (문자열).</target>
        </trans-unit>
        <trans-unit id="83cfbef62783b9adbc5d82cbd03374d9ffac04a3" translate="yes" xml:space="preserve">
          <source>The version number of the run-time SQLite library, as a tuple of integers.</source>
          <target state="translated">정수의 튜플 인 런타임 SQLite 라이브러리의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="82ad32d0ec3913612c3c798f838cb1d4b90e0ca4" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a string. This is not the version of the SQLite library.</source>
          <target state="translated">이 모듈의 버전 번호입니다 (문자열). 이것은 SQLite 라이브러리의 버전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b2bf9e254a8f2ed1bc7d1d04b5316dcc3367de2d" translate="yes" xml:space="preserve">
          <source>The version number of this module, as a tuple of integers. This is not the version of the SQLite library.</source>
          <target state="translated">이 모듈의 버전 번호는 정수 튜플입니다. 이것은 SQLite 라이브러리의 버전이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e547ed29557b93784e133bf96efb332e811697d" translate="yes" xml:space="preserve">
          <source>The version number used to form registry keys on Windows platforms. This is stored as string resource 1000 in the Python DLL. The value is normally the first three characters of &lt;a href=&quot;#sys.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt;. It is provided in the &lt;a href=&quot;#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; module for informational purposes; modifying this value has no effect on the registry keys used by Python.</source>
          <target state="translated">Windows 플랫폼에서 레지스트리 키를 형성하는 데 사용되는 버전 번호입니다. 이것은 파이썬 DLL에서 문자열 리소스 1000으로 저장됩니다. 값은 일반적으로 &lt;a href=&quot;#sys.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 의 처음 세 문자입니다 . 그것은에서 제공 &lt;a href=&quot;#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 정보를 제공하기위한 모듈; 이 값을 수정해도 Python에서 사용하는 레지스트리 키에는 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd9dddc1a822657d560f74f81863263cdf639a3e" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt;&lt;code&gt;BUILD_MAP&lt;/code&gt;&lt;/a&gt; specialized for constant keys. &lt;em&gt;count&lt;/em&gt; values are consumed from the stack. The top element on the stack contains a tuple of keys.</source>
          <target state="translated">상수 키에 특화된 &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt; &lt;code&gt;BUILD_MAP&lt;/code&gt; &lt;/a&gt; 버전 . &lt;em&gt;카운트&lt;/em&gt; 값은 스택에서 소비됩니다. 스택의 맨 위 요소에는 튜플 키가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e5971513ba2095f033e5bb93d0a5852c2eeb055" translate="yes" xml:space="preserve">
          <source>The version of &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt;&lt;code&gt;BUILD_MAP&lt;/code&gt;&lt;/a&gt; specialized for constant keys. Pops the top element on the stack which contains a tuple of keys, then starting from &lt;code&gt;TOS1&lt;/code&gt;, pops &lt;em&gt;count&lt;/em&gt; values to form values in the built dictionary.</source>
          <target state="translated">상수 키에 특화된 &lt;a href=&quot;#opcode-BUILD_MAP&quot;&gt; &lt;code&gt;BUILD_MAP&lt;/code&gt; &lt;/a&gt; 버전입니다 . 키의 튜플을 포함하는 스택의 최상위 요소를 &lt;code&gt;TOS1&lt;/code&gt; 다음 TOS1 에서 시작하여 &lt;em&gt;카운트&lt;/em&gt; 값을 팝 하여 빌드 된 사전에 값을 형성합니다.</target>
        </trans-unit>
        <trans-unit id="5bb4e85c9ec212eecd8d18482a8624ea4b9d922a" translate="yes" xml:space="preserve">
          <source>The version of the Unicode database used in this module.</source>
          <target state="translated">이 모듈에서 사용 된 유니 코드 데이터베이스의 버전.</target>
        </trans-unit>
        <trans-unit id="056761a5a01ae0e3f3f5bb2776ef234db9b6782e" translate="yes" xml:space="preserve">
          <source>The version string of the OpenSSL library loaded by the interpreter:</source>
          <target state="translated">인터프리터가로드 한 OpenSSL 라이브러리의 버전 문자열 :</target>
        </trans-unit>
        <trans-unit id="68f2bb2ab063964d03cb7301ec9bedfef871e189" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library actually loaded by the interpreter.</source>
          <target state="translated">인터프리터가 실제로로드 한 zlib 라이브러리의 버전 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="66895485e5b6e2239606f9c0e8f020dc482fd6aa" translate="yes" xml:space="preserve">
          <source>The version string of the zlib library that was used for building the module. This may be different from the zlib library actually used at runtime, which is available as &lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt;&lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모듈을 빌드하는 데 사용 된 zlib 라이브러리의 버전 문자열입니다. &lt;a href=&quot;#zlib.ZLIB_RUNTIME_VERSION&quot;&gt; &lt;code&gt;ZLIB_RUNTIME_VERSION&lt;/code&gt; &lt;/a&gt; 으로 사용 가능한 런타임에 실제로 사용되는 zlib 라이브러리와 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a928dd1d5b35bf2574f665823c8388fc665c61e" translate="yes" xml:space="preserve">
          <source>The virtual screen may be updated by a &lt;a href=&quot;#curses.window.noutrefresh&quot;&gt;&lt;code&gt;noutrefresh()&lt;/code&gt;&lt;/a&gt; call after write operations such as &lt;a href=&quot;#curses.window.addstr&quot;&gt;&lt;code&gt;addstr()&lt;/code&gt;&lt;/a&gt; have been performed on a window. The normal &lt;a href=&quot;#curses.window.refresh&quot;&gt;&lt;code&gt;refresh()&lt;/code&gt;&lt;/a&gt; call is simply &lt;code&gt;noutrefresh()&lt;/code&gt; followed by &lt;code&gt;doupdate()&lt;/code&gt;; if you have to update multiple windows, you can speed performance and perhaps reduce screen flicker by issuing &lt;code&gt;noutrefresh()&lt;/code&gt; calls on all windows, followed by a single &lt;code&gt;doupdate()&lt;/code&gt;.</source>
          <target state="translated">가상 화면은 다음 과 같은 쓰기 작업 후 &lt;a href=&quot;#curses.window.noutrefresh&quot;&gt; &lt;code&gt;noutrefresh()&lt;/code&gt; &lt;/a&gt; 호출 로 업데이트 될 수 있습니다.&lt;a href=&quot;#curses.window.addstr&quot;&gt; &lt;code&gt;addstr()&lt;/code&gt; &lt;/a&gt; 윈도우에서 수행되었다. 일반적인 &lt;a href=&quot;#curses.window.refresh&quot;&gt; &lt;code&gt;refresh()&lt;/code&gt; &lt;/a&gt; 호출은 단순히 &lt;code&gt;noutrefresh()&lt;/code&gt; 다음에 &lt;code&gt;doupdate()&lt;/code&gt; . 여러 개의 창을 업데이트해야하는 경우 모든 창에서 &lt;code&gt;noutrefresh()&lt;/code&gt; 호출을 실행 한 &lt;code&gt;doupdate()&lt;/code&gt; 단일 doupdate () 를 실행하여 성능을 높이고 화면 깜박임을 줄일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe10e8128cec2a8b853d046a9f0502bfff7b4b2b" translate="yes" xml:space="preserve">
          <source>The warnings filter controls whether warnings are ignored, displayed, or turned into errors (raising an exception).</source>
          <target state="translated">경고 필터는 경고를 무시, 표시 또는 오류로 전환할지 여부를 제어합니다 (예외 발생).</target>
        </trans-unit>
        <trans-unit id="81d6c008939066a9c786b974f1a35df744af57e8" translate="yes" xml:space="preserve">
          <source>The warnings filter is initialized by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; options passed to the Python interpreter command line and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable. The interpreter saves the arguments for all supplied entries without interpretation in &lt;a href=&quot;sys#sys.warnoptions&quot;&gt;&lt;code&gt;sys.warnoptions&lt;/code&gt;&lt;/a&gt;; the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module parses these when it is first imported (invalid options are ignored, after printing a message to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경고 필터는 Python 인터프리터 명령 행에 전달 된 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 옵션과&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; 에&lt;/a&gt; 환경 변수에 . 인터프리터는 &lt;a href=&quot;sys#sys.warnoptions&quot;&gt; &lt;code&gt;sys.warnoptions&lt;/code&gt; &lt;/a&gt; 에서 해석하지 않고 제공된 모든 항목에 대한 인수를 저장합니다 . &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 가 처음 가져올 때 모듈 (유효하지 않은 옵션에 대한 메시지를 인쇄 한 후, 무시하는 이러한 구문 분석 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 를을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="68eed415d9086a5dea30cb8df62a2a15e9f46d08" translate="yes" xml:space="preserve">
          <source>The warnings filter is initialized by &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; options passed to the Python interpreter command line and the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable. The interpreter saves the arguments for all supplied entries without interpretation in &lt;a href=&quot;sys#sys.warnoptions&quot;&gt;&lt;code&gt;sys.warnoptions&lt;/code&gt;&lt;/a&gt;; the &lt;a href=&quot;#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module parses these when it is first imported (invalid options are ignored, after printing a message to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">경고 필터는 Python 인터프리터 명령 줄과 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; &lt;/a&gt; 환경 변수에 전달 된 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 옵션에 의해 초기화됩니다 . 인터프리터는 &lt;a href=&quot;sys#sys.warnoptions&quot;&gt; &lt;code&gt;sys.warnoptions&lt;/code&gt; 에&lt;/a&gt; 해석없이 제공된 모든 항목에 대한 인수를 저장합니다 . &lt;a href=&quot;#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 가 처음 가져올 때 모듈 (유효하지 않은 옵션에 대한 메시지를 인쇄 한 후, 무시하는 이러한 구문 분석 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 를을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f2742895327f8f1c5d2fcfda5a226fa7f537c878" translate="yes" xml:space="preserve">
          <source>The watcher avoids disrupting other code spawning processes by polling every process explicitly on a &lt;code&gt;SIGCHLD&lt;/code&gt; signal.</source>
          <target state="translated">감시자는 모든 프로세스를 &lt;code&gt;SIGCHLD&lt;/code&gt; 신호 에 명시 적으로 폴링하여 다른 코드 생성 프로세스를 방해하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="10a8f59f5f02b63085e6b7ff709cd3f0f1ce5558" translate="yes" xml:space="preserve">
          <source>The way &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; are recorded means that where nested calls are made, the parameters of ancestor calls are not recorded and so will always compare equal:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 가 기록 되는 방식 은 중첩 된 호출이 수행되는 경우 상위 호출의 매개 변수가 기록되지 않으므로 항상 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="07fd27b7e683afd9d6a2777d2e2bc0e02e57826f" translate="yes" xml:space="preserve">
          <source>The widget state is a bitmap of independent state flags.</source>
          <target state="translated">위젯 상태는 독립 상태 플래그의 비트 맵입니다.</target>
        </trans-unit>
        <trans-unit id="ad9e57f84a79be5923c4fad7f02f67bfce0d0138" translate="yes" xml:space="preserve">
          <source>The widget&amp;rsquo;s value is invalid</source>
          <target state="translated">위젯 값이 유효하지 않습니다</target>
        </trans-unit>
        <trans-unit id="7a5decf7ad4f9356a33597c56799bfaaba97e9ea" translate="yes" xml:space="preserve">
          <source>The width of the column in pixels.</source>
          <target state="translated">열 너비 (픽셀)입니다.</target>
        </trans-unit>
        <trans-unit id="4be2057a0cedbaf57fa943fdd00e63d3ccac6ee5" translate="yes" xml:space="preserve">
          <source>The wrapped function is instrumented with a &lt;code&gt;cache_parameters()&lt;/code&gt; function that returns a new &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; showing the values for &lt;em&gt;maxsize&lt;/em&gt; and &lt;em&gt;typed&lt;/em&gt;. This is for information purposes only. Mutating the values has no effect.</source>
          <target state="translated">래핑 된 함수는 &lt;em&gt;maxsize&lt;/em&gt; 및 &lt;em&gt;typed&lt;/em&gt; 값을 표시 하는 새 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 를 반환하는 &lt;code&gt;cache_parameters()&lt;/code&gt; 함수로 계측됩니다 . 이것은 정보 제공 목적으로 만 사용됩니다. 값을 변경해도 효과가 없습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f13a55fc25371355d16c8ccfbb2ea8fb626f5b8b" translate="yes" xml:space="preserve">
          <source>The zero-based Julian day (0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). Leap days are counted, and it is possible to refer to February 29.</source>
          <target state="translated">0부터 시작하는 율리우스 일 (0 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 365). 윤일이 계산되며 2 월 29 일을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38a94f537c497bc41758e7de7dc18b5dc9e5aa4b" translate="yes" xml:space="preserve">
          <source>The zip file format allows arbitrary data to be prepended to a zip file. The zip application format uses this ability to prepend a standard POSIX &amp;ldquo;shebang&amp;rdquo; line to the file (&lt;code&gt;#!/path/to/interpreter&lt;/code&gt;).</source>
          <target state="translated">zip 파일 형식을 사용하면 임의의 데이터를 zip 파일 앞에 추가 할 수 있습니다. zip 애플리케이션 형식은이 기능을 사용하여 표준 POSIX&amp;ldquo;shebang&amp;rdquo;행을 파일 앞에 추가합니다 ( &lt;code&gt;#!/path/to/interpreter&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e0f5450f31911228fbdcb1860dad56d3814c81e" translate="yes" xml:space="preserve">
          <source>The zlib library home page.</source>
          <target state="translated">zlib 라이브러리 홈페이지.</target>
        </trans-unit>
        <trans-unit id="8affd2d9f0cad819c09a176405cd6b5206cef756" translate="yes" xml:space="preserve">
          <source>The zlib manual explains the semantics and usage of the library&amp;rsquo;s many functions.</source>
          <target state="translated">zlib 매뉴얼은 라이브러리의 많은 기능의 의미와 사용법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="190b6a003d5b9ea453b301c3e6ce588721c176be" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; gets a chance. If it accepts &lt;code&gt;a&lt;/code&gt;, all is well.</source>
          <target state="translated">그러면 &lt;code&gt;B&lt;/code&gt; 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 가 기회를 얻습니다. 그것이 받아들이 &lt;code&gt;a&lt;/code&gt; , 모두 잘 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f1e41ec37276bd4db3f77340d349801df4b385c" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;B&lt;/code&gt;&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt;&lt;code&gt;__radd__()&lt;/code&gt;&lt;/a&gt; gets a chance. If it accepts &lt;code&gt;a&lt;/code&gt;, all is well.</source>
          <target state="translated">그러면 &lt;code&gt;B&lt;/code&gt; 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__radd__&quot;&gt; &lt;code&gt;__radd__()&lt;/code&gt; &lt;/a&gt; 가 기회를 얻습니다. 이 수락하면 &lt;code&gt;a&lt;/code&gt; , 모두 잘 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f3cfe2af54d2f5c805181fe58a7558eae8452c" translate="yes" xml:space="preserve">
          <source>Then an interactive Python session may look like this:</source>
          <target state="translated">그런 다음 대화 형 Python 세션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c575aa8053687837f8a56e8486b23babe4c92cdd" translate="yes" xml:space="preserve">
          <source>Then follows a blank line signifying the end of the headers, and then the contents of the file are output. If the file&amp;rsquo;s MIME type starts with &lt;code&gt;text/&lt;/code&gt; the file is opened in text mode; otherwise binary mode is used.</source>
          <target state="translated">그런 다음 헤더의 끝을 나타내는 빈 줄을 따라 가면 파일의 내용이 출력됩니다. 파일의 MIME 형식이 &lt;code&gt;text/&lt;/code&gt; 시작하는 경우 하면 파일이 텍스트 모드로 열립니다. 그렇지 않으면 이진 모드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f553f569d6ec90354bbb3b909858d32b9e9096" translate="yes" xml:space="preserve">
          <source>Then the following version-specific directories are added to &lt;code&gt;sys.path&lt;/code&gt;, in this order:</source>
          <target state="translated">그런 다음 다음 버전 별 디렉토리가 &lt;code&gt;sys.path&lt;/code&gt; 에 추가됩니다. 에이 순서대로 .</target>
        </trans-unit>
        <trans-unit id="82f978014fab5239e5ba8297d9634d6b6d533b89" translate="yes" xml:space="preserve">
          <source>Then use &lt;em&gt;code&lt;/em&gt; as the encoding for &lt;a href=&quot;stdtypes#str.encode&quot;&gt;&lt;code&gt;str.encode()&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">그런 다음 &lt;a href=&quot;stdtypes#str.encode&quot;&gt; &lt;code&gt;str.encode()&lt;/code&gt; &lt;/a&gt; 의 인코딩으로 &lt;em&gt;코드&lt;/em&gt; 를 사용하십시오. 호출 .</target>
        </trans-unit>
        <trans-unit id="9e9915c4a4ddc41d5c5b32ca75771fe219177f58" translate="yes" xml:space="preserve">
          <source>Then when you inherit from &lt;code&gt;AutoNumber&lt;/code&gt; you can write your own &lt;code&gt;__init__&lt;/code&gt; to handle any extra arguments:</source>
          <target state="translated">그런 다음 &lt;code&gt;AutoNumber&lt;/code&gt; 에서 상속 할 때 추가 인수를 처리하기 위해 고유 한 &lt;code&gt;__init__&lt;/code&gt; 를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5799d48128610654dfc6147c53f4b2206c78fb2" translate="yes" xml:space="preserve">
          <source>Then you&amp;rsquo;ll read data from the &lt;code&gt;connstream&lt;/code&gt; and do something with it till you are finished with the client (or the client is finished with you):</source>
          <target state="translated">그런 다음 &lt;code&gt;connstream&lt;/code&gt; 에서 데이터를 읽습니다. 클라이언트가 끝날 때까지 (또는 클라이언트가 끝났을 때까지) 무언가를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="5b1e898fc07d61e53c63f3002ef704c95490010b" translate="yes" xml:space="preserve">
          <source>Theory</source>
          <target state="translated">Theory</target>
        </trans-unit>
        <trans-unit id="7fa259f892d2f161a72fca4bf8158be9adf1787b" translate="yes" xml:space="preserve">
          <source>There are 5 different cases for a mixed-type operation on subclasses of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt;. I&amp;rsquo;ll refer to all of the above code that doesn&amp;rsquo;t refer to &lt;code&gt;MyIntegral&lt;/code&gt; and &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; as &amp;ldquo;boilerplate&amp;rdquo;. &lt;code&gt;a&lt;/code&gt; will be an instance of &lt;code&gt;A&lt;/code&gt;, which is a subtype of &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt;), and &lt;code&gt;b : B &amp;lt;:
Complex&lt;/code&gt;. I&amp;rsquo;ll consider &lt;code&gt;a + b&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; 의&lt;/a&gt; 서브 클래스에서 혼합 유형 연산에 대한 5 가지 경우가 있습니다 . &lt;code&gt;MyIntegral&lt;/code&gt; 및 &lt;code&gt;OtherTypeIKnowAbout&lt;/code&gt; 을 &quot;boilerplate&quot;로 언급하지 않는 위의 모든 코드를 참조 하겠습니다 . &lt;code&gt;a&lt;/code&gt; 는 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;a : A &amp;lt;: Complex&lt;/code&gt; ) 및 &lt;code&gt;b : B &amp;lt;: Complex&lt;/code&gt; 의 하위 유형 인 &lt;code&gt;A&lt;/code&gt; 의 인스턴스입니다 . 나는 &lt;code&gt;a + b&lt;/code&gt; 고려할 것이다 .</target>
        </trans-unit>
        <trans-unit id="3f8916b69856c2223ef6abca8e6fa0e94754e630" translate="yes" xml:space="preserve">
          <source>There are a couple of useful utilities provided in the &lt;a href=&quot;#module-email.utils&quot;&gt;&lt;code&gt;email.utils&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-email.utils&quot;&gt; &lt;code&gt;email.utils&lt;/code&gt; &lt;/a&gt; 에는 몇 가지 유용한 유틸리티가 있습니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="db73f983c1ef412f0f0bf991d5c7b1526f785874" translate="yes" xml:space="preserve">
          <source>There are a few different ways of resolving this problem. The easiest, but not necessarily the least annoying, way is to simply set the required attributes on the mock after creation. Just because &lt;em&gt;autospec&lt;/em&gt; doesn&amp;rsquo;t allow you to fetch attributes that don&amp;rsquo;t exist on the spec it doesn&amp;rsquo;t prevent you setting them:</source>
          <target state="translated">이 문제를 해결하는 방법에는 몇 가지가 있습니다. 가장 성 가시지는 않지만 가장 성가신 방법은 생성 후 모의에 필요한 속성을 간단히 설정하는 것입니다. &lt;em&gt;자동 사양&lt;/em&gt; 때문에&lt;em&gt;&lt;/em&gt; 은 스펙에 존재하지 않는 속성을 가져올 수 설정을 방해하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d3aeadae92ca7f5170f43648b0bf091b7291fb4d" translate="yes" xml:space="preserve">
          <source>There are a few extra restriction which don&amp;rsquo;t apply to the &lt;em&gt;fork&lt;/em&gt; start method.</source>
          <target state="translated">&lt;em&gt;포크&lt;/em&gt; 스타트 방법 에는 적용되지 않는 몇 가지 추가 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d38135d96a58a5ba6397af560568ea76e6c5aa3e" translate="yes" xml:space="preserve">
          <source>There are a few things to note about this module which are important to making use of the data structures created. This is not a tutorial on editing the parse trees for Python code, but some examples of using the &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module are presented.</source>
          <target state="translated">생성 된 데이터 구조를 사용하는 데 중요한이 모듈에 대해 유의해야 할 사항이 몇 가지 있습니다. 이것은 파이썬 코드를위한 파싱 트리 편집에 대한 튜토리얼은 아니지만 &lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 몇 가지 예가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6a6fd0b5587b688c222bcb3323758db69747ea41" translate="yes" xml:space="preserve">
          <source>There are a few tools to extract the strings meant for translation. The original GNU &lt;strong&gt;gettext&lt;/strong&gt; only supported C or C++ source code but its extended version &lt;strong&gt;xgettext&lt;/strong&gt; scans code written in a number of languages, including Python, to find strings marked as translatable. &lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt; is a Python internationalization library that includes a &lt;code&gt;pybabel&lt;/code&gt; script to extract and compile message catalogs. Fran&amp;ccedil;ois Pinard&amp;rsquo;s program called &lt;strong&gt;xpot&lt;/strong&gt; does a similar job and is available as part of his &lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;po-utils package&lt;/a&gt;.</source>
          <target state="translated">번역을위한 문자열을 추출하는 몇 가지 도구가 있습니다. 원래 GNU &lt;strong&gt;gettext&lt;/strong&gt; 는 C 또는 C ++ 소스 코드 만 지원했지만 확장 버전 &lt;strong&gt;xgettext&lt;/strong&gt; 는 Python을 포함하여 여러 언어로 작성된 코드를 스캔하여 번역 가능으로 표시된 문자열을 찾습니다. &lt;a href=&quot;http://babel.pocoo.org/&quot;&gt;Babel&lt;/a&gt; 은 메시지 카탈로그를 추출하고 컴파일 하는 &lt;code&gt;pybabel&lt;/code&gt; 스크립트를 포함하는 Python 국제화 라이브러리입니다 . 프랑수아 Pinard의 프로그램이라고 &lt;strong&gt;xpot은&lt;/strong&gt; 비슷한 일을 자신의 일부로 볼 수 있습니다 &lt;a href=&quot;https://github.com/pinard/po-utils&quot;&gt;포 - 유틸 패키지&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="26f97faaa25467594fb9160eb8740b560db6b4f9" translate="yes" xml:space="preserve">
          <source>There are a few utility functions for framework authors to enable control-c handling functionality within test frameworks.</source>
          <target state="translated">프레임 워크 작성자가 테스트 프레임 워크 내에서 control-c 처리 기능을 사용할 수 있도록하는 몇 가지 유틸리티 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0bb7e25ceb0ffba66ad1c049f198424ce2c3808" translate="yes" xml:space="preserve">
          <source>There are a number of built-in exceptions that represent warning categories. This categorization is useful to be able to filter out groups of warnings.</source>
          <target state="translated">경고 범주를 나타내는 여러 가지 기본 제공 예외가 있습니다. 이 분류는 경고 그룹을 필터링하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="ab4deb2b4c65697178a9e91e651f82ce32bff537" translate="yes" xml:space="preserve">
          <source>There are a number of other caveats:</source>
          <target state="translated">다른 여러 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="740a6e1a370e644b8acad66b626c4251477d08b6" translate="yes" xml:space="preserve">
          <source>There are a number of uses for the &lt;em&gt;func&lt;/em&gt; argument. It can be set to &lt;a href=&quot;functions#min&quot;&gt;&lt;code&gt;min()&lt;/code&gt;&lt;/a&gt; for a running minimum, &lt;a href=&quot;functions#max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; for a running maximum, or &lt;a href=&quot;operator#operator.mul&quot;&gt;&lt;code&gt;operator.mul()&lt;/code&gt;&lt;/a&gt; for a running product. Amortization tables can be built by accumulating interest and applying payments. First-order &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;recurrence relations&lt;/a&gt; can be modeled by supplying the initial value in the iterable and using only the accumulated total in &lt;em&gt;func&lt;/em&gt; argument:</source>
          <target state="translated">&lt;em&gt;func&lt;/em&gt; 인수 에는 여러 가지 용도가 있습니다. 이 설정 될 수 &lt;a href=&quot;functions#min&quot;&gt; &lt;code&gt;min()&lt;/code&gt; &lt;/a&gt; 실행 최소, &lt;a href=&quot;functions#max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 주행 최대 또는 대한 &lt;a href=&quot;operator#operator.mul&quot;&gt; &lt;code&gt;operator.mul()&lt;/code&gt; &lt;/a&gt; 실행 제품. 상각 표는이자를 누적하고 지불을 적용하여 구축 할 수 있습니다. 1 차 &lt;a href=&quot;https://en.wikipedia.org/wiki/Recurrence_relation&quot;&gt;재귀 관계&lt;/a&gt; 는 iterable에 초기 값을 제공하고 &lt;em&gt;func&lt;/em&gt; 인수 에서 누적 된 합계 만 사용하여 모델링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d2c1754d16fc36acf6343a01e5a606d44c91330" translate="yes" xml:space="preserve">
          <source>There are actually two parser interfaces available for use, the &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API and the incremental &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; API. The &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; API is most useful if you have the entire text of the message in memory, or if the entire message lives in a file on the file system. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; is more appropriate when you are reading the message from a stream which might block waiting for more input (such as reading an email message from a socket). The &lt;a href=&quot;#email.parser.FeedParser&quot;&gt;&lt;code&gt;FeedParser&lt;/code&gt;&lt;/a&gt; can consume and parse the message incrementally, and only returns the root object when you close the parser.</source>
          <target state="translated">실제로 사용 가능한 두 가지 구문 분석기 인터페이스 인 &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; API와 증분 &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; API가 있습니다. &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; API를 사용하면 메모리에 메시지의 전체 텍스트가있는 경우에 가장 유용, 또는 파일 시스템에있는 파일의 전체 메시지의 삶 경우. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; &lt;/a&gt; 는 스트림에서 메시지를 읽을 때 소켓에서 전자 메일 메시지를 읽는 것과 같이 더 많은 입력 대기를 차단할 수있는 경우에 더 적합합니다. &lt;a href=&quot;#email.parser.FeedParser&quot;&gt; &lt;code&gt;FeedParser&lt;/code&gt; 는&lt;/a&gt; 소비 점진적으로 메시지를 구문 분석하고 파서을 닫을 경우에만 루트 개체를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="039266eeef2dff97e5e5130bed399d4f0600c2da" translate="yes" xml:space="preserve">
          <source>There are all kinds of additional metadata available on the &lt;code&gt;Distribution&lt;/code&gt; instance:</source>
          <target state="translated">&lt;code&gt;Distribution&lt;/code&gt; 인스턴스 에서 사용 가능한 모든 추가 메타 데이터가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddebb36a5d0bbfeddcd3da60a21d96401142db63" translate="yes" xml:space="preserve">
          <source>There are also experimental methods that give this class more mapping behavior. You can use them or you can use the standardized &lt;code&gt;getAttribute*()&lt;/code&gt; family of methods on the &lt;code&gt;Element&lt;/code&gt; objects.</source>
          <target state="translated">이 클래스에 더 많은 매핑 동작을 제공하는 실험적인 방법도 있습니다. 그것들을 사용하거나 &lt;code&gt;Element&lt;/code&gt; 객체 에 표준화 된 &lt;code&gt;getAttribute*()&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bc97db34ca865c4f6e13f984f32b85cf0430a9c" translate="yes" xml:space="preserve">
          <source>There are also other methods used to perform more specific checks, such as:</source>
          <target state="translated">보다 구체적인 검사를 수행하는 데 사용되는 다른 방법도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd66bff89abb178647e31e8d7b36f2b277e325f3" translate="yes" xml:space="preserve">
          <source>There are also several readonly attributes available:</source>
          <target state="translated">사용 가능한 몇 가지 읽기 전용 속성도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dbe98b62c6ac402e4adf807336479d380787150" translate="yes" xml:space="preserve">
          <source>There are also specific options for tabs:</source>
          <target state="translated">탭에 대한 특정 옵션도 있습니다.</target>
        </trans-unit>
        <trans-unit id="64b4683225cbfb5d8247369d9cbda217bda79fc7" translate="yes" xml:space="preserve">
          <source>There are also variants of these methods that simply return a string instead of printing it:</source>
          <target state="translated">문자열을 인쇄하는 대신 단순히 반환하는 이러한 메소드의 변형도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c959f4df3c12c67509677745222747e6ef2cf83a" translate="yes" xml:space="preserve">
          <source>There are cases, however, when applications need to use prefixes in character data or in attribute values, where they cannot safely be expanded automatically; the &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events supply the information to the application to expand prefixes in those contexts itself, if necessary.</source>
          <target state="translated">그러나 응용 프로그램이 문자 데이터 나 속성 값에 접 두부를 사용해야하는 경우 자동으로 안전하게 확장 할 수없는 경우가 있습니다. &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트가 필요한 경우, 그 상황에서 자신을 접두사를 확장하는 응용 프로그램에 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8ba631db31ee48915b3b121db2e36c181d8ccc00" translate="yes" xml:space="preserve">
          <source>There are certain guidelines and idioms which should be adhered to when using &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 을 사용할 때 준수해야하는 특정 지침 및 관용구가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="827dd66505bcf022799f1772f83bac7872cd90a3" translate="yes" xml:space="preserve">
          <source>There are currently 6 different protocols which can be used for pickling. The higher the protocol used, the more recent the version of Python needed to read the pickle produced.</source>
          <target state="translated">현재 산세에 사용할 수있는 6 가지 프로토콜이 있습니다. 사용 된 프로토콜이 높을수록 생성 된 피클을 읽는 데 필요한 최신 버전의 Python이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ead616e7256dcb5719abe40d028e6090d64aa306" translate="yes" xml:space="preserve">
          <source>There are currently two built-in set types, &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; type is mutable &amp;mdash; the contents can be changed using methods like &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt;. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; type is immutable and &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; &amp;mdash; its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</source>
          <target state="translated">있다 현재이 내장 된 세트 유형, &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 의&lt;/a&gt;. &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 유형 변경 가능한 - 콘텐츠 추천 방법은 사용하여 변경할 수 &lt;code&gt;add()&lt;/code&gt; 및 &lt;code&gt;remove()&lt;/code&gt; . 변경 가능하기 때문에 해시 값이 없으며 사전 키 또는 다른 세트의 요소로 사용할 수 없습니다. &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 의&lt;/a&gt; 유형이 불변 인&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt; 해쉬&lt;/a&gt; -가 생성 된 후, 그 내용이 변경 될 수 없다; 따라서 사전 키 또는 다른 세트의 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25dd1db02d57c5f3fcb570b27f1ec4c898afb3f1" translate="yes" xml:space="preserve">
          <source>There are currently two built-in set types, &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; type is mutable &amp;mdash; the contents can be changed using methods like &lt;code&gt;add()&lt;/code&gt; and &lt;code&gt;remove()&lt;/code&gt;. Since it is mutable, it has no hash value and cannot be used as either a dictionary key or as an element of another set. The &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; type is immutable and &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt; &amp;mdash; its contents cannot be altered after it is created; it can therefore be used as a dictionary key or as an element of another set.</source>
          <target state="translated">현재 두 가지 내장 세트 유형, &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 이&lt;/a&gt; 있습니다. &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 유형 변경 가능한 - 콘텐츠 추천 방법은 사용하여 변경할 수 &lt;code&gt;add()&lt;/code&gt; 및 &lt;code&gt;remove()&lt;/code&gt; . 변경 가능하므로 해시 값이 없으며 사전 키 또는 다른 세트의 요소로 사용할 수 없습니다. &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 의&lt;/a&gt; 유형이 불변 인 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-hashable&quot;&gt;해쉬&lt;/a&gt; -가 생성 된 후, 그 내용이 변경 될 수 없다; 따라서 사전 키 또는 다른 세트의 요소로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7e48ec5af476b663fb0695c8e11aa6c35b465db" translate="yes" xml:space="preserve">
          <source>There are default adapters for the date and datetime types in the datetime module. They will be sent as ISO dates/ISO timestamps to SQLite.</source>
          <target state="translated">datetime 모듈에는 날짜 및 날짜 / 시간 유형에 대한 기본 어댑터가 있습니다. SQL 날짜에는 ISO 날짜 / ISO 타임 스탬프로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="c9f000a68af366a9a5eefed22b9b119e2b234e96" translate="yes" xml:space="preserve">
          <source>There are eight built-in, named bitmaps: &lt;code&gt;'error'&lt;/code&gt;, &lt;code&gt;'gray25'&lt;/code&gt;, &lt;code&gt;'gray50'&lt;/code&gt;, &lt;code&gt;'hourglass'&lt;/code&gt;, &lt;code&gt;'info'&lt;/code&gt;, &lt;code&gt;'questhead'&lt;/code&gt;, &lt;code&gt;'question'&lt;/code&gt;, &lt;code&gt;'warning'&lt;/code&gt;. To specify an X bitmap filename, give the full path to the file, preceded with an &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt;.</source>
          <target state="translated">8 개의 내장 비트 맵이 있습니다 : &lt;code&gt;'error'&lt;/code&gt; , &lt;code&gt;'gray25'&lt;/code&gt; , &lt;code&gt;'gray50'&lt;/code&gt; , &lt;code&gt;'hourglass'&lt;/code&gt; , &lt;code&gt;'info'&lt;/code&gt; , &lt;code&gt;'questhead'&lt;/code&gt; , &lt;code&gt;'question'&lt;/code&gt; , &lt;code&gt;'warning'&lt;/code&gt; 있습니다. X 비트 맵 파일 이름을 지정하려면 &lt;code&gt;&quot;@/usr/contrib/bitmap/gumby.bit&quot;&lt;/code&gt; 에서 와 같이 &lt;code&gt;@&lt;/code&gt; 앞에 파일의 전체 경로를 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="cdfda48041a9be25615bc1e181ea720f1ed03d01" translate="yes" xml:space="preserve">
          <source>There are eight comparison operations in Python. They all have the same priority (which is higher than that of the Boolean operations). Comparisons can be chained arbitrarily; for example, &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; is equivalent to &lt;code&gt;x &amp;lt; y and
y &amp;lt;= z&lt;/code&gt;, except that &lt;em&gt;y&lt;/em&gt; is evaluated only once (but in both cases &lt;em&gt;z&lt;/em&gt; is not evaluated at all when &lt;code&gt;x &amp;lt; y&lt;/code&gt; is found to be false).</source>
          <target state="translated">파이썬에는 8 가지 비교 연산이 있습니다. 모두 동일한 우선 순위를 갖습니다 (부울 연산보다 우선 순위가 높음). 비교는 임의로 연결될 수 있습니다. 예를 들어, &lt;code&gt;x &amp;lt; y &amp;lt;= z&lt;/code&gt; 는 &lt;em&gt;y&lt;/em&gt; 가 한 번만 평가 된다는 점을 제외하고 &lt;code&gt;x &amp;lt; y and y &amp;lt;= z&lt;/code&gt; 같습니다 (두 경우 모두 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 가 false 인 경우 &lt;em&gt;z&lt;/em&gt; 는 전혀 평가되지 않음 ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9237bbf2789014dc169fd8c3d198b4953c139" translate="yes" xml:space="preserve">
          <source>There are five classes in an inheritance diagram, four of which represent synchronous servers of four types:</source>
          <target state="translated">상속 다이어그램에는 5 개의 클래스가 있으며 그 중 4 개는 4 가지 유형의 동기 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="121f7346d52a69a5317d8485ce670ca978d629c2" translate="yes" xml:space="preserve">
          <source>There are four basic concrete server classes:</source>
          <target state="translated">다음과 같은 네 가지 기본 구체적 서버 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="28d84994e74ad89bc8bd10dab4568463a23f06e4" translate="yes" xml:space="preserve">
          <source>There are four keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt;, &lt;em&gt;stack_info&lt;/em&gt;, &lt;em&gt;stacklevel&lt;/em&gt; and &lt;em&gt;extra&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; 에는 4 가지 키워드 인수가 있습니다 .&lt;em&gt; exc_info&lt;/em&gt; , &lt;em&gt;stack_info&lt;/em&gt; , &lt;em&gt;stacklevel&lt;/em&gt; 및 &lt;em&gt;extra&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c8904775f6163564a009e440caf9e4700413f210" translate="yes" xml:space="preserve">
          <source>There are four main kinds of services provided by this module: type checking, getting source code, inspecting classes and functions, and examining the interpreter stack.</source>
          <target state="translated">이 모듈에서 제공하는 4 가지 주요 서비스 유형은 유형 검사, 소스 코드 가져 오기, 클래스 및 함수 검사 및 인터프리터 스택 검사입니다.</target>
        </trans-unit>
        <trans-unit id="607a56c6d25a7712202e05cdfe56d0f4635a21c9" translate="yes" xml:space="preserve">
          <source>There are functions that read/write files as well as functions operating on bytes-like objects.</source>
          <target state="translated">바이트와 ​​유사한 객체에서 작동하는 기능뿐만 아니라 파일을 읽고 쓰는 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aa3669afb266251babb0404fcc0d929459102f0" translate="yes" xml:space="preserve">
          <source>There are fundamental differences between the pickle protocols and &lt;a href=&quot;http://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt;:</source>
          <target state="translated">피클 프로토콜과 &lt;a href=&quot;http://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt; 사이에는 근본적인 차이점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e5dd8651ecb02f7953e2ebd99e2bb62fd9a640c" translate="yes" xml:space="preserve">
          <source>There are fundamental differences between the pickle protocols and &lt;a href=&quot;https://json.org&quot;&gt;JSON (JavaScript Object Notation)&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eff3e0b7d4ac0260b5fcec0fd569b30b6694a180" translate="yes" xml:space="preserve">
          <source>There are many useful subclasses of Variable already defined: &lt;code&gt;StringVar&lt;/code&gt;, &lt;code&gt;IntVar&lt;/code&gt;, &lt;code&gt;DoubleVar&lt;/code&gt;, and &lt;code&gt;BooleanVar&lt;/code&gt;. To read the current value of such a variable, call the &lt;code&gt;get()&lt;/code&gt; method on it, and to change its value you call the &lt;code&gt;set()&lt;/code&gt; method. If you follow this protocol, the widget will always track the value of the variable, with no further intervention on your part.</source>
          <target state="translated">&lt;code&gt;StringVar&lt;/code&gt; , &lt;code&gt;IntVar&lt;/code&gt; , &lt;code&gt;DoubleVar&lt;/code&gt; 및 &lt;code&gt;BooleanVar&lt;/code&gt; 와 같이 이미 정의 된 변수의 유용한 하위 클래스가 많이 있습니다 . 이러한 변수의 현재 값을 읽으려면 &lt;code&gt;get()&lt;/code&gt; 메소드를 호출하고 값을 변경하려면 &lt;code&gt;set()&lt;/code&gt; 메소드 를 호출하십시오 . 이 프로토콜을 따르는 경우 위젯은 사용자의 추가 개입없이 항상 변수 값을 추적합니다.</target>
        </trans-unit>
        <trans-unit id="bf2f9d53cf6bf41d410d3108dd0294a79a931d55" translate="yes" xml:space="preserve">
          <source>There are nearly as many INI format variants as there are applications using it. &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; goes a long way to provide support for the largest sensible set of INI styles available. The default functionality is mainly dictated by historical background and it&amp;rsquo;s very likely that you will want to customize some of the features.</source>
          <target state="translated">INI 형식 변형은 응용 프로그램을 사용하는 것만큼이나 많습니다. &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 는 사용 가능한 가장 큰 INI 스타일 세트를 지원하기 위해 먼 길을갑니다. 기본 기능은 주로 역사적 배경에 의해 결정되며 일부 기능을 사용자 정의하려는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="3265267da2983bf14017aa5df9e7283accfab3d4" translate="yes" xml:space="preserve">
          <source>There are only two ways to have a program on a single processor do &amp;ldquo;more than one thing at a time.&amp;rdquo; Multi-threaded programming is the simplest and most popular way to do it, but there is another very different technique, that lets you have nearly all the advantages of multi-threading, without actually using multiple threads. It&amp;rsquo;s really only practical if your program is largely I/O bound. If your program is processor bound, then pre-emptive scheduled threads are probably what you really need. Network servers are rarely processor bound, however.</source>
          <target state="translated">단일 프로세서에서 한 번에 하나 이상의 프로그램을 수행하는 방법은 두 가지뿐입니다. 멀티 스레드 프로그래밍은 가장 단순하고 가장 널리 사용되는 방법이지만 실제로는 여러 스레드를 사용하지 않고도 멀티 스레딩의 거의 모든 이점을 얻을 수있는 매우 다른 기술이 있습니다. 프로그램이 주로 I / O 바운드 인 경우에만 실용적입니다. 프로그램이 프로세서 바운드 인 경우 선점 예약 된 스레드가 실제로 필요한 것일 수 있습니다. 그러나 네트워크 서버는 프로세서에 거의 묶이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="634f390469439c342320f71f9c406a991d40d6d4" translate="yes" xml:space="preserve">
          <source>There are others, but you get the idea.</source>
          <target state="translated">다른 사람들도 있지만 아이디어를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="1134b66828043dd74bbedfe812d93fef9cb20d28" translate="yes" xml:space="preserve">
          <source>There are really two flavors of function objects: built-in functions and user-defined functions. Both support the same operation (to call the function), but the implementation is different, hence the different object types.</source>
          <target state="translated">내장 함수와 사용자 정의 함수라는 두 가지 기능 개체가 있습니다. 둘 다 동일한 함수 (함수 호출)를 지원하지만 구현 방식이 다르므로 객체 유형이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="c6e44b629dc613ba239924b475b903b7f82838d4" translate="yes" xml:space="preserve">
          <source>There are several equivalent ways to specify IP network masks. A &lt;em&gt;prefix&lt;/em&gt;&lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; is a notation that denotes how many high-order bits are set in the network mask. A &lt;em&gt;net mask&lt;/em&gt; is an IP address with some number of high-order bits set. Thus the prefix &lt;code&gt;/24&lt;/code&gt; is equivalent to the net mask &lt;code&gt;255.255.255.0&lt;/code&gt; in IPv4, or &lt;code&gt;ffff:ff00::&lt;/code&gt; in IPv6. In addition, a &lt;em&gt;host mask&lt;/em&gt; is the logical inverse of a &lt;em&gt;net mask&lt;/em&gt;, and is sometimes used (for example in Cisco access control lists) to denote a network mask. The host mask equivalent to &lt;code&gt;/24&lt;/code&gt; in IPv4 is &lt;code&gt;0.0.0.255&lt;/code&gt;.</source>
          <target state="translated">IP 네트워크 마스크를 지정하는 몇 가지 동등한 방법이 있습니다. &lt;em&gt;접두어 &lt;/em&gt; &lt;code&gt;/&amp;lt;nbits&amp;gt;&lt;/code&gt; 인 것을 나타내고 표기 많은 상위 비트가 네트워크 마스크 설정 방법. &lt;em&gt;네트 마스크&lt;/em&gt; 설정 상위 일부 비트 번호와 IP 주소이다. 따라서 접두사 &lt;code&gt;/24&lt;/code&gt; 는 IPv4 의 네트 마스크 &lt;code&gt;255.255.255.0&lt;/code&gt; 또는 IPv6의 &lt;code&gt;ffff:ff00::&lt;/code&gt; 와 같습니다 . 또한 &lt;em&gt;호스트 마스크&lt;/em&gt; 는 &lt;em&gt;네트 마스크&lt;/em&gt; 의 논리적 역수이며 네트워크 마스크를 나타내는 데 (예 : Cisco 액세스 제어 목록에서) 사용되기도합니다. IPv4에서 &lt;code&gt;/24&lt;/code&gt; 에 해당하는 호스트 마스크 는 &lt;code&gt;0.0.0.255&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3033320704915eae39fe9125e77acd8933f72624" translate="yes" xml:space="preserve">
          <source>There are several ways to enable asyncio debug mode:</source>
          <target state="translated">asyncio 디버그 모드를 활성화하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3b8d5ccd917cf795ff7b17c62847945d840d34" translate="yes" xml:space="preserve">
          <source>There are several ways to load shared libraries into the Python process. One way is to instantiate one of the following classes:</source>
          <target state="translated">공유 라이브러리를 Python 프로세스에로드하는 방법에는 여러 가지가 있습니다. 한 가지 방법은 다음 클래스 중 하나를 인스턴스화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3558a0588ae9ae9394f53aa612b4c8aa871ac418" translate="yes" xml:space="preserve">
          <source>There are some edges in &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; where you might expect something other than what actually happens.</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 에는 실제로 발생하는 것 이외의 것을 기대할 수있는 몇 가지 모서리 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="672b298f2b28f05dcbc4d251f921b55fca7bb3d1" translate="yes" xml:space="preserve">
          <source>There are some limitations to the process of bundling your application into a single file. In most, if not all, cases they can be addressed without needing major changes to your application.</source>
          <target state="translated">응용 프로그램을 단일 파일로 묶는 프로세스에는 몇 가지 제한이 있습니다. 전부는 아니더라도 대부분의 경우 응용 프로그램을 크게 변경하지 않고도 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8efcbf8ecf4671c1e1fcda5c45fbcf4a0ffec20" translate="yes" xml:space="preserve">
          <source>There are some more variants of the tar format which can be read, but not created:</source>
          <target state="translated">읽을 수는 있지만 만들 수없는 tar 형식의 변형이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="14e72aad41ffed86193f1ed0cab701906fad72ac" translate="yes" xml:space="preserve">
          <source>There are some small differences between arithmetic on Decimal objects and arithmetic on integers and floats. When the remainder operator &lt;code&gt;%&lt;/code&gt; is applied to Decimal objects, the sign of the result is the sign of the &lt;em&gt;dividend&lt;/em&gt; rather than the sign of the divisor:</source>
          <target state="translated">Decimal 객체의 산술과 ​​정수 및 부동 소수점의 산술에는 약간의 차이가 있습니다. 나머지 연산자 &lt;code&gt;%&lt;/code&gt; 가 Decimal 객체에 적용되면 결과 의 부호는 제수의 부호가 아닌 &lt;em&gt;배당&lt;/em&gt; 의 부호입니다.</target>
        </trans-unit>
        <trans-unit id="b9b322cbdf6ae8c9c74fcf1ab35d16b9dd8646b3" translate="yes" xml:space="preserve">
          <source>There are three basic sequence types: lists, tuples, and range objects. Additional sequence types tailored for processing of &lt;a href=&quot;#binaryseq&quot;&gt;binary data&lt;/a&gt; and &lt;a href=&quot;#textseq&quot;&gt;text strings&lt;/a&gt; are described in dedicated sections.</source>
          <target state="translated">기본 시퀀스 유형에는 목록, 튜플 및 범위 객체의 세 가지가 있습니다. &lt;a href=&quot;#binaryseq&quot;&gt;이진 데이터&lt;/a&gt; 및 &lt;a href=&quot;#textseq&quot;&gt;텍스트 문자열&lt;/a&gt; 처리에 적합한 추가 시퀀스 유형 은 전용 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b817f8bcc6d4362e55e4611c3d0e8efda6956674" translate="yes" xml:space="preserve">
          <source>There are three different ways to call this function:</source>
          <target state="translated">이 함수를 호출하는 방법에는 세 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b0c875a78b7f62cbc06fe3fdf0cb3be83425f3f" translate="yes" xml:space="preserve">
          <source>There are three distinct numeric types: &lt;em&gt;integers&lt;/em&gt;, &lt;em&gt;floating point numbers&lt;/em&gt;, and &lt;em&gt;complex numbers&lt;/em&gt;. In addition, Booleans are a subtype of integers. Integers have unlimited precision. Floating point numbers are usually implemented using &lt;code&gt;double&lt;/code&gt; in C; information about the precision and internal representation of floating point numbers for the machine on which your program is running is available in &lt;a href=&quot;sys#sys.float_info&quot;&gt;&lt;code&gt;sys.float_info&lt;/code&gt;&lt;/a&gt;. Complex numbers have a real and imaginary part, which are each a floating point number. To extract these parts from a complex number &lt;em&gt;z&lt;/em&gt;, use &lt;code&gt;z.real&lt;/code&gt; and &lt;code&gt;z.imag&lt;/code&gt;. (The standard library includes the additional numeric types &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt;, for rationals, and &lt;a href=&quot;decimal#decimal.Decimal&quot;&gt;&lt;code&gt;decimal.Decimal&lt;/code&gt;&lt;/a&gt;, for floating-point numbers with user-definable precision.)</source>
          <target state="translated">&lt;em&gt;정수&lt;/em&gt; , &lt;em&gt;부동 소수점 수&lt;/em&gt; 및 &lt;em&gt;복소수의&lt;/em&gt; 세 가지 고유 한 숫자 유형이 &lt;em&gt;있습니다&lt;/em&gt; . 또한 부울은 정수의 하위 유형입니다. 정수는 무제한 정밀도를 갖습니다. 부동 소수점 숫자는 일반적으로 C에서 &lt;code&gt;double&lt;/code&gt; 을 사용하여 구현됩니다 . 프로그램이 실행중인 머신의 부동 소수점 숫자의 정밀도 및 내부 표현에 대한 정보는 &lt;a href=&quot;sys#sys.float_info&quot;&gt; &lt;code&gt;sys.float_info&lt;/code&gt; 에&lt;/a&gt; 있습니다. 복소수에는 실수 부와 허수 부가 있으며, 각각 부동 소수점입니다. 복소수에서 이러한 부분을 추출 &lt;em&gt;Z&lt;/em&gt; 사용 &lt;code&gt;z.real&lt;/code&gt; 및 &lt;code&gt;z.imag&lt;/code&gt; . (표준 라이브러리에는 추가 숫자 유형이 포함됩니다&lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; , rationals 및&lt;a href=&quot;decimal#decimal.Decimal&quot;&gt; &lt;code&gt;decimal.Decimal&lt;/code&gt; &lt;/a&gt; , 사용자 정의 가능 정밀도를 갖는 부동 소수점 숫자)</target>
        </trans-unit>
        <trans-unit id="333c521b638ab05e83b6cf3986fc6b02269383b6" translate="yes" xml:space="preserve">
          <source>There are three keyword arguments in &lt;em&gt;kwargs&lt;/em&gt; which are inspected: &lt;em&gt;exc_info&lt;/em&gt; which, if it does not evaluate as false, causes exception information to be added to the logging message. If an exception tuple (in the format returned by &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt;) or an exception instance is provided, it is used; otherwise, &lt;a href=&quot;sys#sys.exc_info&quot;&gt;&lt;code&gt;sys.exc_info()&lt;/code&gt;&lt;/a&gt; is called to get the exception information.</source>
          <target state="translated">&lt;em&gt;kwargs&lt;/em&gt; 에는 3 개의 키워드 인수가 있습니다 . &lt;em&gt;exc_info&lt;/em&gt; 는 false로 평가되지 않으면 예외 정보가 로깅 메시지에 추가됩니다. 예외 튜플 ( &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 반환 한 형식 ) 또는 예외 인스턴스가 제공되면 사용됩니다. 그렇지 않으면 예외 정보를 얻기 위해 &lt;a href=&quot;sys#sys.exc_info&quot;&gt; &lt;code&gt;sys.exc_info()&lt;/code&gt; &lt;/a&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d04821ea3634b3338603d35f9ecfca678dbd808" translate="yes" xml:space="preserve">
          <source>There are three main types of &lt;em&gt;awaitable&lt;/em&gt; objects: &lt;strong&gt;coroutines&lt;/strong&gt;, &lt;strong&gt;Tasks&lt;/strong&gt;, and &lt;strong&gt;Futures&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;대기 가능한&lt;/em&gt; 객체에는 &lt;strong&gt;코 루틴&lt;/strong&gt; , &lt;strong&gt;작업&lt;/strong&gt; 및 &lt;strong&gt;미래&lt;/strong&gt; 의 세 가지 주요 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9fe52cdc5c5e174e3a2732474be4c6eb0d0cd83e" translate="yes" xml:space="preserve">
          <source>There are three tar formats that can be created with the &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈로 작성할 수있는 tar 형식에는 세 가지가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9f8a6f9ebe421ba57fcfb4b59357400f94e96a60" translate="yes" xml:space="preserve">
          <source>There are times where a configuration needs to refer to objects external to the configuration, for example &lt;code&gt;sys.stderr&lt;/code&gt;. If the configuration dict is constructed using Python code, this is straightforward, but a problem arises when the configuration is provided via a text file (e.g. JSON, YAML). In a text file, there is no standard way to distinguish &lt;code&gt;sys.stderr&lt;/code&gt; from the literal string &lt;code&gt;'sys.stderr'&lt;/code&gt;. To facilitate this distinction, the configuration system looks for certain special prefixes in string values and treat them specially. For example, if the literal string &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; is provided as a value in the configuration, then the &lt;code&gt;ext://&lt;/code&gt; will be stripped off and the remainder of the value processed using normal import mechanisms.</source>
          <target state="translated">구성이 구성 외부의 오브젝트를 참조해야하는 경우가 있습니다 (예 : &lt;code&gt;sys.stderr&lt;/code&gt; ) . 구성 코드가 Python 코드를 사용하여 구성된 경우 이는 간단하지만 구성이 텍스트 파일 (예 : JSON, YAML)을 통해 제공 될 때 문제가 발생합니다. 텍스트 파일에는 &lt;code&gt;sys.stderr&lt;/code&gt; 을 리터럴 문자열 &lt;code&gt;'sys.stderr'&lt;/code&gt; 과 구별하는 표준 방법이 없습니다 . 이 구별을 용이하게하기 위해 구성 시스템은 문자열 값에서 특정 특수 접 두부를 찾고 특수하게 처리합니다. 예를 들어, 리터럴 문자열 &lt;code&gt;'ext://sys.stderr'&lt;/code&gt; 이 구성에서 값으로 제공되는 경우 &lt;code&gt;ext://&lt;/code&gt; 가 제거되고 나머지 값은 일반 가져 오기 메커니즘을 사용하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="b952a5fd1b6e29bf7f14c99f1285b4bf5b966ccf" translate="yes" xml:space="preserve">
          <source>There are two &lt;code&gt;MagicMock&lt;/code&gt; variants: &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt;&lt;code&gt;NonCallableMagicMock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 가지가 있습니다 &lt;code&gt;MagicMock&lt;/code&gt; 가 : 변형 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.NonCallableMagicMock&quot;&gt; &lt;code&gt;NonCallableMagicMock&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1e5423c30972002ca80c24e40aa5624a40bd0af" translate="yes" xml:space="preserve">
          <source>There are two common ways to use this function. In both approaches, you use the fd to wake up when a signal arrives, but then they differ in how they determine &lt;em&gt;which&lt;/em&gt; signal or signals have arrived.</source>
          <target state="translated">이 기능을 사용하는 일반적인 두 가지 방법이 있습니다. 두 방법 모두 fd를 사용하여 신호가 도착하면 깨어나지 만 도착한 신호를 결정 &lt;em&gt;하는&lt;/em&gt; 방법이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a9936ddf454d83f25fcc05dfb55a4648a3db888" translate="yes" xml:space="preserve">
          <source>There are two exceptions that may be raised by &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">&lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; &lt;/a&gt; 인스턴스에서 발생할 수있는 두 가지 예외가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d6e02d2cfc3072839fb97bd9bedd2f8db9ebdbd" translate="yes" xml:space="preserve">
          <source>There are two interfaces provided by this module. The modern interface supports encoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; to ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, and decoding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; or strings containing ASCII to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Both base-64 alphabets defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; (normal, and URL- and filesystem-safe) are supported.</source>
          <target state="translated">이 모듈은 두 가지 인터페이스를 제공합니다. 최신 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 를 ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 인코딩 하고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 또는 ASCII를 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 포함하는 문자열의 디코딩 을 지원 합니다 . &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548에&lt;/strong&gt;&lt;/a&gt; 정의 된 기본 64 자 (일반 및 URL 및 파일 시스템 안전)가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2f66a95e6684310c68284ed5fc12fb871f267fa3" translate="yes" xml:space="preserve">
          <source>There are two interfaces provided by this module. The modern interface supports encoding &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; to ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;, and decoding &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; or strings containing ASCII to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;. Both base-64 alphabets defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; (normal, and URL- and filesystem-safe) are supported.</source>
          <target state="translated">이 모듈에서 제공하는 두 가지 인터페이스가 있습니다. 최신 인터페이스는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트 류류 객체&lt;/a&gt; 를 ASCII &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 인코딩하고 바이트 류류 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;객체&lt;/a&gt; 또는 ASCII를 포함하는 문자열을 bytes로 디코딩 하는 것을 지원 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 3548에&lt;/strong&gt;&lt;/a&gt; 정의 된 base-64 알파벳 (일반 및 URL 및 파일 시스템 안전)이 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fa8ad7fa0c084245a8ddab7ad38f2502a86776e1" translate="yes" xml:space="preserve">
          <source>There are two main functions for creating &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt;&lt;code&gt;unittest.TestSuite&lt;/code&gt;&lt;/a&gt; instances from text files and modules with doctests:</source>
          <target state="translated">텍스트 파일 및 doctest가있는 모듈에서 &lt;a href=&quot;unittest#unittest.TestSuite&quot;&gt; &lt;code&gt;unittest.TestSuite&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성하는 주요 기능은 두 가지입니다 .</target>
        </trans-unit>
        <trans-unit id="e0fdb9b9b06f75f219fccefe4c88b64af94e44fb" translate="yes" xml:space="preserve">
          <source>There are two optional keyword-only arguments. The &lt;em&gt;key&lt;/em&gt; argument specifies a one-argument ordering function like that used for &lt;a href=&quot;stdtypes#list.sort&quot;&gt;&lt;code&gt;list.sort()&lt;/code&gt;&lt;/a&gt;. The &lt;em&gt;default&lt;/em&gt; argument specifies an object to return if the provided iterable is empty. If the iterable is empty and &lt;em&gt;default&lt;/em&gt; is not provided, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">두 개의 선택적 키워드 전용 인수가 있습니다. &lt;em&gt;키&lt;/em&gt; 인수 한 인수 순서화 기능에 사용되는 것과 같이 지정 &lt;a href=&quot;stdtypes#list.sort&quot;&gt; &lt;code&gt;list.sort()&lt;/code&gt; &lt;/a&gt; . &lt;em&gt;기본&lt;/em&gt; (가) 반복자가 비어 제공하는 경우 인수 지정은 객체가 돌아갑니다. iterable이 비어 있고 &lt;em&gt;기본값&lt;/em&gt; 이 제공되지 않으면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="40e73167bc2dd539e8cb18681323426ef95edb7e" translate="yes" xml:space="preserve">
          <source>There are two parts to this job:</source>
          <target state="translated">이 작업에는 두 부분이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f617732163ef9ffd09291d0e0a3a8c64bfdd701" translate="yes" xml:space="preserve">
          <source>There are two stages in warning control: first, each time a warning is issued, a determination is made whether a message should be issued or not; next, if a message is to be issued, it is formatted and printed using a user-settable hook.</source>
          <target state="translated">경고 제어에는 두 가지 단계가 있습니다. 첫째, 경고가 발행 될 때마다 메시지의 발행 여부가 결정됩니다. 다음으로, 메시지가 발행 될 경우, 사용자 설정 가능 후크를 사용하여 형식화되고 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="bcfdafc8223a5b68a92a7d9394d696f0c5a9a642" translate="yes" xml:space="preserve">
          <source>There are two typical use cases for &lt;em&gt;super&lt;/em&gt;. In a class hierarchy with single inheritance, &lt;em&gt;super&lt;/em&gt; can be used to refer to parent classes without naming them explicitly, thus making the code more maintainable. This use closely parallels the use of &lt;em&gt;super&lt;/em&gt; in other programming languages.</source>
          <target state="translated">&lt;em&gt;super의&lt;/em&gt; 일반적인 사용 사례는 두 가지 입니다. 단일 상속이있는 클래스 계층 구조에서 &lt;em&gt;super&lt;/em&gt; 를 사용하면 명시 적으로 이름을 지정하지 않고 부모 클래스를 참조 할 수 있으므로 코드를 유지 관리하기가 더 쉽습니다. 이 사용 은 다른 프로그래밍 언어에서 의 &lt;em&gt;super&lt;/em&gt; 사용과 밀접한 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="00afd891065ebece62243a2dd46e14fbe49e11f8" translate="yes" xml:space="preserve">
          <source>There are two ways to enable the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module to adapt a custom Python type to one of the supported ones.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 사용자 정의 파이썬 유형을 지원되는 유형 중 하나에 적용 할 수 있도록하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0dd5354b3d81e371357acf3a005a58e85ee468a" translate="yes" xml:space="preserve">
          <source>There are various server methods that can be overridden by subclasses of base server classes like &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;; these methods aren&amp;rsquo;t useful to external users of the server object.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 와 같은 기본 서버 클래스의 서브 클래스로 대체 할 수있는 다양한 서버 메소드가 있습니다 . 이러한 메소드는 서버 오브젝트의 외부 사용자에게는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b102f0e1bd4efb4a95d03bb36b1a10aab39e47d" translate="yes" xml:space="preserve">
          <source>There are, however, enough ways to crash Python with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;, so you should be careful anyway. The &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt;&lt;code&gt;faulthandler&lt;/code&gt;&lt;/a&gt; module can be helpful in debugging crashes (e.g. from segmentation faults produced by erroneous C library calls).</source>
          <target state="translated">그러나 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 로 Python을 크래시하는 충분한 방법이 있으므로 어쨌든 조심해야합니다. &lt;a href=&quot;faulthandler#module-faulthandler&quot;&gt; &lt;code&gt;faulthandler&lt;/code&gt; &lt;/a&gt; 모듈 충돌 디버깅하는데 도움이 될 수있다 (예를 들어 잘못된 C 라이브러리 호출에 의해 생성 세그멘테이션 오류부터).</target>
        </trans-unit>
        <trans-unit id="60e879387c2e07da69183eca12d6268a65a716b3" translate="yes" xml:space="preserve">
          <source>There are, of course, more possible ABCs for numbers, and this would be a poor hierarchy if it precluded the possibility of adding those. You can add &lt;code&gt;MyFoo&lt;/code&gt; between &lt;a href=&quot;#numbers.Complex&quot;&gt;&lt;code&gt;Complex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numbers.Real&quot;&gt;&lt;code&gt;Real&lt;/code&gt;&lt;/a&gt; with:</source>
          <target state="translated">물론 숫자에 대해 더 많은 ABC가있을 수 있으며이를 추가 할 수없는 경우 계층 구조가 좋지 않습니다. &lt;code&gt;MyFoo&lt;/code&gt; 하여 &lt;a href=&quot;#numbers.Complex&quot;&gt; &lt;code&gt;Complex&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#numbers.Real&quot;&gt; &lt;code&gt;Real&lt;/code&gt; &lt;/a&gt; 사이 에 MyFoo 를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7e142c652134bf8d6bf541d434c33320b8252989" translate="yes" xml:space="preserve">
          <source>There can be a &lt;code&gt;turtle.cfg&lt;/code&gt; file in the directory where &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; is stored and an additional one in the current working directory. The latter will override the settings of the first one.</source>
          <target state="translated">&lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 이 저장된 디렉토리에 &lt;code&gt;turtle.cfg&lt;/code&gt; 파일 이 있고 현재 작업 디렉토리에 추가 파일 이있을 수 있습니다 . 후자는 첫 번째 설정보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1a4413a268d4ebd32ee4dba0e329af575a824d1b" translate="yes" xml:space="preserve">
          <source>There is a &amp;ldquo;main thread&amp;rdquo; object; this corresponds to the initial thread of control in the Python program. It is not a daemon thread.</source>
          <target state="translated">&quot;주 스레드&quot;개체가 있습니다. 이것은 파이썬 프로그램의 초기 제어 스레드에 해당합니다. 데몬 스레드가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1e29d6e10b2c6956c33cb943f01fb5492ba9c5d5" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; flag to set, in order to prevent this, &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt;:</source>
          <target state="translated">이를 방지하기 위해 설정 하는 &lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 플래그가 있습니다. &lt;code&gt;socket.SO_REUSEADDR&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e47e83e62ae2ee4ea0b5b657d1278fc1527f7e36" translate="yes" xml:space="preserve">
          <source>There is a backport of &lt;a href=&quot;#module-unittest.mock&quot;&gt;&lt;code&gt;unittest.mock&lt;/code&gt;&lt;/a&gt; for earlier versions of Python, available as &lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;mock on PyPI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://pypi.org/project/mock&quot;&gt;PyPI에서 mock으로&lt;/a&gt; 사용할 수있는 이전 버전의 Python에 대한 &lt;a href=&quot;#module-unittest.mock&quot;&gt; &lt;code&gt;unittest.mock&lt;/code&gt; &lt;/a&gt; 의 백 포트가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ab37ed1de9956ad2db535992c1cb4eab9ce74122" translate="yes" xml:space="preserve">
          <source>There is a certain baseline overhead associated with executing a pass statement. The code here doesn&amp;rsquo;t try to hide it, but you should be aware of it. The baseline overhead can be measured by invoking the program without arguments, and it might differ between Python versions.</source>
          <target state="translated">pass 문 실행과 관련된 특정 기준 오버 헤드가 있습니다. 여기 코드는 숨기려고하지 않지만 알고 있어야합니다. 기본 오버 헤드는 인수없이 프로그램을 호출하여 측정 할 수 있으며 Python 버전마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482dc1fc316fb8aa025fb46e7933e55a2e4fe842" translate="yes" xml:space="preserve">
          <source>There is a default policy used by all classes in the email package. For all of the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; classes and the related convenience functions, and for the &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class, this is the &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt; policy, via its corresponding pre-defined instance &lt;a href=&quot;#email.policy.compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;. This policy provides for complete backward compatibility (in some cases, including bug compatibility) with the pre-Python3.3 version of the email package.</source>
          <target state="translated">이메일 패키지의 모든 클래스에서 사용되는 기본 정책이 있습니다. 모든 &lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 클래스 및 관련 편의 기능 및 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 클래스의 경우, 해당 사전 정의 된 인스턴스 &lt;a href=&quot;#email.policy.compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 를 통한 &lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; &lt;/a&gt; 정책 입니다. 이 정책은 Python3.3 이전 버전의 전자 메일 패키지와 완전한 역 호환성 (일부 경우 버그 호환성 포함)을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55d1a9e95df13365d139013a6923e69a48124ab1" translate="yes" xml:space="preserve">
          <source>There is a more aggressive version of both &lt;em&gt;spec&lt;/em&gt; and &lt;em&gt;autospec&lt;/em&gt; that &lt;em&gt;does&lt;/em&gt; prevent you setting non-existent attributes. This is useful if you want to ensure your code only &lt;em&gt;sets&lt;/em&gt; valid attributes too, but obviously it prevents this particular scenario:</source>
          <target state="translated">모두의보다 적극적인 버전이 &lt;em&gt;사양&lt;/em&gt; 및 &lt;em&gt;autospec &lt;/em&gt;&lt;em&gt;않는&lt;/em&gt; 존재하지 않는 속성을 설정하지 못하도록은. 이것은 코드 &lt;em&gt;가&lt;/em&gt; 유효한 속성 만 &lt;em&gt;설정&lt;/em&gt; 하도록하려는 경우에 유용 하지만 분명히이 특정 시나리오를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="1beb9533846807b3cddb163730145908edcba46e" translate="yes" xml:space="preserve">
          <source>There is a tiny performance penalty when using &lt;code&gt;frozen=True&lt;/code&gt;: &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; cannot use simple assignment to initialize fields, and must use &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;object.__setattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;frozen=True&lt;/code&gt; 사용시 성능이 약간 저하됩니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 은 간단한 할당을 사용하여 필드를 초기화 할 수 없으며 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;object.__setattr__()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="49fbe885a03f63d401b2b0a3ffbb2939e259105a" translate="yes" xml:space="preserve">
          <source>There is a tiny performance penalty when using &lt;code&gt;frozen=True&lt;/code&gt;: &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; cannot use simple assignment to initialize fields, and must use &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;object.__setattr__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;frozen=True&lt;/code&gt; 를 사용할 때 약간의 성능 저하가 있습니다 . &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 는 필드를 초기화하는 데 간단한 할당을 사용할 수 없으며 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;object.__setattr__()&lt;/code&gt; &lt;/a&gt; 사용해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="45b27f43395afb40755c882e8f8377026ef5693d" translate="yes" xml:space="preserve">
          <source>There is a utility to create a dictionary the keys of which are the method names and the values of which are the docstrings of the public methods of the classes Screen and Turtle.</source>
          <target state="translated">키가 메소드 이름이고 값이 Screen 및 Turtle 클래스의 공용 메소드의 docstring 인 사전을 작성하는 유틸리티가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7eae78a69e9371dbae0111468f3b5d1fc309bfa" translate="yes" xml:space="preserve">
          <source>There is also &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt;&lt;code&gt;patch.dict()&lt;/code&gt;&lt;/a&gt; for setting values in a dictionary just during a scope and restoring the dictionary to its original state when the test ends:</source>
          <target state="translated">또한 스코프 도중 사전에 값을 설정하고 테스트가 끝나면 사전을 원래 상태로 복원하기위한 &lt;a href=&quot;#unittest.mock.patch.dict&quot;&gt; &lt;code&gt;patch.dict()&lt;/code&gt; &lt;/a&gt; 도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e684d0160793e96041b51aa12fbbadc464d12889" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the file name(s) on the command line:</source>
          <target state="translated">&lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 실행을위한 명령 줄 단축키도 있습니다 . Python 인터프리터가 표준 라이브러리에서 직접 doctest 모듈을 실행하고 명령 행에서 파일 이름을 전달하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d111a6794d7726b882e407d115339caecd4e6077" translate="yes" xml:space="preserve">
          <source>There is also a command line shortcut for running &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;. You can instruct the Python interpreter to run the doctest module directly from the standard library and pass the module name(s) on the command line:</source>
          <target state="translated">&lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 를 실행하기위한 명령 줄 바로 가기도 있습니다 . Python 인터프리터가 표준 라이브러리에서 직접 doctest 모듈을 실행하고 명령 행에서 모듈 이름을 전달하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d79a9d980254c0558deebdb3ff6a0c81b5f4f60f" translate="yes" xml:space="preserve">
          <source>There is also a module-level convenience function:</source>
          <target state="translated">모듈 수준의 편의 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb180552aa6e02363503fb5c4bb76b55eebe73da" translate="yes" xml:space="preserve">
          <source>There is also a way to register new option flag names, though this isn&amp;rsquo;t useful unless you intend to extend &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; internals via subclassing:</source>
          <target state="translated">새로운 옵션 플래그 이름을 등록하는 방법도 있지만 서브 클래 싱을 통해 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 내부를 확장하지 않는 한 유용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2907b710c13ff58245f3fab419cf0626710f8bc4" translate="yes" xml:space="preserve">
          <source>There is also no mutable string type, but &lt;a href=&quot;#str.join&quot;&gt;&lt;code&gt;str.join()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; can be used to efficiently construct strings from multiple fragments.</source>
          <target state="translated">또한 변경 가능한 문자열 유형은 없지만 &lt;a href=&quot;#str.join&quot;&gt; &lt;code&gt;str.join()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 조각에서 문자열을 효율적으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67e4f42d4de885a7414466b8f08bd4f8bc181d8" translate="yes" xml:space="preserve">
          <source>There is always a 1:1 relationship between transport and protocol objects: the protocol calls transport methods to send data, while the transport calls protocol methods to pass it data that has been received.</source>
          <target state="translated">전송과 프로토콜 개체 간에는 항상 1 : 1 관계가 있습니다. 프로토콜은 데이터를 전송하기 위해 전송 메서드를 호출하고 전송은 수신 된 데이터를 전달하기 위해 프로토콜 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="3e56625ac1cadac7545d7b1c51dea55a42570abf" translate="yes" xml:space="preserve">
          <source>There is an additional mode character permitted, &lt;code&gt;'U'&lt;/code&gt;, which no longer has any effect, and is considered deprecated. It previously enabled &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the &lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt; parameter for further details.</source>
          <target state="translated">추가 모드 문자 &lt;code&gt;'U'&lt;/code&gt; 가 더 이상 적용되지 않으며 더 이상 사용되지 않으며 더 이상 사용되지 않는 것으로 간주됩니다. 이전 에는 텍스트 모드에서 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용 줄 바꿈&lt;/a&gt; 을 사용 하여 Python 3.0에서 기본 동작이되었습니다. 자세한 내용 은 &lt;a href=&quot;#open-newline-parameter&quot;&gt;개행&lt;/a&gt; 매개 변수 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a887f026af45aa30903a5f15ed3395bf260ebab8" translate="yes" xml:space="preserve">
          <source>There is an additional mode character permitted, &lt;code&gt;'U'&lt;/code&gt;, which no longer has any effect, and is considered deprecated. It previously enabled &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt; in text mode, which became the default behaviour in Python 3.0. Refer to the documentation of the &lt;a href=&quot;#open-newline-parameter&quot;&gt;newline&lt;/a&gt; parameter for further details.</source>
          <target state="translated">허용되는 추가 모드 문자 &lt;code&gt;'U'&lt;/code&gt; 가 있으며 더 이상 효과가 없으며 사용되지 않는 것으로 간주됩니다. 이전 에는 텍스트 모드에서 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;범용 줄 바꿈&lt;/a&gt; 을 활성화 했으며, 이는 Python 3.0에서 기본 동작이되었습니다. 자세한 내용 은 &lt;a href=&quot;#open-newline-parameter&quot;&gt;개행&lt;/a&gt; 매개 변수 의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="935265d6d70dd5bf2f00c18ebafbd01ee2301fae" translate="yes" xml:space="preserve">
          <source>There is an alternative, more powerful interface to the coder and decoder, see the source for details.</source>
          <target state="translated">코더 및 디코더에 대한보다 강력한 대안 인터페이스가 있습니다. 자세한 내용은 소스를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="74c4518e8428116ce41d38c6760bba0be948a71b" translate="yes" xml:space="preserve">
          <source>There is an obsolete function &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">노후된 기능 &lt;code&gt;warn&lt;/code&gt; 가 있으며 기능적으로 &lt;code&gt;warning&lt;/code&gt; 동일합니다 . 로 &lt;code&gt;warn&lt;/code&gt; 되지 않습니다, 그것을 사용하지 마십시오 - 사용 &lt;code&gt;warning&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="c9565a2b6830f7e297c9c91221ecf38feac62a37" translate="yes" xml:space="preserve">
          <source>There is an obsolete method &lt;code&gt;warn&lt;/code&gt; which is functionally identical to &lt;code&gt;warning&lt;/code&gt;. As &lt;code&gt;warn&lt;/code&gt; is deprecated, please do not use it - use &lt;code&gt;warning&lt;/code&gt; instead.</source>
          <target state="translated">기능적으로 &lt;code&gt;warning&lt;/code&gt; 과 동일한 사용되지 않는 &lt;code&gt;warn&lt;/code&gt; 방법 이 있습니다 . 로 &lt;code&gt;warn&lt;/code&gt; 되지 않습니다, 그것을 사용하지 마십시오 - 사용 &lt;code&gt;warning&lt;/code&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="0c04d008df0b3902a3f5080424926193dc66981f" translate="yes" xml:space="preserve">
          <source>There is currently no way to schedule coroutines or callbacks directly from a different process (such as one started with &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;asyncio-eventloop#asyncio-event-loop&quot;&gt;Event Loop Methods&lt;/a&gt; section lists APIs that can read from pipes and watch file descriptors without blocking the event loop. In addition, asyncio&amp;rsquo;s &lt;a href=&quot;asyncio-subprocess#asyncio-subprocess&quot;&gt;Subprocess&lt;/a&gt; APIs provide a way to start a process and communicate with it from the event loop. Lastly, the aforementioned &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt;&lt;code&gt;loop.run_in_executor()&lt;/code&gt;&lt;/a&gt; method can also be used with a &lt;a href=&quot;concurrent.futures#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;concurrent.futures.ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt; to execute code in a different process.</source>
          <target state="translated">현재는 다른 프로세스 (예 : &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; 으로&lt;/a&gt; 시작된 프로세스)에서 직접 코 루틴 또는 콜백을 예약 할 수있는 방법이 없습니다 . &lt;a href=&quot;asyncio-eventloop#asyncio-event-loop&quot;&gt;이벤트 루프 방법&lt;/a&gt; 이벤트 루프를 차단하지 않고 파이프 및 감시 파일 디스크립터에서 읽을 수있는 섹션에서는 API를. 또한 asyncio의 &lt;a href=&quot;asyncio-subprocess#asyncio-subprocess&quot;&gt;Subprocess&lt;/a&gt; API는 프로세스 를 시작하고 이벤트 루프에서 프로세스와 통신하는 방법을 제공합니다. 마지막으로, 앞서 언급 한 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt; &lt;code&gt;loop.run_in_executor()&lt;/code&gt; &lt;/a&gt; 메서드를 &lt;a href=&quot;concurrent.futures#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;concurrent.futures.ProcessPoolExecutor&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하여 다른 프로세스에서 코드를 실행할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a894765372946cbd728f24442f80a275c531295d" translate="yes" xml:space="preserve">
          <source>There is data to read</source>
          <target state="translated">읽을 데이터가 있습니다</target>
        </trans-unit>
        <trans-unit id="e75c6cbe07532d2502dde4b485373249588d95da" translate="yes" xml:space="preserve">
          <source>There is less temptation to change test code to fit the code it tests without a good reason.</source>
          <target state="translated">적절한 이유없이 테스트 코드를 변경하기 위해 테스트 코드를 변경하려는 유혹이 적습니다.</target>
        </trans-unit>
        <trans-unit id="4bd88caba77eb2e0f96b475391a639aa16965d22" translate="yes" xml:space="preserve">
          <source>There is no &lt;em&gt;do_handshake_on_connect&lt;/em&gt; machinery. You must always manually call &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt; to start the handshake.</source>
          <target state="translated">&lt;em&gt;do_handshake_on_connect&lt;/em&gt; 기계 는 없습니다 . 핸드 셰이크를 시작 하려면 항상 수동으로 &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; 를 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="17646ebf84b2cc6d3d2aa087f8fe20aa0ea84904" translate="yes" xml:space="preserve">
          <source>There is no command-line option to control the optimization level used by the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function, because the Python interpreter itself already provides the option: &lt;strong&gt;python -O -m compileall&lt;/strong&gt;.</source>
          <target state="translated">파이썬 인터프리터 자체가 이미 &lt;strong&gt;python -O -m compileall&lt;/strong&gt; 옵션을 제공하기 때문에 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수가 사용하는 최적화 레벨을 제어하는 ​​명령 행 옵션이 없습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a339402e2c08e68357d4607ca200a87f81869499" translate="yes" xml:space="preserve">
          <source>There is no dedicated literal syntax for bytearray objects, instead they are always created by calling the constructor:</source>
          <target state="translated">bytearray 객체에 대한 전용 리터럴 구문은 없지만 생성자를 호출하여 항상 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ab1e290a57c9a8c7c0ca47e3789793780590484a" translate="yes" xml:space="preserve">
          <source>There is no default implementation</source>
          <target state="translated">기본 구현이 없습니다</target>
        </trans-unit>
        <trans-unit id="4cfcfdb7a55717a78c7053ebb53cb164835e6d05" translate="yes" xml:space="preserve">
          <source>There is no handling of &lt;em&gt;suppress_ragged_eofs&lt;/em&gt;. All end-of-file conditions that are in violation of the protocol are reported via the &lt;a href=&quot;#ssl.SSLEOFError&quot;&gt;&lt;code&gt;SSLEOFError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">&lt;em&gt;suppress_ragged_eofs를&lt;/em&gt; 처리하지 않습니다 . 프로토콜을 위반 한 모든 파일 끝 조건은 &lt;a href=&quot;#ssl.SSLEOFError&quot;&gt; &lt;code&gt;SSLEOFError&lt;/code&gt; &lt;/a&gt; 예외 를 통해보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="354d47c9f2be30d4225e6edd3dac13f743ff4c56" translate="yes" xml:space="preserve">
          <source>There is no limitation for running subprocesses from different threads once the watcher is installed.</source>
          <target state="translated">감시자가 설치되면 다른 스레드에서 하위 프로세스를 실행하는 데 제한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="78052c50fd1ad0400209b2cf6aa7fbfab4c2eea6" translate="yes" xml:space="preserve">
          <source>There is no method to obtain the POSIX timestamp directly from a naive &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instance representing UTC time. If your application uses this convention and your system timezone is not set to UTC, you can obtain the POSIX timestamp by supplying &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt;:</source>
          <target state="translated">UTC 시간을 나타내는 순진한 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 인스턴스 에서 POSIX 타임 스탬프를 직접 얻는 방법은 없습니다 . 애플리케이션이이 규칙을 사용하고 시스템 시간대가 UTC로 설정되지 않은 경우 &lt;code&gt;tzinfo=timezone.utc&lt;/code&gt; 를 제공하여 POSIX 타임 스탬프를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ccc659c3dddb17a0d08925d775d9c79df47ca5e" translate="yes" xml:space="preserve">
          <source>There is no module-level &lt;code&gt;wrap_bio()&lt;/code&gt; call like there is for &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt;. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; is always created via an &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">어떤 모듈 수준 없습니다 &lt;code&gt;wrap_bio()&lt;/code&gt; 에 대한이 같은 호출이 &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; 는&lt;/a&gt; 항상을 통해 생성 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="979783c6e7664e6582aa3da703198e886d977840" translate="yes" xml:space="preserve">
          <source>There is no need to install the default policy manually. asyncio is configured to use the default policy automatically.</source>
          <target state="translated">기본 정책을 수동으로 설치할 필요가 없습니다. asyncio는 기본 정책을 자동으로 사용하도록 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="84f726f27659d6fc6e9b60e5ca57b5dfa4b12f91" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates), but stating a thread per process requires extra memory.</source>
          <target state="translated">많은 수의 자식 ( 자식이 종료 될 때마다 &lt;em&gt;O (1))을&lt;/em&gt; 처리 할 때 눈에 띄는 오버 헤드는 없지만 프로세스 당 스레드를 지정하려면 추가 메모리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="eb98ad1710a337cd30d3185a62ee9740d3de4bde" translate="yes" xml:space="preserve">
          <source>There is no noticeable overhead when handling a big number of children (&lt;em&gt;O(1)&lt;/em&gt; each time a child terminates).</source>
          <target state="translated">많은 수의 자식을 처리 할 때 눈에 띄는 오버 헤드가 없습니다 ( 자녀가 종료 할 때마다 &lt;em&gt;O (1)&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="7ea5b79c20fda2d876e2837855af83a60a9f3d1e" translate="yes" xml:space="preserve">
          <source>There is no requirement that &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instances be used to represent messages retrieved using &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances. In some situations, the time and memory required to generate &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; representations might not be acceptable. For such situations, &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instances also offer string and file-like representations, and a custom message factory may be specified when a &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance is initialized.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 검색된 메시지를 나타 내기 위해 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용할 필요는 없습니다 . 경우에 따라 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 표현 을 생성하는 데 필요한 시간과 메모리 가 허용되지 않을 수 있습니다. 이러한 상황에서 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스는 문자열 및 파일과 유사한 표현을 제공하며 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스가 초기화 될 때 사용자 지정 메시지 팩토리를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3ae3451c579ac5b5dbb261bd25097c72e8278dd" translate="yes" xml:space="preserve">
          <source>There is no requirement that the tools in this module are used to create application archives - the module is a convenience, but archives in the above format created by any means are acceptable to Python.</source>
          <target state="translated">이 모듈의 도구를 사용하여 응용 프로그램 아카이브를 만들 필요는 없습니다.이 모듈은 편리하지만 위와 같은 형식의 아카이브는 Python에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="f4cb2262ca8f74431c7529f7caba934501312915" translate="yes" xml:space="preserve">
          <source>There is no return value.</source>
          <target state="translated">반환 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="626b4419124dc05c7ee6eecb962399deb2c5e434" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6755c18f7a4a50204cd008eb3d1159aadb9e5a90" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-20&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="59014a17300c50cea45a4a6358e449e5248694af" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-23&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0b8a967536096b023a787a204a97de48dac9e487" translate="yes" xml:space="preserve">
          <source>There is no runtime checking of these properties. See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-62&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">이러한 속성에 대한 런타임 검사는 없습니다. 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0591&quot; id=&quot;index-62&quot;&gt;&lt;strong&gt;PEP 591&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="93d266ba42289c7350fb4e3a1db7c80f501f09db" translate="yes" xml:space="preserve">
          <source>There is no syntax to indicate optional or keyword arguments; such function types are rarely used as callback types. &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; (literal ellipsis) can be used to type hint a callable taking any number of arguments and returning &lt;code&gt;ReturnType&lt;/code&gt;. A plain &lt;a href=&quot;#typing.Callable&quot;&gt;&lt;code&gt;Callable&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;code&gt;Callable[..., Any]&lt;/code&gt;, and in turn to &lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt;&lt;code&gt;collections.abc.Callable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 또는 키워드 인수를 나타내는 구문은 없습니다. 이러한 함수 유형은 콜백 유형으로 거의 사용되지 않습니다. &lt;code&gt;Callable[..., ReturnType]&lt;/code&gt; (리터럴 줄임표)을 사용하여 여러 인수를 &lt;code&gt;ReturnType&lt;/code&gt; 반환하는 호출 가능 힌트를 입력 할 수 있습니다 . 일반 &lt;a href=&quot;#typing.Callable&quot;&gt; &lt;code&gt;Callable&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;Callable[..., Any]&lt;/code&gt; 와 동일하며 &lt;a href=&quot;collections.abc#collections.abc.Callable&quot;&gt; &lt;code&gt;collections.abc.Callable&lt;/code&gt; 과 같습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b473b64f202d7735b92adfb4667a5ab7ed7dcc5" translate="yes" xml:space="preserve">
          <source>There is no way for CGI code to tell whether the option was set, so a separate handler class is provided. It is used in the same way as &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;, i.e., by calling &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt;, where &lt;code&gt;app&lt;/code&gt; is the WSGI application object you wish to invoke.</source>
          <target state="translated">CGI 코드가 옵션 설정 여부를 알 수있는 방법이 없으므로 별도의 핸들러 클래스가 제공됩니다. &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 와 같은 방식으로 , 즉 &lt;code&gt;IISCGIHandler().run(app)&lt;/code&gt; 를 호출하여 사용됩니다. 여기서 &lt;code&gt;app&lt;/code&gt; 은 호출하려는 WSGI 응용 프로그램 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d0fe2afc95bd9dd12af3411b4ecc87fbcc97df95" translate="yes" xml:space="preserve">
          <source>There is no way to indicate non-native byte order (force byte-swapping); use the appropriate choice of &lt;code&gt;'&amp;lt;'&lt;/code&gt; or &lt;code&gt;'&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">비원시 바이트 순서를 표시하는 방법은 없습니다 (강제 바이트 스와핑). &lt;code&gt;'&amp;lt;'&lt;/code&gt; 또는 &lt;code&gt;'&amp;gt;'&lt;/code&gt; 중 적절한 선택을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d70cda3946eb643babc8c8abe059a00b30a0a0e3" translate="yes" xml:space="preserve">
          <source>There is no way to perform case conversions and character classifications according to the locale. For (Unicode) text strings these are done according to the character value only, while for byte strings, the conversions and classifications are done according to the ASCII value of the byte, and bytes whose high bit is set (i.e., non-ASCII bytes) are never converted or considered part of a character class such as letter or whitespace.</source>
          <target state="translated">로케일에 따라 대소 문자 변환 및 문자 분류를 수행 할 수있는 방법이 없습니다. (유니 코드) 텍스트 문자열의 경우 문자 값으로 만 수행되는 반면 바이트 문자열의 경우 바이트의 ASCII 값과 높은 비트가 설정된 바이트 (예 : 비 ASCII 바이트)에 따라 변환 및 분류가 수행됩니다. )는 문자 나 공백과 같은 문자 클래스의 일부로 변환되거나 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5b9cc71dc4ff206cec212895ed53756aab2a7764" translate="yes" xml:space="preserve">
          <source>There is no way to say &amp;ldquo;python X.Y or later&amp;rdquo;, so be careful of using an exact version like &amp;ldquo;/usr/bin/env python3.4&amp;rdquo; as you will need to change your shebang line for users of Python 3.5, for example.</source>
          <target state="translated">&amp;ldquo;python XY or later&amp;rdquo;라고 말할 방법이 없으므로, 예를 들어&amp;ldquo;/ usr / bin / env python3.4&amp;rdquo;와 같은 정확한 버전을 사용하도록주의하십시오. 예를 들어 Python 3.5 사용자의 shebang 라인을 변경해야합니다. .</target>
        </trans-unit>
        <trans-unit id="d2369966e324eb7a0bb66ca53d7e0b8023f09ca6" translate="yes" xml:space="preserve">
          <source>There is no way to unregister a function.</source>
          <target state="translated">기능을 등록 취소 할 수있는 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="59f1410dd1d1d6d9c22b365f413457bba1605111" translate="yes" xml:space="preserve">
          <source>There is one class defined for each left-hand side symbol in the abstract grammar (for example, &lt;code&gt;ast.stmt&lt;/code&gt; or &lt;code&gt;ast.expr&lt;/code&gt;). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, &lt;a href=&quot;#ast.BinOp&quot;&gt;&lt;code&gt;ast.BinOp&lt;/code&gt;&lt;/a&gt; inherits from &lt;code&gt;ast.expr&lt;/code&gt;. For production rules with alternatives (aka &amp;ldquo;sums&amp;rdquo;), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</source>
          <target state="translated">추상 문법 (예 : &lt;code&gt;ast.stmt&lt;/code&gt; 또는 &lt;code&gt;ast.expr&lt;/code&gt; )의 각 왼쪽 기호에 대해 하나의 클래스가 정의되어 있습니다. 또한 오른쪽에 각 생성자에 대해 정의 된 하나의 클래스가 있습니다. 이러한 클래스는 왼쪽 트리의 클래스에서 상속됩니다. 예를 들어, &lt;a href=&quot;#ast.BinOp&quot;&gt; &lt;code&gt;ast.BinOp&lt;/code&gt; 는&lt;/a&gt; 상속 &lt;code&gt;ast.expr&lt;/code&gt; . 대안 ( &quot;합&quot;이라고도 함)이있는 프로덕션 규칙의 경우 왼쪽 클래스는 추상입니다. 특정 생성자 노드의 인스턴스 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="3dd0e13bda3ae598cc30ece116faadf286e65f28" translate="yes" xml:space="preserve">
          <source>There is one class defined for each left-hand side symbol in the abstract grammar (for example, &lt;code&gt;ast.stmt&lt;/code&gt; or &lt;code&gt;ast.expr&lt;/code&gt;). In addition, there is one class defined for each constructor on the right-hand side; these classes inherit from the classes for the left-hand side trees. For example, &lt;code&gt;ast.BinOp&lt;/code&gt; inherits from &lt;code&gt;ast.expr&lt;/code&gt;. For production rules with alternatives (aka &amp;ldquo;sums&amp;rdquo;), the left-hand side class is abstract: only instances of specific constructor nodes are ever created.</source>
          <target state="translated">추상 문법의 각 왼쪽 기호에 대해 하나의 클래스가 정의되어 있습니다 (예 : &lt;code&gt;ast.stmt&lt;/code&gt; 또는 &lt;code&gt;ast.expr&lt;/code&gt; ). 또한 오른쪽에는 각 생성자에 대해 하나의 클래스가 정의되어 있습니다. 이 클래스는 왼쪽 트리의 클래스에서 상속됩니다. 예를 들어, &lt;code&gt;ast.BinOp&lt;/code&gt; 는 상속 &lt;code&gt;ast.expr&lt;/code&gt; . 대안 (일명&amp;ldquo;합계&amp;rdquo;)이있는 생산 규칙의 경우 왼쪽 클래스는 추상입니다. 특정 생성자 노드의 인스턴스 만 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="8aabd37fa9d78fbac35e4cc9ca691f0871edeeca" translate="yes" xml:space="preserve">
          <source>There is one classmethod to make a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; instance for a filesystem file:</source>
          <target state="translated">파일 시스템 파일 의 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 인스턴스 를 만드는 클래스 방법이 하나 있습니다.</target>
        </trans-unit>
        <trans-unit id="0412fae0e9a520771b5fcb2cddecf67855d8aff1" translate="yes" xml:space="preserve">
          <source>There is one constructor method named for each type of &lt;em&gt;hash&lt;/em&gt;. All return a hash object with the same simple interface. For example: use &lt;code&gt;sha256()&lt;/code&gt; to create a SHA-256 hash object. You can now feed this object with &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; (normally &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) using the &lt;code&gt;update()&lt;/code&gt; method. At any point you can ask it for the &lt;em&gt;digest&lt;/em&gt; of the concatenation of the data fed to it so far using the &lt;code&gt;digest()&lt;/code&gt; or &lt;code&gt;hexdigest()&lt;/code&gt; methods.</source>
          <target state="translated">각 유형의 &lt;em&gt;해시&lt;/em&gt; 마다 이름이 지정된 생성자 메소드가 있습니다 . 모두 동일한 간단한 인터페이스로 해시 객체를 반환합니다. 예를 들면 다음과 같습니다. &lt;code&gt;sha256()&lt;/code&gt; 을 사용하여 SHA-256 해시 객체를 만듭니다. 이제 &lt;code&gt;update()&lt;/code&gt; 메소드를 사용 하여이 객체에 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; (일반적으로 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )를 공급할 수 있습니다 . 언제든지 지금까지 &lt;code&gt;digest()&lt;/code&gt; 또는 &lt;code&gt;hexdigest()&lt;/code&gt; 메소드를 사용하여 지금까지 제공된 데이터의 연결 &lt;em&gt;요약&lt;/em&gt; 을 요청할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3117c0dab3215247b68ccd2e04cecc535a1ca1b6" translate="yes" xml:space="preserve">
          <source>There is one constructor method named for each type of &lt;em&gt;hash&lt;/em&gt;. All return a hash object with the same simple interface. For example: use &lt;code&gt;sha256()&lt;/code&gt; to create a SHA-256 hash object. You can now feed this object with &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; (normally &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) using the &lt;code&gt;update()&lt;/code&gt; method. At any point you can ask it for the &lt;em&gt;digest&lt;/em&gt; of the concatenation of the data fed to it so far using the &lt;code&gt;digest()&lt;/code&gt; or &lt;code&gt;hexdigest()&lt;/code&gt; methods.</source>
          <target state="translated">각 &lt;em&gt;해시&lt;/em&gt; 유형에 대해 이름이 지정된 하나의 생성자 메서드가 있습니다 . 모두 동일한 단순 인터페이스로 해시 객체를 반환합니다. 예 : &lt;code&gt;sha256()&lt;/code&gt; 을 사용하여 SHA-256 해시 개체를 만듭니다. 이제 &lt;code&gt;update()&lt;/code&gt; 메서드를 사용 하여이 객체에 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; (일반적으로 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )를 제공 할 수 있습니다. 언제든지 &lt;code&gt;digest()&lt;/code&gt; 또는 &lt;code&gt;hexdigest()&lt;/code&gt; 메서드를 사용하여 지금까지 제공된 데이터의 연결 &lt;em&gt;다이제스트&lt;/em&gt; 를 요청할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8120f8e5075cd93d0d190c702aaa96797cb5168" translate="yes" xml:space="preserve">
          <source>There is one more &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; method that a subclass may wish to override:</source>
          <target state="translated">서브 클래스가 재정의하고자하는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 메소드 가 하나 더 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fe629198154ae18d59378c3ddd10ff8afbe6fa19" translate="yes" xml:space="preserve">
          <source>There is really only one valid value for the &lt;em&gt;MIME-Version&lt;/em&gt; header, and that is &lt;code&gt;1.0&lt;/code&gt;. For future proofing, this header class supports other valid version numbers. If a version number has a valid value per &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, then the header object will have non-&lt;code&gt;None&lt;/code&gt; values for the following attributes:</source>
          <target state="translated">실제로 &lt;em&gt;MIME-Version&lt;/em&gt; 헤더 에는 유효한 값이 하나만 있으며 이는 &lt;code&gt;1.0&lt;/code&gt; 입니다. 향후 교정을 위해이 헤더 클래스는 다른 유효한 버전 번호를 지원합니다. 버전 번호가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; 당 유효한 값 을 갖는 경우 헤더 오브젝트는 다음 속성에 대해 &lt;code&gt;None&lt;/code&gt; 이외의 값을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="453b4f6d9769fd9f210579ed35f0b45ec2a4f635" translate="yes" xml:space="preserve">
          <source>There is the possibility that &amp;ldquo;dummy thread objects&amp;rdquo; are created. These are thread objects corresponding to &amp;ldquo;alien threads&amp;rdquo;, which are threads of control started outside the threading module, such as directly from C code. Dummy thread objects have limited functionality; they are always considered alive and daemonic, and cannot be &lt;a href=&quot;#threading.Thread.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;ed. They are never deleted, since it is impossible to detect the termination of alien threads.</source>
          <target state="translated">&quot;더미 스레드 개체&quot;가 생성 될 수 있습니다. 이들은 &quot;외국 스레드&quot;에 해당하는 스레드 객체로, C 코드에서 직접 스레딩 모듈 외부에서 시작된 제어 스레드입니다. 더미 스레드 객체는 기능이 제한적입니다. 그것들은 항상 살아 있고 데몬으로 간주되며 &lt;a href=&quot;#threading.Thread.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; 될 수 없습니다 . 외계인 스레드의 종료를 감지하는 것이 불가능하므로 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29a71b710bb3b88050806003b5991d9687cac929" translate="yes" xml:space="preserve">
          <source>There is urgent data to read</source>
          <target state="translated">읽을 긴급한 데이터가 있습니다</target>
        </trans-unit>
        <trans-unit id="268075deb39485d79f07bf18d036ea245830ce43" translate="yes" xml:space="preserve">
          <source>There should be a function to query whether a particular URL is in the cache.</source>
          <target state="translated">특정 URL이 캐시에 있는지 여부를 쿼리하는 기능이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e6e797c6f8f25641f56be38527a8196278af7bbb" translate="yes" xml:space="preserve">
          <source>There was an error parsing a text declaration in an external entity.</source>
          <target state="translated">외부 엔티티에서 텍스트 선언을 구문 분석하는 중에 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="d17e4f0895a59fce0176b492223bf84fc53d1057" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s also a subclass for secure connections:</source>
          <target state="translated">안전한 연결을위한 서브 클래스도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="04529db9fc59784d175f6c070f6a41e39f0d9ba0" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another encoding that is able to encoding the full range of Unicode characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists of two parts: marker bits (the most significant bits) and payload bits. The marker bits are a sequence of zero to four &lt;code&gt;1&lt;/code&gt; bits followed by a &lt;code&gt;0&lt;/code&gt; bit. Unicode characters are encoded like this (with x being payload bits, which when concatenated give the Unicode character):</source>
          <target state="translated">유니 코드 문자의 전체 범위를 UTF-8로 인코딩 할 수있는 또 다른 인코딩이 있습니다. UTF-8은 8 비트 인코딩으로, UTF-8에서 바이트 순서에 문제가 없음을 의미합니다. UTF-8 바이트 시퀀스의 각 바이트는 마커 비트 (가장 중요한 비트)와 페이로드 비트의 두 부분으로 구성됩니다. 마커 비트는 0에서 4까지의 &lt;code&gt;1&lt;/code&gt; 비트와 &lt;code&gt;0&lt;/code&gt; 비트 의 시퀀스입니다 . 유니 코드 문자는 다음과 같이 인코딩됩니다 (x는 페이로드 비트이며 연결된 경우 유니 코드 문자를 나타냄).</target>
        </trans-unit>
        <trans-unit id="0bacbeb7a867039aeb31684676f8649929ec6809" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s another group of encodings (the so called charmap encodings) that choose a different subset of all Unicode code points and how these code points are mapped to the bytes &lt;code&gt;0x0&lt;/code&gt;&amp;ndash;&lt;code&gt;0xff&lt;/code&gt;. To see how this is done simply open e.g. &lt;code&gt;encodings/cp1252.py&lt;/code&gt; (which is an encoding that is used primarily on Windows). There&amp;rsquo;s a string constant with 256 characters that shows you which character is mapped to which byte value.</source>
          <target state="translated">모든 유니 코드 코드 포인트의 다른 서브 세트를 선택하고 이러한 코드 포인트가 바이트 &lt;code&gt;0x0&lt;/code&gt; &amp;ndash; &lt;code&gt;0xff&lt;/code&gt; 에 매핑되는 방식을 선택하는 또 다른 인코딩 그룹 (소위 charmap 인코딩)이 있습니다 . 이 작업을 수행하는 방법을 보려면 &lt;code&gt;encodings/cp1252.py&lt;/code&gt; (Windows에서 주로 사용되는 인코딩)를 간단히 엽니 다 . 어떤 문자가 어떤 바이트 값에 매핑되는지를 나타내는 256 개의 문자열 상수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17e73f60746e10f8033ef47e930f87715709ed8" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s no output! That&amp;rsquo;s normal, and it means all the examples worked. Pass &lt;code&gt;-v&lt;/code&gt; to the script, and &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; prints a detailed log of what it&amp;rsquo;s trying, and prints a summary at the end:</source>
          <target state="translated">출력이 없습니다! 그것은 정상이며 모든 예제가 작동했음을 의미합니다. 패스 &lt;code&gt;-v&lt;/code&gt; 스크립트에, 그리고 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 인쇄가 노력하고 있는지에 대한 자세한 로그를, 그리고 마지막에 요약을 인쇄 :</target>
        </trans-unit>
        <trans-unit id="5107e764cbcf99be3db8a02a597dc9e0dfb5249e" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s one important rule: if you invoke an external program (via the &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt; functions. or others with similar functionality), make very sure you don&amp;rsquo;t pass arbitrary strings received from the client to the shell. This is a well-known security hole whereby clever hackers anywhere on the Web can exploit a gullible CGI script to invoke arbitrary shell commands. Even parts of the URL or field names cannot be trusted, since the request doesn&amp;rsquo;t have to come from your form!</source>
          <target state="translated">중요한 규칙이 하나 있습니다 : &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt; 함수 또는 유사한 기능을 가진 다른 프로그램을 통해 외부 프로그램을 호출하는 경우 클라이언트에서 수신 한 임의의 문자열을 전달하지 마십시오. 껍질. 이것은 잘 알려진 보안 허점으로, 웹의 어느 곳에서나 영리한 해커가 gullible CGI 스크립트를 사용하여 임의의 쉘 명령을 호출 할 수 있습니다. 요청은 양식에서 올 필요가 없으므로 URL 또는 필드 이름의 일부조차도 신뢰할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="465b85dd3cb1dcf881030f6e1facbd759bc882ac" translate="yes" xml:space="preserve">
          <source>Therefore it is probably best to only consider using &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;Process.terminate&lt;/code&gt;&lt;/a&gt; on processes which never use any shared resources.</source>
          <target state="translated">따라서 공유 리소스를 사용하지 않는 프로세스 에서만 &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;Process.terminate&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6d7ac873aab905d0d19416bd5a2e507b4093a46a" translate="yes" xml:space="preserve">
          <source>Therefore, the appropriate way to read form data values was to always use the code which checks whether the obtained value is a single value or a list of values. That&amp;rsquo;s annoying and leads to less readable scripts.</source>
          <target state="translated">따라서 양식 데이터 값을 읽는 적절한 방법은 항상 얻은 값이 단일 값인지 또는 값 목록인지 확인하는 코드를 사용하는 것입니다. 그것은 성가 시며 읽기 어려운 스크립트로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="ee0e8bc4ddad651cd810b740467094854c86f22f" translate="yes" xml:space="preserve">
          <source>Therefore, the same rules apply as with &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;: The lock must be held when called and is re-acquired on return. The predicate is evaluated with the lock held.</source>
          <target state="translated">따라서 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 와 동일한 규칙이 적용됩니다 . 잠금은 호출 될 때 유지되어야하며 리턴시 다시 획득됩니다. 술어는 잠금을 보유한 상태로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="7837e5032c97f9de99277b75a2524a30220ac2b0" translate="yes" xml:space="preserve">
          <source>Therefore, unless the connection object was produced using &lt;code&gt;Pipe()&lt;/code&gt; you should only use the &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; methods after performing some sort of authentication. See &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;Authentication keys&lt;/a&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;Pipe()&lt;/code&gt; 를 사용하여 연결 오브젝트를 작성하지 않은 경우 일종의 인증을 수행 한 후에 &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.connection.Connection.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 메소드 만 사용해야 합니다. &lt;a href=&quot;#multiprocessing-auth-keys&quot;&gt;인증 키를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="96533ee7558cd28344275b7b6faa62d8e6b52b05" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt;&lt;code&gt;BaseRequestHandler&lt;/code&gt;&lt;/a&gt; subclasses override the &lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt;&lt;code&gt;setup()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt;&lt;code&gt;finish()&lt;/code&gt;&lt;/a&gt; methods, and provide &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes. The &lt;code&gt;self.rfile&lt;/code&gt; and &lt;code&gt;self.wfile&lt;/code&gt; attributes can be read or written, respectively, to get the request data or return data to the client.</source>
          <target state="translated">이 &lt;a href=&quot;#socketserver.BaseRequestHandler&quot;&gt; &lt;code&gt;BaseRequestHandler&lt;/code&gt; &lt;/a&gt; 서브 클래스는 &lt;a href=&quot;#socketserver.BaseRequestHandler.setup&quot;&gt; &lt;code&gt;setup()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socketserver.BaseRequestHandler.finish&quot;&gt; &lt;code&gt;finish()&lt;/code&gt; &lt;/a&gt; 메소드를 &lt;code&gt;self.rfile&lt;/code&gt; 하고 &lt;code&gt;self.wfile&lt;/code&gt; 및 self.wfile 속성을 제공 합니다. &lt;code&gt;self.rfile&lt;/code&gt; 및 &lt;code&gt;self.wfile&lt;/code&gt; 속성은 읽기 또는 클라이언트에 요청 데이터 또는 반환 데이터를 얻기 위해 각각 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43420a1e7f2d338a26313b513562211f7c319bad" translate="yes" xml:space="preserve">
          <source>These ABCs allow us to ask classes or instances if they provide particular functionality, for example:</source>
          <target state="translated">이러한 ABC를 통해 클래스 나 인스턴스에 특정 기능을 제공하는지 문의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="79eb154c9b38c333e433efadc74ad44c819279e7" translate="yes" xml:space="preserve">
          <source>These RFCs together define a protocol to support non-ASCII characters in domain names. A domain name containing non-ASCII characters (such as &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt;) is converted into an ASCII-compatible encoding (ACE, such as &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt;). The ACE form of the domain name is then used in all places where arbitrary characters are not allowed by the protocol, such as DNS queries, HTTP &lt;em&gt;Host&lt;/em&gt; fields, and so on. This conversion is carried out in the application; if possible invisible to the user: The application should transparently convert Unicode domain labels to IDNA on the wire, and convert back ACE labels to Unicode before presenting them to the user.</source>
          <target state="translated">이러한 RFC는 함께 도메인 이름에서 비 ASCII 문자를 지원하는 프로토콜을 정의합니다. 비 ASCII 문자를 포함하는 도메인 이름 (예 : &lt;code&gt;www.Alliancefran&amp;ccedil;aise.nu&lt;/code&gt; )은 ASCII 호환 인코딩 (ACE, 예 : &lt;code&gt;www.xn--alliancefranaise-npb.nu&lt;/code&gt; ) 으로 변환 됩니다. 도메인 이름의 ACE 형식은 DNS 쿼리, HTTP &lt;em&gt;호스트&lt;/em&gt; 필드 등과 같이 프로토콜에 의해 임의의 문자가 허용되지 않는 모든 위치에서 사용 됩니다. 이 변환은 응용 프로그램에서 수행됩니다. 가능한 경우 사용자에게 보이지 않는 경우 : 응용 프로그램은 유선으로 유니 코드 도메인 레이블을 투명하게 IDNA로 변환하고 사용자에게 표시하기 전에 ACE 레이블을 다시 유니 코드로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0960be459bc3a6043cacd2025edb486fd19f0b" translate="yes" xml:space="preserve">
          <source>These are available only after &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; has been called.</source>
          <target state="translated">이들은 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 이 호출 된 후에 만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8865173ab02152cd75e5e2adf536e021d990b831" translate="yes" xml:space="preserve">
          <source>These are not used in annotations. They are building blocks for creating generic types.</source>
          <target state="translated">주석에는 사용되지 않습니다. 제네릭 유형을 만들기위한 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="8bbbc79b314368b7b552cdbf5c2628b93b45f0a7" translate="yes" xml:space="preserve">
          <source>These are not used in annotations. They are building blocks for declaring types.</source>
          <target state="translated">주석에는 사용되지 않습니다. 유형 선언을위한 빌딩 블록입니다.</target>
        </trans-unit>
        <trans-unit id="4f5c32d3a29bd1ff89416b3ae09cf4c6ae4a7c9d" translate="yes" xml:space="preserve">
          <source>These are string constants containing Bluetooth addresses with special meanings. For example, &lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt;&lt;code&gt;BDADDR_ANY&lt;/code&gt;&lt;/a&gt; can be used to indicate any address when specifying the binding socket with &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt;.</source>
          <target state="translated">이것은 특별한 의미를 가진 Bluetooth 주소를 포함하는 문자열 상수입니다. 예를 들어 &lt;a href=&quot;#socket.BDADDR_ANY&quot;&gt; &lt;code&gt;BDADDR_ANY&lt;/code&gt; &lt;/a&gt; 함께 결합 소켓 지정할 때 모든 어드레스를 나타내는데 이용 될 수 &lt;code&gt;BTPROTO_RFCOMM&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6e329deebb0b200060e6eef68196fa813fcd6a7c" translate="yes" xml:space="preserve">
          <source>These are the Boolean operations, ordered by ascending priority:</source>
          <target state="translated">다음은 오름차순으로 정렬되는 부울 연산입니다.</target>
        </trans-unit>
        <trans-unit id="257015f45893c1795d9d847c44cd903ea49c2017" translate="yes" xml:space="preserve">
          <source>These are the fundamental ctypes data types:</source>
          <target state="translated">다음은 기본 ctypes 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="26144cb516a5e752da5774e85f8525ae1b490465" translate="yes" xml:space="preserve">
          <source>These are the operations that dictionaries support (and therefore, custom mapping types should support too):</source>
          <target state="translated">다음은 사전이 지원하는 조작입니다. 따라서 사용자 정의 맵핑 유형도 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e52dbf7f9d96621e5053b5b96e01b2cb4d2ddd1" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;code&gt;si_code&lt;/code&gt; in the result returned by &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 결과에서 &lt;code&gt;si_code&lt;/code&gt; 에 가능한 값입니다. .</target>
        </trans-unit>
        <trans-unit id="33d6686360d4d96617294fd588956382c26c1e0b" translate="yes" xml:space="preserve">
          <source>These are the possible values for &lt;em&gt;idtype&lt;/em&gt; in &lt;a href=&quot;#os.waitid&quot;&gt;&lt;code&gt;waitid()&lt;/code&gt;&lt;/a&gt;. They affect how &lt;em&gt;id&lt;/em&gt; is interpreted.</source>
          <target state="translated">이러한 가능한 값이다 &lt;em&gt;idtype&lt;/em&gt; 에 &lt;a href=&quot;#os.waitid&quot;&gt; &lt;code&gt;waitid()&lt;/code&gt; &lt;/a&gt; . 그들은 어떻게 &lt;em&gt;ID에&lt;/em&gt; 영향을 미칩니다&lt;em&gt;&lt;/em&gt; 해석 .</target>
        </trans-unit>
        <trans-unit id="869f56b514f44bafe3fe22e39f703595a56c9bf4" translate="yes" xml:space="preserve">
          <source>These are useful if you want more control, or if you want to employ some of the algorithms implemented in this module in other circumstances.</source>
          <target state="translated">더 많은 제어를 원하거나 다른 환경에서이 모듈에 구현 된 일부 알고리즘을 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="01bf0efec17a4834e0a6b4b11da2c6d1b42d7b04" translate="yes" xml:space="preserve">
          <source>These attribute is true for the network as a whole if it is true for both the network address and the broadcast address.</source>
          <target state="translated">이 속성은 네트워크 주소와 브로드 캐스트 주소 모두에 해당되는 경우 네트워크 전체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="181a67606af87af42c5d3ffd8630c69cbabfe1e4" translate="yes" xml:space="preserve">
          <source>These attributes are deleted at the context manager exit.</source>
          <target state="translated">이 속성은 컨텍스트 관리자 엑시트에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6e7b417bf2efa43f13fc4f3e2f96d7bb14f2e3d8" translate="yes" xml:space="preserve">
          <source>These attributes are true for the network as a whole if they are true for both the network address and the broadcast address.</source>
          <target state="translated">이러한 속성은 네트워크 주소와 브로드 캐스트 주소 모두에 해당되는 경우 네트워크 전체에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe7aee32b05e735896ae2f06ad4b1db866432e5" translate="yes" xml:space="preserve">
          <source>These attributes can be used to hold additional data associated with the element. Their values are usually strings but may be any application-specific object. If the element is created from an XML file, the &lt;em&gt;text&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s start tag and its first child or end tag, or &lt;code&gt;None&lt;/code&gt;, and the &lt;em&gt;tail&lt;/em&gt; attribute holds either the text between the element&amp;rsquo;s end tag and the next tag, or &lt;code&gt;None&lt;/code&gt;. For the XML data</source>
          <target state="translated">이 속성은 요소와 연관된 추가 데이터를 보유하는 데 사용될 수 있습니다. 해당 값은 일반적으로 문자열이지만 응용 프로그램 별 객체 일 수 있습니다. 요소는 XML 파일에서 생성되는 경우, &lt;em&gt;텍스트&lt;/em&gt; 속성은 두 요소의 시작 태그와 첫 번째 자식이나 끝 태그 또는 사이에있는 텍스트 보유 &lt;code&gt;None&lt;/code&gt; , 그리고 &lt;em&gt;꼬리&lt;/em&gt; 속성은 어느 요소의 종료 태그와 다음 태그 사이의 텍스트를 보유하고 또는 &lt;code&gt;None&lt;/code&gt; . XML 데이터</target>
        </trans-unit>
        <trans-unit id="6fd5033e1290cc940ad7cf71f9886488f34ab1aa" translate="yes" xml:space="preserve">
          <source>These bytes can be used to seed user-space random number generators or for cryptographic purposes.</source>
          <target state="translated">이 바이트는 사용자 공간 난수 생성기를 시드하거나 암호화 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44ca4afebbdb6d250b9740f34fbdbf566762d631" translate="yes" xml:space="preserve">
          <source>These calls are only made if control is expected to return to the Python interpreter. A typical &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; launch will not trigger them as the child is not going to re-enter the interpreter.</source>
          <target state="translated">이러한 호출은 제어가 Python 인터프리터로 리턴 될 것으로 예상되는 경우에만 수행됩니다. 자식이 인터프리터에 다시 들어 가지 않을 것이기 때문에 일반적인 &lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 실행은 트리거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="864edae1c9ec3018b8088f575c6cbd03c733ee84" translate="yes" xml:space="preserve">
          <source>These can be used as types in annotations and do not support &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">이들은 주석의 유형으로 사용할 수 있으며 &lt;code&gt;[]&lt;/code&gt; 를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6d3cd0fdf581abcbc624a1353cfbd4046417caef" translate="yes" xml:space="preserve">
          <source>These can be used as types in annotations using &lt;code&gt;[]&lt;/code&gt;, each having a unique syntax.</source>
          <target state="translated">이들은 각각 고유 한 구문을 가진 &lt;code&gt;[]&lt;/code&gt; 를 사용하여 주석의 유형으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="853ef506dfaaa56fab906e6007dbe61b8f184b47" translate="yes" xml:space="preserve">
          <source>These classes are pre-defined using the mix-in classes.</source>
          <target state="translated">이 클래스는 믹스 인 클래스를 사용하여 미리 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="429a7cf26e573ef062098c538c098cd4acba2cab" translate="yes" xml:space="preserve">
          <source>These classes are provided for the purposes of organizing certain functions under one namespace. They aren&amp;rsquo;t meant to be instantiated independently.</source>
          <target state="translated">이러한 클래스는 하나의 네임 스페이스에서 특정 기능을 구성하기 위해 제공됩니다. 독립적으로 인스턴스화되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ae47495c57f5eaa0f0f8df13652cd694013c4578" translate="yes" xml:space="preserve">
          <source>These classes extend the above classes to serve HTML documentation in response to HTTP GET requests. Servers can either be free standing, using &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt;&lt;code&gt;DocXMLRPCServer&lt;/code&gt;&lt;/a&gt;, or embedded in a CGI environment, using &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 클래스는 HTTP GET 요청에 대한 응답으로 HTML 문서를 제공하기 위해 위의 클래스를 확장합니다. 서버는 &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt; &lt;code&gt;DocXMLRPCServer&lt;/code&gt; 를&lt;/a&gt; 사용하여 독립형 이거나 &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt; 를&lt;/a&gt; 사용하여 CGI 환경에 임베드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="771117257d089fde13c49bce5d82474423521fb2" translate="yes" xml:space="preserve">
          <source>These collections are provided for automatic introspection of bytecode instructions:</source>
          <target state="translated">이 컬렉션은 바이트 코드 명령어의 자동 검사를 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bb46852d445b6630c8fabc91fcd9b4c4b7f185c5" translate="yes" xml:space="preserve">
          <source>These commands and their arguments will be passed to a C function in the &lt;code&gt;_tkinter&lt;/code&gt; - note the underscore - extension module.</source>
          <target state="translated">이 명령과 인수는 &lt;code&gt;_tkinter&lt;/code&gt; - 밑줄-확장 모듈 에있는 C 함수에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="7cc8a232ffec17a0509c73cdc3cc5da82cc0c3b0" translate="yes" xml:space="preserve">
          <source>These constants are used as parameters for &lt;a href=&quot;#time.clock_getres&quot;&gt;&lt;code&gt;clock_getres()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.clock_gettime&quot;&gt;&lt;code&gt;clock_gettime()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#time.clock_getres&quot;&gt; &lt;code&gt;clock_getres()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.clock_gettime&quot;&gt; &lt;code&gt;clock_gettime()&lt;/code&gt; &lt;/a&gt; 매개 변수로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8f706a07e280b246aec2eb24a7a6cf4e80c4fad0" translate="yes" xml:space="preserve">
          <source>These constants define various byte sequences, being Unicode byte order marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams to indicate the byte order used, and in UTF-8 as a Unicode signature. &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt; is either &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; depending on the platform&amp;rsquo;s native byte order, &lt;a href=&quot;#codecs.BOM&quot;&gt;&lt;code&gt;BOM&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt;&lt;code&gt;BOM_UTF16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#codecs.BOM_LE&quot;&gt;&lt;code&gt;BOM_LE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt;&lt;code&gt;BOM_UTF16_LE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.BOM_BE&quot;&gt;&lt;code&gt;BOM_BE&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt;&lt;code&gt;BOM_UTF16_BE&lt;/code&gt;&lt;/a&gt;. The others represent the BOM in UTF-8 and UTF-32 encodings.</source>
          <target state="translated">이 상수는 여러 인코딩에 대한 유니 코드 바이트 순서 표시 (BOM) 인 다양한 바이트 시퀀스를 정의합니다. UTF-16 및 UTF-32 데이터 스트림에서 사용 된 바이트 순서를 나타내며 UTF-8에서 유니 코드 서명으로 사용됩니다. &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt; 은 플랫폼의 기본 바이트 순서에 따라 &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt; 이며 &lt;a href=&quot;#codecs.BOM&quot;&gt; &lt;code&gt;BOM&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#codecs.BOM_UTF16&quot;&gt; &lt;code&gt;BOM_UTF16&lt;/code&gt; &lt;/a&gt; 의 별칭 , &lt;a href=&quot;#codecs.BOM_LE&quot;&gt; &lt;code&gt;BOM_LE&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#codecs.BOM_UTF16_LE&quot;&gt; &lt;code&gt;BOM_UTF16_LE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.BOM_BE&quot;&gt; &lt;code&gt;BOM_BE&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#codecs.BOM_UTF16_BE&quot;&gt; &lt;code&gt;BOM_UTF16_BE&lt;/code&gt; &lt;/a&gt; 입니다. 다른 것은 BOM을 UTF-8 및 UTF-32 인코딩으로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="11075a028b89f1287b800e88d2a70525b45b0b3e" translate="yes" xml:space="preserve">
          <source>These constants represent the address (and protocol) families, used for the first argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. If the &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; constant is not defined then this protocol is unsupported. More constants may be available depending on the system.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 의 첫 번째 인수에 사용되는 주소 (및 프로토콜) 패밀리를 나타냅니다 . &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; 인&lt;/a&gt; 경우 상수가 정의되지 않은이 프로토콜은 지원되지 않습니다. 시스템에 따라 더 많은 상수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3636a3cbc66bf8adda778cce9b23ca921f64aa56" translate="yes" xml:space="preserve">
          <source>These constants represent the socket types, used for the second argument to &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt;. More constants may be available depending on the system. (Only &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt;&lt;code&gt;SOCK_DGRAM&lt;/code&gt;&lt;/a&gt; appear to be generally useful.)</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수에 사용되는 소켓 유형을 나타냅니다 . 시스템에 따라 더 많은 상수를 사용할 수 있습니다. ( &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.SOCK_DGRAM&quot;&gt; &lt;code&gt;SOCK_DGRAM&lt;/code&gt; &lt;/a&gt; 만 일반적으로 유용한 것으로 보입니다.)</target>
        </trans-unit>
        <trans-unit id="3850a5b66faf07220246584613141a4ed6ecd46e" translate="yes" xml:space="preserve">
          <source>These context managers may suppress exceptions just as they normally would if used directly as part of a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">이러한 컨텍스트 관리자는 일반적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; 의&lt;/a&gt; 일부로 직접 사용되는 것처럼 예외를 억제 할 수 있습니다 문의 .</target>
        </trans-unit>
        <trans-unit id="c5b59d1f5bf42fa2ad941913b587997df815979c" translate="yes" xml:space="preserve">
          <source>These context managers may suppress exceptions just as they normally would if used directly as part of a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">이러한 컨텍스트 관리자는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문의 일부로 직접 사용되는 경우 일반적인 경우처럼 예외를 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dd856ad1addbac2083c18edada1fee2ecb93a1c" translate="yes" xml:space="preserve">
          <source>These flags can be passed to &lt;a href=&quot;#os.memfd_create&quot;&gt;&lt;code&gt;memfd_create()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#os.memfd_create&quot;&gt; &lt;code&gt;memfd_create()&lt;/code&gt; &lt;/a&gt; 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d893a5018493b1ad1f01b4884c32e1257195fdf" translate="yes" xml:space="preserve">
          <source>These four classes process requests &lt;em&gt;synchronously&lt;/em&gt;; each request must be completed before the next request can be started. This isn&amp;rsquo;t suitable if each request takes a long time to complete, because it requires a lot of computation, or because it returns a lot of data which the client is slow to process. The solution is to create a separate process or thread to handle each request; the &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt;&lt;code&gt;ForkingMixIn&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; mix-in classes can be used to support asynchronous behaviour.</source>
          <target state="translated">이 네 클래스는 요청을 &lt;em&gt;동 기적으로&lt;/em&gt; 처리합니다 . 다음 요청을 시작하기 전에 각 요청을 완료해야합니다. 계산이 많이 필요하거나 클라이언트가 처리하는 속도가 느린 데이터를 많이 반환하기 때문에 각 요청을 완료하는 데 시간이 오래 걸리는 경우 적합하지 않습니다. 해결책은 각 요청을 처리하기 위해 별도의 프로세스 또는 스레드를 작성하는 것입니다. &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt; &lt;code&gt;ForkingMixIn&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; -에 믹스 클래스 비동기 동작을 지원하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72acb5b09128de39b246ae899d12597305851702" translate="yes" xml:space="preserve">
          <source>These functions accept either integers or single-character strings; when the argument is a string, it is first converted using the built-in function &lt;a href=&quot;functions#ord&quot;&gt;&lt;code&gt;ord()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 정수 또는 단일 문자 문자열을 허용합니다. 인수가 문자열 인 경우 내장 함수 &lt;a href=&quot;functions#ord&quot;&gt; &lt;code&gt;ord()&lt;/code&gt; &lt;/a&gt; 사용하여 먼저 변환됩니다. .</target>
        </trans-unit>
        <trans-unit id="15117243b94d605b572f5691b43a112efe192336" translate="yes" xml:space="preserve">
          <source>These functions all execute a new program, replacing the current process; they do not return. On Unix, the new executable is loaded into the current process, and will have the same process id as the caller. Errors will be reported as &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">이 함수들은 모두 현재 프로세스를 대체하여 새로운 프로그램을 실행합니다. 그들은 돌아 오지 않습니다. 유닉스에서는 새로운 실행 파일이 현재 프로세스에로드되고 호출자와 동일한 프로세스 ID를 갖습니다. 오류는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 로보고됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b6139927d660d5e1dad5ec0f32107d8c628a1f2" translate="yes" xml:space="preserve">
          <source>These functions and data items provide information and operate on the current process and user.</source>
          <target state="translated">이러한 기능 및 데이터 항목은 정보를 제공하고 현재 프로세스 및 사용자에 대해 작동합니다.</target>
        </trans-unit>
        <trans-unit id="65b2f130f9e56bca14a7379055f6e9bfc0f55b6b" translate="yes" xml:space="preserve">
          <source>These functions are all available on Linux only.</source>
          <target state="translated">이 기능은 모두 Linux에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4b7ea423186e1ad3686c673479b4eab2cfb592f4" translate="yes" xml:space="preserve">
          <source>These functions are described in &lt;a href=&quot;#os-file-dir&quot;&gt;Files and Directories&lt;/a&gt;.</source>
          <target state="translated">이러한 기능은 &lt;a href=&quot;#os-file-dir&quot;&gt;파일 및 디렉토리에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b95d0027dd729f2509f2876394ae457eb98ec95" translate="yes" xml:space="preserve">
          <source>These functions are used to retrieve resource usage information:</source>
          <target state="translated">이 함수는 자원 사용 정보를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13a1f4f79e7d240a9400f9b84efbdcb7fe5617a9" translate="yes" xml:space="preserve">
          <source>These functions calculate a measure of how much the population or sample tends to deviate from the typical or average values.</source>
          <target state="translated">이 함수는 모집단 또는 표본이 일반적인 값 또는 평균 값에서 벗어나는 정도를 측정합니다.</target>
        </trans-unit>
        <trans-unit id="c7e658bb4b32599c516696e577ad91941fcdf933" translate="yes" xml:space="preserve">
          <source>These functions calculate an average or typical value from a population or sample.</source>
          <target state="translated">이 함수는 모집단 또는 표본에서 평균 또는 일반 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a0ae98a3415f470fd255b1fc3b22d36ac3e83e02" translate="yes" xml:space="preserve">
          <source>These functions cannot be used with complex numbers; use the functions of the same name from the &lt;a href=&quot;cmath#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; module if you require support for complex numbers. The distinction between functions which support complex numbers and those which don&amp;rsquo;t is made since most users do not want to learn quite as much mathematics as required to understand complex numbers. Receiving an exception instead of a complex result allows earlier detection of the unexpected complex number used as a parameter, so that the programmer can determine how and why it was generated in the first place.</source>
          <target state="translated">이 함수는 복소수와 함께 사용할 수 없습니다. 복소수를 지원해야하는 경우 &lt;a href=&quot;cmath#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; &lt;/a&gt; 모듈 과 동일한 이름의 함수를 사용하십시오 . 대부분의 사용자는 복소수를 이해하는 데 필요한만큼 많은 수학을 배우기를 원하지 않기 때문에 복소수를 지원하는 함수와 그렇지 않은 함수의 구별. 복소수 결과 대신 예외를 수신하면 매개 변수로 사용 된 예상치 못한 복소수를 조기에 감지 할 수 있으므로 프로그래머는 처음에 생성 된 방법과 이유를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bc89086a46bb862ee0519c0f004dabc70edbc5" translate="yes" xml:space="preserve">
          <source>These functions control how a process is allocated CPU time by the operating system. They are only available on some Unix platforms. For more detailed information, consult your Unix manpages.</source>
          <target state="translated">이 기능은 운영 체제가 프로세스에 CPU 시간을 할당하는 방법을 제어합니다. 일부 유닉스 플랫폼에서만 사용할 수 있습니다. 자세한 내용은 Unix 맨 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f9d98b250a452db69c03659fe4d2049d567fb07a" translate="yes" xml:space="preserve">
          <source>These functions create new &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. (See also &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; for opening file descriptors.)</source>
          <target state="translated">이 함수는 새로운 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 만듭니다 . (또한 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 참조파일 디스크립터를 을 .</target>
        </trans-unit>
        <trans-unit id="8f604f19cecd1ba0c9a46f93d4cd24e19f43a25f" translate="yes" xml:space="preserve">
          <source>These functions create new &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;. (See also &lt;a href=&quot;#os.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; for opening file descriptors.)</source>
          <target state="translated">이러한 함수는 새 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 개체를&lt;/a&gt; 만듭니다 . ( 파일 설명자를 여는 방법 은 &lt;a href=&quot;#os.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="a9b3e1b34cce84fdb913bf10862151ad4e21d563" translate="yes" xml:space="preserve">
          <source>These functions expose the Windows registry API to Python. Instead of using an integer as the registry handle, a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt; is used to ensure that the handles are closed correctly, even if the programmer neglects to explicitly close them.</source>
          <target state="translated">이 함수는 Windows 레지스트리 API를 Python에 노출시킵니다. 레지스트리 핸들로 정수를 사용하는 대신 , 프로그래머가 명시 적으로 닫는 것을 무시하더라도 &lt;a href=&quot;#handle-object&quot;&gt;핸들 오브젝트&lt;/a&gt; 가 핸들을 올바르게 닫는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="64ca6341c263d0eee46813e38f713dafca73d87a" translate="yes" xml:space="preserve">
          <source>These functions may be used to create and manage processes.</source>
          <target state="translated">이 기능들은 프로세스를 생성하고 관리하는데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e8df50f0bf89eb9f4d3f60786c6448bf4847aa" translate="yes" xml:space="preserve">
          <source>These functions operate on I/O streams referenced using file descriptors.</source>
          <target state="translated">이 함수는 파일 디스크립터를 사용하여 참조 된 I / O 스트림에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="62bfedde268bc00986bbe311ebb5f0786bf6963c" translate="yes" xml:space="preserve">
          <source>These functions provide access to some useful capabilities on Windows platforms. Some higher-level modules use these functions to build the Windows implementations of their services. For example, the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass&lt;/code&gt;&lt;/a&gt; module uses this in the implementation of the &lt;a href=&quot;getpass#module-getpass&quot;&gt;&lt;code&gt;getpass()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이러한 기능을 통해 Windows 플랫폼의 유용한 기능에 액세스 할 수 있습니다. 일부 상위 레벨 모듈은이 기능을 사용하여 서비스의 Windows 구현을 빌드합니다. 예를 들어, &lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;getpass#module-getpass&quot;&gt; &lt;code&gt;getpass()&lt;/code&gt; &lt;/a&gt; 함수 구현에서이를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0280d48461c7d32aa95410598911229c46dae797" translate="yes" xml:space="preserve">
          <source>These functions return the corresponding hash objects for calculating BLAKE2b or BLAKE2s. They optionally take these general parameters:</source>
          <target state="translated">이 함수는 BLAKE2b 또는 BLAKE2를 계산하기위한 해당 해시 개체를 반환합니다. 선택적으로 다음과 같은 일반 매개 변수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="228f30ca6935d93886c690db3fc546e4320724bb" translate="yes" xml:space="preserve">
          <source>These functions should be avoided in Python 3, because they return encoded bytes. It&amp;rsquo;s much better to use alternatives which return Unicode strings instead, since most Python applications will want to manipulate human readable text as strings instead of bytes. Further, it&amp;rsquo;s possible that you may get unexpected Unicode-related exceptions if there are encoding problems with the translated strings.</source>
          <target state="translated">이 함수는 인코딩 된 바이트를 반환하므로 Python 3에서는 피해야합니다. 대부분의 Python 응용 프로그램은 사람이 읽을 수있는 텍스트를 바이트 대신 문자열로 조작하기를 원하므로 유니 코드 문자열을 반환하는 대안을 사용하는 것이 훨씬 좋습니다. 또한 번역 된 문자열에 인코딩 문제가있는 경우 예기치 않은 유니 코드 관련 예외가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="152b061e5d33249f6e76f6fd12669c7d70fbc3d2" translate="yes" xml:space="preserve">
          <source>These interfaces extend the &lt;code&gt;Node&lt;/code&gt; interface. They cannot have child nodes.</source>
          <target state="translated">이러한 인터페이스는 &lt;code&gt;Node&lt;/code&gt; 인터페이스를 확장합니다 . 자식 노드를 가질 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="799c1f5dbfcbd19d6e5bb337ef29e540c95dfa79" translate="yes" xml:space="preserve">
          <source>These junk-filtering functions speed up matching to find differences and do not cause any differing lines or characters to be ignored. Read the description of the &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt;&lt;code&gt;find_longest_match()&lt;/code&gt;&lt;/a&gt; method&amp;rsquo;s &lt;em&gt;isjunk&lt;/em&gt; parameter for an explanation.</source>
          <target state="translated">이러한 정크 필터링 기능은 차이점을 찾기 위해 일치 속도를 높이고 다른 줄이나 문자를 무시하지 않습니다. &lt;a href=&quot;#difflib.SequenceMatcher.find_longest_match&quot;&gt; &lt;code&gt;find_longest_match()&lt;/code&gt; &lt;/a&gt; 메소드의 &lt;em&gt;isjunk&lt;/em&gt; 매개 변수에 대한 설명을 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="364d64d52986eda4fa8d78b737587ffa8380e1f3" translate="yes" xml:space="preserve">
          <source>These may not be available on all platforms when used with the &lt;code&gt;strftime()&lt;/code&gt; method. The ISO 8601 year and ISO 8601 week directives are not interchangeable with the year and week number directives above. Calling &lt;code&gt;strptime()&lt;/code&gt; with incomplete or ambiguous ISO 8601 directives will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;strftime()&lt;/code&gt; 메소드 와 함께 사용하면 일부 플랫폼에서 사용하지 못할 수 있습니다 . ISO 8601 연도 및 ISO 8601 주 지침은 위의 연도 및 주 번호 지침과 호환되지 않습니다. 불완전하거나 모호한 ISO 8601 지시문으로 &lt;code&gt;strptime()&lt;/code&gt; 을 호출 하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2cefa5663c6968d98cda435b00eb0b38f51c7e77" translate="yes" xml:space="preserve">
          <source>These methods are available on &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt;&lt;code&gt;HTTPPasswordMgr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt;&lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">이러한 메소드는 &lt;a href=&quot;#urllib.request.HTTPPasswordMgr&quot;&gt; &lt;code&gt;HTTPPasswordMgr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.HTTPPasswordMgrWithDefaultRealm&quot;&gt; &lt;code&gt;HTTPPasswordMgrWithDefaultRealm&lt;/code&gt; &lt;/a&gt; 오브젝트 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5911df52a37a2f5a8a67b79ea06a439077506bd9" translate="yes" xml:space="preserve">
          <source>These methods are called by a &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object, in response to their methods of the same names. A &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object passes itself as the argument, and a &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; object passes &lt;code&gt;None&lt;/code&gt; as the argument. A &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass&amp;rsquo;s methods should therefore be prepared to accept a &lt;em&gt;dt&lt;/em&gt; argument of &lt;code&gt;None&lt;/code&gt;, or of class &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 메소드는 동일한 이름의 메소드에 대한 응답으로 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 오브젝트에 의해 호출됩니다 . &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 객체는 인수 자체를 전달하고, &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체는 통과하지 &lt;code&gt;None&lt;/code&gt; 인수로합니다. 따라서 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드는 &lt;code&gt;None&lt;/code&gt; 또는 class &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;dt&lt;/em&gt; 인수 를 허용하도록 준비해야합니다 .</target>
        </trans-unit>
        <trans-unit id="18aea1bbbb44bf54322bd21581fcc7fef2dcc544" translate="yes" xml:space="preserve">
          <source>These methods generate unique file names based upon the current process ID. When using multiple threads, undetected name clashes may occur and cause corruption of the mailbox unless threads are coordinated to avoid using these methods to manipulate the same mailbox simultaneously.</source>
          <target state="translated">이러한 메소드는 현재 프로세스 ID를 기반으로 고유 한 파일 이름을 생성합니다. 여러 스레드를 사용하는 경우 이러한 방법을 사용하여 동일한 사서함을 동시에 조작하지 않도록 스레드를 조정하지 않으면 감지되지 않은 이름 충돌이 발생하여 사서함이 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a460e54883612c01c96877b5d32c7a52f41e8cec" translate="yes" xml:space="preserve">
          <source>These methods immediately delete the message. The MH convention of marking a message for deletion by prepending a comma to its name is not used.</source>
          <target state="translated">이러한 방법은 메시지를 즉시 삭제합니다. 이름 앞에 쉼표를 붙여서 메시지를 삭제하도록 표시하는 MH 규칙은 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5940fc3a6f4d0793d0ba67cd0795eb41381f9f36" translate="yes" xml:space="preserve">
          <source>These methods should be avoided in Python 3. See the warning for the &lt;a href=&quot;#gettext.lgettext&quot;&gt;&lt;code&gt;lgettext()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">이 메소드는 Python 3에서 피해야 합니다. &lt;a href=&quot;#gettext.lgettext&quot;&gt; &lt;code&gt;lgettext()&lt;/code&gt; &lt;/a&gt; 함수에 대한 경고를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b48daa7e8c1e0cff066d2e0a4920c8cbfbcd31c" translate="yes" xml:space="preserve">
          <source>These modified docstrings are created automatically together with the function definitions that are derived from the methods at import time.</source>
          <target state="translated">이러한 수정 된 docstring은 가져 오기시 메소드에서 파생 된 함수 정의와 함께 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="37a911174119b81cc68b901672ebc6a9480f0a44" translate="yes" xml:space="preserve">
          <source>These more infrequently used classes are similar to the TCP and UDP classes, but use Unix domain sockets; they&amp;rsquo;re not available on non-Unix platforms. The parameters are the same as for &lt;a href=&quot;#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이처럼 자주 사용되지 않는 클래스는 TCP 및 UDP 클래스와 비슷하지만 Unix 도메인 소켓을 사용합니다. Unix 이외의 플랫폼에서는 사용할 수 없습니다. 매개 변수는 &lt;a href=&quot;#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="1a0feedd3b398644d890b41707a8d3ab57269dc3" translate="yes" xml:space="preserve">
          <source>These must be implemented as class methods:</source>
          <target state="translated">이들은 클래스 메소드로 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7cbdf0b741bfed107869c8df02810045e53d52c4" translate="yes" xml:space="preserve">
          <source>These objects also support being used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will automatically close them when done.</source>
          <target state="translated">이러한 객체는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용되도록 지원하며 완료되면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="4e722b3425b184238de0635b8e8dcc0ea887357b" translate="yes" xml:space="preserve">
          <source>These objects also support being used in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, which will automatically close them when done.</source>
          <target state="translated">이러한 개체는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용되는 것을 지원 하므로 완료되면 자동으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="7ad08a7358df1d2a66eb1de7e37514f52255da7a" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt;, &lt;code&gt;excepthook&lt;/code&gt;, and &lt;code&gt;unraisablehook&lt;/code&gt; at the start of the program. They are saved so that &lt;code&gt;breakpointhook&lt;/code&gt;, &lt;code&gt;displayhook&lt;/code&gt; and &lt;code&gt;excepthook&lt;/code&gt;, &lt;code&gt;unraisablehook&lt;/code&gt; can be restored in case they happen to get replaced with broken or alternative objects.</source>
          <target state="translated">이러한 객체에는 프로그램 시작시 &lt;code&gt;breakpointhook&lt;/code&gt; , &lt;code&gt;displayhook&lt;/code&gt; , &lt;code&gt;excepthook&lt;/code&gt; 및 &lt;code&gt;unraisablehook&lt;/code&gt; 의 원래 값이 포함 됩니다. &lt;code&gt;breakpointhook&lt;/code&gt; , &lt;code&gt;displayhook&lt;/code&gt; 및 &lt;code&gt;excepthook&lt;/code&gt; , &lt;code&gt;unraisablehook&lt;/code&gt; 이 깨지거나 대체 된 객체로 교체되는 경우 복원 할 수 있도록 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="6ca96d692b02c7b885bfcd6a1ee8049c02cbf749" translate="yes" xml:space="preserve">
          <source>These objects contain the original values of &lt;code&gt;stdin&lt;/code&gt;, &lt;code&gt;stderr&lt;/code&gt; and &lt;code&gt;stdout&lt;/code&gt; at the start of the program. They are used during finalization, and could be useful to print to the actual standard stream no matter if the &lt;code&gt;sys.std*&lt;/code&gt; object has been redirected.</source>
          <target state="translated">이 오브젝트에는 프로그램 시작시 &lt;code&gt;stdin&lt;/code&gt; , &lt;code&gt;stderr&lt;/code&gt; 및 &lt;code&gt;stdout&lt;/code&gt; 의 원래 값이 포함 됩니다. 이들은 마무리 과정에서 사용되며 &lt;code&gt;sys.std*&lt;/code&gt; 객체가 리디렉션 되더라도 실제 표준 스트림으로 인쇄하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c79b4fd295e293df8d67f19b3b67a6719463f333" translate="yes" xml:space="preserve">
          <source>These options can be passed to &lt;a href=&quot;#mmap.mmap.madvise&quot;&gt;&lt;code&gt;mmap.madvise()&lt;/code&gt;&lt;/a&gt;. Not every option will be present on every system.</source>
          <target state="translated">이 옵션은 &lt;a href=&quot;#mmap.mmap.madvise&quot;&gt; &lt;code&gt;mmap.madvise()&lt;/code&gt; &lt;/a&gt; 로 전달할 수 있습니다 . 모든 옵션이 모든 시스템에 존재하는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="9926e9592428ba78a5e1b23082749828067c3a4d" translate="yes" xml:space="preserve">
          <source>These options may be repeated multiple times.</source>
          <target state="translated">이러한 옵션은 여러 번 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d457330f80a34e6080d306cadcb1e3ad2dc2766" translate="yes" xml:space="preserve">
          <source>These options, along with all of the other options, are described in more detail in the &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; constructor documentation.</source>
          <target state="translated">이러한 옵션은 다른 모든 옵션과 함께 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 생성자 설명서에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dc76ffa679003835a09fce6bfd595ccfec9bd93" translate="yes" xml:space="preserve">
          <source>These parsers do not support all the argparse features, and will raise exceptions if unsupported features are used. In particular, subparsers, &lt;code&gt;argparse.REMAINDER&lt;/code&gt;, and mutually exclusive groups that include both optionals and positionals are not supported.</source>
          <target state="translated">이 파서는 모든 argparse 기능을 지원하지 않으며 지원되지 않는 기능이 사용되는 경우 예외를 발생시킵니다. 특히, 하위 구문 분석기, &lt;code&gt;argparse.REMAINDER&lt;/code&gt; 및 선택적 및 위치를 모두 포함하는 상호 배타적 인 그룹은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22dba5743cf8255132f82cfb61a9e3e78ed086d7" translate="yes" xml:space="preserve">
          <source>These prefabricated library loaders are available:</source>
          <target state="translated">이 조립식 라이브러리 로더는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e92aef4b27a0b69320cf0a2f7f9c5efc2f4fd1c" translate="yes" xml:space="preserve">
          <source>These protocols are decorated with &lt;a href=&quot;#typing.runtime_checkable&quot;&gt;&lt;code&gt;runtime_checkable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 프로토콜은 &lt;a href=&quot;#typing.runtime_checkable&quot;&gt; &lt;code&gt;runtime_checkable()&lt;/code&gt; &lt;/a&gt; 로 장식되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eef266eadbe60582ab001bde9ad9c46caee2dc9f" translate="yes" xml:space="preserve">
          <source>These restrictions are why picklable functions and classes must be defined in the top level of a module.</source>
          <target state="translated">이러한 제한 때문에 선택 가능한 함수와 클래스를 모듈의 최상위 수준에서 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="35bc8bcd8d7bb38d5e825c33344aa3d246936c4a" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward convenience in the most common use cases.</source>
          <target state="translated">이러한 의미 적 차이는 의도적이며 가장 일반적인 사용 사례에서 편의를 위해 편향되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9d492a24219c745ba294aeae2b21be77edbc2b" translate="yes" xml:space="preserve">
          <source>These semantic differences are intentional and are biased toward maximal convenience.</source>
          <target state="translated">이러한 의미 적 차이는 의도적이며 최대한의 편의를 위해 편향되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="390560ef8845b8bdb712a7c8bf8f16cdd1ae320d" translate="yes" xml:space="preserve">
          <source>These should be implemented as functions:</source>
          <target state="translated">이들은 함수로 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ceca439cc106eb947129c153f66b43d43dadf38e" translate="yes" xml:space="preserve">
          <source>These sizes are available as module &lt;a href=&quot;#constants&quot;&gt;constants&lt;/a&gt; described below.</source>
          <target state="translated">이 크기는 아래 설명 된 모듈 &lt;a href=&quot;#constants&quot;&gt;상수&lt;/a&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="48b7b72381b7aee41373544eef3f010c5c76d709" translate="yes" xml:space="preserve">
          <source>These standard library collections support parameterized generics.</source>
          <target state="translated">이러한 표준 라이브러리 컬렉션은 매개 변수화 된 제네릭을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="2800725d5ea46f65c695489e6472f9a85853adeb" translate="yes" xml:space="preserve">
          <source>These streams are regular &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;text files&lt;/a&gt; like those returned by the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. Their parameters are chosen as follows:</source>
          <target state="translated">이 스트림은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되는 것과 같은 일반 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-text-file&quot;&gt;텍스트 파일&lt;/a&gt; 입니다. 매개 변수는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="85b6d6a6d2d948a358037771f7c838becde52be5" translate="yes" xml:space="preserve">
          <source>These streams are regular &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-file&quot;&gt;text files&lt;/a&gt; like those returned by the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. Their parameters are chosen as follows:</source>
          <target state="translated">이러한 스트림은 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수가 반환하는 것과 같은 일반 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-text-file&quot;&gt;텍스트 파일&lt;/a&gt; 입니다. 해당 매개 변수는 다음과 같이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="e34d0790d235872a36ccb0f116d30f629c65d5a7" translate="yes" xml:space="preserve">
          <source>These symbols define resources whose consumption can be controlled using the &lt;a href=&quot;#resource.setrlimit&quot;&gt;&lt;code&gt;setrlimit()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#resource.getrlimit&quot;&gt;&lt;code&gt;getrlimit()&lt;/code&gt;&lt;/a&gt; functions described below. The values of these symbols are exactly the constants used by C programs.</source>
          <target state="translated">이 기호 는 아래 설명 된 &lt;a href=&quot;#resource.setrlimit&quot;&gt; &lt;code&gt;setrlimit()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#resource.getrlimit&quot;&gt; &lt;code&gt;getrlimit()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 소비를 제어 할 수있는 자원을 정의 합니다. 이 기호의 값은 C 프로그램에서 사용하는 상수입니다.</target>
        </trans-unit>
        <trans-unit id="32d519f5749336b639a376599af558d7266a105d" translate="yes" xml:space="preserve">
          <source>These three variables are not always defined; they are set when an exception is not handled and the interpreter prints an error message and a stack traceback. Their intended use is to allow an interactive user to import a debugger module and engage in post-mortem debugging without having to re-execute the command that caused the error. (Typical use is &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; to enter the post-mortem debugger; see &lt;a href=&quot;pdb#module-pdb&quot;&gt;&lt;code&gt;pdb&lt;/code&gt;&lt;/a&gt; module for more information.)</source>
          <target state="translated">이 세 변수가 항상 정의 된 것은 아닙니다. 예외가 처리되지 않고 인터프리터가 오류 메시지와 스택 추적을 인쇄 할 때 설정됩니다. 의도 된 용도는 대화식 사용자가 디버거 모듈을 가져오고 오류를 일으킨 명령을 다시 실행하지 않고도 사후 디버깅에 참여할 수 있도록하는 것입니다. 사후 디버거에 들어가기 위해 일반적으로 &lt;code&gt;import pdb; pdb.pm()&lt;/code&gt; 을 사용합니다 . 자세한 내용 은 &lt;a href=&quot;pdb#module-pdb&quot;&gt; &lt;code&gt;pdb&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="19392b851464bd02aa15e872a0539674c54e509e" translate="yes" xml:space="preserve">
          <source>These time zones also support the &lt;a href=&quot;datetime#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute introduced in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0495&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 495&lt;/strong&gt;&lt;/a&gt;. During offset transitions which induce ambiguous times (such as a daylight saving time to standard time transition), the offset from &lt;em&gt;before&lt;/em&gt; the transition is used when &lt;code&gt;fold=0&lt;/code&gt;, and the offset &lt;em&gt;after&lt;/em&gt; the transition is used when &lt;code&gt;fold=1&lt;/code&gt;, for example:</source>
          <target state="translated">이러한 시간대는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0495&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 495에&lt;/strong&gt;&lt;/a&gt; 도입 된 &lt;a href=&quot;datetime#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 속성 도 지원합니다 . 모호한 시간을 유발하는 오프셋 전환 (예 : 일광 절약 시간을 표준 시간으로 전환) 동안 전환 &lt;em&gt;이전&lt;/em&gt; 의 오프셋은 &lt;code&gt;fold=0&lt;/code&gt; 일 때 사용되고 전환 &lt;em&gt;후&lt;/em&gt; 오프셋 은 &lt;code&gt;fold=1&lt;/code&gt; 일 때 사용됩니다 . 예를 들면 다음과 같습니다.&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b700f59257d82022d76d6670b95dd0556a5db8f6" translate="yes" xml:space="preserve">
          <source>These tools and their built-in counterparts also work well with the high-speed functions in the &lt;a href=&quot;operator#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module. For example, the multiplication operator can be mapped across two vectors to form an efficient dot-product: &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt;.</source>
          <target state="translated">이 툴들과 내장 된 툴들은 &lt;a href=&quot;operator#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈의 고속 기능과도 잘 작동 합니다. 예를 들어, 곱셈 연산자는 두 벡터에 걸쳐 매핑되어 효율적인 내적을 형성 할 수 있습니다 : &lt;code&gt;sum(map(operator.mul, vector1, vector2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e77fbc4d220030bbcd6181d10d369921bab3851a" translate="yes" xml:space="preserve">
          <source>These tuples correspond to the C library &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt;, &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt;, and &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API calls used to prepare for the &lt;code&gt;posix_spawn()&lt;/code&gt; call itself.</source>
          <target state="translated">이 튜플 은 &lt;code&gt;posix_spawn()&lt;/code&gt; 호출 자체 를 준비하는 데 사용되는 C 라이브러리 &lt;code&gt;posix_spawn_file_actions_addopen()&lt;/code&gt; , &lt;code&gt;posix_spawn_file_actions_addclose()&lt;/code&gt; 및 &lt;code&gt;posix_spawn_file_actions_adddup2()&lt;/code&gt; API 호출에 해당 합니다.</target>
        </trans-unit>
        <trans-unit id="dbf6e0e647e0d38489bb73abd84ff4677afacaad" translate="yes" xml:space="preserve">
          <source>These two approaches both output:</source>
          <target state="translated">이 두 가지 방법 모두 출력에 접근합니다.</target>
        </trans-unit>
        <trans-unit id="7c080ba8814228ce441c13011c88627af47951fe" translate="yes" xml:space="preserve">
          <source>These two constants, if defined, can be combined with the socket types and allow you to set some flags atomically (thus avoiding possible race conditions and the need for separate calls).</source>
          <target state="translated">이 두 상수는 정의 된 경우 소켓 유형과 결합하여 일부 플래그를 원자 적으로 설정할 수 있습니다 (따라서 경쟁 조건과 별도의 호출이 필요하지 않음).</target>
        </trans-unit>
        <trans-unit id="3a39e6e21e19b9d8817c24d832895a8746655153" translate="yes" xml:space="preserve">
          <source>These two make it possible to view the heap as a regular Python list without surprises: &lt;code&gt;heap[0]&lt;/code&gt; is the smallest item, and &lt;code&gt;heap.sort()&lt;/code&gt; maintains the heap invariant!</source>
          <target state="translated">이 두 가지를 사용하면 힙을 놀라지 않고 일반 파이썬 목록으로 볼 수 있습니다. &lt;code&gt;heap[0]&lt;/code&gt; 은 가장 작은 항목이며 &lt;code&gt;heap.sort()&lt;/code&gt; 는 힙을 불변으로 유지합니다!</target>
        </trans-unit>
        <trans-unit id="164431ebbd6018da434ddafc8673fa593bda252e" translate="yes" xml:space="preserve">
          <source>These two values (measured in number of bytes) control when the protocol&amp;rsquo;s &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt;&lt;code&gt;protocol.pause_writing()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt;&lt;code&gt;protocol.resume_writing()&lt;/code&gt;&lt;/a&gt; methods are called. If specified, the low watermark must be less than or equal to the high watermark. Neither &lt;em&gt;high&lt;/em&gt; nor &lt;em&gt;low&lt;/em&gt; can be negative.</source>
          <target state="translated">이 두 값 (바이트 수로 측정)은 프로토콜의 &lt;a href=&quot;#asyncio.BaseProtocol.pause_writing&quot;&gt; &lt;code&gt;protocol.pause_writing()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.BaseProtocol.resume_writing&quot;&gt; &lt;code&gt;protocol.resume_writing()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 될 때 제어합니다 . 지정된 경우 하위 워터 마크는 상위 워터 마크보다 작거나 같아야합니다. 둘 다&lt;em&gt; 높은&lt;/em&gt; 이나 &lt;em&gt;낮은&lt;/em&gt; 음수가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="574630dc61934cf9f92e574ac1641bd851cae54b" translate="yes" xml:space="preserve">
          <source>These type aliases correspond to the return types from &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;re#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt;. These types (and the corresponding functions) are generic in &lt;code&gt;AnyStr&lt;/code&gt; and can be made specific by writing &lt;code&gt;Pattern[str]&lt;/code&gt;, &lt;code&gt;Pattern[bytes]&lt;/code&gt;, &lt;code&gt;Match[str]&lt;/code&gt;, or &lt;code&gt;Match[bytes]&lt;/code&gt;.</source>
          <target state="translated">이 유형 별명은 &lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;re#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 의 리턴 유형에 해당합니다 . 이러한 유형 (및 해당 기능)은 &lt;code&gt;AnyStr&lt;/code&gt; 에서 일반적 이며 &lt;code&gt;Pattern[str]&lt;/code&gt; , &lt;code&gt;Pattern[bytes]&lt;/code&gt; , &lt;code&gt;Match[str]&lt;/code&gt; 를 작성하여 구체적으로 만들 수 있습니다 . 또는 &lt;code&gt;Match[bytes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c8845c2683fe62464e3412e8c25d2712718fdbe" translate="yes" xml:space="preserve">
          <source>These type aliases correspond to the return types from &lt;a href=&quot;re#re.compile&quot;&gt;&lt;code&gt;re.compile()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;re#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt;. These types (and the corresponding functions) are generic in &lt;code&gt;AnyStr&lt;/code&gt; and can be made specific by writing &lt;code&gt;Pattern[str]&lt;/code&gt;, &lt;code&gt;Pattern[bytes]&lt;/code&gt;, &lt;code&gt;Match[str]&lt;/code&gt;, or &lt;code&gt;Match[bytes]&lt;/code&gt;. These types are also in the &lt;code&gt;typing.re&lt;/code&gt; namespace.</source>
          <target state="translated">이러한 유형 별칭은 &lt;a href=&quot;re#re.compile&quot;&gt; &lt;code&gt;re.compile()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;re#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 의 반환 유형에 해당합니다 . 이러한 유형 (및 해당 함수)은 &lt;code&gt;AnyStr&lt;/code&gt; 에서 일반적 이며 &lt;code&gt;Pattern[str]&lt;/code&gt; , &lt;code&gt;Pattern[bytes]&lt;/code&gt; , &lt;code&gt;Match[str]&lt;/code&gt; 또는 &lt;code&gt;Match[bytes]&lt;/code&gt; 를 작성하여 구체적으로 만들 수 있습니다 . 이러한 유형은 &lt;code&gt;typing.re&lt;/code&gt; 네임 스페이스에도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1dff30429da744e3abeb83ca67b97f13e80951a" translate="yes" xml:space="preserve">
          <source>These uses have different requirements, and it is important to distinguish them. In particular, filling your docstrings with obscure test cases makes for bad documentation.</source>
          <target state="translated">이러한 용도에는 요구 사항이 다르므로 구별해야합니다. 특히 문서 문자열을 모호한 테스트 사례로 채우면 문서가 잘못 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="77174f1e7631bf4075a0d95eafd9f3a93f86cee8" translate="yes" xml:space="preserve">
          <source>These values are not designed to be exposed to end-users; for user facing elements, applications should use something like CLDR (the Unicode Common Locale Data Repository) to get more user-friendly strings. See also the cautionary note on &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt;&lt;code&gt;ZoneInfo.key&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 값은 최종 사용자에게 노출되도록 설계되지 않았습니다. 사용자를 향한 요소의 경우 애플리케이션은 CLDR (유니 코드 공통 로케일 데이터 저장소)과 같은 것을 사용하여보다 사용자 친화적 인 문자열을 가져와야합니다. &lt;a href=&quot;#zoneinfo.ZoneInfo.key&quot;&gt; &lt;code&gt;ZoneInfo.key&lt;/code&gt; &lt;/a&gt; 에 대한주의 사항도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f38c67d7afb9e3ad667bc8f7a956cfa60d4f17" translate="yes" xml:space="preserve">
          <source>They are written as &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt;, respectively.</source>
          <target state="translated">그것들은 &lt;code&gt;False&lt;/code&gt; 과 &lt;code&gt;True&lt;/code&gt; 쓰여집니다.각각 .</target>
        </trans-unit>
        <trans-unit id="90b1fe661130f08bec50f79a318e33e031b7d747" translate="yes" xml:space="preserve">
          <source>They must have since the parser can&amp;rsquo;t tell the type of the operands.</source>
          <target state="translated">파서는 피연산자의 유형을 알 수 없으므로 반드시 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="560fa1e47346eab1954f144c298efe7129116f9d" translate="yes" xml:space="preserve">
          <source>Third-party event loops can use their own subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt; for interoperability. In this case, the result type is a subclass of &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt;&lt;code&gt;Task&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">타사 이벤트 루프는 상호 운용성을 위해 자체 하위 클래스 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 을 사용할 수 있습니다 . 이 경우 결과 유형은 &lt;a href=&quot;asyncio-task#asyncio.Task&quot;&gt; &lt;code&gt;Task&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="6885413c3edcf4b3482d003002d40466d1c7529c" translate="yes" xml:space="preserve">
          <source>Third-party event loops implementations might not support custom child watchers. For such event loops, using &lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt;&lt;code&gt;set_child_watcher()&lt;/code&gt;&lt;/a&gt; might be prohibited or have no effect.</source>
          <target state="translated">써드 파티 이벤트 루프 구현은 사용자 정의 하위 감시자를 지원하지 않을 수 있습니다. 이러한 이벤트 루프의 경우 &lt;a href=&quot;#asyncio.set_child_watcher&quot;&gt; &lt;code&gt;set_child_watcher()&lt;/code&gt; &lt;/a&gt; 사용 이 금지되거나 영향을 미치지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d33edc8f37f7925e4e4194d0d68db3b29628f3" translate="yes" xml:space="preserve">
          <source>Third-party library with expanded time zone and parsing support.</source>
          <target state="translated">시간대 및 구문 분석 지원이 확장 된 써드 파티 라이브러리.</target>
        </trans-unit>
        <trans-unit id="537a50311943cfeb994000528b2810d2698fd99b" translate="yes" xml:space="preserve">
          <source>Third-party unittest framework with a lighter-weight syntax for writing tests. For example, &lt;code&gt;assert func(10) == 42&lt;/code&gt;.</source>
          <target state="translated">테스트 작성을 위해 더 가벼운 구문의 타사 unittest 프레임 워크 예를 들어, &lt;code&gt;assert func(10) == 42&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3b9ee4043cb6de20c067db3fc4ab5a88de0e0da" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; class method returns bytearray object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">이 &lt;a href=&quot;#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 클래스 메서드는 주어진 문자열 객체를 디코딩하여 bytearray 객체를 반환합니다. 문자열은 바이트 당 2 개의 16 진수를 포함해야하며 ASCII 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="9f39db7a12ab223e5060700f28e89f71e712b838" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; class method returns a bytes object, decoding the given string object. The string must contain two hexadecimal digits per byte, with ASCII whitespace being ignored.</source>
          <target state="translated">이 &lt;a href=&quot;#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 클래스 메서드는 지정된 문자열 객체를 디코딩하여 bytes 객체를 반환합니다. 문자열은 바이트 당 2 개의 16 진수를 포함해야하며 ASCII 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="25c5a3603bbf6dde0a60e8a1166341e81b90d9ce" translate="yes" xml:space="preserve">
          <source>This C function is able to make calls into other C modules, including the C functions that make up the Tk library. Tk is implemented in C and some Tcl. The Tcl part of the Tk widgets is used to bind certain default behaviors to widgets, and is executed once at the point where the Python &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package is imported. (The user never sees this stage).</source>
          <target state="translated">이 C 함수는 Tk 라이브러리를 구성하는 C 함수를 포함하여 다른 C 모듈을 호출 할 수 있습니다. Tk는 C와 일부 Tcl에서 구현됩니다. Tk 위젯의 Tcl 부분은 특정 기본 동작을 위젯에 바인딩하는 데 사용되며 Python &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; 가&lt;/a&gt; 있는 지점에서 한 번 실행됩니다. 패키지를 가져 오는 됩니다. 사용자는이 단계를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1d6579a392f5cf7ff657ccc443a5878443ad506e" translate="yes" xml:space="preserve">
          <source>This ExampleService demo can be invoked from the command line:</source>
          <target state="translated">이 ExampleService 데모는 명령 행에서 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66603e0f2e17db55d8047fa37dc46cc24b89b2cc" translate="yes" xml:space="preserve">
          <source>This Life Preserver was written by Matt Conway at the University of Virginia.</source>
          <target state="translated">이 생명 구명은 버지니아 대학교의 Matt Conway에 의해 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff67911a0956c12902ae446cfb25b06222d6404b" translate="yes" xml:space="preserve">
          <source>This RFC defined the encoding of data which was XDR at the time this module was originally written. It has apparently been obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">이 RFC는이 모듈이 처음 작성된 시점의 XDR 인 데이터 인코딩을 정의했습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc1832.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 1832에&lt;/strong&gt;&lt;/a&gt; 의해 사용되지 않는 것 같습니다 .</target>
        </trans-unit>
        <trans-unit id="842c2f73983d293e723e4d1bf4e9d2c64a72c57e" translate="yes" xml:space="preserve">
          <source>This Request For Comments includes the rules for joining an absolute and a relative URL, including a fair number of &amp;ldquo;Abnormal Examples&amp;rdquo; which govern the treatment of border cases.</source>
          <target state="translated">이 의견 요청에는 국경 사건의 처리를 통제하는 공정한 수의 &quot;비정상적인 예&quot;를 포함하여 절대 및 상대 URL에 참여하기위한 규칙이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="135088776289217c28423276fa3c4b5d93458f2e" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;clearscreen&lt;/code&gt;. The global function &lt;code&gt;clear&lt;/code&gt; is a different one derived from the Turtle method &lt;code&gt;clear&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름에서 전역 함수로 사용할 수 있습니다 &lt;code&gt;clearscreen&lt;/code&gt; . 전역 함수 &lt;code&gt;clear&lt;/code&gt; 는 Turtle 메소드 &lt;code&gt;clear&lt;/code&gt; 에서 파생 된 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9a5c7fbfb12e64e80a50cd253b77207e3f8d1c22" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;onscreenclick&lt;/code&gt;. The global function &lt;code&gt;onclick&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;onclick&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름에서 전역 함수로 사용할 수 있습니다 &lt;code&gt;onscreenclick&lt;/code&gt; . 전역 함수 &lt;code&gt;onclick&lt;/code&gt; 은 Turtle 메서드 &lt;code&gt;onclick&lt;/code&gt; 에서 파생 된 또 다른 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="cbcf70844f55515130094216c6263e62345d52b8" translate="yes" xml:space="preserve">
          <source>This TurtleScreen method is available as a global function only under the name &lt;code&gt;resetscreen&lt;/code&gt;. The global function &lt;code&gt;reset&lt;/code&gt; is another one derived from the Turtle method &lt;code&gt;reset&lt;/code&gt;.</source>
          <target state="translated">이 TurtleScreen 방법은 이름 &lt;code&gt;resetscreen&lt;/code&gt; 에서만 전역 기능으로 사용할 수 있습니다 . 전역 함수 &lt;code&gt;reset&lt;/code&gt; 은 Turtle 메소드 &lt;code&gt;reset&lt;/code&gt; 에서 파생 된 또 다른 기능 입니다.</target>
        </trans-unit>
        <trans-unit id="4f4aceb05d95d7a494f76ab4488a09282ba3d5bb" translate="yes" xml:space="preserve">
          <source>This activates a special exception handler that will display detailed reports in the Web browser if any errors occur. If you&amp;rsquo;d rather not show the guts of your program to users of your script, you can have the reports saved to files instead, with code like this:</source>
          <target state="translated">이렇게하면 오류가 발생할 경우 웹 브라우저에 자세한 보고서를 표시하는 특수 예외 처리기가 활성화됩니다. 스크립트 사용자에게 프로그램의 장을 표시하지 않으려면 다음과 같은 코드를 사용하여 보고서를 파일에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="943d36d8edb0b61bc7c78f04ba488758674799cf" translate="yes" xml:space="preserve">
          <source>This affects &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt;&lt;code&gt;getTestCaseNames()&lt;/code&gt;&lt;/a&gt; and all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">이는 &lt;a href=&quot;#unittest.TestLoader.getTestCaseNames&quot;&gt; &lt;code&gt;getTestCaseNames()&lt;/code&gt; &lt;/a&gt; 및 모든 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 메소드에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="4c629e7d2eb45c1763b440d04e7b2f6f6d1af0f0" translate="yes" xml:space="preserve">
          <source>This affects all the &lt;code&gt;loadTestsFrom*()&lt;/code&gt; methods.</source>
          <target state="translated">이것은 모든 &lt;code&gt;loadTestsFrom*()&lt;/code&gt; 메소드에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="7e1a9d70f32008ed3c96c0e9a74a6e82daf6f746" translate="yes" xml:space="preserve">
          <source>This allows applications to get a suspend-aware monotonic clock without having to deal with the complications of &lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt;&lt;code&gt;CLOCK_REALTIME&lt;/code&gt;&lt;/a&gt;, which may have discontinuities if the time is changed using &lt;code&gt;settimeofday()&lt;/code&gt; or similar.</source>
          <target state="translated">이를 통해 응용 프로그램은 &lt;a href=&quot;#time.CLOCK_REALTIME&quot;&gt; &lt;code&gt;CLOCK_REALTIME&lt;/code&gt; &lt;/a&gt; 의 합병증을 처리하지 않고도 일시 중단 인식 단조로운 시계를 얻을 수 있습니다 . &lt;code&gt;settimeofday()&lt;/code&gt; 또는 이와 유사한 방법을 사용하여 시간이 변경되면 불연속성이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="019306589ee6acae06fdeea2a2650ea3f4d68bd9" translate="yes" xml:space="preserve">
          <source>This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see &lt;a href=&quot;enum#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt; for an example).</source>
          <target state="translated">이를 통해 인스턴스에서 속성을 활성화하고 동일한 이름의 클래스에 가상 속성을 가질 수 있습니다 ( 예제는 &lt;a href=&quot;enum#enum.Enum&quot;&gt; &lt;code&gt;enum.Enum&lt;/code&gt; &lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="5dc2bd0016562761a167a94107ea18ecde7bcee3" translate="yes" xml:space="preserve">
          <source>This allows one to have properties active on an instance, and have virtual attributes on the class with the same name (see Enum for an example).</source>
          <target state="translated">이를 통해 인스턴스에서 속성을 활성화하고 클래스에서 동일한 이름을 가진 가상 속성을 가질 수 있습니다 (예제 Enum 참조).</target>
        </trans-unit>
        <trans-unit id="f35eea3e328469bbb9e12d321786f404340c6df4" translate="yes" xml:space="preserve">
          <source>This allows the intended cleanup up behaviour to be made explicit up front, rather than requiring a separate flag variable.</source>
          <target state="translated">이를 통해 별도의 플래그 변수를 요구하지 않고 의도 된 정리 동작을 미리 명시 적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca28bc4acec436ecfcdadf8513fc13af190b783" translate="yes" xml:space="preserve">
          <source>This allows the newly spawned Python interpreter to safely import the module and then run the module&amp;rsquo;s &lt;code&gt;foo()&lt;/code&gt; function.</source>
          <target state="translated">이렇게하면 새로 생성 된 Python 인터프리터가 모듈을 안전하게 가져오고 모듈의 &lt;code&gt;foo()&lt;/code&gt; 함수 를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57868094fc52a1cd6c9af993bb993a3e5544da0a" translate="yes" xml:space="preserve">
          <source>This allows you to use the shell filename completion to specify the test module. The file specified must still be importable as a module. The path is converted to a module name by removing the &amp;lsquo;.py&amp;rsquo; and converting path separators into &amp;lsquo;.&amp;rsquo;. If you want to execute a test file that isn&amp;rsquo;t importable as a module you should execute the file directly instead.</source>
          <target state="translated">쉘 파일 이름 완성을 사용하여 테스트 모듈을 지정할 수 있습니다. 지정된 파일은 여전히 ​​모듈로 가져올 수 있어야합니다. 경로는 '.py'를 제거하고 경로 구분 기호를 '.'로 변환하여 모듈 이름으로 변환됩니다. 모듈로 가져올 수없는 테스트 파일을 실행하려면 파일을 직접 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="38d1a626d9c7a8c9eaba4801730692cd5ed50152" translate="yes" xml:space="preserve">
          <source>This also means that it is not possible to create a subtype of &lt;code&gt;Derived&lt;/code&gt; since it is an identity function at runtime, not an actual type:</source>
          <target state="translated">이는 또한 실제 유형이 아닌 런타임시 ID 함수이므로 &lt;code&gt;Derived&lt;/code&gt; 의 하위 유형을 작성할 수 없음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="80557a359ae07843f1afe80a27523489463324a4" translate="yes" xml:space="preserve">
          <source>This applies to &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt;&lt;code&gt;assert_called_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt;&lt;code&gt;assert_called_once_with()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt;&lt;code&gt;assert_has_calls()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt;&lt;code&gt;assert_any_call()&lt;/code&gt;&lt;/a&gt;. When &lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing&lt;/a&gt;, it will also apply to method calls on the mock object.</source>
          <target state="translated">이는 &lt;a href=&quot;#unittest.mock.Mock.assert_called_with&quot;&gt; &lt;code&gt;assert_called_with()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.mock.Mock.assert_called_once_with&quot;&gt; &lt;code&gt;assert_called_once_with()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#unittest.mock.Mock.assert_has_calls&quot;&gt; &lt;code&gt;assert_has_calls()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.assert_any_call&quot;&gt; &lt;code&gt;assert_any_call()&lt;/code&gt; &lt;/a&gt; 됩니다. &lt;a href=&quot;#auto-speccing&quot;&gt;Autospeccing&lt;/a&gt; 일 때 모의 객체의 메소드 호출에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="537b430af62b891eeb9751af6b5c80e259818d26" translate="yes" xml:space="preserve">
          <source>This approach has been first presented in &lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;a discussion on xmlrpc.com&lt;/a&gt;.</source>
          <target state="translated">이 접근 방식은 &lt;a href=&quot;https://web.archive.org/web/20060624230303/http://www.xmlrpc.com/discuss/msgReader%241208?mode=topic&quot;&gt;xmlrpc.com&lt;/a&gt; 에 대한 토론에서 처음 제시되었습니다 .</target>
        </trans-unit>
        <trans-unit id="fb8573037230d3969561b2945452190c58711f18" translate="yes" xml:space="preserve">
          <source>This approach is perhaps less convenient than employing nested &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt; for most use cases but also demonstrates a level of control over the synchronization.</source>
          <target state="translated">이 방법은 대부분의 사용 사례에 중첩 된 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체&lt;/a&gt; 를 사용하는 것보다 편리하지 않을 수도 있지만 동기화에 대한 제어 수준을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a12a4abb0591cce4c8aa99900d108da46a55a5b6" translate="yes" xml:space="preserve">
          <source>This arranges for a &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt;&lt;code&gt;CancelledError&lt;/code&gt;&lt;/a&gt; exception to be thrown into the wrapped coroutine on the next cycle of the event loop.</source>
          <target state="translated">이렇게 하면 이벤트 루프의 다음주기 에서 &lt;a href=&quot;asyncio-exceptions#asyncio.CancelledError&quot;&gt; &lt;code&gt;CancelledError&lt;/code&gt; &lt;/a&gt; 예외가 랩핑 된 코 루틴에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e81de60ddc5e6cb663061f6459f34a67618bb9be" translate="yes" xml:space="preserve">
          <source>This asks the thread to terminate, and then waits for it to do so. Note that if you don&amp;rsquo;t call this before your application exits, there may be some records still left on the queue, which won&amp;rsquo;t be processed.</source>
          <target state="translated">스레드를 종료하도록 요청한 다음 대기합니다. 응용 프로그램이 종료되기 전에 이것을 호출하지 않으면 대기열에 일부 레코드가 남아있을 수 있으며 처리되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d862b47fe45aa6e17de78d8754a167b3ff452f1d" translate="yes" xml:space="preserve">
          <source>This attribute contains a mapping of error code integers to two-element tuples containing a short and long message. For example, &lt;code&gt;{code: (shortmessage,
longmessage)}&lt;/code&gt;. The &lt;em&gt;shortmessage&lt;/em&gt; is usually used as the &lt;em&gt;message&lt;/em&gt; key in an error response, and &lt;em&gt;longmessage&lt;/em&gt; as the &lt;em&gt;explain&lt;/em&gt; key. It is used by &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt;&lt;code&gt;send_response_only()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt;&lt;code&gt;send_error()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이 속성에는 오류 코드 정수를 짧고 긴 메시지를 포함하는 두 요소 튜플에 대한 맵핑이 포함됩니다. 예를 들면 &lt;code&gt;{code: (shortmessage, longmessage)}&lt;/code&gt; 입니다. &lt;em&gt;하는 ShortMessage는&lt;/em&gt; 일반적으로 사용되는 &lt;em&gt;메시지&lt;/em&gt; 오류 응답 키를 &lt;em&gt;longmessage&lt;/em&gt; 는 AS &lt;em&gt;설명&lt;/em&gt; 키를 누릅니다. 그것은 의해 사용 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_response_only&quot;&gt; &lt;code&gt;send_response_only()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.send_error&quot;&gt; &lt;code&gt;send_error()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="3265ec6de83e09f5a858d9d1321fb30470037593" translate="yes" xml:space="preserve">
          <source>This attribute contains the actual value of the instance. For integer and pointer types, it is an integer, for character types, it is a single character bytes object or string, for character pointer types it is a Python bytes object or string.</source>
          <target state="translated">이 속성은 인스턴스의 실제 값을 포함합니다. 정수 및 포인터 유형의 경우 정수이며 문자 유형의 경우 단일 문자 바이트 오브젝트 또는 문자열이며 문자 포인터 유형의 경우 Python 바이트 오브젝트 또는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="ce1d216ac33ce7f92dd6899eec472d3df9018600" translate="yes" xml:space="preserve">
          <source>This attribute controls the maximum length of diffs output by assert methods that report diffs on failure. It defaults to 80*8 characters. Assert methods affected by this attribute are &lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt;&lt;code&gt;assertSequenceEqual()&lt;/code&gt;&lt;/a&gt; (including all the sequence comparison methods that delegate to it), &lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt;&lt;code&gt;assertDictEqual()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt;&lt;code&gt;assertMultiLineEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성은 실패시 diff를보고하는 assert 메소드로 최대 diff 출력 길이를 제어합니다. 기본값은 80 * 8 자입니다. 이 속성의 영향을받는 Assert 메소드는 &lt;a href=&quot;#unittest.TestCase.assertSequenceEqual&quot;&gt; &lt;code&gt;assertSequenceEqual()&lt;/code&gt; &lt;/a&gt; (위임하는 모든 시퀀스 비교 메소드 포함), &lt;a href=&quot;#unittest.TestCase.assertDictEqual&quot;&gt; &lt;code&gt;assertDictEqual()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.TestCase.assertMultiLineEqual&quot;&gt; &lt;code&gt;assertMultiLineEqual()&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b756a9463a6c4c6c113805675dfcd1ed425d592" translate="yes" xml:space="preserve">
          <source>This attribute has no effect if the traceback limit is &lt;code&gt;1&lt;/code&gt;. See the &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt;&lt;code&gt;get_traceback_limit()&lt;/code&gt;&lt;/a&gt; function and &lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt;&lt;code&gt;Snapshot.traceback_limit&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">역 추적 한계가 &lt;code&gt;1&lt;/code&gt; 인 경우이 속성은 적용되지 않습니다 . &lt;a href=&quot;#tracemalloc.get_traceback_limit&quot;&gt; &lt;code&gt;get_traceback_limit()&lt;/code&gt; &lt;/a&gt; 함수 및 &lt;a href=&quot;#tracemalloc.Snapshot.traceback_limit&quot;&gt; &lt;code&gt;Snapshot.traceback_limit&lt;/code&gt; &lt;/a&gt; 참조하십시오. 속성을 .</target>
        </trans-unit>
        <trans-unit id="efb0d29d4166e46dd3615e90c15f7c9725a59567" translate="yes" xml:space="preserve">
          <source>This attribute is &lt;code&gt;None&lt;/code&gt; by default. If you assign a string to it, that string will be recognized as a lexical-level inclusion request similar to the &lt;code&gt;source&lt;/code&gt; keyword in various shells. That is, the immediately following token will be opened as a filename and input will be taken from that stream until EOF, at which point the &lt;a href=&quot;io#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method of that stream will be called and the input source will again become the original input stream. Source requests may be stacked any number of levels deep.</source>
          <target state="translated">이 속성은 기본적으로 &lt;code&gt;None&lt;/code&gt; 입니다. 문자열을 할당하면 해당 문자열은 다양한 쉘 의 &lt;code&gt;source&lt;/code&gt; 키워드 와 유사한 어휘 수준 포함 요청으로 인식됩니다 . 즉, 바로 다음 토큰이 파일 이름으로 열리고 입력이 EOF까지 해당 스트림에서 가져옵니다.이 시점에서 &lt;a href=&quot;io#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출되고 입력 소스가 다시 원래 입력 스트림이됩니다. 소스 요청은 여러 수준의 깊이에 쌓일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e56bfc00c2caadc75dfd2a7c48b1a839469727cd" translate="yes" xml:space="preserve">
          <source>This attribute is a &lt;a href=&quot;#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; (possibly of length 1) of generic types passed to the original &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__class_getitem__&quot;&gt;&lt;code&gt;__class_getitem__()&lt;/code&gt;&lt;/a&gt; of the generic container:</source>
          <target state="translated">이 속성은 제네릭 컨테이너 의 원래 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__class_getitem__&quot;&gt; &lt;code&gt;__class_getitem__()&lt;/code&gt; &lt;/a&gt; 에 전달 된 제네릭 유형 의 &lt;a href=&quot;#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; (길이 1 일 수 있음)입니다 .</target>
        </trans-unit>
        <trans-unit id="2994dd43b52b07e7e69d05397ea676fc07397b4c" translate="yes" xml:space="preserve">
          <source>This attribute is a flag which controls the interpretation of blanks in the window. When it is on, trailing blanks on each line are ignored; any cursor motion that would land the cursor on a trailing blank goes to the end of that line instead, and trailing blanks are stripped when the window contents are gathered.</source>
          <target state="translated">이 속성은 창의 공백 해석을 제어하는 ​​플래그입니다. 켜져 있으면 각 줄의 후행 공백이 무시됩니다. 후행 공백에 커서를 놓는 커서 동작은 대신 해당 줄의 끝으로 이동하고 창 내용이 수집 될 때 후행 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8ea2adbc6d1d9d5676b59f71f289e2286049808c" translate="yes" xml:space="preserve">
          <source>This attribute is a lazily computed tuple (possibly empty) of unique type variables found in &lt;code&gt;__args__&lt;/code&gt;:</source>
          <target state="translated">이 속성은 &lt;code&gt;__args__&lt;/code&gt; 에서 발견 된 고유 한 유형 변수의 지연 계산 된 튜플 (비어있을 수 있음)입니다 .</target>
        </trans-unit>
        <trans-unit id="df0657bd69ee21a9f9148b59c9e8f837030cf6e4" translate="yes" xml:space="preserve">
          <source>This attribute is a tuple of classes that are considered when looking for base classes during method resolution.</source>
          <target state="translated">이 속성은 메소드 분석 중에 기본 클래스를 찾을 때 고려되는 클래스의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="78c2006f554cfe40d6509a13774214ddca5bbec4" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.0g or newer.</source>
          <target state="translated">ssl 모듈이 OpenSSL 1.1.0g 이상으로 컴파일되지 않으면이 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="166affef6e28f80e71c9ea85c86be9204124b32a" translate="yes" xml:space="preserve">
          <source>This attribute is not available unless the ssl module is compiled with OpenSSL 1.1.1 or newer.</source>
          <target state="translated">ssl 모듈이 OpenSSL 1.1.1 이상으로 컴파일되지 않으면이 속성을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d549f5791df423d3f994ffbd043feb8576e017c0" translate="yes" xml:space="preserve">
          <source>This attribute is used by the &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; method; it is initialized from the first argument to the constructor, if present, or to &lt;code&gt;None&lt;/code&gt;, if absent.</source>
          <target state="translated">이 속성은 &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 메소드 에서 사용됩니다 . 첫 번째 인수에서 생성자 (있는 경우)로, 또는 없는 경우 &lt;code&gt;None&lt;/code&gt; 으로 초기화됩니다 .</target>
        </trans-unit>
        <trans-unit id="d4130011af63fce83b7e1131abe74fced7d57bfb" translate="yes" xml:space="preserve">
          <source>This attribute points at the non-parameterized generic class:</source>
          <target state="translated">이 속성은 매개 변수화되지 않은 일반 클래스를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="779ab2149480aad2f6fe229a1b14fecb93369fd5" translate="yes" xml:space="preserve">
          <source>This attribute should be set to a true value if the handler&amp;rsquo;s &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt;&lt;code&gt;_write()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt;&lt;code&gt;_flush()&lt;/code&gt;&lt;/a&gt; are being used to communicate directly to the client, rather than via a CGI-like gateway protocol that wants the HTTP status in a special &lt;code&gt;Status:&lt;/code&gt; header.</source>
          <target state="translated">핸들러의 &lt;a href=&quot;#wsgiref.handlers.BaseHandler._write&quot;&gt; &lt;code&gt;_write()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.BaseHandler._flush&quot;&gt; &lt;code&gt;_flush()&lt;/code&gt; &lt;/a&gt; 를 사용하여 특수한 &lt;code&gt;Status:&lt;/code&gt; 의 HTTP 상태를 원하는 CGI와 같은 게이트웨이 프로토콜을 통하지 않고 클라이언트와 직접 통신 하는 경우이 속성을 true로 설정해야합니다 . 헤더 .</target>
        </trans-unit>
        <trans-unit id="81e7c664cabc787942b1a455028793b2341024c0" translate="yes" xml:space="preserve">
          <source>This attribute&amp;rsquo;s default value is true in &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;, but false in &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt;&lt;code&gt;BaseCGIHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt;&lt;code&gt;CGIHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성의 기본값은 &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 에서 true 이지만 &lt;a href=&quot;#wsgiref.handlers.BaseCGIHandler&quot;&gt; &lt;code&gt;BaseCGIHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#wsgiref.handlers.CGIHandler&quot;&gt; &lt;code&gt;CGIHandler&lt;/code&gt; &lt;/a&gt; 에서 false입니다 .</target>
        </trans-unit>
        <trans-unit id="f563e489bccd3156ff8203cb8818c4bd46df456e" translate="yes" xml:space="preserve">
          <source>This base class defines the following read-only properties:</source>
          <target state="translated">이 기본 클래스는 다음과 같은 읽기 전용 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="5540e595f1d0ce1ff248b688c117efa9d0c46875" translate="yes" xml:space="preserve">
          <source>This base class raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;. Subclasses may leave this method unimplemented.</source>
          <target state="translated">이 기본 클래스는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생시킵니다.&lt;/a&gt; 시킵니다. 서브 클래스는이 메소드를 구현하지 않은 상태로 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63a8a8b933d05fd353efb75eb303a3e9a79cadd5" translate="yes" xml:space="preserve">
          <source>This behaves exactly like &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;, except that it yields a 4-tuple &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt;, and it supports &lt;code&gt;dir_fd&lt;/code&gt;.</source>
          <target state="translated">이것은 4 튜플 &lt;code&gt;(dirpath, dirnames, filenames, dirfd)&lt;/code&gt; 을 생성하고 &lt;code&gt;dir_fd&lt;/code&gt; 를 지원 한다는 점을 제외하고는 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 와 똑같이 작동 합니다 . .</target>
        </trans-unit>
        <trans-unit id="f89ee084a5c3fb6a9b18d5de21c78508c481f569" translate="yes" xml:space="preserve">
          <source>This behavior allows &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to be used as an &lt;em&gt;escape hatch&lt;/em&gt; when you need to mix dynamically and statically typed code.</source>
          <target state="translated">이 동작을 사용하면 동적 및 정적 형식의 코드를 혼합해야 할 때 &lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;이스케이프 해치로&lt;/em&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b455e95c88343559228644a42667890d61597cf" translate="yes" xml:space="preserve">
          <source>This behavior can be customized by assigning to special attributes of the foreign function object.</source>
          <target state="translated">외부 함수 오브젝트의 특수 속성에 지정하여이 동작을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7379b341b2ba41615597b4e4d0b80854cab35ed" translate="yes" xml:space="preserve">
          <source>This behaviour is controlled by the following handler attributes:</source>
          <target state="translated">이 동작은 다음 핸들러 속성에 의해 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="957754b3567b9946eb2150398bc70e91ad0ce381" translate="yes" xml:space="preserve">
          <source>This behaviour may be overridden by setting &lt;em&gt;text&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt;, or &lt;em&gt;universal_newlines&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; as described in &lt;a href=&quot;#frequently-used-arguments&quot;&gt;Frequently Used Arguments&lt;/a&gt; and &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 동작은 &lt;a href=&quot;#frequently-used-arguments&quot;&gt;자주 사용되는 인수&lt;/a&gt; 및 &lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 설명 된대로 &lt;em&gt;text&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; 또는 &lt;em&gt;universal_newlines&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3e39c78a1690e05498b30b508c8ee358893459e4" translate="yes" xml:space="preserve">
          <source>This brings up another issue. It is relatively common to provide a default value of &lt;code&gt;None&lt;/code&gt; for members that will later be an object of a different type. &lt;code&gt;None&lt;/code&gt; would be useless as a spec because it wouldn&amp;rsquo;t let you access &lt;em&gt;any&lt;/em&gt; attributes or methods on it. As &lt;code&gt;None&lt;/code&gt; is &lt;em&gt;never&lt;/em&gt; going to be useful as a spec, and probably indicates a member that will normally of some other type, autospec doesn&amp;rsquo;t use a spec for members that are set to &lt;code&gt;None&lt;/code&gt;. These will just be ordinary mocks (well - MagicMocks):</source>
          <target state="translated">이것은 또 다른 문제를 일으킨다. 나중에 다른 유형의 오브젝트가되는 멤버에 대해 기본값 &lt;code&gt;None&lt;/code&gt; 을 제공하는 것이 일반적 입니다. &lt;code&gt;None&lt;/code&gt; 당신이 액세스 할 수없는 것 때문에 사양 쓸모 없을 것입니다 &lt;em&gt;어떤&lt;/em&gt; 그것에 속성이나 방법을. 마찬가지로 &lt;code&gt;None&lt;/code&gt; 있다 &lt;em&gt;결코&lt;/em&gt; 스펙으로 유용 할 것없고, 아마 일반적으로 다른 유형, autospec로 설정되어 회원에 대한 스펙을 사용하지 않는 것 구성원을 나타냅니다 &lt;code&gt;None&lt;/code&gt; . 이것들은 평범한 모의 일 것입니다 (잘-MagicMocks) :</target>
        </trans-unit>
        <trans-unit id="a01ade15639ca8f0fb9908b5bc15eb94fe21614a" translate="yes" xml:space="preserve">
          <source>This call (say, for example, creating a button widget), is implemented in the &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package, which is written in Python. This Python function will parse the commands and the arguments and convert them into a form that makes them look as if they had come from a Tk script instead of a Python script.</source>
          <target state="translated">이 호출 (예 : 버튼 위젯 작성)은 Python으로 작성된 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 패키지로 구현됩니다 . 이 Python 함수는 명령과 인수를 구문 분석하여 Python 스크립트 대신 Tk 스크립트에서 온 것처럼 보이게하는 형태로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2a3932daa8300dd15eb1238ca7766ace7be0b25b" translate="yes" xml:space="preserve">
          <source>This call decodes uuencoded file &lt;em&gt;in_file&lt;/em&gt; placing the result on file &lt;em&gt;out_file&lt;/em&gt;. If &lt;em&gt;out_file&lt;/em&gt; is a pathname, &lt;em&gt;mode&lt;/em&gt; is used to set the permission bits if the file must be created. Defaults for &lt;em&gt;out_file&lt;/em&gt; and &lt;em&gt;mode&lt;/em&gt; are taken from the uuencode header. However, if the file specified in the header already exists, a &lt;a href=&quot;#uu.Error&quot;&gt;&lt;code&gt;uu.Error&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">이 호출은 uuencoded 파일 &lt;em&gt;in_file을&lt;/em&gt; 해독 하여 결과를 &lt;em&gt;out_file&lt;/em&gt; 파일에 배치합니다 . 경우 &lt;em&gt;out_file로 쓰기는&lt;/em&gt; 경로 이름입니다 &lt;em&gt;모드는&lt;/em&gt; 파일이 생성해야하는 경우 권한 비트를 설정하는 데 사용됩니다. &lt;em&gt;out_file&lt;/em&gt; 및 &lt;em&gt;mode의&lt;/em&gt; 기본값 은 uuencode 헤더에서 가져옵니다. 그러나 헤더에 지정된 파일이 이미 존재하면 &lt;a href=&quot;#uu.Error&quot;&gt; &lt;code&gt;uu.Error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c674f16cfd26246b43950a59f15b8c54770ceded" translate="yes" xml:space="preserve">
          <source>This call will print in the standard output the information returned by &lt;a href=&quot;#sysconfig.get_platform&quot;&gt;&lt;code&gt;get_platform()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_python_version&quot;&gt;&lt;code&gt;get_python_version()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#sysconfig.get_path&quot;&gt;&lt;code&gt;get_path()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt;&lt;code&gt;get_config_vars()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 호출은 &lt;a href=&quot;#sysconfig.get_platform&quot;&gt; &lt;code&gt;get_platform()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sysconfig.get_python_version&quot;&gt; &lt;code&gt;get_python_version()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#sysconfig.get_path&quot;&gt; &lt;code&gt;get_path()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#sysconfig.get_config_vars&quot;&gt; &lt;code&gt;get_config_vars()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 정보를 표준 출력으로 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="a6469546206837a94e51f0f2845bca660667742c" translate="yes" xml:space="preserve">
          <source>This can be achieved from the &lt;a href=&quot;#python-interface&quot;&gt;Python Interface&lt;/a&gt; with:</source>
          <target state="translated">이것은 다음을 사용하여 &lt;a href=&quot;#python-interface&quot;&gt;Python 인터페이스&lt;/a&gt; 에서 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d1d697fe2b31a15d36e206e65de28f58571ea8c" translate="yes" xml:space="preserve">
          <source>This can be called multiple times.</source>
          <target state="translated">여러 번 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b67e671a1c54666dadf6cd890333be68c8592ef" translate="yes" xml:space="preserve">
          <source>This can be especially problematic for the user to see if she&amp;rsquo;s using a proportional font to edit the file. That is why when your application does not need values with empty lines, you should consider disallowing them. This will make empty lines split keys every time. In the example above, it would produce two keys, &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;this&lt;/code&gt;.</source>
          <target state="translated">이것은 사용자가 비례 글꼴을 사용하여 파일을 편집하고 있는지 확인하는 데 특히 문제가 될 수 있습니다. 따라서 응용 프로그램에 빈 줄이있는 값이 필요하지 않으면 허용하지 않는 것이 좋습니다. 이렇게하면 빈 줄이 매번 키를 분리됩니다. 위의 예에서는 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;this&lt;/code&gt; 의 두 키를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="a82ddd14e1f001ea8311d0bd0c24af21a7865d61" translate="yes" xml:space="preserve">
          <source>This can be used for safely evaluating strings containing Python values from untrusted sources without the need to parse the values oneself. It is not capable of evaluating arbitrarily complex expressions, for example involving operators or indexing.</source>
          <target state="translated">값을 직접 구문 분석 할 필요없이 신뢰할 수없는 소스의 Python 값을 포함하는 문자열을 안전하게 평가하는 데 사용할 수 있습니다. 연산자 나 인덱싱과 같은 임의의 복잡한 식을 평가할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a97c97150e89825c650323ea068e2c86fe1ae6b9" translate="yes" xml:space="preserve">
          <source>This can be used to build a shell for SQLite, as in the following example:</source>
          <target state="translated">다음 예제와 같이 SQLite 용 셸을 빌드하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9fd3ddc0879e99d9c02d07c898720ba4d93e0c4" translate="yes" xml:space="preserve">
          <source>This can be used to decode a JSON document from a string that may have extraneous data at the end.</source>
          <target state="translated">마지막에 외부 데이터가있을 수있는 문자열에서 JSON 문서를 디코딩하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0497025141b27c807ca46930213e57d7c9800435" translate="yes" xml:space="preserve">
          <source>This can be used to make triple-quoted strings line up with the left edge of the display, while still presenting them in the source code in indented form.</source>
          <target state="translated">이것은 삼중 인용 문자열을 디스플레이의 왼쪽 가장자리에 맞추면서 소스 코드에 들여 쓰기 된 형태로 표시하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62fbb7012806d21eb05599eae86ce39d18cddf93" translate="yes" xml:space="preserve">
          <source>This can be useful where you want to make a series of assertions that reuse the same object. Note that &lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt;&lt;code&gt;reset_mock()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; clear the return value, &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; or any child attributes you have set using normal assignment by default. In case you want to reset &lt;em&gt;return_value&lt;/em&gt; or &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt;, then pass the corresponding parameter as &lt;code&gt;True&lt;/code&gt;. Child mocks and the return value mock (if any) are reset as well.</source>
          <target state="translated">동일한 객체를 재사용하는 일련의 어설 션을 만들려는 경우에 유용 할 수 있습니다. 그 주 &lt;a href=&quot;#unittest.mock.Mock.reset_mock&quot;&gt; &lt;code&gt;reset_mock()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 하지 않습니다&lt;/em&gt; 반환 값을 취소 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 또는 아이가 당신이 기본적으로 정상 할당을 사용하여 설정 한 속성을. &lt;em&gt;return_value&lt;/em&gt; 또는 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 를 재설정하려는 경우 해당 매개 변수를 &lt;code&gt;True&lt;/code&gt; 로 전달하십시오. . 자식 모의 및 반환 값 모의 (있는 경우)도 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fc685bbf811c69a67bb2bc60d0369711e84128df" translate="yes" xml:space="preserve">
          <source>This can either be a function to be called when the mock is called, an iterable or an exception (class or instance) to be raised.</source>
          <target state="translated">이것은 mock이 호출 될 때 호출되는 함수, iterable 또는 예외 (클래스 또는 인스턴스)가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66804a317957a21867ce8e32ff07c321923752e6" translate="yes" xml:space="preserve">
          <source>This causes the module to behave as it does when initially imported. For example, &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; will be called on the first &lt;a href=&quot;#module-syslog&quot;&gt;&lt;code&gt;syslog()&lt;/code&gt;&lt;/a&gt; call (if &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; hasn&amp;rsquo;t already been called), and &lt;em&gt;ident&lt;/em&gt; and other &lt;a href=&quot;#syslog.openlog&quot;&gt;&lt;code&gt;openlog()&lt;/code&gt;&lt;/a&gt; parameters are reset to defaults.</source>
          <target state="translated">그러면 모듈을 처음 가져올 때와 같이 작동합니다. 예를 들어, &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 는 첫 번째 &lt;a href=&quot;#module-syslog&quot;&gt; &lt;code&gt;syslog()&lt;/code&gt; &lt;/a&gt; 호출에서 호출되고 ( &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 가 아직 호출되지 않은 경우 ) &lt;em&gt;ident&lt;/em&gt; 및 기타 &lt;a href=&quot;#syslog.openlog&quot;&gt; &lt;code&gt;openlog()&lt;/code&gt; &lt;/a&gt; 매개 변수는 기본값으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="17a078e1ca7ba133e471917a29a6b9a67bd6369b" translate="yes" xml:space="preserve">
          <source>This change is just syntactic sugar for any construct of the following form:</source>
          <target state="translated">이 변화는 다음과 같은 형태의 구문에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="20f0e4e7771296269c67abcb6e85f794dfe25cba" translate="yes" xml:space="preserve">
          <source>This class &lt;strong&gt;only&lt;/strong&gt; works with loaders that define &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; as control over what module type is used for the module is required. For those same reasons, the loader&amp;rsquo;s &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; method must return &lt;code&gt;None&lt;/code&gt; or a type for which its &lt;code&gt;__class__&lt;/code&gt; attribute can be mutated along with not using &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slots&lt;/a&gt;. Finally, modules which substitute the object placed into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; will not work as there is no way to properly replace the module references throughout the interpreter safely; &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if such a substitution is detected.</source>
          <target state="translated">이 클래스 는 필요한 모듈 유형에 대한 제어로 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt; 을 정의하는 로더 &lt;strong&gt;에서만&lt;/strong&gt; 작동 합니다. 같은 이유로 로더의 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;code&gt;None&lt;/code&gt; 이나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-slots&quot;&gt;slots를&lt;/a&gt; 사용하지 않고 &lt;code&gt;__class__&lt;/code&gt; 속성을 변경할 수 있는 유형을 반환해야합니다 . 마지막으로 &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 배치 된 객체 를 대체하는 모듈은 인터프리터 전체에서 모듈 참조를 안전하게 대체 할 수있는 방법이 없으므로 작동하지 않습니다. 이러한 대체가 감지되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ac439cfa9809ee47c3e7d79677f27b5eb953b22d" translate="yes" xml:space="preserve">
          <source>This class &lt;strong&gt;only&lt;/strong&gt; works with loaders that define &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt;&lt;code&gt;exec_module()&lt;/code&gt;&lt;/a&gt; as control over what module type is used for the module is required. For those same reasons, the loader&amp;rsquo;s &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; method must return &lt;code&gt;None&lt;/code&gt; or a type for which its &lt;code&gt;__class__&lt;/code&gt; attribute can be mutated along with not using &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-slots&quot;&gt;slots&lt;/a&gt;. Finally, modules which substitute the object placed into &lt;a href=&quot;sys#sys.modules&quot;&gt;&lt;code&gt;sys.modules&lt;/code&gt;&lt;/a&gt; will not work as there is no way to properly replace the module references throughout the interpreter safely; &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if such a substitution is detected.</source>
          <target state="translated">이 클래스 는 모듈에 사용되는 모듈 유형에 대한 제어가 필요하므로 &lt;a href=&quot;#importlib.abc.Loader.exec_module&quot;&gt; &lt;code&gt;exec_module()&lt;/code&gt; &lt;/a&gt; 을 정의하는 로더 &lt;strong&gt;에서만&lt;/strong&gt; 작동 합니다. 같은 이유로 로더의 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt; 메서드는 &lt;code&gt;None&lt;/code&gt; 을 반환 하거나 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-slots&quot;&gt;슬롯을&lt;/a&gt; 사용하지 않고 &lt;code&gt;__class__&lt;/code&gt; 속성을 변경할 수 있는 유형을 반환해야합니다 . 마지막으로, &lt;a href=&quot;sys#sys.modules&quot;&gt; &lt;code&gt;sys.modules&lt;/code&gt; 에&lt;/a&gt; 배치 된 객체 를 대체하는 모듈은 인터프리터 전체에서 모듈 참조를 안전하게 대체 할 방법이 없기 때문에 작동하지 않습니다. 이러한 대체가 감지되면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e680d4b2bbf72f285c1df68c923cf072d3a40f63" translate="yes" xml:space="preserve">
          <source>This class acts as a wrapper around list objects. It is a useful base class for your own list-like classes which can inherit from them and override existing methods or add new ones. In this way, one can add new behaviors to lists.</source>
          <target state="translated">이 클래스는 목록 객체 주위의 래퍼 역할을합니다. 자신의 목록과 같은 클래스에 대해 유용한 기본 클래스로, 클래스에서 상속하고 기존 메소드를 대체하거나 새 메소드를 추가 할 수 있습니다. 이런 식으로 목록에 새로운 동작을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1370cfdacaa0f9c4d0d1e1fcd0d6c3556803396d" translate="yes" xml:space="preserve">
          <source>This class attribute determines what happens when a custom failure message is passed as the msg argument to an assertXYY call that fails. &lt;code&gt;True&lt;/code&gt; is the default value. In this case, the custom message is appended to the end of the standard failure message. When set to &lt;code&gt;False&lt;/code&gt;, the custom message replaces the standard message.</source>
          <target state="translated">이 클래스 속성은 사용자 정의 실패 메시지가 실패한 assertXYY 호출에 msg 인수로 전달 될 때 발생하는 상황을 결정합니다. 기본값은 &lt;code&gt;True&lt;/code&gt; 입니다. 이 경우 사용자 정의 메시지가 표준 실패 메시지의 끝에 추가됩니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 사용자 정의 메시지가 표준 메시지를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="3288c0e4b6772fb834239a23818e745ac39e3d7b" translate="yes" xml:space="preserve">
          <source>This class attribute gives the exception raised by the test method. If a test framework needs to use a specialized exception, possibly to carry additional information, it must subclass this exception in order to &amp;ldquo;play fair&amp;rdquo; with the framework. The initial value of this attribute is &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 클래스 속성은 테스트 메소드에서 발생한 예외를 제공합니다. 테스트 프레임 워크가 추가 정보를 전달하기 위해 특수한 예외를 사용해야하는 경우 프레임 워크와 &quot;공정한 플레이&quot;를 위해이 예외를 서브 클래 싱해야합니다. 이 속성의 초기 값은 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="786df7dd07465af2e7bc8b322a7dd7be2995de77" translate="yes" xml:space="preserve">
          <source>This class builds on the &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;TCPServer&lt;/code&gt;&lt;/a&gt; class by storing the server address as instance variables named &lt;code&gt;server_name&lt;/code&gt; and &lt;code&gt;server_port&lt;/code&gt;. The server is accessible by the handler, typically through the handler&amp;rsquo;s &lt;code&gt;server&lt;/code&gt; instance variable.</source>
          <target state="translated">이 클래스 는 서버 주소를 &lt;code&gt;server_name&lt;/code&gt; 및 &lt;code&gt;server_port&lt;/code&gt; 인스턴스 변수로 저장 하여 &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;TCPServer&lt;/code&gt; &lt;/a&gt; 클래스를 빌드합니다 . 핸들러는 일반적으로 핸들러의 &lt;code&gt;server&lt;/code&gt; 인스턴스 변수를 통해 서버에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a61b50fa9056bcc99d4dfaa7d5cc4c9f738f3886" translate="yes" xml:space="preserve">
          <source>This class can be used to create an HTML table (or a complete HTML file containing the table) showing a side by side, line by line comparison of text with inter-line and intra-line change highlights. The table can be generated in either full or contextual difference mode.</source>
          <target state="translated">이 클래스를 사용하면 텍스트를 줄 단위로 변경하고 줄 내부 변경 강조 표시를 한 줄씩 비교하여 표시하는 HTML 테이블 (또는 테이블을 포함하는 완전한 HTML 파일)을 만들 수 있습니다. 테이블은 전체 또는 상황 별 차이 모드로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a485c6be944a5121095f4313a2ac49f87922ce2" translate="yes" xml:space="preserve">
          <source>This class can be used to generate HTML calendars.</source>
          <target state="translated">이 클래스는 HTML 달력을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24117e29e79a5bae324849b9f5e3b8f11a5140c9" translate="yes" xml:space="preserve">
          <source>This class can be used to generate plain text calendars.</source>
          <target state="translated">이 클래스는 일반 텍스트 달력을 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a69c7233ae85db1ae66cdbf46d18176f63d3a972" translate="yes" xml:space="preserve">
          <source>This class can then be used as follows:</source>
          <target state="translated">이 클래스는 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11039fec5c3d2704158aa1016ef70969433af2d0" translate="yes" xml:space="preserve">
          <source>This class constructor creates an instance of a &amp;ldquo;statistics object&amp;rdquo; from a &lt;em&gt;filename&lt;/em&gt; (or list of filenames) or from a &lt;code&gt;Profile&lt;/code&gt; instance. Output will be printed to the stream specified by &lt;em&gt;stream&lt;/em&gt;.</source>
          <target state="translated">이 클래스 생성자는 &lt;em&gt;파일 이름&lt;/em&gt; (또는 파일 이름 목록) 또는 &lt;code&gt;Profile&lt;/code&gt; 인스턴스 에서 &quot;통계 개체&quot;의 인스턴스를 만듭니다 . 출력에 의해 지정된 스트림에 인쇄됩니다 &lt;em&gt;스트림&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="997df475040ccebecaae3cb4fcd72a5ae6e0b056" translate="yes" xml:space="preserve">
          <source>This class deals with parsing and interpreter state (the user&amp;rsquo;s namespace); it does not deal with input buffering or prompting or input file naming (the filename is always passed in explicitly). The optional &lt;em&gt;locals&lt;/em&gt; argument specifies the dictionary in which code will be executed; it defaults to a newly created dictionary with key &lt;code&gt;'__name__'&lt;/code&gt; set to &lt;code&gt;'__console__'&lt;/code&gt; and key &lt;code&gt;'__doc__'&lt;/code&gt; set to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 클래스는 파싱 및 인터프리터 상태 (사용자 네임 스페이스)를 처리합니다. 입력 버퍼링 또는 프롬 프팅 또는 입력 파일 이름 지정을 처리하지 않습니다 (파일 이름은 항상 명시 적으로 전달됨). 선택적 &lt;em&gt;locals&lt;/em&gt; 인수는 코드가 실행될 사전을 지정합니다. &lt;code&gt;'__name__'&lt;/code&gt; 키 가 &lt;code&gt;'__console__'&lt;/code&gt; &lt;code&gt;'__doc__'&lt;/code&gt; 설정되고 '__doc__' 키 가 &lt;code&gt;None&lt;/code&gt; 으로 설정된 새로 작성된 사전이 기본값 입니다.</target>
        </trans-unit>
        <trans-unit id="ea6ff78f901f2fc6ecc7723c952f97db4d6143dc" translate="yes" xml:space="preserve">
          <source>This class defines the following properties, and thus values for the following may be passed in the constructor of any policy class:</source>
          <target state="translated">이 클래스는 다음과 같은 속성을 정의하므로 모든 정책 클래스의 생성자에 다음 값이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62521481dfb6022d4e3553654487427b9e7ec310" translate="yes" xml:space="preserve">
          <source>This class derives from &lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt;&lt;code&gt;BaseCookie&lt;/code&gt;&lt;/a&gt; and overrides &lt;code&gt;value_decode()&lt;/code&gt; and &lt;code&gt;value_encode()&lt;/code&gt;. SimpleCookie supports strings as cookie values. When setting the value, SimpleCookie calls the builtin &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; to convert the value to a string. Values received from HTTP are kept as strings.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#http.cookies.BaseCookie&quot;&gt; &lt;code&gt;BaseCookie&lt;/code&gt; &lt;/a&gt; 에서 파생되며 value_decode &lt;code&gt;value_decode()&lt;/code&gt; 및 &lt;code&gt;value_encode()&lt;/code&gt; 재정의 합니다. SimpleCookie는 문자열을 쿠키 값으로 지원합니다. 값을 설정할 때 SimpleCookie는 내장 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 값을 문자열로 변환합니다. HTTP에서받은 값은 문자열로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="31f80205c6eb10e35876f4bf787d88c5b1b59257" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#bz2.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;. If you need to decompress a multi-stream input with &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt;&lt;code&gt;BZ2Decompressor&lt;/code&gt;&lt;/a&gt;, you must use a new decompressor for each stream.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#bz2.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 과 달리 여러 압축 스트림을 포함하는 입력을 투명하게 처리하지 않습니다 . &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt; &lt;code&gt;BZ2Decompressor&lt;/code&gt; &lt;/a&gt; 로 멀티 스트림 입력을 압축 해제해야하는 경우 각 스트림에 대해 새로운 압축 해제 기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd0facb251a427869a35ff99157b4dc88e7a7c37" translate="yes" xml:space="preserve">
          <source>This class does not transparently handle inputs containing multiple compressed streams, unlike &lt;a href=&quot;#lzma.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#lzma.LZMAFile&quot;&gt;&lt;code&gt;LZMAFile&lt;/code&gt;&lt;/a&gt;. To decompress a multi-stream input with &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt;&lt;code&gt;LZMADecompressor&lt;/code&gt;&lt;/a&gt;, you must create a new decompressor for each stream.</source>
          <target state="translated">이 클래스는 &lt;a href=&quot;#lzma.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#lzma.LZMAFile&quot;&gt; &lt;code&gt;LZMAFile&lt;/code&gt; &lt;/a&gt; 과 달리 여러 압축 스트림을 포함하는 입력을 투명하게 처리하지 않습니다 . &lt;a href=&quot;#lzma.LZMADecompressor&quot;&gt; &lt;code&gt;LZMADecompressor&lt;/code&gt; &lt;/a&gt; 로 멀티 스트림 입력을 압축 해제하려면 각 스트림에 대해 새로운 압축 해제 기를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="874f644bbcdf96eb234234a971de4328d832635e" translate="yes" xml:space="preserve">
          <source>This class has custom assertion methods for inspecting bytecode.</source>
          <target state="translated">이 클래스에는 바이트 코드를 검사하기위한 사용자 지정 어설 ​​션 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa75e4118b76769ba47ad4be121a41b62ae457bf" translate="yes" xml:space="preserve">
          <source>This class has many &lt;code&gt;read_*()&lt;/code&gt; methods. Note that some of them raise &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; when the end of the connection is read, because they can return an empty string for other reasons. See the individual descriptions below.</source>
          <target state="translated">이 클래스에는 많은 &lt;code&gt;read_*()&lt;/code&gt; 메소드가 있습니다. 다른 이유로 인해 빈 문자열을 반환 할 수 있으므로 연결 끝을 읽을 때 일부는 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다. 아래의 개별 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="80f48affba28f3bca43510cbebf5f583a8d03e11" translate="yes" xml:space="preserve">
          <source>This class has no public constructor. An &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance must be created using the &lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt;&lt;code&gt;wrap_bio()&lt;/code&gt;&lt;/a&gt; method. This method will create the &lt;a href=&quot;#ssl.SSLObject&quot;&gt;&lt;code&gt;SSLObject&lt;/code&gt;&lt;/a&gt; instance and bind it to a pair of BIOs. The &lt;em&gt;incoming&lt;/em&gt; BIO is used to pass data from Python to the SSL protocol instance, while the &lt;em&gt;outgoing&lt;/em&gt; BIO is used to pass data the other way around.</source>
          <target state="translated">이 클래스에는 공개 생성자가 없습니다. &lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 사용하여 작성해야합니다&lt;a href=&quot;#ssl.SSLContext.wrap_bio&quot;&gt; &lt;code&gt;wrap_bio()&lt;/code&gt; &lt;/a&gt; 방법. 이 메소드는&lt;a href=&quot;#ssl.SSLObject&quot;&gt; &lt;code&gt;SSLObject&lt;/code&gt; &lt;/a&gt; 인스턴스를 작성하여한 쌍의 BIO에 바인딩합니다. &lt;em&gt;들어오는&lt;/em&gt; 그동안 BIO는 SSL 프로토콜 인스턴스에 파이썬에서 데이터를 전달하는 데 사용됩니다&lt;em&gt; 나가는&lt;/em&gt; BIO는 주위의 데이터를 다른 방법으로 전달하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d597fa762f6194a350ab0c738e09d5a34ddc0834" translate="yes" xml:space="preserve">
          <source>This class implements an interface on top of a low-level SSL object as implemented by OpenSSL. This object captures the state of an SSL connection but does not provide any network IO itself. IO needs to be performed through separate &amp;ldquo;BIO&amp;rdquo; objects which are OpenSSL&amp;rsquo;s IO abstraction layer.</source>
          <target state="translated">이 클래스는 OpenSSL에 의해 구현 된 하위 레벨 SSL 객체 위에 인터페이스를 구현합니다. 이 오브젝트는 SSL 연결 상태를 캡처하지만 네트워크 IO 자체는 제공하지 않습니다. IO는 OpenSSL의 IO 추상화 계층 인 별도의 &quot;BIO&quot;객체를 통해 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="914712e8832275f17564086e782d3f6685437de0" translate="yes" xml:space="preserve">
          <source>This class implements condition variable objects. A condition variable allows one or more threads to wait until they are notified by another thread.</source>
          <target state="translated">이 클래스는 조건 변수 객체를 구현합니다. 조건 변수를 사용하면 하나 이상의 스레드가 다른 스레드에 의해 통지 될 때까지 기다릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="878bdcd121b4b294dea82e17949c61b8c083f5ce" translate="yes" xml:space="preserve">
          <source>This class implements reentrant lock objects. A reentrant lock must be released by the thread that acquired it. Once a thread has acquired a reentrant lock, the same thread may acquire it again without blocking; the thread must release it once for each time it has acquired it.</source>
          <target state="translated">이 클래스는 재진입 잠금 개체를 구현합니다. 재진입 잠금은 획득 한 스레드에서 해제해야합니다. 스레드가 재진입 잠금을 획득하면 동일한 스레드가 차단하지 않고 다시 스레드를 획득 할 수 있습니다. 스레드는 획득 할 때마다 한 번씩 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="f24265f6cb6b6c3d8739448c1ec326c1945fc991" translate="yes" xml:space="preserve">
          <source>This class implements semaphore objects. A semaphore manages an atomic counter representing the number of &lt;a href=&quot;#threading.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; calls minus the number of &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; calls, plus an initial value. The &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt;&lt;code&gt;acquire()&lt;/code&gt;&lt;/a&gt; method blocks if necessary until it can return without making the counter negative. If not given, &lt;em&gt;value&lt;/em&gt; defaults to 1.</source>
          <target state="translated">이 클래스는 세마포어 객체를 구현합니다. 세마포어는 &lt;a href=&quot;#threading.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 호출 수에서 &lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 호출 수에 초기 값을 더한 원자 카운터를 관리합니다 . 그만큼&lt;a href=&quot;#threading.Semaphore.acquire&quot;&gt; &lt;code&gt;acquire()&lt;/code&gt; &lt;/a&gt; 메소드 블록은 카운터 마이너스 않고 리턴 할 때까지 필요한 경우. 주어진하지 않으면&lt;em&gt; 값&lt;/em&gt; 1 기본값.</target>
        </trans-unit>
        <trans-unit id="06f375996fb5283c367303d6d557ff26404aa722" translate="yes" xml:space="preserve">
          <source>This class implements temporary breakpoints, ignore counts, disabling and (re-)enabling, and conditionals.</source>
          <target state="translated">이 클래스는 임시 중단 점을 구현하고, 카운트 무시, 비활성화 및 (재) 활성화 및 조건을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ef8ab9b1f017689b8221855e12ddfb98f5fab5ae" translate="yes" xml:space="preserve">
          <source>This class implements the &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt;&lt;code&gt;ContentHandler&lt;/code&gt;&lt;/a&gt; interface by writing SAX events back into an XML document. In other words, using an &lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt;&lt;code&gt;XMLGenerator&lt;/code&gt;&lt;/a&gt; as the content handler will reproduce the original document being parsed. &lt;em&gt;out&lt;/em&gt; should be a file-like object which will default to &lt;em&gt;sys.stdout&lt;/em&gt;. &lt;em&gt;encoding&lt;/em&gt; is the encoding of the output stream which defaults to &lt;code&gt;'iso-8859-1'&lt;/code&gt;. &lt;em&gt;short_empty_elements&lt;/em&gt; controls the formatting of elements that contain no content: if &lt;code&gt;False&lt;/code&gt; (the default) they are emitted as a pair of start/end tags, if set to &lt;code&gt;True&lt;/code&gt; they are emitted as a single self-closed tag.</source>
          <target state="translated">이 클래스는 SAX 이벤트를 XML 문서에 다시 써서 &lt;a href=&quot;xml.sax.handler#xml.sax.handler.ContentHandler&quot;&gt; &lt;code&gt;ContentHandler&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현합니다 . 즉, &lt;a href=&quot;#xml.sax.saxutils.XMLGenerator&quot;&gt; &lt;code&gt;XMLGenerator&lt;/code&gt; &lt;/a&gt; 를 컨텐츠 핸들러로 사용하면 구문 분석중인 원본 문서가 재생성됩니다. &lt;em&gt;out&lt;/em&gt; 은 파일과 같은 객체 여야하며 기본값은 &lt;em&gt;sys.stdout&lt;/em&gt; 입니다. &lt;em&gt;encoding&lt;/em&gt; 은 출력 스트림의 인코딩이며 기본값은 &lt;code&gt;'iso-8859-1'&lt;/code&gt; 입니다. &lt;em&gt;short_empty_elements&lt;/em&gt; 는 내용을 포함하지 않는 요소의 형식을 제어합니다. &lt;code&gt;False&lt;/code&gt; (기본값) 인 경우 시작 / 종료 태그 쌍으로 생성되며 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 단일 자체 닫힘 태그로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c98a08502c61e88276fa107a306b9bc8b9b51f82" translate="yes" xml:space="preserve">
          <source>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4 port (143) is used.</source>
          <target state="translated">이 클래스는 실제 IMAP4 프로토콜을 구현합니다. 연결이 작성되고 인스턴스가 초기화 될 때 프로토콜 버전 (IMAP4 또는 IMAP4rev1)이 결정됩니다. 경우 &lt;em&gt;호스트가&lt;/em&gt; 지정되지 않은, &lt;code&gt;''&lt;/code&gt; (로컬 호스트)가 사용됩니다. 경우 &lt;em&gt;포트는&lt;/em&gt; 생략 표준 IMAP4 포트 (143)가 사용된다.</target>
        </trans-unit>
        <trans-unit id="2f061eb8879697c7b6070feb82741ebb04708bc3" translate="yes" xml:space="preserve">
          <source>This class implements the actual IMAP4 protocol. The connection is created and protocol version (IMAP4 or IMAP4rev1) is determined when the instance is initialized. If &lt;em&gt;host&lt;/em&gt; is not specified, &lt;code&gt;''&lt;/code&gt; (the local host) is used. If &lt;em&gt;port&lt;/em&gt; is omitted, the standard IMAP4 port (143) is used. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used.</source>
          <target state="translated">이 클래스는 실제 IMAP4 프로토콜을 구현합니다. 연결이 생성되고 인스턴스가 초기화 될 때 프로토콜 버전 (IMAP4 또는 IMAP4rev1)이 결정됩니다. 경우 &lt;em&gt;호스트가&lt;/em&gt; 지정되지 않은, &lt;code&gt;''&lt;/code&gt; (로컬 호스트)가 사용됩니다. 경우 &lt;em&gt;포트는&lt;/em&gt; 생략 표준 IMAP4 포트 (143)가 사용된다. 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도에 대한 제한 시간 (초)을 지정합니다. 제한 시간이 지정되지 않았거나 없음 인 경우 전역 기본 소켓 제한 시간이 사용됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
