<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="9f6e0effa06c3e5c138d8490e703f490b0039368" translate="yes" xml:space="preserve">
          <source>New in version 3.4: is_global</source>
          <target state="translated">버전 3.4의 새로운 기능 : is_global</target>
        </trans-unit>
        <trans-unit id="1f837cd28063a6c218f31e72720b5003175aed01" translate="yes" xml:space="preserve">
          <source>New in version 3.5.</source>
          <target state="translated">버전 3.5의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="1fa95c8a406c55887ed636be5dccd00a7a0fa295" translate="yes" xml:space="preserve">
          <source>New in version 3.5.1.</source>
          <target state="translated">버전 3.5.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="8b612aef28c4f185839e563a8a96375f82700410" translate="yes" xml:space="preserve">
          <source>New in version 3.5.2.</source>
          <target state="translated">버전 3.5.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="2c7957076db9f4d38f7ee1ad92950f56a72edea9" translate="yes" xml:space="preserve">
          <source>New in version 3.5.3.</source>
          <target state="translated">버전 3.5.3의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="07321da105ae55ff5d5709eae1f53e75964ddc33" translate="yes" xml:space="preserve">
          <source>New in version 3.5.4.</source>
          <target state="translated">버전 3.5.4의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="3fbc5dfdcbe6f0de84bdbc30382ee50720861f9c" translate="yes" xml:space="preserve">
          <source>New in version 3.5: &lt;code&gt;follow_wrapped&lt;/code&gt; parameter. Pass &lt;code&gt;False&lt;/code&gt; to get a signature of &lt;code&gt;callable&lt;/code&gt; specifically (&lt;code&gt;callable.__wrapped__&lt;/code&gt; will not be used to unwrap decorated callables.)</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;follow_wrapped&lt;/code&gt; 매개 변수. 패스 &lt;code&gt;False&lt;/code&gt; 의 서명을받을 &lt;code&gt;callable&lt;/code&gt; 특히 ( &lt;code&gt;callable.__wrapped__&lt;/code&gt; 장식 callables 랩을 해제하는 데 사용되지 않습니다를.)</target>
        </trans-unit>
        <trans-unit id="9e2d52bce291ba21a1b94d4b005b1cf7dc019b90" translate="yes" xml:space="preserve">
          <source>New in version 3.5: &lt;em&gt;quote_via&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;quote_via&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="0a2103b4477c36713c1b4425a3142a28baa40aa4" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Added &lt;code&gt;is_authenticated&lt;/code&gt; support.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;is_authenticated&lt;/code&gt; 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0178c262a4c0123cec8f5bef7190a7211f72daae" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Added the &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt;&lt;code&gt;st_file_attributes&lt;/code&gt;&lt;/a&gt; member on Windows.</source>
          <target state="translated">버전 3.5의 새로운 기능 : Windows에 &lt;a href=&quot;#os.stat_result.st_file_attributes&quot;&gt; &lt;code&gt;st_file_attributes&lt;/code&gt; &lt;/a&gt; 멤버가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="8df129ebe6df04e6f5367d827d4028abd2387a31" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Previously, &lt;a href=&quot;#http.client.BadStatusLine&quot;&gt;&lt;code&gt;BadStatusLine&lt;/code&gt;&lt;/a&gt;&lt;code&gt;('')&lt;/code&gt; was raised.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 이전에는 &lt;a href=&quot;#http.client.BadStatusLine&quot;&gt; &lt;code&gt;BadStatusLine&lt;/code&gt; &lt;/a&gt; &lt;code&gt;('')&lt;/code&gt; 이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="9180aafc542f6e962e2074854b1f38f5061dcdf6" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Previously, a plain &lt;a href=&quot;#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; was raised.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 이전에는 일반 &lt;a href=&quot;#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="3b54ddd1a8adfffd3e1ed259fed23234d3a80add" translate="yes" xml:space="preserve">
          <source>New in version 3.5: Support for internationalized addresses (&lt;code&gt;SMTPUTF8&lt;/code&gt;).</source>
          <target state="translated">버전 3.5의 새로운 기능 : 국제화 된 주소 지원 ( &lt;code&gt;SMTPUTF8&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="146b7ebb3f774b3f489ea95a898318e2a4680f5a" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt;&lt;code&gt;enable()&lt;/code&gt;&lt;/a&gt; method itself, and &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt; support.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt; &lt;code&gt;enable()&lt;/code&gt; &lt;/a&gt; 메소드 자체 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6855.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 6855&lt;/strong&gt;&lt;/a&gt; 지원.</target>
        </trans-unit>
        <trans-unit id="3d5702ae33ccc35d4ec27c96ab0f6748c1bfbbce" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;code&gt;'namereplace'&lt;/code&gt; error handler.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리기.</target>
        </trans-unit>
        <trans-unit id="c97b2effe0e40cd82111946917872bd69cee668e" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;decode_data&lt;/em&gt; and &lt;em&gt;enable_SMTPUTF8&lt;/em&gt; constructor parameters, and the &lt;em&gt;kwargs&lt;/em&gt; parameter to &lt;a href=&quot;#smtpd.SMTPServer.process_message&quot;&gt;&lt;code&gt;process_message()&lt;/code&gt;&lt;/a&gt; when &lt;em&gt;decode_data&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;decode_data&lt;/em&gt; 및 &lt;em&gt;enable_SMTPUTF8&lt;/em&gt; 생성자 매개 변수 및 &lt;em&gt;decode_data&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;em&gt;kwargs&lt;/em&gt; 매개 변수가 &lt;a href=&quot;#smtpd.SMTPServer.process_message&quot;&gt; &lt;code&gt;process_message()&lt;/code&gt; &lt;/a&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="503c88f7cc88d9c109004b72250f22c5abdb8141" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;exr&lt;/em&gt; and &lt;em&gt;webp&lt;/em&gt; formats were added.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;exr&lt;/em&gt; 및 &lt;em&gt;webp&lt;/em&gt; 형식이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="3cfbf13ed17363441f3df8820387841a221acb2f" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The &lt;em&gt;mangle_from_&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;em&gt;mangle_from_&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="b705147dd17b73bdb5144032054ce3ee0a848bed" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The SMTPUTF8 extension (&lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt;) is now supported.</source>
          <target state="translated">버전 3.5의 새로운 기능 : SMTPUTF8 확장 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc6531.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 6531&lt;/strong&gt;&lt;/a&gt; )이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4071071236fe8569928d891b12576f7b86895ed7" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The command-line option &lt;code&gt;--locals&lt;/code&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : 명령 줄 옵션 &lt;code&gt;--locals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f069158efc3960b336f0767e900a4a5a3e81e366" translate="yes" xml:space="preserve">
          <source>New in version 3.5: The name &lt;code&gt;assertNotRegexpMatches&lt;/code&gt; is a deprecated alias for &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt;&lt;code&gt;assertNotRegex()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.5의 새로운 기능 : &lt;code&gt;assertNotRegexpMatches&lt;/code&gt; 라는 이름 은 &lt;a href=&quot;#unittest.TestCase.assertNotRegex&quot;&gt; &lt;code&gt;assertNotRegex()&lt;/code&gt; &lt;/a&gt; 의 더 이상 사용되지 않는 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="19bf2295406fe646f85406c7590ce23f4c62ad62" translate="yes" xml:space="preserve">
          <source>New in version 3.6.</source>
          <target state="translated">버전 3.6의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="90349cc2f262d4c23d65ab39676f28264f9ab398" translate="yes" xml:space="preserve">
          <source>New in version 3.6.0.</source>
          <target state="translated">버전 3.6.0의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="45594f8e6c19eac8ab677c7056e00b26cfb95c1f" translate="yes" xml:space="preserve">
          <source>New in version 3.6.1.</source>
          <target state="translated">버전 3.6.1의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="5a7ee2ea584d1e3940ee533dbeaa4e452bd13404" translate="yes" xml:space="preserve">
          <source>New in version 3.6.1: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">버전 3.6.1의 새로운 기능 : &lt;em&gt;filenames&lt;/em&gt; 매개 변수는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 유사한 객체를&lt;/a&gt; 허용 합니다 .</target>
        </trans-unit>
        <trans-unit id="05a9dd80d7229228d769b87c1f8dedd762ef825f" translate="yes" xml:space="preserve">
          <source>New in version 3.6.1: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">New in version 3.6.1: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="5e7a6843b86d2ae87bc59ed04e6f809cf47c50e6" translate="yes" xml:space="preserve">
          <source>New in version 3.6.2.</source>
          <target state="translated">버전 3.6.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="80dfc6066f14bf6496d45305c08af7a4c450a97c" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;a href=&quot;#hashlib.blake2b&quot;&gt;&lt;code&gt;blake2b()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#hashlib.blake2s&quot;&gt;&lt;code&gt;blake2s()&lt;/code&gt;&lt;/a&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;#hashlib.blake2b&quot;&gt; &lt;code&gt;blake2b()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#hashlib.blake2s&quot;&gt; &lt;code&gt;blake2s()&lt;/code&gt; &lt;/a&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="4340416fdc1fa009b4460cbe3e9816c6f0043daf" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a2feeb245024eb57add73d00ab775abcb904e866" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;%G&lt;/code&gt;, &lt;code&gt;%u&lt;/code&gt; and &lt;code&gt;%V&lt;/code&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;%G&lt;/code&gt; , &lt;code&gt;%u&lt;/code&gt; 및 &lt;code&gt;%V&lt;/code&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="c218c216bff866c0b87e532df3da0d215cc23a5f" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;EPOLLEXCLUSIVE&lt;/code&gt; was added. It&amp;rsquo;s only supported by Linux Kernel 4.5 or later.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;EPOLLEXCLUSIVE&lt;/code&gt; 가 추가되었습니다. Linux Kernel 4.5 이상에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="67f3b398e277e32be1c6a0466247dee478994e07" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;Flag&lt;/code&gt;, &lt;code&gt;IntFlag&lt;/code&gt;, &lt;code&gt;auto&lt;/code&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;Flag&lt;/code&gt; , &lt;code&gt;IntFlag&lt;/code&gt; , &lt;code&gt;auto&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d27e2376c72696bcc77e2fe6f41dd1602bc5773c" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;code&gt;_missing_&lt;/code&gt;, &lt;code&gt;_order_&lt;/code&gt;, &lt;code&gt;_generate_next_value_&lt;/code&gt;</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;_missing_&lt;/code&gt; , &lt;code&gt;_order_&lt;/code&gt; , &lt;code&gt;_generate_next_value_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10e005437ad547a8fd8e2ccd4b8b20d9e4c5dff" translate="yes" xml:space="preserve">
          <source>New in version 3.6: &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; were added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="12ace1f101bca9a308b177329a35f1d66d6db703" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 매개 변수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e301bee116d339912a92c894a8a22f3f1fa59962" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added support for the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; protocol and the &lt;a href=&quot;#os.scandir.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method. If a &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; iterator is neither exhausted nor explicitly closed a &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; will be emitted in its destructor.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;컨텍스트 관리자&lt;/a&gt; 프로토콜 및 &lt;a href=&quot;#os.scandir.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 지원이 추가되었습니다 . 경우 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 반복자는 어느 쪽도 폐쇄 명시 적으로 소모되지도 않은 &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 소멸자에서 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b4eead1f21e0be519048e687407e0242c63c73" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added support for the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; protocol and the &lt;a href=&quot;#os.scandir.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method. If a &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; iterator is neither exhausted nor explicitly closed a &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; will be emitted in its destructor.</source>
          <target state="translated">New in version 3.6: Added support for the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; protocol and the &lt;a href=&quot;#os.scandir.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; method. If a &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; iterator is neither exhausted nor explicitly closed a &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; will be emitted in its destructor.</target>
        </trans-unit>
        <trans-unit id="b402613c2d781a5a7bb0dd32b82d79f1ecb4727b" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;code&gt;fold&lt;/code&gt; argument.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;fold&lt;/code&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="00930151a8d899f4720871c54b11a77ab5264e8f" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;code&gt;prompt&lt;/code&gt; parameter</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;code&gt;prompt&lt;/code&gt; 매개 변수 추가</target>
        </trans-unit>
        <trans-unit id="5f1a9af93f36ac766f8daa131d6c0d3f78622179" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Added the &lt;em&gt;timespec&lt;/em&gt; argument.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;timespec&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="7066aa1da03dd2863a3d30aa190f6000662f4314" translate="yes" xml:space="preserve">
          <source>New in version 3.6: Chunked encoding support. The &lt;em&gt;encode_chunked&lt;/em&gt; parameter was added.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 청크 인코딩 지원. &lt;em&gt;encode_chunked&lt;/em&gt; 매개 변수는 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="a58ba40e7a25c57becebc3eef2d13a66d5397af8" translate="yes" xml:space="preserve">
          <source>New in version 3.6: SHA3 (Keccak) and SHAKE constructors &lt;code&gt;sha3_224()&lt;/code&gt;, &lt;code&gt;sha3_256()&lt;/code&gt;, &lt;code&gt;sha3_384()&lt;/code&gt;, &lt;code&gt;sha3_512()&lt;/code&gt;, &lt;code&gt;shake_128()&lt;/code&gt;, &lt;code&gt;shake_256()&lt;/code&gt;.</source>
          <target state="translated">버전 3.6의 새로운 기능 : SHA3 (Keccak) 및 SHAKE 생성자 &lt;code&gt;sha3_224()&lt;/code&gt; , &lt;code&gt;sha3_256()&lt;/code&gt; , &lt;code&gt;sha3_384()&lt;/code&gt; , &lt;code&gt;sha3_512()&lt;/code&gt; , &lt;code&gt;shake_128()&lt;/code&gt; , &lt;code&gt;shake_256()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba67193ad20bf5f9e114ef18a7615f3b1a6f3fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-11&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d6bd06fa71e11edc99f68e21763a25ff9db9b852" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details.</target>
        </trans-unit>
        <trans-unit id="32a8a06257d0d3aa4bc5a3c9830582cf1e8ac1b0" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details, and for a reference example of a &lt;em&gt;finalizer&lt;/em&gt; method see the implementation of &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; in &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py&quot;&gt;Lib/asyncio/base_events.py&lt;/a&gt;</source>
          <target state="translated">새로운 버전 3.6 : 참조 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-27&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; 자세한 내용 및의 참조 예를 들어 &lt;em&gt;종료 자&lt;/em&gt; 의 구현 볼 방법 &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; 에서 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Lib/asyncio/base_events.py&quot;&gt;/ asyncio / base_events.py 해방을&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84632b7133b2afb86ab03dd6882451587698652f" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details, and for a reference example of a &lt;em&gt;finalizer&lt;/em&gt; method see the implementation of &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/base_events.py&quot;&gt;Lib/asyncio/base_events.py&lt;/a&gt;</source>
          <target state="translated">New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0525&quot; id=&quot;index-28&quot;&gt;&lt;strong&gt;PEP 525&lt;/strong&gt;&lt;/a&gt; for more details, and for a reference example of a &lt;em&gt;finalizer&lt;/em&gt; method see the implementation of &lt;code&gt;asyncio.Loop.shutdown_asyncgens&lt;/code&gt; in &lt;a href=&quot;https://github.com/python/cpython/tree/3.9/Lib/asyncio/base_events.py&quot;&gt;Lib/asyncio/base_events.py&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0029940bca23ccdb728fe00850c420e066576083" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">버전 3.6의 새로운 기능 : 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-31&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5e7dd86913abfca211bf3678e445f5e8d9da9a64" translate="yes" xml:space="preserve">
          <source>New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-32&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">New in version 3.6: See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0529&quot; id=&quot;index-32&quot;&gt;&lt;strong&gt;PEP 529&lt;/strong&gt;&lt;/a&gt; for more details.</target>
        </trans-unit>
        <trans-unit id="e4aac78a8599305666d1bcd98d489c9b474ee017" translate="yes" xml:space="preserve">
          <source>New in version 3.6: The &lt;em&gt;strict&lt;/em&gt; argument (pre-3.6 behavior is strict).</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;엄격한&lt;/em&gt; 인수 (3.6 이전 동작이 엄격함).</target>
        </trans-unit>
        <trans-unit id="ed2cdfb400d26244abead12bdb67496c73a450a0" translate="yes" xml:space="preserve">
          <source>New in version 3.6: The &lt;em&gt;thread_name_prefix&lt;/em&gt; argument was added to allow users to control the &lt;a href=&quot;threading#threading.Thread&quot;&gt;&lt;code&gt;threading.Thread&lt;/code&gt;&lt;/a&gt; names for worker threads created by the pool for easier debugging.</source>
          <target state="translated">버전 3.6의 새로운 기능 : &lt;em&gt;thread_name_prefix&lt;/em&gt; 인수가 추가되어 사용자가 &lt;a href=&quot;threading#threading.Thread&quot;&gt; &lt;code&gt;threading.Thread&lt;/code&gt; &lt;/a&gt; 을 제어 할 수 있습니다. 더 쉬운 디버깅을 위해 풀에서 만든 작업자 스레드 의 스레드 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bd28c614713bbf071342d57c2928588052675b48" translate="yes" xml:space="preserve">
          <source>New in version 3.7.</source>
          <target state="translated">버전 3.7의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="ab8b0d832441ec9f8afe55c3080968bfbf5d3b44" translate="yes" xml:space="preserve">
          <source>New in version 3.7.1.</source>
          <target state="translated">버전 3.7.1의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="c9fd11c42763cb36ec0c19d3ced88d96a640764b" translate="yes" xml:space="preserve">
          <source>New in version 3.7.2.</source>
          <target state="translated">버전 3.7.2의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="9a57a48cac73d938901b1d889265048d7b45f13b" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;--directory&lt;/code&gt; specify alternate directory</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;--directory&lt;/code&gt; 는 대체 디렉토리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2909fbd69c7afbaa6cf6f31b68ba8de890bc59f0" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;A_ITALIC&lt;/code&gt; was added.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;A_ITALIC&lt;/code&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="8a466235e323520983f5de7f81ecbc6daa3c3354" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;_ignore_&lt;/code&gt;</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;_ignore_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adde274e405e80348f0778a3079bdac06f47c1e9" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;code&gt;pdb.py&lt;/code&gt; now accepts a &lt;code&gt;-m&lt;/code&gt; option that execute modules similar to the way &lt;code&gt;python3 -m&lt;/code&gt; does. As with a script, the debugger will pause execution just before the first line of the module.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;pdb.py&lt;/code&gt; 는 &lt;code&gt;python3 -m&lt;/code&gt; 과 유사한 모듈을 실행 하는 &lt;code&gt;-m&lt;/code&gt; 옵션을 허용합니다 . 스크립트와 마찬가지로 디버거는 모듈의 첫 번째 줄 직전에 실행을 일시 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0348eea632d38a741b35d7722942981b7e29f1ce" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;em&gt;text&lt;/em&gt; was added as a more readable alias for &lt;em&gt;universal_newlines&lt;/em&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;텍스트&lt;/em&gt; 가 &lt;em&gt;universal_newlines에&lt;/em&gt; 대한 읽기 쉬운 별명으로 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5f0baef37767767dd3f2cb730f45d1b063439fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.7: &lt;strong&gt;Important:&lt;/strong&gt; this has been added to asyncio in Python 3.7 &lt;em&gt;on a provisional basis&lt;/em&gt;! This is as an experimental API that might be changed or removed completely in Python 3.8.</source>
          <target state="translated">새로운 버전 3.7 : &lt;strong&gt;중요 :&lt;/strong&gt; 이 파이썬 3.7에 asyncio 추가되었습니다 &lt;em&gt;잠정적으로&lt;/em&gt; ! 이것은 Python 3.8에서 완전히 변경되거나 제거 될 수있는 실험용 API입니다.</target>
        </trans-unit>
        <trans-unit id="f3a4eca7b00b876cf18c98faef57e563aee90833" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added &lt;code&gt;f_fsid&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;code&gt;f_fsid&lt;/code&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="acbec27175c9a57e694aea3647f0f2d4e44b15b1" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; and &lt;em&gt;start_serving&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 및 &lt;em&gt;start_serving&lt;/em&gt; 매개 변수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="02404564795309b1c84708a7dc54ae19f294229e" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;a href=&quot;#os.stat_result.st_fstype&quot;&gt;&lt;code&gt;st_fstype&lt;/code&gt;&lt;/a&gt; member to Solaris/derivatives.</source>
          <target state="translated">버전 3.7의 새로운 기능 : Solaris / 파생에 &lt;a href=&quot;#os.stat_result.st_fstype&quot;&gt; &lt;code&gt;st_fstype&lt;/code&gt; &lt;/a&gt; 멤버를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="4825919b8ce59ba82d22b5bba489218e7eb00e42" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;code&gt;-m&lt;/code&gt; option to &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; 에&lt;/a&gt; &lt;code&gt;-m&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="08036b38411b712da487efc5c9de3f5c019a9bfd" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;em&gt;filter&lt;/em&gt; and &lt;em&gt;compressed&lt;/em&gt; arguments.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;필터&lt;/em&gt; 및 &lt;em&gt;압축&lt;/em&gt; 인수가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ce490b7adba761d51637a993e78564658a585b7c" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the &lt;em&gt;text&lt;/em&gt; parameter as an alias for &lt;em&gt;universal_newlines&lt;/em&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;텍스트&lt;/em&gt; 매개 변수를 &lt;em&gt;universal_newlines&lt;/em&gt; 의 별명으로 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="b546280fb3d0cd05c36e366475e058b3bfb9e3cf" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Added the SortKey enum.</source>
          <target state="translated">버전 3.7의 새로운 기능 : SortKey 열거 형이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="410aff229467eac243173224687c8e5967e89a41" translate="yes" xml:space="preserve">
          <source>New in version 3.7: Descriptors for nested definitions. They are accessed through the new children attribute. Each has a new parent attribute.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 중첩 정의를위한 설명자. 새 하위 속성을 통해 액세스합니다. 각각 새로운 부모 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a30a5ef6e12e6aa72ab9eaa507a8c20cae7e496f" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;filenames&lt;/em&gt; parameter accepts a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;filenames&lt;/em&gt; 매개 변수는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="493a985537bd7b9d798cb8594ee5777373a89a86" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; and &lt;em&gt;start_serving&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 및 &lt;em&gt;start_serving&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f67f29ad67b51dd6b7b13f7df829ff2ca08cd222" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.7의 새로운 기능 : &lt;em&gt;ssl_handshake_timeout&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="338f24ef253909c3bf5579f812dd70f28bc15ad5" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The built-in &lt;a href=&quot;functions#breakpoint&quot;&gt;&lt;code&gt;breakpoint()&lt;/code&gt;&lt;/a&gt;, when called with defaults, can be used instead of &lt;code&gt;import pdb; pdb.set_trace()&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 기본적으로 호출 될 때 &lt;code&gt;import pdb; pdb.set_trace()&lt;/code&gt; 대신 내장 된 &lt;a href=&quot;functions#breakpoint&quot;&gt; &lt;code&gt;breakpoint()&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있습니다 . pdb.set_trace () .</target>
        </trans-unit>
        <trans-unit id="7b44bee6a8a9a71004cf5c288fd7ae64eb6f752b" translate="yes" xml:space="preserve">
          <source>New in version 3.7: The command-line option &lt;code&gt;-k&lt;/code&gt;.</source>
          <target state="translated">버전 3.7의 새로운 기능 : 명령 행 옵션 &lt;code&gt;-k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aef538c8351307b1d3b281db6329d7cb7bec872" translate="yes" xml:space="preserve">
          <source>New in version 3.7: __breakpointhook__</source>
          <target state="translated">버전 3.7의 새로운 기능 : __breakpointhook__</target>
        </trans-unit>
        <trans-unit id="d47b26a1d8dd776fc7c16b2a5c0deac1fe3b72d5" translate="yes" xml:space="preserve">
          <source>New in version 3.8.</source>
          <target state="translated">버전 3.8의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="cd6669aa182efb34ab7412c772c8149990945b82" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;code&gt;--bind&lt;/code&gt; argument enhanced to support IPv6</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;--bind&lt;/code&gt; 인수가 IPv6을 지원하도록 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="152fbdc9d06de500d8f88db67583d3d091f0e3fe" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; can now be passed in flags to enable support for top-level &lt;code&gt;await&lt;/code&gt;, &lt;code&gt;async for&lt;/code&gt;, and &lt;code&gt;async with&lt;/code&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;ast.PyCF_ALLOW_TOP_LEVEL_AWAIT&lt;/code&gt; 를 플래그로 전달하여 최상위 &lt;code&gt;await&lt;/code&gt; , &lt;code&gt;async for&lt;/code&gt; 및 &lt;code&gt;async with&lt;/code&gt; 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f75a638f151f376d645945dad75c62bc6c93b237" translate="yes" xml:space="preserve">
          <source>New in version 3.8: &lt;em&gt;order&lt;/em&gt; can be {&amp;lsquo;C&amp;rsquo;, &amp;lsquo;F&amp;rsquo;, &amp;lsquo;A&amp;rsquo;}. When &lt;em&gt;order&lt;/em&gt; is &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo;, the data of the original array is converted to C or Fortran order. For contiguous views, &amp;lsquo;A&amp;rsquo; returns an exact copy of the physical memory. In particular, in-memory Fortran order is preserved. For non-contiguous views, the data is converted to C first. &lt;em&gt;order=None&lt;/em&gt; is the same as &lt;em&gt;order=&amp;rsquo;C&amp;rsquo;&lt;/em&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;순서&lt;/em&gt; 는 { 'C', 'F', 'A'} 일 수 있습니다. 되면 &lt;em&gt;주문&lt;/em&gt; 'C'또는 'F'인 원의 배열의 데이터는 C 또는 포트란 순서로 변환된다. 연속 된 뷰의 경우 'A'는 실제 메모리의 정확한 사본을 반환합니다. 특히 메모리 내 포트란 순서가 유지됩니다. 연속되지 않은 뷰의 경우 데이터가 먼저 C로 변환됩니다. &lt;em&gt;order = 없음&lt;/em&gt; 은 &lt;em&gt;order = 'C'와 같습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2cff40a0917f8f2171e5ff8c7704c205ac772d99" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added &lt;code&gt;--module&lt;/code&gt; option that allows to run an executable module.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 실행 모듈을 실행할 수있는 &lt;code&gt;--module&lt;/code&gt; 옵션이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9ec5376ab9dcf06a2c4b76dd85864c5f7f72d6f3" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added &lt;code&gt;451 UNAVAILABLE_FOR_LEGAL_REASONS&lt;/code&gt; status code.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;451 UNAVAILABLE_FOR_LEGAL_REASONS&lt;/code&gt; 상태 코드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="186ccced30c0596281d99c06878fe06f5cba4d05" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added the &lt;a href=&quot;#os.stat_result.st_reparse_tag&quot;&gt;&lt;code&gt;st_reparse_tag&lt;/code&gt;&lt;/a&gt; member on Windows.</source>
          <target state="translated">버전 3.8의 새로운 기능 : Windows에 &lt;a href=&quot;#os.stat_result.st_reparse_tag&quot;&gt; &lt;code&gt;st_reparse_tag&lt;/code&gt; &lt;/a&gt; 멤버가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="31ad6246322e02482cc2675a0a61de73a9615090" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added the &lt;code&gt;-m&lt;/code&gt; option to &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;code&gt;-m&lt;/code&gt; 옵션을 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; 에&lt;/a&gt; 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f26ceaddd42d6cbf676fedbd2a6fc746d292b5" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Added the &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; and &lt;em&gt;interleave&lt;/em&gt; parameters.</source>
          <target state="translated">New in version 3.8: Added the &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; and &lt;em&gt;interleave&lt;/em&gt; parameters.</target>
        </trans-unit>
        <trans-unit id="94e84a13854d39d8a4e632a89b58cf02e628570f" translate="yes" xml:space="preserve">
          <source>New in version 3.8: PowerShell activation scripts installed under POSIX for PowerShell Core support.</source>
          <target state="translated">버전 3.8의 새로운 기능 : PowerShell Core 지원을 위해 POSIX에 설치된 PowerShell 활성화 스크립트.</target>
        </trans-unit>
        <trans-unit id="f6946e0aad7bd1d3aa73545d7a267c0b448f75c6" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Previous versions of CPython would resolve DLLs using the default behavior for the current process. This led to inconsistencies, such as only sometimes searching &lt;code id=&quot;index-25&quot;&gt;PATH&lt;/code&gt; or the current working directory, and OS functions such as &lt;code&gt;AddDllDirectory&lt;/code&gt; having no effect.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 이전 버전의 CPython은 현재 프로세스의 기본 동작을 사용하여 DLL을 분석합니다. 이로 인해 때때로 &lt;code id=&quot;index-25&quot;&gt;PATH&lt;/code&gt; 검색 또는 현재 작업 디렉토리와 같은 &lt;code&gt;AddDllDirectory&lt;/code&gt; 가 발생 했으며 AddDllDirectory 와 같은 OS 기능은 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="92b71d0989b5e2766fd9e7a24391532ddf29ff85" translate="yes" xml:space="preserve">
          <source>New in version 3.8: Previous versions of CPython would resolve DLLs using the default behavior for the current process. This led to inconsistencies, such as only sometimes searching &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; or the current working directory, and OS functions such as &lt;code&gt;AddDllDirectory&lt;/code&gt; having no effect.</source>
          <target state="translated">New in version 3.8: Previous versions of CPython would resolve DLLs using the default behavior for the current process. This led to inconsistencies, such as only sometimes searching &lt;code id=&quot;index-27&quot;&gt;PATH&lt;/code&gt; or the current working directory, and OS functions such as &lt;code&gt;AddDllDirectory&lt;/code&gt; having no effect.</target>
        </trans-unit>
        <trans-unit id="f977a95a81a55a1784f791e2a58c544b6b5481e3" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;dirs_exist_ok&lt;/em&gt; parameter.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;dirs_exist_ok&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="b713cbde69ae2c18b39ec28507e206c345a918bd" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; and &lt;em&gt;interleave&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;happy_eyeballs_delay&lt;/em&gt; 및 &lt;em&gt;interleave&lt;/em&gt; 매개 변수.</target>
        </trans-unit>
        <trans-unit id="bce6b595725e42c8ce0117c78ce8cc089343e237" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;strict_timestamps&lt;/em&gt; keyword-only argument</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;strict_timestamps&lt;/em&gt; 키워드 전용 인수</target>
        </trans-unit>
        <trans-unit id="aeec7f4f480fc32e5c189622f501015e66103fc7" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The &lt;em&gt;xml_declaration&lt;/em&gt; and &lt;em&gt;default_namespace&lt;/em&gt; parameters.</source>
          <target state="translated">버전 3.8의 새로운 기능 : &lt;em&gt;xml_declaration&lt;/em&gt; 및 &lt;em&gt;default_namespace&lt;/em&gt; 매개 변수</target>
        </trans-unit>
        <trans-unit id="4207315e68011a4c07693dcc3f18b88787928c23" translate="yes" xml:space="preserve">
          <source>New in version 3.8: The optional sixth tuple item, &lt;code&gt;(obj, state)&lt;/code&gt;, was added.</source>
          <target state="translated">버전 3.8의 새로운 기능 : 선택적인 여섯 번째 튜플 항목 &lt;code&gt;(obj, state)&lt;/code&gt; 이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="381a2e6108c8c4e584e3ed66c51e452dbe93d8f5" translate="yes" xml:space="preserve">
          <source>New in version 3.8: __unraisablehook__</source>
          <target state="translated">New in version 3.8: __unraisablehook__</target>
        </trans-unit>
        <trans-unit id="7d32fcf91915e623de562b2552462516032461ba" translate="yes" xml:space="preserve">
          <source>New in version 3.9.</source>
          <target state="translated">버전 3.9의 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="ee8710071aa58c3bea26135b1e09e5d0b4b1be68" translate="yes" xml:space="preserve">
          <source>New in version 3.9: Added &lt;code&gt;103 EARLY_HINTS&lt;/code&gt;, &lt;code&gt;418 IM_A_TEAPOT&lt;/code&gt; and &lt;code&gt;425 TOO_EARLY&lt;/code&gt; status codes.</source>
          <target state="translated">New in version 3.9: Added &lt;code&gt;103 EARLY_HINTS&lt;/code&gt; , &lt;code&gt;418 IM_A_TEAPOT&lt;/code&gt; and &lt;code&gt;425 TOO_EARLY&lt;/code&gt; status codes.</target>
        </trans-unit>
        <trans-unit id="cda6243acf3aaa4d2adb9a50ee4fc2d504a36940" translate="yes" xml:space="preserve">
          <source>New in version 3.9: Added the &lt;code&gt;upgrade_deps&lt;/code&gt; parameter</source>
          <target state="translated">New in version 3.9: Added the &lt;code&gt;upgrade_deps&lt;/code&gt; parameter</target>
        </trans-unit>
        <trans-unit id="c8b7484a9ab24438dc27afbac38d3298eac7733f" translate="yes" xml:space="preserve">
          <source>New in version 3.9: Added the following dataclasses: StatsProfile, FunctionProfile. Added the following function: get_stats_profile.</source>
          <target state="translated">New in version 3.9: Added the following dataclasses: StatsProfile, FunctionProfile. Added the following function: get_stats_profile.</target>
        </trans-unit>
        <trans-unit id="8afe712c1a6039a74e4243e19a702080b616b8d2" translate="yes" xml:space="preserve">
          <source>New in version 3.9: Added the function &lt;code&gt;cache_parameters()&lt;/code&gt;</source>
          <target state="translated">New in version 3.9: Added the function &lt;code&gt;cache_parameters()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc84a24cf8af514ea6370d8af094d8feadb68261" translate="yes" xml:space="preserve">
          <source>New in version 3.9: The &lt;em&gt;base_url&lt;/em&gt; and &lt;em&gt;max_depth&lt;/em&gt; parameters.</source>
          <target state="translated">New in version 3.9: The &lt;em&gt;base_url&lt;/em&gt; and &lt;em&gt;max_depth&lt;/em&gt; parameters.</target>
        </trans-unit>
        <trans-unit id="c1c6534808a333ea947d2e95376ff2e9bd752a08" translate="yes" xml:space="preserve">
          <source>New in version 3.9: backported to 3.7 and 3.8.</source>
          <target state="translated">New in version 3.9: backported to 3.7 and 3.8.</target>
        </trans-unit>
        <trans-unit id="1101fa4c967ee98df4f4734b3541a4560182d08f" translate="yes" xml:space="preserve">
          <source>New: It is now possible to put items in argtypes which are not ctypes types, but each item must have a &lt;code&gt;from_param()&lt;/code&gt; method which returns a value usable as argument (integer, string, ctypes instance). This allows defining adapters that can adapt custom objects as function parameters.</source>
          <target state="translated">이제 ctypes 유형이 아닌 argtypes에 항목을 넣을 수 있지만 각 항목에는 인수로 사용할 수있는 값 (정수, 문자열, ctypes 인스턴스)을 반환하는 &lt;code&gt;from_param()&lt;/code&gt; 메서드 가 있어야합니다 . 이를 통해 사용자 정의 오브젝트를 기능 매개 변수로 조정할 수있는 어댑터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="540f7186c4d530bac579f69bb157fd5e121529cc" translate="yes" xml:space="preserve">
          <source>NewType</source>
          <target state="translated">NewType</target>
        </trans-unit>
        <trans-unit id="1f243883e19f81b334c75128a8750ed8afdcc9d0" translate="yes" xml:space="preserve">
          <source>Newer RFC that provides a revised definition of XDR.</source>
          <target state="translated">XDR의 수정 된 정의를 제공하는 최신 RFC</target>
        </trans-unit>
        <trans-unit id="bc981983e7f547dc62e19a1e383acfe00782a6d5" translate="yes" xml:space="preserve">
          <source>Next</source>
          <target state="translated">Next</target>
        </trans-unit>
        <trans-unit id="3fd8fdbb697f927d539f398a34de5c84c0407d98" translate="yes" xml:space="preserve">
          <source>Next History</source>
          <target state="translated">다음 역사</target>
        </trans-unit>
        <trans-unit id="7012977a58ea8b287c205fbbab7e5434b3642c46" translate="yes" xml:space="preserve">
          <source>Next Line (C1 Control Code)</source>
          <target state="translated">다음 줄 (C1 제어 코드)</target>
        </trans-unit>
        <trans-unit id="4bfc194b68a3369d53aadcddc4f891771d91a3d9" translate="yes" xml:space="preserve">
          <source>Next page</source>
          <target state="translated">다음 페이지</target>
        </trans-unit>
        <trans-unit id="233213a348a3467a9713a7d089885546d38eba8b" translate="yes" xml:space="preserve">
          <source>Next we instantiate a Differ object:</source>
          <target state="translated">다음으로 Differ 객체를 인스턴스화합니다 :</target>
        </trans-unit>
        <trans-unit id="b9fac927a58027f98332aa47670afe3b77e6d6a4" translate="yes" xml:space="preserve">
          <source>Next, we encounter a new person whose feature measurements are known but whose gender is unknown:</source>
          <target state="translated">다음으로, 특징 측정은 알려졌지만 성별을 알 수없는 새로운 사람이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd608f08ab177c1073a159dda57f4a0251fcd9d9" translate="yes" xml:space="preserve">
          <source>No CSI structure available</source>
          <target state="translated">사용 가능한 CSI 구조가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bf8647669a8695bdc05a11d401d6432a9f88b641" translate="yes" xml:space="preserve">
          <source>No XENIX semaphores available</source>
          <target state="translated">사용 가능한 XENIX 세마포가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7c45a435d178e3e2e2c3ba71f0b27f7074852c14" translate="yes" xml:space="preserve">
          <source>No anode</source>
          <target state="translated">양극 없음</target>
        </trans-unit>
        <trans-unit id="b599ea3e9f4d15ca66ad3df24a2527224a8ea2d5" translate="yes" xml:space="preserve">
          <source>No argument is converted, results in a &lt;code&gt;'%'&lt;/code&gt; character in the result.</source>
          <target state="translated">인수가 변환되지 않으며 결과에 &lt;code&gt;'%'&lt;/code&gt; 문자가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="e792e65ee8a80fd8989ad1b66325f180ccd8b365" translate="yes" xml:space="preserve">
          <source>No buffer space available</source>
          <target state="translated">사용 가능한 버퍼 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="099e11888438840a8566c983d5b1e6de2dad8524" translate="yes" xml:space="preserve">
          <source>No child processes</source>
          <target state="translated">자식 프로세스가 없습니다</target>
        </trans-unit>
        <trans-unit id="0cfc430ad5192c2568f967923954cde952307fa4" translate="yes" xml:space="preserve">
          <source>No data available</source>
          <target state="translated">자료 없음</target>
        </trans-unit>
        <trans-unit id="5921088185a40f1dda6c07e51735aa215a517c81" translate="yes" xml:space="preserve">
          <source>No defined value type.</source>
          <target state="translated">정의 된 값 유형이 없습니다.</target>
        </trans-unit>
        <trans-unit id="5cb62108d46698f5697c85ab801ad27a8ef1fbf6" translate="yes" xml:space="preserve">
          <source>No distinction between standard and widget-specific options is made in this document. Some options don&amp;rsquo;t apply to some kinds of widgets. Whether a given widget responds to a particular option depends on the class of the widget; buttons have a &lt;code&gt;command&lt;/code&gt; option, labels do not.</source>
          <target state="translated">이 문서에서는 표준 옵션과 위젯 특정 옵션을 구분하지 않습니다. 일부 옵션은 일부 종류의 위젯에는 적용되지 않습니다. 주어진 위젯이 특정 옵션에 응답하는지 여부는 위젯 클래스에 따라 다릅니다. 버튼에는 &lt;code&gt;command&lt;/code&gt; 옵션이 있지만 레이블에는 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a8258b97ca1863297badad1b0273640969901f7" translate="yes" xml:space="preserve">
          <source>No feature description will ever be deleted from &lt;a href=&quot;#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt;. Since its introduction in Python 2.1 the following features have found their way into the language using this mechanism:</source>
          <target state="translated">&lt;a href=&quot;#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 에서 기능 설명이 삭제되지 않습니다 . Python 2.1에서 소개 된 이후로 다음 기능은이 메커니즘을 사용하여 언어에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="f45ab0b8375bdf5386e021a0b31d679497a33d5c" translate="yes" xml:space="preserve">
          <source>No message of desired type</source>
          <target state="translated">원하는 유형의 메시지가 없습니다</target>
        </trans-unit>
        <trans-unit id="19ae1fe9004b24354abb4ed1dcb0717c604a6346" translate="yes" xml:space="preserve">
          <source>No modifier is given, so it can appear exactly once, as for &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">수정자가 주어지지 않으므로 &lt;code&gt;A&lt;/code&gt; 와 같이 정확히 한 번만 나타날 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7498d9819e38f5924fea12d89303afac91d07387" translate="yes" xml:space="preserve">
          <source>No padding is added when using non-native size and alignment, e.g. with &amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;=&amp;rsquo;, and &amp;lsquo;!&amp;rsquo;.</source>
          <target state="translated">기본이 아닌 크기와 정렬을 사용할 때는 패딩이 추가되지 않습니다 (예 : '&amp;lt;', '&amp;gt;', '='및 '!').</target>
        </trans-unit>
        <trans-unit id="3ab4c24c0255ad55292cf986980b47b2ee3d453f" translate="yes" xml:space="preserve">
          <source>No problem, provided that the traceback is the only output produced by the example: just paste in the traceback. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; Since tracebacks contain details that are likely to change rapidly (for example, exact file paths and line numbers), this is one case where doctest works hard to be flexible in what it accepts.</source>
          <target state="translated">트레이스 백이 예제에서 생성 된 유일한 출력 인 경우 문제가되지 않습니다. 트레이스 백에 붙여 넣기 만하면됩니다. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 트레이스 백에는 빠르게 변경 될 수있는 세부 정보 (예 : 정확한 파일 경로 및 줄 번호)가 포함되어 있기 때문에 doctest가 수용 할 수있는 유연성을 갖추기 어려운 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab134dfa754cd3657dd291f57f80c528eeaa381a" translate="yes" xml:space="preserve">
          <source>No record locks available</source>
          <target state="translated">사용 가능한 레코드 잠금이 없습니다.</target>
        </trans-unit>
        <trans-unit id="62c6526007299ca03f778b5b7ce0d726354cae0d" translate="yes" xml:space="preserve">
          <source>No route to host</source>
          <target state="translated">호스트 경로가 없습니다</target>
        </trans-unit>
        <trans-unit id="5c0580667d6055e92a026b8c67fa943060b2c89d" translate="yes" xml:space="preserve">
          <source>No space left on device</source>
          <target state="translated">기기에 남은 공간이 없습니다.</target>
        </trans-unit>
        <trans-unit id="8affcec2bb7338bba6a528b37e279cb979510364" translate="yes" xml:space="preserve">
          <source>No special efforts are made to achieve exact results. (However, this may change in the future.)</source>
          <target state="translated">정확한 결과를 얻기 위해 특별한 노력을 기울이지 않습니다. (단, 향후 변경 될 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="e5feee0204f5532e0cb04d5be298f4c467c05e6f" translate="yes" xml:space="preserve">
          <source>No such device</source>
          <target state="translated">그런 장치가 없습니다</target>
        </trans-unit>
        <trans-unit id="112765ee706d5c7ea20d7309d6bf892b8a5aa7eb" translate="yes" xml:space="preserve">
          <source>No such device or address</source>
          <target state="translated">그러한 장치 나 주소가 없습니다</target>
        </trans-unit>
        <trans-unit id="8a6cb568f806ffae868a77b519003a5df95ec0c3" translate="yes" xml:space="preserve">
          <source>No such file or directory</source>
          <target state="translated">그러한 파일이나 디렉토리가 없습니다</target>
        </trans-unit>
        <trans-unit id="0cf4a772e5ca24befae7ddee66e425eeaa8130aa" translate="yes" xml:space="preserve">
          <source>No such process</source>
          <target state="translated">그런 과정이 없습니다</target>
        </trans-unit>
        <trans-unit id="589aa359449804b5cecdf6ad3c2674828c4925a4" translate="yes" xml:space="preserve">
          <source>No suitable authentication method was found.</source>
          <target state="translated">적합한 인증 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0e86c9e3430455ac090ffb5eaf4ae106dd193246" translate="yes" xml:space="preserve">
          <source>No-op in the base class, this method takes file object &lt;em&gt;fp&lt;/em&gt;, and reads the data from the file, initializing its message catalog. If you have an unsupported message catalog file format, you should override this method to parse your format.</source>
          <target state="translated">기본 클래스에서 작동하지 않는이 메소드는 파일 객체 &lt;em&gt;fp를&lt;/em&gt; 가져 와서 파일 에서 데이터를 읽고 메시지 카탈로그를 초기화합니다. 지원되지 않는 메시지 카탈로그 파일 형식이있는 경우이 방법을 재정 의하여 형식을 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="b17a6c458741a86bf04ade61ad9a14f7ac61215b" translate="yes" xml:space="preserve">
          <source>Node Objects</source>
          <target state="translated">노드 객체</target>
        </trans-unit>
        <trans-unit id="7e378cbf407e94014d60a68e1eb16b7d4cc0b6a2" translate="yes" xml:space="preserve">
          <source>Node classes</source>
          <target state="translated">노드 클래스</target>
        </trans-unit>
        <trans-unit id="ee401dbf3ea65531fb1e6ce98168be3027792e5e" translate="yes" xml:space="preserve">
          <source>Node representing a single formatting field in an f-string. If the string contains a single formatting field and nothing else the node can be isolated otherwise it appears in &lt;a href=&quot;#ast.JoinedStr&quot;&gt;&lt;code&gt;JoinedStr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">f- 문자열의 단일 형식 필드를 나타내는 노드입니다. 문자열에 단일 서식 필드가 포함되어 있고 다른 항목이 없으면 노드를 분리 할 수 &lt;a href=&quot;#ast.JoinedStr&quot;&gt; &lt;code&gt;JoinedStr&lt;/code&gt; &lt;/a&gt; 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="14144ba530975f0eb39fc2d9e3b0c8023d821c70" translate="yes" xml:space="preserve">
          <source>NodeList Objects</source>
          <target state="translated">NodeList 객체</target>
        </trans-unit>
        <trans-unit id="750728f3a8917784306697d947d7258635f9568e" translate="yes" xml:space="preserve">
          <source>Nodes containing textual content from the document.</source>
          <target state="translated">문서의 텍스트 내용을 포함하는 노드</target>
        </trans-unit>
        <trans-unit id="bdc7ab16126589f949098e57c1b5539a8ac176ed" translate="yes" xml:space="preserve">
          <source>Nomenclature</source>
          <target state="translated">Nomenclature</target>
        </trans-unit>
        <trans-unit id="56c04398e9678198426e682b1f9d96427b74b23b" translate="yes" xml:space="preserve">
          <source>Nominal vs structural subtyping</source>
          <target state="translated">공칭 vs 구조적 서브 타이핑</target>
        </trans-unit>
        <trans-unit id="35d3f82350431652e47bdcf8c933cca085703f88" translate="yes" xml:space="preserve">
          <source>Non-blocking mode is supported through &lt;a href=&quot;#socket.socket.setblocking&quot;&gt;&lt;code&gt;setblocking()&lt;/code&gt;&lt;/a&gt;. A generalization of this based on timeouts is supported through &lt;a href=&quot;#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">비 차단 모드는 &lt;a href=&quot;#socket.socket.setblocking&quot;&gt; &lt;code&gt;setblocking()&lt;/code&gt; &lt;/a&gt; 통해 지원됩니다 . 제한 시간을 기반으로하는 일반화는 &lt;a href=&quot;#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt; 통해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c6473f2b77717e9eaefce19afcd71fb87fcc938" translate="yes" xml:space="preserve">
          <source>Non-empty sets (not frozensets) can be created by placing a comma-separated list of elements within braces, for example: &lt;code&gt;{'jack', 'sjoerd'}&lt;/code&gt;, in addition to the &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">비어 있지 않은 세트 ( &lt;code&gt;{'jack', 'sjoerd'}&lt;/code&gt; &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 아님) 는 세트 생성자 외에 쉼표로 구분 된 요소 목록을 중괄호 내에 배치하여 만들 수 있습니다 (예 : { 'jack', 'sjoerd'} ) .</target>
        </trans-unit>
        <trans-unit id="4aa0a99e9276d0e78ac1248387e6c6b9c79d9b2a" translate="yes" xml:space="preserve">
          <source>Non-identical instances of a class normally compare as non-equal unless the class defines the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">클래스의 동일하지 않은 인스턴스는 클래스가 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 메서드를 정의하지 않는 한 일반적으로 동일하지 않은 것으로 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="f95d02252b0089d1c261319bc20168f160fde1cf" translate="yes" xml:space="preserve">
          <source>Non-identical instances of a class normally compare as non-equal unless the class defines the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt;&lt;code&gt;__eq__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">클래스의 동일하지 않은 인스턴스는 클래스가 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__eq__&quot;&gt; &lt;code&gt;__eq__()&lt;/code&gt; &lt;/a&gt; 메서드를 정의하지 않는 한 일반적으로 같지 않은 것으로 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="5432efc874ee04f0f27783979ffafd974c2144c4" translate="yes" xml:space="preserve">
          <source>Non-quoted escape characters (e.g. &lt;code&gt;'\'&lt;/code&gt;) preserve the literal value of the next character that follows;</source>
          <target state="translated">인용 부호가없는 이스케이프 문자 (예 : &lt;code&gt;'\'&lt;/code&gt; )는 다음에 오는 다음 문자의 리터럴 값을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="7e5255a130b91c89dba736489c8c648b0ae932c0" translate="yes" xml:space="preserve">
          <source>Nonzero if a DST timezone is defined. See note below.</source>
          <target state="translated">DST 시간대가 정의 된 경우 0이 아닙니다. 아래 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5d6248d1d5c865a0048cbc0bf21dcb388cd91a77" translate="yes" xml:space="preserve">
          <source>Nordic languages</source>
          <target state="translated">북유럽 언어</target>
        </trans-unit>
        <trans-unit id="02e21f33972d3ea6d360c18684f08ac13010544f" translate="yes" xml:space="preserve">
          <source>Normal and error output are generally kept separate (on separate lines) from code input and each other. They each get different highlight colors.</source>
          <target state="translated">정상 및 오류 출력은 일반적으로 코드 입력과 서로 분리되어 (별도의 줄에) 유지됩니다. 그들은 각각 다른 하이라이트 색상을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="170f10d24b0b85cf90e96608630df2d96c9b4817" translate="yes" xml:space="preserve">
          <source>Normal attribute</source>
          <target state="translated">일반 속성</target>
        </trans-unit>
        <trans-unit id="f1f743126e0f5dd0902750180da22c23c53778c8" translate="yes" xml:space="preserve">
          <source>Normal distribution. &lt;em&gt;mu&lt;/em&gt; is the mean, and &lt;em&gt;sigma&lt;/em&gt; is the standard deviation.</source>
          <target state="translated">정규 분포. &lt;em&gt;mu&lt;/em&gt; 는 평균이고 &lt;em&gt;sigma&lt;/em&gt; 는 표준 편차입니다.</target>
        </trans-unit>
        <trans-unit id="3d1612e1a01af8e8718757fe0eb13a0da18713da" translate="yes" xml:space="preserve">
          <source>Normal distributions arise from the &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot;&gt;Central Limit Theorem&lt;/a&gt; and have a wide range of applications in statistics.</source>
          <target state="translated">정규 분포는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Central_limit_theorem&quot;&gt;중앙 제한 정리&lt;/a&gt; 에서 발생 하며 통계에 광범위한 응용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f96b6e7e93b1ee612bdc5459b1b4c4ed51951b3b" translate="yes" xml:space="preserve">
          <source>Normal distributions can be used to approximate &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;Binomial distributions&lt;/a&gt; when the sample size is large and when the probability of a successful trial is near 50%.</source>
          <target state="translated">정규 분포는 표본 크기가 크고 성공적인 시행 확률이 거의 50 % 일 때 &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;이항 분포&lt;/a&gt; 를 근사하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe823566d89d09d65bf2172f99f78ec17aa83bd8" translate="yes" xml:space="preserve">
          <source>Normal distributions commonly arise in machine learning problems.</source>
          <target state="translated">정규 분포는 일반적으로 기계 학습 문제에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6b2153c60470208f45dcfdc29d655f5a4049324a" translate="yes" xml:space="preserve">
          <source>NormalDist objects</source>
          <target state="translated">NormalDist 객체</target>
        </trans-unit>
        <trans-unit id="691b62ff89f4b08738f81953df74ff8ae6e26204" translate="yes" xml:space="preserve">
          <source>Normalize a pathname by collapsing redundant separators and up-level references so that &lt;code&gt;A//B&lt;/code&gt;, &lt;code&gt;A/B/&lt;/code&gt;, &lt;code&gt;A/./B&lt;/code&gt; and &lt;code&gt;A/foo/../B&lt;/code&gt; all become &lt;code&gt;A/B&lt;/code&gt;. This string manipulation may change the meaning of a path that contains symbolic links. On Windows, it converts forward slashes to backward slashes. To normalize case, use &lt;a href=&quot;#os.path.normcase&quot;&gt;&lt;code&gt;normcase()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;A//B&lt;/code&gt; , &lt;code&gt;A/B/&lt;/code&gt; , &lt;code&gt;A/./B&lt;/code&gt; 및 &lt;code&gt;A/foo/../B&lt;/code&gt; 모두 &lt;code&gt;A/B&lt;/code&gt; 가 되도록 중복 분리 자와 상위 레벨 참조를 축소하여 경로 이름을 정규화하십시오 . 이 문자열 조작은 기호 링크가 포함 된 경로의 의미를 변경할 수 있습니다. Windows에서는 슬래시를 슬래시로 변환합니다. 대소 문자를 정규화하려면 &lt;a href=&quot;#os.path.normcase&quot;&gt; &lt;code&gt;normcase()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4de47e1cb4db52e6f0ace31520ebf2d73cf5200f" translate="yes" xml:space="preserve">
          <source>Normalize the case of a pathname. On Windows, convert all characters in the pathname to lowercase, and also convert forward slashes to backward slashes. On other operating systems, return the path unchanged.</source>
          <target state="translated">경로명의 대소 문자를 정규화하십시오. Windows에서는 경로 이름의 모든 문자를 소문자로 변환하고 슬래시를 백 슬래시로 변환하십시오. 다른 운영 체제에서는 경로를 변경하지 않고 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="5bb740d481f263379151a90b9e11e2b6fdb345e7" translate="yes" xml:space="preserve">
          <source>Normalize the number by stripping the rightmost trailing zeros and converting any result equal to &lt;code&gt;Decimal('0')&lt;/code&gt; to &lt;code&gt;Decimal('0e0')&lt;/code&gt;. Used for producing canonical values for attributes of an equivalence class. For example, &lt;code&gt;Decimal('32.100')&lt;/code&gt; and &lt;code&gt;Decimal('0.321000e+2')&lt;/code&gt; both normalize to the equivalent value &lt;code&gt;Decimal('32.1')&lt;/code&gt;.</source>
          <target state="translated">가장 오른쪽 후행 0을 제거하고 &lt;code&gt;Decimal('0')&lt;/code&gt; 과 동일한 결과 를 &lt;code&gt;Decimal('0e0')&lt;/code&gt; 로 변환하여 숫자를 정규화하십시오 . 동등 클래스의 속성에 대한 표준 값을 생성하는 데 사용됩니다. 예를 들어 &lt;code&gt;Decimal('32.100')&lt;/code&gt; 및 &lt;code&gt;Decimal('0.321000e+2')&lt;/code&gt; 모두 동등한 값 &lt;code&gt;Decimal('32.1')&lt;/code&gt; 정규화됩니다 .</target>
        </trans-unit>
        <trans-unit id="2f52a413a99343944d32b2af1d020b8d0b1acd04" translate="yes" xml:space="preserve">
          <source>Normally &lt;strong&gt;there is no need&lt;/strong&gt; to create Future objects at the application level code.</source>
          <target state="translated">일반적으로 응용 프로그램 수준 코드에서 Future 객체를 만들 &lt;strong&gt;필요는 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d90ea54070ee394f637e437d868344967800111e" translate="yes" xml:space="preserve">
          <source>Normally derived classes don&amp;rsquo;t override the following methods, but they may if they want to redefine the definition of stopping and breakpoints.</source>
          <target state="translated">일반적으로 파생 된 클래스는 다음 메서드를 재정의하지 않지만 중지 및 중단 점 정의를 재정의하려는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7e3e4198625d7397897fc42c4d0f77e2c31eff8" translate="yes" xml:space="preserve">
          <source>Normally it should not be necessary to use this value directly. Specifying the &lt;code&gt;E&lt;/code&gt; modifier in their format strings causes the &lt;a href=&quot;time#time.strftime&quot;&gt;&lt;code&gt;time.strftime()&lt;/code&gt;&lt;/a&gt; function to use this information. The format of the returned string is not specified, and therefore you should not assume knowledge of it on different systems.</source>
          <target state="translated">일반적으로이 값을 직접 사용할 필요는 없습니다. 형식 문자열에 &lt;code&gt;E&lt;/code&gt; 수정자를 지정하면 &lt;a href=&quot;time#time.strftime&quot;&gt; &lt;code&gt;time.strftime()&lt;/code&gt; &lt;/a&gt; 함수가이 정보를 사용합니다. 리턴 된 문자열의 형식이 지정되지 않았으므로 다른 시스템에서이를 알고 있다고 가정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="2dd8b4f218db00ed4e30efd72f3a335858fe6269" translate="yes" xml:space="preserve">
          <source>Normally the &lt;a href=&quot;#unittest.mock.Mock.__class__&quot;&gt;&lt;code&gt;__class__&lt;/code&gt;&lt;/a&gt; attribute of an object will return its type. For a mock object with a &lt;code&gt;spec&lt;/code&gt;, &lt;code&gt;__class__&lt;/code&gt; returns the spec class instead. This allows mock objects to pass &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; tests for the object they are replacing / masquerading as:</source>
          <target state="translated">일반적으로 객체 의 &lt;a href=&quot;#unittest.mock.Mock.__class__&quot;&gt; &lt;code&gt;__class__&lt;/code&gt; &lt;/a&gt; 속성은 해당 유형을 반환합니다. &lt;code&gt;spec&lt;/code&gt; 을 가진 모의 객체의 경우 &lt;code&gt;__class__&lt;/code&gt; 는 대신 spec 클래스를 반환합니다. 이를 통해 mock 객체 는 다음과 같이 교체 / 가장 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 되는 객체에 대해 isinstance () 테스트 를 통과 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aa93ae111a762d37226903d82a74d9b1f47e777" translate="yes" xml:space="preserve">
          <source>Normally you should use the socket API methods like &lt;a href=&quot;socket#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;socket#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; instead of these methods.</source>
          <target state="translated">일반적으로 이러한 메소드 대신 &lt;a href=&quot;socket#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;socket#socket.socket.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 와 같은 소켓 API 메소드를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8d529dbb8b442b62924e944a3daf4b0e0711efec" translate="yes" xml:space="preserve">
          <source>Normally, however, you do not need to use these additional methods, as &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.set_app&quot;&gt;&lt;code&gt;set_app()&lt;/code&gt;&lt;/a&gt; is normally called by &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt;&lt;code&gt;make_server()&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.get_app&quot;&gt;&lt;code&gt;get_app()&lt;/code&gt;&lt;/a&gt; exists mainly for the benefit of request handler instances.</source>
          <target state="translated">일반적으로, 그러나, 당신은 다음과 같은 추가 방법을 사용할 필요가 없습니다 &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.set_app&quot;&gt; &lt;code&gt;set_app()&lt;/code&gt; &lt;/a&gt; 일반적으로 호출 &lt;a href=&quot;#wsgiref.simple_server.make_server&quot;&gt; &lt;code&gt;make_server()&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#wsgiref.simple_server.WSGIServer.get_app&quot;&gt; &lt;code&gt;get_app()&lt;/code&gt; &lt;/a&gt; 요청 처리기 인스턴스의 이익을 위해 주로 존재한다.</target>
        </trans-unit>
        <trans-unit id="cebe4c16e9be06cdb74c935e7bf03afce6ac0db3" translate="yes" xml:space="preserve">
          <source>Normally, the above warnings are filtered by the default &lt;a href=&quot;warnings#describing-warning-filters&quot;&gt;warning filters&lt;/a&gt;.</source>
          <target state="translated">일반적으로 위의 경고는 기본 &lt;a href=&quot;warnings#describing-warning-filters&quot;&gt;경고 필터에&lt;/a&gt; 의해 필터링됩니다 .</target>
        </trans-unit>
        <trans-unit id="0788443a411022d37bd9d9d545b151030497a024" translate="yes" xml:space="preserve">
          <source>Normally, the generator emits a single string; however, for &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; exceptions, it emits several lines that (when printed) display detailed information about where the syntax error occurred.</source>
          <target state="translated">일반적으로 생성기는 단일 문자열을 방출합니다. 그러나 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 예외의 경우 구문 오류가 발생한 위치에 대한 자세한 정보를 인쇄 할 때 여러 줄을 출력합니다 (인쇄시).</target>
        </trans-unit>
        <trans-unit id="23ff9f150633c592aa535d8b9f1a3400f42cda0e" translate="yes" xml:space="preserve">
          <source>Normally, this method first strips any quotes off the argument. If the result is an absolute pathname, or there was no previous source request in effect, or the previous source was a stream (such as &lt;code&gt;sys.stdin&lt;/code&gt;), the result is left alone. Otherwise, if the result is a relative pathname, the directory part of the name of the file immediately before it on the source inclusion stack is prepended (this behavior is like the way the C preprocessor handles &lt;code&gt;#include
&quot;file.h&quot;&lt;/code&gt;).</source>
          <target state="translated">일반적으로이 메소드는 먼저 인수에서 따옴표를 제거합니다. 결과가 절대 경로 이름이거나 유효한 이전 소스 요청이 없거나 이전 소스가 스트림 (예 : &lt;code&gt;sys.stdin&lt;/code&gt; ) 인 경우 결과는 단독으로 유지됩니다. 그렇지 않으면 결과가 상대 경로 이름 인 경우 소스 포함 스택에서 파일 바로 앞에있는 파일 이름의 디렉토리 부분이 앞에 붙습니다 (이 동작은 C 전처리 기가 &lt;code&gt;#include &quot;file.h&quot;&lt;/code&gt; 처리하는 방식과 같습니다 ).</target>
        </trans-unit>
        <trans-unit id="0fde105c2e0c2c34defc4b3e3f0d9044ebf54e00" translate="yes" xml:space="preserve">
          <source>Normally, when you pass an argument list to the &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;, it &lt;a href=&quot;#prefix-matching&quot;&gt;recognizes abbreviations&lt;/a&gt; of long options.</source>
          <target state="translated">당신이에 인수 목록을 통과 할 때 일반적으로, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 의 방법 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; , 그것은 &lt;a href=&quot;#prefix-matching&quot;&gt;약어 인식&lt;/a&gt; 긴 옵션을.</target>
        </trans-unit>
        <trans-unit id="c8cb9467d1b3a535d48d7b80b7ce51003fd94c2c" translate="yes" xml:space="preserve">
          <source>Normally, when you pass an invalid argument list to the &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;, it will exit with error info.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 메서드에 잘못된 인수 목록을 전달하면 오류 정보와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9db1844f9d4e3e923c05588f67a7669bd03d89f7" translate="yes" xml:space="preserve">
          <source>Normally, you would use the &lt;code&gt;os.path.is*()&lt;/code&gt; functions for testing the type of a file; the functions here are useful when you are doing multiple tests of the same file and wish to avoid the overhead of the &lt;code&gt;stat()&lt;/code&gt; system call for each test. These are also useful when checking for information about a file that isn&amp;rsquo;t handled by &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;, like the tests for block and character devices.</source>
          <target state="translated">일반적으로 파일 유형을 테스트하기 위해 &lt;code&gt;os.path.is*()&lt;/code&gt; 함수를 사용합니다. 여기에있는 함수는 동일한 파일에 대해 여러 테스트를 수행 할 때 유용 하며 각 테스트에 대한 &lt;code&gt;stat()&lt;/code&gt; 시스템 호출 의 오버 헤드를 피하려고합니다 . 블록 및 문자 장치 테스트와 같이 &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 가 처리하지 않는 파일에 대한 정보를 확인할 때도 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="bb0c92aed320c99f3cf5a7b36f620aee6bc3d350" translate="yes" xml:space="preserve">
          <source>Not a XENIX named type file</source>
          <target state="translated">XENIX 명명 된 유형 파일이 아님</target>
        </trans-unit>
        <trans-unit id="16362f559ca4bab86e57b8b31308ce0876579def" translate="yes" xml:space="preserve">
          <source>Not a data message</source>
          <target state="translated">데이터 메시지가 아님</target>
        </trans-unit>
        <trans-unit id="338469a733ebda5aa0e30bb1db80e0e157e51892" translate="yes" xml:space="preserve">
          <source>Not a directory</source>
          <target state="translated">디렉토리가 아님</target>
        </trans-unit>
        <trans-unit id="8c67b4de17834c13bd6e4d2b12aca324d453a11f" translate="yes" xml:space="preserve">
          <source>Not a typewriter</source>
          <target state="translated">타자기가 아님</target>
        </trans-unit>
        <trans-unit id="2c7846a67eb11ab196b9e6f6d7a69ff03be54a85" translate="yes" xml:space="preserve">
          <source>Not all Python object types are supported; in general, only objects whose value is independent from a particular invocation of Python can be written and read by this module. The following types are supported: booleans, integers, floating point numbers, complex numbers, strings, bytes, bytearrays, tuples, lists, sets, frozensets, dictionaries, and code objects, where it should be understood that tuples, lists, sets, frozensets and dictionaries are only supported as long as the values contained therein are themselves supported. The singletons &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;constants#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; can also be marshalled and unmarshalled. For format &lt;em&gt;version&lt;/em&gt; lower than 3, recursive lists, sets and dictionaries cannot be written (see below).</source>
          <target state="translated">모든 Python 객체 유형이 지원되는 것은 아닙니다. 일반적으로 특정 파이썬 호출과 독립적 인 값을 가진 객체 만이 모듈에서 쓰고 읽을 수 있습니다. 부울, 정수, 부동 소수점 숫자, 복소수, 문자열, 바이트, 바이트 배열, 튜플, 목록, 세트, ​​고정 집합, 사전 및 코드 객체 유형이 지원됩니다. 튜플, 목록, 집합, 고정 집합 사전은 여기에 포함 된 값 자체가 지원되는 경우에만 지원됩니다. Singletons &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constants#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 도 마샬링 및 마샬링 해제 할 수 있습니다. 형식 &lt;em&gt;버전&lt;/em&gt; 이 3보다 낮은 경우 재귀 목록, 집합 및 사전을 쓸 수 없습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="a3e1b1287060e9ba795d51d985b235049aa105ed" translate="yes" xml:space="preserve">
          <source>Not all elements of the XML input will end up as elements of the parsed tree. Currently, this module skips over any XML comments, processing instructions, and document type declarations in the input. Nevertheless, trees built using this module&amp;rsquo;s API rather than parsing from XML text can have comments and processing instructions in them; they will be included when generating XML output. A document type declaration may be accessed by passing a custom &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt;&lt;code&gt;TreeBuilder&lt;/code&gt;&lt;/a&gt; instance to the &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">XML 입력의 모든 요소가 구문 분석 된 트리의 요소로 끝나는 것은 아닙니다. 현재이 모듈은 입력에서 XML 주석, 처리 명령 및 문서 유형 선언을 건너 뜁니다. 그럼에도 불구하고 XML 텍스트를 파싱하는 대신이 모듈의 API를 사용하여 작성된 트리에는 주석과 처리 지침이있을 수 있습니다. XML 출력을 생성 할 때 포함됩니다. 사용자 정의 &lt;a href=&quot;#xml.etree.ElementTree.TreeBuilder&quot;&gt; &lt;code&gt;TreeBuilder&lt;/code&gt; &lt;/a&gt; 인스턴스를 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 생성자 에 전달하여 문서 유형 선언에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7451951009f7df728b6f3d4aa4cb2d7ba85029ba" translate="yes" xml:space="preserve">
          <source>Not all flags are valid for all versions of &lt;code&gt;gdbm&lt;/code&gt;. The module constant &lt;code&gt;open_flags&lt;/code&gt; is a string of supported flag characters. The exception &lt;a href=&quot;#dbm.gnu.error&quot;&gt;&lt;code&gt;error&lt;/code&gt;&lt;/a&gt; is raised if an invalid flag is specified.</source>
          <target state="translated">모든 플래그가 모든 버전의 &lt;code&gt;gdbm&lt;/code&gt; 에 유효한 것은 아닙니다 . 모듈 상수 &lt;code&gt;open_flags&lt;/code&gt; 는 지원되는 플래그 문자의 문자열입니다. 유효하지 않은 플래그가 지정되면 예외 &lt;a href=&quot;#dbm.gnu.error&quot;&gt; &lt;code&gt;error&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5642009188b00b4b1401ca4b9758d17920df1198" translate="yes" xml:space="preserve">
          <source>Not all objects can be weakly referenced; those objects which can include class instances, functions written in Python (but not in C), instance methods, sets, frozensets, some &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt;, type objects, sockets, arrays, deques, regular expression pattern objects, and code objects.</source>
          <target state="translated">모든 객체를 약하게 참조 할 수있는 것은 아닙니다. 클래스 인스턴스, Python으로 작성된 함수 (C는 아님), 인스턴스 메소드, 세트, ​​고정 세트, 일부 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; , 유형 객체, 소켓, 배열, deques, 정규 표현식 패턴 객체 및 코드 객체를 포함 할 수있는 객체.</target>
        </trans-unit>
        <trans-unit id="fe190fcc0f6bb0c755a4b3a9ec568d6b7568e446" translate="yes" xml:space="preserve">
          <source>Not all objects can be weakly referenced; those objects which can include class instances, functions written in Python (but not in C), instance methods, sets, frozensets, some &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt;, type objects, sockets, arrays, deques, regular expression pattern objects, and code objects.</source>
          <target state="translated">모든 개체를 약하게 참조 할 수있는 것은 아닙니다. 클래스 인스턴스, Python으로 작성된 함수 (C로 작성되지 않음), 인스턴스 메서드, 세트, ​​frozensets, 일부 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-generator&quot;&gt;생성기&lt;/a&gt; , 유형 객체, 소켓, 배열, 데크, 정규식 패턴 객체 및 코드 객체를 포함 할 수있는 객체.</target>
        </trans-unit>
        <trans-unit id="07c849ef61574f048a53a41ad5a4327d9310750e" translate="yes" xml:space="preserve">
          <source>Not all platforms provide the ability to examine and modify symbolic links. Python itself can tell you what functionality is locally available.</source>
          <target state="translated">모든 플랫폼이 심볼릭 링크를 검사하고 수정할 수있는 기능을 제공하지는 않습니다. 파이썬 자체는 어떤 기능이 로컬에서 사용 가능한지 알려줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a45153922480b755eeb20a8cd5a5df84141dc176" translate="yes" xml:space="preserve">
          <source>Not available on Windows.</source>
          <target state="translated">Windows에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6f9880fe552d25583bff0e051c2af11b02253f33" translate="yes" xml:space="preserve">
          <source>Not closing a resource explicitly can leave a resource open for way longer than expected; it can cause severe issues upon exiting Python. It is bad in CPython, but it is even worse in PyPy. Closing resources explicitly makes an application more deterministic and more reliable.</source>
          <target state="translated">리소스를 명시 적으로 닫지 않으면 예상보다 오랫동안 리소스를 열어 둘 수 있습니다. Python을 종료 할 때 심각한 문제가 발생할 수 있습니다. CPython에서는 나쁘지만 PyPy에서는 더 나쁩니다. 리소스를 명시 적으로 닫으면 응용 프로그램이 더 결정적이고 더 안정적입니다.</target>
        </trans-unit>
        <trans-unit id="4c2c4692797b1c72c2490c0e81cb931fc786ce55" translate="yes" xml:space="preserve">
          <source>Not currently used.</source>
          <target state="translated">현재 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac08186824133d19452b6a51a06060ff36e3034e" translate="yes" xml:space="preserve">
          <source>Not for complex numbers. Instead convert to floats using &lt;a href=&quot;functions#abs&quot;&gt;&lt;code&gt;abs()&lt;/code&gt;&lt;/a&gt; if appropriate.</source>
          <target state="translated">복소수가 아닙니다. 대신 적절한 경우 &lt;a href=&quot;functions#abs&quot;&gt; &lt;code&gt;abs()&lt;/code&gt; &lt;/a&gt; 사용하여 float로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8587c1a0a933c635a00ae69af27b2446cfdae1c" translate="yes" xml:space="preserve">
          <source>Not knowing the default extraction behaviors can cause unexpected decompression results. For example, when extracting the same archive twice, it overwrites files without asking.</source>
          <target state="translated">기본 추출 동작을 모르면 예기치 않은 압축 해제 결과가 발생할 수 있습니다. 예를 들어, 동일한 아카이브를 두 번 추출하면 묻지 않고 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="edfda3842ea6fbe6f744c728779b1389a38d845f" translate="yes" xml:space="preserve">
          <source>Not read, but previously detected by MUA</source>
          <target state="translated">읽지 않았지만 이전에 MUA에서 감지</target>
        </trans-unit>
        <trans-unit id="68572512d58f5572f216f0e3f449070bb1b9602b" translate="yes" xml:space="preserve">
          <source>NotADirectoryError</source>
          <target state="translated">NotADirectoryError</target>
        </trans-unit>
        <trans-unit id="5ceae088184ecb2a3d44c94c6258a6f897118f5f" translate="yes" xml:space="preserve">
          <source>NotImplemented</source>
          <target state="translated">NotImplemented</target>
        </trans-unit>
        <trans-unit id="8850b3bd61499741c05bd500ea7929ed489941ca" translate="yes" xml:space="preserve">
          <source>NotImplementedError</source>
          <target state="translated">NotImplementedError</target>
        </trans-unit>
        <trans-unit id="028373739f7f8068eb474265d2fb30ef33c2b72c" translate="yes" xml:space="preserve">
          <source>Notable Module Contents</source>
          <target state="translated">주목할만한 모듈 내용</target>
        </trans-unit>
        <trans-unit id="b5ae56c0c64d23ceb8b79ad6407cefba354d2d9f" translate="yes" xml:space="preserve">
          <source>Notably, this &amp;ldquo;ignored by default&amp;rdquo; list includes &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt; (for every module except &lt;code&gt;__main__&lt;/code&gt;), which means developers should make sure to test their code with typically ignored warnings made visible in order to receive timely notifications of future breaking API changes (whether in the standard library or third party packages).</source>
          <target state="translated">특히,이 &quot;기본적으로 무시 됨&quot;목록에는 &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;__main__&lt;/code&gt; 을 제외한 모든 모듈에 대한)이 포함되어 있습니다 . 이는 개발자가 향후 주요 API 변경에 대한 알림을 받기 위해 일반적으로 무시되는 경고로 코드를 테스트해야한다는 것을 의미합니다. 표준 라이브러리 또는 타사 패키지).</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="eaaf5966f427f3dea82bee61a4387fc35eceff0f" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;Decimal.from_float(0.1)&lt;/code&gt; is not the same as &lt;code&gt;Decimal(&amp;lsquo;0.1&amp;rsquo;)&lt;/code&gt;. Since 0.1 is not exactly representable in binary floating point, the value is stored as the nearest representable value which is &lt;code&gt;0x1.999999999999ap-4&lt;/code&gt;. That equivalent value in decimal is &lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;Decimal.from_float(0.1)&lt;/code&gt; 은 &lt;code&gt;Decimal(&amp;lsquo;0.1&amp;rsquo;)&lt;/code&gt; 과 다릅니다 . 0.1은 이진 부동 소수점으로 정확하게 표현할 수 없으므로 값은 &lt;code&gt;0x1.999999999999ap-4&lt;/code&gt; 인 가장 가까운 표현 가능한 값으로 저장됩니다 . 해당 10 진수 값은 &lt;code&gt;0.1000000000000000055511151231257827021181583404541015625&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a228a03ba762c109dde9253a8ec3fc25b50a1c65" translate="yes" xml:space="preserve">
          <source>Note also that being reentrant is &lt;em&gt;not&lt;/em&gt; the same thing as being thread safe. &lt;a href=&quot;#contextlib.redirect_stdout&quot;&gt;&lt;code&gt;redirect_stdout()&lt;/code&gt;&lt;/a&gt;, for example, is definitely not thread safe, as it makes a global modification to the system state by binding &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; to a different stream.</source>
          <target state="translated">재진입은 스레드 안전과 동일 &lt;em&gt;하지 않습니다&lt;/em&gt; . 예를 들어 &lt;a href=&quot;#contextlib.redirect_stdout&quot;&gt; &lt;code&gt;redirect_stdout()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 을 다른 스트림 에 바인딩하여 시스템 상태를 전역 적으로 수정하므로 스레드로부터 안전하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f61fec861c768279fab36f6f5c37291126c064a6" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; returns the toplevel module here because this is the object that is bound to a name by the &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 가 여기에서 최상위 레벨 모듈을 리턴 하는 방법에 주목 하십시오. 이는 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문에 의해 이름에 바인드 된 오브젝트이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f06e840efa6e07a42d60a9d72a43d7cc2a569dc0" translate="yes" xml:space="preserve">
          <source>Note how &lt;a href=&quot;#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; returns the toplevel module here because this is the object that is bound to a name by the &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">&lt;a href=&quot;#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 가 여기서 최상위 모듈을 반환 하는 방법에 유의 하십시오. 이것이 &lt;a href=&quot;https://docs.python.org/3.9/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문에 의해 이름에 바인딩 된 객체이기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="39a7d5217c5c02cfeb8a4550c216b87b699db0c2" translate="yes" xml:space="preserve">
          <source>Note however that &lt;a href=&quot;#timeit.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; will automatically determine the number of repetitions only when the command-line interface is used. In the &lt;a href=&quot;#timeit-examples&quot;&gt;Examples&lt;/a&gt; section you can find more advanced examples.</source>
          <target state="translated">그러나 &lt;a href=&quot;#timeit.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 는 명령 행 인터페이스가 사용될 때만 반복 횟수를 자동으로 결정합니다. 에서 &lt;a href=&quot;#timeit-examples&quot;&gt;예&lt;/a&gt; 섹션을 좀 더 고급 예제를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54f228df230f0474c98b205804fa448f5fe875b" translate="yes" xml:space="preserve">
          <source>Note however that in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; only matches at the beginning of the string, whereas using &lt;a href=&quot;#re.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; with a regular expression beginning with &lt;code&gt;'^'&lt;/code&gt; will match at the beginning of each line.</source>
          <target state="translated">그러나 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드에서 &lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 는 문자열의 시작 부분에서만 일치하는 반면 &lt;code&gt;'^'&lt;/code&gt; 로 시작하는 정규 표현식으로 &lt;a href=&quot;#re.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 사용하면 각 행의 시작 부분에서 일치합니다.</target>
        </trans-unit>
        <trans-unit id="05beb81acbbd60ea7c3692e5bef7179c9b5915a3" translate="yes" xml:space="preserve">
          <source>Note in particular that an exception will be raised if &lt;em&gt;methodname&lt;/em&gt; has not been &lt;em&gt;exposed&lt;/em&gt;.</source>
          <target state="translated">특히 &lt;em&gt;methodname&lt;/em&gt; 이 &lt;em&gt;노출&lt;/em&gt; 되지 않은 경우 예외가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bcb9bc5733348cf84603de82545dd9a70a1be5f4" translate="yes" xml:space="preserve">
          <source>Note in particular that options (such as &lt;em&gt;-input&lt;/em&gt;) and arguments (such as &lt;em&gt;eggs.txt&lt;/em&gt;) that are separated by whitespace in the shell go in separate list elements, while arguments that need quoting or backslash escaping when used in the shell (such as filenames containing spaces or the &lt;em&gt;echo&lt;/em&gt; command shown above) are single list elements.</source>
          <target state="translated">특히 셸에서 공백으로 구분 된 옵션 (예 : &lt;em&gt;-input&lt;/em&gt; )과 인수 (예 : &lt;em&gt;eggs.txt&lt;/em&gt; )는 별도의 목록 요소로 이동하고 셸에서 사용될 때 따옴표 나 백 슬래시 이스케이프가 필요한 인수 (예 : 공백이 포함 된 파일 이름 또는 위에 표시된 &lt;em&gt;echo&lt;/em&gt; 명령은 단일 목록 요소입니다.</target>
        </trans-unit>
        <trans-unit id="facb49e906f58a2995d4a0cf64fd63f312feb840" translate="yes" xml:space="preserve">
          <source>Note on SIGPIPE</source>
          <target state="translated">SIGPIPE에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="93d7b55b91dfb84b963b538a0f61240812a059a0" translate="yes" xml:space="preserve">
          <source>Note on VxWorks, this function doesn&amp;rsquo;t return &lt;code&gt;-signal&lt;/code&gt; when the new process is killed. Instead it raises OSError exception.</source>
          <target state="translated">VxWorks에서이 함수는 새 프로세스가 종료 될 때 &lt;code&gt;-signal&lt;/code&gt; 반환하지 않습니다 . 대신 OSError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e7e41fdb90e46b885d4fc21bb32cf0b77b1568d" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; objects only remove an action if all of its option strings are overridden. So, in the example above, the old &lt;code&gt;-f/--foo&lt;/code&gt; action is retained as the &lt;code&gt;-f&lt;/code&gt; action, because only the &lt;code&gt;--foo&lt;/code&gt; option string was overridden.</source>
          <target state="translated">참고 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 은&lt;/a&gt; 자신의 선택 문자열 모두가 무시하는 경우에만 작업을 제거 객체. 따라서 위의 예 에서 &lt;code&gt;--foo&lt;/code&gt; 옵션 문자열 만 재정의 되었으므로 이전 &lt;code&gt;-f/--foo&lt;/code&gt; 동작은 &lt;code&gt;-f&lt;/code&gt; 동작으로 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="bbabc92aff4ed81b97fa59772d1100b9a7b02ef9" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#asyncore.dispatcher.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; may raise &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; , even though &lt;a href=&quot;select#select.select&quot;&gt;&lt;code&gt;select.select()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;select#select.poll&quot;&gt;&lt;code&gt;select.poll()&lt;/code&gt;&lt;/a&gt; has reported the socket ready for reading.</source>
          <target state="translated">참고 &lt;a href=&quot;#asyncore.dispatcher.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 제기 할 수 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; 을&lt;/a&gt; 하더라도, &lt;a href=&quot;select#select.select&quot;&gt; &lt;code&gt;select.select()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;select#select.poll&quot;&gt; &lt;code&gt;select.poll()&lt;/code&gt; &lt;/a&gt; 독서에 대한 준비가 소켓을보고했습니다.</target>
        </trans-unit>
        <trans-unit id="21a214d994f16e1f90118d934dbbf9725f16b159" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; called for any operations besides &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;. This means that &lt;code&gt;get()&lt;/code&gt; will, like normal dictionaries, return &lt;code&gt;None&lt;/code&gt; as a default rather than using &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 외에 어떤 작업을 요구 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; . 즉 , 일반 사전과 마찬가지로 &lt;code&gt;get()&lt;/code&gt; 은 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; 를&lt;/a&gt; 사용하지 않고 &lt;code&gt;None&lt;/code&gt; 을 기본값으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="04676b632fb8896008db73e1dcf56396a8424248" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt;&lt;code&gt;__missing__()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;not&lt;/em&gt; called for any operations besides &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;. This means that &lt;code&gt;get()&lt;/code&gt; will, like normal dictionaries, return &lt;code&gt;None&lt;/code&gt; as a default rather than using &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt;&lt;code&gt;default_factory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#collections.defaultdict.__missing__&quot;&gt; &lt;code&gt;__missing__()&lt;/code&gt; &lt;/a&gt; 되어 &lt;em&gt;있지&lt;/em&gt; 외에 어떤 작업을 요구 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; . 즉, &lt;code&gt;get()&lt;/code&gt; 은 일반 사전과 마찬가지로 &lt;a href=&quot;#collections.defaultdict.default_factory&quot;&gt; &lt;code&gt;default_factory&lt;/code&gt; 를&lt;/a&gt; 사용하는 대신 &lt;code&gt;None&lt;/code&gt; 을 기본값으로 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="0481906125c173c6e85bed62a526281abaa1516a" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt;-generated deltas make no claim to be &lt;strong&gt;minimal&lt;/strong&gt; diffs. To the contrary, minimal diffs are often counter-intuitive, because they synch up anywhere possible, sometimes accidental matches 100 pages apart. Restricting synch points to contiguous matches preserves some notion of locality, at the occasional cost of producing a longer diff.</source>
          <target state="translated">참고 &lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; -generated 델타는 어떤 주장이있을 수 있도록 &lt;strong&gt;최소한의&lt;/strong&gt; 차이점. 반대로, 최소한의 차이는 가능한 한 어디서나 동기화되기 때문에 때로는 100 페이지 간격으로 우연히 일치하기 때문에 반 직관적입니다. 동기 점을 연속 경기로 제한하면 더 긴 diff를 생성하는 경우가 많지만 일부 로컬 리티 개념이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="dd69c68c8e1ff03113702c7b4183ad050851c7e0" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt;&lt;code&gt;ELLIPSIS&lt;/code&gt;&lt;/a&gt; can also be used to ignore the details of the exception message, but such a test may still fail based on whether or not the module details are printed as part of the exception name. Using &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt;&lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt;&lt;/a&gt; and the details from Python 2.3 is also the only clear way to write a doctest that doesn&amp;rsquo;t care about the exception detail yet continues to pass under Python 2.3 or earlier (those releases do not support &lt;a href=&quot;#doctest-directives&quot;&gt;doctest directives&lt;/a&gt; and ignore them as irrelevant comments). For example:</source>
          <target state="translated">참고 &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt; &lt;code&gt;ELLIPSIS&lt;/code&gt; &lt;/a&gt; 또한 예외 메시지의 내용을 무시하는데 사용될 수 있지만, 그러한 테스트가 여전히 모듈의 세부 사항을 제외 이름의 일부로서 인쇄 여부에 기초하여 실패 할 수있다. &lt;a href=&quot;#doctest.IGNORE_EXCEPTION_DETAIL&quot;&gt; &lt;code&gt;IGNORE_EXCEPTION_DETAIL&lt;/code&gt; &lt;/a&gt; 과 Python 2.3의 세부 정보를 사용하는 것도 예외 세부 사항을 신경 쓰지 않고 Python 2.3 또는 이전 버전에서 계속 통과하는 doctest를 작성하는 유일한 명확한 방법입니다 (이 릴리스는 &lt;a href=&quot;#doctest-directives&quot;&gt;doctest 지시문을&lt;/a&gt; 지원하지 않고 관련이없는 주석으로 무시합니다) ). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8e63f31f55e12cdee25e7b08fb73243d54374458" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#float.hex&quot;&gt;&lt;code&gt;float.hex()&lt;/code&gt;&lt;/a&gt; is an instance method, while &lt;a href=&quot;#float.fromhex&quot;&gt;&lt;code&gt;float.fromhex()&lt;/code&gt;&lt;/a&gt; is a class method.</source>
          <target state="translated">주의 &lt;a href=&quot;#float.hex&quot;&gt; &lt;code&gt;float.hex()&lt;/code&gt; &lt;/a&gt; 동안 인스턴스 방법 &lt;a href=&quot;#float.fromhex&quot;&gt; &lt;code&gt;float.fromhex()&lt;/code&gt; &lt;/a&gt; 클래스 방법이다.</target>
        </trans-unit>
        <trans-unit id="8a0c31b2a17d1253675bf81f567abe1a01487d1b" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt;&lt;code&gt;domain_return_ok()&lt;/code&gt;&lt;/a&gt; is called for every &lt;em&gt;cookie&lt;/em&gt; domain, not just for the &lt;em&gt;request&lt;/em&gt; domain. For example, the function might be called with both &lt;code&gt;&quot;.example.com&quot;&lt;/code&gt; and &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; if the request domain is &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt;. The same goes for &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt;&lt;code&gt;path_return_ok()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#http.cookiejar.CookiePolicy.domain_return_ok&quot;&gt; &lt;code&gt;domain_return_ok()&lt;/code&gt; &lt;/a&gt; 모든 호출됩니다 &lt;em&gt;쿠키&lt;/em&gt; 에 대한뿐만 아니라, 도메인 &lt;em&gt;요청&lt;/em&gt; 도메인. 예를 들어 요청 도메인이 &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; 인 경우 &lt;code&gt;&quot;.example.com&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;www.example.com&quot;&lt;/code&gt; 을 사용 하여 함수를 호출 할 수 있습니다 . &lt;a href=&quot;#http.cookiejar.CookiePolicy.path_return_ok&quot;&gt; &lt;code&gt;path_return_ok()&lt;/code&gt; &lt;/a&gt; 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="adc891a129f72cc10502357d2a58f83d2b041536" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#inspect.signature&quot;&gt;&lt;code&gt;signature()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect-signature-object&quot;&gt;Signature Object&lt;/a&gt; provide the recommended API for callable introspection, and support additional behaviours (like positional-only arguments) that are sometimes encountered in extension module APIs. This function is retained primarily for use in code that needs to maintain compatibility with the Python 2 &lt;code&gt;inspect&lt;/code&gt; module API.</source>
          <target state="translated">참고 &lt;a href=&quot;#inspect.signature&quot;&gt; &lt;code&gt;signature()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#inspect-signature-object&quot;&gt;서명 객체가&lt;/a&gt; 호출 성찰에 대한 권장 API를 제공하고, 때로는 확장 모듈의 API에서 발생하는 (위치 만 인수와 같은) 추가 행동을 지원합니다. 이 함수는 주로 Python 2 &lt;code&gt;inspect&lt;/code&gt; 모듈 API 와의 호환성을 유지해야하는 코드에서 사용하기 위해 유지됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddd48ccb5c495507a52bd279914fdcc7d41317f6" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#math.frexp&quot;&gt;&lt;code&gt;frexp()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#math.modf&quot;&gt;&lt;code&gt;modf()&lt;/code&gt;&lt;/a&gt; have a different call/return pattern than their C equivalents: they take a single argument and return a pair of values, rather than returning their second return value through an &amp;lsquo;output parameter&amp;rsquo; (there is no such thing in Python).</source>
          <target state="translated">참고 &lt;a href=&quot;#math.frexp&quot;&gt; &lt;code&gt;frexp()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#math.modf&quot;&gt; &lt;code&gt;modf()&lt;/code&gt; &lt;/a&gt; 자신의 C 당량 상이한 호출 / 복귀 패턴이있다 : 그들은 하나의 인자를 가지고 오히려 '출력 변수'를 통해 제 2 복귀 값을 반환하는 것보다, 한 쌍의 값을 반환은 (더 없다 파이썬에서 그런 것들).</target>
        </trans-unit>
        <trans-unit id="c47ac53dbffb6c7e920e0e9c3a5bd7e68f910640" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; does not have OOR (original object return), it constructs a new, equivalent object each time you retrieve an attribute:</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; OOR (원본 객체 반환)이없는, 그것은 새로운, 해당 객체에게 당신이 속성을 검색 할 때마다 구성한다 :</target>
        </trans-unit>
        <trans-unit id="021cbf64fa7daa47a193a25312368fd1063a8ec4" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#multiprocessing.Lock&quot;&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/a&gt; is actually a factory function which returns an instance of &lt;code&gt;multiprocessing.synchronize.Lock&lt;/code&gt; initialized with a default context.</source>
          <target state="translated">참고 &lt;a href=&quot;#multiprocessing.Lock&quot;&gt; &lt;code&gt;Lock&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환하는 공장 기능을 실제로 &lt;code&gt;multiprocessing.synchronize.Lock&lt;/code&gt; 기본 컨텍스트로 초기화가.</target>
        </trans-unit>
        <trans-unit id="35bd8a5288450aef9ec563731c03552420d81a78" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#multiprocessing.RLock&quot;&gt;&lt;code&gt;RLock&lt;/code&gt;&lt;/a&gt; is actually a factory function which returns an instance of &lt;code&gt;multiprocessing.synchronize.RLock&lt;/code&gt; initialized with a default context.</source>
          <target state="translated">참고 &lt;a href=&quot;#multiprocessing.RLock&quot;&gt; &lt;code&gt;RLock&lt;/code&gt; 가&lt;/a&gt; 의 인스턴스를 반환하는 공장 기능을 실제로 &lt;code&gt;multiprocessing.synchronize.RLock&lt;/code&gt; 기본 컨텍스트로 초기화가.</target>
        </trans-unit>
        <trans-unit id="9325e13fae2a61a60a73c50f96336405ee30e5aa" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#pkgutil.ImpImporter&quot;&gt;&lt;code&gt;ImpImporter&lt;/code&gt;&lt;/a&gt; does not currently support being used by placement on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#pkgutil.ImpImporter&quot;&gt; &lt;code&gt;ImpImporter&lt;/code&gt; 은&lt;/a&gt; 현재 지원하지 않습니다는에 배치 사용하고 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="beaaa22c5ee17911c79acb082b3767365455460e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#socketserver.UnixDatagramServer&quot;&gt;&lt;code&gt;UnixDatagramServer&lt;/code&gt;&lt;/a&gt; derives from &lt;a href=&quot;#socketserver.UDPServer&quot;&gt;&lt;code&gt;UDPServer&lt;/code&gt;&lt;/a&gt;, not from &lt;a href=&quot;#socketserver.UnixStreamServer&quot;&gt;&lt;code&gt;UnixStreamServer&lt;/code&gt;&lt;/a&gt; &amp;mdash; the only difference between an IP and a Unix stream server is the address family, which is simply repeated in both Unix server classes.</source>
          <target state="translated">참고 &lt;a href=&quot;#socketserver.UnixDatagramServer&quot;&gt; &lt;code&gt;UnixDatagramServer&lt;/code&gt; 의&lt;/a&gt; 에서 파생 &lt;a href=&quot;#socketserver.UDPServer&quot;&gt; &lt;code&gt;UDPServer&lt;/code&gt; 이&lt;/a&gt; 아니라에서 &lt;a href=&quot;#socketserver.UnixStreamServer&quot;&gt; &lt;code&gt;UnixStreamServer&lt;/code&gt; &lt;/a&gt; 의 IP와 유닉스 스트림 서버 사이의 유일한 차이는 단순히 두 유닉스 서버 클래스 반복되는 주소 패밀리입니다 -.</target>
        </trans-unit>
        <trans-unit id="778f82ffcb2b485246b0e53ae55c103c932424fb" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is implemented as part of the binding process for explicit dotted attribute lookups such as &lt;code&gt;super().__getitem__(name)&lt;/code&gt;. It does so by implementing its own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is undefined for implicit lookups using statements or operators such as &lt;code&gt;super()[name]&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 명시 적 점선 속성에 대한 바인딩 프로세스의 일부로서 구현과 같은 조회 &lt;code&gt;super().__getitem__(name)&lt;/code&gt; . 협력 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 자체 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 메소드를 구현하여 이를 수행합니다. 따라서 &lt;code&gt;super()[name]&lt;/code&gt; 와 같은 명령문이나 연산자를 사용하여 암시 적 검색에 대해 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 가 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f7795ea5c7b9b9b0af2a5a2436bccd2cc8092c3e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is implemented as part of the binding process for explicit dotted attribute lookups such as &lt;code&gt;super().__getitem__(name)&lt;/code&gt;. It does so by implementing its own &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; method for searching classes in a predictable order that supports cooperative multiple inheritance. Accordingly, &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt; is undefined for implicit lookups using statements or operators such as &lt;code&gt;super()[name]&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 명시 적 점선 속성에 대한 바인딩 프로세스의 일부로서 구현과 같은 조회 &lt;code&gt;super().__getitem__(name)&lt;/code&gt; . 협력 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 자체 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 메서드를 구현하여 이를 수행합니다. 따라서 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 는 명령문 또는 &lt;code&gt;super()[name]&lt;/code&gt; 과 같은 연산자를 사용하는 암시 적 조회에 대해 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f2d150903542528eb29c182959a6e94d9657319e" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; skips over comments in the input instead of creating comment objects for them. An &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; will only contain comment nodes if they have been inserted into to the tree using one of the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 대신 그들을 위해 주석 객체를 생성의 입력에 주석을 통해 건너 뜁니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; 는&lt;/a&gt; 그들이 중 하나를 사용하여 트리에 삽입 된 경우에만 주석 노드를 포함 할 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="7733b443aa3ad7da3792a2988711f38bba4a2a03" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt;&lt;code&gt;XMLParser&lt;/code&gt;&lt;/a&gt; skips over processing instructions in the input instead of creating comment objects for them. An &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt;&lt;code&gt;ElementTree&lt;/code&gt;&lt;/a&gt; will only contain processing instruction nodes if they have been inserted into to the tree using one of the &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.etree.ElementTree.XMLParser&quot;&gt; &lt;code&gt;XMLParser&lt;/code&gt; &lt;/a&gt; 입력에 지시 사항을 처리하는 대신 그들을 위해 주석 객체를 생성 건너 뜁니다. &lt;a href=&quot;#xml.etree.ElementTree.ElementTree&quot;&gt; &lt;code&gt;ElementTree&lt;/code&gt; 는&lt;/a&gt; 그들 만이 중 하나를 사용하여 트리에 삽입 된 경우 명령 노드를 처리 포함 할 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="0a0e52a29264a10a0ed33e3ee017893c317f8a46" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events are not guaranteed to be properly nested relative to each-other: all &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt;&lt;code&gt;startPrefixMapping()&lt;/code&gt;&lt;/a&gt; events will occur before the corresponding &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt;&lt;code&gt;startElement()&lt;/code&gt;&lt;/a&gt; event, and all &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt;&lt;code&gt;endPrefixMapping()&lt;/code&gt;&lt;/a&gt; events will occur after the corresponding &lt;a href=&quot;#xml.sax.handler.ContentHandler.endElement&quot;&gt;&lt;code&gt;endElement()&lt;/code&gt;&lt;/a&gt; event, but their order is not guaranteed.</source>
          <target state="translated">참고 것을 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 모든 : 이벤트가 각각 올바르게 상자로 보장되지 않습니다 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startPrefixMapping&quot;&gt; &lt;code&gt;startPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트가 해당 전에 발생 &lt;a href=&quot;#xml.sax.handler.ContentHandler.startElement&quot;&gt; &lt;code&gt;startElement()&lt;/code&gt; &lt;/a&gt; 이벤트, 모든 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endPrefixMapping&quot;&gt; &lt;code&gt;endPrefixMapping()&lt;/code&gt; &lt;/a&gt; 이벤트는 해당 후 발생 &lt;a href=&quot;#xml.sax.handler.ContentHandler.endElement&quot;&gt; &lt;code&gt;endElement()&lt;/code&gt; &lt;/a&gt; 이벤트이지만 주문이 보장되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="47444f992c8f787e5218f00f598cb803627da402" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;'a:gz'&lt;/code&gt;, &lt;code&gt;'a:bz2'&lt;/code&gt; or &lt;code&gt;'a:xz'&lt;/code&gt; is not possible. If &lt;em&gt;mode&lt;/em&gt; is not suitable to open a certain (compressed) file for reading, &lt;a href=&quot;#tarfile.ReadError&quot;&gt;&lt;code&gt;ReadError&lt;/code&gt;&lt;/a&gt; is raised. Use &lt;em&gt;mode&lt;/em&gt;&lt;code&gt;'r'&lt;/code&gt; to avoid this. If a compression method is not supported, &lt;a href=&quot;#tarfile.CompressionError&quot;&gt;&lt;code&gt;CompressionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">참고 &lt;code&gt;'a:gz'&lt;/code&gt; , &lt;code&gt;'a:bz2'&lt;/code&gt; 또는 &lt;code&gt;'a:xz'&lt;/code&gt; 수 없습니다. 경우 &lt;em&gt;모드를&lt;/em&gt; 읽기 위해 특정 (압축) 파일을 열 수 적합하지 않다, &lt;a href=&quot;#tarfile.ReadError&quot;&gt; &lt;code&gt;ReadError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 이를 피 하려면 &lt;em&gt;모드 &lt;/em&gt; &lt;code&gt;'r'&lt;/code&gt; 을 사용하십시오 . 압축 방법이 지원되지 않으면 &lt;a href=&quot;#tarfile.CompressionError&quot;&gt; &lt;code&gt;CompressionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1cc69e2c68bc296e588d8f892981cbd43a28c6e1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Lock&lt;/code&gt; is actually a factory function which returns an instance of the most efficient version of the concrete Lock class that is supported by the platform.</source>
          <target state="translated">참고 &lt;code&gt;Lock&lt;/code&gt; 플랫폼에서 지원하는 콘크리트 잠금 클래스의 가장 효율적인 버전의 인스턴스를 반환하는 공장 기능은 사실이다.</target>
        </trans-unit>
        <trans-unit id="ee6451008c83ce88b9e80fafc4e7537e799843ea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;None&lt;/code&gt; as a type hint is a special case and is replaced by &lt;code&gt;type(None)&lt;/code&gt;.</source>
          <target state="translated">유의하십시오 &lt;code&gt;None&lt;/code&gt; 타입 힌트는 특별한 경우에 의해 대체 될 때 &lt;code&gt;type(None)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57fae4790fdc5439f742aac77bc9daa66d83e4d4" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;None&lt;/code&gt; may be returned if no handler handles the request (though the default installed global &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;#urllib.request.UnknownHandler&quot;&gt;&lt;code&gt;UnknownHandler&lt;/code&gt;&lt;/a&gt; to ensure this never happens).</source>
          <target state="translated">참고 &lt;code&gt;None&lt;/code&gt; 어떤 핸들러가 요청을 처리하지 않는 경우 반환 될 수 있습니다 (기본값은 글로벌 설치하지만 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; 는&lt;/a&gt; 사용 &lt;a href=&quot;#urllib.request.UnknownHandler&quot;&gt; &lt;code&gt;UnknownHandler&lt;/code&gt; 를&lt;/a&gt; 이 일이 결코 보장하기 위해).</target>
        </trans-unit>
        <trans-unit id="236fa39ea36e5dba046de057b39ac4f3d0d57af9" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;RLock&lt;/code&gt; is actually a factory function which returns an instance of the most efficient version of the concrete RLock class that is supported by the platform.</source>
          <target state="translated">참고 &lt;code&gt;RLock&lt;/code&gt; 이 플랫폼에서 지원하는 콘크리트 RLock 클래스의 가장 효율적인 버전의 인스턴스를 반환하는 공장 기능은 사실이다.</target>
        </trans-unit>
        <trans-unit id="9ed32062270ce11074feca5a6bc1d17484d5ca1f" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Type[C]&lt;/code&gt; is covariant:</source>
          <target state="translated">참고 &lt;code&gt;Type[C]&lt;/code&gt; 공변입니다 :</target>
        </trans-unit>
        <trans-unit id="5b9cfa59b4f04a3b3e5fb4f6cd1086211b01f3d0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;bletch&lt;/code&gt; is omitted because it doesn&amp;rsquo;t exist; the &lt;code&gt;bar&lt;/code&gt; directory precedes the &lt;code&gt;foo&lt;/code&gt; directory because &lt;code&gt;bar.pth&lt;/code&gt; comes alphabetically before &lt;code&gt;foo.pth&lt;/code&gt;; and &lt;code&gt;spam&lt;/code&gt; is omitted because it is not mentioned in either path configuration file.</source>
          <target state="translated">참고 &lt;code&gt;bletch&lt;/code&gt; 가 존재하지 않기 때문에 생략; &lt;code&gt;bar&lt;/code&gt; 디렉토리는 앞에 &lt;code&gt;foo&lt;/code&gt; 때문에 디렉토리를 &lt;code&gt;bar.pth&lt;/code&gt; 이 전에 알파벳 순으로 제공 &lt;code&gt;foo.pth&lt;/code&gt; ; 및 &lt;code&gt;spam&lt;/code&gt; 이 두 경로 구성 파일에 언급되지 않기 때문에 생략하기로한다.</target>
        </trans-unit>
        <trans-unit id="d33be2cd5b4983695dd8516ab51e58c98eb1cabb" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;filter(function, iterable)&lt;/code&gt; is equivalent to the generator expression &lt;code&gt;(item for item in iterable if function(item))&lt;/code&gt; if function is not &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;(item for item in iterable if item)&lt;/code&gt; if function is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 &lt;code&gt;filter(function, iterable)&lt;/code&gt; 발전기 식 동등 &lt;code&gt;(item for item in iterable if function(item))&lt;/code&gt; 기능하지 없으면 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;(item for item in iterable if item)&lt;/code&gt; 기능이없는 경우는 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85efeca034605ee9db13f57e747d94bb977067bc" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fork()&lt;/code&gt; calls made by third-party C code may not call those functions, unless it explicitly calls &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt;&lt;code&gt;PyOS_BeforeFork()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt;&lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt;&lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그 주 &lt;code&gt;fork()&lt;/code&gt; 명시 적으로 호출하지 않는 한, 그 함수를 호출 할 수있는 제 3 자 C 코드에 의해 호출 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt; &lt;code&gt;PyOS_BeforeFork()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt; &lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt; &lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71c7f255fffeef1206d1f6a0f035d3c0897d35b0" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;fork()&lt;/code&gt; calls made by third-party C code may not call those functions, unless it explicitly calls &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt;&lt;code&gt;PyOS_BeforeFork()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt;&lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt;&lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">그 주 &lt;code&gt;fork()&lt;/code&gt; 명시 적으로 호출하지 않는 한, 그 함수를 호출 할 수있는 제 3 자 C 코드에 의해 호출 &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_BeforeFork&quot;&gt; &lt;code&gt;PyOS_BeforeFork()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_AfterFork_Parent&quot;&gt; &lt;code&gt;PyOS_AfterFork_Parent()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/c-api/sys.html#c.PyOS_AfterFork_Child&quot;&gt; &lt;code&gt;PyOS_AfterFork_Child()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d7ba61f0ef9cfc007a2b6f8bfd3fbe4f04edd595" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;m.start(group)&lt;/code&gt; will equal &lt;code&gt;m.end(group)&lt;/code&gt; if &lt;em&gt;group&lt;/em&gt; matched a null string. For example, after &lt;code&gt;m = re.search('b(c?)', 'cba')&lt;/code&gt;, &lt;code&gt;m.start(0)&lt;/code&gt; is 1, &lt;code&gt;m.end(0)&lt;/code&gt; is 2, &lt;code&gt;m.start(1)&lt;/code&gt; and &lt;code&gt;m.end(1)&lt;/code&gt; are both 2, and &lt;code&gt;m.start(2)&lt;/code&gt; raises an &lt;a href=&quot;exceptions#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">참고 &lt;code&gt;m.start(group)&lt;/code&gt; 동일 할 &lt;code&gt;m.end(group)&lt;/code&gt; 경우 &lt;em&gt;그룹&lt;/em&gt; 널 문자열을 매치. 예를 들어 &lt;code&gt;m = re.search('b(c?)', 'cba')&lt;/code&gt; 후에 &lt;code&gt;m.start(0)&lt;/code&gt; 은 1, &lt;code&gt;m.end(0)&lt;/code&gt; 은 2, &lt;code&gt;m.start(1)&lt;/code&gt; 및 &lt;code&gt;m.end(1)&lt;/code&gt; 은 2이고 &lt;code&gt;m.start(2)&lt;/code&gt; 는 &lt;a href=&quot;exceptions#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a801fa594d8a089d333c1d08dda4b81a98110981" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;metavar&lt;/code&gt; only changes the &lt;em&gt;displayed&lt;/em&gt; name - the name of the attribute on the &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; object is still determined by the &lt;a href=&quot;#dest&quot;&gt;dest&lt;/a&gt; value.</source>
          <target state="translated">참고 &lt;code&gt;metavar&lt;/code&gt; 이 변경 사항 만 &lt;em&gt;표시&lt;/em&gt; 이름을 -상의 속성의 이름 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 객체는 여전히에 의해 결정된다 &lt;a href=&quot;#dest&quot;&gt;이명 령&lt;/a&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="36e3e839ce2533fb32ef0684d4636235258670ad" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;nargs=1&lt;/code&gt; produces a list of one item. This is different from the default, in which the item is produced by itself.</source>
          <target state="translated">하는 것으로 &lt;code&gt;nargs=1&lt;/code&gt; 한 항목의 목록을 생성합니다. 항목 자체가 생성되는 기본값과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="6cb4d80564b60cb42824f340ae271f84acf512f2" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;quote(string, safe, encoding, errors)&lt;/code&gt; is equivalent to &lt;code&gt;quote_from_bytes(string.encode(encoding, errors), safe)&lt;/code&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;quote(string, safe, encoding, errors)&lt;/code&gt; 에 해당 &lt;code&gt;quote_from_bytes(string.encode(encoding, errors), safe)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc85143f0c8971e93992f10750203e06ab969614" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;temp0&lt;/code&gt; and &lt;code&gt;temp1&lt;/code&gt; are objects still using the internal buffer of the &lt;code&gt;rc&lt;/code&gt; object above. So executing &lt;code&gt;rc.a = temp0&lt;/code&gt; copies the buffer contents of &lt;code&gt;temp0&lt;/code&gt; into &lt;code&gt;rc&lt;/code&gt; &amp;lsquo;s buffer. This, in turn, changes the contents of &lt;code&gt;temp1&lt;/code&gt;. So, the last assignment &lt;code&gt;rc.b = temp1&lt;/code&gt;, doesn&amp;rsquo;t have the expected effect.</source>
          <target state="translated">참고 &lt;code&gt;temp0&lt;/code&gt; 을 하고 &lt;code&gt;temp1&lt;/code&gt; 여전히 내부 버퍼를 사용하여 객체 &lt;code&gt;rc&lt;/code&gt; 상기 개체. 따라서 &lt;code&gt;rc.a = temp0&lt;/code&gt; 실행 하면 temp0 의 버퍼 내용이 &lt;code&gt;rc&lt;/code&gt; 의 버퍼 에 &lt;code&gt;temp0&lt;/code&gt; 됩니다 . 결과적으로 &lt;code&gt;temp1&lt;/code&gt; 의 내용이 변경 됩니다. 따라서 마지막 할당 &lt;code&gt;rc.b = temp1&lt;/code&gt; 은 예상 된 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f362e945054667a3816f573ef83bd7edea53f2a" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;all&lt;/em&gt;&lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; modifications in the body of the context manager, including replacement of the object, will be reverted at the end of the block.</source>
          <target state="translated">참고 &lt;em&gt;모든 &lt;/em&gt;&lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 에의&lt;/a&gt; 물체의 교체를 포함하는 콘텍스트 관리자의 본체에 변형이 상기 블록의 끝에서 복귀한다.</target>
        </trans-unit>
        <trans-unit id="ce5fc6b37538034752807f8815ba613f8bc848ab" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;lock&lt;/em&gt; is a keyword only argument.</source>
          <target state="translated">참고 &lt;em&gt;잠금&lt;/em&gt; 키워드만을 인수입니다.</target>
        </trans-unit>
        <trans-unit id="3b2234a6dca333d6acda4ece1514b447bb223c5d" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;lock&lt;/em&gt; is a keyword-only argument.</source>
          <target state="translated">참고 것을 &lt;em&gt;잠금&lt;/em&gt; 키워드 전용 인수이다.</target>
        </trans-unit>
        <trans-unit id="3e5897049932333313c37f96477a83c9d676a2c7" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;mapname&lt;/em&gt; is first checked if it is an alias to another name.</source>
          <target state="translated">참고 &lt;em&gt;맵 이름은&lt;/em&gt; 또 다른 이름의 별칭 인 경우 먼저 확인한다.</target>
        </trans-unit>
        <trans-unit id="0bf52d3f07d9f7c54657bde5e8753068a541df3d" translate="yes" xml:space="preserve">
          <source>Note that &lt;em&gt;subtype&lt;/em&gt; is optional; if omitted, then subpart MIME type matching is done only with the main type. &lt;em&gt;maintype&lt;/em&gt; is optional too; it defaults to &lt;em&gt;text&lt;/em&gt;.</source>
          <target state="translated">참고 &lt;em&gt;하위 유형은&lt;/em&gt; 선택 사항입니다; 생략하면 하위 부분 MIME 형식 일치는 기본 형식으로 만 수행됩니다. &lt;em&gt;maintype&lt;/em&gt; 도 옵션입니다. 기본값은 &lt;em&gt;text&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="185bf61bd6bed1a3aeabce3b0e19da1aead89726" translate="yes" xml:space="preserve">
          <source>Note that CGI scripts will be run with UID of user nobody, for security reasons. Problems with the CGI script will be translated to error 403.</source>
          <target state="translated">보안상의 이유로 CGI 스크립트는 nobody 사용자의 UID로 실행됩니다. CGI 스크립트 문제는 오류 403으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d9d2deaf97052c0294923500df788d9b644ff07" translate="yes" xml:space="preserve">
          <source>Note that DOM attributes may also be manipulated as nodes instead of as simple strings. It is fairly rare that you must do this, however, so this usage is not yet documented.</source>
          <target state="translated">DOM 속성은 간단한 문자열 대신 노드로 조작 될 수도 있습니다. 그러나이 작업을 수행해야하는 경우는 매우 드물기 때문에이 사용법은 아직 문서화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f0c209dc694d0046aa169702d84ba458e5877b53" translate="yes" xml:space="preserve">
          <source>Note that GNU &lt;strong&gt;gettext&lt;/strong&gt; also defines a &lt;code&gt;dcgettext()&lt;/code&gt; method, but this was deemed not useful and so it is currently unimplemented.</source>
          <target state="translated">GNU &lt;strong&gt;gettext&lt;/strong&gt; 는 &lt;code&gt;dcgettext()&lt;/code&gt; 메소드 도 정의 하지만 유용하지 않은 것으로 간주되어 현재 구현되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac3a38393892122ad7e515b32aa73f768974848c" translate="yes" xml:space="preserve">
          <source>Note that IMAP4 message numbers change as the mailbox changes; in particular, after an &lt;code&gt;EXPUNGE&lt;/code&gt; command performs deletions the remaining messages are renumbered. So it is highly advisable to use UIDs instead, with the UID command.</source>
          <target state="translated">사서함이 변경되면 IMAP4 메시지 번호가 변경됩니다. 특히 &lt;code&gt;EXPUNGE&lt;/code&gt; 명령이 삭제를 수행 한 후 나머지 메시지의 번호가 다시 매겨집니다. 따라서 UID 명령과 함께 UID를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b2c88144df43e9fa2a3b8a94deba5ba70c305ffa" translate="yes" xml:space="preserve">
          <source>Note that IPv6 scoped addresses are converted to integers without scope zone ID.</source>
          <target state="translated">IPv6 범위 주소는 범위 영역 ID가없는 정수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="171726c431e5e57c0ba8ef895a87dd12a2775147" translate="yes" xml:space="preserve">
          <source>Note that POP3, though widely supported, is obsolescent. The implementation quality of POP3 servers varies widely, and too many are quite poor. If your mailserver supports IMAP, you would be better off using the &lt;a href=&quot;imaplib#imaplib.IMAP4&quot;&gt;&lt;code&gt;imaplib.IMAP4&lt;/code&gt;&lt;/a&gt; class, as IMAP servers tend to be better implemented.</source>
          <target state="translated">POP3는 널리 지원되지만 사용되지 않습니다. POP3 서버의 구현 품질은 매우 다양하며 너무 많은 것이 매우 열악합니다. 메일 서버가 IMAP를 지원하는 경우 IMAP 서버가 더 잘 구현되는 경향이 있으므로 &lt;a href=&quot;imaplib#imaplib.IMAP4&quot;&gt; &lt;code&gt;imaplib.IMAP4&lt;/code&gt; &lt;/a&gt; 클래스를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0976769a6f63c576221d99c17d735ec72b6244d" translate="yes" xml:space="preserve">
          <source>Note that Python makes no effort to distinguish signaling NaNs from quiet NaNs, and behavior for signaling NaNs remains unspecified. Typical behavior is to treat all NaNs as though they were quiet.</source>
          <target state="translated">파이썬은 신호 NaN을 조용한 NaN과 구별하기 위해 노력하지 않으며 NaN 신호를위한 동작은 지정되지 않은 상태로 남아 있습니다. 일반적인 동작은 모든 NaN을 조용히 처리하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9296f2c1170009e8779568448d5aef2bd32ea765" translate="yes" xml:space="preserve">
          <source>Note that SSL-on-563 is discouraged per &lt;a href=&quot;https://tools.ietf.org/html/rfc4642.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4642&lt;/strong&gt;&lt;/a&gt;, in favor of STARTTLS as described below. However, some servers only support the former.</source>
          <target state="translated">SSL-on-563은 아래 설명 된 STARTTLS를 위해 &lt;a href=&quot;https://tools.ietf.org/html/rfc4642.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 4642에&lt;/strong&gt;&lt;/a&gt; 따라 사용하지 않는 것이 좋습니다 . 그러나 일부 서버는 전자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0d544a9bc75ffdcf42bb88359222d7a7b4debd33" translate="yes" xml:space="preserve">
          <source>Note that a daemonic process is not allowed to create child processes. Otherwise a daemonic process would leave its children orphaned if it gets terminated when its parent process exits. Additionally, these are &lt;strong&gt;not&lt;/strong&gt; Unix daemons or services, they are normal processes that will be terminated (and not joined) if non-daemonic processes have exited.</source>
          <target state="translated">데몬 프로세스는 자식 프로세스를 만들 수 없습니다. 그렇지 않으면, 부모 프로세스가 종료 될 때 데몬 프로세스가 종료되면 자식 프로세스가 분리됩니다. 또한 이들은 Unix 데몬이나 서비스 가 &lt;strong&gt;아니며&lt;/strong&gt; , 비 프로세스 프로세스가 종료 된 경우 종료되고 결합되지 않는 정상적인 프로세스입니다.</target>
        </trans-unit>
        <trans-unit id="b3ab68b2d6d6352eec66994675336fc958445858" translate="yes" xml:space="preserve">
          <source>Note that a queue created using a manager does not have this issue. See &lt;a href=&quot;#multiprocessing-programming&quot;&gt;Programming guidelines&lt;/a&gt;.</source>
          <target state="translated">관리자를 사용하여 생성 된 대기열에는이 문제가 없습니다. &lt;a href=&quot;#multiprocessing-programming&quot;&gt;프로그래밍 지침을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="83b09fa4d37d211dda63c2257b5bbfcc0eea346c" translate="yes" xml:space="preserve">
          <source>Note that a single name can be bound to multiple objects. If the result is &lt;code&gt;True&lt;/code&gt;, the name may also be bound to other objects, like an int or list, that does not introduce a new namespace.</source>
          <target state="translated">단일 이름은 여러 개체에 바인딩 될 수 있습니다. 결과가 &lt;code&gt;True&lt;/code&gt; 인 경우 이름은 새 네임 스페이스를 도입하지 않는 int 또는 list와 같은 다른 객체에도 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7182d710470dc2eccc4f80d44d9c3c8590984b" translate="yes" xml:space="preserve">
          <source>Note that accessing the ctypes object through the wrapper can be a lot slower than accessing the raw ctypes object.</source>
          <target state="translated">랩퍼를 통해 ctypes 오브젝트에 액세스하는 것은 원시 ctypes 오브젝트에 액세스하는 것보다 훨씬 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfff56aec00da48d3760fdc8fdc321170625cd65" translate="yes" xml:space="preserve">
          <source>Note that additional file formats which can be decompressed by the &lt;strong&gt;gzip&lt;/strong&gt; and &lt;strong&gt;gunzip&lt;/strong&gt; programs, such as those produced by &lt;strong&gt;compress&lt;/strong&gt; and &lt;strong&gt;pack&lt;/strong&gt;, are not supported by this module.</source>
          <target state="translated">&lt;strong&gt;gzip&lt;/strong&gt; 및 &lt;strong&gt;gunzip&lt;/strong&gt; 프로그램에서 압축 해제 할 수있는 추가 파일 형식 ( 예 : &lt;strong&gt;compress&lt;/strong&gt; 및 &lt;strong&gt;pack으로&lt;/strong&gt; 생성 된 파일 형식) 은이 모듈에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="29cc14f3bb61b303c6e569ab997e5a9c2519db07" translate="yes" xml:space="preserve">
          <source>Note that all examples in this section &lt;strong&gt;purposefully&lt;/strong&gt; show how to use the low-level event loop APIs, such as &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt;&lt;code&gt;loop.run_forever()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt;. Modern asyncio applications rarely need to be written this way; consider using the high-level functions like &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 섹션의 모든 예제는 &lt;a href=&quot;#asyncio.loop.run_forever&quot;&gt; &lt;code&gt;loop.run_forever()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 과 같은 저수준 이벤트 루프 API를 사용하는 방법을 &lt;strong&gt;의도적으로&lt;/strong&gt; 보여줍니다 . 최신 asyncio 응용 프로그램은 이런 방식으로 작성 될 필요가 거의 없습니다. &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 과 같은 고급 기능 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="52b13893f67d7ba58e9280b940186eb07db6ac12" translate="yes" xml:space="preserve">
          <source>Note that all sorts on statistics are in descending order (placing most time consuming items first), where as name, file, and line number searches are in ascending order (alphabetical). The subtle distinction between &lt;code&gt;SortKey.NFL&lt;/code&gt; and &lt;code&gt;SortKey.STDNAME&lt;/code&gt; is that the standard name is a sort of the name as printed, which means that the embedded line numbers get compared in an odd way. For example, lines 3, 20, and 40 would (if the file names were the same) appear in the string order 20, 3 and 40. In contrast, &lt;code&gt;SortKey.NFL&lt;/code&gt; does a numeric compare of the line numbers. In fact, &lt;code&gt;sort_stats(SortKey.NFL)&lt;/code&gt; is the same as &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey.LINE)&lt;/code&gt;.</source>
          <target state="translated">통계의 모든 정렬은 이름, 파일 및 줄 번호 검색이 알파벳 순서로 오름차순 (내림차순)으로 내림차순으로 정렬됩니다 (가장 시간이 오래 걸리는 항목 우선). &lt;code&gt;SortKey.NFL&lt;/code&gt; 과 &lt;code&gt;SortKey.STDNAME&lt;/code&gt; 의 미묘한 차이점 은 표준 이름이 인쇄 된 이름의 일종이라는 것입니다. 즉, 포함 된 줄 번호가 이상한 방식으로 비교됩니다. 예를 들어, 3, 20 및 40 행 (파일 이름이 동일한 경우)은 문자열 순서 20, 3 및 40으로 나타납니다. 반면에 &lt;code&gt;SortKey.NFL&lt;/code&gt; 은 행 번호를 숫자로 비교합니다. 실제로 &lt;code&gt;sort_stats(SortKey.NFL)&lt;/code&gt; 은 &lt;code&gt;sort_stats(SortKey.NAME, SortKey.FILENAME, SortKey.LINE)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0c40fc37a9bf565a857f29ad723c19c596a97f9" translate="yes" xml:space="preserve">
          <source>Note that all these functions check ordinal bit values derived from the character of the string you pass in; they do not actually know anything about the host machine&amp;rsquo;s character encoding.</source>
          <target state="translated">이 모든 함수는 전달한 문자열의 문자에서 파생 된 서수 비트 값을 확인합니다. 실제로 호스트 시스템의 문자 인코딩에 대해서는 아무것도 모릅니다.</target>
        </trans-unit>
        <trans-unit id="0102294a10326ceacdc04ecf27b97bae220074cc" translate="yes" xml:space="preserve">
          <source>Note that alternative event loop implementations might have own limitations; please refer to their documentation.</source>
          <target state="translated">대체 이벤트 루프 구현에는 고유 한 제한이있을 수 있습니다. 해당 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="45152f2b702b262fbbfcdce7c55047081266ed37" translate="yes" xml:space="preserve">
          <source>Note that although the naming for the above described class attributes is singular (e.g. &lt;code&gt;cssclass_month&lt;/code&gt;&lt;code&gt;cssclass_noday&lt;/code&gt;), one can replace the single CSS class with a space separated list of CSS classes, for example:</source>
          <target state="translated">위에서 설명한 클래스 속성의 이름은 단수 &lt;code&gt;cssclass_month&lt;/code&gt; (예 : cssclass_month &lt;code&gt;cssclass_noday&lt;/code&gt; ) 단일 CSS 클래스를 공백으로 구분 된 CSS 클래스 목록으로 바꿀 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc788fedc235ef380745686ed580eadd15bb5571" translate="yes" xml:space="preserve">
          <source>Note that an array of &lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt;&lt;code&gt;ctypes.c_char&lt;/code&gt;&lt;/a&gt; has &lt;code&gt;value&lt;/code&gt; and &lt;code&gt;raw&lt;/code&gt; attributes which allow one to use it to store and retrieve strings &amp;ndash; see documentation for &lt;a href=&quot;ctypes#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt; &lt;code&gt;ctypes.c_char&lt;/code&gt; &lt;/a&gt; 배열 에는 &lt;code&gt;value&lt;/code&gt; 과 &lt;code&gt;raw&lt;/code&gt; 속성이 있으므로이를 사용하여 문자열을 저장하고 검색 할 수 있습니다 . &lt;a href=&quot;ctypes#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dbc239128181b638fbd4155908a13241b2705d34" translate="yes" xml:space="preserve">
          <source>Note that an array of &lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt;&lt;code&gt;ctypes.c_char&lt;/code&gt;&lt;/a&gt; has &lt;em&gt;value&lt;/em&gt; and &lt;em&gt;raw&lt;/em&gt; attributes which allow one to use it to store and retrieve strings.</source>
          <target state="translated">&lt;a href=&quot;ctypes#ctypes.c_char&quot;&gt; &lt;code&gt;ctypes.c_char&lt;/code&gt; &lt;/a&gt; 배열 에는 &lt;em&gt;값&lt;/em&gt; 과 &lt;em&gt;원시&lt;/em&gt; 속성이 있으므로이를 사용하여 문자열을 저장하고 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0725d9c7542906970da6bf54619129ddce9a488b" translate="yes" xml:space="preserve">
          <source>Note that an equivalent command line interface could be produced with less code and more informative help and error messages by using the &lt;a href=&quot;argparse#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;argparse#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하면 코드가 적고 유익한 도움말 및 오류 메시지를 사용하여 동등한 명령 행 인터페이스를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d79de2b4a69fab3541bfc76151735d65f04d953a" translate="yes" xml:space="preserve">
          <source>Note that any arguments not in your user-defined groups will end up back in the usual &amp;ldquo;positional arguments&amp;rdquo; and &amp;ldquo;optional arguments&amp;rdquo; sections.</source>
          <target state="translated">사용자 정의 그룹에없는 인수는 일반적인 &quot;위치 인수&quot;및 &quot;선택적 인수&quot;섹션으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="68a57b0f8502dd0b76f40e988de13524a3dc9d6d" translate="yes" xml:space="preserve">
          <source>Note that any data following the terminator will be available for reading by the channel after &lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt;&lt;code&gt;found_terminator()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#asynchat.async_chat.found_terminator&quot;&gt; &lt;code&gt;found_terminator()&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 터미네이터 다음에 오는 모든 데이터를 채널에서 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10e132ee6084002c7b0a817968e06f5f4037ab02" translate="yes" xml:space="preserve">
          <source>Note that any string beginning with two backslashes is assumed by default to be an &lt;code&gt;'AF_PIPE'&lt;/code&gt; address rather than an &lt;code&gt;'AF_UNIX'&lt;/code&gt; address.</source>
          <target state="translated">두 개의 백 슬래시로 시작하는 문자열은 기본적으로 &lt;code&gt;'AF_UNIX'&lt;/code&gt; 주소가 아닌 &lt;code&gt;'AF_PIPE'&lt;/code&gt; 주소 로 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="27d20a06c7ebcc2a74c0dcd2eec75504ff20d0c8" translate="yes" xml:space="preserve">
          <source>Note that as an exception is propagated down the chain of callers, an &lt;code&gt;'exception'&lt;/code&gt; event is generated at each level.</source>
          <target state="translated">호출자 체인 아래로 예외가 전파되면 &lt;code&gt;'exception'&lt;/code&gt; 이벤트가 각 레벨에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f9800dc40fc6ed2861610fc1c540d6d1d8733fe1" translate="yes" xml:space="preserve">
          <source>Note that calling any method (even inquiries) on a closed stream is undefined. Implementations may raise &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; in this case.</source>
          <target state="translated">닫힌 스트림에서 모든 메소드 (문의 사항 포함)를 호출하는 것은 정의되어 있지 않습니다. 이 경우 구현시 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7982f207f5b326c1a5b9df38ed760b57b9caf0aa" translate="yes" xml:space="preserve">
          <source>Note that child nodes of nodes that have a custom visitor method won&amp;rsquo;t be visited unless the visitor calls &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt;&lt;code&gt;generic_visit()&lt;/code&gt;&lt;/a&gt; or visits them itself.</source>
          <target state="translated">방문자가 &lt;a href=&quot;#ast.NodeVisitor.generic_visit&quot;&gt; &lt;code&gt;generic_visit()&lt;/code&gt; &lt;/a&gt; 호출 하거나 직접 방문하지 않으면 사용자 정의 방문자 메소드가있는 노드의 하위 노드는 방문하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1119ecb23602acd8caeffa5d000794f1eba1757c" translate="yes" xml:space="preserve">
          <source>Note that concurrent modification while iterating can lead to problems, just like when iterating and modifying Python lists or dicts. Therefore, the example first collects all matching elements with &lt;code&gt;root.findall()&lt;/code&gt;, and only then iterates over the list of matches.</source>
          <target state="translated">반복하는 동안 동시 수정은 Python 목록 또는 사전을 반복하고 수정할 때와 마찬가지로 문제를 유발할 수 있습니다. 따라서이 예제는 먼저 &lt;code&gt;root.findall()&lt;/code&gt; 하여 일치하는 모든 요소를 ​​수집 한 다음 일치 항목 목록을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="2d382ed6dd9eab4df2994bedfb13e3537561f992" translate="yes" xml:space="preserve">
          <source>Note that currently expanded netmasks are not supported. That means &lt;code&gt;2001:db00::0/24&lt;/code&gt; is a valid argument while &lt;code&gt;2001:db00::0/ffff:ff00::&lt;/code&gt; not.</source>
          <target state="translated">현재 확장 된 넷 마스크는 지원되지 않습니다. 그 말 &lt;code&gt;2001:db00::0/24&lt;/code&gt; 유효한 인수입니다 동안 &lt;code&gt;2001:db00::0/ffff:ff00::&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="4db3f43ffbaa9cce83c5e9797f11ee3784e159b1" translate="yes" xml:space="preserve">
          <source>Note that currently mutually exclusive argument groups do not support the &lt;em&gt;title&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt; arguments of &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt;&lt;code&gt;add_argument_group()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 상호 배타적 인 인수 그룹 은 &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt; &lt;code&gt;add_argument_group()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;제목&lt;/em&gt; 및 &lt;em&gt;설명&lt;/em&gt; 인수를 지원하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4ba81a2a12ca2905b7e3bc3e32ecb856013a86f5" translate="yes" xml:space="preserve">
          <source>Note that descendant processes of the process will &lt;em&gt;not&lt;/em&gt; be terminated &amp;ndash; they will simply become orphaned.</source>
          <target state="translated">프로세스의 하위 프로세스는 종료 &lt;em&gt;되지 않으며&lt;/em&gt; 단순히 고아가됩니다.</target>
        </trans-unit>
        <trans-unit id="b3a3be6e16147e9e8fd7d6862b1baa360c9c8ab4" translate="yes" xml:space="preserve">
          <source>Note that encoding with &lt;a href=&quot;#email.encoders.encode_quopri&quot;&gt;&lt;code&gt;encode_quopri()&lt;/code&gt;&lt;/a&gt; also encodes all tabs and space characters in the data.</source>
          <target state="translated">참고로 인코딩 것을 &lt;a href=&quot;#email.encoders.encode_quopri&quot;&gt; &lt;code&gt;encode_quopri()&lt;/code&gt; &lt;/a&gt; 또한 데이터의 모든 탭과 공백 문자를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8858707f6b738b8eec7bc257425fec239a5f9e41" translate="yes" xml:space="preserve">
          <source>Note that even for small &lt;code&gt;len(x)&lt;/code&gt;, the total number of permutations of &lt;em&gt;x&lt;/em&gt; can quickly grow larger than the period of most random number generators. This implies that most permutations of a long sequence can never be generated. For example, a sequence of length 2080 is the largest that can fit within the period of the Mersenne Twister random number generator.</source>
          <target state="translated">심지어 작은 참고 &lt;code&gt;len(x)&lt;/code&gt; 의 순열의 수 &lt;em&gt;x는&lt;/em&gt; 빠르게 대부분의 난수 발생기의 기간보다 더 성장할 수 있습니다. 이것은 긴 시퀀스의 대부분의 순열이 절대로 생성 될 수 없음을 의미합니다. 예를 들어, 길이가 2080 인 시퀀스는 Mersenne Twister 난수 생성기의 기간 내에 들어갈 수있는 최대 길이입니다.</target>
        </trans-unit>
        <trans-unit id="c135e18157f388a32703b9e0b8ce0fcf98a88ef9" translate="yes" xml:space="preserve">
          <source>Note that even in &lt;a href=&quot;#re.MULTILINE&quot;&gt;&lt;code&gt;MULTILINE&lt;/code&gt;&lt;/a&gt; mode, &lt;a href=&quot;#re.match&quot;&gt;&lt;code&gt;re.match()&lt;/code&gt;&lt;/a&gt; will only match at the beginning of the string and not at the beginning of each line.</source>
          <target state="translated">도에 참고 &lt;a href=&quot;#re.MULTILINE&quot;&gt; &lt;code&gt;MULTILINE&lt;/code&gt; &lt;/a&gt; 모드, &lt;a href=&quot;#re.match&quot;&gt; &lt;code&gt;re.match()&lt;/code&gt; &lt;/a&gt; 각 줄의 시작 부분에 문자열의 시작 부분이 아니라 일치합니다.</target>
        </trans-unit>
        <trans-unit id="c248f2777a5cff0833e5e1f56ce05642e54cb886" translate="yes" xml:space="preserve">
          <source>Note that even though the time is always returned as a floating point number, not all systems provide time with a better precision than 1 second. While this function normally returns non-decreasing values, it can return a lower value than a previous call if the system clock has been set back between the two calls.</source>
          <target state="translated">시간이 항상 부동 소수점 숫자로 반환 되더라도 모든 시스템이 1 초보다 정확한 정밀도를 제공하는 것은 아닙니다. 이 함수는 일반적으로 감소하지 않는 값을 반환하지만 시스템 호출이 두 호출간에 다시 설정된 경우 이전 호출보다 낮은 값을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8979e2f2b1b29e83666a8cd201294ac167294831" translate="yes" xml:space="preserve">
          <source>Note that existing parameter values of headers may be accessed through the &lt;code&gt;params&lt;/code&gt; attribute of the header value (for example, &lt;code&gt;msg['Content-Type'].params['charset']&lt;/code&gt;).</source>
          <target state="translated">헤더의 기존 매개 변수 값은 헤더 값의 &lt;code&gt;params&lt;/code&gt; 속성 (예 : &lt;code&gt;msg['Content-Type'].params['charset']&lt;/code&gt; )을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5786a82a8493b79c96451e2f0e8ff1a491a88f3b" translate="yes" xml:space="preserve">
          <source>Note that expected output now shows that the snippet runs 1 second faster than before:</source>
          <target state="translated">예상 된 결과는 이제 스 니펫이 이전보다 1 초 빠르게 실행됨을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="356743d5b08962bffdeebdb7d374e8d296f8aa3d" translate="yes" xml:space="preserve">
          <source>Note that filters attached to handlers are consulted before an event is emitted by the handler, whereas filters attached to loggers are consulted whenever an event is logged (using &lt;a href=&quot;#logging.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#logging.info&quot;&gt;&lt;code&gt;info()&lt;/code&gt;&lt;/a&gt;, etc.), before sending an event to handlers. This means that events which have been generated by descendant loggers will not be filtered by a logger&amp;rsquo;s filter setting, unless the filter has also been applied to those descendant loggers.</source>
          <target state="translated">핸들러에 연결된 필터는 이벤트가 핸들러에 의해 생성되기 전에 참조되는 반면, 로거에 연결된 필터 는 이벤트가 핸들러에 전송되기 전에 이벤트가 기록 될 때마다 ( &lt;a href=&quot;#logging.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#logging.info&quot;&gt; &lt;code&gt;info()&lt;/code&gt; &lt;/a&gt; 등을 사용하여 ) 참조 됩니다. 이는 하위 로거에 의해 생성 된 이벤트는 필터가 해당 하위 로거에도 적용되지 않는 한 로거의 필터 설정에 의해 필터링되지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="61a0f268ab225e4ac517bd285248bf03bd4c499e" translate="yes" xml:space="preserve">
          <source>Note that for backward compatibility, the &lt;code&gt;re.U&lt;/code&gt; flag still exists (as well as its synonym &lt;code&gt;re.UNICODE&lt;/code&gt; and its embedded counterpart &lt;code&gt;(?u)&lt;/code&gt;), but these are redundant in Python 3 since matches are Unicode by default for strings (and Unicode matching isn&amp;rsquo;t allowed for bytes).</source>
          <target state="translated">이전 버전과의 호환성을 위해 &lt;code&gt;re.U&lt;/code&gt; 플래그는 여전히 존재하지만 동의어 &lt;code&gt;re.UNICODE&lt;/code&gt; 및 임베디드 대응 물 &lt;code&gt;(?u)&lt;/code&gt; 은 존재하지만 문자열 (및 유니 코드에 대한 일치는 기본적으로 유니 코드이므로 Python 3에서는 중복됩니다) 바이트 일치는 허용되지 않습니다).</target>
        </trans-unit>
        <trans-unit id="465c176dc885bd97b79a8361a2bbae22c1b4e34c" translate="yes" xml:space="preserve">
          <source>Note that for processes created by the &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; function, this attribute is the PID of the spawned shell.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 함수로 작성된 프로세스의 경우이 속성은 생성 된 쉘의 PID입니다.</target>
        </trans-unit>
        <trans-unit id="3882e94a24c32a31d35cc2a1b007f11e37659571" translate="yes" xml:space="preserve">
          <source>Note that for some non-Unix systems, &lt;code&gt;sys.prefix&lt;/code&gt; and &lt;code&gt;sys.exec_prefix&lt;/code&gt; are empty, and the path manipulations are skipped; however the import of &lt;code&gt;sitecustomize&lt;/code&gt; and &lt;code&gt;usercustomize&lt;/code&gt; is still attempted.</source>
          <target state="translated">Unix 이외의 일부 시스템의 경우 &lt;code&gt;sys.prefix&lt;/code&gt; 및 &lt;code&gt;sys.exec_prefix&lt;/code&gt; 가 비어 있고 경로 조작을 건너 뜁니다. 그러나 수입 &lt;code&gt;sitecustomize&lt;/code&gt; 및 &lt;code&gt;usercustomize&lt;/code&gt; 은 아직 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="8fd33ef4d4d5e2689d3ced573aea2f56a54160ad" translate="yes" xml:space="preserve">
          <source>Note that for very large time intervals (greater than 270 years on most platforms) this method will lose microsecond accuracy.</source>
          <target state="translated">매우 많은 시간 간격 (대부분의 플랫폼에서 270 년 이상)의 경우이 방법은 마이크로 초 정확도를 잃습니다.</target>
        </trans-unit>
        <trans-unit id="840170e277d815baed7c66a50d417357022d75d1" translate="yes" xml:space="preserve">
          <source>Note that functions (built-in and user-defined) are pickled by &amp;ldquo;fully qualified&amp;rdquo; name reference, not by value. &lt;a href=&quot;#id8&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; This means that only the function name is pickled, along with the name of the module the function is defined in. Neither the function&amp;rsquo;s code, nor any of its function attributes are pickled. Thus the defining module must be importable in the unpickling environment, and the module must contain the named object, otherwise an exception will be raised. &lt;a href=&quot;#id9&quot; id=&quot;id4&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">함수 (내장 및 사용자 정의)는 값이 아니라 &quot;완전한&quot;이름 참조로 선택됩니다. &lt;a href=&quot;#id8&quot; id=&quot;id3&quot;&gt;2&lt;/a&gt; 이는 함수 이름 만 선택되고 함수가 정의 된 모듈의 이름과 함께 선택됩니다. 함수의 코드 나 함수 속성이 모두 선택되지 않습니다. 따라서 정의 해제 모듈은 피클 링 해제 환경에서 가져올 수 있어야하고 모듈에 명명 된 객체가 포함되어 있어야합니다. 그렇지 않으면 예외가 발생합니다. &lt;a href=&quot;#id9&quot; id=&quot;id4&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb1ee9a91608b1283fe0ceec10e559f6fc6844a7" translate="yes" xml:space="preserve">
          <source>Note that if a slash(/) appears in the parameter list of a function, when invoking &lt;a href=&quot;#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt;, it means that the parameters prior to the slash are positional-only. For more info, see &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-positional-only-arguments&quot;&gt;the FAQ entry on positional-only parameters&lt;/a&gt;.</source>
          <target state="translated">함수의 매개 변수 목록에 슬래시 (/)가 표시되면 &lt;a href=&quot;#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 슬래시 이전의 매개 변수는 위치 전용임을 의미합니다. 자세한 내용 &lt;a href=&quot;https://docs.python.org/3.8/faq/programming.html#faq-positional-only-arguments&quot;&gt;은 위치 전용 매개 변수에 대한 FAQ 항목을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ec568535fd150acb01c00b677671e9fb6fee5f9" translate="yes" xml:space="preserve">
          <source>Note that if a slash(/) appears in the parameter list of a function, when invoking &lt;a href=&quot;#help&quot;&gt;&lt;code&gt;help()&lt;/code&gt;&lt;/a&gt;, it means that the parameters prior to the slash are positional-only. For more info, see &lt;a href=&quot;https://docs.python.org/3.9/faq/programming.html#faq-positional-only-arguments&quot;&gt;the FAQ entry on positional-only parameters&lt;/a&gt;.</source>
          <target state="translated">함수의 매개 변수 목록에 슬래시 (/)가 표시되면 &lt;a href=&quot;#help&quot;&gt; &lt;code&gt;help()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 슬래시 앞의 매개 변수가 위치 전용임을 의미합니다. 자세한 내용 &lt;a href=&quot;https://docs.python.org/3.9/faq/programming.html#faq-positional-only-arguments&quot;&gt;은 위치 전용 매개 변수에 대한 FAQ 항목을&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="6ba29bc642962688bd93f7d7440bdc3d09b1a14c" translate="yes" xml:space="preserve">
          <source>Note that if anything goes wrong while importing the callable named by &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt; is reported and the breakpoint is ignored.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 로&lt;/a&gt; 명명 된 호출 가능 파일을 가져 오는 중에 문제 가 발생 하면 &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; &lt;/a&gt; 이보고되고 중단 점이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="97cb6a869aebbfa67f78bc839290dc18ba9514f9" translate="yes" xml:space="preserve">
          <source>Note that if anything goes wrong while importing the callable named by &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-4&quot;&gt;&lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt;&lt;code&gt;RuntimeWarning&lt;/code&gt;&lt;/a&gt; is reported and the breakpoint is ignored.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONBREAKPOINT&quot; id=&quot;index-4&quot;&gt; &lt;code&gt;PYTHONBREAKPOINT&lt;/code&gt; 로&lt;/a&gt; 명명 된 콜 러블 을 가져 오는 동안 문제 가 발생 하면 &lt;a href=&quot;exceptions#RuntimeWarning&quot;&gt; &lt;code&gt;RuntimeWarning&lt;/code&gt; &lt;/a&gt; 이보고되고 중단 점이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d37b5b457c0e579a56a9008b596dcf0daed0c531" translate="yes" xml:space="preserve">
          <source>Note that if the message object has no preamble, the &lt;em&gt;preamble&lt;/em&gt; attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">메시지 오브젝트에 프리앰블이없는 경우 &lt;em&gt;프리앰블&lt;/em&gt; 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c57b574c5b42a4687029f512f3b789f966aa395d" translate="yes" xml:space="preserve">
          <source>Note that if the named field appears more than once in the message&amp;rsquo;s headers, exactly which of those field values will be returned is undefined. Use the &lt;a href=&quot;#email.message.EmailMessage.get_all&quot;&gt;&lt;code&gt;get_all()&lt;/code&gt;&lt;/a&gt; method to get the values of all the extant headers named &lt;em&gt;name&lt;/em&gt;.</source>
          <target state="translated">이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. &lt;a href=&quot;#email.message.EmailMessage.get_all&quot;&gt; &lt;code&gt;get_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 &lt;em&gt;name&lt;/em&gt; 이라는 모든 기존 헤더의 값을 가져 오십시오 .</target>
        </trans-unit>
        <trans-unit id="15161d213ea81ba024de0a076644d1272635e94d" translate="yes" xml:space="preserve">
          <source>Note that if the named field appears more than once in the message&amp;rsquo;s headers, exactly which of those field values will be returned is undefined. Use the &lt;a href=&quot;#email.message.Message.get_all&quot;&gt;&lt;code&gt;get_all()&lt;/code&gt;&lt;/a&gt; method to get the values of all the extant named headers.</source>
          <target state="translated">이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면 해당 필드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. &lt;a href=&quot;#email.message.Message.get_all&quot;&gt; &lt;code&gt;get_all()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 기존의 모든 명명 된 헤더의 값을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="87ae25219d92f70d8ce3d6068ac05c1ccc107875" translate="yes" xml:space="preserve">
          <source>Note that if you have defined any custom logging level higher than &lt;code&gt;CRITICAL&lt;/code&gt; (this is not recommended), you won&amp;rsquo;t be able to rely on the default value for the &lt;em&gt;level&lt;/em&gt; parameter, but will have to explicitly supply a suitable value.</source>
          <target state="translated">&lt;code&gt;CRITICAL&lt;/code&gt; 보다 높은 사용자 정의 로깅 레벨을 정의한 경우 (권장하지 않음) &lt;em&gt;레벨&lt;/em&gt; 매개 변수 의 기본값을 사용할 수는 없지만 적절한 값을 명시 적으로 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="2465633c732bfdca544359da14ee59c714468eb0" translate="yes" xml:space="preserve">
          <source>Note that if you set the &lt;em&gt;shell&lt;/em&gt; argument to &lt;code&gt;True&lt;/code&gt;, this is the process ID of the spawned shell.</source>
          <target state="translated">&lt;em&gt;shell&lt;/em&gt; 인수를 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 생성 된 쉘의 프로세스 ID입니다.</target>
        </trans-unit>
        <trans-unit id="95edd926d0c8f963e4c8a0f19295c25236bc7bfd" translate="yes" xml:space="preserve">
          <source>Note that if you specify an interpreter and then distribute your application archive, you need to ensure that the interpreter used is portable. The Python launcher for Windows supports most common forms of POSIX &lt;code&gt;#!&lt;/code&gt; line, but there are other issues to consider:</source>
          <target state="translated">인터프리터를 지정한 다음 애플리케이션 아카이브를 분배하는 경우 사용 된 인터프리터가 이식 가능한지 확인해야합니다. Windows 용 Python 런처는 가장 일반적인 형태의 POSIX &lt;code&gt;#!&lt;/code&gt; 고려해야 할 다른 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="aababa3d966c7b1183bc1e3bb713ff94a4b803c7" translate="yes" xml:space="preserve">
          <source>Note that if you want to send data to the process&amp;rsquo;s stdin, you need to create the Popen object with &lt;code&gt;stdin=PIPE&lt;/code&gt;. Similarly, to get anything other than &lt;code&gt;None&lt;/code&gt; in the result tuple, you need to give &lt;code&gt;stdout=PIPE&lt;/code&gt; and/or &lt;code&gt;stderr=PIPE&lt;/code&gt; too.</source>
          <target state="translated">프로세스의 stdin에 데이터를 보내려면 &lt;code&gt;stdin=PIPE&lt;/code&gt; 를 사용하여 Popen 오브젝트를 작성해야합니다 . 마찬가지로 결과 튜플에서 &lt;code&gt;None&lt;/code&gt; 이외의 값을 얻으려면 &lt;code&gt;stdout=PIPE&lt;/code&gt; 및 / 또는 &lt;code&gt;stderr=PIPE&lt;/code&gt; 도 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d30eb9f3b524dd91c924b480ac665ceea172bbd3" translate="yes" xml:space="preserve">
          <source>Note that if your server is not listening on UDP port 514, &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; may appear not to work. In that case, check what address you should be using for a domain socket - it&amp;rsquo;s system dependent. For example, on Linux it&amp;rsquo;s usually &amp;lsquo;/dev/log&amp;rsquo; but on OS/X it&amp;rsquo;s &amp;lsquo;/var/run/syslog&amp;rsquo;. You&amp;rsquo;ll need to check your platform and use the appropriate address (you may need to do this check at runtime if your application needs to run on several platforms). On Windows, you pretty much have to use the UDP option.</source>
          <target state="translated">서버가 UDP 포트 514에서 수신 대기하지 않으면 &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; &lt;/a&gt; 가 작동하지 않는 것처럼 보일 수 있습니다. 이 경우 도메인 소켓에 사용해야하는 주소를 확인하십시오 (시스템에 따라 다름). 예를 들어 Linux에서는 일반적으로 '/ dev / log'이지만 OS / X에서는 '/ var / run / syslog'입니다. 플랫폼을 확인하고 적절한 주소를 사용해야합니다 (응용 프로그램이 여러 플랫폼에서 실행되어야하는 경우 런타임에이 확인을 수행해야 할 수 있음). Windows에서는 UDP 옵션을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e6d6ccf640c4a7fd68532b2415ba6bb4f3714d8" translate="yes" xml:space="preserve">
          <source>Note that in all cases, any envelope header present in the message is not included in the mapping interface.</source>
          <target state="translated">모든 경우에 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba327349434f8a3d52b3e4e613f26c146b8940c2" translate="yes" xml:space="preserve">
          <source>Note that in order to test something, we use one of the &lt;code&gt;assert*()&lt;/code&gt; methods provided by the &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; base class. If the test fails, an exception will be raised with an explanatory message, and &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; will identify the test case as a &lt;em&gt;failure&lt;/em&gt;. Any other exceptions will be treated as &lt;em&gt;errors&lt;/em&gt;.</source>
          <target state="translated">무언가를 테스트하기 위해 &lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 기본 클래스 에서 제공 하는 &lt;code&gt;assert*()&lt;/code&gt; 메소드 중 하나를 사용 합니다. 테스트가 실패하면 설명 메시지와 함께 예외가 발생하고 &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 는 테스트 케이스를 &lt;em&gt;실패한&lt;/em&gt; 것으로 식별합니다 . 다른 예외는 &lt;em&gt;오류&lt;/em&gt; 로 처리됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2963c39aeb1fbe44d9106170763ccfab16bbab6" translate="yes" xml:space="preserve">
          <source>Note that in the first example the return value variable &lt;em&gt;rv&lt;/em&gt; will hold an integer value; in the second example it will hold a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object. The structure lay-out for the &lt;em&gt;lockdata&lt;/em&gt; variable is system dependent &amp;mdash; therefore using the &lt;a href=&quot;#fcntl.flock&quot;&gt;&lt;code&gt;flock()&lt;/code&gt;&lt;/a&gt; call may be better.</source>
          <target state="translated">첫 번째 예에서 반환 값 변수 &lt;em&gt;rv&lt;/em&gt; 는 정수 값을 보유합니다. 두 번째 예에서는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체를 보유 합니다. &lt;em&gt;lockdata&lt;/em&gt; 변수 의 구조 레이아웃 은 시스템에 따라 다르므로 &lt;a href=&quot;#fcntl.flock&quot;&gt; &lt;code&gt;flock()&lt;/code&gt; &lt;/a&gt; 호출을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e76d82ec0cfb558c63a1e08054c8f07fa0699635" translate="yes" xml:space="preserve">
          <source>Note that inclusion in the &lt;em&gt;choices&lt;/em&gt; container is checked after any &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; conversions have been performed, so the type of the objects in the &lt;em&gt;choices&lt;/em&gt; container should match the &lt;a href=&quot;#type&quot;&gt;type&lt;/a&gt; specified:</source>
          <target state="translated">&lt;a href=&quot;#type&quot;&gt;유형&lt;/a&gt; 변환이 수행 된 후 &lt;em&gt;선택&lt;/em&gt; 컨테이너에 포함되는지 확인 되므로 &lt;em&gt;선택&lt;/em&gt; 컨테이너 의 객체 &lt;a href=&quot;#type&quot;&gt;유형은&lt;/a&gt; 지정된 유형 과 일치해야 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a424e123046b9f2ba0f16ae4ec8e158536158450" translate="yes" xml:space="preserve">
          <source>Note that installing a signal handler with &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;/a&gt; will reset the restart behaviour to interruptible by implicitly calling &lt;code&gt;siginterrupt()&lt;/code&gt; with a true &lt;em&gt;flag&lt;/em&gt; value for the given signal.</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal()&lt;/code&gt; &lt;/a&gt; 으로 신호 처리기를 설치 하면 주어진 신호에 대해 true &lt;em&gt;플래그&lt;/em&gt; 값으로 &lt;code&gt;siginterrupt()&lt;/code&gt; 를 암시 적으로 호출하여 재시작 동작을 인터럽트 가능으로 재설정합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bd995b47911c934ecbce7db6be1c427a4ba9cc9f" translate="yes" xml:space="preserve">
          <source>Note that is &lt;strong&gt;not correct&lt;/strong&gt; to rely on the garbage colletor to destroy the pool as CPython does not assure that the finalizer of the pool will be called (see &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt;&lt;code&gt;object.__del__()&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">참고 &lt;strong&gt;정확하지&lt;/strong&gt; CPython과 풀의 종료자를 호출 할 것을 보장하지 않는 풀을 파괴하는 쓰레기 colletor에 의존는 (참조 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__del__&quot;&gt; &lt;code&gt;object.__del__()&lt;/code&gt; &lt;/a&gt; 자세한 내용을).</target>
        </trans-unit>
        <trans-unit id="b9f60fa0720b86d1dcdc718ca772ee8cca933f15" translate="yes" xml:space="preserve">
          <source>Note that it does not allow read/write WAV files.</source>
          <target state="translated">읽기 / 쓰기 WAV 파일은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b37732e38cdf4751eb314377a55436fbd87b874f" translate="yes" xml:space="preserve">
          <source>Note that it is actually the comma which makes a tuple, not the parentheses. The parentheses are optional, except in the empty tuple case, or when they are needed to avoid syntactic ambiguity. For example, &lt;code&gt;f(a, b, c)&lt;/code&gt; is a function call with three arguments, while &lt;code&gt;f((a, b, c))&lt;/code&gt; is a function call with a 3-tuple as the sole argument.</source>
          <target state="translated">실제로는 괄호가 아닌 튜플을 만드는 것이 쉼표입니다. 빈 튜플의 경우 또는 구문 모호성을 피하기 위해 필요한 경우를 제외하고 괄호는 선택 사항입니다. 예를 들어, &lt;code&gt;f(a, b, c)&lt;/code&gt; 는 세 개의 인수를 가진 함수 호출이고 &lt;code&gt;f((a, b, c))&lt;/code&gt; 는 유일한 인수로 3- 튜플을 가진 함수 호출입니다.</target>
        </trans-unit>
        <trans-unit id="c1142fa9322d5765d4454b6dfb466ee0b2fdb642" translate="yes" xml:space="preserve">
          <source>Note that it is invalid to set any parameters after calling &lt;code&gt;writeframes()&lt;/code&gt; or &lt;code&gt;writeframesraw()&lt;/code&gt;, and any attempt to do so will raise &lt;a href=&quot;#wave.Error&quot;&gt;&lt;code&gt;wave.Error&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;writeframes()&lt;/code&gt; 또는 &lt;code&gt;writeframesraw()&lt;/code&gt; 호출 한 후 매개 변수를 설정할 수 없으며 , 그렇게하면 &lt;a href=&quot;#wave.Error&quot;&gt; &lt;code&gt;wave.Error&lt;/code&gt; 가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8bccd4b29f1a54b5e303c1a916237118b7ad7ec0" translate="yes" xml:space="preserve">
          <source>Note that it may cause high memory usage for very long iterables. Consider using &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt;&lt;code&gt;imap()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#multiprocessing.pool.Pool.imap_unordered&quot;&gt;&lt;code&gt;imap_unordered()&lt;/code&gt;&lt;/a&gt; with explicit &lt;em&gt;chunksize&lt;/em&gt; option for better efficiency.</source>
          <target state="translated">매우 긴 iterable에 대해 높은 메모리 사용이 발생할 수 있습니다. 사용을 고려 &lt;a href=&quot;#multiprocessing.pool.Pool.imap&quot;&gt; &lt;code&gt;imap()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#multiprocessing.pool.Pool.imap_unordered&quot;&gt; &lt;code&gt;imap_unordered()&lt;/code&gt; &lt;/a&gt; 명시 적으로 &lt;em&gt;chunksize 영역의&lt;/em&gt; 더 나은 효율성을 위해 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="bc1c75d4508d9bbf24ec9e11eb857898269d1eae" translate="yes" xml:space="preserve">
          <source>Note that it&amp;rsquo;s already possible to iterate on file objects using &lt;code&gt;for
line in file: ...&lt;/code&gt; without calling &lt;code&gt;file.readlines()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;file.readlines()&lt;/code&gt; 를 호출하지 않고 &lt;code&gt;for line in file: ...&lt;/code&gt; 사용하여 파일 객체를 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05a2b045555cd68924e93f59f7b760be26ddd68b" translate="yes" xml:space="preserve">
          <source>Note that many of these have little practical significance in modern usage. The mnemonics derive from teleprinter conventions that predate digital computers.</source>
          <target state="translated">이들 중 많은 것들이 현대적인 사용법에서 실질적인 중요성을 거의 가지고 있지 않습니다. 니모닉은 디지털 컴퓨터 이전의 텔레 프린터 규칙에서 파생됩니다.</target>
        </trans-unit>
        <trans-unit id="9ed4f4956d2d64f5ed11cfc83c3e2520067e2797" translate="yes" xml:space="preserve">
          <source>Note that methods of asyncio queues don&amp;rsquo;t have a &lt;em&gt;timeout&lt;/em&gt; parameter; use &lt;a href=&quot;asyncio-task#asyncio.wait_for&quot;&gt;&lt;code&gt;asyncio.wait_for()&lt;/code&gt;&lt;/a&gt; function to do queue operations with a timeout.</source>
          <target state="translated">asyncio 대기열의 메서드에는 &lt;em&gt;시간 초과&lt;/em&gt; 매개 변수 가 없습니다 . 사용하는 &lt;a href=&quot;asyncio-task#asyncio.wait_for&quot;&gt; &lt;code&gt;asyncio.wait_for()&lt;/code&gt; &lt;/a&gt; 타임 아웃 큐 연산을 수행 할 함수.</target>
        </trans-unit>
        <trans-unit id="9d7173aaff46eece39c6ad050dacaca07a346492" translate="yes" xml:space="preserve">
          <source>Note that most parent parsers will specify &lt;code&gt;add_help=False&lt;/code&gt;. Otherwise, the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; will see two &lt;code&gt;-h/--help&lt;/code&gt; options (one in the parent and one in the child) and raise an error.</source>
          <target state="translated">대부분의 상위 파서는 &lt;code&gt;add_help=False&lt;/code&gt; 를 지정 합니다. 그렇지 않으면 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 에&lt;/a&gt; 두 개의 &lt;code&gt;-h/--help&lt;/code&gt; 옵션 (부모와 자식에 하나씩)이 표시되고 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ec5c2fc42c63d4c02f722210f01d284542c94cdd" translate="yes" xml:space="preserve">
          <source>Note that multiple connection objects may be polled at once by using &lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt;&lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.wait&quot;&gt; &lt;code&gt;multiprocessing.connection.wait()&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 연결 객체를 한 번에 폴링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5aad7f2fe356ddb37a2958193ffcc95757955613" translate="yes" xml:space="preserve">
          <source>Note that no external programs are called from this function, giving it portability and efficiency.</source>
          <target state="translated">이 함수에서 외부 프로그램을 호출하지 않으므로 이식성과 효율성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="73e56395f79c913850173ac7c4bbd0a531342117" translate="yes" xml:space="preserve">
          <source>Note that no stream repositioning should take place. This method is primarily intended to be able to recover from decoding errors.</source>
          <target state="translated">스트림 재배치가 발생하지 않아야합니다. 이 방법은 주로 디코딩 오류를 복구 할 수 있도록 고안되었습니다.</target>
        </trans-unit>
        <trans-unit id="9b04c87d02c729d2b34d36ed6364a0bf9a50ea51" translate="yes" xml:space="preserve">
          <source>Note that normalization of negative values may be surprising at first. For example:</source>
          <target state="translated">음수 값의 정규화는 처음에는 놀랍습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08827e39a2581735ab237416a511e4b4882c7aff" translate="yes" xml:space="preserve">
          <source>Note that objects related to one context may not be compatible with processes for a different context. In particular, locks created using the &lt;em&gt;fork&lt;/em&gt; context cannot be passed to processes started using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods.</source>
          <target state="translated">한 컨텍스트와 관련된 개체는 다른 컨텍스트의 프로세스와 호환되지 않을 수 있습니다. 특히, &lt;em&gt;포크&lt;/em&gt; 컨텍스트를 사용하여 작성된 잠금 은 &lt;em&gt;스폰&lt;/em&gt; 또는 &lt;em&gt;포크 서버&lt;/em&gt; 시작 메소드를 사용하여 시작된 프로세스로 전달 될 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="eda4961590997a45a1e79372239074265d25ed88" translate="yes" xml:space="preserve">
          <source>Note that objects which have already been dereferenced, but which live in cycles and have not yet been collected by the garbage collector can be listed among the resulting referrers. To get only currently live objects, call &lt;a href=&quot;#gc.collect&quot;&gt;&lt;code&gt;collect()&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;#gc.get_referrers&quot;&gt;&lt;code&gt;get_referrers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이미 역 참조되었지만주기에 존재하고 가비지 수집기에 의해 아직 수집되지 않은 객체는 결과 참조 자 사이에 나열 될 수 있습니다. 현재 라이브 객체 만 가져 오려면 &lt;a href=&quot;#gc.get_referrers&quot;&gt; &lt;code&gt;get_referrers()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;#gc.collect&quot;&gt; &lt;code&gt;collect()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0d01f60caa4137debd7332962680da8372d67729" translate="yes" xml:space="preserve">
          <source>Note that on Windows child processes will only inherit the level of the parent process&amp;rsquo;s logger &amp;ndash; any other customization of the logger will not be inherited.</source>
          <target state="translated">Windows에서 하위 프로세스는 상위 프로세스의 로거 레벨 만 상속합니다. 로거의 다른 사용자 정의는 상속되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="71665cc8043f3efa68e4485fe250bc5b29c8a385" translate="yes" xml:space="preserve">
          <source>Note that on some platforms, trying to open a filename using this function, may work and start the operating system&amp;rsquo;s associated program. However, this is neither supported nor portable.</source>
          <target state="translated">일부 플랫폼에서이 기능을 사용하여 파일 이름을 열려고하면 운영 체제와 관련된 프로그램이 작동하고 시작될 수 있습니다. 그러나 이것은 지원되거나 이식되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c5a9e4b55caffc98aca4b11598a9c875e9057ec" translate="yes" xml:space="preserve">
          <source>Note that one can also create a shared queue by using a manager object &amp;ndash; see &lt;a href=&quot;#multiprocessing-managers&quot;&gt;Managers&lt;/a&gt;.</source>
          <target state="translated">하나는 관리자 개체를 사용하여 공유 큐를 만들 수 주 - 참조 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;매니저&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="11489b229a9332af75273ce34ce4bbce75cf8ef6" translate="yes" xml:space="preserve">
          <source>Note that one can also create synchronization primitives by using a manager object &amp;ndash; see &lt;a href=&quot;#multiprocessing-managers&quot;&gt;Managers&lt;/a&gt;.</source>
          <target state="translated">하나는 관리자 개체를 사용하여 동기화 기본을 만들 수 주 - 참조 &lt;a href=&quot;#multiprocessing-managers&quot;&gt;매니저&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d73f2e5696ae1abc027da2033b4b034e5b6843a" translate="yes" xml:space="preserve">
          <source>Note that operations such as &lt;a href=&quot;#audioop.mul&quot;&gt;&lt;code&gt;mul()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#audioop.max&quot;&gt;&lt;code&gt;max()&lt;/code&gt;&lt;/a&gt; make no distinction between mono and stereo fragments, i.e. all samples are treated equal. If this is a problem the stereo fragment should be split into two mono fragments first and recombined later. Here is an example of how to do that:</source>
          <target state="translated">&lt;a href=&quot;#audioop.mul&quot;&gt; &lt;code&gt;mul()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#audioop.max&quot;&gt; &lt;code&gt;max()&lt;/code&gt; &lt;/a&gt; 와 같은 연산 은 모노와 스테레오 프래그먼트를 구별하지 않습니다. 즉, 모든 샘플이 동일하게 취급됩니다. 이것이 문제라면, 스테레오 프래그먼트를 먼저 두 개의 모노 프래그먼트로 나누고 나중에 다시 결합해야합니다. 이를 수행하는 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b16370266d750c139819b213ca33ad0c71c90be" translate="yes" xml:space="preserve">
          <source>Note that other exceptions may also be raised during unpickling, including (but not necessarily limited to) AttributeError, EOFError, ImportError, and IndexError.</source>
          <target state="translated">속성을 제거하는 동안 AttributeError, EOFError, ImportError 및 IndexError를 포함한 다른 예외도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c14ddea7d8a40390395369e4d9bf692d2a322f31" translate="yes" xml:space="preserve">
          <source>Note that parser-level defaults always override argument-level defaults:</source>
          <target state="translated">파서 수준의 기본값은 항상 인수 수준의 기본값보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7eb9240d51fab27d432be3b59cc8d057375a5d25" translate="yes" xml:space="preserve">
          <source>Note that pickles aren&amp;rsquo;t completely secure. If you are concerned about security, you may want to override this method to implement a more secure mechanism. For example, you can sign pickles using HMAC and then verify them on the receiving end, or alternatively you can disable unpickling of global objects on the receiving end.</source>
          <target state="translated">피클은 완전히 안전하지 않습니다. 보안이 우려되는 경우이 방법을 재정 의하여보다 안전한 메커니즘을 구현할 수 있습니다. 예를 들어, HMAC를 사용하여 피클에 서명 한 다음 수신 측에서이를 피클 링하거나 수신 측에서 전역 객체의 피클 링 해제를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb90d29aeda61d23a983d5f5ed8686703c50549" translate="yes" xml:space="preserve">
          <source>Note that printf prints to the real standard output channel, &lt;em&gt;not&lt;/em&gt; to &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt;, so these examples will only work at the console prompt, not from within &lt;em&gt;IDLE&lt;/em&gt; or &lt;em&gt;PythonWin&lt;/em&gt;:</source>
          <target state="translated">참고 실제 표준 출력 채널의 printf 인쇄, &lt;em&gt;하지&lt;/em&gt; 에 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; , 그래서이 예제하지 않습니다 내에서, 콘솔에서만 작업 프롬프트 &lt;em&gt;IDLE&lt;/em&gt; 또는 &lt;em&gt;를 PythonWin&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="dbe8dc287e2d3ac27238f225b2b077ec51310c3b" translate="yes" xml:space="preserve">
          <source>Note that profiling will only work if the called command/function actually returns. If the interpreter is terminated (e.g. via a &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; call during the called command/function execution) no profiling results will be printed.</source>
          <target state="translated">프로파일 링은 호출 된 명령 / 함수가 실제로 리턴 된 경우에만 작동합니다. 인터프리터가 종료 된 경우 (예 : 호출 된 명령 / 함수 실행 중 &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 호출을 통해 ) 프로파일 링 결과가 인쇄되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de353d4750a5cdba4018be858fb797f69441158f" translate="yes" xml:space="preserve">
          <source>Note that returning instances of private classes is not recommended. It is usually preferable to make such classes public.</source>
          <target state="translated">개인 클래스의 인스턴스를 반환하지 않는 것이 좋습니다. 일반적으로 그러한 수업을 공개하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bae0d8a27b12e898d4d9a61e003f0408e393752d" translate="yes" xml:space="preserve">
          <source>Note that setting and getting an element is potentially non-atomic &amp;ndash; use &lt;a href=&quot;#multiprocessing.sharedctypes.Array&quot;&gt;&lt;code&gt;Array()&lt;/code&gt;&lt;/a&gt; instead to make sure that access is automatically synchronized using a lock.</source>
          <target state="translated">요소를 설정하고 가져 오는 것은 잠재적으로 비원 자적입니다. 대신 Lock &lt;a href=&quot;#multiprocessing.sharedctypes.Array&quot;&gt; &lt;code&gt;Array()&lt;/code&gt; &lt;/a&gt; 사용하여 액세스가 자동으로 동기화되도록 Array () 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fba826635b3c9adedafaa20e7c85f3678b0d3888" translate="yes" xml:space="preserve">
          <source>Note that setting and getting the value is potentially non-atomic &amp;ndash; use &lt;a href=&quot;#multiprocessing.sharedctypes.Value&quot;&gt;&lt;code&gt;Value()&lt;/code&gt;&lt;/a&gt; instead to make sure that access is automatically synchronized using a lock.</source>
          <target state="translated">값 설정 및 가져 오기는 잠재적으로 비원 자적입니다. 대신 잠금을 사용하여 액세스가 자동으로 동기화되도록 하려면 &lt;a href=&quot;#multiprocessing.sharedctypes.Value&quot;&gt; &lt;code&gt;Value()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0a4d937d898d6dae87b372469dc8ecdc5efcd60" translate="yes" xml:space="preserve">
          <source>Note that shared fixtures do not play well with [potential] features like test parallelization and they break test isolation. They should be used with care.</source>
          <target state="translated">공유 픽스쳐는 테스트 병렬화와 같은 [잠재적] 기능과 잘 작동하지 않으며 테스트 격리를 중단합니다. 그들은 조심스럽게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a3a80c8445850d90d40639df2476d5a77bd29df" translate="yes" xml:space="preserve">
          <source>Note that simply calling a coroutine will not schedule it to be executed:</source>
          <target state="translated">단순히 코 루틴을 호출한다고해서 실행되도록 예약되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="68956186d48d42443b6758d13e6916e94a8cef68" translate="yes" xml:space="preserve">
          <source>Note that since all options are disabled by default, and directives apply only to the example they appear in, enabling options (via &lt;code&gt;+&lt;/code&gt; in a directive) is usually the only meaningful choice. However, option flags can also be passed to functions that run doctests, establishing different defaults. In such cases, disabling an option via &lt;code&gt;-&lt;/code&gt; in a directive can be useful.</source>
          <target state="translated">모든 옵션은 기본적으로 비활성화되어 있으며 지시문은 표시되는 예제에만 적용되므로 지시문에서 &lt;code&gt;+&lt;/code&gt; 를 통해 옵션을 활성화 하는 것이 일반적으로 유일하게 의미있는 선택입니다. 그러나 doctest를 실행하는 함수에 옵션 플래그를 전달하여 다른 기본값을 설정할 수도 있습니다. 이러한 경우 지시문에서 &lt;code&gt;-&lt;/code&gt; 를 통해 옵션을 비활성화하면 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d486f123342853ccfe49cff51f3b937ee427e3c1" translate="yes" xml:space="preserve">
          <source>Note that some platforms including FreeBSD &amp;lt;= 6.3 and Cygwin have known issues when using &lt;code&gt;fork()&lt;/code&gt; from a thread.</source>
          <target state="translated">FreeBSD &amp;lt;= 6.3 및 Cygwin을 포함한 일부 플랫폼 에는 스레드에서 &lt;code&gt;fork()&lt;/code&gt; 를 사용할 때 알려진 문제가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4eebda1ed9cbd631d501f51d602004fcc0df5dce" translate="yes" xml:space="preserve">
          <source>Note that some recent versions of the HTML specification do state what order the field values should be supplied in, but knowing whether a request was received from a conforming browser, or even from a browser at all, is tedious and error-prone.</source>
          <target state="translated">HTML 사양의 일부 최신 버전에서는 필드 값을 제공해야하는 순서가 명시되어 있지만, 요청이 적합한 브라우저에서 수신되었는지 또는 전혀 브라우저에서 수신되었는지를 아는 것은 지루하고 오류가 발생하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="e49765d68859e961a6e270321dec95f459b3abf4" translate="yes" xml:space="preserve">
          <source>Note that some systems might support ancillary data without providing this function. Also note that setting the buffer size using the results of this function may not precisely limit the amount of ancillary data that can be received, since additional data may be able to fit into the padding area.</source>
          <target state="translated">일부 시스템은이 기능을 제공하지 않고 보조 데이터를 지원할 수 있습니다. 또한이 기능의 결과를 사용하여 버퍼 크기를 설정하면 추가 데이터가 패딩 영역에 들어갈 수 있으므로 수신 할 수있는 보조 데이터의 양이 정확하게 제한되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa8a9295a9dbce0828c8e847a08e997833350743" translate="yes" xml:space="preserve">
          <source>Note that tabs and spaces are both treated as whitespace, but they are not equal: the lines &lt;code&gt;&quot;&amp;nbsp; hello&quot;&lt;/code&gt; and &lt;code&gt;&quot;\thello&quot;&lt;/code&gt; are considered to have no common leading whitespace.</source>
          <target state="translated">탭과 공백은 모두 공백으로 취급되지만 동일하지는 않습니다. &lt;code&gt;&quot;&amp;nbsp; hello&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;\thello&quot;&lt;/code&gt; 에는 공통 선행 공백이없는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d9458e3f856c8568d276b2ccc17c59d5c9e0de3b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; instances that differ only by the value of the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute are considered equal in comparisons.</source>
          <target state="translated">주의 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 의 값으로 만 다를 경우 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 특성 비교가 동일한 것으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="6e00171800132e17b717121535b8def5b8c707ca" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt;&lt;code&gt;join()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt;&lt;code&gt;exitcode&lt;/code&gt;&lt;/a&gt; methods should only be called by the process that created the process object.</source>
          <target state="translated">주의 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.join&quot;&gt; &lt;code&gt;join()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.Process.exitcode&quot;&gt; &lt;code&gt;exitcode&lt;/code&gt; &lt;/a&gt; 방법은 처리 객체를 생성하는 프로세스에 의해 호출되어야한다.</target>
        </trans-unit>
        <trans-unit id="76be1da5963fc00b55ce37e0edfebe2ece5a230b" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;save()&lt;/code&gt; method won&amp;rsquo;t save session cookies anyway, unless you ask otherwise by passing a true &lt;em&gt;ignore_discard&lt;/em&gt; argument.</source>
          <target state="translated">참고 그 &lt;code&gt;save()&lt;/code&gt; 방법이 아니다 세션 쿠키 저장 어쨌든 것입니다, 당신은 진정한 전달하여 달리 요청하지 않는 &lt;em&gt;ignore_discard의&lt;/em&gt; 인수를.</target>
        </trans-unit>
        <trans-unit id="8d128adeddb15c243a31ce0c09ab30c3100bf9aa" translate="yes" xml:space="preserve">
          <source>Note that the application code and tag bindings can set the selection however they wish, regardless of the value of this option.</source>
          <target state="translated">응용 프로그램 코드 및 태그 바인딩은이 옵션의 값에 관계없이 원하는대로 선택을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c688652d419206207ca4fcfbba08a17cc1b4d53" translate="yes" xml:space="preserve">
          <source>Note that the audited arguments may not match the names or positions required by the initializer.</source>
          <target state="translated">감사 된 인수는 이니셜 라이저에 필요한 이름 또는 위치와 일치하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c830f23c52b697abf037e27edcdf6e7c6b75ed04" translate="yes" xml:space="preserve">
          <source>Note that the audited arguments may not match the names or positions required by the initializer. The audit event only occurs for direct instantiation of code objects, and is not raised for normal compilation.</source>
          <target state="translated">감사 된 인수는 이니셜 라이저에 필요한 이름 또는 위치와 일치하지 않을 수 있습니다. 감사 이벤트는 코드 개체의 직접 인스턴스화에만 발생하며 일반 컴파일에는 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1deb77e6b0aedeb954896c3aa4ddbd679ed1b4d5" translate="yes" xml:space="preserve">
          <source>Note that the behaviour of &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt;&lt;code&gt;set_event_loop()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#asyncio.new_event_loop&quot;&gt;&lt;code&gt;new_event_loop()&lt;/code&gt;&lt;/a&gt; functions can be altered by &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;setting a custom event loop policy&lt;/a&gt;.</source>
          <target state="translated">의 행동주의 &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.set_event_loop&quot;&gt; &lt;code&gt;set_event_loop()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#asyncio.new_event_loop&quot;&gt; &lt;code&gt;new_event_loop()&lt;/code&gt; &lt;/a&gt; 함수에 의해 변경 될 수 있습니다 &lt;a href=&quot;asyncio-policy#asyncio-policies&quot;&gt;사용자 정의 이벤트 루프 정책을 설정&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c66dde87415197d1cc25303a3cb3f7fea45cb7cf" translate="yes" xml:space="preserve">
          <source>Note that the callable will get its parameters as Python bytestrings, which will normally be encoded in UTF-8.</source>
          <target state="translated">호출 가능 변수는 일반적으로 UTF-8로 인코딩되는 Python 바이트 문자열로 매개 변수를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e0ce1087d446a80a298883ee298079809ee68d3a" translate="yes" xml:space="preserve">
          <source>Note that the decorators are applied from the bottom upwards. This is the standard way that Python applies decorators. The order of the created mocks passed into your test function matches this order.</source>
          <target state="translated">데코레이터는 아래쪽에서 위쪽으로 적용됩니다. 이것은 파이썬이 데코레이터를 적용하는 표준 방식입니다. 테스트 함수에 전달 된 작성된 모의 순서는이 순서와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e97d1070ca60575742bafcaf80da75c01c5d2f24" translate="yes" xml:space="preserve">
          <source>Note that the default &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt;&lt;code&gt;tzinfo.fromutc()&lt;/code&gt;&lt;/a&gt; method can be overridden in a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass to affect the result returned by &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt;&lt;code&gt;astimezone()&lt;/code&gt;&lt;/a&gt;. Ignoring error cases, &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt;&lt;code&gt;astimezone()&lt;/code&gt;&lt;/a&gt; acts like:</source>
          <target state="translated">기본 &lt;a href=&quot;#datetime.tzinfo.fromutc&quot;&gt; &lt;code&gt;tzinfo.fromutc()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 에서 대체되어 &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt; &lt;code&gt;astimezone()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 결과에 영향을 줄 수 있습니다 . 오류 사례를 무시 &lt;a href=&quot;#datetime.datetime.astimezone&quot;&gt; &lt;code&gt;astimezone()&lt;/code&gt; &lt;/a&gt; 와 같은 역할을합니다 :</target>
        </trans-unit>
        <trans-unit id="1cdde200b54fdac2ca71696d1fcd9ec16758fa9f" translate="yes" xml:space="preserve">
          <source>Note that the end positions are not required by the compiler and are therefore optional. The end offset is &lt;em&gt;after&lt;/em&gt; the last symbol, for example one can get the source segment of a one-line expression node using &lt;code&gt;source_line[node.col_offset : node.end_col_offset]&lt;/code&gt;.</source>
          <target state="translated">종료 위치는 컴파일러에 필요하지 않으므로 선택 사항입니다. 종료 오프셋은 마지막 심볼 &lt;em&gt;뒤에&lt;/em&gt; 있습니다. 예를 들어 &lt;code&gt;source_line[node.col_offset : node.end_col_offset]&lt;/code&gt; 사용하여 한 줄 표현식 노드의 소스 세그먼트를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eec0865e31dfa1bea83fd13d92d1b7c2e61986db" translate="yes" xml:space="preserve">
          <source>Note that the exact contents of code info strings are highly implementation dependent and they may change arbitrarily across Python VMs or Python releases.</source>
          <target state="translated">코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 Python VM 또는 Python 릴리스에서 임의로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="164b1f59a18e5c8abf18fac5ba8c576d24f04885" translate="yes" xml:space="preserve">
          <source>Note that the exact times you set here may not be returned by a subsequent &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt; call, depending on the resolution with which your operating system records access and modification times; see &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;. The best way to preserve exact times is to use the &lt;em&gt;st_atime_ns&lt;/em&gt; and &lt;em&gt;st_mtime_ns&lt;/em&gt; fields from the &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; result object with the &lt;em&gt;ns&lt;/em&gt; parameter to &lt;code&gt;utime&lt;/code&gt;.</source>
          <target state="translated">여기에서 설정 한 정확한 시간 은 운영 체제가 액세스 및 수정 시간을 기록하는 해상도에 따라 후속 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 호출 로 반환되지 않을 수 있습니다 . &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 참조하십시오 . 정확한 시간을 유지하는 가장 좋은 방법 은 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 결과 객체 의 &lt;em&gt;st_atime_ns&lt;/em&gt; 및 &lt;em&gt;st_mtime_ns&lt;/em&gt; 필드를 &lt;em&gt;ns&lt;/em&gt; 매개 변수 와 함께 &lt;code&gt;utime&lt;/code&gt; 에 사용하는 것 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0b5bbdf77d63ecd9abde1ce3e6def80c3014baa1" translate="yes" xml:space="preserve">
          <source>Note that the exponent is written in decimal rather than hexadecimal, and that it gives the power of 2 by which to multiply the coefficient. For example, the hexadecimal string &lt;code&gt;0x3.a7p10&lt;/code&gt; represents the floating-point number &lt;code&gt;(3 + 10./16 + 7./16**2) * 2.0**10&lt;/code&gt;, or &lt;code&gt;3740.0&lt;/code&gt;:</source>
          <target state="translated">지수는 16 진수가 아닌 10 진수로 기록되며 계수를 곱하는 2의 거듭 제곱을 제공합니다. 예를 들어, 16 진 문자열 &lt;code&gt;0x3.a7p10&lt;/code&gt; 은 부동 소수점 숫자 &lt;code&gt;(3 + 10./16 + 7./16**2) * 2.0**10&lt;/code&gt; 또는 &lt;code&gt;3740.0&lt;/code&gt; 을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="eabb40ec8d9514ff31867d76604ec09c63b3f62f" translate="yes" xml:space="preserve">
          <source>Note that the file is always opened in binary mode. To open a compressed file in text mode, use &lt;a href=&quot;#gzip.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; (or wrap your &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt;&lt;code&gt;io.TextIOWrapper&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">파일은 항상 이진 모드로 열립니다. 텍스트 모드에서 압축 파일을 &lt;a href=&quot;#gzip.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 사용 하십시오 (또는 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;io#io.TextIOWrapper&quot;&gt; &lt;code&gt;io.TextIOWrapper&lt;/code&gt; 로&lt;/a&gt; 감싸십시오 ).</target>
        </trans-unit>
        <trans-unit id="2d4d5de3b61f6ba7f6afbe52eb7e703b5895b919" translate="yes" xml:space="preserve">
          <source>Note that the filename separator (&lt;code&gt;'/'&lt;/code&gt; on Unix) is &lt;em&gt;not&lt;/em&gt; special to this module. See module &lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; for pathname expansion (&lt;a href=&quot;glob#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;#fnmatch.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; to match pathname segments). Similarly, filenames starting with a period are not special for this module, and are matched by the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt; patterns.</source>
          <target state="translated">파일 이름 구분 기호 ( UNIX의 경우 &lt;code&gt;'/'&lt;/code&gt; )는 이 모듈에 특별 &lt;em&gt;하지 않습니다&lt;/em&gt; . 경로 이름 확장에 대해서는 모듈 &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 ( &lt;a href=&quot;glob#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#fnmatch.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 경로 이름 세그먼트를 일치시킵니다). 마찬가지로 마침표로 시작하는 파일 이름은이 모듈에서 특별하지 않으며 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;?&lt;/code&gt; 패턴.</target>
        </trans-unit>
        <trans-unit id="1992a5171785db5fc3c20b9338bd90d43b3a8008" translate="yes" xml:space="preserve">
          <source>Note that the first type annotation must be enclosed in quotes, making it a &amp;ldquo;forward reference&amp;rdquo;, to hide the &lt;code&gt;expensive_mod&lt;/code&gt; reference from the interpreter runtime. Type annotations for local variables are not evaluated, so the second annotation does not need to be enclosed in quotes.</source>
          <target state="translated">인터프리터 런타임에서 &lt;code&gt;expensive_mod&lt;/code&gt; 참조 를 숨기려면 첫 번째 유형 어노테이션을 따옴표로 묶어야하며&amp;ldquo;앞으로 참조&amp;rdquo;해야 합니다. 지역 변수에 대한 유형 주석은 평가되지 않으므로 두 번째 주석은 따옴표로 묶을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="59a1de269ac77e8f64ef50ba801d5c66b9db1422" translate="yes" xml:space="preserve">
          <source>Note that the functions &lt;a href=&quot;#parser.compilest&quot;&gt;&lt;code&gt;compilest()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; may raise exceptions which are normally raised by the parsing and compilation process. These include the built in exceptions &lt;a href=&quot;exceptions#MemoryError&quot;&gt;&lt;code&gt;MemoryError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#OverflowError&quot;&gt;&lt;code&gt;OverflowError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;exceptions#SystemError&quot;&gt;&lt;code&gt;SystemError&lt;/code&gt;&lt;/a&gt;. In these cases, these exceptions carry all the meaning normally associated with them. Refer to the descriptions of each function for detailed information.</source>
          <target state="translated">&lt;a href=&quot;#parser.compilest&quot;&gt; &lt;code&gt;compilest()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 함수 는 일반적으로 구문 분석 및 컴파일 프로세스에서 발생하는 예외를 발생시킬 수 있습니다. 여기에는 내장 예외 &lt;a href=&quot;exceptions#MemoryError&quot;&gt; &lt;code&gt;MemoryError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#OverflowError&quot;&gt; &lt;code&gt;OverflowError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#SystemError&quot;&gt; &lt;code&gt;SystemError&lt;/code&gt; 가 포함&lt;/a&gt; 됩니다. 이 경우 이러한 예외는 일반적으로 관련된 모든 의미를 지닙니다. 자세한 정보는 각 기능의 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cba8c1dab1231c0e020d29f555ee5fe18e0dc2a0" translate="yes" xml:space="preserve">
          <source>Note that the global side effect on &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; means that this context manager is not suitable for use in library code and most threaded applications. It also has no effect on the output of subprocesses. However, it is still a useful approach for many utility scripts.</source>
          <target state="translated">&lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 의 글로벌 부작용 은이 컨텍스트 관리자가 라이브러리 코드 및 대부분의 스레드 응용 프로그램에 사용하기에 적합하지 않음을 의미합니다. 또한 서브 프로세스의 출력에는 영향을 미치지 않습니다. 그러나 여전히 많은 유틸리티 스크립트에 유용한 접근 방식입니다.</target>
        </trans-unit>
        <trans-unit id="256291afcdf663f4ee7f5d169948e8c4e068a3ea" translate="yes" xml:space="preserve">
          <source>Note that the implementation of these methods may involve calls of the parent &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt;&lt;code&gt;error()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">이러한 메소드를 구현하려면 상위 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 인스턴스의 &lt;a href=&quot;#urllib.request.OpenerDirector.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.OpenerDirector.error&quot;&gt; &lt;code&gt;error()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="db96e2903bb03526d487ef5f0e7a28904d91b153" translate="yes" xml:space="preserve">
          <source>Note that the last tuple returned by &lt;code&gt;get_matching_blocks()&lt;/code&gt; is always a dummy, &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt;, and this is the only case in which the last tuple element (number of elements matched) is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get_matching_blocks()&lt;/code&gt; 의해 반환 된 마지막 튜플 은 항상 더미 &lt;code&gt;(len(a), len(b), 0)&lt;/code&gt; 이며 마지막 튜플 요소 (일치하는 요소 수)가 &lt;code&gt;0&lt;/code&gt; 인 유일한 경우입니다 .</target>
        </trans-unit>
        <trans-unit id="5d9efcbb8db4d5059e437fd61cf5752e8f008ac4" translate="yes" xml:space="preserve">
          <source>Note that the length of this list must be seven items.</source>
          <target state="translated">이 목록의 길이는 7 개의 항목이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cc6ae65cf6a2c6b690528b4be599e5bed47ef7e9" translate="yes" xml:space="preserve">
          <source>Note that the locator will return correct information only during the invocation of the events in this interface. The application should not attempt to use it at any other time.</source>
          <target state="translated">로케이터는이 인터페이스에서 이벤트를 호출하는 동안에 만 올바른 정보를 리턴합니다. 응용 프로그램은 다른 시간에 응용 프로그램을 사용하려고 시도해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4e632c3015ab8a0ba3453634da1b41b96d4c11e9" translate="yes" xml:space="preserve">
          <source>Note that the man pages list &amp;ldquo;STANDARD OPTIONS&amp;rdquo; and &amp;ldquo;WIDGET SPECIFIC OPTIONS&amp;rdquo; for each widget. The former is a list of options that are common to many widgets, the latter are the options that are idiosyncratic to that particular widget. The Standard Options are documented on the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/options(3)&quot;&gt;options(3)&lt;/a&gt;&lt;/em&gt; man page.</source>
          <target state="translated">매뉴얼 페이지에는 각 위젯에 대한 &quot;표준 옵션&quot;및 &quot;WIDGET 특정 옵션&quot;이 나열되어 있습니다. 전자는 많은 위젯에 공통적 인 옵션 목록이며, 후자는 해당 특정 위젯과 고유 한 옵션입니다. 표준 옵션은 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/options(3)&quot;&gt;options (3)&lt;/a&gt;&lt;/em&gt; 매뉴얼 페이지에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aa16e828033b4f45947239c8dad63dfd83cf58b" translate="yes" xml:space="preserve">
          <source>Note that the methods of a pool should only ever be used by the process which created it.</source>
          <target state="translated">풀의 메소드는 풀을 작성한 프로세스에서만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="403f74ccffe9160e93df16ee60fb1936940a68d7" translate="yes" xml:space="preserve">
          <source>Note that the methods of the pool object should only be called by the process which created the pool.</source>
          <target state="translated">풀 객체의 메서드는 풀을 만든 프로세스에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="072ef7e2339f223029bd2baf38337de36c7889d9" translate="yes" xml:space="preserve">
          <source>Note that the object name, &lt;code&gt;.fred&lt;/code&gt;, starts with a dot.</source>
          <target state="translated">객체 이름 &lt;code&gt;.fred&lt;/code&gt; 는 점으로 시작합니다.</target>
        </trans-unit>
        <trans-unit id="dd5e150e0b095725b6075fcce13020fbe7fbe7d6" translate="yes" xml:space="preserve">
          <source>Note that the object returned by &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will only contain attributes for the main parser and the subparser that was selected by the command line (and not any other subparsers). So in the example above, when the &lt;code&gt;a&lt;/code&gt; command is specified, only the &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; attributes are present, and when the &lt;code&gt;b&lt;/code&gt; command is specified, only the &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt; attributes are present.</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 의해 리턴 된 오브젝트 는 기본 구문 분석기 및 명령 행에 의해 선택된 서브 파서 (다른 서브 파서는 아님)에 대한 속성 만 포함합니다. 따라서 위 예에서 &lt;code&gt;a&lt;/code&gt; 명령이 지정되면 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;bar&lt;/code&gt; 속성 만 존재하고 &lt;code&gt;b&lt;/code&gt; 명령이 지정되면 &lt;code&gt;foo&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 속성 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="833ae3938a6f5fe64221af69a439e4759ab70b12" translate="yes" xml:space="preserve">
          <source>Note that the order of the (states, value) sequences for an option does matter, if the order is changed to &lt;code&gt;[('active', 'blue'), ('pressed',
'red')]&lt;/code&gt; in the foreground option, for example, the result would be a blue foreground when the widget were in active or pressed states.</source>
          <target state="translated">전경 옵션에서 순서가 &lt;code&gt;[('active', 'blue'), ('pressed', 'red')]&lt;/code&gt; 로 변경되면 옵션에 대한 (상태, 값) 순서의 순서는 중요합니다. 예를 들어, 위젯이 활성 상태이거나 눌린 상태 일 때 결과는 파란색 전경이됩니다.</target>
        </trans-unit>
        <trans-unit id="01a23cd9ecbf3257e28cf9b896b0dcad21defe07" translate="yes" xml:space="preserve">
          <source>Note that the parser can be extended in limited ways, and of course you can implement your own parser completely from scratch. All of the logic that connects the &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s bundled parser and the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class is embodied in the &lt;code&gt;policy&lt;/code&gt; class, so a custom parser can create message object trees any way it finds necessary by implementing custom versions of the appropriate &lt;code&gt;policy&lt;/code&gt; methods.</source>
          <target state="translated">파서는 제한적인 방식으로 확장 될 수 있으며 물론 파서는 처음부터 완전히 구현할 수 있습니다. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 번들 파서와 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 클래스 를 연결하는 모든 논리 는 &lt;code&gt;policy&lt;/code&gt; 클래스에 구현되어 있으므로 사용자 정의 파서는 적절한 &lt;code&gt;policy&lt;/code&gt; 방법 의 사용자 정의 버전을 구현하여 원하는 방식으로 메시지 객체 트리를 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1eb8965b25ea5257a0aa1f9f0bb3c11a3367f9de" translate="yes" xml:space="preserve">
          <source>Note that the parser only accepts the Unix-style end of line convention. If you are reading the code from a file, make sure to use newline conversion mode to convert Windows or Mac-style newlines.</source>
          <target state="translated">파서는 유닉스 스타일의 End of Line 규칙 만 받아들입니다. 파일에서 코드를 읽는 경우 개행 변환 모드를 사용하여 Windows 또는 Mac 스타일 개행을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="34bc7518b3bc42848108ade424e482f1e8016982" translate="yes" xml:space="preserve">
          <source>Note that the program name, whether determined from &lt;code&gt;sys.argv[0]&lt;/code&gt; or from the &lt;code&gt;prog=&lt;/code&gt; argument, is available to help messages using the &lt;code&gt;%(prog)s&lt;/code&gt; format specifier.</source>
          <target state="translated">&lt;code&gt;sys.argv[0]&lt;/code&gt; 또는 &lt;code&gt;prog=&lt;/code&gt; 인수 에서 판별 된 프로그램 이름 은 &lt;code&gt;%(prog)s&lt;/code&gt; 형식 지정자를 사용하여 메시지를 돕기 위해 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="b19c49eed7c2426d8842fd07e5e1a3d9193ed340" translate="yes" xml:space="preserve">
          <source>Note that the second use of &lt;code&gt;_()&lt;/code&gt; will not identify &amp;ldquo;a&amp;rdquo; as being translatable to the &lt;strong&gt;gettext&lt;/strong&gt; program, because the parameter is not a string literal.</source>
          <target state="translated">&lt;code&gt;_()&lt;/code&gt; 의 두 번째 사용은 매개 변수가 문자열 리터럴이 아니기 때문에 &quot;a&quot;를 &lt;strong&gt;gettext&lt;/strong&gt; 프로그램 으로 변환 할 수있는 것으로 식별 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="750397ea45aa11b67082fae179f2b2c630c4ca79" translate="yes" xml:space="preserve">
          <source>Note that the selection of functions is similar, but not identical, to that in module &lt;a href=&quot;math#module-math&quot;&gt;&lt;code&gt;math&lt;/code&gt;&lt;/a&gt;. The reason for having two modules is that some users aren&amp;rsquo;t interested in complex numbers, and perhaps don&amp;rsquo;t even know what they are. They would rather have &lt;code&gt;math.sqrt(-1)&lt;/code&gt; raise an exception than return a complex number. Also note that the functions defined in &lt;a href=&quot;#module-cmath&quot;&gt;&lt;code&gt;cmath&lt;/code&gt;&lt;/a&gt; always return a complex number, even if the answer can be expressed as a real number (in which case the complex number has an imaginary part of zero).</source>
          <target state="translated">함수 선택은 &lt;a href=&quot;math#module-math&quot;&gt; &lt;code&gt;math&lt;/code&gt; &lt;/a&gt; 모듈과 유사하지만 동일하지는 않습니다 . 두 개의 모듈을 사용하는 이유는 일부 사용자가 복잡한 숫자에 관심이없고 자신이 무엇인지 모르기 때문입니다. 오히려 &lt;code&gt;math.sqrt(-1)&lt;/code&gt; 가 복소수를 반환하는 것보다 예외를 발생시킵니다. 또한 답을 실수로 표현할 수있는 경우에도 &lt;a href=&quot;#module-cmath&quot;&gt; &lt;code&gt;cmath&lt;/code&gt; 에&lt;/a&gt; 정의 된 함수는 항상 복소수를 반환합니다 (이 경우 복소수의 허수 부분은 0 임).</target>
        </trans-unit>
        <trans-unit id="81dcea5e7b8c2cdc13cbbc4c1f112a24bc49255e" translate="yes" xml:space="preserve">
          <source>Note that the sign of the timezone offset is the opposite of the sign of the &lt;code&gt;time.timezone&lt;/code&gt; variable for the same timezone; the latter variable follows the POSIX standard while this module follows &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">시간대 오프셋의 부호 는 동일한 시간대에 대한 &lt;code&gt;time.timezone&lt;/code&gt; 변수 의 부호와 반대입니다 . 후자의 변수는 POSIX 표준을 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;따르고이&lt;/strong&gt;&lt;/a&gt; 모듈은 &lt;strong&gt;RFC 2822를&lt;/strong&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="e162688246d240a8c716dca372b82c4250936fa7" translate="yes" xml:space="preserve">
          <source>Note that the two instances of class &lt;code&gt;C&lt;/code&gt; share the same class variable &lt;code&gt;x&lt;/code&gt;, as expected.</source>
          <target state="translated">클래스 &lt;code&gt;C&lt;/code&gt; 의 두 인스턴스는 예상대로 동일한 클래스 변수 &lt;code&gt;x&lt;/code&gt; 를 공유합니다 .</target>
        </trans-unit>
        <trans-unit id="cd586d754c27e8997ced1a5ea4a1abad329acacc" translate="yes" xml:space="preserve">
          <source>Note that the type of &lt;a href=&quot;#abc.ABC&quot;&gt;&lt;code&gt;ABC&lt;/code&gt;&lt;/a&gt; is still &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt;, therefore inheriting from &lt;a href=&quot;#abc.ABC&quot;&gt;&lt;code&gt;ABC&lt;/code&gt;&lt;/a&gt; requires the usual precautions regarding metaclass usage, as multiple inheritance may lead to metaclass conflicts. One may also define an abstract base class by passing the metaclass keyword and using &lt;a href=&quot;#abc.ABCMeta&quot;&gt;&lt;code&gt;ABCMeta&lt;/code&gt;&lt;/a&gt; directly, for example:</source>
          <target state="translated">&lt;a href=&quot;#abc.ABC&quot;&gt; &lt;code&gt;ABC&lt;/code&gt; &lt;/a&gt; 유형 은 여전히 &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; &lt;/a&gt; 이므로 다중 상속이 메타 클래스 충돌을 일으킬 수 있으므로 &lt;a href=&quot;#abc.ABC&quot;&gt; &lt;code&gt;ABC&lt;/code&gt; &lt;/a&gt; 에서 상속 하려면 메타 클래스 사용에 관한 일반적인 예방 조치가 필요합니다. 메타 클래스 키워드를 전달하고 &lt;a href=&quot;#abc.ABCMeta&quot;&gt; &lt;code&gt;ABCMeta&lt;/code&gt; 를&lt;/a&gt; 직접 사용하여 추상 기본 클래스를 정의 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2fc591820a47265f251fd7af3b9597e91511cf6a" translate="yes" xml:space="preserve">
          <source>Note that there are no methods &lt;code&gt;read()&lt;/code&gt; or &lt;code&gt;write()&lt;/code&gt;; use &lt;a href=&quot;#socket.socket.recv&quot;&gt;&lt;code&gt;recv()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.socket.send&quot;&gt;&lt;code&gt;send()&lt;/code&gt;&lt;/a&gt; without &lt;em&gt;flags&lt;/em&gt; argument instead.</source>
          <target state="translated">&lt;code&gt;read()&lt;/code&gt; 또는 &lt;code&gt;write()&lt;/code&gt; 메소드는 없습니다 . 사용 &lt;a href=&quot;#socket.socket.recv&quot;&gt; &lt;code&gt;recv()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.socket.send&quot;&gt; &lt;code&gt;send()&lt;/code&gt; &lt;/a&gt; 없이 &lt;em&gt;플래그&lt;/em&gt; 대신 인수.</target>
        </trans-unit>
        <trans-unit id="36630936cce6573d3d4dc4a543a2ef65fc12897f" translate="yes" xml:space="preserve">
          <source>Note that there are unavoidable subtleties twice per year in a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass accounting for both standard and daylight time, at the DST transition points. For concreteness, consider US Eastern (UTC -0500), where EDT begins the minute after 1:59 (EST) on the second Sunday in March, and ends the minute after 1:59 (EDT) on the first Sunday in November:</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스에서는 DST 전환 지점에서 표준 및 일광 시간을 모두 고려 하여 매년 두 번 피할 수없는 미묘함이 있습니다 . 구체적으로, EDT는 3 월 둘째 일요일 1시 59 분 (EST) 이후에 시작되고 11 월 첫째 일요일 1시 59 분 (EDT) 이후에 끝나는 미국 동부 (UTC -0500)를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="15592c72a8f6f854d7f0dbccf4a1703e76bd673a" translate="yes" xml:space="preserve">
          <source>Note that there is a nice correspondence between several attributes and methods of &lt;code&gt;os.DirEntry&lt;/code&gt; and of &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt;. In particular, the &lt;code&gt;name&lt;/code&gt; attribute has the same meaning, as do the &lt;code&gt;is_dir()&lt;/code&gt;, &lt;code&gt;is_file()&lt;/code&gt;, &lt;code&gt;is_symlink()&lt;/code&gt; and &lt;code&gt;stat()&lt;/code&gt; methods.</source>
          <target state="translated">참고 여러 속성과 방법 사이의 좋은 대응이 있음을 &lt;code&gt;os.DirEntry&lt;/code&gt; 와의 &lt;a href=&quot;pathlib#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; 은&lt;/a&gt; . 특히 &lt;code&gt;name&lt;/code&gt; 속성은 &lt;code&gt;is_dir()&lt;/code&gt; , &lt;code&gt;is_file()&lt;/code&gt; , &lt;code&gt;is_symlink()&lt;/code&gt; 및 &lt;code&gt;stat()&lt;/code&gt; 메소드 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8df01b5cba256bfe26308cfbe1ebdc3f6c2def0b" translate="yes" xml:space="preserve">
          <source>Note that there is no need to call this function when &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 을 사용할 때이 함수를 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b57144e5df9df62e17e080fadafa48aa0596258b" translate="yes" xml:space="preserve">
          <source>Note that there is no specific slot for any of these methods in the type structure for Python objects in the Python/C API. Extension types wanting to define these methods must provide them as a normal Python accessible method. Compared to the overhead of setting up the runtime context, the overhead of a single class dictionary lookup is negligible.</source>
          <target state="translated">Python / C API에서 Python 객체의 유형 구조에는 이러한 메소드에 대한 특정 슬롯이 없습니다. 이러한 메소드를 정의하려는 확장 유형은 일반적인 Python 액세스 가능 메소드로 제공해야합니다. 런타임 컨텍스트를 설정하는 오버 헤드와 비교할 때 단일 클래스 사전 검색의 오버 헤드는 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a02df7e02b3ab3b4f010591f5ece20d6e24dd6b" translate="yes" xml:space="preserve">
          <source>Note that there is one additional limitation when using context managers as function decorators: there&amp;rsquo;s no way to access the return value of &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt;. If that value is needed, then it is still necessary to use an explicit &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">컨텍스트 관리자를 함수 데코레이터로 사용하는 경우 한 가지 추가 제한 사항이 있습니다. 반환 값 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 에 액세스 할 수있는 방법이 없습니다 . 해당 값이 필요한 경우 명시 적 &lt;code&gt;with&lt;/code&gt; 문 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fde38b61d1d62820ebcfd27fe4d5d63de63de348" translate="yes" xml:space="preserve">
          <source>Note that there is one additional limitation when using context managers as function decorators: there&amp;rsquo;s no way to access the return value of &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt;. If that value is needed, then it is still necessary to use an explicit &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">컨텍스트 관리자를 함수 데코레이터로 사용할 때 한 가지 추가 제한 사항이 있습니다 . &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 의 반환 값에 액세스 할 방법이 없습니다 . 해당 값이 필요한 경우 명시 적 &lt;code&gt;with&lt;/code&gt; 문 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1a0bc324af393bbb5dd82800c76c036cbda0f5f" translate="yes" xml:space="preserve">
          <source>Note that these checks are enforced only by the static type checker. At runtime, the statement &lt;code&gt;Derived = NewType('Derived', Base)&lt;/code&gt; will make &lt;code&gt;Derived&lt;/code&gt; a function that immediately returns whatever parameter you pass it. That means the expression &lt;code&gt;Derived(some_value)&lt;/code&gt; does not create a new class or introduce any overhead beyond that of a regular function call.</source>
          <target state="translated">이러한 검사는 정적 유형 검사기에서만 시행됩니다. 런타임에 &lt;code&gt;Derived = NewType('Derived', Base)&lt;/code&gt; 은 &lt;code&gt;Derived&lt;/code&gt; 를 전달한 매개 변수를 즉시 반환하는 함수로 만듭니다 . 이는 &lt;code&gt;Derived(some_value)&lt;/code&gt; 표현식 이 새 클래스를 작성하지 않거나 일반 함수 호출보다 오버 헤드를 발생시키지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="472bb74ea73045e483510b2cd999d2e021bf1acc" translate="yes" xml:space="preserve">
          <source>Note that these functions are not meaningful for a multipart message. They must be applied to individual subparts instead, and will raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if passed a message whose type is multipart.</source>
          <target state="translated">이러한 기능은 멀티 파트 메시지에는 의미가 없습니다. 그것들은 대신 개별 서브 파트에 적용되어야하며 , 유형이 멀티 파트 인 메시지를 전달하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="30d1675de10cd2d2ad0bc712bec13688a9a6c970" translate="yes" xml:space="preserve">
          <source>Note that these methods must &lt;em&gt;not&lt;/em&gt; be called during parsing, that is, after parse has been called and before it returns.</source>
          <target state="translated">이러한 방법이 있어야합니다 &lt;em&gt;하지&lt;/em&gt; 파스가 호출 된 후,이다 분석, 동안 그것을 반환하기 전에 호출.</target>
        </trans-unit>
        <trans-unit id="d29fa93c8852c067f1d3f1f3ca06f2de2869049f" translate="yes" xml:space="preserve">
          <source>Note that this adds a sixth attribute (&lt;a href=&quot;#platform.processor&quot;&gt;&lt;code&gt;processor&lt;/code&gt;&lt;/a&gt;) not present in the &lt;a href=&quot;os#os.uname&quot;&gt;&lt;code&gt;os.uname()&lt;/code&gt;&lt;/a&gt; result. Also, the attribute names are different for the first two attributes; &lt;a href=&quot;os#os.uname&quot;&gt;&lt;code&gt;os.uname()&lt;/code&gt;&lt;/a&gt; names them &lt;code&gt;sysname&lt;/code&gt; and &lt;code&gt;nodename&lt;/code&gt;.</source>
          <target state="translated">이는 &lt;a href=&quot;os#os.uname&quot;&gt; &lt;code&gt;os.uname()&lt;/code&gt; &lt;/a&gt; 결과 에없는 여섯 번째 속성 ( &lt;a href=&quot;#platform.processor&quot;&gt; &lt;code&gt;processor&lt;/code&gt; &lt;/a&gt; )을 추가합니다 . 또한 속성 이름은 처음 두 속성마다 다릅니다. &lt;a href=&quot;os#os.uname&quot;&gt; &lt;code&gt;os.uname()&lt;/code&gt; &lt;/a&gt; 이름을 &lt;code&gt;sysname&lt;/code&gt; 과 &lt;code&gt;nodename&lt;/code&gt; 으로 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="2d46886958797cfa9907ad4c6425e0ae6791da66" translate="yes" xml:space="preserve">
          <source>Note that this does &lt;em&gt;not&lt;/em&gt; overwrite or delete any existing header with the same name. If you want to ensure that the new header is the only one present in the message with field name &lt;em&gt;name&lt;/em&gt;, delete the field first, e.g.:</source>
          <target state="translated">동일한 이름의 기존 헤더를 덮어 쓰거나 삭제 하지는 &lt;em&gt;않습니다&lt;/em&gt; . 필드 이름이 &lt;em&gt;name&lt;/em&gt; 인 메시지에 새 헤더 만있는 것을 확인 하려면 먼저 필드를 삭제하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="b79b943f472b0275b7ad6a51da0c669884bba25f" translate="yes" xml:space="preserve">
          <source>Note that this function &lt;em&gt;only&lt;/em&gt; returns a meaningful name for actual Python modules - paths that potentially refer to Python packages will still return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 함수 는 실제 Python 모듈에 대해 의미있는 이름 &lt;em&gt;만&lt;/em&gt; 반환합니다. 잠재적으로 Python 패키지를 참조하는 경로는 여전히 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1e5f27a50e7211ff256009dee22a78b6d7a48364" translate="yes" xml:space="preserve">
          <source>Note that this function does not raise &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt;&lt;code&gt;asyncio.TimeoutError&lt;/code&gt;&lt;/a&gt;. Futures or Tasks that aren&amp;rsquo;t done when the timeout occurs are simply returned in the second set.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;asyncio-exceptions#asyncio.TimeoutError&quot;&gt; &lt;code&gt;asyncio.TimeoutError&lt;/code&gt; 를 발생&lt;/a&gt; 시키지 않습니다 . 타임 아웃이 발생했을 때 완료되지 않은 선물 또는 작업은 단순히 두 번째 세트로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f6e96664f646c10e89d795c433800d7c1e4544c3" translate="yes" xml:space="preserve">
          <source>Note that this function has intimate knowledge of how different libc versions add symbols to the executable is probably only usable for executables compiled using &lt;strong&gt;gcc&lt;/strong&gt;.</source>
          <target state="translated">이 함수는 다른 libc 버전이 실행 파일에 심볼을 추가하는 방법에 대한 친밀한 지식을 가지고 있으며 아마도 &lt;strong&gt;gcc를&lt;/strong&gt; 사용하여 컴파일 된 실행 파일에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45f629527ef98fcd33c266ca1c4678e0ef5157a6" translate="yes" xml:space="preserve">
          <source>Note that this function must import all &lt;em&gt;packages&lt;/em&gt; (&lt;em&gt;not&lt;/em&gt; all modules!) on the given &lt;em&gt;path&lt;/em&gt;, in order to access the &lt;code&gt;__path__&lt;/code&gt; attribute to find submodules.</source>
          <target state="translated">이 기능은 모든 수입해야합니다 &lt;em&gt;패키지&lt;/em&gt; ( &lt;em&gt;하지&lt;/em&gt; 주어진 모든 모듈을!) &lt;em&gt;경로에&lt;/em&gt; 액세스하기 위해, &lt;code&gt;__path__&lt;/code&gt; 서브 모듈을 찾을 속성을.</target>
        </trans-unit>
        <trans-unit id="a589457ce4b7eed1abc8c3023b9a61ab3a1a55e6" translate="yes" xml:space="preserve">
          <source>Note that this function will not work with the &amp;lsquo;C&amp;rsquo; locale, so you have to set a locale via &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; first.</source>
          <target state="translated">이 함수는 'C'로케일에서 작동하지 않으므로 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 통해 로케일을 먼저 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c7fbd744392c36926075a26d9e3ab559ef32a1e2" translate="yes" xml:space="preserve">
          <source>Note that this is &lt;em&gt;not&lt;/em&gt; a sandbox module - all code is executed in the current process, and any side effects (such as cached imports of other modules) will remain in place after the functions have returned.</source>
          <target state="translated">이것은 샌드 박스 모듈 이 &lt;em&gt;아니라는&lt;/em&gt; 점에 유의하십시오. 모든 코드는 현재 프로세스에서 실행되며 함수가 반환 된 후에도 부작용 (예 : 다른 모듈의 캐시 된 가져 오기)이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="5db5a52cc1e7c561c7837d97bc61981bd4e2bf44" translate="yes" xml:space="preserve">
          <source>Note that this is another reason why you need integration tests as well as unit tests. Testing everything in isolation is all fine and dandy, but if you don&amp;rsquo;t test how your units are &amp;ldquo;wired together&amp;rdquo; there is still lots of room for bugs that tests might have caught.</source>
          <target state="translated">이것이 단위 테스트뿐만 아니라 통합 테스트가 필요한 또 다른 이유입니다. 모든 것을 분리해서 테스트하는 것은 괜찮고 멋지지만, 유닛이 어떻게 서로 연결되어 있는지 테스트하지 않으면 테스트에서 발견 된 버그에 대한 여지가 여전히 많습니다.</target>
        </trans-unit>
        <trans-unit id="b965eef784d4d104baee666239b49d8cae11dad4" translate="yes" xml:space="preserve">
          <source>Note that this is equivalent to &lt;code&gt;bool(expr) is True&lt;/code&gt; and not to &lt;code&gt;expr
is True&lt;/code&gt; (use &lt;code&gt;assertIs(expr, True)&lt;/code&gt; for the latter). This method should also be avoided when more specific methods are available (e.g. &lt;code&gt;assertEqual(a, b)&lt;/code&gt; instead of &lt;code&gt;assertTrue(a == b)&lt;/code&gt;), because they provide a better error message in case of failure.</source>
          <target state="translated">참고이 동등이라고 &lt;code&gt;bool(expr) is True&lt;/code&gt; 하지에 &lt;code&gt;expr is True&lt;/code&gt; (사용 &lt;code&gt;assertIs(expr, True)&lt;/code&gt; 후자의 경우). 이 메소드는 실패 할 경우 더 나은 오류 메시지를 제공하므로 보다 구체적인 메소드를 사용할 수있는 경우 (예 : &lt;code&gt;assertTrue(a == b)&lt;/code&gt; 대신 &lt;code&gt;assertEqual(a, b)&lt;/code&gt; 사용하지 않아야 합니다.</target>
        </trans-unit>
        <trans-unit id="5e6fff084be385dbf0bc1a43435632a2295ef2a7" translate="yes" xml:space="preserve">
          <source>Note that this is not the same concept as an optional argument, which is one that has a default. An optional argument with a default does not require the &lt;code&gt;Optional&lt;/code&gt; qualifier on its type annotation just because it is optional. For example:</source>
          <target state="translated">이것은 선택적 인수와 같은 개념이 아니며 기본값을 갖는 인수입니다. 기본값이있는 선택적 인수 는 선택 적이기 때문에 유형 어노테이션에 &lt;code&gt;Optional&lt;/code&gt; 규정자가 필요하지 않습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="497db1e409c9d5535b9f7799396b336c6bf26c17" translate="yes" xml:space="preserve">
          <source>Note that this is only one way, albeit the most convenient way, to make the &lt;code&gt;_()&lt;/code&gt; function available to your application. Because it affects the entire application globally, and specifically the built-in namespace, localized modules should never install &lt;code&gt;_()&lt;/code&gt;. Instead, they should use this code to make &lt;code&gt;_()&lt;/code&gt; available to their module:</source>
          <target state="translated">이 방법은 가장 편리한 방법이지만 응용 프로그램 에서 &lt;code&gt;_()&lt;/code&gt; 함수를 사용할 수있는 한 가지 방법 일뿐 입니다. 전역 응용 프로그램, 특히 내장 네임 스페이스에 영향을주기 때문에 지역화 된 모듈은 &lt;code&gt;_()&lt;/code&gt; 을 설치하지 않아야합니다 . 대신,이 코드를 사용하여 &lt;code&gt;_()&lt;/code&gt; 을 모듈에서 사용할 수있게해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5dd52f7d1a18d76b5b1670ad4b672dfed972deb" translate="yes" xml:space="preserve">
          <source>Note that this manipulation of &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; is not thread-safe. Other threads may see the partially initialised module, as well as the altered list of arguments. It is recommended that the &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; module be left alone when invoking this function from threaded code.</source>
          <target state="translated">이 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 조작은 스레드로부터 안전하지 않습니다. 다른 스레드는 부분적으로 초기화 된 모듈과 변경된 인수 목록을 볼 수 있습니다. 스레드 코드에서이 기능을 호출 할 때는 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; &lt;/a&gt; 모듈을 그대로 두는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ad60b5a4d53caa42fe4b708c2e6654939094b20a" translate="yes" xml:space="preserve">
          <source>Note that this may not be done after authentication information has been transmitted, and authentication occurs by default if possible during a &lt;a href=&quot;#nntplib.NNTP&quot;&gt;&lt;code&gt;NNTP&lt;/code&gt;&lt;/a&gt; object initialization. See &lt;a href=&quot;#nntplib.NNTP.login&quot;&gt;&lt;code&gt;NNTP.login()&lt;/code&gt;&lt;/a&gt; for information on suppressing this behavior.</source>
          <target state="translated">인증 정보가 전송 된 후에는이 작업이 수행되지 않을 수 있으며 &lt;a href=&quot;#nntplib.NNTP&quot;&gt; &lt;code&gt;NNTP&lt;/code&gt; &lt;/a&gt; 객체 초기화 중에 가능한 경우 기본적으로 인증이 수행됩니다 . 이 동작 억제에 대한 정보는 &lt;a href=&quot;#nntplib.NNTP.login&quot;&gt; &lt;code&gt;NNTP.login()&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ca198d21563fd5cf167242f8f7abad568ca45e5" translate="yes" xml:space="preserve">
          <source>Note that this may raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; on Unix platforms like Mac OS X where &lt;code&gt;sem_getvalue()&lt;/code&gt; is not implemented.</source>
          <target state="translated">이 올릴 수 있음을 참고 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를&lt;/a&gt; 맥 OS X와 같은 유닉스 플랫폼에서 &lt;code&gt;sem_getvalue()&lt;/code&gt; 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46df65154fc5779c9a8d8169de6b544a5033f917" translate="yes" xml:space="preserve">
          <source>Note that this method differs from &lt;a href=&quot;#email.message.Message.get_charset&quot;&gt;&lt;code&gt;get_charset()&lt;/code&gt;&lt;/a&gt; which returns the &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance for the default encoding of the message body.</source>
          <target state="translated">이 메소드는 메시지 본문의 기본 인코딩에 대한 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴하는 &lt;a href=&quot;#email.message.Message.get_charset&quot;&gt; &lt;code&gt;get_charset()&lt;/code&gt; &lt;/a&gt; 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7ec37bb1f92cbf01a7d78829d33f077a718bc081" translate="yes" xml:space="preserve">
          <source>Note that this method is automatically added to the class: it is not directly specified in the &lt;code&gt;InventoryItem&lt;/code&gt; definition shown above.</source>
          <target state="translated">이 메소드는 클래스에 자동으로 추가됩니다 . 위에 표시된 &lt;code&gt;InventoryItem&lt;/code&gt; 정의 에 직접 지정되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="2d0305ac41e9e98f465e3a09a7a321fde7592591" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not always format the message the way you want. For example, by default it does not do the mangling of lines that begin with &lt;code&gt;From&lt;/code&gt; that is required by the unix mbox format. For more flexibility, instantiate a &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; instance and use its &lt;a href=&quot;email.generator#email.generator.BytesGenerator.flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt; method directly. For example:</source>
          <target state="translated">이 방법은 편의상 제공되며 원하는 방식으로 메시지를 항상 형식화하지는 않습니다. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 &lt;code&gt;From&lt;/code&gt; 으로 시작하는 행을 조작하지 않습니다 . 유연성을 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 인스턴스를 인스턴스화 하고 &lt;a href=&quot;email.generator#email.generator.BytesGenerator.flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 메소드를 직접 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc1e53b42c929782edab5f61e605edfc1b232f1f" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not always format the message the way you want. For example, by default it does not do the mangling of lines that begin with &lt;code&gt;From&lt;/code&gt; that is required by the unix mbox format. For more flexibility, instantiate a &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; instance and use its &lt;a href=&quot;email.generator#email.generator.Generator.flatten&quot;&gt;&lt;code&gt;flatten()&lt;/code&gt;&lt;/a&gt; method directly. For example:</source>
          <target state="translated">이 방법은 편의상 제공되며 원하는 방식으로 메시지를 항상 형식화하지는 않습니다. 예를 들어, 기본적으로 유닉스 mbox 형식에 필요한 &lt;code&gt;From&lt;/code&gt; 으로 시작하는 행을 조작하지 않습니다 . 유연성을 높이 려면 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 인스턴스화 하고 &lt;a href=&quot;email.generator#email.generator.Generator.flatten&quot;&gt; &lt;code&gt;flatten()&lt;/code&gt; &lt;/a&gt; 메서드를 직접 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="914ac925c90ce0481ed0d7bcee5c22d8232a27d1" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;email.generator.BytesGenerator&lt;/code&gt;&lt;/a&gt; for a more flexible API for serializing messages.</source>
          <target state="translated">이 방법은 편의상 제공되며 특히 여러 메시지를 처리하는 경우 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법이 아닐 수 있습니다. 보다 유연한 메시지 직렬화 API는 &lt;a href=&quot;email.generator#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;email.generator.BytesGenerator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0569aab75ed3c326d1e3ad45e468b2d9a967ffbc" translate="yes" xml:space="preserve">
          <source>Note that this method is provided as a convenience and may not be the most useful way to serialize messages in your application, especially if you are dealing with multiple messages. See &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt;&lt;code&gt;email.generator.Generator&lt;/code&gt;&lt;/a&gt; for a more flexible API for serializing messages. Note also that this method is restricted to producing messages serialized as &amp;ldquo;7 bit clean&amp;rdquo; when &lt;a href=&quot;email.policy#email.policy.EmailPolicy.utf8&quot;&gt;&lt;code&gt;utf8&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;False&lt;/code&gt;, which is the default.</source>
          <target state="translated">이 방법은 편의상 제공되며 특히 여러 메시지를 처리하는 경우 응용 프로그램에서 메시지를 직렬화하는 가장 유용한 방법이 아닐 수 있습니다. 보다 유연한 메시지 직렬화 API는 &lt;a href=&quot;email.generator#email.generator.Generator&quot;&gt; &lt;code&gt;email.generator.Generator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 . 또한이 방법은 &lt;a href=&quot;email.policy#email.policy.EmailPolicy.utf8&quot;&gt; &lt;code&gt;utf8&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우 &quot;7 비트 클린&quot;으로 직렬화 된 메시지를 생성하는 것으로 제한됩니다 ( 기본값).</target>
        </trans-unit>
        <trans-unit id="4863202591f117b45079183ed253d97469614cfd" translate="yes" xml:space="preserve">
          <source>Note that this should be called at most once, and it should be protected inside the &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; clause of the main module.</source>
          <target state="translated">이것은 최대 한 번만 호출해야하며 기본 모듈 의 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 절 내에서 보호되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f023dfbaa5e7784ac868d744c9df4db74a2b0f4" translate="yes" xml:space="preserve">
          <source>Note that this utility does not guarantee complete &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt; compliance; an absence of errors from this module does not necessarily mean that errors do not exist. However, if this module does produce an error, then it is virtually certain that either the server or application is not 100% compliant.</source>
          <target state="translated">이 유틸리티는 완전한 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3333&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;PEP 3333&lt;/strong&gt;&lt;/a&gt; 준수를 보장하지는 않습니다 . 이 모듈에서 오류가 없다고해서 반드시 오류가 없음을 의미하지는 않습니다. 그러나이 모듈에서 오류가 발생하면 서버 나 응용 프로그램이 100 % 호환되지 않는 것이 확실합니다.</target>
        </trans-unit>
        <trans-unit id="392655359709b780ff1bb9da7fb1ff72dc351b8b" translate="yes" xml:space="preserve">
          <source>Note that tracebacks are treated very specially. In particular, in the rewritten example, the use of &lt;code&gt;...&lt;/code&gt; is independent of doctest&amp;rsquo;s &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt;&lt;code&gt;ELLIPSIS&lt;/code&gt;&lt;/a&gt; option. The ellipsis in that example could be left out, or could just as well be three (or three hundred) commas or digits, or an indented transcript of a Monty Python skit.</source>
          <target state="translated">역 추적은 매우 특별하게 처리됩니다. 특히, 재 작성된 예에서 &lt;code&gt;...&lt;/code&gt; 의 사용 은 doctest의 &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt; &lt;code&gt;ELLIPSIS&lt;/code&gt; &lt;/a&gt; 옵션 과 무관 합니다. 이 예제의 줄임표는 생략되거나 쉼표 나 숫자가 3 개 (또는 300 개)이거나 Monty Python skit의 들여 쓰기 된 대본이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="953d734e119512ee18a0a9392b9f9b9d6d4df366" translate="yes" xml:space="preserve">
          <source>Note that unclosed single-quoted strings do not cause an error to be raised. They are tokenized as &lt;a href=&quot;token#token.ERRORTOKEN&quot;&gt;&lt;code&gt;ERRORTOKEN&lt;/code&gt;&lt;/a&gt;, followed by the tokenization of their contents.</source>
          <target state="translated">닫지 않은 작은 따옴표로 묶인 문자열로 인해 오류가 발생하지는 않습니다. 그것들은 &lt;a href=&quot;token#token.ERRORTOKEN&quot;&gt; &lt;code&gt;ERRORTOKEN&lt;/code&gt; &lt;/a&gt; 으로 토큰 화되고 그 뒤에 내용의 토큰 화됩니다.</target>
        </trans-unit>
        <trans-unit id="025bc18a2bc141ea4af9a1700e4ee039cbf3bd9f" translate="yes" xml:space="preserve">
          <source>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</source>
          <target state="translated">최소 필드 너비가 정의되지 않으면 필드 너비는 항상 데이터를 채우는 데이터와 동일한 크기이므로 정렬 옵션은이 경우 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f0733676794f7d6ac39c0d22a2a452465ab6a556" translate="yes" xml:space="preserve">
          <source>Note that unlike many other generics in the typing module, the &lt;code&gt;SendType&lt;/code&gt; of &lt;a href=&quot;#typing.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; behaves contravariantly, not covariantly or invariantly.</source>
          <target state="translated">타이핑 모듈의 다른 많은 제네릭과 달리 &lt;code&gt;SendType&lt;/code&gt; of &lt;a href=&quot;#typing.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 는&lt;/a&gt; 공변량 또는 불변성이 아닌 반동적 으로 동작합니다.</target>
        </trans-unit>
        <trans-unit id="a6e9cb78d9006ba4f85f82103063e16f601f2f04" translate="yes" xml:space="preserve">
          <source>Note that unlike the &lt;a href=&quot;#csv.DictReader&quot;&gt;&lt;code&gt;DictReader&lt;/code&gt;&lt;/a&gt; class, the &lt;em&gt;fieldnames&lt;/em&gt; parameter of the &lt;a href=&quot;#csv.DictWriter&quot;&gt;&lt;code&gt;DictWriter&lt;/code&gt;&lt;/a&gt; class is not optional.</source>
          <target state="translated">달리합니다 &lt;a href=&quot;#csv.DictReader&quot;&gt; &lt;code&gt;DictReader&lt;/code&gt; 의&lt;/a&gt; 클래스의 &lt;em&gt;fieldName에의&lt;/em&gt; 의 매개 변수 &lt;a href=&quot;#csv.DictWriter&quot;&gt; &lt;code&gt;DictWriter&lt;/code&gt; 의&lt;/a&gt; 클래스는 선택 사항이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="b92a04f3a0309df577dbc705f08776279130e14e" translate="yes" xml:space="preserve">
          <source>Note that unlike the C structure, the month value is a range of [1, 12], not [0, 11].</source>
          <target state="translated">C 구조와 달리 월 값은 [0, 11]이 아니라 [1, 12]의 범위입니다.</target>
        </trans-unit>
        <trans-unit id="8eede2ce0b3d8e2c9335916e2ca2bc70c1345924" translate="yes" xml:space="preserve">
          <source>Note that unlike the Python &lt;code&gt;sys.version&lt;/code&gt;, the returned value will always include the patchlevel (it defaults to 0).</source>
          <target state="translated">Python &lt;code&gt;sys.version&lt;/code&gt; 과 달리 반환 된 값에는 항상 patchlevel이 포함됩니다 (기본값은 0).</target>
        </trans-unit>
        <trans-unit id="a0e44189a3d936dd2974b45ad2423d66b85bbb11" translate="yes" xml:space="preserve">
          <source>Note that unlike the Python &lt;code&gt;sys.version&lt;/code&gt;, the returned value will always include the patchlevel (it defaults to &lt;code&gt;'0'&lt;/code&gt;).</source>
          <target state="translated">Python &lt;code&gt;sys.version&lt;/code&gt; 과 달리 반환 된 값에는 항상 patchlevel이 포함됩니다 (기본값은 &lt;code&gt;'0'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="faae0ddf62d8d17e4575535b139e839cc1f2ad54" translate="yes" xml:space="preserve">
          <source>Note that urlopen returns a bytes object. This is because there is no way for urlopen to automatically determine the encoding of the byte stream it receives from the HTTP server. In general, a program will decode the returned bytes object to string once it determines or guesses the appropriate encoding.</source>
          <target state="translated">urlopen은 bytes 객체를 반환합니다. 이는 urlopen이 HTTP 서버로부터 수신 한 바이트 스트림의 인코딩을 자동으로 결정할 방법이 없기 때문입니다. 일반적으로 프로그램은 적절한 인코딩을 결정하거나 추측하면 반환 된 바이트 객체를 문자열로 디코딩합니다.</target>
        </trans-unit>
        <trans-unit id="fb5a04375d4dd30682512ce20dc834dd48ae4073" translate="yes" xml:space="preserve">
          <source>Note that using this function may require some external synchronization if there are other threads whose state is unknown. If a barrier is broken it may be better to just leave it and create a new one.</source>
          <target state="translated">상태를 알 수없는 다른 스레드가있는 경우이 기능을 사용하려면 외부 동기화가 필요할 수 있습니다. 방벽이 깨지면 그냥 방치하여 새 방벽을 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9c6aed152d7d60b297ac12eb40378b5912ced5a2" translate="yes" xml:space="preserve">
          <source>Note that using this method is subtly different from deleting the old &lt;em&gt;Content-Type&lt;/em&gt; header and adding a new one with the new boundary via &lt;a href=&quot;#email.message.EmailMessage.add_header&quot;&gt;&lt;code&gt;add_header()&lt;/code&gt;&lt;/a&gt;, because &lt;a href=&quot;#email.message.EmailMessage.set_boundary&quot;&gt;&lt;code&gt;set_boundary()&lt;/code&gt;&lt;/a&gt; preserves the order of the &lt;em&gt;Content-Type&lt;/em&gt; header in the list of headers.</source>
          <target state="translated">이 방법을 사용하면 기존의 삭제에서 미묘하게 다릅니다 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를하고를 통해 새로운 경계와 새로운 추가 &lt;a href=&quot;#email.message.EmailMessage.add_header&quot;&gt; &lt;code&gt;add_header()&lt;/code&gt; &lt;/a&gt; 하기 때문에, &lt;a href=&quot;#email.message.EmailMessage.set_boundary&quot;&gt; &lt;code&gt;set_boundary()&lt;/code&gt; &lt;/a&gt; 의 순서 보존 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더의 목록에서 헤더를.</target>
        </trans-unit>
        <trans-unit id="9bd23778bbf355f16dc2a21579fe2ace4a93366b" translate="yes" xml:space="preserve">
          <source>Note that using this method is subtly different than deleting the old &lt;em&gt;Content-Type&lt;/em&gt; header and adding a new one with the new boundary via &lt;a href=&quot;#email.message.Message.add_header&quot;&gt;&lt;code&gt;add_header()&lt;/code&gt;&lt;/a&gt;, because &lt;a href=&quot;#email.message.Message.set_boundary&quot;&gt;&lt;code&gt;set_boundary()&lt;/code&gt;&lt;/a&gt; preserves the order of the &lt;em&gt;Content-Type&lt;/em&gt; header in the list of headers. However, it does &lt;em&gt;not&lt;/em&gt; preserve any continuation lines which may have been present in the original &lt;em&gt;Content-Type&lt;/em&gt; header.</source>
          <target state="translated">이 방법을 사용하면 기존의 삭제에 비해 미묘하게 다릅니다 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더를하고를 통해 새로운 경계와 새로운 추가 &lt;a href=&quot;#email.message.Message.add_header&quot;&gt; &lt;code&gt;add_header()&lt;/code&gt; &lt;/a&gt; 하기 때문에, &lt;a href=&quot;#email.message.Message.set_boundary&quot;&gt; &lt;code&gt;set_boundary()&lt;/code&gt; &lt;/a&gt; 의 순서 보존 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더의 목록에서 헤더를. 그러나 원본 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 에있을 수있는 연속 선 은 유지 하지 &lt;em&gt;않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c91ae7008ef906071438192c9d712ce1afcb7577" translate="yes" xml:space="preserve">
          <source>Note that via &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; hooks, all attributes are computed lazily, so there is no speed penalty if only those attributes which are lightweight to compute are used.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 후크 를 통해 모든 속성이 느리게 계산되므로 계산하기에 가벼운 속성 만 사용하면 속도가 저하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a0f182aa4a9ed90d4fef85c4c311a272374c431d" translate="yes" xml:space="preserve">
          <source>Note that via &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; hooks, all attributes are computed lazily, so there is no speed penalty if only those attributes which are lightweight to compute are used.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 후크 를 통해 모든 속성이 느리게 계산되므로 계산하기에 가벼운 속성 만 사용하는 경우 속도 저하가 없습니다.</target>
        </trans-unit>
        <trans-unit id="6620fed817fce6e58ea094966e81cd033a5e4010" translate="yes" xml:space="preserve">
          <source>Note that when instantiating a &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt; object we may pass functions to filter out line and character &amp;ldquo;junk.&amp;rdquo; See the &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ()&lt;/code&gt;&lt;/a&gt; constructor for details.</source>
          <target state="translated">&lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; 객체를 인스턴스화 할 때 함수를 전달하여 줄과 문자&amp;ldquo;정크&amp;rdquo;를 걸러 낼 수 있습니다. 자세한 내용은 &lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ()&lt;/code&gt; &lt;/a&gt; 생성자를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dd02f589dec05a4f2acacc6d0ca5ede64ffc86f9" translate="yes" xml:space="preserve">
          <source>Note that when locals are captured, they are also shown in the traceback.</source>
          <target state="translated">로컬이 캡처되면 트레이스 백에도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="502bb316d8bdb001894aeb3898845cca4d8900b3" translate="yes" xml:space="preserve">
          <source>Note that when reading configuration files, whitespace around the option names is stripped before &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt;&lt;code&gt;optionxform()&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">구성 파일을 읽을 때 &lt;a href=&quot;#configparser.ConfigParser.optionxform&quot;&gt; &lt;code&gt;optionxform()&lt;/code&gt; &lt;/a&gt; 을 호출 하기 전에 옵션 이름 주위의 공백이 제거 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea83e7983f7be281ec5a3262ffed3a7df409c2d9" translate="yes" xml:space="preserve">
          <source>Note that when the Unicode patterns &lt;code&gt;[a-z]&lt;/code&gt; or &lt;code&gt;[A-Z]&lt;/code&gt; are used in combination with the &lt;a href=&quot;#re.IGNORECASE&quot;&gt;&lt;code&gt;IGNORECASE&lt;/code&gt;&lt;/a&gt; flag, they will match the 52 ASCII letters and 4 additional non-ASCII letters: &amp;lsquo;İ&amp;rsquo; (U+0130, Latin capital letter I with dot above), &amp;lsquo;ı&amp;rsquo; (U+0131, Latin small letter dotless i), &amp;lsquo;ſ&amp;rsquo; (U+017F, Latin small letter long s) and &amp;lsquo;K&amp;rsquo; (U+212A, Kelvin sign). If the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag is used, only letters &amp;lsquo;a&amp;rsquo; to &amp;lsquo;z&amp;rsquo; and &amp;lsquo;A&amp;rsquo; to &amp;lsquo;Z&amp;rsquo; are matched.</source>
          <target state="translated">유니 코드 패턴 &lt;code&gt;[a-z]&lt;/code&gt; 또는 &lt;code&gt;[A-Z]&lt;/code&gt; &lt;a href=&quot;#re.IGNORECASE&quot;&gt; &lt;code&gt;IGNORECASE&lt;/code&gt; &lt;/a&gt; 플래그 와 함께 사용 하면 52 개의 ASCII 문자 및 4 개의 추가 비 ASCII 문자와 일치합니다 : 'İ'(U + 0130, 라틴 대문자 I 위의 점), 'ı'(U + 0131, 라틴 소문자 dotless i), 'ſ'(U + 017F, 라틴 소문자 long s) 및 'K'(U + 212A, 켈빈 기호). 경우] &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; 의&lt;/a&gt; 플래그가 'Z'와 'Z'에서 'A'로, 오직 문자 'A'와 일치 사용된다.</target>
        </trans-unit>
        <trans-unit id="941b2bd8c0fceca2a354dab3b47ce6850b8f3e86" translate="yes" xml:space="preserve">
          <source>Note that while &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt;&lt;code&gt;iterparse()&lt;/code&gt;&lt;/a&gt; builds the tree incrementally, it issues blocking reads on &lt;em&gt;source&lt;/em&gt; (or the file it names). As such, it&amp;rsquo;s unsuitable for applications where blocking reads can&amp;rsquo;t be made. For fully non-blocking parsing, see &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt;&lt;code&gt;XMLPullParser&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반면 있습니다 &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt; &lt;code&gt;iterparse()&lt;/code&gt; &lt;/a&gt; 점진적으로 트리를 빌드가 차단 문제에 읽고 &lt;em&gt;소스&lt;/em&gt; (또는 파일 그 이름). 따라서 읽기 차단을 할 수없는 응용 프로그램에는 적합하지 않습니다. 완전 비 차단 구문 분석은 &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt; &lt;code&gt;XMLPullParser&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e2a3769eac1a1d1cf5224599e594a65402067fa" translate="yes" xml:space="preserve">
          <source>Note that widgets do not appear until they have had their geometry specified with a geometry manager. It&amp;rsquo;s a common early mistake to leave out the geometry specification, and then be surprised when the widget is created but nothing appears. A widget will appear only after it has had, for example, the packer&amp;rsquo;s &lt;code&gt;pack()&lt;/code&gt; method applied to it.</source>
          <target state="translated">위젯은 지오메트리 관리자로 지오메트리를 지정할 때까지 표시되지 않습니다. 지오메트리 사양을 생략하고 위젯이 생성되었지만 아무 것도 나타나지 않을 때 놀라는 것은 일반적인 초기 실수입니다. 위젯은 패커의 &lt;code&gt;pack()&lt;/code&gt; 메소드를 적용한 후에 만 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="2968c2dcd25aa32f9a9ffad2dfcf5c7c74536aa8" translate="yes" xml:space="preserve">
          <source>Note that win32 system dlls like &lt;code&gt;kernel32&lt;/code&gt; and &lt;code&gt;user32&lt;/code&gt; often export ANSI as well as UNICODE versions of a function. The UNICODE version is exported with an &lt;code&gt;W&lt;/code&gt; appended to the name, while the ANSI version is exported with an &lt;code&gt;A&lt;/code&gt; appended to the name. The win32 &lt;code&gt;GetModuleHandle&lt;/code&gt; function, which returns a &lt;em&gt;module handle&lt;/em&gt; for a given module name, has the following C prototype, and a macro is used to expose one of them as &lt;code&gt;GetModuleHandle&lt;/code&gt; depending on whether UNICODE is defined or not:</source>
          <target state="translated">&lt;code&gt;kernel32&lt;/code&gt; 및 &lt;code&gt;user32&lt;/code&gt; 와 같은 win32 시스템 dll은 종종 ANSI 및 UNICODE 버전의 함수를 내 보냅니다. 유니 코드 버전은 이름에 &lt;code&gt;W&lt;/code&gt; 가 추가 된 상태로 내보내지고 ANSI 버전은 이름에 &lt;code&gt;A&lt;/code&gt; 가 추가 된 상태로 내보내집니다 . 주어진 모듈 이름에 대한 &lt;em&gt;모듈 핸들&lt;/em&gt; 을 반환하는 win32 &lt;code&gt;GetModuleHandle&lt;/code&gt; 함수 는 다음과 같은 C 프로토 타입을 가지며 매크로는 UNICODE의 정의 여부에 따라 이들 중 하나를 &lt;code&gt;GetModuleHandle&lt;/code&gt; 로 표시하는 데 사용됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e484f1a68e220911d28f836ad1681a6e8b9beab" translate="yes" xml:space="preserve">
          <source>Note that you must have read the whole response before you can send a new request to the server.</source>
          <target state="translated">서버에 새 요청을 보내려면 전체 응답을 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="03c8f7f230406149e0b90ed811820d038dcfd819" translate="yes" xml:space="preserve">
          <source>Note that, as with floating point numbers, &lt;code&gt;v is w&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; imply &lt;code&gt;v == w&lt;/code&gt; for memoryview objects.</source>
          <target state="translated">부동 소수점 숫자와 마찬가지로 &lt;code&gt;v is w&lt;/code&gt; 는 memoryview 객체에 대해 &lt;code&gt;v == w&lt;/code&gt; 를 의미 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="84e31b16758bcc976ec2d505de7ab96563d8cfa9" translate="yes" xml:space="preserve">
          <source>Note that, because of normalization, &lt;code&gt;timedelta.max&lt;/code&gt; &amp;gt; &lt;code&gt;-timedelta.min&lt;/code&gt;. &lt;code&gt;-timedelta.max&lt;/code&gt; is not representable as a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">때문에 정상화의 그 주 &lt;code&gt;timedelta.max&lt;/code&gt; &amp;gt; &lt;code&gt;-timedelta.min&lt;/code&gt; . &lt;code&gt;-timedelta.max&lt;/code&gt; 는 A와 표현할 수없는 것입니다 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; 의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="d2fa3178c8ace73525d94f281c6241f693463f13" translate="yes" xml:space="preserve">
          <source>Note that, unlike &lt;a href=&quot;#runpy.run_module&quot;&gt;&lt;code&gt;run_module()&lt;/code&gt;&lt;/a&gt;, the alterations made to &lt;a href=&quot;sys#module-sys&quot;&gt;&lt;code&gt;sys&lt;/code&gt;&lt;/a&gt; are not optional in this function as these adjustments are essential to allowing the execution of sys.path entries. As the thread-safety limitations still apply, use of this function in threaded code should be either serialised with the import lock or delegated to a separate process.</source>
          <target state="translated">&lt;a href=&quot;#runpy.run_module&quot;&gt; &lt;code&gt;run_module()&lt;/code&gt; &lt;/a&gt; 과 달리 sys.path 항목의 실행을 허용하기 위해 이러한 조정이 필수적 이므로이 기능에서 &lt;a href=&quot;sys#module-sys&quot;&gt; &lt;code&gt;sys&lt;/code&gt; 에&lt;/a&gt; 대한 변경은 선택 사항이 아닙니다. 스레드 안전성 제한이 여전히 적용되므로 스레드 코드에서이 기능의 사용은 가져 오기 잠금으로 직렬화되거나 별도의 프로세스로 위임되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f1c5a3a10c1525bb6f32e3ae69372905a7415c70" translate="yes" xml:space="preserve">
          <source>Note the difference between &lt;code&gt;'@'&lt;/code&gt; and &lt;code&gt;'='&lt;/code&gt;: both use native byte order, but the size and alignment of the latter is standardized.</source>
          <target state="translated">&lt;code&gt;'@'&lt;/code&gt; 과 &lt;code&gt;'='&lt;/code&gt; 의 차이점에 유의하십시오 . 둘 다 기본 바이트 순서를 사용하지만 후자의 크기와 정렬이 표준화됩니다.</target>
        </trans-unit>
        <trans-unit id="394e74fcbbfae11d61ce5fd9d0741b358dc5b679" translate="yes" xml:space="preserve">
          <source>Note the unusual calling syntax: the &lt;em&gt;first&lt;/em&gt; argument is optional, and the second is required. This is a historical artifact for compatibility with the older &lt;code&gt;linuxaudiodev&lt;/code&gt; module which &lt;a href=&quot;#module-ossaudiodev&quot;&gt;&lt;code&gt;ossaudiodev&lt;/code&gt;&lt;/a&gt; supersedes.</source>
          <target state="translated">특이한 호출 구문에 주목하십시오. &lt;em&gt;첫 번째&lt;/em&gt; 인수는 선택 사항이며 두 &lt;em&gt;번째&lt;/em&gt; 인수는 필수입니다. 이것은 &lt;a href=&quot;#module-ossaudiodev&quot;&gt; &lt;code&gt;ossaudiodev&lt;/code&gt; 가&lt;/a&gt; 대체 하는 이전 &lt;code&gt;linuxaudiodev&lt;/code&gt; 모듈 과의 호환성을위한 역사적 유물입니다 .</target>
        </trans-unit>
        <trans-unit id="7af185c96012df581e5e0886681b5f83b41d3210" translate="yes" xml:space="preserve">
          <source>Note there are performance considerations involved with the &lt;em&gt;size&lt;/em&gt; parameter. For optimal performance, it is usually best to use the arraysize attribute. If the &lt;em&gt;size&lt;/em&gt; parameter is used, then it is best for it to retain the same value from one &lt;a href=&quot;#sqlite3.Cursor.fetchmany&quot;&gt;&lt;code&gt;fetchmany()&lt;/code&gt;&lt;/a&gt; call to the next.</source>
          <target state="translated">&lt;em&gt;size&lt;/em&gt; 매개 변수 와 관련된 성능 고려 사항이 있습니다 . 최적의 성능을 위해서는 일반적으로 arraysize 속성을 사용하는 것이 가장 좋습니다. 경우 &lt;em&gt;크기&lt;/em&gt; 매개 변수가 사용되는이 하나 명의 동일한 값을 유지하기 위해, 그것은 최선 &lt;a href=&quot;#sqlite3.Cursor.fetchmany&quot;&gt; &lt;code&gt;fetchmany()&lt;/code&gt; &lt;/a&gt; 호출 다음에 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fe587f2f04237cccac255c57a5d7d8af7041796" translate="yes" xml:space="preserve">
          <source>Note, however, that it&amp;rsquo;s not recommended from a security perspective to spit out diagnostics to any old user; ideally, you should have to do something special to enable diagnostic output, which is why the default implementation doesn&amp;rsquo;t include any.</source>
          <target state="translated">그러나 보안 관점에서 이전 사용자에게 진단을 내놓는 것은 권장되지 않습니다. 이상적으로는 진단 출력을 활성화하기 위해 특별한 작업을 수행해야하므로 기본 구현에 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="762ab7548d9281c2411acf4c20182504bff18c33" translate="yes" xml:space="preserve">
          <source>Note, that the data read is buffered in memory, so do not use this method if the data size is large or unlimited.</source>
          <target state="translated">읽은 데이터는 메모리에 버퍼링되므로 데이터 크기가 크거나 무제한 인 경우이 방법을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="88aebce2f9074a5fa8e2b3fc150edc9adfd4b5a6" translate="yes" xml:space="preserve">
          <source>Note, the &lt;em&gt;default&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt; unless explicitly set to &lt;em&gt;0&lt;/em&gt;.</source>
          <target state="translated">은 참고 &lt;em&gt;기본값은&lt;/em&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 을 명시 적으로 설정하지 않으면 &lt;em&gt;0&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c1bc85960916ca65e7a3c8ddd82bfd13d344d14f" translate="yes" xml:space="preserve">
          <source>Note, the &lt;em&gt;elem&lt;/em&gt; argument to the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt;&lt;code&gt;__contains__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt; methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from &lt;em&gt;elem&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt; &lt;code&gt;__contains__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 및 destroy &lt;a href=&quot;#frozenset.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 메소드에 대한 &lt;em&gt;elem&lt;/em&gt; 인수 는 세트 일 수 있습니다. 동등한 고정 세트 검색을 지원하기 위해 임시 임시 세트는 &lt;em&gt;elem&lt;/em&gt; 에서 &lt;em&gt;작성&lt;/em&gt; 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="20c05024379c7080e1a1d19313a4b57c40b19b31" translate="yes" xml:space="preserve">
          <source>Note, the &lt;em&gt;elem&lt;/em&gt; argument to the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__contains__&quot;&gt;&lt;code&gt;__contains__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.remove&quot;&gt;&lt;code&gt;remove()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.discard&quot;&gt;&lt;code&gt;discard()&lt;/code&gt;&lt;/a&gt; methods may be a set. To support searching for an equivalent frozenset, a temporary one is created from &lt;em&gt;elem&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__contains__&quot;&gt; &lt;code&gt;__contains__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.remove&quot;&gt; &lt;code&gt;remove()&lt;/code&gt; &lt;/a&gt; 및 ignore &lt;a href=&quot;#frozenset.discard&quot;&gt; &lt;code&gt;discard()&lt;/code&gt; &lt;/a&gt; 메서드에 대한 &lt;em&gt;elem&lt;/em&gt; 인수 는 집합 일 수 있습니다. 동등한 frozenset 검색을 지원하기 위해 &lt;em&gt;elem&lt;/em&gt; 에서 임시 집합이 생성됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ce50e6ce36b2bce4757cdba44683aef09df0f6a" translate="yes" xml:space="preserve">
          <source>Note, the iteration order of a &lt;a href=&quot;#collections.ChainMap&quot;&gt;&lt;code&gt;ChainMap()&lt;/code&gt;&lt;/a&gt; is determined by scanning the mappings last to first:</source>
          <target state="translated">&lt;a href=&quot;#collections.ChainMap&quot;&gt; &lt;code&gt;ChainMap()&lt;/code&gt; &lt;/a&gt; 의 반복 순서 는 맵핑을 마지막에서 처음으로 스캔하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3dedf0fa71983b6357e6e9bae7d93a1fd17b41" translate="yes" xml:space="preserve">
          <source>Note, the non-operator versions of &lt;a href=&quot;#frozenset.union&quot;&gt;&lt;code&gt;union()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.intersection&quot;&gt;&lt;code&gt;intersection()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.difference&quot;&gt;&lt;code&gt;difference()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.symmetric_difference&quot;&gt;&lt;code&gt;symmetric_difference()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.issubset&quot;&gt;&lt;code&gt;issubset()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.issuperset&quot;&gt;&lt;code&gt;issuperset()&lt;/code&gt;&lt;/a&gt; methods will accept any iterable as an argument. In contrast, their operator based counterparts require their arguments to be sets. This precludes error-prone constructions like &lt;code&gt;set('abc') &amp;amp; 'cbs'&lt;/code&gt; in favor of the more readable &lt;code&gt;set('abc').intersection('cbs')&lt;/code&gt;.</source>
          <target state="translated">참고의 비 연산자 버전 &lt;a href=&quot;#frozenset.union&quot;&gt; &lt;code&gt;union()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.intersection&quot;&gt; &lt;code&gt;intersection()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.difference&quot;&gt; &lt;code&gt;difference()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.symmetric_difference&quot;&gt; &lt;code&gt;symmetric_difference()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.issubset&quot;&gt; &lt;code&gt;issubset()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.issuperset&quot;&gt; &lt;code&gt;issuperset()&lt;/code&gt; &lt;/a&gt; 메소드와 같은 인자를 반복 가능한 허용한다. 반대로, 연산자 기반의 대응자는 인수를 설정해야합니다. 이것은 더 읽기 쉬운 &lt;code&gt;set('abc').intersection('cbs')&lt;/code&gt; 대신에 &lt;code&gt;set('abc') &amp;amp; 'cbs'&lt;/code&gt; 와 같은 오류가 발생하기 쉬운 구성을 배제합니다 .</target>
        </trans-unit>
        <trans-unit id="051512041c44a2517e704de51f5530d92cd85cdd" translate="yes" xml:space="preserve">
          <source>Note, the non-operator versions of the &lt;a href=&quot;#frozenset.update&quot;&gt;&lt;code&gt;update()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.intersection_update&quot;&gt;&lt;code&gt;intersection_update()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#frozenset.difference_update&quot;&gt;&lt;code&gt;difference_update()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#frozenset.symmetric_difference_update&quot;&gt;&lt;code&gt;symmetric_difference_update()&lt;/code&gt;&lt;/a&gt; methods will accept any iterable as an argument.</source>
          <target state="translated">비 연산자 버전의 &lt;a href=&quot;#frozenset.update&quot;&gt; &lt;code&gt;update()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.intersection_update&quot;&gt; &lt;code&gt;intersection_update()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#frozenset.difference_update&quot;&gt; &lt;code&gt;difference_update()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#frozenset.symmetric_difference_update&quot;&gt; &lt;code&gt;symmetric_difference_update()&lt;/code&gt; &lt;/a&gt; 메소드는 반복 가능한 인수를 인수로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="06c6acd1a7b124604a708af0e14a30f685c53d1e" translate="yes" xml:space="preserve">
          <source>Note, this decorator interferes with the operation of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0412&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 412&lt;/strong&gt;&lt;/a&gt; key-sharing dictionaries. This means that instance dictionaries can take more space than usual.</source>
          <target state="translated">이 데코레이터는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0412&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 412&lt;/strong&gt;&lt;/a&gt; 키 공유 사전 의 작동을 방해 합니다. 이는 인스턴스 사전이 평소보다 더 많은 공간을 차지할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="112b3520cc7fea120e7deb94779035341ecfd7d1" translate="yes" xml:space="preserve">
          <source>Note, this member of the toolkit may require significant auxiliary storage (depending on the length of the iterable).</source>
          <target state="translated">툴킷의이 멤버에는 iterable의 길이에 따라 상당한 보조 기억 장치가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13a1e86095e2b68b8a7fa1905437c2cc90128cdc" translate="yes" xml:space="preserve">
          <source>Note: &lt;a href=&quot;#socket.gethostname&quot;&gt;&lt;code&gt;gethostname()&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t always return the fully qualified domain name; use &lt;a href=&quot;#socket.getfqdn&quot;&gt;&lt;code&gt;getfqdn()&lt;/code&gt;&lt;/a&gt; for that.</source>
          <target state="translated">참고 : &lt;a href=&quot;#socket.gethostname&quot;&gt; &lt;code&gt;gethostname()&lt;/code&gt; &lt;/a&gt; 은 항상 정규화 된 도메인 이름을 반환하지는 않습니다. 이를 위해 &lt;a href=&quot;#socket.getfqdn&quot;&gt; &lt;code&gt;getfqdn()&lt;/code&gt; &lt;/a&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="940b0549d5a0a4041429b4eecbc4dbeb233620a3" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;The policy keyword should always be specified&lt;/strong&gt;; The default will change to &lt;a href=&quot;email.policy#email.policy.default&quot;&gt;&lt;code&gt;email.policy.default&lt;/code&gt;&lt;/a&gt; in a future version of Python.</source>
          <target state="translated">참고 : &lt;strong&gt;정책 키워드는 항상 지정해야합니다&lt;/strong&gt; . 이후 버전의 Python에서는 기본값이 &lt;a href=&quot;email.policy#email.policy.default&quot;&gt; &lt;code&gt;email.policy.default&lt;/code&gt; &lt;/a&gt; 로 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2cbdd7a2167c420ef2fe1b094a5250391cb7403" translate="yes" xml:space="preserve">
          <source>Note: If you just want to pass a pointer to an object to a foreign function call, you should use &lt;code&gt;byref(obj)&lt;/code&gt; which is much faster.</source>
          <target state="translated">참고 : 객체에 대한 포인터를 외부 함수 호출에 전달하려는 경우 훨씬 빠른 &lt;code&gt;byref(obj)&lt;/code&gt; 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="77e52fe2400941c708aa213fb2c6d50d40a1c8b9" translate="yes" xml:space="preserve">
          <source>Note: Some code samples reference the ctypes &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; type. On platforms where &lt;code&gt;sizeof(long) == sizeof(int)&lt;/code&gt; it is an alias to &lt;a href=&quot;#ctypes.c_long&quot;&gt;&lt;code&gt;c_long&lt;/code&gt;&lt;/a&gt;. So, you should not be confused if &lt;a href=&quot;#ctypes.c_long&quot;&gt;&lt;code&gt;c_long&lt;/code&gt;&lt;/a&gt; is printed if you would expect &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; &amp;mdash; they are actually the same type.</source>
          <target state="translated">참고 : 일부 코드 샘플은 ctypes &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 유형을 참조합니다 . &lt;code&gt;sizeof(long) == sizeof(int)&lt;/code&gt; 플랫폼에서는 &lt;a href=&quot;#ctypes.c_long&quot;&gt; &lt;code&gt;c_long&lt;/code&gt; &lt;/a&gt; 의 별명 입니다. 그래서, 당신은 경우 혼동해서는 안 &lt;a href=&quot;#ctypes.c_long&quot;&gt; &lt;code&gt;c_long&lt;/code&gt; 은&lt;/a&gt; 당신이 기대하는 경우 인쇄 &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; 을&lt;/a&gt; 그들은 실제로 같은 유형이다 -.</target>
        </trans-unit>
        <trans-unit id="3e0eb9ee31e1587e739522fcda6c31ae3034a95a" translate="yes" xml:space="preserve">
          <source>Note: The code samples in this tutorial use &lt;a href=&quot;doctest#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; to make sure that they actually work. Since some code samples behave differently under Linux, Windows, or Mac OS X, they contain doctest directives in comments.</source>
          <target state="translated">참고 :이 학습서의 코드 샘플은 &lt;a href=&quot;doctest#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 를 사용 하여 실제로 작동하는지 확인합니다. 일부 코드 샘플은 Linux, Windows 또는 Mac OS X에서 다르게 작동하므로 주석에 doctest 지시문이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="953b3d8abb71583778699e086e9ed766999d86c8" translate="yes" xml:space="preserve">
          <source>Note: The functions do not require the data given to them to be sorted. However, for reading convenience, most of the examples show sorted sequences.</source>
          <target state="translated">참고 : 함수는 주어진 데이터를 정렬 할 필요가 없습니다. 그러나 읽기 편의를 위해 대부분의 예제는 정렬 된 순서를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a1c53c3229edec4d12d1c96e481f3cb1be441c54" translate="yes" xml:space="preserve">
          <source>Note: an awakened thread does not actually return from its &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; call until it can reacquire the lock. Since &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; does not release the lock, its caller should.</source>
          <target state="translated">참고 : 깨어 난 스레드는 잠금을 다시 얻을 수있을 때까지 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 에서 실제로 반환되지 않습니다 . 이후 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 잠금을 해제하지 않습니다, 호출자는해야한다.</target>
        </trans-unit>
        <trans-unit id="0a990121c7b5c3a78884ba5ed2602b8ed6c392e4" translate="yes" xml:space="preserve">
          <source>Note: if your enumeration defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; then whatever value(s) were given to the enum member will be passed into those methods. See &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; for an example.</source>
          <target state="translated">참고 : 열거 형에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 을 정의 하면 열거 형 멤버에 제공된 모든 값이 해당 메서드에 전달됩니다. 예를 들어 &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98eb683dd61fdd0bb9d904a6f22ab048a5a0792e" translate="yes" xml:space="preserve">
          <source>Note: if your enumeration defines &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; then any value(s) given to the enum member will be passed into those methods. See &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; for an example.</source>
          <target state="translated">참고 : 열거 형이 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 를 정의 하는 경우 열거 형 멤버에 제공된 모든 값이 해당 메서드로 전달됩니다. 예를 보려면 &lt;a href=&quot;#planet&quot;&gt;Planet&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="17bfb70d8bc59b6a601bb652e3e1e16fb71419ac" translate="yes" xml:space="preserve">
          <source>Note: loop may be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">참고 : loop는 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcbf716e0a93fc3a46f989b0950001ff549cbbb0" translate="yes" xml:space="preserve">
          <source>Note: the &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; methods don&amp;rsquo;t release the lock; this means that the thread or threads awakened will not return from their &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; call immediately, but only when the thread that called &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; finally relinquishes ownership of the lock.</source>
          <target state="translated">참고 : &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 메소드는 잠금을 해제하지 않습니다. 이것은 깨어 난 스레드가 즉시 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 호출 에서 반환되지 않으며 , &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 을 호출 한 스레드가 결국 잠금 소유권을 포기한 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="20fdf933b6a8eed945310d963fa5e36f40c7100f" translate="yes" xml:space="preserve">
          <source>Note: this function may not be able to retrieve all attributes that getattr can fetch (like dynamically created attributes) and may find attributes that getattr can&amp;rsquo;t (like descriptors that raise AttributeError). It can also return descriptors objects instead of instance members.</source>
          <target state="translated">참고 :이 함수는 getattr이 가져올 수있는 모든 속성 (동적으로 생성 된 속성과 같은)을 검색하지 못할 수 있으며 getattr이 가져올 수없는 속성 (AttributeError를 발생시키는 설명자와 같은)을 찾을 수 있습니다. 또한 인스턴스 멤버 대신 설명자 객체를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe152fdfb8ac8116096c5833a5da72fe28dcdf6" translate="yes" xml:space="preserve">
          <source>Notebook</source>
          <target state="translated">Notebook</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="bd2179fffb660660b08dc66587d54c4693ebd949" translate="yes" xml:space="preserve">
          <source>Notes for type implementors</source>
          <target state="translated">타입 구현자를위한 노트</target>
        </trans-unit>
        <trans-unit id="7d429a334eb57d5c3e2b4354221adcdf790abbaa" translate="yes" xml:space="preserve">
          <source>Notes on Maildir by its inventor. Includes an updated name-creation scheme and details on &amp;ldquo;info&amp;rdquo; semantics.</source>
          <target state="translated">발명가의 Maildir에 대한 참고 사항. 업데이트 된 이름 생성 체계와 &quot;정보&quot;의미에 대한 세부 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="39979ab954b5d6a8f0a293f5c81ebd913e2a234b" translate="yes" xml:space="preserve">
          <source>Notes on Reproducibility</source>
          <target state="translated">재현성에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="994bfa04566317a983e1a93b7ff9716e4f306af7" translate="yes" xml:space="preserve">
          <source>Notes on availability</source>
          <target state="translated">가용성에 대한 메모</target>
        </trans-unit>
        <trans-unit id="96ea6c9601efc087de48baaaf665d4181463804b" translate="yes" xml:space="preserve">
          <source>Notes on non-blocking sockets</source>
          <target state="translated">비 차단 소켓에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="3529fba1dfaa4d96d92ade4092c1a3d7d76cb625" translate="yes" xml:space="preserve">
          <source>Notes on socket timeouts</source>
          <target state="translated">소켓 타임 아웃에 대한 참고 사항</target>
        </trans-unit>
        <trans-unit id="4183ad6f00d027788e1933ebd67bd6184f44f2f1" translate="yes" xml:space="preserve">
          <source>Notes on the availability of these functions:</source>
          <target state="translated">이 기능의 가용성에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="4ab3dde9df12858e1f1d64a466b42281fd1c43e0" translate="yes" xml:space="preserve">
          <source>Notes on using &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#collections.abc.MutableSet&quot;&gt;&lt;code&gt;MutableSet&lt;/code&gt;&lt;/a&gt; as a mixin:</source>
          <target state="translated">믹스 인으로 &lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#collections.abc.MutableSet&quot;&gt; &lt;code&gt;MutableSet&lt;/code&gt; &lt;/a&gt; 사용에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="2174435297546a50c24c84751b2ef81fc8fb5831" translate="yes" xml:space="preserve">
          <source>Notes: (1) For most applications the only &lt;em&gt;preferencelist&lt;/em&gt; combinations that really make sense are &lt;code&gt;('plain',)&lt;/code&gt;, &lt;code&gt;('html', 'plain')&lt;/code&gt;, and the default &lt;code&gt;('related', 'html', 'plain')&lt;/code&gt;. (2) Because matching starts with the object on which &lt;code&gt;get_body&lt;/code&gt; is called, calling &lt;code&gt;get_body&lt;/code&gt; on a &lt;code&gt;multipart/related&lt;/code&gt; will return the object itself unless &lt;em&gt;preferencelist&lt;/em&gt; has a non-default value. (3) Messages (or message parts) that do not specify a &lt;em&gt;Content-Type&lt;/em&gt; or whose &lt;em&gt;Content-Type&lt;/em&gt; header is invalid will be treated as if they are of type &lt;code&gt;text/plain&lt;/code&gt;, which may occasionally cause &lt;code&gt;get_body&lt;/code&gt; to return unexpected results.</source>
          <target state="translated">참고 : (1) 대부분의 응용 프로그램에서 실제로 의미가 있는 유일한 &lt;em&gt;기본 설정 목록&lt;/em&gt; 조합은 &lt;code&gt;('plain',)&lt;/code&gt; , &lt;code&gt;('html', 'plain')&lt;/code&gt; 및 기본값 &lt;code&gt;('related', 'html', 'plain')&lt;/code&gt; . (2)하는 목적에 일치 시작하기 때문에 &lt;code&gt;get_body&lt;/code&gt; 이 호출은 호출 &lt;code&gt;get_body&lt;/code&gt; 을 A의 &lt;code&gt;multipart/related&lt;/code&gt; 않는 오브젝트 자체를 반환 &lt;em&gt;preferencelist이&lt;/em&gt; 디폴트가 아닌 값을 갖는다. (3) 메시지 (또는 메시지 부분)를 지정하지 않은 &lt;em&gt;콘텐츠 형식&lt;/em&gt; 또는 &lt;em&gt;내용 - 형식&lt;/em&gt; 헤더가 형의 경우로 처리됩니다 잘못된 &lt;code&gt;text/plain&lt;/code&gt; ,때때로 발생할 수 있습니다 &lt;code&gt;get_body&lt;/code&gt; 는 예기치 않은 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="409919d20a4d8cdab37ba3de46d6036e52228eae" translate="yes" xml:space="preserve">
          <source>Nothing is specified in this locale.</source>
          <target state="translated">이 로케일에 지정된 것이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5c76d766938924c4560f425f6d8538403d340e8" translate="yes" xml:space="preserve">
          <source>Notice here how we wanted the &lt;em&gt;Subject&lt;/em&gt; field to contain a non-ASCII character? We did this by creating a &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; instance and passing in the character set that the byte string was encoded in. When the subsequent &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance was flattened, the &lt;em&gt;Subject&lt;/em&gt; field was properly &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoded. MIME-aware mail readers would show this header using the embedded ISO-8859-1 character.</source>
          <target state="translated">&lt;em&gt;제목&lt;/em&gt; 필드에 비 ASCII 문자를 포함 시키려면 어떻게해야 합니까? &lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 인스턴스 를 작성 하고 바이트 문자열이 인코딩 된 문자 세트를 전달 하여이 작업을 수행 했습니다. 후속 &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스가 병합되면 &lt;em&gt;Subject&lt;/em&gt; 필드가 올바르게 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 2047로&lt;/strong&gt;&lt;/a&gt; 인코딩되었습니다. MIME 인식 메일 리더는 ISO-8859-1 문자를 사용하여이 헤더를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="30aaa667ceadb867eac4109ef078332b809dce4f" translate="yes" xml:space="preserve">
          <source>Notice how the widget field of the event is being accessed in the &lt;code&gt;turn_red()&lt;/code&gt; callback. This field contains the widget that caught the X event. The following table lists the other event fields you can access, and how they are denoted in Tk, which can be useful when referring to the Tk man pages.</source>
          <target state="translated">&lt;code&gt;turn_red()&lt;/code&gt; 콜백 에서 이벤트의 위젯 필드에 액세스하는 방법을 확인하십시오 . 이 필드에는 X 이벤트를 포착 한 위젯이 있습니다. 다음 표에는 액세스 할 수있는 다른 이벤트 필드와 해당 필드가 Tk로 표시되는 방법이 나와 있으며, 이는 Tk 매뉴얼 페이지를 참조 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="96b9beb737cf3231c7449d825ff3410688086c28" translate="yes" xml:space="preserve">
          <source>Notice that applying &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str()&lt;/code&gt;&lt;/a&gt; to a proxy will return the representation of the referent, whereas applying &lt;a href=&quot;functions#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; will return the representation of the proxy.</source>
          <target state="translated">인가 알 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str()&lt;/code&gt; &lt;/a&gt; 프록시에 적용하는 반면에, 지시 대상의 표현을 반환 &lt;a href=&quot;functions#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 프록시의 표현을 반환한다.</target>
        </trans-unit>
        <trans-unit id="aa30b318f59f62feb7be7cc735b127ba14e6692b" translate="yes" xml:space="preserve">
          <source>Notice that no typechecking is performed when assigning a value of type &lt;a href=&quot;#typing.Any&quot;&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt; to a more precise type. For example, the static type checker did not report an error when assigning &lt;code&gt;a&lt;/code&gt; to &lt;code&gt;s&lt;/code&gt; even though &lt;code&gt;s&lt;/code&gt; was declared to be of type &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and receives an &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; value at runtime!</source>
          <target state="translated">&lt;a href=&quot;#typing.Any&quot;&gt; &lt;code&gt;Any&lt;/code&gt; &lt;/a&gt; 유형의 값을 보다 정확한 유형에 지정할 때는 유형 검사가 수행되지 않습니다 . 할당 할 때 예를 들어, 정적 형식 검사가 오류를보고하지 않았습니다 &lt;code&gt;a&lt;/code&gt; 에 &lt;code&gt;s&lt;/code&gt; 하더라도 &lt;code&gt;s&lt;/code&gt; 타입으로 선언 된 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 수신 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 런타임에 값을!</target>
        </trans-unit>
        <trans-unit id="376b3de67409d19233b0e4907b9f553ccc115c20" translate="yes" xml:space="preserve">
          <source>Notice that on Windows, it&amp;rsquo;s a much smaller set.</source>
          <target state="translated">Windows에서는 훨씬 작은 세트입니다.</target>
        </trans-unit>
        <trans-unit id="2cf0b6869f1edb55f90d57ea0a5832b1aa4e18b8" translate="yes" xml:space="preserve">
          <source>Notice that the behavior of this module depends on the actual implementation of the &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/crypt(3)&quot;&gt;crypt(3)&lt;/a&gt;&lt;/em&gt; routine in the running system. Therefore, any extensions available on the current implementation will also be available on this module.</source>
          <target state="translated">이 모듈의 동작은 실행중인 시스템에서 &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/crypt(3)&quot;&gt;crypt (3)&lt;/a&gt;&lt;/em&gt; 루틴 의 실제 구현에 따라 다릅니다 . 따라서 현재 구현에서 사용 가능한 확장은이 모듈에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c0c4d04cc2d3987360c07fbe4eeb4ed6e5e1e21" translate="yes" xml:space="preserve">
          <source>Now add the Shape to the Screen&amp;rsquo;s shapelist and use it:</source>
          <target state="translated">이제 Shape를 Screen의 shapelist에 추가하고 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="0b5aed1a03f8c35d4b559d5f5099d36802ea5696" translate="yes" xml:space="preserve">
          <source>Now that we have created and saved a configuration file, let&amp;rsquo;s read it back and explore the data it holds.</source>
          <target state="translated">이제 구성 파일을 작성하고 저장 했으므로 파일을 읽고 보유한 데이터를 탐색하십시오.</target>
        </trans-unit>
        <trans-unit id="62f8769fc4f592eaaff3b60938b72976e8a63ca6" translate="yes" xml:space="preserve">
          <source>Now the SSL channel is established and the certificate verified, you can proceed to talk with the server:</source>
          <target state="translated">이제 SSL 채널이 설정되고 인증서가 확인되었으므로 서버와 계속 대화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31924ee76d82b9e37715f009e523c241db6e0226" translate="yes" xml:space="preserve">
          <source>Now we can actually compare the two items and return a useful result:</source>
          <target state="translated">이제 실제로 두 항목을 비교하고 유용한 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5eeebbc7cb554fdc7b5389ad448df86c1df182b" translate="yes" xml:space="preserve">
          <source>Now we plug &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;Row&lt;/code&gt;&lt;/a&gt; in:</source>
          <target state="translated">이제 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;Row&lt;/code&gt; &lt;/a&gt; 을 연결합니다 :</target>
        </trans-unit>
        <trans-unit id="8cb4116ac86e771beb460431be65c48158d5f51c" translate="yes" xml:space="preserve">
          <source>Now we want to test &lt;code&gt;some_function&lt;/code&gt; but we want to mock out &lt;code&gt;SomeClass&lt;/code&gt; using &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt;. The problem is that when we import module b, which we will have to do then it imports &lt;code&gt;SomeClass&lt;/code&gt; from module a. If we use &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; to mock out &lt;code&gt;a.SomeClass&lt;/code&gt; then it will have no effect on our test; module b already has a reference to the &lt;em&gt;real&lt;/em&gt;&lt;code&gt;SomeClass&lt;/code&gt; and it looks like our patching had no effect.</source>
          <target state="translated">이제 &lt;code&gt;some_function&lt;/code&gt; 을 테스트하려고 하지만 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;SomeClass&lt;/code&gt; 를 조롱하려고합니다 . 문제는 모듈 b를 가져올 때 모듈 a에서 &lt;code&gt;SomeClass&lt;/code&gt; 를 가져 오는 것입니다. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;a.SomeClass&lt;/code&gt; 를 조롱하면 테스트에 영향을 미치지 않습니다. 모듈 b는 이미 &lt;em&gt;실제 &lt;/em&gt; &lt;code&gt;SomeClass&lt;/code&gt; 에 대한 참조를 가지고 있으며 패치가 적용되지 않은 것처럼 보입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1ed0c7c2d81859eda6b5cc833464eb0dd988f38" translate="yes" xml:space="preserve">
          <source>Now you need to make the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module know that what you select from the database is actually a point. There are two ways of doing this:</source>
          <target state="translated">이제 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈이 데이터베이스에서 선택한 것이 실제로 포인트라는 것을 알아야합니다. 이를 수행하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d29ec33880afd873623e441fe4abecf453440c79" translate="yes" xml:space="preserve">
          <source>Now you want to store the point in a single SQLite column. First you&amp;rsquo;ll have to choose one of the supported types first to be used for representing the point. Let&amp;rsquo;s just use str and separate the coordinates using a semicolon. Then you need to give your class a method &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; which must return the converted value. The parameter &lt;em&gt;protocol&lt;/em&gt; will be &lt;code&gt;PrepareProtocol&lt;/code&gt;.</source>
          <target state="translated">이제 포인트를 단일 SQLite 열에 저장하려고합니다. 먼저 점을 나타내는 데 사용할 지원되는 유형 중 하나를 먼저 선택해야합니다. str을 사용하고 세미콜론을 사용하여 좌표를 분리합시다. 그런 다음 클래스에 &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; 메소드를 제공하여 변환 된 값을 리턴해야합니다. 매개 변수 &lt;em&gt;프로토콜&lt;/em&gt; 은 &lt;code&gt;PrepareProtocol&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2804678e12fe962caee888447dd00ac076fe71ea" translate="yes" xml:space="preserve">
          <source>Now you want to store the point in a single SQLite column. First you&amp;rsquo;ll have to choose one of the supported types to be used for representing the point. Let&amp;rsquo;s just use str and separate the coordinates using a semicolon. Then you need to give your class a method &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; which must return the converted value. The parameter &lt;em&gt;protocol&lt;/em&gt; will be &lt;code&gt;PrepareProtocol&lt;/code&gt;.</source>
          <target state="translated">이제 단일 SQLite 열에 포인트를 저장하려고합니다. 먼저 포인트를 나타내는 데 사용할 지원되는 유형 중 하나를 선택해야합니다. str을 사용하고 세미콜론을 사용하여 좌표를 분리 해 봅시다. 그런 다음 변환 된 값을 반환 &lt;code&gt;__conform__(self, protocol)&lt;/code&gt; 메서드를 클래스에 제공 해야합니다. 매개 변수 &lt;em&gt;프로토콜&lt;/em&gt; 은 &lt;code&gt;PrepareProtocol&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b6befe568a0abd7fa9cb859e17c6a8a729ffcf6a" translate="yes" xml:space="preserve">
          <source>Null-terminated string containing references to environment variables (&lt;code&gt;%PATH%&lt;/code&gt;).</source>
          <target state="translated">환경 변수에 대한 참조를 포함하는 널 종료 문자열 ( &lt;code&gt;%PATH%&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19a9339a57b70f4cc49edd3bf00a059e1a50c395" translate="yes" xml:space="preserve">
          <source>NullHandler</source>
          <target state="translated">NullHandler</target>
        </trans-unit>
        <trans-unit id="fe1b2483239a18901875b04c1af675561eca1503" translate="yes" xml:space="preserve">
          <source>Number of 512-byte blocks allocated for file. This may be smaller than &lt;a href=&quot;#os.stat_result.st_size&quot;&gt;&lt;code&gt;st_size&lt;/code&gt;&lt;/a&gt;/512 when the file has holes.</source>
          <target state="translated">파일에 할당 된 512 바이트 블록 수 파일에 구멍이있는 경우 &lt;a href=&quot;#os.stat_result.st_size&quot;&gt; &lt;code&gt;st_size&lt;/code&gt; &lt;/a&gt; / 512 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9bd9aeb87537b2525d0c88b89b62a820757528d3" translate="yes" xml:space="preserve">
          <source>Number of days after password expires until account is disabled</source>
          <target state="translated">계정이 비활성화 될 때까지 비밀번호가 만료 된 후 일 수</target>
        </trans-unit>
        <trans-unit id="365942f74cce88224fdaf80b42555c03a1d840aa" translate="yes" xml:space="preserve">
          <source>Number of days before password expires to warn user about it</source>
          <target state="translated">비밀번호가 만료되어 사용자에게 경고하는 일 수</target>
        </trans-unit>
        <trans-unit id="f1d107706720211290a9386c8812c2312f0e8823" translate="yes" xml:space="preserve">
          <source>Number of days since 1970-01-01 when account expires</source>
          <target state="translated">계정이 만료 된 1970-01-01 이후의 일 수</target>
        </trans-unit>
        <trans-unit id="a9ee5a8328ef8d145926d62850a8557baa3d4537" translate="yes" xml:space="preserve">
          <source>Number of fractional digits used in international formatting of monetary values.</source>
          <target state="translated">통화 값의 국제 형식에 사용되는 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="57778df03c86eae3d7455ab3c46c4fdf052bfc73" translate="yes" xml:space="preserve">
          <source>Number of fractional digits used in local formatting of monetary values.</source>
          <target state="translated">통화 값의 로컬 형식에 사용 된 소수 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="6c3cc540d70dfce9e01f95ffe47d1ef75ac135de" translate="yes" xml:space="preserve">
          <source>Number of hard links.</source>
          <target state="translated">하드 링크 수</target>
        </trans-unit>
        <trans-unit id="c971530ee281315f241b2dd1d6ecd30f91644cee" translate="yes" xml:space="preserve">
          <source>Number of items allowed in the queue.</source>
          <target state="translated">대기열에 허용 된 항목 수</target>
        </trans-unit>
        <trans-unit id="a932b86c0474eba5db591ae5f5240a50c1458767" translate="yes" xml:space="preserve">
          <source>Number of links to the inode.</source>
          <target state="translated">inode에 대한 링크 수</target>
        </trans-unit>
        <trans-unit id="4bc5edcccc10a3e8720986ec609357b1e21973dc" translate="yes" xml:space="preserve">
          <source>Number of memory blocks (&lt;code&gt;int&lt;/code&gt;).</source>
          <target state="translated">메모리 블록 수 ( &lt;code&gt;int&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4cac858ebc148236e0b1217a291cec1302b7e513" translate="yes" xml:space="preserve">
          <source>Number of memory blocks in the new snapshot (&lt;code&gt;int&lt;/code&gt;): &lt;code&gt;0&lt;/code&gt; if the memory blocks have been released in the new snapshot.</source>
          <target state="translated">새 스냅 샷의 메모리 블록 수 ( &lt;code&gt;int&lt;/code&gt; ) : 새 스냅 샷 에서 메모리 블록이 해제 된 경우 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c7bc75d07118ba1efb51d5f92550d75df2499753" translate="yes" xml:space="preserve">
          <source>Number-theoretic and representation functions</source>
          <target state="translated">수 이론 및 표현 함수</target>
        </trans-unit>
        <trans-unit id="27268cbddf6ca05f823a05275d4b43b80d3a4bb3" translate="yes" xml:space="preserve">
          <source>Number. This is the same as &lt;code&gt;'d'&lt;/code&gt;, except that it uses the current locale setting to insert the appropriate number separator characters.</source>
          <target state="translated">번호. 이것과 동일 &lt;code&gt;'d'&lt;/code&gt; 는 적절한 수의 구분 문자를 삽입하기 위해 현재 지역 설정을 사용하는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="2247bb12f37411302dec8137671e6f42f4c568a3" translate="yes" xml:space="preserve">
          <source>Number. This is the same as &lt;code&gt;'g'&lt;/code&gt;, except that it uses the current locale setting to insert the appropriate number separator characters.</source>
          <target state="translated">번호. 이것과 동일 &lt;code&gt;'g'&lt;/code&gt; 는 적절한 수의 구분 문자를 삽입하기 위해 현재 지역 설정을 사용하는 것을 제외.</target>
        </trans-unit>
        <trans-unit id="29ab7f8b0894602500582c7973038069b78c9eaf" translate="yes" xml:space="preserve">
          <source>Numbers are created by numeric literals or as the result of built-in functions and operators. Unadorned integer literals (including hex, octal and binary numbers) yield integers. Numeric literals containing a decimal point or an exponent sign yield floating point numbers. Appending &lt;code&gt;'j'&lt;/code&gt; or &lt;code&gt;'J'&lt;/code&gt; to a numeric literal yields an imaginary number (a complex number with a zero real part) which you can add to an integer or float to get a complex number with real and imaginary parts.</source>
          <target state="translated">숫자는 숫자 리터럴 또는 내장 함수 및 연산자의 결과로 생성됩니다. 부호없는 정수 리터럴 (16 진수, 8 진수 및 2 진수 포함)은 정수를 생성합니다. 소수점 또는 지수 부호를 포함하는 숫자 리터럴은 부동 소수점 숫자를 생성합니다. 숫자 리터럴에 &lt;code&gt;'j'&lt;/code&gt; 또는 &lt;code&gt;'J'&lt;/code&gt; 를 추가 하면 허수 (제로 실수 부분이있는 복소수)가 생성되며 정수에 추가하거나 실수로 실수와 허수 부분으로 복소수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9524713edf06bad44da0de5f83160b3103bf5ebf" translate="yes" xml:space="preserve">
          <source>Numbers of the form &lt;code&gt;I/2.**J&lt;/code&gt; are safe across all platforms, and I often contrive doctest examples to produce numbers of that form:</source>
          <target state="translated">&lt;code&gt;I/2.**J&lt;/code&gt; 형식의 숫자는 모든 플랫폼에서 안전하며 종종 doctest 예제를 작성하여 해당 형식의 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ae5a0b6b4520823e7613d9501888e3d11e368899" translate="yes" xml:space="preserve">
          <source>Numerator of the Fraction in lowest term.</source>
          <target state="translated">가장 낮은 용어에서 분수의 분자.</target>
        </trans-unit>
        <trans-unit id="fe7c15f08e26c4968f404fff756bea4c29d294be" translate="yes" xml:space="preserve">
          <source>Numeric &amp;amp; Mathematical</source>
          <target state="translated">숫자 및 수학</target>
        </trans-unit>
        <trans-unit id="9d18068578c94f717e14cf6e56443bc9d65ccc00" translate="yes" xml:space="preserve">
          <source>Numeric Types &amp;mdash; &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;</source>
          <target state="translated">숫자 형 &amp;mdash; &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;complex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0376c4852e68845ab3978d24b24f0cc35e578a" translate="yes" xml:space="preserve">
          <source>Numeric Types &amp;mdash; int, float, complex</source>
          <target state="translated">숫자 유형 &amp;mdash; int, float, complex</target>
        </trans-unit>
        <trans-unit id="77321ffd329dae8a0e37ae9894a49ded0d830d86" translate="yes" xml:space="preserve">
          <source>Numeric and Mathematical Modules</source>
          <target state="translated">숫자 및 수학 모듈</target>
        </trans-unit>
        <trans-unit id="bd54554f02877d81fe4bebfe90fa1408d8cb1959" translate="yes" xml:space="preserve">
          <source>Numeric code specifying the problem. This value can be passed to the &lt;a href=&quot;#xml.parsers.expat.ErrorString&quot;&gt;&lt;code&gt;ErrorString()&lt;/code&gt;&lt;/a&gt; function, or compared to one of the constants defined in the &lt;code&gt;errors&lt;/code&gt; object.</source>
          <target state="translated">문제를 지정하는 숫자 코드. 이 값은 &lt;a href=&quot;#xml.parsers.expat.ErrorString&quot;&gt; &lt;code&gt;ErrorString()&lt;/code&gt; &lt;/a&gt; 함수에 전달 되거나 &lt;code&gt;errors&lt;/code&gt; 객체에 정의 된 상수 중 하나와 비교 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="545ad8b75c0d30c78850cca48b34174137396861" translate="yes" xml:space="preserve">
          <source>Numeric conversion methods: &lt;code&gt;__complex__&lt;/code&gt;, &lt;code&gt;__int__&lt;/code&gt;, &lt;code&gt;__float__&lt;/code&gt; and &lt;code&gt;__index__&lt;/code&gt;</source>
          <target state="translated">숫자 변환 방법 : &lt;code&gt;__complex__&lt;/code&gt; , &lt;code&gt;__int__&lt;/code&gt; , &lt;code&gt;__float__&lt;/code&gt; 및 &lt;code&gt;__index__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="871490f5f5a5ca6fd724e46e5e1c4d2eb2c25301" translate="yes" xml:space="preserve">
          <source>Numeric logging level for the message (&lt;code&gt;DEBUG&lt;/code&gt;, &lt;code&gt;INFO&lt;/code&gt;, &lt;code&gt;WARNING&lt;/code&gt;, &lt;code&gt;ERROR&lt;/code&gt;, &lt;code&gt;CRITICAL&lt;/code&gt;).</source>
          <target state="translated">메시지의 숫자 로깅 레벨 ( &lt;code&gt;DEBUG&lt;/code&gt; , &lt;code&gt;INFO&lt;/code&gt; , &lt;code&gt;WARNING&lt;/code&gt; , &lt;code&gt;ERROR&lt;/code&gt; , &lt;code&gt;CRITICAL&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3bd50801aaae4c7a3a8229dfe2023c97d0cb617c" translate="yes" xml:space="preserve">
          <source>Numeric value</source>
          <target state="translated">숫자 값</target>
        </trans-unit>
        <trans-unit id="b8563a86b2e247948408ea7ca2751b301105c385" translate="yes" xml:space="preserve">
          <source>Numerical group ID</source>
          <target state="translated">숫자 그룹 ID</target>
        </trans-unit>
        <trans-unit id="d6feb6b63e4e9dedb1044129659dca2566b3a4d5" translate="yes" xml:space="preserve">
          <source>Numerical overflow.</source>
          <target state="translated">숫자 오버플로.</target>
        </trans-unit>
        <trans-unit id="504a627804ef772d9d97c9da6cc14b33a6e1fd94" translate="yes" xml:space="preserve">
          <source>Numerical underflow with result rounded to zero.</source>
          <target state="translated">결과가 0으로 반올림 된 수치 언더 플로우.</target>
        </trans-unit>
        <trans-unit id="dae105dbfe6ba9515db517e2c22306eaf168a3ed" translate="yes" xml:space="preserve">
          <source>Numerical user ID</source>
          <target state="translated">숫자 사용자 ID</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="b8e649f839ee53ebcae7841aed5eddf9904a43fd" translate="yes" xml:space="preserve">
          <source>O flag</source>
          <target state="translated">오 플래그</target>
        </trans-unit>
        <trans-unit id="2081f9b4215b950149c134904322caba1359a7a3" translate="yes" xml:space="preserve">
          <source>OS exceptions</source>
          <target state="translated">OS 예외</target>
        </trans-unit>
        <trans-unit id="495dc72791fecbe14725db696ffa42ad8b5edf3d" translate="yes" xml:space="preserve">
          <source>OSError</source>
          <target state="translated">OSError</target>
        </trans-unit>
        <trans-unit id="70bc67f09c2b2fce50ddd07b8816ca72d8245a13" translate="yes" xml:space="preserve">
          <source>OSError.errno</source>
          <target state="translated">OSError.errno</target>
        </trans-unit>
        <trans-unit id="6b00a948ec3f45fe825b1d53b803425a17d2bac9" translate="yes" xml:space="preserve">
          <source>OSError.filename</source>
          <target state="translated">OSError.filename</target>
        </trans-unit>
        <trans-unit id="87b0b664ad8163e07f5f101b197e001d4dadefba" translate="yes" xml:space="preserve">
          <source>OSError.filename2</source>
          <target state="translated">OSError.filename2</target>
        </trans-unit>
        <trans-unit id="1d64b19f5dacbeca7d89e999fabefa0257b25308" translate="yes" xml:space="preserve">
          <source>OSError.strerror</source>
          <target state="translated">OSError.strerror</target>
        </trans-unit>
        <trans-unit id="1252f72b16eb4033e6a82e45191bc3fa864d0cf2" translate="yes" xml:space="preserve">
          <source>OSError.winerror</source>
          <target state="translated">OSError.winerror</target>
        </trans-unit>
        <trans-unit id="fec57e31aba99aafb11659a650fe7e717b5c39f8" translate="yes" xml:space="preserve">
          <source>Object connections</source>
          <target state="translated">객체 연결</target>
        </trans-unit>
        <trans-unit id="ba195d654d6092a3e9da8ddd541dd8c15779615b" translate="yes" xml:space="preserve">
          <source>Object is remote</source>
          <target state="translated">객체가 원격</target>
        </trans-unit>
        <trans-unit id="59b64b94151b6c193b42629c8e0da5f27de1d3fe" translate="yes" xml:space="preserve">
          <source>Object serialization used by &lt;a href=&quot;#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; 가&lt;/a&gt; 사용하는 객체 직렬화 .</target>
        </trans-unit>
        <trans-unit id="94492e219ece2be2aab3f164513645039f660bea" translate="yes" xml:space="preserve">
          <source>Object that is equal to anything. Used to test mixed type comparison.</source>
          <target state="translated">어떤 것과 동등한 객체. 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f503d8f51f7ba310bf7f45e5162a8633bb6e9f0e" translate="yes" xml:space="preserve">
          <source>Object that is greater than anything (except itself). Used to test mixed type comparison.</source>
          <target state="translated">무엇보다 큰 객체 (자체 제외). 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0cd36b2dc674025e7e6b6873e4676f84304e54a" translate="yes" xml:space="preserve">
          <source>Object that is less than anything (except itself). Used to test mixed type comparison.</source>
          <target state="translated">무엇보다 작은 객체 (자체 제외). 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="991224c72c842ab8ac1d85e688f924bd993632e3" translate="yes" xml:space="preserve">
          <source>Object that is not equal to anything (even to &lt;a href=&quot;#test.support.ALWAYS_EQ&quot;&gt;&lt;code&gt;ALWAYS_EQ&lt;/code&gt;&lt;/a&gt;). Used to test mixed type comparison.</source>
          <target state="translated">아무것도 같지 않은 객체 ( &lt;a href=&quot;#test.support.ALWAYS_EQ&quot;&gt; &lt;code&gt;ALWAYS_EQ&lt;/code&gt; 조차도&lt;/a&gt; ). 혼합 유형 비교를 테스트하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="723f3e7fedc35db64092babeaa58ef63cd3624a6" translate="yes" xml:space="preserve">
          <source>Object that when printed, prints the message &amp;ldquo;Type license() to see the full license text&amp;rdquo;, and when called, displays the full license text in a pager-like fashion (one screen at a time).</source>
          <target state="translated">인쇄 할 때&amp;ldquo;전체 라이센스 텍스트를보기 위해 license type을 입력하십시오&amp;rdquo;라는 메시지를 인쇄하고 호출 될 때 전체 라이센스 텍스트를 호출기와 같은 방식으로 표시합니다 (한 번에 한 화면 씩).</target>
        </trans-unit>
        <trans-unit id="6f46d65c8d10b203bddd0e21c7c84db68306a018" translate="yes" xml:space="preserve">
          <source>Object which represents an entire document.</source>
          <target state="translated">전체 문서를 나타내는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7d97a7f0b05a173dd169071a9c7f47af3300ccc5" translate="yes" xml:space="preserve">
          <source>Object whose attributes correspond roughly to the members of the &lt;code&gt;stat&lt;/code&gt; structure. It is used for the result of &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.fstat&quot;&gt;&lt;code&gt;os.fstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">속성이 &lt;code&gt;stat&lt;/code&gt; 구조 의 멤버와 대략 일치하는 객체입니다 . &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.fstat&quot;&gt; &lt;code&gt;os.fstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; 의 결과에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="92ddc22b65e8b5b40d370242a415cbe437e1fb5b" translate="yes" xml:space="preserve">
          <source>Object yielded by &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; to expose the file path and other file attributes of a directory entry.</source>
          <target state="translated">디렉토리 항목의 파일 경로 및 기타 파일 속성을 표시하기 위해 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="b505394857cf752f097451f34e2de726a3519d1d" translate="yes" xml:space="preserve">
          <source>Object-oriented interface to dates and times with similar functionality to the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈 과 유사한 기능을 가진 날짜 및 시간에 대한 객체 지향 인터페이스 .</target>
        </trans-unit>
        <trans-unit id="533836a4f4e1947436d9ed59586d8720b0c3d38a" translate="yes" xml:space="preserve">
          <source>Objects created via this constructor cannot be pickled (see &lt;a href=&quot;#pickling&quot;&gt;pickling&lt;/a&gt;).</source>
          <target state="translated">이 생성자를 통해 생성 된 객체는 피클 할 수 없습니다 ( &lt;a href=&quot;#pickling&quot;&gt;pickling&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4143640e99d59e16fb46fad68725f854ec9f3433" translate="yes" xml:space="preserve">
          <source>Objects created via this constructor will also bypass the cache of a deserializing process when unpickled.</source>
          <target state="translated">이 생성자를 통해 생성 된 객체는 피클을 해제 할 때 역 직렬화 프로세스의 캐시도 우회합니다.</target>
        </trans-unit>
        <trans-unit id="0de0194dce47b55f786136e7ca5d1d1e84495b24" translate="yes" xml:space="preserve">
          <source>Objects implementing the &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; interface have the following methods:</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 인터페이스를 구현하는 객체 에는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d203b8faa0a194771d07d8e7b897dfd529a11dc3" translate="yes" xml:space="preserve">
          <source>Objects in the DOM</source>
          <target state="translated">DOM의 객체</target>
        </trans-unit>
        <trans-unit id="1d2961eba3bc82e095ef8f99f120f340ffafacae" translate="yes" xml:space="preserve">
          <source>Objects instantiated from &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt; can only have their value set to bytes or integers.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; 에서 인스턴스화 된 객체 는 값을 바이트 또는 정수로만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="942293f86c9c554a7407c6e383f6fb514f2d3c50" translate="yes" xml:space="preserve">
          <source>Objects of different types, except different numeric types, never compare equal. The &lt;code&gt;==&lt;/code&gt; operator is always defined but for some object types (for example, class objects) is equivalent to &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators are only defined where they make sense; for example, they raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception when one of the arguments is a complex number.</source>
          <target state="translated">다른 숫자 유형을 제외한 다른 유형의 객체는 결코 동일하지 않습니다. &lt;code&gt;==&lt;/code&gt; 의 조작은 항상 정의되어 있지만, 일부 개체 유형 (예를 들면, 클래스 오브젝트)와 동등 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 가 의미가 어디에 사업자 만 정의; 예를 들어, 인수 중 하나가 복소수 인 경우 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9e090b0f0c940e8935433854198df7f294fb1b61" translate="yes" xml:space="preserve">
          <source>Objects of different types, except different numeric types, never compare equal. The &lt;code&gt;==&lt;/code&gt; operator is always defined but for some object types (for example, class objects) is equivalent to &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is&quot;&gt;&lt;code&gt;is&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt; operators are only defined where they make sense; for example, they raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception when one of the arguments is a complex number.</source>
          <target state="translated">다른 숫자 유형을 제외하고 다른 유형의 객체는 동일하게 비교하지 않습니다. &lt;code&gt;==&lt;/code&gt; 의 조작은 항상 정의되어 있지만, 일부 개체 유형 (예를 들면, 클래스 오브젝트)와 동등 &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#is&quot;&gt; &lt;code&gt;is&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;=&lt;/code&gt; 가 의미가 어디에 사업자 만 정의; 예를 들어, 인수 중 하나가 복소수이면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="844eb425fd6afc3bee0d0b6028be8ef6772711e2" translate="yes" xml:space="preserve">
          <source>Objects of the &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt; type are always naive.</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; 유형의 개체 는 항상 순진합니다.</target>
        </trans-unit>
        <trans-unit id="bd7f72ab2249f983753a1d861db7908c8fcec575" translate="yes" xml:space="preserve">
          <source>Objects of these types are hashable, meaning that they can be used as dictionary keys.</source>
          <target state="translated">이러한 유형의 객체는 해시 가능하므로 사전 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938221cef57f2475840b0471c4e70257edb6b048" translate="yes" xml:space="preserve">
          <source>Objects of these types are immutable.</source>
          <target state="translated">이러한 유형의 객체는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="41b191879a423d793dfaba6e910a7801ce025caa" translate="yes" xml:space="preserve">
          <source>Objects of these types support efficient pickling via the &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">이러한 유형의 객체는 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈을 통한 효율적인 산세를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="5f93dcf2a529620bad38d87c650a52874fefbf22" translate="yes" xml:space="preserve">
          <source>Objects of this class cannot be used to represent timezone information in the locations where different offsets are used in different days of the year or where historical changes have been made to civil time.</source>
          <target state="translated">이 클래스의 객체를 사용하여 연중 다른 날짜에 다른 오프셋이 사용되거나 현지 시간이 역사적으로 변경된 위치의 시간대 정보를 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="214c213394b160163b319993661476db974e76ee" translate="yes" xml:space="preserve">
          <source>Objects returned by &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; when a file is opened for reading have the following methods:</source>
          <target state="translated">읽기 위해 파일을 열 때 &lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 객체 에는 다음과 같은 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="657eae2282d6e60f1300aee5c59552435401221e" translate="yes" xml:space="preserve">
          <source>Objects returned by &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; when a file is opened for writing have all the above methods, except for &lt;code&gt;readframes()&lt;/code&gt; and &lt;code&gt;setpos()&lt;/code&gt;. In addition the following methods exist. The &lt;code&gt;get*()&lt;/code&gt; methods can only be called after the corresponding &lt;code&gt;set*()&lt;/code&gt; methods have been called. Before the first &lt;code&gt;writeframes()&lt;/code&gt; or &lt;code&gt;writeframesraw()&lt;/code&gt;, all parameters except for the number of frames must be filled in.</source>
          <target state="translated">파일을 쓰기 위해 열 때 &lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 반환 한 객체 에는 &lt;code&gt;readframes()&lt;/code&gt; 및 &lt;code&gt;setpos()&lt;/code&gt; 제외한 위의 모든 메서드가 있습니다. 또한 다음과 같은 방법이 있습니다. &lt;code&gt;get*()&lt;/code&gt; 메소드 만이 대응 한 후 호출 할 수 있습니다 &lt;code&gt;set*()&lt;/code&gt; 방법이 호출되고있다. 첫 번째 &lt;code&gt;writeframes()&lt;/code&gt; 또는 &lt;code&gt;writeframesraw()&lt;/code&gt; 전에 프레임 수를 제외한 모든 매개 변수를 채워야합니다.</target>
        </trans-unit>
        <trans-unit id="89396d26028965648a3435a5a9a2e0de20223e3b" translate="yes" xml:space="preserve">
          <source>Objects such as modules and instances have an updateable &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute; however, other objects may have write restrictions on their &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attributes (for example, classes use a &lt;a href=&quot;types#types.MappingProxyType&quot;&gt;&lt;code&gt;types.MappingProxyType&lt;/code&gt;&lt;/a&gt; to prevent direct dictionary updates).</source>
          <target state="translated">모듈 및 인스턴스와 같은 객체에는 업데이트 가능한 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 속성이 있습니다. 그러나 다른 객체의 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 특성 에 대한 쓰기 제한이있을 수 있습니다 (예 : 클래스는 직접 사전 업데이트를 방지하기 위해 &lt;a href=&quot;types#types.MappingProxyType&quot;&gt; &lt;code&gt;types.MappingProxyType&lt;/code&gt; &lt;/a&gt; 을 사용함 ).</target>
        </trans-unit>
        <trans-unit id="24ddcc97acfc6e06b7be05736ede2846c52ff438" translate="yes" xml:space="preserve">
          <source>Objects that when printed or called, print the text of copyright or credits, respectively.</source>
          <target state="translated">인쇄 또는 호출 될 때 각각 저작권 또는 크레디트의 텍스트를 인쇄하는 객체.</target>
        </trans-unit>
        <trans-unit id="6aee9caab0ea803614d4bdec33d7d17a13eeeb34" translate="yes" xml:space="preserve">
          <source>Objects that when printed, print a message like &amp;ldquo;Use quit() or Ctrl-D (i.e. EOF) to exit&amp;rdquo;, and when called, raise &lt;a href=&quot;exceptions#SystemExit&quot;&gt;&lt;code&gt;SystemExit&lt;/code&gt;&lt;/a&gt; with the specified exit code.</source>
          <target state="translated">인쇄시 &quot;quit () 또는 Ctrl-D (예 : EOF)를 사용하여 종료&quot;와 같은 메시지를 인쇄하고 호출되면 지정된 종료 코드를 사용하여 &lt;a href=&quot;exceptions#SystemExit&quot;&gt; &lt;code&gt;SystemExit&lt;/code&gt; &lt;/a&gt; 를 올리 십시오.</target>
        </trans-unit>
        <trans-unit id="317ff8c9afd265b37a084319109dd329ff7e9ee9" translate="yes" xml:space="preserve">
          <source>Objects to be configured are described by dictionaries which detail their configuration. In some places, the logging system will be able to infer from the context how an object is to be instantiated, but when a user-defined object is to be instantiated, the system will not know how to do this. In order to provide complete flexibility for user-defined object instantiation, the user needs to provide a &amp;lsquo;factory&amp;rsquo; - a callable which is called with a configuration dictionary and which returns the instantiated object. This is signalled by an absolute import path to the factory being made available under the special key &lt;code&gt;'()'&lt;/code&gt;. Here&amp;rsquo;s a concrete example:</source>
          <target state="translated">구성 할 개체는 해당 구성을 자세히 설명하는 사전으로 설명됩니다. 경우에 따라 로깅 시스템은 컨텍스트에서 오브젝트의 인스턴스화 방법을 유추 할 수 있지만 사용자 정의 오브젝트를 인스턴스화 할 때 시스템은이를 수행하는 방법을 알 수 없습니다. 사용자 정의 객체 인스턴스화에 대한 완전한 유연성을 제공하기 위해, 사용자는 구성 팩토리와 함께 호출되고 인스턴스화 된 객체를 반환하는 호출 가능한 '공장'을 제공해야합니다. 이것은 특수 키 &lt;code&gt;'()'&lt;/code&gt; 하에서 사용 가능한 팩토리로의 절대 가져 오기 경로로 표시됩니다 . 구체적인 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c09d2d2576e2197a44808fdb59140b84b2d6ab6c" translate="yes" xml:space="preserve">
          <source>Objects with this interface are used to receive error and warning information from the &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt;. If you create an object that implements this interface, then register the object with your &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt;, the parser will call the methods in your object to report all warnings and errors. There are three levels of errors available: warnings, (possibly) recoverable errors, and unrecoverable errors. All methods take a &lt;code&gt;SAXParseException&lt;/code&gt; as the only parameter. Errors and warnings may be converted to an exception by raising the passed-in exception object.</source>
          <target state="translated">이 인터페이스를 가진 객체는 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 로부터 오류 및 경고 정보를받는 데 사용됩니다 . 이 인터페이스를 구현하는 객체를 만든 다음 &lt;a href=&quot;xml.sax.reader#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; 에&lt;/a&gt; 객체를 등록 하면 파서는 객체의 메서드를 호출하여 모든 경고와 오류를보고합니다. 사용 가능한 오류 레벨에는 경고, 복구 가능 오류 및 복구 불가능 오류의 세 가지가 있습니다. 모든 메소드는 &lt;code&gt;SAXParseException&lt;/code&gt; 을 유일한 매개 변수로 사용합니다. 전달 된 예외 개체를 발생시켜 오류 및 경고를 예외로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ffd090521623011161357dcee2bcb6fbdee8700" translate="yes" xml:space="preserve">
          <source>Obsolete type &amp;ndash; it is identical to &lt;code&gt;'d'&lt;/code&gt;.</source>
          <target state="translated">더 이상 사용되지 않는 유형 &amp;ndash; &lt;code&gt;'d'&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b63bbfd86cfd7432e9f0106c88858984af190c93" translate="yes" xml:space="preserve">
          <source>Obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt;. Uses &lt;em&gt;Set-Cookie&lt;/em&gt; with version=1.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2965에서&lt;/strong&gt;&lt;/a&gt; 사용되지 않습니다 . 버전이 1 인 &lt;em&gt;Set-Cookie&lt;/em&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3f55ca62e4ccae40aeb50a0b093437b18720a007" translate="yes" xml:space="preserve">
          <source>Obtaining the Event Loop</source>
          <target state="translated">이벤트 루프 얻기</target>
        </trans-unit>
        <trans-unit id="4f99bb290b9222ef321b66eb0aabb138fcf03891" translate="yes" xml:space="preserve">
          <source>Occasionally, it may be useful to disable the addition of this help option. This can be achieved by passing &lt;code&gt;False&lt;/code&gt; as the &lt;code&gt;add_help=&lt;/code&gt; argument to &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">경우에 따라이 도움말 옵션 추가를 비활성화하는 것이 유용 할 수 있습니다. 이는 전달에 의해 달성 될 수 &lt;code&gt;False&lt;/code&gt; 은 AS &lt;code&gt;add_help=&lt;/code&gt; 에 인수 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="126a6d3a842a574897ac64e80b2a2f96ded4709a" translate="yes" xml:space="preserve">
          <source>Occurs when a subnormal result is pushed to zero by rounding. &lt;a href=&quot;#decimal.Inexact&quot;&gt;&lt;code&gt;Inexact&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#decimal.Subnormal&quot;&gt;&lt;code&gt;Subnormal&lt;/code&gt;&lt;/a&gt; are also signaled.</source>
          <target state="translated">반올림하여 비정상 결과가 0으로 푸시 될 때 발생합니다. &lt;a href=&quot;#decimal.Inexact&quot;&gt; &lt;code&gt;Inexact&lt;/code&gt; &lt;/a&gt; 하고 &lt;a href=&quot;#decimal.Subnormal&quot;&gt; &lt;code&gt;Subnormal&lt;/code&gt; &lt;/a&gt; 신호도 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="1d2ba6a8e415086f99e2740841ad13a25c9e365c" translate="yes" xml:space="preserve">
          <source>Occurs when an operation result is subnormal (the exponent is too small). If not trapped, returns the result unchanged.</source>
          <target state="translated">작업 결과가 비정상 일 때 (지수가 너무 작을 때) 발생합니다. 트랩되지 않은 경우 결과를 변경하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8b690fa09f4c5b0f36d26f6bb8267ab0f5b1a04e" translate="yes" xml:space="preserve">
          <source>Octal escapes are included in a limited form. If the first digit is a 0, or if there are three octal digits, it is considered an octal escape. Otherwise, it is a group reference. As for string literals, octal escapes are always at most three digits in length.</source>
          <target state="translated">8 진 탈출은 제한된 형태로 포함됩니다. 첫 번째 숫자가 0이거나 3 개의 8 진수가있는 경우 8 진수 이스케이프로 간주됩니다. 그렇지 않으면 그룹 참조입니다. 문자열 리터럴의 경우 8 진 이스케이프의 길이는 항상 최대 3 자리입니다.</target>
        </trans-unit>
        <trans-unit id="e48a55708577c922dfe1c8727c5015fe59dcd19c" translate="yes" xml:space="preserve">
          <source>Octal format. Outputs the number in base 8.</source>
          <target state="translated">8 진 형식. 기수 8의 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0c41c8a61bc16d4027683f8db82ba66479208909" translate="yes" xml:space="preserve">
          <source>Of course, as email has been deployed worldwide, it has become internationalized, such that language specific character sets can now be used in email messages. The base standard still requires email messages to be transferred using only 7-bit ASCII characters, so a slew of RFCs have been written describing how to encode email containing non-ASCII characters into &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant format. These RFCs include &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;. The &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package supports these standards in its &lt;a href=&quot;#module-email.header&quot;&gt;&lt;code&gt;email.header&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.charset#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">물론 전자 메일이 전 세계에 배포되면서 언어 별 문자 집합을 전자 메일 메시지에 사용할 수 있도록 국제화되었습니다. 기본 표준에서는 여전히 7 비트 ASCII 문자 만 사용하여 전자 메일 메시지를 전송해야하므로 비 ASCII 문자가 포함 된 전자 메일을 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 형식 으로 인코딩하는 방법을 설명하는 많은 RFC가 작성되었습니다 . 이러한 RFC에는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231이 포함&lt;/strong&gt;&lt;/a&gt; 됩니다. &lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 이러한 표준을 지원 &lt;a href=&quot;#module-email.header&quot;&gt; &lt;code&gt;email.header&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.charset#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="2afb4718d7f7d394f419ceafea003a6616573fac" translate="yes" xml:space="preserve">
          <source>Of course, the dictionary printed will include all the options available and their values. This is meant only as an example.</source>
          <target state="translated">물론 인쇄 된 사전에는 사용 가능한 모든 옵션과 해당 값이 포함됩니다. 이것은 단지 예일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="57957486097ed91a113e640adfd8aa89098b3192" translate="yes" xml:space="preserve">
          <source>Of course, tokens will be returned which are not valid for shells, and you&amp;rsquo;ll need to implement your own error checks on the returned tokens.</source>
          <target state="translated">물론, 셸에 유효하지 않은 토큰이 반환되며 반환 된 토큰에 대해 자체 오류 검사를 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="8d96c2d35a34921bbc473cf1f63f5c7f7ce87d37" translate="yes" xml:space="preserve">
          <source>Of course, you still have to use your head! For instance, it makes no sense to use a forking server if the service contains state in memory that can be modified by different requests, since the modifications in the child process would never reach the initial state kept in the parent process and passed to each child. In this case, you can use a threading server, but you will probably have to use locks to protect the integrity of the shared data.</source>
          <target state="translated">물론, 여전히 머리를 사용해야합니다! 예를 들어, 하위 프로세스의 수정이 상위 프로세스에 유지 된 초기 상태에 도달하지 않고 각 하위에 전달되므로 서비스에 다른 요청에 의해 수정 될 수있는 메모리의 상태가 서비스에 포함 된 경우 분기 서버를 사용하는 것은 의미가 없습니다. . 이 경우 스레딩 서버를 사용할 수 있지만 공유 데이터의 무결성을 보호하려면 잠금을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a189e90de7a831a297990fcc13eed8180febeaaf" translate="yes" xml:space="preserve">
          <source>Of the following list, symbols that are not used on the current platform are not defined by the module. The specific list of defined symbols is available as &lt;code&gt;errno.errorcode.keys()&lt;/code&gt;. Symbols available can include:</source>
          <target state="translated">다음 목록 중 현재 플랫폼에서 사용되지 않는 기호는 모듈에 의해 정의되지 않습니다. 정의 된 심볼의 특정 목록은 &lt;code&gt;errno.errorcode.keys()&lt;/code&gt; 로 사용할 수 있습니다 . 사용 가능한 기호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d6d3eaaecea9032e886e0354de8e806c271d885c" translate="yes" xml:space="preserve">
          <source>Official BLAKE2 website.</source>
          <target state="translated">공식 BLAKE2 웹 사이트.</target>
        </trans-unit>
        <trans-unit id="ce667716547fa82bc8795ad7ef205e9410193ed0" translate="yes" xml:space="preserve">
          <source>Offset</source>
          <target state="translated">Offset</target>
        </trans-unit>
        <trans-unit id="db094d4468a2312d7105c1d93cf46de84f4525c2" translate="yes" xml:space="preserve">
          <source>Often the private key is stored in the same file as the certificate; in this case, only the &lt;code&gt;certfile&lt;/code&gt; parameter to &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt;&lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; needs to be passed. If the private key is stored with the certificate, it should come before the first certificate in the certificate chain:</source>
          <target state="translated">개인 키는 종종 인증서와 동일한 파일에 저장됩니다. 이 경우 &lt;a href=&quot;#ssl.SSLContext.load_cert_chain&quot;&gt; &lt;code&gt;SSLContext.load_cert_chain()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;certfile&lt;/code&gt; 매개 변수 만 전달하면됩니다. 개인 키가 인증서와 함께 저장되면 인증서 체인의 첫 번째 인증서 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="fbb3c38f7157933f1410deccc0c0bd46be6786fa" translate="yes" xml:space="preserve">
          <source>Old</source>
          <target state="translated">Old</target>
        </trans-unit>
        <trans-unit id="b921270420b7b08f1568f831c3397e52a38fa523" translate="yes" xml:space="preserve">
          <source>Old cookies are kept unless overwritten by newly loaded ones.</source>
          <target state="translated">새로로드 한 쿠키로 덮어 쓰지 않는 한 오래된 쿠키는 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="7314a38341e89f90dcb4e508f3c78058527250f6" translate="yes" xml:space="preserve">
          <source>Old getter/setter API for &lt;a href=&quot;#threading.Thread.daemon&quot;&gt;&lt;code&gt;daemon&lt;/code&gt;&lt;/a&gt;; use it directly as a property instead.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread.daemon&quot;&gt; &lt;code&gt;daemon&lt;/code&gt; &lt;/a&gt; 위한 오래된 getter / setter API ; 대신 속성으로 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c7dbcb06ab05ba98c6ef08633aa445b5c4081b42" translate="yes" xml:space="preserve">
          <source>Old getter/setter API for &lt;a href=&quot;#threading.Thread.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt;; use it directly as a property instead.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 대한 오래된 getter / setter API ; 대신 속성으로 직접 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a430408287831c43c01068e431ced99daedf6248" translate="yes" xml:space="preserve">
          <source>Older SQLite versions had issues with sharing connections between threads. That&amp;rsquo;s why the Python module disallows sharing connections and cursors between threads. If you still try to do so, you will get an exception at runtime.</source>
          <target state="translated">이전 SQLite 버전에는 스레드 간 연결 공유에 문제가있었습니다. 그렇기 때문에 파이썬 모듈은 스레드 간 연결 및 커서 공유를 허용하지 않습니다. 여전히 그렇게하려고하면 런타임에 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b798a5717d947276e99cddcb457e1602f3cac8b9" translate="yes" xml:space="preserve">
          <source>Older high-level API</source>
          <target state="translated">오래된 고급 API</target>
        </trans-unit>
        <trans-unit id="6b7df62ceb94ab7be4fe94caa4bfa594c93034e1" translate="yes" xml:space="preserve">
          <source>Omitting values</source>
          <target state="translated">값 생략</target>
        </trans-unit>
        <trans-unit id="1bb81bb7fe8c54a984481046ff452e9ec4cda5b2" translate="yes" xml:space="preserve">
          <source>On Android or in the UTF-8 mode (&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;utf8&lt;/code&gt; option), always return &lt;code&gt;'UTF-8'&lt;/code&gt;, the locale and the &lt;em&gt;do_setlocale&lt;/em&gt; argument are ignored.</source>
          <target state="translated">Android 또는 UTF-8 모드 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;utf8&lt;/code&gt; 옵션)에서 항상 &lt;code&gt;'UTF-8'&lt;/code&gt; 을 리턴 하면 로케일 및 &lt;em&gt;do_setlocale&lt;/em&gt; 인수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="203e6adb380fa1e83c671d16939d8c0b0b5f5fb7" translate="yes" xml:space="preserve">
          <source>On Android or in the UTF-8 mode (&lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;utf8&lt;/code&gt; option), always return &lt;code&gt;'UTF-8'&lt;/code&gt;, the locale and the &lt;em&gt;do_setlocale&lt;/em&gt; argument are ignored.</source>
          <target state="translated">Android 또는 UTF-8 모드 ( &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;utf8&lt;/code&gt; 옵션)에서는 항상 &lt;code&gt;'UTF-8'&lt;/code&gt; 을 반환 하고 로케일 및 &lt;em&gt;do_setlocale&lt;/em&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4464bd203731f640095d017614727a2ce8882aa" translate="yes" xml:space="preserve">
          <source>On Android, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">Android에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cdac50d7ab041ede3970502d373d1b546c0fc224" translate="yes" xml:space="preserve">
          <source>On BSD systems (macOS, FreeBSD, etc.) flow control is not supported for datagram protocols, because there is no reliable way to detect send failures caused by writing too many packets.</source>
          <target state="translated">BSD 시스템 (macOS, FreeBSD 등)에서는 데이터 그램 프로토콜에 대해 흐름 제어가 지원되지 않습니다. 패킷이 너무 많이 작성되어 전송 실패를 감지하는 확실한 방법이 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="5df68af755b4ca9998915a72600b113ea0a954b4" translate="yes" xml:space="preserve">
          <source>On Linux &lt;a href=&quot;os#os.sendfile&quot;&gt;&lt;code&gt;os.sendfile()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Linux에서는 &lt;a href=&quot;os#os.sendfile&quot;&gt; &lt;code&gt;os.sendfile()&lt;/code&gt; &lt;/a&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b894a54ac738054398c257505814cbf2c23a93f5" translate="yes" xml:space="preserve">
          <source>On Linux, &lt;code&gt;find_library()&lt;/code&gt; tries to run external programs (&lt;code&gt;/sbin/ldconfig&lt;/code&gt;, &lt;code&gt;gcc&lt;/code&gt;, &lt;code&gt;objdump&lt;/code&gt; and &lt;code&gt;ld&lt;/code&gt;) to find the library file. It returns the filename of the library file.</source>
          <target state="translated">Linux에서 &lt;code&gt;find_library()&lt;/code&gt; 는 외부 프로그램 ( &lt;code&gt;/sbin/ldconfig&lt;/code&gt; , &lt;code&gt;gcc&lt;/code&gt; , &lt;code&gt;objdump&lt;/code&gt; 및 &lt;code&gt;ld&lt;/code&gt; )을 실행하여 라이브러리 파일을 찾습니다. 라이브러리 파일의 파일 이름을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b7f5823f8fbd988d636ff83e069f2a210239fdad" translate="yes" xml:space="preserve">
          <source>On Linux, if &lt;em&gt;offset&lt;/em&gt; is given as &lt;code&gt;None&lt;/code&gt;, the bytes are read from the current position of &lt;em&gt;in&lt;/em&gt; and the position of &lt;em&gt;in&lt;/em&gt; is updated.</source>
          <target state="translated">경우 리눅스에서 &lt;em&gt;오프셋이&lt;/em&gt; 로 주어진다 &lt;code&gt;None&lt;/code&gt; , 바이트는 현재의 위치에서 읽기 &lt;em&gt;에서&lt;/em&gt; 와의 위치 &lt;em&gt;에&lt;/em&gt; 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="8c474916fc600db3efbd1c743661bfc0f0b02e59" translate="yes" xml:space="preserve">
          <source>On Linux, if &lt;em&gt;offset&lt;/em&gt; is given as &lt;code&gt;None&lt;/code&gt;, the bytes are read from the current position of &lt;em&gt;in_fd&lt;/em&gt; and the position of &lt;em&gt;in_fd&lt;/em&gt; is updated.</source>
          <target state="translated">경우 리눅스에서 &lt;em&gt;오프셋이&lt;/em&gt; 로 주어진다 &lt;code&gt;None&lt;/code&gt; , 바이트는 현재의 위치에서 읽어 &lt;em&gt;in_fd는&lt;/em&gt; 과의 위치 &lt;em&gt;in_fd는이&lt;/em&gt; 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="e281758369d3e3022dacf8f57e2fcc73ab4a776b" translate="yes" xml:space="preserve">
          <source>On Linux, if the &lt;code&gt;getrandom()&lt;/code&gt; syscall is available, it is used in blocking mode: block until the system urandom entropy pool is initialized (128 bits of entropy are collected by the kernel). See the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; for the rationale. On Linux, the &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; function can be used to get random bytes in non-blocking mode (using the &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag) or to poll until the system urandom entropy pool is initialized.</source>
          <target state="translated">Linux에서 &lt;code&gt;getrandom()&lt;/code&gt; syscall을 사용할 수 있으면 차단 모드에서 사용됩니다. 시스템 urandom 엔트로피 풀이 초기화 될 때까지 차단합니다 (128 비트의 엔트로피가 커널에 의해 수집 됨). 이론적 근거 는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-45&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 . Linux에서 &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 함수는 비 차단 모드 ( &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; &lt;/a&gt; 플래그 사용)에서 임의 바이트를 가져 오거나 시스템 urandom 엔트로피 풀이 초기화 될 때까지 폴링 하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7cb52cf7de2620bbb70c3d6b54a151e8aa3360b" translate="yes" xml:space="preserve">
          <source>On Linux, if the &lt;code&gt;getrandom()&lt;/code&gt; syscall is available, it is used in blocking mode: block until the system urandom entropy pool is initialized (128 bits of entropy are collected by the kernel). See the &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-47&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; for the rationale. On Linux, the &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; function can be used to get random bytes in non-blocking mode (using the &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt;&lt;code&gt;GRND_NONBLOCK&lt;/code&gt;&lt;/a&gt; flag) or to poll until the system urandom entropy pool is initialized.</source>
          <target state="translated">Linux에서 &lt;code&gt;getrandom()&lt;/code&gt; syscall을 사용할 수있는 경우 시스템 urandom 엔트로피 풀이 초기화 될 때까지 차단 모드에서 사용됩니다 (커널에서 128 비트의 엔트로피 수집). 근거 는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0524&quot; id=&quot;index-47&quot;&gt;&lt;strong&gt;PEP 524&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 . Linux에서는 &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 비 블로킹 모드 ( &lt;a href=&quot;#os.GRND_NONBLOCK&quot;&gt; &lt;code&gt;GRND_NONBLOCK&lt;/code&gt; &lt;/a&gt; 플래그 사용)에서 임의의 바이트를 가져 오거나 시스템 urandom 엔트로피 풀이 초기화 될 때까지 폴링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34356f543169215adf877047fe8fe6de6815c500" translate="yes" xml:space="preserve">
          <source>On Linux, it is required to specify the filename &lt;em&gt;including&lt;/em&gt; the extension to load a library, so attribute access can not be used to load libraries. Either the &lt;code&gt;LoadLibrary()&lt;/code&gt; method of the dll loaders should be used, or you should load the library by creating an instance of CDLL by calling the constructor:</source>
          <target state="translated">Linux에서는 라이브러리를로드하기위한 확장자를 &lt;em&gt;포함&lt;/em&gt; 하여 파일 이름을 지정해야 하므로 속성 액세스를 사용하여 라이브러리를로드 할 수 없습니다. dll 로더 의 &lt;code&gt;LoadLibrary()&lt;/code&gt; 메소드를 사용하거나 생성자를 호출하여 CDLL 인스턴스를 작성하여 라이브러리를로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="dc1364db7c80f222c6aa60a25008da922cb7a7e1" translate="yes" xml:space="preserve">
          <source>On Mac OS X (and perhaps other platforms), executable files may be universal files containing multiple architectures.</source>
          <target state="translated">Mac OS X (및 기타 플랫폼)에서 실행 파일은 여러 아키텍처를 포함하는 범용 파일 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3005d61cb9e9c1da2b366641dda8f652e63e021" translate="yes" xml:space="preserve">
          <source>On Mac OS X and FreeBSD, a value of 0 for &lt;em&gt;count&lt;/em&gt; specifies to send until the end of &lt;em&gt;in&lt;/em&gt; is reached.</source>
          <target state="translated">맥 OS X와 FreeBSD에서 0의 값을 &lt;em&gt;카운트&lt;/em&gt; 지정이 종료 될 때까지 보내 &lt;em&gt;에&lt;/em&gt; 도달한다.</target>
        </trans-unit>
        <trans-unit id="f2b2d6a45e7bae7bbe9a46add85d282be2542161" translate="yes" xml:space="preserve">
          <source>On Mac OS X and FreeBSD, a value of &lt;code&gt;0&lt;/code&gt; for &lt;em&gt;count&lt;/em&gt; specifies to send until the end of &lt;em&gt;in_fd&lt;/em&gt; is reached.</source>
          <target state="translated">맥 OS X와 FreeBSD에서의 값이 &lt;code&gt;0&lt;/code&gt; 에 대한 &lt;em&gt;카운트&lt;/em&gt; 의 끝까지 지정 보내 &lt;em&gt;in_fd는이&lt;/em&gt; 도달된다.</target>
        </trans-unit>
        <trans-unit id="47c284398b02650696dc28bb5b5b1f62ce624525" translate="yes" xml:space="preserve">
          <source>On Mac OS X, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; behavior differs somewhat from other Unix platforms. If the Python interpreter was built with a deployment target of &lt;code&gt;10.5&lt;/code&gt; or earlier, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; returns the list of effective group ids associated with the current user process; this list is limited to a system-defined number of entries, typically 16, and may be modified by calls to &lt;a href=&quot;#os.setgroups&quot;&gt;&lt;code&gt;setgroups()&lt;/code&gt;&lt;/a&gt; if suitably privileged. If built with a deployment target greater than &lt;code&gt;10.5&lt;/code&gt;, &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; returns the current group access list for the user associated with the effective user id of the process; the group access list may change over the lifetime of the process, it is not affected by calls to &lt;a href=&quot;#os.setgroups&quot;&gt;&lt;code&gt;setgroups()&lt;/code&gt;&lt;/a&gt;, and its length is not limited to 16. The deployment target value, &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt;, can be obtained with &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt;&lt;code&gt;sysconfig.get_config_var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Mac OS X에서 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 동작은 다른 Unix 플랫폼과 약간 다릅니다. Python 인터프리터가 &lt;code&gt;10.5&lt;/code&gt; 이하 의 배치 대상으로 빌드 된 경우 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 는 현재 사용자 프로세스와 연관된 유효 그룹 ID 목록을 리턴합니다. 이 목록은 시스템 정의 항목 수 (일반적으로 16 개 &lt;a href=&quot;#os.setgroups&quot;&gt; &lt;code&gt;setgroups()&lt;/code&gt; &lt;/a&gt; 되며 적절한 권한이있는 경우 setgroups ()를 호출하여 수정할 수 있습니다 . 보다 전개 대상 클로 만든 경우 &lt;code&gt;10.5&lt;/code&gt; , &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 프로세스의 유효 사용자 ID와 연관된 사용자의 현재 그룹 액세스 목록을 반환; 그룹 액세스 목록은 프로세스 수명 동안 변경 될 수 있으며 &lt;a href=&quot;#os.setgroups&quot;&gt; &lt;code&gt;setgroups()&lt;/code&gt; &lt;/a&gt; 호출의 영향을받지 않습니다., 길이는 16으로 제한되지 않습니다. 배치 대상 값 &lt;code&gt;MACOSX_DEPLOYMENT_TARGET&lt;/code&gt; 은 &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt; &lt;code&gt;sysconfig.get_config_var()&lt;/code&gt; &lt;/a&gt; 로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6be300bd70052f23a866a27939e3f7e700d243e4" translate="yes" xml:space="preserve">
          <source>On Mac OS X, &lt;code&gt;sem_timedwait&lt;/code&gt; is unsupported, so calling &lt;code&gt;acquire()&lt;/code&gt; with a timeout will emulate that function&amp;rsquo;s behavior using a sleeping loop.</source>
          <target state="translated">Mac OS X에서는 &lt;code&gt;sem_timedwait&lt;/code&gt; 가 지원되지 않으므로 시간 초과와 함께 &lt;code&gt;acquire()&lt;/code&gt; 를 호출 하면 슬리핑 루프를 사용하여 해당 함수의 동작을 에뮬레이션합니다.</target>
        </trans-unit>
        <trans-unit id="02ec16ecfd2b354d814f70d8478dc9a7f0630d5a" translate="yes" xml:space="preserve">
          <source>On Mac OS X, the length of &lt;em&gt;groups&lt;/em&gt; may not exceed the system-defined maximum number of effective group ids, typically 16. See the documentation for &lt;a href=&quot;#os.getgroups&quot;&gt;&lt;code&gt;getgroups()&lt;/code&gt;&lt;/a&gt; for cases where it may not return the same group list set by calling setgroups().</source>
          <target state="translated">Mac OS X에서 &lt;em&gt;그룹&lt;/em&gt; 길이 는 시스템 정의 최대 유효 그룹 ID 수 (일반적으로 16)를 초과 할 수 없습니다. setgroups ()를 호출하여 동일한 그룹 목록 세트를 리턴하지 않을 수있는 경우 &lt;a href=&quot;#os.getgroups&quot;&gt; &lt;code&gt;getgroups()&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="d466ddfea82165c6998d2732d0fd966668af8aa8" translate="yes" xml:space="preserve">
          <source>On Mac OS X, this is indistinguishable from &lt;a href=&quot;#multiprocessing.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; because &lt;code&gt;sem_getvalue()&lt;/code&gt; is not implemented on that platform.</source>
          <target state="translated">Mac OS X에서는 &lt;code&gt;sem_getvalue()&lt;/code&gt; 가 해당 플랫폼에서 구현되지 않기 때문에 &lt;a href=&quot;#multiprocessing.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; 와&lt;/a&gt; 구별 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80a13c286aa16dd15254ee11f8acc93c6967fcac" translate="yes" xml:space="preserve">
          <source>On Mac OS systems, the following attributes may also be available:</source>
          <target state="translated">Mac OS 시스템에서 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1d8d30d955ec9defda1be84eda85bc8070a5a55" translate="yes" xml:space="preserve">
          <source>On MacOS X, toplevel windows automatically include a built-in size grip by default. Adding a &lt;code&gt;Sizegrip&lt;/code&gt; is harmless, since the built-in grip will just mask the widget.</source>
          <target state="translated">MacOS X에서 최상위 창에는 기본적으로 내장 크기 그립이 자동으로 포함됩니다. 내장 그립이 위젯을 &lt;code&gt;Sizegrip&lt;/code&gt; 때문에 Sizegrip을 추가하는 것은 무해합니다.</target>
        </trans-unit>
        <trans-unit id="b03c534fbf38cbbeafe4e065b76b3779d0494ab0" translate="yes" xml:space="preserve">
          <source>On Microsoft Windows, it may be required to enable the &lt;code&gt;Activate.ps1&lt;/code&gt; script by setting the execution policy for the user. You can do this by issuing the following PowerShell command:</source>
          <target state="translated">Microsoft Windows에서는 사용자에 대한 실행 정책을 설정하여 &lt;code&gt;Activate.ps1&lt;/code&gt; 스크립트를 활성화 해야 할 수 있습니다 . 다음 PowerShell 명령을 실행하여이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047a505ac3a0bde5924ac34403621b5a7b16f3e7" translate="yes" xml:space="preserve">
          <source>On OS X, &lt;code&gt;find_library()&lt;/code&gt; tries several predefined naming schemes and paths to locate the library, and returns a full pathname if successful:</source>
          <target state="translated">OS X에서 &lt;code&gt;find_library()&lt;/code&gt; 는 라이브러리를 찾기 위해 사전 정의 된 여러 이름 지정 체계 및 경로를 시도하고 성공하면 전체 경로 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ee3adeb42a6773c0b5a1d764561ba1bd5f6e5c81" translate="yes" xml:space="preserve">
          <source>On OpenSSL 1.1 and newer the cipher dict contains additional fields:</source>
          <target state="translated">OpenSSL 1.1 이상에서 암호문에는 추가 필드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e86175144551edf0014fe20868235165756774" translate="yes" xml:space="preserve">
          <source>On POSIX platforms the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; socket option is set in order to immediately reuse previous sockets which were bound on the same &lt;em&gt;address&lt;/em&gt; and remained in TIME_WAIT state.</source>
          <target state="translated">POSIX 플랫폼에서 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 소켓 옵션은 동일한 &lt;em&gt;주소&lt;/em&gt; 에 바인드 되어 TIME_WAIT 상태를 유지 한 이전 소켓을 즉시 재사용하기 위해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="14c00f7063151de1165f655a6bb2db8b60c068aa" translate="yes" xml:space="preserve">
          <source>On POSIX platforms, this means that file owner and group are lost as well as ACLs. On Mac OS, the resource fork and other metadata are not used. This means that resources will be lost and file type and creator codes will not be correct. On Windows, file owners, ACLs and alternate data streams are not copied.</source>
          <target state="translated">POSIX 플랫폼에서 이는 파일 소유자 및 그룹과 ACL이 유실되었음을 의미합니다. Mac OS에서는 리소스 포크 및 기타 메타 데이터가 사용되지 않습니다. 이는 리소스가 손실되고 파일 형식과 작성자 코드가 올바르지 않음을 의미합니다. Windows에서는 파일 소유자, ACL 및 대체 데이터 스트림이 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c2f2b0fcb39984b264b9e73654fb68b4dce8860f" translate="yes" xml:space="preserve">
          <source>On POSIX systems this method sends &lt;a href=&quot;signal#signal.SIGTERM&quot;&gt;&lt;code&gt;signal.SIGTERM&lt;/code&gt;&lt;/a&gt; to the child process.</source>
          <target state="translated">POSIX 시스템에서이 메소드는 &lt;a href=&quot;signal#signal.SIGTERM&quot;&gt; &lt;code&gt;signal.SIGTERM&lt;/code&gt; &lt;/a&gt; 을 자식 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="15ae7630db2b82bcf652d24e44fe7ab4a0226a3d" translate="yes" xml:space="preserve">
          <source>On POSIX systems this method sends &lt;code&gt;SIGKILL&lt;/code&gt; to the child process.</source>
          <target state="translated">POSIX 시스템에서이 방법은 &lt;code&gt;SIGKILL&lt;/code&gt; 을 하위 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="7eefcbd33acff5f55854147162274a89ed80a85f" translate="yes" xml:space="preserve">
          <source>On POSIX systems this method sends &lt;code&gt;signal.SIGTERM&lt;/code&gt; to the child process.</source>
          <target state="translated">POSIX 시스템에서이 방법은 &lt;code&gt;signal.SIGTERM&lt;/code&gt; 을 자식 프로세스로 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="d0ff6ad8e999cc10f48eff5c76d5f2a7188b214a" translate="yes" xml:space="preserve">
          <source>On POSIX systems where Python was built with the standard &lt;code&gt;configure&lt;/code&gt; script, this contains the ABI flags as specified by &lt;a href=&quot;https://www.python.org/dev/peps/pep-3149&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3149&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">표준 &lt;code&gt;configure&lt;/code&gt; 스크립트를 사용하여 Python을 빌드 한 POSIX 시스템 에는 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3149&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3149에&lt;/strong&gt;&lt;/a&gt; 지정된 ABI 플래그가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="b236dd13a030ed94e044d584c2fe8291e71001b9" translate="yes" xml:space="preserve">
          <source>On POSIX systems, the function sends SIGKILL to the subprocess. On Windows, this method is an alias for &lt;a href=&quot;#asyncio.SubprocessTransport.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">POSIX 시스템에서이 기능은 SIGKILL을 서브 프로세스로 보냅니다. Windows에서이 메소드는 &lt;a href=&quot;#asyncio.SubprocessTransport.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="f07a49e833d6a2c04f61073e69f1d34ae8d4879c" translate="yes" xml:space="preserve">
          <source>On POSIX systems, this method sends SIGTERM to the subprocess. On Windows, the Windows API function TerminateProcess() is called to stop the subprocess.</source>
          <target state="translated">POSIX 시스템에서이 메소드는 SIGTERM을 서브 프로세스로 보냅니다. Windows에서 Windows API 함수 TerminateProcess ()가 서브 프로세스를 중지하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="39b54d200ee996c99872333f17e610ed05df0ab4" translate="yes" xml:space="preserve">
          <source>On POSIX with &lt;code&gt;shell=True&lt;/code&gt;, the shell defaults to &lt;code&gt;/bin/sh&lt;/code&gt;. If &lt;em&gt;args&lt;/em&gt; is a string, the string specifies the command to execute through the shell. This means that the string must be formatted exactly as it would be when typed at the shell prompt. This includes, for example, quoting or backslash escaping filenames with spaces in them. If &lt;em&gt;args&lt;/em&gt; is a sequence, the first item specifies the command string, and any additional items will be treated as additional arguments to the shell itself. That is to say, &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; does the equivalent of:</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 POSIX 에서 쉘의 기본값은 &lt;code&gt;/bin/sh&lt;/code&gt; 입니다. 경우 &lt;em&gt;인수는&lt;/em&gt; 문자열이 문자열은 쉘을 통해 실행 명령을 지정. 이것은 문자열 프롬프트에서 입력 할 때와 똑같은 형식이어야한다는 것을 의미합니다. 예를 들어 공백이 포함 된 인용 또는 백 슬래시 이스케이프 파일 이름이 포함됩니다. 경우 &lt;em&gt;인수는&lt;/em&gt; 순서는 첫 번째 항목은 명령 문자열을 지정하고, 추가 항목은 쉘 자체에 대한 추가 인수로 처리됩니다. 즉, &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 은 다음과 같은 기능을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e0fbb44798e8fa6c268c46e281d4b570ead4545d" translate="yes" xml:space="preserve">
          <source>On POSIX, if &lt;em&gt;args&lt;/em&gt; is a string, the string is interpreted as the name or path of the program to execute. However, this can only be done if not passing arguments to the program.</source>
          <target state="translated">POSIX에서 &lt;em&gt;args&lt;/em&gt; 가 문자열이면 문자열은 실행할 프로그램의 이름 또는 경로로 해석됩니다. 그러나 이는 프로그램에 인수를 전달하지 않는 경우에만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="042d4232a3ed266a5bf3c414e7d49bafb86c8327" translate="yes" xml:space="preserve">
          <source>On Solaris and derivatives, the following attributes may also be available:</source>
          <target state="translated">Solaris 및 파생 상품에서 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="80cc19f9b1626f125dbd406b222352afad1074ce" translate="yes" xml:space="preserve">
          <source>On UNIX &lt;em&gt;child watchers&lt;/em&gt; are used for subprocess finish waiting, see &lt;a href=&quot;asyncio-policy#asyncio-watchers&quot;&gt;Process Watchers&lt;/a&gt; for more info.</source>
          <target state="translated">UNIX에서 &lt;em&gt;하위 감시자&lt;/em&gt; 는 하위 프로세스 완료 대기에 사용됩니다 . 자세한 정보는 &lt;a href=&quot;asyncio-policy#asyncio-watchers&quot;&gt;프로세스 감시자&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="061033fe6897a382e694d5ebd2c26f0de8aa24b9" translate="yes" xml:space="preserve">
          <source>On UNIX, &lt;a href=&quot;resource#resource.setrlimit&quot;&gt;&lt;code&gt;resource.setrlimit()&lt;/code&gt;&lt;/a&gt; is used to set &lt;a href=&quot;resource#resource.RLIMIT_CORE&quot;&gt;&lt;code&gt;resource.RLIMIT_CORE&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s soft limit to 0 to prevent coredump file creation.</source>
          <target state="translated">UNIX에서 &lt;a href=&quot;resource#resource.setrlimit&quot;&gt; &lt;code&gt;resource.setrlimit()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;resource#resource.RLIMIT_CORE&quot;&gt; &lt;code&gt;resource.RLIMIT_CORE&lt;/code&gt; &lt;/a&gt; 의 소프트 한계를 0으로 설정하여 코어 덤프 파일 작성을 방지 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5303fb5664f54ac196ff0624621bf3e9b937a218" translate="yes" xml:space="preserve">
          <source>On UNIX, non-inheritable file descriptors are closed in child processes at the execution of a new program, other file descriptors are inherited.</source>
          <target state="translated">UNIX에서 상속 불가능한 파일 디스크립터는 새 프로그램 실행시 하위 프로세스에서 닫히고 다른 파일 디스크립터는 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="8c0b4ce9edeaa46004c1ea89a47277ea82f428e7" translate="yes" xml:space="preserve">
          <source>On Unix and Windows, return the argument with an initial component of &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;~user&lt;/code&gt; replaced by that &lt;em&gt;user&lt;/em&gt;&amp;rsquo;s home directory.</source>
          <target state="translated">Unix 및 Windows에서의 초기 구성 요소와 인수를 반환 &lt;code&gt;~&lt;/code&gt; 나 &lt;code&gt;~user&lt;/code&gt; 그 대신 &lt;em&gt;사용자&lt;/em&gt; 의 홈 디렉토리.</target>
        </trans-unit>
        <trans-unit id="b4612ea5389981457aec60b2589e2c3358b80472" translate="yes" xml:space="preserve">
          <source>On Unix using the &lt;em&gt;fork&lt;/em&gt; start method, a child process can make use of a shared resource created in a parent process using a global resource. However, it is better to pass the object as an argument to the constructor for the child process.</source>
          <target state="translated">&lt;em&gt;fork&lt;/em&gt; start 메소드를 사용하는 Unix 에서 하위 프로세스는 글로벌 자원을 사용하여 상위 프로세스에서 작성된 공유 자원을 사용할 수 있습니다. 그러나 자식 프로세스의 생성자에 인수로 객체를 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b0ccbae6c96cdea294fa24abe9f6be651948a8f9" translate="yes" xml:space="preserve">
          <source>On Unix using the &lt;em&gt;spawn&lt;/em&gt; or &lt;em&gt;forkserver&lt;/em&gt; start methods will also start a &lt;em&gt;resource tracker&lt;/em&gt; process which tracks the unlinked named system resources (such as named semaphores or &lt;a href=&quot;multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; objects) created by processes of the program. When all processes have exited the resource tracker unlinks any remaining tracked object. Usually there should be none, but if a process was killed by a signal there may be some &amp;ldquo;leaked&amp;rdquo; resources. (Neither leaked semaphores nor shared memory segments will be automatically unlinked until the next reboot. This is problematic for both objects because the system allows only a limited number of named semaphores, and shared memory segments occupy some space in the main memory.)</source>
          <target state="translated">&lt;em&gt;스폰&lt;/em&gt; 또는 &lt;em&gt;forkserver&lt;/em&gt; start 메소드를 사용하는 Unix 에서는 프로그램 프로세스에 의해 작성된 링크되지 않은 명명 된 시스템 자원 (예 : 명명 된 세마포어 또는 &lt;a href=&quot;multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; &lt;/a&gt; 객체)을 &lt;em&gt;추적&lt;/em&gt; 하는 &lt;em&gt;자원 추적기&lt;/em&gt; 프로세스 도 시작합니다 . 모든 프로세스가 종료되면 리소스 추적기는 나머지 추적 된 개체를 연결 해제합니다. 일반적으로 아무것도 없어야하지만 신호에 의해 프로세스가 종료 된 경우 &quot;누설 된&quot;리소스가있을 수 있습니다. (누적 된 세마포어 나 공유 메모리 세그먼트는 다음에 다시 부팅 할 때까지 자동으로 연결 해제되지 않습니다. 시스템은 제한된 수의 명명 된 세마포어 만 허용하고 공유 메모리 세그먼트는 기본 메모리의 일부 공간을 차지하므로 두 오브젝트 모두에 문제가됩니다.)</target>
        </trans-unit>
        <trans-unit id="4fd6975fe19e134e6847e77c53014ea295e229e5" translate="yes" xml:space="preserve">
          <source>On Unix when a process finishes but has not been joined it becomes a zombie. There should never be very many because each time a new process starts (or &lt;a href=&quot;#multiprocessing.active_children&quot;&gt;&lt;code&gt;active_children()&lt;/code&gt;&lt;/a&gt; is called) all completed processes which have not yet been joined will be joined. Also calling a finished process&amp;rsquo;s &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt;&lt;code&gt;Process.is_alive&lt;/code&gt;&lt;/a&gt; will join the process. Even so it is probably good practice to explicitly join all the processes that you start.</source>
          <target state="translated">프로세스가 완료되었지만 결합되지 않은 Unix에서는 좀비가됩니다. 새 프로세스가 시작될 때마다 (또는 &lt;a href=&quot;#multiprocessing.active_children&quot;&gt; &lt;code&gt;active_children()&lt;/code&gt; &lt;/a&gt; 이 호출 될 때마다 아직 결합되지 않은 완료된 모든 프로세스가 결합 되므로 매우 많지 않아야 합니다 . 또한 완료된 프로세스의 &lt;a href=&quot;#multiprocessing.Process.is_alive&quot;&gt; &lt;code&gt;Process.is_alive&lt;/code&gt; 를&lt;/a&gt; 호출하면 프로세스에 참여합니다. 그럼에도 불구하고 시작하는 모든 프로세스를 명시 적으로 참여시키는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="20c7bf34a19e7e868e7d7ee4afbbdea045c0de94" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;#os.waitstatus_to_exitcode&quot;&gt;&lt;code&gt;waitstatus_to_exitcode()&lt;/code&gt;&lt;/a&gt; can be used to convert the &lt;code&gt;close&lt;/code&gt; method result (exit status) into an exit code if it is not &lt;code&gt;None&lt;/code&gt;. On Windows, the &lt;code&gt;close&lt;/code&gt; method result is directly the exit code (or &lt;code&gt;None&lt;/code&gt;).</source>
          <target state="translated">Unix에서 &lt;a href=&quot;#os.waitstatus_to_exitcode&quot;&gt; &lt;code&gt;waitstatus_to_exitcode()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;close&lt;/code&gt; 메소드 결과 (종료 상태)를 종료 코드 로 변환하는 데 사용할 수 있습니다 . Windows에서 &lt;code&gt;close&lt;/code&gt; 메소드 결과는 직접 종료 코드 (또는 &lt;code&gt;None&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="fd8df95362b8d364eb0e10e82548a253c70aea11" translate="yes" xml:space="preserve">
          <source>On Unix, &lt;a href=&quot;#os.waitstatus_to_exitcode&quot;&gt;&lt;code&gt;waitstatus_to_exitcode()&lt;/code&gt;&lt;/a&gt; can be used to convert the result (exit status) into an exit code. On Windows, the result is directly the exit code.</source>
          <target state="translated">Unix에서는 &lt;a href=&quot;#os.waitstatus_to_exitcode&quot;&gt; &lt;code&gt;waitstatus_to_exitcode()&lt;/code&gt; &lt;/a&gt; 를 사용하여 결과 (종료 상태)를 종료 코드로 변환 할 수 있습니다. Windows에서 결과는 직접 종료 코드입니다.</target>
        </trans-unit>
        <trans-unit id="eac03dafabd5b9228353f47e1be8ab58e5322fe4" translate="yes" xml:space="preserve">
          <source>On Unix, an initial &lt;code&gt;~&lt;/code&gt; is replaced by the environment variable &lt;code id=&quot;index-3&quot;&gt;HOME&lt;/code&gt; if it is set; otherwise the current user&amp;rsquo;s home directory is looked up in the password directory through the built-in module &lt;a href=&quot;pwd#module-pwd&quot;&gt;&lt;code&gt;pwd&lt;/code&gt;&lt;/a&gt;. An initial &lt;code&gt;~user&lt;/code&gt; is looked up directly in the password directory.</source>
          <target state="translated">Unix에서는 초기 &lt;code&gt;~&lt;/code&gt; 가 설정되면 환경 변수 &lt;code id=&quot;index-3&quot;&gt;HOME&lt;/code&gt; 으로 대체됩니다 . 그렇지 않으면 현재 사용자의 홈 디렉토리가 내장 모듈 &lt;a href=&quot;pwd#module-pwd&quot;&gt; &lt;code&gt;pwd&lt;/code&gt; 를&lt;/a&gt; 통해 비밀번호 디렉토리에서 검색 됩니다. 초기 &lt;code&gt;~user&lt;/code&gt; 는 비밀번호 디렉토리에서 직접 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="90a3c08a07528042488b78006ddb2bd1f632d904" translate="yes" xml:space="preserve">
          <source>On Unix, command line arguments are passed by bytes from OS. Python decodes them with filesystem encoding and &amp;ldquo;surrogateescape&amp;rdquo; error handler. When you need original bytes, you can get it by &lt;code&gt;[os.fsencode(arg) for arg in sys.argv]&lt;/code&gt;.</source>
          <target state="translated">Unix에서 명령 행 인수는 OS에서 바이트 단위로 전달됩니다. 파이썬은 파일 시스템 인코딩과&amp;ldquo;surrogateescape&amp;rdquo;에러 핸들러로 그것들을 해독합니다. 원래 바이트가 필요할 때 &lt;code&gt;[os.fsencode(arg) for arg in sys.argv]&lt;/code&gt; 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93002bc4f16ed4f7287d3b4688f861b295aba774" translate="yes" xml:space="preserve">
          <source>On Unix, if &lt;em&gt;src&lt;/em&gt; is a file and &lt;em&gt;dst&lt;/em&gt; is a directory or vice-versa, an &lt;a href=&quot;exceptions#IsADirectoryError&quot;&gt;&lt;code&gt;IsADirectoryError&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt;&lt;code&gt;NotADirectoryError&lt;/code&gt;&lt;/a&gt; will be raised respectively. If both are directories and &lt;em&gt;dst&lt;/em&gt; is empty, &lt;em&gt;dst&lt;/em&gt; will be silently replaced. If &lt;em&gt;dst&lt;/em&gt; is a non-empty directory, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised. If both are files, &lt;em&gt;dst&lt;/em&gt; it will be replaced silently if the user has permission. The operation may fail on some Unix flavors if &lt;em&gt;src&lt;/em&gt; and &lt;em&gt;dst&lt;/em&gt; are on different filesystems. If successful, the renaming will be an atomic operation (this is a POSIX requirement).</source>
          <target state="translated">Unix에서 &lt;em&gt;src&lt;/em&gt; 가 파일이고 &lt;em&gt;dst&lt;/em&gt; 가 디렉토리이거나 그 반대의 경우 &lt;a href=&quot;exceptions#IsADirectoryError&quot;&gt; &lt;code&gt;IsADirectoryError&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;exceptions#NotADirectoryError&quot;&gt; &lt;code&gt;NotADirectoryError&lt;/code&gt; &lt;/a&gt; 가 각각 발생합니다. 둘 다 디렉토리이고 &lt;em&gt;dst&lt;/em&gt; 가 비어 있으면 &lt;em&gt;dst&lt;/em&gt; 가 자동으로 바뀝니다. 경우 &lt;em&gt;DST가&lt;/em&gt; 비어 있지 않은 디렉토리, &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 가&lt;/a&gt; 발생합니다. 둘 다 파일이면 &lt;em&gt;dst&lt;/em&gt; 사용자에게 권한이 있으면 자동으로 바뀝니다. &lt;em&gt;src&lt;/em&gt; 와 &lt;em&gt;dst&lt;/em&gt; 가 다른 파일 시스템에있는 경우 일부 Unix 플레이버에서 작업이 실패 할 수 있습니다 . 성공하면 이름 바꾸기가 원 자성 작업이됩니다 (POSIX 요구 사항).</target>
        </trans-unit>
        <trans-unit id="8925c0a2f7ee268b25b69dc902bb3f8f5965b1b3" translate="yes" xml:space="preserve">
          <source>On Unix, if the process is being traced or if &lt;a href=&quot;#os.waitpid&quot;&gt;&lt;code&gt;waitpid()&lt;/code&gt;&lt;/a&gt; was called with &lt;a href=&quot;#os.WUNTRACED&quot;&gt;&lt;code&gt;WUNTRACED&lt;/code&gt;&lt;/a&gt; option, the caller must first check if &lt;code&gt;WIFSTOPPED(status)&lt;/code&gt; is true. This function must not be called if &lt;code&gt;WIFSTOPPED(status)&lt;/code&gt; is true.</source>
          <target state="translated">Unix에서 프로세스가 추적 중이거나 &lt;a href=&quot;#os.WUNTRACED&quot;&gt; &lt;code&gt;WUNTRACED&lt;/code&gt; &lt;/a&gt; 옵션 으로 &lt;a href=&quot;#os.waitpid&quot;&gt; &lt;code&gt;waitpid()&lt;/code&gt; &lt;/a&gt; 가 호출 된 경우 호출자는 먼저 &lt;code&gt;WIFSTOPPED(status)&lt;/code&gt; 가 참 인지 확인해야 합니다. &lt;code&gt;WIFSTOPPED(status)&lt;/code&gt; 가 true 인 경우이 함수를 호출하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="8780f206d9a466abf25b51a1356f99b2ac3e12d8" translate="yes" xml:space="preserve">
          <source>On Unix, keys and values are decoded with &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler. Use &lt;a href=&quot;#os.getenvb&quot;&gt;&lt;code&gt;os.getenvb()&lt;/code&gt;&lt;/a&gt; if you would like to use a different encoding.</source>
          <target state="translated">Unix에서 키와 값은 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기 로 디코딩됩니다 . 다른 인코딩을 사용 하려면 &lt;a href=&quot;#os.getenvb&quot;&gt; &lt;code&gt;os.getenvb()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2736be53c72c433fb105b8ad845ba0292116edf7" translate="yes" xml:space="preserve">
          <source>On Unix, keys and values use &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler. Use &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; if you would like to use a different encoding.</source>
          <target state="translated">Unix에서 키와 값은 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기를 사용합니다. 다른 인코딩을 사용 하려면 &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0c4f12b4b23fde3793d78231c974ebbe635b6cb" translate="yes" xml:space="preserve">
          <source>On Unix, the &lt;code&gt;myapp.pyz&lt;/code&gt; file is executable as it stands. You can rename the file to remove the &lt;code&gt;.pyz&lt;/code&gt; extension if you prefer a &amp;ldquo;plain&amp;rdquo; command name. On Windows, the &lt;code&gt;myapp.pyz[w]&lt;/code&gt; file is executable by virtue of the fact that the Python interpreter registers the &lt;code&gt;.pyz&lt;/code&gt; and &lt;code&gt;.pyzw&lt;/code&gt; file extensions when installed.</source>
          <target state="translated">Unix에서 &lt;code&gt;myapp.pyz&lt;/code&gt; 파일은 그대로 실행 가능합니다. &quot;일반&quot;명령 이름을 선호하는 경우 파일 이름을 변경하여 &lt;code&gt;.pyz&lt;/code&gt; 확장자 를 제거 할 수 있습니다 . Windows에서 &lt;code&gt;myapp.pyz[w]&lt;/code&gt; 파일은 Python 인터프리터 가 설치 될 때 &lt;code&gt;.pyz&lt;/code&gt; 및 &lt;code&gt;.pyzw&lt;/code&gt; 파일 확장자를 등록한다는 사실 때문에 실행 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f756c834d5e154ecd1fc2f824c744c6fb65726" translate="yes" xml:space="preserve">
          <source>On Unix, the encoding is the locale encoding.</source>
          <target state="translated">Unix에서 인코딩은 로캘 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="4130f28e99fb9d275797c90efd13d5dc34107bb6" translate="yes" xml:space="preserve">
          <source>On Unix, the return value is the exit status of the process encoded in the format specified for &lt;a href=&quot;#os.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;. Note that POSIX does not specify the meaning of the return value of the C &lt;code&gt;system()&lt;/code&gt; function, so the return value of the Python function is system-dependent.</source>
          <target state="translated">Unix에서 리턴 값은 &lt;a href=&quot;#os.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 지정된 형식으로 인코딩 된 프로세스의 종료 상태입니다 . POSIX는 C &lt;code&gt;system()&lt;/code&gt; 함수 의 반환 값의 의미를 지정하지 않으므로 Python 함수의 반환 값은 시스템에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="db73826f114b93339271a1e0fe842703c96cf902" translate="yes" xml:space="preserve">
          <source>On Unix, this method always requires a system call. On Windows, it only requires a system call if &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; and the entry is a reparse point (for example, a symbolic link or directory junction).</source>
          <target state="translated">Unix에서이 메소드는 항상 시스템 호출이 필요합니다. Windows에서는 &lt;em&gt;follow_symlinks&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 이고 항목이 재분석 지점 (예 : 기호 링크 또는 디렉토리 접합) 인 경우에만 시스템 호출이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="150170a27442f2fab1bfdced209dec9ff8347086" translate="yes" xml:space="preserve">
          <source>On Unix-based systems, &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; uses the system&amp;rsquo;s &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html&quot;&gt;opendir()&lt;/a&gt; and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html&quot;&gt;readdir()&lt;/a&gt; functions. On Windows, it uses the Win32 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx&quot;&gt;FindFirstFileW&lt;/a&gt; and &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx&quot;&gt;FindNextFileW&lt;/a&gt; functions.</source>
          <target state="translated">Unix 기반 시스템에서 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 은 시스템의 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/opendir.html&quot;&gt;opendir ()&lt;/a&gt; 및 &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/readdir_r.html&quot;&gt;readdir ()&lt;/a&gt; 함수를 사용합니다. Windows에서는 Win32 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364418(v=vs.85).aspx&quot;&gt;FindFirstFileW&lt;/a&gt; 및 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/aa364428(v=vs.85).aspx&quot;&gt;FindNextFileW&lt;/a&gt; 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cd3be318054f0f7d3a78e6abe995f4e314388b7a" translate="yes" xml:space="preserve">
          <source>On Unix:</source>
          <target state="translated">유닉스에서 :</target>
        </trans-unit>
        <trans-unit id="063f29033f1f42ed60a4000d40548820821c002e" translate="yes" xml:space="preserve">
          <source>On Unix: Wait for completion of a child process given by process id &lt;em&gt;pid&lt;/em&gt;, and return a tuple containing its process id and exit status indication (encoded as for &lt;a href=&quot;#os.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt;). The semantics of the call are affected by the value of the integer &lt;em&gt;options&lt;/em&gt;, which should be &lt;code&gt;0&lt;/code&gt; for normal operation.</source>
          <target state="translated">유닉스에서 : 프로세스 ID &lt;em&gt;pid에&lt;/em&gt; 의해 주어진 자식 프로세스의 완료를 기다렸다가 프로세스 ID와 종료 상태 표시 ( &lt;a href=&quot;#os.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 로 인코딩 됨)를 포함하는 튜플을 반환하십시오 . 호출의 시맨틱은 정수 &lt;em&gt;옵션&lt;/em&gt; 값의 영향을받으며 , 정상 작동의 경우 &lt;code&gt;0&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6664197221cc90bd320057a225826f63dffde52" translate="yes" xml:space="preserve">
          <source>On VT100s and their software emulations, such as X terminal emulators, there are normally at least four function keys (&lt;code&gt;KEY_F1&lt;/code&gt;, &lt;code&gt;KEY_F2&lt;/code&gt;, &lt;code&gt;KEY_F3&lt;/code&gt;, &lt;code&gt;KEY_F4&lt;/code&gt;) available, and the arrow keys mapped to &lt;code&gt;KEY_UP&lt;/code&gt;, &lt;code&gt;KEY_DOWN&lt;/code&gt;, &lt;code&gt;KEY_LEFT&lt;/code&gt; and &lt;code&gt;KEY_RIGHT&lt;/code&gt; in the obvious way. If your machine has a PC keyboard, it is safe to expect arrow keys and twelve function keys (older PC keyboards may have only ten function keys); also, the following keypad mappings are standard:</source>
          <target state="translated">VT100 및 X 터미널 에뮬레이터와 같은 소프트웨어 에뮬레이션에는 일반적으로 사용 가능한 기능 키가 적어도 4 개 ( &lt;code&gt;KEY_F1&lt;/code&gt; , &lt;code&gt;KEY_F2&lt;/code&gt; , &lt;code&gt;KEY_F3&lt;/code&gt; , &lt;code&gt;KEY_F4&lt;/code&gt; )이며 화살표 키는 &lt;code&gt;KEY_UP&lt;/code&gt; , &lt;code&gt;KEY_DOWN&lt;/code&gt; , &lt;code&gt;KEY_LEFT&lt;/code&gt; 및 &lt;code&gt;KEY_RIGHT&lt;/code&gt; 에 명백한 방식으로 매핑됩니다 . 컴퓨터에 PC 키보드가있는 경우 화살표 키와 12 개의 기능 키를 기대하는 것이 안전합니다 (이전 PC 키보드에는 10 개의 기능 키만있을 수 있음). 또한 다음과 같은 키패드 매핑이 표준입니다.</target>
        </trans-unit>
        <trans-unit id="3899987121cefa28d5ca881e747a27db892dca88" translate="yes" xml:space="preserve">
          <source>On VxWorks, os.fork, os.execv and os.spawn*p* are not supported.</source>
          <target state="translated">VxWorks에서는 os.fork, os.execv 및 os.spawn * p *가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ee0d33d4266d631edea6f3c6725804aebe33d95" translate="yes" xml:space="preserve">
          <source>On VxWorks, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">VxWorks에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="203f05598318fc482dff2c5d330d5adcc5f6680a" translate="yes" xml:space="preserve">
          <source>On Windows &lt;a href=&quot;#shutil.copyfile&quot;&gt;&lt;code&gt;shutil.copyfile()&lt;/code&gt;&lt;/a&gt; uses a bigger default buffer size (1 MiB instead of 64 KiB) and a &lt;a href=&quot;stdtypes#memoryview&quot;&gt;&lt;code&gt;memoryview()&lt;/code&gt;&lt;/a&gt;-based variant of &lt;a href=&quot;#shutil.copyfileobj&quot;&gt;&lt;code&gt;shutil.copyfileobj()&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#shutil.copyfile&quot;&gt; &lt;code&gt;shutil.copyfile()&lt;/code&gt; &lt;/a&gt; 은 더 큰 기본 버퍼 크기 (64 KiB 대신 1 MiB)를 사용하고 &lt;a href=&quot;stdtypes#memoryview&quot;&gt; &lt;code&gt;memoryview()&lt;/code&gt; &lt;/a&gt; 기반의 &lt;a href=&quot;#shutil.copyfileobj&quot;&gt; &lt;code&gt;shutil.copyfileobj()&lt;/code&gt; &lt;/a&gt; 변형을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8d9ce61f86eb4d4ac3c24d7367b804553ab20d7c" translate="yes" xml:space="preserve">
          <source>On Windows CE only the standard calling convention is used, for convenience the &lt;a href=&quot;#ctypes.WinDLL&quot;&gt;&lt;code&gt;WinDLL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ctypes.OleDLL&quot;&gt;&lt;code&gt;OleDLL&lt;/code&gt;&lt;/a&gt; use the standard calling convention on this platform.</source>
          <target state="translated">Windows CE에서는 표준 호출 규칙 만 사용되며, 편의상 &lt;a href=&quot;#ctypes.WinDLL&quot;&gt; &lt;code&gt;WinDLL&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.OleDLL&quot;&gt; &lt;code&gt;OleDLL&lt;/code&gt; &lt;/a&gt; 은이 플랫폼에서 표준 호출 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fb04bf356ebd737c66dd73bb5259a054c9ae06c3" translate="yes" xml:space="preserve">
          <source>On Windows creating a &lt;a href=&quot;#ctypes.CDLL&quot;&gt;&lt;code&gt;CDLL&lt;/code&gt;&lt;/a&gt; instance may fail even if the DLL name exists. When a dependent DLL of the loaded DLL is not found, a &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; error is raised with the message &lt;em&gt;&amp;ldquo;[WinError 126] The specified module could not be found&amp;rdquo;.&lt;/em&gt; This error message does not contain the name of the missing DLL because the Windows API does not return this information making this error hard to diagnose. To resolve this error and determine which DLL is not found, you need to find the list of dependent DLLs and determine which one is not found using Windows debugging and tracing tools.</source>
          <target state="translated">Windows 에서는 DLL 이름이 존재하더라도 &lt;a href=&quot;#ctypes.CDLL&quot;&gt; &lt;code&gt;CDLL&lt;/code&gt; &lt;/a&gt; 인스턴스 생성 이 실패 할 수 있습니다. 로드 된 DLL의 종속 DLL을 찾을 &lt;em&gt;수 없으면&amp;ldquo;[WinError 126] The specified module could not be found&amp;rdquo;&lt;/em&gt; 메시지와 함께 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 오류가 발생 &lt;em&gt;합니다. &lt;/em&gt;Windows API가이 정보를 반환하지 않아이 오류를 진단하기 어렵 기 때문에이 오류 메시지에는 누락 된 DLL의 이름이 포함되지 않습니다. 이 오류를 해결하고 찾을 수없는 DLL을 확인하려면 종속 DLL 목록을 찾고 Windows 디버깅 및 추적 도구를 사용하여 찾을 수없는 DLL을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="7681719513275f5101654d8f104bb0a386a1bf9b" translate="yes" xml:space="preserve">
          <source>On Windows network interfaces have different names in different contexts (all names are examples):</source>
          <target state="translated">Windows에서 네트워크 인터페이스는 다른 컨텍스트에서 다른 이름을 갖습니다 (모든 이름은 예임).</target>
        </trans-unit>
        <trans-unit id="0867eba7d4a0405fe6540f206891d83e1500d5af" translate="yes" xml:space="preserve">
          <source>On Windows subprocesses are provided by &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; only (default), &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; has no subprocess support.</source>
          <target state="translated">Windows 하위 프로세스는 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; (기본값) 만 제공하며 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 은 하위 프로세스를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8900df099d23fe4cefc3ed2ff747e1965dae1b2" translate="yes" xml:space="preserve">
          <source>On Windows systems, the following attributes are also available:</source>
          <target state="translated">Windows 시스템에서는 다음 속성도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddfe0eef2e2f38ebe4f48d369d9ce1a6cca527aa" translate="yes" xml:space="preserve">
          <source>On Windows the Win32 API function &lt;code&gt;TerminateProcess()&lt;/code&gt; is called to stop the child process.</source>
          <target state="translated">Windows에서는 하위 프로세스를 중지하기 위해 Win32 API 함수 &lt;code&gt;TerminateProcess()&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="737fe33437bc6a2ea80e837e0281f2030d4293e1" translate="yes" xml:space="preserve">
          <source>On Windows this method is an alias for &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서이 메소드는 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="2a9d37ebffa50750cbeaa7ad01c13a30b0983c37" translate="yes" xml:space="preserve">
          <source>On Windows with &lt;code&gt;shell=True&lt;/code&gt;, the &lt;code id=&quot;index-2&quot;&gt;COMSPEC&lt;/code&gt; environment variable specifies the default shell. The only time you need to specify &lt;code&gt;shell=True&lt;/code&gt; on Windows is when the command you wish to execute is built into the shell (e.g. &lt;strong&gt;dir&lt;/strong&gt; or &lt;strong&gt;copy&lt;/strong&gt;). You do not need &lt;code&gt;shell=True&lt;/code&gt; to run a batch file or console-based executable.</source>
          <target state="translated">&lt;code&gt;shell=True&lt;/code&gt; 인 Windows 에서 &lt;code id=&quot;index-2&quot;&gt;COMSPEC&lt;/code&gt; 환경 변수는 기본 쉘을 지정합니다. Windows에서 &lt;code&gt;shell=True&lt;/code&gt; 를 지정해야하는 유일한 경우는 실행하려는 명령이 쉘에 내장 된 경우입니다 (예 : &lt;strong&gt;dir&lt;/strong&gt; 또는 &lt;strong&gt;copy&lt;/strong&gt; ). 배치 파일 또는 콘솔 기반 실행 파일을 실행하기 위해 &lt;code&gt;shell=True&lt;/code&gt; 가 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="644fd389f0194cebaf7154a9a1f88aabdea9f63c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; uses win32 structured exception handling to prevent crashes from general protection faults when functions are called with invalid argument values:</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 는 win32 구조적 예외 처리를 사용하여 함수가 유효하지 않은 인수 값으로 호출 될 때 일반 보호 결함으로 인한 충돌을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e20bd18b01b22d756d7fbac009a31d413b902ceb" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;/a&gt; can only be called with &lt;a href=&quot;#signal.SIGABRT&quot;&gt;&lt;code&gt;SIGABRT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.SIGFPE&quot;&gt;&lt;code&gt;SIGFPE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.SIGILL&quot;&gt;&lt;code&gt;SIGILL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.SIGINT&quot;&gt;&lt;code&gt;SIGINT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.SIGSEGV&quot;&gt;&lt;code&gt;SIGSEGV&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#signal.SIGTERM&quot;&gt;&lt;code&gt;SIGTERM&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#signal.SIGBREAK&quot;&gt;&lt;code&gt;SIGBREAK&lt;/code&gt;&lt;/a&gt;. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised in any other case. Note that not all systems define the same set of signal names; an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; will be raised if a signal name is not defined as &lt;code&gt;SIG*&lt;/code&gt; module level constant.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal()&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;#signal.SIGABRT&quot;&gt; &lt;code&gt;SIGABRT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#signal.SIGFPE&quot;&gt; &lt;code&gt;SIGFPE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#signal.SIGILL&quot;&gt; &lt;code&gt;SIGILL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#signal.SIGINT&quot;&gt; &lt;code&gt;SIGINT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#signal.SIGSEGV&quot;&gt; &lt;code&gt;SIGSEGV&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#signal.SIGTERM&quot;&gt; &lt;code&gt;SIGTERM&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#signal.SIGBREAK&quot;&gt; &lt;code&gt;SIGBREAK&lt;/code&gt; &lt;/a&gt; 로만 호출 할 수 있습니다 . &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 다른 경우에 발생합니다. 모든 시스템이 동일한 신호 이름 세트를 정의하는 것은 아닙니다. &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 는&lt;/a&gt; 신호 이름으로 정의되어 있지 않은 경우 발생 될 &lt;code&gt;SIG*&lt;/code&gt; 모듈 레벨 상수.</target>
        </trans-unit>
        <trans-unit id="1b11ed5ae47203f10f9e39c4677ebfc9b376f13c" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal()&lt;/code&gt;&lt;/a&gt; can only be called with &lt;code&gt;SIGABRT&lt;/code&gt;, &lt;code&gt;SIGFPE&lt;/code&gt;, &lt;code&gt;SIGILL&lt;/code&gt;, &lt;code&gt;SIGINT&lt;/code&gt;, &lt;code&gt;SIGSEGV&lt;/code&gt;, &lt;code&gt;SIGTERM&lt;/code&gt;, or &lt;code&gt;SIGBREAK&lt;/code&gt;. A &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised in any other case. Note that not all systems define the same set of signal names; an &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt; will be raised if a signal name is not defined as &lt;code&gt;SIG*&lt;/code&gt; module level constant.</source>
          <target state="translated">Windows에서 &lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal()&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;SIGABRT&lt;/code&gt; , &lt;code&gt;SIGFPE&lt;/code&gt; , &lt;code&gt;SIGILL&lt;/code&gt; , &lt;code&gt;SIGINT&lt;/code&gt; , &lt;code&gt;SIGSEGV&lt;/code&gt; , &lt;code&gt;SIGTERM&lt;/code&gt; 또는 &lt;code&gt;SIGBREAK&lt;/code&gt; 만 사용하여 호출 할 수 있습니다 . &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 다른 경우에 발생합니다. 모든 시스템이 동일한 신호 이름 세트를 정의하는 것은 아닙니다. &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; 는&lt;/a&gt; 신호 이름으로 정의되어 있지 않은 경우 발생 될 &lt;code&gt;SIG*&lt;/code&gt; 모듈 레벨 상수.</target>
        </trans-unit>
        <trans-unit id="c63488f33cea6ed67ee2b396df2631f882861591" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code id=&quot;index-4&quot;&gt;USERPROFILE&lt;/code&gt; will be used if set, otherwise a combination of &lt;code id=&quot;index-5&quot;&gt;HOMEPATH&lt;/code&gt; and &lt;code id=&quot;index-6&quot;&gt;HOMEDRIVE&lt;/code&gt; will be used. An initial &lt;code&gt;~user&lt;/code&gt; is handled by stripping the last directory component from the created user path derived above.</source>
          <target state="translated">Windows에서는 &lt;code id=&quot;index-4&quot;&gt;USERPROFILE&lt;/code&gt; 이 설정되면 사용되며 그렇지 않으면 &lt;code id=&quot;index-5&quot;&gt;HOMEPATH&lt;/code&gt; 와 &lt;code id=&quot;index-6&quot;&gt;HOMEDRIVE&lt;/code&gt; 의 조합 이 사용됩니다. 초기 &lt;code&gt;~user&lt;/code&gt; 는 위에서 파생 된 작성된 사용자 경로에서 마지막 디렉토리 구성 요소를 제거하여 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="78373ba9cc1e658aeb2f4b7766b4619af35de1bd" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;%name%&lt;/code&gt; expansions are supported in addition to &lt;code&gt;$name&lt;/code&gt; and &lt;code&gt;${name}&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;$name&lt;/code&gt; 및 &lt;code&gt;${name}&lt;/code&gt; 외에도 &lt;code&gt;%name%&lt;/code&gt; 확장이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9eb07682cf8d7554c89ddc6eb7649bd072a9065" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;SIGTERM&lt;/code&gt; is an alias for &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;CTRL_C_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_BREAK_EVENT&lt;/code&gt; can be sent to processes started with a &lt;em&gt;creationflags&lt;/em&gt; parameter which includes &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;SIGTERM&lt;/code&gt; 은 &lt;a href=&quot;#asyncio.asyncio.subprocess.Process.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 . &lt;code&gt;CTRL_C_EVENT&lt;/code&gt; 및 &lt;code&gt;CTRL_BREAK_EVENT&lt;/code&gt; 는 &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt; 을 포함 하는 &lt;em&gt;creationflags&lt;/em&gt; 매개 변수로 시작된 프로세스로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b164d50e56bce46e5b506000cebb450ea480b3ac" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt;, &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; appear if run-time Windows supports.</source>
          <target state="translated">Windows에서 런타임 Windows가 지원하는 경우 &lt;code&gt;TCP_KEEPIDLE&lt;/code&gt; , &lt;code&gt;TCP_KEEPINTVL&lt;/code&gt; 이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="ae142dbc5c5a17511c3df2343dcf4473e9997091" translate="yes" xml:space="preserve">
          <source>On Windows, &lt;code&gt;find_library()&lt;/code&gt; searches along the system search path, and returns the full pathname, but since there is no predefined naming scheme a call like &lt;code&gt;find_library(&quot;c&quot;)&lt;/code&gt; will fail and return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">Windows에서 &lt;code&gt;find_library()&lt;/code&gt; 는 시스템 검색 경로를 따라 검색하고 전체 경로 이름을 리턴하지만 사전 정의 된 이름 지정 체계가 없으므로 &lt;code&gt;find_library(&quot;c&quot;)&lt;/code&gt; 와 같은 호출 이 실패하고 &lt;code&gt;None&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="5c65155288185d4a2495f910b1a07cb130b3e4d7" translate="yes" xml:space="preserve">
          <source>On Windows, SIGTERM is an alias for &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt;&lt;code&gt;terminate()&lt;/code&gt;&lt;/a&gt;. CTRL_C_EVENT and CTRL_BREAK_EVENT can be sent to processes started with a &lt;em&gt;creationflags&lt;/em&gt; parameter which includes &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt;.</source>
          <target state="translated">Windows에서 SIGTERM은 &lt;a href=&quot;#subprocess.Popen.terminate&quot;&gt; &lt;code&gt;terminate()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 . CTRL_C_EVENT 및 CTRL_BREAK_EVENT 는 &lt;code&gt;CREATE_NEW_PROCESS_GROUP&lt;/code&gt; 을 포함 하는 &lt;em&gt;creationflags&lt;/em&gt; 매개 변수로 시작된 프로세스로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f3b8e43dba078c733dd83c201ede25e60d579e5" translate="yes" xml:space="preserve">
          <source>On Windows, UTF-8 is used for the console device. Non-character devices such as disk files and pipes use the system locale encoding (i.e. the ANSI codepage). Non-console character devices such as NUL (i.e. where &lt;code&gt;isatty()&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;) use the value of the console input and output codepages at startup, respectively for stdin and stdout/stderr. This defaults to the system locale encoding if the process is not initially attached to a console.</source>
          <target state="translated">Windows에서는 콘솔 장치에 UTF-8이 사용됩니다. 디스크 파일 및 파이프와 같은 문자가 아닌 장치는 시스템 로캘 인코딩 (즉, ANSI 코드 페이지)을 사용합니다. NUL과 같은 콘솔 이외의 문자 장치 (예 : &lt;code&gt;isatty()&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 를 반환 하는 경우 ) 는 stdin 및 stdout / stderr에 대해 각각 시작시 콘솔 입력 및 출력 코드 페이지의 값을 사용합니다. 프로세스가 처음 콘솔에 연결되지 않은 경우 시스템 로케일 인코딩이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="b01b208cf55586de3c3689ead1e3a6f10f966e03" translate="yes" xml:space="preserve">
          <source>On Windows, a symlink represents either a file or a directory, and does not morph to the target dynamically. If the target is present, the type of the symlink will be created to match. Otherwise, the symlink will be created as a directory if &lt;em&gt;target_is_directory&lt;/em&gt; is &lt;code&gt;True&lt;/code&gt; or a file symlink (the default) otherwise. On non-Windows platforms, &lt;em&gt;target_is_directory&lt;/em&gt; is ignored.</source>
          <target state="translated">Windows에서 심볼릭 링크는 파일 또는 디렉토리를 나타내며 대상으로 동적으로 변경되지 않습니다. 대상이 존재하면 심볼릭 링크 유형이 일치하도록 작성됩니다. 그렇지 않으면 &lt;em&gt;target_is_directory&lt;/em&gt; 가 &lt;code&gt;True&lt;/code&gt; 이면 심볼릭 링크가 디렉토리로 작성되고 그렇지 않으면 파일 심볼릭 링크 (기본값)가 작성됩니다. Windows 이외의 플랫폼에서는 &lt;em&gt;target_is_directory&lt;/em&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c2d9aee7b296b4bb607ee17ff222cfff0af15e2d" translate="yes" xml:space="preserve">
          <source>On Windows, an &lt;em&gt;args&lt;/em&gt; sequence is converted to a string that can be parsed using the following rules (which correspond to the rules used by the MS C runtime):</source>
          <target state="translated">Windows에서 &lt;em&gt;args&lt;/em&gt; 시퀀스는 다음 규칙을 사용하여 구문 분석 할 수있는 문자열로 변환됩니다 (MS C 런타임에서 사용하는 규칙에 해당).</target>
        </trans-unit>
        <trans-unit id="afd63b6fc8ddc6f6804a57f1784ecec5567ec0b8" translate="yes" xml:space="preserve">
          <source>On Windows, attempting to remove a file that is in use causes an exception to be raised; on Unix, the directory entry is removed but the storage allocated to the file is not made available until the original file is no longer in use.</source>
          <target state="translated">Windows에서 사용중인 파일을 제거하려고하면 예외가 발생합니다. Unix에서는 디렉토리 항목이 제거되지만 원본 파일을 더 이상 사용하지 않을 때까지 파일에 할당 된 스토리지를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="324c0800a7c7e804335674d04ffb5659d07d9331" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;args&lt;/em&gt; is a sequence, it will be converted to a string in a manner described in &lt;a href=&quot;#converting-argument-sequence&quot;&gt;Converting an argument sequence to a string on Windows&lt;/a&gt;. This is because the underlying &lt;code&gt;CreateProcess()&lt;/code&gt; operates on strings.</source>
          <target state="translated">Windows에서 &lt;em&gt;args&lt;/em&gt; 가 시퀀스 이면 Windows에서 &lt;a href=&quot;#converting-argument-sequence&quot;&gt;인수 시퀀스를 문자열&lt;/a&gt; 로 변환에 설명 된 방식으로 문자열로 변환됩니다 . 기본 &lt;code&gt;CreateProcess()&lt;/code&gt; 가 문자열에서 작동 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="1ca0b135ebc47d0ae31593b807a8b41656a98f18" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;close_fds&lt;/em&gt; is true then no handles will be inherited by the child process unless explicitly passed in the &lt;code&gt;handle_list&lt;/code&gt; element of &lt;a href=&quot;#subprocess.STARTUPINFO.lpAttributeList&quot;&gt;&lt;code&gt;STARTUPINFO.lpAttributeList&lt;/code&gt;&lt;/a&gt;, or by standard handle redirection.</source>
          <target state="translated">Windows에서 &lt;em&gt;close_fds&lt;/em&gt; 가 true이면 &lt;a href=&quot;#subprocess.STARTUPINFO.lpAttributeList&quot;&gt; &lt;code&gt;STARTUPINFO.lpAttributeList&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;handle_list&lt;/code&gt; 요소에 명시 적으로 전달 되거나 표준 핸들 리디렉션에 의해 명시 적으로 전달되지 않는 한 하위 프로세스가 핸들을 상속하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="58cdff6f38e8a2fc1c45a1396be1d9e11b5516bf" translate="yes" xml:space="preserve">
          <source>On Windows, if &lt;em&gt;dst&lt;/em&gt; exists a &lt;a href=&quot;exceptions#FileExistsError&quot;&gt;&lt;code&gt;FileExistsError&lt;/code&gt;&lt;/a&gt; is always raised.</source>
          <target state="translated">Windows에서 &lt;em&gt;dst&lt;/em&gt; 가 존재하면 &lt;a href=&quot;exceptions#FileExistsError&quot;&gt; &lt;code&gt;FileExistsError&lt;/code&gt; &lt;/a&gt; 가 항상 발생합니다.</target>
        </trans-unit>
        <trans-unit id="151772e095fb4521d0d15c163d22479ec518b344" translate="yes" xml:space="preserve">
          <source>On Windows, invoke the &lt;code&gt;venv&lt;/code&gt; command as follows:</source>
          <target state="translated">Windows에서 다음과 같이 &lt;code&gt;venv&lt;/code&gt; 명령을 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f8dcef9d943b988c3e3efd4a7635b6a0452bcf9" translate="yes" xml:space="preserve">
          <source>On Windows, it disables Windows Error Reporting dialogs using &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx&quot;&gt;SetErrorMode&lt;/a&gt;.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx&quot;&gt;SetErrorMode를&lt;/a&gt; 사용하여 Windows 오류보고 대화 상자를 사용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="80f74d4a0cc9c87f486e6c7e5dfa2600066b3d59" translate="yes" xml:space="preserve">
          <source>On Windows, it will use &lt;code&gt;CryptGenRandom()&lt;/code&gt;.</source>
          <target state="translated">Windows에서는 &lt;code&gt;CryptGenRandom()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="5fdaa8220ca2781471b1bc92ae5261ce25d132d2" translate="yes" xml:space="preserve">
          <source>On Windows, non-inheritable handles and file descriptors are closed in child processes, except for standard streams (file descriptors 0, 1 and 2: stdin, stdout and stderr), which are always inherited. Using &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; functions, all inheritable handles and all inheritable file descriptors are inherited. Using the &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module, all file descriptors except standard streams are closed, and inheritable handles are only inherited if the &lt;em&gt;close_fds&lt;/em&gt; parameter is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">Windows에서 상속 할 수없는 핸들 및 파일 디스크립터는 항상 상속되는 표준 스트림 (파일 디스크립터 0, 1 및 2 : stdin, stdout 및 stderr)을 제외하고 하위 프로세스에서 닫힙니다. &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수를 사용하면 상속 가능한 모든 핸들과 모든 상속 가능한 파일 설명자가 상속됩니다. &lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈을 사용 하면 표준 스트림을 제외한 모든 파일 디스크립터가 닫히고 상속 가능한 핸들은 &lt;em&gt;close_fds&lt;/em&gt; 매개 변수가 &lt;code&gt;False&lt;/code&gt; 인 경우에만 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="f9dbbca27b5bff454495040c1d717be7efc3364e" translate="yes" xml:space="preserve">
          <source>On Windows, opening a console buffer may return a subclass of &lt;a href=&quot;io#io.RawIOBase&quot;&gt;&lt;code&gt;io.RawIOBase&lt;/code&gt;&lt;/a&gt; other than &lt;a href=&quot;io#io.FileIO&quot;&gt;&lt;code&gt;io.FileIO&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서 콘솔 버퍼를 열면의 서브 클래스 반환 할 수 있습니다 &lt;a href=&quot;io#io.RawIOBase&quot;&gt; &lt;code&gt;io.RawIOBase&lt;/code&gt; &lt;/a&gt; 이외의 &lt;a href=&quot;io#io.FileIO&quot;&gt; &lt;code&gt;io.FileIO&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cfe81378442524ce067312e393681abdbd697179" translate="yes" xml:space="preserve">
          <source>On Windows, passing &lt;code&gt;follow_symlinks=False&lt;/code&gt; will disable following all name-surrogate reparse points, which includes symlinks and directory junctions. Other types of reparse points that do not resemble links or that the operating system is unable to follow will be opened directly. When following a chain of multiple links, this may result in the original link being returned instead of the non-link that prevented full traversal. To obtain stat results for the final path in this case, use the &lt;a href=&quot;os.path#os.path.realpath&quot;&gt;&lt;code&gt;os.path.realpath()&lt;/code&gt;&lt;/a&gt; function to resolve the path name as far as possible and call &lt;a href=&quot;#os.lstat&quot;&gt;&lt;code&gt;lstat()&lt;/code&gt;&lt;/a&gt; on the result. This does not apply to dangling symlinks or junction points, which will raise the usual exceptions.</source>
          <target state="translated">Windows에서 &lt;code&gt;follow_symlinks=False&lt;/code&gt; 를 전달 하면 이름 링크 재분석 지점 ( 심볼 링크 및 디렉토리 정션 포함)을 따르는 것이 비활성화됩니다. 링크와 유사하지 않거나 운영 체제에서 추적 할 수없는 다른 유형의 재분석 지점이 직접 열립니다. 여러 링크 체인을 따라갈 때 전체 순회를 방해하는 비 링크 대신 원래 링크가 리턴 될 수 있습니다. 이 경우 최종 경로에 대한 통계 결과를 얻으려면 &lt;a href=&quot;os.path#os.path.realpath&quot;&gt; &lt;code&gt;os.path.realpath()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 가능한 한 경로 이름 을 확인하고 결과에서 &lt;a href=&quot;#os.lstat&quot;&gt; &lt;code&gt;lstat()&lt;/code&gt; &lt;/a&gt; 를 호출 하십시오. 매달린 심볼릭 링크 또는 접합점에는 적용되지 않으므로 일반적인 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c6205a30ddac655e92925086962c3c5fcb701b9b" translate="yes" xml:space="preserve">
          <source>On Windows, registration of the &lt;code&gt;.pyz&lt;/code&gt; extension is optional, and furthermore, there are certain places that don&amp;rsquo;t recognise registered extensions &amp;ldquo;transparently&amp;rdquo; (the simplest example is that &lt;code&gt;subprocess.run(['myapp'])&lt;/code&gt; won&amp;rsquo;t find your application - you need to explicitly specify the extension).</source>
          <target state="translated">Windows에서 &lt;code&gt;.pyz&lt;/code&gt; 확장명 등록 은 선택 사항이며 등록 된 확장명을 &quot;투명하게&quot;인식하지 못하는 특정 장소가 있습니다 (가장 간단한 예는 &lt;code&gt;subprocess.run(['myapp'])&lt;/code&gt; 가 응용 프로그램-확장명을 명시 적으로 지정해야합니다).</target>
        </trans-unit>
        <trans-unit id="b7cef7a8f7aec70f461146fb489c493eadecdb76" translate="yes" xml:space="preserve">
          <source>On Windows, return &lt;em&gt;status&lt;/em&gt; shifted right by 8 bits.</source>
          <target state="translated">Windows에서 8 비트 오른쪽으로 이동 한 &lt;em&gt;상태를&lt;/em&gt; 반환 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e03e9ab7254bf5d9f3bb216b7f00876ce2b424a1" translate="yes" xml:space="preserve">
          <source>On Windows, some dlls export functions not by name but by ordinal. These functions can be accessed by indexing the dll object with the ordinal number:</source>
          <target state="translated">Windows에서 일부 dll은 이름이 아니라 서수로 함수를 내 보냅니다. 이러한 함수는 서수로 dll 객체를 인덱싱하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf783f34ae011486fa108e118d4bbe59763b0114" translate="yes" xml:space="preserve">
          <source>On Windows, splits a pathname into drive/UNC sharepoint and relative path.</source>
          <target state="translated">Windows에서는 경로 이름을 드라이브 / UNC 공유 지점과 상대 경로로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="68fb8e7f05cf4a3d74f2fa5903e1bafcce342f6e" translate="yes" xml:space="preserve">
          <source>On Windows, the &lt;code&gt;st_ino&lt;/code&gt;, &lt;code&gt;st_dev&lt;/code&gt; and &lt;code&gt;st_nlink&lt;/code&gt; attributes of the &lt;a href=&quot;#os.stat_result&quot;&gt;&lt;code&gt;stat_result&lt;/code&gt;&lt;/a&gt; are always set to zero. Call &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt; to get these attributes.</source>
          <target state="translated">Windows 에서 &lt;a href=&quot;#os.stat_result&quot;&gt; &lt;code&gt;stat_result&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;st_ino&lt;/code&gt; , &lt;code&gt;st_dev&lt;/code&gt; 및 &lt;code&gt;st_nlink&lt;/code&gt; 속성 은 항상 0으로 설정됩니다. 이러한 속성을 얻으려면 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="66761d013cd2216b1b7b3cd2e296f227d596f61c" translate="yes" xml:space="preserve">
          <source>On Windows, the current directory is always prepended to the &lt;em&gt;path&lt;/em&gt; whether or not you use the default or provide your own, which is the behavior the command shell uses when finding executables. Additionally, when finding the &lt;em&gt;cmd&lt;/em&gt; in the &lt;em&gt;path&lt;/em&gt;, the &lt;code&gt;PATHEXT&lt;/code&gt; environment variable is checked. For example, if you call &lt;code&gt;shutil.which(&quot;python&quot;)&lt;/code&gt;, &lt;a href=&quot;#shutil.which&quot;&gt;&lt;code&gt;which()&lt;/code&gt;&lt;/a&gt; will search &lt;code&gt;PATHEXT&lt;/code&gt; to know that it should look for &lt;code&gt;python.exe&lt;/code&gt; within the &lt;em&gt;path&lt;/em&gt; directories. For example, on Windows:</source>
          <target state="translated">Windows에서 현재 디렉토리는 기본값 사용 여부에 관계없이 항상 &lt;em&gt;경로&lt;/em&gt; 앞에 추가됩니다. 이는 실행 파일을 찾을 때 명령 쉘이 사용하는 동작입니다. 발견 할 때 또한 &lt;em&gt;cmd를&lt;/em&gt; 의 &lt;em&gt;경로&lt;/em&gt; 는 &lt;code&gt;PATHEXT&lt;/code&gt; 의 환경 변수를 확인합니다. 예를 들어, 호출하는 경우 &lt;code&gt;shutil.which(&quot;python&quot;)&lt;/code&gt; , &lt;a href=&quot;#shutil.which&quot;&gt; &lt;code&gt;which()&lt;/code&gt; &lt;/a&gt; 를 검색합니다 &lt;code&gt;PATHEXT&lt;/code&gt; 을 그것을 찾아야 알고 &lt;code&gt;python.exe&lt;/code&gt; 를 내에서 &lt;em&gt;경로&lt;/em&gt; 디렉토리. 예를 들어, Windows의 경우 :</target>
        </trans-unit>
        <trans-unit id="983f7bfa681a3a9d17b8f9ddb50e0f8c76511264" translate="yes" xml:space="preserve">
          <source>On Windows, the default event loop &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; supports subprocesses, whereas &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; does not.</source>
          <target state="translated">Windows에서 기본 이벤트 루프 &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 는 하위 프로세스를 지원하지만 &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 는 지원 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d6f7b60f53b56af7a399af55e0827b6d4cfd445" translate="yes" xml:space="preserve">
          <source>On Windows, the directories &lt;code&gt;C:\TEMP&lt;/code&gt;, &lt;code&gt;C:\TMP&lt;/code&gt;, &lt;code&gt;\TEMP&lt;/code&gt;, and &lt;code&gt;\TMP&lt;/code&gt;, in that order.</source>
          <target state="translated">Windows에서 &lt;code&gt;C:\TEMP&lt;/code&gt; , &lt;code&gt;C:\TMP&lt;/code&gt; , &lt;code&gt;\TEMP&lt;/code&gt; 및 &lt;code&gt;\TMP&lt;/code&gt; 디렉토리 는 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="54e0eb52cbdbb1158e147637462f36af394569b1" translate="yes" xml:space="preserve">
          <source>On Windows, the drive letter is not reset when an absolute path component (e.g., &lt;code&gt;r'\foo'&lt;/code&gt;) is encountered. If a component contains a drive letter, all previous components are thrown away and the drive letter is reset. Note that since there is a current directory for each drive, &lt;code&gt;os.path.join(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; represents a path relative to the current directory on drive &lt;code&gt;C:&lt;/code&gt; (&lt;code&gt;c:foo&lt;/code&gt;), not &lt;code&gt;c:\foo&lt;/code&gt;.</source>
          <target state="translated">Windows에서 절대 경로 구성 요소 (예 : &lt;code&gt;r'\foo'&lt;/code&gt; )가 발생 하면 드라이브 문자가 재설정되지 않습니다 . 구성 요소에 드라이브 문자가 포함되어 있으면 이전의 모든 구성 요소가 버리고 드라이브 문자가 재설정됩니다. 각 드라이브에 대한 현재 디렉토리가 있으므로 &lt;code&gt;os.path.join(&quot;c:&quot;, &quot;foo&quot;)&lt;/code&gt; 는 &lt;code&gt;c:\foo&lt;/code&gt; 아니라 &lt;code&gt;C:&lt;/code&gt; 드라이브의 현재 디렉토리에 상대적인 경로를 나타냅니다 ( &lt;code&gt;c:foo&lt;/code&gt; ) . .</target>
        </trans-unit>
        <trans-unit id="c3df504605e52e9837e62d0e690a03b408496ac1" translate="yes" xml:space="preserve">
          <source>On Windows, the encoding may be &lt;code&gt;'utf-8'&lt;/code&gt; or &lt;code&gt;'mbcs'&lt;/code&gt;, depending on user configuration.</source>
          <target state="translated">Windows 에서 사용자 구성에 따라 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 또는 &lt;code&gt;'mbcs'&lt;/code&gt; 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77f58003eb530e09c101d14120e7527b154308b9" translate="yes" xml:space="preserve">
          <source>On Windows, the file-like object created by &lt;a href=&quot;#socket.socket.makefile&quot;&gt;&lt;code&gt;makefile()&lt;/code&gt;&lt;/a&gt; cannot be used where a file object with a file descriptor is expected, such as the stream arguments of &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt;&lt;code&gt;subprocess.Popen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Windows에서, &lt;a href=&quot;#socket.socket.makefile&quot;&gt; &lt;code&gt;makefile()&lt;/code&gt; &lt;/a&gt; 작성된 파일 유사 오브젝트 는 &lt;a href=&quot;subprocess#subprocess.Popen&quot;&gt; &lt;code&gt;subprocess.Popen()&lt;/code&gt; &lt;/a&gt; 의 스트림 인수와 같이 파일 디스크립터가있는 파일 오브젝트가 필요한 위치에서 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0d2f852baab8a06d37a6a99be399f20b228e0595" translate="yes" xml:space="preserve">
          <source>On Windows, the following constants are available for comparing against the &lt;code&gt;st_reparse_tag&lt;/code&gt; member returned by &lt;a href=&quot;os#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt;. These are well-known constants, but are not an exhaustive list.</source>
          <target state="translated">Windows에서 다음 상수는에 대해 비교 가능한 &lt;code&gt;st_reparse_tag&lt;/code&gt; 에 의해 반환 된 멤버 &lt;a href=&quot;os#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; . 이것들은 잘 알려진 상수이지만 완전한 목록은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="548033f4f74edd90159967683a7e43861d78a74e" translate="yes" xml:space="preserve">
          <source>On Windows, the following file attribute constants are available for use when testing bits in the &lt;code&gt;st_file_attributes&lt;/code&gt; member returned by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;. See the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;Windows API documentation&lt;/a&gt; for more detail on the meaning of these constants.</source>
          <target state="translated">Windows에서는 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 리턴 한 &lt;code&gt;st_file_attributes&lt;/code&gt; 멤버 에서 비트를 테스트 할 때 다음 파일 속성 상수를 사용할 수 있습니다 . 이러한 상수의 의미에 대한 자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/gg258117.aspx&quot;&gt;Windows API 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c96823b6f593e3c93fa502eb83c4b5bb1b5a0af" translate="yes" xml:space="preserve">
          <source>On Windows, the return value is that returned by the system shell after running &lt;em&gt;command&lt;/em&gt;. The shell is given by the Windows environment variable &lt;code id=&quot;index-35&quot;&gt;COMSPEC&lt;/code&gt;: it is usually &lt;strong&gt;cmd.exe&lt;/strong&gt;, which returns the exit status of the command run; on systems using a non-native shell, consult your shell documentation.</source>
          <target state="translated">Windows에서 리턴 값은 &lt;em&gt;command&lt;/em&gt; 를 실행 한 후 시스템 쉘이 리턴 한 값입니다 . 셸은 Windows 환경 변수 &lt;code id=&quot;index-35&quot;&gt;COMSPEC&lt;/code&gt; 에 의해 제공됩니다. 일반적으로 &lt;strong&gt;cmd.exe&lt;/strong&gt; 이며 명령 실행의 종료 상태를 반환합니다. 비원시 쉘을 사용하는 시스템에서는 쉘 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e476f5cdebcf0629f48aebee8947070a3e92fcbe" translate="yes" xml:space="preserve">
          <source>On Windows, the return value is that returned by the system shell after running &lt;em&gt;command&lt;/em&gt;. The shell is given by the Windows environment variable &lt;code id=&quot;index-37&quot;&gt;COMSPEC&lt;/code&gt;: it is usually &lt;strong&gt;cmd.exe&lt;/strong&gt;, which returns the exit status of the command run; on systems using a non-native shell, consult your shell documentation.</source>
          <target state="translated">Windows에서 반환 값은 &lt;em&gt;command&lt;/em&gt; 를 실행 한 후 시스템 셸에서 반환 한 값입니다 . 셸은 Windows 환경 변수 &lt;code id=&quot;index-37&quot;&gt;COMSPEC&lt;/code&gt; 에 의해 제공됩니다. 일반적으로 &lt;strong&gt;cmd.exe&lt;/strong&gt; 이며 실행 명령의 종료 상태를 반환합니다. 네이티브가 아닌 쉘을 사용하는 시스템에서는 쉘 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8c1b0007f46b6c5205cec2ccc2367335b248f69b" translate="yes" xml:space="preserve">
          <source>On Windows, therefore, it is often preferable to create an executable from the zipapp. This is relatively easy, although it does require a C compiler. The basic approach relies on the fact that zipfiles can have arbitrary data prepended, and Windows exe files can have arbitrary data appended. So by creating a suitable launcher and tacking the &lt;code&gt;.pyz&lt;/code&gt; file onto the end of it, you end up with a single-file executable that runs your application.</source>
          <target state="translated">따라서 Windows에서는 종종 zipapp에서 실행 파일을 작성하는 것이 좋습니다. C 컴파일러가 필요하지만 비교적 쉽습니다. 기본 접근 방식은 zip 파일에 임의의 데이터가 추가되고 Windows exe 파일에 임의의 데이터가 추가 될 수 있다는 사실에 의존합니다. 따라서 적절한 런처를 만들고 &lt;code&gt;.pyz&lt;/code&gt; 파일을 그 끝에 붙임 으로써 응용 프로그램을 실행하는 단일 파일 실행 파일 이 생깁니다 .</target>
        </trans-unit>
        <trans-unit id="37dc40ac402c8823d0b71dfd8517ae8bdca2012b" translate="yes" xml:space="preserve">
          <source>On Windows, this is an OS handle usable with the &lt;code&gt;WaitForSingleObject&lt;/code&gt; and &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; family of API calls. On Unix, this is a file descriptor usable with primitives from the &lt;a href=&quot;select#module-select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">Windows에서 이는 API 호출 의 &lt;code&gt;WaitForSingleObject&lt;/code&gt; 및 &lt;code&gt;WaitForMultipleObjects&lt;/code&gt; 제품군에서 사용할 수있는 OS 핸들 입니다. 유닉스에서 이것은 &lt;a href=&quot;select#module-select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 모듈의 프리미티브와 함께 사용할 수있는 파일 디스크립터 입니다.</target>
        </trans-unit>
        <trans-unit id="97e0c647fa3b8fd69df5ae6d02b841041c7dc102" translate="yes" xml:space="preserve">
          <source>On Windows, when a foreign function call raises a system exception (for example, due to an access violation), it will be captured and replaced with a suitable Python exception. Further, an auditing event &lt;code&gt;ctypes.seh_exception&lt;/code&gt; with argument &lt;code&gt;code&lt;/code&gt; will be raised, allowing an audit hook to replace the exception with its own.</source>
          <target state="translated">Windows에서 외부 함수 호출로 인해 시스템 예외 (예 : 액세스 위반으로 인해)가 발생하면이를 캡처하여 적합한 Python 예외로 대체합니다. 또한 인수 &lt;code&gt;code&lt;/code&gt; 와 함께 감사 이벤트 &lt;code&gt;ctypes.seh_exception&lt;/code&gt; 이 발생하여 감사 후크가 예외를 자체로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10b5f3f739606c767f0a53174c343344eb123b63" translate="yes" xml:space="preserve">
          <source>On Windows, when duplicating a standard stream (0: stdin, 1: stdout, 2: stderr), the new file descriptor is &lt;a href=&quot;#fd-inheritance&quot;&gt;inheritable&lt;/a&gt;.</source>
          <target state="translated">Windows에서 표준 스트림 (0 : stdin, 1 : stdout, 2 : stderr)을 복제 할 때 새 파일 디스크립터는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 가능&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="fb6115c799330ee3de4f9e4a92324f487e44ec5f" translate="yes" xml:space="preserve">
          <source>On Windows: Wait for completion of a process given by process handle &lt;em&gt;pid&lt;/em&gt;, and return a tuple containing &lt;em&gt;pid&lt;/em&gt;, and its exit status shifted left by 8 bits (shifting makes cross-platform use of the function easier). A &lt;em&gt;pid&lt;/em&gt; less than or equal to &lt;code&gt;0&lt;/code&gt; has no special meaning on Windows, and raises an exception. The value of integer &lt;em&gt;options&lt;/em&gt; has no effect. &lt;em&gt;pid&lt;/em&gt; can refer to any process whose id is known, not necessarily a child process. The &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; functions called with &lt;a href=&quot;#os.P_NOWAIT&quot;&gt;&lt;code&gt;P_NOWAIT&lt;/code&gt;&lt;/a&gt; return suitable process handles.</source>
          <target state="translated">Windows의 경우 : 프로세스 핸들에 의해 주어진 프로세스가 완료 될 때까지 기다립니다 &lt;em&gt;PID&lt;/em&gt; 및 튜플 포함 반환 &lt;em&gt;PID를&lt;/em&gt; , 그 종료 상태 8 비트 (이동 쉽게 함수의 크로스 플랫폼을 사용합니다) 왼쪽으로 시프트. A는 &lt;em&gt;PID&lt;/em&gt; 보다 작거나 같음 &lt;code&gt;0&lt;/code&gt; Windows에서 특별한 의미가없는, 예외를 발생시킵니다. 정수 &lt;em&gt;옵션&lt;/em&gt; 의 값은 영향을 미치지 않습니다. &lt;em&gt;pid&lt;/em&gt; 는 반드시 자식 프로세스 일 필요는 없지만 id가 알려진 프로세스를 가리킬 수 있습니다. &lt;a href=&quot;#os.P_NOWAIT&quot;&gt; &lt;code&gt;P_NOWAIT&lt;/code&gt; &lt;/a&gt; 로 호출 된 &lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수는 적절한 프로세스 핸들을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5f12c3a4544b46b4dcf9f6fec778669f13f9f9d3" translate="yes" xml:space="preserve">
          <source>On a Unix-like system, random bytes are read from the &lt;code&gt;/dev/urandom&lt;/code&gt; device. If the &lt;code&gt;/dev/urandom&lt;/code&gt; device is not available or not readable, the &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; exception is raised.</source>
          <target state="translated">유닉스 계열 시스템에서는 &lt;code&gt;/dev/urandom&lt;/code&gt; 장치 에서 임의 바이트를 읽습니다 . 경우 &lt;code&gt;/dev/urandom&lt;/code&gt; 장치를 읽을 가능 여부되지는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 의&lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2601d2cefa3f396475ef76603408eb2f24b04bbb" translate="yes" xml:space="preserve">
          <source>On all other platforms, the directories &lt;code&gt;/tmp&lt;/code&gt;, &lt;code&gt;/var/tmp&lt;/code&gt;, and &lt;code&gt;/usr/tmp&lt;/code&gt;, in that order.</source>
          <target state="translated">다른 모든 플랫폼에서는 &lt;code&gt;/tmp&lt;/code&gt; , &lt;code&gt;/var/tmp&lt;/code&gt; 및 &lt;code&gt;/usr/tmp&lt;/code&gt; 디렉토리 가 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc2d24ff952b9a8190a5c30dcfc6274d113abed" translate="yes" xml:space="preserve">
          <source>On all platforms, the configured value is available as the &lt;code&gt;TZPATH&lt;/code&gt; key in &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt;&lt;code&gt;sysconfig.get_config_var()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모든 플랫폼에서 구성된 값은 &lt;a href=&quot;sysconfig#sysconfig.get_config_var&quot;&gt; &lt;code&gt;sysconfig.get_config_var()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;TZPATH&lt;/code&gt; 키로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="46dbf9b949c04044ffab0fab48aba4115d7ca33a" translate="yes" xml:space="preserve">
          <source>On both platforms, the old value is restored by &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 플랫폼 모두에서 이전 값은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 의해 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="17c3210130adf4765432271b8ea3db329dae5e0f" translate="yes" xml:space="preserve">
          <source>On both platforms, the old value is restored by &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 플랫폼 모두에서 이전 값은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 의해 복원됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e7006d98db74f1849b0b0e7ef365ada8d73e13e" translate="yes" xml:space="preserve">
          <source>On client connections, the optional parameter &lt;em&gt;server_hostname&lt;/em&gt; specifies the hostname of the service which we are connecting to. This allows a single server to host multiple SSL-based services with distinct certificates, quite similarly to HTTP virtual hosts. Specifying &lt;em&gt;server_hostname&lt;/em&gt; will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;server_side&lt;/em&gt; is true.</source>
          <target state="translated">클라이언트 연결에서 선택적 매개 변수 &lt;em&gt;server_hostname&lt;/em&gt; 은 연결중인 서비스의 호스트 이름을 지정합니다. 이를 통해 단일 서버는 HTTP 가상 호스트와 매우 유사한 고유 한 인증서로 여러 SSL 기반 서비스를 호스팅 할 수 있습니다. &lt;em&gt;server_side&lt;/em&gt; 가 true 인 경우 &lt;em&gt;server_hostname&lt;/em&gt; 을 지정 하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="67540c72da6a0c69935598617862e3eb3b0268da" translate="yes" xml:space="preserve">
          <source>On decoding, replace byte with individual surrogate code ranging from &lt;code&gt;U+DC80&lt;/code&gt; to &lt;code&gt;U+DCFF&lt;/code&gt;. This code will then be turned back into the same byte when the &lt;code&gt;'surrogateescape'&lt;/code&gt; error handler is used when encoding the data. (See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; for more.)</source>
          <target state="translated">복호에 이르기까지 각각의 대리 바이트 코드 교체 &lt;code&gt;U+DC80&lt;/code&gt; 에 &lt;code&gt;U+DCFF&lt;/code&gt; . 이 코드는 데이터를 인코딩 할 때 &lt;code&gt;'surrogateescape'&lt;/code&gt; 오류 처리기가 사용될 때 동일한 바이트로 다시 변환 됩니다. (자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0383&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 383&lt;/strong&gt;&lt;/a&gt; 을 참조하십시오 .)</target>
        </trans-unit>
        <trans-unit id="40a675dc2422036bd8b6d3953dd22e9373dc65f0" translate="yes" xml:space="preserve">
          <source>On encountering an invalid cookie, &lt;a href=&quot;#http.cookies.CookieError&quot;&gt;&lt;code&gt;CookieError&lt;/code&gt;&lt;/a&gt; is raised, so if your cookie data comes from a browser you should always prepare for invalid data and catch &lt;a href=&quot;#http.cookies.CookieError&quot;&gt;&lt;code&gt;CookieError&lt;/code&gt;&lt;/a&gt; on parsing.</source>
          <target state="translated">유효하지 않은 쿠키가 발생하면 &lt;a href=&quot;#http.cookies.CookieError&quot;&gt; &lt;code&gt;CookieError&lt;/code&gt; &lt;/a&gt; 가 발생하므로 쿠키 데이터가 브라우저에서 제공되면 항상 유효하지 않은 데이터를 준비 하고 구문 분석시 &lt;a href=&quot;#http.cookies.CookieError&quot;&gt; &lt;code&gt;CookieError&lt;/code&gt; &lt;/a&gt; 를 잡아야 합니다.</target>
        </trans-unit>
        <trans-unit id="34f29889fea4fa5095b6af09d7ca99a6568ae898" translate="yes" xml:space="preserve">
          <source>On entry to the context manager, a &lt;code&gt;WarningRecorder&lt;/code&gt; instance is returned. The underlying warnings list from &lt;a href=&quot;warnings#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings()&lt;/code&gt;&lt;/a&gt; is available via the recorder object&amp;rsquo;s &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; attribute. As a convenience, the attributes of the object representing the most recent warning can also be accessed directly through the recorder object (see example below). If no warning has been raised, then any of the attributes that would otherwise be expected on an object representing a warning will return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자에 진입하면 &lt;code&gt;WarningRecorder&lt;/code&gt; 인스턴스가 리턴됩니다. &lt;a href=&quot;warnings#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings()&lt;/code&gt; &lt;/a&gt; 의 기본 경고 목록 은 레코더 개체의 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 속성을 통해 사용할 수 있습니다 . 편의상 가장 최근 경고를 나타내는 객체의 속성은 레코더 객체를 통해 직접 액세스 할 수도 있습니다 (아래 예 참조). 경고가 발생하지 않으면 경고를 나타내는 객체에서 예상되는 속성은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="689aca40c906c0122884f520ca113dd2d097568c" translate="yes" xml:space="preserve">
          <source>On large-file-capable Linux systems, this might work:</source>
          <target state="translated">대용량 파일 가능 Linux 시스템에서는 다음과 같이 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b7b3c25b067b29ff568eb64dceface5effcedb6" translate="yes" xml:space="preserve">
          <source>On macOS 10.6, 10.7 and 10.8, the default event loop uses &lt;a href=&quot;selectors#selectors.KqueueSelector&quot;&gt;&lt;code&gt;selectors.KqueueSelector&lt;/code&gt;&lt;/a&gt;, which does not support character devices on these versions. The &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; can be manually configured to use &lt;a href=&quot;selectors#selectors.SelectSelector&quot;&gt;&lt;code&gt;SelectSelector&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;selectors#selectors.PollSelector&quot;&gt;&lt;code&gt;PollSelector&lt;/code&gt;&lt;/a&gt; to support character devices on these older versions of macOS. Example:</source>
          <target state="translated">macOS 10.6, 10.7 및 10.8에서 기본 이벤트 루프는 &lt;a href=&quot;selectors#selectors.KqueueSelector&quot;&gt; &lt;code&gt;selectors.KqueueSelector&lt;/code&gt; 를&lt;/a&gt; 사용 하며이 버전에서는 문자 장치를 지원하지 않습니다. &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; 은&lt;/a&gt; 수동으로 사용하도록 구성 할 수 있습니다 &lt;a href=&quot;selectors#selectors.SelectSelector&quot;&gt; &lt;code&gt;SelectSelector&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;selectors#selectors.PollSelector&quot;&gt; &lt;code&gt;PollSelector&lt;/code&gt; 를&lt;/a&gt; 맥 OS의 이러한 이전 버전에서 지원 문자 장치. 예:</target>
        </trans-unit>
        <trans-unit id="59711c87f37f48c6b5ca1ccbf181736677303198" translate="yes" xml:space="preserve">
          <source>On macOS &lt;a href=&quot;http://www.manpagez.com/man/3/copyfile/&quot;&gt;fcopyfile&lt;/a&gt; is used to copy the file content (not metadata).</source>
          <target state="translated">macOS에서는 &lt;a href=&quot;http://www.manpagez.com/man/3/copyfile/&quot;&gt;fcopyfile&lt;/a&gt; 을 사용하여 메타 데이터가 아닌 파일 내용을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="e0095f6ed60d065349c04b6eefb4d5ebe1925719" translate="yes" xml:space="preserve">
          <source>On macOS, the encoding is &lt;code&gt;'utf-8'&lt;/code&gt;.</source>
          <target state="translated">macOS에서 인코딩은 &lt;code&gt;'utf-8'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ce1208192f171228b4901a07d6b02cdddfc85990" translate="yes" xml:space="preserve">
          <source>On macOS, there is one application menu. It dynamically changes according to the window currently selected. It has an IDLE menu, and some entries described below are moved around to conform to Apple guidelines.</source>
          <target state="translated">macOS에는 하나의 응용 프로그램 메뉴가 있습니다. 현재 선택된 창에 따라 동적으로 변경됩니다. 유휴 메뉴가 있으며 아래 설명 된 일부 항목은 Apple 지침에 따라 이동됩니다.</target>
        </trans-unit>
        <trans-unit id="d215bf1c5b7b0def948c235e18bfe40621e88451" translate="yes" xml:space="preserve">
          <source>On many Unix systems (including *BSD, Linux, Solaris, and Darwin), it is more convenient to use the system&amp;rsquo;s zoneinfo (&lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tzfile(5)&quot;&gt;tzfile(5)&lt;/a&gt;&lt;/em&gt;) database to specify the timezone rules. To do this, set the &lt;code id=&quot;index-18&quot;&gt;TZ&lt;/code&gt; environment variable to the path of the required timezone datafile, relative to the root of the systems &amp;lsquo;zoneinfo&amp;rsquo; timezone database, usually located at &lt;code&gt;/usr/share/zoneinfo&lt;/code&gt;. For example, &lt;code&gt;'US/Eastern'&lt;/code&gt;, &lt;code&gt;'Australia/Melbourne'&lt;/code&gt;, &lt;code&gt;'Egypt'&lt;/code&gt; or &lt;code&gt;'Europe/Amsterdam'&lt;/code&gt;.</source>
          <target state="translated">많은 Unix 시스템 (* BSD, Linux, Solaris 및 Darwin 포함)에서 시스템의 zoneinfo ( &lt;em&gt;&lt;a href=&quot;https://manpages.debian.org/tzfile(5)&quot;&gt;tzfile (5)&lt;/a&gt;&lt;/em&gt; ) 데이터베이스를 사용하여 시간대 규칙을 지정하는 것이 더 편리합니다 . 이렇게하려면 &lt;code id=&quot;index-18&quot;&gt;TZ&lt;/code&gt; 환경 변수를 시스템 'zoneinfo'시간대 데이터베이스의 루트 (일반적으로 &lt;code&gt;/usr/share/zoneinfo&lt;/code&gt; 에 있음)를 기준으로 필요한 시간대 데이터 파일의 경로로 설정하십시오 . 예를 들어, &lt;code&gt;'US/Eastern'&lt;/code&gt; , &lt;code&gt;'Australia/Melbourne'&lt;/code&gt; , &lt;code&gt;'Egypt'&lt;/code&gt; 또는 &lt;code&gt;'Europe/Amsterdam'&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="04ba6be7d13c87b73b6437d8a6f57d4cef94efc0" translate="yes" xml:space="preserve">
          <source>On newer versions of Windows 10, unprivileged accounts can create symlinks if Developer Mode is enabled. When Developer Mode is not available/enabled, the &lt;em&gt;SeCreateSymbolicLinkPrivilege&lt;/em&gt; privilege is required, or the process must be run as an administrator.</source>
          <target state="translated">최신 버전의 Windows 10에서 개발자 모드를 사용하면 권한이없는 계정이 심볼릭 링크를 만들 수 있습니다. 개발자 모드를 사용할 수 없거나 사용할 수없는 경우 &lt;em&gt;SeCreateSymbolicLinkPrivilege&lt;/em&gt; 권한이 필요하거나 프로세스를 관리자로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7bf663d20ba88f3d3779656c2de6b087faad7b7" translate="yes" xml:space="preserve">
          <source>On other Unix systems (such as FreeBSD), the following attributes may be available (but may be only filled out if root tries to use them):</source>
          <target state="translated">다른 Unix 시스템 (예 : FreeBSD)에서는 다음과 같은 속성을 사용할 수 있습니다 (그러나 루트가이를 사용하려는 경우에만 채워질 수 있음).</target>
        </trans-unit>
        <trans-unit id="06c0e7561753d8281468dc3f168c40f9e9b2351d" translate="yes" xml:space="preserve">
          <source>On other platforms, the generic &lt;a href=&quot;fcntl#fcntl.fcntl&quot;&gt;&lt;code&gt;fcntl.fcntl()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fcntl#fcntl.ioctl&quot;&gt;&lt;code&gt;fcntl.ioctl()&lt;/code&gt;&lt;/a&gt; functions may be used; they accept a socket object as their first argument.</source>
          <target state="translated">다른 플랫폼에서는 일반 &lt;a href=&quot;fcntl#fcntl.fcntl&quot;&gt; &lt;code&gt;fcntl.fcntl()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fcntl#fcntl.ioctl&quot;&gt; &lt;code&gt;fcntl.ioctl()&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다. 소켓 객체를 첫 번째 인수로 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="30fe0b6f68fa261e54a2b916d494101fac571654" translate="yes" xml:space="preserve">
          <source>On output, if &lt;em&gt;doublequote&lt;/em&gt; is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; and no &lt;em&gt;escapechar&lt;/em&gt; is set, &lt;a href=&quot;#csv.Error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt; is raised if a &lt;em&gt;quotechar&lt;/em&gt; is found in a field.</source>
          <target state="translated">경우 출력에서 &lt;em&gt;doublequote이&lt;/em&gt; 있다 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 과 더 &lt;em&gt;escapechar이&lt;/em&gt; 설정되어 있지 않은, &lt;a href=&quot;#csv.Error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt; 경우 발생 &lt;em&gt;quotechar이&lt;/em&gt; 필드에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0af5b92888c4dc7ffac3572dfa0d442dabf0ede" translate="yes" xml:space="preserve">
          <source>On platforms that do not support symbolic links, this is an alias for &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기호 링크를 지원하지 않는 플랫폼에서 이는 &lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="835888031d7cef42de83709eee1579e07f8ea020" translate="yes" xml:space="preserve">
          <source>On platforms that support the necessary fd-based functions a symlink attack resistant version of &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt; is used by default. On other platforms, the &lt;a href=&quot;#shutil.rmtree&quot;&gt;&lt;code&gt;rmtree()&lt;/code&gt;&lt;/a&gt; implementation is susceptible to a symlink attack: given proper timing and circumstances, attackers can manipulate symlinks on the filesystem to delete files they wouldn&amp;rsquo;t be able to access otherwise. Applications can use the &lt;a href=&quot;#shutil.rmtree.avoids_symlink_attacks&quot;&gt;&lt;code&gt;rmtree.avoids_symlink_attacks&lt;/code&gt;&lt;/a&gt; function attribute to determine which case applies.</source>
          <target state="translated">필요한 fd 기반 함수를 지원하는 플랫폼에서는 기본적으로 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 의 symlink 공격 방지 버전 이 사용됩니다. 다른 플랫폼에서는 &lt;a href=&quot;#shutil.rmtree&quot;&gt; &lt;code&gt;rmtree()&lt;/code&gt; &lt;/a&gt; 구현이 심볼릭 링크 공격에 취약합니다. 적절한 타이밍과 상황에 따라 공격자는 파일 시스템에서 심볼릭 링크를 조작하여 다른 방법으로는 액세스 할 수없는 파일을 삭제할 수 있습니다. 애플리케이션은 &lt;a href=&quot;#shutil.rmtree.avoids_symlink_attacks&quot;&gt; &lt;code&gt;rmtree.avoids_symlink_attacks&lt;/code&gt; &lt;/a&gt; 함수 속성을 사용하여 적용되는 케이스를 결정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2539c27ac2c42d14e6d76946d07ef981a8cc60c" translate="yes" xml:space="preserve">
          <source>On platforms using IEEE 754 binary floating-point, the result of this operation is always exactly representable: no rounding error is introduced.</source>
          <target state="translated">IEEE 754 이진 부동 소수점을 사용하는 플랫폼에서이 작업의 결과는 항상 정확하게 표현 가능합니다. 반올림 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0f67e7089bb8910b4e4fda4cf6b72e3df1c3c94" translate="yes" xml:space="preserve">
          <source>On platforms where some or all of this functionality is unavailable, when asked to modify a symbolic link, &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; will copy everything it can. &lt;a href=&quot;#shutil.copystat&quot;&gt;&lt;code&gt;copystat()&lt;/code&gt;&lt;/a&gt; never returns failure.</source>
          <target state="translated">이 기능 중 일부 또는 전부를 사용할 수없는 플랫폼에서 심볼릭 링크를 수정하라는 요청을 &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 가 가능한 모든 것을 복사합니다. &lt;a href=&quot;#shutil.copystat&quot;&gt; &lt;code&gt;copystat()&lt;/code&gt; &lt;/a&gt; 는 실패를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c6b1f69887e623bddc661e6cae08b9b00d43caf" translate="yes" xml:space="preserve">
          <source>On platforms with hardware and system-level support for signed zeros, functions involving branch cuts are continuous on &lt;em&gt;both&lt;/em&gt; sides of the branch cut: the sign of the zero distinguishes one side of the branch cut from the other. On platforms that do not support signed zeros the continuity is as specified below.</source>
          <target state="translated">서명 제로를위한 하드웨어 및 시스템 수준의 지원 플랫폼, 지점 삭감을 포함하는 기능에 연속 &lt;em&gt;모두&lt;/em&gt; 다른에서 분기 컷의 제로 구별하는 한쪽의 부호 : 분기 컷의 측면. 부호있는 0을 지원하지 않는 플랫폼에서 연속성은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cea002554b75820329fc15191d1a6a71d5584562" translate="yes" xml:space="preserve">
          <source>On platforms without &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;Completer&lt;/code&gt; class defined by this module can still be used for custom purposes.</source>
          <target state="translated">없이 플랫폼 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;Completer&lt;/code&gt; 의 이 모듈에 의해 정의 된 클래스는 여전히 사용자 정의 목적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c6a777251164aea8999f437ba7c8d0b926184ae" translate="yes" xml:space="preserve">
          <source>On some Unix platforms, many of these functions support one or more of these features:</source>
          <target state="translated">일부 Unix 플랫폼에서 이러한 기능 중 다수는 다음 기능 중 하나 이상을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="eaba699b79f7765281c28b47b3e0ec7e21c3ec5c" translate="yes" xml:space="preserve">
          <source>On some Unix systems (such as Linux), the following attributes may also be available:</source>
          <target state="translated">일부 Unix 시스템 (예 : Linux)에서는 다음 속성을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0ae39c0ac3f68172a6d225258c4c362c47d6748" translate="yes" xml:space="preserve">
          <source>On some platforms, an optional field width and precision specification can immediately follow the initial &lt;code&gt;'%'&lt;/code&gt; of a directive in the following order; this is also not portable. The field width is normally 2 except for &lt;code&gt;%j&lt;/code&gt; where it is 3.</source>
          <target state="translated">일부 플랫폼에서 선택적 필드 너비 및 정밀도 사양은 지시문 의 초기 &lt;code&gt;'%'&lt;/code&gt; 를 다음 순서로 즉시 따를 수 있습니다 . 이것은 또한 휴대용이 아닙니다. 필드 너비는 일반적으로 2이며 &lt;code&gt;%j&lt;/code&gt; 는 3입니다.</target>
        </trans-unit>
        <trans-unit id="49846f91b44b9eabca7917db8a10258a1a0b35cf" translate="yes" xml:space="preserve">
          <source>On some platforms, including FreeBSD and Mac OS X, setting &lt;code&gt;environ&lt;/code&gt; may cause memory leaks. Refer to the system documentation for &lt;code&gt;putenv()&lt;/code&gt;.</source>
          <target state="translated">FreeBSD 및 Mac OS X를 포함한 일부 플랫폼에서 &lt;code&gt;environ&lt;/code&gt; 설정 하면 메모리 누수가 발생할 수 있습니다. &lt;code&gt;putenv()&lt;/code&gt; 시스템 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58e337bb68a53e0e0fdf875e3f9a3ba499302b95" translate="yes" xml:space="preserve">
          <source>On some platforms, including FreeBSD and Mac OS X, setting &lt;code&gt;environ&lt;/code&gt; may cause memory leaks. Refer to the system documentation for putenv.</source>
          <target state="translated">FreeBSD 및 Mac OS X를 포함한 일부 플랫폼에서 &lt;code&gt;environ&lt;/code&gt; 설정 하면 메모리 누수가 발생할 수 있습니다. putenv에 대한 시스템 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ce939615baf6b4e6e43bf427856a8f1921f68d68" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; can be used to pass file descriptors between processes over an &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; socket. When this facility is used (it is often restricted to &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; sockets), &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; will return, in its ancillary data, items of the form &lt;code&gt;(socket.SOL_SOCKET,
socket.SCM_RIGHTS, fds)&lt;/code&gt;, where &lt;em&gt;fds&lt;/em&gt; is a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object representing the new file descriptors as a binary array of the native C &lt;code&gt;int&lt;/code&gt; type. If &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt;&lt;code&gt;recvmsg()&lt;/code&gt;&lt;/a&gt; raises an exception after the system call returns, it will first attempt to close any file descriptors received via this mechanism.</source>
          <target state="translated">일부 시스템에서는 &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 소켓을 통해 프로세스간에 파일 설명자를 전달할 수 있습니다 . 이 기능은 (이 종종 제한된다 사용될 때 &lt;a href=&quot;#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; 의&lt;/a&gt; 소켓) &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 그 보조 데이터 형태의 항목에서, 반환 &lt;code&gt;(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)&lt;/code&gt; , &lt;em&gt;FDS는&lt;/em&gt; A는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 나타내는 객체 네이티브 C &lt;code&gt;int&lt;/code&gt; 형 의 바이너리 배열로서의 새로운 파일 기술자 시스템 호출이 리턴 된 후 &lt;a href=&quot;#socket.socket.recvmsg&quot;&gt; &lt;code&gt;recvmsg()&lt;/code&gt; &lt;/a&gt; 에서 예외가 발생 하면 먼저이 메커니즘을 통해 수신 된 파일 디스크립터를 닫으려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="0854fe514f9f478ef9200189533ba9f76d283b6e" translate="yes" xml:space="preserve">
          <source>On some systems, &lt;em&gt;mode&lt;/em&gt; is ignored. Where it is used, the current umask value is first masked out. If bits other than the last 9 (i.e. the last 3 digits of the octal representation of the &lt;em&gt;mode&lt;/em&gt;) are set, their meaning is platform-dependent. On some platforms, they are ignored and you should call &lt;a href=&quot;#os.chmod&quot;&gt;&lt;code&gt;chmod()&lt;/code&gt;&lt;/a&gt; explicitly to set them.</source>
          <target state="translated">일부 시스템에서는 &lt;em&gt;모드&lt;/em&gt; 가 무시됩니다. 사용되는 경우 현재 umask 값이 먼저 마스킹됩니다. 마지막 9 이외의 비트 (즉, &lt;em&gt;모드&lt;/em&gt; 의 8 진 표현의 마지막 3 자리 )가 설정되면 그 의미는 플랫폼에 따라 다릅니다. 일부 플랫폼에서는 무시되며 &lt;a href=&quot;#os.chmod&quot;&gt; &lt;code&gt;chmod()&lt;/code&gt; &lt;/a&gt; 명시 적으로 호출 하여 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="91c09add15e3897cc71e4285cad983d35ae19c62" translate="yes" xml:space="preserve">
          <source>On some systems, it is necessary to invoke &lt;a href=&quot;#locale.setlocale&quot;&gt;&lt;code&gt;setlocale()&lt;/code&gt;&lt;/a&gt; to obtain the user preferences, so this function is not thread-safe. If invoking setlocale is not necessary or desired, &lt;em&gt;do_setlocale&lt;/em&gt; should be set to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">일부 시스템에서는 &lt;a href=&quot;#locale.setlocale&quot;&gt; &lt;code&gt;setlocale()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 사용자 기본 설정을 가져와야 하므로이 함수는 스레드로부터 안전하지 않습니다. setlocale을 호출하지 않아도되거나 &lt;em&gt;do_setlocale&lt;/em&gt; 을 &lt;code&gt;False&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c6110a82223307cc8967bdb9b6a267ed5e823067" translate="yes" xml:space="preserve">
          <source>On success, the data and separator will be removed from the internal buffer (consumed). Returned data will include the separator at the end.</source>
          <target state="translated">성공하면 데이터와 구분 기호가 내부 버퍼에서 제거됩니다 (소비 됨). 반환 된 데이터는 끝에 구분 기호를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="81d3e77503079dc680941880acaf81e6572cb402" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, this module will also import and configure the &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module, if Python is started in &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt; and without the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; option. The default behavior is enable tab-completion and to use &lt;code&gt;~/.python_history&lt;/code&gt; as the history save file. To disable it, delete (or override) the &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt;&lt;code&gt;sys.__interactivehook__&lt;/code&gt;&lt;/a&gt; attribute in your &lt;code&gt;sitecustomize&lt;/code&gt; or &lt;code&gt;usercustomize&lt;/code&gt; module or your &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 을 지원하는 시스템 에서이 모듈은 Python이 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화식 모드&lt;/a&gt; 에서 시작되고 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 옵션 없이 시작되면 &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; &lt;/a&gt; 모듈을 가져오고 구성합니다 . 기본 동작은 탭 완성 활성화이며 &lt;code&gt;~/.python_history&lt;/code&gt; 를 기록 저장 파일로 사용하는 것입니다. 그것을 사용하지 않으려면 삭제 (또는 오버라이드) &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt; &lt;code&gt;sys.__interactivehook__&lt;/code&gt; &lt;/a&gt; 당신의 속성 &lt;code&gt;sitecustomize&lt;/code&gt; 또는 &lt;code&gt;usercustomize&lt;/code&gt; 의 모듈 또는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; 의&lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="9eb104f76bd96ade5a8176723ed9b7aea345a251" translate="yes" xml:space="preserve">
          <source>On systems that support &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, this module will also import and configure the &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module, if Python is started in &lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt; and without the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; option. The default behavior is enable tab-completion and to use &lt;code&gt;~/.python_history&lt;/code&gt; as the history save file. To disable it, delete (or override) the &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt;&lt;code&gt;sys.__interactivehook__&lt;/code&gt;&lt;/a&gt; attribute in your &lt;code&gt;sitecustomize&lt;/code&gt; or &lt;code&gt;usercustomize&lt;/code&gt; module or your &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt;&lt;code&gt;PYTHONSTARTUP&lt;/code&gt;&lt;/a&gt; file.</source>
          <target state="translated">&lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 을 지원하는 시스템 에서이 모듈은 Python이 &lt;a href=&quot;https://docs.python.org/3.9/tutorial/interpreter.html#tut-interactive&quot;&gt;대화 형 모드&lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 옵션 없이 시작된 경우 &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; &lt;/a&gt; 모듈 도 가져오고 구성합니다 . 기본 동작은 탭 완성을 활성화하고 &lt;code&gt;~/.python_history&lt;/code&gt; 를 히스토리 저장 파일로 사용하는 것입니다. 그것을 사용하지 않으려면 삭제 (또는 오버라이드) &lt;a href=&quot;sys#sys.__interactivehook__&quot;&gt; &lt;code&gt;sys.__interactivehook__&lt;/code&gt; &lt;/a&gt; 당신의 속성 &lt;code&gt;sitecustomize&lt;/code&gt; 또는 &lt;code&gt;usercustomize&lt;/code&gt; 의 모듈 또는 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONSTARTUP&quot; id=&quot;index-7&quot;&gt; &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; 의&lt;/a&gt; 파일을.</target>
        </trans-unit>
        <trans-unit id="4ce3a4c7161faf6a2733a2da667b68f080fb9ebe" translate="yes" xml:space="preserve">
          <source>On systems which support the &lt;code&gt;SCM_RIGHTS&lt;/code&gt; mechanism, the following function will receive up to &lt;em&gt;maxfds&lt;/em&gt; file descriptors, returning the message data and a list containing the descriptors (while ignoring unexpected conditions such as unrelated control messages being received). See also &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt;&lt;code&gt;sendmsg()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;SCM_RIGHTS&lt;/code&gt; 메커니즘 을 지원하는 시스템 에서 다음 함수는 최대 &lt;em&gt;maxfds&lt;/em&gt; 파일 디스크립터 를 수신 하여 메시지 데이터 및 디스크립터가 포함 된 목록을 리턴합니다 (관련되지 않은 제어 메시지 수신과 같은 예상치 못한 조건은 무시 함). &lt;a href=&quot;#socket.socket.sendmsg&quot;&gt; &lt;code&gt;sendmsg()&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bd387ae56d8456aacef9c5c7039622bbd157974" translate="yes" xml:space="preserve">
          <source>On systems with overallocation (e.g. Linux), a more sophisticated approach is to adjust &lt;code&gt;prec&lt;/code&gt; to the amount of available RAM. Suppose that you have 8GB of RAM and expect 10 simultaneous operands using a maximum of 500MB each:</source>
          <target state="translated">초과 할당 (예를 들어, 리눅스)와 시스템에서보다 정교한 접근 방식은 조정하는 &lt;code&gt;prec&lt;/code&gt; 사용 가능한 RAM의 양. 8GB의 RAM이 있고 각각 최대 500MB를 사용하여 10 개의 동시 피연산자가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="170fe28c30f87352badfea6a1b0adfa7979f0455" translate="yes" xml:space="preserve">
          <source>On the Font tab, see the text sample for the effect of font face and size on multiple characters in multiple languages. Edit the sample to add other characters of personal interest. Use the sample to select monospaced fonts. If particular characters have problems in Shell or an editor, add them to the top of the sample and try changing first size and then font.</source>
          <target state="translated">서체 탭에서 여러 언어로 된 여러 문자의 서체 및 크기 효과에 대한 텍스트 샘플을 참조하십시오. 관심있는 다른 문자를 추가하려면 샘플을 편집하십시오. 샘플을 사용하여 고정 폭 글꼴을 선택하십시오. Shell이나 편집기에서 특정 문자에 문제가있는 경우 샘플 상단에 해당 문자를 추가하고 첫 번째 크기를 변경 한 다음 글꼴을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="0b329dc6e9c4b674641af665ee59096dbcd8c046" translate="yes" xml:space="preserve">
          <source>On the Highlights and Keys tab, select a built-in or custom color theme and key set. To use a newer built-in color theme or key set with older IDLEs, save it as a new custom theme or key set and it well be accessible to older IDLEs.</source>
          <target state="translated">강조 표시 및 키 탭에서 내장 또는 사용자 정의 색상 테마 및 키 세트를 선택하십시오. 이전 IDLE과 함께 최신 내장 색상 테마 또는 키 세트를 사용하려면 새 ID를 테마로 저장하거나 이전 IDLE에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9fb9ccc44f0f6638fed1a987aa33ae9f6959c6" translate="yes" xml:space="preserve">
          <source>On the POSIX compliant platforms, it is equivalent to the following expression:</source>
          <target state="translated">POSIX 호환 플랫폼에서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8718a6ecfb2948f94e8214f2c029ea186b4fea26" translate="yes" xml:space="preserve">
          <source>On the consumer side, we can pickle those objects the usual way, which when unserialized will give us a copy of the original object:</source>
          <target state="translated">소비자 측에서는 일반적인 방법으로 해당 객체를 피클 할 수 있습니다. 직렬화를 해제하면 원래 객체의 사본이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="491abdd927ace9b614d81c92dc19845f26b3d2e7" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, a system call is required on Windows but not on Unix.</source>
          <target state="translated">캐시되지 않은 첫 번째 호출에서는 Windows에서는 시스템 호출이 필요하지만 Unix에서는 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5cd90c0c17f384bfaab3cff8f5c166412c102c98" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, no system call is required in most cases. Specifically, for non-symlinks, neither Windows or Unix require a system call, except on certain Unix file systems, such as network file systems, that return &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt;. If the entry is a symlink, a system call will be required to follow the symlink unless &lt;em&gt;follow_symlinks&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">캐시되지 않은 첫 번째 통화에서는 대부분의 경우 시스템 호출이 필요하지 않습니다. 특히 심볼릭 링크가 아닌 경우, Windows 또는 Unix는 네트워크 파일 시스템과 같은 특정 Unix 파일 시스템을 제외하고 &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt; 을 반환하는 시스템 호출을 요구하지 않습니다 . 항목이 symlink 인 경우 &lt;em&gt;follow_symlinks&lt;/em&gt; 가 &lt;code&gt;False&lt;/code&gt; 가 아닌 한 시스템 호출은 symlink를 따라야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9dac8ead05b600f65bb3a1c6b260cbf7bc2b51d" translate="yes" xml:space="preserve">
          <source>On the first, uncached call, no system call is required in most cases. Specifically, neither Windows or Unix require a system call, except on certain Unix file systems, such as network file systems, that return &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt;.</source>
          <target state="translated">캐시되지 않은 첫 번째 통화에서는 대부분의 경우 시스템 호출이 필요하지 않습니다. 특히, Windows 또는 Unix는 &lt;code&gt;dirent.d_type == DT_UNKNOWN&lt;/code&gt; 을 리턴하는 네트워크 파일 시스템과 같은 특정 Unix 파일 시스템을 제외하고 시스템 호출이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="3e84ca525861c9e265cab3b438b32f029594120f" translate="yes" xml:space="preserve">
          <source>On the other hand, if an explicit value of &lt;code&gt;None&lt;/code&gt; is allowed, the use of &lt;code&gt;Optional&lt;/code&gt; is appropriate, whether the argument is optional or not. For example:</source>
          <target state="translated">반면에 명시적인 &lt;code&gt;None&lt;/code&gt; 값 이 허용되는 경우 인수의 선택 여부에 관계없이 &lt;code&gt;Optional&lt;/code&gt; 을 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf9973b9d57271129427560d24c59bd726fbd904" translate="yes" xml:space="preserve">
          <source>On the other hand, if you are building an HTTP server where all data is stored externally (for instance, in the file system), a synchronous class will essentially render the service &amp;ldquo;deaf&amp;rdquo; while one request is being handled &amp;ndash; which may be for a very long time if a client is slow to receive all the data it has requested. Here a threading or forking server is appropriate.</source>
          <target state="translated">반면에 모든 데이터가 외부 (예 : 파일 시스템)에 저장된 HTTP 서버를 구축하는 경우 동기 클래스는 하나의 요청이 처리되는 동안 서비스를 &quot;청각 장애&quot;로 렌더링합니다. 클라이언트가 요청한 모든 데이터를 느리게받는 경우 매우 오랜 시간. 여기에는 스레딩 또는 포크 서버가 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9d9537632dbfd5ce7c3381fb8473c75296dfa687" translate="yes" xml:space="preserve">
          <source>On the other hand, the precision of &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#time.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; is better than their Unix equivalents: times are expressed as floating point numbers, &lt;a href=&quot;#time.time&quot;&gt;&lt;code&gt;time()&lt;/code&gt;&lt;/a&gt; returns the most accurate time available (using Unix &lt;code&gt;gettimeofday()&lt;/code&gt; where available), and &lt;a href=&quot;#time.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; will accept a time with a nonzero fraction (Unix &lt;code&gt;select()&lt;/code&gt; is used to implement this, where available).</source>
          <target state="translated">반면 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#time.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 의 정밀도는 유닉스에 해당하는 것보다 낫습니다. 시간은 부동 소수점 숫자로 표현되고 &lt;a href=&quot;#time.time&quot;&gt; &lt;code&gt;time()&lt;/code&gt; &lt;/a&gt; 은 사용 가능한 가장 정확한 시간을 반환합니다 (사용 가능한 경우 Unix &lt;code&gt;gettimeofday()&lt;/code&gt; 사용). &lt;a href=&quot;#time.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 은 0이 아닌 분수를 가진 시간을 받아들입니다 (사용 가능한 경우 유닉스 &lt;code&gt;select()&lt;/code&gt; 가 이것을 구현하는 데 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="2b4270c26ef431be82a119288026b915740bbad6" translate="yes" xml:space="preserve">
          <source>On the other hand, the statement &lt;code&gt;from spam.ham import eggs, sausage as
saus&lt;/code&gt; results in</source>
          <target state="translated">다른 한편으로, &lt;code&gt;from spam.ham import eggs, sausage as saus&lt;/code&gt; 진술 은 saus 결과</target>
        </trans-unit>
        <trans-unit id="302064ecd83cf854ce5daa489ae06236b2f77d49" translate="yes" xml:space="preserve">
          <source>On the real line, there are functions to compute uniform, normal (Gaussian), lognormal, negative exponential, gamma, and beta distributions. For generating distributions of angles, the von Mises distribution is available.</source>
          <target state="translated">실제 라인에는 균일, 정규 (가우시안), 로그 정규, 음의 지수, 감마 및 베타 분포를 계산하는 함수가 있습니다. 각도 분포를 생성하기 위해 von Mises 분포를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="021f9c86cdcc2f4cf15e28ff86eb4c57b0b3ffd0" translate="yes" xml:space="preserve">
          <source>On the receiving side, it needs to pass a &lt;em&gt;buffers&lt;/em&gt; argument to &lt;a href=&quot;#pickle.Unpickler&quot;&gt;&lt;code&gt;Unpickler&lt;/code&gt;&lt;/a&gt; (or to the &lt;a href=&quot;#pickle.load&quot;&gt;&lt;code&gt;load()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.loads&quot;&gt;&lt;code&gt;loads()&lt;/code&gt;&lt;/a&gt; function), which is an iterable of the buffers which were passed to &lt;em&gt;buffer_callback&lt;/em&gt;. That iterable should produce buffers in the same order as they were passed to &lt;em&gt;buffer_callback&lt;/em&gt;. Those buffers will provide the data expected by the reconstructors of the objects whose pickling produced the original &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">수신 측에서는 &lt;em&gt;버퍼&lt;/em&gt; 인수를 &lt;a href=&quot;#pickle.Unpickler&quot;&gt; &lt;code&gt;Unpickler&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pickle.load&quot;&gt; &lt;code&gt;load()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.loads&quot;&gt; &lt;code&gt;loads()&lt;/code&gt; &lt;/a&gt; 함수)에 전달해야 &lt;em&gt;합니다&lt;/em&gt; . 이 &lt;em&gt;인수는 buffer_callback&lt;/em&gt; 에 전달 된 버퍼의 반복 가능입니다 . iterable은 &lt;em&gt;buffer_callback&lt;/em&gt; 에 전달 된 순서와 동일한 순서로 버퍼를 생성해야합니다 . 이러한 버퍼는 피클 링에서 원래 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; &lt;/a&gt; 객체를 생성 한 객체의 재구성자가 예상 한 데이터를 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="66db2c4de162079fa6ad1e56a412af6e40b12ff3" translate="yes" xml:space="preserve">
          <source>On the sending side, it needs to pass a &lt;em&gt;buffer_callback&lt;/em&gt; argument to &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; (or to the &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; function), which will be called with each &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt; generated while pickling the object graph. Buffers accumulated by the &lt;em&gt;buffer_callback&lt;/em&gt; will not see their data copied into the pickle stream, only a cheap marker will be inserted.</source>
          <target state="translated">송신 측에서는 객체 그래프를 산세하는 동안 생성 된 각 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; &lt;/a&gt; 와 함께 호출 되는 &lt;em&gt;buffer_callback&lt;/em&gt; 인수를 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt; 함수)에 전달 해야합니다. &lt;em&gt;buffer_callback에&lt;/em&gt; 의해 누적 된 버퍼 는 자신의 데이터가 피클 스트림으로 복사되는 것을 보지 않고 저렴한 마커 만 삽입됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dfc3524ee9c52842ac68b4cbfd63f42ac55c13bf" translate="yes" xml:space="preserve">
          <source>On top of the core functionality, &lt;a href=&quot;#configparser.ConfigParser&quot;&gt;&lt;code&gt;ConfigParser&lt;/code&gt;&lt;/a&gt; supports interpolation. This means values can be preprocessed before returning them from &lt;code&gt;get()&lt;/code&gt; calls.</source>
          <target state="translated">핵심 기능 &lt;a href=&quot;#configparser.ConfigParser&quot;&gt; &lt;code&gt;ConfigParser&lt;/code&gt; &lt;/a&gt; 는 보간을 지원합니다. 즉, &lt;code&gt;get()&lt;/code&gt; 호출 에서 값을 반환하기 전에 값을 사전 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0a89fb92ab1b6c953761430059ee14bf39ac4f" translate="yes" xml:space="preserve">
          <source>On unsupported Windows versions, &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지원되지 않는 Windows 버전에서는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a7af216ac764a8e05fdb02285dd1f73ff0b4bf41" translate="yes" xml:space="preserve">
          <source>On-line reference material.</source>
          <target state="translated">온라인 참조 자료.</target>
        </trans-unit>
        <trans-unit id="7ee9b6bbcd3fc003f8c514b8359b3b3d847b5991" translate="yes" xml:space="preserve">
          <source>On-line version of the man pages and reference material.</source>
          <target state="translated">온라인 설명서 페이지 및 참조 자료.</target>
        </trans-unit>
        <trans-unit id="6aeb9a0eecc81b131da11166dd168337677c0196" translate="yes" xml:space="preserve">
          <source>On-line version of the programmer&amp;rsquo;s reference material.</source>
          <target state="translated">프로그래머 참조 자료의 온라인 버전.</target>
        </trans-unit>
        <trans-unit id="d68ef1995b7e1837b6328a4152bbf582900b7c03" translate="yes" xml:space="preserve">
          <source>Once &lt;a href=&quot;#itertools.tee&quot;&gt;&lt;code&gt;tee()&lt;/code&gt;&lt;/a&gt; has made a split, the original &lt;em&gt;iterable&lt;/em&gt; should not be used anywhere else; otherwise, the &lt;em&gt;iterable&lt;/em&gt; could get advanced without the tee objects being informed.</source>
          <target state="translated">일단 &lt;a href=&quot;#itertools.tee&quot;&gt; &lt;code&gt;tee()&lt;/code&gt; &lt;/a&gt; 분할, 원래했다 &lt;em&gt;반복자는&lt;/em&gt; 다른 곳에서는 사용하지 않아야을; 그렇지 않으면 티 개체에 대한 정보를 제공하지 않고 &lt;em&gt;iterable&lt;/em&gt; 이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13355ef156e37b7df46841221634670e6bd21bf1" translate="yes" xml:space="preserve">
          <source>Once a thread object is created, its activity must be started by calling the thread&amp;rsquo;s &lt;a href=&quot;#threading.Thread.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; method. This invokes the &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method in a separate thread of control.</source>
          <target state="translated">스레드 객체가 생성되면 스레드의 &lt;a href=&quot;#threading.Thread.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 해당 활동을 시작해야합니다 . 이것은 별도의 제어 스레드에서 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="207c91dde7ce754af70d86e35ca18a8bfb78b4b4" translate="yes" xml:space="preserve">
          <source>Once a virtual environment has been created, it can be &amp;ldquo;activated&amp;rdquo; using a script in the virtual environment&amp;rsquo;s binary directory. The invocation of the script is platform-specific (&lt;code&gt;&amp;lt;venv&amp;gt;&lt;/code&gt; must be replaced by the path of the directory containing the virtual environment):</source>
          <target state="translated">가상 환경이 만들어지면 가상 환경의 이진 디렉터리에있는 스크립트를 사용하여 &quot;활성화&quot;될 수 있습니다. 스크립트 호출은 플랫폼마다 다릅니다 ( &lt;code&gt;&amp;lt;venv&amp;gt;&lt;/code&gt; 는 가상 환경을 포함하는 디렉토리의 경로로 바꿔야합니다).</target>
        </trans-unit>
        <trans-unit id="889abf09b206885a298b4b0048c82881bd8294ef" translate="yes" xml:space="preserve">
          <source>Once an iterator&amp;rsquo;s &lt;a href=&quot;#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; method raises &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt;, it must continue to do so on subsequent calls. Implementations that do not obey this property are deemed broken.</source>
          <target state="translated">반복자의 &lt;a href=&quot;#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드가 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 을 발생 시키면 후속 호출에서 계속 수행해야합니다. 이 속성에 따르지 않는 구현은 고장난 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c8954a531e8e55ebee2fcb88a5f5f25aa89c78a2" translate="yes" xml:space="preserve">
          <source>Once constructed, &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; objects are immutable.</source>
          <target state="translated">일단 생성되면 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 객체는 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="16be74f5902bbdc230632d054aabd873de1dda59" translate="yes" xml:space="preserve">
          <source>Once created one should call &lt;a href=&quot;#multiprocessing.managers.BaseManager.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;get_server().serve_forever()&lt;/code&gt; to ensure that the manager object refers to a started manager process.</source>
          <target state="translated">일단 작성되면 &lt;a href=&quot;#multiprocessing.managers.BaseManager.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;get_server().serve_forever()&lt;/code&gt; 를 호출 하여 관리자 오브젝트가 시작된 관리자 프로세스를 참조하도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="ccc2cd016213a015dfbf70d995a4eef4403a9624" translate="yes" xml:space="preserve">
          <source>Once created, an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt; object may be manipulated by directly changing its fields (such as &lt;a href=&quot;#xml.etree.ElementTree.Element.text&quot;&gt;&lt;code&gt;Element.text&lt;/code&gt;&lt;/a&gt;), adding and modifying attributes (&lt;a href=&quot;#xml.etree.ElementTree.Element.set&quot;&gt;&lt;code&gt;Element.set()&lt;/code&gt;&lt;/a&gt; method), as well as adding new children (for example with &lt;a href=&quot;#xml.etree.ElementTree.Element.append&quot;&gt;&lt;code&gt;Element.append()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">일단 생성 된 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; 객체는 필드 (예 : &lt;a href=&quot;#xml.etree.ElementTree.Element.text&quot;&gt; &lt;code&gt;Element.text&lt;/code&gt; &lt;/a&gt; ) 를 직접 변경하고 속성 ( &lt;a href=&quot;#xml.etree.ElementTree.Element.set&quot;&gt; &lt;code&gt;Element.set()&lt;/code&gt; &lt;/a&gt; 메서드)을 추가 및 수정 하고 새 자식 (예 : &lt;a href=&quot;#xml.etree.ElementTree.Element.append&quot;&gt; &lt;code&gt;Element.append()&lt;/code&gt; &lt;/a&gt; 하여)을 조작하여 조작 할 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="d98f7cd89572d4bbe43871efa04dc25f912f9367" translate="yes" xml:space="preserve">
          <source>Once created, the pathname to the widget becomes a new command. This new &lt;em&gt;widget command&lt;/em&gt; is the programmer&amp;rsquo;s handle for getting the new widget to perform some &lt;em&gt;action&lt;/em&gt;. In C, you&amp;rsquo;d express this as someAction(fred, someOptions), in C++, you would express this as fred.someAction(someOptions), and in Tk, you say:</source>
          <target state="translated">일단 작성되면 위젯의 경로 이름이 새 명령이됩니다. 이 새 &lt;em&gt;위젯 명령&lt;/em&gt; 은 새 위젯이 일부 &lt;em&gt;조치&lt;/em&gt; 를 수행하도록하는 프로그래머의 핸들입니다 . C에서는 이것을 someAction (fred, someOptions)으로 표현하고, C ++에서는 이것을 fred.someAction (someOptions)로 표현하고 Tk에서는 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="b88e8436dc34ad8ecac85ed9098e7930bd406ff6" translate="yes" xml:space="preserve">
          <source>Once executed the &lt;a href=&quot;#module-gzip&quot;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; module keeps the input file(s).</source>
          <target state="translated">일단 실행되면 &lt;a href=&quot;#module-gzip&quot;&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;/a&gt; 모듈은 입력 파일을 유지합니다.</target>
        </trans-unit>
        <trans-unit id="59bd0557426d252898ba83d74b3d08da5feeacce" translate="yes" xml:space="preserve">
          <source>Once spawned, worker threads call the semaphore&amp;rsquo;s acquire and release methods when they need to connect to the server:</source>
          <target state="translated">일단 생성 된 작업자 스레드는 서버에 연결해야 할 때 세마포어의 획득 및 해제 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="9dc52253ba5d16f68a3458bf5594be6616430d42" translate="yes" xml:space="preserve">
          <source>Once the context manager exits, the warnings filter is restored to its state when the context was entered. This prevents tests from changing the warnings filter in unexpected ways between tests and leading to indeterminate test results. The &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt; function in the module is also restored to its original value. Note: this can only be guaranteed in a single-threaded application. If two or more threads use the &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; context manager at the same time, the behavior is undefined.</source>
          <target state="translated">컨텍스트 관리자가 종료되면 컨텍스트를 입력했을 때 경고 필터가 상태로 복원됩니다. 이렇게하면 테스트간에 경고 필터가 예기치 않은 방식으로 변경되어 테스트 결과가 불확실 해지지 않습니다. 모듈 의 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 함수도 원래 값으로 복원됩니다. 참고 : 이것은 단일 스레드 응용 프로그램에서만 보장 될 수 있습니다. 둘 이상의 스레드가 &lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; &lt;/a&gt; 컨텍스트 관리자를 동시에 사용하면 동작이 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4d5043f40e3990a632ef7cf48ff135c75a7ff554" translate="yes" xml:space="preserve">
          <source>Once the headers have been read, if the request is of type POST (indicating that further data are present in the input stream) then the &lt;code&gt;Content-Length:&lt;/code&gt; header is used to set a numeric terminator to read the right amount of data from the channel.</source>
          <target state="translated">헤더를 읽은 후 요청이 POST 유형 인 경우 (입력 스트림에 추가 데이터가 있음을 나타내는) &lt;code&gt;Content-Length:&lt;/code&gt; 헤더를 사용하여 채널에서 올바른 양의 데이터를 읽도록 숫자 종결자를 설정합니다. .</target>
        </trans-unit>
        <trans-unit id="3625bd42b562728df6287438cfb43f246eb75f17" translate="yes" xml:space="preserve">
          <source>Once the initial channel(s) is(are) created, calling the &lt;a href=&quot;#asyncore.loop&quot;&gt;&lt;code&gt;loop()&lt;/code&gt;&lt;/a&gt; function activates channel service, which continues until the last channel (including any that have been added to the map during asynchronous service) is closed.</source>
          <target state="translated">초기 채널이 생성되면 &lt;a href=&quot;#asyncore.loop&quot;&gt; &lt;code&gt;loop()&lt;/code&gt; &lt;/a&gt; 함수를 호출하면 채널 서비스가 활성화되어 마지막 서비스 (비동기 서비스 중 맵에 추가 된 채널 포함)가 닫힐 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="4a2546b8a5097fd780cdeb2adc6d3eb6f8ec8d23" translate="yes" xml:space="preserve">
          <source>Once the thread&amp;rsquo;s activity is started, the thread is considered &amp;lsquo;alive&amp;rsquo;. It stops being alive when its &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method terminates &amp;ndash; either normally, or by raising an unhandled exception. The &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt;&lt;code&gt;is_alive()&lt;/code&gt;&lt;/a&gt; method tests whether the thread is alive.</source>
          <target state="translated">스레드 활동이 시작되면 스레드는 '작동 중'으로 간주됩니다. 일반적으로 또는 처리되지 않은 예외를 발생시켜 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드가 종료 되면 작동 이 중지됩니다 . &lt;a href=&quot;#threading.Thread.is_alive&quot;&gt; &lt;code&gt;is_alive()&lt;/code&gt; &lt;/a&gt; 메소드 테스트 실 살아 있는지 여부.</target>
        </trans-unit>
        <trans-unit id="a235b9ded0ea3a43927ac13de68434d28c8fa6ae" translate="yes" xml:space="preserve">
          <source>Once you have a &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, you can create a &lt;a href=&quot;#sqlite3.Cursor&quot;&gt;&lt;code&gt;Cursor&lt;/code&gt;&lt;/a&gt; object and call its &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt;&lt;code&gt;execute()&lt;/code&gt;&lt;/a&gt; method to perform SQL commands:</source>
          <target state="translated">당신은 일단 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , 당신은 만들 수 &lt;a href=&quot;#sqlite3.Cursor&quot;&gt; &lt;code&gt;Cursor&lt;/code&gt; &lt;/a&gt; 오브젝트를하고 전화를 &lt;a href=&quot;#sqlite3.Cursor.execute&quot;&gt; &lt;code&gt;execute()&lt;/code&gt; &lt;/a&gt; SQL 명령을 수행하는 방법 :</target>
        </trans-unit>
        <trans-unit id="81002ef1c052dbc9b87479ed00026cc46e6b7f55" translate="yes" xml:space="preserve">
          <source>Once you have a DOM document object, you can access the parts of your XML document through its properties and methods. These properties are defined in the DOM specification. The main property of the document object is the &lt;code&gt;documentElement&lt;/code&gt; property. It gives you the main element in the XML document: the one that holds all others. Here is an example program:</source>
          <target state="translated">DOM 문서 객체가 있으면 속성 및 메서드를 통해 XML 문서의 일부에 액세스 할 수 있습니다. 이러한 속성은 DOM 사양에 정의되어 있습니다. 문서 객체의 주요 속성은 &lt;code&gt;documentElement&lt;/code&gt; 속성입니다. XML 문서의 주요 요소 인 다른 모든 요소를 ​​포함합니다. 예제 프로그램은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="570eb1dd3b2dc9c9893e632a6855fcb1892d470f" translate="yes" xml:space="preserve">
          <source>Once you have a DOM document object, you can access the parts of your XML document through its properties and methods. These properties are defined in the DOM specification; this portion of the reference manual describes the interpretation of the specification in Python.</source>
          <target state="translated">DOM 문서 객체가 있으면 속성 및 메서드를 통해 XML 문서의 일부에 액세스 할 수 있습니다. 이러한 속성은 DOM 사양에 정의되어 있습니다. 참조 매뉴얼의이 부분은 파이썬 사양의 해석을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="50a39d682c8b293bc2c1a0cd3988cb1316472ae2" translate="yes" xml:space="preserve">
          <source>Once you have the file, you can also read its contents:</source>
          <target state="translated">파일이 있으면 내용을 읽을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b23c60dd5536314803c0f831966f5b1fc94290ea" translate="yes" xml:space="preserve">
          <source>One &lt;code&gt;for&lt;/code&gt; clause in a comprehension. &lt;code&gt;target&lt;/code&gt; is the reference to use for each element - typically a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.Tuple&quot;&gt;&lt;code&gt;Tuple&lt;/code&gt;&lt;/a&gt; node. &lt;code&gt;iter&lt;/code&gt; is the object to iterate over. &lt;code&gt;ifs&lt;/code&gt; is a list of test expressions: each &lt;code&gt;for&lt;/code&gt; clause can have multiple &lt;code&gt;ifs&lt;/code&gt;.</source>
          <target state="translated">하나 &lt;code&gt;for&lt;/code&gt; 이해력에있는 절. &lt;code&gt;target&lt;/code&gt; 은 각 요소 (일반적으로 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ast.Tuple&quot;&gt; &lt;code&gt;Tuple&lt;/code&gt; &lt;/a&gt; 노드) 에 사용할 참조 입니다. &lt;code&gt;iter&lt;/code&gt; 는 반복 할 객체입니다. &lt;code&gt;ifs&lt;/code&gt; 는 테스트 표현식의 목록입니다 : 각 &lt;code&gt;for&lt;/code&gt; 절은 여러 &lt;code&gt;ifs&lt;/code&gt; 를 가질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f7ff6936f08d9dafa27c2a7c0ea9ece2945b6a" translate="yes" xml:space="preserve">
          <source>One can also cause all warnings to be exceptions by using &lt;code&gt;error&lt;/code&gt; instead of &lt;code&gt;always&lt;/code&gt;. One thing to be aware of is that if a warning has already been raised because of a &lt;code&gt;once&lt;/code&gt;/&lt;code&gt;default&lt;/code&gt; rule, then no matter what filters are set the warning will not be seen again unless the warnings registry related to the warning has been cleared.</source>
          <target state="translated">&lt;code&gt;always&lt;/code&gt; 대신 &lt;code&gt;error&lt;/code&gt; 를 사용하여 모든 경고를 예외로 만들 수도 있습니다 . 주의해야 할 한 가지 경고가 이미 때문에로 제기되고있는 경우입니다 &lt;code&gt;once&lt;/code&gt; / &lt;code&gt;default&lt;/code&gt; 규칙, 다음에는 경고가 해제 된 경고에 관련된 레지스트리를 제외 필터는 경고가 다시 볼 수 없습니다 설정 무슨 상관.</target>
        </trans-unit>
        <trans-unit id="412f97dfac468fe3c85abdccb1436f3c6754c211" translate="yes" xml:space="preserve">
          <source>One can create a pool of processes which will carry out tasks submitted to it with the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 클래스로 제출 된 작업을 수행 할 프로세스 풀을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ad735603768448e20a288aa471831e1d3bf88e6" translate="yes" xml:space="preserve">
          <source>One class, &lt;a href=&quot;#http.server.HTTPServer&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt;, is a &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;socketserver.TCPServer&lt;/code&gt;&lt;/a&gt; subclass. It creates and listens at the HTTP socket, dispatching the requests to a handler. Code to create and run the server looks like this:</source>
          <target state="translated">하나의 클래스 인 &lt;a href=&quot;#http.server.HTTPServer&quot;&gt; &lt;code&gt;HTTPServer&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;socketserver.TCPServer&lt;/code&gt; &lt;/a&gt; 서브 클래스입니다. HTTP 소켓을 작성하고 청취하여 요청을 핸들러로 디스패치합니다. 서버를 만들고 실행하는 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7087184633e7181831a047d644ec560eea655368" translate="yes" xml:space="preserve">
          <source>One client can access the server as follows:</source>
          <target state="translated">한 클라이언트가 다음과 같이 서버에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d4ef3d17dad8ff1ba572aeda5566878ba2d3416" translate="yes" xml:space="preserve">
          <source>One difference between this module and Henstridge&amp;rsquo;s: his catalog objects supported access through a mapping API, but this appears to be unused and so is not currently supported.</source>
          <target state="translated">이 모듈과 Henstridge와의 한 가지 차이점 : 카탈로그 객체는 매핑 API를 통한 액세스를 지원했지만 사용되지 않은 것으로 보이므로 현재 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5763c2d1a6c833df6c8067ce7085ffa547578913" translate="yes" xml:space="preserve">
          <source>One downside of these convenience functions is that the need to handle both IPv4 and IPv6 formats means that error messages provide minimal information on the precise error, as the functions don&amp;rsquo;t know whether the IPv4 or IPv6 format was intended. More detailed error reporting can be obtained by calling the appropriate version specific class constructors directly.</source>
          <target state="translated">이러한 편의 기능 중 하나의 단점은 IPv4 및 IPv6 형식을 모두 처리해야한다는 것은 오류 메시지가 정확한 오류에 대한 정보를 최소한으로 제공한다는 것을 의미합니다. 기능은 IPv4 또는 IPv6 형식의 의도 여부를 알 수 없기 때문입니다. 적절한 버전 별 클래스 생성자를 직접 호출하여보다 자세한 오류보고를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d3b96d4bd51e1e6c79ce329a792e822561bb377" translate="yes" xml:space="preserve">
          <source>One exception is defined as an attribute of the &lt;a href=&quot;#module-poplib&quot;&gt;&lt;code&gt;poplib&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">&lt;a href=&quot;#module-poplib&quot;&gt; &lt;code&gt;poplib&lt;/code&gt; &lt;/a&gt; 모듈 의 속성으로 한 가지 예외가 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="a72557fcbc3e55ff795f503fb908c1ad3cb3e7c3" translate="yes" xml:space="preserve">
          <source>One limitation has to do with accuracy of timing information. There is a fundamental problem with deterministic profilers involving accuracy. The most obvious restriction is that the underlying &amp;ldquo;clock&amp;rdquo; is only ticking at a rate (typically) of about .001 seconds. Hence no measurements will be more accurate than the underlying clock. If enough measurements are taken, then the &amp;ldquo;error&amp;rdquo; will tend to average out. Unfortunately, removing this first error induces a second source of error.</source>
          <target state="translated">타이밍 정보의 정확성과 관련하여 한 가지 제한이 있습니다. 정확성과 관련된 결정 론적 프로파일 러에는 근본적인 문제가 있습니다. 가장 명백한 제한은 기본 &quot;시계&quot;가 (일반적으로) 약 .001 초의 속도로만 똑딱 거리는 것입니다. 따라서 기본 클럭보다 더 정확한 측정은 없습니다. 충분한 측정을 수행하면 &quot;오류&quot;가 평균이되는 경향이 있습니다. 불행히도이 첫 번째 오류를 제거하면 두 번째 오류 원인이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5d30662d8771fa11b0017b4d40f87263cc12f04c" translate="yes" xml:space="preserve">
          <source>One method needs to be defined for container objects to provide iteration support:</source>
          <target state="translated">반복 지원을 제공하기 위해 컨테이너 객체에 대해 한 가지 방법을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c275e97c9c5002e886d7fe72ea350785b0233d2a" translate="yes" xml:space="preserve">
          <source>One more support function is also defined:</source>
          <target state="translated">지원 기능이 하나 더 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33c0248d0f5b644a8ee6869c9c83e50620e88604" translate="yes" xml:space="preserve">
          <source>One more than the number of the highest signal number.</source>
          <target state="translated">가장 높은 신호 번호보다 하나 더.</target>
        </trans-unit>
        <trans-unit id="b14b841456d54340be37e877cf490ede6a8dc178" translate="yes" xml:space="preserve">
          <source>One more thing to be aware of is that the parser-level &lt;code&gt;get()&lt;/code&gt; method provides a custom, more complex interface, maintained for backwards compatibility. When using this method, a fallback value can be provided via the &lt;code&gt;fallback&lt;/code&gt; keyword-only argument:</source>
          <target state="translated">알아 두어야 할 또 다른 사항은 파서 레벨 &lt;code&gt;get()&lt;/code&gt; 메소드가 이전 버전과의 호환성을 위해 유지되는보다 복잡한 사용자 정의 인터페이스를 제공한다는 것입니다. 이 방법을 사용할 때 &lt;code&gt;fallback&lt;/code&gt; 키워드 전용 인수 를 통해 폴백 값을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4dad841e0c8793fb2acecc194fc87215ceb56552" translate="yes" xml:space="preserve">
          <source>One needs to call this function straight after the &lt;code&gt;if __name__ ==
'__main__'&lt;/code&gt; line of the main module. For example:</source>
          <target state="translated">메인 모듈 의 &lt;code&gt;if __name__ == '__main__'&lt;/code&gt; 줄 바로 다음에이 함수를 호출해야 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c23c4fd93b19eb8a93ad4ea94f5022d7dccf40a4" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;determinate&amp;rdquo; or &amp;ldquo;indeterminate&amp;rdquo;.</source>
          <target state="translated">&quot;결정적&quot;또는 &quot;불확정 적&quot;중 하나.</target>
        </trans-unit>
        <trans-unit id="792368d2ec0cc35704b6cdade00d87e0b1b51091" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;horizontal&amp;rdquo; or &amp;ldquo;vertical&amp;rdquo;. Specifies the orientation of the progress bar.</source>
          <target state="translated">&quot;가로&quot;또는 &quot;세로&quot;중 하나입니다. 진행률 표시 줄의 방향을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="413c6ea48d40de27918453c5164fccb674e90d4c" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;horizontal&amp;rdquo; or &amp;ldquo;vertical&amp;rdquo;. Specifies the orientation of the separator.</source>
          <target state="translated">&quot;가로&quot;또는 &quot;세로&quot;중 하나입니다. 구분 기호의 방향을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="76cba3ca26e12a80e4964b3cd3c4c38e4f3792c1" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;normal&amp;rdquo;, &amp;ldquo;readonly&amp;rdquo;, or &amp;ldquo;disabled&amp;rdquo;. In the &amp;ldquo;readonly&amp;rdquo; state, the value may not be edited directly, and the user can only selection of the values from the dropdown list. In the &amp;ldquo;normal&amp;rdquo; state, the text field is directly editable. In the &amp;ldquo;disabled&amp;rdquo; state, no interaction is possible.</source>
          <target state="translated">&quot;정상&quot;, &quot;읽기 전용&quot;또는 &quot;비활성화&quot;중 하나입니다. &quot;읽기 전용&quot;상태에서는 값을 직접 편집 할 수 없으며 사용자는 드롭 다운 목록에서 값만 선택할 수 있습니다. &quot;정상&quot;상태에서는 텍스트 필드를 직접 편집 할 수 있습니다. &quot;비활성화 됨&quot;상태에서는 상호 작용이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="b71680b34169ae274a157ce0f891fed86a995ab7" translate="yes" xml:space="preserve">
          <source>One of the more common uses of &lt;code&gt;nargs='?'&lt;/code&gt; is to allow optional input and output files:</source>
          <target state="translated">&lt;code&gt;nargs='?'&lt;/code&gt; 의 더 일반적인 용도 중 하나 선택적 입력 및 출력 파일을 허용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5b55b53653ecf6bdee05bb4d9db6dde58eb35a46" translate="yes" xml:space="preserve">
          <source>One of the most common tasks is to generate the flat (serialized) version of the email message represented by a message object structure. You will need to do this if you want to send your message via &lt;a href=&quot;smtplib#smtplib.SMTP.sendmail&quot;&gt;&lt;code&gt;smtplib.SMTP.sendmail()&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;nntplib#module-nntplib&quot;&gt;&lt;code&gt;nntplib&lt;/code&gt;&lt;/a&gt; module, or print the message on the console. Taking a message object structure and producing a serialized representation is the job of the generator classes.</source>
          <target state="translated">가장 일반적인 작업 중 하나는 메시지 개체 구조로 표시되는 전자 메일 메시지의 플랫 (직렬화 된) 버전을 생성하는 것입니다. &lt;a href=&quot;smtplib#smtplib.SMTP.sendmail&quot;&gt; &lt;code&gt;smtplib.SMTP.sendmail()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;nntplib#module-nntplib&quot;&gt; &lt;code&gt;nntplib&lt;/code&gt; &lt;/a&gt; 모듈을 통해 메시지를 보내 거나 콘솔에서 메시지를 인쇄하려면 이 작업을 수행해야합니다 . 메시지 객체 구조를 취하고 직렬화 된 표현을 생성하는 것은 생성기 클래스의 작업입니다.</target>
        </trans-unit>
        <trans-unit id="93c09cddaf4af85bdb82c014ec742b6b5d02f54f" translate="yes" xml:space="preserve">
          <source>One of two places where &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; actually inspects the type of a field is to determine if a field is a class variable as defined in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;. It does this by checking if the type of the field is &lt;code&gt;typing.ClassVar&lt;/code&gt;. If a field is a &lt;code&gt;ClassVar&lt;/code&gt;, it is excluded from consideration as a field and is ignored by the dataclass mechanisms. Such &lt;code&gt;ClassVar&lt;/code&gt; pseudo-fields are not returned by the module-level &lt;a href=&quot;#dataclasses.fields&quot;&gt;&lt;code&gt;fields()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 실제로 필드의 유형을 검사하는 두 곳 중 하나는 필드가 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 526에&lt;/strong&gt;&lt;/a&gt; 정의 된 클래스 변수인지 확인하는 것입니다 . 필드 유형이 &lt;code&gt;typing.ClassVar&lt;/code&gt; 인지 확인하여이를 수행합니다 . 필드가 &lt;code&gt;ClassVar&lt;/code&gt; 인 경우 필드로 간주되지 않고 데이터 클래스 메커니즘에서 무시됩니다. 이러한 &lt;code&gt;ClassVar&lt;/code&gt; 의사 필드는 모듈 수준 &lt;a href=&quot;#dataclasses.fields&quot;&gt; &lt;code&gt;fields()&lt;/code&gt; &lt;/a&gt; 함수에 의해 반환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="b4fa5b092d960caa5c98eb1763a721595959c032" translate="yes" xml:space="preserve">
          <source>One particularly effective way of handling sub-commands is to combine the use of the &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method with calls to &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt;&lt;code&gt;set_defaults()&lt;/code&gt;&lt;/a&gt; so that each subparser knows which Python function it should execute. For example:</source>
          <target state="translated">하위 명령을 처리하는 특히 효과적인 방법 중 하나는 &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메서드를 &lt;a href=&quot;#argparse.ArgumentParser.set_defaults&quot;&gt; &lt;code&gt;set_defaults()&lt;/code&gt; &lt;/a&gt; 호출과 결합하여 각 하위 구문 분석기가 실행할 Python 함수를 알 수 있도록하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6265c9633edbf23fb81d92e275200b17517c24ee" translate="yes" xml:space="preserve">
          <source>One possible reason to set &lt;code&gt;hash=False&lt;/code&gt; but &lt;code&gt;compare=True&lt;/code&gt; would be if a field is expensive to compute a hash value for, that field is needed for equality testing, and there are other fields that contribute to the type&amp;rsquo;s hash value. Even if a field is excluded from the hash, it will still be used for comparisons.</source>
          <target state="translated">&lt;code&gt;hash=False&lt;/code&gt; 이지만 &lt;code&gt;compare=True&lt;/code&gt; = 참을 설정하는 한 가지 가능한 이유 는 필드가 해시 값을 계산하는 데 비용이 많이 들고, 해당 필드가 동등성 테스트에 필요하고 유형의 해시 값에 기여하는 다른 필드가 있기 때문입니다. 필드가 해시에서 제외 되더라도 여전히 비교에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a226b0eaad4988e53ed4f880b8d7a128f07557e7" translate="yes" xml:space="preserve">
          <source>One should just use a copy of the referent instead when making comparisons.</source>
          <target state="translated">비교할 때 참조의 사본을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c62e6f913693a5417011764c6f11e9c5f58e5593" translate="yes" xml:space="preserve">
          <source>One use case for this is for mocking objects used as context managers in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">이에 대한 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 컨텍스트 관리자로 사용되는 객체를 조롱하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="ab3e7193bd28fb961e976d99467bf8a10813836c" translate="yes" xml:space="preserve">
          <source>One use case for this is for mocking objects used as context managers in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement:</source>
          <target state="translated">이에 대한 한 가지 사용 사례는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 컨텍스트 관리자로 사용되는 개체를 모의하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="2db721d062a28eead2d894ec1cc32437698273d5" translate="yes" xml:space="preserve">
          <source>One useful application of the second form of &lt;a href=&quot;#iter&quot;&gt;&lt;code&gt;iter()&lt;/code&gt;&lt;/a&gt; is to build a block-reader. For example, reading fixed-width blocks from a binary database file until the end of file is reached:</source>
          <target state="translated">&lt;a href=&quot;#iter&quot;&gt; &lt;code&gt;iter()&lt;/code&gt; &lt;/a&gt; 의 두 번째 형식의 유용한 응용 프로그램 중 하나 는 블록 리더를 작성하는 것입니다. 예를 들어, 파일 끝에 도달 할 때까지 이진 데이터베이스 파일에서 고정 너비 블록을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="941e0e22f8b46e0572e23109cb229b556c8c68de" translate="yes" xml:space="preserve">
          <source>One useful feature of the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module is the built-in &lt;a href=&quot;#sqlite3.Row&quot;&gt;&lt;code&gt;sqlite3.Row&lt;/code&gt;&lt;/a&gt; class designed to be used as a row factory.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈 의 유용한 기능 중 하나 는 행 팩토리로 사용하도록 설계된 내장 &lt;a href=&quot;#sqlite3.Row&quot;&gt; &lt;code&gt;sqlite3.Row&lt;/code&gt; &lt;/a&gt; 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fd18cd38e6a1b32596d71ef2b185bf3b797fb25f" translate="yes" xml:space="preserve">
          <source>One way to open a box is to type a key character and wait for a predefined interval. This defaults to 2 seconds; customize it in the settings dialog. (To prevent auto popups, set the delay to a large number of milliseconds, such as 100000000.) For imported module names or class or function attributes, type &amp;lsquo;.&amp;rsquo;. For filenames in the root directory, type &lt;a href=&quot;os#os.sep&quot;&gt;&lt;code&gt;os.sep&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;os#os.altsep&quot;&gt;&lt;code&gt;os.altsep&lt;/code&gt;&lt;/a&gt; immediately after an opening quote. (On Windows, one can specify a drive first.) Move into subdirectories by typing a directory name and a separator.</source>
          <target state="translated">상자를 여는 한 가지 방법은 키 문자를 입력하고 미리 정의 된 간격을 기다리는 것입니다. 기본값은 2 초입니다. 설정 대화 상자에서 사용자 정의하십시오. (자동 팝업을 방지하려면 100000000과 같이 많은 밀리 초로 지연을 설정하십시오.) 가져온 모듈 이름이나 클래스 또는 함수 속성의 경우 '.'를 입력하십시오. 루트 디렉토리에있는 파일 이름의 경우 여는 따옴표 바로 뒤에 &lt;a href=&quot;os#os.sep&quot;&gt; &lt;code&gt;os.sep&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;os#os.altsep&quot;&gt; &lt;code&gt;os.altsep&lt;/code&gt; 를&lt;/a&gt; 입력 합니다. (Windows에서는 먼저 드라이브를 지정할 수 있습니다.) 디렉터리 이름과 구분 기호를 입력하여 하위 디렉터리로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="aaef7b6555dea31b8a999a49a168f126d8d8fdaf" translate="yes" xml:space="preserve">
          <source>One way to search and explore this XML example is to manually add the URI to every tag or attribute in the xpath of a &lt;a href=&quot;#xml.etree.ElementTree.Element.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#xml.etree.ElementTree.Element.findall&quot;&gt;&lt;code&gt;findall()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 XML 예제를 검색하고 탐색하는 한 가지 방법은 &lt;a href=&quot;#xml.etree.ElementTree.Element.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#xml.etree.ElementTree.Element.findall&quot;&gt; &lt;code&gt;findall()&lt;/code&gt; &lt;/a&gt; xpath의 모든 태그 또는 속성에 URI를 수동으로 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="685a8c4199bf6d2bcd91aafdcf97ef52c57e0bf8" translate="yes" xml:space="preserve">
          <source>One-dimensional memoryviews of hashable (read-only) types with formats &amp;lsquo;B&amp;rsquo;, &amp;lsquo;b&amp;rsquo; or &amp;lsquo;c&amp;rsquo; are also hashable. The hash is defined as &lt;code&gt;hash(m) == hash(m.tobytes())&lt;/code&gt;:</source>
          <target state="translated">형식이 'B', 'b'또는 'c'인 해시 가능 (읽기 전용) 유형의 1 차원 메모리 뷰도 해시 가능합니다. 해시는 &lt;code&gt;hash(m) == hash(m.tobytes())&lt;/code&gt; 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e2cd4c7e6f9d4fd20fd3009b486f148f36ad549" translate="yes" xml:space="preserve">
          <source>One-shot (de)compression</source>
          <target state="translated">원샷 (de) 압축</target>
        </trans-unit>
        <trans-unit id="e92a8f9a44d55a6fa57ab9d7f17030266d725e27" translate="yes" xml:space="preserve">
          <source>Online reference for tkinter supported by effbot.org.</source>
          <target state="translated">effbot.org에서 지원하는 tkinter에 대한 온라인 참조.</target>
        </trans-unit>
        <trans-unit id="9dbb8fb37052c67451fd1294542a0777a48cd714" translate="yes" xml:space="preserve">
          <source>Only &lt;em&gt;days&lt;/em&gt;, &lt;em&gt;seconds&lt;/em&gt; and &lt;em&gt;microseconds&lt;/em&gt; are stored internally. Arguments are converted to those units:</source>
          <target state="translated">&lt;em&gt;일&lt;/em&gt; , &lt;em&gt;초&lt;/em&gt; 및 &lt;em&gt;마이크로 &lt;/em&gt;&lt;em&gt;초&lt;/em&gt; 만 내부에 저장됩니다. 인수는 해당 단위로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="e496096627294b6371ddb1a7da261de2d33baeed" translate="yes" xml:space="preserve">
          <source>Only ASCII characters are permitted in bytes literals (regardless of the declared source code encoding). Any binary values over 127 must be entered into bytes literals using the appropriate escape sequence.</source>
          <target state="translated">선언 된 소스 코드 인코딩에 관계없이 ASCII 문자 만 바이트 리터럴로 허용됩니다. 127 이상의 이진 값은 적절한 이스케이프 시퀀스를 사용하여 바이트 리터럴로 입력해야합니다.</target>
        </trans-unit>
        <trans-unit id="9bcb0283c49f6302675a6e970eee6fdb45189e87" translate="yes" xml:space="preserve">
          <source>Only ASCII is supported. The &lt;code&gt;backslashreplace&lt;/code&gt; error handler is used on encoding.</source>
          <target state="translated">ASCII 만 지원됩니다. &lt;code&gt;backslashreplace&lt;/code&gt; 의 오류 처리기는 부호화에 사용된다.</target>
        </trans-unit>
        <trans-unit id="c6113a93896d56d6fd83ee494a739a1940a20027" translate="yes" xml:space="preserve">
          <source>Only authors of web servers and programming frameworks need to know every detail and corner case of the WSGI design. You don&amp;rsquo;t need to understand every detail of WSGI just to install a WSGI application or to write a web application using an existing framework.</source>
          <target state="translated">웹 서버 및 프로그래밍 프레임 워크 작성자 만 WSGI 디자인의 모든 세부 사항과 코너 사례를 알아야합니다. WSGI 응용 프로그램을 설치하거나 기존 프레임 워크를 사용하여 웹 응용 프로그램을 작성하기 위해 WSGI의 모든 세부 사항을 이해할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="5472056d6db2aa4b4e5fca6b6d943ffdc4c17bf0" translate="yes" xml:space="preserve">
          <source>Only available on Windows.</source>
          <target state="translated">Windows에서만 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9cff90a9caa5fca4e097eda23e08985099f6cbd6" translate="yes" xml:space="preserve">
          <source>Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the method raises &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenSSL 1.1.1 및 TLS 1.3이 활성화 된 경우에만 사용 가능합니다. TLS 1.3 지원이 없으면이 메소드는 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="62a51d86e2878cfb5387b455ada7f61c5dffd8a7" translate="yes" xml:space="preserve">
          <source>Only available with OpenSSL 1.1.1 and TLS 1.3 enabled. Without TLS 1.3 support, the property value is None and can&amp;rsquo;t be modified</source>
          <target state="translated">OpenSSL 1.1.1 및 TLS 1.3이 활성화 된 경우에만 사용 가능합니다. TLS 1.3 지원이 없으면 특성 값은 없음이며 수정할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="95c159d38cefff4dfee104a391e7876c9172be62" translate="yes" xml:space="preserve">
          <source>Only call this method when the calling process or thread owns the lock. An &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; is raised if this method is called by a process or thread other than the owner or if the lock is in an unlocked (unowned) state. Note that the type of exception raised in this situation differs from the implemented behavior in &lt;a href=&quot;threading#threading.RLock.release&quot;&gt;&lt;code&gt;threading.RLock.release()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 프로세스 또는 스레드가 잠금을 소유 한 경우에만이 메소드를 호출하십시오. &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; 를는&lt;/a&gt; 이 메소드를 호출하는 방법에 의해 또는 소유자 이외의 스레드 경우 발생되거나 로크가 해제 (소유되지 않은) 상태 인 경우. 이 상황에서 발생한 예외 유형은 &lt;a href=&quot;threading#threading.RLock.release&quot;&gt; &lt;code&gt;threading.RLock.release()&lt;/code&gt; &lt;/a&gt; 에서 구현 된 동작과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="a1b68642ddd76fe9bd27aab5c4134b933957a9b2" translate="yes" xml:space="preserve">
          <source>Only call this method when the calling thread owns the lock. A &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised if this method is called when the lock is unlocked.</source>
          <target state="translated">호출 스레드가 잠금을 소유 한 경우에만이 메소드를 호출하십시오. &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; 에는&lt;/a&gt; 잠금이 해제 될 때이 메소드가 불려 갔을 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="eb1874f752845c50ae749ab0610da40d6a9ed03f" translate="yes" xml:space="preserve">
          <source>Only class methods are defined by this class to alleviate the need for instantiation.</source>
          <target state="translated">이 클래스는 인스턴스화의 필요성을 완화하기 위해 클래스 메소드 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c3bad470e2ecc603718c76f4c9074b5de3a88646" translate="yes" xml:space="preserve">
          <source>Only docstrings attached to objects belonging to module &lt;em&gt;m&lt;/em&gt; are searched.</source>
          <target state="translated">모듈 &lt;em&gt;m에&lt;/em&gt; 속하는 오브젝트에 첨부 된 docstring 만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="51af0077ba3cd9ef0693961e00abb68011fe16f6" translate="yes" xml:space="preserve">
          <source>Only on Mac OS X platform.</source>
          <target state="translated">Mac OS X 플랫폼에서만.</target>
        </trans-unit>
        <trans-unit id="4052b81eb936f003d4ae4d67da6755035d5b6d2c" translate="yes" xml:space="preserve">
          <source>Only on Windows platforms.</source>
          <target state="translated">Windows 플랫폼에서만.</target>
        </trans-unit>
        <trans-unit id="c739e35e3345aa2c864403c706892dacb2999ed6" translate="yes" xml:space="preserve">
          <source>Only one &lt;em&gt;ch&lt;/em&gt; can be pushed before &lt;code&gt;get_wch()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;get_wch()&lt;/code&gt; 가 호출 되기 전에 하나의 &lt;em&gt;ch&lt;/em&gt; 만 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a0fe79f0e31124b5d7fe36b8522ebf56951357a" translate="yes" xml:space="preserve">
          <source>Only one &lt;em&gt;ch&lt;/em&gt; can be pushed before &lt;code&gt;getch()&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;getch()&lt;/code&gt; 가 호출 되기 전에 하나의 &lt;em&gt;ch&lt;/em&gt; 만 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bb6c14b3d23d2945eacea1ff6486fbffeceb261" translate="yes" xml:space="preserve">
          <source>Only one callback can be set per &lt;code&gt;SSLContext&lt;/code&gt;. If &lt;em&gt;sni_callback&lt;/em&gt; is set to &lt;code&gt;None&lt;/code&gt; then the callback is disabled. Calling this function a subsequent time will disable the previously registered callback.</source>
          <target state="translated">&lt;code&gt;SSLContext&lt;/code&gt; 당 하나의 콜백 만 설정할 수 있습니다 . 경우 &lt;em&gt;sni_callback가&lt;/em&gt; 설정되어 &lt;code&gt;None&lt;/code&gt; 다음 콜백을 사용할 수 없습니다. 이 기능을 다음에 호출하면 이전에 등록 된 콜백이 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="921877f46f6c2f6c956d4c2b43d413ed0f256f18" translate="yes" xml:space="preserve">
          <source>Only one concrete &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class, is supplied by the &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module. The &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class can represent simple timezones with fixed offsets from UTC, such as UTC itself or North American EST and EDT timezones. Supporting timezones at deeper levels of detail is up to the application. The rules for time adjustment across the world are more political than rational, change frequently, and there is no standard suitable for every application aside from UTC.</source>
          <target state="translated">하나의 구체적인 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 클래스의 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 클래스는,에 의해 공급되는 &lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈. &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 클래스는 UTC 자체 또는 북미 EST와 EDT 시간대 등 UTC에서 고정 오프셋, 간단한 시간대를 나타낼 수 있습니다. 더 자세한 수준의 시간대 지원은 응용 프로그램에 달려 있습니다. 전 세계의 시간 조정 규칙은 합리적보다 더 정치적이며 자주 변경되며 UTC 이외의 모든 응용 프로그램에 적합한 표준은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2694ff82c068ccb7ad25e6614404effc6e0e6dd" translate="yes" xml:space="preserve">
          <source>Only one stack frame is returned for a suspended coroutine.</source>
          <target state="translated">정지 된 코 루틴에 대해 하나의 스택 프레임 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="45899a65083753942e402707d87a02ef650b8c6b" translate="yes" xml:space="preserve">
          <source>Only run test methods and classes that match the pattern or substring. This option may be used multiple times, in which case all test cases that match of the given patterns are included.</source>
          <target state="translated">패턴 또는 하위 문자열과 일치하는 테스트 메소드 및 클래스 만 실행하십시오. 이 옵션은 여러 번 사용될 수 있으며,이 경우 주어진 패턴과 일치하는 모든 테스트 사례가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b86acce0e0c3ada12f44f0e9d2c197184c46af52" translate="yes" xml:space="preserve">
          <source>Only the directives specified in the documentation are supported. Because &lt;code&gt;strftime()&lt;/code&gt; is implemented per platform it can sometimes offer more directives than those listed. But &lt;code&gt;strptime()&lt;/code&gt; is independent of any platform and thus does not necessarily support all directives available that are not documented as supported.</source>
          <target state="translated">설명서에 지정된 지시문 만 지원됩니다. &lt;code&gt;strftime()&lt;/code&gt; 은 플랫폼마다 구현 되므로 때로는 나열된 것보다 많은 지시문을 제공 할 수 있습니다. 그러나 &lt;code&gt;strptime()&lt;/code&gt; 은 모든 플랫폼과 독립적이므로 지원되는 것으로 문서화되지 않은 사용 가능한 모든 지시문을 반드시 지원하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="16dec77f10fe170dae724bd68005e7aa2cc49646" translate="yes" xml:space="preserve">
          <source>Only the filename, the function name and the line number are displayed. (no source code)</source>
          <target state="translated">파일 이름, 기능 이름 및 줄 번호 만 표시됩니다. (소스 코드 없음)</target>
        </trans-unit>
        <trans-unit id="60d352aab6fcb944b7fc146c1abce5b6e9d139b1" translate="yes" xml:space="preserve">
          <source>Only the memory consumption directly attributed to the object is accounted for, not the memory consumption of objects it refers to.</source>
          <target state="translated">객체에 직접 기여한 메모리 소비 만 설명하며, 객체의 메모리 소비는 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d182c5edf8d6af50c78e1101233e80d072394832" translate="yes" xml:space="preserve">
          <source>Only works for a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; which defines an &lt;code&gt;iter_modules()&lt;/code&gt; method. This interface is non-standard, so the module also provides implementations for &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt;&lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt;&lt;code&gt;zipimport.zipimporter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iter_modules()&lt;/code&gt; 메소드 를 정의하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-finder&quot;&gt;파인더&lt;/a&gt; 에서만 작동합니다 . 이 인터페이스는 비표준이므로 모듈은 &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt; &lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt; &lt;code&gt;zipimport.zipimporter&lt;/code&gt; &lt;/a&gt; 구현도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cd9a00ba5a14c9c2324fca22dccca7c5e146c055" translate="yes" xml:space="preserve">
          <source>Only works for a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;finder&lt;/a&gt; which defines an &lt;code&gt;iter_modules()&lt;/code&gt; method. This interface is non-standard, so the module also provides implementations for &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt;&lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt;&lt;code&gt;zipimport.zipimporter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;iter_modules()&lt;/code&gt; 메서드 를 정의하는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-finder&quot;&gt;파인더&lt;/a&gt; 에서만 작동합니다 . 이 인터페이스는 비표준이므로 모듈은 &lt;a href=&quot;importlib#importlib.machinery.FileFinder&quot;&gt; &lt;code&gt;importlib.machinery.FileFinder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zipimport#zipimport.zipimporter&quot;&gt; &lt;code&gt;zipimport.zipimporter&lt;/code&gt; 에&lt;/a&gt; 대한 구현도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="cce35e3b95640fdd8783117c0d6b1bb2575dc0c6" translate="yes" xml:space="preserve">
          <source>Only writeable with OpenSSL 1.1.0 or higher.</source>
          <target state="translated">OpenSSL 1.1.0 이상에서만 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c549906c5562588206324bfc20c815277d21a5" translate="yes" xml:space="preserve">
          <source>Opcode collections</source>
          <target state="translated">Opcode 컬렉션</target>
        </trans-unit>
        <trans-unit id="cf9b77061f7b3126b49d50a6fa68f7ca8c26b7a3" translate="yes" xml:space="preserve">
          <source>Open</source>
          <target state="translated">Open</target>
        </trans-unit>
        <trans-unit id="3fc17c6daa0379542d7b9c9064a83dc69e75bffb" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;file&lt;/em&gt; and return a corresponding &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. If the file cannot be opened, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;파일을&lt;/em&gt; 열고 해당 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 . 파일을 열 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6767f6f97a36f678cadfed5ebab2204f4d3ef84f" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;file&lt;/em&gt; and return a corresponding &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. If the file cannot be opened, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised. See &lt;a href=&quot;https://docs.python.org/3.9/tutorial/inputoutput.html#tut-files&quot;&gt;Reading and Writing Files&lt;/a&gt; for more examples of how to use this function.</source>
          <target state="translated">&lt;em&gt;파일을&lt;/em&gt; 열고 해당 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 . 파일을 열 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 이 함수를 사용하는 방법에 대한 더 많은 예제는 &lt;a href=&quot;https://docs.python.org/3.9/tutorial/inputoutput.html#tut-files&quot;&gt;파일 읽기 및 쓰기를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0969da77d3b4939c7e92316eec745323136d4364" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;fullurl&lt;/em&gt; using the appropriate protocol. This method sets up cache and proxy information, then calls the appropriate open method with its input arguments. If the scheme is not recognized, &lt;a href=&quot;#urllib.request.URLopener.open_unknown&quot;&gt;&lt;code&gt;open_unknown()&lt;/code&gt;&lt;/a&gt; is called. The &lt;em&gt;data&lt;/em&gt; argument has the same meaning as the &lt;em&gt;data&lt;/em&gt; argument of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열기 &lt;em&gt;fullurl&lt;/em&gt; 적절한 프로토콜을 사용. 이 메소드는 캐시 및 프록시 정보를 설정 한 다음 입력 인수로 적절한 open 메소드를 호출합니다. 체계가 인식되지 않으면 &lt;a href=&quot;#urllib.request.URLopener.open_unknown&quot;&gt; &lt;code&gt;open_unknown()&lt;/code&gt; &lt;/a&gt; 이 호출됩니다. &lt;em&gt;데이터&lt;/em&gt; 인수는 동일한 의미를 갖는 &lt;em&gt;데이터&lt;/em&gt; 의 인수 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ea233b21029cc672f31fe9b3997814419601cd0" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new page (&amp;ldquo;tab&amp;rdquo;) of the browser handled by this controller, if possible, otherwise equivalent to &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 경우이 컨트롤러가 처리하는 브라우저의 새 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 &lt;em&gt;url&lt;/em&gt; 을 엽니 다 . 그렇지 않으면 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b6693c0a4bbf0ab0047e8b16619f81dc52e9dab4" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new page (&amp;ldquo;tab&amp;rdquo;) of the default browser, if possible, otherwise equivalent to &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가능한 경우 기본 브라우저의 새 페이지 (&amp;ldquo;탭&amp;rdquo;)에서 &lt;em&gt;url&lt;/em&gt; 을 엽니 다 . 그렇지 않으면 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="b8866b21bed2f90c7e0d0db5d81720b7915e2396" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new window of the browser handled by this controller, if possible, otherwise, open &lt;em&gt;url&lt;/em&gt; in the only browser window. Alias &lt;a href=&quot;#webbrowser.open_new&quot;&gt;&lt;code&gt;open_new()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">열기 &lt;em&gt;URL을&lt;/em&gt; 가능하면 브라우저의 새 창에서, 그렇지 않으면,이 컨트롤러에 의해 개방 처리 &lt;em&gt;URL을&lt;/em&gt; 하는 유일한 브라우저 창에서. 별명 &lt;a href=&quot;#webbrowser.open_new&quot;&gt; &lt;code&gt;open_new()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80be1f0f5216d3c4d0013d4e332bf117ad7d0caf" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt; in a new window of the default browser, if possible, otherwise, open &lt;em&gt;url&lt;/em&gt; in the only browser window.</source>
          <target state="translated">열기 &lt;em&gt;URL&lt;/em&gt; 기본 브라우저의 새 창에서 가능하면, 그렇지 않으면 오픈 &lt;em&gt;URL&lt;/em&gt; 유일한 브라우저 창입니다.</target>
        </trans-unit>
        <trans-unit id="c004943ea8325dbad5b0898f3d806b2cc79ada2b" translate="yes" xml:space="preserve">
          <source>Open &lt;em&gt;url&lt;/em&gt;. If open fails, raises &lt;a href=&quot;#test.support.TestFailed&quot;&gt;&lt;code&gt;TestFailed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;url을&lt;/em&gt; 엽니 다 . 열리지 않으면 &lt;a href=&quot;#test.support.TestFailed&quot;&gt; &lt;code&gt;TestFailed&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="167f647cfa354d55132f5f4c726947ab44e252e5" translate="yes" xml:space="preserve">
          <source>Open FTP URLs, keeping a cache of open FTP connections to minimize delays.</source>
          <target state="translated">지연 시간을 최소화하기 위해 열린 FTP 연결 캐시를 유지하는 열린 FTP URL</target>
        </trans-unit>
        <trans-unit id="8d287b03a85c8b0ae6a80daba6bfee69f5e82fba" translate="yes" xml:space="preserve">
          <source>Open FTP URLs.</source>
          <target state="translated">FTP URL을여십시오.</target>
        </trans-unit>
        <trans-unit id="83a9f9ab392f027e4bb05e016c0ac5b186fb79a0" translate="yes" xml:space="preserve">
          <source>Open Module&amp;hellip;</source>
          <target state="translated">모듈 열기&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="0a169583e6466c4bfd610a1b2484012408457535" translate="yes" xml:space="preserve">
          <source>Open Sound System Programmer&amp;rsquo;s Guide</source>
          <target state="translated">개방형 사운드 시스템 프로그래머 안내서</target>
        </trans-unit>
        <trans-unit id="d650c621aed21d23bbb1a249e9d1ffa127b4a119" translate="yes" xml:space="preserve">
          <source>Open a &lt;code&gt;dumbdbm&lt;/code&gt; database and return a dumbdbm object. The &lt;em&gt;filename&lt;/em&gt; argument is the basename of the database file (without any specific extensions). When a dumbdbm database is created, files with &lt;code&gt;.dat&lt;/code&gt; and &lt;code&gt;.dir&lt;/code&gt; extensions are created.</source>
          <target state="translated">&lt;code&gt;dumbdbm&lt;/code&gt; 데이터베이스를 열고 dumbdbm 오브젝트를 리턴하십시오. &lt;em&gt;파일 이름&lt;/em&gt; 인수는 (특정 확장자없이) 데이터베이스 파일의 기본 이름입니다. dumbdbm 데이터베이스가 작성되면 확장자가 &lt;code&gt;.dat&lt;/code&gt; 및 &lt;code&gt;.dir&lt;/code&gt; 인 파일 이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="e632fe179883b3d0338581a425671fd5094822ca" translate="yes" xml:space="preserve">
          <source>Open a &lt;code&gt;gdbm&lt;/code&gt; database and return a &lt;code&gt;gdbm&lt;/code&gt; object. The &lt;em&gt;filename&lt;/em&gt; argument is the name of the database file.</source>
          <target state="translated">&lt;code&gt;gdbm&lt;/code&gt; 데이터베이스를 열고 &lt;code&gt;gdbm&lt;/code&gt; 객체를 반환하십시오 . &lt;em&gt;파일 이름&lt;/em&gt; 인수는 데이터베이스 파일의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4322583748a9c6421dfb4c09fcaf033d44e4d9da" translate="yes" xml:space="preserve">
          <source>Open a &lt;em&gt;stream&lt;/em&gt; of tar blocks for reading with transparent compression.</source>
          <target state="translated">투명한 압축으로 읽을 수 있도록 tar 블록 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="729abd50a19a9f17e3e7c4f19594ca97385dcc56" translate="yes" xml:space="preserve">
          <source>Open a &lt;em&gt;stream&lt;/em&gt; of uncompressed tar blocks for reading.</source>
          <target state="translated">읽을 압축되지 않은 tar 블록 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="0a595c5666012f5a73201a7ad3255c23528028d9" translate="yes" xml:space="preserve">
          <source>Open a TCP connection.</source>
          <target state="translated">TCP 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="dedbe01a1c7e4b40aa832642beeaa62e8071b7b2" translate="yes" xml:space="preserve">
          <source>Open a Unix socket connection.</source>
          <target state="translated">유닉스 소켓 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="c30333aca1528eaa7dec5dcc0b551102c76fb3bc" translate="yes" xml:space="preserve">
          <source>Open a ZIP file, where &lt;em&gt;file&lt;/em&gt; can be a path to a file (a string), a file-like object or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">ZIP 파일을 엽니 다. 여기서 &lt;em&gt;파일&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 의 경로 (문자열), 파일과 같은 객체 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은 객체 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b844406e1d7fb2c84d714af40a1c0b56204e8098" translate="yes" xml:space="preserve">
          <source>Open a ZIP file, where &lt;em&gt;file&lt;/em&gt; can be a path to a file (a string), a file-like object or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;path-like object&lt;/a&gt;.</source>
          <target state="translated">ZIP 파일을 엽니 다. 여기서 &lt;em&gt;file&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 의 경로 (문자열), 파일 류 객체 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-like-object&quot;&gt;경로 류 객체 일 수&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="769e263af17bbeb1d57314125f9ccfea5fdf9008" translate="yes" xml:space="preserve">
          <source>Open a bzip2 compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 bzip2 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="d71b74051ccf64b5252b5579fb9f29f5d65d41ae" translate="yes" xml:space="preserve">
          <source>Open a bzip2 compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 bzip2 압축 &lt;em&gt;스트림&lt;/em&gt; 을여십시오.</target>
        </trans-unit>
        <trans-unit id="6c202a8f725c3966ee9eb45191a4f1f648fe6ef6" translate="yes" xml:space="preserve">
          <source>Open a bzip2-compressed file in binary mode.</source>
          <target state="translated">이진 모드에서 bzip2 압축 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="61e2bcd0c719fe1eff240cd130593bcf98e87f8b" translate="yes" xml:space="preserve">
          <source>Open a bzip2-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">bzip2 압축 파일을 이진 또는 텍스트 모드로 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="5c501141e20ca6f1bb67e9874109864e0151202e" translate="yes" xml:space="preserve">
          <source>Open a bzip2-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">바이너리 또는 텍스트 모드에서 bzip2 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="efeeb124691327df2e796c4e2f61fca215aaaf35" translate="yes" xml:space="preserve">
          <source>Open a column to the left of the edit window which shows the number of each line of text. The default is off, which may be changed in the preferences (see &lt;a href=&quot;#preferences&quot;&gt;Setting preferences&lt;/a&gt;).</source>
          <target state="translated">각 텍스트 줄 수를 표시하는 편집 창 왼쪽에서 열을 엽니 다. 기본값은 (참조 환경 설정에서 변경 될 수있는, 꺼져 &lt;a href=&quot;#preferences&quot;&gt;설정 기본 설정&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5138f8e4961bfac889560919d28c3273c8242a35" translate="yes" xml:space="preserve">
          <source>Open a configuration dialog and change preferences for the following: fonts, indentation, keybindings, text color themes, startup windows and size, additional help sources, and extensions. On macOS, open the configuration dialog by selecting Preferences in the application menu. For more details, see &lt;a href=&quot;#preferences&quot;&gt;Setting preferences&lt;/a&gt; under Help and preferences.</source>
          <target state="translated">구성 대화 상자를 열고 글꼴, 들여 쓰기, 키 바인딩, 텍스트 색상 테마, 시작 창 및 크기, 추가 도움말 소스 및 확장에 대한 환경 설정을 변경하십시오. macOS의 경우 응용 프로그램 메뉴에서 기본 설정을 선택하여 구성 대화 상자를여십시오. 자세한 내용은 도움말 및 환경 &lt;a href=&quot;#preferences&quot;&gt;설정에서 환경 설정 구성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb78ee95466565bc19aba0319a23cbc54a1f5a4d" translate="yes" xml:space="preserve">
          <source>Open a context menu by right-clicking in a window (Control-click on macOS). Context menus have the standard clipboard functions also on the Edit menu.</source>
          <target state="translated">윈도우에서 마우스 오른쪽 버튼을 클릭하여 상황에 맞는 메뉴를 엽니 다 (macOS에서 Control- 클릭). 상황에 맞는 메뉴에는 편집 메뉴에도 표준 클립 보드 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364f2f6816d76d9a15863cac1e9715a393be440" translate="yes" xml:space="preserve">
          <source>Open a datagram (UDP) connection.</source>
          <target state="translated">데이터 그램 (UDP) 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="dab27c8f9d447246bffdf89284e45b057ad9df09" translate="yes" xml:space="preserve">
          <source>Open a dbm database and return a &lt;code&gt;ndbm&lt;/code&gt; object. The &lt;em&gt;filename&lt;/em&gt; argument is the name of the database file (without the &lt;code&gt;.dir&lt;/code&gt; or &lt;code&gt;.pag&lt;/code&gt; extensions).</source>
          <target state="translated">dbm 데이터베이스를 열고 &lt;code&gt;ndbm&lt;/code&gt; 오브젝트를 리턴하십시오 . &lt;em&gt;파일 이름&lt;/em&gt; 인수합니다 (없는 데이터베이스 파일의 이름입니다 &lt;code&gt;.dir&lt;/code&gt; 또는 &lt;code&gt;.pag&lt;/code&gt; 확장).</target>
        </trans-unit>
        <trans-unit id="da0ecd35b7e06e2e10631de386f9db741d263580" translate="yes" xml:space="preserve">
          <source>Open a dialog to change indent width. The accepted default by the Python community is 4 spaces.</source>
          <target state="translated">들여 쓰기 너비를 변경하려면 대화 상자를 엽니 다. Python 커뮤니티에서 허용되는 기본값은 4 개의 공백입니다.</target>
        </trans-unit>
        <trans-unit id="ab3cd1f4cf6f887a03a632cf57e13ad36b7a697f" translate="yes" xml:space="preserve">
          <source>Open a dialog to switch between indenting with spaces and tabs.</source>
          <target state="translated">공백과 탭 들여 쓰기 간을 전환하는 대화 상자를 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a25e5b56a56e73584a7689c789c2a64cbda285d4" translate="yes" xml:space="preserve">
          <source>Open a file in read only mode using the encoding detected by &lt;a href=&quot;#tokenize.detect_encoding&quot;&gt;&lt;code&gt;detect_encoding()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tokenize.detect_encoding&quot;&gt; &lt;code&gt;detect_encoding()&lt;/code&gt; &lt;/a&gt; 의해 감지 된 인코딩을 사용하여 파일을 읽기 전용 모드로 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="37ab3730c8e04788612d761f24c638eb97873272" translate="yes" xml:space="preserve">
          <source>Open a file search dialog. Put results in a new output window.</source>
          <target state="translated">파일 검색 대화 상자를 엽니 다. 새로운 출력 창에 결과를 넣습니다.</target>
        </trans-unit>
        <trans-unit id="2eb14a6fd323b13d0beb8b8c63d260dee2458311" translate="yes" xml:space="preserve">
          <source>Open a gzip compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 gzip 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="58de51c83b15bd0a90eb56d615d749c080c0428e" translate="yes" xml:space="preserve">
          <source>Open a gzip compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 gzip 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5f9ebb796e4ce59f8458da340d1d52a456be5ef3" translate="yes" xml:space="preserve">
          <source>Open a gzip-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">바이너리 또는 텍스트 모드에서 gzip 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="df9eaa58da31d44e870bff5c208ccabfb6e4d3cb" translate="yes" xml:space="preserve">
          <source>Open a gzip-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">바이너리 또는 텍스트 모드에서 gzip 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="30c017ce0258307bd561cc1c740687ba59474f0b" translate="yes" xml:space="preserve">
          <source>Open a list of recent files. Click one to open it.</source>
          <target state="translated">최근 파일 목록을 엽니 다. 하나를 클릭하여 엽니 다.</target>
        </trans-unit>
        <trans-unit id="ca394801875e76928a12c9b6e408f346c581adf2" translate="yes" xml:space="preserve">
          <source>Open a mixer device and return an OSS mixer device object. &lt;em&gt;device&lt;/em&gt; is the mixer device filename to use. If it is not specified, this module first looks in the environment variable &lt;code id=&quot;index-1&quot;&gt;MIXERDEV&lt;/code&gt; for a device to use. If not found, it falls back to &lt;code&gt;/dev/mixer&lt;/code&gt;.</source>
          <target state="translated">믹서 장치를 열고 OSS 믹서 장치 개체를 반환하십시오. &lt;em&gt;device&lt;/em&gt; 는 사용할 믹서 장치 파일 이름입니다. 지정되지 않은 경우이 모듈은 먼저 환경 변수 &lt;code id=&quot;index-1&quot;&gt;MIXERDEV&lt;/code&gt; 에서 장치를 찾습니다 . 찾을 수 없으면 &lt;code&gt;/dev/mixer&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="124de94624e9d6235daba0288398e8d0eda77911" translate="yes" xml:space="preserve">
          <source>Open a new pseudo-terminal pair, using &lt;a href=&quot;os#os.openpty&quot;&gt;&lt;code&gt;os.openpty()&lt;/code&gt;&lt;/a&gt; if possible, or emulation code for generic Unix systems. Return a pair of file descriptors &lt;code&gt;(master, slave)&lt;/code&gt;, for the master and the slave end, respectively.</source>
          <target state="translated">가능한 경우 &lt;a href=&quot;os#os.openpty&quot;&gt; &lt;code&gt;os.openpty()&lt;/code&gt; &lt;/a&gt; 또는 일반 Unix 시스템의 에뮬레이션 코드를 사용하여 새로운 의사 터미널 쌍을 엽니 다 . 마스터 및 슬레이브 엔드에 대해 한 쌍의 파일 디스크립터 &lt;code&gt;(master, slave)&lt;/code&gt; 를 각각 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0f92982986d32cddede6d079b18b515667e6c40" translate="yes" xml:space="preserve">
          <source>Open a new pseudo-terminal pair. Return a pair of file descriptors &lt;code&gt;(master, slave)&lt;/code&gt; for the pty and the tty, respectively. The new file descriptors are &lt;a href=&quot;#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;. For a (slightly) more portable approach, use the &lt;a href=&quot;pty#module-pty&quot;&gt;&lt;code&gt;pty&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">새로운 의사 터미널 쌍을 엽니 다. pty 및 tty에 대한 파일 디스크립터 &lt;code&gt;(master, slave)&lt;/code&gt; 쌍을 각각 리턴하십시오 . 새로운 파일 기술자는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; . 좀 더 휴대하기 편리한 방법으로 &lt;a href=&quot;pty#module-pty&quot;&gt; &lt;code&gt;pty&lt;/code&gt; &lt;/a&gt; 모듈을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="310ce69a8bca050de2aaf114ea01dff137cc8b62" translate="yes" xml:space="preserve">
          <source>Open a pane at the top of the edit window which shows the block context of the code which has scrolled above the top of the window. See &lt;a href=&quot;#code-context&quot;&gt;Code Context&lt;/a&gt; in the Editing and Navigation section below.</source>
          <target state="translated">창의 상단 위로 스크롤 된 코드의 블록 컨텍스트를 표시하는 편집 창의 상단에서 분할 창을여십시오. 아래의 편집 및 탐색 섹션에서 &lt;a href=&quot;#code-context&quot;&gt;코드 컨텍스트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="961144629087d810690a8c197d9838fead119d99" translate="yes" xml:space="preserve">
          <source>Open a persistent dictionary. The filename specified is the base filename for the underlying database. As a side-effect, an extension may be added to the filename and more than one file may be created. By default, the underlying database file is opened for reading and writing. The optional &lt;em&gt;flag&lt;/em&gt; parameter has the same interpretation as the &lt;em&gt;flag&lt;/em&gt; parameter of &lt;a href=&quot;dbm#dbm.open&quot;&gt;&lt;code&gt;dbm.open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">영구 사전을 엽니 다. 지정된 파일 이름은 기본 데이터베이스의 기본 파일 이름입니다. 부작용으로 확장명이 파일 이름에 추가되고 둘 이상의 파일이 생성 될 수 있습니다. 기본적으로 기본 데이터베이스 파일은 읽고 쓰기 위해 열립니다. 선택적 &lt;em&gt;플래그&lt;/em&gt; 매개 변수는 &lt;a href=&quot;dbm#dbm.open&quot;&gt; &lt;code&gt;dbm.open()&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;플래그&lt;/em&gt; 매개 변수 와 동일한 해석 을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="e30bcb19f1f39f996dce7f6ad300b894ce70b960" translate="yes" xml:space="preserve">
          <source>Open a pipe to or from command &lt;em&gt;cmd&lt;/em&gt;. The return value is an open file object connected to the pipe, which can be read or written depending on whether &lt;em&gt;mode&lt;/em&gt; is &lt;code&gt;'r'&lt;/code&gt; (default) or &lt;code&gt;'w'&lt;/code&gt;. The &lt;em&gt;buffering&lt;/em&gt; argument has the same meaning as the corresponding argument to the built-in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function. The returned file object reads or writes text strings rather than bytes.</source>
          <target state="translated">&lt;em&gt;cmd&lt;/em&gt; 명령으로 또는 파이프에서 파이프를여십시오 . 리턴 값은 파이프에 연결된 열린 파일 오브젝트 이며 &lt;em&gt;mode&lt;/em&gt; 가 &lt;code&gt;'r'&lt;/code&gt; (기본값) 또는 &lt;code&gt;'w'&lt;/code&gt; 인지에 따라 읽거나 쓸 수 있습니다 . &lt;em&gt;버퍼링&lt;/em&gt; 인수는 내장에 대응하는 인수와 같은 의미가 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수. 반환 된 파일 객체는 바이트가 아닌 텍스트 문자열을 읽거나 씁니다.</target>
        </trans-unit>
        <trans-unit id="8c5fd40c145ccacef9428c87b2f9836894576731" translate="yes" xml:space="preserve">
          <source>Open a scrollable list allowing selection of existing names. See &lt;a href=&quot;#completions&quot;&gt;Completions&lt;/a&gt; in the Editing and navigation section below.</source>
          <target state="translated">기존 이름을 선택할 수있는 스크롤 가능한 목록을 엽니 다. 아래의 편집 및 탐색 섹션에서 &lt;a href=&quot;#completions&quot;&gt;완료&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4303f9f37906dec81588a51089c928e75e68e4f" translate="yes" xml:space="preserve">
          <source>Open a scrollable list allowing selection of keywords and attributes. See &lt;a href=&quot;#completions&quot;&gt;Completions&lt;/a&gt; in the Editing and navigation section below.</source>
          <target state="translated">키워드 및 속성을 선택할 수있는 스크롤 가능 목록을 엽니 다. 아래의 편집 및 탐색 섹션에서 &lt;a href=&quot;#completions&quot;&gt;완료&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4217d0cef98e970f4e763e2abdcb21e0e9dba748" translate="yes" xml:space="preserve">
          <source>Open a search dialog with many options</source>
          <target state="translated">많은 옵션으로 검색 대화 상자를 엽니 다</target>
        </trans-unit>
        <trans-unit id="7d488b8ee4c8ad111ad3e0840a8cf0d33d625078" translate="yes" xml:space="preserve">
          <source>Open a search-and-replace dialog.</source>
          <target state="translated">찾기 및 바꾸기 대화 상자를여십시오.</target>
        </trans-unit>
        <trans-unit id="ff5f177e11975357dd6078d245cc9e65ff7d469c" translate="yes" xml:space="preserve">
          <source>Open a streaming transport connection to a given address specified by &lt;em&gt;host&lt;/em&gt; and &lt;em&gt;port&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;host&lt;/em&gt; 및 &lt;em&gt;port로&lt;/em&gt; 지정된 지정된 주소로 스트리밍 전송 연결을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="1744e1544566dcdbef4e0123916bae4c8ecaef7a" translate="yes" xml:space="preserve">
          <source>Open an AIFF or AIFF-C file and return an object instance with methods that are described below. The argument &lt;em&gt;file&lt;/em&gt; is either a string naming a file or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. &lt;em&gt;mode&lt;/em&gt; must be &lt;code&gt;'r'&lt;/code&gt; or &lt;code&gt;'rb'&lt;/code&gt; when the file must be opened for reading, or &lt;code&gt;'w'&lt;/code&gt; or &lt;code&gt;'wb'&lt;/code&gt; when the file must be opened for writing. If omitted, &lt;code&gt;file.mode&lt;/code&gt; is used if it exists, otherwise &lt;code&gt;'rb'&lt;/code&gt; is used. When used for writing, the file object should be seekable, unless you know ahead of time how many samples you are going to write in total and use &lt;code&gt;writeframesraw()&lt;/code&gt; and &lt;code&gt;setnframes()&lt;/code&gt;. The &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function may be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When the &lt;code&gt;with&lt;/code&gt; block completes, the &lt;a href=&quot;#aifc.aifc.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">AIFF 또는 AIFF-C 파일을 열고 아래 설명 된 방법으로 객체 인스턴스를 반환하십시오. 인수 &lt;em&gt;파일&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 이름을 지정하는 문자열이거나 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. 읽기 위해 파일을 열어야하는 경우 &lt;em&gt;mode&lt;/em&gt; 는 &lt;code&gt;'r'&lt;/code&gt; 또는 &lt;code&gt;'rb'&lt;/code&gt; 이거나 파일을 쓰기 위해 열어야하는 경우 &lt;code&gt;'w'&lt;/code&gt; 또는 &lt;code&gt;'wb'&lt;/code&gt; 여야합니다. 생략하면, &lt;code&gt;file.mode&lt;/code&gt; 가 있으면 사용되며 그렇지 않으면 &lt;code&gt;'rb'&lt;/code&gt; 가 사용됩니다. 쓰기에 사용될 때 총 몇 개의 샘플을 &lt;code&gt;writeframesraw()&lt;/code&gt; 미리 알고 writeframesraw () 및 &lt;code&gt;setnframes()&lt;/code&gt; 사용하지 않으면 파일 객체를 찾을 수 있어야합니다 . 그만큼&lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; ()&lt;/a&gt; 문에서 open () 함수를 사용할 수 있습니다. 경우 &lt;code&gt;with&lt;/code&gt; 블록 완료의&lt;a href=&quot;#aifc.aifc.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출된다.</target>
        </trans-unit>
        <trans-unit id="ddf92b972ba5b44c47eb08af4356977d6224354c" translate="yes" xml:space="preserve">
          <source>Open an AIFF or AIFF-C file and return an object instance with methods that are described below. The argument &lt;em&gt;file&lt;/em&gt; is either a string naming a file or a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. &lt;em&gt;mode&lt;/em&gt; must be &lt;code&gt;'r'&lt;/code&gt; or &lt;code&gt;'rb'&lt;/code&gt; when the file must be opened for reading, or &lt;code&gt;'w'&lt;/code&gt; or &lt;code&gt;'wb'&lt;/code&gt; when the file must be opened for writing. If omitted, &lt;code&gt;file.mode&lt;/code&gt; is used if it exists, otherwise &lt;code&gt;'rb'&lt;/code&gt; is used. When used for writing, the file object should be seekable, unless you know ahead of time how many samples you are going to write in total and use &lt;code&gt;writeframesraw()&lt;/code&gt; and &lt;code&gt;setnframes()&lt;/code&gt;. The &lt;a href=&quot;#aifc.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function may be used in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When the &lt;code&gt;with&lt;/code&gt; block completes, the &lt;a href=&quot;#aifc.aifc.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">AIFF 또는 AIFF-C 파일을 열고 아래에 설명 된 메서드를 사용하여 개체 인스턴스를 반환합니다. 인수 &lt;em&gt;파일&lt;/em&gt; 은 &lt;em&gt;파일&lt;/em&gt; 이름을 지정하는 문자열이거나 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. &lt;em&gt;mode&lt;/em&gt; 는 읽기 위해 파일을 열어야하는 경우 &lt;code&gt;'r'&lt;/code&gt; 또는 &lt;code&gt;'rb'&lt;/code&gt; , 쓰기를 위해 파일을 열어야하는 경우 &lt;code&gt;'w'&lt;/code&gt; 또는 &lt;code&gt;'wb'&lt;/code&gt; 여야합니다. 생략하면 &lt;code&gt;file.mode&lt;/code&gt; 가 있으면 사용하고, 그렇지 않으면 &lt;code&gt;'rb'&lt;/code&gt; 를 사용합니다. 쓰기에 사용될 때 총 샘플 수를 미리 알고 &lt;code&gt;writeframesraw()&lt;/code&gt; 및 &lt;code&gt;setnframes()&lt;/code&gt; 사용하지 않는 한 파일 객체는 검색 가능해야합니다 . 그만큼&lt;a href=&quot;#aifc.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수는&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에서 사용할 수 있습니다. 경우 &lt;code&gt;with&lt;/code&gt; 블록 완료의&lt;a href=&quot;#aifc.aifc.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출된다.</target>
        </trans-unit>
        <trans-unit id="c826d14c450bf65432c928fcd0ab030434d46051" translate="yes" xml:space="preserve">
          <source>Open an LZMA-compressed file in binary mode.</source>
          <target state="translated">이진 모드에서 LZMA 압축 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e1faabe747c63d77a2b349aef83e34f029746298" translate="yes" xml:space="preserve">
          <source>Open an LZMA-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">이진 또는 텍스트 모드에서 LZMA 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="3dc1a2e7448af77fafeaad4b56b7249fb522823e" translate="yes" xml:space="preserve">
          <source>Open an LZMA-compressed file in binary or text mode, returning a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">바이너리 또는 텍스트 모드에서 LZMA 압축 파일을 열고 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="63c9941ee4cb89d2d889eb4b86133c79f4dbfe23" translate="yes" xml:space="preserve">
          <source>Open an audio device and return an OSS audio device object. This object supports many file-like methods, such as &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, and &lt;code&gt;fileno()&lt;/code&gt; (although there are subtle differences between conventional Unix read/write semantics and those of OSS audio devices). It also supports a number of audio-specific methods; see below for the complete list of methods.</source>
          <target state="translated">오디오 장치를 열고 OSS 오디오 장치 개체를 반환하십시오. 이 객체는 &lt;code&gt;read()&lt;/code&gt; , &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;fileno()&lt;/code&gt; 와 같은 많은 파일과 유사한 메소드를 지원합니다 ( 기존의 Unix 읽기 / 쓰기 시맨틱과 OSS 오디오 장치의 미묘한 차이가 있지만). 또한 여러 가지 오디오 관련 방법을 지원합니다. 전체 방법 목록은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="603bc2bb14d64c97ed149bdeb1f454a0cdee6bdf" translate="yes" xml:space="preserve">
          <source>Open an encoded file using the given &lt;em&gt;mode&lt;/em&gt; and return an instance of &lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt;&lt;code&gt;StreamReaderWriter&lt;/code&gt;&lt;/a&gt;, providing transparent encoding/decoding. The default file mode is &lt;code&gt;'r'&lt;/code&gt;, meaning to open the file in read mode.</source>
          <target state="translated">주어진 &lt;em&gt;모드를&lt;/em&gt; 사용하여 인코딩 된 파일을 열고 투명한 인코딩 / 디코딩을 제공하는 &lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt; &lt;code&gt;StreamReaderWriter&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환합니다 . 기본 파일 모드는 &lt;code&gt;'r'&lt;/code&gt; 이며 파일을 읽기 모드로 여는 것입니다.</target>
        </trans-unit>
        <trans-unit id="70e42698ff3f06e64e68df6dd8b37bb0b559281d" translate="yes" xml:space="preserve">
          <source>Open an existing file with an Open dialog.</source>
          <target state="translated">열기 대화 상자로 기존 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="d98d15f410a1d6752590d2b11440fb75fb110d32" translate="yes" xml:space="preserve">
          <source>Open an existing module (searches sys.path).</source>
          <target state="translated">기존 모듈을 엽니 다 (sys.path 검색).</target>
        </trans-unit>
        <trans-unit id="0ee43539d00f6f0549ec54060b1769296318ac88" translate="yes" xml:space="preserve">
          <source>Open an lzma compressed &lt;em&gt;stream&lt;/em&gt; for reading.</source>
          <target state="translated">읽을 lzma 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="31602b490a7a64e6c2db5f868743fe69a5882ae0" translate="yes" xml:space="preserve">
          <source>Open an lzma compressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">쓰기 위해 lzma 압축 &lt;em&gt;스트림&lt;/em&gt; 을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="079b069912678bc0e9edc918427fbb1c6c90a22d" translate="yes" xml:space="preserve">
          <source>Open an uncompressed &lt;em&gt;stream&lt;/em&gt; for writing.</source>
          <target state="translated">비 압축 &lt;em&gt;스트림&lt;/em&gt; 을 작성 하여 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="98a6f72f0f8ba4690a7074b4a4a5e9ed2745f83c" translate="yes" xml:space="preserve">
          <source>Open data URLs.</source>
          <target state="translated">열린 데이터 URL.</target>
        </trans-unit>
        <trans-unit id="16d266be663a4baf112aaf41a72a96cf96f3a372" translate="yes" xml:space="preserve">
          <source>Open database for reading and writing, creating it if it doesn&amp;rsquo;t exist</source>
          <target state="translated">읽기 및 쓰기를위한 데이터베이스를 열고 존재하지 않는 경우 생성</target>
        </trans-unit>
        <trans-unit id="781766b35fa1fffb57637176b0ab6b1592f6edda" translate="yes" xml:space="preserve">
          <source>Open existing database for reading and writing</source>
          <target state="translated">읽고 쓰는 기존 데이터베이스 열기</target>
        </trans-unit>
        <trans-unit id="410e2a4489d3a436b0413ceb110aca00b9d836e3" translate="yes" xml:space="preserve">
          <source>Open existing database for reading only (default)</source>
          <target state="translated">읽기 전용으로 기존 데이터베이스 열기 (기본값)</target>
        </trans-unit>
        <trans-unit id="da8803e86851bcbc32ed1a652aec62b5acaa7e27" translate="yes" xml:space="preserve">
          <source>Open for appending with no compression. The file is created if it does not exist.</source>
          <target state="translated">압축없이 추가하기 위해 엽니 다. 파일이 없으면 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="a92945eaf20e290447e2fee4702651291e88a7a8" translate="yes" xml:space="preserve">
          <source>Open for binary reading the &lt;em&gt;resource&lt;/em&gt; within &lt;em&gt;package&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;패키지&lt;/em&gt; 내의 &lt;em&gt;리소스&lt;/em&gt; 를 바이너리로 읽을 수 있도록 엽니 다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3d7a0fda614e078919dfeee281a77c3029b4cd8d" translate="yes" xml:space="preserve">
          <source>Open for bzip2 compressed writing.</source>
          <target state="translated">bzip2 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="3be0b1cac4b854897b77bfa1ac3644fca43d5aa8" translate="yes" xml:space="preserve">
          <source>Open for gzip compressed writing.</source>
          <target state="translated">gzip 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e4536676ca1a607495256d83de74122a14e9f319" translate="yes" xml:space="preserve">
          <source>Open for lzma compressed writing.</source>
          <target state="translated">lzma 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e39a5b6a548b20c25318d8a7703ff10916012921" translate="yes" xml:space="preserve">
          <source>Open for reading exclusively without compression.</source>
          <target state="translated">압축하지 않고 읽기 전용으로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="5d2a4b3378fdbc3be17d246022eb416831821745" translate="yes" xml:space="preserve">
          <source>Open for reading with bzip2 compression.</source>
          <target state="translated">bzip2 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e27915e983e4971e83b72733d9272da24ed3062a" translate="yes" xml:space="preserve">
          <source>Open for reading with gzip compression.</source>
          <target state="translated">gzip 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2da82d3e5ef9f2ef062573cb554660a3c136498f" translate="yes" xml:space="preserve">
          <source>Open for reading with lzma compression.</source>
          <target state="translated">lzma 압축으로 읽기 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="e3a348820cc41064f1578562b070372b25c805da" translate="yes" xml:space="preserve">
          <source>Open for reading with transparent compression (recommended).</source>
          <target state="translated">투명한 압축으로 읽기 위해 엽니 다 (권장).</target>
        </trans-unit>
        <trans-unit id="72bd4d78cdd6d40e6b66c653af1f6efc9092b2a0" translate="yes" xml:space="preserve">
          <source>Open for text reading the &lt;em&gt;resource&lt;/em&gt; within &lt;em&gt;package&lt;/em&gt;. By default, the resource is opened for reading as UTF-8.</source>
          <target state="translated">&lt;em&gt;패키지&lt;/em&gt; 내 에서 &lt;em&gt;리소스를&lt;/em&gt; 읽는 텍스트를 열려면 엽니 다 . 기본적으로 리소스는 UTF-8로 읽을 수 있도록 열립니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5fbd33d2eb6cd4b2ececd950d2a289a68364e3b2" translate="yes" xml:space="preserve">
          <source>Open for uncompressed writing.</source>
          <target state="translated">비 압축 쓰기를 위해 엽니 다.</target>
        </trans-unit>
        <trans-unit id="2d5629e9c9ad86de82f582a75bd5aac184a32a98" translate="yes" xml:space="preserve">
          <source>Open local files.</source>
          <target state="translated">로컬 파일을여십시오.</target>
        </trans-unit>
        <trans-unit id="c31d0d8dc1af57114456f8a6995200302c826647" translate="yes" xml:space="preserve">
          <source>Open or wake up the Python Shell window.</source>
          <target state="translated">Python Shell 창을 열거 나 깨 웁니다.</target>
        </trans-unit>
        <trans-unit id="64e54bad7370d9dd3ea7ce90f39c116822954b3f" translate="yes" xml:space="preserve">
          <source>Open the FTP file indicated by &lt;em&gt;req&lt;/em&gt;. The login is always done with empty username and password.</source>
          <target state="translated">&lt;em&gt;req로&lt;/em&gt; 표시된 FTP 파일을여십시오 . 로그인은 항상 빈 사용자 이름과 비밀번호로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf0ac9893ebd85b77099d4a402423ddf3e569c0" translate="yes" xml:space="preserve">
          <source>Open the URL &lt;em&gt;url&lt;/em&gt;, which can be either a string or a &lt;a href=&quot;#urllib.request.Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">문자열 또는 &lt;a href=&quot;#urllib.request.Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; 객체 일 수있는 URL &lt;em&gt;url을&lt;/em&gt; 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="a2f57839feb75512fa819cec149b3ca923d075ec" translate="yes" xml:space="preserve">
          <source>Open the database file &lt;em&gt;file&lt;/em&gt; and return a corresponding object.</source>
          <target state="translated">데이터베이스 파일 &lt;em&gt;파일을&lt;/em&gt; 열고 해당 오브젝트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9778684242145c7e5980545da5305f1a835b31fd" translate="yes" xml:space="preserve">
          <source>Open the database in fast mode. Writes to the database will not be synchronized.</source>
          <target state="translated">데이터베이스를 빠른 모드로 엽니 다. 데이터베이스에 대한 쓰기는 동기화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0dc0480d0f4224d0fb02e5967e073c791476447a" translate="yes" xml:space="preserve">
          <source>Open the file &lt;em&gt;path&lt;/em&gt; and set various flags according to &lt;em&gt;flags&lt;/em&gt; and possibly its mode according to &lt;em&gt;mode&lt;/em&gt;. When computing &lt;em&gt;mode&lt;/em&gt;, the current umask value is first masked out. Return the file descriptor for the newly opened file. The new file descriptor is &lt;a href=&quot;#fd-inheritance&quot;&gt;non-inheritable&lt;/a&gt;.</source>
          <target state="translated">파일 열기 &lt;em&gt;경로&lt;/em&gt; 에 따라 설정하고 다양한 플래그 &lt;em&gt;플래그&lt;/em&gt; 와 가능성의 모드에 따라 &lt;em&gt;모드&lt;/em&gt; . 컴퓨팅 &lt;em&gt;모드&lt;/em&gt; 에서는 현재 umask 값이 먼저 마스킹됩니다. 새로 열린 파일의 파일 설명자를 반환합니다. 새로운 파일 기술자는 &lt;a href=&quot;#fd-inheritance&quot;&gt;상속 할 수 없습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="caa52afce9506061d0fa4472348c0e95be91ed41" translate="yes" xml:space="preserve">
          <source>Open the file locally, if there is no host name, or the host name is &lt;code&gt;'localhost'&lt;/code&gt;.</source>
          <target state="translated">호스트 이름이 없거나 호스트 이름이 &lt;code&gt;'localhost'&lt;/code&gt; 인 경우 파일을 로컬로여십시오 .</target>
        </trans-unit>
        <trans-unit id="cfc513f94813f282c3c61b3a5c7b58c27fabbaa9" translate="yes" xml:space="preserve">
          <source>Open the file pointed to by the path, like the built-in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function does:</source>
          <target state="translated">내장 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수 처럼 경로가 가리키는 파일을 엽니 다 .</target>
        </trans-unit>
        <trans-unit id="5eba403538351b5c16610a19c57e8a8df88568dc" translate="yes" xml:space="preserve">
          <source>Open the file pointed to in bytes mode, write &lt;em&gt;data&lt;/em&gt; to it, and close the file:</source>
          <target state="translated">바이트 모드로 지정된 파일을 열고 &lt;em&gt;데이터&lt;/em&gt; 를 쓴 다음 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="e701b16e8d36cd75f1fa0285568b0411ec651724" translate="yes" xml:space="preserve">
          <source>Open the file pointed to in text mode, write &lt;em&gt;data&lt;/em&gt; to it, and close the file:</source>
          <target state="translated">텍스트 모드에서 지정된 파일을 열고 &lt;em&gt;데이터&lt;/em&gt; 를 쓴 다음 파일을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="89b97b71d7fce960991c7dd1c07e2cdaec524088" translate="yes" xml:space="preserve">
          <source>Open the given &lt;em&gt;url&lt;/em&gt; (which can be a request object or a string), optionally passing the given &lt;em&gt;data&lt;/em&gt;. Arguments, return values and exceptions raised are the same as those of &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; (which simply calls the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; method on the currently installed global &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt;). The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for blocking operations like the connection attempt (if not specified, the global default timeout setting will be used). The timeout feature actually works only for HTTP, HTTPS and FTP connections).</source>
          <target state="translated">주어진 &lt;em&gt;url&lt;/em&gt; (요청 객체 또는 문자열 일 수 있음)을 열고 선택적으로 주어진 &lt;em&gt;data를&lt;/em&gt; 전달합니다 . 인수, 리턴 값 및 예외는 &lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 과 동일 합니다 (현재 설치된 글로벌 &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 메소드를 호출 함 ). 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도와 같은 작업을 차단하기위한 시간 초과를 초 단위로 지정합니다 (지정하지 않으면 전역 기본 시간 초과 설정이 사용됨). 시간 초과 기능은 실제로 HTTP, HTTPS 및 FTP 연결에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5e1480c8605ef5bc7bd341fc4f6753a37e43a4d4" translate="yes" xml:space="preserve">
          <source>Open&amp;hellip;</source>
          <target state="translated">Open&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="01d60b1917be3088476a0cd4e28b367766a98677" translate="yes" xml:space="preserve">
          <source>OpenEXR Files</source>
          <target state="translated">OpenEXR 파일</target>
        </trans-unit>
        <trans-unit id="73728b14af6a4a2f3551f7cdac9f5c4d6228013b" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.0 to 1.1.0e will abort the handshake and raise &lt;a href=&quot;#ssl.SSLError&quot;&gt;&lt;code&gt;SSLError&lt;/code&gt;&lt;/a&gt; when both sides support ALPN but cannot agree on a protocol. 1.1.0f+ behaves like 1.0.2, &lt;a href=&quot;#ssl.SSLSocket.selected_alpn_protocol&quot;&gt;&lt;code&gt;SSLSocket.selected_alpn_protocol()&lt;/code&gt;&lt;/a&gt; returns None.</source>
          <target state="translated">OpenSSL 1.1.0-1.1.0e는 양측이 ALPN을 지원하지만 프로토콜에 동의 할 수없는 경우 핸드 셰이크를 중단하고 &lt;a href=&quot;#ssl.SSLError&quot;&gt; &lt;code&gt;SSLError&lt;/code&gt; 를&lt;/a&gt; 발생시킵니다. 1.1.0f +는 1.0.2처럼 동작하며 &lt;a href=&quot;#ssl.SSLSocket.selected_alpn_protocol&quot;&gt; &lt;code&gt;SSLSocket.selected_alpn_protocol()&lt;/code&gt; &lt;/a&gt; 은 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="608031ed74d99bf56acad6cfae3a559becd3fe58" translate="yes" xml:space="preserve">
          <source>OpenSSL 1.1.1 has TLS 1.3 cipher suites enabled by default. The suites cannot be disabled with &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;set_ciphers()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">OpenSSL 1.1.1에는 기본적으로 TLS 1.3 암호화 제품군이 활성화되어 있습니다. 스위트는 &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;set_ciphers()&lt;/code&gt; &lt;/a&gt; 로 비활성화 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="87910396f08c825fecd3572b61ad32564c05b34d" translate="yes" xml:space="preserve">
          <source>OpenerDirector Objects</source>
          <target state="translated">OpenerDirector 개체</target>
        </trans-unit>
        <trans-unit id="4fa7faa0fef5cd2e070617de5da06be08f27d93b" translate="yes" xml:space="preserve">
          <source>OpenerDirector objects open URLs in three stages:</source>
          <target state="translated">OpenerDirector 개체는 3 단계로 URL을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="16d066a3fc9b4ed5f9b17e3224ef371f27c42ab1" translate="yes" xml:space="preserve">
          <source>Opening a file:</source>
          <target state="translated">파일 열기 :</target>
        </trans-unit>
        <trans-unit id="3b13dba20249cec4bebcc1e50c72c68162719b5f" translate="yes" xml:space="preserve">
          <source>Opening network connections</source>
          <target state="translated">네트워크 연결 열기</target>
        </trans-unit>
        <trans-unit id="2e4955dc64b4b6a99ad04615254b1e5dbed12175" translate="yes" xml:space="preserve">
          <source>Opens a connection to the SQLite database file &lt;em&gt;database&lt;/em&gt;. By default returns a &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; object, unless a custom &lt;em&gt;factory&lt;/em&gt; is given.</source>
          <target state="translated">SQLite 데이터베이스 파일 &lt;em&gt;데이터베이스에&lt;/em&gt; 대한 연결을 엽니 다 . 사용자 정의 &lt;em&gt;팩토리&lt;/em&gt; 가 제공 되지 않은 경우 기본적으로 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 객체가 반환 됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="85224a398354ea36e289250e0f429ab80eb410a3" translate="yes" xml:space="preserve">
          <source>Opens a new element. &lt;em&gt;tag&lt;/em&gt; is the element name. &lt;em&gt;attrs&lt;/em&gt; is a dictionary containing element attributes. Returns the opened element.</source>
          <target state="translated">새로운 요소를 엽니 다. &lt;em&gt;태그&lt;/em&gt; 는 요소 이름입니다. &lt;em&gt;attrs&lt;/em&gt; 는 요소 속성을 포함하는 사전입니다. 열린 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5552ba1b994865292838a17cccf8d2f7dbeb693a" translate="yes" xml:space="preserve">
          <source>Opens socket to &lt;em&gt;port&lt;/em&gt; at &lt;em&gt;host&lt;/em&gt;. The optional &lt;em&gt;timeout&lt;/em&gt; parameter specifies a timeout in seconds for the connection attempt. If timeout is not given or is None, the global default socket timeout is used. Also note that if the &lt;em&gt;timeout&lt;/em&gt; parameter is set to be zero, it will raise a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; to reject creating a non-blocking socket. This method is implicitly called by the &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; constructor. The connection objects established by this method will be used in the &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt;&lt;code&gt;IMAP4.read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt;&lt;code&gt;IMAP4.readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt;&lt;code&gt;IMAP4.send()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt;&lt;code&gt;IMAP4.shutdown()&lt;/code&gt;&lt;/a&gt; methods. You may override this method.</source>
          <target state="translated">&lt;em&gt;호스트의 &lt;/em&gt;&lt;em&gt;포트&lt;/em&gt; 에 소켓을 엽니 다 . 선택적 &lt;em&gt;timeout&lt;/em&gt; 매개 변수는 연결 시도에 대한 제한 시간 (초)을 지정합니다. 제한 시간이 지정되지 않았거나 없음 인 경우 전역 기본 소켓 제한 시간이 사용됩니다. 또한 &lt;em&gt;timeout&lt;/em&gt; 매개 변수가 0으로 설정 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 비 블로킹 소켓 생성을 거부하기 위해 ValueError 가 발생합니다. 이 메서드는 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 생성자에 의해 암시 적으로 호출됩니다 . 이 메서드에 의해 설정된 연결 개체는 &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt; &lt;code&gt;IMAP4.read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt; &lt;code&gt;IMAP4.readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt; &lt;code&gt;IMAP4.send()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt; &lt;code&gt;IMAP4.shutdown()&lt;/code&gt; &lt;/a&gt; 메서드에서 사용됩니다. 이 메서드를 재정의 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aabf2727e8cb0ec31b954ad851960d268b7966e2" translate="yes" xml:space="preserve">
          <source>Opens socket to &lt;em&gt;port&lt;/em&gt; at &lt;em&gt;host&lt;/em&gt;. This method is implicitly called by the &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; constructor. The connection objects established by this method will be used in the &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt;&lt;code&gt;IMAP4.read()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt;&lt;code&gt;IMAP4.readline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt;&lt;code&gt;IMAP4.send()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt;&lt;code&gt;IMAP4.shutdown()&lt;/code&gt;&lt;/a&gt; methods. You may override this method.</source>
          <target state="translated">&lt;em&gt;호스트&lt;/em&gt; 에서 &lt;em&gt;포트&lt;/em&gt; 로 소켓을 엽니 다 . 이 메소드는 &lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; &lt;/a&gt; 생성자에 의해 내재적으로 호출됩니다 . 이 메소드로 설정된 연결 오브젝트는 &lt;a href=&quot;#imaplib.IMAP4.read&quot;&gt; &lt;code&gt;IMAP4.read()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.readline&quot;&gt; &lt;code&gt;IMAP4.readline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#imaplib.IMAP4.send&quot;&gt; &lt;code&gt;IMAP4.send()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#imaplib.IMAP4.shutdown&quot;&gt; &lt;code&gt;IMAP4.shutdown()&lt;/code&gt; &lt;/a&gt; 메소드에서 사용됩니다. 이 방법을 무시할 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="525d07220d0ff4234fa0ad51dedfb34d53d57012" translate="yes" xml:space="preserve">
          <source>Opens the provided file with mode &lt;code&gt;'rb'&lt;/code&gt;. This function should be used when the intent is to treat the contents as executable code.</source>
          <target state="translated">제공된 파일을 &lt;code&gt;'rb'&lt;/code&gt; 모드로 엽니 다 . 이 기능은 내용을 실행 코드로 취급하려는 경우에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="413464a07680bc80891d442ceee2443c353ed2dd" translate="yes" xml:space="preserve">
          <source>Opens the specified key, returning a &lt;a href=&quot;#handle-object&quot;&gt;handle object&lt;/a&gt;.</source>
          <target state="translated">지정된 키를 열고 &lt;a href=&quot;#handle-object&quot;&gt;핸들 객체를&lt;/a&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="e5ba86326755952233b0543acced2995e5faf457" translate="yes" xml:space="preserve">
          <source>Operating System</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="8c04dd154019c144217096dfd3976827b05133f0" translate="yes" xml:space="preserve">
          <source>Operating system interfaces, including functions to work with files at a lower level than Python &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;.</source>
          <target state="translated">파이썬보다 낮은 수준의 파일 작업에 대한 기능을 포함한 시스템 인터페이스, 운영 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5fc87b7e16c60d713e7c730fe487c543126364e8" translate="yes" xml:space="preserve">
          <source>Operating system interfaces, including functions to work with files at a lower level than Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file objects&lt;/a&gt;.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 보다 낮은 수준에서 파일 작업을 수행하는 함수를 포함한 운영 체제 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="430d32076eb256f0fb1db5fd1333254c368ef1ba" translate="yes" xml:space="preserve">
          <source>Operation</source>
          <target state="translated">Operation</target>
        </trans-unit>
        <trans-unit id="0fc51a5c314382c855158eda38ff5409a7e69535" translate="yes" xml:space="preserve">
          <source>Operation already in progress</source>
          <target state="translated">이미 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="25ef925607b43bca64c3829868d9989b76540d3a" translate="yes" xml:space="preserve">
          <source>Operation not permitted</source>
          <target state="translated">작동이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="43a0d8034edc13c8132ddaa1b799ae87a6565b50" translate="yes" xml:space="preserve">
          <source>Operation not supported on transport endpoint</source>
          <target state="translated">전송 끝점에서 지원되지 않는 작업</target>
        </trans-unit>
        <trans-unit id="8fdc938d87d0b18a567701392c335d0c883fa4b7" translate="yes" xml:space="preserve">
          <source>Operation now in progress</source>
          <target state="translated">현재 진행중인 작업</target>
        </trans-unit>
        <trans-unit id="db648ff618df972b87b0f378a6996fcda48575ee" translate="yes" xml:space="preserve">
          <source>Operation would block</source>
          <target state="translated">작업 차단</target>
        </trans-unit>
        <trans-unit id="3f36c3736abf81762323dd82f7d22a61738746fb" translate="yes" xml:space="preserve">
          <source>Operations and built-in functions that have a Boolean result always return &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt; for false and &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;True&lt;/code&gt; for true, unless otherwise stated. (Important exception: the Boolean operations &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt; always return one of their operands.)</source>
          <target state="translated">부울 결과가있는 연산 및 내장 함수는 달리 명시되지 않는 한 항상 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 를 false로, &lt;code&gt;1&lt;/code&gt; 을 true 또는 &lt;code&gt;True&lt;/code&gt; 를 반환합니다. (중요 예외 : 부울 작업 &lt;code&gt;or&lt;/code&gt; 하고 &lt;code&gt;and&lt;/code&gt; 항상 피연산자 중 하나를 반환합니다.)</target>
        </trans-unit>
        <trans-unit id="b0a2a652140b72b9707efca49f6096fb106713ee" translate="yes" xml:space="preserve">
          <source>Operations are used as methods. Since the DOM uses only &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; parameters, the arguments are passed in normal order (from left to right). There are no optional arguments. &lt;code&gt;void&lt;/code&gt; operations return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">작업은 방법으로 사용됩니다. DOM을만을 사용하므로 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 파라미터 (왼쪽에서 오른쪽)에서, 인수는 정상적인 순서로 전달된다. 선택적 인수가 없습니다. &lt;code&gt;void&lt;/code&gt; 연산은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6d6b35cab74cd4bff853d83e0a100977302a8b95" translate="yes" xml:space="preserve">
          <source>Operations are used as methods. Since the DOM uses only &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; parameters, the arguments are passed in normal order (from left to right). There are no optional arguments. &lt;code&gt;void&lt;/code&gt; operations return &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">작업은 방법으로 사용됩니다. DOM은 &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 매개 변수 만 사용하므로 인수는 정상적인 순서 (왼쪽에서 오른쪽으로)로 전달됩니다. 선택적 인수가 없습니다. &lt;code&gt;void&lt;/code&gt; 작업은 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5842137c602e8b1e20079af1475196379c2bc7a2" translate="yes" xml:space="preserve">
          <source>Operations like &lt;code&gt;+=&lt;/code&gt; which involve a read and write are not atomic. So if, for instance, you want to atomically increment a shared value it is insufficient to just do</source>
          <target state="translated">&lt;code&gt;+=&lt;/code&gt; 와 같은 연산읽기와 쓰기를 포함하는 은 원 자성이 아닙니다. 예를 들어 공유 값을 원자 적으로 증분하려는 경우에는 수행하기에 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f419c43f2273d35c973397ffc8873fd0cff6d1f6" translate="yes" xml:space="preserve">
          <source>Operations which work with sequences (some of them with mappings too) include:</source>
          <target state="translated">시퀀스로 작업하는 작업 (일부 매핑도 해당)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e90414358dbfff0a68e4eb5d68a16978cf197d5a" translate="yes" xml:space="preserve">
          <source>Operators</source>
          <target state="translated">Operators</target>
        </trans-unit>
        <trans-unit id="e31d972229de381b461860014dd710856361917a" translate="yes" xml:space="preserve">
          <source>Option</source>
          <target state="translated">Option</target>
        </trans-unit>
        <trans-unit id="c431496d10314a298eb196699644e449631b5f2f" translate="yes" xml:space="preserve">
          <source>Option Flags</source>
          <target state="translated">옵션 플래그</target>
        </trans-unit>
        <trans-unit id="e495fe30fe845f1d5517bc35c9d0601fa416e0f7" translate="yes" xml:space="preserve">
          <source>Option for &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;. This value indicates that the context may be used to authenticate Web clients (therefore, it will be used to create server-side sockets).</source>
          <target state="translated">&lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 옵션입니다 . 이 값은 컨텍스트가 웹 클라이언트를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 서버 측 소켓을 작성하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="0ed5f390cd43fec0c1a9f5e969163e9713365adc" translate="yes" xml:space="preserve">
          <source>Option for &lt;a href=&quot;#ssl.create_default_context&quot;&gt;&lt;code&gt;create_default_context()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt;&lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt;&lt;/a&gt;. This value indicates that the context may be used to authenticate Web servers (therefore, it will be used to create client-side sockets).</source>
          <target state="translated">&lt;a href=&quot;#ssl.create_default_context&quot;&gt; &lt;code&gt;create_default_context()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.load_default_certs&quot;&gt; &lt;code&gt;SSLContext.load_default_certs()&lt;/code&gt; &lt;/a&gt; 옵션입니다 . 이 값은 컨텍스트가 웹 서버를 인증하는 데 사용될 수 있음을 나타냅니다 (따라서 클라이언트 측 소켓을 작성하는 데 사용됨).</target>
        </trans-unit>
        <trans-unit id="1dc214003b5cc3f6b308d940b627561092a1f7c2" translate="yes" xml:space="preserve">
          <source>Option value syntax</source>
          <target state="translated">옵션 값 구문</target>
        </trans-unit>
        <trans-unit id="0877ad74bf360dfde627563dd4aa4b01f6ce3129" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the audio data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.audio.MIMEAudio&quot;&gt;&lt;code&gt;MIMEAudio&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적인 &lt;em&gt;_encoder&lt;/em&gt; 는 호출 가능한 오디오 기능의 실제 인코딩을 수행하는 호출 가능 (즉, 기능)입니다. 이 콜 &lt;a href=&quot;#email.mime.audio.MIMEAudio&quot;&gt; &lt;code&gt;MIMEAudio&lt;/code&gt; &lt;/a&gt; 은 하나의 인수, 즉 MIMEAudio 인스턴스를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ea5df2800bbbbd80f815acd541243fa31a50750a" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.application.MIMEApplication&quot;&gt;&lt;code&gt;MIMEApplication&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적 &lt;em&gt;_encoder&lt;/em&gt; 는 전송 가능한 데이터의 실제 인코딩을 수행하는 호출 가능 (즉, 함수)입니다. 이 콜 &lt;a href=&quot;#email.mime.application.MIMEApplication&quot;&gt; &lt;code&gt;MIMEApplication&lt;/code&gt; &lt;/a&gt; 은 하나의 인수, 즉 MIMEApplication 인스턴스를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f423d4e8b5e1e91960dd208dab5452be79d71fb8" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_encoder&lt;/em&gt; is a callable (i.e. function) which will perform the actual encoding of the image data for transport. This callable takes one argument, which is the &lt;a href=&quot;#email.mime.image.MIMEImage&quot;&gt;&lt;code&gt;MIMEImage&lt;/code&gt;&lt;/a&gt; instance. It should use &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;get_payload()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt;&lt;code&gt;set_payload()&lt;/code&gt;&lt;/a&gt; to change the payload to encoded form. It should also add any &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; or other headers to the message object as necessary. The default encoding is base64. See the &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt;&lt;code&gt;email.encoders&lt;/code&gt;&lt;/a&gt; module for a list of the built-in encoders.</source>
          <target state="translated">선택적 &lt;em&gt;_encoder&lt;/em&gt; 는 호출 가능한 이미지 데이터의 실제 인코딩을 수행하는 호출 가능 (즉, 함수)입니다. 이 콜 &lt;a href=&quot;#email.mime.image.MIMEImage&quot;&gt; &lt;code&gt;MIMEImage&lt;/code&gt; &lt;/a&gt; 은 MIMEImage 인스턴스 인 하나의 인수를 취 합니다. 페이로드를 인코딩 된 형식으로 변경 하려면 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;get_payload()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.compat32-message#email.message.Message.set_payload&quot;&gt; &lt;code&gt;set_payload()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 필요에 따라 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 또는 기타 헤더를 ​​메시지 객체에 추가해야합니다. 기본 인코딩은 base64입니다. 내장 인코더 목록은 &lt;a href=&quot;email.encoders#module-email.encoders&quot;&gt; &lt;code&gt;email.encoders&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d1640c671992d66aa1ab94530cbf0176f120aa8b" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_mangle_from_&lt;/em&gt; and &lt;em&gt;maxheaderlen&lt;/em&gt; are as with the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; base class.</source>
          <target state="translated">선택적인 &lt;em&gt;_mangle_from_&lt;/em&gt; 및 &lt;em&gt;maxheaderlen&lt;/em&gt; 은 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 기본 클래스 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c135f5214b837e44f2f6460a17880339144023cb" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;_subtype&lt;/em&gt; sets the subtype of the message; it defaults to &lt;em&gt;rfc822&lt;/em&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;_subtype&lt;/em&gt; 은 메시지의 하위 유형을 설정합니다. 기본값은 &lt;em&gt;rfc822입니다.&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="923ac92596f5e0b048764c0544725cb7d8315bfb" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of at least length 2 (additional characters are ignored) which specifies an alternative alphabet for the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters. This allows an application to e.g. generate URL or filesystem safe Base64 strings. The default is &lt;code&gt;None&lt;/code&gt;, for which the standard Base64 alphabet is used.</source>
          <target state="translated">선택적 &lt;em&gt;altchars&lt;/em&gt; 는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자 의 대체 알파벳을 지정하는 최소 길이 2 (추가 문자는 무시 됨) 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야합니다 . 이를 통해 응용 프로그램은 예를 들어 URL 또는 파일 시스템 안전 Base64 문자열을 생성 할 수 있습니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 표준 Base64 알파벳이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76bee86fbcac7650eb452298a6aece94136101d1" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or ASCII string of at least length 2 (additional characters are ignored) which specifies the alternative alphabet used instead of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters.</source>
          <target state="translated">선택적 &lt;em&gt;altchar&lt;/em&gt; 는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 이거나 길이가 2 이상인 ASCII 문자열 (추가 문자는 무시 됨)이어야하며 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자 대신 사용되는 대체 알파벳을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="4fabfb6d04a5ebe03ff438990cb3d85dcdc7ef20" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of at least length 2 (additional characters are ignored) which specifies an alternative alphabet for the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters. This allows an application to e.g. generate URL or filesystem safe Base64 strings. The default is &lt;code&gt;None&lt;/code&gt;, for which the standard Base64 alphabet is used.</source>
          <target state="translated">선택적 &lt;em&gt;altchars&lt;/em&gt; 는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자에 대한 대체 알파벳을 지정하는 최소 길이 2 (추가 문자는 무시 됨) 의 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트 &lt;/a&gt;&lt;em&gt;류류 객체&lt;/em&gt; 여야합니다 . 이를 통해 애플리케이션은 URL 또는 파일 시스템 안전 Base64 문자열을 생성 할 수 있습니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 표준 Base64 알파벳이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="89ced3e3b797c1fa90962aca8b5c19deaa514379" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;altchars&lt;/em&gt; must be a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or ASCII string of at least length 2 (additional characters are ignored) which specifies the alternative alphabet used instead of the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; characters.</source>
          <target state="translated">선택적 &lt;em&gt;altchars&lt;/em&gt; 는 &lt;code&gt;+&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 문자 대신 사용되는 대체 알파벳을 지정하는 최소 길이 2 (추가 문자는 무시 됨)의 ASCII 문자열 또는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="cb4b9921d192cd1a45a6adc8e11889092e96883c" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;boundary&lt;/em&gt; is the multipart boundary string. When &lt;code&gt;None&lt;/code&gt; (the default), the boundary is calculated when needed (for example, when the message is serialized).</source>
          <target state="translated">선택적인 &lt;em&gt;경계&lt;/em&gt; 는 다중 부분 경계 문자열입니다. 때 &lt;code&gt;None&lt;/code&gt; 필요한 경우 (기본값), 경계가 계산되지 않습니다 (예를 들어, 메시지 직렬화 경우).</target>
        </trans-unit>
        <trans-unit id="83df4bdb171cf95d87daaeffb55e269018e15e7e" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;casefold&lt;/em&gt; is a flag specifying whether a lowercase alphabet is acceptable as input. For security purposes, the default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;casefold&lt;/em&gt; 는 소문자 알파벳을 입력으로 사용할 수 있는지 여부를 지정하는 플래그입니다. 보안을 위해 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b3b940d26a790e7ff0f6bc05a182d4d5e74c6dad" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt; is the character set that will be used in the &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoding of the &lt;code&gt;realname&lt;/code&gt; if the &lt;code&gt;realname&lt;/code&gt; contains non-ASCII characters. Can be an instance of &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt;. Defaults to &lt;code&gt;utf-8&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;문자 세트&lt;/em&gt; 는 &lt;code&gt;realname&lt;/code&gt; 에 비 ASCII 문자가 포함 된 경우 &lt;code&gt;realname&lt;/code&gt; 의 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 인코딩에 사용되는 문자 세트입니다 . &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 의 인스턴스 일 수 있습니다 . 기본값은 &lt;code&gt;utf-8&lt;/code&gt; 입니다 입니다.</target>
        </trans-unit>
        <trans-unit id="63ec82a1964cf6c1f24661387a4dc0633c206b42" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt; serves two purposes: it has the same meaning as the &lt;em&gt;charset&lt;/em&gt; argument to the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method. It also sets the default character set for all subsequent &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; calls that omit the &lt;em&gt;charset&lt;/em&gt; argument. If &lt;em&gt;charset&lt;/em&gt; is not provided in the constructor (the default), the &lt;code&gt;us-ascii&lt;/code&gt; character set is used both as &lt;em&gt;s&lt;/em&gt;&amp;rsquo;s initial charset and as the default for subsequent &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; calls.</source>
          <target state="translated">선택적 &lt;em&gt;문자 집합&lt;/em&gt; 은 두 가지 용도로 사용됩니다. &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메서드 의 &lt;em&gt;문자 집합&lt;/em&gt; 인수 와 동일한 의미를 갖습니다 . 또한 문자 &lt;em&gt;세트&lt;/em&gt; 인수 를 생략하는 모든 후속 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 호출에 대한 기본 문자 세트를 설정합니다 . 경우 &lt;em&gt;캐릭터 세트가&lt;/em&gt; 생성자 (기본값)에서 제공되지는 &lt;code&gt;us-ascii&lt;/code&gt; 문자 세트는 모두 사용되는 &lt;em&gt;S&lt;/em&gt; 의 초기 캐릭터 세트 이후의 기본값으로 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 호출을.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="642b9453af4c0269ab0ad7d0d8bcb29305105881" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;charset&lt;/em&gt;, if given, should be a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance (see &lt;a href=&quot;email.charset#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt;) or the name of a character set, which will be converted to a &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; instance. A value of &lt;code&gt;None&lt;/code&gt; (the default) means that the &lt;em&gt;charset&lt;/em&gt; given in the constructor is used.</source>
          <target state="translated">옵션 &lt;em&gt;캐릭터 세트&lt;/em&gt; , 주어진 경우이어야한다 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; (참조 예를 &lt;a href=&quot;email.charset#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; ) 또는으로 변환하는 문자 세트의 이름 &lt;a href=&quot;email.charset#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. &lt;code&gt;None&lt;/code&gt; (기본값) 은 생성자에 지정된 &lt;em&gt;문자&lt;/em&gt; 집합 이 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="3105978bd6f7423833b30c5cebf668aba1d75338" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;context&lt;/em&gt; parameter is an &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; object; This is an alternative to using a keyfile and a certfile and if specified both &lt;em&gt;keyfile&lt;/em&gt; and &lt;em&gt;certfile&lt;/em&gt; should be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;컨텍스트&lt;/em&gt; 매개 변수는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 오브젝트입니다. 이 키 파일과 certfile를 사용하는 대신하고 모두 지정한 경우 &lt;em&gt;키 파일을&lt;/em&gt; 하고 &lt;em&gt;certfile는&lt;/em&gt; 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d99f38424b2c5ff22681c0c95a235051c8f5f6c" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;continuation_ws&lt;/em&gt; must be &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;-compliant folding whitespace, and is usually either a space or a hard tab character. This character will be prepended to continuation lines. &lt;em&gt;continuation_ws&lt;/em&gt; defaults to a single space character.</source>
          <target state="translated">선택적 &lt;em&gt;continuation_ws&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-9&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 호환 접이식 공백 이어야하며 일반적으로 공백 또는 하드 탭 문자입니다. 이 문자는 연속 줄 앞에 추가됩니다. &lt;em&gt;continuation_ws의&lt;/em&gt; 기본값은 단일 공백 ​​문자입니다.</target>
        </trans-unit>
        <trans-unit id="c67c2285f2ee3c267919b8e982d48c9f0e3fac16" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;decode&lt;/em&gt; is a flag indicating whether the payload should be decoded or not, according to the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header. When &lt;code&gt;True&lt;/code&gt; and the message is not a multipart, the payload will be decoded if this header&amp;rsquo;s value is &lt;code&gt;quoted-printable&lt;/code&gt; or &lt;code&gt;base64&lt;/code&gt;. If some other encoding is used, or &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header is missing, the payload is returned as-is (undecoded). In all cases the returned value is binary data. If the message is a multipart and the &lt;em&gt;decode&lt;/em&gt; flag is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;None&lt;/code&gt; is returned. If the payload is base64 and it was not perfectly formed (missing padding, characters outside the base64 alphabet), then an appropriate defect will be added to the message&amp;rsquo;s defect property (&lt;code&gt;InvalidBase64PaddingDefect&lt;/code&gt; or &lt;code&gt;InvalidBase64CharactersDefect&lt;/code&gt;, respectively).</source>
          <target state="translated">선택적 &lt;em&gt;디코드&lt;/em&gt; 는 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더 에 따라 페이로드를 디코드해야하는지 여부를 나타내는 플래그 입니다. 때 &lt;code&gt;True&lt;/code&gt; 과 메시지가 다중 아닌이 헤더의 값이되면, 페이로드 디코딩됩니다 &lt;code&gt;quoted-printable&lt;/code&gt; 또는 &lt;code&gt;base64&lt;/code&gt; . 다른 인코딩이 사용되거나 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더가 누락 된 경우 페이로드는 그대로 (비 경제적) 반환됩니다. 모든 경우에 반환 된 값은 이진 데이터입니다. 메시지가 멀티 파트이고 &lt;em&gt;디코드&lt;/em&gt; 플래그가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;None&lt;/code&gt; 반환됩니다. 페이로드가 base64이고 완벽하게 형성되지 않은 경우 (패딩 누락, base64 알파벳 이외의 문자), 해당 결함이 메시지의 결함 특성 ( 각각 &lt;code&gt;InvalidBase64PaddingDefect&lt;/code&gt; 또는 &lt;code&gt;InvalidBase64CharactersDefect&lt;/code&gt; )에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="369dd5ecc7951cf49ed4b1356b49e703da098189" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;decode&lt;/em&gt; is passed through to &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt;&lt;code&gt;Message.get_payload&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;디코딩&lt;/em&gt; 은 &lt;a href=&quot;email.compat32-message#email.message.Message.get_payload&quot;&gt; &lt;code&gt;Message.get_payload&lt;/code&gt; &lt;/a&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="84972e509ca18de70cc29ad7afa6e0258541f329" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;errors&lt;/em&gt; is passed as the errors argument to the decode call if &lt;em&gt;s&lt;/em&gt; is a byte string.</source>
          <target state="translated">&lt;em&gt;s&lt;/em&gt; 가 바이트 문자열 인 경우 선택적 &lt;em&gt;오류&lt;/em&gt; 가 오류 인수로 디코드 호출에 전달됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cdfa3072d99360bc8281b6670d7022d51cad8c05" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;errors&lt;/em&gt; is passed straight through to the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;오류&lt;/em&gt; 는 &lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메소드로 직접 전달 됩니다.</target>
        </trans-unit>
        <trans-unit id="af5602daa1b8d69afae9c649f6b6721510f50598" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;failobj&lt;/em&gt; is the object to return if there is no &lt;em&gt;Content-Type&lt;/em&gt; header. Optional &lt;em&gt;header&lt;/em&gt; is the header to search instead of &lt;em&gt;Content-Type&lt;/em&gt;.</source>
          <target state="translated">선택적인 &lt;em&gt;failobj&lt;/em&gt; 는 &lt;em&gt;Content-Type&lt;/em&gt; 헤더 가없는 경우 반환 할 객체 입니다. 선택적 &lt;em&gt;헤더&lt;/em&gt; 는 &lt;em&gt;Content-Type&lt;/em&gt; 대신 검색 할 헤더 입니다.</target>
        </trans-unit>
        <trans-unit id="1c9958c82059fc6801aef502b2e8413f811d61fd" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;fp&lt;/em&gt; is a file-like object to print the output to. It must be suitable for Python&amp;rsquo;s &lt;a href=&quot;functions#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; function. &lt;em&gt;level&lt;/em&gt; is used internally. &lt;em&gt;include_default&lt;/em&gt;, if true, prints the default type as well.</source>
          <target state="translated">선택적 &lt;em&gt;fp&lt;/em&gt; 는 출력을 인쇄 할 파일과 유사한 객체입니다. Python의 &lt;a href=&quot;functions#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 함수에 적합해야합니다 . &lt;em&gt;레벨&lt;/em&gt; 은 내부적으로 사용됩니다. &lt;em&gt;include_default&lt;/em&gt; 는 true 인 경우 기본 유형도 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a8edc8339641cac835a5f65084c400648dd7bc38" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header&lt;/em&gt; if given, specifies the message header to use instead of &lt;em&gt;Content-Type&lt;/em&gt;.</source>
          <target state="translated">옵션 &lt;em&gt;헤더 (&lt;/em&gt; 제공된 경우)는 &lt;em&gt;Content-Type&lt;/em&gt; 대신 사용할 메시지 헤더를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="56ec783d1d1ef92af29b2b3bf0edfc7eeea59252" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header&lt;/em&gt; specifies an alternative header to &lt;em&gt;Content-Type&lt;/em&gt;, and all parameters will be quoted as necessary unless optional &lt;em&gt;requote&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt; (the default is &lt;code&gt;True&lt;/code&gt;).</source>
          <target state="translated">옵션 &lt;em&gt;헤더&lt;/em&gt; 에 대한 대안 헤더 지정 &lt;em&gt;콘텐츠 형식을&lt;/em&gt; , 및 선택하지 않는 한 모든 매개 변수는 필요에 따라 인용한다 &lt;em&gt;requote이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; (기본값은 &lt;code&gt;True&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d5523c1c7da4baa3419962027d50d39d8397401a" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;header_enc&lt;/em&gt; and &lt;em&gt;body_enc&lt;/em&gt; is either &lt;code&gt;Charset.QP&lt;/code&gt; for quoted-printable, &lt;code&gt;Charset.BASE64&lt;/code&gt; for base64 encoding, &lt;code&gt;Charset.SHORTEST&lt;/code&gt; for the shortest of quoted-printable or base64 encoding, or &lt;code&gt;None&lt;/code&gt; for no encoding. &lt;code&gt;SHORTEST&lt;/code&gt; is only valid for &lt;em&gt;header_enc&lt;/em&gt;. The default is &lt;code&gt;None&lt;/code&gt; for no encoding.</source>
          <target state="translated">선택 &lt;em&gt;header_enc&lt;/em&gt; 및 &lt;em&gt;body_enc가&lt;/em&gt; 하나 인 &lt;code&gt;Charset.QP&lt;/code&gt; 인용 된 인쇄 들면 &lt;code&gt;Charset.BASE64&lt;/code&gt; 는 Base64 인코딩 들어 &lt;code&gt;Charset.SHORTEST&lt;/code&gt; 는 인용 된 인쇄 또는베이스 64의 최단 인코딩 없거나 &lt;code&gt;None&lt;/code&gt; 없음 인코딩. &lt;code&gt;SHORTEST&lt;/code&gt; 는 &lt;em&gt;header_enc&lt;/em&gt; 에만 유효합니다 . 인코딩이없는 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="348f37b616413a59290dc4137576e659b6b66805" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is a flag specifying whether to stop parsing after reading the headers or not. The default is &lt;code&gt;False&lt;/code&gt;, meaning it parses the entire contents of the file.</source>
          <target state="translated">선택적 &lt;em&gt;헤더 만은&lt;/em&gt; 헤더를 읽은 후 구문 분석을 중지할지 여부를 지정하는 플래그입니다. 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 파일의 전체 내용을 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="70ab572101a30eef47fe16af46c39372bde2e339" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is as with the &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;헤더&lt;/em&gt; 만 &lt;a href=&quot;#email.parser.BytesParser.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="b729b7533028c3755db136b3ae706911b578a369" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;headersonly&lt;/em&gt; is as with the &lt;a href=&quot;#email.parser.Parser.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">선택적 &lt;em&gt;헤더&lt;/em&gt; 만 &lt;a href=&quot;#email.parser.Parser.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="1300eb907c8a0950cd615120af8b9e9015e21490" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;input_charset&lt;/em&gt; is as described below; it is always coerced to lower case. After being alias normalized it is also used as a lookup into the registry of character sets to find out the header encoding, body encoding, and output conversion codec to be used for the character set. For example, if &lt;em&gt;input_charset&lt;/em&gt; is &lt;code&gt;iso-8859-1&lt;/code&gt;, then headers and bodies will be encoded using quoted-printable and no output conversion codec is necessary. If &lt;em&gt;input_charset&lt;/em&gt; is &lt;code&gt;euc-jp&lt;/code&gt;, then headers will be encoded with base64, bodies will not be encoded, but output text will be converted from the &lt;code&gt;euc-jp&lt;/code&gt; character set to the &lt;code&gt;iso-2022-jp&lt;/code&gt; character set.</source>
          <target state="translated">선택적 &lt;em&gt;input_charset&lt;/em&gt; 은 다음과 같습니다. 항상 소문자로 강제됩니다. 별칭이 정규화 된 후에는 문자 집합 레지스트리에서 조회로 사용되어 문자 집합에 사용할 헤더 인코딩, 본문 인코딩 및 출력 변환 코덱을 찾습니다. 예를 들어 &lt;em&gt;input_charset&lt;/em&gt; 이 &lt;code&gt;iso-8859-1&lt;/code&gt; 인 경우 헤더와 본문은 인용 인쇄 가능을 사용하여 인코딩되며 출력 변환 코덱이 필요하지 않습니다. 경우 &lt;em&gt;input_charset가&lt;/em&gt; 있다 &lt;code&gt;euc-jp&lt;/code&gt; , 다음 헤더는, 몸이 인코딩되지 않습니다 base64로 인코딩되지만, 출력 텍스트가 변환됩니다 &lt;code&gt;euc-jp&lt;/code&gt; 받는 문자 집합 &lt;code&gt;iso-2022-jp&lt;/code&gt; 문자 세트.</target>
        </trans-unit>
        <trans-unit id="7f0ac5d6eacc6d8910fdc79f834598dba5f7ecc0" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;localtime&lt;/em&gt; is a flag that when &lt;code&gt;True&lt;/code&gt;, interprets &lt;em&gt;timeval&lt;/em&gt;, and returns a date relative to the local timezone instead of UTC, properly taking daylight savings time into account. The default is &lt;code&gt;False&lt;/code&gt; meaning UTC is used.</source>
          <target state="translated">선택적 &lt;em&gt;localtime&lt;/em&gt; 은 &lt;code&gt;True&lt;/code&gt; 일 때 &lt;em&gt;timeval을&lt;/em&gt; 해석 하고 UTC 대신 현지 시간대를 기준으로 날짜를 반환하여 일광 절약 시간을 올바르게 고려 하는 플래그입니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 UTC가 사용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="081534f96775eff49e5f20cd9241c5dc8464300b" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;output_charset&lt;/em&gt; is the character set that the output should be in. Conversions will proceed from input charset, to Unicode, to the output charset when the method &lt;code&gt;Charset.convert()&lt;/code&gt; is called. The default is to output in the same character set as the input.</source>
          <target state="translated">선택적 &lt;em&gt;output_charset&lt;/em&gt; 은 출력에 포함 된 문자 세트입니다. &lt;code&gt;Charset.convert()&lt;/code&gt; 메소드 가 호출 될 때 입력 문자 세트에서 유니 코드로, 출력 문자 세트로 변환이 진행됩니다 . 기본값은 입력과 동일한 문자 세트로 출력하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="27a289728023caa13d781ff4f3845ee08d743ebe" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;policy&lt;/em&gt; argument defaults to &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt;&lt;code&gt;compat32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;정책&lt;/em&gt; 인수의 기본값은 &lt;a href=&quot;email.policy#email.policy.Compat32&quot;&gt; &lt;code&gt;compat32&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e9de5adc35af35a2d0dbdc98b0b7dccae205e947" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;s&lt;/em&gt; is the initial header value. If &lt;code&gt;None&lt;/code&gt; (the default), the initial header value is not set. You can later append to the header with &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; method calls. &lt;em&gt;s&lt;/em&gt; may be an instance of &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, but see the &lt;a href=&quot;#email.header.Header.append&quot;&gt;&lt;code&gt;append()&lt;/code&gt;&lt;/a&gt; documentation for semantics.</source>
          <target state="translated">선택적인 &lt;em&gt;s&lt;/em&gt; 는 초기 헤더 값입니다. 경우 &lt;code&gt;None&lt;/code&gt; (기본값), 초기 헤더 값이 설정되어 있지 않습니다. 나중에 헤더에 추가 할 수 있습니다&lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 메서드 호출 추가.&lt;em&gt; s&lt;/em&gt; 는&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 인스턴스일 수 있지만의미에대해서는&lt;a href=&quot;#email.header.Header.append&quot;&gt; &lt;code&gt;append()&lt;/code&gt; &lt;/a&gt; 설명서를참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4a06aa49f277b03a309f72dd81f7730544395c46" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;splitchars&lt;/em&gt; is a string containing characters which should be given extra weight by the splitting algorithm during normal header wrapping. This is in very rough support of &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;&amp;rsquo;s &amp;lsquo;higher level syntactic breaks&amp;rsquo;: split points preceded by a splitchar are preferred during line splitting, with the characters preferred in the order in which they appear in the string. Space and tab may be included in the string to indicate whether preference should be given to one over the other as a split point when other split chars do not appear in the line being split. Splitchars does not affect &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; encoded lines.</source>
          <target state="translated">선택적 &lt;em&gt;splitchars&lt;/em&gt; 는 문자를 포함하는 문자열로 일반 헤더 줄 바꿈 중 분할 알고리즘으로 추가 가중치를 받아야합니다. 이것은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 의 '상위 구문 구문 나누기' 를 매우 대략적으로 지원합니다 . 행 분할 중에 splitchar가 앞에 오는 분리 점이 선호되며 문자열에 표시되는 순서대로 문자가 선호됩니다. 공백과 탭이 문자열에 포함되어 다른 분할 문자가 분할되는 행에 나타나지 않을 때 분할 점으로 우선 순위를 부여해야하는지 여부를 나타냅니다. Splitchars는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-13&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; 인코딩 된 라인에 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a3f21b8e8630f6eb8e4be7786fc506fc0f12e579" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;timeval&lt;/em&gt; if given is a floating point time value as accepted by &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;time.gmtime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;time#time.localtime&quot;&gt;&lt;code&gt;time.localtime()&lt;/code&gt;&lt;/a&gt;, otherwise the current time is used.</source>
          <target state="translated">&lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;time.gmtime()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;time#time.localtime&quot;&gt; &lt;code&gt;time.localtime()&lt;/code&gt; &lt;/a&gt; 에서 허용되는 부동 소수점 시간 값인 경우 선택적인 &lt;em&gt;timeval&lt;/em&gt; 입니다. 그렇지 않으면 현재 시간이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d94e2bee88984200593b6f6da3352d09ebd1bdf9" translate="yes" xml:space="preserve">
          <source>Optional &lt;em&gt;usegmt&lt;/em&gt; is a flag that when &lt;code&gt;True&lt;/code&gt;, outputs a date string with the timezone as an ascii string &lt;code&gt;GMT&lt;/code&gt;, rather than a numeric &lt;code&gt;-0000&lt;/code&gt;. This is needed for some protocols (such as HTTP). This only applies when &lt;em&gt;localtime&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;. The default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;em&gt;usegmt&lt;/em&gt; 는 &lt;code&gt;True&lt;/code&gt; 일 때 숫자가 아닌 시간대를 ASCII 문자열 &lt;code&gt;GMT&lt;/code&gt; 로 사용하여 날짜 문자열을 출력 하는 플래그입니다. &lt;code&gt;-0000&lt;/code&gt; 이 . 이것은 일부 프로토콜 (예 : HTTP)에 필요합니다. &lt;em&gt;localtime&lt;/em&gt; 이 &lt;code&gt;False&lt;/code&gt; 인 경우에만 적용됩니다 . 기본값은 &lt;code&gt;False&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3f1580e50d2eddf54a3ae07be51a03a3b611fbc6" translate="yes" xml:space="preserve">
          <source>Optional abstract method which returns a &lt;a href=&quot;stdtypes#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt; containing metadata about the specified path. Supported dictionary keys are:</source>
          <target state="translated">지정된 경로에 대한 메타 데이터를 포함 하는 &lt;a href=&quot;stdtypes#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; &lt;/a&gt; 를 반환하는 선택적 추상 메소드입니다 . 지원되는 사전 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="95081d9d4e8221143e59084ea58753f21593f36b" translate="yes" xml:space="preserve">
          <source>Optional abstract method which returns the modification time for the specified path.</source>
          <target state="translated">지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="89231b5583c81ea0c69000746832d731cd8bae53" translate="yes" xml:space="preserve">
          <source>Optional abstract method which writes the specified bytes to a file path. Any intermediate directories which do not exist are to be created automatically.</source>
          <target state="translated">지정된 바이트를 파일 경로에 쓰는 선택적 추상 메소드. 존재하지 않는 중간 디렉토리는 자동으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="44f898292a2dcbd773017d0c19c497a57f45394d" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;compileflags&lt;/em&gt; gives the set of flags that should be used by the Python compiler when running the examples. By default, or if &lt;code&gt;None&lt;/code&gt;, flags are deduced corresponding to the set of future features found in &lt;em&gt;globs&lt;/em&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;compileflags&lt;/em&gt; 는 예제를 실행할 때 Python 컴파일러에서 사용해야하는 플래그 세트를 제공합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면, &lt;em&gt;globs&lt;/em&gt; 에서 발견 된 향후 기능 세트에 해당하는 플래그가 추론 됩니다.</target>
        </trans-unit>
        <trans-unit id="a1d7c5227339a3dd1d8d5e5070885d664aae3a21" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;cutoff&lt;/em&gt; (default &lt;code&gt;0.6&lt;/code&gt;) is a float in the range [0, 1]. Possibilities that don&amp;rsquo;t score at least that similar to &lt;em&gt;word&lt;/em&gt; are ignored.</source>
          <target state="translated">선택적 인수 &lt;em&gt;컷오프&lt;/em&gt; (기본값 &lt;code&gt;0.6&lt;/code&gt; )는 [0, 1] 범위의 부동 소수점입니다. 최소한 &lt;em&gt;단어&lt;/em&gt; 와 비슷한 점수를 얻지 못할 가능성 은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a241b6f1ed98aec382909620ac3173fbadb0aac1" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;encoding&lt;/em&gt; specifies an encoding that should be used to convert the file to unicode.</source>
          <target state="translated">선택적 인수 &lt;em&gt;인코딩&lt;/em&gt; 은 파일을 유니 코드로 변환하는 데 사용해야하는 인코딩을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="32822bcfb01fea87cd439dcc50837e241cd10492" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;exclude_empty&lt;/em&gt; defaults to false. If true, objects for which no doctests are found are excluded from consideration. The default is a backward compatibility hack, so that code still using &lt;code&gt;doctest.master.summarize()&lt;/code&gt; in conjunction with &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt; continues to get output for objects with no tests. The &lt;em&gt;exclude_empty&lt;/em&gt; argument to the newer &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt;&lt;code&gt;DocTestFinder&lt;/code&gt;&lt;/a&gt; constructor defaults to true.</source>
          <target state="translated">선택적 인수 &lt;em&gt;exclude_empty의&lt;/em&gt; 기본값은 false입니다. true 인 경우, doctest가없는 오브젝트는 고려에서 제외됩니다. 기본값은 이전 버전과의 호환성 해킹이므로 &lt;code&gt;doctest.master.summarize()&lt;/code&gt; 와 함께 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 계속 사용하는 코드는 테스트없이 객체에 대한 출력을 계속 얻습니다. 최신 &lt;a href=&quot;#doctest.DocTestFinder&quot;&gt; &lt;code&gt;DocTestFinder&lt;/code&gt; &lt;/a&gt; 생성자에 대한 &lt;em&gt;exclude_empty&lt;/em&gt; 인수의 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="c56059e44a1695148c4922ca4f4a049c77eff06a" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;extraglobs&lt;/em&gt; gives a dict merged into the globals used to execute examples. This works like &lt;a href=&quot;stdtypes#dict.update&quot;&gt;&lt;code&gt;dict.update()&lt;/code&gt;&lt;/a&gt;: if &lt;em&gt;globs&lt;/em&gt; and &lt;em&gt;extraglobs&lt;/em&gt; have a common key, the associated value in &lt;em&gt;extraglobs&lt;/em&gt; appears in the combined dict. By default, or if &lt;code&gt;None&lt;/code&gt;, no extra globals are used. This is an advanced feature that allows parameterization of doctests. For example, a doctest can be written for a base class, using a generic name for the class, then reused to test any number of subclasses by passing an &lt;em&gt;extraglobs&lt;/em&gt; dict mapping the generic name to the subclass to be tested.</source>
          <target state="translated">선택적 인수 &lt;em&gt;extraglobs&lt;/em&gt; 는 예제를 실행하는 데 사용되는 전역으로 병합 된 dict를 제공합니다. 같은이 작품 &lt;a href=&quot;stdtypes#dict.update&quot;&gt; &lt;code&gt;dict.update()&lt;/code&gt; &lt;/a&gt; 다음과 같은 경우 &lt;em&gt;globs와&lt;/em&gt; 와 &lt;em&gt;extraglobs는&lt;/em&gt; 공통의 키가에 관련된 값 &lt;em&gt;extraglobs이&lt;/em&gt; 결합 된 DICT에 나타납니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 추가 전역이 사용되지 않습니다. 이것은 doctest의 매개 변수화를 허용하는 고급 기능입니다. 예를 들어, 클래스의 일반 이름을 사용하여 기본 클래스에 대해 doctest를 작성한 다음, 테스트 할 서브 클래스에 일반 이름을 맵핑 하는 &lt;em&gt;엑스트라 글로브 (extraglobs)&lt;/em&gt; dict 를 전달하여 여러 서브 클래스를 테스트하는 데 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fba34650a7fe8672d07c230f7d0e87f1c888f71" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;extraglobs&lt;/em&gt; specifies an extra set of global variables, which is merged into &lt;em&gt;globs&lt;/em&gt;. By default, no extra globals are used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;extraglobs&lt;/em&gt; 는 추가되는 전역 변수 세트를 지정합니다.&lt;em&gt; globs&lt;/em&gt; . 기본적으로 추가 전역이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47e27778c61b07e6d1aab3d14114ebc81c4fa2f2" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; gives a dict to be used as the globals when executing examples. A new shallow copy of this dict is created for the doctest, so its examples start with a clean slate. By default, or if &lt;code&gt;None&lt;/code&gt;, a new empty dict is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 예제를 실행할 때 전역으로 사용될 dict를 제공합니다. 이 dict의 새로운 얕은 사본은 doctest를 위해 만들어 졌으므로 예제는 깨끗한 슬레이트로 시작합니다. 기본적으로 또는 &lt;code&gt;None&lt;/code&gt; 이면 새로운 빈 dict가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e45842c5895e5ae4432fbb87c16f7cb0eeaec604" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; gives a dictionary to use as both local and global execution context. If not specified, or &lt;code&gt;None&lt;/code&gt;, an empty dictionary is used. If specified, a shallow copy of the dictionary is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 로컬 및 전역 실행 컨텍스트로 사용할 사전을 제공합니다. 지정하지 않은 경우 &lt;code&gt;None&lt;/code&gt; 이면 빈 사전이 사용됩니다. 지정된 경우 사전의 얕은 사본이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac2368691c9de6fd84091afdc4f7a61c1910faf1" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;globs&lt;/em&gt; is a dictionary containing the initial global variables for the tests. A new copy of this dictionary is created for each test. By default, &lt;em&gt;globs&lt;/em&gt; is a new empty dictionary.</source>
          <target state="translated">선택적 인수 &lt;em&gt;globs&lt;/em&gt; 는 테스트의 초기 전역 변수를 포함하는 사전입니다. 이 사전의 새 사본이 각 테스트마다 작성됩니다. 기본적으로,&lt;em&gt; globs&lt;/em&gt; 는 새로운 빈 사전입니다.</target>
        </trans-unit>
        <trans-unit id="fb750e9897e2507830eb1c28fae23ef3fcb29129" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;interval&lt;/em&gt; represents the class interval, and defaults to 1. Changing the class interval naturally will change the interpolation:</source>
          <target state="translated">선택적 인수 &lt;em&gt;간격&lt;/em&gt; 은 클래스 나타내며 기본값은 1입니다. 클래스 간격을 자연스럽게 변경하면 보간이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3aac0b0b4936e97b6b254322e753031731854457" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;isjunk&lt;/em&gt; must be &lt;code&gt;None&lt;/code&gt; (the default) or a one-argument function that takes a sequence element and returns true if and only if the element is &amp;ldquo;junk&amp;rdquo; and should be ignored. Passing &lt;code&gt;None&lt;/code&gt; for &lt;em&gt;isjunk&lt;/em&gt; is equivalent to passing &lt;code&gt;lambda x: False&lt;/code&gt;; in other words, no elements are ignored. For example, pass:</source>
          <target state="translated">선택적 인수 &lt;em&gt;isjunk&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; (기본값) 또는 시퀀스 요소를 가져 와서 요소가 &quot;junk&quot;이고 무시해야하는 경우에만 true를 리턴하는 1 인수 함수 여야합니다. 전달하지 &lt;code&gt;None&lt;/code&gt; 위해 &lt;em&gt;isjunk은&lt;/em&gt; 전달에 해당 &lt;code&gt;lambda x: False&lt;/code&gt; ; 즉, 요소가 무시되지 않습니다. 예를 들어, 다음을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="74aea2ea98253e841261cf8043788a6866f1d3cf" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module&lt;/em&gt; provides the module to be tested. It can be a module object or a (possibly dotted) module name. If not specified, the module calling this function is used.</source>
          <target state="translated">선택적 인수 &lt;em&gt;모듈&lt;/em&gt; 은 테스트 할 모듈을 제공합니다. 모듈 객체 또는 점으로 구분 된 모듈 이름 일 수 있습니다. 지정하지 않으면이 함수를 호출하는 모듈이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88fe4782e94348e9fdc401064c2ad56c8058b300" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module_relative&lt;/em&gt; specifies how the filename should be interpreted:</source>
          <target state="translated">선택적 인수 &lt;em&gt;module_relative&lt;/em&gt; 는 파일 이름을 해석하는 방법을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="22ad18924a8191c36d6c5c768f2a1805167cb09a" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;module_relative&lt;/em&gt; specifies how the filenames in &lt;em&gt;paths&lt;/em&gt; should be interpreted:</source>
          <target state="translated">선택적 인수 &lt;em&gt;module_relative&lt;/em&gt; 는 &lt;em&gt;경로&lt;/em&gt; 에서 파일 이름을 지정하는 방법을 지정합니다.&lt;em&gt;&lt;/em&gt; 해석 .</target>
        </trans-unit>
        <trans-unit id="c683e99d27fef7549d8e40a7457b3d344329fce8" translate="yes" xml:space="preserve">
          <source>Optional argument &lt;em&gt;n&lt;/em&gt; (default &lt;code&gt;3&lt;/code&gt;) is the maximum number of close matches to return; &lt;em&gt;n&lt;/em&gt; must be greater than &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">선택적 인수 &lt;em&gt;n&lt;/em&gt; (기본값 &lt;code&gt;3&lt;/code&gt; )은 반환 할 최대 근접 일치 수입니다. &lt;em&gt;n&lt;/em&gt; 은 &lt;code&gt;0&lt;/code&gt; 보다 커야합니다 .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
