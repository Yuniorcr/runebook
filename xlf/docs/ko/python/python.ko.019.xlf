<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="e367c2302e72de69a7a939f03f510bb5eab31173" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;em&gt;address_family&lt;/em&gt; are currently &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;. If the IP address string &lt;em&gt;ip_string&lt;/em&gt; is invalid, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; will be raised. Note that exactly what is valid depends on both the value of &lt;em&gt;address_family&lt;/em&gt; and the underlying implementation of &lt;code&gt;inet_pton()&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;address_family에&lt;/em&gt; 지원되는 값 은 현재 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt; 입니다. IP 주소 문자열 &lt;em&gt;ip_string&lt;/em&gt; 이 유효하지 않으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 정확히 유효한 것은 &lt;em&gt;address_family&lt;/em&gt; 값 과 &lt;code&gt;inet_pton()&lt;/code&gt; 의 기본 구현에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="0e9fde244b17f9b103b9bf324659c200069ab093" translate="yes" xml:space="preserve">
          <source>Supported values for &lt;em&gt;address_family&lt;/em&gt; are currently &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#socket.AF_INET6&quot;&gt;&lt;code&gt;AF_INET6&lt;/code&gt;&lt;/a&gt;. If the bytes object &lt;em&gt;packed_ip&lt;/em&gt; is not the correct length for the specified address family, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised. &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised for errors from the call to &lt;a href=&quot;#socket.inet_ntop&quot;&gt;&lt;code&gt;inet_ntop()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;address_family에&lt;/em&gt; 지원되는 값 은 현재 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#socket.AF_INET6&quot;&gt; &lt;code&gt;AF_INET6&lt;/code&gt; &lt;/a&gt; 입니다. 바이트 객체의 경우 &lt;em&gt;packed_ip가&lt;/em&gt; 지정된 주소 가족을위한 올바른 길이 아닌, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. &lt;a href=&quot;#socket.inet_ntop&quot;&gt; &lt;code&gt;inet_ntop()&lt;/code&gt; &lt;/a&gt; 호출로 인한 오류에 대해 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="09e336d73118eb768da01cca5618d57d7b503e9d" translate="yes" xml:space="preserve">
          <source>Supported, &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;IANA-registered&lt;/a&gt; status codes available in &lt;a href=&quot;#http.HTTPStatus&quot;&gt;&lt;code&gt;http.HTTPStatus&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#http.HTTPStatus&quot;&gt; &lt;code&gt;http.HTTPStatus&lt;/code&gt; &lt;/a&gt; 에서 사용 가능한 지원되는 &lt;a href=&quot;https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml&quot;&gt;IANA 등록&lt;/a&gt; 상태 코드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fbbbea93c1c5df9b273b63f34add5d6a935c85e8" translate="yes" xml:space="preserve">
          <source>Supporting a variable number of context managers</source>
          <target state="translated">가변 수의 컨텍스트 관리자 지원</target>
        </trans-unit>
        <trans-unit id="430fdd77b068348b7fc76000478a45dd8feb2327" translate="yes" xml:space="preserve">
          <source>Supporting sub-commands.</source>
          <target state="translated">지원되는 하위 명령.</target>
        </trans-unit>
        <trans-unit id="5353a4310fa3de26f04bb5315747474ebebe3b0d" translate="yes" xml:space="preserve">
          <source>Supports the following objects and types by default:</source>
          <target state="translated">기본적으로 다음 객체 및 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ed7383e628fad324b7b5dbc2ef5232ff9eb0de60" translate="yes" xml:space="preserve">
          <source>Suppose a car travels 10 km at 40 km/hr, then another 10 km at 60 km/hr. What is the average speed?</source>
          <target state="translated">자동차가 40km / hr로 10km를 주행 한 다음 60km / hr로 10km를 이동한다고 가정 해보십시오. 평균 속도는 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="4ed7afaf4b512d83ce6e0b4b0ff8ec5635d0cee0" translate="yes" xml:space="preserve">
          <source>Suppose an investor purchases an equal value of shares in each of three companies, with P/E (price/earning) ratios of 2.5, 3 and 10. What is the average P/E ratio for the investor&amp;rsquo;s portfolio?</source>
          <target state="translated">투자자가 P / E (가격 / 수익) 비율이 2.5, 3 및 10 인 세 회사 각각에서 동일한 주식 가치를 구입한다고 가정 해 봅시다. 투자자 포트폴리오의 평균 P / E 비율은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="eaf782ee46dbe7ee16e8a3fa45ccff536424ea2f" translate="yes" xml:space="preserve">
          <source>Suppose we want to create a class whose instances represent temporary directories. The directories should be deleted with their contents when the first of the following events occurs:</source>
          <target state="translated">인스턴스가 임시 디렉토리를 나타내는 클래스를 작성한다고 가정하십시오. 다음 이벤트 중 첫 번째 이벤트가 발생하면 해당 내용으로 디렉토리를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="dae8fd2ae7a644b210a65c97e04dd4a10af6eaf1" translate="yes" xml:space="preserve">
          <source>Suppose you are writing a poker program where a player&amp;rsquo;s hand is represented as a 5-character string with each character representing a card, &amp;ldquo;a&amp;rdquo; for ace, &amp;ldquo;k&amp;rdquo; for king, &amp;ldquo;q&amp;rdquo; for queen, &amp;ldquo;j&amp;rdquo; for jack, &amp;ldquo;t&amp;rdquo; for 10, and &amp;ldquo;2&amp;rdquo; through &amp;ldquo;9&amp;rdquo; representing the card with that value.</source>
          <target state="translated">플레이어의 손이 카드를 나타내는 5 자 문자열, 에이스의 경우 &quot;a&quot;, 킹의 경우 &quot;k&quot;, 퀸의 경우 &quot;q&quot;, 잭의 경우 &quot;j&quot;로 표시되는 포커 프로그램을 작성한다고 가정합니다. &quot;t&quot;는 10이고 &quot;2&quot;에서 &quot;9&quot;는 해당 값을 가진 카드를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f393e730a2a08893c63f470b503752ca86b2b301" translate="yes" xml:space="preserve">
          <source>Surprises</source>
          <target state="translated">Surprises</target>
        </trans-unit>
        <trans-unit id="b24247fb5a9d8d8059901182187be57626f3ba71" translate="yes" xml:space="preserve">
          <source>Suspend</source>
          <target state="translated">Suspend</target>
        </trans-unit>
        <trans-unit id="a7ac10f457b6a58e8db141ff4f40d96148eeab0e" translate="yes" xml:space="preserve">
          <source>Suspend execution of the calling thread for the given number of seconds. The argument may be a floating point number to indicate a more precise sleep time. The actual suspension time may be less than that requested because any caught signal will terminate the &lt;a href=&quot;#time.sleep&quot;&gt;&lt;code&gt;sleep()&lt;/code&gt;&lt;/a&gt; following execution of that signal&amp;rsquo;s catching routine. Also, the suspension time may be longer than requested by an arbitrary amount because of the scheduling of other activity in the system.</source>
          <target state="translated">주어진 시간 (초) 동안 호출 스레드 실행을 일시 중단합니다. 인수는보다 정확한 수면 시간을 나타내는 부동 소수점 숫자 일 수 있습니다. 포착 된 신호가 해당 신호의 포착 루틴을 실행 한 후 &lt;a href=&quot;#time.sleep&quot;&gt; &lt;code&gt;sleep()&lt;/code&gt; &lt;/a&gt; 종료하기 때문에 실제 정지 시간은 요청 된 것보다 짧을 수 있습니다 . 또한, 정지 시간은 시스템 내의 다른 활동의 스케줄링으로 인해 임의의 양만큼 요청 된 것보다 길 수있다.</target>
        </trans-unit>
        <trans-unit id="721fc37163cc5ef97473efd877420d38d14966c0" translate="yes" xml:space="preserve">
          <source>Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set &lt;em&gt;sigset&lt;/em&gt;. The function accepts the signal (removes it from the pending list of signals), and returns the signal number.</source>
          <target state="translated">신호 세트 &lt;em&gt;sigset에&lt;/em&gt; 지정된 신호 중 하나가 전달 될 때까지 호출 스레드의 실행을 일시 중단합니다 . 이 함수는 신호를 받아들이고 (대기중인 신호 목록에서 제거) 신호 번호를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0d6d4c32622974b9d1c49557ecd6fdc3384f6d0f" translate="yes" xml:space="preserve">
          <source>Suspend execution of the calling thread until the delivery of one of the signals specified in the signal set &lt;em&gt;sigset&lt;/em&gt;. The function accepts the signal and removes it from the pending list of signals. If one of the signals in &lt;em&gt;sigset&lt;/em&gt; is already pending for the calling thread, the function will return immediately with information about that signal. The signal handler is not called for the delivered signal. The function raises an &lt;a href=&quot;exceptions#InterruptedError&quot;&gt;&lt;code&gt;InterruptedError&lt;/code&gt;&lt;/a&gt; if it is interrupted by a signal that is not in &lt;em&gt;sigset&lt;/em&gt;.</source>
          <target state="translated">신호 세트 &lt;em&gt;sigset에&lt;/em&gt; 지정된 신호 중 하나가 전달 될 때까지 호출 스레드의 실행을 일시 중단합니다 . 이 기능은 신호를 받아 들여 보류중인 신호 목록에서 제거합니다. &lt;em&gt;sigset&lt;/em&gt; 의 신호 중 하나 가 이미 호출 스레드에 대해 보류중인 경우 함수는 해당 신호에 대한 정보와 함께 즉시 리턴합니다. 전달 된 신호에 대해 신호 처리기가 호출되지 않습니다. &lt;em&gt;sigset에&lt;/em&gt; 없는 신호에 의해 &lt;a href=&quot;exceptions#InterruptedError&quot;&gt; &lt;code&gt;InterruptedError&lt;/code&gt; &lt;/a&gt; 되면 이 함수는 InterruptedError를 발생 시킵니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5be3b88fe6050f07242146d412f9682bcec1857" translate="yes" xml:space="preserve">
          <source>Suspend or resume input or output on file descriptor &lt;em&gt;fd&lt;/em&gt;. The &lt;em&gt;action&lt;/em&gt; argument can be &lt;code&gt;TCOOFF&lt;/code&gt; to suspend output, &lt;code&gt;TCOON&lt;/code&gt; to restart output, &lt;code&gt;TCIOFF&lt;/code&gt; to suspend input, or &lt;code&gt;TCION&lt;/code&gt; to restart input.</source>
          <target state="translated">파일 디스크립터 &lt;em&gt;fd의&lt;/em&gt; 입력 또는 출력을 일시 중단 또는 재개하십시오 . &lt;em&gt;작용&lt;/em&gt; 인자 일 수 &lt;code&gt;TCOOFF&lt;/code&gt; 가 출력 중단 &lt;code&gt;TCOON&lt;/code&gt; 재시작 출력을 &lt;code&gt;TCIOFF&lt;/code&gt; 는 입력을 일시 중단하거나 &lt;code&gt;TCION&lt;/code&gt; 재시작 입력.</target>
        </trans-unit>
        <trans-unit id="496f3ed6f7e14ef62d9e444944e5bf0608249526" translate="yes" xml:space="preserve">
          <source>Swaps the two top-most stack items.</source>
          <target state="translated">두 개의 최상위 스택 항목을 교체합니다.</target>
        </trans-unit>
        <trans-unit id="2e0dcb00e65a28125117875b793974ff78034961" translate="yes" xml:space="preserve">
          <source>Switching protocol should only be done when both protocols are documented to support the switch.</source>
          <target state="translated">스위칭 프로토콜은 스위치를 지원하도록 두 프로토콜이 모두 문서화 된 경우에만 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fe0965f151a6bf0067ecb9aa1896964bf350a557" translate="yes" xml:space="preserve">
          <source>Symbol tables are generated by the compiler from AST just before bytecode is generated. The symbol table is responsible for calculating the scope of every identifier in the code. &lt;a href=&quot;#module-symtable&quot;&gt;&lt;code&gt;symtable&lt;/code&gt;&lt;/a&gt; provides an interface to examine these tables.</source>
          <target state="translated">심볼 테이블은 바이트 코드가 생성되기 직전에 AST에서 컴파일러에 의해 생성됩니다. 심볼 테이블은 코드에서 모든 식별자의 범위를 계산합니다. &lt;a href=&quot;#module-symtable&quot;&gt; &lt;code&gt;symtable&lt;/code&gt; &lt;/a&gt; 은 이러한 테이블을 검사하기위한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="08f7ff9d34edbbf7d7ae7d368633ffd9090dec8b" translate="yes" xml:space="preserve">
          <source>Symbol used to annotate a negative monetary value.</source>
          <target state="translated">음수 통화 값에 주석을다는 데 사용되는 기호.</target>
        </trans-unit>
        <trans-unit id="dc9ab385c43a04a353935818fc27997e22e5f289" translate="yes" xml:space="preserve">
          <source>Symbol used to annotate a positive monetary value.</source>
          <target state="translated">양의 금전적 가치에 주석을다는 데 사용되는 기호.</target>
        </trans-unit>
        <trans-unit id="66e9aca03dcf567e45a76a6d9b9aff78a6e0594a" translate="yes" xml:space="preserve">
          <source>Symbolic constants are used to specify particular system resources and to request usage information about either the current process or its children.</source>
          <target state="translated">기호 상수는 특정 시스템 자원을 지정하고 현재 프로세스 또는 해당 하위에 대한 사용 정보를 요청하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15d2715339927ab1cacbd3a795da09326886df84" translate="yes" xml:space="preserve">
          <source>Symbolic link.</source>
          <target state="translated">심볼릭 링크.</target>
        </trans-unit>
        <trans-unit id="b5fbcc04189e5e7ee4d138a02eb7cd6accc39d21" translate="yes" xml:space="preserve">
          <source>Symbolic value</source>
          <target state="translated">상징적 가치</target>
        </trans-unit>
        <trans-unit id="cbcf7ae51d210c4ce6c53f74b6ecb4c2b26819b4" translate="yes" xml:space="preserve">
          <source>Synchronization</source>
          <target state="translated">Synchronization</target>
        </trans-unit>
        <trans-unit id="29a7d1ea3d952fb85c579718deee912747842d8b" translate="yes" xml:space="preserve">
          <source>Synchronization Primitives</source>
          <target state="translated">동기화 프리미티브</target>
        </trans-unit>
        <trans-unit id="cbba062bbc83d66b28e943658c29a28c7fa8e0a9" translate="yes" xml:space="preserve">
          <source>Synchronization between processes</source>
          <target state="translated">프로세스 간 동기화</target>
        </trans-unit>
        <trans-unit id="36f95c993c41614d9487682d4095effab046a2f5" translate="yes" xml:space="preserve">
          <source>Synchronization primitives</source>
          <target state="translated">동기화 프리미티브</target>
        </trans-unit>
        <trans-unit id="dd9c2ef1022d2fe014d89f4287eec32c29bfe326" translate="yes" xml:space="preserve">
          <source>Synchronize and close the persistent &lt;em&gt;dict&lt;/em&gt; object. Operations on a closed shelf will fail with a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지속적 &lt;em&gt;dict&lt;/em&gt; 오브젝트를 동기화하고 닫으십시오 . 닫힌 선반에서의 작업은 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 와 함께 실패합니다 .</target>
        </trans-unit>
        <trans-unit id="69f7b0bd705db19c171a6d38cf3af9ce071ab2f2" translate="yes" xml:space="preserve">
          <source>Synchronize the on-disk directory and data files. This method is called by the &lt;code&gt;Shelve.sync()&lt;/code&gt; method.</source>
          <target state="translated">온 디스크 디렉토리와 데이터 파일을 동기화하십시오. 이 메소드는 &lt;code&gt;Shelve.sync()&lt;/code&gt; 메소드에 의해 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="c1f2bcf942acd2dc75db00756276387b3576d4b5" translate="yes" xml:space="preserve">
          <source>Synchronized mode. This will cause changes to the database to be immediately written to the file.</source>
          <target state="translated">동기화 모드. 이로 인해 데이터베이스 변경 사항이 파일에 즉시 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="478e0859dcfcb931254a976e6eb032edd080e8e0" translate="yes" xml:space="preserve">
          <source>Synchronous idle</source>
          <target state="translated">동기 유휴</target>
        </trans-unit>
        <trans-unit id="17c7ba7676ad1ad6dd1c4e6b997adcae910262c9" translate="yes" xml:space="preserve">
          <source>Syntax</source>
          <target state="translated">Syntax</target>
        </trans-unit>
        <trans-unit id="de4af2ff6c0bd31526ce7f5f8ca08783d0cc5ed7" translate="yes" xml:space="preserve">
          <source>SyntaxError</source>
          <target state="translated">SyntaxError</target>
        </trans-unit>
        <trans-unit id="239fde2b81323f82aa960faa292c8b84c09678bd" translate="yes" xml:space="preserve">
          <source>SyntaxWarning</source>
          <target state="translated">SyntaxWarning</target>
        </trans-unit>
        <trans-unit id="f99a1e0c4f99a37b7ffe012e980d6c18e08746d3" translate="yes" xml:space="preserve">
          <source>SysLogHandler</source>
          <target state="translated">SysLogHandler</target>
        </trans-unit>
        <trans-unit id="bc0792d8dc81e8aa30b987246a5ce97c40cd6833" translate="yes" xml:space="preserve">
          <source>System</source>
          <target state="translated">System</target>
        </trans-unit>
        <trans-unit id="dd32ed28eedb2fad18cd75ec03e544cf0d2ca3ec" translate="yes" xml:space="preserve">
          <source>System V file locking enforcement. This flag is shared with &lt;a href=&quot;#stat.S_ISGID&quot;&gt;&lt;code&gt;S_ISGID&lt;/code&gt;&lt;/a&gt;: file/record locking is enforced on files that do not have the group execution bit (&lt;a href=&quot;#stat.S_IXGRP&quot;&gt;&lt;code&gt;S_IXGRP&lt;/code&gt;&lt;/a&gt;) set.</source>
          <target state="translated">시스템 V 파일 잠금 적용. 이 플래그는 &lt;a href=&quot;#stat.S_ISGID&quot;&gt; &lt;code&gt;S_ISGID&lt;/code&gt; &lt;/a&gt; 와 공유됩니다 . 파일 / 레코드 잠금은 그룹 실행 비트 ( &lt;a href=&quot;#stat.S_IXGRP&quot;&gt; &lt;code&gt;S_IXGRP&lt;/code&gt; &lt;/a&gt; )가 설정 되지 않은 파일에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd4230b8fa1e196ceea27a4c97446bbf43db362e" translate="yes" xml:space="preserve">
          <source>System which created ZIP archive.</source>
          <target state="translated">ZIP 아카이브를 생성 한 시스템.</target>
        </trans-unit>
        <trans-unit id="d5ff5bc7b647223447ff8bbcf7017bf138ec3ea5" translate="yes" xml:space="preserve">
          <source>System-wide real-time clock. Setting this clock requires appropriate privileges.</source>
          <target state="translated">시스템 전체의 실시간 시계. 이 시계를 설정하려면 적절한 권한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="47e68638ef3b94e3c34563e1179f97e827fb9bec" translate="yes" xml:space="preserve">
          <source>SystemError</source>
          <target state="translated">SystemError</target>
        </trans-unit>
        <trans-unit id="7cc841d8ecdbfbc0498942bb2b4d8fa89ce32a41" translate="yes" xml:space="preserve">
          <source>SystemExit</source>
          <target state="translated">SystemExit</target>
        </trans-unit>
        <trans-unit id="eb1c93ed6255e73b69cef6bc348253d7b278840c" translate="yes" xml:space="preserve">
          <source>SystemExit.code</source>
          <target state="translated">SystemExit.code</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="c8079de7f39924a818429b6bbcf89203b522e2b1" translate="yes" xml:space="preserve">
          <source>T flag</source>
          <target state="translated">T 플래그</target>
        </trans-unit>
        <trans-unit id="100693b0324bc7e8a80c61cdf57cf7ead8f74082" translate="yes" xml:space="preserve">
          <source>T. Dierks et. al.</source>
          <target state="translated">T. Dierks et. 알.</target>
        </trans-unit>
        <trans-unit id="d1ffc191533bb2cbb8bf40d3119d9fe2916278fe" translate="yes" xml:space="preserve">
          <source>TCP Echo Client</source>
          <target state="translated">TCP 에코 클라이언트</target>
        </trans-unit>
        <trans-unit id="5b0877d2c21a8a83292debfb59a6c929390d3c9c" translate="yes" xml:space="preserve">
          <source>TCP Echo Server</source>
          <target state="translated">TCP 에코 서버</target>
        </trans-unit>
        <trans-unit id="5ef15cad06042dc4a49f48eedea031e55b9ecf0c" translate="yes" xml:space="preserve">
          <source>TCP echo client using streams</source>
          <target state="translated">스트림을 사용하는 TCP 에코 클라이언트</target>
        </trans-unit>
        <trans-unit id="73bbf4f27b80ee62463e82c07b0eb7dcc7b9c6f2" translate="yes" xml:space="preserve">
          <source>TCP echo client using the &lt;a href=&quot;#asyncio.open_connection&quot;&gt;&lt;code&gt;asyncio.open_connection()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.open_connection&quot;&gt; &lt;code&gt;asyncio.open_connection()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 TCP 에코 클라이언트 :</target>
        </trans-unit>
        <trans-unit id="2c08259ebc5b31cf20f523f0ca4fc480ddcb6886" translate="yes" xml:space="preserve">
          <source>TCP echo server using streams</source>
          <target state="translated">스트림을 사용하는 TCP 에코 서버</target>
        </trans-unit>
        <trans-unit id="2f7ae8465b345c81e3dc31fb3c5cb5c918ab2831" translate="yes" xml:space="preserve">
          <source>TCP echo server using the &lt;a href=&quot;#asyncio.start_server&quot;&gt;&lt;code&gt;asyncio.start_server()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.start_server&quot;&gt; &lt;code&gt;asyncio.start_server()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 TCP 에코 서버 :</target>
        </trans-unit>
        <trans-unit id="7adc41db35e4460161060a3765be2f4ce053917f" translate="yes" xml:space="preserve">
          <source>TEST_PREFIX</source>
          <target state="translated">TEST_PREFIX</target>
        </trans-unit>
        <trans-unit id="6d9797f70add1e44d57484714671c7206b7319ef" translate="yes" xml:space="preserve">
          <source>TIFF Files</source>
          <target state="translated">TIFF 파일</target>
        </trans-unit>
        <trans-unit id="cdeae3d22c263be0cc15f30b6b04620cb8d92ba6" translate="yes" xml:space="preserve">
          <source>TIPC related constants, matching the ones exported by the C socket API. See the TIPC documentation for more information.</source>
          <target state="translated">C 소켓 API에서 내 보낸 것과 일치하는 TIPC 관련 상수 자세한 내용은 TIPC 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0baa8888f9d0aa88c338a67431b067309925ea86" translate="yes" xml:space="preserve">
          <source>TKDocs</source>
          <target state="translated">TKDocs</target>
        </trans-unit>
        <trans-unit id="fbbfb6a7ead947e0fa27a3b7b0d471dcc4e2e9cf" translate="yes" xml:space="preserve">
          <source>TLS 1.3</source>
          <target state="translated">TLS 1.3</target>
        </trans-unit>
        <trans-unit id="49c878ba00b23828e711672cf8e175f204471d48" translate="yes" xml:space="preserve">
          <source>TLS 1.3 features like early data, deferred TLS client cert request, signature algorithm configuration, and rekeying are not supported yet.</source>
          <target state="translated">초기 데이터, 지연된 TLS 클라이언트 인증서 요청, 서명 알고리즘 구성 및 키 재 입력과 같은 TLS 1.3 기능은 아직 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e44a2f555a3fa72211507497bc3b16d61be51770" translate="yes" xml:space="preserve">
          <source>TLS 1.3 protocol will be available with &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt; in OpenSSL &amp;gt;= 1.1.1. There is no dedicated PROTOCOL constant for just TLS 1.3.</source>
          <target state="translated">TLS 1.3 프로토콜은 OpenSSL&amp;gt; = 1.1.1에서 &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 있습니다 . TLS 1.3에 대한 전용 PROTOCOL 상수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="300c5ad845fddb16bd752e6113d28d8e57573058" translate="yes" xml:space="preserve">
          <source>TLS 1.3 uses a disjunct set of cipher suites. All AES-GCM and ChaCha20 cipher suites are enabled by default. The method &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt;&lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt;&lt;/a&gt; cannot enable or disable any TLS 1.3 ciphers yet, but &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt;&lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt;&lt;/a&gt; returns them.</source>
          <target state="translated">TLS 1.3은 분리 된 암호 세트를 사용합니다. 모든 AES-GCM 및 ChaCha20 암호화 제품군은 기본적으로 활성화되어 있습니다. &lt;a href=&quot;#ssl.SSLContext.set_ciphers&quot;&gt; &lt;code&gt;SSLContext.set_ciphers()&lt;/code&gt; &lt;/a&gt; 메소드 는 아직 TLS 1.3 암호를 활성화하거나 비활성화 할 수 없지만 &lt;a href=&quot;#ssl.SSLContext.get_ciphers&quot;&gt; &lt;code&gt;SSLContext.get_ciphers()&lt;/code&gt; &lt;/a&gt; 는이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4c9f6c270dbdfd7c10f6e315eda01961135acc43" translate="yes" xml:space="preserve">
          <source>TLS Upgrade</source>
          <target state="translated">TLS 업그레이드</target>
        </trans-unit>
        <trans-unit id="1925fffff55dc3ab10762126722e13334b4e97f9" translate="yes" xml:space="preserve">
          <source>TOS is an &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;iterator&lt;/a&gt;. Call its &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt;&lt;code&gt;__next__()&lt;/code&gt;&lt;/a&gt; method. If this yields a new value, push it on the stack (leaving the iterator below it). If the iterator indicates it is exhausted TOS is popped, and the byte code counter is incremented by &lt;em&gt;delta&lt;/em&gt;.</source>
          <target state="translated">TOS는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterator&quot;&gt;반복자&lt;/a&gt; 입니다. &lt;a href=&quot;stdtypes#iterator.__next__&quot;&gt; &lt;code&gt;__next__()&lt;/code&gt; &lt;/a&gt; 메소드를 호출하십시오 . 새로운 값이 나오면 스택에 밀어 넣으십시오 (반복자를 아래에 두십시오). 반복자가 소진되었음을 표시하면 TOS가 팝되고 바이트 코드 카운터가 &lt;em&gt;delta&lt;/em&gt; 만큼 증가합니다 .</target>
        </trans-unit>
        <trans-unit id="6518048fef935aa22f2005310f203a44163eed2f" translate="yes" xml:space="preserve">
          <source>TOS is result of &lt;code&gt;__exit__()&lt;/code&gt; or &lt;code&gt;__aexit__()&lt;/code&gt; function call pushed by &lt;a href=&quot;#opcode-WITH_CLEANUP_START&quot;&gt;&lt;code&gt;WITH_CLEANUP_START&lt;/code&gt;&lt;/a&gt;. SECOND is &lt;code&gt;None&lt;/code&gt; or an exception type (pushed when an exception has been raised).</source>
          <target state="translated">TOS는 &lt;code&gt;__aexit__()&lt;/code&gt; 의해 푸시 된 &lt;code&gt;__exit__()&lt;/code&gt; 또는 __aexit __ () 함수 호출의 &lt;a href=&quot;#opcode-WITH_CLEANUP_START&quot;&gt; &lt;code&gt;WITH_CLEANUP_START&lt;/code&gt; &lt;/a&gt; 입니다. SECOND는 &lt;code&gt;None&lt;/code&gt; 또는 예외 유형입니다 (예외가 발생하면 푸시 됨).</target>
        </trans-unit>
        <trans-unit id="fe06eb6459c87f0e497ce1805f076f104bfecf78" translate="yes" xml:space="preserve">
          <source>Tab</source>
          <target state="translated">Tab</target>
        </trans-unit>
        <trans-unit id="4184dd72104948d4639fb02992b945838da9b7f6" translate="yes" xml:space="preserve">
          <source>Tab Identifiers</source>
          <target state="translated">탭 식별자</target>
        </trans-unit>
        <trans-unit id="ed8e6b927b4b9b1d5b371f2cbda818df4e9c2773" translate="yes" xml:space="preserve">
          <source>Tab Options</source>
          <target state="translated">탭 옵션</target>
        </trans-unit>
        <trans-unit id="51f3a2b97c44b6a3c489db9429828e97e0f34041" translate="yes" xml:space="preserve">
          <source>TabError</source>
          <target state="translated">TabError</target>
        </trans-unit>
        <trans-unit id="2206975a0bc82674c0da51c6c27096e7cdc13c17" translate="yes" xml:space="preserve">
          <source>Tabify Region</source>
          <target state="translated">지역화</target>
        </trans-unit>
        <trans-unit id="5c5654cdd4ba7e4325c694865e3aa84d89b76f3e" translate="yes" xml:space="preserve">
          <source>Tabular ListBox</source>
          <target state="translated">표 목록 상자</target>
        </trans-unit>
        <trans-unit id="15acd88369228a7f1fe88365876d812d72d0097e" translate="yes" xml:space="preserve">
          <source>Tag Options</source>
          <target state="translated">태그 옵션</target>
        </trans-unit>
        <trans-unit id="e301d53adc28f8dfd9375071aa503322cf99bba4" translate="yes" xml:space="preserve">
          <source>Tajik</source>
          <target state="translated">Tajik</target>
        </trans-unit>
        <trans-unit id="0f61aa9290c984334ded57f6b79fcd7a9c37e221" translate="yes" xml:space="preserve">
          <source>Take a key value &lt;em&gt;ch&lt;/em&gt;, and return &lt;code&gt;True&lt;/code&gt; if the current terminal type recognizes a key with that value.</source>
          <target state="translated">키 값 &lt;em&gt;ch를&lt;/em&gt; 가져 와서 현재 터미널 유형이 해당 값을 가진 키를 인식하면 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="a1bf82aa7514021d06d60729000a11f5c6462fa9" translate="yes" xml:space="preserve">
          <source>Take a snapshot of traces of memory blocks allocated by Python. Return a new &lt;a href=&quot;#tracemalloc.Snapshot&quot;&gt;&lt;code&gt;Snapshot&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">파이썬이 할당 한 미량의 메모리 블록의 스냅 샷을 만듭니다. 새로운 &lt;a href=&quot;#tracemalloc.Snapshot&quot;&gt; &lt;code&gt;Snapshot&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="5b3da8de64c814d9b3266a7876910cf8fa78ebd3" translate="yes" xml:space="preserve">
          <source>Take two (non complex) numbers as arguments and return a pair of numbers consisting of their quotient and remainder when using integer division. With mixed operand types, the rules for binary arithmetic operators apply. For integers, the result is the same as &lt;code&gt;(a // b, a % b)&lt;/code&gt;. For floating point numbers the result is &lt;code&gt;(q, a % b)&lt;/code&gt;, where &lt;em&gt;q&lt;/em&gt; is usually &lt;code&gt;math.floor(a /
b)&lt;/code&gt; but may be 1 less than that. In any case &lt;code&gt;q * b + a % b&lt;/code&gt; is very close to &lt;em&gt;a&lt;/em&gt;, if &lt;code&gt;a % b&lt;/code&gt; is non-zero it has the same sign as &lt;em&gt;b&lt;/em&gt;, and &lt;code&gt;0
&amp;lt;= abs(a % b) &amp;lt; abs(b)&lt;/code&gt;.</source>
          <target state="translated">정수 나눗셈을 사용할 때 두 개의 (비 복잡한) 숫자를 인수로 취하고 몫과 나머지로 구성된 한 쌍의 숫자를 반환합니다. 피연산자 유형이 혼합 된 경우 이진 산술 연산자에 대한 규칙이 적용됩니다. 정수의 경우 결과는 &lt;code&gt;(a // b, a % b)&lt;/code&gt; . 부동 소수점 숫자의 경우 결과는 &lt;code&gt;(q, a % b)&lt;/code&gt; . 여기서 &lt;em&gt;q&lt;/em&gt; 는 일반적으로 &lt;code&gt;math.floor(a / b)&lt;/code&gt; 이지만 1보다 작을 수 있습니다. 모든 경우에서 &lt;code&gt;q * b + a % b&lt;/code&gt; 매우 가까운 것이다 경우 &lt;code&gt;a % b&lt;/code&gt; 인이 같은 부호 갖는 비제로 &lt;em&gt;(B)을&lt;/em&gt; , 그리고 &lt;code&gt;0 &amp;lt;= abs(a % b) &amp;lt; abs(b)&lt;/code&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b550fa31fa155f09d009498f80c69ed7a5f7214" translate="yes" xml:space="preserve">
          <source>Take two snapshots and display the differences:</source>
          <target state="translated">두 개의 스냅 샷을 작성하고 차이점을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="7ef7f5d9e4af8c0c66f8e8f30af4e07e8b357199" translate="yes" xml:space="preserve">
          <source>Takes a descriptor and returns whenever there is data available to read</source>
          <target state="translated">디스크립터를 가져와 읽을 수있는 데이터가있을 때마다 리턴</target>
        </trans-unit>
        <trans-unit id="29dd968868abb9574902a11a99e959b2c749985b" translate="yes" xml:space="preserve">
          <source>Takes a descriptor and returns whenever there is data available to write</source>
          <target state="translated">디스크립터를 가져와 쓸 수있는 데이터가있을 때마다 리턴</target>
        </trans-unit>
        <trans-unit id="f364904f9bca83617ee18d0f66b705bf631e1470" translate="yes" xml:space="preserve">
          <source>Takes a producer object and adds it to the producer queue associated with the channel. When all currently-pushed producers have been exhausted the channel will consume this producer&amp;rsquo;s data by calling its &lt;code&gt;more()&lt;/code&gt; method and send the data to the remote endpoint.</source>
          <target state="translated">제작자 객체를 가져 와서 채널과 연결된 제작자 대기열에 추가합니다. 현재 푸시 된 모든 생산자가 소진되면 채널은 &lt;code&gt;more()&lt;/code&gt; 메소드 를 호출하여이 생산자의 데이터를 소비 하고 데이터를 원격 엔드 포인트로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="ff928e238afcf6f2cd7cd54fb1287dd9d8cf9798" translate="yes" xml:space="preserve">
          <source>Takes an instance &lt;code&gt;sock&lt;/code&gt; of &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt;, and returns an instance of &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;ssl.SSLSocket&lt;/code&gt;&lt;/a&gt;, a subtype of &lt;a href=&quot;socket#socket.socket&quot;&gt;&lt;code&gt;socket.socket&lt;/code&gt;&lt;/a&gt;, which wraps the underlying socket in an SSL context. &lt;code&gt;sock&lt;/code&gt; must be a &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt; socket; other socket types are unsupported.</source>
          <target state="translated">인스턴스 걸린다 &lt;code&gt;sock&lt;/code&gt; 의 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; 를&lt;/a&gt; , 그리고 인스턴스를 반환 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;ssl.SSLSocket&lt;/code&gt; &lt;/a&gt; 의 하위 유형 &lt;a href=&quot;socket#socket.socket&quot;&gt; &lt;code&gt;socket.socket&lt;/code&gt; &lt;/a&gt; 의 SSL 맥락에서 기본 소켓을 래핑. &lt;code&gt;sock&lt;/code&gt; 은 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 소켓 이어야합니다 . 다른 소켓 유형은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34d6d23eb55d67c76ef90341b26b6e54587f6d13" translate="yes" xml:space="preserve">
          <source>Takes an optional &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;&lt;em&gt;fp&lt;/em&gt;, which is ignored by the base class. Initializes &amp;ldquo;protected&amp;rdquo; instance variables &lt;em&gt;_info&lt;/em&gt; and &lt;em&gt;_charset&lt;/em&gt; which are set by derived classes, as well as &lt;em&gt;_fallback&lt;/em&gt;, which is set through &lt;a href=&quot;#gettext.NullTranslations.add_fallback&quot;&gt;&lt;code&gt;add_fallback()&lt;/code&gt;&lt;/a&gt;. It then calls &lt;code&gt;self._parse(fp)&lt;/code&gt; if &lt;em&gt;fp&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">선택적인 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체 &lt;/a&gt;&lt;em&gt;fp&lt;/em&gt; 를 가져옵니다.이 클래스는 기본 클래스에서 무시됩니다. 를 초기화 &quot;보호&quot;인스턴스 변수 &lt;em&gt;_info&lt;/em&gt; 및 &lt;em&gt;_charset&lt;/em&gt; 파생 클래스뿐만 아니라 설정되어 &lt;em&gt;_fallback&lt;/em&gt; 통해 설정된다 &lt;a href=&quot;#gettext.NullTranslations.add_fallback&quot;&gt; &lt;code&gt;add_fallback()&lt;/code&gt; &lt;/a&gt; . 그런 다음 &lt;em&gt;fp&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;self._parse(fp)&lt;/code&gt; 를 호출합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8b4636270f85b3fbf49ec462c18c732c12489509" translate="yes" xml:space="preserve">
          <source>Takes no action.</source>
          <target state="translated">조치를 취하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d44c8bec65a784d54741226d3313e62820c0d3c0" translate="yes" xml:space="preserve">
          <source>Takes the logging configuration from a dictionary. The contents of this dictionary are described in &lt;a href=&quot;#logging-config-dictschema&quot;&gt;Configuration dictionary schema&lt;/a&gt; below.</source>
          <target state="translated">사전에서 로깅 구성을 가져옵니다. 이 사전의 내용은 아래 &lt;a href=&quot;#logging-config-dictschema&quot;&gt;구성 사전 스키마에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b24523566c5e88f7857c12583bae9db24b5f7ff" translate="yes" xml:space="preserve">
          <source>TarFile Objects</source>
          <target state="translated">TarFile 객체</target>
        </trans-unit>
        <trans-unit id="338ec1e68af6f6ecd45d04f6ae39977241f13226" translate="yes" xml:space="preserve">
          <source>TarInfo Objects</source>
          <target state="translated">TarInfo 객체</target>
        </trans-unit>
        <trans-unit id="df740b79240b1ed7d5039a52848bff953794ae64" translate="yes" xml:space="preserve">
          <source>Task Object</source>
          <target state="translated">작업 객체</target>
        </trans-unit>
        <trans-unit id="76ff5d606073755c34a850d78d36a327964fe96b" translate="yes" xml:space="preserve">
          <source>Task object.</source>
          <target state="translated">작업 개체.</target>
        </trans-unit>
        <trans-unit id="090ec5f560fc50377fcd95e5cda128e91b276e98" translate="yes" xml:space="preserve">
          <source>Tasks</source>
          <target state="translated">Tasks</target>
        </trans-unit>
        <trans-unit id="b518979fdc61af5116b8c56f428e81decb342dd2" translate="yes" xml:space="preserve">
          <source>Tasks and Futures</source>
          <target state="translated">과제와 미래</target>
        </trans-unit>
        <trans-unit id="c06119a570c94693c9d4d0837718d89596fcbf13" translate="yes" xml:space="preserve">
          <source>Tasks are used to run coroutines in event loops. If a coroutine awaits on a Future, the Task suspends the execution of the coroutine and waits for the completion of the Future. When the Future is &lt;em&gt;done&lt;/em&gt;, the execution of the wrapped coroutine resumes.</source>
          <target state="translated">작업은 이벤트 루프에서 코 루틴을 실행하는 데 사용됩니다. 코 루틴이 미래를 기다리는 경우, 태스크는 코 루틴 실행을 일시 중단하고 미래의 완료를 기다립니다. 미래가 &lt;em&gt;완료&lt;/em&gt; 되면 랩핑 된 코 루틴 실행이 재개됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad2539642036f28e8b61b0f9b6d99c5a5830bd2" translate="yes" xml:space="preserve">
          <source>Tasks awaiting on &lt;a href=&quot;asyncio-task#asyncio.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; will now block until the &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method is called again.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 에서 대기 중인 작업 은 이제 &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메소드가 다시 호출 될 때까지 차단 됩니다.</target>
        </trans-unit>
        <trans-unit id="81a5cbff1d85f3a27872443b815bea858276d844" translate="yes" xml:space="preserve">
          <source>Tasks support the &lt;a href=&quot;contextvars#module-contextvars&quot;&gt;&lt;code&gt;contextvars&lt;/code&gt;&lt;/a&gt; module. When a Task is created it copies the current context and later runs its coroutine in the copied context.</source>
          <target state="translated">작업은 &lt;a href=&quot;contextvars#module-contextvars&quot;&gt; &lt;code&gt;contextvars&lt;/code&gt; &lt;/a&gt; 모듈을 지원합니다 . 작업이 생성되면 현재 컨텍스트를 복사하고 나중에 복사 된 컨텍스트에서 해당 코 루틴을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="c851c0b9d4006555fe7f3404359f227c45d9d618" translate="yes" xml:space="preserve">
          <source>Tcl and the Tk Toolkit</source>
          <target state="translated">Tcl과 Tk 툴킷</target>
        </trans-unit>
        <trans-unit id="43a5e042b92461e70adb58a52473afadf173f803" translate="yes" xml:space="preserve">
          <source>Tcl&amp;rsquo;2004 conference presentation</source>
          <target state="translated">Tcl'2004 컨퍼런스 프레젠테이션</target>
        </trans-unit>
        <trans-unit id="4ad4a8a864c413b47f4e059d9acf57f436c5a7c4" translate="yes" xml:space="preserve">
          <source>Tcl/Tk documentation:</source>
          <target state="translated">Tcl / Tk 설명서 :</target>
        </trans-unit>
        <trans-unit id="a3403aac734e1750dc5ff0e3802a01f145f5a272" translate="yes" xml:space="preserve">
          <source>Tcl/Tk recent man pages</source>
          <target state="translated">Tcl / Tk 최근 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="d158527ef8c2142b4c46d702046ebf260285bd9e" translate="yes" xml:space="preserve">
          <source>Technical Detail</source>
          <target state="translated">기술적 세부 사항</target>
        </trans-unit>
        <trans-unit id="aa834a46f3cebd900ddb52e6657f6cf355273c46" translate="yes" xml:space="preserve">
          <source>Technically, the returned distribution metadata object is an &lt;a href=&quot;https://docs.python.org/3/library/email.message.html#email.message.EmailMessage&quot;&gt;email.message.Message&lt;/a&gt; instance, but this is an implementation detail, and not part of the stable API. You should only use dictionary-like methods and syntax to access the metadata contents.</source>
          <target state="translated">기술적으로, 리턴 된 분배 메타 데이터 오브젝트는 &lt;a href=&quot;https://docs.python.org/3/library/email.message.html#email.message.EmailMessage&quot;&gt;email.message.Message&lt;/a&gt; 인스턴스이지만 이는 안정적인 API의 일부가 아닌 구현 세부 사항입니다. 메타 데이터 컨텐츠에 액세스하려면 사전과 유사한 메소드 및 구문 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3ea0075bea730eec77b806506f32f0d381fcc64b" translate="yes" xml:space="preserve">
          <source>Tell Turtle&amp;rsquo;s state</source>
          <target state="translated">터틀의 상태를 알려주세요</target>
        </trans-unit>
        <trans-unit id="57c9fa98eae32bb5e5b49439a7536aa770d066a7" translate="yes" xml:space="preserve">
          <source>Tell the &lt;a href=&quot;#socketserver.BaseServer.serve_forever&quot;&gt;&lt;code&gt;serve_forever()&lt;/code&gt;&lt;/a&gt; loop to stop and wait until it does.</source>
          <target state="translated">에게 &lt;a href=&quot;#socketserver.BaseServer.serve_forever&quot;&gt; &lt;code&gt;serve_forever()&lt;/code&gt; &lt;/a&gt; 정류장에서 루프를하고 수행 할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="f6d6d31710ade58855c0e0dc2e38de65e346cb3d" translate="yes" xml:space="preserve">
          <source>Tell the driver that there is likely to be a pause in the output, making it possible for the device to handle the pause more intelligently. You might use this after playing a spot sound effect, before waiting for user input, or before doing disk I/O.</source>
          <target state="translated">출력에 일시 정지가있을 가능성이 있음을 드라이버에 알리면 장치가보다 지능적으로 일시 정지를 처리 ​​할 수 ​​있습니다. 스팟 사운드 효과를 재생 한 후, 사용자 입력을 기다리거나 디스크 I / O를 수행하기 전에이 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="979f0c58a42b6ec68148003150326a19672c0c06" translate="yes" xml:space="preserve">
          <source>Tells the logging system to use the class &lt;em&gt;klass&lt;/em&gt; when instantiating a logger. The class should define &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; such that only a name argument is required, and the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; should call &lt;code&gt;Logger.__init__()&lt;/code&gt;. This function is typically called before any loggers are instantiated by applications which need to use custom logger behavior. After this call, as at any other time, do not instantiate loggers directly using the subclass: continue to use the &lt;a href=&quot;#logging.getLogger&quot;&gt;&lt;code&gt;logging.getLogger()&lt;/code&gt;&lt;/a&gt; API to get your loggers.</source>
          <target state="translated">클래스 사용하는 로깅 시스템에 지시 &lt;em&gt;KLASS을&lt;/em&gt; 로거를 인스턴스화 할 때입니다. 정의해야합니다 클래스 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 이름 만 인수가 필요하도록하고, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 를 호출해야 &lt;code&gt;Logger.__init__()&lt;/code&gt; . 이 함수는 일반적으로 사용자 정의 로거 동작을 사용해야하는 응용 프로그램에서 로거를 인스턴스화하기 전에 호출됩니다. 이 호출 후에는 다른 경우와 같이 서브 클래스를 사용하여 로거를 직접 인스턴스화하지 마십시오 . 로거를 가져 오려면 &lt;a href=&quot;#logging.getLogger&quot;&gt; &lt;code&gt;logging.getLogger()&lt;/code&gt; &lt;/a&gt; API를 계속 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ee4ea885f6bcb046b3f3aa350eedc6e6efae427" translate="yes" xml:space="preserve">
          <source>Telnet Example</source>
          <target state="translated">텔넷 예</target>
        </trans-unit>
        <trans-unit id="986434a39af28397b35384c75e8a00e8ea6b0648" translate="yes" xml:space="preserve">
          <source>Telnet Objects</source>
          <target state="translated">텔넷 객체</target>
        </trans-unit>
        <trans-unit id="78c16f64ddfd962c1a4af200be96953360f3c35a" translate="yes" xml:space="preserve">
          <source>Template Objects</source>
          <target state="translated">템플릿 객체</target>
        </trans-unit>
        <trans-unit id="e3efa6f36d852abc780df7bdacccc378b52ac40e" translate="yes" xml:space="preserve">
          <source>Template objects following methods:</source>
          <target state="translated">메소드를 따르는 템플리트 오브젝트 :</target>
        </trans-unit>
        <trans-unit id="dc68610743d7021a571f80b8ceb084cbd65c3e6a" translate="yes" xml:space="preserve">
          <source>Template strings</source>
          <target state="translated">템플릿 문자열</target>
        </trans-unit>
        <trans-unit id="5a89087fcb3dbd31fb0209ea648ced885e6487d2" translate="yes" xml:space="preserve">
          <source>Template strings provide simpler string substitutions as described in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0292&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;PEP 292&lt;/strong&gt;&lt;/a&gt;. A primary use case for template strings is for internationalization (i18n) since in that context, the simpler syntax and functionality makes it easier to translate than other built-in string formatting facilities in Python. As an example of a library built on template strings for i18n, see the &lt;a href=&quot;http://flufli18n.readthedocs.io/en/latest/&quot;&gt;flufl.i18n&lt;/a&gt; package.</source>
          <target state="translated">템플릿 문자열은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0292&quot; id=&quot;index-10&quot;&gt;&lt;strong&gt;PEP 292에&lt;/strong&gt;&lt;/a&gt; 설명 된 것처럼 더 간단한 문자열 대체를 제공합니다 . 템플릿 문자열의 주요 사용 사례는 국제화 (i18n)에 대한 것입니다. 그 맥락에서 구문과 기능이 단순 해 파이썬의 다른 내장 문자열 형식화 기능보다 쉽게 ​​번역 할 수 있습니다. i18n 용 템플릿 문자열을 기반으로하는 라이브러리의 예로 &lt;a href=&quot;http://flufli18n.readthedocs.io/en/latest/&quot;&gt;flufl.i18n&lt;/a&gt; 패키지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a9deb261f9b2f4d0f7eded9969ecdd7d5833596" translate="yes" xml:space="preserve">
          <source>Template strings support &lt;code&gt;$&lt;/code&gt;-based substitutions, using the following rules:</source>
          <target state="translated">템플릿 문자열 은 다음 규칙을 사용하여 &lt;code&gt;$&lt;/code&gt; 기반 대체를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="0947e54aa814a89db0132f2a3a8abba379ef8ac5" translate="yes" xml:space="preserve">
          <source>Temporarily Suppressing Warnings</source>
          <target state="translated">일시적인 경고 억제</target>
        </trans-unit>
        <trans-unit id="fb0de27eea1e97b394b820d91ec3fc9180ea1196" translate="yes" xml:space="preserve">
          <source>Temporarily set the environment variable &lt;code&gt;envvar&lt;/code&gt; to the value of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">임시 환경 변수 설정 &lt;code&gt;envvar&lt;/code&gt; 의 값 &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c6165ec5ae55f10e836365e531adb4499b9792f" translate="yes" xml:space="preserve">
          <source>Temporarily sets the current theme to &lt;em&gt;themename&lt;/em&gt;, apply specified &lt;em&gt;settings&lt;/em&gt; and then restore the previous theme.</source>
          <target state="translated">현재 테마를 &lt;em&gt;themename으로&lt;/em&gt; 임시 설정하고 지정된 &lt;em&gt;설정을&lt;/em&gt; 적용한 후 이전 테마를 복원하십시오.</target>
        </trans-unit>
        <trans-unit id="f9891b3e90ff69ceb72b7031cf9b6011e339fc99" translate="yes" xml:space="preserve">
          <source>Temporarily unset the environment variable &lt;code&gt;envvar&lt;/code&gt;.</source>
          <target state="translated">환경 변수 &lt;code&gt;envvar&lt;/code&gt; 를 임시로 설정 해제하십시오 .</target>
        </trans-unit>
        <trans-unit id="69631d1cc986e660695cb30ca0598a3183aa39ab" translate="yes" xml:space="preserve">
          <source>Temporary breakpoint, which is removed automatically when it is first hit. The arguments are the same as for &lt;a href=&quot;#pdbcommand-break&quot;&gt;&lt;code&gt;break&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">임시 중단 점. 처음 도달하면 자동으로 제거됩니다. 인수는 &lt;a href=&quot;#pdbcommand-break&quot;&gt; &lt;code&gt;break&lt;/code&gt; &lt;/a&gt; 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="714a4b8e0ad4f7e2f284e3700b61738448e85029" translate="yes" xml:space="preserve">
          <source>Terminal elements are represented in much the same way, but without any child elements and the addition of the source text which was identified. The example of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; keyword above is representative. The various types of terminal symbols are defined in the C header file &lt;code&gt;Include/token.h&lt;/code&gt; and the Python module &lt;a href=&quot;token#module-token&quot;&gt;&lt;code&gt;token&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">터미널 요소는 거의 같은 방식으로 표시되지만 자식 요소가없고 식별 된 소스 텍스트가 추가되지 않습니다. 위 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 키워드 의 예가 대표적입니다. 다양한 유형의 터미널 기호는 C 헤더 파일 &lt;code&gt;Include/token.h&lt;/code&gt; 및 Python 모듈 &lt;a href=&quot;token#module-token&quot;&gt; &lt;code&gt;token&lt;/code&gt; &lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f5954e9ee331c9765fcb2626ab0eea8827305bb" translate="yes" xml:space="preserve">
          <source>Terminal resize event</source>
          <target state="translated">터미널 크기 조정 이벤트</target>
        </trans-unit>
        <trans-unit id="072eb39d82843db4dd7fa61737a180b6aeb46526" translate="yes" xml:space="preserve">
          <source>Terminate if the window is 1 line, otherwise insert newline.</source>
          <target state="translated">창이 한 줄이면 종료하고 그렇지 않으면 줄 바꿈을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="fd033bc9a5266b01e8d52bb455c0d01450f65fe0" translate="yes" xml:space="preserve">
          <source>Terminate the SMTP session and close the connection. Return the result of the SMTP &lt;code&gt;QUIT&lt;/code&gt; command.</source>
          <target state="translated">SMTP 세션을 종료하고 연결을 닫습니다. SMTP &lt;code&gt;QUIT&lt;/code&gt; 명령 의 결과를 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="56021beb31597eb1df8180161a2353ef1babbdef" translate="yes" xml:space="preserve">
          <source>Terminate the process. On Unix this is done using the &lt;code&gt;SIGTERM&lt;/code&gt; signal; on Windows &lt;code&gt;TerminateProcess()&lt;/code&gt; is used. Note that exit handlers and finally clauses, etc., will not be executed.</source>
          <target state="translated">프로세스를 종료하십시오. Unix에서는 &lt;code&gt;SIGTERM&lt;/code&gt; 신호를 사용하여 수행됩니다 . Windows에서는 &lt;code&gt;TerminateProcess()&lt;/code&gt; 가 사용됩니다. 종료 처리기 및 finally 절 등은 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="180e106003e06373ecda6bf07c34be4f01515a40" translate="yes" xml:space="preserve">
          <source>Terminate, returning the window contents.</source>
          <target state="translated">종료하고 창 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="573640e028ca71d2e1a5f91f98a1da47339051c3" translate="yes" xml:space="preserve">
          <source>Terminates a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; clause. The interpreter recalls whether the exception has to be re-raised or execution has to be continued depending on the value of TOS.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 절을 종료합니다 . 통역사는 TOS의 가치에 따라 예외를 다시 제기해야하는지 또는 실행을 계속해야하는지 기억합니다.</target>
        </trans-unit>
        <trans-unit id="a6f331fdf9d1e91ec6c3749198d30191ebd4b47c" translate="yes" xml:space="preserve">
          <source>Terminates an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-for&quot;&gt;&lt;code&gt;async for&lt;/code&gt;&lt;/a&gt; loop. Handles an exception raised when awaiting a next item. If TOS is &lt;a href=&quot;exceptions#StopAsyncIteration&quot;&gt;&lt;code&gt;StopAsyncIteration&lt;/code&gt;&lt;/a&gt; pop 7 values from the stack and restore the exception state using the second three of them. Otherwise re-raise the exception using the three values from the stack. An exception handler block is removed from the block stack.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#async-for&quot;&gt; &lt;code&gt;async for&lt;/code&gt; &lt;/a&gt; 루프를 종료합니다 . 다음 항목을 기다릴 때 발생하는 예외를 처리합니다. TOS가 &lt;a href=&quot;exceptions#StopAsyncIteration&quot;&gt; &lt;code&gt;StopAsyncIteration&lt;/code&gt; 인&lt;/a&gt; 경우 스택에서 7 개의 값을 팝하고 두 번째 값을 사용하여 예외 상태를 복원하십시오. 그렇지 않으면 스택에서 세 값을 사용하여 예외를 다시 발생시킵니다. 예외 처리기 블록이 블록 스택에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="56a0877f18348cf0be96e625fedb6746aeee4fd0" translate="yes" xml:space="preserve">
          <source>Test &lt;em&gt;x&lt;/em&gt; for membership in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">테스트는 &lt;em&gt;X&lt;/em&gt; 의 회원 &lt;em&gt;들&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5463ef35f9a17bd79bc9011c028c2e5fc9f65e5f" translate="yes" xml:space="preserve">
          <source>Test &lt;em&gt;x&lt;/em&gt; for non-membership in &lt;em&gt;s&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;s의&lt;/em&gt; 비회원 자격에 대해 &lt;em&gt;x&lt;/em&gt; 를 테스트합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eb6fdd2e9dab95cad6f2778f0163bd3ef28d1d0e" translate="yes" xml:space="preserve">
          <source>Test Discovery</source>
          <target state="translated">테스트 발견</target>
        </trans-unit>
        <trans-unit id="ab7ed7054249cf37446be8e0a0b5203982c7e901" translate="yes" xml:space="preserve">
          <source>Test Driven Development</source>
          <target state="translated">테스트 주도 개발</target>
        </trans-unit>
        <trans-unit id="5bdbfab66783753cdeb866267c3e01eab16087f3" translate="yes" xml:space="preserve">
          <source>Test cases</source>
          <target state="translated">테스트 사례</target>
        </trans-unit>
        <trans-unit id="f786dd8c58ee071092250227304be11a0ce508ee" translate="yes" xml:space="preserve">
          <source>Test code should be modified much less frequently than the code it tests.</source>
          <target state="translated">테스트 코드는 테스트하는 코드보다 훨씬 덜 수정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b3c54db43b5f25ef6cbe415cd8d28c97adca5c02" translate="yes" xml:space="preserve">
          <source>Test discovery is implemented in &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt;&lt;code&gt;TestLoader.discover()&lt;/code&gt;&lt;/a&gt;, but can also be used from the command line. The basic command-line usage is:</source>
          <target state="translated">테스트 발견은 &lt;a href=&quot;#unittest.TestLoader.discover&quot;&gt; &lt;code&gt;TestLoader.discover()&lt;/code&gt; &lt;/a&gt; 에서 구현 되지만 명령 행에서도 사용할 수 있습니다. 기본 명령 줄 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae6fc69df923b84e706cb7874cf768d1ea87acab" translate="yes" xml:space="preserve">
          <source>Test discovery loads tests by importing them. Once test discovery has found all the test files from the start directory you specify it turns the paths into package names to import. For example &lt;code&gt;foo/bar/baz.py&lt;/code&gt; will be imported as &lt;code&gt;foo.bar.baz&lt;/code&gt;.</source>
          <target state="translated">테스트 감지는 테스트를 가져 와서로드합니다. 테스트 발견이 시작 디렉토리에서 모든 테스트 파일을 찾으면 지정한 경로를 패키지 이름으로 가져 와서 가져옵니다. 예를 들어 &lt;code&gt;foo/bar/baz.py&lt;/code&gt; 는 &lt;code&gt;foo.bar.baz&lt;/code&gt; 로 가져 옵니다 .</target>
        </trans-unit>
        <trans-unit id="ac2618574421564be2711f0c9df7d88b7cb3369f" translate="yes" xml:space="preserve">
          <source>Test examples associated with object &lt;em&gt;f&lt;/em&gt;; for example, &lt;em&gt;f&lt;/em&gt; may be a string, a module, a function, or a class object.</source>
          <target state="translated">객체 &lt;em&gt;f&lt;/em&gt; 와 관련된 테스트 예제 ; 예를 들어, &lt;em&gt;f&lt;/em&gt; 는 문자열, 모듈, 함수 또는 클래스 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fd9094d262fa8bc19984e455b37cda962b9dd52" translate="yes" xml:space="preserve">
          <source>Test examples in docstrings in functions and classes reachable from module &lt;em&gt;m&lt;/em&gt; (or module &lt;a href=&quot;__main__#module-__main__&quot;&gt;&lt;code&gt;__main__&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;m&lt;/em&gt; is not supplied or is &lt;code&gt;None&lt;/code&gt;), starting with &lt;code&gt;m.__doc__&lt;/code&gt;.</source>
          <target state="translated">함수와 클래스에 문서화 문자열의 시험 예는 모듈로부터 도달 &lt;em&gt;m&lt;/em&gt; (또는 모듈 &lt;a href=&quot;__main__#module-__main__&quot;&gt; &lt;code&gt;__main__&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;m은&lt;/em&gt; 제공되지되지 않았거나 &lt;code&gt;None&lt;/code&gt; 시작으로) &lt;code&gt;m.__doc__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8e11e0daab30f5e8535ab9421c43ae03c6ece4e" translate="yes" xml:space="preserve">
          <source>Test examples in the file named &lt;em&gt;filename&lt;/em&gt;. Return &lt;code&gt;(failure_count,
test_count)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 &lt;em&gt;파일의&lt;/em&gt; 예제를 테스트하십시오 . &lt;code&gt;(failure_count, test_count)&lt;/code&gt; 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fdc88bc9bdb7b33c186720ef5c4e0fd14d158bb" translate="yes" xml:space="preserve">
          <source>Test for syntax errors in &lt;em&gt;statement&lt;/em&gt; by attempting to compile &lt;em&gt;statement&lt;/em&gt;. &lt;em&gt;testcase&lt;/em&gt; is the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; instance for the test. &lt;em&gt;errtext&lt;/em&gt; is the regular expression which should match the string representation of the raised &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;lineno&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, compares to the line of the exception. If &lt;em&gt;offset&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, compares to the offset of the exception.</source>
          <target state="translated">에서 구문 오류에 대한 시험 &lt;em&gt;문&lt;/em&gt; 컴파일을 시도하여 &lt;em&gt;문을&lt;/em&gt; . &lt;em&gt;테스트 케이스는&lt;/em&gt; 은 IS &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트를위한 인스턴스입니다. &lt;em&gt;errtext&lt;/em&gt; 는 발생한 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 의 문자열 표현과 일치해야하는 정규식입니다 . &lt;em&gt;lineno&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 예외 줄과 비교합니다. &lt;em&gt;offset&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 예외의 오프셋과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="c4235725b64e90a6f1d7737e25022f2edd399fe5" translate="yes" xml:space="preserve">
          <source>Test for syntax warning in &lt;em&gt;statement&lt;/em&gt; by attempting to compile &lt;em&gt;statement&lt;/em&gt;. Test also that the &lt;a href=&quot;exceptions#SyntaxWarning&quot;&gt;&lt;code&gt;SyntaxWarning&lt;/code&gt;&lt;/a&gt; is emitted only once, and that it will be converted to a &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt; when turned into error. &lt;em&gt;testcase&lt;/em&gt; is the &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; instance for the test. &lt;em&gt;errtext&lt;/em&gt; is the regular expression which should match the string representation of the emitted &lt;a href=&quot;exceptions#SyntaxWarning&quot;&gt;&lt;code&gt;SyntaxWarning&lt;/code&gt;&lt;/a&gt; and raised &lt;a href=&quot;exceptions#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;lineno&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, compares to the line of the warning and exception. If &lt;em&gt;offset&lt;/em&gt; is not &lt;code&gt;None&lt;/code&gt;, compares to the offset of the exception.</source>
          <target state="translated">에서 구문 경고에 대한 시험 &lt;em&gt;문&lt;/em&gt; 컴파일을 시도하여 &lt;em&gt;문을&lt;/em&gt; . &lt;a href=&quot;exceptions#SyntaxWarning&quot;&gt; &lt;code&gt;SyntaxWarning&lt;/code&gt; &lt;/a&gt; 이 한 번만 방출 되고 오류로 전환되면 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 로 변환 되는지 테스트하십시오 . &lt;em&gt;테스트 케이스는&lt;/em&gt; 은 IS &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트를위한 인스턴스입니다. &lt;em&gt;errtext&lt;/em&gt; 는 생성 된 &lt;a href=&quot;exceptions#SyntaxWarning&quot;&gt; &lt;code&gt;SyntaxWarning&lt;/code&gt; &lt;/a&gt; 의 문자열 표현과 일치하는 &lt;a href=&quot;exceptions#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 와 일치해야하는 정규식입니다 . &lt;em&gt;lineno&lt;/em&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 경고 및 예외 줄과 비교합니다. &lt;em&gt;오프셋&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우예외의 오프셋과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e8e482572a6e2a0b7cec6b7a36589209058e88d1" translate="yes" xml:space="preserve">
          <source>Test modules and packages can customize test loading and discovery by through the &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests protocol&lt;/a&gt;.</source>
          <target state="translated">테스트 모듈 및 패키지는 &lt;a href=&quot;#load-tests-protocol&quot;&gt;load_tests 프로토콜&lt;/a&gt; 을 통해 테스트로드 및 검색을 사용자 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1fe477cac5445537b9dc7ac19f68f459535df4a3" translate="yes" xml:space="preserve">
          <source>Test modules can be specified by file path as well:</source>
          <target state="translated">테스트 모듈은 파일 경로로도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="51c68a35f2582d9e248723342ef0b4d3c4ab9a13" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;expr&lt;/em&gt; is (or is not) &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;expr&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 인지 아닌지를 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="09baf90b22e7f8fe91854aa6e1a470a4312b5398" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;expr&lt;/em&gt; is true (or false).</source>
          <target state="translated">&lt;em&gt;expr&lt;/em&gt; 이 true (또는 false)인지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="3736830b5e038d416279e9e6f5c58bc4301451f3" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; are approximately (or not approximately) equal by computing the difference, rounding to the given number of decimal &lt;em&gt;places&lt;/em&gt; (default 7), and comparing to zero. Note that these methods round the values to the given number of &lt;em&gt;decimal places&lt;/em&gt; (i.e. like the &lt;a href=&quot;functions#round&quot;&gt;&lt;code&gt;round()&lt;/code&gt;&lt;/a&gt; function) and not &lt;em&gt;significant digits&lt;/em&gt;.</source>
          <target state="translated">차이를 계산하고 주어진 소수점 이하 &lt;em&gt;자릿수로&lt;/em&gt; 반올림하고 (기본값 7) 0과 비교하여 &lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 대략 (또는 대략 같지 않음) 테스트합니다 . 이 메소드는 &lt;em&gt;유효 자릿수가&lt;/em&gt; 아닌 지정된 &lt;em&gt;소수 자릿수&lt;/em&gt; (예 : &lt;a href=&quot;functions#round&quot;&gt; &lt;code&gt;round()&lt;/code&gt; &lt;/a&gt; 함수)로 값을 반올림합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="08f1d05ada5fc1ff6126334b279a2a1edfe50b8c" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; are equal. If the values do not compare equal, the test will fail.</source>
          <target state="translated">&lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 같은지 테스트하십시오 . 값이 같지 않으면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3ee894a74d8ec94f5ae9d3bcfca07533d6dd5eaf" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; are not equal. If the values do compare equal, the test will fail.</source>
          <target state="translated">테스트 &lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 같지 않은지 . 값이 동일하게 비교되면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="0fd50d60f4aebeb0a25dcb9e5609c7f8246051b3" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; evaluate (or don&amp;rsquo;t evaluate) to the same object.</source>
          <target state="translated">&lt;em&gt;첫 번째&lt;/em&gt; 와 &lt;em&gt;두 번째&lt;/em&gt; 가 동일한 개체를 평가하는지 (또는 평가하지 않는지) 테스트 합니다.</target>
        </trans-unit>
        <trans-unit id="9a1cf6be14d0576501e4cf568a99625aa36624c7" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; is (or is not) in &lt;em&gt;second&lt;/em&gt;.</source>
          <target state="translated">테스트 &lt;em&gt;첫 번째&lt;/em&gt; 가 &lt;em&gt;두 번째&lt;/em&gt; 인지 아닌지 .</target>
        </trans-unit>
        <trans-unit id="9fab7717de343b5f61fcb12f39620674b0cf8da4" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;first&lt;/em&gt; is respectively &amp;gt;, &amp;gt;=, &amp;lt; or &amp;lt;= than &lt;em&gt;second&lt;/em&gt; depending on the method name. If not, the test will fail:</source>
          <target state="translated">테스트 &lt;em&gt; 제&lt;/em&gt; 각각이다&amp;gt;,&amp;gt; =, &amp;lt;또는 &amp;lt;=보다 &lt;em&gt;제&lt;/em&gt; 메소드 이름에 따라. 그렇지 않으면 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="758622e273eb447756fd82218de39fd9e387ffba" translate="yes" xml:space="preserve">
          <source>Test that &lt;em&gt;obj&lt;/em&gt; is (or is not) an instance of &lt;em&gt;cls&lt;/em&gt; (which can be a class or a tuple of classes, as supported by &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt;). To check for the exact type, use &lt;a href=&quot;#unittest.TestCase.assertIs&quot;&gt;&lt;code&gt;assertIs(type(obj), cls)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 &lt;em&gt;cls&lt;/em&gt; 의 인스턴스인지 아닌지 테스트합니다 ( &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 지원하는 클래스 또는 튜플 일 수 있음 ). ). 정확한 유형을 확인하려면 &lt;a href=&quot;#unittest.TestCase.assertIs&quot;&gt; &lt;code&gt;assertIs(type(obj), cls)&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e5a55f49dd7a534f8b2cf1e904ca582f1f5f129" translate="yes" xml:space="preserve">
          <source>Test that a &lt;em&gt;regex&lt;/em&gt; search matches (or does not match) &lt;em&gt;text&lt;/em&gt;. In case of failure, the error message will include the pattern and the &lt;em&gt;text&lt;/em&gt; (or the pattern and the part of &lt;em&gt;text&lt;/em&gt; that unexpectedly matched). &lt;em&gt;regex&lt;/em&gt; may be a regular expression object or a string containing a regular expression suitable for use by &lt;a href=&quot;re#re.search&quot;&gt;&lt;code&gt;re.search()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;정규식&lt;/em&gt; 검색이 &lt;em&gt;text&lt;/em&gt; 와 일치하는지 (또는 일치하지 않는지) 테스트 &lt;em&gt;하십시오&lt;/em&gt; . 실패한 경우 오류 메시지에 패턴 및 &lt;em&gt;텍스트&lt;/em&gt; (또는 예기치 않게 일치 한 패턴 및 &lt;em&gt;텍스트&lt;/em&gt; 부분 )가 포함됩니다. &lt;em&gt;정규식&lt;/em&gt; 정규식 객체 또는하여 사용하기에 적합한 정규 표현이 포함 된 문자열 일 수있다 &lt;a href=&quot;re#re.search&quot;&gt; &lt;code&gt;re.search()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="af0edbd1e9710f76fdbabc4e0b0bffc3e19f660e" translate="yes" xml:space="preserve">
          <source>Test that a warning is triggered when &lt;em&gt;callable&lt;/em&gt; is called with any positional or keyword arguments that are also passed to &lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt;&lt;code&gt;assertWarns()&lt;/code&gt;&lt;/a&gt;. The test passes if &lt;em&gt;warning&lt;/em&gt; is triggered and fails if it isn&amp;rsquo;t. Any exception is an error. To catch any of a group of warnings, a tuple containing the warning classes may be passed as &lt;em&gt;warnings&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertWarns&quot;&gt; &lt;code&gt;assertWarns()&lt;/code&gt; &lt;/a&gt; 전달되는 위치 또는 키워드 인수와 함께 &lt;em&gt;callable&lt;/em&gt; 이 호출 될 때 경고가 트리거되는지 테스트하십시오 . 테스트는 다음과 같은 경우에 통과합니다.&lt;em&gt; 경고&lt;/em&gt; 가 트리거 실패합니다. 모든 예외는 오류입니다. 경고의 그룹 중 하나를 잡으려고, 경고 클래스를 포함하는 튜플로 전달 될 수 있습니다 &lt;em&gt;경고&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7655599618476a611da3f9b310926487e95bca" translate="yes" xml:space="preserve">
          <source>Test that an exception is raised when &lt;em&gt;callable&lt;/em&gt; is called with any positional or keyword arguments that are also passed to &lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt;&lt;code&gt;assertRaises()&lt;/code&gt;&lt;/a&gt;. The test passes if &lt;em&gt;exception&lt;/em&gt; is raised, is an error if another exception is raised, or fails if no exception is raised. To catch any of a group of exceptions, a tuple containing the exception classes may be passed as &lt;em&gt;exception&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertRaises&quot;&gt; &lt;code&gt;assertRaises()&lt;/code&gt; &lt;/a&gt; 전달되는 위치 또는 키워드 인수로 &lt;em&gt;callable&lt;/em&gt; 이 호출 될 때 예외가 발생하는지 테스트하십시오 . 테스트는 다음과 같은 경우에 통과합니다.&lt;em&gt;예외&lt;/em&gt; 가 발생 다른 예외가 발생하면 오류가 발생하거나 예외가 발생하지 않으면 실패합니다. 예외의 그룹 중 하나를 잡기 위해, 예외 클래스를 포함하는 튜플로 전달 될 수 있습니다 &lt;em&gt;예외&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9369d81fe32ae88f220c14ff0fbb2c0171f7b74c" translate="yes" xml:space="preserve">
          <source>Test that sequence &lt;em&gt;first&lt;/em&gt; contains the same elements as &lt;em&gt;second&lt;/em&gt;, regardless of their order. When they don&amp;rsquo;t, an error message listing the differences between the sequences will be generated.</source>
          <target state="translated">그 순서를 &lt;em&gt;먼저&lt;/em&gt; 테스트하십시오&lt;em&gt;&lt;/em&gt; 에 관계없이&lt;em&gt; second&lt;/em&gt; 와 동일한 요소가 포함되어 . 그렇지 않은 경우 시퀀스 간의 차이를 나열하는 오류 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fd95d388e0bc9cfcb7e0be95b669bdc0516c58ce" translate="yes" xml:space="preserve">
          <source>Test that the multiline string &lt;em&gt;first&lt;/em&gt; is equal to the string &lt;em&gt;second&lt;/em&gt;. When not equal a diff of the two strings highlighting the differences will be included in the error message. This method is used by default when comparing strings with &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">테스트 여러 문자열은 &lt;em&gt;제&lt;/em&gt; 문자열 같다 &lt;em&gt;초&lt;/em&gt; . 같지 않으면 두 문자열의 차이가 강조 표시되어 오류 메시지에 포함됩니다. 이 방법은 문자열을 다음과 비교할 때 기본적으로 사용됩니다&lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="2a09605ab8c6b2346563311c688a8c06a6dbfc71" translate="yes" xml:space="preserve">
          <source>Test that two dictionaries are equal. If not, an error message is constructed that shows the differences in the dictionaries. This method will be used by default to compare dictionaries in calls to &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 사전이 같은지 테스트하십시오. 그렇지 않은 경우 사전의 차이점을 표시하는 오류 메시지가 구성됩니다. 이 메소드는 기본적으로 &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 호출에서 사전을 비교하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b4a7f4372cff07bb2871cfb34af58249fa008917" translate="yes" xml:space="preserve">
          <source>Test the widget&amp;rsquo;s state. If a callback is not specified, returns &lt;code&gt;True&lt;/code&gt; if the widget state matches &lt;em&gt;statespec&lt;/em&gt; and &lt;code&gt;False&lt;/code&gt; otherwise. If callback is specified then it is called with args if widget state matches &lt;em&gt;statespec&lt;/em&gt;.</source>
          <target state="translated">위젯 상태를 테스트하십시오. 콜백을 지정하지 않으면 위젯 상태가 &lt;em&gt;statespec&lt;/em&gt; 과 일치하면 &lt;code&gt;True&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환합니다. 콜백이 지정된 경우 위젯 상태가 &lt;em&gt;statespec&lt;/em&gt; 과 일치하면 args와 함께 호출됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3252a55c6d8b2b05365bf27eff7c204fbe5a8d0f" translate="yes" xml:space="preserve">
          <source>Test whether &lt;em&gt;filename&lt;/em&gt; matches &lt;em&gt;pattern&lt;/em&gt;, returning &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;; the comparison is case-sensitive and does not apply &lt;a href=&quot;os.path#os.path.normcase&quot;&gt;&lt;code&gt;os.path.normcase()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;filename이 &lt;/em&gt;&lt;em&gt;pattern&lt;/em&gt; 과 일치 하는지 테스트하여 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환합니다 . 비교는 대소 문자를 구분하며 &lt;a href=&quot;os.path#os.path.normcase&quot;&gt; &lt;code&gt;os.path.normcase()&lt;/code&gt; &lt;/a&gt; 적용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="1bbae1e68b4ab8b26adcd3775306845fefd99a62" translate="yes" xml:space="preserve">
          <source>Test whether every element in &lt;em&gt;other&lt;/em&gt; is in the set.</source>
          <target state="translated">&lt;em&gt;다른&lt;/em&gt; 모든 요소 가 세트 에 있는지 테스트 하십시오.</target>
        </trans-unit>
        <trans-unit id="f947d05a8e989c8b1556bb5a7ea38dede393dbe6" translate="yes" xml:space="preserve">
          <source>Test whether every element in the set is in &lt;em&gt;other&lt;/em&gt;.</source>
          <target state="translated">집합의 모든 요소가 &lt;em&gt;다른&lt;/em&gt; 요소인지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="2a8c5d283f0787819be784087bb6409980272a0e" translate="yes" xml:space="preserve">
          <source>Test whether self and other have the same exponent or whether both are &lt;code&gt;NaN&lt;/code&gt;.</source>
          <target state="translated">자기 지수와 다른 지수가 동일한 지 여부 또는 둘 다 &lt;code&gt;NaN&lt;/code&gt; 인지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="3637628b04fc850c896798d027ee4ca99b188b72" translate="yes" xml:space="preserve">
          <source>Test whether the &lt;em&gt;filename&lt;/em&gt; string matches the &lt;em&gt;pattern&lt;/em&gt; string, returning &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;. Both parameters are case-normalized using &lt;a href=&quot;os.path#os.path.normcase&quot;&gt;&lt;code&gt;os.path.normcase()&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#fnmatch.fnmatchcase&quot;&gt;&lt;code&gt;fnmatchcase()&lt;/code&gt;&lt;/a&gt; can be used to perform a case-sensitive comparison, regardless of whether that&amp;rsquo;s standard for the operating system.</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 문자열이 &lt;em&gt;패턴&lt;/em&gt; 문자열과 일치 하는지 테스트하여 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 를&lt;/a&gt; 반환 합니다. 두 매개 변수는 &lt;a href=&quot;os.path#os.path.normcase&quot;&gt; &lt;code&gt;os.path.normcase()&lt;/code&gt; &lt;/a&gt; 사용하여 대소 문자를 구분 합니다. &lt;a href=&quot;#fnmatch.fnmatchcase&quot;&gt; &lt;code&gt;fnmatchcase()&lt;/code&gt; &lt;/a&gt; 는 운영 체제의 표준 여부에 관계없이 대소 문자 구분을 비교하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee05867c711f322cfcfe9e76c439a43d28a27a4" translate="yes" xml:space="preserve">
          <source>Test whether the given pair of screen-relative character-cell coordinates are enclosed by the given window, returning &lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;. It is useful for determining what subset of the screen windows enclose the location of a mouse event.</source>
          <target state="translated">주어진 화면 기준 문자 셀 좌표 쌍이 주어진 창으로 둘러싸여 &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; 를 반환하는지 테스트합니다 . 마우스 창의 위치를 ​​에워싸는 화면 창의 하위 집합을 결정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="916b10a98c94b3646aca3f798189b9bf36bdb056" translate="yes" xml:space="preserve">
          <source>Test whether the set is a proper subset of &lt;em&gt;other&lt;/em&gt;, that is, &lt;code&gt;set &amp;lt;= other and set != other&lt;/code&gt;.</source>
          <target state="translated">세트가 &lt;em&gt;other&lt;/em&gt; 의 적절한 서브 세트인지 , 즉 &lt;code&gt;set &amp;lt;= other and set != other&lt;/code&gt; 인지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="d432513ee0123cd1a13733349fd041b83c5b1e43" translate="yes" xml:space="preserve">
          <source>Test whether the set is a proper superset of &lt;em&gt;other&lt;/em&gt;, that is, &lt;code&gt;set &amp;gt;=
other and set != other&lt;/code&gt;.</source>
          <target state="translated">세트가 &lt;em&gt;other&lt;/em&gt; 의 올바른 수퍼 세트인지 , 즉 &lt;code&gt;set &amp;gt;= other and set != other&lt;/code&gt; 인지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="0f23698d1ee41342775e72b59b793d4fa4ee7350" translate="yes" xml:space="preserve">
          <source>Test whether the tarfile is valid or not.</source>
          <target state="translated">tarfile이 유효한지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="1f73fcb0d952970335312a2670a1276fac62abe7" translate="yes" xml:space="preserve">
          <source>Test whether the zipfile is valid or not.</source>
          <target state="translated">zip 파일이 유효한지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="5a8150059a72c4f17d4247e501bd049f3fd08488" translate="yes" xml:space="preserve">
          <source>Tested code can be refactored more easily.</source>
          <target state="translated">테스트 된 코드를보다 쉽게 ​​리팩토링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61f38d1d8201f094a34ac329beb6d755ed79a79e" translate="yes" xml:space="preserve">
          <source>Testing Warnings</source>
          <target state="translated">테스트 경고</target>
        </trans-unit>
        <trans-unit id="cc43c151a25f111033e3c67c5282813bd0bb7c14" translate="yes" xml:space="preserve">
          <source>Testing for SSL support</source>
          <target state="translated">SSL 지원 테스트</target>
        </trans-unit>
        <trans-unit id="7b6553cde91fa3c13041b8a95dc60f532ab97659" translate="yes" xml:space="preserve">
          <source>Testing frameworks built on top of &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; may want access to the &lt;a href=&quot;#unittest.TestResult&quot;&gt;&lt;code&gt;TestResult&lt;/code&gt;&lt;/a&gt; object generated by running a set of tests for reporting purposes; a &lt;a href=&quot;#unittest.TestResult&quot;&gt;&lt;code&gt;TestResult&lt;/code&gt;&lt;/a&gt; instance is returned by the &lt;code&gt;TestRunner.run()&lt;/code&gt; method for this purpose.</source>
          <target state="translated">&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 위에 구축 된 테스트 프레임 워크 는보고 목적으로 일련의 테스트를 실행하여 생성 된 &lt;a href=&quot;#unittest.TestResult&quot;&gt; &lt;code&gt;TestResult&lt;/code&gt; &lt;/a&gt; 객체에 대한 액세스를 원할 수 있습니다 . 이를 위해 &lt;code&gt;TestRunner.run()&lt;/code&gt; 메소드 가 &lt;a href=&quot;#unittest.TestResult&quot;&gt; &lt;code&gt;TestResult&lt;/code&gt; &lt;/a&gt; 인스턴스를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="fe919eee0e3ca452b798ae6980b4e58c4af2b5a5" translate="yes" xml:space="preserve">
          <source>Testing frameworks can use the following methods to collect information on the test:</source>
          <target state="translated">테스트 프레임 워크는 다음 방법을 사용하여 테스트에 대한 정보를 수집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38686aaaf5fc5e003212208b9184a178fba7333f" translate="yes" xml:space="preserve">
          <source>Testing in Python Mailing List</source>
          <target state="translated">파이썬 메일 링리스트에서 테스트</target>
        </trans-unit>
        <trans-unit id="da11bed90e87fd7fb0fbcc4f8ff64942c6b34747" translate="yes" xml:space="preserve">
          <source>Testing range objects for equality with &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; compares them as sequences. That is, two range objects are considered equal if they represent the same sequence of values. (Note that two range objects that compare equal might have different &lt;a href=&quot;#range.start&quot;&gt;&lt;code&gt;start&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#range.stop&quot;&gt;&lt;code&gt;stop&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#range.step&quot;&gt;&lt;code&gt;step&lt;/code&gt;&lt;/a&gt; attributes, for example &lt;code&gt;range(0) == range(2, 1, 3)&lt;/code&gt; or &lt;code&gt;range(0, 3, 2) == range(0, 4, 2)&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;==&lt;/code&gt; 및 &lt;code&gt;!=&lt;/code&gt; 하여 범위 개체가 동일한 지 테스트하면 개체를 시퀀스로 비교합니다. 즉, 두 개의 범위 개체가 동일한 값 시퀀스를 나타내는 경우 동일한 것으로 간주됩니다. (동일하게 비교되는 두 범위 오브젝트는 &lt;a href=&quot;#range.start&quot;&gt; &lt;code&gt;start&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#range.stop&quot;&gt; &lt;code&gt;stop&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#range.step&quot;&gt; &lt;code&gt;step&lt;/code&gt; &lt;/a&gt; 속성 이 다를 수 있습니다 &lt;code&gt;range(0) == range(2, 1, 3)&lt;/code&gt; 예 : range (0) == range (2, 1, 3) 또는 &lt;code&gt;range(0, 3, 2) == range(0, 4, 2)&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="003efaa02b4b57128dcca991ec741e8a4eeb3716" translate="yes" xml:space="preserve">
          <source>Testing that a weak reference object is still live should be done using the expression &lt;code&gt;ref() is not None&lt;/code&gt;. Normally, application code that needs to use a reference object should follow this pattern:</source>
          <target state="translated">약한 참조 객체가 여전히 활성 상태인지 테스트하려면 &lt;code&gt;ref() is not None&lt;/code&gt; 표현식을 사용해야합니다 . 일반적으로 참조 객체를 사용해야하는 응용 프로그램 코드는 다음 패턴을 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="34733bb1e62600c3f8ae30cae693f94f1778a9ed" translate="yes" xml:space="preserve">
          <source>Testing your CGI script</source>
          <target state="translated">CGI 스크립트 테스트</target>
        </trans-unit>
        <trans-unit id="4e19688909d746da7f053c97e9a89a6180114515" translate="yes" xml:space="preserve">
          <source>Tests can be numerous, and their set-up can be repetitive. Luckily, we can factor out set-up code by implementing a method called &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt;, which the testing framework will automatically call for every single test we run:</source>
          <target state="translated">테스트는 다양 할 수 있으며 설정은 반복적 일 수 있습니다. 운 좋게도 &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 이라는 메소드를 구현하여 설정 코드를 제거 할 수 있습니다. setUp () 메소드 는 테스트 프레임 워크가 실행하는 모든 단일 테스트를 자동으로 호출합니다.</target>
        </trans-unit>
        <trans-unit id="d252b8a5f27daa8e41c6d3c2cb5eda98be0ec9ff" translate="yes" xml:space="preserve">
          <source>Tests embedded in documentation strings.</source>
          <target state="translated">설명서 문자열에 포함 된 테스트</target>
        </trans-unit>
        <trans-unit id="1406d991822128e10256d130b2e562a9f4a563b8" translate="yes" xml:space="preserve">
          <source>Tests for modules written in C must be in separate modules anyway, so why not be consistent?</source>
          <target state="translated">C로 작성된 모듈에 대한 테스트는 어쨌든 별도의 모듈에 있어야하는데 왜 일관성이 없는가?</target>
        </trans-unit>
        <trans-unit id="09983bd6189c4e80c72f5f7dbeabf106aff83bf9" translate="yes" xml:space="preserve">
          <source>Tests grouped by a &lt;a href=&quot;#unittest.TestSuite&quot;&gt;&lt;code&gt;TestSuite&lt;/code&gt;&lt;/a&gt; are always accessed by iteration. Subclasses can lazily provide tests by overriding &lt;a href=&quot;#unittest.TestSuite.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt;. Note that this method may be called several times on a single suite (for example when counting tests or comparing for equality) so the tests returned by repeated iterations before &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt;&lt;code&gt;TestSuite.run()&lt;/code&gt;&lt;/a&gt; must be the same for each call iteration. After &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt;&lt;code&gt;TestSuite.run()&lt;/code&gt;&lt;/a&gt;, callers should not rely on the tests returned by this method unless the caller uses a subclass that overrides &lt;code&gt;TestSuite._removeTestAtIndex()&lt;/code&gt; to preserve test references.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestSuite&quot;&gt; &lt;code&gt;TestSuite&lt;/code&gt; &lt;/a&gt; 로 그룹화 된 테스트 는 항상 반복을 통해 액세스됩니다. 서브 클래스는 &lt;a href=&quot;#unittest.TestSuite.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 을 재정 의하여 게으르게 테스트를 제공 할 수 있습니다 . 이 메소드는 단일 스위트에서 여러 번 호출 될 수 있으므로 (예 : 테스트 수 또는 동등성을 비교할 때) &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt; &lt;code&gt;TestSuite.run()&lt;/code&gt; &lt;/a&gt; 이전에 반복 된 반복으로 리턴 된 테스트는 각 호출 반복에 대해 동일해야합니다. &lt;a href=&quot;#unittest.TestSuite.run&quot;&gt; &lt;code&gt;TestSuite.run()&lt;/code&gt; &lt;/a&gt; 후 , 호출자가 테스트 참조를 보존하기 위해 &lt;code&gt;TestSuite._removeTestAtIndex()&lt;/code&gt; 를 대체하는 서브 클래스를 사용하지 않는 한 호출자는이 메소드가 리턴 한 테스트에 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="746f46b044088f5f407262ed246469a3a9cd3ffd" translate="yes" xml:space="preserve">
          <source>Tests that two lists or tuples are equal. If not, an error message is constructed that shows only the differences between the two. An error is also raised if either of the parameters are of the wrong type. These methods are used by default when comparing lists or tuples with &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 목록 또는 튜플이 같은지 테스트합니다. 그렇지 않은 경우, 둘 사이의 차이점 만 보여주는 오류 메시지가 구성됩니다. 매개 변수 중 하나가 잘못된 유형 인 경우에도 오류가 발생합니다. 이러한 메소드는 목록 또는 튜플을 &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 과 비교할 때 기본적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="12cb88d29c157a8c448f5221a48fcec3e2a2416d" translate="yes" xml:space="preserve">
          <source>Tests that two sequences are equal. If a &lt;em&gt;seq_type&lt;/em&gt; is supplied, both &lt;em&gt;first&lt;/em&gt; and &lt;em&gt;second&lt;/em&gt; must be instances of &lt;em&gt;seq_type&lt;/em&gt; or a failure will be raised. If the sequences are different an error message is constructed that shows the difference between the two.</source>
          <target state="translated">두 시퀀스가 ​​같은지 테스트합니다. 경우 &lt;em&gt;seq_type가&lt;/em&gt; 공급되고, 모두 &lt;em&gt;첫번째&lt;/em&gt; 와 &lt;em&gt;두번째&lt;/em&gt; 의 인스턴스이어야 &lt;em&gt;seq_type&lt;/em&gt; 또는 실패가 발생 될 것이다. 시퀀스가 다르면 두 메시지의 차이를 나타내는 오류 메시지가 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="50b57be9042dd364aa10610ff756601a77a8bc1e" translate="yes" xml:space="preserve">
          <source>Tests that two sets are equal. If not, an error message is constructed that lists the differences between the sets. This method is used by default when comparing sets or frozensets with &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 세트가 같은지 테스트합니다. 그렇지 않은 경우, 세트 간의 차이점을 나열하는 오류 메시지가 구성됩니다. 이 메소드는 기본적으로 세트 또는 고정 세트를 &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 과 비교할 때 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f2e5d85501569c4ac7d093b6592e30df4f105c2c" translate="yes" xml:space="preserve">
          <source>Tests the image data contained in the file named by &lt;em&gt;filename&lt;/em&gt;, and returns a string describing the image type. If optional &lt;em&gt;h&lt;/em&gt; is provided, the &lt;em&gt;filename&lt;/em&gt; is ignored and &lt;em&gt;h&lt;/em&gt; is assumed to contain the byte stream to test.</source>
          <target state="translated">&lt;em&gt;filename&lt;/em&gt; 이라는 파일에 포함 된 이미지 데이터를 테스트하고 이미지 유형을 설명하는 문자열을 반환합니다. 선택적인 &lt;em&gt;h&lt;/em&gt; 가 제공되면 &lt;em&gt;파일 이름&lt;/em&gt; 이 무시되고 &lt;em&gt;h&lt;/em&gt; 는 테스트 할 바이트 스트림을 포함하는 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="c9efb9d787a1a844d9d75c706c96b2d104de210f" translate="yes" xml:space="preserve">
          <source>Text Encodings</source>
          <target state="translated">텍스트 인코딩</target>
        </trans-unit>
        <trans-unit id="109f7c2f219315f947611c43c343d61302c960d4" translate="yes" xml:space="preserve">
          <source>Text I/O</source>
          <target state="translated">텍스트 I / O</target>
        </trans-unit>
        <trans-unit id="76ff03d8469b4fa76d987bf57d0bfa338515e0f7" translate="yes" xml:space="preserve">
          <source>Text I/O expects and produces &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects. This means that whenever the backing store is natively made of bytes (such as in the case of a file), encoding and decoding of data is made transparently as well as optional translation of platform-specific newline characters.</source>
          <target state="translated">텍스트 I / O는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체를 예상하고 생성 합니다. 이는 백업 저장소가 기본적으로 바이트 (예 : 파일의 경우)로 만들어 질 때마다 플랫폼 별 개행 문자의 선택적 변환뿐만 아니라 데이터의 인코딩 및 디코딩이 투명하게 이루어짐을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="d25b06b6b4a420e9c0c72ee30c50397503bc4867" translate="yes" xml:space="preserve">
          <source>Text I/O over a binary storage (such as a file) is significantly slower than binary I/O over the same storage, because it requires conversions between unicode and binary data using a character codec. This can become noticeable handling huge amounts of text data like large log files. Also, &lt;code&gt;TextIOWrapper.tell()&lt;/code&gt; and &lt;code&gt;TextIOWrapper.seek()&lt;/code&gt; are both quite slow due to the reconstruction algorithm used.</source>
          <target state="translated">파일과 같은 이진 저장소의 텍스트 I / O는 문자 코덱을 사용하여 유니 코드와 이진 데이터 간의 변환이 필요하기 때문에 동일한 저장소의 이진 I / O보다 상당히 느립니다. 이것은 큰 로그 파일과 같은 방대한 양의 텍스트 데이터를 처리 할 때 눈에 띄게됩니다. 또한 &lt;code&gt;TextIOWrapper.tell()&lt;/code&gt; 및 &lt;code&gt;TextIOWrapper.seek()&lt;/code&gt; 는 사용 된 재구성 알고리즘으로 인해 상당히 느립니다.</target>
        </trans-unit>
        <trans-unit id="b20688b2fd1febba21368c0b5690809bc433f2a2" translate="yes" xml:space="preserve">
          <source>Text Munging</source>
          <target state="translated">텍스트 문징</target>
        </trans-unit>
        <trans-unit id="5e7edac2cc88ea213ca3d3f3af0c25e020e3d37c" translate="yes" xml:space="preserve">
          <source>Text Processing</source>
          <target state="translated">텍스트 처리</target>
        </trans-unit>
        <trans-unit id="d75341f5e2708bd83dd875c8ee696d0a3461cbc3" translate="yes" xml:space="preserve">
          <source>Text Processing Services</source>
          <target state="translated">텍스트 처리 서비스</target>
        </trans-unit>
        <trans-unit id="d38c3fcbffdd11a45d7bcdcb6653c5f250097c68" translate="yes" xml:space="preserve">
          <source>Text Sequence Type &amp;mdash; &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">텍스트 시퀀스 타입 &amp;mdash; &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4da446389b00cf2098e337f3e9ec304abd5ae69d" translate="yes" xml:space="preserve">
          <source>Text Sequence Type &amp;mdash; str</source>
          <target state="translated">텍스트 시퀀스 타입 &amp;mdash; str</target>
        </trans-unit>
        <trans-unit id="6b61b4bd4d90f6dc874cfca9d95be9fb364f9b14" translate="yes" xml:space="preserve">
          <source>Text Transforms</source>
          <target state="translated">텍스트 변환</target>
        </trans-unit>
        <trans-unit id="7ddeaf5fb25a3098cc61cf569a9609c8423fe0ca" translate="yes" xml:space="preserve">
          <source>Text and CDATASection Objects</source>
          <target state="translated">텍스트 및 CDATASection 객체</target>
        </trans-unit>
        <trans-unit id="7e6151b50920d76fbcb71fc57c974ef648c49885" translate="yes" xml:space="preserve">
          <source>Text coloring is done in the background, so uncolorized text is occasionally visible. To change the color scheme, use the Configure IDLE dialog Highlighting tab. The marking of debugger breakpoint lines in the editor and text in popups and dialogs is not user-configurable.</source>
          <target state="translated">텍스트 채색은 백그라운드에서 수행되므로 색상이 지정되지 않은 텍스트가 표시되는 경우가 있습니다. 색 구성표를 변경하려면 유휴 구성 대화 상자 강조 표시 탭을 사용하십시오. 편집기의 디버거 중단 점 표시 및 팝업 및 대화 상자의 텍스트 표시는 사용자가 구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8a57dc74ece05356ee746dfe80671051d658e460" translate="yes" xml:space="preserve">
          <source>Text colors</source>
          <target state="translated">텍스트 색상</target>
        </trans-unit>
        <trans-unit id="660f799d669d5b7231f67c281132ba4f5cffb5db" translate="yes" xml:space="preserve">
          <source>Text file busy</source>
          <target state="translated">바쁜 텍스트 파일</target>
        </trans-unit>
        <trans-unit id="3831f3c17839811e5844d39136a6e4d1069c7fd7" translate="yes" xml:space="preserve">
          <source>Text is preferably wrapped on whitespaces and right after the hyphens in hyphenated words; only then will long words be broken if necessary, unless &lt;a href=&quot;#textwrap.TextWrapper.break_long_words&quot;&gt;&lt;code&gt;TextWrapper.break_long_words&lt;/code&gt;&lt;/a&gt; is set to false.</source>
          <target state="translated">텍스트는 공백과 하이픈 바로 뒤에 하이픈으로 묶인 단어로 묶는 것이 좋습니다. &lt;a href=&quot;#textwrap.TextWrapper.break_long_words&quot;&gt; &lt;code&gt;TextWrapper.break_long_words&lt;/code&gt; &lt;/a&gt; 가 false로 설정되어 있지 않으면 필요한 경우에만 긴 단어가 깨집니다 .</target>
        </trans-unit>
        <trans-unit id="12e22a819501b7839de966684daf36d764443f8c" translate="yes" xml:space="preserve">
          <source>Text logging level for the message (&lt;code&gt;'DEBUG'&lt;/code&gt;, &lt;code&gt;'INFO'&lt;/code&gt;, &lt;code&gt;'WARNING'&lt;/code&gt;, &lt;code&gt;'ERROR'&lt;/code&gt;, &lt;code&gt;'CRITICAL'&lt;/code&gt;).</source>
          <target state="translated">메시지의 텍스트 로깅 레벨 ( &lt;code&gt;'DEBUG'&lt;/code&gt; , &lt;code&gt;'INFO'&lt;/code&gt; , &lt;code&gt;'WARNING'&lt;/code&gt; , &lt;code&gt;'ERROR'&lt;/code&gt; , &lt;code&gt;'CRITICAL'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="987d6f0b28dc65ff1239d10e0d44ea7cc7fcc301" translate="yes" xml:space="preserve">
          <source>Text widget indexes</source>
          <target state="translated">텍스트 위젯 인덱스</target>
        </trans-unit>
        <trans-unit id="3fdfd69b27f0a02d3b68f1b45c9ee6e94da682e0" translate="yes" xml:space="preserve">
          <source>Text widget with a vertical scroll bar built in.</source>
          <target state="translated">수직 스크롤 막대가 내장 된 텍스트 위젯.</target>
        </trans-unit>
        <trans-unit id="63ca83a63aa65e4881414699c40dc49a0eea9ea4" translate="yes" xml:space="preserve">
          <source>Textbox objects</source>
          <target state="translated">텍스트 상자 객체</target>
        </trans-unit>
        <trans-unit id="46347caa9c96519fa9f4ef646b0b35f9da71370b" translate="yes" xml:space="preserve">
          <source>Textual data in Python is handled with &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects, or &lt;em&gt;strings&lt;/em&gt;. Strings are immutable &lt;a href=&quot;#typesseq&quot;&gt;sequences&lt;/a&gt; of Unicode code points. String literals are written in a variety of ways:</source>
          <target state="translated">파이썬의 텍스트 데이터는 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;em&gt;문자열로&lt;/em&gt; 처리 &lt;em&gt;됩니다&lt;/em&gt; . 문자열은 변경 불가능한 유니 코드 코드 포인트 &lt;a href=&quot;#typesseq&quot;&gt;시퀀스&lt;/a&gt; 입니다. 문자열 리터럴은 다양한 방법으로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="c32767e0541fe7038ff8d87e7b8aed17f49474f8" translate="yes" xml:space="preserve">
          <source>Thai</source>
          <target state="translated">Thai</target>
        </trans-unit>
        <trans-unit id="7e15e8ed56909024bd97b96d075895a121cf534e" translate="yes" xml:space="preserve">
          <source>Thai languages</source>
          <target state="translated">태국어</target>
        </trans-unit>
        <trans-unit id="63beac302793fb4c2b8edf609f9123624506d326" translate="yes" xml:space="preserve">
          <source>Thanks to Matthew Dixon Cowles for the original inspiration and examples.</source>
          <target state="translated">독창적 인 영감과 예를 주신 Matthew Dixon Cowles에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="801b224b2c27d3c4c3785e85a4f6f799925da25a" translate="yes" xml:space="preserve">
          <source>That code causes several &lt;a href=&quot;#module-tkinter.ttk&quot;&gt;&lt;code&gt;tkinter.ttk&lt;/code&gt;&lt;/a&gt; widgets (&lt;code&gt;Button&lt;/code&gt;, &lt;code&gt;Checkbutton&lt;/code&gt;, &lt;code&gt;Entry&lt;/code&gt;, &lt;code&gt;Frame&lt;/code&gt;, &lt;code&gt;Label&lt;/code&gt;, &lt;code&gt;LabelFrame&lt;/code&gt;, &lt;code&gt;Menubutton&lt;/code&gt;, &lt;code&gt;PanedWindow&lt;/code&gt;, &lt;code&gt;Radiobutton&lt;/code&gt;, &lt;code&gt;Scale&lt;/code&gt; and &lt;code&gt;Scrollbar&lt;/code&gt;) to automatically replace the Tk widgets.</source>
          <target state="translated">그 코드는 여러 가지 원인이 &lt;a href=&quot;#module-tkinter.ttk&quot;&gt; &lt;code&gt;tkinter.ttk&lt;/code&gt; 의&lt;/a&gt; 위젯 ( &lt;code&gt;Button&lt;/code&gt; , &lt;code&gt;Checkbutton&lt;/code&gt; , &lt;code&gt;Entry&lt;/code&gt; , &lt;code&gt;Frame&lt;/code&gt; , &lt;code&gt;Label&lt;/code&gt; , &lt;code&gt;LabelFrame&lt;/code&gt; , &lt;code&gt;Menubutton&lt;/code&gt; , &lt;code&gt;PanedWindow&lt;/code&gt; , &lt;code&gt;Radiobutton&lt;/code&gt; , &lt;code&gt;Scale&lt;/code&gt; 및 &lt;code&gt;Scrollbar&lt;/code&gt; 자동으로 TK에 위젯을 대체 할을).</target>
        </trans-unit>
        <trans-unit id="1b34a090e905f2f91f164b616a609eae4239508a" translate="yes" xml:space="preserve">
          <source>That default is subject to change at any time, including during maintenance releases.</source>
          <target state="translated">이 기본값은 유지 보수 릴리스를 포함하여 언제든지 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305099f8690907083c8e1f88926191ba01b8d9be" translate="yes" xml:space="preserve">
          <source>That doctest succeeds if &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised, with the &lt;code&gt;list.remove(x):
x not in list&lt;/code&gt; detail as shown.</source>
          <target state="translated">&lt;code&gt;list.remove(x): x not in list&lt;/code&gt; 와 같이 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 해당 doctest가 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="7af14a7bea1fe17b77ce68743033a173fd5b0d31" translate="yes" xml:space="preserve">
          <source>That is, anything extra that the specialized class puts in to the &lt;code&gt;kwds&lt;/code&gt; dictionary should be removed and handled, and the remaining contents of &lt;code&gt;kw&lt;/code&gt; (and &lt;code&gt;args&lt;/code&gt;) passed to the &lt;code&gt;BaseHeader&lt;/code&gt;&lt;code&gt;init&lt;/code&gt; method.</source>
          <target state="translated">즉, 특수 클래스가 &lt;code&gt;kwds&lt;/code&gt; 사전 에 추가하는 모든 것을 제거하고 처리해야하며 &lt;code&gt;kw&lt;/code&gt; (및 &lt;code&gt;args&lt;/code&gt; ) 의 나머지 내용은 &lt;code&gt;BaseHeader&lt;/code&gt; &lt;code&gt;init&lt;/code&gt; 메소드로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0bc557e45ef5a3dbe18b8040fb35104eb35a7415" translate="yes" xml:space="preserve">
          <source>That last hand, &lt;code&gt;&quot;727ak&quot;&lt;/code&gt;, contained a pair, or two of the same valued cards. To match this with a regular expression, one could use backreferences as such:</source>
          <target state="translated">마지막 &lt;code&gt;&quot;727ak&quot;&lt;/code&gt; 에는 한 쌍 또는 같은 가치가있는 카드 두 개가 들어있었습니다. 이것을 정규 표현식과 일치시키기 위해 역 참조를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca1c777fbc1f6e256bcbd75cee9a6460910a6ef6" translate="yes" xml:space="preserve">
          <source>That means when the type of a value is &lt;a href=&quot;functions#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt;, a type checker will reject almost all operations on it, and assigning it to a variable (or using it as a return value) of a more specialized type is a type error. For example:</source>
          <target state="translated">즉, 값의 유형이 &lt;a href=&quot;functions#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 인 경우 유형 검사기는 거의 모든 작업을 거부하고 더 특수한 유형의 변수에 값을 할당하거나 반환 값으로 사용하면 유형 오류가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9cc1064d298dd1efe1205f99e287bdb018327f8f" translate="yes" xml:space="preserve">
          <source>That short script executes and verifies any interactive Python examples contained in the file &lt;code&gt;example.txt&lt;/code&gt;. The file content is treated as if it were a single giant docstring; the file doesn&amp;rsquo;t need to contain a Python program! For example, perhaps &lt;code&gt;example.txt&lt;/code&gt; contains this:</source>
          <target state="translated">이 짧은 스크립트는 &lt;code&gt;example.txt&lt;/code&gt; 파일에 포함 된 대화 형 Python 예제를 실행하고 확인합니다 . 파일 내용은 마치 하나의 거대한 docstring 인 것처럼 취급됩니다. 파일은 파이썬 프로그램을 포함 할 필요가 없습니다! 예를 들어 &lt;code&gt;example.txt&lt;/code&gt; 에 다음이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ebaa0b37641dbc0c9c4c7f49bd40a80dc199fab" translate="yes" xml:space="preserve">
          <source>That way, separator components are always found at the same relative indices within the result list.</source>
          <target state="translated">이런 식으로 구분 기호 구성 요소는 항상 결과 목록 내에서 동일한 상대 인덱스에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d985bc25496ca07f21e5b6b8027aab8030bb3cc" translate="yes" xml:space="preserve">
          <source>That&amp;rsquo;s all you need to know to start making productive use of &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt;! Jump in. The following sections provide full details. Note that there are many examples of doctests in the standard Python test suite and libraries. Especially useful examples can be found in the standard test file &lt;code&gt;Lib/test/test_doctest.py&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 를 생산적으로 사용하기 위해 알아야 할 전부입니다 ! 다음 섹션은 자세한 내용을 제공합니다. 표준 Python 테스트 스위트 및 라이브러리에는 doctest의 많은 예가 있습니다. 특히 유용한 예제는 표준 테스트 파일 &lt;code&gt;Lib/test/test_doctest.py&lt;/code&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24767c748b9c923eaeff84e0ecaa1b3edd0e2c9e" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;&lt;code&gt;**&lt;/code&gt;&amp;rdquo; pattern means &amp;ldquo;this directory and all subdirectories, recursively&amp;rdquo;. In other words, it enables recursive globbing:</source>
          <target state="translated">&quot; &lt;code&gt;**&lt;/code&gt; &quot;패턴은 &quot;이 디렉토리 및 모든 서브 디렉토리를 재귀 적으로&quot;의미합니다. 다시 말해, 재귀 적 글 로빙을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="0fb252c960feb71015d07ccf7a5fa1d3bae709f5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;R&amp;rdquo; and &amp;ldquo;O&amp;rdquo; flags are stored in the &lt;em&gt;Status&lt;/em&gt; header, and the &amp;ldquo;D&amp;rdquo;, &amp;ldquo;F&amp;rdquo;, and &amp;ldquo;A&amp;rdquo; flags are stored in the &lt;em&gt;X-Status&lt;/em&gt; header. The flags and headers typically appear in the order mentioned.</source>
          <target state="translated">&quot;R&quot;및 &quot;O&quot;플래그는 &lt;em&gt;상태&lt;/em&gt; 헤더에 저장되고 &quot;D&quot;, &quot;F&quot;및 &quot;A&quot;플래그는 &lt;em&gt;X- 상태&lt;/em&gt; 헤더에 저장됩니다 . 플래그와 헤더는 일반적으로 언급 된 순서대로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="850628f9d76c3c78d286ee4197ab0bb760d1f09f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;ctime&amp;rdquo; as reported by the operating system. On some systems (like Unix) is the time of the last metadata change, and, on others (like Windows), is the creation time (see platform documentation for details).</source>
          <target state="translated">운영 체제에서보고 한 &quot;ctime&quot; 일부 시스템 (예 : Unix)은 마지막 메타 데이터 변경 시간이고 다른 시스템 (예 : Windows)은 생성 시간입니다 (자세한 내용은 플랫폼 설명서 참조).</target>
        </trans-unit>
        <trans-unit id="5f051f0b1c246488e612587cabeb323919ac9e28" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;l&amp;rdquo; and &amp;ldquo;v&amp;rdquo; variants of the &lt;a href=&quot;#os.execl&quot;&gt;&lt;code&gt;exec*&lt;/code&gt;&lt;/a&gt; functions differ in how command-line arguments are passed. The &amp;ldquo;l&amp;rdquo; variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the &lt;code&gt;execl*()&lt;/code&gt; functions. The &amp;ldquo;v&amp;rdquo; variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the &lt;em&gt;args&lt;/em&gt; parameter. In either case, the arguments to the child process should start with the name of the command being run, but this is not enforced.</source>
          <target state="translated">&lt;a href=&quot;#os.execl&quot;&gt; &lt;code&gt;exec*&lt;/code&gt; &lt;/a&gt; 함수 의 &quot;l&quot;및 &quot;v&quot;변형은 명령 줄 인수가 전달되는 방식이 다릅니다. 코드가 작성 될 때 매개 변수의 수가 고정되어 있으면&amp;ldquo;l&amp;rdquo;변형이 가장 쉬운 방법 일 것입니다. 개별 매개 변수는 단순히 &lt;code&gt;execl*()&lt;/code&gt; 함수 에 대한 추가 매개 변수가 됩니다. &quot;v&quot;변형은 매개 변수의 수가 가변적 일 때 인수가 &lt;em&gt;args&lt;/em&gt; 매개 변수 로 목록 또는 튜플에 전달되어 적합합니다 . 두 경우 모두 하위 프로세스에 대한 인수는 실행중인 명령의 이름으로 시작해야하지만 적용되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="dda6a33b048efb7394cfa7788d36d000c6865c2a" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;l&amp;rdquo; and &amp;ldquo;v&amp;rdquo; variants of the &lt;a href=&quot;#os.spawnl&quot;&gt;&lt;code&gt;spawn*&lt;/code&gt;&lt;/a&gt; functions differ in how command-line arguments are passed. The &amp;ldquo;l&amp;rdquo; variants are perhaps the easiest to work with if the number of parameters is fixed when the code is written; the individual parameters simply become additional parameters to the &lt;code&gt;spawnl*()&lt;/code&gt; functions. The &amp;ldquo;v&amp;rdquo; variants are good when the number of parameters is variable, with the arguments being passed in a list or tuple as the &lt;em&gt;args&lt;/em&gt; parameter. In either case, the arguments to the child process must start with the name of the command being run.</source>
          <target state="translated">&lt;a href=&quot;#os.spawnl&quot;&gt; &lt;code&gt;spawn*&lt;/code&gt; &lt;/a&gt; 함수 의 &quot;l&quot;및 &quot;v&quot;변형은 명령 줄 인수가 전달되는 방식이 다릅니다. 코드가 작성 될 때 매개 변수의 수가 고정되어 있으면&amp;ldquo;l&amp;rdquo;변형이 가장 쉬운 방법 일 것입니다. 개별 매개 변수는 단순히 &lt;code&gt;spawnl*()&lt;/code&gt; 함수 에 대한 추가 매개 변수가 됩니다. &quot;v&quot;변형은 매개 변수의 수가 가변적 일 때 인수가 &lt;em&gt;args&lt;/em&gt; 매개 변수 로 목록 또는 튜플에 전달되어 적합합니다 . 두 경우 모두 하위 프로세스에 대한 인수는 실행중인 명령의 이름으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebc5c5eff4ebaa2aabc62e546b5d710cc242a1f0" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;return&amp;rdquo; annotation for the callable. If the callable has no &amp;ldquo;return&amp;rdquo; annotation, this attribute is set to &lt;a href=&quot;#inspect.Signature.empty&quot;&gt;&lt;code&gt;Signature.empty&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">콜 러블에 대한 &quot;반환&quot;주석. 콜 러블에 &quot;return&quot;주석이 없으면이 속성은 &lt;a href=&quot;#inspect.Signature.empty&quot;&gt; &lt;code&gt;Signature.empty&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="fe5a66d9030159d4a1298e1aa9f3e8498628b01f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;sendfile&amp;rdquo; syscall is not available for the given socket or file type.</source>
          <target state="translated">지정된 소켓 또는 파일 유형에 대해 &quot;sendfile&quot;syscall을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6b37f6a38c6f4ef0df7a7bd6db684f2957f82875" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;thread identifier&amp;rsquo; of this thread or &lt;code&gt;None&lt;/code&gt; if the thread has not been started. This is a nonzero integer. See the &lt;a href=&quot;#threading.get_ident&quot;&gt;&lt;code&gt;get_ident()&lt;/code&gt;&lt;/a&gt; function. Thread identifiers may be recycled when a thread exits and another thread is created. The identifier is available even after the thread has exited.</source>
          <target state="translated">이 스레드의 '스레드 식별자'또는 스레드가 시작되지 않은 경우 &lt;code&gt;None&lt;/code&gt; 이것은 0이 아닌 정수입니다. &lt;a href=&quot;#threading.get_ident&quot;&gt; &lt;code&gt;get_ident()&lt;/code&gt; &lt;/a&gt; 함수를 참조하십시오 . 스레드 식별자는 스레드가 종료되고 다른 스레드가 작성 될 때 재활용 될 수 있습니다. 스레드가 종료 된 후에도 식별자를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09100573d37b9f6f1a6f374309892673e325a3e" translate="yes" xml:space="preserve">
          <source>The 6 optional arguments can only be specified when the window is a pad created with &lt;a href=&quot;#curses.newpad&quot;&gt;&lt;code&gt;newpad()&lt;/code&gt;&lt;/a&gt;. The additional parameters are needed to indicate what part of the pad and screen are involved. &lt;em&gt;pminrow&lt;/em&gt; and &lt;em&gt;pmincol&lt;/em&gt; specify the upper left-hand corner of the rectangle to be displayed in the pad. &lt;em&gt;sminrow&lt;/em&gt;, &lt;em&gt;smincol&lt;/em&gt;, &lt;em&gt;smaxrow&lt;/em&gt;, and &lt;em&gt;smaxcol&lt;/em&gt; specify the edges of the rectangle to be displayed on the screen. The lower right-hand corner of the rectangle to be displayed in the pad is calculated from the screen coordinates, since the rectangles must be the same size. Both rectangles must be entirely contained within their respective structures. Negative values of &lt;em&gt;pminrow&lt;/em&gt;, &lt;em&gt;pmincol&lt;/em&gt;, &lt;em&gt;sminrow&lt;/em&gt;, or &lt;em&gt;smincol&lt;/em&gt; are treated as if they were zero.</source>
          <target state="translated">6 개의 선택적 인수는 윈도우가 &lt;a href=&quot;#curses.newpad&quot;&gt; &lt;code&gt;newpad()&lt;/code&gt; &lt;/a&gt; 만든 패드 인 경우에만 지정할 수 있습니다 . 패드와 스크린의 어떤 부분이 관련되어 있는지를 나타 내기 위해 추가 파라미터가 필요합니다. &lt;em&gt;pminrow&lt;/em&gt; 및 &lt;em&gt;pmincol&lt;/em&gt; 은 패드에 표시 할 사각형의 왼쪽 위 모서리를 지정합니다. &lt;em&gt;sminrow&lt;/em&gt; , &lt;em&gt;smincol&lt;/em&gt; , &lt;em&gt;smaxrow&lt;/em&gt; 및 &lt;em&gt;smaxcol&lt;/em&gt; 은 화면에 표시 할 사각형의 가장자리를 지정합니다. 사각형의 크기가 같아야하기 때문에 패드에 표시 할 사각형의 오른쪽 아래 모서리가 화면 좌표에서 계산됩니다. 두 직사각형 모두 해당 구조 내에 완전히 포함되어야합니다. 음수 값&lt;em&gt;pminrow&lt;/em&gt; , &lt;em&gt;pmincol&lt;/em&gt; , &lt;em&gt;sminrow&lt;/em&gt; 또는 &lt;em&gt;smincol&lt;/em&gt; 은 마치 0 인 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="2c7c3977ea82a165dda3d13226526b2a3b9a05ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#abc.ABCMeta.__subclasshook__&quot;&gt;&lt;code&gt;__subclasshook__()&lt;/code&gt;&lt;/a&gt; class method defined here says that any class that has an &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; method in its &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; (or in that of one of its base classes, accessed via the &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt;&lt;code&gt;__mro__&lt;/code&gt;&lt;/a&gt; list) is considered a &lt;code&gt;MyIterable&lt;/code&gt; too.</source>
          <target state="translated">&lt;a href=&quot;#abc.ABCMeta.__subclasshook__&quot;&gt; &lt;code&gt;__subclasshook__()&lt;/code&gt; &lt;/a&gt; 여기에 정의 된 클래스의 메소드가 갖는 모든 클래스 있다고 &lt;a href=&quot;stdtypes#iterator.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 는 메소드 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; 가&lt;/a&gt; (또는 통해 액세스의 기본 클래스 중 하나의 점에서 &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt; &lt;code&gt;__mro__&lt;/code&gt; 의&lt;/a&gt; 리스트)를 고려 &lt;code&gt;MyIterable&lt;/code&gt; 를 도.</target>
        </trans-unit>
        <trans-unit id="8893e61d48dfb45170ae7cec047a2cf3133bda0a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; object will hold all the information necessary to parse the command line into Python data types.</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 의&lt;/a&gt; 객체는 파이썬 데이터 유형에 명령 줄을 구문 분석하는 데 필요한 모든 정보를 개최한다.</target>
        </trans-unit>
        <trans-unit id="7526d0f6695800a5de1896614b5b1f1489511344" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; method must know whether an optional argument, like &lt;code&gt;-f&lt;/code&gt; or &lt;code&gt;--foo&lt;/code&gt;, or a positional argument, like a list of filenames, is expected. The first arguments passed to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; must therefore be either a series of flags, or a simple argument name. For example, an optional argument could be created like:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 메소드는 선택적 인수가 같은 있는지 알고 있어야합니다 &lt;code&gt;-f&lt;/code&gt; 또는 &lt;code&gt;--foo&lt;/code&gt; , 또는 파일 이름의 목록과 같은 위치 인수, 기대된다. 따라서 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 전달 된 첫 번째 인수 는 일련의 플래그이거나 간단한 인수 이름이어야합니다. 예를 들어 다음과 같은 선택적 인수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="200c899b9946a2c72d68748bb9a2de68d91482ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt;&lt;code&gt;add_argument_group()&lt;/code&gt;&lt;/a&gt; method returns an argument group object which has an &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; method just like a regular &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;. When an argument is added to the group, the parser treats it just like a normal argument, but displays the argument in a separate group for help messages. The &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt;&lt;code&gt;add_argument_group()&lt;/code&gt;&lt;/a&gt; method accepts &lt;em&gt;title&lt;/em&gt; and &lt;em&gt;description&lt;/em&gt; arguments which can be used to customize this display:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt; &lt;code&gt;add_argument_group()&lt;/code&gt; &lt;/a&gt; 메소드는이 인수 그룹 개체를 반환 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 단지 일반 같은 방법 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 을&lt;/a&gt; . 인수가 그룹에 추가되면 구문 분석기는 해당 인수를 일반 인수처럼 취급하지만 도움말 메시지를 위해 별도의 그룹에 인수를 표시합니다. &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt; &lt;code&gt;add_argument_group()&lt;/code&gt; &lt;/a&gt; 방법 허용 &lt;em&gt;타이틀&lt;/em&gt; 과 &lt;em&gt;설명&lt;/em&gt; 이 디스플레이를 지정하는 데 사용될 수 인자 :</target>
        </trans-unit>
        <trans-unit id="3fef92983dfc504a867a24713175cff415d4ec68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.add_mutually_exclusive_group&quot;&gt;&lt;code&gt;add_mutually_exclusive_group()&lt;/code&gt;&lt;/a&gt; method also accepts a &lt;em&gt;required&lt;/em&gt; argument, to indicate that at least one of the mutually exclusive arguments is required:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_mutually_exclusive_group&quot;&gt; &lt;code&gt;add_mutually_exclusive_group()&lt;/code&gt; &lt;/a&gt; 메소드는 또한 허용 &lt;em&gt;필요한&lt;/em&gt; 상호 배타적 인자 중 적어도 하나가 필요하다는 것을 나타 내기 위해, 인자 :</target>
        </trans-unit>
        <trans-unit id="2dbbdc4eaca6aa33616d69e89d9701442ad04b5d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt;&lt;code&gt;add_subparsers()&lt;/code&gt;&lt;/a&gt; method also supports &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt; keyword arguments. When either is present, the subparser&amp;rsquo;s commands will appear in their own group in the help output. For example:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_subparsers&quot;&gt; &lt;code&gt;add_subparsers()&lt;/code&gt; &lt;/a&gt; 메소드는 지원 &lt;code&gt;title&lt;/code&gt; 과 &lt;code&gt;description&lt;/code&gt; 키워드 인수를. 둘 중 하나가 있으면 하위 구문 분석기의 명령이 도움말 출력의 자체 그룹에 나타납니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e53c41a574c2192239e516354d84c6f7d331e309" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method &lt;a href=&quot;#allow-abbrev&quot;&gt;by default&lt;/a&gt; allows long options to be abbreviated to a prefix, if the abbreviation is unambiguous (the prefix matches a unique option):</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;#allow-abbrev&quot;&gt;기본적으로는&lt;/a&gt; 약어가 (접두사가 고유 옵션을 일치) 모호 경우, 긴 옵션을 접두사로 축약 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1c0f44b29023b0d7f21a1850c8ff6d43047cea22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method attempts to give errors whenever the user has clearly made a mistake, but some situations are inherently ambiguous. For example, the command-line argument &lt;code&gt;-1&lt;/code&gt; could either be an attempt to specify an option or an attempt to provide a positional argument. The &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method is cautious here: positional arguments may only begin with &lt;code&gt;-&lt;/code&gt; if they look like negative numbers and there are no options in the parser that look like negative numbers:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 메소드의 시도는 사용자가 명확하게 실수를 때마다 오류를주고 있지만, 상황은 본질적으로 모호하다. 예를 들어, 명령 행 인수 &lt;code&gt;-1&lt;/code&gt; 은 옵션을 지정하려는 시도이거나 위치 인수를 제공하려는 시도 일 수 있습니다. &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 방법은 여기 신중는 : 위치 인수는 시작 할 수있다 &lt;code&gt;-&lt;/code&gt; 그들이 부정적인 번호처럼 파서에는 옵션이없는 경우 그 음수과 같이 :</target>
        </trans-unit>
        <trans-unit id="b82bb7c2b5e826472abba2cfa940e03bea6a139f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; method supports several ways of specifying the value of an option (if it takes one). In the simplest case, the option and its value are passed as two separate arguments:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 방법은 (는 하나 걸리는 경우) 옵션의 값을 지정하는 여러 가지 방법을 지원합니다. 가장 간단한 경우 옵션과 해당 값은 두 개의 개별 인수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="90c8a41a856e529848d6eade10c1d8d41a7a4839" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#argparse.FileType&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt; factory creates objects that can be passed to the type argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;ArgumentParser.add_argument()&lt;/code&gt;&lt;/a&gt;. Arguments that have &lt;a href=&quot;#argparse.FileType&quot;&gt;&lt;code&gt;FileType&lt;/code&gt;&lt;/a&gt; objects as their type will open command-line arguments as files with the requested modes, buffer sizes, encodings and error handling (see the &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function for more details):</source>
          <target state="translated">&lt;a href=&quot;#argparse.FileType&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; 공장의 형식 인수로 전달 될 수있는 개체 생성 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;ArgumentParser.add_argument()&lt;/code&gt; &lt;/a&gt; . 이 인수 &lt;a href=&quot;#argparse.FileType&quot;&gt; &lt;code&gt;FileType&lt;/code&gt; &lt;/a&gt; 크기, 인코딩 및 오류 처리 버퍼, 요청 된 모드를 파일로 명령 줄 인수를 엽니 다 자신의 유형을합니다 (참조로 객체 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 자세한 내용은 기능) :</target>
        </trans-unit>
        <trans-unit id="30f75f59a9a7268631e66d52cbd510df63fb3b35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ast.NodeTransformer&quot;&gt;&lt;code&gt;NodeTransformer&lt;/code&gt;&lt;/a&gt; will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is &lt;code&gt;None&lt;/code&gt;, the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place.</source>
          <target state="translated">&lt;a href=&quot;#ast.NodeTransformer&quot;&gt; &lt;code&gt;NodeTransformer&lt;/code&gt; 은&lt;/a&gt; 대서양 표준시를 걸어 교체하거나 이전 노드를 제거하는 방문자 방법의 반환 값을 사용합니다. 방문자 메소드의 리턴 값이 &lt;code&gt;None&lt;/code&gt; 이면 노드가 해당 위치에서 제거되고, 그렇지 않으면 리턴 값으로 대체됩니다. 리턴 값은 원래 노드 일 수 있으며,이 경우 교체가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="44129255c25550851ce7e2aa0778b3b4d25d9e16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#asyncio-event-loop&quot;&gt;Event Loop Methods&lt;/a&gt; section lists all methods that an alternative implementation of &lt;code&gt;AbstractEventLoop&lt;/code&gt; should have defined.</source>
          <target state="translated">&lt;a href=&quot;#asyncio-event-loop&quot;&gt;이벤트 루프 방법&lt;/a&gt; 섹션의 대안 구현하는 모든 방법을 나열 &lt;code&gt;AbstractEventLoop&lt;/code&gt; 가 정의해야한다.</target>
        </trans-unit>
        <trans-unit id="566b6568a456d6b2074cb276dfb3442143d58f54" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#asyncio.create_task&quot;&gt;&lt;code&gt;asyncio.create_task()&lt;/code&gt;&lt;/a&gt; function to run coroutines concurrently as asyncio &lt;a href=&quot;#asyncio.Task&quot;&gt;&lt;code&gt;Tasks&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.create_task&quot;&gt; &lt;code&gt;asyncio.create_task()&lt;/code&gt; &lt;/a&gt; 함수는 asyncio로 동시에 코 루틴을 실행하는 &lt;a href=&quot;#asyncio.Task&quot;&gt; &lt;code&gt;Tasks&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0828773ce7ea3491738f68a93eb0b46a845438a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#asyncio.loop.subprocess_exec&quot;&gt;&lt;code&gt;loop.subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.subprocess_shell&quot;&gt;&lt;code&gt;loop.subprocess_shell()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.subprocess_exec&quot;&gt; &lt;code&gt;loop.subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.subprocess_shell&quot;&gt; &lt;code&gt;loop.subprocess_shell()&lt;/code&gt; &lt;/a&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="14e1e89d72e3abb7ad7a42c6bb4657ef919d4a09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt; function to run the top-level entry point &amp;ldquo;main()&amp;rdquo; function (see the above example.)</source>
          <target state="translated">최상위 진입 점 &quot;main ()&quot;함수를 실행하기 위한 &lt;a href=&quot;#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 함수 (위 예 참조)</target>
        </trans-unit>
        <trans-unit id="8c2d28f88261c63a30bcb012973da5c29ebc108f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;dispatcher&lt;/code&gt;&lt;/a&gt; class is a thin wrapper around a low-level socket object. To make it more useful, it has a few methods for event-handling which are called from the asynchronous loop. Otherwise, it can be treated as a normal non-blocking socket object.</source>
          <target state="translated">&lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;dispatcher&lt;/code&gt; &lt;/a&gt; 클래스는 낮은 수준의 소켓 객체 주위에 얇은 래퍼입니다. 보다 유용하게하기 위해 비동기 루프에서 호출되는 이벤트 처리 방법이 몇 가지 있습니다. 그렇지 않으면 일반적인 비 차단 소켓 객체로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b116f4cff6f99d06c7507048ccef1a5dd888de1f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#bdb.Bdb&quot;&gt;&lt;code&gt;Bdb&lt;/code&gt;&lt;/a&gt; class acts as a generic Python debugger base class.</source>
          <target state="translated">&lt;a href=&quot;#bdb.Bdb&quot;&gt; &lt;code&gt;Bdb&lt;/code&gt; &lt;/a&gt; 클래스는 일반적인 파이썬 디버거 기본 클래스 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="62525848a0c9c88cc01e3367b6ebc3c4abb4d531" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#bytes.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method should be used only if you need to know the position of &lt;em&gt;sub&lt;/em&gt;. To check if &lt;em&gt;sub&lt;/em&gt; is a substring or not, use the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">&lt;a href=&quot;#bytes.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 당신의 위치를 알 필요가 있다면 방법에만 사용해야합니다 &lt;em&gt;하위&lt;/em&gt; . &lt;em&gt;sub&lt;/em&gt; 가 하위 문자열인지 확인하려면 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="841a1b693b3ece85984308dadf9e2ac6e168a09d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt;&lt;code&gt;BZ2Compressor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt;&lt;code&gt;BZ2Decompressor&lt;/code&gt;&lt;/a&gt; classes for incremental (de)compression.</source>
          <target state="translated">&lt;a href=&quot;#bz2.BZ2Compressor&quot;&gt; &lt;code&gt;BZ2Compressor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bz2.BZ2Decompressor&quot;&gt; &lt;code&gt;BZ2Decompressor&lt;/code&gt; &lt;/a&gt; 증분 (DE) 압축 클래스.</target>
        </trans-unit>
        <trans-unit id="2251eac4644699f0e79ff35b47a34df095f7a6ec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#bz2.compress&quot;&gt;&lt;code&gt;compress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#bz2.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; functions for one-shot (de)compression.</source>
          <target state="translated">&lt;a href=&quot;#bz2.compress&quot;&gt; &lt;code&gt;compress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#bz2.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 원샷 (DE) 압축 기능한다.</target>
        </trans-unit>
        <trans-unit id="dde39ca4d885c419c3b0a279b055ec1bdc4d0f3f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#bz2.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function and &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; class for reading and writing compressed files.</source>
          <target state="translated">&lt;a href=&quot;#bz2.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 기능과 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; 의&lt;/a&gt; 읽기 및 압축 파일을 작성하기위한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="bc4869d7893639e257f10707e3378acdfc95d33f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#callback-handles&quot;&gt;Callback Handles&lt;/a&gt; section documents the &lt;a href=&quot;#asyncio.Handle&quot;&gt;&lt;code&gt;Handle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt;&lt;code&gt;TimerHandle&lt;/code&gt;&lt;/a&gt; instances which are returned from scheduling methods such as &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt;&lt;code&gt;loop.call_later()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;#callback-handles&quot;&gt;콜백 핸들&lt;/a&gt; 부 기록한 &lt;a href=&quot;#asyncio.Handle&quot;&gt; &lt;code&gt;Handle&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt; &lt;code&gt;TimerHandle&lt;/code&gt; 의&lt;/a&gt; 경우와 같은 스케쥴링 방법에서 반환 &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt; &lt;code&gt;loop.call_later()&lt;/code&gt; &lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="19e3ac2baf30036958038b751ca097c70434efec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#choices&quot;&gt;choices&lt;/a&gt; keyword argument may be more convenient for type checkers that simply check against a range of values:</source>
          <target state="translated">&lt;a href=&quot;#choices&quot;&gt;선택&lt;/a&gt; 키워드 인수는 단순히 값의 범위에 대해 확인 유형 검사기 더 편리 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="73eea60dabe306547088c9373001f60cb2cf86dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; class provides a simple framework for writing line-oriented command interpreters. These are often useful for test harnesses, administrative tools, and prototypes that will later be wrapped in a more sophisticated interface.</source>
          <target state="translated">&lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; 를의&lt;/a&gt; 클래스는 라인 - 지향 명령어 인터프리터를 작성하기위한 간단한 프레임 워크를 제공합니다. 이것들은 종종 테스트 인터페이스, 관리 도구 및 프로토 타입에 유용하며 나중에 더 복잡한 인터페이스로 포장 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="1178f6d26db9b3eb867ab07976420e2db629ec7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#cmdoption-unittest-c&quot;&gt;&lt;code&gt;-c/--catch&lt;/code&gt;&lt;/a&gt; command-line option to unittest, along with the &lt;code&gt;catchbreak&lt;/code&gt; parameter to &lt;a href=&quot;#unittest.main&quot;&gt;&lt;code&gt;unittest.main()&lt;/code&gt;&lt;/a&gt;, provide more friendly handling of control-C during a test run. With catch break behavior enabled control-C will allow the currently running test to complete, and the test run will then end and report all the results so far. A second control-c will raise a &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; in the usual way.</source>
          <target state="translated">&lt;a href=&quot;#unittest.main&quot;&gt; &lt;code&gt;unittest.main()&lt;/code&gt; &lt;/a&gt; 에 대한 &lt;code&gt;catchbreak&lt;/code&gt; 매개 변수 와 함께 unittest에 대한 &lt;a href=&quot;#cmdoption-unittest-c&quot;&gt; &lt;code&gt;-c/--catch&lt;/code&gt; &lt;/a&gt; -catch 명령 행 옵션 은 테스트 실행 중에 control-C를보다 친숙하게 처리합니다. catch-break 동작을 사용하면 control-C는 현재 실행중인 테스트를 완료 할 수 있으며 테스트 실행은 지금까지 모든 결과를 종료하고보고합니다. 두 번째 control-c는 일반적인 방법으로 &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="63490877ff3a85f9c2d44dd0355422e762f325ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#cmdoption-unittest-discover-s&quot;&gt;&lt;code&gt;-s&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#cmdoption-unittest-discover-p&quot;&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#cmdoption-unittest-discover-t&quot;&gt;&lt;code&gt;-t&lt;/code&gt;&lt;/a&gt; options can be passed in as positional arguments in that order. The following two command lines are equivalent:</source>
          <target state="translated">&lt;a href=&quot;#cmdoption-unittest-discover-s&quot;&gt; &lt;code&gt;-s&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#cmdoption-unittest-discover-p&quot;&gt; &lt;code&gt;-p&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmdoption-unittest-discover-t&quot;&gt; &lt;code&gt;-t&lt;/code&gt; &lt;/a&gt; 옵션이 순서대로 위치 인수로 전달 될 수있다. 다음 두 명령 줄은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="6c59426c7e0123b84cab685c4b9f14badbba1fce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#code.InteractiveConsole&quot;&gt;&lt;code&gt;InteractiveConsole&lt;/code&gt;&lt;/a&gt; class is a subclass of &lt;a href=&quot;#code.InteractiveInterpreter&quot;&gt;&lt;code&gt;InteractiveInterpreter&lt;/code&gt;&lt;/a&gt;, and so offers all the methods of the interpreter objects as well as the following additions.</source>
          <target state="translated">&lt;a href=&quot;#code.InteractiveConsole&quot;&gt; &lt;code&gt;InteractiveConsole&lt;/code&gt; 의&lt;/a&gt; 클래스의 서브 클래스입니다 &lt;a href=&quot;#code.InteractiveInterpreter&quot;&gt; &lt;code&gt;InteractiveInterpreter&lt;/code&gt; &lt;/a&gt; 및 이벤트 있도록 모든 인터프리터의 방법은 다음의 추가뿐만 아니라 객체.</target>
        </trans-unit>
        <trans-unit id="96c5b96dabb5d58406339e28f0d18463c785b843" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt; class is used for decoding an input in multiple steps. It defines the following methods which every incremental decoder must define in order to be compatible with the Python codec registry.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; 의&lt;/a&gt; 클래스는 여러 단계의 입력을 디코딩하기 위해 사용된다. Python 코덱 레지스트리와 호환되도록 모든 증분 디코더에서 정의해야하는 다음 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="12b6dabe58008d386c68a529a1a3d84cc72a3fd8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt; may implement different error handling schemes by providing the &lt;em&gt;errors&lt;/em&gt; keyword argument. See &lt;a href=&quot;#error-handlers&quot;&gt;Error Handlers&lt;/a&gt; for possible values.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; 은&lt;/a&gt; , 제공에 의해 다른 오류 처리 방식을 구현할 수 &lt;em&gt;오류&lt;/em&gt; 키워드 인수를. 가능한 값 은 &lt;a href=&quot;#error-handlers&quot;&gt;오류 핸들러&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e185664ec2161e86c9fbec456c7de05f6c65ac1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt; classes provide the basic interface for incremental encoding and decoding. Encoding/decoding the input isn&amp;rsquo;t done with one call to the stateless encoder/decoder function, but with multiple calls to the &lt;a href=&quot;#codecs.IncrementalEncoder.encode&quot;&gt;&lt;code&gt;encode()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#codecs.IncrementalDecoder.decode&quot;&gt;&lt;code&gt;decode()&lt;/code&gt;&lt;/a&gt; method of the incremental encoder/decoder. The incremental encoder/decoder keeps track of the encoding/decoding process during method calls.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; &lt;/a&gt; 클래스 증분 부호화 및 복호화의 기본 인터페이스를 제공한다. 입력 인코딩 / 디코딩은 상태 비 저장 인코더 / 디코더 함수를 한 번 호출하는 것이 아니라 증분 형 인코더 / 디코더 의 &lt;a href=&quot;#codecs.IncrementalEncoder.encode&quot;&gt; &lt;code&gt;encode()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#codecs.IncrementalDecoder.decode&quot;&gt; &lt;code&gt;decode()&lt;/code&gt; &lt;/a&gt; 메서드를 여러 번 호출하여 수행 됩니다. 증분 형 인코더 / 디코더는 메서드 호출 중에 인코딩 / 디코딩 프로세스를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="bc96bb1e5bb997de11b564f8d27ab528a38179fa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; class is used for encoding an input in multiple steps. It defines the following methods which every incremental encoder must define in order to be compatible with the Python codec registry.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; 의&lt;/a&gt; 클래스는 여러 단계의 입력을 인코딩하는 데 사용된다. Python 코덱 레지스트리와 호환되도록 모든 증분 인코더가 정의해야하는 다음 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e2bd8b06f67f9be3a323becd255a18bceb81210a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; may implement different error handling schemes by providing the &lt;em&gt;errors&lt;/em&gt; keyword argument. See &lt;a href=&quot;#error-handlers&quot;&gt;Error Handlers&lt;/a&gt; for possible values.</source>
          <target state="translated">&lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; 은&lt;/a&gt; , 제공에 의해 다른 오류 처리 방식을 구현할 수 &lt;em&gt;오류&lt;/em&gt; 키워드 인수를. 가능한 값 은 &lt;a href=&quot;#error-handlers&quot;&gt;오류 핸들러&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfcf2fee9aa1a95053dfac968fc8995ea968b54f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; class is a subclass of &lt;code&gt;Codec&lt;/code&gt; and defines the following methods which every stream reader must define in order to be compatible with the Python codec registry.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 클래스의 서브 클래스 &lt;code&gt;Codec&lt;/code&gt; 모든 스트림 리더 순서대로 정의해야 다음 방법은 파이썬 코덱 레지스트리와 호환되도록 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a74db9f878ab20f93cdfdd2fabf45e07bd3fc4d5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; may implement different error handling schemes by providing the &lt;em&gt;errors&lt;/em&gt; keyword argument. See &lt;a href=&quot;#error-handlers&quot;&gt;Error Handlers&lt;/a&gt; for the standard error handlers the underlying stream codec may support.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; , 제공에 의해 다른 오류 처리 방식을 구현할 수 &lt;em&gt;오류&lt;/em&gt; 키워드 인수를. 기본 스트림 코덱이 지원할 수있는 표준 오류 처리기는 &lt;a href=&quot;#error-handlers&quot;&gt;오류 처리기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa1d63e6a14c5c60c083aca1e383d623af746e00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt;&lt;code&gt;StreamReaderWriter&lt;/code&gt;&lt;/a&gt; is a convenience class that allows wrapping streams which work in both read and write modes.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamReaderWriter&quot;&gt; &lt;code&gt;StreamReaderWriter&lt;/code&gt; 는&lt;/a&gt; 모두 읽기 및 쓰기 모드로 포장 스트림 어떤 일을 할 수있는 편리한 클래스이다.</target>
        </trans-unit>
        <trans-unit id="0a7733e3e5e214a64bb04476828836ff2628a303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamRecoder&quot;&gt;&lt;code&gt;StreamRecoder&lt;/code&gt;&lt;/a&gt; translates data from one encoding to another, which is sometimes useful when dealing with different encoding environments.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamRecoder&quot;&gt; &lt;code&gt;StreamRecoder&lt;/code&gt; 는&lt;/a&gt; 상이한 인코딩 환경을 처리 할 때 종종 유용한 다른 하나의 인코딩으로부터 데이터 변환한다.</target>
        </trans-unit>
        <trans-unit id="c06bfff712d73bdd42d5d056eaffd3eeff3467ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; classes provide generic working interfaces which can be used to implement new encoding submodules very easily. See &lt;code&gt;encodings.utf_8&lt;/code&gt; for an example of how this is done.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 클래스는 아주 쉽게 새로운 인코딩 서브 모듈을 구현하는 데 사용할 수있는 일반 작업 인터페이스를 제공합니다. 이 작업을 수행하는 방법에 대한 예제는 &lt;code&gt;encodings.utf_8&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fb9c4cff14e46f29004385b19f7361543d171a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; class is a subclass of &lt;code&gt;Codec&lt;/code&gt; and defines the following methods which every stream writer must define in order to be compatible with the Python codec registry.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스의 서브 클래스 &lt;code&gt;Codec&lt;/code&gt; 모든 스트림 작가가 순서대로 정의해야 다음 방법은 파이썬 코덱 레지스트리와 호환되도록 정의합니다.</target>
        </trans-unit>
        <trans-unit id="aef1b8ecf8fd76381a0ffc278a060efd6c603c35" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; may implement different error handling schemes by providing the &lt;em&gt;errors&lt;/em&gt; keyword argument. See &lt;a href=&quot;#error-handlers&quot;&gt;Error Handlers&lt;/a&gt; for the standard error handlers the underlying stream codec may support.</source>
          <target state="translated">&lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; , 제공에 의해 다른 오류 처리 방식을 구현할 수 &lt;em&gt;오류&lt;/em&gt; 키워드 인수를. 기본 스트림 코덱이 지원할 수있는 표준 오류 처리기는 &lt;a href=&quot;#error-handlers&quot;&gt;오류 처리기&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9bee3555767bf16eb1a388914a85c6ca66f4d100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.ChainMap&quot;&gt;&lt;code&gt;ChainMap&lt;/code&gt;&lt;/a&gt; class only makes updates (writes and deletions) to the first mapping in the chain while lookups will search the full chain. However, if deep writes and deletions are desired, it is easy to make a subclass that updates keys found deeper in the chain:</source>
          <target state="translated">&lt;a href=&quot;#collections.ChainMap&quot;&gt; &lt;code&gt;ChainMap&lt;/code&gt; 의&lt;/a&gt; 조회 전체 체인을 검색합니다 동안 클래스는 체인의 첫 번째 매핑에 대한 업데이트 (쓰기 및 삭제)를 만든다. 그러나 깊은 쓰기 및 삭제가 필요한 경우 체인에서 더 깊이 발견 된 키를 업데이트하는 서브 클래스를 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7e12096cb1dcc3b817df5f7b165f68e249dcd7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.Counter&quot;&gt;&lt;code&gt;Counter&lt;/code&gt;&lt;/a&gt; class itself is a dictionary subclass with no restrictions on its keys and values. The values are intended to be numbers representing counts, but you &lt;em&gt;could&lt;/em&gt; store anything in the value field.</source>
          <target state="translated">&lt;a href=&quot;#collections.Counter&quot;&gt; &lt;code&gt;Counter&lt;/code&gt; &lt;/a&gt; 클래스 자체는 키와 값에 제한없이 사전 서브 클래스입니다. 값은 개수를 나타내는 숫자이지만 값 필드에 아무 것도 저장할 &lt;em&gt;수&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="6086cbed3ff10b04a2566042c0149ffc2e90a216" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.Counter.elements&quot;&gt;&lt;code&gt;elements()&lt;/code&gt;&lt;/a&gt; method requires integer counts. It ignores zero and negative counts.</source>
          <target state="translated">&lt;a href=&quot;#collections.Counter.elements&quot;&gt; &lt;code&gt;elements()&lt;/code&gt; &lt;/a&gt; 메소드는 카운트 정수가 필요합니다. 0과 음수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="509800d2c98aa249e5689f757a5ee7ba2256ee10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.Counter.most_common&quot;&gt;&lt;code&gt;most_common()&lt;/code&gt;&lt;/a&gt; method requires only that the values be orderable.</source>
          <target state="translated">&lt;a href=&quot;#collections.Counter.most_common&quot;&gt; &lt;code&gt;most_common()&lt;/code&gt; &lt;/a&gt; 메소드는 값을 주문할 수있을 것만 필요로한다.</target>
        </trans-unit>
        <trans-unit id="930c05586beb6ba13547b88f3994228dfa5ece0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; was designed to be good at reordering operations. Space efficiency, iteration speed, and the performance of update operations were secondary.</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; 는&lt;/a&gt; 작업을 재정렬 잘 할 수 있도록 설계되었다. 공간 효율성, 반복 속도 및 업데이트 작업 성능이 부차적이었습니다.</target>
        </trans-unit>
        <trans-unit id="14c700a71a41622dbac3704cd157df6e5a883a12" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.OrderedDict.popitem&quot;&gt;&lt;code&gt;popitem()&lt;/code&gt;&lt;/a&gt; method for ordered dictionaries returns and removes a (key, value) pair. The pairs are returned in</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict.popitem&quot;&gt; &lt;code&gt;popitem()&lt;/code&gt; &lt;/a&gt; 명령 사전 반환 및 제거하는 (키, 값) 쌍에 대한 방법. 쌍이 반환됩니다</target>
        </trans-unit>
        <trans-unit id="a69c67ce83ebf3a08e3f3bb6aedaab859ff19801" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set&lt;/code&gt;&lt;/a&gt; mixin provides a &lt;code&gt;_hash()&lt;/code&gt; method to compute a hash value for the set; however, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; is not defined because not all sets are hashable or immutable. To add set hashability using mixins, inherit from both &lt;a href=&quot;#collections.abc.Set&quot;&gt;&lt;code&gt;Set()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#collections.abc.Hashable&quot;&gt;&lt;code&gt;Hashable()&lt;/code&gt;&lt;/a&gt;, then define &lt;code&gt;__hash__ = Set._hash&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set&lt;/code&gt; &lt;/a&gt; 믹스 인이 제공 &lt;code&gt;_hash()&lt;/code&gt; 세트의 해시 값을 계산하는 방법; 그러나 모든 세트가 해시 가능하거나 변경 불가능한 것은 아니기 때문에 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 가 정의되지 않았습니다. 믹스 인을 사용하여 해시 설정을 추가하려면 &lt;a href=&quot;#collections.abc.Set&quot;&gt; &lt;code&gt;Set()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#collections.abc.Hashable&quot;&gt; &lt;code&gt;Hashable()&lt;/code&gt; &lt;/a&gt; 에서 상속 한 다음 &lt;code&gt;__hash__ = Set._hash&lt;/code&gt; 를 정의 하십시오 .</target>
        </trans-unit>
        <trans-unit id="221671db373989976e5802c67c139377271af252" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#collections.deque.rotate&quot;&gt;&lt;code&gt;rotate()&lt;/code&gt;&lt;/a&gt; method provides a way to implement &lt;a href=&quot;#collections.deque&quot;&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/a&gt; slicing and deletion. For example, a pure Python implementation of &lt;code&gt;del d[n]&lt;/code&gt; relies on the &lt;code&gt;rotate()&lt;/code&gt; method to position elements to be popped:</source>
          <target state="translated">&lt;a href=&quot;#collections.deque.rotate&quot;&gt; &lt;code&gt;rotate()&lt;/code&gt; &lt;/a&gt; 메소드 구현하는 방법을 제공합니다 &lt;a href=&quot;#collections.deque&quot;&gt; &lt;code&gt;deque&lt;/code&gt; &lt;/a&gt; 슬라이스 및 삭제합니다. 예를 들어, &lt;code&gt;del d[n]&lt;/code&gt; 의 순수한 파이썬 구현은 &lt;code&gt;rotate()&lt;/code&gt; 시킬 요소를 위치 시키기 위해 rotate () 메소드 에 의존합니다 :</target>
        </trans-unit>
        <trans-unit id="4e569183bc5f6990d984884660176ba9ef4b859c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; class encapsulates the asynchronous execution of a callable. &lt;a href=&quot;#concurrent.futures.Future&quot;&gt;&lt;code&gt;Future&lt;/code&gt;&lt;/a&gt; instances are created by &lt;a href=&quot;#concurrent.futures.Executor.submit&quot;&gt;&lt;code&gt;Executor.submit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 클래스는 호출의 비동기 실행을 캡슐화합니다. &lt;a href=&quot;#concurrent.futures.Future&quot;&gt; &lt;code&gt;Future&lt;/code&gt; &lt;/a&gt; 인스턴스는 &lt;a href=&quot;#concurrent.futures.Executor.submit&quot;&gt; &lt;code&gt;Executor.submit()&lt;/code&gt; &lt;/a&gt; 의해 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1822bc14bc9a0b1a844ed1deebde9d250080ac69" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt; class is an &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt;&lt;code&gt;Executor&lt;/code&gt;&lt;/a&gt; subclass that uses a pool of processes to execute calls asynchronously. &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt; uses the &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; module, which allows it to side-step the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;Global Interpreter Lock&lt;/a&gt; but also means that only picklable objects can be executed and returned.</source>
          <target state="translated">&lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; 의&lt;/a&gt; 클래스는이다 &lt;a href=&quot;#concurrent.futures.Executor&quot;&gt; &lt;code&gt;Executor&lt;/code&gt; &lt;/a&gt; 비동기 호출을 실행하는 프로세스의 풀을 사용하는 서브 클래스입니다. &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-global-interpreter-lock&quot;&gt;Global Interpreter Lock을&lt;/a&gt; 회피 할 수 있지만 피클 가능한 오브젝트 만 실행하고 리턴 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="203d331c7758087cc357182ac4e448ee2ceee40b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#copy.deepcopy&quot;&gt;&lt;code&gt;deepcopy()&lt;/code&gt;&lt;/a&gt; function avoids these problems by:</source>
          <target state="translated">&lt;a href=&quot;#copy.deepcopy&quot;&gt; &lt;code&gt;deepcopy()&lt;/code&gt; &lt;/a&gt; 함수에 의해 이러한 문제를 피할 수 :</target>
        </trans-unit>
        <trans-unit id="caa491dc6320beb3427a9719796a171735692831" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.Dialect&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt; class is a container class relied on primarily for its attributes, which are used to define the parameters for a specific &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#csv.Dialect&quot;&gt; &lt;code&gt;Dialect&lt;/code&gt; &lt;/a&gt; 클래스는 컨테이너 클래스는 주로 특정에 대한 매개 변수를 정의하는 데 사용됩니다 그 속성에 대한 의존이다 &lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="b15a7ae6b823bade54f2f0c1b40edf7363d08013" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.Sniffer&quot;&gt;&lt;code&gt;Sniffer&lt;/code&gt;&lt;/a&gt; class is used to deduce the format of a CSV file.</source>
          <target state="translated">&lt;a href=&quot;#csv.Sniffer&quot;&gt; &lt;code&gt;Sniffer&lt;/code&gt; &lt;/a&gt; 클래스는 CSV 파일의 형식을 추론하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d23bf26ffbe4dd5b952da6577a2a178717e8ca08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.Sniffer&quot;&gt;&lt;code&gt;Sniffer&lt;/code&gt;&lt;/a&gt; class provides two methods:</source>
          <target state="translated">&lt;a href=&quot;#csv.Sniffer&quot;&gt; &lt;code&gt;Sniffer&lt;/code&gt; &lt;/a&gt; 클래스는 두 가지 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="ea19f633e775d51af41f15adaed6eeb3e13872ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.excel&quot;&gt;&lt;code&gt;excel&lt;/code&gt;&lt;/a&gt; class defines the usual properties of an Excel-generated CSV file. It is registered with the dialect name &lt;code&gt;'excel'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#csv.excel&quot;&gt; &lt;code&gt;excel&lt;/code&gt; &lt;/a&gt; 클래스는 엑셀에서 생성 된 CSV 파일의 일반적인 속성을 정의합니다. 방언 이름 &lt;code&gt;'excel'&lt;/code&gt; 으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="553e6a4ea2302f3aa758db648fd949972f5c4bb3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.excel_tab&quot;&gt;&lt;code&gt;excel_tab&lt;/code&gt;&lt;/a&gt; class defines the usual properties of an Excel-generated TAB-delimited file. It is registered with the dialect name &lt;code&gt;'excel-tab'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#csv.excel_tab&quot;&gt; &lt;code&gt;excel_tab&lt;/code&gt; &lt;/a&gt; 클래스는 엑셀 생성 탭으로 구분 된 파일의 일반적인 속성을 정의합니다. 방언 이름 &lt;code&gt;'excel-tab'&lt;/code&gt; 으로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="023f18c8a27378a5268ca8b5eafbc5ee0e99be10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; is hard-coded to recognise either &lt;code&gt;'\r'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; as end-of-line, and ignores &lt;em&gt;lineterminator&lt;/em&gt;. This behavior may change in the future.</source>
          <target state="translated">&lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 중 인식 코딩 어렵다 &lt;code&gt;'\r'&lt;/code&gt; 또는 &lt;code&gt;'\n'&lt;/code&gt; 끝 (end-of-line) 등을 무시하고 &lt;em&gt;lineterminator를&lt;/em&gt; . 이 동작은 나중에 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b35b42348b19c6b1314a5e48f0b28d92824e17ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#csv.unix_dialect&quot;&gt;&lt;code&gt;unix_dialect&lt;/code&gt;&lt;/a&gt; class defines the usual properties of a CSV file generated on UNIX systems, i.e. using &lt;code&gt;'\n'&lt;/code&gt; as line terminator and quoting all fields. It is registered with the dialect name &lt;code&gt;'unix'&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#csv.unix_dialect&quot;&gt; &lt;code&gt;unix_dialect&lt;/code&gt; &lt;/a&gt; 클래스는 CSV를 사용하여 UNIX 시스템에서 생성 된 파일, 즉의 일반적인 속성 정의 &lt;code&gt;'\n'&lt;/code&gt; 줄 끝으로 모든 필드를 인용합니다. 방언 이름 &lt;code&gt;'unix'&lt;/code&gt; 로 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="898a4ae235ffd60b9f411cb15628737373ee7a1e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt;&lt;code&gt;CFUNCTYPE()&lt;/code&gt;&lt;/a&gt; factory function creates types for callback functions using the &lt;code&gt;cdecl&lt;/code&gt; calling convention. On Windows, the &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt;&lt;code&gt;WINFUNCTYPE()&lt;/code&gt;&lt;/a&gt; factory function creates types for callback functions using the &lt;code&gt;stdcall&lt;/code&gt; calling convention.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.CFUNCTYPE&quot;&gt; &lt;code&gt;CFUNCTYPE()&lt;/code&gt; &lt;/a&gt; 공장 기능은 사용 콜백 기능 유형을 생성 &lt;code&gt;cdecl&lt;/code&gt; 규칙의 호출 규칙을. Windows에서 &lt;a href=&quot;#ctypes.WINFUNCTYPE&quot;&gt; &lt;code&gt;WINFUNCTYPE()&lt;/code&gt; &lt;/a&gt; 팩토리 함수는 &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하여 콜백 함수에 대한 유형을 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="ea1faf8022d86fcafadc0d6214d8c226523b156e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; class variable must, however, be defined before the type is first used (an instance is created, &lt;a href=&quot;#ctypes.sizeof&quot;&gt;&lt;code&gt;sizeof()&lt;/code&gt;&lt;/a&gt; is called on it, and so on). Later assignments to the &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; class variable will raise an AttributeError.</source>
          <target state="translated">그러나 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 클래스 변수는 유형이 처음 사용되기 전에 정의되어야합니다 (인스턴스가 작성되고 &lt;a href=&quot;#ctypes.sizeof&quot;&gt; &lt;code&gt;sizeof()&lt;/code&gt; &lt;/a&gt; 가 호출되는 등). &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 클래스 변수에 나중에 할당 하면 AttributeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="39e788a6f6117703fe1acaddcb5b42f60830bc05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ctypes.cast&quot;&gt;&lt;code&gt;cast()&lt;/code&gt;&lt;/a&gt; function can be used to cast a ctypes instance into a pointer to a different ctypes data type. &lt;a href=&quot;#ctypes.cast&quot;&gt;&lt;code&gt;cast()&lt;/code&gt;&lt;/a&gt; takes two parameters, a ctypes object that is or can be converted to a pointer of some kind, and a ctypes pointer type. It returns an instance of the second argument, which references the same memory block as the first argument:</source>
          <target state="translated">&lt;a href=&quot;#ctypes.cast&quot;&gt; &lt;code&gt;cast()&lt;/code&gt; &lt;/a&gt; 함수는 상이한하는 ctypes 데이터 형식에 대한 포인터로하는 ctypes 인스턴스를 전송할 수있다. &lt;a href=&quot;#ctypes.cast&quot;&gt; &lt;code&gt;cast()&lt;/code&gt; &lt;/a&gt; 는 두 종류의 매개 변수, 즉 어떤 종류의 포인터로 변환 될 수있는 ctypes 객체와 ctypes 포인터 유형을 취합니다. 첫 번째 인수와 동일한 메모리 블록을 참조하는 두 번째 인수의 인스턴스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f04e4712598dbb153bd55f26be6b5a134f66e409" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt;&lt;code&gt;create_string_buffer()&lt;/code&gt;&lt;/a&gt; function replaces the &lt;code&gt;c_buffer()&lt;/code&gt; function (which is still available as an alias), as well as the &lt;code&gt;c_string()&lt;/code&gt; function from earlier ctypes releases. To create a mutable memory block containing unicode characters of the C type &lt;code&gt;wchar_t&lt;/code&gt; use the &lt;a href=&quot;#ctypes.create_unicode_buffer&quot;&gt;&lt;code&gt;create_unicode_buffer()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#ctypes.create_string_buffer&quot;&gt; &lt;code&gt;create_string_buffer()&lt;/code&gt; &lt;/a&gt; 함수는 대체 &lt;code&gt;c_buffer()&lt;/code&gt; (별칭으로 계속 사용할 수 있습니다) 기능뿐만 아니라 &lt;code&gt;c_string()&lt;/code&gt; 이전하는 ctypes 릴리스의 기능을. C 유형 &lt;code&gt;wchar_t&lt;/code&gt; 의 유니 코드 문자를 포함하는 가변 메모리 블록을 작성하려면 &lt;a href=&quot;#ctypes.create_unicode_buffer&quot;&gt; &lt;code&gt;create_unicode_buffer()&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc1abd016bdf60e677ca1c13260f47722c20943b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ctypes.resize&quot;&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;/a&gt; function can be used to resize the memory buffer of an existing ctypes object. The function takes the object as first argument, and the requested size in bytes as the second argument. The memory block cannot be made smaller than the natural memory block specified by the objects type, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised if this is tried:</source>
          <target state="translated">&lt;a href=&quot;#ctypes.resize&quot;&gt; &lt;code&gt;resize()&lt;/code&gt; &lt;/a&gt; 함수는 존재하는 ctypes 객체의 메모리 버퍼의 크기를 조절하는데 사용될 수있다. 이 함수는 객체를 첫 번째 인수로, 요청 된 크기 (바이트)를 두 번째 인수로 사용합니다. 메모리 블록은 객체 유형에 의해 지정된 자연 메모리 블록보다 작게 만들 수 없습니다. 이 작업을 시도하면 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="17c7ed721f6c997536e3eae62333ddd1ec2d70f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#curses.filter&quot;&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/a&gt; routine, if used, must be called before &lt;a href=&quot;#curses.initscr&quot;&gt;&lt;code&gt;initscr()&lt;/code&gt;&lt;/a&gt; is called. The effect is that, during those calls, &lt;code id=&quot;index-0&quot;&gt;LINES&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt;; the capabilities &lt;code&gt;clear&lt;/code&gt;, &lt;code&gt;cup&lt;/code&gt;, &lt;code&gt;cud&lt;/code&gt;, &lt;code&gt;cud1&lt;/code&gt;, &lt;code&gt;cuu1&lt;/code&gt;, &lt;code&gt;cuu&lt;/code&gt;, &lt;code&gt;vpa&lt;/code&gt; are disabled; and the &lt;code&gt;home&lt;/code&gt; string is set to the value of &lt;code&gt;cr&lt;/code&gt;. The effect is that the cursor is confined to the current line, and so are screen updates. This may be used for enabling character-at-a-time line editing without touching the rest of the screen.</source>
          <target state="translated">&lt;a href=&quot;#curses.filter&quot;&gt; &lt;code&gt;filter()&lt;/code&gt; &lt;/a&gt; , 사용 된 경우, 이전에 호출해야 루틴 &lt;a href=&quot;#curses.initscr&quot;&gt; &lt;code&gt;initscr()&lt;/code&gt; &lt;/a&gt; 호출된다. 결과적으로 해당 통화 중에 &lt;code id=&quot;index-0&quot;&gt;LINES&lt;/code&gt; 는 &lt;code&gt;1&lt;/code&gt; 로 설정됩니다 . 기능은 &lt;code&gt;clear&lt;/code&gt; , &lt;code&gt;cup&lt;/code&gt; , &lt;code&gt;cud&lt;/code&gt; , &lt;code&gt;cud1&lt;/code&gt; , &lt;code&gt;cuu1&lt;/code&gt; , &lt;code&gt;cuu&lt;/code&gt; , &lt;code&gt;vpa&lt;/code&gt; 사용할 수 없습니다; 그리고 &lt;code&gt;home&lt;/code&gt; 문자열의 값으로 설정됩니다 &lt;code&gt;cr&lt;/code&gt; . 커서가 현재 줄에 국한되어 화면이 업데이트되는 효과가 있습니다. 화면의 나머지 부분을 건드리지 않고 한 번에 한 줄씩 편집 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="316363716152925b75d3cb4ebaef9b0e32360b84" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator examines the class to find &lt;code&gt;field&lt;/code&gt;s. A &lt;code&gt;field&lt;/code&gt; is defined as class variable that has a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-variable-annotation&quot;&gt;type annotation&lt;/a&gt;. With two exceptions described below, nothing in &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; examines the type specified in the variable annotation.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 데코레이터 찾을 수있는 클래스를 검사 &lt;code&gt;field&lt;/code&gt; 들. &lt;code&gt;field&lt;/code&gt; 가 클래스 변수로 정의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-variable-annotation&quot;&gt;형의 주석을&lt;/a&gt; . 아래에 설명 된 두 가지 예외를 제외하고 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 에서는 변수 주석에 지정된 유형을 검사 하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4699e9b5a61dff36896adb38ef9387de7f4bbf32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; decorator will add various &amp;ldquo;dunder&amp;rdquo; methods to the class, described below. If any of the added methods already exist on the class, the behavior depends on the parameter, as documented below. The decorator returns the same class that is called on; no new class is created.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 장식은 후술하는 클래스의 방법 &quot;던더&quot;다양한 추가한다. 추가 된 메소드 중 하나라도 이미 클래스에 존재하면 동작은 아래에 설명 된대로 매개 변수에 따라 다릅니다. 데코레이터는 호출 된 것과 동일한 클래스를 반환합니다. 새로운 수업이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="63c38db09f7ff00463891fd5330badf211e2c04f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#datetime.date&quot;&gt;&lt;code&gt;date&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; types share these common features:</source>
          <target state="translated">&lt;a href=&quot;#datetime.date&quot;&gt; &lt;code&gt;date&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 유형이 공통적 인 특징을 공유 :</target>
        </trans-unit>
        <trans-unit id="7285c2c2396c8d7548a1767431a66dc14e38b3e7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class is a subclass of &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt;, each instance of which represents a timezone defined by a fixed offset from UTC.</source>
          <target state="translated">&lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 클래스의 하위 클래스 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 각 인스턴스는의이 UTC에서 고정 된 오프셋에 의해 정의되는 시간대를 나타낸다.</target>
        </trans-unit>
        <trans-unit id="30ab4c018014c365ee7ffb771c34bba718d05f93" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; class defines several general purpose methods as well as a large number of methods for doing arithmetic directly in a given context. In addition, for each of the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; methods described above (with the exception of the &lt;code&gt;adjusted()&lt;/code&gt; and &lt;code&gt;as_tuple()&lt;/code&gt; methods) there is a corresponding &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; method. For example, for a &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; instance &lt;code&gt;C&lt;/code&gt; and &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;C.exp(x)&lt;/code&gt; is equivalent to &lt;code&gt;x.exp(context=C)&lt;/code&gt;. Each &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; method accepts a Python integer (an instance of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;) anywhere that a Decimal instance is accepted.</source>
          <target state="translated">&lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 클래스는 여러 범용 방법뿐만 아니라 주어진 상황에서 직접 연산 수행하기위한 방법의 큰 숫자를 정의합니다. 또한 위에서 설명한 각 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 메서드 ( &lt;code&gt;adjusted()&lt;/code&gt; 및 &lt;code&gt;as_tuple()&lt;/code&gt; 메서드 제외)에 해당하는 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 메서드가 있습니다. 예를 들어, &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 인스턴스 &lt;code&gt;C&lt;/code&gt; 및 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스 &lt;code&gt;x&lt;/code&gt; 의 경우 &lt;code&gt;C.exp(x)&lt;/code&gt; 는 &lt;code&gt;x.exp(context=C)&lt;/code&gt; . 각 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 메소드는 Python 정수 ( &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 의 인스턴스)를 허용합니다.) Decimal 인스턴스가 허용되는 모든 위치.</target>
        </trans-unit>
        <trans-unit id="4c2451a4b748fe7038fb95ffc7f31dc59d1bfe5e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; function accesses a different &lt;a href=&quot;#decimal.Context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; object for each thread. Having separate thread contexts means that threads may make changes (such as &lt;code&gt;getcontext().prec=10&lt;/code&gt;) without interfering with other threads.</source>
          <target state="translated">&lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 함수는 다른 액세스 &lt;a href=&quot;#decimal.Context&quot;&gt; &lt;code&gt;Context&lt;/code&gt; &lt;/a&gt; 각 스레드 개체. 별도의 스레드 컨텍스트가 있으면 스레드가 다른 스레드를 방해하지 않고 변경 (예 : &lt;code&gt;getcontext().prec=10&lt;/code&gt; ) 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="262401b2372aaa25cb2cdfc7cb06fb241a0f0bdc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#difflib.Differ&quot;&gt;&lt;code&gt;Differ&lt;/code&gt;&lt;/a&gt; class has this constructor:</source>
          <target state="translated">&lt;a href=&quot;#difflib.Differ&quot;&gt; &lt;code&gt;Differ&lt;/code&gt; &lt;/a&gt; 클래스는 생성자가 :</target>
        </trans-unit>
        <trans-unit id="f84a219ce565ea3dd400d91f14baef3e6167fa14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt;&lt;code&gt;SequenceMatcher&lt;/code&gt;&lt;/a&gt; class has this constructor:</source>
          <target state="translated">&lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt; &lt;code&gt;SequenceMatcher&lt;/code&gt; 의&lt;/a&gt; 클래스는 생성자가 :</target>
        </trans-unit>
        <trans-unit id="f1a296dacbe11dd809b20737940faffda6e869f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#difflib.get_close_matches&quot;&gt;&lt;code&gt;get_close_matches()&lt;/code&gt;&lt;/a&gt; function in this module which shows how simple code building on &lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt;&lt;code&gt;SequenceMatcher&lt;/code&gt;&lt;/a&gt; can be used to do useful work.</source>
          <target state="translated">이 모듈 의 &lt;a href=&quot;#difflib.get_close_matches&quot;&gt; &lt;code&gt;get_close_matches()&lt;/code&gt; &lt;/a&gt; 함수는 &lt;a href=&quot;#difflib.SequenceMatcher&quot;&gt; &lt;code&gt;SequenceMatcher&lt;/code&gt; &lt;/a&gt; 에서 간단한 코드 작성을 사용하여 유용한 작업을 수행 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="7f4ec7076d0fb2f20af8c32cf7906ea9bc88fdf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#dis.get_instructions&quot;&gt;&lt;code&gt;get_instructions()&lt;/code&gt;&lt;/a&gt; function and &lt;a href=&quot;#dis.Bytecode&quot;&gt;&lt;code&gt;Bytecode&lt;/code&gt;&lt;/a&gt; class provide details of bytecode instructions as &lt;a href=&quot;#dis.Instruction&quot;&gt;&lt;code&gt;Instruction&lt;/code&gt;&lt;/a&gt; instances:</source>
          <target state="translated">&lt;a href=&quot;#dis.get_instructions&quot;&gt; &lt;code&gt;get_instructions()&lt;/code&gt; &lt;/a&gt; 기능과 &lt;a href=&quot;#dis.Bytecode&quot;&gt; &lt;code&gt;Bytecode&lt;/code&gt; &lt;/a&gt; 클래스로 바이트 코드 지침의 세부 사항을 제공 &lt;a href=&quot;#dis.Instruction&quot;&gt; &lt;code&gt;Instruction&lt;/code&gt; &lt;/a&gt; 경우 :</target>
        </trans-unit>
        <trans-unit id="b8609345658f9e3f7fd9c556781a8ceab1948f77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt; class is a subclass of &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; that raises an exception for the first failing example, containing information about that example. This information can be used to perform post-mortem debugging on the example.</source>
          <target state="translated">&lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; 의&lt;/a&gt; 클래스의 하위 클래스 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 하는 예에 대한 정보를 포함하는, 제 실패 예컨대 예외를 제기한다. 이 정보는 예제에서 사후 디버깅을 수행하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a753b5aee0860388f6f4914fb3a05c949fe9effa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt; class, and the special exceptions it may raise, are of most interest to testing framework authors, and will only be sketched here. See the source code, and especially &lt;a href=&quot;#doctest.DebugRunner&quot;&gt;&lt;code&gt;DebugRunner&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s docstring (which is a doctest!) for more details:</source>
          <target state="translated">&lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; 의&lt;/a&gt; 클래스, 그리고 올리 수있는 특별한 예외가 프레임 워크의 저자 테스트에 가장 관심이있는, 오직 여기 스케치됩니다. 자세한 내용은 소스 코드, 특히 &lt;a href=&quot;#doctest.DebugRunner&quot;&gt; &lt;code&gt;DebugRunner&lt;/code&gt; &lt;/a&gt; 의 docstring (doctest입니다!)을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db4e4d2f74c5768a719d3127ef0d73fd7ed1c368" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#doctest.DocTest&quot;&gt;&lt;code&gt;DocTest&lt;/code&gt;&lt;/a&gt; object that was being run when the example failed.</source>
          <target state="translated">&lt;a href=&quot;#doctest.DocTest&quot;&gt; &lt;code&gt;DocTest&lt;/code&gt; &lt;/a&gt; 예제가 실패했을 때 실행되는 한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="e14145b7ea305b81edc3a0187c0f5ae4147252d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt;&lt;code&gt;ELLIPSIS&lt;/code&gt;&lt;/a&gt; directive gives a nice approach for the last example:</source>
          <target state="translated">&lt;a href=&quot;#doctest.ELLIPSIS&quot;&gt; &lt;code&gt;ELLIPSIS&lt;/code&gt; &lt;/a&gt; 지시어는 마지막 예를 들어 좋은 접근 방식을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="a3fd9ed4c6f4d1c3ee85bd113b3a6e65aced55a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#doctest.Example&quot;&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/a&gt; that failed.</source>
          <target state="translated">&lt;a href=&quot;#doctest.Example&quot;&gt; &lt;code&gt;Example&lt;/code&gt; &lt;/a&gt; 에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="12952789268d4531a057ffffdea84d074c22d65e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.charset.Charset&quot;&gt;&lt;code&gt;Charset&lt;/code&gt;&lt;/a&gt; class also provides a number of methods to support standard operations and built-in functions.</source>
          <target state="translated">&lt;a href=&quot;#email.charset.Charset&quot;&gt; &lt;code&gt;Charset&lt;/code&gt; &lt;/a&gt; 클래스는 표준 운영 및 기능 내장을 지원하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e24f5e3fa9d9f920266109958df4565b0b3c077b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; class can be used to flatten a message into a text (as opposed to binary) serialized representation, but since Unicode cannot represent binary data directly, the message is of necessity transformed into something that contains only ASCII characters, using the standard email RFC Content Transfer Encoding techniques for encoding email messages for transport over channels that are not &amp;ldquo;8 bit clean&amp;rdquo;.</source>
          <target state="translated">&lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 직렬화 표현 (바이너리 반대) 클래스는 텍스트로 메시지를 평평하게 사용할 수 있지만, 유니 코드를 직접 바이너리 데이터를 표시 할 수 없기 때문에, 메시지는 표준 이메일 RFC를 사용하여 ASCII 문자 만 포함 무언가로 변환 필요하다 &quot;8 비트 클린&quot;이 아닌 채널을 통한 전송을 위해 이메일 메시지를 인코딩하기위한 컨텐츠 전송 인코딩 기술.</target>
        </trans-unit>
        <trans-unit id="57c1078eb78d57874e3db83f4f9d2a1a41f52b0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.header.Header&quot;&gt;&lt;code&gt;Header&lt;/code&gt;&lt;/a&gt; class also provides a number of methods to support standard operators and built-in functions.</source>
          <target state="translated">&lt;a href=&quot;#email.header.Header&quot;&gt; &lt;code&gt;Header&lt;/code&gt; &lt;/a&gt; 클래스는 표준 연산자와 함수 내장을 지원하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ff0626c380b6c21daadf51b2206b16b6e1b3b18b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; dictionary-like interface is indexed by the header names, which must be ASCII values. The values of the dictionary are strings with some extra methods. Headers are stored and returned in case-preserving form, but field names are matched case-insensitively. Unlike a real dict, there is an ordering to the keys, and there can be duplicate keys. Additional methods are provided for working with headers that have duplicate keys.</source>
          <target state="translated">&lt;a href=&quot;#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 사전과 같은 인터페이스는 ASCII 값이어야합니다 헤더 이름에 의해 색인이 생성됩니다. 사전의 값은 몇 가지 추가 방법이있는 문자열입니다. 헤더는 대소 문자를 유지하면서 저장 및 반환되지만 필드 이름은 대소 문자를 구분하지 않습니다. 실제 명령과 달리 키 순서가 있으며 중복 키가있을 수 있습니다. 중복 키가있는 헤더 작업을위한 추가 방법이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7beb5e5a031dd79580c00039aecf0006eddf006e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.message.EmailMessage.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use &lt;a href=&quot;#email.message.EmailMessage.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; as the iterator in a &lt;code&gt;for&lt;/code&gt; loop; each iteration returns the next subpart.</source>
          <target state="translated">&lt;a href=&quot;#email.message.EmailMessage.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 메소드는, 깊이 우선 탐색을 위하여, 부품, 메시지 오브젝트 트리의 모든 서브 파트를 반복하는 데 사용할 수있는 다목적 발생기이다. 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 에서 &lt;a href=&quot;#email.message.EmailMessage.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 를 반복자로 사용 합니다. 각 반복은 다음 하위 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="51f30eb0997a6bed3821ee80398f62d132641248" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; class is very similar to the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class, without the methods added by that class, and with the default behavior of certain other methods being slightly different. We also document here some methods that, while supported by the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; class, are not recommended unless you are dealing with legacy code.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 클래스는 매우 유사하다 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 클래스에 의해 추가 된 방법없이, 클래스, 및 기타 방법의 기본 동작이 약간 다른 존재로. 또한 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 클래스에서 지원하지만 레거시 코드를 다루지 않는 한 권장되지 않는 일부 메소드도 여기에 문서화되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2137b67a1cad530c1434e4f34ea24dddaa0f111b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; pseudo-dictionary is indexed by the header names, which must be ASCII values. The values of the dictionary are strings that are supposed to contain only ASCII characters; there is some special handling for non-ASCII input, but it doesn&amp;rsquo;t always produce the correct results. Headers are stored and returned in case-preserving form, but field names are matched case-insensitively. There may also be a single envelope header, also known as the &lt;em&gt;Unix-From&lt;/em&gt; header or the &lt;code&gt;From_&lt;/code&gt; header. The &lt;em&gt;payload&lt;/em&gt; is either a string or bytes, in the case of simple message objects, or a list of &lt;a href=&quot;#email.message.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; objects, for MIME container documents (e.g. &lt;em&gt;multipart/*&lt;/em&gt; and &lt;em&gt;message/rfc822&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 의사 사전은 ASCII 값이어야합니다 헤더 이름에 의해 색인이 생성됩니다. 사전의 값은 ASCII 문자 만 포함해야하는 문자열입니다. 비 ASCII 입력에 대한 특수 처리가 있지만 항상 올바른 결과를 생성하지는 않습니다. 헤더는 대소 문자를 유지하면서 저장 및 반환되지만 필드 이름은 대소 문자를 구분하지 않습니다. &lt;em&gt;Unix-From&lt;/em&gt; 헤더 또는 &lt;code&gt;From_&lt;/code&gt; 헤더 라고도하는 단일 봉투 헤더가있을 수도 있습니다 . &lt;em&gt;페이로드&lt;/em&gt; 중 문자열 또는 단순한 메시지 오브젝트의 경우에는, 바이트, 또는 목록 &lt;a href=&quot;#email.message.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; (예를 들어, MIME 컨테이너 문서 객체 &lt;em&gt;다중 / *&lt;/em&gt; 및 &lt;em&gt;메시지 / RFC822&lt;/em&gt;).</target>
        </trans-unit>
        <trans-unit id="ca981282c5517da9128d2368f106a4e670e04bb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.message.Message.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; method is an all-purpose generator which can be used to iterate over all the parts and subparts of a message object tree, in depth-first traversal order. You will typically use &lt;a href=&quot;#email.message.Message.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; as the iterator in a &lt;code&gt;for&lt;/code&gt; loop; each iteration returns the next subpart.</source>
          <target state="translated">&lt;a href=&quot;#email.message.Message.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 메소드는, 깊이 우선 탐색을 위하여, 부품, 메시지 오브젝트 트리의 모든 서브 파트를 반복하는 데 사용할 수있는 다목적 발생기이다. 일반적으로 &lt;code&gt;for&lt;/code&gt; 루프 에서 &lt;a href=&quot;#email.message.Message.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 를 반복자로 사용 합니다. 각 반복은 다음 하위 부분을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4efcfb3c7cb51e40bed4d82c7465685ab9a3df4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt;&lt;code&gt;MIMEBase&lt;/code&gt;&lt;/a&gt; class always adds a &lt;em&gt;Content-Type&lt;/em&gt; header (based on &lt;em&gt;_maintype&lt;/em&gt;, &lt;em&gt;_subtype&lt;/em&gt;, and &lt;em&gt;_params&lt;/em&gt;), and a &lt;em&gt;MIME-Version&lt;/em&gt; header (always set to &lt;code&gt;1.0&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;#email.mime.base.MIMEBase&quot;&gt; &lt;code&gt;MIMEBase&lt;/code&gt; 의&lt;/a&gt; 클래스는 항상 추가 &lt;em&gt;내용 - 형식&lt;/em&gt; (에 따라 헤더 &lt;em&gt;_maintype&lt;/em&gt; , &lt;em&gt;_subtype&lt;/em&gt; 및 &lt;em&gt;_params&lt;/em&gt; ) 및 &lt;em&gt;MIME - 버전&lt;/em&gt; 헤더 (항상로 설정 &lt;code&gt;1.0&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b5297e6544521f2b54ac92dce43d72fcb5f8e9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt;&amp;rsquo;s API is simple; you create an instance, feed it a bunch of bytes until there&amp;rsquo;s no more to feed it, then close the parser to retrieve the root message object. The &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt; is extremely accurate when parsing standards-compliant messages, and it does a very good job of parsing non-compliant messages, providing information about how a message was deemed broken. It will populate a message object&amp;rsquo;s &lt;a href=&quot;email.message#email.message.EmailMessage.defects&quot;&gt;&lt;code&gt;defects&lt;/code&gt;&lt;/a&gt; attribute with a list of any problems it found in a message. See the &lt;a href=&quot;email.errors#module-email.errors&quot;&gt;&lt;code&gt;email.errors&lt;/code&gt;&lt;/a&gt; module for the list of defects that it can find.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; &lt;/a&gt; 의 API는 간단하다; 더 이상 인스턴스를 만들지 않을 때까지 인스턴스를 생성하고 많은 바이트를 공급 한 다음 파서를 닫아 루트 메시지 객체를 검색합니다. &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; 는&lt;/a&gt; 표준을 준수하는 메시지를 구문 분석 할 때 매우 정확하며, 비 호환 메시지를 구문 분석 메시지가 깨진 것으로 간주 된 방법에 대한 정보를 제공하는 아주 좋은 일을한다. 메시지 에서 발견 된 모든 문제의 목록으로 메시지 객체의 &lt;a href=&quot;email.message#email.message.EmailMessage.defects&quot;&gt; &lt;code&gt;defects&lt;/code&gt; &lt;/a&gt; 속성을 채 웁니다 . 찾을 수있는 결함 목록은 &lt;a href=&quot;email.errors#module-email.errors&quot;&gt; &lt;code&gt;email.errors&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="455ea518b92fec5912569d645995d649271f1068" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt;, imported from the &lt;code&gt;email.feedparser&lt;/code&gt; module, provides an API that is conducive to incremental parsing of email messages, such as would be necessary when reading the text of an email message from a source that can block (such as a socket). The &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt;&lt;code&gt;BytesFeedParser&lt;/code&gt;&lt;/a&gt; can of course be used to parse an email message fully contained in a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;, string, or file, but the &lt;a href=&quot;#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt; API may be more convenient for such use cases. The semantics and results of the two parser APIs are identical.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; &lt;/a&gt; 으로부터 수입 &lt;code&gt;email.feedparser&lt;/code&gt; 의 모듈은 (예 : 소켓으로) 차단할 수있는 소스에서 이메일 메시지의 텍스트를 읽을 때 필요하다와 같은 전자 메일 메시지의 증가 분석에 도움이되는 API를 제공합니다. &lt;a href=&quot;#email.parser.BytesFeedParser&quot;&gt; &lt;code&gt;BytesFeedParser&lt;/code&gt; 는&lt;/a&gt; 물론 완전히에 포함 된 전자 메일 메시지 구문 분석하는 데 사용할 수있는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; , 문자열, 또는 파일,하지만 &lt;a href=&quot;#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; 의&lt;/a&gt; API는 사용 사례에 대한 더 편리 할 수 있습니다. 두 파서 API의 의미와 결과는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="23578df0528e2bcfa2d13e7a22ac4991916102e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt; class, imported from the &lt;a href=&quot;#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; module, provides an API that can be used to parse a message when the complete contents of the message are available in a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; or file. The &lt;a href=&quot;#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; module also provides &lt;a href=&quot;#email.parser.Parser&quot;&gt;&lt;code&gt;Parser&lt;/code&gt;&lt;/a&gt; for parsing strings, and header-only parsers, &lt;a href=&quot;#email.parser.BytesHeaderParser&quot;&gt;&lt;code&gt;BytesHeaderParser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#email.parser.HeaderParser&quot;&gt;&lt;code&gt;HeaderParser&lt;/code&gt;&lt;/a&gt;, which can be used if you&amp;rsquo;re only interested in the headers of the message. &lt;a href=&quot;#email.parser.BytesHeaderParser&quot;&gt;&lt;code&gt;BytesHeaderParser&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#email.parser.HeaderParser&quot;&gt;&lt;code&gt;HeaderParser&lt;/code&gt;&lt;/a&gt; can be much faster in these situations, since they do not attempt to parse the message body, instead setting the payload to the raw body.</source>
          <target state="translated">&lt;a href=&quot;#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; 의&lt;/a&gt; 으로부터 수입 클래스, &lt;a href=&quot;#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; 의&lt;/a&gt; 모듈은 메시지의 전체 내용은에서 사용할 수있는 메시지를 구문 분석하는 데 사용할 수있는 API 제공 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 같은 객체&lt;/a&gt; 나 파일을. &lt;a href=&quot;#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; 의&lt;/a&gt; 모듈도 제공 &lt;a href=&quot;#email.parser.Parser&quot;&gt; &lt;code&gt;Parser&lt;/code&gt; &lt;/a&gt; 구문 분석 문자열 및 헤더 전용 파서에 대한 &lt;a href=&quot;#email.parser.BytesHeaderParser&quot;&gt; &lt;code&gt;BytesHeaderParser&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#email.parser.HeaderParser&quot;&gt; &lt;code&gt;HeaderParser&lt;/code&gt; &lt;/a&gt; 만 메시지의 헤더에 관심이 있다면 사용할 수 있습니다. &lt;a href=&quot;#email.parser.BytesHeaderParser&quot;&gt; &lt;code&gt;BytesHeaderParser&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#email.parser.HeaderParser&quot;&gt; &lt;code&gt;HeaderParser&lt;/code&gt; &lt;/a&gt; 는 메시지 본문을 구문 분석하지 않고 페이로드를 원시 본문으로 설정하기 때문에 이러한 상황에서 훨씬 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85bf3f39230092aa892f16e0f7eecb87426fe897" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; class is callable, providing the following functional API:</source>
          <target state="translated">&lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 클래스는 다음과 같은 기능 API를 제공 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6c277b78ba2ec81d6d2de28b1c77027805e2aa66" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#event-loop-implementations&quot;&gt;Event Loop Implementations&lt;/a&gt; section documents the &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; classes;</source>
          <target state="translated">&lt;a href=&quot;#event-loop-implementations&quot;&gt;이벤트 루프 구현의&lt;/a&gt; 섹션 기록한 &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 클래스;</target>
        </trans-unit>
        <trans-unit id="1cdbf0a871b5a60d9146255b077a077d5731d02d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#event-loop-methods&quot;&gt;Event Loop Methods&lt;/a&gt; section is the reference documentation of the event loop APIs;</source>
          <target state="translated">&lt;a href=&quot;#event-loop-methods&quot;&gt;이벤트 루프 방법&lt;/a&gt; 섹션은 이벤트 루프의 API 참조 문서입니다;</target>
        </trans-unit>
        <trans-unit id="5ea2c779a8d4a043248492f818a19fe18aed4343" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt; section showcases how to work with some event loop APIs.</source>
          <target state="translated">&lt;a href=&quot;#examples&quot;&gt;예제&lt;/a&gt; 섹션 쇼케이스에서는 일부 이벤트 루프 API를 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="0b489d830a7d9d9099ae9cf3e071f2eb2d0ffc41" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#examples&quot;&gt;Examples&lt;/a&gt; section showcases how to work with transports, protocols, and low-level event loop APIs.</source>
          <target state="translated">&lt;a href=&quot;#examples&quot;&gt;예제&lt;/a&gt; 섹션 쇼케이스 방법 전송, 프로토콜 및 낮은 수준의 이벤트 루프 API를 사용하여 작업합니다.</target>
        </trans-unit>
        <trans-unit id="46a625abe6df6aa03f16639dd4d7da65b44c473b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#filecmp.dircmp&quot;&gt;&lt;code&gt;dircmp&lt;/code&gt;&lt;/a&gt; class compares files by doing &lt;em&gt;shallow&lt;/em&gt; comparisons as described for &lt;a href=&quot;#filecmp.cmp&quot;&gt;&lt;code&gt;filecmp.cmp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#filecmp.dircmp&quot;&gt; &lt;code&gt;dircmp&lt;/code&gt; &lt;/a&gt; 클래스를 수행하여 파일을 비교 &lt;em&gt;얕은의&lt;/em&gt; 에 기재 한 바와 같이 비교를 &lt;a href=&quot;#filecmp.cmp&quot;&gt; &lt;code&gt;filecmp.cmp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbd2c2804abf18aa233595f2c9066be859802a7d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#filecmp.dircmp&quot;&gt;&lt;code&gt;dircmp&lt;/code&gt;&lt;/a&gt; class offers a number of interesting attributes that may be used to get various bits of information about the directory trees being compared.</source>
          <target state="translated">&lt;a href=&quot;#filecmp.dircmp&quot;&gt; &lt;code&gt;dircmp&lt;/code&gt; &lt;/a&gt; 클래스는 비교되는 디렉토리 트리에 대한 다양한 정보 비트를 얻기 위해 사용될 수있는 흥미로운 속성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="72adb57220e6e99be6d29493dd6a1420ee7c643f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#filecmp.dircmp&quot;&gt;&lt;code&gt;dircmp&lt;/code&gt;&lt;/a&gt; class provides the following methods:</source>
          <target state="translated">&lt;a href=&quot;#filecmp.dircmp&quot;&gt; &lt;code&gt;dircmp&lt;/code&gt; &lt;/a&gt; 클래스는 다음과 같은 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="19db21dafd9ed069b9a82326fff208a83767e71d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#fileinput.FileInput&quot;&gt;&lt;code&gt;FileInput&lt;/code&gt;&lt;/a&gt; instance can be used as a context manager in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. In this example, &lt;em&gt;input&lt;/em&gt; is closed after the &lt;code&gt;with&lt;/code&gt; statement is exited, even if an exception occurs:</source>
          <target state="translated">&lt;a href=&quot;#fileinput.FileInput&quot;&gt; &lt;code&gt;FileInput&lt;/code&gt; &lt;/a&gt; 인스턴스가있는 컨텍스트 관리자로 사용할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문. 이 예제에서 예외가 발생하더라도 &lt;code&gt;with&lt;/code&gt; 문이 종료 된 후 &lt;em&gt;입력&lt;/em&gt; 이 닫힙니다 .</target>
        </trans-unit>
        <trans-unit id="0c4e28be954ee79e9597284f6ac163856e52fada" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; class inherits from the abstract base class &lt;a href=&quot;numbers#numbers.Rational&quot;&gt;&lt;code&gt;numbers.Rational&lt;/code&gt;&lt;/a&gt;, and implements all of the methods and operations from that class. &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; instances are hashable, and should be treated as immutable. In addition, &lt;a href=&quot;#fractions.Fraction&quot;&gt;&lt;code&gt;Fraction&lt;/code&gt;&lt;/a&gt; has the following properties and methods:</source>
          <target state="translated">&lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 클래스의 추상 기본 클래스에서 상속 &lt;a href=&quot;numbers#numbers.Rational&quot;&gt; &lt;code&gt;numbers.Rational&lt;/code&gt; &lt;/a&gt; 및 구현 클래스의 방법과 모든 작업. &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 인스턴스는 해시 가능하며 불변으로 처리해야합니다. 또한 &lt;a href=&quot;#fractions.Fraction&quot;&gt; &lt;code&gt;Fraction&lt;/code&gt; &lt;/a&gt; 에는 다음과 같은 속성과 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bcd4b660916451139fc57514e9529994a253ed2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ftplib.FTP&quot;&gt;&lt;code&gt;FTP&lt;/code&gt;&lt;/a&gt; class supports the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement, e.g.:</source>
          <target state="translated">&lt;a href=&quot;#ftplib.FTP&quot;&gt; &lt;code&gt;FTP&lt;/code&gt; 의&lt;/a&gt; 클래스는 지원 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문, 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="cfa181fb78bf9ba81555b448529484ffdd34a22c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#functools.partial&quot;&gt;&lt;code&gt;partial()&lt;/code&gt;&lt;/a&gt; is used for partial function application which &amp;ldquo;freezes&amp;rdquo; some portion of a function&amp;rsquo;s arguments and/or keywords resulting in a new object with a simplified signature. For example, &lt;a href=&quot;#functools.partial&quot;&gt;&lt;code&gt;partial()&lt;/code&gt;&lt;/a&gt; can be used to create a callable that behaves like the &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt; function where the &lt;em&gt;base&lt;/em&gt; argument defaults to two:</source>
          <target state="translated">&lt;a href=&quot;#functools.partial&quot;&gt; &lt;code&gt;partial()&lt;/code&gt; &lt;/a&gt; 함수의 인수 및 / 또는 간략화 서명 새로운 객체 결과 키워드의 일부를 &quot;정지&quot;기능 일부 애플리케이션에 사용된다. 예를 들어 &lt;a href=&quot;#functools.partial&quot;&gt; &lt;code&gt;partial()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 &lt;em&gt;기본&lt;/em&gt; 인수의 기본값이 2 인 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; 함수 와 같은 동작을하는 호출 가능 객체를 만들 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b92768c0557e915145268b557943da321bb07ba9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt; class</source>
          <target state="translated">&lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; 의&lt;/a&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="0e65da98e6eb2e07ea2a424434d84f7b1e5135c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#gettext.NullTranslations&quot;&gt;&lt;code&gt;NullTranslations&lt;/code&gt;&lt;/a&gt; class</source>
          <target state="translated">&lt;a href=&quot;#gettext.NullTranslations&quot;&gt; &lt;code&gt;NullTranslations&lt;/code&gt; 의&lt;/a&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="de0c6d582e790dcb21659a701d2610820617b77d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; class uses the SGML syntactic rules for processing instructions. An XHTML processing instruction using the trailing &lt;code&gt;'?'&lt;/code&gt; will cause the &lt;code&gt;'?'&lt;/code&gt; to be included in &lt;em&gt;data&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; 의&lt;/a&gt; 클래스는 명령을 처리하는 SGML 구문 규칙을 사용합니다. 후행 &lt;code&gt;'?'&lt;/code&gt; 를 사용하는 XHTML 처리 명령 원인 것 &lt;code&gt;'?'&lt;/code&gt; &lt;em&gt;데이터에&lt;/em&gt; 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="1eb39bcce74f6e84c6360ac4ce120085f00979c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; class also defines the following method:</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.Cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 클래스는 다음과 같은 방법을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="ff5b055fb2cf07cb0cc7bbc35321af963ac5bcb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; class stores HTTP cookies. It extracts cookies from HTTP requests, and returns them in HTTP responses. &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; instances automatically expire contained cookies when necessary. Subclasses are also responsible for storing and retrieving cookies from a file or database.</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 의&lt;/a&gt; 클래스를 저장 HTTP 쿠키. HTTP 요청에서 쿠키를 추출하여 HTTP 응답으로 반환합니다. &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; &lt;/a&gt; 인스턴스는 필요할 때 포함 된 쿠키를 자동으로 만료합니다. 서브 클래스는 파일이나 데이터베이스에서 쿠키를 저장하고 검색하는 역할도합니다.</target>
        </trans-unit>
        <trans-unit id="d62327d1da1bdae98350ead4c676a194b62121b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;CookieJar&lt;/code&gt;&lt;/a&gt; will look for allowable &lt;em&gt;Set-Cookie&lt;/em&gt; and &lt;em&gt;Set-Cookie2&lt;/em&gt; headers in the &lt;em&gt;response&lt;/em&gt; argument, and store cookies as appropriate (subject to the &lt;a href=&quot;#http.cookiejar.CookiePolicy.set_ok&quot;&gt;&lt;code&gt;CookiePolicy.set_ok()&lt;/code&gt;&lt;/a&gt; method&amp;rsquo;s approval).</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;CookieJar&lt;/code&gt; 는&lt;/a&gt; 허용 찾습니다 &lt;em&gt;설정 쿠키&lt;/em&gt; 와 &lt;em&gt;하는 Set-Cookie2&lt;/em&gt; 에서 헤더 &lt;em&gt;응답&lt;/em&gt; 해당합니다 (을 대상으로 인수, 저장 쿠키 &lt;a href=&quot;#http.cookiejar.CookiePolicy.set_ok&quot;&gt; &lt;code&gt;CookiePolicy.set_ok()&lt;/code&gt; &lt;/a&gt; 메소드의 승인).</target>
        </trans-unit>
        <trans-unit id="892509a53a5d6f89a661272b12ef7f4fbe726d49" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.server.CGIHTTPRequestHandler&quot;&gt;&lt;code&gt;CGIHTTPRequestHandler&lt;/code&gt;&lt;/a&gt; defines the following data member:</source>
          <target state="translated">&lt;a href=&quot;#http.server.CGIHTTPRequestHandler&quot;&gt; &lt;code&gt;CGIHTTPRequestHandler&lt;/code&gt; 는&lt;/a&gt; 다음과 같은 데이터 멤버를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="4f3ec92b59878117b7fe2c93d4c2a548bc59f10f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.server.CGIHTTPRequestHandler&quot;&gt;&lt;code&gt;CGIHTTPRequestHandler&lt;/code&gt;&lt;/a&gt; defines the following method:</source>
          <target state="translated">&lt;a href=&quot;#http.server.CGIHTTPRequestHandler&quot;&gt; &lt;code&gt;CGIHTTPRequestHandler&lt;/code&gt; 는&lt;/a&gt; 다음과 같은 방법을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="3063dd9d9ba74b5988d1c7ce6e176579f1298f7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.server.HTTPServer&quot;&gt;&lt;code&gt;HTTPServer&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#http.server.ThreadingHTTPServer&quot;&gt;&lt;code&gt;ThreadingHTTPServer&lt;/code&gt;&lt;/a&gt; must be given a &lt;em&gt;RequestHandlerClass&lt;/em&gt; on instantiation, of which this module provides three different variants:</source>
          <target state="translated">&lt;a href=&quot;#http.server.HTTPServer&quot;&gt; &lt;code&gt;HTTPServer&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#http.server.ThreadingHTTPServer&quot;&gt; &lt;code&gt;ThreadingHTTPServer&lt;/code&gt; 는&lt;/a&gt; 주어진해야 &lt;em&gt;RequestHandlerClass&lt;/em&gt; 이 모듈이 세 가지 변종을 제공하는의 인스턴스에를 :</target>
        </trans-unit>
        <trans-unit id="c3b07c0d36cb7b2328e4e39fd85c0c91ce6e34c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt;&lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt;&lt;/a&gt; class can be used in the following manner in order to create a very basic webserver serving files relative to the current directory:</source>
          <target state="translated">&lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt; &lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt; 의&lt;/a&gt; 클래스는 현재 디렉토리를 기준으로 파일을 제공하는 아주 기본적인 웹 서버를 생성하기 위해 다음과 같은 방법으로 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="37b85c9f85de1e416b802425612ceacd7d1c6971" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt;&lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt;&lt;/a&gt; class defines the following methods:</source>
          <target state="translated">&lt;a href=&quot;#http.server.SimpleHTTPRequestHandler&quot;&gt; &lt;code&gt;SimpleHTTPRequestHandler&lt;/code&gt; 의&lt;/a&gt; 클래스는 다음과 같은 방법을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="852b43c2316c324fc522d7ff1a68a1885ce96c04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#imaplib.IMAP4&quot;&gt;&lt;code&gt;IMAP4&lt;/code&gt;&lt;/a&gt; class supports the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When used like this, the IMAP4 &lt;code&gt;LOGOUT&lt;/code&gt; command is issued automatically when the &lt;code&gt;with&lt;/code&gt; statement exits. E.g.:</source>
          <target state="translated">&lt;a href=&quot;#imaplib.IMAP4&quot;&gt; &lt;code&gt;IMAP4&lt;/code&gt; 의&lt;/a&gt; 클래스는 지원 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문. 이와 같이 사용 하면 &lt;code&gt;with&lt;/code&gt; 문이 종료 되면 IMAP4 &lt;code&gt;LOGOUT&lt;/code&gt; 명령이 자동으로 실행됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="b9b70bff057b7a70a8bd99ea96ead45a3220331b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;import_module()&lt;/code&gt;&lt;/a&gt; function acts as a simplifying wrapper around &lt;a href=&quot;#importlib.__import__&quot;&gt;&lt;code&gt;importlib.__import__()&lt;/code&gt;&lt;/a&gt;. This means all semantics of the function are derived from &lt;a href=&quot;#importlib.__import__&quot;&gt;&lt;code&gt;importlib.__import__()&lt;/code&gt;&lt;/a&gt;. The most important difference between these two functions is that &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;import_module()&lt;/code&gt;&lt;/a&gt; returns the specified package or module (e.g. &lt;code&gt;pkg.mod&lt;/code&gt;), while &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; returns the top-level package or module (e.g. &lt;code&gt;pkg&lt;/code&gt;).</source>
          <target state="translated">&lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;import_module()&lt;/code&gt; &lt;/a&gt; 함수는 주변의 단순화 래퍼로서 &lt;a href=&quot;#importlib.__import__&quot;&gt; &lt;code&gt;importlib.__import__()&lt;/code&gt; &lt;/a&gt; . 이는 함수의 모든 의미가 &lt;a href=&quot;#importlib.__import__&quot;&gt; &lt;code&gt;importlib.__import__()&lt;/code&gt; &lt;/a&gt; 에서 파생되었음을 의미합니다 . 이 두 기능 사이의 가장 중요한 차이점은 즉 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;import_module()&lt;/code&gt; &lt;/a&gt; (예를 들어 지정된 패키지 또는 모듈을 반환 &lt;code&gt;pkg.mod&lt;/code&gt; 동안) &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 최상위 패키지 또는 모듈을 반환합니다 (예 : &lt;code&gt;pkg&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1bae6a97d9fde07f950ebc819fa267abcbcd2efc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/a&gt; properties can be used to invoke functions:</source>
          <target state="translated">&lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt; &lt;code&gt;kwargs&lt;/code&gt; 로&lt;/a&gt; 속성은 호출 기능을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="91f42df007f7e0205554d47c412bcec7bdab5e36" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#inspect.getmembers&quot;&gt;&lt;code&gt;getmembers()&lt;/code&gt;&lt;/a&gt; function retrieves the members of an object such as a class or module. The functions whose names begin with &amp;ldquo;is&amp;rdquo; are mainly provided as convenient choices for the second argument to &lt;a href=&quot;#inspect.getmembers&quot;&gt;&lt;code&gt;getmembers()&lt;/code&gt;&lt;/a&gt;. They also help you determine when you can expect to find the following special attributes:</source>
          <target state="translated">&lt;a href=&quot;#inspect.getmembers&quot;&gt; &lt;code&gt;getmembers()&lt;/code&gt; &lt;/a&gt; 함수는 클래스 또는 모듈로 물체의 멤버를 검색한다. 이름이 &quot;is&quot;로 시작하는 함수는 주로 &lt;a href=&quot;#inspect.getmembers&quot;&gt; &lt;code&gt;getmembers()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수에 편리한 선택으로 제공됩니다 . 또한 다음과 같은 특수 속성을 언제 찾을 수 있는지 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="de3d811682e32c7451600320608bf74aadd88a87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; ABC deals with buffering on a raw byte stream (&lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt;). Its subclasses, &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#io.BufferedRWPair&quot;&gt;&lt;code&gt;BufferedRWPair&lt;/code&gt;&lt;/a&gt; buffer streams that are readable, writable, and both readable and writable. &lt;a href=&quot;#io.BufferedRandom&quot;&gt;&lt;code&gt;BufferedRandom&lt;/code&gt;&lt;/a&gt; provides a buffered interface to random access streams. Another &lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt; subclass, &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt;, is a stream of in-memory bytes.</source>
          <target state="translated">&lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; ABC 원시 바이트 스트림 (버퍼링에 다룬다 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; ). 읽을 수 있고, 쓸 수 있으며, 읽고 쓸 수있는 서브 클래스 인 &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedRWPair&quot;&gt; &lt;code&gt;BufferedRWPair&lt;/code&gt; &lt;/a&gt; 버퍼 스트림. &lt;a href=&quot;#io.BufferedRandom&quot;&gt; &lt;code&gt;BufferedRandom&lt;/code&gt; &lt;/a&gt; 은 랜덤 액세스 스트림에 버퍼링 된 인터페이스를 제공합니다. 또 다른 &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; 서브 클래스 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 는 메모리 내 바이트 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="a9df85f7e47c1af60b04aa0945a7c5afd4020154" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; ABC extends &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. It deals with the reading and writing of bytes to a stream. &lt;a href=&quot;#io.FileIO&quot;&gt;&lt;code&gt;FileIO&lt;/code&gt;&lt;/a&gt; subclasses &lt;a href=&quot;#io.RawIOBase&quot;&gt;&lt;code&gt;RawIOBase&lt;/code&gt;&lt;/a&gt; to provide an interface to files in the machine&amp;rsquo;s file system.</source>
          <target state="translated">&lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; ABC 는 IOBase를 확장 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; . 바이트의 스트림 읽기 및 쓰기를 처리합니다. &lt;a href=&quot;#io.FileIO&quot;&gt; &lt;code&gt;FileIO&lt;/code&gt; &lt;/a&gt; 는 시스템의 파일 시스템에있는 파일에 대한 인터페이스를 제공하기 위해 &lt;a href=&quot;#io.RawIOBase&quot;&gt; &lt;code&gt;RawIOBase&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱 합니다.</target>
        </trans-unit>
        <trans-unit id="41837a13305b80f8a061fb12801afa565fb495f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#io.TextIOBase&quot;&gt;&lt;code&gt;TextIOBase&lt;/code&gt;&lt;/a&gt; ABC, another subclass of &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;, deals with streams whose bytes represent text, and handles encoding and decoding to and from strings. &lt;a href=&quot;#io.TextIOWrapper&quot;&gt;&lt;code&gt;TextIOWrapper&lt;/code&gt;&lt;/a&gt;, which extends it, is a buffered text interface to a buffered raw stream (&lt;a href=&quot;#io.BufferedIOBase&quot;&gt;&lt;code&gt;BufferedIOBase&lt;/code&gt;&lt;/a&gt;). Finally, &lt;a href=&quot;#io.StringIO&quot;&gt;&lt;code&gt;StringIO&lt;/code&gt;&lt;/a&gt; is an in-memory stream for text.</source>
          <target state="translated">&lt;a href=&quot;#io.TextIOBase&quot;&gt; &lt;code&gt;TextIOBase&lt;/code&gt; &lt;/a&gt; ABC의 다른 서브 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; &lt;/a&gt; , 인코딩하고 디코딩 문자열에서 그 텍스트를 나타내는 바이트 스트림 및 핸들 다룬다. &lt;a href=&quot;#io.TextIOWrapper&quot;&gt; &lt;code&gt;TextIOWrapper&lt;/code&gt; &lt;/a&gt; 는 확장되어 버퍼링 된 원시 스트림 ( &lt;a href=&quot;#io.BufferedIOBase&quot;&gt; &lt;code&gt;BufferedIOBase&lt;/code&gt; &lt;/a&gt; ) 에 대한 버퍼링 된 텍스트 인터페이스 입니다. 마지막으로 &lt;a href=&quot;#io.StringIO&quot;&gt; &lt;code&gt;StringIO&lt;/code&gt; &lt;/a&gt; 는 텍스트에 대한 메모리 내 스트림입니다.</target>
        </trans-unit>
        <trans-unit id="831877a01cc5755207975d598f2d08a6f65a34fe" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ipaddress.IPv6Address&quot;&gt;&lt;code&gt;IPv6Address&lt;/code&gt;&lt;/a&gt; objects share a lot of common attributes. Some attributes that are only meaningful for IPv6 addresses are also implemented by &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt;&lt;code&gt;IPv4Address&lt;/code&gt;&lt;/a&gt; objects, in order to make it easier to write code that handles both IP versions correctly. Address objects are &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;hashable&lt;/a&gt;, so they can be used as keys in dictionaries.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ipaddress.IPv6Address&quot;&gt; &lt;code&gt;IPv6Address&lt;/code&gt; &lt;/a&gt; 객체는 공통 속성을 많이 공유 할 수 있습니다. IPv6 주소에만 의미가있는 일부 속성 은 두 IP 버전을 모두 올바르게 처리하는 코드를보다 쉽게 ​​작성할 수 있도록 &lt;a href=&quot;#ipaddress.IPv4Address&quot;&gt; &lt;code&gt;IPv4Address&lt;/code&gt; &lt;/a&gt; 객체로 구현 됩니다. 주소 개체는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-hashable&quot;&gt;해시 가능&lt;/a&gt; 하므로 사전에서 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f41a3b3613b689885978e0b22d94e53f3f5175" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt;&lt;code&gt;IPv4Network&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ipaddress.IPv6Network&quot;&gt;&lt;code&gt;IPv6Network&lt;/code&gt;&lt;/a&gt; objects provide a mechanism for defining and inspecting IP network definitions. A network definition consists of a &lt;em&gt;mask&lt;/em&gt; and a &lt;em&gt;network address&lt;/em&gt;, and as such defines a range of IP addresses that equal the network address when masked (binary AND) with the mask. For example, a network definition with the mask &lt;code&gt;255.255.255.0&lt;/code&gt; and the network address &lt;code&gt;192.168.1.0&lt;/code&gt; consists of IP addresses in the inclusive range &lt;code&gt;192.168.1.0&lt;/code&gt; to &lt;code&gt;192.168.1.255&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ipaddress.IPv4Network&quot;&gt; &lt;code&gt;IPv4Network&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ipaddress.IPv6Network&quot;&gt; &lt;code&gt;IPv6Network&lt;/code&gt; &lt;/a&gt; 객체 정의 및 IP 네트워크 정의를 검사하는 메커니즘을 제공한다. 네트워크 정의는 &lt;em&gt;마스크&lt;/em&gt; 와 &lt;em&gt;네트워크 주소&lt;/em&gt; 로 구성되며 &lt;em&gt;마스크&lt;/em&gt; 로 마스크 (이진 AND)로 마스킹 될 때 네트워크 주소와 동일한 IP 주소 범위를 정의합니다. 예를 들어, 마스크 네트워크 정의 &lt;code&gt;255.255.255.0&lt;/code&gt; 네트워크 주소 &lt;code&gt;192.168.1.0&lt;/code&gt; 은 포괄적 범위의 IP 주소로 구성 &lt;code&gt;192.168.1.0&lt;/code&gt; 에 &lt;code&gt;192.168.1.255&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63df5b1d6dacc56e59023287b9ca3fa75d8515b8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; built-in function is recommended for testing the type of an object, because it takes subclasses into account.</source>
          <target state="translated">&lt;a href=&quot;#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 이 계정으로 서브 클래스를 필요하기 때문에 내장 된 기능은 객체의 유형을 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0d1c65ba78a45f962714b9319f827c7af9cc0ecc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#list.sort&quot;&gt;&lt;code&gt;sort()&lt;/code&gt;&lt;/a&gt; method is guaranteed to be stable. A sort is stable if it guarantees not to change the relative order of elements that compare equal &amp;mdash; this is helpful for sorting in multiple passes (for example, sort by department, then by salary grade).</source>
          <target state="translated">&lt;a href=&quot;#list.sort&quot;&gt; &lt;code&gt;sort()&lt;/code&gt; &lt;/a&gt; 메소드가 안정 보장됩니다. 동일하게 비교되는 요소의 상대적 순서를 변경하지 않으면 정렬은 안정적입니다. 이는 여러 단계로 정렬하는 데 유용합니다 (예 : 부서별, 급여 등급별).</target>
        </trans-unit>
        <trans-unit id="3ce38cd7780c003a8d51cc5d4c3b9f429ba014be" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#locale.nl_langinfo&quot;&gt;&lt;code&gt;nl_langinfo()&lt;/code&gt;&lt;/a&gt; function accepts one of the following keys. Most descriptions are taken from the corresponding description in the GNU C library.</source>
          <target state="translated">&lt;a href=&quot;#locale.nl_langinfo&quot;&gt; &lt;code&gt;nl_langinfo()&lt;/code&gt; &lt;/a&gt; 함수는 다음의 키 중 하나를 수용한다. 대부분의 설명은 GNU C 라이브러리의 해당 설명에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="88aecf840dcaa99bd5989e62825b4f2fb44f5de1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.FileHandler&quot;&gt;&lt;code&gt;FileHandler&lt;/code&gt;&lt;/a&gt; class, located in the core &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; package, sends logging output to a disk file. It inherits the output functionality from &lt;a href=&quot;#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#logging.FileHandler&quot;&gt; &lt;code&gt;FileHandler&lt;/code&gt; &lt;/a&gt; 핵심에있는 클래스, &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 패키지는 디스크 파일에 로그 출력을 보냅니다. &lt;a href=&quot;#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt; 의 출력 기능을 상속합니다 .</target>
        </trans-unit>
        <trans-unit id="e6cec3c7b03eb3763340d71aa19faf7e93cb3434" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.NullHandler&quot;&gt;&lt;code&gt;NullHandler&lt;/code&gt;&lt;/a&gt; class, located in the core &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; package, does not do any formatting or output. It is essentially a &amp;lsquo;no-op&amp;rsquo; handler for use by library developers.</source>
          <target state="translated">&lt;a href=&quot;#logging.NullHandler&quot;&gt; &lt;code&gt;NullHandler&lt;/code&gt; 의&lt;/a&gt; 핵심에있는 클래스, &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 패키지, 서식 또는 출력하지 않습니다. 기본적으로 라이브러리 개발자가 사용하는 'no-op'핸들러입니다.</target>
        </trans-unit>
        <trans-unit id="803ef5a656c1ac2cbfa6e72511bcb741cbd82a6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.StreamHandler&quot;&gt;&lt;code&gt;StreamHandler&lt;/code&gt;&lt;/a&gt; class, located in the core &lt;a href=&quot;logging#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; package, sends logging output to streams such as &lt;em&gt;sys.stdout&lt;/em&gt;, &lt;em&gt;sys.stderr&lt;/em&gt; or any file-like object (or, more precisely, any object which supports &lt;code&gt;write()&lt;/code&gt; and &lt;code&gt;flush()&lt;/code&gt; methods).</source>
          <target state="translated">&lt;a href=&quot;#logging.StreamHandler&quot;&gt; &lt;code&gt;StreamHandler&lt;/code&gt; &lt;/a&gt; 코어에있는 클래스, &lt;a href=&quot;logging#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 패키지와 같은 스트림 출력을 기록 보낸다 &lt;em&gt;sys.stdout&lt;/em&gt; , &lt;em&gt;sys.stderr를&lt;/em&gt; 나 파일과 같은 객체 (또는, 더 정확하게는, 지원하는 오브젝트 &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;flush()&lt;/code&gt; 메소드) .</target>
        </trans-unit>
        <trans-unit id="c461bb4215cadaffdd24f570336111d1d39b40a8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.captureWarnings&quot;&gt;&lt;code&gt;captureWarnings()&lt;/code&gt;&lt;/a&gt; function can be used to integrate &lt;a href=&quot;#module-logging&quot;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;warnings#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#logging.captureWarnings&quot;&gt; &lt;code&gt;captureWarnings()&lt;/code&gt; &lt;/a&gt; 함수를 통합 할 수있는 &lt;a href=&quot;#module-logging&quot;&gt; &lt;code&gt;logging&lt;/code&gt; &lt;/a&gt; 으로 &lt;a href=&quot;warnings#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="9fa83eb6a4e125e4b7d38fb0d0a3eb8c044cbdf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.config.fileConfig&quot;&gt;&lt;code&gt;fileConfig()&lt;/code&gt;&lt;/a&gt; API is older than the &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt; API and does not provide functionality to cover certain aspects of logging. For example, you cannot configure &lt;a href=&quot;logging#logging.Filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; objects, which provide for filtering of messages beyond simple integer levels, using &lt;a href=&quot;#logging.config.fileConfig&quot;&gt;&lt;code&gt;fileConfig()&lt;/code&gt;&lt;/a&gt;. If you need to have instances of &lt;a href=&quot;logging#logging.Filter&quot;&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/a&gt; in your logging configuration, you will need to use &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt;. Note that future enhancements to configuration functionality will be added to &lt;a href=&quot;#logging.config.dictConfig&quot;&gt;&lt;code&gt;dictConfig()&lt;/code&gt;&lt;/a&gt;, so it&amp;rsquo;s worth considering transitioning to this newer API when it&amp;rsquo;s convenient to do so.</source>
          <target state="translated">&lt;a href=&quot;#logging.config.fileConfig&quot;&gt; &lt;code&gt;fileConfig()&lt;/code&gt; &lt;/a&gt; API는보다 오래된 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; API 및 로깅의 특정 측면을 커버하는 기능을 제공하지 않습니다. 예를 들어 &lt;a href=&quot;#logging.config.fileConfig&quot;&gt; &lt;code&gt;fileConfig()&lt;/code&gt; &lt;/a&gt; 사용하여 단순한 정수 수준 이상의 메시지를 필터링 할 수있는 &lt;a href=&quot;logging#logging.Filter&quot;&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/a&gt; 객체를 구성 할 수 없습니다 . 로깅 구성 에 &lt;a href=&quot;logging#logging.Filter&quot;&gt; &lt;code&gt;Filter&lt;/code&gt; &lt;/a&gt; 인스턴스 가 필요한 경우 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다. 구성 기능에 대한 향후 개선 사항이 &lt;a href=&quot;#logging.config.dictConfig&quot;&gt; &lt;code&gt;dictConfig()&lt;/code&gt; &lt;/a&gt; 추가 될 것이므로 편리 할 때이 최신 API로 전환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e39370cbcdd3340d5e408f053307fc1a4a9b92a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.BaseRotatingHandler&quot;&gt;&lt;code&gt;BaseRotatingHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, is the base class for the rotating file handlers, &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;&lt;/a&gt;. You should not need to instantiate this class, but it has attributes and methods you may need to override.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.BaseRotatingHandler&quot;&gt; &lt;code&gt;BaseRotatingHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스 &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈은, 상기 회전 파일 핸들러 기본 클래스이다 &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt; &lt;code&gt;RotatingFileHandler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt; &lt;code&gt;TimedRotatingFileHandler&lt;/code&gt; &lt;/a&gt; . 이 클래스를 인스턴스화 할 필요는 없지만 대체해야하는 속성과 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e43817c72b4003b672fbf6b9e4a775e15419ecf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.DatagramHandler&quot;&gt;&lt;code&gt;DatagramHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, inherits from &lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt;&lt;code&gt;SocketHandler&lt;/code&gt;&lt;/a&gt; to support sending logging messages over UDP sockets.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.DatagramHandler&quot;&gt; &lt;code&gt;DatagramHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈에서 상속 &lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt; &lt;code&gt;SocketHandler&lt;/code&gt; 는&lt;/a&gt; UDP 소켓을 통해 로깅 메시지를 보내는 지원합니다.</target>
        </trans-unit>
        <trans-unit id="29fa63a6ab1859f8388b9272a607d7ed41e4577d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.HTTPHandler&quot;&gt;&lt;code&gt;HTTPHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports sending logging messages to a Web server, using either &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; semantics.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.HTTPHandler&quot;&gt; &lt;code&gt;HTTPHandler&lt;/code&gt; &lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈 중 하나를 사용하여 웹 서버에 로그 메시지를 보내는 지원 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;POST&lt;/code&gt; 의 의미.</target>
        </trans-unit>
        <trans-unit id="4b3bf4fce2fdbe09c72de4fa938200db198c6786" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.MemoryHandler&quot;&gt;&lt;code&gt;MemoryHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports buffering of logging records in memory, periodically flushing them to a &lt;em&gt;target&lt;/em&gt; handler. Flushing occurs whenever the buffer is full, or when an event of a certain severity or greater is seen.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.MemoryHandler&quot;&gt; &lt;code&gt;MemoryHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 는&lt;/a&gt; 지원이 주기적에게 홍조, 메모리에 로그 기록의 버퍼링, 모듈 &lt;em&gt;대상&lt;/em&gt; 핸들러입니다. 플러싱은 버퍼가 가득 찼거나 특정 심각도 이상의 이벤트가 나타날 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6835f5279a08ad57f0b66909d044557366fc8f85" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.NTEventLogHandler&quot;&gt;&lt;code&gt;NTEventLogHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports sending logging messages to a local Windows NT, Windows 2000 or Windows XP event log. Before you can use it, you need Mark Hammond&amp;rsquo;s Win32 extensions for Python installed.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.NTEventLogHandler&quot;&gt; &lt;code&gt;NTEventLogHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈은 지원은 로컬 Windows NT, Windows 2000 또는 Windows XP 이벤트 로그에 로그 메시지를 보낼. 사용하기 전에 Mark Hammond의 Python 용 Win32 확장이 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7aba5b2300254e8ea0e333db3962218861ba04d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt;&lt;code&gt;QueueHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports sending logging messages to a queue, such as those implemented in the &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; modules.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt; &lt;code&gt;QueueHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스 &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 는&lt;/a&gt; 지지체 등으로 구현 것과 큐에 로그 메시지를 전송하는 모듈 &lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="e133f786a9f0bbb4574a162a4bcd28dc139d0fca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt;&lt;code&gt;QueueListener&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports receiving logging messages from a queue, such as those implemented in the &lt;a href=&quot;queue#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; modules. The messages are received from a queue in an internal thread and passed, on the same thread, to one or more handlers for processing. While &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt;&lt;code&gt;QueueListener&lt;/code&gt;&lt;/a&gt; is not itself a handler, it is documented here because it works hand-in-hand with &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt;&lt;code&gt;QueueHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt; &lt;code&gt;QueueListener&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스 &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 는&lt;/a&gt; 지지체 등으로 구현 것과 같이, 큐에서 로깅 메시지를 수신하는 모듈 &lt;a href=&quot;queue#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;multiprocessing#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈. 메시지는 내부 스레드의 큐에서 수신되고 동일한 스레드에서 처리를 위해 하나 이상의 핸들러로 전달됩니다. 하지만 &lt;a href=&quot;#logging.handlers.QueueListener&quot;&gt; &lt;code&gt;QueueListener&lt;/code&gt; 이&lt;/a&gt; 핸들러하지 자체가와 긴밀하게 작동하기 때문에, 그것은 여기에 설명되어 있습니다 &lt;a href=&quot;#logging.handlers.QueueHandler&quot;&gt; &lt;code&gt;QueueHandler&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb9b0b4eb47b826b69b42a40d290b13672f8bc15" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt;&lt;code&gt;RotatingFileHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports rotation of disk log files.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.RotatingFileHandler&quot;&gt; &lt;code&gt;RotatingFileHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈은 지원하는 디스크의 로그 파일의 회전.</target>
        </trans-unit>
        <trans-unit id="31584d463a02ed74e40b37c8319648296b019156" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt;&lt;code&gt;SMTPHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports sending logging messages to an email address via SMTP.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.SMTPHandler&quot;&gt; &lt;code&gt;SMTPHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 는&lt;/a&gt; 지원은 SMTP를 통해 이메일 주소로 로깅 메시지를 전송, 모듈.</target>
        </trans-unit>
        <trans-unit id="d1eb30567d146d30f819a686de9415335350aa29" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt;&lt;code&gt;SocketHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, sends logging output to a network socket. The base class uses a TCP socket.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.SocketHandler&quot;&gt; &lt;code&gt;SocketHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스 &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈은 네트워크 소켓 로깅 출력을 보낸다. 기본 클래스는 TCP 소켓을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f1725eea43751716f84846378d8032df6d964f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt;&lt;code&gt;SysLogHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports sending logging messages to a remote or local Unix syslog.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.SysLogHandler&quot;&gt; &lt;code&gt;SysLogHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스 &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 는&lt;/a&gt; 지지체는 원격 또는 로컬 UNIX 시스템 로그에 로그 메시지를 전송하는 모듈을 포함한다.</target>
        </trans-unit>
        <trans-unit id="e439d324bb2811d1000db769f81cd0d651b345d8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt;&lt;code&gt;TimedRotatingFileHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, supports rotation of disk log files at certain timed intervals.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.TimedRotatingFileHandler&quot;&gt; &lt;code&gt;TimedRotatingFileHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; &lt;/a&gt; 모듈이 지원하는 특정 시간 간격으로 디스크의 로그 파일의 회전.</target>
        </trans-unit>
        <trans-unit id="f549bfbf465afb4f59b0d34dabfb8c319bfdecdd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#logging.handlers.WatchedFileHandler&quot;&gt;&lt;code&gt;WatchedFileHandler&lt;/code&gt;&lt;/a&gt; class, located in the &lt;a href=&quot;#module-logging.handlers&quot;&gt;&lt;code&gt;logging.handlers&lt;/code&gt;&lt;/a&gt; module, is a &lt;code&gt;FileHandler&lt;/code&gt; which watches the file it is logging to. If the file changes, it is closed and reopened using the file name.</source>
          <target state="translated">&lt;a href=&quot;#logging.handlers.WatchedFileHandler&quot;&gt; &lt;code&gt;WatchedFileHandler&lt;/code&gt; 의&lt;/a&gt; 에있는 클래스, &lt;a href=&quot;#module-logging.handlers&quot;&gt; &lt;code&gt;logging.handlers&lt;/code&gt; 의&lt;/a&gt; 모듈은이다 &lt;code&gt;FileHandler&lt;/code&gt; 가 로깅되는 파일을 감시합니다. 파일이 변경되면 파일 이름을 사용하여 닫히고 다시 열립니다.</target>
        </trans-unit>
        <trans-unit id="bf5388a8dc4e9c74cc256017fd462ce7da0e8fb2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#mailbox.MH&quot;&gt;&lt;code&gt;MH&lt;/code&gt;&lt;/a&gt; class manipulates MH mailboxes, but it does not attempt to emulate all of &lt;strong&gt;mh&lt;/strong&gt;&amp;rsquo;s behaviors. In particular, it does not modify and is not affected by the &lt;code&gt;context&lt;/code&gt; or &lt;code&gt;.mh_profile&lt;/code&gt; files that are used by &lt;strong&gt;mh&lt;/strong&gt; to store its state and configuration.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.MH&quot;&gt; &lt;code&gt;MH&lt;/code&gt; 의&lt;/a&gt; 클래스를 조작 MH 사서함는하지만, 모든 모방하려고 시도하지 않습니다 &lt;strong&gt;MH&lt;/strong&gt; 의 행동을. 특히 &lt;strong&gt;mh&lt;/strong&gt; 에서 상태 및 구성을 저장하는 데 사용 하는 &lt;code&gt;context&lt;/code&gt; 또는 &lt;code&gt;.mh_profile&lt;/code&gt; 파일 은 수정되지 않으며 영향을받지 않습니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9dd1a3f1fdf40b9925961770165ca8a82472141" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; class defines an interface and is not intended to be instantiated. Instead, format-specific subclasses should inherit from &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; and your code should instantiate a particular subclass.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 클래스는 인터페이스를 정의하고 인스턴스화 수 없습니다. 대신 형식 별 하위 클래스는 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 에서 상속해야합니다. 해야하며 코드는 특정 하위 클래스를 인스턴스화해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ac3915262dc8630a67a64ad2e0ad71194086ede" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; interface is dictionary-like, with small keys corresponding to messages. Keys are issued by the &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance with which they will be used and are only meaningful to that &lt;a href=&quot;#mailbox.Mailbox&quot;&gt;&lt;code&gt;Mailbox&lt;/code&gt;&lt;/a&gt; instance. A key continues to identify a message even if the corresponding message is modified, such as by replacing it with another message.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인터페이스는 작은 키 메시지에 대응, 사전과 같은 것입니다. 키는 발급 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 는 사용 만 그에게 의미있는됩니다있는 예를 &lt;a href=&quot;#mailbox.Mailbox&quot;&gt; &lt;code&gt;Mailbox&lt;/code&gt; &lt;/a&gt; 인스턴스입니다. 키는 메시지를 다른 메시지로 바꾸는 등 해당 메시지가 수정 된 경우에도 메시지를 계속 식별합니다.</target>
        </trans-unit>
        <trans-unit id="a019e770f701b87042c21c3465130dceb581a0a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#math.erf&quot;&gt;&lt;code&gt;erf()&lt;/code&gt;&lt;/a&gt; function can be used to compute traditional statistical functions such as the &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function&quot;&gt;cumulative standard normal distribution&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#math.erf&quot;&gt; &lt;code&gt;erf()&lt;/code&gt; &lt;/a&gt; 함수와 같은 전통적인 통계 함수를 계산하는데 이용 될 수 &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution#Cumulative_distribution_function&quot;&gt;누적 표준 정규 분포&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7a71fcebbba63874049750f91dc5d654f046999b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#mimetypes.MimeTypes&quot;&gt;&lt;code&gt;MimeTypes&lt;/code&gt;&lt;/a&gt; class may be useful for applications which may want more than one MIME-type database; it provides an interface similar to the one of the &lt;a href=&quot;#module-mimetypes&quot;&gt;&lt;code&gt;mimetypes&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#mimetypes.MimeTypes&quot;&gt; &lt;code&gt;MimeTypes&lt;/code&gt; &lt;/a&gt; 클래스는 하나의 MIME 타입의 데이터베이스보다 더 할 수 있습니다 응용 프로그램에 유용 할 수있다; &lt;a href=&quot;#module-mimetypes&quot;&gt; &lt;code&gt;mimetypes&lt;/code&gt; &lt;/a&gt; 중 하나와 유사한 인터페이스를 제공합니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="32d9533a1491fb57b208e5f32f43b48d18eb2a01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; module also provides the following decorator:</source>
          <target state="translated">&lt;a href=&quot;#module-abc&quot;&gt; &lt;code&gt;abc&lt;/code&gt; &lt;/a&gt; 모듈은 또한 다음과 같은 장식을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="f1c5b0fc44115f034b4d77d538b593c9107faba0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; module also provides the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-abc&quot;&gt; &lt;code&gt;abc&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="3b06c0895f11aac3409cc1eb1c4896e4e8162e1b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-abc&quot;&gt;&lt;code&gt;abc&lt;/code&gt;&lt;/a&gt; module also supports the following legacy decorators:</source>
          <target state="translated">&lt;a href=&quot;#module-abc&quot;&gt; &lt;code&gt;abc&lt;/code&gt; &lt;/a&gt; 모듈은 또한 다음과 같은 기존의 장식을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="bd250dea88ef11132e077bccd9219f3815e5b2b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module improves on the standard library &lt;a href=&quot;optparse#module-optparse&quot;&gt;&lt;code&gt;optparse&lt;/code&gt;&lt;/a&gt; module in a number of ways including:</source>
          <target state="translated">&lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 표준 라이브러리에 개선 &lt;a href=&quot;optparse#module-optparse&quot;&gt; &lt;code&gt;optparse&lt;/code&gt; 의의&lt;/a&gt; 를 포함하여 여러 가지 방법으로 모듈 :</target>
        </trans-unit>
        <trans-unit id="c9bf50b09089d63d5a993888ab95201b7c5cbcc7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module makes it easy to write user-friendly command-line interfaces. The program defines what arguments it requires, and &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; will figure out how to parse those out of &lt;a href=&quot;sys#sys.argv&quot;&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module also automatically generates help and usage messages and issues errors when users give the program invalid arguments.</source>
          <target state="translated">&lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 쉽게 사용자 친화적 인 명령 줄 인터페이스를 작성할 수 있습니다. 프로그램은 필요한 인수를 정의하고 &lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;sys#sys.argv&quot;&gt; &lt;code&gt;sys.argv&lt;/code&gt; 에서&lt;/a&gt; 인수 를 구문 분석하는 방법을 알아냅니다 . &lt;a href=&quot;#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 모듈은 자동으로 도움말 및 사용 메시지와 사용자가 프로그램을 유효하지 않은 인수를주고 문제의 오류를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e6be456db1d54d4f38e4ec57fdcedb85fa8f7bff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module helps Python applications to process trees of the Python abstract syntax grammar. The abstract syntax itself might change with each Python release; this module helps to find out programmatically what the current grammar looks like.</source>
          <target state="translated">&lt;a href=&quot;#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; &lt;/a&gt; 모듈은 파이썬 추상 구문 문법의 프로세스 트리에 파이썬 응용 프로그램을하는 데 도움이됩니다. 추상 구문 자체는 각 Python 릴리스마다 바뀔 수 있습니다. 이 모듈은 프로그래밍 방식으로 현재 문법의 모양을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="e7d3a14950a2b21d8385b845f3a521bc85e901c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; module defines functions to register and unregister cleanup functions. Functions thus registered are automatically executed upon normal interpreter termination. &lt;a href=&quot;#module-atexit&quot;&gt;&lt;code&gt;atexit&lt;/code&gt;&lt;/a&gt; runs these functions in the &lt;em&gt;reverse&lt;/em&gt; order in which they were registered; if you register &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;, at interpreter termination time they will be run in the order &lt;code&gt;C&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 모듈을 정의 기능을 등록하고 등록 해제 정리 기능을합니다. 이렇게 등록 된 기능은 정상적인 인터프리터 종료시 자동으로 실행됩니다. &lt;a href=&quot;#module-atexit&quot;&gt; &lt;code&gt;atexit&lt;/code&gt; &lt;/a&gt; 은 이러한 기능을 등록 된 &lt;em&gt;역순으로&lt;/em&gt; 실행합니다 . &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; 및 &lt;code&gt;C&lt;/code&gt; 를 등록하면 인터프리터 종료 시간에 &lt;code&gt;C&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 순서로 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="09461f2a572ad5dc979c6c886dcbebdcbfc33f45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-audioop&quot;&gt;&lt;code&gt;audioop&lt;/code&gt;&lt;/a&gt; module contains some useful operations on sound fragments. It operates on sound fragments consisting of signed integer samples 8, 16, 24 or 32 bits wide, stored in &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt;. All scalar items are integers, unless specified otherwise.</source>
          <target state="translated">&lt;a href=&quot;#module-audioop&quot;&gt; &lt;code&gt;audioop&lt;/code&gt; 의&lt;/a&gt; 모듈은 사운드 조각에 대한 몇 가지 유용한 작업이 포함되어 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체에&lt;/a&gt; 저장된 8, 16, 24 또는 32 비트 너비의 부호있는 정수 샘플로 구성된 사운드 조각에서 작동 합니다 . 달리 지정하지 않는 한 모든 스칼라 항목은 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ae09b3a58592c0882f475dd1d36f713be9722d6f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-bdb&quot;&gt;&lt;code&gt;bdb&lt;/code&gt;&lt;/a&gt; module also defines two classes:</source>
          <target state="translated">&lt;a href=&quot;#module-bdb&quot;&gt; &lt;code&gt;bdb&lt;/code&gt; &lt;/a&gt; 모듈은 두 개의 클래스를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="232248945d1a22c3cb9a5862e8d9ecc59ec9c738" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-bdb&quot;&gt;&lt;code&gt;bdb&lt;/code&gt;&lt;/a&gt; module handles basic debugger functions, like setting breakpoints or managing execution via the debugger.</source>
          <target state="translated">&lt;a href=&quot;#module-bdb&quot;&gt; &lt;code&gt;bdb&lt;/code&gt; &lt;/a&gt; 모듈은 디버거 통해 실행을 중단 점을 설정 또는 관리 등 디버거 기본적인 기능을 처리한다.</target>
        </trans-unit>
        <trans-unit id="aa0e9cda8b76dcc67511667751aec4df606567e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-binascii&quot;&gt;&lt;code&gt;binascii&lt;/code&gt;&lt;/a&gt; module contains a number of methods to convert between binary and various ASCII-encoded binary representations. Normally, you will not use these functions directly but use wrapper modules like &lt;a href=&quot;uu#module-uu&quot;&gt;&lt;code&gt;uu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;base64#module-base64&quot;&gt;&lt;code&gt;base64&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;binhex#module-binhex&quot;&gt;&lt;code&gt;binhex&lt;/code&gt;&lt;/a&gt; instead. The &lt;a href=&quot;#module-binascii&quot;&gt;&lt;code&gt;binascii&lt;/code&gt;&lt;/a&gt; module contains low-level functions written in C for greater speed that are used by the higher-level modules.</source>
          <target state="translated">&lt;a href=&quot;#module-binascii&quot;&gt; &lt;code&gt;binascii&lt;/code&gt; &lt;/a&gt; 모듈은 바이너리 다양한 ASCII 인코딩 이진 표현 간의 변환 방법들을 포함한다. 일반적으로 이러한 함수를 직접 사용 하지 않고 대신 &lt;a href=&quot;uu#module-uu&quot;&gt; &lt;code&gt;uu&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;base64#module-base64&quot;&gt; &lt;code&gt;base64&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;binhex#module-binhex&quot;&gt; &lt;code&gt;binhex&lt;/code&gt; &lt;/a&gt; 와 같은 랩퍼 모듈을 사용하십시오. &lt;a href=&quot;#module-binascii&quot;&gt; &lt;code&gt;binascii&lt;/code&gt; &lt;/a&gt; 모듈은 상위 레벨 모듈들에 의해 사용되는 더 큰 속도 C에 기입 로우 레벨 기능을 포함한다.</target>
        </trans-unit>
        <trans-unit id="230ed6c84e26b9f25251e99e324667c60febba51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-binascii&quot;&gt;&lt;code&gt;binascii&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-binascii&quot;&gt; &lt;code&gt;binascii&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="81c720d6186a47a903320723cae98c9bd445747c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-binhex&quot;&gt;&lt;code&gt;binhex&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-binhex&quot;&gt; &lt;code&gt;binhex&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="5c9e61b02ca1fa682864673e83749c144e0030fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-bisect&quot;&gt;&lt;code&gt;bisect()&lt;/code&gt;&lt;/a&gt; function can be useful for numeric table lookups. This example uses &lt;a href=&quot;#module-bisect&quot;&gt;&lt;code&gt;bisect()&lt;/code&gt;&lt;/a&gt; to look up a letter grade for an exam score (say) based on a set of ordered numeric breakpoints: 90 and up is an &amp;lsquo;A&amp;rsquo;, 80 to 89 is a &amp;lsquo;B&amp;rsquo;, and so on:</source>
          <target state="translated">&lt;a href=&quot;#module-bisect&quot;&gt; &lt;code&gt;bisect()&lt;/code&gt; &lt;/a&gt; 함수는 숫자 테이블 조회를 위해 유용 할 수 있습니다. 이 예제는 &lt;a href=&quot;#module-bisect&quot;&gt; &lt;code&gt;bisect()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 일련의 일련의 숫자 중단 점을 기준으로 시험 점수에 대한 문자 등급을 찾습니다. 90 이상은 'A', 80 ~ 89는 'B'등입니다.</target>
        </trans-unit>
        <trans-unit id="0db4d8367c8fa65b1ca519e0fa4866a4c08477de" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; module contains:</source>
          <target state="translated">&lt;a href=&quot;#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 모듈이 포함되어 있습니다</target>
        </trans-unit>
        <trans-unit id="6af3dd435e3f9abff01b6a27a709fda9f3c63f1a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-calendar&quot;&gt;&lt;code&gt;calendar&lt;/code&gt;&lt;/a&gt; module exports the following data attributes:</source>
          <target state="translated">&lt;a href=&quot;#module-calendar&quot;&gt; &lt;code&gt;calendar&lt;/code&gt; &lt;/a&gt; 모듈 수출 다음과 같은 데이터 속성 :</target>
        </trans-unit>
        <trans-unit id="17c7999cdaacdbb7fed3d7c718c840b2316c6c40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-cgitb&quot;&gt;&lt;code&gt;cgitb&lt;/code&gt;&lt;/a&gt; module provides a special exception handler for Python scripts. (Its name is a bit misleading. It was originally designed to display extensive traceback information in HTML for CGI scripts. It was later generalized to also display this information in plain text.) After this module is activated, if an uncaught exception occurs, a detailed, formatted report will be displayed. The report includes a traceback showing excerpts of the source code for each level, as well as the values of the arguments and local variables to currently running functions, to help you debug the problem. Optionally, you can save this information to a file instead of sending it to the browser.</source>
          <target state="translated">&lt;a href=&quot;#module-cgitb&quot;&gt; &lt;code&gt;cgitb&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬 스크립트에 대한 특별한 예외 핸들러를 제공합니다. (이름은 약간 오해의 소지가 있습니다. 원래는 CGI 스크립트를 위해 HTML에 광범위한 역 추적 정보를 표시하도록 설계되었습니다. 나중에이 정보를 일반 텍스트로 표시하도록 일반화되었습니다.)이 모듈이 활성화 된 후 발견되지 않은 예외가 발생하면 자세한 형식의 보고서가 표시됩니다. 이 보고서에는 각 수준에 대한 소스 코드 발췌와 현재 실행중인 함수에 대한 인수 및 로컬 변수의 값을 보여주는 역 추적이 포함되어 문제를 디버그하는 데 도움이됩니다. 선택적으로이 정보를 브라우저로 보내지 않고 파일로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55b0f4245fc0c07710dea9e772bf2789d8189b32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-cmd&quot;&gt;&lt;code&gt;cmd&lt;/code&gt;&lt;/a&gt; module is mainly useful for building custom shells that let a user work with a program interactively.</source>
          <target state="translated">&lt;a href=&quot;#module-cmd&quot;&gt; &lt;code&gt;cmd&lt;/code&gt; 를&lt;/a&gt; 모듈은 대화 형 프로그램으로 사용자의 작업을 할 수 사용자 정의 조개를 구축하기위한 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="96af487ef6d7e00efa4b8e683db6f6f172964429" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module defines a set of base classes which define the interfaces for working with codec objects, and can also be used as the basis for custom codec implementations.</source>
          <target state="translated">&lt;a href=&quot;#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; 정의를 코덱 객체 작업에 대한 인터페이스를 정의하는 기본 클래스의 집합을 모듈 및 사용자 지정 코덱 구현을위한 기초로서 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="825e3ed0518170c83aded2c55be81235e549b50a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-codeop&quot;&gt;&lt;code&gt;codeop&lt;/code&gt;&lt;/a&gt; module provides a way of doing each of these things, and a way of doing them both.</source>
          <target state="translated">&lt;a href=&quot;#module-codeop&quot;&gt; &lt;code&gt;codeop&lt;/code&gt; 의&lt;/a&gt; 모듈은이 일의 각을하는 방법, 그리고 둘 다 일을하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="052d15e90591e35dab5867b81d334d6aa14b8029" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-codeop&quot;&gt;&lt;code&gt;codeop&lt;/code&gt;&lt;/a&gt; module provides utilities upon which the Python read-eval-print loop can be emulated, as is done in the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; module. As a result, you probably don&amp;rsquo;t want to use the module directly; if you want to include such a loop in your program you probably want to use the &lt;a href=&quot;code#module-code&quot;&gt;&lt;code&gt;code&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;a href=&quot;#module-codeop&quot;&gt; &lt;code&gt;codeop&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬은 읽기 평가 후면 인쇄하는시 루프에서 수행되는 한, 에뮬레이트 할 수있는 유틸리티를 제공합니다 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 모듈을. 결과적으로 모듈을 직접 사용하고 싶지 않을 것입니다. 프로그램에 이러한 루프를 포함하려면 대신 &lt;a href=&quot;code#module-code&quot;&gt; &lt;code&gt;code&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="a65fb5b258755a4579d3195a6bac80725fe5d317" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-colorsys&quot;&gt;&lt;code&gt;colorsys&lt;/code&gt;&lt;/a&gt; module defines bidirectional conversions of color values between colors expressed in the RGB (Red Green Blue) color space used in computer monitors and three other coordinate systems: YIQ, HLS (Hue Lightness Saturation) and HSV (Hue Saturation Value). Coordinates in all of these color spaces are floating point values. In the YIQ space, the Y coordinate is between 0 and 1, but the I and Q coordinates can be positive or negative. In all other spaces, the coordinates are all between 0 and 1.</source>
          <target state="translated">&lt;a href=&quot;#module-colorsys&quot;&gt; &lt;code&gt;colorsys&lt;/code&gt; &lt;/a&gt; YIQ, HLS (색조 명도 채도)와 HSV (색조 채도 값) : 모듈은 컴퓨터 모니터에 사용되는 RGB (빨강 녹색 파랑) 색 공간에서 표현되는 색상과 세 가지 다른 좌표계 사이의 색상 값의 양방향 변환을 정의합니다. 이러한 모든 색 공간의 좌표는 부동 소수점 값입니다. YIQ 공간에서 Y 좌표는 0과 1 사이이지만 I 및 Q 좌표는 양수 또는 음수 일 수 있습니다. 다른 모든 공간에서 좌표는 모두 0과 1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="c85480a61de9b939bd0de9d56021736c13db66f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-colorsys&quot;&gt;&lt;code&gt;colorsys&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-colorsys&quot;&gt; &lt;code&gt;colorsys&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="885d466e93eb82c4aae2ef859e52b25a2b0cbe05" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; module provides a high-level interface for asynchronously executing callables.</source>
          <target state="translated">&lt;a href=&quot;#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; 의&lt;/a&gt; 모듈은 비동기 적으로 실행 callables위한 하이 레벨 인터페이스를 제공한다.</target>
        </trans-unit>
        <trans-unit id="f5839cbd7564f7728fd1d678c29d8a3505447a24" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-copyreg&quot;&gt;&lt;code&gt;copyreg&lt;/code&gt;&lt;/a&gt; module offers a way to define functions used while pickling specific objects. The &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; modules use those functions when pickling/copying those objects. The module provides configuration information about object constructors which are not classes. Such constructors may be factory functions or class instances.</source>
          <target state="translated">&lt;a href=&quot;#module-copyreg&quot;&gt; &lt;code&gt;copyreg&lt;/code&gt; 의&lt;/a&gt; 모듈 이벤트 방법은 특정 오브젝트를 산 세척하는 동안 사용되는 기능을 정의합니다. &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 해당 개체를 복사 / 산세 때 모듈은 이러한 기능을 사용합니다. 이 모듈은 클래스가 아닌 객체 생성자에 대한 구성 정보를 제공합니다. 이러한 생성자는 팩토리 함수 또는 클래스 인스턴스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="721ebf8a61fd647ae84d28799df425b0d4dfbde5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-crypt&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-crypt&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="1c62a1b252997090398bfb1ebd100196cab3225e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-crypt&quot;&gt;&lt;code&gt;crypt&lt;/code&gt;&lt;/a&gt; module defines the list of hashing methods (not all methods are available on all platforms):</source>
          <target state="translated">&lt;a href=&quot;#module-crypt&quot;&gt; &lt;code&gt;crypt&lt;/code&gt; &lt;/a&gt; 모듈은 해싱 방법의 목록을 (모든 방법을 모든 플랫폼에서 사용할 수있는)를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="c636424130025f1e89ce7931f9bbbabaa890facc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module defines the following classes:</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 클래스를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="27431b45d67a6159175c47900316994fcaec91cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module defines the following constants:</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈은 다음의 상수를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="2a8046905055a0a0b6a1413246dbf6c34224b1ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module defines the following exception:</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 예외를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="df713f7e9acfda4fb51e36976ba8818bb68c3d50" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="ed7b40e10e0b99a98d872d4f9807b33889674efd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module implements classes to read and write tabular data in CSV format. It allows programmers to say, &amp;ldquo;write this data in the format preferred by Excel,&amp;rdquo; or &amp;ldquo;read data from this file which was generated by Excel,&amp;rdquo; without knowing the precise details of the CSV format used by Excel. Programmers can also describe the CSV formats understood by other applications or define their own special-purpose CSV formats.</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈을 구현하는 클래스 읽기 및 CSV 형식으로 기록 테이블 데이터. 프로그래머는 Excel에서 사용하는 CSV 형식의 정확한 세부 정보를 알지 못하고 &quot;Excel에서 선호하는 형식으로이 데이터를 쓰거나&quot;Excel에서 생성 한이 파일에서 데이터를 읽습니다 &quot;라고 말할 수 있습니다. 프로그래머는 다른 응용 프로그램에서 이해하는 CSV 형식을 설명하거나 고유 한 특수 목적 CSV 형식을 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfd8e3c2e8154ec4a3cd8f80fa7b3c3c209a2772" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-csv&quot;&gt;&lt;code&gt;csv&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;a href=&quot;#csv.reader&quot;&gt;&lt;code&gt;reader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#csv.writer&quot;&gt;&lt;code&gt;writer&lt;/code&gt;&lt;/a&gt; objects read and write sequences. Programmers can also read and write data in dictionary form using the &lt;a href=&quot;#csv.DictReader&quot;&gt;&lt;code&gt;DictReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#csv.DictWriter&quot;&gt;&lt;code&gt;DictWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;#module-csv&quot;&gt; &lt;code&gt;csv&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;a href=&quot;#csv.reader&quot;&gt; &lt;code&gt;reader&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#csv.writer&quot;&gt; &lt;code&gt;writer&lt;/code&gt; &lt;/a&gt; 객체는 읽기 및 쓰기 시퀀스. 프로그래머는 &lt;a href=&quot;#csv.DictReader&quot;&gt; &lt;code&gt;DictReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#csv.DictWriter&quot;&gt; &lt;code&gt;DictWriter&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 사전 형식으로 데이터를 읽고 쓸 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7625b256eb64d8fea01867d67ac0134999467f64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; module defines the following data members:</source>
          <target state="translated">&lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 데이터 멤버를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="530db11d214428f7bb16efb76c2183ef8978387d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-curses&quot;&gt;&lt;code&gt;curses&lt;/code&gt;&lt;/a&gt; module provides an interface to the curses library, the de-facto standard for portable advanced terminal handling.</source>
          <target state="translated">&lt;a href=&quot;#module-curses&quot;&gt; &lt;code&gt;curses&lt;/code&gt; &lt;/a&gt; 모듈 커스 라이브러리 고급 휴대용 단말 처리를위한 사실상의 표준 인터페이스를 제공한다.</target>
        </trans-unit>
        <trans-unit id="b5e85f84c3cb5ea987216b39f8fde862c3b03857" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-curses.ascii&quot;&gt;&lt;code&gt;curses.ascii&lt;/code&gt;&lt;/a&gt; module supplies name constants for ASCII characters and functions to test membership in various ASCII character classes. The constants supplied are names for control characters as follows:</source>
          <target state="translated">&lt;a href=&quot;#module-curses.ascii&quot;&gt; &lt;code&gt;curses.ascii&lt;/code&gt; &lt;/a&gt; 모듈 공급 장치는 다양한 ASCII 문자 클래스에서 테스트 회원으로 ASCII 문자 상수와 함수 이름을 지정합니다. 제공된 상수는 다음과 같이 제어 문자의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0ef5dd676e2a85889cd2acbb8c2771ade941730d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-curses.textpad&quot;&gt;&lt;code&gt;curses.textpad&lt;/code&gt;&lt;/a&gt; module provides a &lt;a href=&quot;#curses.textpad.Textbox&quot;&gt;&lt;code&gt;Textbox&lt;/code&gt;&lt;/a&gt; class that handles elementary text editing in a curses window, supporting a set of keybindings resembling those of Emacs (thus, also of Netscape Navigator, BBedit 6.x, FrameMaker, and many other programs). The module also provides a rectangle-drawing function useful for framing text boxes or for other purposes.</source>
          <target state="translated">&lt;a href=&quot;#module-curses.textpad&quot;&gt; &lt;code&gt;curses.textpad&lt;/code&gt; 의&lt;/a&gt; 모듈은 제공 &lt;a href=&quot;#curses.textpad.Textbox&quot;&gt; &lt;code&gt;Textbox&lt;/code&gt; &lt;/a&gt; 핸들 초등학교 텍스트를하는 저주 창에서 편집 이맥스의 사람들을 닮은 키 바인딩 세트를 지원하는 클래스를 (따라서, 또한 넷스케이프 네비게이터, BBEdit에서 6.x에서,의 FrameMaker, 그리고 많은 다른 프로그램). 이 모듈은 텍스트 상자의 구도를 잡거나 다른 목적으로 유용한 사각형 그리기 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="68fa7b8d8cd84f32489bcf52cf35218335bd2861" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module exports the following constants:</source>
          <target state="translated">&lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 상수를 보냅니다</target>
        </trans-unit>
        <trans-unit id="d3d2735ee014446e28a8622acf775517ae092333" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module has a basic &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt; class (for handling arbitrary fixed offsets from UTC) and its &lt;a href=&quot;#datetime.timezone.utc&quot;&gt;&lt;code&gt;timezone.utc&lt;/code&gt;&lt;/a&gt; attribute (a UTC timezone instance).</source>
          <target state="translated">&lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 모듈은 기본 갖는다 &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; (UTC에서 임의의 고정 오프셋을 처리하는) 클래스 및 &lt;a href=&quot;#datetime.timezone.utc&quot;&gt; &lt;code&gt;timezone.utc&lt;/code&gt; &lt;/a&gt; 특성 (a UTC 시간대 인스턴스).</target>
        </trans-unit>
        <trans-unit id="4b2f35fb3014c39c4303763cc20160296da87ef0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; module supplies classes for manipulating dates and times.</source>
          <target state="translated">&lt;a href=&quot;#module-datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 날짜와 시간을 조작하기위한 모듈 공급 클래스.</target>
        </trans-unit>
        <trans-unit id="224fb159bc8424f10fd5ee5ca9b0cae4008a74b3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dbm.dumb&quot;&gt;&lt;code&gt;dbm.dumb&lt;/code&gt;&lt;/a&gt; module is intended as a last resort fallback for the &lt;a href=&quot;#module-dbm&quot;&gt;&lt;code&gt;dbm&lt;/code&gt;&lt;/a&gt; module when a more robust module is not available. The &lt;a href=&quot;#module-dbm.dumb&quot;&gt;&lt;code&gt;dbm.dumb&lt;/code&gt;&lt;/a&gt; module is not written for speed and is not nearly as heavily used as the other database modules.</source>
          <target state="translated">&lt;a href=&quot;#module-dbm.dumb&quot;&gt; &lt;code&gt;dbm.dumb&lt;/code&gt; 의&lt;/a&gt; 모듈을위한 최후의 수단 대체위한 것입니다 &lt;a href=&quot;#module-dbm&quot;&gt; &lt;code&gt;dbm&lt;/code&gt; &lt;/a&gt; 보다 강력한 모듈을 사용할 수없는 경우 모듈. &lt;a href=&quot;#module-dbm.dumb&quot;&gt; &lt;code&gt;dbm.dumb&lt;/code&gt; 의&lt;/a&gt; 모듈은 속도를 작성하지 않고 거의 무겁게 다른 데이터베이스 모듈로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4aee0663c41d37a708ff1a6a8740267197fa621" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dbm.dumb&quot;&gt;&lt;code&gt;dbm.dumb&lt;/code&gt;&lt;/a&gt; module provides a persistent dictionary-like interface which is written entirely in Python. Unlike other modules such as &lt;a href=&quot;#module-dbm.gnu&quot;&gt;&lt;code&gt;dbm.gnu&lt;/code&gt;&lt;/a&gt; no external library is required. As with other persistent mappings, the keys and values are always stored as bytes.</source>
          <target state="translated">&lt;a href=&quot;#module-dbm.dumb&quot;&gt; &lt;code&gt;dbm.dumb&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬로 작성되어 지속적인 사전과 같은 인터페이스를 제공합니다. &lt;a href=&quot;#module-dbm.gnu&quot;&gt; &lt;code&gt;dbm.gnu&lt;/code&gt; &lt;/a&gt; 와 같은 다른 모듈과 달리 외부 라이브러리가 필요하지 않습니다. 다른 영속 매핑과 마찬가지로 키와 값은 항상 바이트로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a81bac34c141774d30f753105eeea411b8b8b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dbm.gnu&quot;&gt;&lt;code&gt;dbm.gnu&lt;/code&gt;&lt;/a&gt; module provides an interface to the GNU DBM library. &lt;code&gt;dbm.gnu.gdbm&lt;/code&gt; objects behave like mappings (dictionaries), except that keys and values are always converted to bytes before storing. Printing a &lt;code&gt;gdbm&lt;/code&gt; object doesn&amp;rsquo;t print the keys and values, and the &lt;code&gt;items()&lt;/code&gt; and &lt;code&gt;values()&lt;/code&gt; methods are not supported.</source>
          <target state="translated">&lt;a href=&quot;#module-dbm.gnu&quot;&gt; &lt;code&gt;dbm.gnu&lt;/code&gt; 의&lt;/a&gt; 모듈은 GNU DBM 라이브러리에 대한 인터페이스를 제공합니다. &lt;code&gt;dbm.gnu.gdbm&lt;/code&gt; 객체는 키와 값이 저장되기 전에 항상 바이트로 변환된다는 점을 제외하고 매핑 (사전)처럼 동작합니다. 인쇄 &lt;code&gt;gdbm&lt;/code&gt; 목적은 키와 값 및 인쇄되지 않는 &lt;code&gt;items()&lt;/code&gt; 와 &lt;code&gt;values()&lt;/code&gt; 방법은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="47e5dd53aa4406655c5446f6ca3c8f631ee6ed71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dbm.ndbm&quot;&gt;&lt;code&gt;dbm.ndbm&lt;/code&gt;&lt;/a&gt; module provides an interface to the Unix &amp;ldquo;(n)dbm&amp;rdquo; library. Dbm objects behave like mappings (dictionaries), except that keys and values are always stored as bytes. Printing a &lt;code&gt;dbm&lt;/code&gt; object doesn&amp;rsquo;t print the keys and values, and the &lt;code&gt;items()&lt;/code&gt; and &lt;code&gt;values()&lt;/code&gt; methods are not supported.</source>
          <target state="translated">&lt;a href=&quot;#module-dbm.ndbm&quot;&gt; &lt;code&gt;dbm.ndbm&lt;/code&gt; 의&lt;/a&gt; 모듈은 유닉스 &quot;(N) DBM&quot;라이브러리에 대한 인터페이스를 제공한다. Dbm 객체는 키와 값이 항상 바이트로 저장된다는 점을 제외하고 매핑 (사전)처럼 동작합니다. 인쇄 &lt;code&gt;dbm&lt;/code&gt; 목적은 키와 값 및 인쇄되지 않는 &lt;code&gt;items()&lt;/code&gt; 와 &lt;code&gt;values()&lt;/code&gt; 방법은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d3eb110940a6d0c2a6b4dec54bf67cbb5278cf6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-decimal&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; module makes it possible to restore the identities by expanding the precision sufficiently to avoid loss of significance:</source>
          <target state="translated">&lt;a href=&quot;#module-decimal&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; 모듈은 중요성을 피할 손실을 충분히 정밀도를 확장하여 ID를 복원 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f1c49495d316a958e59f16606cc20968ceafbde8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-decimal&quot;&gt;&lt;code&gt;decimal&lt;/code&gt;&lt;/a&gt; module provides support for fast correctly-rounded decimal floating point arithmetic. It offers several advantages over the &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; datatype:</source>
          <target state="translated">&lt;a href=&quot;#module-decimal&quot;&gt; &lt;code&gt;decimal&lt;/code&gt; &lt;/a&gt; 모듈은 빠르고 정확하게 잡힌 진 부동 소수점 연산을위한 지원을 제공한다. &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 데이터 유형에 비해 몇 가지 장점이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b04c5fc66e11c44d867e1a7fff66f53200ae38a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dis&quot;&gt;&lt;code&gt;dis&lt;/code&gt;&lt;/a&gt; module also defines the following analysis functions that convert the input directly to the desired output. They can be useful if only a single operation is being performed, so the intermediate analysis object isn&amp;rsquo;t useful:</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-dis&quot;&gt; &lt;code&gt;dis&lt;/code&gt; &lt;/a&gt; 모듈은 원하는 출력에 직접 입력 변환 다음 분석 함수를 정의한다. 단일 작업 만 수행하는 경우 유용 할 수 있으므로 중간 분석 개체는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ccd02e4c91d4eee4a192e274ca77914c68054b5f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-dis&quot;&gt;&lt;code&gt;dis&lt;/code&gt;&lt;/a&gt; module supports the analysis of CPython &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytecode&quot;&gt;bytecode&lt;/a&gt; by disassembling it. The CPython bytecode which this module takes as an input is defined in the file &lt;code&gt;Include/opcode.h&lt;/code&gt; and used by the compiler and the interpreter.</source>
          <target state="translated">&lt;a href=&quot;#module-dis&quot;&gt; &lt;code&gt;dis&lt;/code&gt; &lt;/a&gt; 지지체를 CPython과의 분석 모듈&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytecode&quot;&gt; 바이트 코드&lt;/a&gt; 를 분해하여. 이 모듈이 입력으로 사용하는 CPython 바이트 코드는 &lt;code&gt;Include/opcode.h&lt;/code&gt; 파일에 정의되어 있으며 컴파일러와 인터프리터가 사용합니다.</target>
        </trans-unit>
        <trans-unit id="83431c34eb88b196a63f7d81ddc1e74988c77b08" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-distutils&quot;&gt;&lt;code&gt;distutils&lt;/code&gt;&lt;/a&gt; package provides support for building and installing additional modules into a Python installation. The new modules may be either 100%-pure Python, or may be extension modules written in C, or may be collections of Python packages which include modules coded in both Python and C.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-distutils&quot;&gt; &lt;code&gt;distutils&lt;/code&gt; &lt;/a&gt; 패키지를 구축하고 파이썬 설치에 모듈을 추가로 설치에 대한 지원을 제공합니다. 새 모듈은 100 % 순수 Python이거나 C로 작성된 확장 모듈이거나 Python 및 C로 코딩 된 모듈을 포함하는 Python 패키지 모음 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f19705a8fbfef4641836bb169973d67accdf5232" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; module searches for pieces of text that look like interactive Python sessions, and then executes those sessions to verify that they work exactly as shown. There are several common ways to use doctest:</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 다음 대화 형 파이썬 세션 및처럼 보이는 그림과 같이 그들이 정확히 작동하는지 확인하기 위해 그 세션을 실행하는 텍스트 조각을위한 모듈을 검색합니다. doctest를 사용하는 몇 가지 일반적인 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="518c528d98749aa7b88d3f6f6943b6e0c9e88226" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package is a library for managing email messages. It is specifically &lt;em&gt;not&lt;/em&gt; designed to do any sending of email messages to SMTP (&lt;a href=&quot;https://tools.ietf.org/html/rfc2821.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2821&lt;/strong&gt;&lt;/a&gt;), NNTP, or other servers; those are functions of modules such as &lt;a href=&quot;smtplib#module-smtplib&quot;&gt;&lt;code&gt;smtplib&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;nntplib#module-nntplib&quot;&gt;&lt;code&gt;nntplib&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package attempts to be as RFC-compliant as possible, supporting &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; and &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt;, as well as such MIME-related RFCs as &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2183.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2183&lt;/strong&gt;&lt;/a&gt;, and &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 이메일 메시지를 관리하기위한 라이브러리입니다. SMTP ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2821.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2821&lt;/strong&gt;&lt;/a&gt; ), NNTP 또는 기타 서버 로 전자 메일 메시지를 보내도록 특별히 설계 &lt;em&gt;되지 않았습니다&lt;/em&gt; . 이들은 &lt;a href=&quot;smtplib#module-smtplib&quot;&gt; &lt;code&gt;smtplib&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;nntplib#module-nntplib&quot;&gt; &lt;code&gt;nntplib&lt;/code&gt; &lt;/a&gt; 와 같은 모듈의 기능입니다 . &lt;a href=&quot;#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지 시도, 가능한 한 RFC 호환 지원으로 할 수 &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 6532을&lt;/strong&gt;&lt;/a&gt; 같은뿐만 아니라, MIME-관련 RFC &lt;a href=&quot;https://tools.ietf.org/html/rfc2045.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2045&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2046.html&quot; id=&quot;index-4&quot;&gt;&lt;strong&gt;RFC 2046&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2047.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 2047&lt;/strong&gt;&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2183.html&quot; id=&quot;index-6&quot;&gt;&lt;strong&gt;RFC 2183&lt;/strong&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc2231.html&quot; id=&quot;index-7&quot;&gt;&lt;strong&gt;RFC 2231&lt;/strong&gt;&lt;/a&gt; .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6d0eb3b7300956a2ceeb28372a83de449576a00" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-email.charset&quot;&gt;&lt;code&gt;email.charset&lt;/code&gt;&lt;/a&gt; module also provides the following functions for adding new entries to the global character set, alias, and codec registries:</source>
          <target state="translated">&lt;a href=&quot;#module-email.charset&quot;&gt; &lt;code&gt;email.charset&lt;/code&gt; &lt;/a&gt; 모듈은 글로벌 문자 세트, 별칭, 및 코덱 레지스트리에 새 항목을 추가하기위한 다음과 같은 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="276df02b8f91028e04b917f396e67af6014f067f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-email.generator&quot;&gt;&lt;code&gt;email.generator&lt;/code&gt;&lt;/a&gt; module also provides a derived class, &lt;a href=&quot;#email.generator.DecodedGenerator&quot;&gt;&lt;code&gt;DecodedGenerator&lt;/code&gt;&lt;/a&gt;, which is like the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; base class, except that non-&lt;em&gt;text&lt;/em&gt; parts are not serialized, but are instead represented in the output stream by a string derived from a template filled in with information about the part.</source>
          <target state="translated">&lt;a href=&quot;#module-email.generator&quot;&gt; &lt;code&gt;email.generator&lt;/code&gt; 의&lt;/a&gt; 모듈은 또한 유도 된 클래스를 제공 &lt;a href=&quot;#email.generator.DecodedGenerator&quot;&gt; &lt;code&gt;DecodedGenerator&lt;/code&gt; &lt;/a&gt; 등이며, &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 의 기본 클래스는 그 비를 제외시켰다 &lt;em&gt;텍스트&lt;/em&gt; 부분 연재되지을 대신 정보로 채워진 템플릿 유래의 문자열이 출력 스트림으로 표현되는 부분에 대해.</target>
        </trans-unit>
        <trans-unit id="c5baa91c85a09658397938aaa55e254801323f0d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-email.header&quot;&gt;&lt;code&gt;email.header&lt;/code&gt;&lt;/a&gt; module also provides the following convenient functions.</source>
          <target state="translated">&lt;a href=&quot;#module-email.header&quot;&gt; &lt;code&gt;email.header&lt;/code&gt; &lt;/a&gt; 모듈은 또한 다음과 같은 편리한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="864ae3019787fbbacc4869aa22ed280c894269df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-ensurepip&quot;&gt;&lt;code&gt;ensurepip&lt;/code&gt;&lt;/a&gt; package provides support for bootstrapping the &lt;code&gt;pip&lt;/code&gt; installer into an existing Python installation or virtual environment. This bootstrapping approach reflects the fact that &lt;code&gt;pip&lt;/code&gt; is an independent project with its own release cycle, and the latest available stable version is bundled with maintenance and feature releases of the CPython reference interpreter.</source>
          <target state="translated">&lt;a href=&quot;#module-ensurepip&quot;&gt; &lt;code&gt;ensurepip&lt;/code&gt; 의&lt;/a&gt; 패키지는 부트 스트랩에 대한 지원 제공 &lt;code&gt;pip&lt;/code&gt; 기존의 파이썬 설치 또는 가상 환경에 설치합니다. 이 부트 스트랩 접근 방식은 &lt;code&gt;pip&lt;/code&gt; 가 자체 릴리스주기를 갖는 독립적 인 프로젝트이며, 최신의 안정적인 버전은 CPython 참조 인터프리터의 유지 보수 및 기능 릴리스와 번들로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="2e914c64de75e03d81ec5c06af9f225333493592" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-filecmp&quot;&gt;&lt;code&gt;filecmp&lt;/code&gt;&lt;/a&gt; module defines functions to compare files and directories, with various optional time/correctness trade-offs. For comparing files, see also the &lt;a href=&quot;difflib#module-difflib&quot;&gt;&lt;code&gt;difflib&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-filecmp&quot;&gt; &lt;code&gt;filecmp&lt;/code&gt; 의&lt;/a&gt; 모듈을 정의 기능은 다양한 옵션 시간 / 정확성 절충, 파일과 디렉토리를 비교합니다. 파일을 비교하려면 &lt;a href=&quot;difflib#module-difflib&quot;&gt; &lt;code&gt;difflib&lt;/code&gt; &lt;/a&gt; 도 참조하십시오 모듈 .</target>
        </trans-unit>
        <trans-unit id="afe0c20edeebc5dc92c7666ce3faa36625476e96" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-filecmp&quot;&gt;&lt;code&gt;filecmp&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-filecmp&quot;&gt; &lt;code&gt;filecmp&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="8baea7d5d3185343f11f955e55d58ecf627ccc7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-fractions&quot;&gt;&lt;code&gt;fractions&lt;/code&gt;&lt;/a&gt; module provides support for rational number arithmetic.</source>
          <target state="translated">&lt;a href=&quot;#module-fractions&quot;&gt; &lt;code&gt;fractions&lt;/code&gt; &lt;/a&gt; 모듈은 유리수 연산에 대한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3f749de40e7867147e0f2845567293403dfc026c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-functools&quot;&gt;&lt;code&gt;functools&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-functools&quot;&gt; &lt;code&gt;functools&lt;/code&gt; &lt;/a&gt; 다음과 같은 기능을 정의를 모듈 :</target>
        </trans-unit>
        <trans-unit id="7f1fe2c5ba179e60e1f1cb7dcb0baa108c0d4357" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-functools&quot;&gt;&lt;code&gt;functools&lt;/code&gt;&lt;/a&gt; module is for higher-order functions: functions that act on or return other functions. In general, any callable object can be treated as a function for the purposes of this module.</source>
          <target state="translated">&lt;a href=&quot;#module-functools&quot;&gt; &lt;code&gt;functools&lt;/code&gt; 의&lt;/a&gt; 모듈은 고차 함수이다 : 다른 기능을 반환하는 함수에 있는지 또는 행위. 일반적으로 호출 가능한 객체는이 모듈의 목적을위한 함수로 취급 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97d1a2dde8c7152f96bb497e1ed989a639688463" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gc&quot;&gt;&lt;code&gt;gc&lt;/code&gt;&lt;/a&gt; module provides the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-gc&quot;&gt; &lt;code&gt;gc&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 제공한다 :</target>
        </trans-unit>
        <trans-unit id="c62bc40a4ff1e5558a365f12d75aa08d21852606" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-getopt&quot;&gt;&lt;code&gt;getopt&lt;/code&gt;&lt;/a&gt; module is a parser for command line options whose API is designed to be familiar to users of the C &lt;code&gt;getopt()&lt;/code&gt; function. Users who are unfamiliar with the C &lt;code&gt;getopt()&lt;/code&gt; function or who would like to write less code and get better help and error messages should consider using the &lt;a href=&quot;argparse#module-argparse&quot;&gt;&lt;code&gt;argparse&lt;/code&gt;&lt;/a&gt; module instead.</source>
          <target state="translated">&lt;a href=&quot;#module-getopt&quot;&gt; &lt;code&gt;getopt&lt;/code&gt; 에의&lt;/a&gt; 모듈 API는 C의 사용자에게 친숙한 수 있도록 설계 명령 행 옵션에 대한 파서 &lt;code&gt;getopt()&lt;/code&gt; 함수입니다. C &lt;code&gt;getopt()&lt;/code&gt; 함수에 익숙하지 않거나 더 적은 코드를 작성하고 더 나은 도움말 및 오류 메시지를 원하는 &lt;a href=&quot;argparse#module-argparse&quot;&gt; &lt;code&gt;argparse&lt;/code&gt; &lt;/a&gt; 는 argparse를 사용하는 것이 좋습니다. 모듈을 대신 합니다.</target>
        </trans-unit>
        <trans-unit id="9c38cf20156455ac80ef263339cb001fb1613a20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-getpass&quot;&gt;&lt;code&gt;getpass&lt;/code&gt;&lt;/a&gt; module provides two functions:</source>
          <target state="translated">&lt;a href=&quot;#module-getpass&quot;&gt; &lt;code&gt;getpass&lt;/code&gt; &lt;/a&gt; 모듈은 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="f3f02bcefd4d73672c7971b1989f2f09e0845192" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module defines the following API, which is very similar to the GNU &lt;strong&gt;gettext&lt;/strong&gt; API. If you use this API you will affect the translation of your entire application globally. Often this is what you want if your application is monolingual, with the choice of language dependent on the locale of your user. If you are localizing a Python module, or if your application needs to switch languages on the fly, you probably want to use the class-based API instead.</source>
          <target state="translated">&lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈은 GNU의 매우 유사합니다 다음 API 정의 &lt;strong&gt;의 gettext&lt;/strong&gt; API를. 이 API를 사용하면 전체 응용 프로그램의 전 세계 번역에 영향을 미칩니다. 응용 프로그램이 단일 언어 인 경우 사용자의 로캘에 따라 언어를 선택할 수있는 경우가 종종 있습니다. Python 모듈을 지역화하거나 응용 프로그램에서 언어를 즉시 전환해야하는 경우 클래스 기반 API를 대신 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="304703f37d6e6bee804d49ec8effba5df7d13725" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module provides internationalization (I18N) and localization (L10N) services for your Python modules and applications. It supports both the GNU &lt;strong&gt;gettext&lt;/strong&gt; message catalog API and a higher level, class-based API that may be more appropriate for Python files. The interface described below allows you to write your module and application messages in one natural language, and provide a catalog of translated messages for running under different natural languages.</source>
          <target state="translated">&lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈이 제공하는 국제화 (I18N)와 파이썬 모듈과 응용 프로그램에 대한 지역화 (L10N) 서비스를 제공합니다. GNU &lt;strong&gt;gettext&lt;/strong&gt; 메시지 카탈로그 API와 Python 파일에 더 적합한 고급 클래스 기반 API를 모두 지원 합니다. 아래 설명 된 인터페이스를 사용하면 모듈 및 응용 프로그램 메시지를 하나의 자연어로 작성하고 다른 자연 언어로 실행하기 위해 번역 된 메시지 카탈로그를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="465e3272bad4a252804f16ac717e1e46b75c91a0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; module provides one additional class derived from &lt;a href=&quot;#gettext.NullTranslations&quot;&gt;&lt;code&gt;NullTranslations&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt;&lt;code&gt;GNUTranslations&lt;/code&gt;&lt;/a&gt;. This class overrides &lt;code&gt;_parse()&lt;/code&gt; to enable reading GNU &lt;strong&gt;gettext&lt;/strong&gt; format &lt;code&gt;.mo&lt;/code&gt; files in both big-endian and little-endian format.</source>
          <target state="translated">&lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 모듈에서 파생 된 하나 개의 추가 클래스를 제공 &lt;a href=&quot;#gettext.NullTranslations&quot;&gt; &lt;code&gt;NullTranslations&lt;/code&gt; &lt;/a&gt; : &lt;a href=&quot;#gettext.GNUTranslations&quot;&gt; &lt;code&gt;GNUTranslations&lt;/code&gt; 를&lt;/a&gt; . 이 클래스는 &lt;code&gt;_parse()&lt;/code&gt; 를 재정 의하여 빅 엔디안 및 리틀 엔디안 형식으로 GNU &lt;strong&gt;gettext&lt;/strong&gt; 형식 &lt;code&gt;.mo&lt;/code&gt; 파일을 읽을 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="66eca1cb3bba0fc5c53d2a48fa4bd9ad5c7386f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; module finds all the pathnames matching a specified pattern according to the rules used by the Unix shell, although results are returned in arbitrary order. No tilde expansion is done, but &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt;, and character ranges expressed with &lt;code&gt;[]&lt;/code&gt; will be correctly matched. This is done by using the &lt;a href=&quot;os#os.scandir&quot;&gt;&lt;code&gt;os.scandir()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;fnmatch#fnmatch.fnmatch&quot;&gt;&lt;code&gt;fnmatch.fnmatch()&lt;/code&gt;&lt;/a&gt; functions in concert, and not by actually invoking a subshell. Note that unlike &lt;a href=&quot;fnmatch#fnmatch.fnmatch&quot;&gt;&lt;code&gt;fnmatch.fnmatch()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#module-glob&quot;&gt;&lt;code&gt;glob&lt;/code&gt;&lt;/a&gt; treats filenames beginning with a dot (&lt;code&gt;.&lt;/code&gt;) as special cases. (For tilde and shell variable expansion, use &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt;&lt;code&gt;os.path.expanduser()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os.path#os.path.expandvars&quot;&gt;&lt;code&gt;os.path.expandvars()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">&lt;a href=&quot;#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 결과는 임의의 순서로 반환되지만 모듈 유닉스 쉘에 사용 된 규칙에 따라 소정 패턴과 일치하는 모든 패스를 찾는다. 어떤 물결표 확장은 이루어지지되지만, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;[]&lt;/code&gt; 로 표시되는 문자 범위 가 올바르게 일치합니다. 이는 실제로 서브 쉘을 호출하는 것이 아니라 &lt;a href=&quot;os#os.scandir&quot;&gt; &lt;code&gt;os.scandir()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;fnmatch#fnmatch.fnmatch&quot;&gt; &lt;code&gt;fnmatch.fnmatch()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 수행됩니다 . 달리합니다 &lt;a href=&quot;fnmatch#fnmatch.fnmatch&quot;&gt; &lt;code&gt;fnmatch.fnmatch()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#module-glob&quot;&gt; &lt;code&gt;glob&lt;/code&gt; &lt;/a&gt; 취급 파일 이름은 점 (로 시작 &lt;code&gt;.&lt;/code&gt; ) 특별한 경우로. 물결표 및 셸 변수 확장의 경우 &lt;a href=&quot;os.path#os.path.expanduser&quot;&gt; &lt;code&gt;os.path.expanduser()&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;os.path#os.path.expandvars&quot;&gt; &lt;code&gt;os.path.expandvars()&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ee135b0e52ba012d398c3ba5f0f48800bfbf94c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gzip&quot;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; module provides a simple command line interface to compress or decompress files.</source>
          <target state="translated">&lt;a href=&quot;#module-gzip&quot;&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;/a&gt; 모듈은 압축하거나 압축 해제 파일 단순한 커맨드 라인 인터페이스를 제공한다.</target>
        </trans-unit>
        <trans-unit id="15bd57aeec8fc138aafe0bb49a573984c38a169f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-gzip&quot;&gt;&lt;code&gt;gzip&lt;/code&gt;&lt;/a&gt; module provides the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; class, as well as the &lt;a href=&quot;#gzip.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gzip.compress&quot;&gt;&lt;code&gt;compress()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gzip.decompress&quot;&gt;&lt;code&gt;decompress()&lt;/code&gt;&lt;/a&gt; convenience functions. The &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; class reads and writes &lt;strong&gt;gzip&lt;/strong&gt;-format files, automatically compressing or decompressing the data so that it looks like an ordinary &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-gzip&quot;&gt; &lt;code&gt;gzip&lt;/code&gt; &lt;/a&gt; 모듈은 제공 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 클래스뿐만 아니라 &lt;a href=&quot;#gzip.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gzip.compress&quot;&gt; &lt;code&gt;compress()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#gzip.decompress&quot;&gt; &lt;code&gt;decompress()&lt;/code&gt; &lt;/a&gt; 편의 기능. &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; &lt;/a&gt; 클래스는 읽기와 쓰기는 &lt;strong&gt;gzip을&lt;/strong&gt; 자동으로 압축하거나 보통처럼 보이도록 데이터를 압축 해제, -format 파일을 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c6f6b35db45c5afe68357f79f8ad46f1bea281f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; module defines classes for automatic handling of HTTP cookies. It is useful for accessing web sites that require small pieces of data &amp;ndash; &lt;em&gt;cookies&lt;/em&gt; &amp;ndash; to be set on the client machine by an HTTP response from a web server, and then returned to the server in later HTTP requests.</source>
          <target state="translated">&lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; HTTP 쿠키의 자동 처리를위한 모듈을 정의 클래스. 웹 서버의 HTTP 응답으로 클라이언트 시스템에서 작은 데이터 조각 ( &lt;em&gt;쿠키)&lt;/em&gt; 이 필요한 웹 사이트에 액세스 한 후 나중에 HTTP 요청으로 서버로 반환하는 데 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="3f3fea001927a18b85a4c09ec271e65d4287d954" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-http.cookies&quot;&gt;&lt;code&gt;http.cookies&lt;/code&gt;&lt;/a&gt; module defines classes for abstracting the concept of cookies, an HTTP state management mechanism. It supports both simple string-only cookies, and provides an abstraction for having any serializable data-type as cookie value.</source>
          <target state="translated">&lt;a href=&quot;#module-http.cookies&quot;&gt; &lt;code&gt;http.cookies&lt;/code&gt; &lt;/a&gt; 쿠키의 개념은 HTTP 상태 관리 메커니즘을 추상화에 대한 모듈을 정의 클래스. 단순 문자열 전용 쿠키를 모두 지원하며 직렬화 가능한 데이터 유형을 쿠키 값으로 사용하기위한 추상화를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e195dbec46f0f01af467f05e89883e34aaea795" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-imghdr&quot;&gt;&lt;code&gt;imghdr&lt;/code&gt;&lt;/a&gt; module defines the following function:</source>
          <target state="translated">&lt;a href=&quot;#module-imghdr&quot;&gt; &lt;code&gt;imghdr&lt;/code&gt; 의&lt;/a&gt; 모듈은 다음 함수를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="5051c64ebd99c3b18d020b3ccbef47324152e360" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-imghdr&quot;&gt;&lt;code&gt;imghdr&lt;/code&gt;&lt;/a&gt; module determines the type of image contained in a file or byte stream.</source>
          <target state="translated">&lt;a href=&quot;#module-imghdr&quot;&gt; &lt;code&gt;imghdr&lt;/code&gt; 의&lt;/a&gt; 모듈은 파일, 바이트 스트림에 포함 된 화상의 종류를 결정한다.</target>
        </trans-unit>
        <trans-unit id="b37e066e590ee782ac8088a20c1d0d219f14201c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-importlib.abc&quot;&gt;&lt;code&gt;importlib.abc&lt;/code&gt;&lt;/a&gt; module contains all of the core abstract base classes used by &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt;. Some subclasses of the core abstract base classes are also provided to help in implementing the core ABCs.</source>
          <target state="translated">&lt;a href=&quot;#module-importlib.abc&quot;&gt; &lt;code&gt;importlib.abc&lt;/code&gt; &lt;/a&gt; 모듈에 사용되는 핵심 추상 기본 클래스의 모든 포함 &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; . 핵심 ABC를 구현하는 데 도움이되도록 핵심 추상 기본 클래스의 일부 하위 클래스도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c66bbf31fa9b8e4bdc53ceff09f10bbba2ee186a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module also provides a basic introspection capability from the command line.</source>
          <target state="translated">또한 &lt;a href=&quot;#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈은 명령 줄에서 기본적인 내부 검사 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c4b5818a166440b1e94eba83e154dc5cd38c9e16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module provides several useful functions to help get information about live objects such as modules, classes, methods, functions, tracebacks, frame objects, and code objects. For example, it can help you examine the contents of a class, retrieve the source code of a method, extract and format the argument list for a function, or get all the information you need to display a detailed traceback.</source>
          <target state="translated">는 &lt;a href=&quot;#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈은 모듈, 클래스, 메소드, 함수, 역 추적, 프레임 개체 및 코드 개체로 라이브 개체에 대한 도움말 가져 오기 정보에 대한 몇 가지 유용한 기능을 제공합니다. 예를 들어, 클래스의 내용을 검사하고, 메소드의 소스 코드를 검색하고, 함수의 인수 목록을 추출 및 형식화하거나, 자세한 역 추적을 표시하는 데 필요한 모든 정보를 얻는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22eaf9c954b96777da730d55699780a014bef920" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module provides Python&amp;rsquo;s main facilities for dealing with various types of I/O. There are three main types of I/O: &lt;em&gt;text I/O&lt;/em&gt;, &lt;em&gt;binary I/O&lt;/em&gt; and &lt;em&gt;raw I/O&lt;/em&gt;. These are generic categories, and various backing stores can be used for each of them. A concrete object belonging to any of these categories is called a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. Other common terms are &lt;em&gt;stream&lt;/em&gt; and &lt;em&gt;file-like object&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈은 I / O의 다양한 종류를 처리하기위한 파이썬의 주요 기능을 제공합니다. I / O에는 세 가지 주요 유형 인 &lt;em&gt;텍스트 I / O가 있습니다&lt;/em&gt; .&lt;em&gt; 이진 I / O&lt;/em&gt; 및 &lt;em&gt;원시 I / O&lt;/em&gt; 입니다. 이들은 일반적인 범주이며 다양한 백업 저장소를 각각에 사용할 수 있습니다. 이러한 범주에 속하는 구체적인 객체를 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 라고 합니다 . 다른 일반적인 용어는 &lt;em&gt;stream&lt;/em&gt; 및 &lt;em&gt;file-like object&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="337e940454ffef6546d00cf1ac696aa914c429f9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-ipaddress&quot;&gt;&lt;code&gt;ipaddress&lt;/code&gt;&lt;/a&gt; module provides factory functions to conveniently create IP addresses, networks and interfaces:</source>
          <target state="translated">&lt;a href=&quot;#module-ipaddress&quot;&gt; &lt;code&gt;ipaddress&lt;/code&gt; &lt;/a&gt; 모듈은 편리하게 IP 주소, 네트워크와 인터페이스를 만드는 공장 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="d18242ee067513d021ffb35aad13c8c4957412e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-json&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; module always produces &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; objects, not &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects. Therefore, &lt;code&gt;fp.write()&lt;/code&gt; must support &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; input.</source>
          <target state="translated">&lt;a href=&quot;#module-json&quot;&gt; &lt;code&gt;json&lt;/code&gt; &lt;/a&gt; 모듈은 항상 생산 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , 오브젝트를하지&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체. 따라서 &lt;code&gt;fp.write()&lt;/code&gt; 는 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 입력을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1cd3675e58eb6cf4678aabcd494c8d6a3069bc0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-json.tool&quot;&gt;&lt;code&gt;json.tool&lt;/code&gt;&lt;/a&gt; module provides a simple command line interface to validate and pretty-print JSON objects.</source>
          <target state="translated">&lt;a href=&quot;#module-json.tool&quot;&gt; &lt;code&gt;json.tool&lt;/code&gt; 의&lt;/a&gt; 모듈 검증 및 JSON 객체를 꽤 인쇄에 대한 간단한 명령 줄 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4ee0472c78500aff4f45be9b42a534d389f95f4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module allows one to get any line from a Python source file, while attempting to optimize internally, using a cache, the common case where many lines are read from a single file. This is used by the &lt;a href=&quot;traceback#module-traceback&quot;&gt;&lt;code&gt;traceback&lt;/code&gt;&lt;/a&gt; module to retrieve source lines for inclusion in the formatted traceback.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; &lt;/a&gt; 모듈은 내부적으로 최적화를 시도 캐시, 많은 행이 하나의 파일에서 읽기 일반적인 경우를 사용하는 동안, 파이썬 소스 파일의 모든 줄을 얻기 위해 일을 할 수 있습니다. 이것은 &lt;a href=&quot;traceback#module-traceback&quot;&gt; &lt;code&gt;traceback&lt;/code&gt; &lt;/a&gt; 모듈에서 형식화 된 역 추적에 포함 할 소스 행을 검색 하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="4388c78f3684702514a1a530e894dc30b457a76b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-linecache&quot;&gt;&lt;code&gt;linecache&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-linecache&quot;&gt; &lt;code&gt;linecache&lt;/code&gt; 의&lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="7cc0ca9ca7858a7e663453102d705f686951b40b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module defines the following exception and functions:</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 예외와 함수를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="9d17797caba78de9da6840e87cdb7c017d4979aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module is implemented on top of the &lt;code&gt;_locale&lt;/code&gt; module, which in turn uses an ANSI C locale implementation if available.</source>
          <target state="translated">&lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈은 위에 구현 &lt;code&gt;_locale&lt;/code&gt; 가능한 경우 턴에서 ANSI C 로케일 구현을 사용하는 모듈.</target>
        </trans-unit>
        <trans-unit id="985eb6bd03d0ee6cad1fe0d5905ed42ca1a9c6d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-locale&quot;&gt;&lt;code&gt;locale&lt;/code&gt;&lt;/a&gt; module opens access to the POSIX locale database and functionality. The POSIX locale mechanism allows programmers to deal with certain cultural issues in an application, without requiring the programmer to know all the specifics of each country where the software is executed.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-locale&quot;&gt; &lt;code&gt;locale&lt;/code&gt; &lt;/a&gt; 모듈은 POSIX 로케일 데이터베이스 및 기능에 대한 액세스를 엽니 다. POSIX 로케일 메커니즘을 사용하면 프로그래머가 소프트웨어가 실행되는 각 국가의 모든 세부 사항을 알 필요없이 애플리케이션의 특정 문화 문제를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d329ac973f755c3eeaf2eb63a56cf4ee876322a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; module is not intended to be secure against erroneous or maliciously constructed data. Never unmarshal data received from an untrusted or unauthenticated source.</source>
          <target state="translated">그만큼 &lt;a href=&quot;#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 모듈은 잘못된 또는 악의의 데이터 구성에 대해 안전한 것으로 의도되지 않는다. 신뢰할 수 없거나 인증되지 않은 소스에서받은 데이터를 마샬링 해제하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2fa1709239f31c9ef299cc4aa55815731315529f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-mimetypes&quot;&gt;&lt;code&gt;mimetypes&lt;/code&gt;&lt;/a&gt; module converts between a filename or URL and the MIME type associated with the filename extension. Conversions are provided from filename to MIME type and from MIME type to filename extension; encodings are not supported for the latter conversion.</source>
          <target state="translated">&lt;a href=&quot;#module-mimetypes&quot;&gt; &lt;code&gt;mimetypes&lt;/code&gt; &lt;/a&gt; 파일명과 URL 또는 파일 확장명과 연관된 MIME 타입간에 변환을 모듈. 파일 이름에서 MIME 유형으로, MIME 유형에서 파일 이름 확장자로의 변환이 제공됩니다. 후자의 변환에는 인코딩이 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7cec5e16f074ccd4b88c3f2c5b5ad1747c08fecf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-msilib&quot;&gt;&lt;code&gt;msilib&lt;/code&gt;&lt;/a&gt; supports the creation of Microsoft Installer (&lt;code&gt;.msi&lt;/code&gt;) files. Because these files often contain an embedded &amp;ldquo;cabinet&amp;rdquo; file (&lt;code&gt;.cab&lt;/code&gt;), it also exposes an API to create CAB files. Support for reading &lt;code&gt;.cab&lt;/code&gt; files is currently not implemented; read support for the &lt;code&gt;.msi&lt;/code&gt; database is possible.</source>
          <target state="translated">&lt;a href=&quot;#module-msilib&quot;&gt; &lt;code&gt;msilib&lt;/code&gt; 는&lt;/a&gt; Microsoft 설치 (의 작성 지원 &lt;code&gt;.msi&lt;/code&gt; ) 파일을. 이러한 파일에는 포함 된 &quot;cabinet&quot;파일 ( &lt;code&gt;.cab&lt;/code&gt; )이 포함되어 있기 때문에 CAB 파일을 만드는 API도 제공합니다. &lt;code&gt;.cab&lt;/code&gt; 파일 읽기 지원 은 현재 구현되어 있지 않습니다. &lt;code&gt;.msi&lt;/code&gt; 데이터베이스에 대한 읽기 지원 이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="1d180c1f5f80ac6b7619e22dea9da3b1d42d7b68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; module also introduces APIs which do not have analogs in the &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module. A prime example of this is the &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; object which offers a convenient means of parallelizing the execution of a function across multiple input values, distributing the input data across processes (data parallelism). The following example demonstrates the common practice of defining such functions in a module so that child processes can successfully import that module. This basic example of data parallelism using &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 모듈은 또한에 아날로그가없는 API를 소개 &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈을. 이것의 대표적인 예는 여러 입력 값에 걸쳐 함수 실행을 병렬화하고 입력 데이터를 프로세스에 분산시키는 편리한 방법을 제공하는 &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 객체입니다 (데이터 병렬 처리). 다음 예제는 하위 프로세스가 해당 모듈을 성공적으로 가져올 수 있도록 모듈에서 이러한 기능을 정의하는 일반적인 방법을 보여줍니다. 사용하여 데이터 병렬이 기본 예제 &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="3ce6c0ff4a425000d2ca5b18082944e870330bd9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-multiprocessing&quot;&gt;&lt;code&gt;multiprocessing&lt;/code&gt;&lt;/a&gt; package mostly replicates the API of the &lt;a href=&quot;threading#module-threading&quot;&gt;&lt;code&gt;threading&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing&quot;&gt; &lt;code&gt;multiprocessing&lt;/code&gt; &lt;/a&gt; 패키지는 대부분의 API 복제 &lt;a href=&quot;threading#module-threading&quot;&gt; &lt;code&gt;threading&lt;/code&gt; &lt;/a&gt; 모듈을.</target>
        </trans-unit>
        <trans-unit id="2e04e4b80cc93688459ebf1f22c4af2810aed5ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-multiprocessing.dummy&quot;&gt;&lt;code&gt;multiprocessing.dummy&lt;/code&gt;&lt;/a&gt; module</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing.dummy&quot;&gt; &lt;code&gt;multiprocessing.dummy&lt;/code&gt; &lt;/a&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="2e6ccfe6b1949eb189200e600c146480d6b41838" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt;&lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt;&lt;/a&gt; module</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt; &lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt; 는&lt;/a&gt; 모듈</target>
        </trans-unit>
        <trans-unit id="54123a4d5ab46582e743e998c4d9d717ab3833e0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt;&lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt;&lt;/a&gt; module provides functions for allocating &lt;a href=&quot;ctypes#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; objects from shared memory which can be inherited by child processes.</source>
          <target state="translated">&lt;a href=&quot;#module-multiprocessing.sharedctypes&quot;&gt; &lt;code&gt;multiprocessing.sharedctypes&lt;/code&gt; 의&lt;/a&gt; 모듈은 할당 기능을 제공 &lt;a href=&quot;ctypes#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 자식 프로세스가 상속 될 수있는 공유 메모리에서 객체.</target>
        </trans-unit>
        <trans-unit id="5e77d3fa14560b48c3bb530fbc3f0bf4bfc64b6d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-nis&quot;&gt;&lt;code&gt;nis&lt;/code&gt;&lt;/a&gt; module defines the following exception:</source>
          <target state="translated">&lt;a href=&quot;#module-nis&quot;&gt; &lt;code&gt;nis&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 예외를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="1e3761c45ab69e027f8b7edb51fe146513e4f73b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-nis&quot;&gt;&lt;code&gt;nis&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-nis&quot;&gt; &lt;code&gt;nis&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="71fc5dc1aea79e21eb08ca6f6a8fbaf5908823ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-nis&quot;&gt;&lt;code&gt;nis&lt;/code&gt;&lt;/a&gt; module gives a thin wrapper around the NIS library, useful for central administration of several hosts.</source>
          <target state="translated">&lt;a href=&quot;#module-nis&quot;&gt; &lt;code&gt;nis&lt;/code&gt; &lt;/a&gt; 모듈은 여러 호스트의 중앙 관리를위한 유용한 NIS 라이브러리 주위에 얇은 래퍼를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="55de6a4c667171a477291b0e3c4227176341dcf7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numbers&quot;&gt;&lt;code&gt;numbers&lt;/code&gt;&lt;/a&gt; module (&lt;a href=&quot;https://www.python.org/dev/peps/pep-3141&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3141&lt;/strong&gt;&lt;/a&gt;) defines a hierarchy of numeric &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;abstract base classes&lt;/a&gt; which progressively define more operations. None of the types defined in this module can be instantiated.</source>
          <target state="translated">&lt;a href=&quot;#module-numbers&quot;&gt; &lt;code&gt;numbers&lt;/code&gt; &lt;/a&gt; 모듈 ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-3141&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 3141&lt;/strong&gt;&lt;/a&gt; ) 숫자의 계층 구조를 정의하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-abstract-base-class&quot;&gt;추상 기본 클래스&lt;/a&gt; 점진적으로 더 작업을 정의합니다. 이 모듈에 정의 된 유형을 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="70373d538baff7f0323f18426896989846c3f044" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module also defines tools for generalized attribute and item lookups. These are useful for making fast field extractors as arguments for &lt;a href=&quot;functions#map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;functions#sorted&quot;&gt;&lt;code&gt;sorted()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;itertools#itertools.groupby&quot;&gt;&lt;code&gt;itertools.groupby()&lt;/code&gt;&lt;/a&gt;, or other functions that expect a function argument.</source>
          <target state="translated">&lt;a href=&quot;#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈은 일반 속성과 항목 조회 도구를 정의합니다. 이들은 빠른 필드 추출기를 &lt;a href=&quot;functions#map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;functions#sorted&quot;&gt; &lt;code&gt;sorted()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;itertools#itertools.groupby&quot;&gt; &lt;code&gt;itertools.groupby()&lt;/code&gt; &lt;/a&gt; 또는 함수 인수가 필요한 다른 함수에 대한 인수로 만드는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a53ed99c7adf19e939eacd855f49e5b5bb689f11" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module exports a set of efficient functions corresponding to the intrinsic operators of Python. For example, &lt;code&gt;operator.add(x, y)&lt;/code&gt; is equivalent to the expression &lt;code&gt;x+y&lt;/code&gt;. Many function names are those used for special methods, without the double underscores. For backward compatibility, many of these have a variant with the double underscores kept. The variants without the double underscores are preferred for clarity.</source>
          <target state="translated">&lt;a href=&quot;#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈 파이썬 극한 연산자에 대응하는 효율적인 기능의 세트를 반출. 예를 들어 &lt;code&gt;operator.add(x, y)&lt;/code&gt; 는 표현식 &lt;code&gt;x+y&lt;/code&gt; 와 같습니다 . 많은 함수 이름은 이중 밑줄없이 특수한 방법에 사용되는 이름입니다. 이전 버전과의 호환성을 위해 이중 밑줄을 유지 한 변형이 있습니다. 이중 밑줄이없는 변형은 명확성을 위해 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="61ce337cbedc3f2529912d2201eb2b625280d4e4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module defines functions for a few distinct purposes. The most important purposes are to create ST objects and to convert ST objects to other representations such as parse trees and compiled code objects, but there are also functions which serve to query the type of parse tree represented by an ST object.</source>
          <target state="translated">&lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈은 몇 가지 뚜렷한 목적 함수를 정의합니다. 가장 중요한 목적은 ST 오브젝트를 작성하고 ST 오브젝트를 구문 분석 트리 및 컴파일 된 코드 오브젝트와 같은 다른 표현으로 변환하는 것입니다. 그러나 ST 오브젝트가 나타내는 구문 분석 트리의 유형을 조회하는 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="25ef15b9c592ea1ea9713013e94dbb5918e5266e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-parser&quot;&gt;&lt;code&gt;parser&lt;/code&gt;&lt;/a&gt; module provides an interface to Python&amp;rsquo;s internal parser and byte-code compiler. The primary purpose for this interface is to allow Python code to edit the parse tree of a Python expression and create executable code from this. This is better than trying to parse and modify an arbitrary Python code fragment as a string because parsing is performed in a manner identical to the code forming the application. It is also faster.</source>
          <target state="translated">&lt;a href=&quot;#module-parser&quot;&gt; &lt;code&gt;parser&lt;/code&gt; &lt;/a&gt; 모듈 파이썬 내부 파서와 바이트 코드 컴파일러에 대한 인터페이스를 제공한다. 이 인터페이스의 주요 목적은 Python 코드가 Python 표현식의 구문 분석 트리를 편집하고 이로부터 실행 코드를 작성할 수 있도록하는 것입니다. 응용 프로그램을 구성하는 코드와 동일한 방식으로 구문 분석이 수행되므로 임의의 Python 코드 조각을 문자열로 구문 분석하고 수정하는 것보다 낫습니다. 또한 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="124d6c592431fa7358eb2e18c55240e683dffb5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module defines three exceptions:</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 세 가지 예외를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="9f814de04271749df0afff6d13e98c3c7d28fbff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module differs from &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; in several significant ways:</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 에서 모듈 다릅니다 &lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 몇 가지 중요한 방법 :</target>
        </trans-unit>
        <trans-unit id="9d4c57e70369b25520cce55fa2bce230fdd44e46" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module exports three classes, &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#pickle.Unpickler&quot;&gt;&lt;code&gt;Unpickler&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt;&lt;code&gt;PickleBuffer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 세 가지 클래스, 수출 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#pickle.Unpickler&quot;&gt; &lt;code&gt;Unpickler&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.PickleBuffer&quot;&gt; &lt;code&gt;PickleBuffer&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="43904a297de386b3b1196f81f8862c9836da9d0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module implements binary protocols for serializing and de-serializing a Python object structure. &lt;em&gt;&amp;ldquo;Pickling&amp;rdquo;&lt;/em&gt; is the process whereby a Python object hierarchy is converted into a byte stream, and &lt;em&gt;&amp;ldquo;unpickling&amp;rdquo;&lt;/em&gt; is the inverse operation, whereby a byte stream (from a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;binary file&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;) is converted back into an object hierarchy. Pickling (and unpickling) is alternatively known as &amp;ldquo;serialization&amp;rdquo;, &amp;ldquo;marshalling,&amp;rdquo; &lt;a href=&quot;#id7&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; or &amp;ldquo;flattening&amp;rdquo;; however, to avoid confusion, the terms used here are &amp;ldquo;pickling&amp;rdquo; and &amp;ldquo;unpickling&amp;rdquo;.</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈 구현 직렬화와 파이썬 객체 구조를 드 - 직렬화 바이너리 프로토콜을 지원합니다. &lt;em&gt;&quot;산세&quot;&lt;/em&gt; 파이썬 오브젝트 계층이 바이트 스트림으로 변환된다 공정이며, &lt;em&gt;&quot;unpickling&quot;을&lt;/em&gt; 역 연산이다있다 바이트 스트림 (a에서 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-binary-file&quot;&gt;이진 파일&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;객체와 같이 바이트&lt;/a&gt; ) 오브젝트 계층으로 변환 돌아온다. &quot;마샬링&quot;산세 (및 unpickling) 대안 &quot;시리얼&quot;로 알려진 &lt;a href=&quot;#id7&quot; id=&quot;id1&quot;&gt;하나&lt;/a&gt; 또는 &quot;평탄화&quot;; 그러나 혼동을 피하기 위해 여기에 사용 된 용어는 &quot;산세&quot;및 &quot;언 산세&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="02d5b31a8a38315feca7469759e047393292369e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module keeps track of the objects it has already serialized, so that later references to the same object won&amp;rsquo;t be serialized again. &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t do this.</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 동일한 개체에 대한 참조를 나중에 다시 직렬화 수 없기 때문, 이미 연재 한 객체를 추적합니다. &lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 은 이것을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f39d6e73fb52a3aadce8298900f7e06e2e556325" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module provides the following constants:</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 상수를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="053f27ecbe7215e45dbf076ba18174c65da7243d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; module provides the following functions to make the pickling process more convenient:</source>
          <target state="translated">&lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 모듈은 산세 프로세스를보다 편리하게하기 위해 다음과 같은 기능을 제공 :</target>
        </trans-unit>
        <trans-unit id="64eb838d62f1db80b3cbc0372ce64caf83a19886" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pipes&quot;&gt;&lt;code&gt;pipes&lt;/code&gt;&lt;/a&gt; module defines a class to abstract the concept of a &lt;em&gt;pipeline&lt;/em&gt; &amp;mdash; a sequence of converters from one file to another.</source>
          <target state="translated">&lt;a href=&quot;#module-pipes&quot;&gt; &lt;code&gt;pipes&lt;/code&gt; &lt;/a&gt; 추상적으로 정의에게의 개념 클래스를 모듈 &lt;em&gt;파이프 라인을&lt;/em&gt; 한 파일에서 다른 파일로 컨버터의 순서를 -.</target>
        </trans-unit>
        <trans-unit id="a1b768d96de059405677d76a8af3854827acb627" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pipes&quot;&gt;&lt;code&gt;pipes&lt;/code&gt;&lt;/a&gt; module defines the following class:</source>
          <target state="translated">&lt;a href=&quot;#module-pipes&quot;&gt; &lt;code&gt;pipes&lt;/code&gt; &lt;/a&gt; 를 정의에게 다음과 같은 클래스를 모듈 :</target>
        </trans-unit>
        <trans-unit id="331e2eb4f9fab99bc8e2b88d891c21f4e7af485c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-poplib&quot;&gt;&lt;code&gt;poplib&lt;/code&gt;&lt;/a&gt; module provides two classes:</source>
          <target state="translated">&lt;a href=&quot;#module-poplib&quot;&gt; &lt;code&gt;poplib&lt;/code&gt; 의&lt;/a&gt; 모듈은 두 개의 클래스를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="277cd96cc96661f93e3472a013fb860bbba2fc2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint&lt;/code&gt;&lt;/a&gt; module also provides several shortcut functions:</source>
          <target state="translated">&lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint&lt;/code&gt; 의&lt;/a&gt; 모듈은 여러 가지 바로 가기 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="d897764f84c5e66fbafbf3d0843fc53af9d0cf09" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint&lt;/code&gt;&lt;/a&gt; module defines one class:</source>
          <target state="translated">&lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint&lt;/code&gt; 의&lt;/a&gt; 모듈은 하나 개의 클래스를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="b8e21659673c9450a31264128faaad6dc4a8112f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pprint&quot;&gt;&lt;code&gt;pprint&lt;/code&gt;&lt;/a&gt; module provides a capability to &amp;ldquo;pretty-print&amp;rdquo; arbitrary Python data structures in a form which can be used as input to the interpreter. If the formatted structures include objects which are not fundamental Python types, the representation may not be loadable. This may be the case if objects such as files, sockets or classes are included, as well as many other objects which are not representable as Python literals.</source>
          <target state="translated">&lt;a href=&quot;#module-pprint&quot;&gt; &lt;code&gt;pprint&lt;/code&gt; 의&lt;/a&gt; 모듈은 인터프리터에 대한 입력으로 사용될 수있는 형태 &quot;프리티 인쇄&quot;파이썬 임의의 데이터 구조에 대한 능력을 제공한다. 형식이 지정된 구조에 기본 Python 유형이 아닌 객체가 포함 된 경우 표현을로드 할 수 없습니다. 파일, 소켓 또는 클래스와 같은 객체뿐만 아니라 파이썬 리터럴로 표현할 수없는 다른 많은 객체가 포함 된 경우가 이에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="02e2c18e85aeab815f7b3884e7ac136f87ea1c89" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pstats&quot;&gt;&lt;code&gt;pstats&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;a href=&quot;#pstats.Stats&quot;&gt;&lt;code&gt;Stats&lt;/code&gt;&lt;/a&gt; class has a variety of methods for manipulating and printing the data saved into a profile results file:</source>
          <target state="translated">&lt;a href=&quot;#module-pstats&quot;&gt; &lt;code&gt;pstats&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;a href=&quot;#pstats.Stats&quot;&gt; &lt;code&gt;Stats&lt;/code&gt; &lt;/a&gt; 클래스는 프로파일 결과 파일에 저장된 데이터를 조작하고 인쇄하기위한 다양한 방법이있다 :</target>
        </trans-unit>
        <trans-unit id="a09452594af9cc2998d0e20d8f6c2e8b7f7a1f37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pty&quot;&gt;&lt;code&gt;pty&lt;/code&gt;&lt;/a&gt; module defines operations for handling the pseudo-terminal concept: starting another process and being able to write to and read from its controlling terminal programmatically.</source>
          <target state="translated">&lt;a href=&quot;#module-pty&quot;&gt; &lt;code&gt;pty&lt;/code&gt; &lt;/a&gt; 다른 프로세스를 시작으로 물품 및 프로그래밍 제어 단자로부터 판독 할 수있는 다음의 의사 단말 개념 처리 모듈 정의 동작.</target>
        </trans-unit>
        <trans-unit id="16051c54e966e34e449d24aeb93463ad01647347" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pty&quot;&gt;&lt;code&gt;pty&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-pty&quot;&gt; &lt;code&gt;pty&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="9026c767b36d7a0109e5a56ec8ab97278ea8b8dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-py_compile&quot;&gt;&lt;code&gt;py_compile&lt;/code&gt;&lt;/a&gt; module provides a function to generate a byte-code file from a source file, and another function used when the module source file is invoked as a script.</source>
          <target state="translated">&lt;a href=&quot;#module-py_compile&quot;&gt; &lt;code&gt;py_compile&lt;/code&gt; 의&lt;/a&gt; 모듈은 소스 파일의 바이트 코드 파일을 생성하는 기능을 제공하며, 모듈의 소스 파일이 스크립트로 호출 될 때 다른 함수가 사용된다.</target>
        </trans-unit>
        <trans-unit id="9d72069fd861edd1c3341b07a968d03ad4695e43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pyclbr&quot;&gt;&lt;code&gt;pyclbr&lt;/code&gt;&lt;/a&gt; module provides limited information about the functions, classes, and methods defined in a Python-coded module. The information is sufficient to implement a module browser. The information is extracted from the Python source code rather than by importing the module, so this module is safe to use with untrusted code. This restriction makes it impossible to use this module with modules not implemented in Python, including all standard and optional extension modules.</source>
          <target state="translated">&lt;a href=&quot;#module-pyclbr&quot;&gt; &lt;code&gt;pyclbr&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬 코딩 모듈에서 정의 된 함수, 클래스, 메소드에 관한 제한된 정보를 제공한다. 이 정보는 모듈 브라우저를 구현하기에 충분합니다. 정보는 모듈을 가져 오는 것이 아니라 Python 소스 코드에서 추출되므로이 모듈은 신뢰할 수없는 코드와 함께 사용하는 것이 안전합니다. 이 제한으로 인해 모든 표준 및 선택적 확장 모듈을 포함하여 Python으로 구현되지 않은 모듈에는이 모듈을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ceef20222c51dc13351c20ead7bd6f0c6894fdf4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-pydoc&quot;&gt;&lt;code&gt;pydoc&lt;/code&gt;&lt;/a&gt; module automatically generates documentation from Python modules. The documentation can be presented as pages of text on the console, served to a Web browser, or saved to HTML files.</source>
          <target state="translated">&lt;a href=&quot;#module-pydoc&quot;&gt; &lt;code&gt;pydoc&lt;/code&gt; 이의&lt;/a&gt; 모듈은 자동으로 파이썬 모듈에서 문서를 생성합니다. 설명서는 콘솔에서 텍스트 페이지로 제공되거나 웹 브라우저에 제공되거나 HTML 파일로 저장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="543ced21f6b4d6a8c71f947acf0e8d0247183255" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; module defines the following classes and exceptions:</source>
          <target state="translated">&lt;a href=&quot;#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 클래스 및 예외를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="9aa5ceed315221356796eb8e3f4afc125b41ac99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-queue&quot;&gt;&lt;code&gt;queue&lt;/code&gt;&lt;/a&gt; module implements multi-producer, multi-consumer queues. It is especially useful in threaded programming when information must be exchanged safely between multiple threads. The &lt;a href=&quot;#queue.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; class in this module implements all the required locking semantics.</source>
          <target state="translated">&lt;a href=&quot;#module-queue&quot;&gt; &lt;code&gt;queue&lt;/code&gt; &lt;/a&gt; 모듈 구현 멀티 프로듀서, 다중 소비자 큐. 정보가 여러 스레드간에 안전하게 교환되어야하는 경우 스레드 프로그래밍에 특히 유용합니다. 이 모듈 의 &lt;a href=&quot;#queue.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 클래스는 필요한 모든 잠금 의미를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ce2e2f809e5adf24db412ccc37a23cf7c3690617" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; module also provides the &lt;a href=&quot;#random.SystemRandom&quot;&gt;&lt;code&gt;SystemRandom&lt;/code&gt;&lt;/a&gt; class which uses the system function &lt;a href=&quot;os#os.urandom&quot;&gt;&lt;code&gt;os.urandom()&lt;/code&gt;&lt;/a&gt; to generate random numbers from sources provided by the operating system.</source>
          <target state="translated">&lt;a href=&quot;#module-random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 모듈도 제공 &lt;a href=&quot;#random.SystemRandom&quot;&gt; &lt;code&gt;SystemRandom&lt;/code&gt; 의&lt;/a&gt; 시스템 기능을 사용하는 클래스 &lt;a href=&quot;os#os.urandom&quot;&gt; &lt;code&gt;os.urandom()&lt;/code&gt; &lt;/a&gt; 운영 체제에 의해 제공되는 소스에서 난수를 생성한다.</target>
        </trans-unit>
        <trans-unit id="660c9edcebc298478ef94c0e97923d795a1d7ea0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module defines a number of functions to facilitate completion and reading/writing of history files from the Python interpreter. This module can be used directly, or via the &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module, which supports completion of Python identifiers at the interactive prompt. Settings made using this module affect the behaviour of both the interpreter&amp;rsquo;s interactive prompt and the prompts offered by the built-in &lt;a href=&quot;functions#input&quot;&gt;&lt;code&gt;input()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; &lt;/a&gt; 모듈은 파이썬 인터프리터에서 히스토리 파일의 작성 / 완료하고 독서를 촉진하는 기능의 수를 정의합니다. 이 모듈은 직접 사용하거나 대화식 프롬프트에서 Python 식별자 완성을 지원 하는 &lt;a href=&quot;rlcompleter#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; &lt;/a&gt; 모듈을 통해 사용할 수 있습니다 . 이 모듈을 사용하여 설정 한 내용은 인터프리터의 대화식 프롬프트와 내장 &lt;a href=&quot;functions#input&quot;&gt; &lt;code&gt;input()&lt;/code&gt; &lt;/a&gt; 함수가 제공하는 프롬프트의 동작에 영향을줍니다 .</target>
        </trans-unit>
        <trans-unit id="8cb8c7fc3ba5633401913c3281336b234b751d20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-reprlib&quot;&gt;&lt;code&gt;reprlib&lt;/code&gt;&lt;/a&gt; module provides a means for producing object representations with limits on the size of the resulting strings. This is used in the Python debugger and may be useful in other contexts as well.</source>
          <target state="translated">&lt;a href=&quot;#module-reprlib&quot;&gt; &lt;code&gt;reprlib&lt;/code&gt; 의&lt;/a&gt; 모듈은 상기 생성 된 캐릭터의 크기에 제한 객체 표현을 생성하기위한 수단을 제공한다. 이것은 파이썬 디버거에서 사용되며 다른 상황에서도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98425ecc51ce0e54b42b84ccf96d36884a9eada" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module defines a completion function suitable for the &lt;a href=&quot;readline#module-readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt; module by completing valid Python identifiers and keywords.</source>
          <target state="translated">&lt;a href=&quot;#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; 의&lt;/a&gt; 모듈이 완성하기에 적합한 함수 정의 &lt;a href=&quot;readline#module-readline&quot;&gt; &lt;code&gt;readline&lt;/code&gt; 에&lt;/a&gt; 유효한 파이썬 식별자와 키워드를 완료하여 모듈.</target>
        </trans-unit>
        <trans-unit id="c0b25d4342ebdd8a2a2b1ce722bd086c190928bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-rlcompleter&quot;&gt;&lt;code&gt;rlcompleter&lt;/code&gt;&lt;/a&gt; module is designed for use with Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;interactive mode&lt;/a&gt;. Unless Python is run with the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; option, the module is automatically imported and configured (see &lt;a href=&quot;site#rlcompleter-config&quot;&gt;Readline configuration&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#module-rlcompleter&quot;&gt; &lt;code&gt;rlcompleter&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬과 함께 사용하도록 설계 &lt;a href=&quot;https://docs.python.org/3.8/tutorial/interpreter.html#tut-interactive&quot;&gt;대화 형 모드&lt;/a&gt; . &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 옵션을 사용하여 Python을 실행하지 않으면 모듈을 자동으로 가져 와서 구성합니다 ( &lt;a href=&quot;site#rlcompleter-config&quot;&gt;Readline 구성&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="b28772e324417b3932525709d74daf62bf935dd5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-runpy&quot;&gt;&lt;code&gt;runpy&lt;/code&gt;&lt;/a&gt; module is used to locate and run Python modules without importing them first. Its main use is to implement the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt;&lt;code&gt;-m&lt;/code&gt;&lt;/a&gt; command line switch that allows scripts to be located using the Python module namespace rather than the filesystem.</source>
          <target state="translated">&lt;a href=&quot;#module-runpy&quot;&gt; &lt;code&gt;runpy&lt;/code&gt; &lt;/a&gt; 모듈은 찾아 먼저 가져 오지 않고 파이썬 모듈을 실행하는 데 사용됩니다. 주요 용도는 파일 시스템이 아닌 Python 모듈 네임 스페이스를 사용하여 스크립트를 찾을 수 있는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt; &lt;code&gt;-m&lt;/code&gt; &lt;/a&gt; 명령 행 스위치 를 구현하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc3ddf57200cdb8fbdd57ac19a46f766137d4790" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-runpy&quot;&gt;&lt;code&gt;runpy&lt;/code&gt;&lt;/a&gt; module provides two functions:</source>
          <target state="translated">&lt;a href=&quot;#module-runpy&quot;&gt; &lt;code&gt;runpy&lt;/code&gt; &lt;/a&gt; 모듈은 두 가지 기능을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="01a602199174a318278c5a270b7c9a02dc1addcd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-sched&quot;&gt;&lt;code&gt;sched&lt;/code&gt;&lt;/a&gt; module defines a class which implements a general purpose event scheduler:</source>
          <target state="translated">&lt;a href=&quot;#module-sched&quot;&gt; &lt;code&gt;sched&lt;/code&gt; &lt;/a&gt; 모듈은 구현 범용 이벤트 스케줄러 클래스를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="4f152c98375827775a1715a1a99a228ef3083649" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module is used for generating cryptographically strong random numbers suitable for managing data such as passwords, account authentication, security tokens, and related secrets.</source>
          <target state="translated">&lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈은 패스워드, 계정 인증, 보안 토큰과 관련된 비밀 정보 등의 데이터를 관리하기위한 적합한 강력한 암호 난수를 생성하는데 사용된다.</target>
        </trans-unit>
        <trans-unit id="cbab347c0a408d23a665e1801ca57f80ec76e7c0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module provides access to the most secure source of randomness that your operating system provides.</source>
          <target state="translated">&lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈은 운영 체제가 제공하는 난수의 가장 안전한 소스에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e4b477222814e65dff6d74820dc3f7363c0a5219" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module provides functions for generating secure tokens, suitable for applications such as password resets, hard-to-guess URLs, and similar.</source>
          <target state="translated">&lt;a href=&quot;#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈은 보안 토큰, 같은 암호 재설정, 어려운 추측 URL 및 유사한 같은 애플리케이션에 적합을 생성하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="135efbd99b4712cb39b1be6b03521151c5bacb0f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt; module does not support &lt;em&gt;concurrent&lt;/em&gt; read/write access to shelved objects. (Multiple simultaneous read accesses are safe.) When a program has a shelf open for writing, no other program should have it open for reading or writing. Unix file locking can be used to solve this, but this differs across Unix versions and requires knowledge about the database implementation used.</source>
          <target state="translated">&lt;a href=&quot;#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; &lt;/a&gt; 모듈은 지원하지 않습니다 &lt;em&gt;동시&lt;/em&gt; 보류 개체에 대한 읽기 / 쓰기 액세스를. (복수의 동시 읽기 액세스는 안전합니다.) 프로그램에 쓰기를위한 선반이 열려 있으면 다른 프로그램이 읽기 나 쓰기를 위해 열지 않아야합니다. Unix 파일 잠금을 사용하여이 문제를 해결할 수 있지만 Unix 버전마다 다르며 사용 된 데이터베이스 구현에 대한 지식이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9faec9689592e9547e90e0ccaf66b0c7f30d0e20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; class provides compatibility with the parsing performed by common Unix shells like &lt;code&gt;bash&lt;/code&gt;, &lt;code&gt;dash&lt;/code&gt;, and &lt;code&gt;sh&lt;/code&gt;. To take advantage of this compatibility, specify the &lt;code&gt;punctuation_chars&lt;/code&gt; argument in the constructor. This defaults to &lt;code&gt;False&lt;/code&gt;, which preserves pre-3.6 behaviour. However, if it is set to &lt;code&gt;True&lt;/code&gt;, then parsing of the characters &lt;code&gt;();&amp;lt;&amp;gt;|&amp;amp;&lt;/code&gt; is changed: any run of these characters is returned as a single token. While this is short of a full parser for shells (which would be out of scope for the standard library, given the multiplicity of shells out there), it does allow you to perform processing of command lines more easily than you could otherwise. To illustrate, you can see the difference in the following snippet:</source>
          <target state="translated">&lt;a href=&quot;#module-shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 클래스는 같은 일반적인 유닉스 쉘에 의해 수행 된 파싱과의 호환성을 제공 &lt;code&gt;bash&lt;/code&gt; 는 , &lt;code&gt;dash&lt;/code&gt; 및 &lt;code&gt;sh&lt;/code&gt; . 이 호환성을 이용하려면 생성자에서 &lt;code&gt;punctuation_chars&lt;/code&gt; 인수를 지정하십시오 . 기본값은 &lt;code&gt;False&lt;/code&gt; 이며 3.6 이전 동작을 유지합니다. 그러나 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 문자 &lt;code&gt;();&amp;lt;&amp;gt;|&amp;amp;&lt;/code&gt; 변경 :이 문자의 모든 실행은 단일 토큰으로 반환됩니다. 이것은 쉘에 대한 전체 파서가 부족하지만 (여러 개의 쉘이있는 경우 표준 라이브러리의 범위를 벗어남) 명령 줄 처리를보다 쉽게 ​​수행 할 수 있습니다. 설명을 위해 다음 스 니펫의 차이점을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="919bf48690255147cc9d4800d709ba206de17a98" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; module defines the following class:</source>
          <target state="translated">&lt;a href=&quot;#module-shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 클래스를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="16369c83843c49a48cc7a498ae5c91f3a35b18c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="8d0e584e13229932fd788a08968e71a778ff56f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-shutil&quot;&gt;&lt;code&gt;shutil&lt;/code&gt;&lt;/a&gt; module offers a number of high-level operations on files and collections of files. In particular, functions are provided which support file copying and removal. For operations on individual files, see also the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-shutil&quot;&gt; &lt;code&gt;shutil&lt;/code&gt; &lt;/a&gt; 모듈 이벤트 파일과 파일의 컬렉션에 대한 높은 수준의 작업의 수. 특히, 파일 복사 및 제거를 지원하는 기능이 제공됩니다. 개별 파일에 대한 작업은 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a5254ed16f29b4b1810c72e9cdb9efbecf62619" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module defines one exception:</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈은 하나 개의 예외를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="55203edded87483a5c2e560ccf2b55021cb05d90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="ee452f2e6f0e5cc42b0bda95278ce8eac8e50a55" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module also provides a way to get the user directories from the command line:</source>
          <target state="translated">&lt;a href=&quot;#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 모듈은 명령 줄에서 사용자 디렉토리를 얻을 수있는 방법을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="afdc95d7cc063c7620c57497d1c06e523c7c721b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-smtplib&quot;&gt;&lt;code&gt;smtplib&lt;/code&gt;&lt;/a&gt; module defines an SMTP client session object that can be used to send mail to any Internet machine with an SMTP or ESMTP listener daemon. For details of SMTP and ESMTP operation, consult &lt;a href=&quot;https://tools.ietf.org/html/rfc821.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 821&lt;/strong&gt;&lt;/a&gt; (Simple Mail Transfer Protocol) and &lt;a href=&quot;https://tools.ietf.org/html/rfc1869.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 1869&lt;/strong&gt;&lt;/a&gt; (SMTP Service Extensions).</source>
          <target state="translated">&lt;a href=&quot;#module-smtplib&quot;&gt; &lt;code&gt;smtplib&lt;/code&gt; 의&lt;/a&gt; 모듈은 SMTP 또는 ESMTP 리스너 데몬 어떤 인터넷 컴퓨터에 메일을 보내는 데 사용할 수있는 SMTP 클라이언트 세션 객체를 정의합니다. SMTP 및 ESMTP 작업에 대한 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc821.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 821&lt;/strong&gt;&lt;/a&gt; (Simple Mail Transfer Protocol) 및 &lt;a href=&quot;https://tools.ietf.org/html/rfc1869.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 1869&lt;/strong&gt;&lt;/a&gt; (SMTP Service Extensions)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5010df5f5785564c1be45eab8f18484d365f10fa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-sndhdr&quot;&gt;&lt;code&gt;sndhdr&lt;/code&gt;&lt;/a&gt; provides utility functions which attempt to determine the type of sound data which is in a file. When these functions are able to determine what type of sound data is stored in a file, they return a &lt;a href=&quot;collections#collections.namedtuple&quot;&gt;&lt;code&gt;namedtuple()&lt;/code&gt;&lt;/a&gt;, containing five attributes: (&lt;code&gt;filetype&lt;/code&gt;, &lt;code&gt;framerate&lt;/code&gt;, &lt;code&gt;nchannels&lt;/code&gt;, &lt;code&gt;nframes&lt;/code&gt;, &lt;code&gt;sampwidth&lt;/code&gt;). The value for &lt;em&gt;type&lt;/em&gt; indicates the data type and will be one of the strings &lt;code&gt;'aifc'&lt;/code&gt;, &lt;code&gt;'aiff'&lt;/code&gt;, &lt;code&gt;'au'&lt;/code&gt;, &lt;code&gt;'hcom'&lt;/code&gt;, &lt;code&gt;'sndr'&lt;/code&gt;, &lt;code&gt;'sndt'&lt;/code&gt;, &lt;code&gt;'voc'&lt;/code&gt;, &lt;code&gt;'wav'&lt;/code&gt;, &lt;code&gt;'8svx'&lt;/code&gt;, &lt;code&gt;'sb'&lt;/code&gt;, &lt;code&gt;'ub'&lt;/code&gt;, or &lt;code&gt;'ul'&lt;/code&gt;. The &lt;em&gt;sampling_rate&lt;/em&gt; will be either the actual value or &lt;code&gt;0&lt;/code&gt; if unknown or difficult to decode. Similarly, &lt;em&gt;channels&lt;/em&gt; will be either the number of channels or &lt;code&gt;0&lt;/code&gt; if it cannot be determined or if the value is difficult to decode. The value for &lt;em&gt;frames&lt;/em&gt; will be either the number of frames or &lt;code&gt;-1&lt;/code&gt;. The last item in the tuple, &lt;em&gt;bits_per_sample&lt;/em&gt;, will either be the sample size in bits or &lt;code&gt;'A'&lt;/code&gt; for A-LAW or &lt;code&gt;'U'&lt;/code&gt; for u-LAW.</source>
          <target state="translated">&lt;a href=&quot;#module-sndhdr&quot;&gt; &lt;code&gt;sndhdr&lt;/code&gt; 는&lt;/a&gt; 파일에 사운드 데이터의 유형을 결정하려고 시도 유틸리티 기능을 제공합니다. 이러한 함수가 파일에 어떤 유형의 사운드 데이터가 저장되는지 확인할 수 있으면 ( &lt;code&gt;filetype&lt;/code&gt; , &lt;code&gt;framerate&lt;/code&gt; , &lt;code&gt;nchannels&lt;/code&gt; , &lt;code&gt;nframes&lt;/code&gt; , &lt;code&gt;sampwidth&lt;/code&gt; ) 라는 다섯 가지 속성이 포함 된 &lt;a href=&quot;collections#collections.namedtuple&quot;&gt; &lt;code&gt;namedtuple()&lt;/code&gt; &lt;/a&gt; 을 반환합니다 . 값 &lt;em&gt;유형이&lt;/em&gt; 데이터 형식을 나타내며, 문자열 중 하나가 될 것이다 &lt;code&gt;'aifc'&lt;/code&gt; , &lt;code&gt;'aiff'&lt;/code&gt; , &lt;code&gt;'au'&lt;/code&gt; , &lt;code&gt;'hcom'&lt;/code&gt; , &lt;code&gt;'sndr'&lt;/code&gt; , &lt;code&gt;'sndt'&lt;/code&gt; , &lt;code&gt;'voc'&lt;/code&gt; , &lt;code&gt;'wav'&lt;/code&gt; &lt;em&gt;&lt;/em&gt;, &lt;code&gt;'8svx'&lt;/code&gt; , &lt;code&gt;'sb'&lt;/code&gt; , &lt;code&gt;'ub'&lt;/code&gt; 또는 &lt;code&gt;'ul'&lt;/code&gt; 입니다. &lt;em&gt;위한 sampling_rate은&lt;/em&gt; 실제 값 또는 어느 것 &lt;code&gt;0&lt;/code&gt; 디코드 알려지지 않거나 어려운 경우. 마찬가지로 &lt;em&gt;채널&lt;/em&gt; 수는 채널 수이거나 확인할 수 없거나 값을 디코딩하기 어려운 경우 &lt;code&gt;0&lt;/code&gt; 입니다. &lt;em&gt;프레임&lt;/em&gt; 값은 &lt;em&gt;프레임&lt;/em&gt; 수 또는 &lt;code&gt;-1&lt;/code&gt; 입니다. 튜플의 마지막 항목 인 &lt;em&gt;bits_per_sample&lt;/em&gt; 은 샘플 크기 (비트)이거나 A-LAW &lt;code&gt;'A'&lt;/code&gt; 경우 'A' 또는 u-LAW &lt;code&gt;'U'&lt;/code&gt; 경우 'U' 입니다.</target>
        </trans-unit>
        <trans-unit id="f2bbd54678e57dc4c92878b357c79bf8e092f46d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; module also offers various network-related services:</source>
          <target state="translated">&lt;a href=&quot;#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 모듈은 다양한 네트워크 관련 서비스를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="8ba72662e12ca1e862a21df7b945467f8e047ff6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-socketserver&quot;&gt;&lt;code&gt;socketserver&lt;/code&gt;&lt;/a&gt; module simplifies the task of writing network servers.</source>
          <target state="translated">&lt;a href=&quot;#module-socketserver&quot;&gt; &lt;code&gt;socketserver&lt;/code&gt; 의&lt;/a&gt; 모듈은 네트워크 서버를 작성하는 작업을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="23972564f34650ae2a05c05e7de5ad20291b61f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module has two default adapters for Python&amp;rsquo;s built-in &lt;a href=&quot;datetime#datetime.date&quot;&gt;&lt;code&gt;datetime.date&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; types. Now let&amp;rsquo;s suppose we want to store &lt;a href=&quot;datetime#datetime.datetime&quot;&gt;&lt;code&gt;datetime.datetime&lt;/code&gt;&lt;/a&gt; objects not in ISO representation, but as a Unix timestamp.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 를의&lt;/a&gt; 모듈은 파이썬의 두 가지 기본 어댑터가 내장 &lt;a href=&quot;datetime#datetime.date&quot;&gt; &lt;code&gt;datetime.date&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 유형. 이제 &lt;a href=&quot;datetime#datetime.datetime&quot;&gt; &lt;code&gt;datetime.datetime&lt;/code&gt; &lt;/a&gt; 객체를 ISO 표현이 아닌 Unix 타임 스탬프 로 저장한다고 가정 해 봅시다 .</target>
        </trans-unit>
        <trans-unit id="00fac285f3151c95ef30230b0c141c3afd186802" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module internally uses a statement cache to avoid SQL parsing overhead. If you want to explicitly set the number of statements that are cached for the connection, you can set the &lt;em&gt;cached_statements&lt;/em&gt; parameter. The currently implemented default is to cache 100 statements.</source>
          <target state="translated">&lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; 를의&lt;/a&gt; 모듈은 내부적으로 SQL 오버 헤드 분석 피하기 위해 명령문 캐시를 사용합니다. 연결에 대해 캐시되는 명령문 수를 명시 적으로 설정하려는 경우 &lt;em&gt;cached_statements&lt;/em&gt; 매개 변수를 설정할 수 있습니다 . 현재 구현 된 기본값은 100 개의 명령문을 캐시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4d2ce586ec3a270007b05b96357f828bc872595b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module defines constants and functions for interpreting the results of &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;os#os.fstat&quot;&gt;&lt;code&gt;os.fstat()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#os.lstat&quot;&gt;&lt;code&gt;os.lstat()&lt;/code&gt;&lt;/a&gt; (if they exist). For complete details about the &lt;code&gt;stat()&lt;/code&gt;, &lt;code&gt;fstat()&lt;/code&gt; and &lt;code&gt;lstat()&lt;/code&gt; calls, consult the documentation for your system.</source>
          <target state="translated">&lt;a href=&quot;#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 결과 해석 모듈 정의 상수 및 함수 &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;os#os.fstat&quot;&gt; &lt;code&gt;os.fstat()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os#os.lstat&quot;&gt; &lt;code&gt;os.lstat()&lt;/code&gt; &lt;/a&gt; (있는 경우). &lt;code&gt;stat()&lt;/code&gt; , &lt;code&gt;fstat()&lt;/code&gt; 및 &lt;code&gt;lstat()&lt;/code&gt; 호출 에 대한 자세한 내용은 시스템 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="687e8631f9c61961d2c9931b2fd726158c32d7c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-stat&quot;&gt;&lt;code&gt;stat&lt;/code&gt;&lt;/a&gt; module defines the following functions to test for specific file types:</source>
          <target state="translated">&lt;a href=&quot;#module-stat&quot;&gt; &lt;code&gt;stat&lt;/code&gt; &lt;/a&gt; 모듈은 특정 파일 형식에 대한 테스트는 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="480a84318ee703dc5a9b0be69b50b6ad6fc66170" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; module provides a &lt;a href=&quot;#string.Template&quot;&gt;&lt;code&gt;Template&lt;/code&gt;&lt;/a&gt; class that implements these rules. The methods of &lt;a href=&quot;#string.Template&quot;&gt;&lt;code&gt;Template&lt;/code&gt;&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 모듈은 제공하는 &lt;a href=&quot;#string.Template&quot;&gt; &lt;code&gt;Template&lt;/code&gt; &lt;/a&gt; 클래스 그 구현이 규칙을. &lt;a href=&quot;#string.Template&quot;&gt; &lt;code&gt;Template&lt;/code&gt; &lt;/a&gt; 의 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c46cb6742876c99877d7145c9406a69e6add43d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module also defines the following type:</source>
          <target state="translated">&lt;a href=&quot;#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 유형을 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="d3ce39cace6e0b8f0545dfae131c2f6375ca35c1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes. This module intends to replace several older modules and functions:</source>
          <target state="translated">&lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈은, 새로운 프로세스를 생성 입력 / 출력 / 오류 파이프에 연결 및 반환 코드를 획득 할 수있다. 이 모듈은 몇 가지 이전 모듈 및 기능을 대체하려고합니다.</target>
        </trans-unit>
        <trans-unit id="28f5c7e6366c580d5585fae232c046c902162567" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module exposes the following constants.</source>
          <target state="translated">&lt;a href=&quot;#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈은 다음의 상수를 공개한다.</target>
        </trans-unit>
        <trans-unit id="56d9cc0d0b5899e8707e8417bfe835a52f57f24d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-sysconfig&quot;&gt;&lt;code&gt;sysconfig&lt;/code&gt;&lt;/a&gt; module provides access to Python&amp;rsquo;s configuration information like the list of installation paths and the configuration variables relevant for the current platform.</source>
          <target state="translated">&lt;a href=&quot;#module-sysconfig&quot;&gt; &lt;code&gt;sysconfig&lt;/code&gt; &lt;/a&gt; 모듈은 설치 경로와 현재의 플랫폼에 관련된 구성 변수의 목록과 같은 파이썬의 구성 정보에 대한 액세스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6429efa2bca86eb7f85b79e9818a9493d6e675dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module defines the following exceptions:</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 예외를 정의한다 :</target>
        </trans-unit>
        <trans-unit id="60e2b8de9d60bf56e732bcf798aa0e16e9a4fe20" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module makes it possible to read and write tar archives, including those using gzip, bz2 and lzma compression. Use the &lt;a href=&quot;zipfile#module-zipfile&quot;&gt;&lt;code&gt;zipfile&lt;/code&gt;&lt;/a&gt; module to read or write &lt;code&gt;.zip&lt;/code&gt; files, or the higher-level functions in &lt;a href=&quot;shutil#archiving-operations&quot;&gt;shutil&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈은 가능한 판독 GZIP, BZ2 및 LZMA 압축을 사용 포함한 기록 타르 아카이브 할 수있다. &lt;a href=&quot;zipfile#module-zipfile&quot;&gt; &lt;code&gt;zipfile&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 &lt;code&gt;.zip&lt;/code&gt; 파일 또는 &lt;a href=&quot;shutil#archiving-operations&quot;&gt;shutil&lt;/a&gt; 의 상위 레벨 기능 을 읽거나 쓰십시오 .</target>
        </trans-unit>
        <trans-unit id="78fd81d6196e9460d83369490a0e3a8bada8d1a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; module provides a simple command-line interface to interact with tar archives.</source>
          <target state="translated">&lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 모듈은 타르 아카이브와 상호 작용하는 간단한 명령 줄 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b8918dc3dbfcb58a46c0efa12e0d908925c6d58c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-telnetlib&quot;&gt;&lt;code&gt;telnetlib&lt;/code&gt;&lt;/a&gt; module provides a &lt;a href=&quot;#telnetlib.Telnet&quot;&gt;&lt;code&gt;Telnet&lt;/code&gt;&lt;/a&gt; class that implements the Telnet protocol. See &lt;a href=&quot;https://tools.ietf.org/html/rfc854.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 854&lt;/strong&gt;&lt;/a&gt; for details about the protocol. In addition, it provides symbolic constants for the protocol characters (see below), and for the telnet options. The symbolic names of the telnet options follow the definitions in &lt;code&gt;arpa/telnet.h&lt;/code&gt;, with the leading &lt;code&gt;TELOPT_&lt;/code&gt; removed. For symbolic names of options which are traditionally not included in &lt;code&gt;arpa/telnet.h&lt;/code&gt;, see the module source itself.</source>
          <target state="translated">&lt;a href=&quot;#module-telnetlib&quot;&gt; &lt;code&gt;telnetlib&lt;/code&gt; 의&lt;/a&gt; 모듈은 제공 &lt;a href=&quot;#telnetlib.Telnet&quot;&gt; &lt;code&gt;Telnet&lt;/code&gt; &lt;/a&gt; 클래스를 구현하는 텔넷 프로토콜을. 프로토콜에 대한 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc854.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 854&lt;/strong&gt;&lt;/a&gt; 를 참조하십시오 . 또한 프로토콜 문자 (아래 참조) 및 텔넷 옵션에 대한 기호 상수를 제공합니다. 텔넷 옵션의 기호 이름은 주요 &lt;code&gt;TELOPT_&lt;/code&gt; 가 제거 된 &lt;code&gt;arpa/telnet.h&lt;/code&gt; 의 정의를 따릅니다 . &lt;code&gt;arpa/telnet.h&lt;/code&gt; 에 일반적으로 포함되지 않은 옵션의 기호 이름은 모듈 소스 자체를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a5e7efa00ab2f0fae31f9c832f0e22eaba4bbf97" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; package can be run as a script to drive Python&amp;rsquo;s regression test suite, thanks to the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt;&lt;code&gt;-m&lt;/code&gt;&lt;/a&gt; option: &lt;strong&gt;python -m test&lt;/strong&gt;. Under the hood, it uses &lt;code&gt;test.regrtest&lt;/code&gt;; the call &lt;strong&gt;python -m test.regrtest&lt;/strong&gt; used in previous Python versions still works. Running the script by itself automatically starts running all regression tests in the &lt;a href=&quot;#module-test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; package. It does this by finding all modules in the package whose name starts with &lt;code&gt;test_&lt;/code&gt;, importing them, and executing the function &lt;code&gt;test_main()&lt;/code&gt; if present or loading the tests via unittest.TestLoader.loadTestsFromModule if &lt;code&gt;test_main&lt;/code&gt; does not exist. The names of tests to execute may also be passed to the script. Specifying a single regression test (&lt;strong&gt;python -m test test_spam&lt;/strong&gt;) will minimize output and only print whether the test passed or failed.</source>
          <target state="translated">&lt;a href=&quot;#module-test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 패키지는, 파이썬의 회귀 테스트 스위트를 구동하는 스크립트로 덕분에 실행할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt; &lt;code&gt;-m&lt;/code&gt; &lt;/a&gt; : 옵션 &lt;strong&gt;파이썬 -m 테스트를&lt;/strong&gt; . 후드 아래에서 &lt;code&gt;test.regrtest&lt;/code&gt; 를 사용합니다 . 이전 파이썬 버전에서 사용 된 &lt;strong&gt;python -m test.regrtest&lt;/strong&gt; 호출은 여전히 작동합니다. 스크립트 자체를 실행하면 &lt;a href=&quot;#module-test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 패키지 에서 모든 회귀 테스트가 자동으로 실행 됩니다. 패키지에서 이름이 &lt;code&gt;test_&lt;/code&gt; 로 시작하는 모든 모듈을 찾아서 가져오고 가져 오는 경우 &lt;code&gt;test_main()&lt;/code&gt; 함수를 실행 하거나 &lt;code&gt;test_main&lt;/code&gt; 인 경우 unittest.TestLoader.loadTestsFromModule을 통해 테스트를로드하여이를 수행합니다 .존재하지 않는다. 실행할 테스트 이름도 스크립트로 전달 될 수 있습니다. 단일 회귀 테스트 ( &lt;strong&gt;python -m test test_spam&lt;/strong&gt; )를 지정하면 출력이 최소화되고 테스트 통과 또는 실패 여부 만 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5d4304c9ba049d42957cc58ededa17769ed778" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; package contains all regression tests for Python as well as the modules &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;test.regrtest&lt;/code&gt;. &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; is used to enhance your tests while &lt;code&gt;test.regrtest&lt;/code&gt; drives the testing suite.</source>
          <target state="translated">&lt;a href=&quot;#module-test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 패키지는 파이썬에 대한 모든 회귀 테스트뿐만 아니라 모듈이 포함되어 &lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;test.regrtest&lt;/code&gt; 을 . &lt;code&gt;test.regrtest&lt;/code&gt; 가 테스트 스위트를 구동하는 동안 &lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; &lt;/a&gt; 는 테스트를 향상시키는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9117d73cefcf380ffbe79a1cfa00d1882f1ed60a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; package is meant for internal use by Python only. It is documented for the benefit of the core developers of Python. Any use of this package outside of Python&amp;rsquo;s standard library is discouraged as code mentioned here can change or be removed without notice between releases of Python.</source>
          <target state="translated">&lt;a href=&quot;#module-test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 패키지 만 파이썬으로 내부 사용을위한 것입니다. 파이썬 핵심 개발자의 이익을 위해 문서화되었습니다. 여기에 언급 된 코드가 Python 릴리스간에 통지없이 변경되거나 제거 될 수 있으므로 Python 표준 라이브러리 외부에서이 패키지를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0244d10625882318f2449d3c4d63b55e83bf132e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; module defines the following classes:</source>
          <target state="translated">&lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; 의&lt;/a&gt; 모듈은 다음과 같은 클래스를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="cd92d858e88b1051a2b11b06c524823853936238" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; module defines the following constants:</source>
          <target state="translated">&lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; 의&lt;/a&gt; 모듈은 다음의 상수를 정의합니다 :</target>
        </trans-unit>
        <trans-unit id="19a622513d587ca5bec49ac4dcc1a72fc02b52ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; 의&lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="a6e75d382748152f3eb0456dcb32bf8ada4db960" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test.support&quot;&gt;&lt;code&gt;test.support&lt;/code&gt;&lt;/a&gt; module provides support for Python&amp;rsquo;s regression test suite.</source>
          <target state="translated">&lt;a href=&quot;#module-test.support&quot;&gt; &lt;code&gt;test.support&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬의 회귀 테스트 스위트에 대한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="aaea65c10dc101120e4cd4f0a1b3cf522268725f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-test.support.script_helper&quot;&gt;&lt;code&gt;test.support.script_helper&lt;/code&gt;&lt;/a&gt; module provides support for Python&amp;rsquo;s script execution tests.</source>
          <target state="translated">&lt;a href=&quot;#module-test.support.script_helper&quot;&gt; &lt;code&gt;test.support.script_helper&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬의 스크립트 실행 테스트에 대한 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f2b9de08e53424b2e1f33e222c50a8ca31672d7e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-textwrap&quot;&gt;&lt;code&gt;textwrap&lt;/code&gt;&lt;/a&gt; module provides some convenience functions, as well as &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt;, the class that does all the work. If you&amp;rsquo;re just wrapping or filling one or two text strings, the convenience functions should be good enough; otherwise, you should use an instance of &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; for efficiency.</source>
          <target state="translated">&lt;a href=&quot;#module-textwrap&quot;&gt; &lt;code&gt;textwrap&lt;/code&gt; 의&lt;/a&gt; 모듈은 일부 편의 기능뿐만 아니라 제공 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; , 모든 작업을 수행하는 클래스를. 하나 또는 두 개의 텍스트 문자열을 감싸거나 채우는 경우 편의 기능이 충분해야합니다. 그렇지 않으면 효율성을 위해 &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="69521f021f4fce9480016bdd177094adebc1e7d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; package (&amp;ldquo;Tk interface&amp;rdquo;) is the standard Python interface to the Tk GUI toolkit. Both Tk and &lt;a href=&quot;#module-tkinter&quot;&gt;&lt;code&gt;tkinter&lt;/code&gt;&lt;/a&gt; are available on most Unix platforms, as well as on Windows systems. (Tk itself is not part of Python; it is maintained at ActiveState.)</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 패키지 ( &quot;Tk의 인터페이스&quot;)는 Tk의 GUI 툴킷에 표준 파이썬 인터페이스입니다. Tk 및 &lt;a href=&quot;#module-tkinter&quot;&gt; &lt;code&gt;tkinter&lt;/code&gt; &lt;/a&gt; 는 Windows 시스템뿐만 아니라 대부분의 Unix 플랫폼에서 사용할 수 있습니다. (Tk 자체는 Python의 일부가 아니며 ActiveState에서 유지 관리됩니다.)</target>
        </trans-unit>
        <trans-unit id="0d0d11947e38a35eedb8da5696601eb21877c07b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tkinter.scrolledtext&quot;&gt;&lt;code&gt;tkinter.scrolledtext&lt;/code&gt;&lt;/a&gt; module provides a class of the same name which implements a basic text widget which has a vertical scroll bar configured to do the &amp;ldquo;right thing.&amp;rdquo; Using the &lt;code&gt;ScrolledText&lt;/code&gt; class is a lot easier than setting up a text widget and scroll bar directly. The constructor is the same as that of the &lt;code&gt;tkinter.Text&lt;/code&gt; class.</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.scrolledtext&quot;&gt; &lt;code&gt;tkinter.scrolledtext&lt;/code&gt; 의&lt;/a&gt; 모듈은 어떻게 구성 세로 스크롤 막대가있는 기본 텍스트 위젯 구현하는 같은 이름의 클래스를 제공한다 &quot;옳은 일을.&quot; &lt;code&gt;ScrolledText&lt;/code&gt; 클래스를 사용하면 텍스트 위젯과 스크롤 막대를 직접 설정하는 것보다 훨씬 쉽습니다. 생성자는 &lt;code&gt;tkinter.Text&lt;/code&gt; 클래스 의 생성자와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="087dc6d87474f5743996f1e0d70ffbb201f64cca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; (Tk Interface Extension) module provides an additional rich set of widgets. Although the standard Tk library has many useful widgets, they are far from complete. The &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; library provides most of the commonly needed widgets that are missing from standard Tk: &lt;a href=&quot;#tkinter.tix.HList&quot;&gt;&lt;code&gt;HList&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.tix.ComboBox&quot;&gt;&lt;code&gt;ComboBox&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.tix.Control&quot;&gt;&lt;code&gt;Control&lt;/code&gt;&lt;/a&gt; (a.k.a. SpinBox) and an assortment of scrollable widgets. &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; also includes many more widgets that are generally useful in a wide range of applications: &lt;a href=&quot;#tkinter.tix.NoteBook&quot;&gt;&lt;code&gt;NoteBook&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.tix.FileEntry&quot;&gt;&lt;code&gt;FileEntry&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.tix.PanedWindow&quot;&gt;&lt;code&gt;PanedWindow&lt;/code&gt;&lt;/a&gt;, etc; there are more than 40 of them.</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; 은&lt;/a&gt; (TK 인터페이스 확장) 모듈 위젯의 추가적인 풍부한 세트를 제공한다. 표준 Tk 라이브러리에는 유용한 위젯이 많이 있지만 완전하지는 않습니다. &lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; 의&lt;/a&gt; : 라이브러리는 표준의 Tk에서 누락 일반적으로 필요한 위젯의 대부분을 제공 &lt;a href=&quot;#tkinter.tix.HList&quot;&gt; &lt;code&gt;HList&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.tix.ComboBox&quot;&gt; &lt;code&gt;ComboBox&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.tix.Control&quot;&gt; &lt;code&gt;Control&lt;/code&gt; &lt;/a&gt; (SpinBox 일명) 및 스크롤 위젯의 구색을. &lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; &lt;/a&gt; 에는 또한 광범위한 애플리케이션에서 일반적으로 유용한 더 많은 위젯이 포함되어 있습니다 : &lt;a href=&quot;#tkinter.tix.NoteBook&quot;&gt; &lt;code&gt;NoteBook&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.tix.FileEntry&quot;&gt; &lt;code&gt;FileEntry&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.tix.PanedWindow&quot;&gt; &lt;code&gt;PanedWindow&lt;/code&gt; &lt;/a&gt; 등; 40 개 이상이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e594d147bd9eee8773327872d17cd09f5e75e165" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tkinter.tix&quot;&gt;&lt;code&gt;tkinter.tix&lt;/code&gt;&lt;/a&gt; module adds:</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.tix&quot;&gt; &lt;code&gt;tkinter.tix&lt;/code&gt; 의&lt;/a&gt; 모듈 추가 :</target>
        </trans-unit>
        <trans-unit id="43cf6af180abfd7efccd55d54b05a62d2aaf6372" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tkinter.ttk&quot;&gt;&lt;code&gt;tkinter.ttk&lt;/code&gt;&lt;/a&gt; module provides access to the Tk themed widget set, introduced in Tk 8.5. If Python has not been compiled against Tk 8.5, this module can still be accessed if &lt;em&gt;Tile&lt;/em&gt; has been installed. The former method using Tk 8.5 provides additional benefits including anti-aliased font rendering under X11 and window transparency (requiring a composition window manager on X11).</source>
          <target state="translated">&lt;a href=&quot;#module-tkinter.ttk&quot;&gt; &lt;code&gt;tkinter.ttk&lt;/code&gt; 의&lt;/a&gt; 모듈은 TK에 8.5에 소개 된 Tk의 테마 위젯 세트에 대한 액세스를 제공합니다. Python이 Tk 8.5에 대해 컴파일되지 않은 경우 &lt;em&gt;Tile&lt;/em&gt; 이 설치된 경우 &lt;em&gt;에도이&lt;/em&gt; 모듈에 액세스 할 수 있습니다 . Tk 8.5를 사용하는 전자의 방법은 X11에서 앤티 앨리어싱 된 글꼴 렌더링 및 창 투명도 (X11에서 컴포지션 창 관리자 필요)를 포함한 추가 이점을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="010d5d784a9d3ed823f679c97185fddd96fad511" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tokenize&quot;&gt;&lt;code&gt;tokenize&lt;/code&gt;&lt;/a&gt; module can be executed as a script from the command line. It is as simple as:</source>
          <target state="translated">&lt;a href=&quot;#module-tokenize&quot;&gt; &lt;code&gt;tokenize&lt;/code&gt; &lt;/a&gt; 모듈은 명령 줄에서 스크립트로 실행할 수 있습니다. 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e1bc5e1c9efb3cd19a492a1a8e05de0147910024" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tokenize&quot;&gt;&lt;code&gt;tokenize&lt;/code&gt;&lt;/a&gt; module provides a lexical scanner for Python source code, implemented in Python. The scanner in this module returns comments as tokens as well, making it useful for implementing &amp;ldquo;pretty-printers,&amp;rdquo; including colorizers for on-screen displays.</source>
          <target state="translated">&lt;a href=&quot;#module-tokenize&quot;&gt; &lt;code&gt;tokenize&lt;/code&gt; &lt;/a&gt; 모듈은 파이썬으로 구현 파이썬 소스 코드에 대한 어휘 스캐너를 제공합니다. 이 모듈의 스캐너는 주석을 토큰으로도 반환하므로 화면 디스플레이 용 컬러 ​​라이저를 포함하여 &quot;예쁜 프린터&quot;를 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5f511da6744b577f0c50909f08baf3d8662be4dd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt; module allows you to trace program execution, generate annotated statement coverage listings, print caller/callee relationships and list functions executed during a program run. It can be used in another program or from the command line.</source>
          <target state="translated">&lt;a href=&quot;#module-trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; 모듈은 프로그램 실행 중에 실행 프로그램 실행, 주석 생성 문 범위 목록, 인쇄 발신자 / 수신자 관계 및 목록 기능을 추적 할 수 있습니다. 다른 프로그램이나 명령 줄에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d5dc02a91ffc0ddc0a0cd2fae8acbe61a69b08c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt; module can be invoked from the command line. It can be as simple as</source>
          <target state="translated">&lt;a href=&quot;#module-trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; 모듈은 명령 줄에서 호출 할 수 있습니다. 그것은 간단 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="db5ac03755b4e60a53a29f18e14817336774543a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module must be tracing memory allocations to get the limit, otherwise an exception is raised.</source>
          <target state="translated">&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; 의&lt;/a&gt; 모듈 그렇지 않으면 예외가 발생, 한계를 얻기 위해 메모리 할당을 추적해야합니다.</target>
        </trans-unit>
        <trans-unit id="fde229bd690b9e68c2b1e464dbe341752078b66c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tracemalloc&quot;&gt;&lt;code&gt;tracemalloc&lt;/code&gt;&lt;/a&gt; module must be tracing memory allocations to take a snapshot, see the &lt;a href=&quot;#tracemalloc.start&quot;&gt;&lt;code&gt;start()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#module-tracemalloc&quot;&gt; &lt;code&gt;tracemalloc&lt;/code&gt; 의&lt;/a&gt; 모듈은 스냅 샷을 메모리 할당을 추적 참조해야 &lt;a href=&quot;#tracemalloc.start&quot;&gt; &lt;code&gt;start()&lt;/code&gt; &lt;/a&gt; 기능을.</target>
        </trans-unit>
        <trans-unit id="59b15a41895ec7eac05a90753c6997b7add40ffd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tty&quot;&gt;&lt;code&gt;tty&lt;/code&gt;&lt;/a&gt; module defines functions for putting the tty into cbreak and raw modes.</source>
          <target state="translated">&lt;a href=&quot;#module-tty&quot;&gt; &lt;code&gt;tty&lt;/code&gt; &lt;/a&gt; 모듈은 CBREAK 원시 모드로 청각 장애를 퍼 팅에 대 한 함수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="07eaa4568ecb34fbafd3088112219dd6ba46369c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-tty&quot;&gt;&lt;code&gt;tty&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-tty&quot;&gt; &lt;code&gt;tty&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="2b67f134175f6566de6a32665323b518f06e0cd1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; module is an extended reimplementation of the same-named module from the Python standard distribution up to version Python 2.5.</source>
          <target state="translated">&lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 모듈 버전 파이썬 2.5 파이썬 표준 분포 업에서 동일한 이름의 모듈의 연장 다시 구현된다.</target>
        </trans-unit>
        <trans-unit id="6a3f21e1d1c58048ad940fbc6563e7b4bf6523a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-turtledemo&quot;&gt;&lt;code&gt;turtledemo&lt;/code&gt;&lt;/a&gt; package directory contains:</source>
          <target state="translated">&lt;a href=&quot;#module-turtledemo&quot;&gt; &lt;code&gt;turtledemo&lt;/code&gt; 의&lt;/a&gt; 패키지 디렉토리에는 다음이 포함됩니다</target>
        </trans-unit>
        <trans-unit id="fc0bfc0c5dda5c5c718c2d5d6afe3366e858d76a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-turtledemo&quot;&gt;&lt;code&gt;turtledemo&lt;/code&gt;&lt;/a&gt; package includes a set of demo scripts. These scripts can be run and viewed using the supplied demo viewer as follows:</source>
          <target state="translated">&lt;a href=&quot;#module-turtledemo&quot;&gt; &lt;code&gt;turtledemo&lt;/code&gt; 의&lt;/a&gt; 패키지는 데모 스크립트의 집합이 포함되어 있습니다. 이 스크립트는 다음과 같이 제공된 데모 뷰어를 사용하여 실행하고 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c274f74c69f3f523773db89028d39ebfb3c2a4e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module provides a rich set of tools for constructing and running tests. This section demonstrates that a small subset of the tools suffice to meet the needs of most users.</source>
          <target state="translated">&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈을 구성하고 테스트를 실행하기위한 다양한 도구를 제공합니다. 이 섹션에서는 도구의 작은 하위 집합이 대부분의 사용자 요구를 충족시키기에 충분하다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="550ed8a2e0d5ef66b50281dc4ed0a2cf8c5e67a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; unit testing framework was originally inspired by JUnit and has a similar flavor as major unit testing frameworks in other languages. It supports test automation, sharing of setup and shutdown code for tests, aggregation of tests into collections, and independence of the tests from the reporting framework.</source>
          <target state="translated">&lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 단위 테스트 프레임 워크는 원래의 JUnit에서 영감을 다른 언어의 주요 단위 테스트 프레임 워크와 유사한 맛을 가지고 있었다. 테스트 자동화, 테스트를위한 설정 및 종료 코드 공유, 테스트를 컬렉션으로 집계 및보고 프레임 워크의 테스트 독립성을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="1434ea41d7d542121a8217544637f1bfba7ae044" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-urllib.error&quot;&gt;&lt;code&gt;urllib.error&lt;/code&gt;&lt;/a&gt; module defines the exception classes for exceptions raised by &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt;. The base exception class is &lt;a href=&quot;#urllib.error.URLError&quot;&gt;&lt;code&gt;URLError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.error&quot;&gt; &lt;code&gt;urllib.error&lt;/code&gt; 의&lt;/a&gt; 모듈에 의해 제기 된 예외에 대한 예외 클래스를 정의 &lt;a href=&quot;urllib.request#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; 을&lt;/a&gt; . 기본 예외 클래스는 &lt;a href=&quot;#urllib.error.URLError&quot;&gt; &lt;code&gt;URLError&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2ee64e18ba6d9ec07ba811ca447c01b9534d6ae7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-urllib.parse&quot;&gt;&lt;code&gt;urllib.parse&lt;/code&gt;&lt;/a&gt; module defines functions that fall into two broad categories: URL parsing and URL quoting. These are covered in detail in the following sections.</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.parse&quot;&gt; &lt;code&gt;urllib.parse&lt;/code&gt; &lt;/a&gt; 두 가지 범주로 구분 모듈을 정의 기능 : URL 구문 분석 및 URL은 인용. 이에 대해서는 다음 섹션에서 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="91f4d970ce1b3aeb81168e2ce9b4e4b29a3feba8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt; module defines functions and classes which help in opening URLs (mostly HTTP) in a complex world &amp;mdash; basic and digest authentication, redirections, cookies and more.</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; &lt;/a&gt; 이상의 인증, 리디렉션, 쿠키를 소화하고 기본 및 - 모듈은 복잡한 세상에서 여는 URL을 (주로 HTTP)의 도움 함수와 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="4427049224ca80d28bb6cd1f4ba8aa3eac642a9a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="158d83543b097cd1a684ccd480ac339d1df24307" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-urllib.response&quot;&gt;&lt;code&gt;urllib.response&lt;/code&gt;&lt;/a&gt; module defines functions and classes which define a minimal file like interface, including &lt;code&gt;read()&lt;/code&gt; and &lt;code&gt;readline()&lt;/code&gt;. The typical response object is an addinfourl instance, which defines an &lt;code&gt;info()&lt;/code&gt; method and that returns headers and a &lt;code&gt;geturl()&lt;/code&gt; method that returns the url. Functions defined by this module are used internally by the &lt;a href=&quot;#module-urllib.request&quot;&gt;&lt;code&gt;urllib.request&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;#module-urllib.response&quot;&gt; &lt;code&gt;urllib.response&lt;/code&gt; 의&lt;/a&gt; 모듈을 포함 인터페이스처럼 최소 파일을 정의하는 함수와 클래스 정의 &lt;code&gt;read()&lt;/code&gt; 과 &lt;code&gt;readline()&lt;/code&gt; . 일반적인 응답 객체는 addinfourl 인스턴스로, &lt;code&gt;info()&lt;/code&gt; 메서드 를 정의하고 헤더를 반환하고 &lt;code&gt;geturl()&lt;/code&gt; 메서드는 URL을 반환합니다. 이 모듈에 의해 정의 된 기능은 &lt;a href=&quot;#module-urllib.request&quot;&gt; &lt;code&gt;urllib.request&lt;/code&gt; &lt;/a&gt; 모듈에 의해 내부적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="d60cd16cabda39f1e5a654be3225e45721ab2b76" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-uu&quot;&gt;&lt;code&gt;uu&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-uu&quot;&gt; &lt;code&gt;uu&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="4c618ead0516bb686d9dd02e4c383114c17e6fe6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-uuid&quot;&gt;&lt;code&gt;uuid&lt;/code&gt;&lt;/a&gt; module defines the following constants for the possible values of the &lt;code&gt;variant&lt;/code&gt; attribute:</source>
          <target state="translated">&lt;a href=&quot;#module-uuid&quot;&gt; &lt;code&gt;uuid&lt;/code&gt; &lt;/a&gt; 모듈의 가능한 값은 다음 상수 정의 &lt;code&gt;variant&lt;/code&gt; 특성 :</target>
        </trans-unit>
        <trans-unit id="dfa0704de3ca100bba5d25f4eff9d322a057cc7f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-uuid&quot;&gt;&lt;code&gt;uuid&lt;/code&gt;&lt;/a&gt; module defines the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-uuid&quot;&gt; &lt;code&gt;uuid&lt;/code&gt; &lt;/a&gt; 모듈은 다음과 같은 기능을 정의한다 :</target>
        </trans-unit>
        <trans-unit id="e7c7759cdf4ea6781379bac932cc154b598d9c03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-uuid&quot;&gt;&lt;code&gt;uuid&lt;/code&gt;&lt;/a&gt; module defines the following namespace identifiers for use with &lt;a href=&quot;#uuid.uuid3&quot;&gt;&lt;code&gt;uuid3()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#uuid.uuid5&quot;&gt;&lt;code&gt;uuid5()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-uuid&quot;&gt; &lt;code&gt;uuid&lt;/code&gt; &lt;/a&gt; 모듈에 사용하기 위해 다음 네임 스페이스 식별자를 정의 &lt;a href=&quot;#uuid.uuid3&quot;&gt; &lt;code&gt;uuid3()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#uuid.uuid5&quot;&gt; &lt;code&gt;uuid5()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6841f915e5c6db3b149cd5e09f2d363c06b1cb5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-venv&quot;&gt;&lt;code&gt;venv&lt;/code&gt;&lt;/a&gt; module provides support for creating lightweight &amp;ldquo;virtual environments&amp;rdquo; with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (which matches the version of the binary that was used to create this environment) and can have its own independent set of installed Python packages in its site directories.</source>
          <target state="translated">&lt;a href=&quot;#module-venv&quot;&gt; &lt;code&gt;venv&lt;/code&gt; 의&lt;/a&gt; 모듈은 선택적으로 시스템 사이트 디렉터리에서 격리 자신의 사이트 디렉터리와 경량의 &quot;가상 환경&quot;을 만들기위한 지원을 제공합니다. 각 가상 환경에는 자체 Python 이진 파일 (이 환경을 만드는 데 사용 된 이진 버전과 일치)이 있으며 사이트 디렉토리에 독립적으로 설치된 Python 패키지 세트를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe6bcf346326e5482e10284d7d56ca5e5249e4f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt; module defines the following function and exception:</source>
          <target state="translated">&lt;a href=&quot;#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; &lt;/a&gt; 모듈은 다음 기능, 예외를 정의</target>
        </trans-unit>
        <trans-unit id="db1287ed4466a744ea41400d0c9b31503ca62f25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt; module provides a convenient interface to the WAV sound format. It does not support compression/decompression, but it does support mono/stereo.</source>
          <target state="translated">&lt;a href=&quot;#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; &lt;/a&gt; 모듈은 WAV 사운드 형식으로 편리한 인터페이스를 제공합니다. 압축 / 압축 해제는 지원하지 않지만 모노 / 스테레오는 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ce0a6c0a72b64cc9c303875352bd99f1f28d877c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-weakref&quot;&gt;&lt;code&gt;weakref&lt;/code&gt;&lt;/a&gt; module allows the Python programmer to create &lt;em&gt;weak references&lt;/em&gt; to objects.</source>
          <target state="translated">&lt;a href=&quot;#module-weakref&quot;&gt; &lt;code&gt;weakref&lt;/code&gt; &lt;/a&gt; 모듈은 파이썬 프로그래머가 만들 수 있습니다 &lt;em&gt;약한 참조&lt;/em&gt; 객체를.</target>
        </trans-unit>
        <trans-unit id="602ebdec6ca13a1397450d4fe2b22e2e1ced8817" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-webbrowser&quot;&gt;&lt;code&gt;webbrowser&lt;/code&gt;&lt;/a&gt; module provides a high-level interface to allow displaying Web-based documents to users. Under most circumstances, simply calling the &lt;a href=&quot;#webbrowser.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function from this module will do the right thing.</source>
          <target state="translated">&lt;a href=&quot;#module-webbrowser&quot;&gt; &lt;code&gt;webbrowser&lt;/code&gt; &lt;/a&gt; 모듈은 사용자에게 웹 기반 문서를 표시 할 수 있도록하는 높은 수준의 인터페이스를 제공합니다. 대부분의 상황 에서이 모듈에서 &lt;a href=&quot;#webbrowser.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수를 호출 하면 올바른 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1f5c82843a509b2a143237cf2ba7e8a05441e4b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-winsound&quot;&gt;&lt;code&gt;winsound&lt;/code&gt;&lt;/a&gt; module provides access to the basic sound-playing machinery provided by Windows platforms. It includes functions and several constants.</source>
          <target state="translated">&lt;a href=&quot;#module-winsound&quot;&gt; &lt;code&gt;winsound&lt;/code&gt; 의&lt;/a&gt; 모듈은 Windows 플랫폼에서 제공하는 기본 사운드 재생 장치에 대한 액세스를 제공합니다. 함수와 여러 상수가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="392fb45242b14c4b7cd1b0ded98856e64199fc71" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xdrlib&quot;&gt;&lt;code&gt;xdrlib&lt;/code&gt;&lt;/a&gt; module defines two classes, one for packing variables into XDR representation, and another for unpacking from XDR representation. There are also two exception classes.</source>
          <target state="translated">&lt;a href=&quot;#module-xdrlib&quot;&gt; &lt;code&gt;xdrlib&lt;/code&gt; 의&lt;/a&gt; 모듈은 XDR 표현에서 풀기위한 두 개의 클래스, XDR 표현으로 변수를 포장하는 일, 또 다른를 정의합니다. 예외 클래스도 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0765a0ff3c40c9034d664c7e44836a0a5dd558f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xdrlib&quot;&gt;&lt;code&gt;xdrlib&lt;/code&gt;&lt;/a&gt; module supports the External Data Representation Standard as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc1014.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1014&lt;/strong&gt;&lt;/a&gt;, written by Sun Microsystems, Inc. June 1987. It supports most of the data types described in the RFC.</source>
          <target state="translated">&lt;a href=&quot;#module-xdrlib&quot;&gt; &lt;code&gt;xdrlib&lt;/code&gt; 의&lt;/a&gt; 에 설명 된대로 모듈은 외부 데이터 표현 표준을 지원 &lt;a href=&quot;https://tools.ietf.org/html/rfc1014.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 1014&lt;/strong&gt;&lt;/a&gt; Sun Microsystems에서 작성, 주식 6월 1987 그것은 RFC에 설명 된 데이터 형식의 대부분을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7e23e8421593d34c75aa5877916b6c00871448fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.dom&quot;&gt;&lt;code&gt;xml.dom&lt;/code&gt;&lt;/a&gt; contains the following functions:</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom&quot;&gt; &lt;code&gt;xml.dom&lt;/code&gt; 는&lt;/a&gt; 다음과 같은 기능을 포함 :</target>
        </trans-unit>
        <trans-unit id="afe2596a2a0bf334c7c6480123b905a534e201ea" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; module is essentially a DOM 1.0-compatible DOM with some DOM 2 features (primarily namespace features).</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 의&lt;/a&gt; 모듈은 기본적으로 어떤 DOM 2 개 기능 (주로 기능이 네임 스페이스)와 DOM 1.0 호환 DOM이다.</target>
        </trans-unit>
        <trans-unit id="ec4bf1281109a15a8ce9a354baa7f424d805c298" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.dom.minidom&quot;&gt;&lt;code&gt;xml.dom.minidom&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.minidom&quot;&gt; &lt;code&gt;xml.dom.minidom&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ff2e624fa14eb71f82d8114b3704cd9e49c79c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.dom.pulldom&quot;&gt;&lt;code&gt;xml.dom.pulldom&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.pulldom&quot;&gt; &lt;code&gt;xml.dom.pulldom&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7da8d9e204b18cde09a1c5927abca16c2dc06f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.dom.pulldom&quot;&gt;&lt;code&gt;xml.dom.pulldom&lt;/code&gt;&lt;/a&gt; module provides a &amp;ldquo;pull parser&amp;rdquo; which can also be asked to produce DOM-accessible fragments of the document where necessary. The basic concept involves pulling &amp;ldquo;events&amp;rdquo; from a stream of incoming XML and processing them. In contrast to SAX which also employs an event-driven processing model together with callbacks, the user of a pull parser is responsible for explicitly pulling events from the stream, looping over those events until either processing is finished or an error condition occurs.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.dom.pulldom&quot;&gt; &lt;code&gt;xml.dom.pulldom&lt;/code&gt; 의&lt;/a&gt; 모듈은 필요한 경우 문서의 DOM 접근 조각을 생산하도록 요청받을 수있는 &quot;풀 파서&quot;를 제공합니다. 기본 개념은 들어오는 XML 스트림에서 &quot;이벤트&quot;를 가져 와서 처리하는 것입니다. 콜백과 함께 이벤트 중심 처리 모델을 사용하는 SAX와 달리 풀 파서 사용자는 처리가 완료되거나 오류 조건이 발생할 때까지 해당 이벤트를 반복하여 스트림에서 이벤트를 명시 적으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="753f54582b46244e21a8831572953d24a4288d90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt;&lt;code&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/a&gt; module implements a simple and efficient API for parsing and creating XML data.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt; &lt;code&gt;xml.etree.ElementTree&lt;/code&gt; 의&lt;/a&gt; 모듈 구현 구문 분석 및 XML 데이터를 생성하기위한 간단하고 효율적인 API.</target>
        </trans-unit>
        <trans-unit id="220ca5b36fbe3faa62dc3cebfd386cfa746bf773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt;&lt;code&gt;xml.etree.ElementTree&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.etree.ElementTree&quot;&gt; &lt;code&gt;xml.etree.ElementTree&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3cff07b737ccb6a53a248041c03aea6c1778b60" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module contains two functions:</source>
          <target state="translated">&lt;a href=&quot;#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; 의&lt;/a&gt; 모듈은 두 가지 기능을 포함 :</target>
        </trans-unit>
        <trans-unit id="487cc8b216b2d808ca3378ccef6ef8a4592695bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module is a Python interface to the Expat non-validating XML parser. The module provides a single extension type, &lt;code&gt;xmlparser&lt;/code&gt;, that represents the current state of an XML parser. After an &lt;code&gt;xmlparser&lt;/code&gt; object has been created, various attributes of the object can be set to handler functions. When an XML document is then fed to the parser, the handler functions are called for the character data and markup in the XML document.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; 의&lt;/a&gt; 모듈은 국외 거주자의 타당성을 검증하지 않는 XML 파서에 파이썬 인터페이스입니다. 이 모듈은 XML 파서의 현재 상태를 나타내는 단일 확장 유형 인 &lt;code&gt;xmlparser&lt;/code&gt; 를 제공합니다 . &lt;code&gt;xmlparser&lt;/code&gt; 객체가 생성 된 후 객체의 다양한 속성을 핸들러 함수로 설정할 수 있습니다. 그런 다음 XML 문서가 구문 분석기에 공급되면 XML 문서에서 문자 데이터 및 마크 업에 대해 핸들러 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbce4c26fd4ba418c1eaed5f2fdba794b888e4f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.parsers.expat.errors&quot;&gt;&lt;code&gt;errors&lt;/code&gt;&lt;/a&gt; module also provides error message constants and a dictionary &lt;a href=&quot;#xml.parsers.expat.errors.codes&quot;&gt;&lt;code&gt;codes&lt;/code&gt;&lt;/a&gt; mapping these messages back to the error codes, see below.</source>
          <target state="translated">또한 &lt;a href=&quot;#module-xml.parsers.expat.errors&quot;&gt; &lt;code&gt;errors&lt;/code&gt; &lt;/a&gt; 모듈은 오류 메시지 상수와 이러한 메시지를 오류 코드로 다시 매핑 하는 사전 &lt;a href=&quot;#xml.parsers.expat.errors.codes&quot;&gt; &lt;code&gt;codes&lt;/code&gt; &lt;/a&gt; 를 제공합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="33e272786d76f67af9436fe85e804086e74d1b40" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e221cca934884e0f8a8c65a15fb87eb0cc204e0c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xml.sax&quot;&gt;&lt;code&gt;xml.sax&lt;/code&gt;&lt;/a&gt; package provides a number of modules which implement the Simple API for XML (SAX) interface for Python. The package itself provides the SAX exceptions and the convenience functions which will be most used by users of the SAX API.</source>
          <target state="translated">&lt;a href=&quot;#module-xml.sax&quot;&gt; &lt;code&gt;xml.sax&lt;/code&gt; 의&lt;/a&gt; 패키지는 파이썬에 대한 XML (SAX) 인터페이스에 대한 간단한 API를 구현하는 모듈을 제공합니다. 패키지 자체는 SAX 예외 및 SAX API 사용자가 가장 많이 사용하는 편의 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ad2d781d2ea000faaa92755486cec8e6660fceeb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xmlrpc.client&quot;&gt;&lt;code&gt;xmlrpc.client&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xmlrpc.client&quot;&gt; &lt;code&gt;xmlrpc.client&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b8fce2f24b87c1546f646642802c15515a04d748" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xmlrpc.server&quot;&gt;&lt;code&gt;xmlrpc.server&lt;/code&gt;&lt;/a&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xmlrpc.server&quot;&gt; &lt;code&gt;xmlrpc.server&lt;/code&gt; 의&lt;/a&gt; 모듈은 악의적으로 구성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfcd4ee4d8d026e3b265966b4ea47954ccc18a9e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-xmlrpc.server&quot;&gt;&lt;code&gt;xmlrpc.server&lt;/code&gt;&lt;/a&gt; module provides a basic server framework for XML-RPC servers written in Python. Servers can either be free standing, using &lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt;&lt;code&gt;SimpleXMLRPCServer&lt;/code&gt;&lt;/a&gt;, or embedded in a CGI environment, using &lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#module-xmlrpc.server&quot;&gt; &lt;code&gt;xmlrpc.server&lt;/code&gt; 의&lt;/a&gt; 모듈은 파이썬으로 작성된 XML-RPC 서버에 대한 기본 서버 프레임 워크를 제공합니다. 서버는 &lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt; &lt;code&gt;SimpleXMLRPCServer&lt;/code&gt; 를&lt;/a&gt; 사용하여 &lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt; &lt;/a&gt; 사용하여 CGI 환경에 임베드 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97fe9e07c5e698e1d9d613108136f0084f9421ee" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-zipfile&quot;&gt;&lt;code&gt;zipfile&lt;/code&gt;&lt;/a&gt; module provides a simple command-line interface to interact with ZIP archives.</source>
          <target state="translated">&lt;a href=&quot;#module-zipfile&quot;&gt; &lt;code&gt;zipfile&lt;/code&gt; &lt;/a&gt; 모듈은 ZIP 아카이브와 상호 작용하는 간단한 명령 줄 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="75b75c1f39769dc1c5764f94ee93c4d6b84f3fed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.Pipe&quot;&gt;&lt;code&gt;Pipe()&lt;/code&gt;&lt;/a&gt; function returns a pair of connection objects connected by a pipe which by default is duplex (two-way). For example:</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Pipe&quot;&gt; &lt;code&gt;Pipe()&lt;/code&gt; &lt;/a&gt; 함수가 리턴 접속 쌍은 기본적으로 듀플렉스 파이프 (양방향)으로 연결된 객체. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8cf5feb4818516622d330a29f73f50132adfc639" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; class</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="4b293343c1c587e9b5ac647079a9431b786ace07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt; class is a near clone of &lt;a href=&quot;queue#queue.Queue&quot;&gt;&lt;code&gt;queue.Queue&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; 클래스의 근처 클론입니다 &lt;a href=&quot;queue#queue.Queue&quot;&gt; &lt;code&gt;queue.Queue&lt;/code&gt; &lt;/a&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a0cedb7fa5260d9907b2328d34b19ed312430247" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.Queue&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#multiprocessing.SimpleQueue&quot;&gt;&lt;code&gt;SimpleQueue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt;&lt;code&gt;JoinableQueue&lt;/code&gt;&lt;/a&gt; types are multi-producer, multi-consumer</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.Queue&quot;&gt; &lt;code&gt;Queue&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#multiprocessing.SimpleQueue&quot;&gt; &lt;code&gt;SimpleQueue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#multiprocessing.JoinableQueue&quot;&gt; &lt;code&gt;JoinableQueue&lt;/code&gt; &lt;/a&gt; 종류의 멀티 프로듀서, 멀티 소비자 있습니다</target>
        </trans-unit>
        <trans-unit id="038df3c220f2741b8456e0029e0ca1e05d8417f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt;&lt;code&gt;Connection.recv()&lt;/code&gt;&lt;/a&gt; method automatically unpickles the data it receives, which can be a security risk unless you can trust the process which sent the message.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.connection.Connection.recv&quot;&gt; &lt;code&gt;Connection.recv()&lt;/code&gt; &lt;/a&gt; 메서드는 자동으로 메시지를 전송하는 과정을 신뢰할 수없는 보안 위험이 될 수는 수신 데이터를 unpickles.</target>
        </trans-unit>
        <trans-unit id="29d6684e7eeea81aa92bf41bfe61a7c9303a408d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt;&lt;code&gt;Pool&lt;/code&gt;&lt;/a&gt; class represents a pool of worker processes. It has methods which allows tasks to be offloaded to the worker processes in a few different ways.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.pool.Pool&quot;&gt; &lt;code&gt;Pool&lt;/code&gt; &lt;/a&gt; 클래스는 작업자 프로세스의 풀을 나타냅니다. 여기에는 몇 가지 방법으로 작업을 작업자 프로세스로 오프로드 할 수있는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a507cb2ece4cc4bff46e7f21b384b92f4c11139f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt;&lt;code&gt;SharedMemory&lt;/code&gt;&lt;/a&gt; instance where the values are stored.</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory&quot;&gt; &lt;code&gt;SharedMemory&lt;/code&gt; 의&lt;/a&gt; 값이 저장되어있는 경우.</target>
        </trans-unit>
        <trans-unit id="eb8247966315c33ed7d42e4bdd9f010ba4c75fdd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#netrc.netrc&quot;&gt;&lt;code&gt;netrc&lt;/code&gt;&lt;/a&gt; class parses and encapsulates the netrc file format used by the Unix &lt;strong&gt;ftp&lt;/strong&gt; program and other FTP clients.</source>
          <target state="translated">&lt;a href=&quot;#netrc.netrc&quot;&gt; &lt;code&gt;netrc&lt;/code&gt; 의&lt;/a&gt; 클래스 구문 분석은 유닉스에서 사용하는 netrc 파일 형식 캡슐화 &lt;strong&gt;FTP&lt;/strong&gt; 프로그램과 다른 FTP 클라이언트.</target>
        </trans-unit>
        <trans-unit id="8d9f703f8f300e46186097fad3623f0d59c01381" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#os.name&quot;&gt;&lt;code&gt;name&lt;/code&gt;&lt;/a&gt; attribute will be &lt;code&gt;bytes&lt;/code&gt; if the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument is of type &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; otherwise. Use &lt;a href=&quot;#os.fsdecode&quot;&gt;&lt;code&gt;fsdecode()&lt;/code&gt;&lt;/a&gt; to decode byte filenames.</source>
          <target state="translated">&lt;a href=&quot;#os.name&quot;&gt; &lt;code&gt;name&lt;/code&gt; &lt;/a&gt; 속성이 될 것입니다 &lt;code&gt;bytes&lt;/code&gt; 경우 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수는 타입이다 &lt;code&gt;bytes&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 그렇지. 바이트 파일 이름을 디코딩 하려면 &lt;a href=&quot;#os.fsdecode&quot;&gt; &lt;code&gt;fsdecode()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f828ec7e960d4be893a45463a9230b6baafb0f22" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; function returns directory entries along with file attribute information, giving better performance for many common use cases.</source>
          <target state="translated">&lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 파일 속성 정보와 함께 함수가 반환 디렉토리 항목, 많은 일반적인 사용 사례에 대한 더 나은 성능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c5c2323bdc5e7fee3b0c455c908e3670af275b78" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; iterator supports the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;context manager&lt;/a&gt; protocol and has the following method:</source>
          <target state="translated">&lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 반복기를 지원하는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-context-manager&quot;&gt;콘텍스트 관리자&lt;/a&gt; 프로토콜과 같은 방법이있다 :</target>
        </trans-unit>
        <trans-unit id="43bededb39b0a5e3947c94653bc8a5e138915265" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#os.stat&quot;&gt;&lt;code&gt;stat()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;#os.stat&quot;&gt; &lt;code&gt;stat()&lt;/code&gt; &lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="bd878a547586902bf1c4b2db9bcb9b047247a72d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#parser.expr&quot;&gt;&lt;code&gt;expr()&lt;/code&gt;&lt;/a&gt; function parses the parameter &lt;em&gt;source&lt;/em&gt; as if it were an input to &lt;code&gt;compile(source, 'file.py', 'eval')&lt;/code&gt;. If the parse succeeds, an ST object is created to hold the internal parse tree representation, otherwise an appropriate exception is raised.</source>
          <target state="translated">&lt;a href=&quot;#parser.expr&quot;&gt; &lt;code&gt;expr()&lt;/code&gt; &lt;/a&gt; 함수는 파라미터 파싱 &lt;em&gt;소스&lt;/em&gt; 그것이 입력하는 것처럼 &lt;code&gt;compile(source, 'file.py', 'eval')&lt;/code&gt; . 구문 분석에 성공하면 내부 구문 분석 트리 표현을 보유하기 위해 ST 오브젝트가 작성됩니다. 그렇지 않으면 적절한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6d012d594304d7266b44a2752d73569066704c93" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#parser.suite&quot;&gt;&lt;code&gt;suite()&lt;/code&gt;&lt;/a&gt; function parses the parameter &lt;em&gt;source&lt;/em&gt; as if it were an input to &lt;code&gt;compile(source, 'file.py', 'exec')&lt;/code&gt;. If the parse succeeds, an ST object is created to hold the internal parse tree representation, otherwise an appropriate exception is raised.</source>
          <target state="translated">&lt;a href=&quot;#parser.suite&quot;&gt; &lt;code&gt;suite()&lt;/code&gt; &lt;/a&gt; 함수는 파라미터 파싱 &lt;em&gt;소스&lt;/em&gt; 그것의 입력을 마치 &lt;code&gt;compile(source, 'file.py', 'exec')&lt;/code&gt; . 구문 분석에 성공하면 내부 구문 분석 트리 표현을 보유하기 위해 ST 오브젝트가 작성됩니다. 그렇지 않으면 적절한 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9544d49104e9b2f429af86f2c8c929928e7a546f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#profile.Profile&quot;&gt;&lt;code&gt;Profile&lt;/code&gt;&lt;/a&gt; class can also be used as a context manager (supported only in &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt; module. see &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;Context Manager Types&lt;/a&gt;):</source>
          <target state="translated">&lt;a href=&quot;#profile.Profile&quot;&gt; &lt;code&gt;Profile&lt;/code&gt; &lt;/a&gt; 클래스는 컨텍스트 관리자로 사용할 수 있습니다 (만 지원 &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오. &lt;a href=&quot;stdtypes#typecontextmanager&quot;&gt;컨텍스트 관리자 유형&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="faf57ccc0cc476807993436cf501f3326fcbfcc1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#protocols&quot;&gt;Protocols&lt;/a&gt; section documents asyncio &lt;a href=&quot;#asyncio.BaseProtocol&quot;&gt;&lt;code&gt;BaseProtocol&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Protocol&quot;&gt;&lt;code&gt;Protocol&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.BufferedProtocol&quot;&gt;&lt;code&gt;BufferedProtocol&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.DatagramProtocol&quot;&gt;&lt;code&gt;DatagramProtocol&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#asyncio.SubprocessProtocol&quot;&gt;&lt;code&gt;SubprocessProtocol&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;#protocols&quot;&gt;프로토콜&lt;/a&gt; asyncio 단원에서는 &lt;a href=&quot;#asyncio.BaseProtocol&quot;&gt; &lt;code&gt;BaseProtocol&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.Protocol&quot;&gt; &lt;code&gt;Protocol&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.BufferedProtocol&quot;&gt; &lt;code&gt;BufferedProtocol&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.DatagramProtocol&quot;&gt; &lt;code&gt;DatagramProtocol&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.SubprocessProtocol&quot;&gt; &lt;code&gt;SubprocessProtocol&lt;/code&gt; 의&lt;/a&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="226339913a9761d8d008b8dbb0aa15827c049517" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pstats.Stats&quot;&gt;&lt;code&gt;pstats.Stats&lt;/code&gt;&lt;/a&gt; class reads profile results from a file and formats them in various ways.</source>
          <target state="translated">&lt;a href=&quot;#pstats.Stats&quot;&gt; &lt;code&gt;pstats.Stats&lt;/code&gt; 의&lt;/a&gt; 클래스는 파일에서 프로파일 결과를 읽고 다양한 방법으로 그 형식을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="f68199c1afb4ab885475da66322b237f646c0f3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#pstats.Stats.strip_dirs&quot;&gt;&lt;code&gt;strip_dirs()&lt;/code&gt;&lt;/a&gt; method removed the extraneous path from all the module names. The &lt;a href=&quot;#pstats.Stats.sort_stats&quot;&gt;&lt;code&gt;sort_stats()&lt;/code&gt;&lt;/a&gt; method sorted all the entries according to the standard module/line/name string that is printed. The &lt;a href=&quot;#pstats.Stats.print_stats&quot;&gt;&lt;code&gt;print_stats()&lt;/code&gt;&lt;/a&gt; method printed out all the statistics. You might try the following sort calls:</source>
          <target state="translated">&lt;a href=&quot;#pstats.Stats.strip_dirs&quot;&gt; &lt;code&gt;strip_dirs()&lt;/code&gt; &lt;/a&gt; 메소드는 모든 모듈 이름의 외부 경로를 제거 하였다. &lt;a href=&quot;#pstats.Stats.sort_stats&quot;&gt; &lt;code&gt;sort_stats()&lt;/code&gt; &lt;/a&gt; 메소드는 표준 인쇄 모듈 / 라인 / 이름 문자열에 따라 모든 항목을 분류. &lt;a href=&quot;#pstats.Stats.print_stats&quot;&gt; &lt;code&gt;print_stats()&lt;/code&gt; &lt;/a&gt; 메소드는 모든 통계를 인쇄. 다음과 같은 정렬 호출을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5544d4649257a25ae9f7706cb59f82c5565624e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#range&quot;&gt;&lt;code&gt;range&lt;/code&gt;&lt;/a&gt; type represents an immutable sequence of numbers and is commonly used for looping a specific number of times in &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt;&lt;code&gt;for&lt;/code&gt;&lt;/a&gt; loops.</source>
          <target state="translated">&lt;a href=&quot;#range&quot;&gt; &lt;code&gt;range&lt;/code&gt; &lt;/a&gt; 타입은 숫자의 불변 서열을 나타내며, 일반적으로 시간의 특정 번호를 반복 사용되는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;/a&gt; 루프.</target>
        </trans-unit>
        <trans-unit id="02d79383c695b081c5ccacc2d185b0227b09d755" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#re-objects&quot;&gt;regular expression object&lt;/a&gt; whose &lt;a href=&quot;#re.Pattern.match&quot;&gt;&lt;code&gt;match()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#re.Pattern.search&quot;&gt;&lt;code&gt;search()&lt;/code&gt;&lt;/a&gt; method produced this match instance.</source>
          <target state="translated">&lt;a href=&quot;#re-objects&quot;&gt;정규식 객체&lt;/a&gt; 그 &lt;a href=&quot;#re.Pattern.match&quot;&gt; &lt;code&gt;match()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#re.Pattern.search&quot;&gt; &lt;code&gt;search()&lt;/code&gt; &lt;/a&gt; 방법이 매치 인스턴스를 생성.</target>
        </trans-unit>
        <trans-unit id="fd9268eb754a15ad397f9c9fc09eaf71e25be7ed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sched.scheduler&quot;&gt;&lt;code&gt;scheduler&lt;/code&gt;&lt;/a&gt; class defines a generic interface to scheduling events. It needs two functions to actually deal with the &amp;ldquo;outside world&amp;rdquo; &amp;mdash; &lt;em&gt;timefunc&lt;/em&gt; should be callable without arguments, and return a number (the &amp;ldquo;time&amp;rdquo;, in any units whatsoever). The &lt;em&gt;delayfunc&lt;/em&gt; function should be callable with one argument, compatible with the output of &lt;em&gt;timefunc&lt;/em&gt;, and should delay that many time units. &lt;em&gt;delayfunc&lt;/em&gt; will also be called with the argument &lt;code&gt;0&lt;/code&gt; after each event is run to allow other threads an opportunity to run in multi-threaded applications.</source>
          <target state="translated">&lt;a href=&quot;#sched.scheduler&quot;&gt; &lt;code&gt;scheduler&lt;/code&gt; &lt;/a&gt; 클래스는 예약 이벤트에 대한 일반적인 인터페이스를 정의합니다. 실제로 &quot;외부 세계&quot;를 처리하려면 두 가지 함수가 필요합니다. &lt;em&gt;timefunc&lt;/em&gt; 는 인수없이 호출 가능해야하며 숫자 (모든 단위의 &quot;시간&quot;)를 반환해야합니다. &lt;em&gt;delayfunc의&lt;/em&gt; 함수의 출력과 호환되는 하나 개의 인자로 호출되어야 &lt;em&gt;timefunc&lt;/em&gt; 하고 많은 시간 단위를 지연한다. &lt;em&gt;delayfunc는&lt;/em&gt; 또한 인수와 함께 호출됩니다 &lt;code&gt;0&lt;/code&gt; 각 이벤트는 다른 스레드에게 멀티 스레드 애플리케이션에서 실행 할 수있는 기회를 허용하기 위해 실행 한 후.</target>
        </trans-unit>
        <trans-unit id="36be084ce98cf1d1198d3409e1035b3326919bd6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#server-objects&quot;&gt;Server Objects&lt;/a&gt; section documents types returned from event loop methods like &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt;;</source>
          <target state="translated">&lt;a href=&quot;#server-objects&quot;&gt;서버는 개체&lt;/a&gt; 와 같은 이벤트 루프 방법에서 반환 섹션 문서 유형 &lt;a href=&quot;#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="94096215001803cb14ba00b186d7e0b29c7a5262" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#shlex.shlex&quot;&gt;&lt;code&gt;shlex&lt;/code&gt;&lt;/a&gt; class makes it easy to write lexical analyzers for simple syntaxes resembling that of the Unix shell. This will often be useful for writing minilanguages, (for example, in run control files for Python applications) or for parsing quoted strings.</source>
          <target state="translated">&lt;a href=&quot;#shlex.shlex&quot;&gt; &lt;code&gt;shlex&lt;/code&gt; &lt;/a&gt; 클래스는 쉽게 유닉스 쉘의를 닮은 간단한 구문을위한 어휘 분석기를 작성할 수 있습니다. 이 기능은 미니 언어를 작성하거나 (예를 들어 Python 응용 프로그램의 실행 제어 파일에서) 인용 된 문자열을 구문 분석 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="261858698a1b8371fdde292b2461fac39e64543f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#signal.signal&quot;&gt;&lt;code&gt;signal.signal()&lt;/code&gt;&lt;/a&gt; function allows defining custom handlers to be executed when a signal is received. A small number of default handlers are installed: &lt;code&gt;SIGPIPE&lt;/code&gt; is ignored (so write errors on pipes and sockets can be reported as ordinary Python exceptions) and &lt;code&gt;SIGINT&lt;/code&gt; is translated into a &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt;&lt;code&gt;KeyboardInterrupt&lt;/code&gt;&lt;/a&gt; exception if the parent process has not changed it.</source>
          <target state="translated">&lt;a href=&quot;#signal.signal&quot;&gt; &lt;code&gt;signal.signal()&lt;/code&gt; &lt;/a&gt; 함수는, 신호가 수신 될 때 실행되는 사용자 핸들러를 정의 허용한다. 소수의 기본 처리기가 설치됩니다. &lt;code&gt;SIGPIPE&lt;/code&gt; 는 무시되므로 (파이프 및 소켓의 쓰기 오류는 일반적인 Python 예외로보고 될 수 있음) 부모 프로세스가 변경하지 않은 경우 &lt;code&gt;SIGINT&lt;/code&gt; 는 &lt;a href=&quot;exceptions#KeyboardInterrupt&quot;&gt; &lt;code&gt;KeyboardInterrupt&lt;/code&gt; &lt;/a&gt; 예외 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5a79026512537c574eb6c65db11730a5f08239f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt;&lt;code&gt;SMTPChannel&lt;/code&gt;&lt;/a&gt; has the following instance variables:</source>
          <target state="translated">&lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt; &lt;code&gt;SMTPChannel&lt;/code&gt; 는&lt;/a&gt; 다음과 같은 인스턴스 변수가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0af2badecdbd4dbfe8d3ed8f8f0c1e55816e49bb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt;&lt;code&gt;SMTPChannel&lt;/code&gt;&lt;/a&gt; operates by invoking methods named &lt;code&gt;smtp_&amp;lt;command&amp;gt;&lt;/code&gt; upon reception of a command line from the client. Built into the base &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt;&lt;code&gt;SMTPChannel&lt;/code&gt;&lt;/a&gt; class are methods for handling the following commands (and responding to them appropriately):</source>
          <target state="translated">&lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt; &lt;code&gt;SMTPChannel&lt;/code&gt; 은&lt;/a&gt; 라는 메소드 호출함으로써 동작 &lt;code&gt;smtp_&amp;lt;command&amp;gt;&lt;/code&gt; 클라이언트의 명령 라인을 수신하면. 기본 &lt;a href=&quot;#smtpd.SMTPChannel&quot;&gt; &lt;code&gt;SMTPChannel&lt;/code&gt; &lt;/a&gt; 클래스에는 다음 명령을 처리하고 적절하게 응답하기위한 메소드가 내장되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c248d381a6387f2e58305c651544e1788fd34391" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#smtplib.SMTP&quot;&gt;&lt;code&gt;SMTP&lt;/code&gt;&lt;/a&gt; class supports the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When used like this, the SMTP &lt;code&gt;QUIT&lt;/code&gt; command is issued automatically when the &lt;code&gt;with&lt;/code&gt; statement exits. E.g.:</source>
          <target state="translated">&lt;a href=&quot;#smtplib.SMTP&quot;&gt; &lt;code&gt;SMTP&lt;/code&gt; 의&lt;/a&gt; 클래스는 지원 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문. 이와 같이 사용 하면 &lt;code&gt;with&lt;/code&gt; 문이 종료 되면 SMTP &lt;code&gt;QUIT&lt;/code&gt; 명령이 자동으로 실행됩니다. 예 :</target>
        </trans-unit>
        <trans-unit id="7ba7227180d23083c63b7cd70e4416628bfdae8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; operation is also subject to the timeout setting, and in general it is recommended to call &lt;a href=&quot;#socket.socket.settimeout&quot;&gt;&lt;code&gt;settimeout()&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;#socket.socket.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; or pass a timeout parameter to &lt;a href=&quot;#socket.create_connection&quot;&gt;&lt;code&gt;create_connection()&lt;/code&gt;&lt;/a&gt;. However, the system network stack may also return a connection timeout error of its own regardless of any Python socket timeout setting.</source>
          <target state="translated">&lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 작업이 또한 제한 시간 설정 될 수 있으며, 일반적으로는 전화를하는 것이 좋습니다 &lt;a href=&quot;#socket.socket.settimeout&quot;&gt; &lt;code&gt;settimeout()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 &lt;a href=&quot;#socket.socket.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 또는에 시간 초과 매개 변수 통과 &lt;a href=&quot;#socket.create_connection&quot;&gt; &lt;code&gt;create_connection()&lt;/code&gt; &lt;/a&gt; . 그러나 시스템 네트워크 스택은 Python 소켓 시간 초과 설정에 관계없이 자체 연결 시간 초과 오류를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f34a3a52948310ee7b973bbd6b7593ee24a7e87" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#socket.socket.ioctl&quot;&gt;&lt;code&gt;ioctl()&lt;/code&gt;&lt;/a&gt; method is a limited interface to the WSAIoctl system interface. Please refer to the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx&quot;&gt;Win32 documentation&lt;/a&gt; for more information.</source>
          <target state="translated">&lt;a href=&quot;#socket.socket.ioctl&quot;&gt; &lt;code&gt;ioctl()&lt;/code&gt; &lt;/a&gt; 메소드는 WSAIoctl 시스템 인터페이스에 제한 인터페이스이다. 자세한 내용은 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms741621%28VS.85%29.aspx&quot;&gt;Win32 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0c9a0bec90b943d5adc4cadb9125116e6af7f717" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt;&lt;code&gt;ForkingMixIn&lt;/code&gt;&lt;/a&gt; class is used in the same way, except that the server will spawn a new process for each request. Available only on POSIX platforms that support &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#socketserver.ForkingMixIn&quot;&gt; &lt;code&gt;ForkingMixIn&lt;/code&gt; 의&lt;/a&gt; 클래스가 같은 방식으로 사용되며, 서버가 각 요청에 대해 새로운 프로세스를 생성한다는 점입니다. &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 를 지원하는 POSIX 플랫폼에서만 사용 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="b22e3b3c0b3d428c1075294cae2728e7d78d57b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt;&lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt;&lt;/a&gt; protocol configures the context for cert validation and hostname verification. &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt;&lt;code&gt;verify_mode&lt;/code&gt;&lt;/a&gt; is set to &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;True&lt;/code&gt;. All other protocols create SSL contexts with insecure defaults.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS_CLIENT&quot;&gt; &lt;code&gt;PROTOCOL_TLS_CLIENT&lt;/code&gt; 의&lt;/a&gt; 프로토콜은 인증서 검증 및 호스트 이름 확인을 위해 컨텍스트를 구성합니다. &lt;a href=&quot;#ssl.SSLContext.verify_mode&quot;&gt; &lt;code&gt;verify_mode&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; 이&lt;/a&gt; 설정되어 &lt;code&gt;True&lt;/code&gt; . 다른 모든 프로토콜은 안전하지 않은 기본값으로 SSL 컨텍스트를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="5470adc94cef770e82c8dc9da60579e42d5c3ef8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; object this SSL socket is tied to. If the SSL socket was created using the deprecated &lt;a href=&quot;#ssl.wrap_socket&quot;&gt;&lt;code&gt;wrap_socket()&lt;/code&gt;&lt;/a&gt; function (rather than &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt;&lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt;&lt;/a&gt;), this is a custom context object created for this SSL socket.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 이 SSL 소켓이 연결되어 있습니다 오브젝트. 더 이상 사용되지 않는 &lt;a href=&quot;#ssl.wrap_socket&quot;&gt; &lt;code&gt;wrap_socket()&lt;/code&gt; &lt;/a&gt; 함수 ( &lt;a href=&quot;#ssl.SSLContext.wrap_socket&quot;&gt; &lt;code&gt;SSLContext.wrap_socket()&lt;/code&gt; &lt;/a&gt; 대신 )를 사용하여 SSL 소켓을 작성한 경우이 SSL 소켓에 대해 작성된 사용자 정의 컨텍스트 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="a6167917237eb99295fe6afdef07d22ea214c720" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ssl.SSLSession&quot;&gt;&lt;code&gt;SSLSession&lt;/code&gt;&lt;/a&gt; for this SSL connection. The session is available for client and server side sockets after the TLS handshake has been performed. For client sockets the session can be set before &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt;&lt;code&gt;do_handshake()&lt;/code&gt;&lt;/a&gt; has been called to reuse a session.</source>
          <target state="translated">이 SSL 연결 의 &lt;a href=&quot;#ssl.SSLSession&quot;&gt; &lt;code&gt;SSLSession&lt;/code&gt; &lt;/a&gt; 입니다. 세션은 TLS 핸드 셰이크가 수행 된 후 클라이언트 및 서버 측 소켓에 사용 가능합니다. 클라이언트 소켓의 경우 세션 을 재사용 하기 &lt;a href=&quot;#ssl.SSLSocket.do_handshake&quot;&gt; &lt;code&gt;do_handshake()&lt;/code&gt; &lt;/a&gt; 를 호출 하기 전에 세션을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bcd0b01f83837796f08fb415d94353728ad5dc5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; methods are the low-level methods that read and write unencrypted, application-level data and decrypt/encrypt it to encrypted, wire-level data. These methods require an active SSL connection, i.e. the handshake was completed and &lt;a href=&quot;#ssl.SSLSocket.unwrap&quot;&gt;&lt;code&gt;SSLSocket.unwrap()&lt;/code&gt;&lt;/a&gt; was not called.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 메소드는 암호화 / 해독이 암호화 와이어 수준의 데이터 읽기 및 쓰기 저급 방법은 암호화 애플리케이션 레벨 데이터이다. 이러한 메소드에는 활성 SSL 연결이 필요합니다. 즉, 핸드 셰이크가 완료되었고 &lt;a href=&quot;#ssl.SSLSocket.unwrap&quot;&gt; &lt;code&gt;SSLSocket.unwrap()&lt;/code&gt; &lt;/a&gt; 이 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="1f53d2eee18de9c0c4875c339dfa8b9bce47a924" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#str.find&quot;&gt;&lt;code&gt;find()&lt;/code&gt;&lt;/a&gt; method should be used only if you need to know the position of &lt;em&gt;sub&lt;/em&gt;. To check if &lt;em&gt;sub&lt;/em&gt; is a substring or not, use the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator:</source>
          <target state="translated">&lt;a href=&quot;#str.find&quot;&gt; &lt;code&gt;find()&lt;/code&gt; &lt;/a&gt; 당신의 위치를 알 필요가 있다면 방법에만 사용해야합니다 &lt;em&gt;하위&lt;/em&gt; . &lt;em&gt;sub&lt;/em&gt; 가 하위 문자열인지 확인하려면 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="73c06bca828d67bdfb43cc865a64d21c1502ae10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; class has the following public methods:</source>
          <target state="translated">&lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 클래스는 다음과 같은 공공 방법이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="b720e60f05b2d504c18bd6025532017adbb42ca5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt;&lt;code&gt;STARTUPINFO&lt;/code&gt;&lt;/a&gt; class and following constants are only available on Windows.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.STARTUPINFO&quot;&gt; &lt;code&gt;STARTUPINFO&lt;/code&gt; 의&lt;/a&gt; 클래스와 다음 상수는 윈도우에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d55c54994cff722fca955da59c89d7d333ea0e56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#subprocess.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; function was added in Python 3.5; if you need to retain compatibility with older versions, see the &lt;a href=&quot;#call-function-trio&quot;&gt;Older high-level API&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 함수는 파이썬 3.5에서 추가되었다; 이전 버전과의 호환성을 유지해야하는 경우 &lt;a href=&quot;#call-function-trio&quot;&gt;이전 고급 API&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30fbbed09a97b3cd59b7f8953724c13a4c63dd4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#sys.unraisablehook&quot;&gt;&lt;code&gt;sys.unraisablehook()&lt;/code&gt;&lt;/a&gt; function handles unraisable exceptions and the &lt;a href=&quot;threading#threading.excepthook&quot;&gt;&lt;code&gt;threading.excepthook()&lt;/code&gt;&lt;/a&gt; function handles exception raised by &lt;a href=&quot;threading#threading.Thread.run&quot;&gt;&lt;code&gt;threading.Thread.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#sys.unraisablehook&quot;&gt; &lt;code&gt;sys.unraisablehook()&lt;/code&gt; &lt;/a&gt; 함수 unraisable 예외 핸들 &lt;a href=&quot;threading#threading.excepthook&quot;&gt; &lt;code&gt;threading.excepthook()&lt;/code&gt; &lt;/a&gt; 에 의해 발생 함수 핸들 예외 &lt;a href=&quot;threading#threading.Thread.run&quot;&gt; &lt;code&gt;threading.Thread.run()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d3a0057fe0fb71f61b6c145a72bca3f56f585507" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tarfile.TarFile&quot;&gt;&lt;code&gt;TarFile&lt;/code&gt;&lt;/a&gt; object provides an interface to a tar archive. A tar archive is a sequence of blocks. An archive member (a stored file) is made up of a header block followed by data blocks. It is possible to store a file in a tar archive several times. Each archive member is represented by a &lt;a href=&quot;#tarfile.TarInfo&quot;&gt;&lt;code&gt;TarInfo&lt;/code&gt;&lt;/a&gt; object, see &lt;a href=&quot;#tarinfo-objects&quot;&gt;TarInfo Objects&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile&quot;&gt; &lt;code&gt;TarFile&lt;/code&gt; &lt;/a&gt; 객체는 tar 아카이브에 대한 인터페이스를 제공합니다. tar 아카이브는 일련의 블록입니다. 아카이브 멤버 (저장 파일)는 헤더 블록과 데이터 블록으로 구성됩니다. tar 아카이브에 파일을 여러 번 저장할 수 있습니다. 각 아카이브 멤버는 &lt;a href=&quot;#tarfile.TarInfo&quot;&gt; &lt;code&gt;TarInfo&lt;/code&gt; &lt;/a&gt; 오브젝트로 표시 됩니다. 자세한 내용 은 &lt;a href=&quot;#tarinfo-objects&quot;&gt;TarInfo 오브젝트&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97a64804b61284aa185a7e81cd4b409ab490a7f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt;&lt;code&gt;extract()&lt;/code&gt;&lt;/a&gt; method does not take care of several extraction issues. In most cases you should consider using the &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt;&lt;code&gt;extractall()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#tarfile.TarFile.extract&quot;&gt; &lt;code&gt;extract()&lt;/code&gt; &lt;/a&gt; 메소드는 여러 추출 문제를 처리하지 않습니다. 대부분의 경우 &lt;a href=&quot;#tarfile.TarFile.extractall&quot;&gt; &lt;code&gt;extractall()&lt;/code&gt; &lt;/a&gt; 메소드 사용을 고려해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9cfe3269d37c7bc235b57f8a026ae88957a0f7f5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; constructor accepts a number of optional keyword arguments. Each keyword argument corresponds to an instance attribute, so for example</source>
          <target state="translated">&lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; 의&lt;/a&gt; 생성자는 선택적 키워드 인수의 숫자를 받아들입니다. 각 키워드 인수는 인스턴스 속성에 해당하므로 예를 들어</target>
        </trans-unit>
        <trans-unit id="7703bb87af59c734834b856195ac87e519ac6ee2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#textwrap.TextWrapper&quot;&gt;&lt;code&gt;TextWrapper&lt;/code&gt;&lt;/a&gt; instance attributes (and keyword arguments to the constructor) are as follows:</source>
          <target state="translated">&lt;a href=&quot;#textwrap.TextWrapper&quot;&gt; &lt;code&gt;TextWrapper&lt;/code&gt; 에&lt;/a&gt; 다음과 같이 인스턴스 특성 (생성자에 대한 키워드 인자)가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="33361bdf206a24520f829bae7a81a1dc0d37aa21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; method wakes up one of the threads waiting for the condition variable, if any are waiting. The &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt;&lt;code&gt;notify_all()&lt;/code&gt;&lt;/a&gt; method wakes up all threads waiting for the condition variable.</source>
          <target state="translated">&lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 라도 대기하는 경우에있어서, 조건 변수에 대기 스레드 중 하나를 웨이크 업. &lt;a href=&quot;#threading.Condition.notify_all&quot;&gt; &lt;code&gt;notify_all()&lt;/code&gt; &lt;/a&gt; 메소드는 조건 변수를 기다리는 모든 스레드를 깨어.</target>
        </trans-unit>
        <trans-unit id="70fa13c482f98185f2eb2a33d30687c5053e2d32" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#threading.Thread&quot;&gt;&lt;code&gt;Thread&lt;/code&gt;&lt;/a&gt; class represents an activity that is run in a separate thread of control. There are two ways to specify the activity: by passing a callable object to the constructor, or by overriding the &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; method in a subclass. No other methods (except for the constructor) should be overridden in a subclass. In other words, &lt;em&gt;only&lt;/em&gt; override the &lt;code&gt;__init__()&lt;/code&gt; and &lt;a href=&quot;#threading.Thread.run&quot;&gt;&lt;code&gt;run()&lt;/code&gt;&lt;/a&gt; methods of this class.</source>
          <target state="translated">&lt;a href=&quot;#threading.Thread&quot;&gt; &lt;code&gt;Thread&lt;/code&gt; &lt;/a&gt; 클래스는 컨트롤의 별도의 스레드에서 실행되는 작업을 나타냅니다. 액티비티를 지정하는 방법은 호출 가능한 객체를 생성자에 전달하거나 하위 클래스에서 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메서드를 재정의하는 두 가지 방법이 있습니다 . 서브 클래스에서 다른 메소드 (생성자를 제외하고)를 대체해서는 안됩니다. 즉, 이 클래스 의 &lt;code&gt;__init__()&lt;/code&gt; 및 &lt;a href=&quot;#threading.Thread.run&quot;&gt; &lt;code&gt;run()&lt;/code&gt; &lt;/a&gt; 메소드 &lt;em&gt;만&lt;/em&gt; 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c3b2617bcf43cb43eb39a08c7265bedcf6123a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tkinter.Tcl&quot;&gt;&lt;code&gt;Tcl()&lt;/code&gt;&lt;/a&gt; function is a factory function which creates an object much like that created by the &lt;a href=&quot;#tkinter.Tk&quot;&gt;&lt;code&gt;Tk&lt;/code&gt;&lt;/a&gt; class, except that it does not initialize the Tk subsystem. This is most often useful when driving the Tcl interpreter in an environment where one doesn&amp;rsquo;t want to create extraneous toplevel windows, or where one cannot (such as Unix/Linux systems without an X server). An object created by the &lt;a href=&quot;#tkinter.Tcl&quot;&gt;&lt;code&gt;Tcl()&lt;/code&gt;&lt;/a&gt; object can have a Toplevel window created (and the Tk subsystem initialized) by calling its &lt;code&gt;loadtk()&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.Tcl&quot;&gt; &lt;code&gt;Tcl()&lt;/code&gt; &lt;/a&gt; 함수는 많은 만든 같은 객체 생성하는 팩토리 함수 &lt;a href=&quot;#tkinter.Tk&quot;&gt; &lt;code&gt;Tk&lt;/code&gt; &lt;/a&gt; 클래스를가 TK에 서브 시스템을 초기화하지 않는다는 점을 제외. 이는 외부 최상위 창을 생성하지 않으려는 환경 또는 X 서버가없는 Unix / Linux 시스템과 같은 환경에서 Tcl 인터프리터를 구동 할 때 가장 유용합니다. &lt;a href=&quot;#tkinter.Tcl&quot;&gt; &lt;code&gt;Tcl()&lt;/code&gt; &lt;/a&gt; 객체로 생성 된 객체는 &lt;code&gt;loadtk()&lt;/code&gt; 메소드를 호출하여 최상위 창을 생성하고 Tk 하위 시스템을 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a2c177dddb81e041c2f1178faa5fcee9f2675fe1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tkinter.Tk&quot;&gt;&lt;code&gt;Tk&lt;/code&gt;&lt;/a&gt; class is instantiated without arguments. This creates a toplevel widget of Tk which usually is the main window of an application. Each instance has its own associated Tcl interpreter.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.Tk&quot;&gt; &lt;code&gt;Tk&lt;/code&gt; &lt;/a&gt; 클래스는 인수없이 인스턴스화됩니다. 일반적으로 응용 프로그램의 기본 창인 Tk의 최상위 위젯을 만듭니다. 각 인스턴스에는 고유 한 Tcl 인터프리터가 있습니다.</target>
        </trans-unit>
        <trans-unit id="869c3855e73e73353ff5dfa55f6cc880f2540f3a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tkinter.Tk&quot;&gt;&lt;code&gt;Tk&lt;/code&gt;&lt;/a&gt; class is meant to be instantiated only once in an application. Application programmers need not instantiate one explicitly, the system creates one whenever any of the other classes are instantiated.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.Tk&quot;&gt; &lt;code&gt;Tk&lt;/code&gt; &lt;/a&gt; 클래스는 응용 프로그램에서 한 번만 인스턴스화하기위한 것입니다. 응용 프로그램 프로그래머는 명시 적으로 인스턴스를 생성 할 필요가 없습니다. 시스템은 다른 클래스가 인스턴스화 될 때마다 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c3baf0bee1f8feca4f4af014435d6ef95a8f5af8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tkinter.tix.DirSelectBox&quot;&gt;&lt;code&gt;DirSelectBox&lt;/code&gt;&lt;/a&gt; is similar to the standard Motif(TM) directory-selection box. It is generally used for the user to choose a directory. DirSelectBox stores the directories mostly recently selected into a ComboBox widget so that they can be quickly selected again.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.tix.DirSelectBox&quot;&gt; &lt;code&gt;DirSelectBox&lt;/code&gt; 는&lt;/a&gt; 표준 모티프 (TM) 디렉토리 선택 상자와 유사하다. 일반적으로 사용자가 디렉토리를 선택하는 데 사용됩니다. DirSelectBox는 가장 최근에 선택한 디렉토리를 ComboBox 위젯에 저장하여 빠르게 다시 선택할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="427de85d6d015476411261c28cb3757d1cc9681b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tkinter.ttk.Treeview.focus&quot;&gt;&lt;code&gt;Treeview.focus()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Treeview.selection&quot;&gt;&lt;code&gt;Treeview.selection()&lt;/code&gt;&lt;/a&gt; methods can be used to determine the affected item or items.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.ttk.Treeview.focus&quot;&gt; &lt;code&gt;Treeview.focus()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Treeview.selection&quot;&gt; &lt;code&gt;Treeview.selection()&lt;/code&gt; &lt;/a&gt; 메소드는 해당 아이템이 결정하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="dd9a1fc943e550366e74685fe1223f3b26967c03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tokenize.detect_encoding&quot;&gt;&lt;code&gt;detect_encoding()&lt;/code&gt;&lt;/a&gt; function is used to detect the encoding that should be used to decode a Python source file. It requires one argument, readline, in the same way as the &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt; generator.</source>
          <target state="translated">&lt;a href=&quot;#tokenize.detect_encoding&quot;&gt; &lt;code&gt;detect_encoding()&lt;/code&gt; &lt;/a&gt; 함수는 파이썬 원본 파일을 디코딩하는데 사용되어야하는 인코딩을 검출하는데 사용된다. &lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 생성기 와 동일한 방식으로 하나의 인수 readline이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="64839bca3d7e3ea9f319d47b623da23adf764dc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tokenize.tokenize&quot;&gt;&lt;code&gt;tokenize()&lt;/code&gt;&lt;/a&gt; generator requires one argument, &lt;em&gt;readline&lt;/em&gt;, which must be a callable object which provides the same interface as the &lt;a href=&quot;io#io.IOBase.readline&quot;&gt;&lt;code&gt;io.IOBase.readline()&lt;/code&gt;&lt;/a&gt; method of file objects. Each call to the function should return one line of input as bytes.</source>
          <target state="translated">&lt;a href=&quot;#tokenize.tokenize&quot;&gt; &lt;code&gt;tokenize()&lt;/code&gt; &lt;/a&gt; 발생기는 하나의 인자 요구 &lt;em&gt;의 readline&lt;/em&gt; 은 AS와 동일한 인터페이스를 제공하는 호출 객체 여야 &lt;a href=&quot;io#io.IOBase.readline&quot;&gt; &lt;code&gt;io.IOBase.readline()&lt;/code&gt; &lt;/a&gt; 파일 오브젝트의 방법. 함수를 호출 할 때마다 한 줄의 입력을 바이트로 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="19a1fb9e075526300ca51090f919c11430914bb8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tracemalloc.Snapshot.traces&quot;&gt;&lt;code&gt;Snapshot.traces&lt;/code&gt;&lt;/a&gt; attribute is a sequence of &lt;a href=&quot;#tracemalloc.Trace&quot;&gt;&lt;code&gt;Trace&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.Snapshot.traces&quot;&gt; &lt;code&gt;Snapshot.traces&lt;/code&gt; 의&lt;/a&gt; 속성의 순서입니다 &lt;a href=&quot;#tracemalloc.Trace&quot;&gt; &lt;code&gt;Trace&lt;/code&gt; &lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="332c59a71d42e936b120ee2869f6034aae7ee7c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tracemalloc.Trace.traceback&quot;&gt;&lt;code&gt;Trace.traceback&lt;/code&gt;&lt;/a&gt; attribute is an instance of &lt;a href=&quot;#tracemalloc.Traceback&quot;&gt;&lt;code&gt;Traceback&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.Trace.traceback&quot;&gt; &lt;code&gt;Trace.traceback&lt;/code&gt; 의&lt;/a&gt; 속성의 인스턴스 &lt;a href=&quot;#tracemalloc.Traceback&quot;&gt; &lt;code&gt;Traceback&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9a6bad6d294ac9422d316c91034858a33f66eaed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tracemalloc.Traceback&quot;&gt;&lt;code&gt;Traceback&lt;/code&gt;&lt;/a&gt; class is a sequence of &lt;a href=&quot;#tracemalloc.Frame&quot;&gt;&lt;code&gt;Frame&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.Traceback&quot;&gt; &lt;code&gt;Traceback&lt;/code&gt; &lt;/a&gt; 클래스의 순서입니다 &lt;a href=&quot;#tracemalloc.Frame&quot;&gt; &lt;code&gt;Frame&lt;/code&gt; &lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="f3406051299b4b3da8e9e48c0ce7606278d24f47" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt;&lt;code&gt;take_snapshot()&lt;/code&gt;&lt;/a&gt; function creates a snapshot instance.</source>
          <target state="translated">&lt;a href=&quot;#tracemalloc.take_snapshot&quot;&gt; &lt;code&gt;take_snapshot()&lt;/code&gt; &lt;/a&gt; 함수는 스냅 인스턴스를 생성한다.</target>
        </trans-unit>
        <trans-unit id="84c2a6d4ca49213209ef75d3df2f3a2fd2b30c47" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#transports&quot;&gt;Transports&lt;/a&gt; section documents asyncio &lt;a href=&quot;#asyncio.BaseTransport&quot;&gt;&lt;code&gt;BaseTransport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.ReadTransport&quot;&gt;&lt;code&gt;ReadTransport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.WriteTransport&quot;&gt;&lt;code&gt;WriteTransport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.Transport&quot;&gt;&lt;code&gt;Transport&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#asyncio.DatagramTransport&quot;&gt;&lt;code&gt;DatagramTransport&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#asyncio.SubprocessTransport&quot;&gt;&lt;code&gt;SubprocessTransport&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">&lt;a href=&quot;#transports&quot;&gt;수송선&lt;/a&gt; asyncio 부 문서 &lt;a href=&quot;#asyncio.BaseTransport&quot;&gt; &lt;code&gt;BaseTransport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.ReadTransport&quot;&gt; &lt;code&gt;ReadTransport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.WriteTransport&quot;&gt; &lt;code&gt;WriteTransport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.Transport&quot;&gt; &lt;code&gt;Transport&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#asyncio.DatagramTransport&quot;&gt; &lt;code&gt;DatagramTransport&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.SubprocessTransport&quot;&gt; &lt;code&gt;SubprocessTransport&lt;/code&gt; 의&lt;/a&gt; 클래스.</target>
        </trans-unit>
        <trans-unit id="45e6a04779a2aac298a7345925b878b31f2605be" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#turtle.Shape&quot;&gt;&lt;code&gt;Shape&lt;/code&gt;&lt;/a&gt; class is used internally by the &lt;a href=&quot;#turtle.register_shape&quot;&gt;&lt;code&gt;register_shape()&lt;/code&gt;&lt;/a&gt; method in different ways. The application programmer has to deal with the Shape class &lt;em&gt;only&lt;/em&gt; when using compound shapes like shown above!</source>
          <target state="translated">&lt;a href=&quot;#turtle.Shape&quot;&gt; &lt;code&gt;Shape&lt;/code&gt; &lt;/a&gt; 클래스는 내부적으로 사용 &lt;a href=&quot;#turtle.register_shape&quot;&gt; &lt;code&gt;register_shape()&lt;/code&gt; &lt;/a&gt; 다른 방법으로하는 방법. 응용 프로그램 프로그래머는 위에 표시된 것처럼 복합 모양을 &lt;em&gt;사용할&lt;/em&gt; 때에 &lt;em&gt;만&lt;/em&gt; Shape 클래스를 처리해야합니다 !</target>
        </trans-unit>
        <trans-unit id="405810328337c79336080d4bbff10bf81c77b04f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#turtle.TurtleScreen&quot;&gt;&lt;code&gt;TurtleScreen&lt;/code&gt;&lt;/a&gt; class defines graphics windows as a playground for the drawing turtles. Its constructor needs a &lt;code&gt;tkinter.Canvas&lt;/code&gt; or a &lt;a href=&quot;#turtle.ScrolledCanvas&quot;&gt;&lt;code&gt;ScrolledCanvas&lt;/code&gt;&lt;/a&gt; as argument. It should be used when &lt;a href=&quot;#module-turtle&quot;&gt;&lt;code&gt;turtle&lt;/code&gt;&lt;/a&gt; is used as part of some application.</source>
          <target state="translated">&lt;a href=&quot;#turtle.TurtleScreen&quot;&gt; &lt;code&gt;TurtleScreen&lt;/code&gt; 의&lt;/a&gt; 드로잉 거북이 놀이터 등의 클래스를 정의 그래픽 창. 생성자는 인수로 &lt;code&gt;tkinter.Canvas&lt;/code&gt; 또는 &lt;a href=&quot;#turtle.ScrolledCanvas&quot;&gt; &lt;code&gt;ScrolledCanvas&lt;/code&gt; &lt;/a&gt; 가 필요합니다 . &lt;a href=&quot;#module-turtle&quot;&gt; &lt;code&gt;turtle&lt;/code&gt; &lt;/a&gt; 가 일부 응용 프로그램의 일부로 사용될 때 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="5f7817a294561249109e0213cb886fb9a394f719" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#typing.Generic&quot;&gt;&lt;code&gt;Generic&lt;/code&gt;&lt;/a&gt; base class defines &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__class_getitem__&quot;&gt;&lt;code&gt;__class_getitem__()&lt;/code&gt;&lt;/a&gt; so that &lt;code&gt;LoggedVar[t]&lt;/code&gt; is valid as a type:</source>
          <target state="translated">&lt;a href=&quot;#typing.Generic&quot;&gt; &lt;code&gt;Generic&lt;/code&gt; &lt;/a&gt; 기본 클래스는 정의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__class_getitem__&quot;&gt; &lt;code&gt;__class_getitem__()&lt;/code&gt; &lt;/a&gt; 되도록 &lt;code&gt;LoggedVar[t]&lt;/code&gt; 형태로서 유효하다 :</target>
        </trans-unit>
        <trans-unit id="bdbc7c7538faa9b8b179a5ae34651133e53b396a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.TestCase&quot;&gt;&lt;code&gt;TestCase&lt;/code&gt;&lt;/a&gt; class provides several assert methods to check for and report failures. The following table lists the most commonly used methods (see the tables below for more assert methods):</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase&quot;&gt; &lt;code&gt;TestCase&lt;/code&gt; &lt;/a&gt; 클래스는과 보고서의 오류를 확인하기 위해 여러 어설 션 방법을 제공합니다. 다음 표는 가장 일반적으로 사용되는 방법을 보여줍니다 (자세한 방법은 아래 표 참조).</target>
        </trans-unit>
        <trans-unit id="357849b93faca6354c3d4ac37300068296f06948" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt;&lt;code&gt;assertEqual()&lt;/code&gt;&lt;/a&gt; method dispatches the equality check for objects of the same type to different type-specific methods. These methods are already implemented for most of the built-in types, but it&amp;rsquo;s also possible to register new methods using &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt;&lt;code&gt;addTypeEqualityFunc()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.assertEqual&quot;&gt; &lt;code&gt;assertEqual()&lt;/code&gt; &lt;/a&gt; 메소드는 다른 유형의 특정 방법에 동일한 타입의 객체에 대한 동등 검사를 전달. 이러한 메소드는 대부분의 내장 유형에 대해 이미 구현되었지만 &lt;a href=&quot;#unittest.TestCase.addTypeEqualityFunc&quot;&gt; &lt;code&gt;addTypeEqualityFunc()&lt;/code&gt; &lt;/a&gt; 사용하여 새 메소드를 등록 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="22637af39afc56e8ff037ad10c9f11d9befcbb2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt;&lt;code&gt;setUp()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt;&lt;code&gt;tearDown()&lt;/code&gt;&lt;/a&gt; methods allow you to define instructions that will be executed before and after each test method. They are covered in more detail in the section &lt;a href=&quot;#organizing-tests&quot;&gt;Organizing test code&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestCase.setUp&quot;&gt; &lt;code&gt;setUp()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#unittest.TestCase.tearDown&quot;&gt; &lt;code&gt;tearDown()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하면 이전에 각 시험 방법 후 실행됩니다 지침을 정의 할 수 있습니다. &lt;a href=&quot;#organizing-tests&quot;&gt;테스트 코드 구성&lt;/a&gt; 섹션에서 자세히 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="dc1c6cadd0b004eb6997ad3ea10089824eac359a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.TestLoader&quot;&gt;&lt;code&gt;TestLoader&lt;/code&gt;&lt;/a&gt; class is used to create test suites from classes and modules. Normally, there is no need to create an instance of this class; the &lt;a href=&quot;#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; module provides an instance that can be shared as &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt;&lt;code&gt;unittest.defaultTestLoader&lt;/code&gt;&lt;/a&gt;. Using a subclass or instance, however, allows customization of some configurable properties.</source>
          <target state="translated">&lt;a href=&quot;#unittest.TestLoader&quot;&gt; &lt;code&gt;TestLoader&lt;/code&gt; 의&lt;/a&gt; 클래스는 클래스와 모듈의 테스트 스위트를 만드는 데 사용됩니다. 일반적으로이 클래스의 인스턴스를 만들 필요가 없습니다. &lt;a href=&quot;#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 모듈로 공유 될 수있는 예를 제공 &lt;a href=&quot;#unittest.defaultTestLoader&quot;&gt; &lt;code&gt;unittest.defaultTestLoader&lt;/code&gt; 를&lt;/a&gt; . 그러나 서브 클래스 또는 인스턴스를 사용하면 구성 가능한 일부 특성을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8501dc081aeb30c81ae92c0d0e04e0c41cb84669" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt;&lt;code&gt;DEFAULT&lt;/code&gt;&lt;/a&gt; object is a pre-created sentinel (actually &lt;code&gt;sentinel.DEFAULT&lt;/code&gt;). It can be used by &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt; functions to indicate that the normal return value should be used.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.DEFAULT&quot;&gt; &lt;code&gt;DEFAULT&lt;/code&gt; 의&lt;/a&gt; 목적은 미리 만들어진 센티넬 (실제로 &lt;code&gt;sentinel.DEFAULT&lt;/code&gt; ). &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 함수는 일반 반환 값을 사용해야 함을 나타내는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdcfd4dbf05f3ea1376b30902339d7b1d03f8370" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt; classes have support for mocking magic methods. See &lt;a href=&quot;#magic-methods&quot;&gt;magic methods&lt;/a&gt; for the full details.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 수업 마법 방법을 조롱에 대한 지원이있다. 자세한 내용은 &lt;a href=&quot;#magic-methods&quot;&gt;마술 방법&lt;/a&gt; 을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="5e26f823852082cdcb5967e9b535492e0c1c671b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; decorator / context manager makes it easy to mock classes or objects in a module under test. The object you specify will be replaced with a mock (or other object) during the test and restored when the test ends:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 장식 / 컨텍스트 매니저는 테스트중인 모듈에서 모의 클래스 나 개체에 쉽게이를 수 있습니다. 지정한 객체는 테스트 도중 모의 (또는 다른 객체)로 바뀌고 테스트가 끝나면 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="80a80259bfce823ad699c29717dead32645dea68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; decorators makes it easy to temporarily replace classes in a particular module with a &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt; object. By default &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; will create a &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt; for you. You can specify an alternative class of &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt; using the &lt;em&gt;new_callable&lt;/em&gt; argument to &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 데코레이터 일시적으로 특정 모듈에서 클래스를 쉽게 교체를하게 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 객체입니다. 기본적으로 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 을 생성 합니다. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; new_callable&lt;/em&gt; 인수를 사용하여 대체 &lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 클래스를 지정할 수 있습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="24ec41b5639b3ee7a1f0da7eb3430610465199f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; class offers one additional method that should be overloaded to provide the appropriate behavior:</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; 를 하부&lt;/a&gt; 적절한 동작을 제공하는 오버로드해야 클래스 이벤트 하나 개의 추가 방법 :</target>
        </trans-unit>
        <trans-unit id="19fc1b684f8e8cb021e12bf33c0c383c6acc7662" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt;&lt;code&gt;OpenerDirector&lt;/code&gt;&lt;/a&gt; class opens URLs via &lt;a href=&quot;#urllib.request.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt;s chained together. It manages the chaining of handlers, and recovery from errors.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.OpenerDirector&quot;&gt; &lt;code&gt;OpenerDirector&lt;/code&gt; 의&lt;/a&gt; 클래스를 통해 URL을 엽니 다 &lt;a href=&quot;#urllib.request.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 의 연쇄 함께. 핸들러 체인과 오류 복구를 관리합니다.</target>
        </trans-unit>
        <trans-unit id="add80da97c67b3a9dd408516d121f455497e4bfb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt;&lt;code&gt;ProxyHandler&lt;/code&gt;&lt;/a&gt; will have a method &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; for every &lt;em&gt;protocol&lt;/em&gt; which has a proxy in the &lt;em&gt;proxies&lt;/em&gt; dictionary given in the constructor. The method will modify requests to go through the proxy, by calling &lt;code&gt;request.set_proxy()&lt;/code&gt;, and call the next handler in the chain to actually execute the protocol.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.ProxyHandler&quot;&gt; &lt;code&gt;ProxyHandler&lt;/code&gt; 는&lt;/a&gt; 방법 것 &lt;code&gt;&amp;lt;protocol&amp;gt;_open()&lt;/code&gt; 마다위한 &lt;em&gt;프로토콜&lt;/em&gt; 에서 프록시 갖는 &lt;em&gt;프록시&lt;/em&gt; 생성자에서 지정된 사전. 이 메소드는 &lt;code&gt;request.set_proxy()&lt;/code&gt; 를 호출하여 프록시를 통과하는 요청을 수정 하고 체인에서 다음 핸들러를 호출하여 실제로 프로토콜을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cdd99a9142cb9c6c14e02abc9d69ca1feaaea19d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#urllib.request.urlopen&quot;&gt;&lt;code&gt;urlopen()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt;&lt;code&gt;urlretrieve()&lt;/code&gt;&lt;/a&gt; functions can cause arbitrarily long delays while waiting for a network connection to be set up. This means that it is difficult to build an interactive Web client using these functions without using threads.</source>
          <target state="translated">&lt;a href=&quot;#urllib.request.urlopen&quot;&gt; &lt;code&gt;urlopen()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#urllib.request.urlretrieve&quot;&gt; &lt;code&gt;urlretrieve()&lt;/code&gt; &lt;/a&gt; 네트워크 연결을 위해 대기하는 것은 설정하는 동안 기능을 임의로 오래 지연 될 수 있습니다. 이는 스레드를 사용하지 않고 이러한 기능을 사용하여 대화식 웹 클라이언트를 빌드하는 것이 어렵다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ff68c745bc211e58099a0292f41586aed45a05a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; class accepts the following keyword arguments on instantiation:</source>
          <target state="translated">&lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; 의&lt;/a&gt; 클래스 인스턴스에서 다음 키워드 인수를 허용합니다</target>
        </trans-unit>
        <trans-unit id="59d615e0d009ca2a9c92a3001e2f4beae3b2a481" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#warnings.catch_warnings&quot;&gt;&lt;code&gt;catch_warnings&lt;/code&gt;&lt;/a&gt; manager works by replacing and then later restoring the module&amp;rsquo;s &lt;a href=&quot;#warnings.showwarning&quot;&gt;&lt;code&gt;showwarning()&lt;/code&gt;&lt;/a&gt; function and internal list of filter specifications. This means the context manager is modifying global state and therefore is not thread-safe.</source>
          <target state="translated">&lt;a href=&quot;#warnings.catch_warnings&quot;&gt; &lt;code&gt;catch_warnings&lt;/code&gt; 의&lt;/a&gt; 관리자가 대체하고 나중에 복원 모듈의 작동에 의해 &lt;a href=&quot;#warnings.showwarning&quot;&gt; &lt;code&gt;showwarning()&lt;/code&gt; &lt;/a&gt; 함수 및 필터 사양의 내부 목록. 이는 컨텍스트 관리자가 글로벌 상태를 수정 중이므로 스레드로부터 안전하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5a863a8afee1888f928b0e90399ac841fb612398" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#wave.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; function may be used in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement. When the &lt;code&gt;with&lt;/code&gt; block completes, the &lt;a href=&quot;#wave.Wave_read.close&quot;&gt;&lt;code&gt;Wave_read.close()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#wave.Wave_write.close&quot;&gt;&lt;code&gt;Wave_write.close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">&lt;a href=&quot;#wave.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 함수는 사용할 수있다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문. 경우 &lt;code&gt;with&lt;/code&gt; 블록 완료의 &lt;a href=&quot;#wave.Wave_read.close&quot;&gt; &lt;code&gt;Wave_read.close()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#wave.Wave_write.close&quot;&gt; &lt;code&gt;Wave_write.close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출된다.</target>
        </trans-unit>
        <trans-unit id="e4ee02f8ac6deb5da7b63ba5cd9b059abe2fc64c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#winreg.DeleteKeyEx&quot;&gt;&lt;code&gt;DeleteKeyEx()&lt;/code&gt;&lt;/a&gt; function is implemented with the RegDeleteKeyEx Windows API function, which is specific to 64-bit versions of Windows. See the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724847%28VS.85%29.aspx&quot;&gt;RegDeleteKeyEx documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#winreg.DeleteKeyEx&quot;&gt; &lt;code&gt;DeleteKeyEx()&lt;/code&gt; &lt;/a&gt; 함수는 64 비트 버전의 Windows에 해당되는 RegDeleteKeyEx Windows API 함수로 구현됩니다. &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms724847%28VS.85%29.aspx&quot;&gt;RegDeleteKeyEx 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="399aa159694ce19221f03cc60c1a299edffa9d06" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xdrlib.Unpacker&quot;&gt;&lt;code&gt;Unpacker&lt;/code&gt;&lt;/a&gt; class offers the following methods:</source>
          <target state="translated">&lt;a href=&quot;#xdrlib.Unpacker&quot;&gt; &lt;code&gt;Unpacker&lt;/code&gt; 에의&lt;/a&gt; 클래스 이벤트 다음과 같은 방법 :</target>
        </trans-unit>
        <trans-unit id="76cf68ae7957b35e83f23ece2b3309062cdda7f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; function can take either a filename or an open file object.</source>
          <target state="translated">&lt;a href=&quot;#xml.dom.minidom.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 함수는 파일 이름이나 열린 파일 객체 중 하나를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="42363806b6749b6e566d7bb04cf5b64ac5fd77fa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xml.etree.ElementTree.SubElement&quot;&gt;&lt;code&gt;SubElement()&lt;/code&gt;&lt;/a&gt; function also provides a convenient way to create new sub-elements for a given element:</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.SubElement&quot;&gt; &lt;code&gt;SubElement()&lt;/code&gt; &lt;/a&gt; 함수는, 주어진 요소에 대한 새로운 서브 요소를 생성하는 편리한 방법을 제공한다 :</target>
        </trans-unit>
        <trans-unit id="f5c03be79e189e48f1592d5b76ef8723131ebf44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xml.sax.SAXException&quot;&gt;&lt;code&gt;SAXException&lt;/code&gt;&lt;/a&gt; exception class supports the following methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.SAXException&quot;&gt; &lt;code&gt;SAXException&lt;/code&gt; &lt;/a&gt; 예외 클래스는 다음과 같은 방법을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="b7f09a811b6f16f6e6b41e1749d0111bd5475969" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt;&lt;code&gt;XMLReader&lt;/code&gt;&lt;/a&gt; interface supports the following methods:</source>
          <target state="translated">&lt;a href=&quot;#xml.sax.xmlreader.XMLReader&quot;&gt; &lt;code&gt;XMLReader&lt;/code&gt; &lt;/a&gt; 인터페이스는 다음과 같은 방법을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="71db7881f16ee841e40c7459de9cb399a3551b6d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xmlrpc.client.MultiCall&quot;&gt;&lt;code&gt;MultiCall&lt;/code&gt;&lt;/a&gt; object provides a way to encapsulate multiple calls to a remote server into a single request &lt;a href=&quot;#id6&quot; id=&quot;id5&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.client.MultiCall&quot;&gt; &lt;code&gt;MultiCall&lt;/code&gt; &lt;/a&gt; 객체는 하나의 요청으로 원격 서버에 여러 개의 호출을 캡슐화하는 방법을 제공합니다 &lt;a href=&quot;#id6&quot; id=&quot;id5&quot;&gt;1&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="622abcb4c5e3f0d1c6a6c9a81ff5668467677198" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt; class can be used to handle XML-RPC requests sent to Python CGI scripts.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt; 의&lt;/a&gt; 클래스는 파이썬 CGI 스크립트로 전송 핸들 XML-RPC 요청에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95f80fe9bc84ab8e564acf727e1d0660cdf38213" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt; class is derived from &lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt;&lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt;&lt;/a&gt; and provides a means of creating self-documenting, XML-RPC CGI scripts. HTTP POST requests are handled as XML-RPC method calls. HTTP GET requests are handled by generating pydoc-style HTML documentation. This allows a server to provide its own web-based documentation.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.server.DocCGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;DocCGIXMLRPCRequestHandler&lt;/code&gt; 의&lt;/a&gt; 클래스에서 파생 &lt;a href=&quot;#xmlrpc.server.CGIXMLRPCRequestHandler&quot;&gt; &lt;code&gt;CGIXMLRPCRequestHandler&lt;/code&gt; &lt;/a&gt; 자기 문서화, XML-RPC의 CGI 스크립트를 생성하는 방법을 제공합니다. HTTP POST 요청은 XML-RPC 메서드 호출로 처리됩니다. pydoc 스타일 HTML 문서를 생성하여 HTTP GET 요청을 처리합니다. 이를 통해 서버는 자체 웹 기반 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c0042da7248e1a56ffe3ff0e18f1d7d371d991" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt;&lt;code&gt;DocXMLRPCServer&lt;/code&gt;&lt;/a&gt; class is derived from &lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt;&lt;code&gt;SimpleXMLRPCServer&lt;/code&gt;&lt;/a&gt; and provides a means of creating self-documenting, stand alone XML-RPC servers. HTTP POST requests are handled as XML-RPC method calls. HTTP GET requests are handled by generating pydoc-style HTML documentation. This allows a server to provide its own web-based documentation.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.server.DocXMLRPCServer&quot;&gt; &lt;code&gt;DocXMLRPCServer&lt;/code&gt; 의&lt;/a&gt; 클래스에서 파생 &lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt; &lt;code&gt;SimpleXMLRPCServer&lt;/code&gt; &lt;/a&gt; 하고 그 자체로 문서를 작성하는 수단을 제공, 혼자 XML-RPC 서버를 서있다. HTTP POST 요청은 XML-RPC 메서드 호출로 처리됩니다. pydoc 스타일 HTML 문서를 생성하여 HTTP GET 요청을 처리합니다. 이를 통해 서버는 자체 웹 기반 문서를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17468b965845f5f1ed57aaffe567cc32c6433ece" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt;&lt;code&gt;SimpleXMLRPCServer&lt;/code&gt;&lt;/a&gt; class is based on &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt;&lt;code&gt;socketserver.TCPServer&lt;/code&gt;&lt;/a&gt; and provides a means of creating simple, stand alone XML-RPC servers.</source>
          <target state="translated">&lt;a href=&quot;#xmlrpc.server.SimpleXMLRPCServer&quot;&gt; &lt;code&gt;SimpleXMLRPCServer&lt;/code&gt; 의&lt;/a&gt; 클래스를 기반으로 &lt;a href=&quot;socketserver#socketserver.TCPServer&quot;&gt; &lt;code&gt;socketserver.TCPServer&lt;/code&gt; &lt;/a&gt; 간단한을 만들어줍니다 단독 XML-RPC 서버를 서있다.</target>
        </trans-unit>
        <trans-unit id="5346c90ac636426e0f2dec193ef68d35f72083a2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#zipfile.PyZipFile&quot;&gt;&lt;code&gt;PyZipFile&lt;/code&gt;&lt;/a&gt; constructor takes the same parameters as the &lt;a href=&quot;#zipfile.ZipFile&quot;&gt;&lt;code&gt;ZipFile&lt;/code&gt;&lt;/a&gt; constructor, and one additional parameter, &lt;em&gt;optimize&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile&quot;&gt; &lt;code&gt;PyZipFile&lt;/code&gt; 의&lt;/a&gt; 생성자는 동일한 파라미터 얻어 &lt;a href=&quot;#zipfile.ZipFile&quot;&gt; &lt;code&gt;ZipFile&lt;/code&gt; 에의&lt;/a&gt; 생성자, 그리고 하나 개의 추가 파라미터 &lt;em&gt;의 최적화를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="48674c8ee4e2fea87426b46d821d737e70e4528d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#zipfile.PyZipFile.writepy&quot;&gt;&lt;code&gt;writepy()&lt;/code&gt;&lt;/a&gt; method makes archives with file names like this:</source>
          <target state="translated">&lt;a href=&quot;#zipfile.PyZipFile.writepy&quot;&gt; &lt;code&gt;writepy()&lt;/code&gt; &lt;/a&gt; 메소드는이 같은 파일 이름으로 아카이브를 만드는 :</target>
        </trans-unit>
        <trans-unit id="ed921ba78ac31d3ba4a15509e53132e71f4cceb4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#zipfile.ZipFile.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#zipfile.ZipFile.extract&quot;&gt;&lt;code&gt;extract()&lt;/code&gt;&lt;/a&gt; methods can take a filename or a &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt;&lt;code&gt;ZipInfo&lt;/code&gt;&lt;/a&gt; object. You will appreciate this when trying to read a ZIP file that contains members with duplicate names.</source>
          <target state="translated">&lt;a href=&quot;#zipfile.ZipFile.open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#zipfile.ZipFile.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#zipfile.ZipFile.extract&quot;&gt; &lt;code&gt;extract()&lt;/code&gt; &lt;/a&gt; 메소드는 파일 이름이나 취할 수 &lt;a href=&quot;#zipfile.ZipInfo&quot;&gt; &lt;code&gt;ZipInfo&lt;/code&gt; &lt;/a&gt; 개체. 중복 이름을 가진 멤버가 포함 된 ZIP 파일을 읽으려고 할 때이 점에 감사합니다.</target>
        </trans-unit>
        <trans-unit id="385ef4a7dae3b567bb461e659f8acf4bb71f699a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#zipimport.zipimporter.archive&quot;&gt;&lt;code&gt;archive&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#zipimport.zipimporter.prefix&quot;&gt;&lt;code&gt;prefix&lt;/code&gt;&lt;/a&gt; attributes, when combined with a slash, equal the original &lt;em&gt;archivepath&lt;/em&gt; argument given to the &lt;a href=&quot;#zipimport.zipimporter&quot;&gt;&lt;code&gt;zipimporter&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;a href=&quot;#zipimport.zipimporter.archive&quot;&gt; &lt;code&gt;archive&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#zipimport.zipimporter.prefix&quot;&gt; &lt;code&gt;prefix&lt;/code&gt; &lt;/a&gt; 슬래시와 결합 속성은 원래 동일 &lt;em&gt;archivepath 매를&lt;/em&gt; 받는 지정된 인수 &lt;a href=&quot;#zipimport.zipimporter&quot;&gt; &lt;code&gt;zipimporter&lt;/code&gt; 의&lt;/a&gt; 생성자를.</target>
        </trans-unit>
        <trans-unit id="5ab66251f09f4901c71bf052d319006ae2f26849" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;array#module-array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; module supports efficient storage of basic data types like 32-bit integers and IEEE754 double-precision floating values.</source>
          <target state="translated">&lt;a href=&quot;array#module-array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 모듈은 32 비트 정수 IEEE754 및 배정 밀도 부동 값과 같은 기본 데이터 타입의 효율적인 스토리지를 지원한다.</target>
        </trans-unit>
        <trans-unit id="7fab3709a4de46037f0d17afafd44aa66a4e53d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; module is designed to be portable, but some platforms have subtle differences and limitations due to the platforms&amp;rsquo; underlying architecture and capabilities.</source>
          <target state="translated">&lt;a href=&quot;asyncio#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 모듈은 휴대 할 수 있도록 설계하지만, 일부 플랫폼 인해 구조와 기능을 기본 플랫폼 '에 미묘한 차이와 한계를 가지고있다.</target>
        </trans-unit>
        <trans-unit id="f0ca72df64b9d0808c1acdb7553cc5f4e1ad030c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; module supports &lt;a href=&quot;#ssl-nonblocking&quot;&gt;non-blocking SSL sockets&lt;/a&gt; and provides a higher level API. It polls for events using the &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; module and handles &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt;&lt;code&gt;SSLWantWriteError&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt;&lt;code&gt;SSLWantReadError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt;&lt;code&gt;BlockingIOError&lt;/code&gt;&lt;/a&gt; exceptions. It runs the SSL handshake asynchronously as well.</source>
          <target state="translated">&lt;a href=&quot;asyncio#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; &lt;/a&gt; 모듈 지원은 &lt;a href=&quot;#ssl-nonblocking&quot;&gt;SSL 소켓을 비 차단&lt;/a&gt; 하고 높은 수준의 API를 제공한다. &lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 이벤트를 폴링 하고 &lt;a href=&quot;#ssl.SSLWantWriteError&quot;&gt; &lt;code&gt;SSLWantWriteError&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ssl.SSLWantReadError&quot;&gt; &lt;code&gt;SSLWantReadError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#BlockingIOError&quot;&gt; &lt;code&gt;BlockingIOError&lt;/code&gt; &lt;/a&gt; 예외를 처리합니다. SSL 핸드 셰이크도 비동기 적으로 실행합니다.</target>
        </trans-unit>
        <trans-unit id="388449a7ece27291eb76f144920ee0e139befa4a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-dev#asyncio-debug-mode&quot;&gt;debug mode of asyncio&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;asyncio-dev#asyncio-debug-mode&quot;&gt;asyncio&lt;/a&gt; 의 디버그 모드입니다 .</target>
        </trans-unit>
        <trans-unit id="269ec5e7278f4c68c07dc0423317c0a42c97b603" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;Concurrency and multithreading in asyncio&lt;/a&gt; section.</source>
          <target state="translated">&lt;a href=&quot;asyncio-dev#asyncio-multithreading&quot;&gt;asyncio&lt;/a&gt; 섹션 의 동시성 및 멀티 스레딩 섹션</target>
        </trans-unit>
        <trans-unit id="f6f1264da62220cbd3de89ae3749a348b0db15c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-eventloop#asyncio-example-watch-fd&quot;&gt;watch a file descriptor for read events&lt;/a&gt; example uses the low-level &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; method to register an FD.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio-example-watch-fd&quot;&gt;시계는 읽기 이벤트를위한 파일 기술자&lt;/a&gt; 예는 낮은 수준의 사용 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt; FD의를 등록하는 방법을.</target>
        </trans-unit>
        <trans-unit id="04932ed7777f762e8938b825eb1d0532fcd37d8f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-eventloop#asyncio-example-watch-fd&quot;&gt;watch a file descriptor for read events&lt;/a&gt; example uses the low-level &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; method to watch a file descriptor.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio-example-watch-fd&quot;&gt;시계는 읽기 이벤트를위한 파일 기술자&lt;/a&gt; 예는 낮은 수준의 사용 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt; 파일 기술자를 보는 방법.</target>
        </trans-unit>
        <trans-unit id="e03d070a4817aa0536e984c1c7295309a52d285f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt;&lt;code&gt;loop.add_reader()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_writer&quot;&gt;&lt;code&gt;loop.add_writer()&lt;/code&gt;&lt;/a&gt; methods are not supported.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_reader&quot;&gt; &lt;code&gt;loop.add_reader()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.add_writer&quot;&gt; &lt;code&gt;loop.add_writer()&lt;/code&gt; &lt;/a&gt; 메소드는 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="85a7b8ebbd28d502ad8092d4c90022d59420b313" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt;&lt;code&gt;loop.run_in_executor()&lt;/code&gt;&lt;/a&gt; method can be used with a &lt;a href=&quot;concurrent.futures#concurrent.futures.ThreadPoolExecutor&quot;&gt;&lt;code&gt;concurrent.futures.ThreadPoolExecutor&lt;/code&gt;&lt;/a&gt; to execute blocking code in a different OS thread without blocking the OS thread that the event loop runs in.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt; &lt;code&gt;loop.run_in_executor()&lt;/code&gt; &lt;/a&gt; 방법은 함께 사용할 수 &lt;a href=&quot;concurrent.futures#concurrent.futures.ThreadPoolExecutor&quot;&gt; &lt;code&gt;concurrent.futures.ThreadPoolExecutor&lt;/code&gt; &lt;/a&gt; 이벤트 루프에서 실행되는 OS 스레드를 차단하지 않고 다른 OS 스레드 블록 코드를 실행.</target>
        </trans-unit>
        <trans-unit id="e39552b2c33bb4965caf4401d681e139ecd60b45" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-policy#asyncio.AbstractEventLoopPolicy.set_child_watcher&quot;&gt;&lt;code&gt;policy.set_child_watcher()&lt;/code&gt;&lt;/a&gt; function is also not supported, as &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; has a different mechanism to watch child processes.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 에는 하위 프로세스를 감시하는 다른 메커니즘 이 &lt;a href=&quot;asyncio-policy#asyncio.AbstractEventLoopPolicy.set_child_watcher&quot;&gt; &lt;code&gt;policy.set_child_watcher()&lt;/code&gt; &lt;/a&gt; 함수도 지원되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0117effbf73dedbb4c08f9e6aa6bb84a360194f4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-protocol#asyncio-example-create-connection&quot;&gt;register an open socket to wait for data using a protocol&lt;/a&gt; example uses a low-level protocol and the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;asyncio-protocol#asyncio-example-create-connection&quot;&gt;프로토콜 사용 데이터 대기 개방형 소켓 등록&lt;/a&gt; 예는 낮은 수준의 프로토콜과 사용 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="bdf0529b63d84eaad00de25e6995746687f10495" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-client-protocol&quot;&gt;TCP echo client protocol&lt;/a&gt; example uses the low-level &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt;&lt;code&gt;loop.create_connection()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-client-protocol&quot;&gt;TCP 에코 클라이언트 프로토콜의&lt;/a&gt; 예는 저급 사용 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_connection&quot;&gt; &lt;code&gt;loop.create_connection()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="69fda5584336079e986631f089241b677491bf9c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-server-protocol&quot;&gt;TCP echo server protocol&lt;/a&gt; example uses the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt;&lt;code&gt;loop.create_server()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;asyncio-protocol#asyncio-example-tcp-echo-server-protocol&quot;&gt;TCP 에코 서버 프로토콜의&lt;/a&gt; 예는 사용 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.create_server&quot;&gt; &lt;code&gt;loop.create_server()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="4855612a9a026751a928540ca2ac83567ab76bca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;register an open socket to wait for data using streams&lt;/a&gt; example uses high-level streams created by the &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; function in a coroutine.</source>
          <target state="translated">는 &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;데이터 스트림을 사용 기다릴 개방 소켓을 등록&lt;/a&gt; 의 예에 의해 작성된 스트림 고레벨 사용 &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 코 루틴의 기능.</target>
        </trans-unit>
        <trans-unit id="5fa7c63c53753a42c8dec77606ff72631f73707e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-stream#asyncio-tcp-echo-client-streams&quot;&gt;TCP echo client using streams&lt;/a&gt; example uses the high-level &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt;&lt;code&gt;asyncio.open_connection()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;asyncio-stream#asyncio-tcp-echo-client-streams&quot;&gt;스트림을 사용&lt;/a&gt; 하는 TCP 에코 클라이언트 예제는 고급 &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt; &lt;code&gt;asyncio.open_connection()&lt;/code&gt; &lt;/a&gt; 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c4874f91fc60a76f94308f7d5d35b0d0415366fd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-stream#asyncio-tcp-echo-server-streams&quot;&gt;TCP echo server using streams&lt;/a&gt; example uses the high-level &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt;&lt;code&gt;asyncio.start_server()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;asyncio-stream#asyncio-tcp-echo-server-streams&quot;&gt;스트림을 사용&lt;/a&gt; 하는 TCP 에코 서버 예제는 고급 &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt; &lt;code&gt;asyncio.start_server()&lt;/code&gt; &lt;/a&gt; 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e70447010538ebf052cf5086fd5a5c51be44e9a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt;&lt;code&gt;open_connection()&lt;/code&gt;&lt;/a&gt; function is a high-level alternative API. It returns a pair of (&lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt;) that can be used directly in async/await code.</source>
          <target state="translated">&lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt; &lt;code&gt;open_connection()&lt;/code&gt; &lt;/a&gt; 함수는 높은 수준의 대안 API입니다. 비동기 / 대기 코드에서 직접 사용할 수있는 ( &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; ) 쌍을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="aba9db86440cb3768db85740b3f75e621d8282f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt;&lt;code&gt;start_server()&lt;/code&gt;&lt;/a&gt; function is a higher-level alternative API that returns a pair of &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; that can be used in an async/await code.</source>
          <target state="translated">&lt;a href=&quot;asyncio-stream#asyncio.start_server&quot;&gt; &lt;code&gt;start_server()&lt;/code&gt; &lt;/a&gt; 함수는 상위 대체 API하다 복귀 한 쌍 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;asyncio-stream#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; 를&lt;/a&gt; 비동기 / AWAIT 코드에 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="3b03b65ebfef3d0e0cf7e8d7c48142c7bd3ed8f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asyncio-task#asyncio.sleep&quot;&gt;&lt;code&gt;asyncio.sleep()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;asyncio-task#asyncio.sleep&quot;&gt; &lt;code&gt;asyncio.sleep()&lt;/code&gt; &lt;/a&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="b052a492ced0457e8bdd97864405d6b419c03daa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;collections#module-collections&quot;&gt;&lt;code&gt;collections&lt;/code&gt;&lt;/a&gt; module has some concrete classes that derive from ABCs; these can, of course, be further derived. In addition, the &lt;a href=&quot;collections.abc#module-collections.abc&quot;&gt;&lt;code&gt;collections.abc&lt;/code&gt;&lt;/a&gt; submodule has some ABCs that can be used to test whether a class or instance provides a particular interface, for example, if it is hashable or if it is a mapping.</source>
          <target state="translated">&lt;a href=&quot;collections#module-collections&quot;&gt; &lt;code&gt;collections&lt;/code&gt; &lt;/a&gt; 모듈은 상식에서 파생 몇 가지 구체적인 클래스를 가지고; 이들은 물론 더 도출 될 수있다. 또한 &lt;a href=&quot;collections.abc#module-collections.abc&quot;&gt; &lt;code&gt;collections.abc&lt;/code&gt; &lt;/a&gt; 하위 모듈에는 클래스 나 인스턴스가 특정 인터페이스를 제공하는지 여부를 테스트하는 데 사용할 수있는 ABC가 있습니다 (예 : 해시 가능 여부 또는 매핑 여부).</target>
        </trans-unit>
        <trans-unit id="0c5e6186b5abd612a9a9b222bb05aec57b248739" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;copy#module-copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; module uses this protocol for shallow and deep copying operations.</source>
          <target state="translated">&lt;a href=&quot;copy#module-copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 모듈은 얕은 및 깊은 복사 작업이 프로토콜을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9bc670c86c2ecb0d326db3f2c349c930cae50785" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dataclasses#module-dataclasses&quot;&gt;&lt;code&gt;dataclasses&lt;/code&gt;&lt;/a&gt; module provides a decorator and functions for automatically adding generated special methods to user-defined classes.</source>
          <target state="translated">&lt;a href=&quot;dataclasses#module-dataclasses&quot;&gt; &lt;code&gt;dataclasses&lt;/code&gt; 의&lt;/a&gt; 모듈은 자동으로 사용자 정의 된 클래스 생성 특별한 방법을 추가 할 수있는 장식 및 기능을 제공한다.</target>
        </trans-unit>
        <trans-unit id="f66ecab62e66fb68cc92b1e6b7ad01f3b29ba8a6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package provides a standard parser that understands most email document structures, including MIME documents. You can pass the parser a bytes, string or file object, and the parser will return to you the root &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; instance of the object structure. For simple, non-MIME messages the payload of this root object will likely be a string containing the text of the message. For MIME messages, the root object will return &lt;code&gt;True&lt;/code&gt; from its &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt;&lt;code&gt;is_multipart()&lt;/code&gt;&lt;/a&gt; method, and the subparts can be accessed via the payload manipulation methods, such as &lt;a href=&quot;email.message#email.message.EmailMessage.get_body&quot;&gt;&lt;code&gt;get_body()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt;&lt;code&gt;iter_parts()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;email.message#email.message.EmailMessage.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 MIME 문서를 포함한 대부분의 이메일 문서의 구조를 이해하는 표준 파서를 제공합니다. 파서에 바이트, 문자열 또는 파일 객체를 전달하면 파서가 객체 구조 의 루트 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 인스턴스를 반환합니다 . MIME이 아닌 간단한 메시지의 경우이 루트 객체의 페이로드는 메시지 텍스트를 포함하는 문자열 일 수 있습니다. MIME 메시지의 경우 루트 객체는 &lt;a href=&quot;email.message#email.message.EmailMessage.is_multipart&quot;&gt; &lt;code&gt;is_multipart()&lt;/code&gt; &lt;/a&gt; 메서드 에서 &lt;code&gt;True&lt;/code&gt; 를 반환 하며 &lt;a href=&quot;email.message#email.message.EmailMessage.get_body&quot;&gt; &lt;code&gt;get_body()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;email.message#email.message.EmailMessage.iter_parts&quot;&gt; &lt;code&gt;iter_parts()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.message#email.message.EmailMessage.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 와 같은 페이로드 조작 방법을 통해 하위 파트에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d65549da0a6ac50abbe17e6dbe3a7106056321e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package provides some convenient encoders in its &lt;code&gt;encoders&lt;/code&gt; module. These encoders are actually used by the &lt;a href=&quot;email.mime#email.mime.audio.MIMEAudio&quot;&gt;&lt;code&gt;MIMEAudio&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;email.mime#email.mime.image.MIMEImage&quot;&gt;&lt;code&gt;MIMEImage&lt;/code&gt;&lt;/a&gt; class constructors to provide default encodings. All encoder functions take exactly one argument, the message object to encode. They usually extract the payload, encode it, and reset the payload to this newly encoded value. They should also set the &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; header as appropriate.</source>
          <target state="translated">&lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지는 몇 가지 편리한 인코더 제공 &lt;code&gt;encoders&lt;/code&gt; 모듈. 이러한 인코더는 실제로 &lt;a href=&quot;email.mime#email.mime.audio.MIMEAudio&quot;&gt; &lt;code&gt;MIMEAudio&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;email.mime#email.mime.image.MIMEImage&quot;&gt; &lt;code&gt;MIMEImage&lt;/code&gt; &lt;/a&gt; 클래스 생성자가 기본 인코딩을 제공 하는 데 사용됩니다 . 모든 인코더 함수는 인코딩 할 메시지 객체 인 정확히 하나의 인수를 취합니다. 일반적으로 페이로드를 추출하여 인코딩 한 다음 페이로드를 새로 인코딩 된 값으로 재설정합니다. 또한 &lt;em&gt;Content-Transfer-Encoding&lt;/em&gt; 헤더를 적절하게 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8de4e0a1545677ea0bebec40ff1e9c58b3f8edd3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;email#module-email&quot;&gt;&lt;code&gt;email&lt;/code&gt;&lt;/a&gt; package&amp;rsquo;s prime focus is the handling of email messages as described by the various email and MIME RFCs. However, the general format of email messages (a block of header fields each consisting of a name followed by a colon followed by a value, the whole block followed by a blank line and an arbitrary &amp;lsquo;body&amp;rsquo;), is a format that has found utility outside of the realm of email. Some of these uses conform fairly closely to the main email RFCs, some do not. Even when working with email, there are times when it is desirable to break strict compliance with the RFCs, such as generating emails that interoperate with email servers that do not themselves follow the standards, or that implement extensions you want to use in ways that violate the standards.</source>
          <target state="translated">&lt;a href=&quot;email#module-email&quot;&gt; &lt;code&gt;email&lt;/code&gt; &lt;/a&gt; 패키지의 주요 초점은 다양한 전자 메일 및 MIME RFC에 의해 설명 된 바와 같이 전자 메일 메시지의 처리이다. 그러나 전자 메일 메시지의 일반적인 형식 (이름, 콜론, 값, 전체 블록, 빈 줄 및 임의의 '본문'으로 구성되는 헤더 필드 블록)은 발견 된 형식입니다. 이메일 영역 밖의 유틸리티. 이러한 용도 중 일부는 기본 전자 메일 RFC와 상당히 유사하지만 일부는 그렇지 않습니다. 전자 메일을 사용할 때도 자체 표준을 따르지 않는 전자 메일 서버와 상호 운용되거나 전자 메일을 위반하는 방식으로 사용하려는 확장 기능을 구현하는 전자 메일 생성과 같이 RFC를 엄격하게 준수하는 것이 바람직한 경우가 있습니다. 표준.</target>
        </trans-unit>
        <trans-unit id="a50b634650fe68487172709d4f3225db627c42af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;functools#functools.cmp_to_key&quot;&gt;&lt;code&gt;functools.cmp_to_key()&lt;/code&gt;&lt;/a&gt; utility is available to convert a 2.x style &lt;em&gt;cmp&lt;/em&gt; function to a &lt;em&gt;key&lt;/em&gt; function.</source>
          <target state="translated">&lt;a href=&quot;functools#functools.cmp_to_key&quot;&gt; &lt;code&gt;functools.cmp_to_key()&lt;/code&gt; &lt;/a&gt; 유틸리티는 2.X 스타일 변환 할 수 있습니다 &lt;em&gt;CMP의&lt;/em&gt; A와 기능 &lt;em&gt;키&lt;/em&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="cb3b71eeb6c10fe4e1063ddf86b43b1331b19dbf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http.cookiejar#http.cookiejar.CookieJar&quot;&gt;&lt;code&gt;http.cookiejar.CookieJar&lt;/code&gt;&lt;/a&gt; in which cookies are stored.</source>
          <target state="translated">&lt;a href=&quot;http.cookiejar#http.cookiejar.CookieJar&quot;&gt; &lt;code&gt;http.cookiejar.CookieJar&lt;/code&gt; &lt;/a&gt; 쿠키가 저장되는.</target>
        </trans-unit>
        <trans-unit id="c912b7d4aed5c4dd186c5942bf55dc89d7ded472" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://aiosmtpd.readthedocs.io/&quot;&gt;aiosmtpd&lt;/a&gt; package is a recommended replacement for this module. It is based on &lt;a href=&quot;asyncio#module-asyncio&quot;&gt;&lt;code&gt;asyncio&lt;/code&gt;&lt;/a&gt; and provides a more straightforward API. &lt;a href=&quot;#module-smtpd&quot;&gt;&lt;code&gt;smtpd&lt;/code&gt;&lt;/a&gt; should be considered deprecated.</source>
          <target state="translated">&lt;a href=&quot;http://aiosmtpd.readthedocs.io/&quot;&gt;aiosmtpd의&lt;/a&gt; 패키지는이 모듈에 대한 권장 대체합니다. &lt;a href=&quot;asyncio#module-asyncio&quot;&gt; &lt;code&gt;asyncio&lt;/code&gt; 를&lt;/a&gt; 기반으로 하며보다 간단한 API를 제공합니다. &lt;a href=&quot;#module-smtpd&quot;&gt; &lt;code&gt;smtpd&lt;/code&gt; &lt;/a&gt; 는 더 이상 사용되지 않는 것으로 간주해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1784bfb338b8f4b79d0d75b7910d3ad4a01c0e2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://code.activestate.com/recipes/579000/&quot;&gt;linspace recipe&lt;/a&gt; shows how to implement a lazy version of range suitable for floating point applications.</source>
          <target state="translated">&lt;a href=&quot;http://code.activestate.com/recipes/579000/&quot;&gt;linspace 레시피&lt;/a&gt; 쇼에서는 포인트 애플리케이션을 떠에 적합한 범위의 게으른 버전을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d300d77cc8d0556a45c8f3612ef4a50b041b117f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://python-pillow.org/&quot;&gt;Pillow&lt;/a&gt; package adds support for formats such as BMP, JPEG, TIFF, and WebP, among others.</source>
          <target state="translated">&lt;a href=&quot;http://python-pillow.org/&quot;&gt;베개&lt;/a&gt; 패키지는 다른 사람의 사이에서 BMP, JPEG, TIFF, 및 WebP 형식과 같은 형식에 대한 지원을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e9169c27758b9a12167014506c5416a5dfaf6c16" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tix.htm&quot;&gt;tix commands&lt;/a&gt; provide access to miscellaneous elements of &lt;code&gt;Tix&lt;/code&gt;&amp;rsquo;s internal state and the &lt;code&gt;Tix&lt;/code&gt; application context. Most of the information manipulated by these methods pertains to the application as a whole, or to a screen or display, rather than to a particular window.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tix.htm&quot;&gt;TIX 명령&lt;/a&gt; 기타의 요소에 대한 액세스 제공 &lt;code&gt;Tix&lt;/code&gt; 의 내부 상태와 &lt;code&gt;Tix&lt;/code&gt; 애플리케이션 컨텍스트. 이러한 방법으로 조작되는 대부분의 정보는 특정 창이 아닌 응용 프로그램 전체 또는 화면 또는 디스플레이와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b788c78050dfd71c2443cbcfe38005d465da797" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixButtonBox.htm&quot;&gt;ButtonBox&lt;/a&gt; widget creates a box of buttons, such as is commonly used for &lt;code&gt;Ok Cancel&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixButtonBox.htm&quot;&gt;ButtonBox&lt;/a&gt; 일반적으로 사용되는 버튼 등의 박스를 생성 위젯 &lt;code&gt;Ok Cancel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86e1a883a18debb1e0837213b5b12c5d312026c3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixCheckList.htm&quot;&gt;CheckList&lt;/a&gt; widget displays a list of items to be selected by the user. CheckList acts similarly to the Tk checkbutton or radiobutton widgets, except it is capable of handling many more items than checkbuttons or radiobuttons.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixCheckList.htm&quot;&gt;체크리스트&lt;/a&gt; 는 사용자가 선택하도록 표시를 상품 목록 위젯. CheckList는 체크 버튼 또는 라디오 버튼보다 더 많은 항목을 처리 할 수 ​​있다는 점을 제외하고 Tk 체크 버튼 또는 라디오 버튼 위젯과 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="603558cb202ba89c4a3bb58d8825ab5b57237ec8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixComboBox.htm&quot;&gt;ComboBox&lt;/a&gt; widget is similar to the combo box control in MS Windows. The user can select a choice by either typing in the entry subwidget or selecting from the listbox subwidget.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixComboBox.htm&quot;&gt;콤보&lt;/a&gt; MS Windows에서 콤보 상자 컨트롤과 유사 위젯. 사용자는 항목 서브 위젯을 입력하거나 목록 상자 서브 위젯에서 선택하여 선택 사항을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c037cfe619555da329d2d697abb192a7f9ee3bdf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixControl.htm&quot;&gt;Control&lt;/a&gt; widget is also known as the &lt;code&gt;SpinBox&lt;/code&gt; widget. The user can adjust the value by pressing the two arrow buttons or by entering the value directly into the entry. The new value will be checked against the user-defined upper and lower limits.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixControl.htm&quot;&gt;제어&lt;/a&gt; 또한으로 알려져 위젯 &lt;code&gt;SpinBox&lt;/code&gt; 의 위젯. 사용자는 두 개의 화살표 버튼을 누르거나 항목에 직접 값을 입력하여 값을 조정할 수 있습니다. 새로운 값은 사용자 정의 상한 및 하한에 대해 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="04acb7539b464cd9018f7470202ff0b3a41f2a21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirList.htm&quot;&gt;DirList&lt;/a&gt; widget displays a list view of a directory, its previous directories and its sub-directories. The user can choose one of the directories displayed in the list or change to another directory.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirList.htm&quot;&gt;DirList는&lt;/a&gt; 표시를 목록의 디렉토리보기 이전 디렉토리 및 하위 디렉토리를 위젯. 사용자는 목록에 표시된 디렉토리 중 하나를 선택하거나 다른 디렉토리로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1047d1e24d522d85fa0ed385c293f709e614880" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirSelectDialog.htm&quot;&gt;DirSelectDialog&lt;/a&gt; widget presents the directories in the file system in a dialog window. The user can use this dialog window to navigate through the file system to select the desired directory.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirSelectDialog.htm&quot;&gt;DirSelectDialog는&lt;/a&gt; 대화 창에 선물을 파일 시스템에있는 디렉토리를 위젯. 사용자는이 대화 상자 창을 사용하여 파일 시스템을 탐색하여 원하는 디렉토리를 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fde708622bcb6f1bd06532cf4cc9669bf75d05a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirTree.htm&quot;&gt;DirTree&lt;/a&gt; widget displays a tree view of a directory, its previous directories and its sub-directories. The user can choose one of the directories displayed in the list or change to another directory.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixDirTree.htm&quot;&gt;DirTree는&lt;/a&gt; 표시를 트리 디렉토리의보기 이전 디렉토리 및 하위 디렉토리를 위젯. 사용자는 목록에 표시된 디렉토리 중 하나를 선택하거나 다른 디렉토리로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16650b193bc914d7c1b5ec60af4aeeb1c992cfb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixExFileSelectBox.htm&quot;&gt;ExFileSelectBox&lt;/a&gt; widget is usually embedded in a tixExFileSelectDialog widget. It provides a convenient method for the user to select files. The style of the &lt;a href=&quot;#tkinter.tix.ExFileSelectBox&quot;&gt;&lt;code&gt;ExFileSelectBox&lt;/code&gt;&lt;/a&gt; widget is very similar to the standard file dialog on MS Windows 3.1.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixExFileSelectBox.htm&quot;&gt;ExFileSelectBox&lt;/a&gt; 보통 tixExFileSelectDialog 위젯에 포함 된 위젯. 사용자가 파일을 편리하게 선택할 수있는 방법을 제공합니다. &lt;a href=&quot;#tkinter.tix.ExFileSelectBox&quot;&gt; &lt;code&gt;ExFileSelectBox&lt;/code&gt; &lt;/a&gt; 위젯 의 스타일은 MS Windows 3.1의 표준 파일 대화 상자와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="c9fbbdbd0dc3081d4631e705316075550a075986" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixFileEntry.htm&quot;&gt;FileEntry&lt;/a&gt; widget can be used to input a filename. The user can type in the filename manually. Alternatively, the user can press the button widget that sits next to the entry, which will bring up a file selection dialog.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixFileEntry.htm&quot;&gt;FileEntry는&lt;/a&gt; 입력 파일 이름을 사용할 수있는 위젯. 사용자는 파일 이름을 수동으로 입력 할 수 있습니다. 또는 사용자가 항목 옆에있는 단추 위젯을 누르면 파일 선택 대화 상자가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="527939224dcc8dc15ed6dff487c130a43399497c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixFileSelectBox.htm&quot;&gt;FileSelectBox&lt;/a&gt; is similar to the standard Motif(TM) file-selection box. It is generally used for the user to choose a file. FileSelectBox stores the files mostly recently selected into a &lt;a href=&quot;#tkinter.tix.ComboBox&quot;&gt;&lt;code&gt;ComboBox&lt;/code&gt;&lt;/a&gt; widget so that they can be quickly selected again.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixFileSelectBox.htm&quot;&gt;FileSelectBox는&lt;/a&gt; 표준 모티프 (TM) 파일 선택 상자와 유사하다. 일반적으로 사용자가 파일을 선택하는 데 사용됩니다. FileSelectBox는 가장 최근에 선택한 파일을 &lt;a href=&quot;#tkinter.tix.ComboBox&quot;&gt; &lt;code&gt;ComboBox&lt;/code&gt; &lt;/a&gt; 위젯에 저장하므로 빠르게 다시 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab61a7e3e90519857cf6d7040c91b4f49f6e791d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixForm.htm&quot;&gt;Form&lt;/a&gt; geometry manager based on attachment rules for all Tk widgets.</source>
          <target state="translated">모든 Tk 위젯에 대한 첨부 규칙을 기반으로 하는 &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixForm.htm&quot;&gt;양식&lt;/a&gt; 지오메트리 관리자.</target>
        </trans-unit>
        <trans-unit id="5a8956c2a460398355b14f63db03a07548e237ca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixHList.htm&quot;&gt;HList&lt;/a&gt; widget can be used to display any data that have a hierarchical structure, for example, file system directory trees. The list entries are indented and connected by branch lines according to their places in the hierarchy.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixHList.htm&quot;&gt;HList&lt;/a&gt; 예를 들어, 계층 구조를 가지고있는 데이터를 표시하는 데 사용할 수있는 위젯, 파일 시스템 디렉토리 트리. 목록 항목은 계층 구조 내 위치에 따라 분기선으로 들여 쓰기되고 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="e6354f123568048b67a926ccd0cd7d72d7496d5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixInputOnly.htm&quot;&gt;InputOnly&lt;/a&gt; widgets are to accept inputs from the user, which can be done with the &lt;code&gt;bind&lt;/code&gt; command (Unix only).</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixInputOnly.htm&quot;&gt;InputOnly의&lt;/a&gt; 위젯이 함께 할 수있는 사용자로부터 입력을 받아 들일 수 있습니다 &lt;code&gt;bind&lt;/code&gt; 명령을 (유닉스에만 해당).</target>
        </trans-unit>
        <trans-unit id="b0f5237f8198c76d42e5611f1189b4003b6e8249" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixLabelEntry.htm&quot;&gt;LabelEntry&lt;/a&gt; widget packages an entry widget and a label into one mega widget. It can be used to simplify the creation of &amp;ldquo;entry-form&amp;rdquo; type of interface.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixLabelEntry.htm&quot;&gt;LabelEntry&lt;/a&gt; 항목 위젯 하나의 메가 위젯에 라벨을 패키지 위젯. &quot;입력 양식&quot;유형의 인터페이스 작성을 단순화하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3aea0a8cf0ed5d2a381d7f8313262712a00d6c5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixLabelFrame.htm&quot;&gt;LabelFrame&lt;/a&gt; widget packages a frame widget and a label into one mega widget. To create widgets inside a LabelFrame widget, one creates the new widgets relative to the &lt;code&gt;frame&lt;/code&gt; subwidget and manage them inside the &lt;code&gt;frame&lt;/code&gt; subwidget.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixLabelFrame.htm&quot;&gt;LabelFrame&lt;/a&gt; 프레임 위젯 하나의 메가 위젯에 라벨을 패키지 위젯. LabelFrame 위젯 안에 위젯을 만들려면 하나는 상대 새로운 위젯 생성 &lt;code&gt;frame&lt;/code&gt; 는 SubWidget을하고 내부를 관리 &lt;code&gt;frame&lt;/code&gt; 는 SubWidget.</target>
        </trans-unit>
        <trans-unit id="7353a09d354c96f14d0973fb0e21bb9d2fa8dd0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixListNoteBook.htm&quot;&gt;ListNoteBook&lt;/a&gt; widget is very similar to the &lt;code&gt;TixNoteBook&lt;/code&gt; widget: it can be used to display many windows in a limited space using a notebook metaphor. The notebook is divided into a stack of pages (windows). At one time only one of these pages can be shown. The user can navigate through these pages by choosing the name of the desired page in the &lt;code&gt;hlist&lt;/code&gt; subwidget.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixListNoteBook.htm&quot;&gt;ListNoteBook&lt;/a&gt; 받는 사람과 매우 유사 위젯 &lt;code&gt;TixNoteBook&lt;/code&gt; 는 위젯 :이 노트북 은유를 사용하여 제한된 공간에서 여러 창을 표시 할 수 있습니다. 노트북은 여러 페이지 (창)로 나뉩니다. 한 번에 이러한 페이지 중 하나만 표시 할 수 있습니다. 사용자는 &lt;code&gt;hlist&lt;/code&gt; 서브 위젯 에서 원하는 페이지의 이름을 선택 하여이 페이지를 탐색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b879094947bc5e75feb18accde29b2dcd3c95b44" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixMeter.htm&quot;&gt;Meter&lt;/a&gt; widget can be used to show the progress of a background job which may take a long time to execute.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixMeter.htm&quot;&gt;미터&lt;/a&gt; 실행하는 데 시간이 오래 걸릴 수 있습니다 백그라운드 작업의 진행률을 표시하는 데 사용할 수있는 위젯.</target>
        </trans-unit>
        <trans-unit id="3b1884f8df17b41f26d089c22fbb18040c6f90ca" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixNoteBook.htm&quot;&gt;NoteBook&lt;/a&gt; widget can be used to display many windows in a limited space using a notebook metaphor. The notebook is divided into a stack of pages. At one time only one of these pages can be shown. The user can navigate through these pages by choosing the visual &amp;ldquo;tabs&amp;rdquo; at the top of the NoteBook widget.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixNoteBook.htm&quot;&gt;노트북&lt;/a&gt; 노트북 은유를 사용하여 제한된 공간에서 여러 창을 표시 할 수 있습니다 위젯. 노트북은 여러 페이지로 나뉩니다. 한 번에 이러한 페이지 중 하나만 표시 할 수 있습니다. 사용자는 NoteBook 위젯 상단에서 시각적 인 &quot;탭&quot;을 선택하여이 페이지를 탐색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fa47245f999c16063fff0ba1cb1595d3932a354" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixOptionMenu.htm&quot;&gt;OptionMenu&lt;/a&gt; creates a menu button of options.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixOptionMenu.htm&quot;&gt;OptionMenu는&lt;/a&gt; 옵션 메뉴 버튼을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="50e74e732a22202361fcac63091277793c2028f2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixPanedWindow.htm&quot;&gt;PanedWindow&lt;/a&gt; widget allows the user to interactively manipulate the sizes of several panes. The panes can be arranged either vertically or horizontally. The user changes the sizes of the panes by dragging the resize handle between two panes.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixPanedWindow.htm&quot;&gt;PanedWindow&lt;/a&gt; 에 사용자를 허용 위젯은 대화 형으로 여러 패널의 크기를 조작 할 수 있습니다. 판유리는 수직 또는 수평으로 배열 될 수 있습니다. 사용자는 두 개의 창 사이에서 크기 조정 핸들을 드래그하여 창의 크기를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d01273c8f94acbb62bbb2a0d580e288dbff01b64" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixPopupMenu.htm&quot;&gt;PopupMenu&lt;/a&gt; widget can be used as a replacement of the &lt;code&gt;tk_popup&lt;/code&gt; command. The advantage of the &lt;code&gt;Tix&lt;/code&gt;&lt;a href=&quot;#tkinter.tix.PopupMenu&quot;&gt;&lt;code&gt;PopupMenu&lt;/code&gt;&lt;/a&gt; widget is it requires less application code to manipulate.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixPopupMenu.htm&quot;&gt;의 PopupMenu는&lt;/a&gt; 의 대체로서 사용할 수있는 위젯 &lt;code&gt;tk_popup&lt;/code&gt; 의 명령. &lt;code&gt;Tix&lt;/code&gt; &lt;a href=&quot;#tkinter.tix.PopupMenu&quot;&gt; &lt;code&gt;PopupMenu&lt;/code&gt; &lt;/a&gt; 위젯 의 장점은 조작하는 데 더 적은 응용 프로그램 코드가 필요하다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="86685b685f4f3022f75f6a8e5f8a260f97634653" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixSelect.htm&quot;&gt;Select&lt;/a&gt; widget is a container of button subwidgets. It can be used to provide radio-box or check-box style of selection options for the user.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixSelect.htm&quot;&gt;선택&lt;/a&gt; 위젯은 버튼 subwidgets의 컨테이너입니다. 라디오 상자 또는 확인란 스타일의 선택 옵션을 사용자에게 제공하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f87617dead56f7c9ce2e3d900227d8e1e1d8545" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixStdButtonBox.htm&quot;&gt;StdButtonBox&lt;/a&gt; widget is a group of standard buttons for Motif-like dialog boxes.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixStdButtonBox.htm&quot;&gt;StdButtonBox&lt;/a&gt; 모티프 같은 대화 상자의 표준 단추 그룹입니다 위젯.</target>
        </trans-unit>
        <trans-unit id="36ae666d2c2ace8d201e3ab5211750075b3424e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixTList.htm&quot;&gt;TList&lt;/a&gt; widget can be used to display data in a tabular format. The list entries of a &lt;a href=&quot;#tkinter.tix.TList&quot;&gt;&lt;code&gt;TList&lt;/code&gt;&lt;/a&gt; widget are similar to the entries in the Tk listbox widget. The main differences are (1) the &lt;a href=&quot;#tkinter.tix.TList&quot;&gt;&lt;code&gt;TList&lt;/code&gt;&lt;/a&gt; widget can display the list entries in a two dimensional format and (2) you can use graphical images as well as multiple colors and fonts for the list entries.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixTList.htm&quot;&gt;은 TList는&lt;/a&gt; 표 형식으로 표시 데이터로 사용할 수있는 위젯. &lt;a href=&quot;#tkinter.tix.TList&quot;&gt; &lt;code&gt;TList&lt;/code&gt; &lt;/a&gt; 위젯 의 목록 항목은 Tk 목록 상자 위젯의 항목과 유사합니다. 주요 차이점은 (1) &lt;a href=&quot;#tkinter.tix.TList&quot;&gt; &lt;code&gt;TList&lt;/code&gt; &lt;/a&gt; 위젯이 목록 항목을 2 차원 형식으로 표시 할 수 있고 (2) 그래픽 이미지와 목록 항목에 대해 여러 색상 및 글꼴을 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9f138f0ac33a15cc112a69fa280a186d5e9d3505" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixTree.htm&quot;&gt;Tree&lt;/a&gt; widget can be used to display hierarchical data in a tree form. The user can adjust the view of the tree by opening or closing parts of the tree.</source>
          <target state="translated">&lt;a href=&quot;http://tix.sourceforge.net/dist/current/man/html/TixCmd/tixTree.htm&quot;&gt;트리&lt;/a&gt; 트리 형태의 계층 적 데이터를 표시하는 데 사용할 수있는 위젯. 사용자는 트리의 일부를 열거 나 닫아 트리의보기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b00b68144b0a7ccb966491d97590d5d1941b85a7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://code.activestate.com/recipes/577434/&quot;&gt;Nested Contexts recipe&lt;/a&gt; has options to control whether writes and other mutations apply only to the first mapping or to any mapping in the chain.</source>
          <target state="translated">&lt;a href=&quot;https://code.activestate.com/recipes/577434/&quot;&gt;중첩 된 컨텍스트 조리법은&lt;/a&gt; 쓰기와 다른 돌연변이가 첫 번째 매핑 또는 체인의 모든 매핑에 적용할지 여부를 제어하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="366df768713cd6eb282ce460c0c95bf88b3b540c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt; of the module. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-docstring&quot;&gt;docstring&lt;/a&gt; 입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e3f1b0ff9c725f0fb7678b7b3cb4937a376eb68" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; which loaded the module. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 모듈을로드. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87396fa33c5c1368bb55278c1b85eb1735ea8b77" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;named tuple&lt;/a&gt;&lt;em&gt;flags&lt;/em&gt; exposes the status of command line flags. The attributes are read only.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-named-tuple&quot;&gt;라는 이름의 튜플 &lt;/a&gt;&lt;em&gt;플래그는&lt;/em&gt; 명령 줄 플래그의 상태를 표시합니다. 속성은 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="0ac1b83ed391c6537aaeee5ffb70049e9f1bee75" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-qualified-name&quot;&gt;qualified name&lt;/a&gt; of the class, function, method, descriptor, or generator instance.</source>
          <target state="translated">클래스, 함수, 메소드, 설명자 또는 생성기 인스턴스 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-qualified-name&quot;&gt;규정 된 이름&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5a87f32ea5285eb1c52cf2503f70cc6587feb22e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; method, if defined, is used during creation of the Enum members; it is then replaced by Enum&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; which is used after class creation for lookup of existing members.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 메소드가 정의 된 경우, 상기 ENUM 부재의 제작시 사용되며 그런 다음 클래스 생성 후 기존 멤버를 찾기 위해 사용 되는 Enum의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="f3c33e932c88b9c61c62b48968186a1c88162159" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; statement is syntactic sugar for this function.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/simple_stmts.html#import&quot;&gt; &lt;code&gt;import&lt;/code&gt; &lt;/a&gt; 문은이 기능에 대한 문법 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="7e4b4ff99f1cb38fb0a5352172600bb59ef56737" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt;&lt;code&gt;-m&lt;/code&gt;&lt;/a&gt; option offering equivalent functionality from the command line.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-m&quot;&gt; &lt;code&gt;-m&lt;/code&gt; &lt;/a&gt; 명령 줄에서 동일한 기능을 제공하는 옵션을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="a7814f0bcc445d6ea051b404b0588a400412f9d0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-2&quot;&gt;&lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt;&lt;/a&gt; environment variable (&lt;code&gt;PYTHONTRACEMALLOC=NFRAME&lt;/code&gt;) and the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;tracemalloc=NFRAME&lt;/code&gt; command line option can be used to start tracing at startup.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-2&quot;&gt; &lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt; 의&lt;/a&gt; 환경 변수 ( &lt;code&gt;PYTHONTRACEMALLOC=NFRAME&lt;/code&gt; )와 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tracemalloc=NFRAME&lt;/code&gt; 명령 줄 옵션은 시작시 추적을 시작하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28a390a30a62ca1f5d0f41f5bdeaf8e424f3a223" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://en.wikipedia.org/wiki/Billion_laughs&quot;&gt;Billion Laughs&lt;/a&gt; attack &amp;ndash; also known as exponential entity expansion &amp;ndash; uses multiple levels of nested entities. Each entity refers to another entity several times, and the final entity definition contains a small string. The exponential expansion results in several gigabytes of text and consumes lots of memory and CPU time.</source>
          <target state="translated">지수 엔터티 확장이라고도 하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Billion_laughs&quot;&gt;Billion Laughs&lt;/a&gt; 공격은 여러 수준의 중첩 된 엔터티를 사용합니다. 각 엔터티는 다른 엔터티를 여러 번 참조하며 최종 엔터티 정의에는 작은 문자열이 포함됩니다. 지수 확장은 수 기가 바이트의 텍스트를 생성하고 많은 메모리와 CPU 시간을 소비합니다.</target>
        </trans-unit>
        <trans-unit id="e7d2e0bc9e7c3fe6abdfea0d8f090df8932358cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py&quot;&gt;MultiContext class&lt;/a&gt; in the Enthought &lt;a href=&quot;https://github.com/enthought/codetools&quot;&gt;CodeTools package&lt;/a&gt; has options to support writing to any mapping in the chain.</source>
          <target state="translated">Enthought &lt;a href=&quot;https://github.com/enthought/codetools&quot;&gt;CodeTools 패키지&lt;/a&gt; 의 &lt;a href=&quot;https://github.com/enthought/codetools/blob/4.0.0/codetools/contexts/multi_context.py&quot;&gt;MultiContext 클래스&lt;/a&gt; 에는 체인의 모든 매핑에 대한 쓰기를 지원하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c370b58e8da7033646d2a0e82dff131888172df1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Tools/demo/&quot;&gt;Tools/demo/&lt;/a&gt; directory in the Python source distribution contains some example programs using the curses bindings provided by this module.</source>
          <target state="translated">Python 소스 배포 의 &lt;a href=&quot;https://github.com/python/cpython/tree/3.8/Tools/demo/&quot;&gt;Tools / demo /&lt;/a&gt; 디렉토리에는이 모듈에서 제공하는 curses 바인딩을 사용하는 일부 예제 프로그램이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c68c52a2e707faa21d8b537706f88593db3e7b67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://help.gnome.org/users/gnumeric/stable/gnumeric.html#gnumeric-function-SSMEDIAN&quot;&gt;SSMEDIAN&lt;/a&gt; function in the Gnome Gnumeric spreadsheet, including &lt;a href=&quot;https://mail.gnome.org/archives/gnumeric-list/2011-April/msg00018.html&quot;&gt;this discussion&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://mail.gnome.org/archives/gnumeric-list/2011-April/msg00018.html&quot;&gt;이 설명을&lt;/a&gt; 포함하여 Gnome Gnumeric 스프레드 시트 의 &lt;a href=&quot;https://help.gnome.org/users/gnumeric/stable/gnumeric.html#gnumeric-function-SSMEDIAN&quot;&gt;SSMEDIAN&lt;/a&gt; 함수 .</target>
        </trans-unit>
        <trans-unit id="3719a92f6bc634688a542f7f28587c9a13eaf643" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://requests.readthedocs.io/en/master/&quot;&gt;Requests package&lt;/a&gt; is recommended for a higher-level HTTP client interface.</source>
          <target state="translated">상위 레벨 HTTP 클라이언트 인터페이스 에는 &lt;a href=&quot;https://requests.readthedocs.io/en/master/&quot;&gt;요청 패키지&lt;/a&gt; 가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="b063ff9485718a2e89faf0ab510e54940c874604" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; encodings are suitable for encoding binary data so that it can safely sent by email, used as parts of URLs, or included as part of an HTTP POST request. The encoding algorithm is not the same as the &lt;strong&gt;uuencode&lt;/strong&gt; program.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc3548.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 3548&lt;/strong&gt;&lt;/a&gt; 인코딩이 안전하게 HTTP POST 요청의 일부로서, 이메일 전송 된 URL의 일부로서 사용되거나 포함될 수 있도록 이진 데이터를 인코딩하기에 적합하다. 인코딩 알고리즘은 &lt;strong&gt;uuencode&lt;/strong&gt; 프로그램 과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="9420f9f109d018ebd955fab4fd92512492f54acd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;importlib#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt; function</source>
          <target state="translated">&lt;a href=&quot;importlib#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt; 함수</target>
        </trans-unit>
        <trans-unit id="96cf8e8e3869ca40ea2511ede446ce1808bbd3b4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;stdout&lt;/em&gt; should write each chunk in full, like &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;stdout&lt;/em&gt; 의 &lt;a href=&quot;io#io.BufferedIOBase.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 메소드는 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 와 같이 각 청크를 완전히 작성해야합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c23ffc96778cd83371ca325ec9a280da044137ff" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io#io.IOBase.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; method can be used to obtain the file descriptor associated with a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt; when required. Note that using the file descriptor directly will bypass the file object methods, ignoring aspects such as internal buffering of data.</source>
          <target state="translated">&lt;a href=&quot;io#io.IOBase.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 메소드는 파일과 관련된 디스크립터 획득하는데 사용될 수 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트를&lt;/a&gt; 요구 될 때. 파일 디스크립터를 직접 사용하면 데이터의 내부 버퍼링과 같은 측면을 무시하고 파일 오브젝트 메소드를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="399bd4ce685d281a7befd1de6af3e29f9430d945" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;json#module-json&quot;&gt;&lt;code&gt;json&lt;/code&gt;&lt;/a&gt; module: a standard library module allowing JSON serialization and deserialization.</source>
          <target state="translated">&lt;a href=&quot;json#module-json&quot;&gt; &lt;code&gt;json&lt;/code&gt; &lt;/a&gt; 모듈 : JSON 직렬화 및 역 직렬화를 허용하는 표준 라이브러리 모듈.</target>
        </trans-unit>
        <trans-unit id="b423614dd427b120857806b9ad473895269343ba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;marshal#module-marshal&quot;&gt;&lt;code&gt;marshal&lt;/code&gt;&lt;/a&gt; serialization format is not guaranteed to be portable across Python versions. Because its primary job in life is to support &lt;code&gt;.pyc&lt;/code&gt; files, the Python implementers reserve the right to change the serialization format in non-backwards compatible ways should the need arise. The &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; serialization format is guaranteed to be backwards compatible across Python releases provided a compatible pickle protocol is chosen and pickling and unpickling code deals with Python 2 to Python 3 type differences if your data is crossing that unique breaking change language boundary.</source>
          <target state="translated">&lt;a href=&quot;marshal#module-marshal&quot;&gt; &lt;code&gt;marshal&lt;/code&gt; &lt;/a&gt; 직렬화 형식은 파이썬 버전에서 호환성을 보장 할 수 없습니다. 인생의 주요 작업은 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 지원하는 것이기 때문에 파이썬 구현자는 필요에 따라 역 호환되지 않는 방식으로 직렬화 형식을 변경할 권리를 보유합니다. &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 파이썬 버전이 호환 피클 프로토콜을 선택하고 제공을 통해 직렬화 형식은 이전 버전과 호환되도록 보장 산세와 데이터가 고유의 차단 언어 변경 경계하는 것이 교차하는 경우 파이썬 3 종류의 차이에 파이썬 2 코드 거래를 unpickling.</target>
        </trans-unit>
        <trans-unit id="9a48d7f9092d5b73d9f57bc216ea762816cf68b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module provides an alternate implementation of &lt;code&gt;environ&lt;/code&gt; which updates the environment on modification. Note also that updating &lt;a href=&quot;os#os.environ&quot;&gt;&lt;code&gt;os.environ&lt;/code&gt;&lt;/a&gt; will render this dictionary obsolete. Use of the &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; module version of this is recommended over direct access to the &lt;a href=&quot;#module-posix&quot;&gt;&lt;code&gt;posix&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈의 대체 구현을 제공 &lt;code&gt;environ&lt;/code&gt; 수정에 환경을 업데이트합니다. &lt;a href=&quot;os#os.environ&quot;&gt; &lt;code&gt;os.environ&lt;/code&gt; &lt;/a&gt; 을 업데이트 하면이 사전이 더 이상 사용되지 않습니다. &lt;a href=&quot;#module-posix&quot;&gt; &lt;code&gt;posix&lt;/code&gt; &lt;/a&gt; 모듈에 직접 액세스 할 때 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 모듈 버전을 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f7b74ac0b4916b2a2815d16beac508a288819a90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;os#os.O_TMPFILE&quot;&gt;&lt;code&gt;os.O_TMPFILE&lt;/code&gt;&lt;/a&gt; flag is used if it is available and works (Linux-specific, requires Linux kernel 3.11 or later).</source>
          <target state="translated">&lt;a href=&quot;os#os.O_TMPFILE&quot;&gt; &lt;code&gt;os.O_TMPFILE&lt;/code&gt; 의&lt;/a&gt; 이 가능하며 작업 (리눅스에서만은, 리눅스가 3.11 이상 커널 필요)하면 플래그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="be53a0f028cc8f2f7cb574eaeda9d516422827b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt; attribute will be &lt;code&gt;bytes&lt;/code&gt; if the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt;&lt;em&gt;path&lt;/em&gt; argument is of type &lt;code&gt;bytes&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; otherwise. Use &lt;a href=&quot;#os.fsdecode&quot;&gt;&lt;code&gt;fsdecode()&lt;/code&gt;&lt;/a&gt; to decode byte filenames.</source>
          <target state="translated">&lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 속성이 될 것입니다 &lt;code&gt;bytes&lt;/code&gt; 경우 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 경로&lt;/em&gt; 인수는 타입이다 &lt;code&gt;bytes&lt;/code&gt; 및 &lt;code&gt;str&lt;/code&gt; 그렇지. 바이트 파일 이름을 디코딩 하려면 &lt;a href=&quot;#os.fsdecode&quot;&gt; &lt;code&gt;fsdecode()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="471dcc1abba4e4319f505be9780becb5d37241e8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;pathlib#module-pathlib&quot;&gt;&lt;code&gt;pathlib&lt;/code&gt;&lt;/a&gt; module offers high-level path objects.</source>
          <target state="translated">&lt;a href=&quot;pathlib#module-pathlib&quot;&gt; &lt;code&gt;pathlib&lt;/code&gt; 의&lt;/a&gt; 모듈 제공하는 높은 수준의 경로는 객체.</target>
        </trans-unit>
        <trans-unit id="9241756174385f49d4dfffd6e60c0bbef34ded67" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;platform#module-platform&quot;&gt;&lt;code&gt;platform&lt;/code&gt;&lt;/a&gt; module provides detailed checks for the system&amp;rsquo;s identity.</source>
          <target state="translated">&lt;a href=&quot;platform#module-platform&quot;&gt; &lt;code&gt;platform&lt;/code&gt; &lt;/a&gt; 모듈은 시스템의 신원에 대한 자세한 검사를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e3164e9402a163cd69e25ca9534f9c207636ddfc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;secrets#module-secrets&quot;&gt;&lt;code&gt;secrets&lt;/code&gt;&lt;/a&gt; module provides higher level functions. For an easy-to-use interface to the random number generator provided by your platform, please see &lt;a href=&quot;random#random.SystemRandom&quot;&gt;&lt;code&gt;random.SystemRandom&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;secrets#module-secrets&quot;&gt; &lt;code&gt;secrets&lt;/code&gt; &lt;/a&gt; 모듈은 높은 수준의 기능을 제공합니다. 플랫폼에서 제공하는 난수 생성기에 대한 사용하기 쉬운 인터페이스는 &lt;a href=&quot;random#random.SystemRandom&quot;&gt; &lt;code&gt;random.SystemRandom&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79808356e012c04c25cfc73650f064d2eaca11f7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; module allows high-level and efficient I/O multiplexing, built upon the &lt;a href=&quot;#module-select&quot;&gt;&lt;code&gt;select&lt;/code&gt;&lt;/a&gt; module primitives. Users are encouraged to use the &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; module instead, unless they want precise control over the OS-level primitives used.</source>
          <target state="translated">&lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 모듈에 내장 된 높은 수준의 효율적인 I / O 멀티플렉싱, 수 &lt;a href=&quot;#module-select&quot;&gt; &lt;code&gt;select&lt;/code&gt; &lt;/a&gt; 모듈 프리미티브. 사용 된 OS 레벨 프리미티브에 대한 정확한 제어를 원하지 않는 한, &lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 모듈을 대신 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="49a28f80ab152e5e2358049c0893fe3c0b3a0dc6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 모듈.</target>
        </trans-unit>
        <trans-unit id="38effe416777378b22cda470a25dc6a7e848d01c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;site#module-site&quot;&gt;&lt;code&gt;site&lt;/code&gt;&lt;/a&gt; module (which is imported automatically during startup, except if the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/a&gt; command-line option is given) adds several constants to the built-in namespace. They are useful for the interactive interpreter shell and should not be used in programs.</source>
          <target state="translated">&lt;a href=&quot;site#module-site&quot;&gt; &lt;code&gt;site&lt;/code&gt; &lt;/a&gt; 합니다 (있는 경우를 제외하고, 시작시 자동으로 가져온 모듈 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id3&quot;&gt; &lt;code&gt;-S&lt;/code&gt; &lt;/a&gt; 명령 행 옵션이 주어)가 내장 된 네임 스페이스에 여러 상수를 추가합니다. 대화식 인터프리터 쉘에 유용하며 프로그램에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3ade11583d8fdf4059483f38abf928bd1432aba8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt;&lt;code&gt;__mro__&lt;/code&gt;&lt;/a&gt; attribute of the &lt;em&gt;object-or-type&lt;/em&gt; lists the method resolution search order used by both &lt;a href=&quot;#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#super&quot;&gt;&lt;code&gt;super()&lt;/code&gt;&lt;/a&gt;. The attribute is dynamic and can change whenever the inheritance hierarchy is updated.</source>
          <target state="translated">&lt;em&gt;객체 또는 유형&lt;/em&gt; 의 &lt;a href=&quot;stdtypes#class.__mro__&quot;&gt; &lt;code&gt;__mro__&lt;/code&gt; &lt;/a&gt; 속성은 &lt;a href=&quot;#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#super&quot;&gt; &lt;code&gt;super()&lt;/code&gt; &lt;/a&gt; 의해 사용되는 메서드 확인 검색 순서를 나열합니다 . 속성은 동적이며 상속 계층이 업데이트 될 때마다 변경 될 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d3d084e9d41e4f4c212d80200f0d53e8de5452d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;stdtypes#str.format&quot;&gt;&lt;code&gt;str.format()&lt;/code&gt;&lt;/a&gt; method and the &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; class share the same syntax for format strings (although in the case of &lt;a href=&quot;#string.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt;, subclasses can define their own format string syntax). The syntax is related to that of &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;formatted string literals&lt;/a&gt;, but there are differences.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#str.format&quot;&gt; &lt;code&gt;str.format()&lt;/code&gt; &lt;/a&gt; 방법 및 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; (의 경우 비록 클래스 형식 문자열에 대해 동일한 구문을 공유 &lt;a href=&quot;#string.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; , 서브 클래스가 자신의 형식 문자열 구문을 정의 할 수있다). 구문은 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#f-strings&quot;&gt;형식화 된 문자열 리터럴&lt;/a&gt; 의 구문과 관련이 있지만 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="16b93b46d811fc398b39ecaca2fce94e92de2773" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; module provides more powerful facilities for spawning new processes and retrieving their results; using that module is preferable to using this function. See the &lt;a href=&quot;subprocess#subprocess-replacements&quot;&gt;Replacing Older Functions with the subprocess Module&lt;/a&gt; section in the &lt;a href=&quot;subprocess#module-subprocess&quot;&gt;&lt;code&gt;subprocess&lt;/code&gt;&lt;/a&gt; documentation for some helpful recipes.</source>
          <target state="translated">&lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 모듈은 새로운 프로세스를 산란하고 결과를 검색하기위한보다 강력한 기능을 제공합니다; 이 기능을 사용하는 것보다 해당 모듈을 사용하는 것이 좋습니다. 유용한 레시피 는 &lt;a href=&quot;subprocess#module-subprocess&quot;&gt; &lt;code&gt;subprocess&lt;/code&gt; &lt;/a&gt; 문서 에서 &lt;a href=&quot;subprocess#subprocess-replacements&quot;&gt;이전 프로세스를 서브 프로세스 모듈로 대체&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02fda4db0686e8cf23f242cc65ce3efd8b28cefc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;text#textservices&quot;&gt;Text Processing Services&lt;/a&gt; section of the standard library covers a number of other modules that provide various text related utilities (including regular expression support in the &lt;a href=&quot;re#module-re&quot;&gt;&lt;code&gt;re&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">표준 라이브러리 의 &lt;a href=&quot;text#textservices&quot;&gt;텍스트 처리 서비스&lt;/a&gt; 섹션은 다양한 텍스트 관련 유틸리티를 제공하는 여러 다른 모듈을 다룹니다 ( &lt;a href=&quot;re#module-re&quot;&gt; &lt;code&gt;re&lt;/code&gt; &lt;/a&gt; 모듈의 정규식 지원 포함 ).</target>
        </trans-unit>
        <trans-unit id="bb5820ab12ab63458bab2d4624fdd0e942a0e50e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tokenize#tokenize.open&quot;&gt;&lt;code&gt;tokenize.open()&lt;/code&gt;&lt;/a&gt; function is used to open files. This function uses &lt;a href=&quot;tokenize#tokenize.detect_encoding&quot;&gt;&lt;code&gt;tokenize.detect_encoding()&lt;/code&gt;&lt;/a&gt; to get the encoding of the file; in the absence of an encoding token, the file encoding defaults to UTF-8.</source>
          <target state="translated">&lt;a href=&quot;tokenize#tokenize.open&quot;&gt; &lt;code&gt;tokenize.open()&lt;/code&gt; &lt;/a&gt; 함수는 열려있는 파일에 사용됩니다. 이 함수는 &lt;a href=&quot;tokenize#tokenize.detect_encoding&quot;&gt; &lt;code&gt;tokenize.detect_encoding()&lt;/code&gt; &lt;/a&gt; 을 사용 하여 파일의 인코딩을 가져옵니다. 인코딩 토큰이 없으면 파일 인코딩의 기본값은 UTF-8입니다.</target>
        </trans-unit>
        <trans-unit id="e3d58c07fec169dbcdb3df24325c1d256766749d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; cases generated by &lt;a href=&quot;#doctest.DocTestSuite&quot;&gt;&lt;code&gt;DocTestSuite()&lt;/code&gt;&lt;/a&gt; support the &lt;a href=&quot;#doctest.debug&quot;&gt;&lt;code&gt;debug()&lt;/code&gt;&lt;/a&gt; method defined by &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt;&lt;code&gt;unittest.TestCase&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 에 의해 생성 된 경우 &lt;a href=&quot;#doctest.DocTestSuite&quot;&gt; &lt;code&gt;DocTestSuite()&lt;/code&gt; &lt;/a&gt; 지지 &lt;a href=&quot;#doctest.debug&quot;&gt; &lt;code&gt;debug()&lt;/code&gt; &lt;/a&gt; 에 의해 정의 된 방법 &lt;a href=&quot;unittest#unittest.TestCase&quot;&gt; &lt;code&gt;unittest.TestCase&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3e525132d5ae456f3d840eb956b446a76191a36" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;index-16&quot;&gt;TZ&lt;/code&gt; environment variable should contain no whitespace.</source>
          <target state="translated">&lt;code id=&quot;index-16&quot;&gt;TZ&lt;/code&gt; 의 환경 변수에 공백이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4df849fd3a6c6323909eb01638af5828a8b08ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code id=&quot;index-4&quot;&gt;no_proxy&lt;/code&gt; environment variable can be used to specify hosts which shouldn&amp;rsquo;t be reached via proxy; if set, it should be a comma-separated list of hostname suffixes, optionally with &lt;code&gt;:port&lt;/code&gt; appended, for example &lt;code&gt;cern.ch,ncsa.uiuc.edu,some.host:8080&lt;/code&gt;.</source>
          <target state="translated">&lt;code id=&quot;index-4&quot;&gt;no_proxy&lt;/code&gt; 환경 변수는 프록시를 통해 도달하지 않는 호스트를 지정하는 데 사용될 수있다; 설정된 경우 쉼표로 구분 된 호스트 이름 접미사의 목록이어야하며 선택적으로 &lt;code&gt;:port&lt;/code&gt; 가 추가되어 있습니다 (예 : &lt;code&gt;cern.ch,ncsa.uiuc.edu,some.host:8080&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="124717b2376ede57740fad89729551e596c6a01f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%(prog)s&lt;/code&gt; format specifier is available to fill in the program name in your usage messages.</source>
          <target state="translated">&lt;code&gt;%(prog)s&lt;/code&gt; 형식 지정자는 사용 메시지에서 프로그램 이름을 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e6968cbd74079cf51599969bef7c4705220d9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; operators implement the &lt;code&gt;remainder&lt;/code&gt; and &lt;code&gt;divide-integer&lt;/code&gt; operations (respectively) as described in the specification.</source>
          <target state="translated">&lt;code&gt;%&lt;/code&gt; 와 &lt;code&gt;//&lt;/code&gt; 연산자는 구현 &lt;code&gt;remainder&lt;/code&gt; 와 &lt;code&gt;divide-integer&lt;/code&gt; 사양에 설명 된대로 작업 (각각)를.</target>
        </trans-unit>
        <trans-unit id="26fc765bc88715c46b879eccb94104c2e8a58922" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'#'&lt;/code&gt; option causes the &amp;ldquo;alternate form&amp;rdquo; to be used for the conversion. The alternate form is defined differently for different types. This option is only valid for integer, float, complex and Decimal types. For integers, when binary, octal, or hexadecimal output is used, this option adds the prefix respective &lt;code&gt;'0b'&lt;/code&gt;, &lt;code&gt;'0o'&lt;/code&gt;, or &lt;code&gt;'0x'&lt;/code&gt; to the output value. For floats, complex and Decimal the alternate form causes the result of the conversion to always contain a decimal-point character, even if no digits follow it. Normally, a decimal-point character appears in the result of these conversions only if a digit follows it. In addition, for &lt;code&gt;'g'&lt;/code&gt; and &lt;code&gt;'G'&lt;/code&gt; conversions, trailing zeros are not removed from the result.</source>
          <target state="translated">&lt;code&gt;'#'&lt;/code&gt; 옵션은 변환에 사용되는 &quot;대체 양식을&quot;이 발생합니다. 대체 형식은 유형에 따라 다르게 정의됩니다. 이 옵션은 정수, 부동, 복합 및 소수 유형에만 유효합니다. 정수의 경우 2 진, 8 진 또는 16 진 출력이 사용되는 경우이 옵션은 각각 &lt;code&gt;'0b'&lt;/code&gt; , &lt;code&gt;'0o'&lt;/code&gt; 또는 &lt;code&gt;'0x'&lt;/code&gt; 접 두부 를 출력 값에 추가합니다. float, complex 및 Decimal의 경우 대체 형식은 뒤에 숫자가 없더라도 변환 결과에 항상 소수점 문자를 포함합니다. 일반적으로 소수점 이하 자릿수가 뒤에 오는 경우에만 이러한 변환 결과에 소수점 문자가 나타납니다. 또한 &lt;code&gt;'g'&lt;/code&gt; 및 &lt;code&gt;'G'&lt;/code&gt; 변환, 후행 0은 결과에서 제거되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d086e8403ba4ce40550b0cbe1abec1085dab4b24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'%'&lt;/code&gt; character, which marks the start of the specifier.</source>
          <target state="translated">&lt;code&gt;'%'&lt;/code&gt; 문자 지정자의 마크 시작.</target>
        </trans-unit>
        <trans-unit id="29578cc20ffa9483eee996d330ad586d947c7483" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'*'&lt;/code&gt;, &lt;code&gt;'+'&lt;/code&gt;, and &lt;code&gt;'?'&lt;/code&gt; qualifiers are all &lt;em&gt;greedy&lt;/em&gt;; they match as much text as possible. Sometimes this behaviour isn&amp;rsquo;t desired; if the RE &lt;code&gt;&amp;lt;.*&amp;gt;&lt;/code&gt; is matched against &lt;code&gt;'&amp;lt;a&amp;gt; b &amp;lt;c&amp;gt;'&lt;/code&gt;, it will match the entire string, and not just &lt;code&gt;'&amp;lt;a&amp;gt;'&lt;/code&gt;. Adding &lt;code&gt;?&lt;/code&gt; after the qualifier makes it perform the match in &lt;em&gt;non-greedy&lt;/em&gt; or &lt;em&gt;minimal&lt;/em&gt; fashion; as &lt;em&gt;few&lt;/em&gt; characters as possible will be matched. Using the RE &lt;code&gt;&amp;lt;.*?&amp;gt;&lt;/code&gt; will match only &lt;code&gt;'&amp;lt;a&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'*'&lt;/code&gt; , &lt;code&gt;'+'&lt;/code&gt; 와 &lt;code&gt;'?'&lt;/code&gt; 한정자는 모두 &lt;em&gt;탐욕 스럽습니다&lt;/em&gt; . 가능한 한 많은 텍스트와 일치합니다. 때때로이 동작은 바람직하지 않습니다. RE &lt;code&gt;&amp;lt;.*&amp;gt;&lt;/code&gt; 가 &lt;code&gt;'&amp;lt;a&amp;gt; b &amp;lt;c&amp;gt;'&lt;/code&gt; 와 일치하면 &lt;code&gt;'&amp;lt;a&amp;gt;'&lt;/code&gt; 뿐만 아니라 전체 문자열과 일치합니다 . 추가 &lt;code&gt;?&lt;/code&gt; 한정자가 &lt;em&gt;욕심이&lt;/em&gt; 없거나 &lt;em&gt;최소한의&lt;/em&gt; 방식으로 경기를 수행 한 후 ; 가능한 &lt;em&gt;적은&lt;/em&gt; 문자가 일치합니다. RE &lt;code&gt;&amp;lt;.*?&amp;gt;&lt;/code&gt; 를 사용하면 &lt;code&gt;'&amp;lt;a&amp;gt;'&lt;/code&gt; 와만 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="a9ecb205841d6a4b96487d164ca5b87434878f2b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;','&lt;/code&gt; option signals the use of a comma for a thousands separator. For a locale aware separator, use the &lt;code&gt;'n'&lt;/code&gt; integer presentation type instead.</source>
          <target state="translated">은 &lt;code&gt;','&lt;/code&gt; 옵션은 1000 단락 쉼표의 사용을 신호. 로케일 인식 구분 기호의 경우 &lt;code&gt;'n'&lt;/code&gt; 정수 표시 유형을 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4bede3f058d1080c59bb7223d2576a9639b17ed5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'?'&lt;/code&gt; conversion code corresponds to the &lt;code&gt;_Bool&lt;/code&gt; type defined by C99. If this type is not available, it is simulated using a &lt;code&gt;char&lt;/code&gt;. In standard mode, it is always represented by one byte.</source>
          <target state="translated">&lt;code&gt;'?'&lt;/code&gt; 변환 코드 는 C99로 정의 된 &lt;code&gt;_Bool&lt;/code&gt; 유형에 해당합니다 . 이 유형을 사용할 수 없으면 &lt;code&gt;char&lt;/code&gt; 을 사용하여 시뮬레이션됩니다 . 표준 모드에서는 항상 1 바이트로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2cbabc01b5030a839af16dd31d6d1582669f469f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'P'&lt;/code&gt; format character is only available for the native byte ordering (selected as the default or with the &lt;code&gt;'@'&lt;/code&gt; byte order character). The byte order character &lt;code&gt;'='&lt;/code&gt; chooses to use little- or big-endian ordering based on the host system. The struct module does not interpret this as native ordering, so the &lt;code&gt;'P'&lt;/code&gt; format is not available.</source>
          <target state="translated">&lt;code&gt;'P'&lt;/code&gt; 형식 문자 (기본값으로 또는 함께 선택한 기본 바이트 순서에 대해서만 사용할 수 있습니다 &lt;code&gt;'@'&lt;/code&gt; 바이트 순서 문자). 바이트 순서 문자 &lt;code&gt;'='&lt;/code&gt; 는 호스트 시스템을 기반으로 리틀 또는 빅 엔디안 순서를 사용하도록 선택합니다. struct 모듈은 이것을 기본 순서로 해석하지 않으므로 &lt;code&gt;'P'&lt;/code&gt; 형식을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="684c972da1ab1e572962745d55ed7035986dfd64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'_'&lt;/code&gt; option signals the use of an underscore for a thousands separator for floating point presentation types and for integer presentation type &lt;code&gt;'d'&lt;/code&gt;. For integer presentation types &lt;code&gt;'b'&lt;/code&gt;, &lt;code&gt;'o'&lt;/code&gt;, &lt;code&gt;'x'&lt;/code&gt;, and &lt;code&gt;'X'&lt;/code&gt;, underscores will be inserted every 4 digits. For other presentation types, specifying this option is an error.</source>
          <target state="translated">&lt;code&gt;'_'&lt;/code&gt; 옵션 신호 포인트 프레젠테이션 타입 부동 정수 프리젠 테이션 유형에 대해 1000 단락 밑줄 사용 &lt;code&gt;'d'&lt;/code&gt; . 정수 표현 유형 &lt;code&gt;'b'&lt;/code&gt; , &lt;code&gt;'o'&lt;/code&gt; , &lt;code&gt;'x'&lt;/code&gt; 및 &lt;code&gt;'X'&lt;/code&gt; 의 경우 4 자리마다 밑줄이 삽입됩니다. 다른 프리젠 테이션 유형의 경우이 옵션을 지정하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2dab823989a3bfcb1eb81a87c5a993cedef1847d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'d'&lt;/code&gt; and &lt;code&gt;'i'&lt;/code&gt; arguments used when creating &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;arr&lt;/code&gt; are typecodes of the kind used by the &lt;a href=&quot;array#module-array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; module: &lt;code&gt;'d'&lt;/code&gt; indicates a double precision float and &lt;code&gt;'i'&lt;/code&gt; indicates a signed integer. These shared objects will be process and thread-safe.</source>
          <target state="translated">&lt;code&gt;'d'&lt;/code&gt; 및 &lt;code&gt;'i'&lt;/code&gt; 만들 때 사용되는 인수 &lt;code&gt;num&lt;/code&gt; 및 &lt;code&gt;arr&lt;/code&gt; 에 의해 사용되는 종류의 타입 코드이다 &lt;a href=&quot;array#module-array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 모듈 : &lt;code&gt;'d'&lt;/code&gt; 이중 정밀 부동 소수점을 나타내며, &lt;code&gt;'i'&lt;/code&gt; 부호있는 정수를 나타낸다. 이러한 공유 객체는 프로세스 및 스레드로부터 안전합니다.</target>
        </trans-unit>
        <trans-unit id="f27e8e197e546ffdcfe9c93e4f87bfb1b8dd4be4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'n'&lt;/code&gt; and &lt;code&gt;'N'&lt;/code&gt; conversion codes are only available for the native size (selected as the default or with the &lt;code&gt;'@'&lt;/code&gt; byte order character). For the standard size, you can use whichever of the other integer formats fits your application.</source>
          <target state="translated">&lt;code&gt;'n'&lt;/code&gt; 과 &lt;code&gt;'N'&lt;/code&gt; 변환 코드 (기본값으로 또는 함께 선택한 기본 크기에서만 사용할 수 있습니다 &lt;code&gt;'@'&lt;/code&gt; 바이트 순서 문자). 표준 크기의 경우 응용 프로그램에 맞는 다른 정수 형식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f505078713789f13c3c23c17c695637662859e7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'namereplace'&lt;/code&gt; error handler was added.</source>
          <target state="translated">&lt;code&gt;'namereplace'&lt;/code&gt; 오류 처리기가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b3a9b42db88708058f73659938e683f11a352cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'p'&lt;/code&gt; format character encodes a &amp;ldquo;Pascal string&amp;rdquo;, meaning a short variable-length string stored in a &lt;em&gt;fixed number of bytes&lt;/em&gt;, given by the count. The first byte stored is the length of the string, or 255, whichever is smaller. The bytes of the string follow. If the string passed in to &lt;a href=&quot;#struct.pack&quot;&gt;&lt;code&gt;pack()&lt;/code&gt;&lt;/a&gt; is too long (longer than the count minus 1), only the leading &lt;code&gt;count-1&lt;/code&gt; bytes of the string are stored. If the string is shorter than &lt;code&gt;count-1&lt;/code&gt;, it is padded with null bytes so that exactly count bytes in all are used. Note that for &lt;a href=&quot;#struct.unpack&quot;&gt;&lt;code&gt;unpack()&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;'p'&lt;/code&gt; format character consumes &lt;code&gt;count&lt;/code&gt; bytes, but that the string returned can never contain more than 255 bytes.</source>
          <target state="translated">&lt;code&gt;'p'&lt;/code&gt; 형식의 문자가 저장 짧은 가변 길이의 문자열을 의미하는 &quot;파스칼 문자열&quot;코딩 &lt;em&gt;바이트의 고정 된 수의&lt;/em&gt; 카운트를 주어진. 저장된 첫 번째 바이트는 문자열의 길이 또는 255 중 작은 쪽입니다. 문자열의 바이트는 다음과 같습니다. &lt;a href=&quot;#struct.pack&quot;&gt; &lt;code&gt;pack()&lt;/code&gt; &lt;/a&gt; 전달 된 문자열 이 너무 길면 (카운트에서 1을 뺀 길이 ) 문자열 의 선행 &lt;code&gt;count-1&lt;/code&gt; 바이트 만 저장됩니다. 문자열이 &lt;code&gt;count-1&lt;/code&gt; 보다 짧으면 널 바이트로 채워져 모든 바이트 수가 정확하게 사용됩니다. 참고를위한 &lt;a href=&quot;#struct.unpack&quot;&gt; &lt;code&gt;unpack()&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;'p'&lt;/code&gt; 형식의 문자를 소비하는 &lt;code&gt;count&lt;/code&gt; 그러나 반환 된 문자열은 255 바이트를 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="57a200ea9356e51b01fb419cb534f48ddc87b1df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'spawn'&lt;/code&gt; and &lt;code&gt;'forkserver'&lt;/code&gt; start methods cannot currently be used with &amp;ldquo;frozen&amp;rdquo; executables (i.e., binaries produced by packages like &lt;strong&gt;PyInstaller&lt;/strong&gt; and &lt;strong&gt;cx_Freeze&lt;/strong&gt;) on Unix. The &lt;code&gt;'fork'&lt;/code&gt; start method does work.</source>
          <target state="translated">&lt;code&gt;'spawn'&lt;/code&gt; 과 &lt;code&gt;'forkserver'&lt;/code&gt; 방법이 현재 (즉, 같은 패키지에 의해 생성 된 바이너리 &quot;냉동&quot;실행 파일을 사용할 수 없습니다 시작 &lt;strong&gt;pyInstaller 중에&lt;/strong&gt; 와 &lt;strong&gt;나 cx_Freeze&lt;/strong&gt; ) 유닉스. &lt;code&gt;'fork'&lt;/code&gt; 시작 방법은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="adef4fc3618584c3f50f2758661fb96fa19c2234" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'u'&lt;/code&gt; type code corresponds to Python&amp;rsquo;s obsolete unicode character (&lt;a href=&quot;https://docs.python.org/3.8/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt; which is &lt;code&gt;wchar_t&lt;/code&gt;). Depending on the platform, it can be 16 bits or 32 bits.</source>
          <target state="translated">&lt;code&gt;'u'&lt;/code&gt; (파이썬의 사용되지 않는 유니 코드 문자를 입력 코드에 대응 &lt;a href=&quot;https://docs.python.org/3.8/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; &lt;/a&gt; 입니다 &lt;code&gt;wchar_t&lt;/code&gt; 를 ). 플랫폼에 따라 16 비트 또는 32 비트 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c947a2e5b4b365958137ab1c93d552f460d46b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'x'&lt;/code&gt; mode was added.</source>
          <target state="translated">&lt;code&gt;'x'&lt;/code&gt; 모드가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7bbeb9294fba3141e309a6b58e12d5136a037789" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.pyc&lt;/code&gt; file includes a hash of the source file content, which Python will compare against the source at runtime to determine if the &lt;code&gt;.pyc&lt;/code&gt; file needs to be regenerated.</source>
          <target state="translated">&lt;code&gt;.pyc&lt;/code&gt; 파일은 파이썬이 있는지 확인하기 위해 런타임에 소스에 대해 비교합니다 소스 파일 내용의 해시 포함 &lt;code&gt;.pyc&lt;/code&gt; 파일의 요구가 재생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41102abee06a7be2913a11ad4a23f9f58926e024" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.pyc&lt;/code&gt; file includes the timestamp and size of the source file, which Python will compare against the metadata of the source file at runtime to determine if the &lt;code&gt;.pyc&lt;/code&gt; file needs to be regenerated.</source>
          <target state="translated">&lt;code&gt;.pyc&lt;/code&gt; 파일은 파이썬이 있는지 확인하기 위해 런타임에 소스 파일의 메타 데이터와 비교합니다 소스 파일의 타임 스탬프와 크기, 포함 &lt;code&gt;.pyc&lt;/code&gt; 파일의 요구가 재생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a573c16cb80e8fe9674796ab260ceb7cbc3fe3e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:?&lt;/code&gt; pattern matches the colon after the last name, so that it does not occur in the result list. With a &lt;code&gt;maxsplit&lt;/code&gt; of &lt;code&gt;4&lt;/code&gt;, we could separate the house number from the street name:</source>
          <target state="translated">&lt;code&gt;:?&lt;/code&gt; 패턴은 성 다음의 콜론과 일치하므로 결과 목록에 나타나지 않습니다. A를 &lt;code&gt;maxsplit&lt;/code&gt; 의 &lt;code&gt;4&lt;/code&gt; , 우리는 거리 이름과 집 번호를 분리 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cc57d505c38b0eb494f685993037d2665517e08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@classmethod&lt;/code&gt; form is a function &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; &amp;ndash; see &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#function&quot;&gt;Function definitions&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;@classmethod&lt;/code&gt; 의 형태는 기능입니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;장식&lt;/a&gt; - 참조 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#function&quot;&gt;기능 정의를&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="8cdc6e71c4a11c2ee7cd108a9fa0910a7827a59b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@overload&lt;/code&gt; decorator allows describing functions and methods that support multiple different combinations of argument types. A series of &lt;code&gt;@overload&lt;/code&gt;-decorated definitions must be followed by exactly one non-&lt;code&gt;@overload&lt;/code&gt;-decorated definition (for the same function/method). The &lt;code&gt;@overload&lt;/code&gt;-decorated definitions are for the benefit of the type checker only, since they will be overwritten by the non-&lt;code&gt;@overload&lt;/code&gt;-decorated definition, while the latter is used at runtime but should be ignored by a type checker. At runtime, calling a &lt;code&gt;@overload&lt;/code&gt;-decorated function directly will raise &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt;&lt;code&gt;NotImplementedError&lt;/code&gt;&lt;/a&gt;. An example of overload that gives a more precise type than can be expressed using a union or a type variable:</source>
          <target state="translated">&lt;code&gt;@overload&lt;/code&gt; 의 장식 인수 종류의 여러 상이한 조합을 지원하는 기능 및 방법을 설명 할 수 있습니다. 일련의 &lt;code&gt;@overload&lt;/code&gt; 로 장식 된 정의 뒤에는 정확히 하나의 &lt;code&gt;@overload&lt;/code&gt; 로 장식되지 않은 정의가 있어야합니다 (동일한 기능 / 방법에 대해). &lt;code&gt;@overload&lt;/code&gt; 가 비 덮어 쓰기 때문에 -decorated 정의는, 단지 형 검사기의 이익을위한 것입니다 &lt;code&gt;@overload&lt;/code&gt; -decorated 정의 후자가 런타임에 사용되지만 유형 검사에 의해 무시되어야하는 동안. 런타임에 &lt;code&gt;@overload&lt;/code&gt; -decorated 함수를 직접 호출하면 NotImplementedError 가 &lt;a href=&quot;exceptions#NotImplementedError&quot;&gt; &lt;code&gt;NotImplementedError&lt;/code&gt; &lt;/a&gt;. 공용체 또는 유형 변수를 사용하여 표현할 수있는 것보다 정확한 유형을 제공하는 과부하의 예 :</target>
        </trans-unit>
        <trans-unit id="86d1c0468eec97ef063c81a25b38effe8beb236a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@property&lt;/code&gt; decorator turns the &lt;code&gt;voltage()&lt;/code&gt; method into a &amp;ldquo;getter&amp;rdquo; for a read-only attribute with the same name, and it sets the docstring for &lt;em&gt;voltage&lt;/em&gt; to &amp;ldquo;Get the current voltage.&amp;rdquo;</source>
          <target state="translated">&lt;code&gt;@property&lt;/code&gt; 의 장식은 온 &lt;code&gt;voltage()&lt;/code&gt; 과 동일한 이름을 갖는 판독 전용 속성의 &quot;게터&quot;로 방법, 그리고 대한 참조 문을 설정 &lt;em&gt;전압&lt;/em&gt; 에 &quot;현재 전압하세요.&quot;</target>
        </trans-unit>
        <trans-unit id="e9a0de22a543be5823e8fc00bdf1bc19e1836998" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@staticmethod&lt;/code&gt; form is a function &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;decorator&lt;/a&gt; &amp;ndash; see &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#function&quot;&gt;Function definitions&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;@staticmethod&lt;/code&gt; 의 형태는 기능입니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-decorator&quot;&gt;장식&lt;/a&gt; - 참조 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#function&quot;&gt;기능 정의를&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="1134bfad7e728a8c50f8c0e2b0e36568e03a0665" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AUTH&lt;/code&gt; command is not supported by the server.</source>
          <target state="translated">&lt;code&gt;AUTH&lt;/code&gt; 의 명령은 서버에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72a7880652409c5976ca3dfe4bf7cf1e1ffc4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Any&lt;/code&gt; type</source>
          <target state="translated">&lt;code&gt;Any&lt;/code&gt; 유형</target>
        </trans-unit>
        <trans-unit id="08ef83d6c825495ed685c5e095ac1ea8add9f9a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Attributes&lt;/code&gt; Interface</source>
          <target state="translated">는 &lt;code&gt;Attributes&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="5d5712e868fcd76470aa0d1b67f60f6da25288af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AttributesNS&lt;/code&gt; Interface</source>
          <target state="translated">&lt;code&gt;AttributesNS&lt;/code&gt; 인터페이스</target>
        </trans-unit>
        <trans-unit id="1866cebe2c58853ca647a2457b47007a6b73cab7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CAN_BCM_CAN_FD_FRAME&lt;/code&gt; flag is only available on Linux &amp;gt;= 4.8.</source>
          <target state="translated">&lt;code&gt;CAN_BCM_CAN_FD_FRAME&lt;/code&gt; 의 플래그 리눅스&amp;gt; = 4.8에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4328f0909355ebc7b140a3c105fbd8ceaf492a6f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOMImplementation&lt;/code&gt; interface provides a way for applications to determine the availability of particular features in the DOM they are using. DOM Level 2 added the ability to create new &lt;code&gt;Document&lt;/code&gt; and &lt;code&gt;DocumentType&lt;/code&gt; objects using the &lt;code&gt;DOMImplementation&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;DOMImplementation&lt;/code&gt; 인터페이스는 응용 프로그램들이 사용하는 DOM의 특정 기능의 사용 가능 여부를 확인하는 방법을 제공합니다. DOM Level 2 는 &lt;code&gt;DOMImplementation&lt;/code&gt; 을 사용하여 새로운 &lt;code&gt;Document&lt;/code&gt; 및 &lt;code&gt;DocumentType&lt;/code&gt; 객체 를 생성하는 기능을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="ceb6ddc3543e53a154f8edc359027b84c0cc9c41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DistributionFinder.Context&lt;/code&gt; object provides &lt;code&gt;.path&lt;/code&gt; and &lt;code&gt;.name&lt;/code&gt; properties indicating the path to search and names to match and may supply other relevant context.</source>
          <target state="translated">&lt;code&gt;DistributionFinder.Context&lt;/code&gt; 의 개체가 제공 &lt;code&gt;.path&lt;/code&gt; 및 &lt;code&gt;.name&lt;/code&gt; 을 경로를 나타내는 속성을 검색하고 일치하는 이름 및 기타 관련 컨텍스트를 제공 할 수 있습니다 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595f270592a8413c36ba336bfcceb50a835ab5b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EnumMeta&lt;/code&gt; metaclass is responsible for providing the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt;&lt;code&gt;__contains__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt;&lt;code&gt;__dir__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt;&lt;code&gt;__iter__()&lt;/code&gt;&lt;/a&gt; and other methods that allow one to do things with an &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; class that fail on a typical class, such as &lt;code&gt;list(Color)&lt;/code&gt; or &lt;code&gt;some_enum_var in Color&lt;/code&gt;. &lt;code&gt;EnumMeta&lt;/code&gt; is responsible for ensuring that various other methods on the final &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; class are correct (such as &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;pickle#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt;&lt;code&gt;__repr__()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;EnumMeta&lt;/code&gt; 의 메타 클래스가 제공 할 책임이 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__contains__&quot;&gt; &lt;code&gt;__contains__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__dir__&quot;&gt; &lt;code&gt;__dir__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__iter__&quot;&gt; &lt;code&gt;__iter__()&lt;/code&gt; &lt;/a&gt; 과 하나는 함께 일을 할 수있는 다른 방법을 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 같은 일반적인 클래스에 실패 클래스 &lt;code&gt;list(Color)&lt;/code&gt; 또는 &lt;code&gt;some_enum_var in Color&lt;/code&gt; . &lt;code&gt;EnumMeta&lt;/code&gt; 는 최종 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 클래스 의 다양한 다른 메소드 (예 : &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;pickle#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__repr__&quot;&gt; &lt;code&gt;__repr__()&lt;/code&gt; &lt;/a&gt; )가 올바른지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="5d69ba1589530352dd1f5dd4e45bac251bfe088b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FieldStorage&lt;/code&gt; instance can be indexed like a Python dictionary. It allows membership testing with the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt;&lt;code&gt;in&lt;/code&gt;&lt;/a&gt; operator, and also supports the standard dictionary method &lt;a href=&quot;stdtypes#dict.keys&quot;&gt;&lt;code&gt;keys()&lt;/code&gt;&lt;/a&gt; and the built-in function &lt;a href=&quot;functions#len&quot;&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/a&gt;. Form fields containing empty strings are ignored and do not appear in the dictionary; to keep such values, provide a true value for the optional &lt;em&gt;keep_blank_values&lt;/em&gt; keyword parameter when creating the &lt;code&gt;FieldStorage&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;FieldStorage&lt;/code&gt; 의 인스턴스는 파이썬 사전처럼 인덱싱 할 수 있습니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#in&quot;&gt; &lt;code&gt;in&lt;/code&gt; &lt;/a&gt; 연산자로 멤버쉽 테스트를 수행 할 수 있으며 표준 사전 메소드 &lt;a href=&quot;stdtypes#dict.keys&quot;&gt; &lt;code&gt;keys()&lt;/code&gt; &lt;/a&gt; 및 내장 함수 &lt;a href=&quot;functions#len&quot;&gt; &lt;code&gt;len()&lt;/code&gt; &lt;/a&gt; 도 지원합니다 . 빈 문자열을 포함하는 양식 필드는 무시되며 사전에 나타나지 않습니다. 이러한 값을 유지 하려면 &lt;code&gt;FieldStorage&lt;/code&gt; 인스턴스를 작성할 때 선택적 &lt;em&gt;keep_blank_values&lt;/em&gt; 키워드 매개 변수에 true 값을 제공하십시오 .</target>
        </trans-unit>
        <trans-unit id="bc007293220ad574c1fcd983a7ec8c5d4fbd6307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lib/turtledemo&lt;/code&gt; directory contains a &lt;code&gt;turtle.cfg&lt;/code&gt; file. You can study it as an example and see its effects when running the demos (preferably not from within the demo-viewer).</source>
          <target state="translated">&lt;code&gt;Lib/turtledemo&lt;/code&gt; 디렉토리는 포함 &lt;code&gt;turtle.cfg&lt;/code&gt; 의 파일을. 예제로 연구하고 데모를 실행할 때 그 효과를 볼 수 있습니다 (바람직하게는 데모 뷰어가 아닌).</target>
        </trans-unit>
        <trans-unit id="ae122c966f98b743129b8e2eb8ae111c4c5f37fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MessageBox&lt;/code&gt; foreign function can now be called in these ways:</source>
          <target state="translated">&lt;code&gt;MessageBox&lt;/code&gt; 외국 기능은 이제 다음과 같은 방법으로 호출 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e14135cf6dd26c3e1d281555a749c86475cd4969" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;None&lt;/code&gt; constant. Passing is allowed only if &lt;em&gt;allow_none&lt;/em&gt; is true.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 정수입니다. &lt;em&gt;allow_none&lt;/em&gt; 이 true 인 경우에만 전달이 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="0dc13f9481c47256735a6380f63398af874a2bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Package&lt;/code&gt; type is defined as &lt;code&gt;Union[str, ModuleType]&lt;/code&gt;. This means that where the function describes accepting a &lt;code&gt;Package&lt;/code&gt;, you can pass in either a string or a module. Module objects must have a resolvable &lt;code&gt;__spec__.submodule_search_locations&lt;/code&gt; that is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Package&lt;/code&gt; 유형으로 정의 &lt;code&gt;Union[str, ModuleType]&lt;/code&gt; . 즉, 함수가 &lt;code&gt;Package&lt;/code&gt; 수락을 설명하는 경우 문자열 또는 모듈을 전달할 수 있습니다. 모듈 객체는 해석이 있어야합니다 &lt;code&gt;__spec__.submodule_search_locations&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f32e3fb82b3c83abc395d93958c1777b6e5e38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SMTP&lt;/code&gt; class provides &lt;code&gt;authobjects&lt;/code&gt; for the &lt;code&gt;CRAM-MD5&lt;/code&gt;, &lt;code&gt;PLAIN&lt;/code&gt;, and &lt;code&gt;LOGIN&lt;/code&gt; mechanisms; they are named &lt;code&gt;SMTP.auth_cram_md5&lt;/code&gt;, &lt;code&gt;SMTP.auth_plain&lt;/code&gt;, and &lt;code&gt;SMTP.auth_login&lt;/code&gt; respectively. They all require that the &lt;code&gt;user&lt;/code&gt; and &lt;code&gt;password&lt;/code&gt; properties of the &lt;code&gt;SMTP&lt;/code&gt; instance are set to appropriate values.</source>
          <target state="translated">&lt;code&gt;SMTP&lt;/code&gt; 의 클래스를 제공 &lt;code&gt;authobjects&lt;/code&gt; 에 대한 &lt;code&gt;CRAM-MD5&lt;/code&gt; , &lt;code&gt;PLAIN&lt;/code&gt; , 및 &lt;code&gt;LOGIN&lt;/code&gt; 메커니즘을; 이름은 각각 &lt;code&gt;SMTP.auth_cram_md5&lt;/code&gt; , &lt;code&gt;SMTP.auth_plain&lt;/code&gt; 및 &lt;code&gt;SMTP.auth_login&lt;/code&gt; 입니다. 모두 &lt;code&gt;SMTP&lt;/code&gt; 인스턴스 의 &lt;code&gt;user&lt;/code&gt; 및 &lt;code&gt;password&lt;/code&gt; 속성이 적절한 값으로 설정되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7a1cf223256389df786f4a089e7a5f771da06658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Stats&lt;/code&gt; Class</source>
          <target state="translated">&lt;code&gt;Stats&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="7b6323f0d9a01c8bacf864cdae4d5a57325ea708" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEDESC&lt;/code&gt; structure describes a COM data type, the &lt;code&gt;vt&lt;/code&gt; field specifies which one of the union fields is valid. Since the &lt;code&gt;u&lt;/code&gt; field is defined as anonymous field, it is now possible to access the members directly off the TYPEDESC instance. &lt;code&gt;td.lptdesc&lt;/code&gt; and &lt;code&gt;td.u.lptdesc&lt;/code&gt; are equivalent, but the former is faster since it does not need to create a temporary union instance:</source>
          <target state="translated">&lt;code&gt;TYPEDESC&lt;/code&gt; 구조는 COM 데이터 유형을 설명하며 &lt;code&gt;vt&lt;/code&gt; 필드 는 공용 필드 중 어느 것이 유효한지를 지정합니다. 때문에 &lt;code&gt;u&lt;/code&gt; 필드가 익명의 필드로 정의됩니다, 직접 TYPEDESC 인스턴스 떨어져 멤버에 액세스 할 수있게되었습니다. &lt;code&gt;td.lptdesc&lt;/code&gt; 와 &lt;code&gt;td.u.lptdesc&lt;/code&gt; 는 동일하지만 임시 결합 인스턴스를 작성할 필요가 없기 때문에 전자가 더 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f9ea1769001491fd452c7e549a3da58d9eb40808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Text&lt;/code&gt; interface represents text in the XML document. If the parser and DOM implementation support the DOM&amp;rsquo;s XML extension, portions of the text enclosed in CDATA marked sections are stored in &lt;code&gt;CDATASection&lt;/code&gt; objects. These two interfaces are identical, but provide different values for the &lt;code&gt;nodeType&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;Text&lt;/code&gt; 인터페이스는 XML 문서 의 텍스트 를 나타냅니다. 파서 및 DOM 구현이 DOM의 XML 확장을 지원하면 CDATA로 표시된 섹션으로 묶인 텍스트 부분이 &lt;code&gt;CDATASection&lt;/code&gt; 객체에 저장 됩니다. 이 두 인터페이스는 동일하지만 &lt;code&gt;nodeType&lt;/code&gt; 속성에 다른 값을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="f68d9bca14cc73a34996c6d88e3f294d7d02e0fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Widget&lt;/code&gt; class is not meant to be instantiated, it is meant only for subclassing to make &amp;ldquo;real&amp;rdquo; widgets (in C++, this is called an &amp;lsquo;abstract class&amp;rsquo;).</source>
          <target state="translated">&lt;code&gt;Widget&lt;/code&gt; 전용 &quot;진짜&quot;위젯을 만들기 위해 서브 클래스에 대한 클래스가 인스턴스화하는 것은 아닙니다 그것이 의미 (C에서 + +, 이것은 '추상 클래스'라고합니다).</target>
        </trans-unit>
        <trans-unit id="d2a297f57cd1bc861efed1e813b4b8a2f8061b73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__call__&lt;/code&gt; method may perform arbitrary actions, but will typically set attributes on the &lt;code&gt;namespace&lt;/code&gt; based on &lt;code&gt;dest&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__call__&lt;/code&gt; 의 방법은 임의의 작업을 수행 할 수 있지만, 일반적으로에 속성을 설정합니다 &lt;code&gt;namespace&lt;/code&gt; 를 기반으로 &lt;code&gt;dest&lt;/code&gt; 및 &lt;code&gt;values&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc938070d6c39bccc58652b25fa0b1e1af788ab6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__main__&lt;/code&gt; module must be importable by worker subprocesses. This means that &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt;&lt;code&gt;ProcessPoolExecutor&lt;/code&gt;&lt;/a&gt; will not work in the interactive interpreter.</source>
          <target state="translated">&lt;code&gt;__main__&lt;/code&gt; 의 모듈은 작업자 서브 프로세스에 의해 수입 할 수 있어야합니다. 이는 &lt;a href=&quot;#concurrent.futures.ProcessPoolExecutor&quot;&gt; &lt;code&gt;ProcessPoolExecutor&lt;/code&gt; &lt;/a&gt; 가 대화식 인터프리터에서 작동하지 않음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="af193d5902a95c55c4324893e16623ef88c8dc8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__members__&lt;/code&gt; attribute can be used for detailed programmatic access to the enumeration members. For example, finding all the aliases:</source>
          <target state="translated">&lt;code&gt;__members__&lt;/code&gt; 의 속성은 열거 회원에 대한 자세한 프로그래밍 방식의 액세스에 사용할 수 있습니다. 예를 들어, 모든 별명 찾기 :</target>
        </trans-unit>
        <trans-unit id="a87425a1104799def71154528dfd19ddddcfb54d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__name__&lt;/code&gt; attribute of generators is now set from the function name, instead of the code name, and it can now be modified.</source>
          <target state="translated">생성기 의 &lt;code&gt;__name__&lt;/code&gt; 속성이 이제 코드 이름 대신 함수 이름에서 설정되었으며 이제 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f0dcd079a594f43bb2a22125cfba03fcfd4cb33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__suppress_context__&lt;/code&gt; value from the original exception.</source>
          <target state="translated">원래 예외 의 &lt;code&gt;__suppress_context__&lt;/code&gt; 값</target>
        </trans-unit>
        <trans-unit id="9122ae2607633af14a0a527e56d351f46a1f76a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;args&lt;/code&gt; entry, when &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;uated in the context of the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace, is the list of arguments to the constructor for the handler class. Refer to the constructors for the relevant handlers, or to the examples below, to see how typical entries are constructed. If not provided, it defaults to &lt;code&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 항목, &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 의 맥락에서 uated &lt;code&gt;logging&lt;/code&gt; 패키지의 네임 스페이스, 핸들러 클래스의 생성자에 대한 인수의 목록입니다. 일반적인 항목이 구성되는 방법을 보려면 관련 처리기의 생성자 또는 아래 예를 참조하십시오. 제공되지 않은 경우 기본값은 &lt;code&gt;()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b936e943ecfcd201f6a825fee01f91c8aca05480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;asyncio&lt;/code&gt; subprocess API does not support decoding the streams as text. &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt;&lt;code&gt;bytes.decode()&lt;/code&gt;&lt;/a&gt; can be used to convert the bytes returned from the stream to text.</source>
          <target state="translated">&lt;code&gt;asyncio&lt;/code&gt; 서브 프로세스 API는 텍스트로 스트림을 디코딩을 지원하지 않습니다. &lt;a href=&quot;stdtypes#bytes.decode&quot;&gt; &lt;code&gt;bytes.decode()&lt;/code&gt; &lt;/a&gt; 는 스트림에서 반환 된 바이트를 텍스트로 변환하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec504929a2fb2ce3901b05f7e84e725f7539dce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;call&lt;/code&gt; objects in &lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt;&lt;code&gt;Mock.call_args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt;&lt;code&gt;Mock.call_args_list&lt;/code&gt;&lt;/a&gt; are two-tuples of (positional args, keyword args) whereas the &lt;code&gt;call&lt;/code&gt; objects in &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;Mock.mock_calls&lt;/code&gt;&lt;/a&gt;, along with ones you construct yourself, are three-tuples of (name, positional args, keyword args).</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.call_args&quot;&gt; &lt;code&gt;Mock.call_args&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.call_args_list&quot;&gt; &lt;code&gt;Mock.call_args_list&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;call&lt;/code&gt; 객체 는 (위치 args, 키워드 args)의 두 튜플이지만 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;Mock.mock_calls&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;call&lt;/code&gt; 객체는 사용자가 구성하는 것과 함께 (이름, 위치 args, 키워드 인수).</target>
        </trans-unit>
        <trans-unit id="f0095fb07694807b7d7160a1ed193f2c7fb50cbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;class&lt;/code&gt; entry indicates the handler&amp;rsquo;s class (as determined by &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace). The &lt;code&gt;level&lt;/code&gt; is interpreted as for loggers, and &lt;code&gt;NOTSET&lt;/code&gt; is taken to mean &amp;lsquo;log everything&amp;rsquo;.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 항목 (의 결정에 따라 핸들러의 클래스를 나타내는 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;logging&lt;/code&gt; 패키지의 이름 공간). &lt;code&gt;level&lt;/code&gt; 로거로 해석하고, &lt;code&gt;NOTSET&lt;/code&gt; 는 '로그 모든 것을'의미 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8f7bfa816dd3504e8292223adda9c4361b672f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;class&lt;/code&gt; entry is optional. It indicates the name of the formatter&amp;rsquo;s class (as a dotted module and class name.) This option is useful for instantiating a &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; subclass. Subclasses of &lt;a href=&quot;logging#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; can present exception tracebacks in an expanded or condensed format.</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 항목은 선택 사항입니다. 포맷터 클래스 이름 (점으로 구분 된 모듈 및 클래스 이름)을 나타냅니다.이 옵션은 &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스 를 인스턴스화하는 데 유용합니다 . &lt;a href=&quot;logging#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 서브 클래스 는 확장 또는 압축 형식으로 예외 추적을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ec22605f4896ed5a3fbb6991cb3daa62a8dc30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close()&lt;/code&gt; method is not implemented, &lt;a href=&quot;#contextlib.AsyncExitStack.aclose&quot;&gt;&lt;code&gt;aclose()&lt;/code&gt;&lt;/a&gt; must be used instead.</source>
          <target state="translated">&lt;code&gt;close()&lt;/code&gt; 메소드가 실행되지 않는다 &lt;a href=&quot;#contextlib.AsyncExitStack.aclose&quot;&gt; &lt;code&gt;aclose()&lt;/code&gt; &lt;/a&gt; 대신에 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="baf71b295297eb68de3b61fbcfcaf38f3dced956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method returns &lt;a href=&quot;constants#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; if the subprocess exited successfully, or the subprocess&amp;rsquo;s return code if there was an error. On POSIX systems, if the return code is positive it represents the return value of the process left-shifted by one byte. If the return code is negative, the process was terminated by the signal given by the negated value of the return code. (For example, the return value might be &lt;code&gt;- signal.SIGKILL&lt;/code&gt; if the subprocess was killed.) On Windows systems, the return value contains the signed integer return code from the child process.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 방법은 반환 &lt;a href=&quot;constants#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 에러가 발생했을 경우 서브 프로세스가 성공적으로 종료, 또는 하위 프로세스의 리턴 코드합니다. POSIX 시스템에서 리턴 코드가 양수이면 1 바이트 왼쪽으로 시프트 된 프로세스의 리턴 값을 나타냅니다. 리턴 코드가 음수이면, 리턴 코드의 부정 된 값에 의해 주어진 신호에 의해 프로세스가 종료되었습니다. (예를 들어, 서브 프로세스가 종료 된 경우 리턴 값은 &lt;code&gt;- signal.SIGKILL&lt;/code&gt; 일 수 있습니다 .) Windows 시스템에서 리턴 값에는 하위 프로세스의 부호있는 정수 리턴 코드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f3738771cfde745973ee9e9e6e59d483c5c69d30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code&lt;/code&gt; module provides facilities to implement read-eval-print loops in Python. Two classes and convenience functions are included which can be used to build applications which provide an interactive interpreter prompt.</source>
          <target state="translated">&lt;code&gt;code&lt;/code&gt; 모듈은 파이썬에서 읽기 평가 후면 인쇄 루프를 구현하는 기능을 제공합니다. 대화식 통역사 프롬프트를 제공하는 응용 프로그램을 빌드하는 데 사용할 수있는 두 개의 클래스와 편의 기능이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6f8a5f6cdeeb43455302373902fc6f690cfea1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;colon&lt;/code&gt; attribute may also be set on a per-instance basis.</source>
          <target state="translated">&lt;code&gt;colon&lt;/code&gt; 속성은 또한 인스턴스마다 설정 될 수있다.</target>
        </trans-unit>
        <trans-unit id="7fa8bb90452b238e4231410cf712c3c51172e7e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concurrent&lt;/code&gt; package</source>
          <target state="translated">&lt;code&gt;concurrent&lt;/code&gt; 패키지</target>
        </trans-unit>
        <trans-unit id="47958b98a21f02493afe011d1fe7fd47b89e4221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;const&lt;/code&gt; argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; is used to hold constant values that are not read from the command line but are required for the various &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; actions. The two most common uses of it are:</source>
          <target state="translated">&lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;const&lt;/code&gt; 인수 는 명령 줄에서 읽지 않지만 다양한 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 작업에 필요한 상수 값을 보유하는 데 사용됩니다 . 가장 일반적인 두 가지 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c1a6767fe12e172b4870adf50fb52b7ad98ffb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create&lt;/code&gt; method of the &lt;a href=&quot;#venv.EnvBuilder&quot;&gt;&lt;code&gt;EnvBuilder&lt;/code&gt;&lt;/a&gt; class illustrates the hooks available for subclass customization:</source>
          <target state="translated">&lt;a href=&quot;#venv.EnvBuilder&quot;&gt; &lt;code&gt;EnvBuilder&lt;/code&gt; &lt;/a&gt; 클래스 의 &lt;code&gt;create&lt;/code&gt; 메소드는 서브 클래스 사용자 정의에 사용 가능한 후크를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="2d03fa71ebb6e231d59aa9390e871246c5344d6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctypes.util&lt;/code&gt; module provides a function which can help to determine the library to load.</source>
          <target state="translated">&lt;code&gt;ctypes.util&lt;/code&gt; 모듈은 부하에 라이브러리를 결정하는 데 도움을 줄 수있는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7496909f52e59e234f12e33f691492d0ff1051aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ctypes.wintypes&lt;/code&gt; module provides quite some other Windows specific data types, for example &lt;code&gt;HWND&lt;/code&gt;, &lt;code&gt;WPARAM&lt;/code&gt;, or &lt;code&gt;DWORD&lt;/code&gt;. Some useful structures like &lt;code&gt;MSG&lt;/code&gt; or &lt;code&gt;RECT&lt;/code&gt; are also defined.</source>
          <target state="translated">&lt;code&gt;ctypes.wintypes&lt;/code&gt; 의 모듈은 예를 들어, 꽤 다른 Windows 특정 데이터 유형을 제공 &lt;code&gt;HWND&lt;/code&gt; , &lt;code&gt;WPARAM&lt;/code&gt; , 또는 &lt;code&gt;DWORD&lt;/code&gt; . &lt;code&gt;MSG&lt;/code&gt; 또는 &lt;code&gt;RECT&lt;/code&gt; 와 같은 유용한 구조 도 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4762e5a3dafdaba2c58c248e6d2ff0abbc78c9e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decoded&lt;/code&gt; value of the header is determined by formatting the &lt;code&gt;datetime&lt;/code&gt; according to the &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; rules; that is, it is set to:</source>
          <target state="translated">헤더 의 &lt;code&gt;decoded&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-8&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 규칙 에 따라 &lt;code&gt;datetime&lt;/code&gt; 을 포맷함으로써 결정되며 ; 즉, 다음과 같이 설정됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0bf7c8f5ef57293f4a035c7235afdf736241c388" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decoded&lt;/code&gt; value of the header will have all encoded words decoded to unicode. &lt;a href=&quot;codecs#module-encodings.idna&quot;&gt;&lt;code&gt;idna&lt;/code&gt;&lt;/a&gt; encoded domain names are also decoded to unicode. The &lt;code&gt;decoded&lt;/code&gt; value is set by &lt;a href=&quot;stdtypes#str.join&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt;ing the &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; value of the elements of the &lt;code&gt;groups&lt;/code&gt; attribute with &lt;code&gt;',
'&lt;/code&gt;.</source>
          <target state="translated">헤더 의 &lt;code&gt;decoded&lt;/code&gt; 값은 모든 인코딩 된 단어를 유니 코드로 디코딩 할 것이다. &lt;a href=&quot;codecs#module-encodings.idna&quot;&gt; &lt;code&gt;idna&lt;/code&gt; 로&lt;/a&gt; 인코딩 된 도메인 이름도 유니 코드로 디코딩됩니다. &lt;code&gt;decoded&lt;/code&gt; 하여 설정 값은 &lt;a href=&quot;stdtypes#str.join&quot;&gt; &lt;code&gt;join&lt;/code&gt; &lt;/a&gt; ING를 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 의 요소의 값이 &lt;code&gt;groups&lt;/code&gt; 으로 속성 &lt;code&gt;', '&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fa89fca3d85626b155af4cfba20357d4cc96830" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defusedxml&lt;/code&gt; and &lt;code&gt;defusedexpat&lt;/code&gt; Packages</source>
          <target state="translated">&lt;code&gt;defusedxml&lt;/code&gt; 및 &lt;code&gt;defusedexpat&lt;/code&gt; 패키지</target>
        </trans-unit>
        <trans-unit id="dfc2ee4946a057f25375d575b48219960fa9f49b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dircmp&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;dircmp&lt;/code&gt; 클래스</target>
        </trans-unit>
        <trans-unit id="8ffc245c6775a61d7871af9ec0f8704fe5eef1cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;discover&lt;/code&gt; sub-command has the following options:</source>
          <target state="translated">는 &lt;code&gt;discover&lt;/code&gt; 하위 명령은 다음과 같은 옵션이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="648875dd3e0111333c4afffc1af11bfc7a4a6c31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_name&lt;/code&gt; of the group. If it is &lt;code&gt;None&lt;/code&gt; and there is exactly one &lt;code&gt;Address&lt;/code&gt; in &lt;code&gt;addresses&lt;/code&gt;, then the &lt;code&gt;Group&lt;/code&gt; represents a single address that is not in a group.</source>
          <target state="translated">그룹 의 &lt;code&gt;display_name&lt;/code&gt; 입니다. 이없는 경우 &lt;code&gt;None&lt;/code&gt; 하나 개 정확히이 &lt;code&gt;Address&lt;/code&gt; 의 &lt;code&gt;addresses&lt;/code&gt; 다음 &lt;code&gt;Group&lt;/code&gt; 그룹에 포함되지 않은 하나의 주소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b7b171073f1958b4ddf2620702c25cb5e7487c86" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do_GET()&lt;/code&gt; and &lt;code&gt;do_HEAD()&lt;/code&gt; functions are modified to run CGI scripts and serve the output, instead of serving files, if the request leads to somewhere below the &lt;code&gt;cgi_directories&lt;/code&gt; path.</source>
          <target state="translated">&lt;code&gt;do_GET()&lt;/code&gt; 및 &lt;code&gt;do_HEAD()&lt;/code&gt; 함수는 요청 리드 경우 아래 어딘가에 대신 파일을 제공의 출력을 CGI 스크립트를 실행하고 봉사하는 수정 &lt;code&gt;cgi_directories&lt;/code&gt; 의 경로.</target>
        </trans-unit>
        <trans-unit id="c3677fc05242ea4075af857b2c902b5aceeacc42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;domain&lt;/code&gt; portion of the address.</source>
          <target state="translated">주소 의 &lt;code&gt;domain&lt;/code&gt; 부분.</target>
        </trans-unit>
        <trans-unit id="705f2d3bcf70b0357b08a41f5d6b8adc484dd65b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;entry_points()&lt;/code&gt; function returns a dictionary of all entry points, keyed by group. Entry points are represented by &lt;code&gt;EntryPoint&lt;/code&gt; instances; each &lt;code&gt;EntryPoint&lt;/code&gt; has a &lt;code&gt;.name&lt;/code&gt;, &lt;code&gt;.group&lt;/code&gt;, and &lt;code&gt;.value&lt;/code&gt; attributes and a &lt;code&gt;.load()&lt;/code&gt; method to resolve the value.</source>
          <target state="translated">&lt;code&gt;entry_points()&lt;/code&gt; 함수는 그룹에 의해 키가 모든 진입 점의 사전을 반환합니다. 진입 점은 &lt;code&gt;EntryPoint&lt;/code&gt; 인스턴스 로 표시됩니다 . 각 &lt;code&gt;EntryPoint&lt;/code&gt; 에는 값을 확인하기위한 &lt;code&gt;.name&lt;/code&gt; , &lt;code&gt;.group&lt;/code&gt; 및 &lt;code&gt;.value&lt;/code&gt; 속성과 &lt;code&gt;.load()&lt;/code&gt; 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="470247d84f91b5ace4b798cb71b48d89f4faa7c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors&lt;/code&gt; module has the following attributes:</source>
          <target state="translated">&lt;code&gt;errors&lt;/code&gt; 모듈은 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="9b83f601ca71c62648a67d0ae21f05a3c4105c9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method can return any of the types supported by SQLite: bytes, str, int, float and &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;finalize&lt;/code&gt; 바이트, STR, INT, 플로트와 : 방법은 SQLite는 지원하는 유형의 반환 할 수 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27b6f5afd09e8d42f8ef61e3e33d7e1326356e9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find*()&lt;/code&gt; routines might look a bit funny at first sight. They are primarily meant to do echo cancellation. A reasonably fast way to do this is to pick the most energetic piece of the output sample, locate that in the input sample and subtract the whole output sample from the input sample:</source>
          <target state="translated">&lt;code&gt;find*()&lt;/code&gt; 루틴은 첫눈에 재미 좀 볼 수 있습니다. 주로 에코 제거를 수행합니다. 이렇게하는 가장 빠른 방법은 출력 샘플 중 가장 에너지가 많은 부분을 선택하고 입력 샘플에서 해당 샘플을 찾아 입력 샘플에서 전체 출력 샘플을 빼는 것입니다.</target>
        </trans-unit>
        <trans-unit id="cabfb6998c66a156b607518aa9258a73d1121858" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;format&lt;/code&gt; entry is the overall format string, and the &lt;code&gt;datefmt&lt;/code&gt; entry is the &lt;code&gt;strftime()&lt;/code&gt;-compatible date/time format string. If empty, the package substitutes something which is almost equivalent to specifying the date format string &lt;code&gt;'%Y-%m-%d %H:%M:%S'&lt;/code&gt;. This format also specifies milliseconds, which are appended to the result of using the above format string, with a comma separator. An example time in this format is &lt;code&gt;2003-01-23 00:29:50,411&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;format&lt;/code&gt; 항목은 전체 형식 문자열이며, &lt;code&gt;datefmt&lt;/code&gt; 의 항목은이다 &lt;code&gt;strftime()&lt;/code&gt; 호환 날짜 / 시간 형식 문자열입니다. 비어있는 경우 패키지는 날짜 형식 문자열 &lt;code&gt;'%Y-%m-%d %H:%M:%S'&lt;/code&gt; 를 지정하는 것과 거의 동일한 것을 대체합니다 . 이 형식은 또한 밀리 초를 지정합니다. 밀리 초는 위 형식 문자열을 사용한 결과에 쉼표 구분 기호와 함께 추가됩니다. 이 형식의 예제 시간은 &lt;code&gt;2003-01-23 00:29:50,411&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="17356f2f06eb5423af82d8f66e100cef27b9c151" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;formatter&lt;/code&gt; entry indicates the key name of the formatter for this handler. If blank, a default formatter (&lt;code&gt;logging._defaultFormatter&lt;/code&gt;) is used. If a name is specified, it must appear in the &lt;code&gt;[formatters]&lt;/code&gt; section and have a corresponding section in the configuration file.</source>
          <target state="translated">&lt;code&gt;formatter&lt;/code&gt; 항목이 핸들러에 대한 포맷터의 키 이름을 나타냅니다. 비어 있으면 기본 포맷터 ( &lt;code&gt;logging._defaultFormatter&lt;/code&gt; )가 사용됩니다. 이름이 지정되면 &lt;code&gt;[formatters]&lt;/code&gt; 섹션에 나타나고 구성 파일에 해당 섹션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e965f45c045d1ea3947a47df71b810d8c5eccba9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;formatweekday()&lt;/code&gt; and &lt;code&gt;formatmonthname()&lt;/code&gt; methods of these two classes temporarily change the current locale to the given &lt;em&gt;locale&lt;/em&gt;. Because the current locale is a process-wide setting, they are not thread-safe.</source>
          <target state="translated">이 두 클래스 의 &lt;code&gt;formatweekday()&lt;/code&gt; 및 &lt;code&gt;formatmonthname()&lt;/code&gt; 메소드는 현재 로케일을 주어진 &lt;em&gt;로케일&lt;/em&gt; 로 임시 변경합니다 . 현재 로캘은 프로세스 전체 설정이므로 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f09d559d6b736bafa34f34c899e2feab29c13e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fromfile_prefix_chars=&lt;/code&gt; argument defaults to &lt;code&gt;None&lt;/code&gt;, meaning that arguments will never be treated as file references.</source>
          <target state="translated">&lt;code&gt;fromfile_prefix_chars=&lt;/code&gt; 에 인수 기본값 &lt;code&gt;None&lt;/code&gt; 이 인수 의미는, 파일 참조로 취급되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66ce82075ae6e82092c56a7bcf7aa3f519092869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; are arbitrary values defined by the package author and usually a client will wish to resolve all entry points for a particular group. Read &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;the setuptools docs&lt;/a&gt; for more information on entrypoints, their definition, and usage.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 과 &lt;code&gt;name&lt;/code&gt; 패키지 작성자가 정의한 임의의 값이며, 일반적으로 클라이언트가 특정 그룹에 대한 모든 진입 점을 해결하고자하는 것입니다. 진입 점, 정의 및 사용법에 대한 자세한 정보 &lt;a href=&quot;https://setuptools.readthedocs.io/en/latest/setuptools.html#dynamic-discovery-of-services-and-plugins&quot;&gt;는 setuptools 문서&lt;/a&gt; 를 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="734b8ef87e08eaf3f6a91d381e68a3ec5afe96cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handle_request()&lt;/code&gt; method is called once all relevant input has been marshalled, after setting the channel terminator to &lt;code&gt;None&lt;/code&gt; to ensure that any extraneous data sent by the web client are ignored.</source>
          <target state="translated">&lt;code&gt;handle_request()&lt;/code&gt; 관련된 모든 입력 채널에 터미네이터를 설정 한 후, 정렬 화 된 후에 방법이라고 &lt;code&gt;None&lt;/code&gt; 웹 클라이언트에 의해 전송 된 외부 데이터는 무시되도록.</target>
        </trans-unit>
        <trans-unit id="cc968396993a8b75be630e29fb2af6f69b3b6185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handlers&lt;/code&gt; entry is a comma-separated list of handler names, which must appear in the &lt;code&gt;[handlers]&lt;/code&gt; section. These names must appear in the &lt;code&gt;[handlers]&lt;/code&gt; section and have corresponding sections in the configuration file.</source>
          <target state="translated">&lt;code&gt;handlers&lt;/code&gt; 항목이 표시되어야 핸들러 이름 쉼표로 구분이다 &lt;code&gt;[handlers]&lt;/code&gt; 부. 이러한 이름은 &lt;code&gt;[handlers]&lt;/code&gt; 섹션에 나타나고 구성 파일에 해당 섹션이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d0bdbe8053135d93602cf27febee65acb6f80d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help&lt;/code&gt; strings can include various format specifiers to avoid repetition of things like the program name or the argument &lt;a href=&quot;#default&quot;&gt;default&lt;/a&gt;. The available specifiers include the program name, &lt;code&gt;%(prog)s&lt;/code&gt; and most keyword arguments to &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt;, e.g. &lt;code&gt;%(default)s&lt;/code&gt;, &lt;code&gt;%(type)s&lt;/code&gt;, etc.:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 문자열은 프로그램 이름이나 인수 같은 것들의 반복을 피하기 위해 다양한 형식 지정자를 포함 할 수 있습니다 &lt;a href=&quot;#default&quot;&gt;기본&lt;/a&gt; . 사용 가능한 지정자에는 프로그램 이름, &lt;code&gt;%(prog)s&lt;/code&gt; 및 &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 대한 대부분의 키워드 인수가 포함 됩니다 ( 예 : &lt;code&gt;%(default)s&lt;/code&gt; , &lt;code&gt;%(type)s&lt;/code&gt; 등).</target>
        </trans-unit>
        <trans-unit id="8376e018657c4b93a09c801a30a071868534e6e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;help&lt;/code&gt; value is a string containing a brief description of the argument. When a user requests help (usually by using &lt;code&gt;-h&lt;/code&gt; or &lt;code&gt;--help&lt;/code&gt; at the command line), these &lt;code&gt;help&lt;/code&gt; descriptions will be displayed with each argument:</source>
          <target state="translated">&lt;code&gt;help&lt;/code&gt; 값은 인수에 대한 간략한 설명을 포함하는 문자열입니다. 사용자가 도움말을 요청하면 (일반적으로 명령 행에서 &lt;code&gt;-h&lt;/code&gt; 또는 &lt;code&gt;--help&lt;/code&gt; 를 사용하여 ) 다음과 같은 &lt;code&gt;help&lt;/code&gt; 설명이 각 인수와 함께 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e141e9805f4250470f88de20907a8951788930fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;in&lt;/code&gt; and &lt;code&gt;not in&lt;/code&gt; operations have the same priorities as the comparison operations. The &lt;code&gt;+&lt;/code&gt; (concatenation) and &lt;code&gt;*&lt;/code&gt; (repetition) operations have the same priority as the corresponding numeric operations. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;3&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;in&lt;/code&gt; 와 &lt;code&gt;not in&lt;/code&gt; 작업은 비교 연산과 같은 우선 순위를 가지고있다. &lt;code&gt;+&lt;/code&gt; (연결) 및 &lt;code&gt;*&lt;/code&gt; (반복) 조작 대응 수치 연산과 동일한 우선 순위를 갖는다. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;삼&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5250a5eeb7f9d4c6ad580919cbbcca70c30999a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;level&lt;/code&gt; and &lt;code&gt;handlers&lt;/code&gt; entries are interpreted as for the root logger, except that if a non-root logger&amp;rsquo;s level is specified as &lt;code&gt;NOTSET&lt;/code&gt;, the system consults loggers higher up the hierarchy to determine the effective level of the logger. The &lt;code&gt;propagate&lt;/code&gt; entry is set to 1 to indicate that messages must propagate to handlers higher up the logger hierarchy from this logger, or 0 to indicate that messages are &lt;strong&gt;not&lt;/strong&gt; propagated to handlers up the hierarchy. The &lt;code&gt;qualname&lt;/code&gt; entry is the hierarchical channel name of the logger, that is to say the name used by the application to get the logger.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 및 &lt;code&gt;handlers&lt;/code&gt; 비 루트 로거의 레벨로 지정된 경우 항목은 제외하고, 루트 로거로 해석됩니다 &lt;code&gt;NOTSET&lt;/code&gt; , 최대 시스템 문의 할 로거 높은 계층 로거의 유효 수준을 결정합니다. &lt;code&gt;propagate&lt;/code&gt; 항목은 그 메시지가이 로거에서 높은 로거 계층까지 핸들러에 전파해야하며, 0이 메시지를 표시하기 위해 표시하기 위해 1로 설정되어 &lt;strong&gt;있지&lt;/strong&gt; 계층까지 핸들러에 전달. &lt;code&gt;qualname&lt;/code&gt; 의 항목은 로거를 얻기 위해 응용 프로그램에서 사용하는 이름을 말을하는 것입니다 로거의 계층 채널 이름입니다.</target>
        </trans-unit>
        <trans-unit id="a1cc2815c38730b635f4df6ea065b320e9beb19c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;level&lt;/code&gt; entry can be one of &lt;code&gt;DEBUG, INFO, WARNING, ERROR, CRITICAL&lt;/code&gt; or &lt;code&gt;NOTSET&lt;/code&gt;. For the root logger only, &lt;code&gt;NOTSET&lt;/code&gt; means that all messages will be logged. Level values are &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;uated in the context of the &lt;code&gt;logging&lt;/code&gt; package&amp;rsquo;s namespace.</source>
          <target state="translated">&lt;code&gt;level&lt;/code&gt; 항목 중 하나가 될 수 있습니다 &lt;code&gt;DEBUG, INFO, WARNING, ERROR, CRITICAL&lt;/code&gt; 또는 &lt;code&gt;NOTSET&lt;/code&gt; . 루트 로거의 경우에만 &lt;code&gt;NOTSET&lt;/code&gt; 은 모든 메시지가 기록됨을 의미합니다. 레벨 값은 &lt;code&gt;logging&lt;/code&gt; 패키지의 네임 스페이스 컨텍스트에서 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="20549cb4258c041928c1d53bc24856087374a8f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logical_and()&lt;/code&gt;, &lt;code&gt;logical_invert()&lt;/code&gt;, &lt;code&gt;logical_or()&lt;/code&gt;, and &lt;code&gt;logical_xor()&lt;/code&gt; methods expect their arguments to be &lt;em&gt;logical operands&lt;/em&gt;. A &lt;em&gt;logical operand&lt;/em&gt; is a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance whose exponent and sign are both zero, and whose digits are all either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">는 &lt;code&gt;logical_and()&lt;/code&gt; , &lt;code&gt;logical_invert()&lt;/code&gt; , &lt;code&gt;logical_or()&lt;/code&gt; , 및 &lt;code&gt;logical_xor()&lt;/code&gt; 메소드는 인수가 될 것으로 기대 &lt;em&gt;논리적 피연산자&lt;/em&gt; . &lt;em&gt;논리적 피연산자&lt;/em&gt; A는 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 그 지수 및 기호 양쪽 모두 0이고, 그 중 모든 숫자이다 인스턴스 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2894cd9ca319bdc7c0ff6fb46276e37f22647d34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt; arguments may have been modified or inferred from the original call.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;flags&lt;/code&gt; 인수를 수정하거나 원래 통화에서 추정되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17efeea07dfaa7e18f0e4f49edec6a634a2254b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; attributes can be set using keyword-only arguments to the constructor. When set they represent the name of the module that was attempted to be imported and the path to any file which triggered the exception, respectively.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;path&lt;/code&gt; 속성은 생성자에 키워드 전용 인수를 사용하여 설정할 수 있습니다. 설정되면 가져 오려고 시도한 모듈의 이름과 각각 예외를 트리거 한 파일의 경로를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="44ec035ffa5b84f633e8a9db377a08d7cf3735fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; is potentially a period-separated hierarchical value, like &lt;code&gt;foo.bar.baz&lt;/code&gt; (though it could also be just plain &lt;code&gt;foo&lt;/code&gt;, for example). Loggers that are further down in the hierarchical list are children of loggers higher up in the list. For example, given a logger with a name of &lt;code&gt;foo&lt;/code&gt;, loggers with names of &lt;code&gt;foo.bar&lt;/code&gt;, &lt;code&gt;foo.bar.baz&lt;/code&gt;, and &lt;code&gt;foo.bam&lt;/code&gt; are all descendants of &lt;code&gt;foo&lt;/code&gt;. The logger name hierarchy is analogous to the Python package hierarchy, and identical to it if you organise your loggers on a per-module basis using the recommended construction &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt;. That&amp;rsquo;s because in a module, &lt;code&gt;__name__&lt;/code&gt; is the module&amp;rsquo;s name in the Python package namespace.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 잠재적으로 같은 기간으로 구분 계층 값이다 &lt;code&gt;foo.bar.baz&lt;/code&gt; (또한 평범한 일 수 있지만 &lt;code&gt;foo&lt;/code&gt; 는 예를 들어,). 계층 목록에서 더 아래에있는 로거는 목록에서 더 높은 로거의 하위입니다. 예를 들어, 이름이 &lt;code&gt;foo&lt;/code&gt; 인 로거가 주어지면 이름이 &lt;code&gt;foo.bar&lt;/code&gt; , &lt;code&gt;foo.bar.baz&lt;/code&gt; 및 &lt;code&gt;foo.bam&lt;/code&gt; 인 로거 는 모두 &lt;code&gt;foo&lt;/code&gt; 의 자손입니다 . 로거 이름 계층은 Python 패키지 계층과 유사하며 권장되는 구성 &lt;code&gt;logging.getLogger(__name__)&lt;/code&gt; 사용하여 모듈별로 로거를 구성하는 경우와 동일합니다 . 모듈에서 &lt;code&gt;__name__&lt;/code&gt; 은 Python 패키지 네임 스페이스의 모듈 이름입니다.</target>
        </trans-unit>
        <trans-unit id="c463374771af257aa19a3e7470848bbe19caa8c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p1.stdout.close()&lt;/code&gt; call after starting the p2 is important in order for p1 to receive a SIGPIPE if p2 exits before p1.</source>
          <target state="translated">&lt;code&gt;p1.stdout.close()&lt;/code&gt; P2 카드를 시작한 후 호출 P1 전에 P2 종료 만약 SIGPIPE를받을 P1 위해서는 중요하다.</target>
        </trans-unit>
        <trans-unit id="6c5afe3f20d08659f0801d09a465c4f246d3ab30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pickle&lt;/code&gt; module &lt;strong&gt;is not secure&lt;/strong&gt;. Only unpickle data you trust.</source>
          <target state="translated">&lt;code&gt;pickle&lt;/code&gt; 모듈은 &lt;strong&gt;안전하지 않습니다&lt;/strong&gt; . 신뢰할 수있는 데이터 만 피클 링하십시오.</target>
        </trans-unit>
        <trans-unit id="4f25fd4a79428a7a734c8203ffa74cdc9ffac57a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;poll()&lt;/code&gt; system call, supported on most Unix systems, provides better scalability for network servers that service many, many clients at the same time. &lt;code&gt;poll()&lt;/code&gt; scales better because the system call only requires listing the file descriptors of interest, while &lt;code&gt;select()&lt;/code&gt; builds a bitmap, turns on bits for the fds of interest, and then afterward the whole bitmap has to be linearly scanned again. &lt;code&gt;select()&lt;/code&gt; is O(highest file descriptor), while &lt;code&gt;poll()&lt;/code&gt; is O(number of file descriptors).</source>
          <target state="translated">&lt;code&gt;poll()&lt;/code&gt; 대부분의 유닉스 시스템에서 지원 시스템 호출은 네트워크 서버에 대한 더 나은 확장 성을 제공하는 동시에 서비스 많은, 많은 클라이언트가. 시스템 호출은 관심있는 파일 설명자를 나열하기 만하면되기 때문에 &lt;code&gt;poll()&lt;/code&gt; 은 더 잘 확장됩니다. &lt;code&gt;select()&lt;/code&gt; 는 비트 맵을 빌드하고 관심있는 fd에 대한 비트를 설정 한 후 전체 비트 맵을 다시 선형으로 스캔해야하기 때문에 더 잘 확장됩니다. &lt;code&gt;select()&lt;/code&gt; 는 O (가장 높은 파일 디스크립터)이고 &lt;code&gt;poll()&lt;/code&gt; 은 O (파일 디스크립터 수)입니다.</target>
        </trans-unit>
        <trans-unit id="3adfcd2af06573abb2087db55784b60bbc3f041d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;popitem()&lt;/code&gt; method of &lt;a href=&quot;#collections.OrderedDict&quot;&gt;&lt;code&gt;OrderedDict&lt;/code&gt;&lt;/a&gt; has a different signature. It accepts an optional argument to specify which item is popped.</source>
          <target state="translated">&lt;a href=&quot;#collections.OrderedDict&quot;&gt; &lt;code&gt;OrderedDict&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;popitem()&lt;/code&gt; 메소드는 서명이 다릅니다. 팝되는 항목을 지정하는 선택적 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f26b175564211cc5d95f4799adf4280e32941448" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix_chars=&lt;/code&gt; argument defaults to &lt;code&gt;'-'&lt;/code&gt;. Supplying a set of characters that does not include &lt;code&gt;-&lt;/code&gt; will cause &lt;code&gt;-f/--foo&lt;/code&gt; options to be disallowed.</source>
          <target state="translated">&lt;code&gt;prefix_chars=&lt;/code&gt; 에 인수 기본값 &lt;code&gt;'-'&lt;/code&gt; . 포함하지 않는 문자 집합 공급 &lt;code&gt;-&lt;/code&gt; 원인이됩니다 &lt;code&gt;-f/--foo&lt;/code&gt; 옵션을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="6cbc1096c67f757db14d69db3e5c36cba803f269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pyexpat&lt;/code&gt; module is not secure against maliciously constructed data. If you need to parse untrusted or unauthenticated data see &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML vulnerabilities&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;pyexpat&lt;/code&gt; 의 모듈은 악의적으로 구성된 데이터에 대한 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 데이터를 구문 분석해야하는 경우 &lt;a href=&quot;xml#xml-vulnerabilities&quot;&gt;XML 취약성을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="56906a2e6d9db176d17fb2b6647596ea13b54940" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;quantize()&lt;/code&gt; method rounds a number to a fixed exponent. This method is useful for monetary applications that often round results to a fixed number of places:</source>
          <target state="translated">&lt;code&gt;quantize()&lt;/code&gt; 메소드는 고정 지수의 숫자 반올림. 이 방법은 종종 고정 된 수의 장소로 결과를 반올림하는 통화 애플리케이션에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="48b01acd0241a2442ff5b4aae7c3e1806b139057" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read()&lt;/code&gt; (when called with a positive argument), &lt;code&gt;readinto()&lt;/code&gt; and &lt;code&gt;write()&lt;/code&gt; methods on this class will only make one system call.</source>
          <target state="translated">이 클래스 의 &lt;code&gt;read()&lt;/code&gt; (양의 인수로 호출 된 경우), &lt;code&gt;readinto()&lt;/code&gt; 및 &lt;code&gt;write()&lt;/code&gt; 메소드는 하나의 시스템 호출 만 수행합니다.</target>
        </trans-unit>
        <trans-unit id="56f3c5d9f151c39458862c4187286a2e030ef45f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register()&lt;/code&gt; attribute returns the undecorated function which enables decorator stacking, pickling, as well as creating unit tests for each variant independently:</source>
          <target state="translated">&lt;code&gt;register()&lt;/code&gt; 속성 산세뿐만 아니라, 각각 독립적 변종 단위 테스트를 만드는 장식 적층을 가능하게 장식되지 않은 기능을 리턴</target>
        </trans-unit>
        <trans-unit id="3dc67ec796044fe79c20baf27688a12b0b165186" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; function is used for interactive echo of expression values. It returns an altered version of the input string in which control codes, some BMP codepoints, and all non-BMP codepoints are replaced with escape codes. As demonstrated above, it allows one to identify the characters in a string, regardless of how they are displayed.</source>
          <target state="translated">&lt;code&gt;repr&lt;/code&gt; 기능 발현 값 대화식 에코에 대해 이용된다. 제어 코드, 일부 BMP ​​코드 포인트 및 BMP 이외의 모든 코드 포인트가 이스케이프 코드로 대체되는 변경된 버전의 입력 문자열을 리턴합니다. 위에서 설명했듯이 문자열의 표시 방법에 관계없이 문자열의 문자를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6694efe52e7d12ce180dcca2b71b57be3eda6fae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reverse()&lt;/code&gt; method modifies the sequence in place for economy of space when reversing a large sequence. To remind users that it operates by side effect, it does not return the reversed sequence.</source>
          <target state="translated">&lt;code&gt;reverse()&lt;/code&gt; 대형 서열을 역전 할 때 방법은 공간을 절약하기 위하여 그 순서를 변경한다. 부작용으로 작동한다는 것을 사용자에게 상기시키기 위해 반대 순서를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70d611f664da4872758f6cac2500dc6d64789f50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rfile&lt;/code&gt; attributes of both classes support the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; readable interface, and &lt;code&gt;DatagramRequestHandler.wfile&lt;/code&gt; supports the &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt;&lt;code&gt;io.BufferedIOBase&lt;/code&gt;&lt;/a&gt; writable interface.</source>
          <target state="translated">&lt;code&gt;rfile&lt;/code&gt; 의 두 클래스의 속성은 지원 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 읽을 수있는 인터페이스를하고 &lt;code&gt;DatagramRequestHandler.wfile&lt;/code&gt; 는 지지대 &lt;a href=&quot;io#io.BufferedIOBase&quot;&gt; &lt;code&gt;io.BufferedIOBase&lt;/code&gt; &lt;/a&gt; 쓰기 가능한 인터페이스를.</target>
        </trans-unit>
        <trans-unit id="2e5a1e0c9ba618171130cb7735890718c55a68eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run*&lt;/code&gt; functions and &lt;a href=&quot;#pdb.set_trace&quot;&gt;&lt;code&gt;set_trace()&lt;/code&gt;&lt;/a&gt; are aliases for instantiating the &lt;a href=&quot;#pdb.Pdb&quot;&gt;&lt;code&gt;Pdb&lt;/code&gt;&lt;/a&gt; class and calling the method of the same name. If you want to access further features, you have to do this yourself:</source>
          <target state="translated">&lt;code&gt;run*&lt;/code&gt; 기능과 &lt;a href=&quot;#pdb.set_trace&quot;&gt; &lt;code&gt;set_trace()&lt;/code&gt; &lt;/a&gt; 인스턴스화하는 앨리어스 (alias) &lt;a href=&quot;#pdb.Pdb&quot;&gt; &lt;code&gt;Pdb&lt;/code&gt; &lt;/a&gt; 클래스와 같은 이름의 메소드를 호출. 추가 기능에 액세스하려면 직접 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0c7daa1f0bf95ee399648b399e3569e912a4226" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sentinel&lt;/code&gt; object provides a convenient way of providing unique objects for your tests.</source>
          <target state="translated">&lt;code&gt;sentinel&lt;/code&gt; 목적은 당신의 검사 결과에 대해 고유 한 개체를 제공하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4f2b8b9e54da55b5343a0feb08a9e06383efbd02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shake_128()&lt;/code&gt; and &lt;code&gt;shake_256()&lt;/code&gt; algorithms provide variable length digests with length_in_bits//2 up to 128 or 256 bits of security. As such, their digest methods require a length. Maximum length is not limited by the SHAKE algorithm.</source>
          <target state="translated">&lt;code&gt;shake_128()&lt;/code&gt; 및 &lt;code&gt;shake_256()&lt;/code&gt; 알고리즘은 보안의 128 또는 256 비트 length_in_bits // 2쪽으로 가변 길이 분해물을 제공한다. 따라서 다이제스트 방법에는 길이가 필요합니다. 최대 길이는 SHAKE 알고리즘에 의해 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2679ce48058db1acf0cd9c304d5a336da90caf62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;side_effect&lt;/code&gt; can also be any iterable object. Repeated calls to the mock will return values from the iterable (until the iterable is exhausted and a &lt;a href=&quot;exceptions#StopIteration&quot;&gt;&lt;code&gt;StopIteration&lt;/code&gt;&lt;/a&gt; is raised):</source>
          <target state="translated">&lt;code&gt;side_effect&lt;/code&gt; 은 또한 어떤 반복자 객체가 될 수 있습니다. mock에 대한 반복 호출은 iterable에서 값을 반환합니다 (iterable이 소진되고 &lt;a href=&quot;exceptions#StopIteration&quot;&gt; &lt;code&gt;StopIteration&lt;/code&gt; &lt;/a&gt; 이 발생할 때까지 ).</target>
        </trans-unit>
        <trans-unit id="bbc828704026e73a7132d7861c1f6ea3b2c9c718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sort&lt;/code&gt; command is a variant of &lt;code&gt;search&lt;/code&gt; with sorting semantics for the results. Returned data contains a space separated list of matching message numbers.</source>
          <target state="translated">&lt;code&gt;sort&lt;/code&gt; 명령의 변형입니다 &lt;code&gt;search&lt;/code&gt; 결과에 대한 의미를 정렬과 함께. 반환 된 데이터는 공백으로 구분 된 일치하는 메시지 번호 목록을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="5e876713b1b58ed7e57cd0a3c49de12c593470a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; value of a &lt;code&gt;Group&lt;/code&gt; is formatted according to &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt;, but with no Content Transfer Encoding of any non-ASCII characters. If &lt;code&gt;display_name&lt;/code&gt; is none and there is a single &lt;code&gt;Address&lt;/code&gt; in the &lt;code&gt;addresses&lt;/code&gt; list, the &lt;code&gt;str&lt;/code&gt; value will be the same as the &lt;code&gt;str&lt;/code&gt; of that single &lt;code&gt;Address&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Group&lt;/code&gt; 의 &lt;code&gt;str&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 에 따라 형식화 되지만 비 ASCII 문자의 컨텐츠 전송 인코딩은 없습니다. 경우 &lt;code&gt;display_name&lt;/code&gt; 포함되지 않은 하나의 존재 &lt;code&gt;Address&lt;/code&gt; 에서 &lt;code&gt;addresses&lt;/code&gt; 목록의 &lt;code&gt;str&lt;/code&gt; 값과 동일합니다 &lt;code&gt;str&lt;/code&gt; 그 하나의 &lt;code&gt;Address&lt;/code&gt; .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b50753b2718f1b5d3b1b08f7d48365835500f23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str&lt;/code&gt; value of the object is the address quoted according to &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; rules, but with no Content Transfer Encoding of any non-ASCII characters.</source>
          <target state="translated">오브젝트 의 &lt;code&gt;str&lt;/code&gt; 값은 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 규칙 에 따라 인용 된 주소 이지만 ASCII가 아닌 문자의 컨텐츠 전송 인코딩은 없습니다.</target>
        </trans-unit>
        <trans-unit id="5863a575332c9bfbc7b8eeb262ad8abeefba260f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strptime()&lt;/code&gt; method can parse years in the full [1, 9999] range, but years &amp;lt; 1000 must be zero-filled to 4-digit width.</source>
          <target state="translated">&lt;code&gt;strptime()&lt;/code&gt; 메소드는 전체 [1, 9999] 범위 년 분석 할 수 있지만, 세 &amp;lt;1000 4 자리 폭으로 제로 - 채워 져야한다.</target>
        </trans-unit>
        <trans-unit id="f40fa8d24afda44ef7ba1b9017535f589e255937" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subject&lt;/code&gt; and &lt;code&gt;issuer&lt;/code&gt; fields are tuples containing the sequence of relative distinguished names (RDNs) given in the certificate&amp;rsquo;s data structure for the respective fields, and each RDN is a sequence of name-value pairs. Here is a real-world example:</source>
          <target state="translated">&lt;code&gt;subject&lt;/code&gt; 및 &lt;code&gt;issuer&lt;/code&gt; 필드는 각 필드에 대한 인증서의 데이터 구조에 대하여 소정의 식별 명 (RDN으로)의 서열을 포함하는 튜플이다 각 RDN은 이름 - 값 쌍들의 시퀀스이다. 실제 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48bc15cd70ec89240e8c5077ca67cca8ab36280e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thread&lt;/code&gt; command is a variant of &lt;code&gt;search&lt;/code&gt; with threading semantics for the results. Returned data contains a space separated list of thread members.</source>
          <target state="translated">&lt;code&gt;thread&lt;/code&gt; 명령의 변형 인 &lt;code&gt;search&lt;/code&gt; 결과에 대한 의미를 스레딩. 리턴 된 데이터는 공백으로 구분 된 스레드 멤버 목록을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="95c4f2f11ca60f7337a0bd2dddfc357c898cff74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Combobox&lt;/code&gt; widget combines a text field with a pop-down list of values. This widget is a subclass of &lt;code&gt;Entry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Combobox&lt;/code&gt; 값의 팝 다운 목록이있는 텍스트 필드를 결합 위젯. 이 위젯은 &lt;code&gt;Entry&lt;/code&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="352dd537bd626bd414d868a36dd17e8367456400" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Progressbar&lt;/code&gt; widget shows the status of a long-running operation. It can operate in two modes: 1) the determinate mode which shows the amount completed relative to the total amount of work to be done and 2) the indeterminate mode which provides an animated display to let the user know that work is progressing.</source>
          <target state="translated">&lt;code&gt;ttk.Progressbar&lt;/code&gt; 는 쇼에게 장기 실행 작업의 상태를 위젯. 1) 수행 할 총 작업량과 관련하여 완료된 양을 표시하는 결정 모드와 2) 작업이 진행 중임을 사용자에게 알리는 애니메이션 표시를 제공하는 결정되지 않은 모드입니다.</target>
        </trans-unit>
        <trans-unit id="251bfa8f490dc70c8808050862bc83c86fb9d1f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Separator&lt;/code&gt; widget displays a horizontal or vertical separator bar.</source>
          <target state="translated">&lt;code&gt;ttk.Separator&lt;/code&gt; 는 디스플레이를 수평 또는 수직 분리기 바 위젯.</target>
        </trans-unit>
        <trans-unit id="f758b0179e7d65969a79f1e77fd20a0943975f0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Sizegrip&lt;/code&gt; widget (also known as a grow box) allows the user to resize the containing toplevel window by pressing and dragging the grip.</source>
          <target state="translated">&lt;code&gt;ttk.Sizegrip&lt;/code&gt; 의 (도 성장한다 상자라고도 함) 위젯은 사용자가 누르고 그립을 끌어 포함하는 최상위 창 크기를 조정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f7c9dc42acbbb7afe7822de5598582a08914264" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Spinbox&lt;/code&gt; widget is a &lt;code&gt;ttk.Entry&lt;/code&gt; enhanced with increment and decrement arrows. It can be used for numbers or lists of string values. This widget is a subclass of &lt;code&gt;Entry&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ttk.Spinbox&lt;/code&gt; A는 위젯 &lt;code&gt;ttk.Entry&lt;/code&gt; 증가 및 감소 화살표 향상. 숫자 또는 문자열 값 목록에 사용할 수 있습니다. 이 위젯은 &lt;code&gt;Entry&lt;/code&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="e6fc76a70719682fd79d2ebe3a3918e54edb387f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ttk.Treeview&lt;/code&gt; widget displays a hierarchical collection of items. Each item has a textual label, an optional image, and an optional list of data values. The data values are displayed in successive columns after the tree label.</source>
          <target state="translated">&lt;code&gt;ttk.Treeview&lt;/code&gt; 는 표시를 항목의 계층 적 모음 위젯. 각 항목에는 텍스트 레이블, 선택적 이미지 및 선택적 데이터 값 목록이 있습니다. 데이터 값은 트리 레이블 다음에 연속 열에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f0e2919d156958c0ab2b6cf34ca6fec36edfad34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;username&lt;/code&gt; portion of the address, with all quoting removed.</source>
          <target state="translated">모든 인용 부호가 제거 된 주소 의 &lt;code&gt;username&lt;/code&gt; 부분.</target>
        </trans-unit>
        <trans-unit id="7462f687d399e631ee022aa8a0c1be3259a71d02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;username@domain&lt;/code&gt; portion of the address, correctly quoted for use as a bare address (the second form shown above). This attribute is not mutable.</source>
          <target state="translated">주소 의 &lt;code&gt;username@domain&lt;/code&gt; 부분으로 베어 주소 (위의 두 번째 형식)로 사용하기 위해 올바르게 인용됩니다. 이 속성은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e04165a0b7839d9196d963a9d99b152be548425" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verify&lt;/code&gt; argument, if specified, should be a callable which should verify whether bytes received across the socket are valid and should be processed. This could be done by encrypting and/or signing what is sent across the socket, such that the &lt;code&gt;verify&lt;/code&gt; callable can perform signature verification and/or decryption. The &lt;code&gt;verify&lt;/code&gt; callable is called with a single argument - the bytes received across the socket - and should return the bytes to be processed, or &lt;code&gt;None&lt;/code&gt; to indicate that the bytes should be discarded. The returned bytes could be the same as the passed in bytes (e.g. when only verification is done), or they could be completely different (perhaps if decryption were performed).</source>
          <target state="translated">&lt;code&gt;verify&lt;/code&gt; 인수 지정된 경우, 소켓에 걸쳐 수신 된 바이트가 유효하고 처리할지 여부를 확인해야하는 호출 가능해야한다. 이것은 소켓을 통해 전송 된 것을 암호화 및 / 또는 서명함으로써 수행 될 수 있어서, &lt;code&gt;verify&lt;/code&gt; 호출 가능이 서명 검증 및 / 또는 복호화를 수행 할 수있다. 는 &lt;code&gt;verify&lt;/code&gt; 소켓 통해받은 바이트 - - 호출이 하나의 인자로 호출되고, 바이트 처리로 복귀한다, 또는 &lt;code&gt;None&lt;/code&gt; 바이트가 폐기되어야 함을 나타 내기 않음. 반환 된 바이트는 전달 된 바이트 수와 같거나 (예 : 확인 만 수행 된 경우) 완전히 다를 수 있습니다 (아마도 해독이 수행 된 경우).</target>
        </trans-unit>
        <trans-unit id="2bfd67854453b9508617bc5ecb87d6bf83b9e2f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version()&lt;/code&gt; function is the quickest way to get a distribution&amp;rsquo;s version number, as a string:</source>
          <target state="translated">&lt;code&gt;version()&lt;/code&gt; 함수는 문자열로, 분배의 버전 번호를 얻을 수있는 가장 빠른 방법입니다 :</target>
        </trans-unit>
        <trans-unit id="9457eb2c5daeb61cce915fa460df6791a47eebc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; loop checking for the application&amp;rsquo;s condition is necessary because &lt;a href=&quot;#threading.Condition.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; can return after an arbitrary long time, and the condition which prompted the &lt;a href=&quot;#threading.Condition.notify&quot;&gt;&lt;code&gt;notify()&lt;/code&gt;&lt;/a&gt; call may no longer hold true. This is inherent to multi-threaded programming. The &lt;a href=&quot;#threading.Condition.wait_for&quot;&gt;&lt;code&gt;wait_for()&lt;/code&gt;&lt;/a&gt; method can be used to automate the condition checking, and eases the computation of timeouts:</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 때문에 응용 프로그램의 조건에 대해 루프 검사는 필요하지 않습니다 &lt;a href=&quot;#threading.Condition.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 임의의 긴 시간 이후에 반환 할 수 있으며, 프롬프트 상태 &lt;a href=&quot;#threading.Condition.notify&quot;&gt; &lt;code&gt;notify()&lt;/code&gt; &lt;/a&gt; 호출이 성립 더 이상 할 수 있습니다. 이것은 다중 스레드 프로그래밍에 내재되어 있습니다. &lt;a href=&quot;#threading.Condition.wait_for&quot;&gt; &lt;code&gt;wait_for()&lt;/code&gt; &lt;/a&gt; 메소드는 조건 검사를 자동화하는 데 사용하고, 제한 시간의 계산을 용이하게 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="68b060fff3c4e153991c4ede204ad1db0712fced" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;with&lt;/code&gt; block logs on &lt;em&gt;logger&lt;/em&gt; with minimum &lt;em&gt;level&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;with&lt;/code&gt; 블록에 기록 &lt;em&gt;로거&lt;/em&gt; 최소 &lt;em&gt;수준&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9356ea9fa5513a007b3e1c50146086929d32ee69" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Content-Length&lt;/em&gt; is treated as a lower bound: if there&amp;rsquo;s more data to read, urlretrieve reads more data, but if less data is available, it raises the exception.</source>
          <target state="translated">&lt;em&gt;콘텐츠 길이는&lt;/em&gt; 낮은 바운드로 처리됩니다 읽을 수있는 더 많은 데이터가 있다면, urlretrieve는 더 많은 데이터를 읽지 만 적은 데이터를 사용할 수있는 경우는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a0fdb4923aa98d7d944fbee512e9d4d1baf28cd0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Emin&lt;/em&gt; and &lt;em&gt;Emax&lt;/em&gt; fields are integers specifying the outer limits allowable for exponents. &lt;em&gt;Emin&lt;/em&gt; must be in the range [&lt;a href=&quot;#decimal.MIN_EMIN&quot;&gt;&lt;code&gt;MIN_EMIN&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;0&lt;/code&gt;], &lt;em&gt;Emax&lt;/em&gt; in the range [&lt;code&gt;0&lt;/code&gt;, &lt;a href=&quot;#decimal.MAX_EMAX&quot;&gt;&lt;code&gt;MAX_EMAX&lt;/code&gt;&lt;/a&gt;].</source>
          <target state="translated">&lt;em&gt;에민&lt;/em&gt; 과 &lt;em&gt;EMAX&lt;/em&gt; 필드는 지수에 대한 허용 바깥 쪽 한계를 지정하는 정수입니다. &lt;em&gt;Emin&lt;/em&gt; 은 [ &lt;a href=&quot;#decimal.MIN_EMIN&quot;&gt; &lt;code&gt;MIN_EMIN&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;0&lt;/code&gt; ] 범위에 있고 &lt;em&gt;Emax&lt;/em&gt; 는 [ &lt;code&gt;0&lt;/code&gt; , &lt;a href=&quot;#decimal.MAX_EMAX&quot;&gt; &lt;code&gt;MAX_EMAX&lt;/code&gt; &lt;/a&gt; ] 범위 에 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="099de42faf0f0b2a0cf8ddac8528d10fd5f74ec0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;allow_fragments&lt;/em&gt; argument has the same meaning and default as for &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt;&lt;code&gt;urlparse()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;allow_fragments의&lt;/em&gt; 인수와 동일한 의미와 기본이 &lt;a href=&quot;#urllib.parse.urlparse&quot;&gt; &lt;code&gt;urlparse()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2e831ae773ee2dd264b6b78cde7feab2044ba27e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;arg&lt;/em&gt; parameter depends on the previous event.</source>
          <target state="translated">&lt;em&gt;, 인수&lt;/em&gt; 매개 변수는 이전 이벤트에 따라 달라집니다.</target>
        </trans-unit>
        <trans-unit id="e8e08e0c1e7cb5d08ab5c2d641f0e97d0a518bb3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; argument as it was passed to &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; &amp;ndash; a sequence of program arguments or else a single string.</source>
          <target state="translated">&lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 에 전달 된 &lt;em&gt;args&lt;/em&gt; 인수 &amp;ndash; 프로그램 인수 시퀀스 또는 단일 문자열.</target>
        </trans-unit>
        <trans-unit id="1d3a577fd674bcea3227fd720956de76ed22bd4d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; argument has the following attributes:</source>
          <target state="translated">&lt;em&gt;인수의&lt;/em&gt; 인수는 다음과 같은 특성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fd13acf025140fb6639151e4ed9a4f868af627a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;args&lt;/em&gt; parameter is set to the list of positional arguments to &lt;a href=&quot;#string.Formatter.vformat&quot;&gt;&lt;code&gt;vformat()&lt;/code&gt;&lt;/a&gt;, and the &lt;em&gt;kwargs&lt;/em&gt; parameter is set to the dictionary of keyword arguments.</source>
          <target state="translated">&lt;em&gt;인수&lt;/em&gt; 에 위치 인수 목록에 설정되어있는 파라미터 &lt;a href=&quot;#string.Formatter.vformat&quot;&gt; &lt;code&gt;vformat()&lt;/code&gt; &lt;/a&gt; 및 &lt;em&gt;kwargs로&lt;/em&gt; 키워드 인자의 사전 설정된 파라미터.</target>
        </trans-unit>
        <trans-unit id="cbfbb46472247d0b887aaa75774bf8ab442ab41a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;argv&lt;/em&gt; argument can be a list of options passed to the program, with the first element being the program name. If not specified or &lt;code&gt;None&lt;/code&gt;, the values of &lt;a href=&quot;sys#sys.argv&quot;&gt;&lt;code&gt;sys.argv&lt;/code&gt;&lt;/a&gt; are used.</source>
          <target state="translated">&lt;em&gt;을 argv&lt;/em&gt; 인수는 첫 번째 요소는 프로그램 이름 인으로, 프로그램에 전달 옵션의 목록이 될 수 있습니다. 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;sys#sys.argv&quot;&gt; &lt;code&gt;sys.argv&lt;/code&gt; &lt;/a&gt; 값 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b0cc005a8dd1192de2426a343f6644b9f34b41bf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;blacklist&lt;/em&gt; argument can be a set of names that must not be treated as part of the public API even though their names indicate otherwise.</source>
          <target state="translated">&lt;em&gt;블랙리스트&lt;/em&gt; 인수는 자신의 이름이 다르게 표시에도 공개 API의 일부로 취급해서는 안 이름의 집합이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d472fb09d267545549f54dfcd1448efdf7d1a71a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;buffering&lt;/em&gt; argument is ignored. Its use is deprecated since Python 3.0.</source>
          <target state="translated">&lt;em&gt;버퍼링&lt;/em&gt; 인수는 무시됩니다. 파이썬 3.0부터는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9b5ef68ccd955c5bc87fad98f76a98a1362f7808" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;byteorder&lt;/em&gt; argument determines the byte order used to represent the integer. If &lt;em&gt;byteorder&lt;/em&gt; is &lt;code&gt;&quot;big&quot;&lt;/code&gt;, the most significant byte is at the beginning of the byte array. If &lt;em&gt;byteorder&lt;/em&gt; is &lt;code&gt;&quot;little&quot;&lt;/code&gt;, the most significant byte is at the end of the byte array. To request the native byte order of the host system, use &lt;a href=&quot;sys#sys.byteorder&quot;&gt;&lt;code&gt;sys.byteorder&lt;/code&gt;&lt;/a&gt; as the byte order value.</source>
          <target state="translated">&lt;em&gt;바이트 순서의&lt;/em&gt; 인수는 정수를 나타내는데 사용하는 바이트 순서를 결정한다. 경우 &lt;em&gt;바이트 순서가&lt;/em&gt; 있다 &lt;code&gt;&quot;big&quot;&lt;/code&gt; , 가장 중요한 바이트가 바이트 배열의 시작 부분입니다. 경우 &lt;em&gt;바이트 순서가&lt;/em&gt; 있다 &lt;code&gt;&quot;little&quot;&lt;/code&gt; , 최상위 바이트는 바이트 배열의 끝에서입니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 &lt;a href=&quot;sys#sys.byteorder&quot;&gt; &lt;code&gt;sys.byteorder&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dfe4c096e9d46ef87c6014cc8115884999f9571d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cadata&lt;/em&gt; object, if present, is either an ASCII string of one or more PEM-encoded certificates or a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt; of DER-encoded certificates. Like with &lt;em&gt;capath&lt;/em&gt; extra lines around PEM-encoded certificates are ignored but at least one certificate must be present.</source>
          <target state="translated">&lt;em&gt;cadata의&lt;/em&gt; 오브젝트가 존재하는 경우, 어느 하나 이상의 PEM 인코딩 인증서 또는의 ASCII 문자열이다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트 형 객체&lt;/a&gt; DER 인코딩 인증서. &lt;em&gt;캡틴&lt;/em&gt; 과 마찬가지로 PEM으로 인코딩 된 인증서 주변의 추가 라인은 무시되지만 하나 이상의 인증서가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="fa644494d39e4ababa095081c9e901ded5d4e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cadefault&lt;/em&gt; parameter is ignored.</source>
          <target state="translated">&lt;em&gt;cadefault의&lt;/em&gt; 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="17c8b195b094fb49ee9de35d0bdf391b2aeafc14" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cafile&lt;/em&gt; string, if present, is the path to a file of concatenated CA certificates in PEM format. See the discussion of &lt;a href=&quot;#ssl-certificates&quot;&gt;Certificates&lt;/a&gt; for more information about how to arrange the certificates in this file.</source>
          <target state="translated">&lt;em&gt;cafile에서의&lt;/em&gt; 문자열이 존재하는 경우, PEM 형식으로 연결된 CA 인증서 파일의 경로입니다. 이 파일에서 인증서를 배열하는 방법에 대한 자세한 정보 는 &lt;a href=&quot;#ssl-certificates&quot;&gt;인증서&lt;/a&gt; 토론을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="15c7daa6e069448b8e979e9ffc5f343170589a8c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;callback&lt;/em&gt; callable must be thread-safe.</source>
          <target state="translated">&lt;em&gt;콜백&lt;/em&gt; 호출 스레드 안전해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f39a130157f612057b2a04830330e09fc1bb8b9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;callback&lt;/em&gt; is called with the Future object as its only argument.</source>
          <target state="translated">&lt;em&gt;콜백은&lt;/em&gt; 유일한 인수로 향후 개체라고합니다.</target>
        </trans-unit>
        <trans-unit id="7b7825c54e612df4242ae324acc59aa178b0a8be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capath&lt;/em&gt; string, if present, is the path to a directory containing several CA certificates in PEM format, following an &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html&quot;&gt;OpenSSL specific layout&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;capath에의&lt;/em&gt; 캐릭터 라인은, 현재의 경우, 다음 PEM 형식의 여러 CA 인증서를 포함하는 디렉토리의 경로 &lt;a href=&quot;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_load_verify_locations.html&quot;&gt;에서 OpenSSL 특정 레이아웃을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fb0d6c3c720e62f41c129079fa155f95ad67efe5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capitals&lt;/em&gt; field is either &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; (the default). If set to &lt;code&gt;1&lt;/code&gt;, exponents are printed with a capital &lt;code&gt;E&lt;/code&gt;; otherwise, a lowercase &lt;code&gt;e&lt;/code&gt; is used: &lt;code&gt;Decimal('6.02e+23')&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;자본의&lt;/em&gt; 필드 중 하나입니다 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; (기본값). &lt;code&gt;1&lt;/code&gt; 로 설정하면 지수는 대문자 &lt;code&gt;E&lt;/code&gt; 로 인쇄됩니다 . 그렇지 않으면 소문자 &lt;code&gt;e&lt;/code&gt; 가 사용됩니다 : &lt;code&gt;Decimal('6.02e+23')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a4471e81f460554b6a4cbdc7f3ddf8327b0a009" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;capturestderr&lt;/em&gt; argument is replaced with the &lt;em&gt;stderr&lt;/em&gt; argument.</source>
          <target state="translated">&lt;em&gt;capturestderr의&lt;/em&gt; 인수는 대체됩니다 &lt;em&gt;열려진&lt;/em&gt; 인수입니다.</target>
        </trans-unit>
        <trans-unit id="82b367b59ab20936a4abae0ec9731b9670a88c72" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;cb_type&lt;/em&gt; parameter allow selection of the desired channel binding type. Valid channel binding types are listed in the &lt;a href=&quot;#ssl.CHANNEL_BINDING_TYPES&quot;&gt;&lt;code&gt;CHANNEL_BINDING_TYPES&lt;/code&gt;&lt;/a&gt; list. Currently only the &amp;lsquo;tls-unique&amp;rsquo; channel binding, defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc5929.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5929&lt;/strong&gt;&lt;/a&gt;, is supported. &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; will be raised if an unsupported channel binding type is requested.</source>
          <target state="translated">&lt;em&gt;cb_type의&lt;/em&gt; 파라미터는 원하는 채널 바인딩 타입의 선택을 허용한다. 유효한 채널 바인딩 유형은 &lt;a href=&quot;#ssl.CHANNEL_BINDING_TYPES&quot;&gt; &lt;code&gt;CHANNEL_BINDING_TYPES&lt;/code&gt; &lt;/a&gt; 목록에 나열되어 있습니다. 현재 &lt;a href=&quot;https://tools.ietf.org/html/rfc5929.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 5929에&lt;/strong&gt;&lt;/a&gt; 의해 정의 된 'tls-unique'채널 바인딩 만 지원됩니다. 지원되지 않는 채널 바인딩 유형이 요청 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2ddc504d7b79bdd1162c0d5bd7b50a0a1521922" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;chars&lt;/em&gt; argument indicates the number of decoded code points or bytes to return. The &lt;a href=&quot;#codecs.StreamReader.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; method will never return more data than requested, but it might return less, if there is not enough available.</source>
          <target state="translated">&lt;em&gt;문자의&lt;/em&gt; 인수는 디코딩 코드 포인트의 수를 표시하거나 반환하는 바이트. &lt;a href=&quot;#codecs.StreamReader.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 메소드는 요청보다 더 많은 데이터를 반환하지 않습니다,하지만 충분한 존재하지 않는 경우는, 덜 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88197343169a15c41919f107e9bccf7f75352518" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;check&lt;/em&gt; argument specifies the type of integrity check to include in the compressed data. This check is used when decompressing, to ensure that the data has not been corrupted. Possible values are:</source>
          <target state="translated">&lt;em&gt;체크&lt;/em&gt; 인수 지정 무결성 검사의 유형 압축 데이터에 포함한다. 이 검사는 압축을 풀 때 데이터가 손상되지 않았는지 확인하는 데 사용됩니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b3687dc03dd8946b6e5590e6e04cde893b863caa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;check_hostname&lt;/em&gt; parameter is also deprecated; the &lt;a href=&quot;ssl#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;ssl.SSLContext.check_hostname&lt;/code&gt;&lt;/a&gt; attribute of &lt;em&gt;context&lt;/em&gt; should be used instead.</source>
          <target state="translated">&lt;em&gt;check_hostname의&lt;/em&gt; 매개 변수는 사용되지 않습니다; &lt;em&gt;컨텍스트&lt;/em&gt; 의 &lt;a href=&quot;ssl#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;ssl.SSLContext.check_hostname&lt;/code&gt; &lt;/a&gt; 속성을 대신 사용해야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cb93343e76b87a0f171f91290f48a421c682e6a1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;chunksize&lt;/em&gt; argument is the same as the one used by the &lt;a href=&quot;#multiprocessing.pool.Pool.map&quot;&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/a&gt; method. For very long iterables using a large value for &lt;em&gt;chunksize&lt;/em&gt; can make the job complete &lt;strong&gt;much&lt;/strong&gt; faster than using the default value of &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;chunksize 영역의&lt;/em&gt; 인수에 의해 사용 된 것과 동일 &lt;a href=&quot;#multiprocessing.pool.Pool.map&quot;&gt; &lt;code&gt;map()&lt;/code&gt; &lt;/a&gt; 방법. &lt;em&gt;chunksize에&lt;/em&gt; 큰 값을 사용하는 iterable이 매우 긴 경우 기본값 &lt;code&gt;1&lt;/code&gt; 을 사용하는 것보다 작업을 &lt;strong&gt;훨씬&lt;/strong&gt; 빠르게 완료 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcdd385b6dc12a6a9473a0c033d73137d50d5433" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;clamp&lt;/em&gt; field is either &lt;code&gt;0&lt;/code&gt; (the default) or &lt;code&gt;1&lt;/code&gt;. If set to &lt;code&gt;1&lt;/code&gt;, the exponent &lt;code&gt;e&lt;/code&gt; of a &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance representable in this context is strictly limited to the range &lt;code&gt;Emin - prec + 1 &amp;lt;= e &amp;lt;= Emax - prec + 1&lt;/code&gt;. If &lt;em&gt;clamp&lt;/em&gt; is &lt;code&gt;0&lt;/code&gt; then a weaker condition holds: the adjusted exponent of the &lt;a href=&quot;#decimal.Decimal&quot;&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/a&gt; instance is at most &lt;code&gt;Emax&lt;/code&gt;. When &lt;em&gt;clamp&lt;/em&gt; is &lt;code&gt;1&lt;/code&gt;, a large normal number will, where possible, have its exponent reduced and a corresponding number of zeros added to its coefficient, in order to fit the exponent constraints; this preserves the value of the number but loses information about significant trailing zeros. For example:</source>
          <target state="translated">&lt;em&gt;클램프&lt;/em&gt; 분야 중 하나입니다 &lt;code&gt;0&lt;/code&gt; (기본값) 또는 &lt;code&gt;1&lt;/code&gt; . &lt;code&gt;1&lt;/code&gt; 로 설정하면 이 컨텍스트에서 표현할 수 있는 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스 의 지수 &lt;code&gt;e&lt;/code&gt; 는 &lt;code&gt;Emin - prec + 1 &amp;lt;= e &amp;lt;= Emax - prec + 1&lt;/code&gt; 범위로 엄격하게 제한됩니다 . 경우 &lt;em&gt;클램프&lt;/em&gt; 인 &lt;code&gt;0&lt;/code&gt; 후 약한 상태가 원하는 분야의 조정 지수 &lt;a href=&quot;#decimal.Decimal&quot;&gt; &lt;code&gt;Decimal&lt;/code&gt; &lt;/a&gt; 인스턴스는 많아야이다 &lt;code&gt;Emax&lt;/code&gt; . 경우 &lt;em&gt;클램프&lt;/em&gt; 인 &lt;code&gt;1&lt;/code&gt; &lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;, 지수 제약 조건에 맞추기 위해, 가능한 경우, 큰 정규수는 지수가 감소되고 계수에 대응하는 수의 제로가 추가 될 것이다; 이렇게하면 숫자 값은 유지되지만 후행 0에 대한 정보는 손실됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e7d326f4fcf7f161639b74c69e8c84eea6966131" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;client_connected_cb&lt;/em&gt; callback is called whenever a new client connection is established. It receives a &lt;code&gt;(reader, writer)&lt;/code&gt; pair as two arguments, instances of the &lt;a href=&quot;#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; classes.</source>
          <target state="translated">&lt;em&gt;client_connected_cb의&lt;/em&gt; 새 클라이언트 연결이 설정 될 때마다 콜백이 호출됩니다. &lt;a href=&quot;#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스 인 두 개의 인수로 &lt;code&gt;(reader, writer)&lt;/code&gt; 쌍을 받습니다 .</target>
        </trans-unit>
        <trans-unit id="f4a778098245593126ac70d38e2feddb7c5b0931" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;comment_factory&lt;/em&gt; and &lt;em&gt;pi_factory&lt;/em&gt; functions, when given, should behave like the &lt;a href=&quot;#xml.etree.ElementTree.Comment&quot;&gt;&lt;code&gt;Comment()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#xml.etree.ElementTree.ProcessingInstruction&quot;&gt;&lt;code&gt;ProcessingInstruction()&lt;/code&gt;&lt;/a&gt; functions to create comments and processing instructions. When not given, the default factories will be used. When &lt;em&gt;insert_comments&lt;/em&gt; and/or &lt;em&gt;insert_pis&lt;/em&gt; is true, comments/pis will be inserted into the tree if they appear within the root element (but not outside of it).</source>
          <target state="translated">&lt;em&gt;comment_factory&lt;/em&gt; 및 &lt;em&gt;pi_factory&lt;/em&gt; 기능은 주어진 때처럼 행동한다 &lt;a href=&quot;#xml.etree.ElementTree.Comment&quot;&gt; &lt;code&gt;Comment()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#xml.etree.ElementTree.ProcessingInstruction&quot;&gt; &lt;code&gt;ProcessingInstruction()&lt;/code&gt; &lt;/a&gt; 주석 및 처리 지침을 작성하는 기능을합니다. 지정하지 않으면 기본 팩토리가 사용됩니다. 때 &lt;em&gt;insert_comments&lt;/em&gt; 및 / 또는 &lt;em&gt;insert_pis이&lt;/em&gt; 사실 그들은 루트 요소 (그러나 밖에서의) 내에 표시하는 경우, 의견 / PIS가 트리에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="ae46dd7b8b3f0c9dff74383b81f0b0b055f15c1b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;completekey&lt;/em&gt;, &lt;em&gt;stdin&lt;/em&gt; and &lt;em&gt;stdout&lt;/em&gt; arguments are passed to the underlying &lt;a href=&quot;cmd#cmd.Cmd&quot;&gt;&lt;code&gt;cmd.Cmd&lt;/code&gt;&lt;/a&gt; class; see the description there.</source>
          <target state="translated">&lt;em&gt;completekey는&lt;/em&gt; , &lt;em&gt;표준 입력&lt;/em&gt; 과 &lt;em&gt;표준 출력&lt;/em&gt; 인수는 기본에 전달되는 &lt;a href=&quot;cmd#cmd.Cmd&quot;&gt; &lt;code&gt;cmd.Cmd&lt;/code&gt; 의&lt;/a&gt; 클래스; 거기에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5a1f18b255019414a78bdbbdc091b232a1484516" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from 0 to 9, as for the &lt;a href=&quot;#gzip.GzipFile&quot;&gt;&lt;code&gt;GzipFile&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인자는에 대해, 0 내지 9의 정수이고 &lt;a href=&quot;#gzip.GzipFile&quot;&gt; &lt;code&gt;GzipFile&lt;/code&gt; 으로의&lt;/a&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="a61f0cb9aa11a7de1821e1143b80646c4fdd247d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from 1 to 9, as for the &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인자는에 대해, 1 내지 9의 정수이고 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; 의&lt;/a&gt; 생성자.</target>
        </trans-unit>
        <trans-unit id="851d04e3fb4b234e2a60f5e3589b15db66360cf7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; argument is an integer from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt; controlling the level of compression; &lt;code&gt;1&lt;/code&gt; is fastest and produces the least compression, and &lt;code&gt;9&lt;/code&gt; is slowest and produces the most compression. &lt;code&gt;0&lt;/code&gt; is no compression. The default is &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 인수의 정수이고 &lt;code&gt;0&lt;/code&gt; 행 &lt;code&gt;9&lt;/code&gt; 압축률을 제어하는 단계; &lt;code&gt;1&lt;/code&gt; 이 가장 빠르며 압축률 이 가장 낮고 &lt;code&gt;9&lt;/code&gt; 가 가장 느리고 압축률이 가장 높습니다. &lt;code&gt;0&lt;/code&gt; 은 압축이 없습니다. 기본값은 &lt;code&gt;9&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c73bf8969ac57945539c860056209cac0643be6c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compresslevel&lt;/em&gt; parameter controls the compression level to use when writing files to the archive. When using &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt;&lt;code&gt;ZIP_STORED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#zipfile.ZIP_LZMA&quot;&gt;&lt;code&gt;ZIP_LZMA&lt;/code&gt;&lt;/a&gt; it has no effect. When using &lt;a href=&quot;#zipfile.ZIP_DEFLATED&quot;&gt;&lt;code&gt;ZIP_DEFLATED&lt;/code&gt;&lt;/a&gt; integers &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; are accepted (see &lt;a href=&quot;zlib#zlib.compressobj&quot;&gt;&lt;code&gt;zlib&lt;/code&gt;&lt;/a&gt; for more information). When using &lt;a href=&quot;#zipfile.ZIP_BZIP2&quot;&gt;&lt;code&gt;ZIP_BZIP2&lt;/code&gt;&lt;/a&gt; integers &lt;code&gt;1&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; are accepted (see &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">&lt;em&gt;compresslevel의&lt;/em&gt; 아카이브에 파일을 기록 할 때 매개 변수 컨트롤은 압축 수준을 사용합니다. &lt;a href=&quot;#zipfile.ZIP_STORED&quot;&gt; &lt;code&gt;ZIP_STORED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#zipfile.ZIP_LZMA&quot;&gt; &lt;code&gt;ZIP_LZMA&lt;/code&gt; 를&lt;/a&gt; 사용할 때는 효과가 없습니다. &lt;a href=&quot;#zipfile.ZIP_DEFLATED&quot;&gt; &lt;code&gt;ZIP_DEFLATED&lt;/code&gt; 를&lt;/a&gt; 사용 하는 경우 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;9&lt;/code&gt; 까지의 정수 가 허용됩니다 ( 자세한 내용 은 &lt;a href=&quot;zlib#zlib.compressobj&quot;&gt; &lt;code&gt;zlib&lt;/code&gt; &lt;/a&gt; 참조 ). 사용시 &lt;a href=&quot;#zipfile.ZIP_BZIP2&quot;&gt; &lt;code&gt;ZIP_BZIP2&lt;/code&gt; &lt;/a&gt; 정수 &lt;code&gt;1&lt;/code&gt; 내지 &lt;code&gt;9&lt;/code&gt; 접수를 (참조 &lt;a href=&quot;bz2#bz2.BZ2File&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="ddb13b39623dcafcf4f44aec9717c0167926fdf6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;context&lt;/em&gt; precision does not affect how many digits are stored. That is determined exclusively by the number of digits in &lt;em&gt;value&lt;/em&gt;. For example, &lt;code&gt;Decimal('3.00000')&lt;/code&gt; records all five zeros even if the context precision is only three.</source>
          <target state="translated">&lt;em&gt;상황에 맞는&lt;/em&gt; 정밀도는 저장 얼마나 많은 숫자에 영향을주지 않습니다. 이는 &lt;em&gt;값&lt;/em&gt; 의 자릿수에 의해서만 결정됩니다 . 예를 들어, &lt;code&gt;Decimal('3.00000')&lt;/code&gt; 은 컨텍스트 정밀도가 3에 불과하더라도 5 개의 0을 모두 기록합니다.</target>
        </trans-unit>
        <trans-unit id="d5e6fbc8c11370385eb242760b9740f5836b90d3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;conversion&lt;/em&gt; field causes a type coercion before formatting. Normally, the job of formatting a value is done by the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt; method of the value itself. However, in some cases it is desirable to force a type to be formatted as a string, overriding its own definition of formatting. By converting the value to a string before calling &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt;&lt;code&gt;__format__()&lt;/code&gt;&lt;/a&gt;, the normal formatting logic is bypassed.</source>
          <target state="translated">&lt;em&gt;변환&lt;/em&gt; 필드 포맷하기 전에 유형 강제 변환됩니다. 일반적으로 값을 형식화하는 작업은 값 자체 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 메소드에 의해 수행 됩니다. 그러나 경우에 따라 형식을 문자열 형식으로 지정하여 형식에 대한 자체 정의를 재정의하는 것이 바람직합니다. &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__format__&quot;&gt; &lt;code&gt;__format__()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 값을 문자열로 변환하면 일반 형식 지정 논리가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b2cdc701e2c81ec997648e61d22b6adb27be68cf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;d&lt;/em&gt;&amp;rsquo;th day (0 &amp;lt;= &lt;em&gt;d&lt;/em&gt; &amp;lt;= 6) of week &lt;em&gt;n&lt;/em&gt; of month &lt;em&gt;m&lt;/em&gt; of the year (1 &amp;lt;= &lt;em&gt;n&lt;/em&gt; &amp;lt;= 5, 1 &amp;lt;= &lt;em&gt;m&lt;/em&gt; &amp;lt;= 12, where week 5 means &amp;ldquo;the last &lt;em&gt;d&lt;/em&gt; day in month &lt;em&gt;m&lt;/em&gt;&amp;rdquo; which may occur in either the fourth or the fifth week). Week 1 is the first week in which the &lt;em&gt;d&lt;/em&gt;&amp;rsquo;th day occurs. Day zero is a Sunday.</source>
          <target state="translated">&lt;em&gt;D&lt;/em&gt; '일째 (0 &amp;lt;= &lt;em&gt;D&lt;/em&gt; &amp;lt;= 6) 주 &lt;em&gt;N&lt;/em&gt; 개월의 &lt;em&gt;m&lt;/em&gt; 올 (1 &amp;lt;= &lt;em&gt;N&lt;/em&gt; &amp;lt;= 5, 1 &amp;lt;= &lt;em&gt;m&lt;/em&gt; &amp;lt;= 12, 여기서 주 5 수단 &quot;마지막 &lt;em&gt;차원&lt;/em&gt; 날 개월 &lt;em&gt;m&lt;/em&gt; &amp;rdquo;) (4 번째 또는 5 번째 주에 발생할 수 있음). 1 주차는 &lt;em&gt;d&lt;/em&gt; 번째 날 이 발생한 첫 주입니다 . 0 일은 일요일입니다.</target>
        </trans-unit>
        <trans-unit id="9036429e9d7f5146bc247599a86f71fa7486b2b8" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; argument can be whatever the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function supports (i.e. string or bytes). The &lt;em&gt;path&lt;/em&gt; argument should be the &amp;ldquo;path&amp;rdquo; to where the source code originated from, which can be an abstract concept (e.g. location in a zip file).</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 인수는 무엇이든 할 수있다 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 기능 지원 (예 : 문자열 또는 바이트). &lt;em&gt;경로&lt;/em&gt; 인수는 소스 코드는 추상적 인 개념 (zip 파일의 예를 들어 위치)가 될 수있는, 어디에서 유래에 &quot;경로&quot;이어야한다.</target>
        </trans-unit>
        <trans-unit id="8e21c5c2ac1fec214edb5720c17f5f7ed3424d7e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; can be any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;iterable&lt;/a&gt; and should consist of values that can be converted to type &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;data&lt;/em&gt; does not contain at least two elements, raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; because it takes at least one point to estimate a central value and at least two points to estimate dispersion.</source>
          <target state="translated">&lt;em&gt;데이터는&lt;/em&gt; 임의의 것일 수있는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-iterable&quot;&gt;반복 가능한&lt;/a&gt; 및 유형으로 변환 할 수있는 값으로 구성되어야 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; . 경우 &lt;em&gt;데이터가&lt;/em&gt; 적어도 두 개의 요소를 포함하지 않는 상승 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 을&lt;/a&gt; 그 중심 값과 추정 된 분산에 적어도 두 점을 추정하는 적어도 하나의 포인트 걸리므.</target>
        </trans-unit>
        <trans-unit id="0b832475cfa8a9dd77d9b1b927964df35f6bb322" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; can be any iterable containing sample data. For meaningful results, the number of data points in &lt;em&gt;data&lt;/em&gt; should be larger than &lt;em&gt;n&lt;/em&gt;. Raises &lt;a href=&quot;#statistics.StatisticsError&quot;&gt;&lt;code&gt;StatisticsError&lt;/code&gt;&lt;/a&gt; if there are not at least two data points.</source>
          <target state="translated">&lt;em&gt;데이터는&lt;/em&gt; 어떠한 반복 가능 함유 샘플 데이터 일 수있다. 의미있는 결과를 들면, 데이터 포인트의 개수 &lt;em&gt;데이터&lt;/em&gt; 보다 커야 &lt;em&gt;N&lt;/em&gt; . 발생시킵니다 &lt;a href=&quot;#statistics.StatisticsError&quot;&gt; &lt;code&gt;StatisticsError&lt;/code&gt; 는&lt;/a&gt; 적어도 두 개의 데이터 포인트가없는 경우.</target>
        </trans-unit>
        <trans-unit id="d46475fe7beb032a1dde9b71f62e7b60ff7cca66" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;data&lt;/em&gt; parameter will be the entire contents of the declaration inside the &lt;code&gt;&amp;lt;![...]&amp;gt;&lt;/code&gt; markup. It is sometimes useful to be overridden by a derived class. The base class implementation does nothing.</source>
          <target state="translated">&lt;em&gt;데이터&lt;/em&gt; 파라미터는 내부 선언의 전체 내용이 될 것이다 &lt;code&gt;&amp;lt;![...]&amp;gt;&lt;/code&gt; 태그. 파생 클래스로 재정의하는 것이 유용한 경우가 있습니다. 기본 클래스 구현은 아무 것도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd72e401bf63a75fade8457ee5eccda856af08af" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;debug_override&lt;/em&gt; parameter is deprecated and can be used to override the system&amp;rsquo;s value for &lt;code&gt;__debug__&lt;/code&gt;. A &lt;code&gt;True&lt;/code&gt; value is the equivalent of setting &lt;em&gt;optimization&lt;/em&gt; to the empty string. A &lt;code&gt;False&lt;/code&gt; value is the same as setting &lt;em&gt;optimization&lt;/em&gt; to &lt;code&gt;1&lt;/code&gt;. If both &lt;em&gt;debug_override&lt;/em&gt; an &lt;em&gt;optimization&lt;/em&gt; are not &lt;code&gt;None&lt;/code&gt; then &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;em&gt;debug_override의&lt;/em&gt; 매개 변수는 사용되지 않으며위한 시스템의 값을 대체하는 데 사용할 수 있습니다 &lt;code&gt;__debug__&lt;/code&gt; 을 . &lt;code&gt;True&lt;/code&gt; 값을 설정하는 것과 동일 &lt;em&gt;최적화를&lt;/em&gt; 빈 문자열로. &lt;code&gt;False&lt;/code&gt; 값을 설정하는 것과 같습니다 &lt;em&gt;최적화&lt;/em&gt; 에 &lt;code&gt;1&lt;/code&gt; . 두 경우 &lt;em&gt;debug_override &lt;/em&gt;&lt;em&gt;최적화&lt;/em&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 다음 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99e0c356da751dd166a63e978dc2a39c5eedc1fa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;decl&lt;/em&gt; parameter will be the entire contents of the declaration inside the &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; markup (e.g. &lt;code&gt;'DOCTYPE html'&lt;/code&gt;).</source>
          <target state="translated">&lt;em&gt;자명 한 일 입니의&lt;/em&gt; 매개 변수는 내부의 선언의 전체 내용이 될 것입니다 &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; 마크 업 (예를 들어 &lt;code&gt;'DOCTYPE html'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6ef3824e032cf9a741f848cb50c2d7646000b316" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;defaultTest&lt;/em&gt; argument is either the name of a single test or an iterable of test names to run if no test names are specified via &lt;em&gt;argv&lt;/em&gt;. If not specified or &lt;code&gt;None&lt;/code&gt; and no test names are provided via &lt;em&gt;argv&lt;/em&gt;, all tests found in &lt;em&gt;module&lt;/em&gt; are run.</source>
          <target state="translated">&lt;em&gt;defaultTest&lt;/em&gt; 인수는 하나 하나 테스트의 이름이나 더 테스트 이름을 통해 지정되지 않은 경우 실행 테스트 이름의 반복자입니다 &lt;em&gt;ARGV&lt;/em&gt; . &lt;em&gt;argv&lt;/em&gt; 를 통해 지정되지 않거나 &lt;code&gt;None&lt;/code&gt; 이고 테스트 이름이 제공되지 않으면 &lt;em&gt;모듈&lt;/em&gt; 에서 찾은 모든 테스트 가 실행됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2d19d5ca4548580938d6b4d9329d9a62bbfc3144" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;defects&lt;/em&gt; attribute contains a list of all the problems found when parsing this message. See &lt;a href=&quot;email.errors#module-email.errors&quot;&gt;&lt;code&gt;email.errors&lt;/code&gt;&lt;/a&gt; for a detailed description of the possible parsing defects.</source>
          <target state="translated">&lt;em&gt;결함의&lt;/em&gt; 속성은이 메시지를 구문 분석 할 때 발견 된 모든 문제의 목록이 포함되어 있습니다. 가능한 구문 분석 결함에 대한 자세한 설명은 &lt;a href=&quot;email.errors#module-email.errors&quot;&gt; &lt;code&gt;email.errors&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3f2596b66bd7ed716cf9dba1109e5f24389e006" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dict_type&lt;/em&gt; is the type used for dictionaries that are read from the plist file.</source>
          <target state="translated">&lt;em&gt;dict_type는&lt;/em&gt; PLIST 파일에서 읽어 사전에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="4e0020d0746abd869d54f08c307ddd6914e84e24" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dir&lt;/em&gt;, &lt;em&gt;prefix&lt;/em&gt; and &lt;em&gt;suffix&lt;/em&gt; parameters have the same meaning and defaults as with &lt;a href=&quot;#tempfile.mkstemp&quot;&gt;&lt;code&gt;mkstemp()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;DIR&lt;/em&gt; , &lt;em&gt;접두사&lt;/em&gt; 와 &lt;em&gt;접미사&lt;/em&gt; 매개 변수와 동일한 의미와 기본값이 &lt;a href=&quot;#tempfile.mkstemp&quot;&gt; &lt;code&gt;mkstemp()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="678377d21d95b5da2eccbd2ed6a5bf79dc5f7822" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;domain&lt;/em&gt; argument allows overriding the NIS domain used for the lookup. If unspecified, lookup is in the default NIS domain.</source>
          <target state="translated">&lt;em&gt;도메인&lt;/em&gt; 인수는 조회에 사용되는 NIS 도메인을 무시 허용한다. 지정하지 않으면 조회가 기본 NIS 도메인에 있습니다.</target>
        </trans-unit>
        <trans-unit id="541a21c0d12fc17803562f97e87bab04e8920e68" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;doraise&lt;/em&gt; and &lt;em&gt;quiet&lt;/em&gt; arguments determine how errors are handled while compiling file. If &lt;em&gt;quiet&lt;/em&gt; is 0 or 1, and &lt;em&gt;doraise&lt;/em&gt; is false, the default behaviour is enabled: an error string is written to &lt;code&gt;sys.stderr&lt;/code&gt;, and the function returns &lt;code&gt;None&lt;/code&gt; instead of a path. If &lt;em&gt;doraise&lt;/em&gt; is true, a &lt;a href=&quot;#py_compile.PyCompileError&quot;&gt;&lt;code&gt;PyCompileError&lt;/code&gt;&lt;/a&gt; is raised instead. However if &lt;em&gt;quiet&lt;/em&gt; is 2, no message is written, and &lt;em&gt;doraise&lt;/em&gt; has no effect.</source>
          <target state="translated">&lt;em&gt;doraise&lt;/em&gt; 과 &lt;em&gt;조용한&lt;/em&gt; 인수 파일을 컴파일하는 동안 오류를 처리하는 방법을 결정합니다. 경우 &lt;em&gt;조용한는&lt;/em&gt; 0 또는 1이고, &lt;em&gt;doraise는&lt;/em&gt; 오류 문자열에 기록됩니다 거짓, 기본 동작이 활성화되지 &lt;code&gt;sys.stderr&lt;/code&gt; 를 하고, 함수 반환 &lt;code&gt;None&lt;/code&gt; 대신 경로. 경우 &lt;em&gt;doraise는&lt;/em&gt; 사실이다하는 &lt;a href=&quot;#py_compile.PyCompileError&quot;&gt; &lt;code&gt;PyCompileError&lt;/code&gt; 가&lt;/a&gt; 대신 발생합니다. 그러나 &lt;em&gt;quiet&lt;/em&gt; 가 2이면 메시지가 작성 되지 않으며 &lt;em&gt;doraise&lt;/em&gt; 가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f45beba9ae9b99fd6eddff1254b265a6b06ccf7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;dt&lt;/em&gt; argument is ignored. The return value is a &lt;a href=&quot;#datetime.timedelta&quot;&gt;&lt;code&gt;timedelta&lt;/code&gt;&lt;/a&gt; instance equal to the difference between the local time and UTC.</source>
          <target state="translated">&lt;em&gt;DT의&lt;/em&gt; 인수는 무시됩니다. 반환 값은 현지 시간과 UTC의 차이와 동일한 &lt;a href=&quot;#datetime.timedelta&quot;&gt; &lt;code&gt;timedelta&lt;/code&gt; &lt;/a&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="7ed9f309122fc25ff8178610e7f4da0a59231fe1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encode&lt;/em&gt; and &lt;em&gt;decode&lt;/em&gt; arguments must adhere to the &lt;code&gt;Codec&lt;/code&gt; interface. &lt;em&gt;Reader&lt;/em&gt; and &lt;em&gt;Writer&lt;/em&gt; must be factory functions or classes providing objects of the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; interface respectively.</source>
          <target state="translated">&lt;em&gt;인 코드&lt;/em&gt; 및 &lt;em&gt;디코드&lt;/em&gt; 인수는 준수해야 &lt;code&gt;Codec&lt;/code&gt; 인터페이스를 제공합니다. &lt;em&gt;Reader&lt;/em&gt; 와 &lt;em&gt;Writer&lt;/em&gt; 는 각각 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 인터페이스의 객체를 제공하는 팩토리 함수 또는 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="29e7c348a1628ee9dd37b6150c94cd6ec0cfbf2a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encode_chunked&lt;/em&gt; argument is only relevant if Transfer-Encoding is specified in &lt;em&gt;headers&lt;/em&gt;. If &lt;em&gt;encode_chunked&lt;/em&gt; is &lt;code&gt;False&lt;/code&gt;, the HTTPConnection object assumes that all encoding is handled by the calling code. If it is &lt;code&gt;True&lt;/code&gt;, the body will be chunk-encoded.</source>
          <target state="translated">&lt;em&gt;encode_chunked&lt;/em&gt; 전송 인코딩이 지정되면 인수는 관련이 &lt;em&gt;헤더&lt;/em&gt; . 경우 &lt;em&gt;encode_chunked이&lt;/em&gt; 있다 &lt;code&gt;False&lt;/code&gt; 의 HttpConnection에 객체는 모든 인코딩이 호출 코드에 의해 처리되어 있다고 가정합니다. 이 경우 &lt;code&gt;True&lt;/code&gt; , 몸은 덩어리 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="c325607a7de886abde53f31697d71ac0d9b3a43d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encoding&lt;/em&gt; and &lt;em&gt;errors&lt;/em&gt; arguments define the character encoding to be used for reading or writing the archive and how conversion errors are going to be handled. The default settings will work for most users. See section &lt;a href=&quot;#tar-unicode&quot;&gt;Unicode issues&lt;/a&gt; for in-depth information.</source>
          <target state="translated">&lt;em&gt;인코딩&lt;/em&gt; 및 &lt;em&gt;오류&lt;/em&gt; 인수는 문자 인코딩 읽거나 아카이브를 작성하는 방법과 변환 오류 처리 할 예정에 사용되는 정의합니다. 기본 설정은 대부분의 사용자에게 적용됩니다. 자세한 정보는 &lt;a href=&quot;#tar-unicode&quot;&gt;유니 코드 문제&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c14540e9d5e02ef282d24989bc0560f5d43b74be" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;encoding&lt;/em&gt; argument behaves like the corresponding argument of &lt;a href=&quot;#xml.dom.minidom.Node.toxml&quot;&gt;&lt;code&gt;toxml()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;코딩&lt;/em&gt; 의 대응하는 인자처럼 행동한다 인수 &lt;a href=&quot;#xml.dom.minidom.Node.toxml&quot;&gt; &lt;code&gt;toxml()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff5ea8da7e93711f96576b90a0535523be394058" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epilogue&lt;/em&gt; attribute acts the same way as the &lt;em&gt;preamble&lt;/em&gt; attribute, except that it contains text that appears between the last boundary and the end of the message.</source>
          <target state="translated">&lt;em&gt;에필로그&lt;/em&gt; 속성은 같은 방식으로 작동 &lt;em&gt;프리앰블&lt;/em&gt; 은 텍스트가 포함 된 것을 제외하고, 속성을 그 마지막 경계와 메시지의 끝 사이가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="922c64a430cac350255517325dcc4e95110a3128" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epilogue&lt;/em&gt; attribute acts the same way as the &lt;em&gt;preamble&lt;/em&gt; attribute, except that it contains text that appears between the last boundary and the end of the message. As with the &lt;a href=&quot;#email.message.EmailMessage.preamble&quot;&gt;&lt;code&gt;preamble&lt;/code&gt;&lt;/a&gt;, if there is no epilog text this attribute will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;에필로그&lt;/em&gt; 속성은 같은 방식으로 작동 &lt;em&gt;프리앰블&lt;/em&gt; 은 텍스트가 포함 된 것을 제외하고, 속성을 그 마지막 경계와 메시지의 끝 사이가 나타납니다. &lt;a href=&quot;#email.message.EmailMessage.preamble&quot;&gt; &lt;code&gt;preamble&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 에필로그 텍스트가없는 경우이 속성은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="07e6075314e49857e472236bdfa91c705e2f0813" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;epoch&lt;/em&gt; is the point where the time starts, and is platform dependent. For Unix, the epoch is January 1, 1970, 00:00:00 (UTC). To find out what the epoch is on a given platform, look at &lt;code&gt;time.gmtime(0)&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;시대는&lt;/em&gt; 시간이 시작되는 지점이며, 플랫폼에 따라 달라집니다. 유닉스의 시대는 1970 년 1 월 1 일 00:00:00 (UTC)입니다. 주어진 플랫폼에서 신기원이 무엇인지 알아 보려면 &lt;code&gt;time.gmtime(0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3738dcf310d32e085451a3c93f9bf3c820ec7a6b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument defines how characters are treated that cannot be converted. Possible values are listed in section &lt;a href=&quot;codecs#error-handlers&quot;&gt;Error Handlers&lt;/a&gt;. The default scheme is &lt;code&gt;'surrogateescape'&lt;/code&gt; which Python also uses for its file system calls, see &lt;a href=&quot;os#os-filenames&quot;&gt;File Names, Command Line Arguments, and Environment Variables&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 문자는 변환 할 수없는 것을 처리하는 방법을 인수 정의합니다. 가능한 값은 &lt;a href=&quot;codecs#error-handlers&quot;&gt;오류 처리기&lt;/a&gt; 섹션에 나열되어 있습니다 . 기본 체계는 파이썬이 파일 시스템 호출에 사용하는 &lt;code&gt;'surrogateescape'&lt;/code&gt; 입니다 ( &lt;a href=&quot;os#os-filenames&quot;&gt;파일 이름, 명령 줄 인수 및 환경 변수 참조)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="accd6ed2c4add06dcc82825a5c29164b4aa44ad7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument defines the error handling to apply. It defaults to &lt;code&gt;'strict'&lt;/code&gt; handling.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 적용 오류 처리를 정의합니다. 기본값은 &lt;code&gt;'strict'&lt;/code&gt; 처리입니다.</target>
        </trans-unit>
        <trans-unit id="417c35e3c3489ecae455dfd7cc1fdfb4272d8a54" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt;&lt;code&gt;IncrementalDecoder&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.IncrementalDecoder&quot;&gt; &lt;code&gt;IncrementalDecoder&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0193b2731a3bc5048c2a96e0d3333506018910d7" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt;&lt;code&gt;IncrementalEncoder&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.IncrementalEncoder&quot;&gt; &lt;code&gt;IncrementalEncoder&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="07408f3978c0e16f152e5b37f0839ea36889cf01" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 특성에 할당하면 &lt;a href=&quot;#codecs.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 개체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56664efc67b073b3b091d3fb8068398e69c0cbdf" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;errors&lt;/em&gt; argument will be assigned to an attribute of the same name. Assigning to this attribute makes it possible to switch between different error handling strategies during the lifetime of the &lt;a href=&quot;#codecs.StreamWriter&quot;&gt;&lt;code&gt;StreamWriter&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;em&gt;오류&lt;/em&gt; 인수는 같은 이름의 속성에 할당됩니다. 이 속성에 할당하면 &lt;a href=&quot;#codecs.StreamWriter&quot;&gt; &lt;code&gt;StreamWriter&lt;/code&gt; &lt;/a&gt; 객체 의 수명 동안 다른 오류 처리 전략간에 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdb2e9827a01e7259645dad2c2d3343a896529f4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;exec_body&lt;/em&gt; argument is a callback that is used to populate the freshly created class namespace. It should accept the class namespace as its sole argument and update the namespace directly with the class contents. If no callback is provided, it has the same effect as passing in &lt;code&gt;lambda ns: ns&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;exec_body&lt;/em&gt; 인수는 새로 생성 된 클래스 네임 스페이스를 채우는 데 사용되는 콜백입니다. 클래스 네임 스페이스를 유일한 인수로 허용하고 클래스 컨텐츠로 네임 스페이스를 직접 업데이트해야합니다. 콜백이 제공되지 않으면 &lt;code&gt;lambda ns: ns&lt;/code&gt; 를 전달하는 것과 동일한 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="55c7ca7eb02e1ac631fb9b49acf3b5fa4fbcaaa0" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executable&lt;/em&gt; argument specifies a replacement program to execute. It is very seldom needed. When &lt;code&gt;shell=False&lt;/code&gt;, &lt;em&gt;executable&lt;/em&gt; replaces the program to execute specified by &lt;em&gt;args&lt;/em&gt;. However, the original &lt;em&gt;args&lt;/em&gt; is still passed to the program. Most programs treat the program specified by &lt;em&gt;args&lt;/em&gt; as the command name, which can then be different from the program actually executed. On POSIX, the &lt;em&gt;args&lt;/em&gt; name becomes the display name for the executable in utilities such as &lt;strong&gt;ps&lt;/strong&gt;. If &lt;code&gt;shell=True&lt;/code&gt;, on POSIX the &lt;em&gt;executable&lt;/em&gt; argument specifies a replacement shell for the default &lt;code&gt;/bin/sh&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;실행&lt;/em&gt; 인수는 실행할 대체 프로그램을 지정합니다. 거의 필요하지 않습니다. &lt;code&gt;shell=False&lt;/code&gt; 일 때 &lt;em&gt;실행 파일&lt;/em&gt; 은 &lt;em&gt;args로&lt;/em&gt; 지정된 실행 프로그램을 대체합니다 . 그러나 원래 &lt;em&gt;인수&lt;/em&gt; 는 여전히 프로그램으로 전달됩니다. 대부분의 프로그램은 &lt;em&gt;args&lt;/em&gt; 로 지정된 프로그램을 명령 이름으로 취급하므로 실제로 실행되는 프로그램과 다를 수 있습니다. POSIX에서 &lt;em&gt;args&lt;/em&gt; 이름은 &lt;strong&gt;ps&lt;/strong&gt; 와 같은 유틸리티에서 실행 파일의 표시 이름이됩니다 . &lt;code&gt;shell=True&lt;/code&gt; 인 경우 POSIX에서 &lt;em&gt;실행 가능&lt;/em&gt; 인수는 기본 &lt;code&gt;/bin/sh&lt;/code&gt; 의 대체 쉘을 지정합니다..</target>
        </trans-unit>
        <trans-unit id="a2283b4e58ae37a66ef528c3791a1b7ee66c3708" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;executor&lt;/em&gt; argument should be an &lt;a href=&quot;concurrent.futures#concurrent.futures.Executor&quot;&gt;&lt;code&gt;concurrent.futures.Executor&lt;/code&gt;&lt;/a&gt; instance. The default executor is used if &lt;em&gt;executor&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;실행 프로그램&lt;/em&gt; 인수는해야 &lt;a href=&quot;concurrent.futures#concurrent.futures.Executor&quot;&gt; &lt;code&gt;concurrent.futures.Executor&lt;/code&gt; 의&lt;/a&gt; 인스턴스입니다. &lt;em&gt;실행 프로그램&lt;/em&gt; 이 &lt;code&gt;None&lt;/code&gt; 경우 기본 실행 프로그램이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="bc0182bbf1f5e1c0e30b3cb44d4050e6085c5147" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;expression&lt;/em&gt; argument is parsed and evaluated as a Python expression (technically speaking, a condition list) using the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; dictionaries as global and local namespace. If the &lt;em&gt;globals&lt;/em&gt; dictionary is present and does not contain a value for the key &lt;code&gt;__builtins__&lt;/code&gt;, a reference to the dictionary of the built-in module &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; is inserted under that key before &lt;em&gt;expression&lt;/em&gt; is parsed. This means that &lt;em&gt;expression&lt;/em&gt; normally has full access to the standard &lt;a href=&quot;builtins#module-builtins&quot;&gt;&lt;code&gt;builtins&lt;/code&gt;&lt;/a&gt; module and restricted environments are propagated. If the &lt;em&gt;locals&lt;/em&gt; dictionary is omitted it defaults to the &lt;em&gt;globals&lt;/em&gt; dictionary. If both dictionaries are omitted, the expression is executed with the &lt;em&gt;globals&lt;/em&gt; and &lt;em&gt;locals&lt;/em&gt; in the environment where &lt;a href=&quot;#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt; is called. Note, &lt;em&gt;eval()&lt;/em&gt; does not have access to the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;nested scopes&lt;/a&gt; (non-locals) in the enclosing environment.</source>
          <target state="translated">&lt;em&gt;식&lt;/em&gt; 인수는 구문 분석하고 사용하며 (기술적 조건 목록을 말하기) 파이썬 표현으로 평가 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역 주민의&lt;/em&gt; 글로벌 및 로컬 네임 스페이스로 사전을. 경우] &lt;em&gt;전역의&lt;/em&gt; 사전 존재하고, 키의 값이 포함되지 않는 &lt;code&gt;__builtins__&lt;/code&gt; , 내장 모듈의 사전 참조 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 전에 키에 삽입되어 &lt;em&gt;발현&lt;/em&gt; 해석된다. 이는 &lt;em&gt;표현식이&lt;/em&gt; 일반적으로 표준 &lt;a href=&quot;builtins#module-builtins&quot;&gt; &lt;code&gt;builtins&lt;/code&gt; &lt;/a&gt; 모듈에 대한 전체 액세스 권한을 가지며 제한된 환경이 전파됨을 의미합니다. &lt;em&gt;지역&lt;/em&gt; 사전이 생략 되면 기본값은&lt;em&gt;글로벌&lt;/em&gt; 사전. 두 사전을 모두 생략하면 &lt;a href=&quot;#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 이 호출 되는 환경에서 &lt;em&gt;전역&lt;/em&gt; 및 &lt;em&gt;지역&lt;/em&gt; 을 사용하여 표현식이 실행됩니다 . 참고 &lt;em&gt;평가는 ()&lt;/em&gt; 에 액세스 할 수 없습니다 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-nested-scope&quot;&gt;중첩 된 범위를&lt;/a&gt; 둘러싸고있는 환경에서 (비 지역 주민).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1c27bdb65636017d6b3ff59ca63cf0593fdd5b0b" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;extra&lt;/em&gt; argument can be a set of names that wouldn&amp;rsquo;t otherwise be automatically detected as &amp;ldquo;public&amp;rdquo;, like objects without a proper &lt;code&gt;__module__&lt;/code&gt; attribute. If provided, it will be added to the automatically detected ones.</source>
          <target state="translated">&lt;em&gt;추가&lt;/em&gt; 인수는 적절한없이 객체와 같은 그렇지 않으면 자동으로 &quot;공개&quot;로 감지되지 않을 것이다 이름의 설정을 할 수 있습니다 &lt;code&gt;__module__&lt;/code&gt; 의 속성. 제공되는 경우 자동 감지 된 항목에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a08cf90e834703ae213fd12223835ee5ad8adf15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;failfast&lt;/em&gt;, &lt;em&gt;catchbreak&lt;/em&gt; and &lt;em&gt;buffer&lt;/em&gt; parameters have the same effect as the same-name &lt;a href=&quot;#command-line-options&quot;&gt;command-line options&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;페일 패스트&lt;/em&gt; , &lt;em&gt;catchbreak&lt;/em&gt; 및 &lt;em&gt;버퍼&lt;/em&gt; 파라미터와 동일한 이름과 동일한 효과가 &lt;a href=&quot;#command-line-options&quot;&gt;명령 행 옵션&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="874e26c7407b8380f904f71fc4795a0f8587333f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;family&lt;/em&gt;, &lt;em&gt;type&lt;/em&gt; and &lt;em&gt;proto&lt;/em&gt; arguments can be optionally specified in order to narrow the list of addresses returned. Passing zero as a value for each of these arguments selects the full range of results. The &lt;em&gt;flags&lt;/em&gt; argument can be one or several of the &lt;code&gt;AI_*&lt;/code&gt; constants, and will influence how results are computed and returned. For example, &lt;code&gt;AI_NUMERICHOST&lt;/code&gt; will disable domain name resolution and will raise an error if &lt;em&gt;host&lt;/em&gt; is a domain name.</source>
          <target state="translated">&lt;em&gt;가족&lt;/em&gt; , &lt;em&gt;유형&lt;/em&gt; 및 &lt;em&gt;프로토&lt;/em&gt; 인수는 선택적으로 반환 주소 목록을 축소하기 위해 지정 될 수 있습니다. 이러한 각 인수의 값으로 0을 전달하면 전체 범위의 결과가 선택됩니다. &lt;em&gt;플래그&lt;/em&gt; 인수는 하나 또는 여러 될 수 있습니다 &lt;code&gt;AI_*&lt;/code&gt; 상수 및 결과를 계산하고 반환하는 방법에 영향을 미칠 것이다. 예를 들어 &lt;code&gt;AI_NUMERICHOST&lt;/code&gt; 는 도메인 이름 확인을 비활성화하고 &lt;em&gt;호스트&lt;/em&gt; 가 도메인 이름 인 경우 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="f85bfe90a7abfa4522d7aec6379ca2959433acc1" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;field_name&lt;/em&gt; itself begins with an &lt;em&gt;arg_name&lt;/em&gt; that is either a number or a keyword. If it&amp;rsquo;s a number, it refers to a positional argument, and if it&amp;rsquo;s a keyword, it refers to a named keyword argument. If the numerical arg_names in a format string are 0, 1, 2, &amp;hellip; in sequence, they can all be omitted (not just some) and the numbers 0, 1, 2, &amp;hellip; will be automatically inserted in that order. Because &lt;em&gt;arg_name&lt;/em&gt; is not quote-delimited, it is not possible to specify arbitrary dictionary keys (e.g., the strings &lt;code&gt;'10'&lt;/code&gt; or &lt;code&gt;':-]'&lt;/code&gt;) within a format string. The &lt;em&gt;arg_name&lt;/em&gt; can be followed by any number of index or attribute expressions. An expression of the form &lt;code&gt;'.name'&lt;/code&gt; selects the named attribute using &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt;, while an expression of the form &lt;code&gt;'[index]'&lt;/code&gt; does an index lookup using &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt;&lt;code&gt;__getitem__()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;FIELD_NAME&lt;/em&gt; 자체는 시작 &lt;em&gt;arg_name&lt;/em&gt; 숫자 나 키워드 중 하나입니다. 숫자 인 경우 위치 인수를 나타내고 키워드 인 경우 명명 된 키워드 인수를 나타냅니다. 형식 문자열의 숫자 arg_name이 순서대로 0, 1, 2,&amp;hellip; 인 경우 모두 생략 할 수 있으며 숫자 0, 1, 2,&amp;hellip;가 자동으로 순서대로 삽입됩니다. 때문에 &lt;em&gt;arg_name가&lt;/em&gt; 구분 인용되지 않으며, 이는 임의의 키를 사전에 특정 할 수 없다 (예를 들어, 문자열 &lt;code&gt;'10'&lt;/code&gt; 또는 &lt;code&gt;':-]'&lt;/code&gt; ) 형식 문자열 내의. &lt;em&gt;arg_name은&lt;/em&gt; 인덱스 또는 속성 표현의 수에 따라 할 수있다. &lt;code&gt;'.name'&lt;/code&gt; 형식의 표현식&lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 사용하여 이름 지정된 속성을 선택하고 &lt;code&gt;'[index]'&lt;/code&gt; 양식의 표현식은 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getitem__&quot;&gt; &lt;code&gt;__getitem__()&lt;/code&gt; &lt;/a&gt; 사용하여 색인을 검색 합니다.</target>
        </trans-unit>
        <trans-unit id="c6d4fb8370566360de6f478e25e82c7c55877045" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;field_names&lt;/em&gt; are a sequence of strings such as &lt;code&gt;['x', 'y']&lt;/code&gt;. Alternatively, &lt;em&gt;field_names&lt;/em&gt; can be a single string with each fieldname separated by whitespace and/or commas, for example &lt;code&gt;'x y'&lt;/code&gt; or &lt;code&gt;'x, y'&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;FIELD_NAMES가&lt;/em&gt; 같은 문자열의 시퀀스이다 &lt;code&gt;['x', 'y']&lt;/code&gt; . 또는 &lt;em&gt;field_names&lt;/em&gt; 는 각 필드 이름이 공백 및 / 또는 쉼표로 구분 된 단일 문자열 일 수 있습니다 (예 : &lt;code&gt;'x y'&lt;/code&gt; 또는 &lt;code&gt;'x, y'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac35b9bd55fdc804fb4c9bb3bd701f67c7d5c57d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fieldnames&lt;/em&gt; parameter is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt;. If &lt;em&gt;fieldnames&lt;/em&gt; is omitted, the values in the first row of file &lt;em&gt;f&lt;/em&gt; will be used as the fieldnames. Regardless of how the fieldnames are determined, the dictionary preserves their original ordering.</source>
          <target state="translated">&lt;em&gt;fieldName에의&lt;/em&gt; 파라미터는 인 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-sequence&quot;&gt;시퀀스&lt;/a&gt; . 필드 &lt;em&gt;이름&lt;/em&gt; 을 생략하면 파일 &lt;em&gt;f&lt;/em&gt; 의 첫 번째 행에있는 값 이 필드 이름으로 사용됩니다. 필드 이름이 어떻게 결정되는지에 관계없이 사전은 원래 순서를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="86a8ce72332326de2cfebbc785262328b5fe47c2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument is an I/O stream to which the output is written; by default output is written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수 출력이 기록되는에 I / O 스트림이고; 기본적으로 출력은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 에&lt;/a&gt; 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6040de02499cbcc78ffe2e6448ad957eea44c1ad" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument must be an object with a &lt;code&gt;write(string)&lt;/code&gt; method; if it is not present or &lt;code&gt;None&lt;/code&gt;, &lt;a href=&quot;sys#sys.stdout&quot;&gt;&lt;code&gt;sys.stdout&lt;/code&gt;&lt;/a&gt; will be used. Since printed arguments are converted to text strings, &lt;a href=&quot;#print&quot;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/a&gt; cannot be used with binary mode file objects. For these, use &lt;code&gt;file.write(...)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수는 가진 객체 여야 &lt;code&gt;write(string)&lt;/code&gt; 방법; 존재하지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 &lt;a href=&quot;sys#sys.stdout&quot;&gt; &lt;code&gt;sys.stdout&lt;/code&gt; &lt;/a&gt; 이 사용됩니다. 인쇄 된 인수는 텍스트 문자열로 변환되므로 &lt;a href=&quot;#print&quot;&gt; &lt;code&gt;print()&lt;/code&gt; &lt;/a&gt; 는 이진 모드 파일 객체와 함께 사용할 수 없습니다. 이를 위해 대신 &lt;code&gt;file.write(...)&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="aa19d5965537594f6e3e44281d687c4aee5dfebd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; argument must have a write() method that accepts a single bytes argument. It can thus be an on-disk file opened for binary writing, an &lt;a href=&quot;io#io.BytesIO&quot;&gt;&lt;code&gt;io.BytesIO&lt;/code&gt;&lt;/a&gt; instance, or any other custom object that meets this interface.</source>
          <target state="translated">&lt;em&gt;파일&lt;/em&gt; 인수는 단일 바이트 인수를 받아들이는 쓰기 () 메소드가 있어야합니다. 따라서 이진 쓰기를 위해 열린 온 디스크 파일, &lt;a href=&quot;io#io.BytesIO&quot;&gt; &lt;code&gt;io.BytesIO&lt;/code&gt; &lt;/a&gt; 인스턴스 또는이 인터페이스를 충족하는 다른 사용자 지정 개체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="201c087ccb99a58c31b45c2b8d49929eddafdd3d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the fault handler is disabled: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일은&lt;/em&gt; 결함 핸들러가 비활성화 될 때까지 개방 유지해야한다 : 참조 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3d824b624f53e9446bead5d0c937eff0e8b3123" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the signal is unregistered by &lt;a href=&quot;#faulthandler.unregister&quot;&gt;&lt;code&gt;unregister()&lt;/code&gt;&lt;/a&gt;: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일이&lt;/em&gt; 신호가 등록 해제 될 때까지 개방 유지해야 &lt;a href=&quot;#faulthandler.unregister&quot;&gt; &lt;code&gt;unregister()&lt;/code&gt; &lt;/a&gt; : 참조 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c60c6ff1b28a53b914ece79a1a14de1b66fed36f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file&lt;/em&gt; must be kept open until the traceback is dumped or &lt;a href=&quot;#faulthandler.cancel_dump_traceback_later&quot;&gt;&lt;code&gt;cancel_dump_traceback_later()&lt;/code&gt;&lt;/a&gt; is called: see &lt;a href=&quot;#faulthandler-fd&quot;&gt;issue with file descriptors&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;파일을&lt;/em&gt; 역 추적이 덤프 될 때까지 또는 개방 유지해야 &lt;a href=&quot;#faulthandler.cancel_dump_traceback_later&quot;&gt; &lt;code&gt;cancel_dump_traceback_later()&lt;/code&gt; &lt;/a&gt; 참조하십시오라고 &lt;a href=&quot;#faulthandler-fd&quot;&gt;파일 기술자와 함께 문제를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a5d02926f630f9388faa40b312c84ee98f366aa" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;file_actions&lt;/em&gt; argument may be a sequence of tuples describing actions to take on specific file descriptors in the child process between the C library implementation&amp;rsquo;s &lt;code&gt;fork()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt; steps. The first item in each tuple must be one of the three type indicator listed below describing the remaining tuple elements:</source>
          <target state="translated">&lt;em&gt;file_actions의&lt;/em&gt; 인수는 C 라이브러리 구현 사이의 자식 프로세스의 특정 파일 디스크립터에 수행 할 동작을 설명하는 튜플들의 시퀀스 일 수있다 &lt;code&gt;fork()&lt;/code&gt; 와 &lt;code&gt;exec()&lt;/code&gt; 단계. 각 튜플의 첫 번째 항목은 나머지 튜플 요소를 설명하는 아래에 나열된 세 가지 유형 표시기 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="574ad47a01d4d5dcdc30c910d4f1c794203d0425" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument can be an actual filename (a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object), or an existing file object to read from or write to.</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 인수는 실제 파일 이름 (A 할 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체), 또는 나 쓰기에 읽을 수있는 기존 파일 개체를.</target>
        </trans-unit>
        <trans-unit id="f033d031375597aa29c16f1a2c2f915020115b6f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument can be either an actual file name (given as a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;path-like&lt;/a&gt; object), in which case the named file is opened, or it can be an existing file object to read from or write to.</source>
          <target state="translated">&lt;em&gt;파일명&lt;/em&gt; 인수 할 수 있습니다 (A로서 주어진 실제 파일 이름 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-like-object&quot;&gt;경로와 같은&lt;/a&gt; ,이 경우에 지정된 파일을 열 또는 그것으로부터 또는 기록을 판독 기존 파일 오브젝트 일 수 오브젝트).</target>
        </trans-unit>
        <trans-unit id="0545d354ccd3ed5753d4a3cb4b6a2b0b028f6ed5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filename&lt;/em&gt; argument should give the file from which the code was read; pass some recognizable value if it wasn&amp;rsquo;t read from a file (&lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; is commonly used).</source>
          <target state="translated">&lt;em&gt;파일 이름&lt;/em&gt; 인수는 코드를 읽은있는 파일을 제공해야합니다; 파일에서 읽지 않은 경우 인식 가능한 값을 전달하십시오 ( &lt;code&gt;'&amp;lt;string&amp;gt;'&lt;/code&gt; 이 일반적으로 사용됨).</target>
        </trans-unit>
        <trans-unit id="79131f6c9ec73987bfeb48e4342c755777c193ff" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filters&lt;/em&gt; argument (if provided) should be a filter chain specifier. See &lt;a href=&quot;#filter-chain-specs&quot;&gt;Specifying custom filter chains&lt;/a&gt; for details.</source>
          <target state="translated">&lt;em&gt;필터&lt;/em&gt; 인수 (있는 경우)의 필터 체인 지정해야한다. 자세한 내용은 &lt;a href=&quot;#filter-chain-specs&quot;&gt;사용자 정의 필터 체인 지정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="408e886918eee46fcb78729db9d3758b4414e533" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;filters&lt;/em&gt; argument specifies the filter chain that was used to create the stream being decompressed. This argument is required if &lt;em&gt;format&lt;/em&gt; is &lt;code&gt;FORMAT_RAW&lt;/code&gt;, but should not be used for other formats. See &lt;a href=&quot;#filter-chain-specs&quot;&gt;Specifying custom filter chains&lt;/a&gt; for more information about filter chains.</source>
          <target state="translated">&lt;em&gt;필터&lt;/em&gt; 인수 압축되는 스트림을 생성하는데 사용 된 필터 체인을 지정한다. &lt;em&gt;format&lt;/em&gt; 이 &lt;code&gt;FORMAT_RAW&lt;/code&gt; 인 경우이 인수가 필요 하지만 다른 형식에는 사용하지 않아야합니다. &lt;a href=&quot;#filter-chain-specs&quot;&gt;필터 체인에&lt;/a&gt; 대한 자세한 내용은 사용자 지정 필터 체인 지정을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f878d73c0efd98476dfc7a9b6cd6ad2c5b1de9d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;firstline&lt;/em&gt; flag indicates that it would be sufficient to only return the first line, if there are decoding errors on later lines.</source>
          <target state="translated">&lt;em&gt;firstLine의&lt;/em&gt; 플래그는 나중에 라인 디코딩 오류가있는 경우에만, 첫 번째 행을 반환하기에 충분 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ac4ac00687930f48d3d074bf948c94183e0fde15" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;flags&lt;/em&gt; entry shows that the rational approximation to &lt;code&gt;Pi&lt;/code&gt; was rounded (digits beyond the context precision were thrown away) and that the result is inexact (some of the discarded digits were non-zero).</source>
          <target state="translated">&lt;em&gt;플래그&lt;/em&gt; 항목의 합리적인 근사 것을 보여준다 &lt;code&gt;Pi&lt;/code&gt; 반올림 (컨텍스트 정밀도 이후 자리 폐기 하였다), 그 결과가 정확하지 않은 것을 (폐기 된 숫자 중 일부는 비 - 제로였다).</target>
        </trans-unit>
        <trans-unit id="6d6f6e39e403984a4847eaa33b4050de83b8f060" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fmt&lt;/em&gt; argument specifies the format of the plist file and can be one of the following values:</source>
          <target state="translated">&lt;em&gt;FMT의&lt;/em&gt; 인수는 PLIST 파일의 형식을 지정하고 다음 값 중 하나 일 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="082a80c3e67542d38e417ef51374d4c86db647c6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fmt&lt;/em&gt; is the format of the file and the following values are valid:</source>
          <target state="translated">&lt;em&gt;FMT는&lt;/em&gt; 파일의 형식이며 다음 값이 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="734f781d1046d3f0c2a738be36757146bb995a3f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; argument specifies the container format that should be used. The default is &lt;code&gt;FORMAT_AUTO&lt;/code&gt;, which can decompress both &lt;code&gt;.xz&lt;/code&gt; and &lt;code&gt;.lzma&lt;/code&gt; files. Other possible values are &lt;code&gt;FORMAT_XZ&lt;/code&gt;, &lt;code&gt;FORMAT_ALONE&lt;/code&gt;, and &lt;code&gt;FORMAT_RAW&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;형식&lt;/em&gt; 인수를 사용해야 컨테이너 형식을 지정합니다. 기본값은 &lt;code&gt;FORMAT_AUTO&lt;/code&gt; 이며 &lt;code&gt;.xz&lt;/code&gt; 및 &lt;code&gt;.lzma&lt;/code&gt; 파일을 모두 압축 해제 할 수 있습니다. 다른 가능한 값은 &lt;code&gt;FORMAT_XZ&lt;/code&gt; , &lt;code&gt;FORMAT_ALONE&lt;/code&gt; 및 &lt;code&gt;FORMAT_RAW&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8d0e2b25e206ba418847ddd00bd26fd5a6a4f7db" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; argument specifies what container format should be used. Possible values are:</source>
          <target state="translated">&lt;em&gt;포맷&lt;/em&gt; 어떤 컨테이너 형식 인수 지정을 사용해야합니다. 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04f2de35ac0704ac281d73b5042b2f29f702dc28" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format&lt;/em&gt; parameter uses the same directives as those used by &lt;a href=&quot;#time.strftime&quot;&gt;&lt;code&gt;strftime()&lt;/code&gt;&lt;/a&gt;; it defaults to &lt;code&gt;&quot;%a %b %d %H:%M:%S %Y&quot;&lt;/code&gt; which matches the formatting returned by &lt;a href=&quot;#time.ctime&quot;&gt;&lt;code&gt;ctime()&lt;/code&gt;&lt;/a&gt;. If &lt;em&gt;string&lt;/em&gt; cannot be parsed according to &lt;em&gt;format&lt;/em&gt;, or if it has excess data after parsing, &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised. The default values used to fill in any missing data when more accurate values cannot be inferred are &lt;code&gt;(1900, 1, 1, 0, 0, 0, 0, 1, -1)&lt;/code&gt;. Both &lt;em&gt;string&lt;/em&gt; and &lt;em&gt;format&lt;/em&gt; must be strings.</source>
          <target state="translated">&lt;em&gt;포맷&lt;/em&gt; 파라미터에 의해 사용되는 것과 같은 사용 지시문 &lt;a href=&quot;#time.strftime&quot;&gt; &lt;code&gt;strftime()&lt;/code&gt; &lt;/a&gt; ; 기본값은 &lt;code&gt;&quot;%a %b %d %H:%M:%S %Y&quot;&lt;/code&gt; 이며 &lt;a href=&quot;#time.ctime&quot;&gt; &lt;code&gt;ctime()&lt;/code&gt; &lt;/a&gt; 반환 한 형식과 일치합니다 . 경우 &lt;em&gt;문자열&lt;/em&gt; 에 따라 구문 분석 할 수없는 &lt;em&gt;형식&lt;/em&gt; 은 구문 분석 후 초과 데이터가있는 경우, 또는, &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; 를이&lt;/a&gt; 발생합니다. 더 정확한 값을 유추 할 수없는 경우 누락 된 데이터를 채우는 데 사용되는 기본값은 &lt;code&gt;(1900, 1, 1, 0, 0, 0, 0, 1, -1)&lt;/code&gt; 입니다. &lt;em&gt;문자열&lt;/em&gt; 과 &lt;em&gt;형식&lt;/em&gt; 은 모두 &lt;em&gt;문자열&lt;/em&gt; 이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4acae6593e4e526e2dd1506dcee311e81a8b65fb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;format_spec&lt;/em&gt; field contains a specification of how the value should be presented, including such details as field width, alignment, padding, decimal precision and so on. Each value type can define its own &amp;ldquo;formatting mini-language&amp;rdquo; or interpretation of the &lt;em&gt;format_spec&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;format_spec&lt;/em&gt; 필드는 값이 너무 필드 폭, 정렬, 패딩, 소수점 정밀도와 같은 세부 사항을 포함, 제시 방법의 사양이 포함되어 있습니다. 각 값 유형은 자체 &quot;포맷 미니 언어&quot;또는 &lt;em&gt;format_spec&lt;/em&gt; 해석을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d65dc8f14d94c0d358e1bb13b0be3cd77bc040c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;from_addr&lt;/em&gt; and &lt;em&gt;to_addrs&lt;/em&gt; parameters are used to construct the message envelope used by the transport agents. &lt;code&gt;sendmail&lt;/code&gt; does not modify the message headers in any way.</source>
          <target state="translated">&lt;em&gt;from_addr&lt;/em&gt; 및 &lt;em&gt;to_addrs&lt;/em&gt; 파라미터 전송 에이전트에 의해 사용되는 메시지 엔벨로프를 구성하는 데 사용된다. &lt;code&gt;sendmail&lt;/code&gt; 은 어떤 방식 으로든 메시지 헤더를 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f0efc2987cba5877b55bc8427e0a05d7b5359a2" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fullname&lt;/em&gt; argument is a fully resolved name of the module the loader is to handle. The &lt;em&gt;path&lt;/em&gt; argument is the path to the file for the module.</source>
          <target state="translated">&lt;em&gt;전체 이름의&lt;/em&gt; 인수는 로더가 처리 할 수있는 모듈의 완전히 확인 된 이름입니다. &lt;em&gt;경로&lt;/em&gt; 인수는 모듈 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="e3b5b1e7f6306fdfed32d8aa3e48723c730e25bb" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;fullname&lt;/em&gt; argument specifies the name of the module the loader is to support. The &lt;em&gt;path&lt;/em&gt; argument is the path to the extension module&amp;rsquo;s file.</source>
          <target state="translated">&lt;em&gt;전체 이름의&lt;/em&gt; 인수는 로더가 지원하는 모듈의 이름을 지정합니다. &lt;em&gt;경로&lt;/em&gt; 인수는 확장 모듈의 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="945b0cd999a4b800654797e3d0ae5eddc4b8534c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;handler&lt;/em&gt; is called with two arguments: the signal number and the current stack frame (&lt;code&gt;None&lt;/code&gt; or a frame object; for a description of frame objects, see the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame-objects&quot;&gt;description in the type hierarchy&lt;/a&gt; or see the attribute descriptions in the &lt;a href=&quot;inspect#module-inspect&quot;&gt;&lt;code&gt;inspect&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">&lt;em&gt;핸들러&lt;/em&gt; 개의 인자로 호출 상기 신호 번호와 현재 스택 프레임 ( &lt;code&gt;None&lt;/code&gt; 또는 프레임 객체, 프레임 객체에 대한 설명 참조 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#frame-objects&quot;&gt;타입 계층 구조에서 설명&lt;/a&gt; 하거나 안으로 특성 설명을 참조 &lt;a href=&quot;inspect#module-inspect&quot;&gt; &lt;code&gt;inspect&lt;/code&gt; &lt;/a&gt; 모듈).</target>
        </trans-unit>
        <trans-unit id="5c0d1f32a3c5ced96c19803c4ef9d22ef4513b71" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;headers&lt;/em&gt; argument should be a mapping of extra HTTP headers to send with the request.</source>
          <target state="translated">&lt;em&gt;헤더&lt;/em&gt; 인수는 요청과 함께 보낼 수있는 별도의 HTTP 헤더의 매핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a6eea28dbdb86941e4e47c17df323a2b65db50f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;host&lt;/em&gt; parameter can be set to several types which determine where the server would be listening:</source>
          <target state="translated">&lt;em&gt;호스트&lt;/em&gt; 매개 변수는 서버가 수신 될 위치를 결정하는 여러 종류로 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3567013f4ba803cbc03a19e951935ba9875d379e" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;input&lt;/em&gt; argument is passed to &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt;&lt;code&gt;Popen.communicate()&lt;/code&gt;&lt;/a&gt; and thus to the subprocess&amp;rsquo;s stdin. If used it must be a byte sequence, or a string if &lt;em&gt;encoding&lt;/em&gt; or &lt;em&gt;errors&lt;/em&gt; is specified or &lt;em&gt;text&lt;/em&gt; is true. When used, the internal &lt;a href=&quot;#subprocess.Popen&quot;&gt;&lt;code&gt;Popen&lt;/code&gt;&lt;/a&gt; object is automatically created with &lt;code&gt;stdin=PIPE&lt;/code&gt;, and the &lt;em&gt;stdin&lt;/em&gt; argument may not be used as well.</source>
          <target state="translated">&lt;em&gt;입력&lt;/em&gt; 인수로 전달된다 &lt;a href=&quot;#subprocess.Popen.communicate&quot;&gt; &lt;code&gt;Popen.communicate()&lt;/code&gt; &lt;/a&gt; 따라서 서브 프로세스의 표준 입력. 사용되는 경우 바이트 시퀀스이거나 &lt;em&gt;인코딩&lt;/em&gt; 또는 &lt;em&gt;오류&lt;/em&gt; 가 지정되거나 &lt;em&gt;텍스트&lt;/em&gt; 가 true 인 경우 문자열이어야 합니다. 사용되는 경우, 내부 &lt;a href=&quot;#subprocess.Popen&quot;&gt; &lt;code&gt;Popen&lt;/code&gt; &lt;/a&gt; 목적은 자동으로 생성되는 &lt;code&gt;stdin=PIPE&lt;/code&gt; 및 &lt;em&gt;표준 입력의&lt;/em&gt; 인수가 아니라 이용 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="309add7406369c9e13cbbe07f0abac084c4aeac9" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;interpreter&lt;/em&gt; argument specifies the name of the Python interpreter with which the archive will be executed. It is written as a &amp;ldquo;shebang&amp;rdquo; line at the start of the archive. On POSIX, this will be interpreted by the OS, and on Windows it will be handled by the Python launcher. Omitting the &lt;em&gt;interpreter&lt;/em&gt; results in no shebang line being written. If an interpreter is specified, and the target is a filename, the executable bit of the target file will be set.</source>
          <target state="translated">&lt;em&gt;통역&lt;/em&gt; 인수는 아카이브가 실행됩니다있는 파이썬 인터프리터의 이름을 지정합니다. 아카이브 시작시 &quot;shebang&quot;행으로 작성됩니다. POSIX에서는 OS가이를 해석하고 Windows에서는 Python 런처가이를 처리합니다. &lt;em&gt;인터프리터를&lt;/em&gt; 생략하면 Shebang 줄이 작성되지 않습니다. 인터프리터가 지정되고 대상이 파일 이름 인 경우 대상 파일의 실행 가능 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bc413367ebb6cea357fcef201d058874ef7a2cd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;keyencoding&lt;/em&gt; parameter is the encoding used to encode keys before they are used with the underlying dict.</source>
          <target state="translated">&lt;em&gt;keyencoding&lt;/em&gt; 파라미터들이 기본 딕셔너리로 사용되기 전에 인코딩 키로 사용 된 인코딩이다.</target>
        </trans-unit>
        <trans-unit id="3e344c69f7b03d28b5ecf255f27851cd1ec1b42a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;limit&lt;/em&gt; argument is passed to &lt;a href=&quot;#asyncio.Task.get_stack&quot;&gt;&lt;code&gt;get_stack()&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">&lt;em&gt;제한&lt;/em&gt; 인수로 전달됩니다 &lt;a href=&quot;#asyncio.Task.get_stack&quot;&gt; &lt;code&gt;get_stack()&lt;/code&gt; &lt;/a&gt; 직접.</target>
        </trans-unit>
        <trans-unit id="03da4d795bd5e7eacf03e419e5465b47a81aab14" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;limit&lt;/em&gt; argument sets the buffer limit for &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; wrappers for &lt;code&gt;Process.stdout&lt;/code&gt; and &lt;code&gt;Process.stderr&lt;/code&gt; (if &lt;a href=&quot;subprocess#subprocess.PIPE&quot;&gt;&lt;code&gt;subprocess.PIPE&lt;/code&gt;&lt;/a&gt; is passed to &lt;em&gt;stdout&lt;/em&gt; and &lt;em&gt;stderr&lt;/em&gt; arguments).</source>
          <target state="translated">&lt;em&gt;제한&lt;/em&gt; 인자에 대한 버퍼 제한 세트 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 래퍼 &lt;code&gt;Process.stdout&lt;/code&gt; 및 &lt;code&gt;Process.stderr&lt;/code&gt; 를 IF ( &lt;a href=&quot;subprocess#subprocess.PIPE&quot;&gt; &lt;code&gt;subprocess.PIPE&lt;/code&gt; 이&lt;/a&gt; 에 전달되는 &lt;em&gt;표준 출력&lt;/em&gt; 과 &lt;em&gt;표준 에러&lt;/em&gt; 인자).</target>
        </trans-unit>
        <trans-unit id="129e7c784b9b3ee51082a82585d3133b4d781544" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loader_details&lt;/em&gt; argument is a variable number of 2-item tuples each containing a loader and a sequence of file suffixes the loader recognizes. The loaders are expected to be callables which accept two arguments of the module&amp;rsquo;s name and the path to the file found.</source>
          <target state="translated">&lt;em&gt;loader_details의&lt;/em&gt; 인수는 2 항목 가변 개수는 로더 파일의 시퀀스를 포함하는 각각의 로더 인식 접미사 튜플이다. 로더는 호출 할 수 있어야하며 모듈 이름의 두 인수와 찾은 파일의 경로를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="c4075eb186f5064895077ca769fb8de129e00f4c" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loop&lt;/em&gt; argument is optional and can always be determined automatically when this function is awaited from a coroutine.</source>
          <target state="translated">&lt;em&gt;루프&lt;/em&gt; 인수는 선택 사항이며,이 기능이 코 루틴에서 기다리고 때 항상 자동으로 결정될 수있다.</target>
        </trans-unit>
        <trans-unit id="73a8039d019649d2ee4bb760661a133481fe2941" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;loop&lt;/em&gt; argument is optional and can always be determined automatically when this method is awaited from a coroutine.</source>
          <target state="translated">&lt;em&gt;루프&lt;/em&gt; 인수는 선택 사항이며이 방법은 코 루틴에서 기다리고 때 항상 자동으로 결정될 수있다.</target>
        </trans-unit>
        <trans-unit id="c152814f2f36109416e46a812106fb4bb59ade66" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;main&lt;/em&gt; argument specifies the name of a callable which will be used as the main program for the archive. It can only be specified if the source is a directory, and the source does not already contain a &lt;code&gt;__main__.py&lt;/code&gt; file. The &lt;em&gt;main&lt;/em&gt; argument should take the form &amp;ldquo;pkg.module:callable&amp;rdquo; and the archive will be run by importing &amp;ldquo;pkg.module&amp;rdquo; and executing the given callable with no arguments. It is an error to omit &lt;em&gt;main&lt;/em&gt; if the source is a directory and does not contain a &lt;code&gt;__main__.py&lt;/code&gt; file, as otherwise the resulting archive would not be executable.</source>
          <target state="translated">&lt;em&gt;주요&lt;/em&gt; 인수는 아카이브의 메인 프로그램으로 사용됩니다 호출의 이름을 지정합니다. 소스가 디렉토리이고 소스에 &lt;code&gt;__main__.py&lt;/code&gt; 파일 이없는 경우에만 지정할 수 있습니다 . &lt;em&gt;주&lt;/em&gt; &quot;: 호출 pkg.module&quot;아카이브는 인수없이 주어진 호출을 &quot;pkg.module을&quot;가져 오기 및 실행하여 실행됩니다 인수 형태를 취한다. 소스가 디렉토리이고 &lt;code&gt;__main__.py&lt;/code&gt; 파일을 포함하지 않는 경우 &lt;em&gt;main&lt;/em&gt; 을 생략하면 오류가 발생합니다. 그렇지 않으면 결과 아카이브가 실행 가능하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a792d7ef7a7c58a9f18c32feedd94d015e4b0544" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;map&lt;/em&gt; parameter is a dictionary whose items are the channels to watch. As channels are closed they are deleted from their map. If &lt;em&gt;map&lt;/em&gt; is omitted, a global map is used. Channels (instances of &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;asyncore.dispatcher&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt;&lt;code&gt;asynchat.async_chat&lt;/code&gt;&lt;/a&gt; and subclasses thereof) can freely be mixed in the map.</source>
          <target state="translated">&lt;em&gt;맵&lt;/em&gt; 매개 변수는 항목을 볼 수있는 채널이 사전이다. 채널이 닫히면지도에서 삭제됩니다. 경우 &lt;em&gt;지도가&lt;/em&gt; 생략, 글로벌 맵이 사용된다. 채널 ( &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;asyncore.dispatcher&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asynchat#asynchat.async_chat&quot;&gt; &lt;code&gt;asynchat.async_chat&lt;/code&gt; &lt;/a&gt; 및 해당 서브 클래스의 인스턴스 )을 맵에서 자유롭게 혼합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de3df102b5a039ab9487bee97ffa75b5ffdf2c3" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;maxlevels&lt;/em&gt; parameter is used to limit the depth of the recursion; it defaults to &lt;code&gt;10&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;maxlevels의&lt;/em&gt; 파라미터는 재귀의 깊이를 제한하는데 사용된다; 기본값은 &lt;code&gt;10&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb182bf741586c60f69a2721098eca2297c8d83d" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;memLevel&lt;/em&gt; argument controls the amount of memory used for the internal compression state. Valid values range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;9&lt;/code&gt;. Higher values use more memory, but are faster and produce smaller output.</source>
          <target state="translated">&lt;em&gt;memLevel의&lt;/em&gt; 인수는 내부의 압축 상태를 위해 사용되는 메모리의 양을 제어한다. 유효한 값의 범위 &lt;code&gt;1&lt;/code&gt; 에 &lt;code&gt;9&lt;/code&gt; . 값이 클수록 더 많은 메모리를 사용하지만 더 빠르고 더 작은 출력을 생성합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
