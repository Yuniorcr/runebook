<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="python">
    <body>
      <group id="python">
        <trans-unit id="b301e64f6be02c979b39c0a7f2f8742151baec4c" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. If this is a top-level import, &lt;em&gt;path&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;. Otherwise, this is a search for a subpackage or module and &lt;em&gt;path&lt;/em&gt; will be the value of &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt; from the parent package. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;MetaPathFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;스펙&lt;/a&gt; 을 찾는 추상적 인 방법입니다 . 이것이 최상위 레벨 임포트 인 경우 &lt;em&gt;path&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다. 그렇지 않으면 하위 패키지 또는 모듈을 검색하며 &lt;em&gt;경로&lt;/em&gt; 는 상위 패키지 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; &lt;/a&gt; 값입니다 . 스펙을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다. 전달되면 &lt;code&gt;target&lt;/code&gt; 은 파인더가 어떤 스펙을 반환할지에 대해 더 잘 추측 할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;MetaPathFinders&lt;/code&gt; 를 구현하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd63589c5c5bc876ea90a7b05def4d9308abd0ce" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. The finder will search for the module only within the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry&quot;&gt;path entry&lt;/a&gt; to which it is assigned. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;PathEntryFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-module-spec&quot;&gt;스펙&lt;/a&gt; 을 찾는 추상적 인 방법입니다 . 파인더 는 지정된 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-path-entry&quot;&gt;경로 항목&lt;/a&gt; 내에서만 모듈을 검색합니다 . 스펙을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 리턴됩니다. 전달 될 때 &lt;code&gt;target&lt;/code&gt; 은 파인더가 반환 할 스펙에 대해보다 잘 추측 할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;PathEntryFinders&lt;/code&gt; 구현에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ec7fa64597ec4d9362aa636f6c3e9342c5c3475" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; for the specified module. Originally specified in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 302&lt;/strong&gt;&lt;/a&gt;, this method was meant for use in &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt; and in the path-based import subsystem.</source>
          <target state="translated">지정된 모듈 의 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 를 찾는 추상 메서드입니다 . 원래 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0302&quot; id=&quot;index-12&quot;&gt;&lt;strong&gt;PEP 302에&lt;/strong&gt;&lt;/a&gt; 지정된 이 메서드는 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 및 경로 기반 가져 오기 하위 시스템에서 사용하기위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="a078fcb028abf664294af6a6107d24c54ea703c8" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. If this is a top-level import, &lt;em&gt;path&lt;/em&gt; will be &lt;code&gt;None&lt;/code&gt;. Otherwise, this is a search for a subpackage or module and &lt;em&gt;path&lt;/em&gt; will be the value of &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt; from the parent package. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;MetaPathFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈에 대한 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module-spec&quot;&gt;사양&lt;/a&gt; 을 찾는 추상 메서드입니다 . 최상위 수준 가져 오기 인 경우 &lt;em&gt;경로&lt;/em&gt; 는 &lt;code&gt;None&lt;/code&gt; 이 됩니다. 그렇지 않으면 하위 패키지 또는 모듈을 검색하고 &lt;em&gt;경로&lt;/em&gt; 는 상위 패키지 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; &lt;/a&gt; 값이 됩니다. 사양을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 전달되면 &lt;code&gt;target&lt;/code&gt; 은 파인더가 반환 할 사양에 대해 더 많은 정보를 제공하는 데 사용할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;MetaPathFinders&lt;/code&gt; 구현에 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38df08fcaf14d4d9addb424c44c752bc5b9d7929" translate="yes" xml:space="preserve">
          <source>An abstract method for finding a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module-spec&quot;&gt;spec&lt;/a&gt; for the specified module. The finder will search for the module only within the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-entry&quot;&gt;path entry&lt;/a&gt; to which it is assigned. If a spec cannot be found, &lt;code&gt;None&lt;/code&gt; is returned. When passed in, &lt;code&gt;target&lt;/code&gt; is a module object that the finder may use to make a more educated guess about what spec to return. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt;&lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt;&lt;/a&gt; may be useful for implementing concrete &lt;code&gt;PathEntryFinders&lt;/code&gt;.</source>
          <target state="translated">지정된 모듈에 대한 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-module-spec&quot;&gt;사양&lt;/a&gt; 을 찾는 추상 메서드입니다 . 파인더 는 할당 된 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-path-entry&quot;&gt;경로 항목&lt;/a&gt; 내에서만 모듈을 검색합니다 . 사양을 찾을 수 없으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 전달되면 &lt;code&gt;target&lt;/code&gt; 은 파인더가 반환 할 사양에 대해 더 많은 정보를 제공하는 데 사용할 수있는 모듈 객체입니다. &lt;a href=&quot;#importlib.util.spec_from_loader&quot;&gt; &lt;code&gt;importlib.util.spec_from_loader()&lt;/code&gt; &lt;/a&gt; 는 구체적인 &lt;code&gt;PathEntryFinders&lt;/code&gt; 를 구현하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b518cc20074a6e012522371b44d4863fba9c6708" translate="yes" xml:space="preserve">
          <source>An abstract method that executes the module in its own namespace when a module is imported or reloaded. The module should already be initialized when &lt;code&gt;exec_module()&lt;/code&gt; is called. When this method exists, &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt;&lt;code&gt;create_module()&lt;/code&gt;&lt;/a&gt; must be defined.</source>
          <target state="translated">모듈을 가져 오거나 다시로드 할 때 자체 네임 스페이스에서 모듈을 실행하는 추상 메서드입니다. &lt;code&gt;exec_module()&lt;/code&gt; 을 호출 할 때 모듈이 이미 초기화되어 있어야합니다 . 이 메소드가 존재하면 &lt;a href=&quot;#importlib.abc.Loader.create_module&quot;&gt; &lt;code&gt;create_module()&lt;/code&gt; &lt;/a&gt; 을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6bf9688b7b004247ae61425719c8753e917df0c" translate="yes" xml:space="preserve">
          <source>An abstract method that is to return the value of &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; for the specified module. If no path is available, &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 모듈에 대한 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; &lt;/a&gt; 값을 반환하는 추상 메서드입니다 . 사용 가능한 경로가 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20672959b0be97ef0818210d53eef4fcf8b86803" translate="yes" xml:space="preserve">
          <source>An abstract method that is to return the value of &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; for the specified module. If no path is available, &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">지정된 모듈에 대한 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; &lt;/a&gt; 의 값을 반환하는 추상 메서드입니다 . 사용 가능한 경로가 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9546a7a2c25822b3aefc76fd55131bcac817f789" translate="yes" xml:space="preserve">
          <source>An abstract method to return a true value if the module is a package, a false value otherwise. &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised if the &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; cannot find the module.</source>
          <target state="translated">모듈이 패키지이면 true 값을 반환하고 그렇지 않으면 false 값을 반환하는 추상 메서드입니다. &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 가 모듈을 찾을 수 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="edbcbbce2983a4d0aa1b211eba4bdaace496fbb5" translate="yes" xml:space="preserve">
          <source>An abstract method to return a true value if the module is a package, a false value otherwise. &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; is raised if the &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;loader&lt;/a&gt; cannot find the module.</source>
          <target state="translated">모듈이 패키지이면 true 값을 반환하고 그렇지 않으면 false 값을 반환하는 추상 메서드입니다. &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-loader&quot;&gt;로더&lt;/a&gt; 가 모듈을 찾을 수 없으면 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="800c0095cbad1a18da2d314befc33c5c39978794" translate="yes" xml:space="preserve">
          <source>An abstract method to return the bytes for the data located at &lt;em&gt;path&lt;/em&gt;. Loaders that have a file-like storage back-end that allows storing arbitrary data can implement this abstract method to give direct access to the data stored. &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is to be raised if the &lt;em&gt;path&lt;/em&gt; cannot be found. The &lt;em&gt;path&lt;/em&gt; is expected to be constructed using a module&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; attribute or an item from a package&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 에 위치한 데이터의 바이트를 반환하는 추상 메소드 입니다. 임의의 데이터를 저장할 수있는 파일과 같은 스토리지 백엔드가있는 로더는이 추상 메소드를 구현하여 저장된 데이터에 직접 액세스 할 수 있습니다. &lt;em&gt;경로&lt;/em&gt; 를 찾을 수 없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;em&gt;경로는&lt;/em&gt; 모듈의 사용하여 구성 될 것으로 예상된다 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; 의&lt;/a&gt; 속성 또는 패키지의에서 항목 &lt;a href=&quot;https://docs.python.org/3.8/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; 을&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="09482733ccd9350dc7770f132c5a1e5936dc7a07" translate="yes" xml:space="preserve">
          <source>An abstract method to return the bytes for the data located at &lt;em&gt;path&lt;/em&gt;. Loaders that have a file-like storage back-end that allows storing arbitrary data can implement this abstract method to give direct access to the data stored. &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is to be raised if the &lt;em&gt;path&lt;/em&gt; cannot be found. The &lt;em&gt;path&lt;/em&gt; is expected to be constructed using a module&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__file__&quot;&gt;&lt;code&gt;__file__&lt;/code&gt;&lt;/a&gt; attribute or an item from a package&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__path__&quot;&gt;&lt;code&gt;__path__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;path&lt;/em&gt; 에있는 데이터의 바이트를 반환하는 추상 메서드 입니다. 임의의 데이터를 저장할 수있는 파일과 유사한 스토리지 백엔드가있는 로더는이 추상 방법을 구현하여 저장된 데이터에 직접 액세스 할 수 있습니다. &lt;em&gt;경로&lt;/em&gt; 를 찾을 수없는 경우 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . &lt;em&gt;경로는&lt;/em&gt; 모듈의 사용하여 구성 될 것으로 예상된다 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__file__&quot;&gt; &lt;code&gt;__file__&lt;/code&gt; 의&lt;/a&gt; 속성 또는 패키지의에서 항목 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#__path__&quot;&gt; &lt;code&gt;__path__&lt;/code&gt; 을&lt;/a&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="563d61fc457a3bfb950c5833afc59f047a9c4836" translate="yes" xml:space="preserve">
          <source>An abstract method to return the source of a module. It is returned as a text string using &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt;, translating all recognized line separators into &lt;code&gt;'\n'&lt;/code&gt; characters. Returns &lt;code&gt;None&lt;/code&gt; if no source is available (e.g. a built-in module). Raises &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; if the loader cannot find the module specified.</source>
          <target state="translated">모듈의 소스를 돌려주는 추상 메소드. 인식되는 모든 줄 구분 기호를 &lt;code&gt;'\n'&lt;/code&gt; 문자 로 변환 하여 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-universal-newlines&quot;&gt;범용&lt;/a&gt; 줄 바꾸기를 사용하여 텍스트 문자열로 반환됩니다 . 사용 가능한 소스가없는 경우 (예 : 내장 모듈) &lt;code&gt;None&lt;/code&gt; 반환 합니다. 발생시킵니다 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를이&lt;/a&gt; 로더가 지정된 모듈을 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6b19fc2d056eee4a7eec499bcdca3418e2a9c84c" translate="yes" xml:space="preserve">
          <source>An abstract method to return the source of a module. It is returned as a text string using &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;universal newlines&lt;/a&gt;, translating all recognized line separators into &lt;code&gt;'\n'&lt;/code&gt; characters. Returns &lt;code&gt;None&lt;/code&gt; if no source is available (e.g. a built-in module). Raises &lt;a href=&quot;exceptions#ImportError&quot;&gt;&lt;code&gt;ImportError&lt;/code&gt;&lt;/a&gt; if the loader cannot find the module specified.</source>
          <target state="translated">모듈의 소스를 반환하는 추상 메서드입니다. 인식 된 모든 줄 구분 기호를 &lt;code&gt;'\n'&lt;/code&gt; 문자 로 변환 하는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-universal-newlines&quot;&gt;범용 개행 문자를&lt;/a&gt; 사용하여 텍스트 문자열로 반환됩니다 . 사용할 수있는 소스가 없으면 &lt;code&gt;None&lt;/code&gt; 을 반환 합니다 (예 : 내장 모듈). 발생시킵니다 &lt;a href=&quot;exceptions#ImportError&quot;&gt; &lt;code&gt;ImportError&lt;/code&gt; 를이&lt;/a&gt; 로더가 지정된 모듈을 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6dc181f14f2a6fd494fcdfa6748662a11c18b1fd" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree can be generated by passing &lt;a href=&quot;#ast.PyCF_ONLY_AST&quot;&gt;&lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt;&lt;/a&gt; as a flag to the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; built-in function, or using the &lt;a href=&quot;#ast.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; helper provided in this module. The result will be a tree of objects whose classes all inherit from &lt;a href=&quot;#ast.AST&quot;&gt;&lt;code&gt;ast.AST&lt;/code&gt;&lt;/a&gt;. An abstract syntax tree can be compiled into a Python code object using the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">추상 구문 트리는 &lt;a href=&quot;#ast.PyCF_ONLY_AST&quot;&gt; &lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 내장 함수에 플래그로 전달 하거나이 모듈에서 제공 하는 &lt;a href=&quot;#ast.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 생성 할 수 있습니다 . 결과는 모든 클래스가 &lt;a href=&quot;#ast.AST&quot;&gt; &lt;code&gt;ast.AST&lt;/code&gt; &lt;/a&gt; 에서 상속되는 객체 트리가됩니다 . 추상 구문 트리는 내장 된 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 Python 코드 객체로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9ce1167dff3e80e3af3cc98084356e72a0bd3a36" translate="yes" xml:space="preserve">
          <source>An abstract syntax tree can be generated by passing &lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt; as a flag to the &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; built-in function, or using the &lt;a href=&quot;#ast.parse&quot;&gt;&lt;code&gt;parse()&lt;/code&gt;&lt;/a&gt; helper provided in this module. The result will be a tree of objects whose classes all inherit from &lt;a href=&quot;#ast.AST&quot;&gt;&lt;code&gt;ast.AST&lt;/code&gt;&lt;/a&gt;. An abstract syntax tree can be compiled into a Python code object using the built-in &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;code&gt;ast.PyCF_ONLY_AST&lt;/code&gt; 를 플래그로 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 내장 함수 에 전달 하거나이 모듈에 제공된 &lt;a href=&quot;#ast.parse&quot;&gt; &lt;code&gt;parse()&lt;/code&gt; &lt;/a&gt; 도우미를 사용하여 추상 구문 트리를 생성 할 수 있습니다 . 결과는 클래스가 모두 &lt;a href=&quot;#ast.AST&quot;&gt; &lt;code&gt;ast.AST&lt;/code&gt; &lt;/a&gt; 에서 상속되는 객체 트리가됩니다 . 내장 된 &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 추상 구문 트리를 Python 코드 객체로 컴파일 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70da3ef21c99fc01e1c391e4ec0a45bb54025f8a" translate="yes" xml:space="preserve">
          <source>An abstraction of a pipeline.</source>
          <target state="translated">파이프 라인의 추상화.</target>
        </trans-unit>
        <trans-unit id="2b4487c478caae94a1d2a055c39dc744680ef17b" translate="yes" xml:space="preserve">
          <source>An abstraction to represent a connection between a parent and its child OS process.</source>
          <target state="translated">부모와 자식 OS 프로세스 간의 연결을 나타내는 추상화입니다.</target>
        </trans-unit>
        <trans-unit id="70554b33f749f867144e33b7010322e8a2d9c2f6" translate="yes" xml:space="preserve">
          <source>An additional example of normalization:</source>
          <target state="translated">정규화의 추가 예 :</target>
        </trans-unit>
        <trans-unit id="1f8b93a1b318ef3b489264436cd2920634f37e5c" translate="yes" xml:space="preserve">
          <source>An additional section describes the exceptions defined for working with the DOM in Python.</source>
          <target state="translated">추가 섹션에서는 Python에서 DOM 작업을 위해 정의 된 예외에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7de5be9d95857a8f7fae738465f4f7a4ecbfe0bd" translate="yes" xml:space="preserve">
          <source>An additional utility function is provided to convert a file&amp;rsquo;s mode in a human readable string:</source>
          <target state="translated">사람이 읽을 수있는 문자열로 파일 모드를 변환하기위한 추가 유틸리티 기능이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b4bc718c3660ae312ee29fc3f760532b2ef990dd" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#ssl.SSLCertVerificationError&quot;&gt;&lt;code&gt;SSLCertVerificationError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#ssl.SSLCertVerificationError&quot;&gt; &lt;code&gt;SSLCertVerificationError&lt;/code&gt; &lt;/a&gt; 의 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="d8d058f0ff4ac1d3e35f124836eb7543d9d30422" translate="yes" xml:space="preserve">
          <source>An alias for &lt;a href=&quot;#tkinter.ttk.Treeview.move&quot;&gt;&lt;code&gt;Treeview.move()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#tkinter.ttk.Treeview.move&quot;&gt; &lt;code&gt;Treeview.move()&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="4f34bb1fd3121bf24f28736c112a6ea7ecb860b5" translate="yes" xml:space="preserve">
          <source>An alias for the built-in &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; exception.</source>
          <target state="translated">내장 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 예외 의 별명 .</target>
        </trans-unit>
        <trans-unit id="ee952a3e338de8476144642c2ed1be940175b262" translate="yes" xml:space="preserve">
          <source>An alias to &lt;a href=&quot;collections.abc#collections.abc.Hashable&quot;&gt;&lt;code&gt;collections.abc.Hashable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.Hashable&quot;&gt; &lt;code&gt;collections.abc.Hashable&lt;/code&gt; &lt;/a&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="72cf7f2af19bdbb20c360e706340e6ea11885d97" translate="yes" xml:space="preserve">
          <source>An alias to &lt;a href=&quot;collections.abc#collections.abc.Sized&quot;&gt;&lt;code&gt;collections.abc.Sized&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;collections.abc#collections.abc.Sized&quot;&gt; &lt;code&gt;collections.abc.Sized&lt;/code&gt; &lt;/a&gt; 의 별명</target>
        </trans-unit>
        <trans-unit id="a6540aa0e6b78ff35eaf43cee039535142533b79" translate="yes" xml:space="preserve">
          <source>An alternate constructor that bypasses the constructor&amp;rsquo;s cache. It is identical to the primary constructor, but returns a new object on each call. This is most likely to be useful for testing or demonstration purposes, but it can also be used to create a system with a different cache invalidation strategy.</source>
          <target state="translated">생성자의 캐시를 우회하는 대체 생성자입니다. 기본 생성자와 동일하지만 호출 할 때마다 새 개체를 반환합니다. 이는 테스트 또는 데모 목적으로 유용 할 가능성이 높지만 다른 캐시 무효화 전략으로 시스템을 만드는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a63391b1faab340a2bb4934be82d08de2b51040f" translate="yes" xml:space="preserve">
          <source>An alternative character used by the operating system to separate pathname components, or &lt;code&gt;None&lt;/code&gt; if only one separator character exists. This is set to &lt;code&gt;'/'&lt;/code&gt; on Windows systems where &lt;code&gt;sep&lt;/code&gt; is a backslash. Also available via &lt;a href=&quot;os.path#module-os.path&quot;&gt;&lt;code&gt;os.path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경로 이름 구성 요소를 분리하기 위해 운영 체제에서 사용하는 대체 문자이거나 하나의 분리 문자 만있는 경우 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;sep&lt;/code&gt; 가 백 슬래시 인 Windows 시스템에서는 &lt;code&gt;'/'&lt;/code&gt; 로 설정됩니다 . &lt;a href=&quot;os.path#module-os.path&quot;&gt; &lt;code&gt;os.path&lt;/code&gt; &lt;/a&gt; 를 통해서도 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="a3d5b628a54d39bf8ee6093f8e0d37a9d4cee60c" translate="yes" xml:space="preserve">
          <source>An alternative dictionary type can be used for example to sort sections and options on write-back.</source>
          <target state="translated">대체 사전 유형을 사용하여 예를 들어 다시 쓸 때 섹션과 옵션을 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d850059763c1f7e51f2d1d11cf0427ad5eded88" translate="yes" xml:space="preserve">
          <source>An alternative event loop policy that uses the &lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; event loop implementation.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 이벤트 루프 구현 을 사용하는 대체 이벤트 루프 정책 .</target>
        </trans-unit>
        <trans-unit id="84083d9dc2f2455c7f8ae18733c112f9f4922f99" translate="yes" xml:space="preserve">
          <source>An alternative event loop policy that uses the &lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; event loop implementation.</source>
          <target state="translated">&lt;a href=&quot;asyncio-eventloop#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 이벤트 루프 구현 을 사용하는 대체 이벤트 루프 정책 .</target>
        </trans-unit>
        <trans-unit id="8fe9d34c1b43e8d3bc59379cabc74d88762dfb06" translate="yes" xml:space="preserve">
          <source>An alternative handler for interpolation which implements a more advanced syntax, used for instance in &lt;code&gt;zc.buildout&lt;/code&gt;. Extended interpolation is using &lt;code&gt;${section:option}&lt;/code&gt; to denote a value from a foreign section. Interpolation can span multiple levels. For convenience, if the &lt;code&gt;section:&lt;/code&gt; part is omitted, interpolation defaults to the current section (and possibly the default values from the special section).</source>
          <target state="translated">&lt;code&gt;zc.buildout&lt;/code&gt; 에서 사용되는 고급 구문을 구현하는 보간 용 대체 처리기입니다 . 확장 보간은 &lt;code&gt;${section:option}&lt;/code&gt; 을 사용하여 외부 섹션의 값을 나타냅니다. 보간은 여러 수준으로 확장 될 수 있습니다. 편의상 &lt;code&gt;section:&lt;/code&gt; part가 생략되면 보간은 현재 섹션 (및 가능하면 특수 섹션의 기본값)으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="558c117d3161559bd859666a91b9bb66c414c1f5" translate="yes" xml:space="preserve">
          <source>An alternative header can be specified in the &lt;em&gt;header&lt;/em&gt; argument. When the &lt;em&gt;Content-Type&lt;/em&gt; header is set a &lt;em&gt;MIME-Version&lt;/em&gt; header is also added.</source>
          <target state="translated">&lt;em&gt;헤더&lt;/em&gt; 인수 에 대체 헤더를 지정할 수 있습니다 . 경우 &lt;em&gt;컨텐츠 유형&lt;/em&gt; 헤더가 설정되어있는 &lt;em&gt;MIME-버전&lt;/em&gt; 헤더도 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f5ba665411f071ae5d955adbe5282d9694eae5c4" translate="yes" xml:space="preserve">
          <source>An alternative name can be specified with &lt;code&gt;metavar&lt;/code&gt;:</source>
          <target state="translated">대체 이름은 &lt;code&gt;metavar&lt;/code&gt; 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6416917ffae045c2865eba964ef88e695b8f701a" translate="yes" xml:space="preserve">
          <source>An alternative request handler class that makes use of streams (file-like objects that simplify communication by providing the standard file interface):</source>
          <target state="translated">스트림 (표준 파일 인터페이스를 제공하여 통신을 단순화하는 파일과 유사한 객체)을 사용하는 대체 요청 핸들러 클래스 :</target>
        </trans-unit>
        <trans-unit id="affd50cda4dcf68b768688e4f672192d92888ed0" translate="yes" xml:space="preserve">
          <source>An analogue of &lt;a href=&quot;threading#threading.current_thread&quot;&gt;&lt;code&gt;threading.current_thread()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;threading#threading.current_thread&quot;&gt; &lt;code&gt;threading.current_thread()&lt;/code&gt; &lt;/a&gt; 의 아날로그 .</target>
        </trans-unit>
        <trans-unit id="8e8b2aaa418b53858967709906f3a78f69197dab" translate="yes" xml:space="preserve">
          <source>An application which needs both ST and code objects can package this code into readily available functions:</source>
          <target state="translated">ST와 코드 객체를 모두 필요로하는 응용 프로그램은이 코드를 즉시 사용 가능한 기능으로 패키지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a68e4a13d841bc92021b61944ccadf166e7e79" translate="yes" xml:space="preserve">
          <source>An appropriate &lt;code&gt;Content-Type&lt;/code&gt; header should be included if the &lt;em&gt;data&lt;/em&gt; argument is present. If this header has not been provided and &lt;em&gt;data&lt;/em&gt; is not None, &lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt; will be added as a default.</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 인수가있는 경우 적절한 &lt;code&gt;Content-Type&lt;/code&gt; 헤더가 포함되어야합니다 . 이 헤더가 제공되지 않고 &lt;em&gt;데이터&lt;/em&gt; 가 없음이 아닌 경우 &lt;code&gt;Content-Type: application/x-www-form-urlencoded&lt;/code&gt; 가 기본값으로 추가됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c475a455c39ee03168c8c78b435dcd38ae70e3df" translate="yes" xml:space="preserve">
          <source>An argument for using the original mbox format rather than a variation.</source>
          <target state="translated">변형이 아닌 원래 mbox 형식을 사용하기위한 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6ec278a245be82c537401d0aff88bd1ef6e21621" translate="yes" xml:space="preserve">
          <source>An array that represents the abbreviated days of the week in the current locale.</source>
          <target state="translated">현재 로케일에서 약식 요일을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2ba535593adca4dfcb800d6a4065c1b6b73e79fa" translate="yes" xml:space="preserve">
          <source>An array that represents the abbreviated months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and &lt;code&gt;month_abbr[0]&lt;/code&gt; is the empty string.</source>
          <target state="translated">현재 로캘에서 약식 월을 나타내는 배열입니다. 이는 1 월이 1 월의 일반적인 규칙을 따르므로 길이는 13이며 &lt;code&gt;month_abbr[0]&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fcf4961a8aabb7adc6bcd479568762d6de58a7a7" translate="yes" xml:space="preserve">
          <source>An array that represents the days of the week in the current locale.</source>
          <target state="translated">현재 로케일의 요일을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f186d41c71a389deb5bc2ad8c9d947ed1464a0a8" translate="yes" xml:space="preserve">
          <source>An array that represents the months of the year in the current locale. This follows normal convention of January being month number 1, so it has a length of 13 and &lt;code&gt;month_name[0]&lt;/code&gt; is the empty string.</source>
          <target state="translated">현재 로케일에서 한 달의 월을 나타내는 배열입니다. 이것은 1 월의 월 번호 1 인 일반적인 규칙을 따르므로 길이는 13이며 &lt;code&gt;month_name[0]&lt;/code&gt; 은 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4945cd01dba97e9df97bb4a5e0472f4c79b63619" translate="yes" xml:space="preserve">
          <source>An assertion. &lt;code&gt;test&lt;/code&gt; holds the condition, such as a &lt;a href=&quot;#ast.Compare&quot;&gt;&lt;code&gt;Compare&lt;/code&gt;&lt;/a&gt; node. &lt;code&gt;msg&lt;/code&gt; holds the failure message.</source>
          <target state="translated">주장. &lt;code&gt;test&lt;/code&gt; 는 &lt;a href=&quot;#ast.Compare&quot;&gt; &lt;code&gt;Compare&lt;/code&gt; &lt;/a&gt; 노드 와 같은 조건을 보유 합니다. &lt;code&gt;msg&lt;/code&gt; 는 실패 메시지를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="b98f9befa7e21b68efee9fcdf15d47f44a0708eb" translate="yes" xml:space="preserve">
          <source>An assignment with a type annotation. &lt;code&gt;target&lt;/code&gt; is a single node and can be a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;#ast.Attribute&quot;&gt;&lt;code&gt;Attribute&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#ast.Subscript&quot;&gt;&lt;code&gt;Subscript&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;annotation&lt;/code&gt; is the annotation, such as a &lt;a href=&quot;#ast.Constant&quot;&gt;&lt;code&gt;Constant&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt; node. &lt;code&gt;value&lt;/code&gt; is a single optional node. &lt;code&gt;simple&lt;/code&gt; is a boolean integer set to True for a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt; node in &lt;code&gt;target&lt;/code&gt; that do not appear in between parenthesis and are hence pure names and not expressions.</source>
          <target state="translated">유형 주석이있는 할당. &lt;code&gt;target&lt;/code&gt; 은 단일 노드이며 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.Attribute&quot;&gt; &lt;code&gt;Attribute&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ast.Subscript&quot;&gt; &lt;code&gt;Subscript&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . &lt;code&gt;annotation&lt;/code&gt; &lt;a href=&quot;#ast.Constant&quot;&gt; &lt;code&gt;Constant&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 노드 와 같은 주석 입니다 . &lt;code&gt;value&lt;/code&gt; 은 단일 선택적 노드입니다. &lt;code&gt;simple&lt;/code&gt; 은 괄호 사이에 표시되지 않으므로 표현식이 아닌 순수한 이름 인 &lt;code&gt;target&lt;/code&gt; 의 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 노드에 대해 True로 설정된 부울 정수입니다 .</target>
        </trans-unit>
        <trans-unit id="e372d92a12b5d0790318943d944a7cbc84547329" translate="yes" xml:space="preserve">
          <source>An assignment. &lt;code&gt;targets&lt;/code&gt; is a list of nodes, and &lt;code&gt;value&lt;/code&gt; is a single node.</source>
          <target state="translated">과제. &lt;code&gt;targets&lt;/code&gt; 는 노드 목록이고 &lt;code&gt;value&lt;/code&gt; 는 단일 노드입니다.</target>
        </trans-unit>
        <trans-unit id="2f78c0d8986a31d197009b378a1891659c6d5c40" translate="yes" xml:space="preserve">
          <source>An async generator can be annotated by the generic type &lt;code&gt;AsyncGenerator[YieldType, SendType]&lt;/code&gt;. For example:</source>
          <target state="translated">비동기 생성기는 일반 유형 &lt;code&gt;AsyncGenerator[YieldType, SendType]&lt;/code&gt; 로 주석을 달 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca81f375b0f07ac473e89b02f52e35dc9a49c97b" translate="yes" xml:space="preserve">
          <source>An asynchronous version of &lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt;&lt;code&gt;MagicMock&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt;&lt;code&gt;AsyncMock&lt;/code&gt;&lt;/a&gt; object will behave so the object is recognized as an async function, and the result of a call is an awaitable.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.MagicMock&quot;&gt; &lt;code&gt;MagicMock&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 . &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt; &lt;code&gt;AsyncMock&lt;/code&gt; 의&lt;/a&gt; 목적은 비동기 함수로서 인식되어 있고, 호출의 결과가 awaitable 정도로 개체 동작한다.</target>
        </trans-unit>
        <trans-unit id="47a32ba6658f6bd3552449f82e57df961a67e806" translate="yes" xml:space="preserve">
          <source>An asynchronous version of &lt;a href=&quot;#unittest.mock.Mock&quot;&gt;&lt;code&gt;Mock&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt;&lt;code&gt;AsyncMock&lt;/code&gt;&lt;/a&gt; object will behave so the object is recognized as an async function, and the result of a call is an awaitable.</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock&quot;&gt; &lt;code&gt;Mock&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 . &lt;a href=&quot;#unittest.mock.AsyncMock&quot;&gt; &lt;code&gt;AsyncMock&lt;/code&gt; 의&lt;/a&gt; 목적은 비동기 함수로서 인식되어 있고, 호출의 결과가 awaitable 정도로 개체 동작한다.</target>
        </trans-unit>
        <trans-unit id="1fdc0779a5b2419f946e9654c6370c12f380766a" translate="yes" xml:space="preserve">
          <source>An asyncio condition primitive can be used by a task to wait for some event to happen and then get exclusive access to a shared resource.</source>
          <target state="translated">asyncio condition 프리미티브는 작업에서 일부 이벤트가 발생할 때까지 기다린 다음 공유 리소스에 독점적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce693ef39f956e4dfceff810a01b25898982c4eb" translate="yes" xml:space="preserve">
          <source>An asyncio event can be used to notify multiple asyncio tasks that some event has happened.</source>
          <target state="translated">asyncio 이벤트는 여러 asyncio 작업에 일부 이벤트가 발생했음을 알리는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d221089bb63278ae2eac9dba4c559652680a0628" translate="yes" xml:space="preserve">
          <source>An asyncio lock can be used to guarantee exclusive access to a shared resource.</source>
          <target state="translated">공유 리소스에 대한 독점 액세스를 보장하기 위해 asyncio 잠금을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8132e7095ff57a267c20149288415aebe2314d5" translate="yes" xml:space="preserve">
          <source>An attempt to resume the parser was made when the parser had not been suspended.</source>
          <target state="translated">파서가 일시 중지되지 않았을 때 파서를 다시 시작하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="06688b12c4727b91b1013a9b4b85afe3f1de51e7" translate="yes" xml:space="preserve">
          <source>An attribute value that must be a tuple listing valid path portions of the URL for receiving XML-RPC requests. Requests posted to other paths will result in a 404 &amp;ldquo;no such page&amp;rdquo; HTTP error. If this tuple is empty, all paths will be considered valid. The default value is &lt;code&gt;('/', '/RPC2')&lt;/code&gt;.</source>
          <target state="translated">XML-RPC 요청을 수신하기 위해 URL의 유효한 경로 부분을 나열하는 튜플이어야하는 속성 값입니다. 다른 경로에 게시 된 요청은 404 &quot;No such page&quot;HTTP 오류를 발생시킵니다. 이 튜플이 비어 있으면 모든 경로가 유효한 것으로 간주됩니다. 기본값은 &lt;code&gt;('/', '/RPC2')&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="247e09baf71df7f71e226b7096feb96275db6196" translate="yes" xml:space="preserve">
          <source>An attribute was used more than once in a start tag.</source>
          <target state="translated">시작 태그에서 속성이 두 번 이상 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="cca38611cc7b83df2236356ffa28d63d72e96458" translate="yes" xml:space="preserve">
          <source>An authentication key is a byte string which can be thought of as a password: once a connection is established both ends will demand proof that the other knows the authentication key. (Demonstrating that both ends are using the same key does &lt;strong&gt;not&lt;/strong&gt; involve sending the key over the connection.)</source>
          <target state="translated">인증 키는 암호로 생각할 수있는 바이트 문자열입니다. 일단 연결이 설정되면 양쪽 끝에 상대방이 인증 키를 알고 있다는 증거가 필요합니다. (두 끝이 같은 키를 사용하고 있음을 증명하는 것은 연결을 통해 키를 보내는 것을 포함 하지 &lt;strong&gt;않습니다&lt;/strong&gt; .)</target>
        </trans-unit>
        <trans-unit id="c23b9bb5bd999d4e26c014cb734e6fa9c87b39aa" translate="yes" xml:space="preserve">
          <source>An email message consists of &lt;em&gt;headers&lt;/em&gt; and a &lt;em&gt;payload&lt;/em&gt; (which is also referred to as the &lt;em&gt;content&lt;/em&gt;). Headers are &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; or &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; style field names and values, where the field name and value are separated by a colon. The colon is not part of either the field name or the field value. The payload may be a simple text message, or a binary object, or a structured sequence of sub-messages each with their own set of headers and their own payload. The latter type of payload is indicated by the message having a MIME type such as &lt;em&gt;multipart/*&lt;/em&gt; or &lt;em&gt;message/rfc822&lt;/em&gt;.</source>
          <target state="translated">이메일 메시지는 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;페이로드&lt;/em&gt; ( &lt;em&gt;콘텐츠&lt;/em&gt; 라고도 함)로 &lt;em&gt;구성&lt;/em&gt; 됩니다. 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5322.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5322&lt;/strong&gt;&lt;/a&gt; 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc6532.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 6532&lt;/strong&gt;&lt;/a&gt; 스타일 필드 이름 및 값이며 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름 또는 필드 값의 일부가 아닙니다. 페이로드는 간단한 문자 메시지 또는 이진 객체이거나 각각 고유 한 헤더 세트와 자체 페이로드가있는 구조화 된 하위 메시지 시퀀스 일 수 있습니다. 후자의 페이로드 유형은 &lt;em&gt;multipart / *&lt;/em&gt; 또는 &lt;em&gt;message / rfc822&lt;/em&gt; 와 같은 MIME 유형을 가진 메시지로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c372588e305c30fd92a3064303d38c2f969de76" translate="yes" xml:space="preserve">
          <source>An email message consists of &lt;em&gt;headers&lt;/em&gt; and a &lt;em&gt;payload&lt;/em&gt;. Headers must be &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; style names and values, where the field name and value are separated by a colon. The colon is not part of either the field name or the field value. The payload may be a simple text message, or a binary object, or a structured sequence of sub-messages each with their own set of headers and their own payload. The latter type of payload is indicated by the message having a MIME type such as &lt;em&gt;multipart/*&lt;/em&gt; or &lt;em&gt;message/rfc822&lt;/em&gt;.</source>
          <target state="translated">이메일 메시지는 &lt;em&gt;헤더&lt;/em&gt; 와 &lt;em&gt;페이로드&lt;/em&gt; 로 구성됩니다 . 헤더는 &lt;a href=&quot;https://tools.ietf.org/html/rfc5233.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 5233&lt;/strong&gt;&lt;/a&gt; 스타일 이름과 값 이어야하며 필드 이름과 값은 콜론으로 구분됩니다. 콜론은 필드 이름 또는 필드 값의 일부가 아닙니다. 페이로드는 간단한 텍스트 메시지, 이진 객체 또는 각각 고유 한 헤더 세트와 자체 페이로드가있는 구조화 된 하위 메시지 시퀀스 일 수 있습니다. 후자의 페이로드 유형은 &lt;em&gt;multipart / *&lt;/em&gt; 또는 &lt;em&gt;message / rfc822&lt;/em&gt; 와 같은 MIME 유형을 가진 메시지로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9ac870ddd7b9cee7af970522ac0cb62cc665869" translate="yes" xml:space="preserve">
          <source>An empty string is returned if the value cannot be determined. Note that many platforms do not provide this information or simply return the same value as for &lt;a href=&quot;#platform.machine&quot;&gt;&lt;code&gt;machine()&lt;/code&gt;&lt;/a&gt;. NetBSD does this.</source>
          <target state="translated">값을 확인할 수 없으면 빈 문자열이 반환됩니다. 많은 플랫폼에서이 정보를 제공하지 않거나 단순히 &lt;a href=&quot;#platform.machine&quot;&gt; &lt;code&gt;machine()&lt;/code&gt; &lt;/a&gt; 과 동일한 값을 반환합니다 . NetBSD는 이것을합니다.</target>
        </trans-unit>
        <trans-unit id="0626a6597dc747aecf4b27d088ed3268190477de" translate="yes" xml:space="preserve">
          <source>An end tag did not match the innermost open start tag.</source>
          <target state="translated">종료 태그가 가장 안쪽에있는 시작 태그와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e204644cad08d09082fc0881f67657a40116f7c5" translate="yes" xml:space="preserve">
          <source>An end-of-file on input is passed back as the string &lt;code&gt;'EOF'&lt;/code&gt;.</source>
          <target state="translated">입력시 파일 끝은 문자열 &lt;code&gt;'EOF'&lt;/code&gt; 로 다시 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7b3b2a0614b25738aef986d351e59fa4b2b82de" translate="yes" xml:space="preserve">
          <source>An entity reference contained another reference to the same entity; possibly via a different name, and possibly indirectly.</source>
          <target state="translated">엔티티 참조는 동일한 엔티티에 대한 다른 참조를 포함합니다. 다른 이름을 통해 간접적으로 가능할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3703befccbd34b5b25cb780b7ad45fd641ab0fee" translate="yes" xml:space="preserve">
          <source>An entity reference in an attribute value referred to an external entity instead of an internal entity.</source>
          <target state="translated">속성 값의 엔티티 참조는 내부 엔티티 대신 외부 엔티티를 참조했습니다.</target>
        </trans-unit>
        <trans-unit id="3d37f6c8e1d729e4b74279866b363474e3ce5063" translate="yes" xml:space="preserve">
          <source>An entity reference referred to an entity which was declared with a notation, so cannot be parsed.</source>
          <target state="translated">엔티티 참조는 표기법으로 선언 된 엔티티를 참조하므로 구문 분석 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="35cf344fbad219897b2d51ae8eba44868eff1f92" translate="yes" xml:space="preserve">
          <source>An entry in a &lt;a href=&quot;#symtable.SymbolTable&quot;&gt;&lt;code&gt;SymbolTable&lt;/code&gt;&lt;/a&gt; corresponding to an identifier in the source. The constructor is not public.</source>
          <target state="translated">소스의 식별자에 해당 하는 &lt;a href=&quot;#symtable.SymbolTable&quot;&gt; &lt;code&gt;SymbolTable&lt;/code&gt; &lt;/a&gt; 의 항목입니다 . 생성자가 공개되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f406f6ad3dfbdd6e32c42a45910cc78a6fbc0eb9" translate="yes" xml:space="preserve">
          <source>An enumeration is a set of symbolic names (members) bound to unique, constant values. Within an enumeration, the members can be compared by identity, and the enumeration itself can be iterated over.</source>
          <target state="translated">열거 형은 고유 한 상수 값에 바인딩 된 일련의 기호 이름 (멤버)입니다. 열거 내에서 멤버를 ID별로 비교할 수 있으며 열거 자체를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ceb56cb5ae384a7c045483416aaaa181587fc4e" translate="yes" xml:space="preserve">
          <source>An enumeration of &lt;a href=&quot;#uuid.SafeUUID&quot;&gt;&lt;code&gt;SafeUUID&lt;/code&gt;&lt;/a&gt; which indicates whether the platform generated the UUID in a multiprocessing-safe way.</source>
          <target state="translated">플랫폼이 다중 처리 안전 방식으로 UUID를 생성했는지 여부를 나타내는 &lt;a href=&quot;#uuid.SafeUUID&quot;&gt; &lt;code&gt;SafeUUID&lt;/code&gt; &lt;/a&gt; 열거입니다 .</target>
        </trans-unit>
        <trans-unit id="191e9b46b39612e5a45fb6724e6abdd03694c710" translate="yes" xml:space="preserve">
          <source>An equality comparison between one &lt;code&gt;dict.values()&lt;/code&gt; view and another will always return &lt;code&gt;False&lt;/code&gt;. This also applies when comparing &lt;code&gt;dict.values()&lt;/code&gt; to itself:</source>
          <target state="translated">한 &lt;code&gt;dict.values()&lt;/code&gt; 뷰와 다른 dict.values ​​() 뷰 의 동등 비교 는 항상 &lt;code&gt;False&lt;/code&gt; 를 반환 합니다. &lt;code&gt;dict.values()&lt;/code&gt; 를 자체와 비교할 때도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="a01448ba36fc6180ade36d1e4999112151667f7e" translate="yes" xml:space="preserve">
          <source>An error is produced for arguments that could produce more than one options. This feature can be disabled by setting &lt;a href=&quot;#allow-abbrev&quot;&gt;allow_abbrev&lt;/a&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">둘 이상의 옵션을 생성 할 수있는 인수에 대해 오류가 발생합니다. &lt;a href=&quot;#allow-abbrev&quot;&gt;allow_abbrev&lt;/a&gt; 를 &lt;code&gt;False&lt;/code&gt; 로 설정 하면 이 기능을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dc2e93e3b7a317994b5c3eb2e52e7df07abc268" translate="yes" xml:space="preserve">
          <source>An error is returned whenever the resulting exponent is greater than &lt;code&gt;Emax&lt;/code&gt; or less than &lt;code&gt;Etiny&lt;/code&gt;.</source>
          <target state="translated">결과 지수가 &lt;code&gt;Emax&lt;/code&gt; 보다 크 거나 &lt;code&gt;Etiny&lt;/code&gt; 보다 작을 때마다 오류가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="516d3d6e48e258e621be2b2a76babfa7dc02e706" translate="yes" xml:space="preserve">
          <source>An error raised when a NIS function returns an error code.</source>
          <target state="translated">NIS 함수가 오류 코드를 리턴하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="58377c1e23ec237f7e5eaaef750df18f85b3cb45" translate="yes" xml:space="preserve">
          <source>An error raised when something is impossible because it violates the WAV specification or hits an implementation deficiency.</source>
          <target state="translated">WAV 사양을 위반하거나 구현 결함에 도달하여 불가능한 경우 오류가 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="4593a10048262564ce6c822735e42f44f346b661" translate="yes" xml:space="preserve">
          <source>An event loop based on the &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">&lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 모듈을 기반으로하는 이벤트 루프 .</target>
        </trans-unit>
        <trans-unit id="f3adc0d9c6ca30e1ba3e56151e0bcf79cc795c22" translate="yes" xml:space="preserve">
          <source>An event loop for Windows that uses &amp;ldquo;I/O Completion Ports&amp;rdquo; (IOCP).</source>
          <target state="translated">&amp;ldquo;I / O 완료 포트&amp;rdquo;(IOCP)를 사용하는 Windows 용 이벤트 루프.</target>
        </trans-unit>
        <trans-unit id="fd91140b0fe187a666b9e9bf676cecb25b813937" translate="yes" xml:space="preserve">
          <source>An event loop policy is a global per-process object that controls the management of the event loop. Each event loop has a default policy, which can be changed and customized using the policy API.</source>
          <target state="translated">이벤트 루프 정책은 이벤트 루프 관리를 제어하는 ​​전역 프로세스 별 개체입니다. 각 이벤트 루프에는 기본 정책이 있으며 정책 API를 사용하여 변경하고 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2e556041e787dfb19531ed6bea3ca88bb68687f" translate="yes" xml:space="preserve">
          <source>An event loop runs in a thread (typically the main thread) and executes all callbacks and Tasks in its thread. While a Task is running in the event loop, no other Tasks can run in the same thread. When a Task executes an &lt;code&gt;await&lt;/code&gt; expression, the running Task gets suspended, and the event loop executes the next Task.</source>
          <target state="translated">이벤트 루프는 스레드 (일반적으로 기본 스레드)에서 실행되며 스레드의 모든 콜백 및 작업을 실행합니다. 작업이 이벤트 루프에서 실행되는 동안 다른 작업은 동일한 스레드에서 실행할 수 없습니다. Task가 &lt;code&gt;await&lt;/code&gt; 식을 실행하면 실행중인 Task가 일시 중단되고 이벤트 루프가 다음 Task를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="608baac34ec6b479b1e075077346da843d886918" translate="yes" xml:space="preserve">
          <source>An event object manages an internal flag that can be set to true with the &lt;a href=&quot;#threading.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; method and reset to false with the &lt;a href=&quot;#threading.Event.clear&quot;&gt;&lt;code&gt;clear()&lt;/code&gt;&lt;/a&gt; method. The &lt;a href=&quot;#threading.Event.wait&quot;&gt;&lt;code&gt;wait()&lt;/code&gt;&lt;/a&gt; method blocks until the flag is true.</source>
          <target state="translated">이벤트 객체는 &lt;a href=&quot;#threading.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 메서드 로 true로 설정 하고 &lt;a href=&quot;#threading.Event.clear&quot;&gt; &lt;code&gt;clear()&lt;/code&gt; &lt;/a&gt; 메서드 로 false로 재설정 할 수있는 내부 플래그를 관리합니다 . &lt;a href=&quot;#threading.Event.wait&quot;&gt; &lt;code&gt;wait()&lt;/code&gt; &lt;/a&gt; 플래그까지 방법 블록은 사실이다.</target>
        </trans-unit>
        <trans-unit id="9cf919b4535184a2bac9b21b394a3391ed3be52c" translate="yes" xml:space="preserve">
          <source>An event object.</source>
          <target state="translated">이벤트 객체.</target>
        </trans-unit>
        <trans-unit id="3197165a12532ea18a4db9c10db35c9e41c35331" translate="yes" xml:space="preserve">
          <source>An event object. Not thread-safe.</source>
          <target state="translated">이벤트 객체. 스레드 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="58be36b1fcb18ab8fd811be0960165993ee1b495" translate="yes" xml:space="preserve">
          <source>An example for &lt;a href=&quot;#csv.Sniffer&quot;&gt;&lt;code&gt;Sniffer&lt;/code&gt;&lt;/a&gt; use:</source>
          <target state="translated">&lt;a href=&quot;#csv.Sniffer&quot;&gt; &lt;code&gt;Sniffer&lt;/code&gt; &lt;/a&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="d24bd94253a9e026200e1be3ce54276cf7eb1d9f" translate="yes" xml:space="preserve">
          <source>An example for the &lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt;&lt;code&gt;ThreadingMixIn&lt;/code&gt;&lt;/a&gt; class:</source>
          <target state="translated">&lt;a href=&quot;#socketserver.ThreadingMixIn&quot;&gt; &lt;code&gt;ThreadingMixIn&lt;/code&gt; &lt;/a&gt; 클래스 의 예 :</target>
        </trans-unit>
        <trans-unit id="2b1abaee744f811fdecf714da38ec6d05c1976f7" translate="yes" xml:space="preserve">
          <source>An example illustrating the order:</source>
          <target state="translated">순서를 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="71f4f4affa7b143203b514eaf53d7bbc4a253b38" translate="yes" xml:space="preserve">
          <source>An example may make it more understandable:</source>
          <target state="translated">예를 들어 이해하기 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80b147a88b6b8cb2d7f13419efc055fe8a5741d" translate="yes" xml:space="preserve">
          <source>An example of a callback displaying the current date every second. The callback uses the &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt;&lt;code&gt;loop.call_later()&lt;/code&gt;&lt;/a&gt; method to reschedule itself after 5 seconds, and then stops the event loop:</source>
          <target state="translated">매초마다 현재 날짜를 표시하는 콜백의 예입니다. 콜백은 &lt;a href=&quot;#asyncio.loop.call_later&quot;&gt; &lt;code&gt;loop.call_later()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 5 초 후에 자체 일정을 조정 한 다음 이벤트 루프를 중지합니다.</target>
        </trans-unit>
        <trans-unit id="11af1171f8dc0175c6f96364b3dfa7e2608ea195" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns a related object is the one returned by &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt;&lt;code&gt;decimal.localcontext()&lt;/code&gt;&lt;/a&gt;. These managers set the active decimal context to a copy of the original decimal context and then return the copy. This allows changes to be made to the current decimal context in the body of the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement without affecting code outside the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">관련 객체를 반환하는 컨텍스트 관리자의 예는 &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt; &lt;code&gt;decimal.localcontext()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 것 입니다. 이 관리자는 활성 10 진수 컨텍스트를 원래 10 진수 컨텍스트의 사본으로 설정 한 다음 사본을 리턴합니다. 이 변화가 본문에 현재의 진수 컨텍스트에 할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 외부 코드에 영향을주지 않고 문 &lt;code&gt;with&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="aaa6de7586c2063984c7b7c3d3b5cb79168e0d34" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns a related object is the one returned by &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt;&lt;code&gt;decimal.localcontext()&lt;/code&gt;&lt;/a&gt;. These managers set the active decimal context to a copy of the original decimal context and then return the copy. This allows changes to be made to the current decimal context in the body of the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement without affecting code outside the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">관련 객체를 반환하는 컨텍스트 관리자의 예는 &lt;a href=&quot;decimal#decimal.localcontext&quot;&gt; &lt;code&gt;decimal.localcontext()&lt;/code&gt; &lt;/a&gt; 의해 반환되는 것 입니다. 이러한 관리자는 활성 십진 컨텍스트를 원래 십진 컨텍스트의 복사본으로 설정 한 다음 복사본을 반환합니다. 이 변화가 본문에 현재의 진수 컨텍스트에 할 수 있습니다 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 외부 코드에 영향을주지 않고 문 &lt;code&gt;with&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="229e46ea428fdf9847aacb2de4467c37f32f31e2" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns itself is a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. File objects return themselves from __enter__() to allow &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; to be used as the context expression in a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">자체를 리턴하는 컨텍스트 관리자의 예는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-file-object&quot;&gt;파일 오브젝트&lt;/a&gt; 입니다. 파일 객체는 __enter __ ()에서 자신을 반환 하여 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 컨텍스트 표현식으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="26e0ecb0e14afdc2a9657a109cdda63266fd0dd1" translate="yes" xml:space="preserve">
          <source>An example of a context manager that returns itself is a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;file object&lt;/a&gt;. File objects return themselves from __enter__() to allow &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; to be used as the context expression in a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement.</source>
          <target state="translated">자신을 반환하는 컨텍스트 관리자의 예는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-file-object&quot;&gt;파일 객체&lt;/a&gt; 입니다. 파일 객체는 __enter __ ()에서 자신을 반환하여 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 컨텍스트 표현식으로 사용할 수 있도록 합니다.</target>
        </trans-unit>
        <trans-unit id="a36c0094a4d20f58e22fab2dc6ea6b13c4064617" translate="yes" xml:space="preserve">
          <source>An example of a custom action:</source>
          <target state="translated">맞춤 작업의 예 :</target>
        </trans-unit>
        <trans-unit id="bd79d7fcb90941297a732fcb5d7d3317ee346397" translate="yes" xml:space="preserve">
          <source>An example of a mock that raises an exception (to test exception handling of an API):</source>
          <target state="translated">API의 예외 처리를 테스트하기 위해 예외를 발생시키는 모의 예 :</target>
        </trans-unit>
        <trans-unit id="16f4febaa13c59704ab69ba35886f8105bd56383" translate="yes" xml:space="preserve">
          <source>An example of a subprocess protocol used to get the output of a subprocess and to wait for the subprocess exit.</source>
          <target state="translated">하위 프로세스의 출력을 가져오고 하위 프로세스 종료를 기다리는 데 사용되는 하위 프로세스 프로토콜의 예입니다.</target>
        </trans-unit>
        <trans-unit id="359da9d396e7a3381bf357db2dce0ae96d67afdf" translate="yes" xml:space="preserve">
          <source>An example of dictionary view usage:</source>
          <target state="translated">사전보기 사용법의 예 :</target>
        </trans-unit>
        <trans-unit id="195305d65f73569e3259a2afbec9afedbef3ecc9" translate="yes" xml:space="preserve">
          <source>An example of extending &lt;code&gt;EnvBuilder&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;EnvBuilder&lt;/code&gt; 확장의 예</target>
        </trans-unit>
        <trans-unit id="009b99e279ffcfd9cbdb98ce048a15df969325ea" translate="yes" xml:space="preserve">
          <source>An example of passing some arguments to an external program as a sequence is:</source>
          <target state="translated">일부 인수를 시퀀스로 외부 프로그램에 전달하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1081cc9057f681139574ba8aa1d51a1b7326375e" translate="yes" xml:space="preserve">
          <source>An example of reading the configuration file again:</source>
          <target state="translated">구성 파일을 다시 읽는 예 :</target>
        </trans-unit>
        <trans-unit id="a17cbc95ce9a012142cb3b9171e1c0a196a14699" translate="yes" xml:space="preserve">
          <source>An example of setting some log options, these would include the process ID in logged messages, and write the messages to the destination facility used for mail logging:</source>
          <target state="translated">일부 로그 옵션을 설정하는 예는 로깅 된 메시지의 프로세스 ID를 포함하고 메일 로깅에 사용되는 대상 기능에 메시지를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="0fc1f9040cc5763e678640ef2363a997c9953de5" translate="yes" xml:space="preserve">
          <source>An example of the extended interface with non-ASCII characters:</source>
          <target state="translated">비 ASCII 문자로 확장 된 인터페이스의 예 :</target>
        </trans-unit>
        <trans-unit id="cc391b585ed780ac543ae3ed4c184e7ef73852d8" translate="yes" xml:space="preserve">
          <source>An example of the usage of &lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt;&lt;code&gt;_callmethod()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#multiprocessing.managers.BaseProxy._callmethod&quot;&gt; &lt;code&gt;_callmethod()&lt;/code&gt; &lt;/a&gt; 사용법의 예 :</target>
        </trans-unit>
        <trans-unit id="b0374afa67447b447f7a013a60acd58beb789bd8" translate="yes" xml:space="preserve">
          <source>An example of writing to a configuration file:</source>
          <target state="translated">구성 파일에 쓰는 예 :</target>
        </trans-unit>
        <trans-unit id="678e726964a2ce10c4c1a7c983eb935e47f7d7bc" translate="yes" xml:space="preserve">
          <source>An example showing how to use queues to feed tasks to a collection of worker processes and collect the results:</source>
          <target state="translated">대기열을 사용하여 작업자 프로세스 콜렉션에 태스크를 공급하고 결과를 수집하는 방법을 보여주는 예제 :</target>
        </trans-unit>
        <trans-unit id="ce7f7b7a4c5476e3cc316370c635a0a929e3cae0" translate="yes" xml:space="preserve">
          <source>An example that will remove &lt;em&gt;remove_this&lt;/em&gt; from email addresses:</source>
          <target state="translated">이메일 주소에서 &lt;em&gt;remove_this&lt;/em&gt; 를 제거하는 예제 :</target>
        </trans-unit>
        <trans-unit id="81981452dd23b6b05db05d7cfb0589b85b814ed7" translate="yes" xml:space="preserve">
          <source>An example to show the &lt;code&gt;_ignore_&lt;/code&gt; attribute in use:</source>
          <target state="translated">사용중인 &lt;code&gt;_ignore_&lt;/code&gt; 속성 을 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="85eca7d3c00b4de3339c2e436d45332986ea35c3" translate="yes" xml:space="preserve">
          <source>An example usage of the module:</source>
          <target state="translated">모듈 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="b8690b021b6b6b9da606f08de01ded9048222325" translate="yes" xml:space="preserve">
          <source>An example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="7c60e5df7208cba172a6b4861bef2a01e85722af" translate="yes" xml:space="preserve">
          <source>An example using &lt;em&gt;enter_result&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;enter_result&lt;/em&gt; 사용 예 :</target>
        </trans-unit>
        <trans-unit id="619d126046efa510fbee514e656faac7c28fa578" translate="yes" xml:space="preserve">
          <source>An example using only Unix style options:</source>
          <target state="translated">유닉스 스타일 옵션 만 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="cb40c2136fa42deb9a36926aa145be2f5a4b420f" translate="yes" xml:space="preserve">
          <source>An example using the &lt;a href=&quot;#asyncio.asyncio.subprocess.Process&quot;&gt;&lt;code&gt;Process&lt;/code&gt;&lt;/a&gt; class to control a subprocess and the &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt;&lt;code&gt;StreamReader&lt;/code&gt;&lt;/a&gt; class to read from its standard output.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.asyncio.subprocess.Process&quot;&gt; &lt;code&gt;Process&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 하위 프로세스를 제어하고 &lt;a href=&quot;asyncio-stream#asyncio.StreamReader&quot;&gt; &lt;code&gt;StreamReader&lt;/code&gt; &lt;/a&gt; 클래스를 표준 출력에서 ​​읽 도록 제어 하는 예제 입니다.</target>
        </trans-unit>
        <trans-unit id="99f3529798fae53307059d813edb69b2362e7c71" translate="yes" xml:space="preserve">
          <source>An example using the &lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt;&lt;code&gt;loop.call_soon()&lt;/code&gt;&lt;/a&gt; method to schedule a callback. The callback displays &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; and then stops the event loop:</source>
          <target state="translated">&lt;a href=&quot;#asyncio.loop.call_soon&quot;&gt; &lt;code&gt;loop.call_soon()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 콜백을 스케줄 하는 예제 입니다. 콜백에 &lt;code&gt;&quot;Hello World&quot;&lt;/code&gt; 가 표시 되고 이벤트 루프가 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="ff40ba096df117ee2ce62d129f289e94ce50d311" translate="yes" xml:space="preserve">
          <source>An example which will deadlock is the following:</source>
          <target state="translated">교착 상태가되는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1449c62b11b34c51038e54fc84c6c14e5bdd420c" translate="yes" xml:space="preserve">
          <source>An example with non-ASCII characters:</source>
          <target state="translated">비 ASCII 문자의 예 :</target>
        </trans-unit>
        <trans-unit id="f71f4e4b07c8d3bd6da392502d651c55e4d66276" translate="yes" xml:space="preserve">
          <source>An example&amp;rsquo;s doctest directives modify doctest&amp;rsquo;s behavior for that single example. Use &lt;code&gt;+&lt;/code&gt; to enable the named behavior, or &lt;code&gt;-&lt;/code&gt; to disable it.</source>
          <target state="translated">예제의 doctest 지시문은 해당 단일 예제에 대한 doctest의 동작을 수정합니다. 명명 된 동작을 사용 하려면 &lt;code&gt;+&lt;/code&gt; 를 사용하고, 사용하지 않으려면 &lt;code&gt;-&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="23a14600961e92118a1b9c9768e9bc704485af4b" translate="yes" xml:space="preserve">
          <source>An exception has occurred. The local trace function is called; &lt;em&gt;arg&lt;/em&gt; is a tuple &lt;code&gt;(exception, value, traceback)&lt;/code&gt;; the return value specifies the new local trace function.</source>
          <target state="translated">예외가 발생했습니다. 로컬 추적 기능이 호출됩니다. &lt;em&gt;arg&lt;/em&gt; 는 튜플 &lt;code&gt;(exception, value, traceback)&lt;/code&gt; . 리턴 값은 새로운 로컬 추적 기능을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="077f3a8d799c59c87a7879ae93f65a8b265b382c" translate="yes" xml:space="preserve">
          <source>An exception inheriting &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; that is raised when an unsupported operation is called on a stream.</source>
          <target state="translated">지원되지 않는 작업이 스트림에서 호출 될 때 발생하는 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 상속하는 예외 입니다.</target>
        </trans-unit>
        <trans-unit id="90348b9ec43ea456461b13b883f04b6adc7d95fc" translate="yes" xml:space="preserve">
          <source>An exception raised by &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; to signal that a doctest example raised an unexpected exception. The constructor arguments are used to initialize the attributes of the same names.</source>
          <target state="translated">&lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 가 doctest 예제에서 예기치 않은 예외가 발생했음을 알리기 위해 예외가 발생했습니다 . 생성자 인수는 동일한 이름의 속성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2d6bd0f6bfde706cbcad0479411815ccfff05d" translate="yes" xml:space="preserve">
          <source>An exception raised by &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt;&lt;code&gt;DocTestRunner&lt;/code&gt;&lt;/a&gt; to signal that a doctest example&amp;rsquo;s actual output did not match its expected output. The constructor arguments are used to initialize the attributes of the same names.</source>
          <target state="translated">doctest 예제의 실제 출력이 예상 출력과 일치하지 않음 을 &lt;a href=&quot;#doctest.DocTestRunner&quot;&gt; &lt;code&gt;DocTestRunner&lt;/code&gt; &lt;/a&gt; 위해 DocTestRunner 에 의해 발생한 예외 입니다. 생성자 인수는 동일한 이름의 속성을 초기화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d371cb40c11f76c5c36febec63cfec9705178506" translate="yes" xml:space="preserve">
          <source>An exception raised for invalid gzip files. It inherits &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;exceptions#EOFError&quot;&gt;&lt;code&gt;EOFError&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;zlib#zlib.error&quot;&gt;&lt;code&gt;zlib.error&lt;/code&gt;&lt;/a&gt; can also be raised for invalid gzip files.</source>
          <target state="translated">잘못된 gzip 파일에 대해 예외가 발생했습니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 를&lt;/a&gt; 상속 합니다. 잘못된 gzip 파일에 대해 &lt;a href=&quot;exceptions#EOFError&quot;&gt; &lt;code&gt;EOFError&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;zlib#zlib.error&quot;&gt; &lt;code&gt;zlib.error&lt;/code&gt; &lt;/a&gt; 도 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595cdbaab3299ecf183e16949385b4ed75622bb8" translate="yes" xml:space="preserve">
          <source>An exception tuple, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">예외 튜플, 또는 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6b714867157f6242c971860d61ec3d6ff7556a5" translate="yes" xml:space="preserve">
          <source>An executable line in a &lt;code&gt;.pth&lt;/code&gt; file is run at every Python startup, regardless of whether a particular module is actually going to be used. Its impact should thus be kept to a minimum. The primary intended purpose of executable lines is to make the corresponding module(s) importable (load 3rd-party import hooks, adjust &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; etc). Any other initialization is supposed to be done upon a module&amp;rsquo;s actual import, if and when it happens. Limiting a code chunk to a single line is a deliberate measure to discourage putting anything more complex here.</source>
          <target state="translated">&lt;code&gt;.pth&lt;/code&gt; 파일 의 실행 가능 라인은 특정 모듈의 실제 사용 여부에 관계없이 모든 Python 시작시 실행됩니다. 따라서 영향을 최소화해야합니다. 실행 가능한 행의 주요 목적은 해당 모듈을 가져 오기 가능하게 만드는 것입니다 (타사 가져 오기 후크로드, &lt;code id=&quot;index-3&quot;&gt;PATH&lt;/code&gt; 조정 등). 다른 초기화는 모듈의 실제 가져 오기에 따라 수행됩니다. 코드 청크를 한 줄로 제한하는 것은 여기에 더 복잡한 것을 넣지 않도록 의도적으로 측정하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b1add73ad794c032de45e9a10a3307ac96e89eae" translate="yes" xml:space="preserve">
          <source>An executor can be used to run a task in a different thread or even in a different process to avoid blocking the OS thread with the event loop. See the &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt;&lt;code&gt;loop.run_in_executor()&lt;/code&gt;&lt;/a&gt; method for more details.</source>
          <target state="translated">실행기는 이벤트 스레드로 OS 스레드를 차단하지 않도록 다른 스레드 또는 다른 프로세스에서 태스크를 실행하는 데 사용할 수 있습니다. 자세한 내용은 &lt;a href=&quot;asyncio-eventloop#asyncio.loop.run_in_executor&quot;&gt; &lt;code&gt;loop.run_in_executor()&lt;/code&gt; &lt;/a&gt; 메서드를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e11c12943faf16444ceedb9804a38db006485b2" translate="yes" xml:space="preserve">
          <source>An existing file of the same name is overwritten.</source>
          <target state="translated">동일한 이름의 기존 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="2e1fe8390882dfde7bc76d70b8e2cafd23494e82" translate="yes" xml:space="preserve">
          <source>An existing file of the same name is overwritten. The optional parameters have the same meaning as in &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">동일한 이름의 기존 파일을 덮어 씁니다. 선택적 매개 변수는 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 과 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="02ba8d7a14486c8e174ff533d6d9c0663952b29e" translate="yes" xml:space="preserve">
          <source>An explanation of some terminology and conventions is in order.</source>
          <target state="translated">일부 용어 및 규칙에 대한 설명이 순서대로 있습니다.</target>
        </trans-unit>
        <trans-unit id="afcd75246a2757517247035db4d172b90f008625" translate="yes" xml:space="preserve">
          <source>An expression such as &lt;code&gt;a if b else c&lt;/code&gt;. Each field holds a single node, so in the following example, all three are &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt; nodes.</source>
          <target state="translated">&lt;code&gt;a if b else c&lt;/code&gt; 와 같은 표현식 . 각 필드는 단일 노드를 보유하므로 다음 예에서 세 개 모두 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 노드입니다.</target>
        </trans-unit>
        <trans-unit id="890aae396d7bacf660f2e6509a7c070fac630d67" translate="yes" xml:space="preserve">
          <source>An extended example which also demonstrates the use of pointers accesses the &lt;a href=&quot;https://docs.python.org/3.8/c-api/import.html#c.PyImport_FrozenModules&quot;&gt;&lt;code&gt;PyImport_FrozenModules&lt;/code&gt;&lt;/a&gt; pointer exported by Python.</source>
          <target state="translated">포인터 사용을 보여주는 확장 된 예제 는 Python에서 내 보낸 &lt;a href=&quot;https://docs.python.org/3.8/c-api/import.html#c.PyImport_FrozenModules&quot;&gt; &lt;code&gt;PyImport_FrozenModules&lt;/code&gt; &lt;/a&gt; 포인터에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="786f4b149806f265b7a77db548ada758892c3ee6" translate="yes" xml:space="preserve">
          <source>An extended example which also demonstrates the use of pointers accesses the &lt;a href=&quot;https://docs.python.org/3.9/c-api/import.html#c.PyImport_FrozenModules&quot;&gt;&lt;code&gt;PyImport_FrozenModules&lt;/code&gt;&lt;/a&gt; pointer exported by Python.</source>
          <target state="translated">포인터 사용을 보여주는 확장 예제 는 Python에서 내 보낸 &lt;a href=&quot;https://docs.python.org/3.9/c-api/import.html#c.PyImport_FrozenModules&quot;&gt; &lt;code&gt;PyImport_FrozenModules&lt;/code&gt; &lt;/a&gt; 포인터에 액세스합니다 .</target>
        </trans-unit>
        <trans-unit id="d874aff9356fc6c2a27e76364bce500fa2c6518e" translate="yes" xml:space="preserve">
          <source>An extensive list of Python testing tools including functional testing frameworks and mock object libraries.</source>
          <target state="translated">기능 테스트 프레임 워크 및 모의 객체 라이브러리를 포함한 광범위한 Python 테스트 도구 목록.</target>
        </trans-unit>
        <trans-unit id="5db187c411091906fb89eaeff2e7a3de90c9b6af" translate="yes" xml:space="preserve">
          <source>An f-string, comprising a series of &lt;a href=&quot;#ast.FormattedValue&quot;&gt;&lt;code&gt;FormattedValue&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ast.Constant&quot;&gt;&lt;code&gt;Constant&lt;/code&gt;&lt;/a&gt; nodes.</source>
          <target state="translated">일련의 &lt;a href=&quot;#ast.FormattedValue&quot;&gt; &lt;code&gt;FormattedValue&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ast.Constant&quot;&gt; &lt;code&gt;Constant&lt;/code&gt; &lt;/a&gt; 노드로 구성된 f- 문자열 .</target>
        </trans-unit>
        <trans-unit id="0a23d9f159c83bfe97b484a3e6115e80af5d4380" translate="yes" xml:space="preserve">
          <source>An hour is converted to 3600 seconds.</source>
          <target state="translated">시간은 3600 초로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8b6236d6ba69aedf0745fd1ea63614a9e2262bf5" translate="yes" xml:space="preserve">
          <source>An id which does not have a corresponding destination.</source>
          <target state="translated">해당 목적지가없는 아이디입니다.</target>
        </trans-unit>
        <trans-unit id="b4dfb427510e074283a39a54e4d9dbf2b185f2a3" translate="yes" xml:space="preserve">
          <source>An idealized naive date, assuming the current Gregorian calendar always was, and always will be, in effect. Attributes: &lt;a href=&quot;#datetime.date.year&quot;&gt;&lt;code&gt;year&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.date.month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#datetime.date.day&quot;&gt;&lt;code&gt;day&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 그레고리력이 항상 유효하고 항상 유효하다고 가정 할 때 이상적인 순진한 날짜. 속성 : &lt;a href=&quot;#datetime.date.year&quot;&gt; &lt;code&gt;year&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.date.month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;#datetime.date.day&quot;&gt; &lt;code&gt;day&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5099199c1ac259aae0741f72ef6e8d7849ea93" translate="yes" xml:space="preserve">
          <source>An idealized time, independent of any particular day, assuming that every day has exactly 24*60*60 seconds. (There is no notion of &amp;ldquo;leap seconds&amp;rdquo; here.) Attributes: &lt;a href=&quot;#datetime.time.hour&quot;&gt;&lt;code&gt;hour&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.minute&quot;&gt;&lt;code&gt;minute&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.second&quot;&gt;&lt;code&gt;second&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#datetime.time.microsecond&quot;&gt;&lt;code&gt;microsecond&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매일 하루가 정확히 24 * 60 * 60 초라고 가정 할 때 특정 날짜와 상관없이 이상적인 시간입니다. (. 여기에 &quot;윤초&quot;에 대한 개념이 없다) 속성 : &lt;a href=&quot;#datetime.time.hour&quot;&gt; &lt;code&gt;hour&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.minute&quot;&gt; &lt;code&gt;minute&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.second&quot;&gt; &lt;code&gt;second&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#datetime.time.microsecond&quot;&gt; &lt;code&gt;microsecond&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5610b3c1cc31886ddf86db3b6bfe9dce38bb3a3c" translate="yes" xml:space="preserve">
          <source>An immutable sequence providing access to the logical ancestors of the path:</source>
          <target state="translated">경로의 논리적 조상에 대한 액세스를 제공하는 불변 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="6b6c96734c11fca9ebe4c7cbcdfffa8db89d5e28" translate="yes" xml:space="preserve">
          <source>An implementation of the built-in &lt;a href=&quot;functions#__import__&quot;&gt;&lt;code&gt;__import__()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">내장 된 &lt;a href=&quot;functions#__import__&quot;&gt; &lt;code&gt;__import__()&lt;/code&gt; &lt;/a&gt; 함수 의 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="c90f6d36b2a0d230cb3491ea18751b34717c64b0" translate="yes" xml:space="preserve">
          <source>An import statement. &lt;code&gt;names&lt;/code&gt; is a list of &lt;a href=&quot;#ast.alias&quot;&gt;&lt;code&gt;alias&lt;/code&gt;&lt;/a&gt; nodes.</source>
          <target state="translated">import 문. &lt;code&gt;names&lt;/code&gt; 는 &lt;a href=&quot;#ast.alias&quot;&gt; &lt;code&gt;alias&lt;/code&gt; &lt;/a&gt; 노드 의 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="f7720d17fff53dae117343d8e9e4e3bdf42554ea" translate="yes" xml:space="preserve">
          <source>An important feature of proxy objects is that they are picklable so they can be passed between processes. As such, a referent can contain &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt;. This permits nesting of these managed lists, dicts, and other &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;Proxy Objects&lt;/a&gt;:</source>
          <target state="translated">프록시 개체의 중요한 기능은 프로세스간에 전달 될 수 있도록 선택 가능하다는 것입니다. 따라서, 지시자는 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체를&lt;/a&gt; 포함 할 수 있습니다 . 이를 통해 이러한 관리되는 목록, dict 및 기타 &lt;a href=&quot;#multiprocessing-proxy-objects&quot;&gt;프록시 객체를&lt;/a&gt; 중첩 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ca5c2b2d5e23075377145528c4bb6a274c41020" translate="yes" xml:space="preserve">
          <source>An in-memory stream for text I/O. The text buffer is discarded when the &lt;a href=&quot;#io.IOBase.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method is called.</source>
          <target state="translated">텍스트 I / O를위한 인 메모리 스트림. &lt;a href=&quot;#io.IOBase.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드가 호출 되면 텍스트 버퍼가 삭제됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c40d804be737d2c53024a9e0ca00bbefc518b84" translate="yes" xml:space="preserve">
          <source>An incomplete character was found in the input.</source>
          <target state="translated">입력에서 불완전한 문자가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="90ea41c9a0216bd11cc24452f4b96fc38cb07e7e" translate="yes" xml:space="preserve">
          <source>An indicator of the native byte order. This will have the value &lt;code&gt;'big'&lt;/code&gt; on big-endian (most-significant byte first) platforms, and &lt;code&gt;'little'&lt;/code&gt; on little-endian (least-significant byte first) platforms.</source>
          <target state="translated">기본 바이트 순서의 표시기입니다. 이는 빅 엔디안 (가장 중요한 바이트 우선) 플랫폼에서 &lt;code&gt;'big'&lt;/code&gt; 값을 가지며 리틀 엔디안 (가장 중요한 바이트 우선) 플랫폼에서 &lt;code&gt;'little'&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="703b3bb1868e2e8bc5b77367f969f62a6671a60f" translate="yes" xml:space="preserve">
          <source>An instance &lt;em&gt;tz&lt;/em&gt; of a &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass that models both standard and daylight times must be consistent in this sense:</source>
          <target state="translated">표준 및 일광 시간을 모두 모델링 하는 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 인스턴스 &lt;em&gt;tz&lt;/em&gt; 는 이러한 의미에서 일관성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="2f07dcb4a65f5f3cfefa434bd9d52d248683b91d" translate="yes" xml:space="preserve">
          <source>An instance of (a concrete subclass of) &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; can be passed to the constructors for &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; objects. The latter objects view their attributes as being in local time, and the &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; object supports methods revealing offset of local time from UTC, the name of the time zone, and DST offset, all relative to a date or time object passed to them.</source>
          <target state="translated">&lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 의 (구체적인 서브 클래스) 인스턴스는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 객체 의 생성자에 전달 될 수 있습니다 . 후자의 객체는 속성을 현지 시간으로 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 하고 tzinfo 객체는 UTC에서 현지 시간의 오프셋, 시간대 이름 및 DST 오프셋을 전달하는 날짜 또는 시간 객체를 기준으로하는 메서드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e4b67a267f48e3562f47079d2bb418c11e0684d5" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#asyncio.Handle&quot;&gt;&lt;code&gt;asyncio.Handle&lt;/code&gt;&lt;/a&gt; is returned, which can be used later to cancel the callback.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.Handle&quot;&gt; &lt;code&gt;asyncio.Handle&lt;/code&gt; &lt;/a&gt; 의 인스턴스 가 리턴되며 나중에 콜백을 취소하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d80ce39420c2628cfc7e1e9324435012f462488d" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt;&lt;code&gt;asyncio.TimerHandle&lt;/code&gt;&lt;/a&gt; is returned which can be used to cancel the callback.</source>
          <target state="translated">콜백을 취소하는 데 사용할 수있는 &lt;a href=&quot;#asyncio.TimerHandle&quot;&gt; &lt;code&gt;asyncio.TimerHandle&lt;/code&gt; &lt;/a&gt; 인스턴스 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01872a127016c725833502fe1517e9a8bb1110fd" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#ctypes.PyDLL&quot;&gt;&lt;code&gt;PyDLL&lt;/code&gt;&lt;/a&gt; that exposes Python C API functions as attributes. Note that all these functions are assumed to return C &lt;code&gt;int&lt;/code&gt;, which is of course not always the truth, so you have to assign the correct &lt;code&gt;restype&lt;/code&gt; attribute to use these functions.</source>
          <target state="translated">Python C API 함수를 속성으로 노출 하는 &lt;a href=&quot;#ctypes.PyDLL&quot;&gt; &lt;code&gt;PyDLL&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다 . 이러한 모든 함수는 C &lt;code&gt;int&lt;/code&gt; 를 반환하는 것으로 가정합니다. 물론 항상 사실은 아니므로 이러한 함수를 사용 하려면 올바른 &lt;code&gt;restype&lt;/code&gt; 속성을 할당 해야합니다.</target>
        </trans-unit>
        <trans-unit id="c664e0f73090f1e1bd70299e8da8a6073f9919cd" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#email.policy.Compat32&quot;&gt;&lt;code&gt;Compat32&lt;/code&gt;&lt;/a&gt;, providing backward compatibility with the behavior of the email package in Python 3.2.</source>
          <target state="translated">Python 3.2의 전자 메일 패키지 동작과 호환되는 &lt;a href=&quot;#email.policy.Compat32&quot;&gt; &lt;code&gt;Compat32&lt;/code&gt; &lt;/a&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="753712898d5c60e92ce9fc7f47232fd4e688b279" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;EmailPolicy&lt;/code&gt; with all defaults unchanged. This policy uses the standard Python &lt;code&gt;\n&lt;/code&gt; line endings rather than the RFC-correct &lt;code&gt;\r\n&lt;/code&gt;.</source>
          <target state="translated">모든 기본값이 변경되지 않은 &lt;code&gt;EmailPolicy&lt;/code&gt; 인스턴스 . 이 정책은 RFC-correct &lt;code&gt;\r\n&lt;/code&gt; 대신 표준 Python &lt;code&gt;\n&lt;/code&gt; 줄 끝을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="6eefcaafe768844d20d2285a9ea781eccd2b0ead" translate="yes" xml:space="preserve">
          <source>An int containing the default buffer size used by the module&amp;rsquo;s buffered I/O classes. &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; uses the file&amp;rsquo;s blksize (as obtained by &lt;a href=&quot;os#os.stat&quot;&gt;&lt;code&gt;os.stat()&lt;/code&gt;&lt;/a&gt;) if possible.</source>
          <target state="translated">모듈의 버퍼 된 I / O 클래스에서 사용하는 기본 버퍼 크기를 포함하는 int입니다. &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 은 가능한 경우 파일의 blksize를 사용합니다 ( &lt;a href=&quot;os#os.stat&quot;&gt; &lt;code&gt;os.stat()&lt;/code&gt; &lt;/a&gt; 얻은대로 ).</target>
        </trans-unit>
        <trans-unit id="6753a22067c075c8c9a4c5a84ef7830915742ad2" translate="yes" xml:space="preserve">
          <source>An integer between zero and the number of tabs</source>
          <target state="translated">0과 탭 수 사이의 정수</target>
        </trans-unit>
        <trans-unit id="645936da5c83c45f9587c17d8b318b09bd721e60" translate="yes" xml:space="preserve">
          <source>An integer containing the number of characters written to the stream before it blocked. This attribute is available when using the buffered I/O classes from the &lt;a href=&quot;io#module-io&quot;&gt;&lt;code&gt;io&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">스트림하기 전에 스트림에 쓴 문자 수를 포함하는 정수입니다. 이 속성은 &lt;a href=&quot;io#module-io&quot;&gt; &lt;code&gt;io&lt;/code&gt; &lt;/a&gt; 모듈 에서 버퍼 된 I / O 클래스를 사용할 때 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f40b0022f33627acc9876d1e86f6750f237785b" translate="yes" xml:space="preserve">
          <source>An integer giving the maximum value a variable of type &lt;code&gt;Py_ssize_t&lt;/code&gt; can take. It&amp;rsquo;s usually &lt;code&gt;2**31 - 1&lt;/code&gt; on a 32-bit platform and &lt;code&gt;2**63 - 1&lt;/code&gt; on a 64-bit platform.</source>
          <target state="translated">&lt;code&gt;Py_ssize_t&lt;/code&gt; 유형의 변수에 사용할 수 있는 최대 값을 제공하는 정수 입니다. 일반적으로 32 비트 플랫폼에서는 &lt;code&gt;2**31 - 1&lt;/code&gt; 이고 64 비트 플랫폼에서는 &lt;code&gt;2**63 - 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b4f6a82aa8fc81a2e88d2ec14a5abf2c015f9ab5" translate="yes" xml:space="preserve">
          <source>An integer giving the number of sub keys this key has.</source>
          <target state="translated">이 키가 가진 하위 키 수를 제공하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="e3671820be7fdb3b8d7153be88789dda60eca34a" translate="yes" xml:space="preserve">
          <source>An integer giving the number of values this key has.</source>
          <target state="translated">이 키의 값을 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="61158287398e3913556fd8de17d987f121a49ce2" translate="yes" xml:space="preserve">
          <source>An integer giving the registry type for this value (see table in docs for &lt;a href=&quot;#winreg.SetValueEx&quot;&gt;&lt;code&gt;SetValueEx()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">이 값의 레지스트리 유형을 제공하는 정수입니다 ( &lt;a href=&quot;#winreg.SetValueEx&quot;&gt; &lt;code&gt;SetValueEx()&lt;/code&gt; &lt;/a&gt; 대한 문서는 표 참조 ).</target>
        </trans-unit>
        <trans-unit id="9c4fb4071cc7728855d3b16ff06baa25bc7f67a5" translate="yes" xml:space="preserve">
          <source>An integer giving the value of the largest Unicode code point, i.e. &lt;code&gt;1114111&lt;/code&gt; (&lt;code&gt;0x10FFFF&lt;/code&gt; in hexadecimal).</source>
          <target state="translated">가장 큰 유니 코드 코드 포인트의 값 ( 예 : &lt;code&gt;1114111&lt;/code&gt; ( 16 진의 &lt;code&gt;0x10FFFF&lt;/code&gt; ))을 제공하는 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="70ed9451b9be56604da549be2ff4d27c0a823db6" translate="yes" xml:space="preserve">
          <source>An integer giving when the key was last modified (if available) as 100&amp;rsquo;s of nanoseconds since Jan 1, 1601.</source>
          <target state="translated">1601 년 1 월 1 일 이후로 키가 마지막으로 수정되었을 때 (가능한 경우) 100 초의 나노초로 제공되는 정수.</target>
        </trans-unit>
        <trans-unit id="17b0fef7eb70950fd1875b2099b192af05f223df" translate="yes" xml:space="preserve">
          <source>An integer indicating how many dimensions of a multi-dimensional array the memory represents.</source>
          <target state="translated">메모리가 나타내는 다차원 배열의 차원 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="8bef0117d73063c1a4d56593cf70e5fec7f031c6" translate="yes" xml:space="preserve">
          <source>An integer keeping track of how many times the mock object has been awaited.</source>
          <target state="translated">모의 객체가 몇 번이나 대기했는지를 추적하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ae0518f4d7529a2d85bc7601acec4302104bbbbb" translate="yes" xml:space="preserve">
          <source>An integer n, specifying the nth data column.</source>
          <target state="translated">n 번째 데이터 열을 지정하는 정수 n.</target>
        </trans-unit>
        <trans-unit id="b0d279e661a8927158d65f021e9f995b44d56314" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 16, big-endian.</source>
          <target state="translated">길이가 16 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 (big-endian) 로 채워진 정수 입니다.</target>
        </trans-unit>
        <trans-unit id="646e733efcef9696eb9443aa091caa22bf73aa29" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 16, big-endian. The interpretation is similar to an integer &lt;em&gt;address&lt;/em&gt;.</source>
          <target state="translated">길이가 16 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체 (big-endian) 로 채워진 정수 해석은 정수 &lt;em&gt;주소&lt;/em&gt; 와 유사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f5ca0496bffcd3b5349fb91457405154481dd3" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 4 (most significant octet first).</source>
          <target state="translated">길이가 4 인 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 오브젝트에 채워진 정수 (가장 중요한 옥텟 우선).</target>
        </trans-unit>
        <trans-unit id="64aac0469b4285c7ace562fb45219c88f4d45beb" translate="yes" xml:space="preserve">
          <source>An integer packed into a &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object of length 4, big-endian. The interpretation is similar to an integer &lt;em&gt;address&lt;/em&gt;.</source>
          <target state="translated">길이 4, 빅 엔디안 의 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 채워진 정수 입니다. 해석은 정수 &lt;em&gt;주소&lt;/em&gt; 와 유사 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="882a8de446fcecf6cab8bc081fa438fcd87c37bf" translate="yes" xml:space="preserve">
          <source>An integer preceded by &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;@6&lt;/code&gt;, where the integer is interpreted as a y pixel coordinate in the menu&amp;rsquo;s coordinate system;</source>
          <target state="translated">&lt;code&gt;@6&lt;/code&gt; 에서와 같이 &lt;code&gt;@&lt;/code&gt; 앞에 오는 정수 . 여기서 정수는 메뉴의 좌표계에서 y 픽셀 좌표로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="dc8c87923a15988fabf3c441c9e1307e478e6d10" translate="yes" xml:space="preserve">
          <source>An integer representing the node type. Symbolic constants for the types are on the &lt;code&gt;Node&lt;/code&gt; object: &lt;code&gt;ELEMENT_NODE&lt;/code&gt;, &lt;code&gt;ATTRIBUTE_NODE&lt;/code&gt;, &lt;code&gt;TEXT_NODE&lt;/code&gt;, &lt;code&gt;CDATA_SECTION_NODE&lt;/code&gt;, &lt;code&gt;ENTITY_NODE&lt;/code&gt;, &lt;code&gt;PROCESSING_INSTRUCTION_NODE&lt;/code&gt;, &lt;code&gt;COMMENT_NODE&lt;/code&gt;, &lt;code&gt;DOCUMENT_NODE&lt;/code&gt;, &lt;code&gt;DOCUMENT_TYPE_NODE&lt;/code&gt;, &lt;code&gt;NOTATION_NODE&lt;/code&gt;. This is a read-only attribute.</source>
          <target state="translated">노드 유형을 나타내는 정수 유형에 대한 기호 상수는에있는 &lt;code&gt;Node&lt;/code&gt; 객체 : &lt;code&gt;ELEMENT_NODE&lt;/code&gt; , &lt;code&gt;ATTRIBUTE_NODE&lt;/code&gt; , &lt;code&gt;TEXT_NODE&lt;/code&gt; , &lt;code&gt;CDATA_SECTION_NODE&lt;/code&gt; , &lt;code&gt;ENTITY_NODE&lt;/code&gt; , &lt;code&gt;PROCESSING_INSTRUCTION_NODE&lt;/code&gt; , &lt;code&gt;COMMENT_NODE&lt;/code&gt; , &lt;code&gt;DOCUMENT_NODE&lt;/code&gt; , &lt;code&gt;DOCUMENT_TYPE_NODE&lt;/code&gt; , &lt;code&gt;NOTATION_NODE&lt;/code&gt; . 이것은 읽기 전용 속성입니다.</target>
        </trans-unit>
        <trans-unit id="f1a555fc41c7502bfba0c65b97ab4ac5b9cd080b" translate="yes" xml:space="preserve">
          <source>An integer representing the set of SSL options enabled on this context. The default value is &lt;a href=&quot;#ssl.OP_ALL&quot;&gt;&lt;code&gt;OP_ALL&lt;/code&gt;&lt;/a&gt;, but you can specify other options such as &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt;&lt;code&gt;OP_NO_SSLv2&lt;/code&gt;&lt;/a&gt; by ORing them together.</source>
          <target state="translated">이 컨텍스트에서 사용 가능한 SSL 옵션 세트를 나타내는 정수입니다. 기본값은 &lt;a href=&quot;#ssl.OP_ALL&quot;&gt; &lt;code&gt;OP_ALL&lt;/code&gt; &lt;/a&gt; 이지만 &lt;a href=&quot;#ssl.OP_NO_SSLv2&quot;&gt; &lt;code&gt;OP_NO_SSLv2&lt;/code&gt; &lt;/a&gt; 와 같은 다른 옵션을 함께 OR하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e38281ba09868abdfe8882473c5fa3690e426a3" translate="yes" xml:space="preserve">
          <source>An integer representing the version of the NNTP protocol supported by the server. In practice, this should be &lt;code&gt;2&lt;/code&gt; for servers advertising &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC 3977&lt;/strong&gt;&lt;/a&gt; compliance and &lt;code&gt;1&lt;/code&gt; for others.</source>
          <target state="translated">서버에서 지원하는 NNTP 프로토콜 버전을 나타내는 정수입니다. 실제로,이 있어야한다 &lt;code&gt;2&lt;/code&gt; 광고 서버에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc3977.html&quot; id=&quot;index-5&quot;&gt;&lt;strong&gt;RFC에게 3977&lt;/strong&gt;&lt;/a&gt; 준수 및 &lt;code&gt;1&lt;/code&gt; 다른 사람을.</target>
        </trans-unit>
        <trans-unit id="543f543f7b3326e3df52c58c046ecc3ca49dcfe2" translate="yes" xml:space="preserve">
          <source>An integer telling you how many times the mock object has been called:</source>
          <target state="translated">모의 객체가 몇 번이나 호출되었는지를 알려주는 정수 :</target>
        </trans-unit>
        <trans-unit id="187f154843eb20b15b663f5ef77b74ffa766be88" translate="yes" xml:space="preserve">
          <source>An integer that fits into 128 bits.</source>
          <target state="translated">128 비트에 맞는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4243e776fd6616aba00dbcc2c2488ad7be2afc37" translate="yes" xml:space="preserve">
          <source>An integer that fits into 128 bits. This is equivalent to a single-address network, with the network address being &lt;em&gt;address&lt;/em&gt; and the mask being &lt;code&gt;/128&lt;/code&gt;.</source>
          <target state="translated">128 비트에 맞는 정수입니다. 이는 네트워크 주소가 &lt;em&gt;주소&lt;/em&gt; 이고 마스크가 &lt;code&gt;/128&lt;/code&gt; 인 단일 주소 네트워크와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="44316d770fca56bd5eaaf3a3511c5ee64cecdc22" translate="yes" xml:space="preserve">
          <source>An integer that fits into 32 bits.</source>
          <target state="translated">32 비트에 맞는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="ecdd55c3c245e5b3b8388fa54918c20b35e6e67f" translate="yes" xml:space="preserve">
          <source>An integer that fits into 32 bits. This is equivalent to a single-address network, with the network address being &lt;em&gt;address&lt;/em&gt; and the mask being &lt;code&gt;/32&lt;/code&gt;.</source>
          <target state="translated">32 비트에 맞는 정수입니다. 이는 네트워크 주소가 &lt;em&gt;주소&lt;/em&gt; 이고 마스크가 &lt;code&gt;/32&lt;/code&gt; 인 단일 주소 네트워크와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a078dc74c1c703bd1abf51f26bcdd05ff58dc2cc" translate="yes" xml:space="preserve">
          <source>An integer that identifies the type of the value data (see table in docs for &lt;a href=&quot;#winreg.SetValueEx&quot;&gt;&lt;code&gt;SetValueEx()&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">값 데이터의 유형을 식별하는 정수 ( &lt;a href=&quot;#winreg.SetValueEx&quot;&gt; &lt;code&gt;SetValueEx()&lt;/code&gt; &lt;/a&gt; 대한 문서는 표 참조 )</target>
        </trans-unit>
        <trans-unit id="6221568d61a57ce1a59e1d75f271d5b94fd58a61" translate="yes" xml:space="preserve">
          <source>An integer, the default &lt;a href=&quot;#pickle-protocols&quot;&gt;protocol version&lt;/a&gt; used for pickling. May be less than &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt;&lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt;&lt;/a&gt;. Currently the default protocol is 4, first introduced in Python 3.4 and incompatible with previous versions.</source>
          <target state="translated">산세에 사용되는 기본 &lt;a href=&quot;#pickle-protocols&quot;&gt;프로토콜 버전&lt;/a&gt; 인 정수 입니다. &lt;a href=&quot;#pickle.HIGHEST_PROTOCOL&quot;&gt; &lt;code&gt;HIGHEST_PROTOCOL&lt;/code&gt; &lt;/a&gt; 보다 작을 수 있습니다 . 현재 기본 프로토콜은 4이며, Python 3.4에서 처음 도입되었으며 이전 버전과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b3ff29ab8afde8b6ee23d29bb72e09168c7b6f37" translate="yes" xml:space="preserve">
          <source>An integer, the highest &lt;a href=&quot;#pickle-protocols&quot;&gt;protocol version&lt;/a&gt; available. This value can be passed as a &lt;em&gt;protocol&lt;/em&gt; value to functions &lt;a href=&quot;#pickle.dump&quot;&gt;&lt;code&gt;dump()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#pickle.dumps&quot;&gt;&lt;code&gt;dumps()&lt;/code&gt;&lt;/a&gt; as well as the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">사용 가능한 최고 &lt;a href=&quot;#pickle-protocols&quot;&gt;프로토콜 버전&lt;/a&gt; 인 정수 입니다. 이 값은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 뿐만 아니라 함수 &lt;a href=&quot;#pickle.dump&quot;&gt; &lt;code&gt;dump()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#pickle.dumps&quot;&gt; &lt;code&gt;dumps()&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 프로토콜&lt;/em&gt; 값 으로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="89f7acaa85bea0ee87dbe1ef47defa1dd89b2cca" translate="yes" xml:space="preserve">
          <source>An interface to the group database, similar to this.</source>
          <target state="translated">이와 유사한 그룹 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="59cb6ef37b0cd57060129e4c5a383119176babe9" translate="yes" xml:space="preserve">
          <source>An interface to the normal password database, similar to this.</source>
          <target state="translated">이와 유사한 일반 비밀번호 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="23aa9ac5ddca3f3d883d5cc83284856548229022" translate="yes" xml:space="preserve">
          <source>An interface to the shadow password database, similar to this.</source>
          <target state="translated">이와 유사한 섀도 비밀번호 데이터베이스에 대한 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="994fe15ee3ca3aa04c018a8fe65a5d200d8e16aa" translate="yes" xml:space="preserve">
          <source>An interface to the user database, similar to this.</source>
          <target state="translated">이와 유사한 사용자 데이터베이스 인터페이스.</target>
        </trans-unit>
        <trans-unit id="8d1844ce395b8e9fdc98c2cc653690def38555f0" translate="yes" xml:space="preserve">
          <source>An interpreter instance will recognize a command name &lt;code&gt;foo&lt;/code&gt; if and only if it has a method &lt;code&gt;do_foo()&lt;/code&gt;. As a special case, a line beginning with the character &lt;code&gt;'?'&lt;/code&gt; is dispatched to the method &lt;code&gt;do_help()&lt;/code&gt;. As another special case, a line beginning with the character &lt;code&gt;'!'&lt;/code&gt; is dispatched to the method &lt;code&gt;do_shell()&lt;/code&gt; (if such a method is defined).</source>
          <target state="translated">인터프리터 인스턴스는 &lt;code&gt;do_foo()&lt;/code&gt; 메소드가있는 경우에만 명령 이름 &lt;code&gt;foo&lt;/code&gt; 를 인식합니다 . 특별한 경우, 문자 &lt;code&gt;'?'&lt;/code&gt; 로 시작하는 줄 &lt;code&gt;do_help()&lt;/code&gt; 메소드로 전달됩니다 . 또 다른 특별한 경우로, 문자 &lt;code&gt;'!'&lt;/code&gt; 로 시작하는 줄 &lt;code&gt;do_shell()&lt;/code&gt; 메소드로 전달됩니다 (이러한 메소드가 정의 된 경우).</target>
        </trans-unit>
        <trans-unit id="a6fc8b26e70e09d313612cac6794fdb4aad1682f" translate="yes" xml:space="preserve">
          <source>An invalid logger name.</source>
          <target state="translated">잘못된 로거 이름입니다.</target>
        </trans-unit>
        <trans-unit id="74a940fd099263dda413cd8757526ef0956f8af4" translate="yes" xml:space="preserve">
          <source>An invalid operation was performed.</source>
          <target state="translated">유효하지 않은 작업이 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a26e16375583adf85ddeccaecb2b8c4ef50d837" translate="yes" xml:space="preserve">
          <source>An object containing information about the implementation of the currently running Python interpreter. The following attributes are required to exist in all Python implementations.</source>
          <target state="translated">현재 실행중인 Python 인터프리터의 구현에 대한 정보가 포함 된 객체입니다. 모든 Python 구현에 다음 속성이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="998e5eccbd293e12c5532b4dc44ce7656abeec0b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;a href=&quot;#datetime.time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; may be aware or naive.</source>
          <target state="translated">&lt;a href=&quot;#datetime.time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 유형의 오브젝트는 인식하거나 순진 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b174b298545e9f1f9dff3565076e2ed782564e88" translate="yes" xml:space="preserve">
          <source>An object that holds the value data, and whose type depends on the underlying registry type</source>
          <target state="translated">값 데이터를 보유하고 유형이 기본 레지스트리 유형에 따라 달라지는 오브젝트</target>
        </trans-unit>
        <trans-unit id="97080ae4ed5d803c9b0a23c71de971dafd14c52c" translate="yes" xml:space="preserve">
          <source>An object that wraps OS processes created by the &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; functions.</source>
          <target state="translated">&lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 함수로 생성 된 OS 프로세스를 래핑하는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="6159e0ee946985cc1c35519ceaa4c338a8e80214" translate="yes" xml:space="preserve">
          <source>An object with a subset of pathlib.Path methods suitable for traversing directories and opening files.</source>
          <target state="translated">디렉토리를 탐색하고 파일을 여는 데 적합한 pathlib.Path 메서드의 하위 집합이있는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="647c7a24d6cf9ebcbec2e05257e54cb377032a7a" translate="yes" xml:space="preserve">
          <source>An object with at least two methods: get_content and set_content. When the &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt;&lt;code&gt;get_content()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt;&lt;code&gt;set_content()&lt;/code&gt;&lt;/a&gt; method of an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object is called, it calls the corresponding method of this object, passing it the message object as its first argument, and any arguments or keywords that were passed to it as additional arguments. By default &lt;code&gt;content_manager&lt;/code&gt; is set to &lt;a href=&quot;email.contentmanager#email.contentmanager.raw_data_manager&quot;&gt;&lt;code&gt;raw_data_manager&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">get_content 및 set_content 두 가지 이상의 메소드가있는 오브젝트입니다. 때 &lt;a href=&quot;email.message#email.message.EmailMessage.get_content&quot;&gt; &lt;code&gt;get_content()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;email.message#email.message.EmailMessage.set_content&quot;&gt; &lt;code&gt;set_content()&lt;/code&gt; &lt;/a&gt; 방법 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 의&lt;/a&gt; 객체가 호출 될 때, 그것의 첫 번째 인수로에게 메시지 객체를 전달,이 오브젝트의 해당 메소드를 호출하고, 추가 인수로 전달 된 인수 또는 키워드. 기본적으로 &lt;code&gt;content_manager&lt;/code&gt; 는 &lt;a href=&quot;email.contentmanager#email.contentmanager.raw_data_manager&quot;&gt; &lt;code&gt;raw_data_manager&lt;/code&gt; &lt;/a&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1865264489923958e5df1f2c9473facc3252cce6" translate="yes" xml:space="preserve">
          <source>An operation was requested that requires DTD support to be compiled in, but Expat was configured without DTD support. This should never be reported by a standard build of the &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt;&lt;code&gt;xml.parsers.expat&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">DTD 지원을 컴파일해야하는 작업이 요청되었지만 Expat은 DTD 지원없이 구성되었습니다. &lt;a href=&quot;#module-xml.parsers.expat&quot;&gt; &lt;code&gt;xml.parsers.expat&lt;/code&gt; &lt;/a&gt; 모듈 의 표준 빌드에서보고해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="4947a546c6d3f34597067ace626c8f1253938be2" translate="yes" xml:space="preserve">
          <source>An optional keyword-only &lt;em&gt;context&lt;/em&gt; argument allows specifying a custom &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; for the &lt;em&gt;callback&lt;/em&gt; to run in. The current context is used when no &lt;em&gt;context&lt;/em&gt; is provided.</source>
          <target state="translated">선택적 키워드 전용 &lt;em&gt;컨텍스트&lt;/em&gt; 인수를 사용 하면 &lt;em&gt;콜백&lt;/em&gt; 을 실행할 사용자 정의 &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; &lt;/a&gt; 를 지정할 수 있습니다 . &lt;em&gt;컨텍스트&lt;/em&gt; 가 제공 되지 않으면 현재 컨텍스트가 사용됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ea3a8a5b272ed84ab311819ca2985d04005ee2d" translate="yes" xml:space="preserve">
          <source>An optional method which, when called, should invalidate any internal cache used by the finder. Used by &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt;&lt;code&gt;importlib.invalidate_caches()&lt;/code&gt;&lt;/a&gt; when invalidating the caches of all finders on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호출 될 때 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메소드입니다. &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 의 모든 파인더 캐시를 무효화 할 때 &lt;a href=&quot;#importlib.invalidate_caches&quot;&gt; &lt;code&gt;importlib.invalidate_caches()&lt;/code&gt; &lt;/a&gt; 의해 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9077f55d2b0b62326a8204fc9578f269c9e7d89a" translate="yes" xml:space="preserve">
          <source>An optional method which, when called, should invalidate any internal cache used by the finder. Used by &lt;code&gt;PathFinder.invalidate_caches()&lt;/code&gt; when invalidating the caches of all cached finders.</source>
          <target state="translated">호출 될 때 파인더가 사용하는 내부 캐시를 무효화해야하는 선택적 메소드입니다. 캐시 된 모든 파인더의 캐시를 무효화 할 때 &lt;code&gt;PathFinder.invalidate_caches()&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="1c77488f2592943bd451545ce7ed54c2b1a12d3c" translate="yes" xml:space="preserve">
          <source>An optional sequence that lists the names of unnamed (anonymous) fields. &lt;a href=&quot;#ctypes.Structure._anonymous_&quot;&gt;&lt;code&gt;_anonymous_&lt;/code&gt;&lt;/a&gt; must be already defined when &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; is assigned, otherwise it will have no effect.</source>
          <target state="translated">이름이없는 (익명) 필드의 이름을 나열하는 선택적 순서입니다. &lt;a href=&quot;#ctypes.Structure._anonymous_&quot;&gt; &lt;code&gt;_anonymous_&lt;/code&gt; &lt;/a&gt; 가 할당 될 때 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 가 이미 정의되어 있어야합니다 . 그렇지 않으면 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b40583112592749895ecadcf35532f5fbb351912" translate="yes" xml:space="preserve">
          <source>An optional shebang line, containing the characters &lt;code&gt;b'#!'&lt;/code&gt; followed by an interpreter name, and then a newline (&lt;code&gt;b'\n'&lt;/code&gt;) character. The interpreter name can be anything acceptable to the OS &amp;ldquo;shebang&amp;rdquo; processing, or the Python launcher on Windows. The interpreter should be encoded in UTF-8 on Windows, and in &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt;&lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt;&lt;/a&gt; on POSIX.</source>
          <target state="translated">문자 &lt;code&gt;b'#!'&lt;/code&gt; 포함하는 선택적인 shebang 행 뒤에 인터프리터 이름과 개행 문자 ( &lt;code&gt;b'\n'&lt;/code&gt; )가 옵니다 . 인터프리터 이름은 OS&amp;ldquo;shebang&amp;rdquo;처리 또는 Windows의 Python 실행기에 허용되는 이름 일 수 있습니다. 인터프리터는 Windows에서는 UTF-8로, POSIX 에서는 &lt;a href=&quot;sys#sys.getfilesystemencoding&quot;&gt; &lt;code&gt;sys.getfilesystemencoding()&lt;/code&gt; &lt;/a&gt; 으로 인코딩해야합니다 .</target>
        </trans-unit>
        <trans-unit id="eadbfe27c0b9f4036e4c5d9ffd152ecaddfb607d" translate="yes" xml:space="preserve">
          <source>An optional small integer that allows overriding the alignment of structure fields in the instance. &lt;a href=&quot;#ctypes.Structure._pack_&quot;&gt;&lt;code&gt;_pack_&lt;/code&gt;&lt;/a&gt; must already be defined when &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt;&lt;code&gt;_fields_&lt;/code&gt;&lt;/a&gt; is assigned, otherwise it will have no effect.</source>
          <target state="translated">인스턴스에서 구조 필드의 정렬을 재정의 할 수있는 선택적 작은 정수입니다. &lt;a href=&quot;#ctypes.Structure._pack_&quot;&gt; &lt;code&gt;_pack_&lt;/code&gt; &lt;/a&gt; 가 지정 되면 &lt;a href=&quot;#ctypes.Structure._fields_&quot;&gt; &lt;code&gt;_fields_&lt;/code&gt; &lt;/a&gt; 이 이미 정의되어 있어야합니다 . 그렇지 않으면 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79293485a901f4be4341911a3c3007d1e643a627" translate="yes" xml:space="preserve">
          <source>An ordered enumeration that is not based on &lt;a href=&quot;#enum.IntEnum&quot;&gt;&lt;code&gt;IntEnum&lt;/code&gt;&lt;/a&gt; and so maintains the normal &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; invariants (such as not being comparable to other enumerations):</source>
          <target state="translated">&lt;a href=&quot;#enum.IntEnum&quot;&gt; &lt;code&gt;IntEnum&lt;/code&gt; 을&lt;/a&gt; 기반으로하지 않기 때문에 일반적인 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; &lt;/a&gt; 불변량을 유지 하는 순서가 지정된 열거 형 (예 : 다른 열거 형과 비교할 수 없음) :</target>
        </trans-unit>
        <trans-unit id="a54eaeb427bd767e9c78a3fcf6309d624d005ab3" translate="yes" xml:space="preserve">
          <source>An ordered mapping of parameters&amp;rsquo; names to the corresponding &lt;a href=&quot;#inspect.Parameter&quot;&gt;&lt;code&gt;Parameter&lt;/code&gt;&lt;/a&gt; objects. Parameters appear in strict definition order, including keyword-only parameters.</source>
          <target state="translated">매개 변수 이름을 해당 &lt;a href=&quot;#inspect.Parameter&quot;&gt; &lt;code&gt;Parameter&lt;/code&gt; &lt;/a&gt; 객체에 순서대로 매핑 합니다. 키워드 전용 매개 변수를 포함하여 매개 변수가 엄격한 정의 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e73d51218d474d87723969e9844e08e443986117" translate="yes" xml:space="preserve">
          <source>An ordered, mutable mapping (&lt;a href=&quot;collections#collections.OrderedDict&quot;&gt;&lt;code&gt;collections.OrderedDict&lt;/code&gt;&lt;/a&gt;) of parameters&amp;rsquo; names to arguments&amp;rsquo; values. Contains only explicitly bound arguments. Changes in &lt;a href=&quot;#inspect.BoundArguments.arguments&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;/a&gt; will reflect in &lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt;&lt;code&gt;args&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt;&lt;code&gt;kwargs&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">매개 변수 이름과 인수 값 의 순서가 변경 가능한 맵핑 ( &lt;a href=&quot;collections#collections.OrderedDict&quot;&gt; &lt;code&gt;collections.OrderedDict&lt;/code&gt; &lt;/a&gt; ) 명시 적으로 바인딩 된 인수 만 포함합니다. &lt;a href=&quot;#inspect.BoundArguments.arguments&quot;&gt; &lt;code&gt;arguments&lt;/code&gt; &lt;/a&gt; 변화는 &lt;a href=&quot;#inspect.BoundArguments.args&quot;&gt; &lt;code&gt;args&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#inspect.BoundArguments.kwargs&quot;&gt; &lt;code&gt;kwargs&lt;/code&gt; 에&lt;/a&gt; 반영됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b5b35b74ba6101747c9d4196b50ff8061dcc151" translate="yes" xml:space="preserve">
          <source>An output filename must be specified if the &lt;em&gt;source&lt;/em&gt; is an archive (and in that case, &lt;em&gt;output&lt;/em&gt; must not be the same as &lt;em&gt;source&lt;/em&gt;).</source>
          <target state="translated">&lt;em&gt;소스&lt;/em&gt; 가 아카이브 인 경우 출력 파일 이름을 지정해야합니다 (이 경우 &lt;em&gt;출력&lt;/em&gt; 은 &lt;em&gt;source&lt;/em&gt; 와 동일하지 않아야 함 ).</target>
        </trans-unit>
        <trans-unit id="521aa7e611225a521017270940523db0f976f977" translate="yes" xml:space="preserve">
          <source>An undeclared prefix was found when namespace processing was enabled.</source>
          <target state="translated">네임 스페이스 처리가 활성화되었을 때 선언되지 않은 접두사가 발견되었습니다.</target>
        </trans-unit>
        <trans-unit id="9656bc89a24603fa1dca440ac3a2361066df5ac5" translate="yes" xml:space="preserve">
          <source>An unrelated but handy function that takes a time tuple such as returned by the &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;gmtime()&lt;/code&gt;&lt;/a&gt; function in the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module, and returns the corresponding Unix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In fact, &lt;a href=&quot;time#time.gmtime&quot;&gt;&lt;code&gt;time.gmtime()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#calendar.timegm&quot;&gt;&lt;code&gt;timegm()&lt;/code&gt;&lt;/a&gt; are each others&amp;rsquo; inverse.</source>
          <target state="translated">&lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;gmtime()&lt;/code&gt; &lt;/a&gt; 함수에 의해 리턴되는 것과 같이 시간 튜플을 취하고 1970 년의 에포크 (epoch) 및 POSIX 인코딩을 가정하여 해당 Unix 타임 스탬프 값을 리턴 하는 관련이없는 편리한 함수입니다 . 실제로 &lt;a href=&quot;time#time.gmtime&quot;&gt; &lt;code&gt;time.gmtime()&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#calendar.timegm&quot;&gt; &lt;code&gt;timegm()&lt;/code&gt; &lt;/a&gt; 은 서로의 역수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0de6a3a36da0eabd1ed37cb78f0a84df8288d5" translate="yes" xml:space="preserve">
          <source>Analyse the bytecode corresponding to a function, generator, asynchronous generator, coroutine, method, string of source code, or a code object (as returned by &lt;a href=&quot;functions#compile&quot;&gt;&lt;code&gt;compile()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">함수, 생성기, 비동기 생성기, 코 루틴, 메소드, 소스 코드 문자열 또는 코드 오브젝트 ( &lt;a href=&quot;functions#compile&quot;&gt; &lt;code&gt;compile()&lt;/code&gt; &lt;/a&gt; 의해 리턴 됨 )에 해당하는 바이트 코드를 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="819da723c3c425f237bdf8f03b696821a94f3e1f" translate="yes" xml:space="preserve">
          <source>Analysis functions</source>
          <target state="translated">분석 기능</target>
        </trans-unit>
        <trans-unit id="975f7b4df518f323a30297a1f1be4e096d3fcec3" translate="yes" xml:space="preserve">
          <source>Analysis of the profiler data is done using the &lt;a href=&quot;#pstats.Stats&quot;&gt;&lt;code&gt;Stats&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">프로파일 러 데이터의 분석은 &lt;a href=&quot;#pstats.Stats&quot;&gt; &lt;code&gt;Stats&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="25ad53cf48f04b7c123150cc524cc9d87c444927" translate="yes" xml:space="preserve">
          <source>Analyze the contents of the &lt;em&gt;pathname&lt;/em&gt; file, which must contain Python code.</source>
          <target state="translated">Python 코드를 포함해야하는 &lt;em&gt;경로 이름&lt;/em&gt; 파일 의 내용을 분석하십시오 .</target>
        </trans-unit>
        <trans-unit id="4623f537e597cbfacf24dc615db20b47e0e3c5c7" translate="yes" xml:space="preserve">
          <source>Analyze the given &lt;em&gt;sample&lt;/em&gt; and return a &lt;a href=&quot;#csv.Dialect&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt; subclass reflecting the parameters found. If the optional &lt;em&gt;delimiters&lt;/em&gt; parameter is given, it is interpreted as a string containing possible valid delimiter characters.</source>
          <target state="translated">주어진 &lt;em&gt;샘플을&lt;/em&gt; 분석하고 발견 된 매개 변수를 반영 하는 &lt;a href=&quot;#csv.Dialect&quot;&gt; &lt;code&gt;Dialect&lt;/code&gt; &lt;/a&gt; 서브 클래스를 반환합니다 . 선택적 &lt;em&gt;분리 문자&lt;/em&gt; 매개 변수가 제공되면 유효한 분리 문자를 포함하는 문자열로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="d3c77624248a182e0208b43d1dd511b74c035283" translate="yes" xml:space="preserve">
          <source>Analyze the sample text (presumed to be in CSV format) and return &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if the first row appears to be a series of column headers.</source>
          <target state="translated">샘플 텍스트 (CSV 형식으로 추정)를 분석하고 첫 번째 행이 일련의 열 머리글 인 경우 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; 를&lt;/a&gt; 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b15cefd38640764e47311aa1a3c3174217ea802b" translate="yes" xml:space="preserve">
          <source>Anchor type. Denotes where the packer is to place each slave in its parcel.</source>
          <target state="translated">앵커 타입. 패커가 각 슬레이브를 해당 소포에 배치 할 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8a680a6b219fde5428a49a155c5016f2f6534116" translate="yes" xml:space="preserve">
          <source>And also as a function decorator:</source>
          <target state="translated">또한 함수 데코레이터로서 :</target>
        </trans-unit>
        <trans-unit id="e25b174a26dc77d7bd4c171e7b788567380cfcad" translate="yes" xml:space="preserve">
          <source>And for reading files:</source>
          <target state="translated">그리고 파일을 읽는 경우 :</target>
        </trans-unit>
        <trans-unit id="8ea4f6d1b5164f1de2cd6425075d887c2f52dc7b" translate="yes" xml:space="preserve">
          <source>And go back to listening for new client connections (of course, a real server would probably handle each client connection in a separate thread, or put the sockets in &lt;a href=&quot;#ssl-nonblocking&quot;&gt;non-blocking mode&lt;/a&gt; and use an event loop).</source>
          <target state="translated">그리고 새로운 클라이언트 연결 수신으로 돌아가십시오 (물론 실제 서버는 각 클라이언트 연결을 별도의 스레드에서 처리하거나 소켓을 &lt;a href=&quot;#ssl-nonblocking&quot;&gt;비 블로킹 모드로 설정&lt;/a&gt; 하고 이벤트 루프를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="e01a2b18c0aa33d0bf1ebb4b61f24aa85532e4a4" translate="yes" xml:space="preserve">
          <source>And lets you write code like this:</source>
          <target state="translated">그리고 다음과 같은 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02c80b8291de4e65f0384d5df0e931faa6f06e26" translate="yes" xml:space="preserve">
          <source>And so on, eventually ending with:</source>
          <target state="translated">그리고 결국은 다음과 같이 끝납니다.</target>
        </trans-unit>
        <trans-unit id="56675d3775ea977079a196ffe5d39d5c6e0ed45d" translate="yes" xml:space="preserve">
          <source>And some mathematical functions are also available to Decimal:</source>
          <target state="translated">Decimal에는 다음과 같은 수학 함수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e030fd6f202d12a04313413b21ce123caf324f74" translate="yes" xml:space="preserve">
          <source>And while the module doesn&amp;rsquo;t directly support parsing strings, it can easily be done:</source>
          <target state="translated">모듈은 문자열 구문 분석을 직접 지원하지 않지만 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29a859de34d8206276e4fbe86c78577ef463680" translate="yes" xml:space="preserve">
          <source>And:</source>
          <target state="translated">And:</target>
        </trans-unit>
        <trans-unit id="5d25066343c14fdbc8cd148ee308e69f694558d6" translate="yes" xml:space="preserve">
          <source>Angular conversion</source>
          <target state="translated">각도 변환</target>
        </trans-unit>
        <trans-unit id="fa955e785130d1bfb76908f175692b42dcf5a748" translate="yes" xml:space="preserve">
          <source>Animation control</source>
          <target state="translated">애니메이션 컨트롤</target>
        </trans-unit>
        <trans-unit id="e17e6aa01f27f483f31ae9a05f633ce17a08ca63" translate="yes" xml:space="preserve">
          <source>Annotate each line with a short opcode description.</source>
          <target state="translated">짧은 opcode 설명으로 각 줄에 주석을 답니다.</target>
        </trans-unit>
        <trans-unit id="c1fbe3f2c0adda2514893a924abcd2d00ba0c968" translate="yes" xml:space="preserve">
          <source>Announces an intention to access data in a specific pattern thus allowing the kernel to make optimizations. The advice applies to the region of the file specified by &lt;em&gt;fd&lt;/em&gt; starting at &lt;em&gt;offset&lt;/em&gt; and continuing for &lt;em&gt;len&lt;/em&gt; bytes. &lt;em&gt;advice&lt;/em&gt; is one of &lt;a href=&quot;#os.POSIX_FADV_NORMAL&quot;&gt;&lt;code&gt;POSIX_FADV_NORMAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_SEQUENTIAL&quot;&gt;&lt;code&gt;POSIX_FADV_SEQUENTIAL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_RANDOM&quot;&gt;&lt;code&gt;POSIX_FADV_RANDOM&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_NOREUSE&quot;&gt;&lt;code&gt;POSIX_FADV_NOREUSE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.POSIX_FADV_WILLNEED&quot;&gt;&lt;code&gt;POSIX_FADV_WILLNEED&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.POSIX_FADV_DONTNEED&quot;&gt;&lt;code&gt;POSIX_FADV_DONTNEED&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">커널이 최적화 할 수 있도록 특정 패턴으로 데이터에 액세스하려는 의도를 나타냅니다. 조언 은 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작하여 &lt;em&gt;len&lt;/em&gt; 바이트 동안 계속되는 &lt;em&gt;fd로&lt;/em&gt; 지정된 파일 영역에 적용됩니다 . &lt;em&gt;권고&lt;/em&gt; 는 &lt;a href=&quot;#os.POSIX_FADV_NORMAL&quot;&gt; &lt;code&gt;POSIX_FADV_NORMAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_SEQUENTIAL&quot;&gt; &lt;code&gt;POSIX_FADV_SEQUENTIAL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_RANDOM&quot;&gt; &lt;code&gt;POSIX_FADV_RANDOM&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_NOREUSE&quot;&gt; &lt;code&gt;POSIX_FADV_NOREUSE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.POSIX_FADV_WILLNEED&quot;&gt; &lt;code&gt;POSIX_FADV_WILLNEED&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.POSIX_FADV_DONTNEED&quot;&gt; &lt;code&gt;POSIX_FADV_DONTNEED&lt;/code&gt; &lt;/a&gt; 중 하나입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="eddbfc47bdf2815567f148a943ae50904ef48c9e" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 16 character salt and 43 character hash based on the SHA-256 hash function.</source>
          <target state="translated">SHA-256 해시 함수를 기반으로 16 자 솔트 및 43 자 해시를 사용하는 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="1489f7e40318e54fcbeae8f12ceaa2e676f89a1d" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 22 character salt and 31 character hash based on the Blowfish cipher.</source>
          <target state="translated">복어 암호를 기반으로 22 문자 소금과 31 문자 해시를 사용하는 또 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="cfaedd99a89f28548596fb67a7f378505de1e4e9" translate="yes" xml:space="preserve">
          <source>Another Modular Crypt Format method with 8 character salt and 22 character hash based on the MD5 hash function.</source>
          <target state="translated">MD5 해시 함수를 기반으로 8 문자 솔트와 22 문자 해시를 사용하는 다른 모듈 식 암호화 형식 방법.</target>
        </trans-unit>
        <trans-unit id="59264d0e98298421242f9f70b711b5e947525220" translate="yes" xml:space="preserve">
          <source>Another approach to handling multiple simultaneous requests in an environment that supports neither threads nor &lt;a href=&quot;os#os.fork&quot;&gt;&lt;code&gt;fork()&lt;/code&gt;&lt;/a&gt; (or where these are too expensive or inappropriate for the service) is to maintain an explicit table of partially finished requests and to use &lt;a href=&quot;selectors#module-selectors&quot;&gt;&lt;code&gt;selectors&lt;/code&gt;&lt;/a&gt; to decide which request to work on next (or whether to handle a new incoming request). This is particularly important for stream services where each client can potentially be connected for a long time (if threads or subprocesses cannot be used). See &lt;a href=&quot;asyncore#module-asyncore&quot;&gt;&lt;code&gt;asyncore&lt;/code&gt;&lt;/a&gt; for another way to manage this.</source>
          <target state="translated">스레드 나 &lt;a href=&quot;os#os.fork&quot;&gt; &lt;code&gt;fork()&lt;/code&gt; &lt;/a&gt; 를 지원하지 않는 환경에서 (또는 서비스에 너무 비싸거나 부적절한 경우 ) 여러 동시 요청을 처리하는 또 다른 방법 은 부분적으로 완료된 요청의 명시적인 테이블을 유지하고 &lt;a href=&quot;selectors#module-selectors&quot;&gt; &lt;code&gt;selectors&lt;/code&gt; &lt;/a&gt; 를 사용 하여 요청을 결정하는 것입니다. 다음에 작업하십시오 (또는 새로운 수신 요청을 처리할지 여부). 이는 스레드 또는 하위 프로세스를 사용할 수없는 경우 각 클라이언트를 오랫동안 연결할 수있는 스트림 서비스에 특히 중요합니다. 이것을 관리하는 다른 방법 은 &lt;a href=&quot;asyncore#module-asyncore&quot;&gt; &lt;code&gt;asyncore&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7a6eaecc1b4becc1ce97180c1ca37fd242427bac" translate="yes" xml:space="preserve">
          <source>Another approach to using deques is to maintain a sequence of recently added elements by appending to the right and popping to the left:</source>
          <target state="translated">deques를 사용하는 또 다른 방법은 오른쪽에 추가하고 왼쪽에 팝하여 최근에 추가 된 요소의 순서를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="154eea36fb4a3e04d9685d308f84e6f97bb356c1" translate="yes" xml:space="preserve">
          <source>Another bad idea is to print things that embed an object address, like</source>
          <target state="translated">또 다른 나쁜 아이디어는 객체 주소를 포함하는 것을 인쇄하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="857365788cdb8b0f09e1949a46fb3dc32e28e350" translate="yes" xml:space="preserve">
          <source>Another client can also use it:</source>
          <target state="translated">다른 클라이언트도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf9dd39551f08b3b4f74c2740c180fe41caccd4b" translate="yes" xml:space="preserve">
          <source>Another example for &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mapping&quot;&gt;mapping&lt;/a&gt; objects, using a &lt;a href=&quot;#dict&quot;&gt;&lt;code&gt;dict&lt;/code&gt;&lt;/a&gt;, which is a generic type expecting two type parameters representing the key type and the value type. In this example, the function expects a &lt;code&gt;dict&lt;/code&gt; with keys of type &lt;a href=&quot;#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; and values of type &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">키 유형과 값 유형을 나타내는 두 개의 유형 매개 변수를 예상하는 제네릭 유형 인 &lt;a href=&quot;#dict&quot;&gt; &lt;code&gt;dict&lt;/code&gt; 를&lt;/a&gt; 사용하여 객체 를 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mapping&quot;&gt;매핑하는&lt;/a&gt; 또 다른 예입니다 . 이 예제에서 함수는 &lt;a href=&quot;#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 유형의 키 와 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 유형의 값이 있는 &lt;code&gt;dict&lt;/code&gt; 를 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="830cb7a34d4e9668c5f056cdbb14f9a43e0de2af" translate="yes" xml:space="preserve">
          <source>Another example of a reusable, but not reentrant, context manager is &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt;, as it invokes &lt;em&gt;all&lt;/em&gt; currently registered callbacks when leaving any with statement, regardless of where those callbacks were added:</source>
          <target state="translated">재사용 가능하지만 재진입 할 ​​수없는 컨텍스트 관리자의 또 다른 예는 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 이며, 콜백이 추가 된 위치에 관계없이 with 문을 떠날 때 현재 등록 된 &lt;em&gt;모든&lt;/em&gt; 콜백을 호출 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="970d45390b614e57c3adbeccf052061f6cbb7027" translate="yes" xml:space="preserve">
          <source>Another example that may behave differently from what one would expect is this:</source>
          <target state="translated">예상했던 것과 다르게 행동 할 수있는 또 다른 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1524e3727b5a15e1e58deafe30417f1f9c6a01f4" translate="yes" xml:space="preserve">
          <source>Another example that uses the &lt;a href=&quot;#shutil.ignore_patterns&quot;&gt;&lt;code&gt;ignore_patterns()&lt;/code&gt;&lt;/a&gt; helper:</source>
          <target state="translated">&lt;a href=&quot;#shutil.ignore_patterns&quot;&gt; &lt;code&gt;ignore_patterns()&lt;/code&gt; &lt;/a&gt; 도우미 를 사용하는 또 다른 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5cd67ff52eb9c7ecece2900a3c7ca5a0e8906891" translate="yes" xml:space="preserve">
          <source>Another example that uses the &lt;em&gt;ignore&lt;/em&gt; argument to add a logging call:</source>
          <target state="translated">&lt;em&gt;ignore&lt;/em&gt; 인수를 사용하여 로깅 호출을 추가하는 다른 예 :</target>
        </trans-unit>
        <trans-unit id="a012876e7eec4d9cf2933f51ae341f5f02747bc6" translate="yes" xml:space="preserve">
          <source>Another function is provided to reverse the tokenization process. This is useful for creating tools that tokenize a script, modify the token stream, and write back the modified script.</source>
          <target state="translated">토큰 화 프로세스를 취소하기위한 다른 기능이 제공됩니다. 이는 스크립트를 토큰 화하고 토큰 스트림을 수정하며 수정 된 스크립트를 다시 작성하는 도구를 작성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1345847ee9d2d8f4b40cf2bd43a2a8f4b81d19c5" translate="yes" xml:space="preserve">
          <source>Another important difference between &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#enum.Enum&quot;&gt;&lt;code&gt;Enum&lt;/code&gt;&lt;/a&gt; is that if no flags are set (the value is 0), its boolean evaluation is &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#enum.Enum&quot;&gt; &lt;code&gt;Enum&lt;/code&gt; 의&lt;/a&gt; 또 다른 중요한 차이점은 플래그가 설정되지 않은 경우 (값이 0 임) 부울 평가는 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bd138c705d1febdcd3cd71c72f455f7d8136282" translate="yes" xml:space="preserve">
          <source>Another option is to pass &lt;a href=&quot;functions#globals&quot;&gt;&lt;code&gt;globals()&lt;/code&gt;&lt;/a&gt; to the &lt;em&gt;globals&lt;/em&gt; parameter, which will cause the code to be executed within your current global namespace. This can be more convenient than individually specifying imports:</source>
          <target state="translated">또 다른 옵션은 &lt;a href=&quot;functions#globals&quot;&gt; &lt;code&gt;globals()&lt;/code&gt; &lt;/a&gt; 를 &lt;em&gt;globals&lt;/em&gt; 매개 변수에 전달하는 것입니다.이 경우 현재 전역 네임 스페이스 내에서 코드가 실행됩니다. 개별적으로 가져 오기를 지정하는 것보다 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="7d89ebe791f42c5af101c46d42ea21377b531087" translate="yes" xml:space="preserve">
          <source>Another similar &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;example&lt;/a&gt; using the high-level &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt;&lt;code&gt;asyncio.open_connection()&lt;/code&gt;&lt;/a&gt; function and streams.</source>
          <target state="translated">고급 &lt;a href=&quot;asyncio-stream#asyncio.open_connection&quot;&gt; &lt;code&gt;asyncio.open_connection()&lt;/code&gt; &lt;/a&gt; 함수 및 스트림을 사용하는 또 다른 유사한 &lt;a href=&quot;asyncio-stream#asyncio-example-create-connection-streams&quot;&gt;예&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b12cf40ba46cdbcdda739851e799c9deed7beda0" translate="yes" xml:space="preserve">
          <source>Another simple application of doctest is testing interactive examples in a text file. This can be done with the &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">doctest의 또 다른 간단한 적용은 텍스트 파일에서 대화식 예제를 테스트하는 것입니다. 이 작업은 수행 할 수 있습니다 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 기능 :</target>
        </trans-unit>
        <trans-unit id="380a1673c02d6ffedb7ef8ccb17de0d7583fd47b" translate="yes" xml:space="preserve">
          <source>Another solution to the problem of non-comparable tasks is to create a wrapper class that ignores the task item and only compares the priority field:</source>
          <target state="translated">비교할 수없는 작업 문제에 대한 또 다른 해결책은 작업 항목을 무시하고 우선 순위 필드 만 비교하는 랩퍼 클래스를 작성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0f5e78d9ba1c7a1f17d713904f11c8fb976e77d2" translate="yes" xml:space="preserve">
          <source>Another specification of the format, with details on locking.</source>
          <target state="translated">잠금에 대한 세부 사항이있는 형식의 다른 스펙.</target>
        </trans-unit>
        <trans-unit id="e0a6209aa300b723ce63cb3581b82c93359f079d" translate="yes" xml:space="preserve">
          <source>Another specification of the format. Describes a common extension for supporting folders.</source>
          <target state="translated">형식의 다른 사양. 폴더를 지원하기위한 일반적인 확장명을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="259c6f7c7f71afa5d1276a3716f6996db84a2e2c" translate="yes" xml:space="preserve">
          <source>Another test-support module with a very different flavor.</source>
          <target state="translated">맛이 매우 다른 또 다른 테스트 지원 모듈.</target>
        </trans-unit>
        <trans-unit id="e52e511337918750293ba11f89a9f569c1bc3067" translate="yes" xml:space="preserve">
          <source>Another use case might be to replace an object with an &lt;a href=&quot;io#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">또 다른 사용 사례는 객체를 &lt;a href=&quot;io#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 인스턴스 로 교체하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="62a6c1f548ab752cd5952e7bc0d4d963e5bf6502" translate="yes" xml:space="preserve">
          <source>Another way to encode binary hashes for non-binary environments.</source>
          <target state="translated">비 이진 환경에 대한 이진 해시를 인코딩하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="fefd86df1dfa20cdf5dc78f24eca9be7a5e90b0f" translate="yes" xml:space="preserve">
          <source>Another way to handle this is with the following example:</source>
          <target state="translated">이를 처리하는 다른 방법은 다음 예제를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e0cebdfbbfd2a87dc6c52fdedb0b3db0e01e83" translate="yes" xml:space="preserve">
          <source>Another way to use variable-sized data types with &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; is to use the dynamic nature of Python, and (re-)define the data type after the required size is already known, on a case by case basis.</source>
          <target state="translated">&lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 와 함께 가변 크기 데이터 유형을 사용하는 또 다른 방법 은 Python의 동적 특성을 사용하고 필요한 크기가 이미 알려진 후에 데이터 유형을 경우에 따라 재정의하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e0aafffa028c1a77c7cc61a286a8bfa21a85356c" translate="yes" xml:space="preserve">
          <source>Answered</source>
          <target state="translated">Answered</target>
        </trans-unit>
        <trans-unit id="082fb2ca7290eae9e50333c559aae463c44ee785" translate="yes" xml:space="preserve">
          <source>Any *args and **kwargs supplied for this function are directly passed to &lt;em&gt;func&lt;/em&gt;. Also, the current &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt;&lt;code&gt;contextvars.Context&lt;/code&gt;&lt;/a&gt; is propogated, allowing context variables from the event loop thread to be accessed in the separate thread.</source>
          <target state="translated">이 함수에 제공된 모든 * args 및 ** kwargs는 &lt;em&gt;func&lt;/em&gt; 로 직접 전달됩니다 . 또한 현재 &lt;a href=&quot;contextvars#contextvars.Context&quot;&gt; &lt;code&gt;contextvars.Context&lt;/code&gt; &lt;/a&gt; 가 전파되어 이벤트 루프 스레드의 컨텍스트 변수를 별도의 스레드에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af5a6d2c7bcbd0595666bd7855f0f03cca3bf497" translate="yes" xml:space="preserve">
          <source>Any changes to any context variables that &lt;em&gt;callable&lt;/em&gt; makes will be contained in the context object:</source>
          <target state="translated">&lt;em&gt;호출&lt;/em&gt; 가능한 컨텍스트 변수에 대한 변경 사항 은 컨텍스트 객체에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e39a27177f793a03dc9f620dad817066a7f33c1" translate="yes" xml:space="preserve">
          <source>Any classes found are recursively searched similarly, to test docstrings in their contained methods and nested classes.</source>
          <target state="translated">발견 된 모든 클래스는 포함 된 메소드 및 중첩 클래스에서 docstring을 테스트하기 위해 유사하게 재귀 적으로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="f798ac81b2f74b659d7f586dd5eabb5ce15db13e" translate="yes" xml:space="preserve">
          <source>Any container can be passed as the &lt;em&gt;choices&lt;/em&gt; value, so &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; objects, &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; objects, and custom containers are all supported.</source>
          <target state="translated">모든 컨테이너는 &lt;em&gt;선택 사항&lt;/em&gt; 값 으로 전달 될 수 있으므로 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 오브젝트, &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 오브젝트 및 사용자 정의 컨테이너가 모두 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="808d1aeb7f37ecb67a57bc678598df13336e350c" translate="yes" xml:space="preserve">
          <source>Any container can be passed as the &lt;em&gt;choices&lt;/em&gt; value, so &lt;a href=&quot;stdtypes#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt; objects, &lt;a href=&quot;stdtypes#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; objects, and custom containers are all supported. This includes &lt;a href=&quot;enum#enum.Enum&quot;&gt;&lt;code&gt;enum.Enum&lt;/code&gt;&lt;/a&gt;, which could be used to restrain argument&amp;rsquo;s choices; if we reuse previous rock/paper/scissors game example, this could be as follows:</source>
          <target state="translated">모든 컨테이너를 &lt;em&gt;선택&lt;/em&gt; 값 으로 전달할 수 있으므로 &lt;a href=&quot;stdtypes#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; 개체, &lt;a href=&quot;stdtypes#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 개체 및 사용자 지정 컨테이너가 모두 지원됩니다. 여기에는 인수의 선택을 제한하는 데 사용할 수있는 &lt;a href=&quot;enum#enum.Enum&quot;&gt; &lt;code&gt;enum.Enum&lt;/code&gt; &lt;/a&gt; 이 포함됩니다 . 이전의 가위 바위 보 게임 예제를 재사용하면 다음과 같을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d6483718787eb0c399b57df09b4bd366515f2b" translate="yes" xml:space="preserve">
          <source>Any detected nonconformance results in an &lt;a href=&quot;exceptions#AssertionError&quot;&gt;&lt;code&gt;AssertionError&lt;/code&gt;&lt;/a&gt; being raised; note, however, that how these errors are handled is server-dependent. For example, &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt;&lt;code&gt;wsgiref.simple_server&lt;/code&gt;&lt;/a&gt; and other servers based on &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt;&lt;code&gt;wsgiref.handlers&lt;/code&gt;&lt;/a&gt; (that don&amp;rsquo;t override the error handling methods to do something else) will simply output a message that an error has occurred, and dump the traceback to &lt;code&gt;sys.stderr&lt;/code&gt; or some other error stream.</source>
          <target state="translated">감지 된 부적합으로 인해 &lt;a href=&quot;exceptions#AssertionError&quot;&gt; &lt;code&gt;AssertionError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 그러나 이러한 오류를 처리하는 방법은 서버에 따라 다릅니다. 예를 들어 &lt;a href=&quot;#module-wsgiref.simple_server&quot;&gt; &lt;code&gt;wsgiref.simple_server&lt;/code&gt; &lt;/a&gt; 에 기초하여 다른 서버 &lt;a href=&quot;#module-wsgiref.handlers&quot;&gt; &lt;code&gt;wsgiref.handlers&lt;/code&gt; &lt;/a&gt; (즉, 다른 뭔가를 할 방법을 처리하는 오류를 무시하지 않음) 단순히 출력 메시지가 오류가 발생하고,에 역 추적을 덤프 한 것을 &lt;code&gt;sys.stderr&lt;/code&gt; 를 또는 일부 다른 오류 스트림.</target>
        </trans-unit>
        <trans-unit id="c3161a1f48d49aece84ad1e7ba2994c99487c066" translate="yes" xml:space="preserve">
          <source>Any expected output must immediately follow the final &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; or &lt;code&gt;'... '&lt;/code&gt; line containing the code, and the expected output (if any) extends to the next &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; or all-whitespace line.</source>
          <target state="translated">예상되는 출력은 코드를 포함 하는 마지막 &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; 또는 &lt;code&gt;'... '&lt;/code&gt; 줄 바로 뒤에 와야하며 예상되는 출력 (있는 경우)은 다음 &lt;code&gt;'&amp;gt;&amp;gt;&amp;gt; '&lt;/code&gt; 또는 전체 공백 줄로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="16ef8204c61c9a1813182c916e1e34ec0c335625" translate="yes" xml:space="preserve">
          <source>Any files may be present in the ZIP archive, but only files &lt;code&gt;.py&lt;/code&gt; and &lt;code&gt;.pyc&lt;/code&gt; are available for import. ZIP import of dynamic modules (&lt;code&gt;.pyd&lt;/code&gt;, &lt;code&gt;.so&lt;/code&gt;) is disallowed. Note that if an archive only contains &lt;code&gt;.py&lt;/code&gt; files, Python will not attempt to modify the archive by adding the corresponding &lt;code&gt;.pyc&lt;/code&gt; file, meaning that if a ZIP archive doesn&amp;rsquo;t contain &lt;code&gt;.pyc&lt;/code&gt; files, importing may be rather slow.</source>
          <target state="translated">ZIP 아카이브에는 모든 파일이있을 수 있지만 &lt;code&gt;.py&lt;/code&gt; 및 &lt;code&gt;.pyc&lt;/code&gt; 파일 만 가져올 수 있습니다. 동적 모듈 ( &lt;code&gt;.pyd&lt;/code&gt; , &lt;code&gt;.so&lt;/code&gt; ) 의 ZIP 가져 오기 는 허용되지 않습니다. 아카이브에 &lt;code&gt;.py&lt;/code&gt; 파일 만 포함 된 경우 Python은 해당 &lt;code&gt;.pyc&lt;/code&gt; 파일 을 추가하여 아카이브를 수정하려고 시도 하지 않습니다. 즉, ZIP 아카이브에 &lt;code&gt;.pyc&lt;/code&gt; 파일 이 없으면 가져 오기 속도가 느려질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8dee1375bcf6a8c6c517898f5fc97f065da4ba9" translate="yes" xml:space="preserve">
          <source>Any form of network IO; &lt;code&gt;recv()&lt;/code&gt; and &lt;code&gt;send()&lt;/code&gt; read and write only to the underlying &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt;&lt;code&gt;MemoryBIO&lt;/code&gt;&lt;/a&gt; buffers.</source>
          <target state="translated">모든 형태의 네트워크 IO; &lt;code&gt;recv()&lt;/code&gt; 및 &lt;code&gt;send()&lt;/code&gt; 는 기본 &lt;a href=&quot;#ssl.MemoryBIO&quot;&gt; &lt;code&gt;MemoryBIO&lt;/code&gt; &lt;/a&gt; 버퍼 에만 읽고 씁니다 .</target>
        </trans-unit>
        <trans-unit id="0f114f3ceee9858acec62bd48fb36dd2e76f81ac" translate="yes" xml:space="preserve">
          <source>Any header object, or any header that is refolded due to the policy settings, is folded using an algorithm that fully implements the RFC folding algorithms, including knowing where encoded words are required and allowed.</source>
          <target state="translated">인코딩 된 단어가 필요한 위치와 허용되는 위치를 포함하여 RFC 폴딩 알고리즘을 완전히 구현하는 알고리즘을 사용하여 모든 헤더 개체 또는 정책 설정으로 인해 다시 접힌 헤더가 접 힙니다.</target>
        </trans-unit>
        <trans-unit id="87a66302b5c5f0a22de125246046b1cdfffefa6b" translate="yes" xml:space="preserve">
          <source>Any object can be tested for truth value, for use in an &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; condition or as operand of the Boolean operations below.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 조건에서 사용하거나 아래 부울 연산의 피연산자로 사용하기 위해 모든 값을 진리 값으로 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1110e65f07bb65d564abb72e4ad0a27d774a7b9" translate="yes" xml:space="preserve">
          <source>Any object can be tested for truth value, for use in an &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#if&quot;&gt;&lt;code&gt;if&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#while&quot;&gt;&lt;code&gt;while&lt;/code&gt;&lt;/a&gt; condition or as operand of the Boolean operations below.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#if&quot;&gt; &lt;code&gt;if&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#while&quot;&gt; &lt;code&gt;while&lt;/code&gt; &lt;/a&gt; 조건에서 사용하거나 아래의 부울 연산의 피연산자로 사용하기 위해 모든 개체의 진리 값을 테스트 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b871425be90d75ff7f0f750362354908800f258b" translate="yes" xml:space="preserve">
          <source>Any other appearance of &lt;code&gt;$&lt;/code&gt; in the string will result in a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; being raised.</source>
          <target state="translated">문자열 에 &lt;code&gt;$&lt;/code&gt; 가 표시 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="32e241730c485594f505f9764a3cbc96f2e45b62" translate="yes" xml:space="preserve">
          <source>Any other keys in the dictionary are ignored, to allow for future extensions. If the path cannot be handled, &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">향후 확장을 위해 사전의 다른 키는 무시됩니다. 경로를 처리 할 수 ​​없으면 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e32d9113d754ea90473171c0599a4afdcc0feabd" translate="yes" xml:space="preserve">
          <source>Any truncated integers at the end of the list of file descriptors.</source>
          <target state="translated">파일 설명자 목록 끝에있는 잘린 정수입니다.</target>
        </trans-unit>
        <trans-unit id="8d4f45530c29236c208822a755f335ab895f7ae9" translate="yes" xml:space="preserve">
          <source>Any valid Python identifier may be used for a fieldname except for names starting with an underscore. Valid identifiers consist of letters, digits, and underscores but do not start with a digit or underscore and cannot be a &lt;a href=&quot;keyword#module-keyword&quot;&gt;&lt;code&gt;keyword&lt;/code&gt;&lt;/a&gt; such as &lt;em&gt;class&lt;/em&gt;, &lt;em&gt;for&lt;/em&gt;, &lt;em&gt;return&lt;/em&gt;, &lt;em&gt;global&lt;/em&gt;, &lt;em&gt;pass&lt;/em&gt;, or &lt;em&gt;raise&lt;/em&gt;.</source>
          <target state="translated">밑줄로 시작하는 이름을 제외한 모든 유효한 Python 식별자를 필드 이름에 사용할 수 있습니다. 유효한 식별자는 문자, 숫자 및 밑줄로 구성되지만 숫자 또는 밑줄로 시작하지 않으며 &lt;em&gt;class&lt;/em&gt; , &lt;em&gt;for&lt;/em&gt; , &lt;em&gt;return&lt;/em&gt; , &lt;em&gt;global&lt;/em&gt; , &lt;em&gt;pass&lt;/em&gt; 또는 &lt;em&gt;raise&lt;/em&gt; 와 같은 &lt;a href=&quot;keyword#module-keyword&quot;&gt; &lt;code&gt;keyword&lt;/code&gt; &lt;/a&gt; 될 수 없습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1518232458ae063224b67a33fbc39f874e6e7652" translate="yes" xml:space="preserve">
          <source>Any value error related to the address.</source>
          <target state="translated">주소와 관련된 모든 값 오류.</target>
        </trans-unit>
        <trans-unit id="71a52ce7a5fdb3bd7ec0934cf4eb202d8034ff6e" translate="yes" xml:space="preserve">
          <source>Any value error related to the net mask.</source>
          <target state="translated">넷 마스크와 관련된 모든 값 오류.</target>
        </trans-unit>
        <trans-unit id="f5f7839523439ed5db0c3285770ed6a7ad0ef07d" translate="yes" xml:space="preserve">
          <source>Apart from &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt;, config parsers also provide equivalent &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt;&lt;code&gt;getint()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt;&lt;code&gt;getfloat()&lt;/code&gt;&lt;/a&gt; methods. You can register your own converters and customize the provided ones. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt; 외에도 구성 파서는 동등한 &lt;a href=&quot;#configparser.ConfigParser.getint&quot;&gt; &lt;code&gt;getint()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#configparser.ConfigParser.getfloat&quot;&gt; &lt;code&gt;getfloat()&lt;/code&gt; &lt;/a&gt; 메소드를 제공합니다. 자신의 변환기를 등록하고 제공된 변환기를 사용자 정의 할 수 있습니다. &lt;a href=&quot;#id14&quot; id=&quot;id4&quot;&gt;1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="004e30185abf19283aba3fcb4dd5458909228910" translate="yes" xml:space="preserve">
          <source>Apart from making the code (potentially) compatible with Windows and the other start methods this also ensures that as long as the child process is still alive the object will not be garbage collected in the parent process. This might be important if some resource is freed when the object is garbage collected in the parent process.</source>
          <target state="translated">Windows 및 기타 시작 방법과 코드를 (잠재적으로) 호환 가능하게 만드는 것 외에도 자식 프로세스가 계속 존재하는 한 부모 프로세스에서 개체가 가비지 수집되지 않습니다. 부모 프로세스에서 개체가 가비지 수집 될 때 일부 리소스가 해제 된 경우 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f8e3f0f5b15c39aef46bc951d434aa2f994181" translate="yes" xml:space="preserve">
          <source>Apart from the node classes, the &lt;a href=&quot;#module-ast&quot;&gt;&lt;code&gt;ast&lt;/code&gt;&lt;/a&gt; module defines these utility functions and classes for traversing abstract syntax trees:</source>
          <target state="translated">노드 클래스 외에도 &lt;a href=&quot;#module-ast&quot;&gt; &lt;code&gt;ast&lt;/code&gt; &lt;/a&gt; 모듈은 추상 구문 트리를 순회하기 위해 다음 유틸리티 함수와 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="41def7a0febe741da87c5b79ce78ce27b83f3ae7" translate="yes" xml:space="preserve">
          <source>Appearance</source>
          <target state="translated">Appearance</target>
        </trans-unit>
        <trans-unit id="7c6156597bec64b2efa893f896b414ba015b84f0" translate="yes" xml:space="preserve">
          <source>Append &lt;em&gt;line&lt;/em&gt; to the history buffer, as if it was the last line typed. This calls &lt;code&gt;add_history()&lt;/code&gt; in the underlying library.</source>
          <target state="translated">추가]의 &lt;em&gt;라인&lt;/em&gt; 이 인 것처럼 역사 버퍼는, 마지막 줄에 입력했습니다. 기본 라이브러리에서 &lt;code&gt;add_history()&lt;/code&gt; 를 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="15e3d810f53a90235f3be7ee31ad204835b47079" translate="yes" xml:space="preserve">
          <source>Append &lt;em&gt;message&lt;/em&gt; to named mailbox.</source>
          <target state="translated">명명 된 사서함에 &lt;em&gt;메시지&lt;/em&gt; 를 추가 합니다.</target>
        </trans-unit>
        <trans-unit id="5012b56fdb1fabff75d417024359f5123b3c7cf5" translate="yes" xml:space="preserve">
          <source>Append a new action at the end. The &lt;em&gt;cmd&lt;/em&gt; variable must be a valid bourne shell command. The &lt;em&gt;kind&lt;/em&gt; variable consists of two letters.</source>
          <target state="translated">끝에 새로운 행동을 추가하십시오. &lt;em&gt;cmd를의&lt;/em&gt; 변수는 유효한 본 셸 명령이어야합니다. &lt;em&gt;종류의&lt;/em&gt; 변수는 두 글자로 구성되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb2f2dddbf426366118168a9e541a67ab5450c2" translate="yes" xml:space="preserve">
          <source>Append a new item with value &lt;em&gt;x&lt;/em&gt; to the end of the array.</source>
          <target state="translated">값이 &lt;em&gt;x 인&lt;/em&gt; 새 항목을 배열 끝에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bec2f10908ba5de36daf156b98af3c60ee338f32" translate="yes" xml:space="preserve">
          <source>Append items from &lt;em&gt;iterable&lt;/em&gt; to the end of the array. If &lt;em&gt;iterable&lt;/em&gt; is another array, it must have &lt;em&gt;exactly&lt;/em&gt; the same type code; if not, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; will be raised. If &lt;em&gt;iterable&lt;/em&gt; is not an array, it must be iterable and its elements must be the right type to be appended to the array.</source>
          <target state="translated">&lt;em&gt;반복 가능한&lt;/em&gt; 항목부터 배열의 끝까지 항목을 추가합니다 . 경우 &lt;em&gt;반복 가능한이&lt;/em&gt; 다른 배열이, 그것은이 있어야 &lt;em&gt;정확히&lt;/em&gt; 같은 종류의 코드; 그렇지 않으면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. &lt;em&gt;iterable&lt;/em&gt; 이 배열이 아닌 경우 &lt;em&gt;iterable&lt;/em&gt; 이어야하며 해당 요소는 배열에 추가 할 올바른 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="70b18019b4972b108e37841f15945c9d21d175bf" translate="yes" xml:space="preserve">
          <source>Append items from the list. This is equivalent to &lt;code&gt;for x in list:
a.append(x)&lt;/code&gt; except that if there is a type error, the array is unchanged.</source>
          <target state="translated">목록에서 항목을 추가하십시오. 이것은 유형 오류가있는 경우 배열이 변경되지 않는다는 점을 제외하고 &lt;code&gt;for x in list: a.append(x)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="44b7a672882b72ed3eb65f4fc161e2735a4aad2e" translate="yes" xml:space="preserve">
          <source>Append the callable &lt;em&gt;hook&lt;/em&gt; to the list of active auditing hooks for the current interpreter.</source>
          <target state="translated">현재 인터프리터의 활성 감사 후크 목록에 호출 가능 &lt;em&gt;후크&lt;/em&gt; 를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb08b061999d25be95bd753505fb9df32467aab4" translate="yes" xml:space="preserve">
          <source>Append the last &lt;em&gt;nelements&lt;/em&gt; items of history to a file. The default filename is &lt;code&gt;~/.history&lt;/code&gt;. The file must already exist. This calls &lt;code&gt;append_history()&lt;/code&gt; in the underlying library. This function only exists if Python was compiled for a version of the library that supports it.</source>
          <target state="translated">히스토리 의 마지막 &lt;em&gt;nelements&lt;/em&gt; 항목을 파일에 추가 하십시오. 기본 파일 이름은 &lt;code&gt;~/.history&lt;/code&gt; 입니다. 파일이 이미 존재해야합니다. 기본 라이브러리에서 &lt;code&gt;append_history()&lt;/code&gt; 를 호출 합니다. 이 함수는 Python이이를 지원하는 라이브러리 버전 용으로 컴파일 된 경우에만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2c421a3b35b989d4ece772b4d7f4d642bcef1d02" translate="yes" xml:space="preserve">
          <source>Append the record to the buffer. If &lt;a href=&quot;#logging.handlers.BufferingHandler.shouldFlush&quot;&gt;&lt;code&gt;shouldFlush()&lt;/code&gt;&lt;/a&gt; returns true, call &lt;a href=&quot;#logging.handlers.BufferingHandler.flush&quot;&gt;&lt;code&gt;flush()&lt;/code&gt;&lt;/a&gt; to process the buffer.</source>
          <target state="translated">레코드를 버퍼에 추가하십시오. &lt;a href=&quot;#logging.handlers.BufferingHandler.shouldFlush&quot;&gt; &lt;code&gt;shouldFlush()&lt;/code&gt; &lt;/a&gt; 가 true를 리턴 하면 &lt;a href=&quot;#logging.handlers.BufferingHandler.flush&quot;&gt; &lt;code&gt;flush()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 버퍼를 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="b6428efcfa3b692ae0853afc12b91104655bc067" translate="yes" xml:space="preserve">
          <source>Append the string &lt;em&gt;s&lt;/em&gt; to the MIME header.</source>
          <target state="translated">추가] 문자열 &lt;em&gt;s의&lt;/em&gt; MIME 헤더에.</target>
        </trans-unit>
        <trans-unit id="63afd5dcef3cb2a0dae141c8bb5ab6871063eaa8" translate="yes" xml:space="preserve">
          <source>Appends &lt;em&gt;subelements&lt;/em&gt; from a sequence object with zero or more elements. Raises &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if a subelement is not an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">추가 &lt;em&gt;서브 엘리먼트&lt;/em&gt; 는 0 개 이상의 요소가 시퀀스에서 객체. 발생시킵니다 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 하위 요소가 아닌 경우 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bceea9f719c67ae44ec147e59a3ff45f6a13a85" translate="yes" xml:space="preserve">
          <source>Appends items from the string, interpreting the string as an array of machine values (as if it had been read from a file using the &lt;a href=&quot;#array.array.fromfile&quot;&gt;&lt;code&gt;fromfile()&lt;/code&gt;&lt;/a&gt; method).</source>
          <target state="translated">문자열을 기계 값의 배열로 해석하여 문자열에서 항목을 추가합니다 ( &lt;a href=&quot;#array.array.fromfile&quot;&gt; &lt;code&gt;fromfile()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 파일에서 읽은 것처럼 ).</target>
        </trans-unit>
        <trans-unit id="7f55a9d7c4f227e50d8f45b68bd0268e8a04c0f7" translate="yes" xml:space="preserve">
          <source>Appends whitespace to the subtree to indent the tree visually. This can be used to generate pretty-printed XML output. &lt;em&gt;tree&lt;/em&gt; can be an Element or ElementTree. &lt;em&gt;space&lt;/em&gt; is the whitespace string that will be inserted for each indentation level, two space characters by default. For indenting partial subtrees inside of an already indented tree, pass the initial indentation level as &lt;em&gt;level&lt;/em&gt;.</source>
          <target state="translated">하위 트리에 공백을 추가하여 트리를 시각적으로 들여 씁니다. 이것은 예쁘게 인쇄 된 XML 출력을 생성하는 데 사용할 수 있습니다. &lt;em&gt;tree&lt;/em&gt; 는 Element 또는 ElementTree 일 수 있습니다. &lt;em&gt;공백&lt;/em&gt; 은 각 들여 쓰기 수준에 대해 삽입 될 공백 문자열이며 기본적으로 두 개의 공백 문자입니다. 이미 들여 쓰기 된 트리 내부에서 부분 하위 트리를 들여 쓰려면 초기 들여 쓰기 수준을 &lt;em&gt;level&lt;/em&gt; 로 전달합니다 .</target>
        </trans-unit>
        <trans-unit id="e26d38984e101ccc199d48ef993f80d0a613b479" translate="yes" xml:space="preserve">
          <source>Apple&amp;rsquo;s documentation of the file format.</source>
          <target state="translated">파일 형식에 대한 Apple의 설명서</target>
        </trans-unit>
        <trans-unit id="09c258e5edf35ac67db5d64e7635e8a3d86b778e" translate="yes" xml:space="preserve">
          <source>Application developers should typically use the high-level asyncio functions, such as &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt;&lt;code&gt;asyncio.run()&lt;/code&gt;&lt;/a&gt;, and should rarely need to reference the loop object or call its methods. This section is intended mostly for authors of lower-level code, libraries, and frameworks, who need finer control over the event loop behavior.</source>
          <target state="translated">애플리케이션 개발자는 일반적으로 &lt;a href=&quot;asyncio-task#asyncio.run&quot;&gt; &lt;code&gt;asyncio.run()&lt;/code&gt; &lt;/a&gt; 과 같은 고급 asyncio 함수를 사용해야하며 루프 객체를 참조하거나 해당 메소드를 호출 할 필요가 거의 없습니다. 이 섹션은 주로 이벤트 루프 동작을보다 세밀하게 제어해야하는 하위 수준 코드, 라이브러리 및 프레임 워크 작성자를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="ad91f8ac2108f501e8aa1719fa2b68f46b05d5af" translate="yes" xml:space="preserve">
          <source>Applications can add their own callbacks to this list. The primary use cases are:</source>
          <target state="translated">애플리케이션은이 목록에 자체 콜백을 추가 할 수 있습니다. 주요 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="15e3de344c6c36974c5693ae0deb456a758bdd3d" translate="yes" xml:space="preserve">
          <source>Applications may store arbitrary objects in these attributes.</source>
          <target state="translated">응용 프로그램은 이러한 속성에 임의의 개체를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c498690ce78323bc09d2e18d14d4892b6e8abd0" translate="yes" xml:space="preserve">
          <source>Applications should not &lt;a href=&quot;http://cwe.mitre.org/data/definitions/257.html&quot;&gt;store passwords in a recoverable format&lt;/a&gt;, whether plain text or encrypted. They should be salted and hashed using a cryptographically-strong one-way (irreversible) hash function.</source>
          <target state="translated">응용 프로그램은 일반 텍스트 또는 암호화 된 &lt;a href=&quot;http://cwe.mitre.org/data/definitions/257.html&quot;&gt;암호를 복구 가능한 형식으로 저장&lt;/a&gt; 해서는 안됩니다 . 암호화 방식으로 강력한 단방향 (돌이킬 수없는) 해시 기능을 사용하여 소금에 절이고 해시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9516d3c40d5579ce0328d2d1808e751ea327f8e2" translate="yes" xml:space="preserve">
          <source>Applications that can&amp;rsquo;t bear wall-time ambiguities should explicitly check the value of the &lt;a href=&quot;#datetime.datetime.fold&quot;&gt;&lt;code&gt;fold&lt;/code&gt;&lt;/a&gt; attribute or avoid using hybrid &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclasses; there are no ambiguities when using &lt;a href=&quot;#datetime.timezone&quot;&gt;&lt;code&gt;timezone&lt;/code&gt;&lt;/a&gt;, or any other fixed-offset &lt;a href=&quot;#datetime.tzinfo&quot;&gt;&lt;code&gt;tzinfo&lt;/code&gt;&lt;/a&gt; subclass (such as a class representing only EST (fixed offset -5 hours), or only EDT (fixed offset -4 hours)).</source>
          <target state="translated">Wall-Time 모호성을 견딜 수없는 응용 프로그램은 &lt;a href=&quot;#datetime.datetime.fold&quot;&gt; &lt;code&gt;fold&lt;/code&gt; &lt;/a&gt; 속성 값을 명시 적으로 확인 하거나 하이브리드 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스를 사용하지 않아야합니다 . &lt;a href=&quot;#datetime.timezone&quot;&gt; &lt;code&gt;timezone&lt;/code&gt; &lt;/a&gt; 또는 기타 고정 오프셋 &lt;a href=&quot;#datetime.tzinfo&quot;&gt; &lt;code&gt;tzinfo&lt;/code&gt; &lt;/a&gt; 서브 클래스 (예 : EST 만 (고정 오프셋 -5 시간) 또는 EDT (고정 오프셋 -4 시간) 만 나타내는 클래스)를 사용할 때는 모호성이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0719959018ae4f7d3b51e5a78769bd3b0ca3df46" translate="yes" xml:space="preserve">
          <source>Applications that need to operate on potentially improperly quoted URLs that may contain non-ASCII data will need to do their own decoding from bytes to characters before invoking the URL parsing methods.</source>
          <target state="translated">비 ASCII 데이터를 포함 할 수있는 잘못 인용 된 URL에서 작동해야하는 응용 프로그램은 URL 구문 분석 방법을 호출하기 전에 바이트에서 문자로 자체 디코딩을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="fafdab997b122fcdc3b5c0971f1785992cabff68" translate="yes" xml:space="preserve">
          <source>Applications will create objects of this class for use in the &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt;&lt;code&gt;XMLReader.parse()&lt;/code&gt;&lt;/a&gt; method and for returning from EntityResolver.resolveEntity.</source>
          <target state="translated">애플리케이션은 &lt;a href=&quot;#xml.sax.xmlreader.XMLReader.parse&quot;&gt; &lt;code&gt;XMLReader.parse()&lt;/code&gt; &lt;/a&gt; 메소드에서 사용하고 EntityResolver.resolveEntity에서 리턴 하기 위해이 클래스의 오브젝트를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e7284143fe53744047558a065875930ca468cf98" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;and&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산 적용 &lt;em&gt;및&lt;/em&gt; 각 피연산자의 숫자 사이를.</target>
        </trans-unit>
        <trans-unit id="37c10a7d11316205bdac710e988348ca767a1a19" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;or&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산을 적용 &lt;em&gt;하거나&lt;/em&gt; 각 피연산자의 숫자 사이에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="a0b520db8cdcd1e798321610d25b1d0aa46d3781" translate="yes" xml:space="preserve">
          <source>Applies the logical operation &lt;em&gt;xor&lt;/em&gt; between each operand&amp;rsquo;s digits.</source>
          <target state="translated">논리 연산의 적용 &lt;em&gt;XOR&lt;/em&gt; 각 피연산자의 숫자 사이를.</target>
        </trans-unit>
        <trans-unit id="c6347e1f0ae0fe6eb691488a3a3790d194631241" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; rules on unverifiable transactions even to Netscape cookies.</source>
          <target state="translated">검증 할 수없는 거래에 대해 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-19&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 규칙을 Netscape 쿠키에도 적용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b6c11221fbbce04188875f4bbd9a5712dd69e34a" translate="yes" xml:space="preserve">
          <source>Apply &lt;em&gt;function&lt;/em&gt; of two arguments cumulatively to the items of &lt;em&gt;iterable&lt;/em&gt;, from left to right, so as to reduce the iterable to a single value. For example, &lt;code&gt;reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])&lt;/code&gt; calculates &lt;code&gt;((((1+2)+3)+4)+5)&lt;/code&gt;. The left argument, &lt;em&gt;x&lt;/em&gt;, is the accumulated value and the right argument, &lt;em&gt;y&lt;/em&gt;, is the update value from the &lt;em&gt;iterable&lt;/em&gt;. If the optional &lt;em&gt;initializer&lt;/em&gt; is present, it is placed before the items of the iterable in the calculation, and serves as a default when the iterable is empty. If &lt;em&gt;initializer&lt;/em&gt; is not given and &lt;em&gt;iterable&lt;/em&gt; contains only one item, the first item is returned.</source>
          <target state="translated">iterable을 단일 값으로 줄이기 위해 두 인수의 &lt;em&gt;함수&lt;/em&gt; 를 왼쪽에서 오른쪽 으로 &lt;em&gt;iterable&lt;/em&gt; 의 항목에 누적 적으로 적용하십시오 . 예를 들어, &lt;code&gt;reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])&lt;/code&gt; 는 &lt;code&gt;((((1+2)+3)+4)+5)&lt;/code&gt; 를 계산 합니다. 왼쪽 인수 &lt;em&gt;x&lt;/em&gt; 는 누적 값이고 오른쪽 인수 &lt;em&gt;y&lt;/em&gt; 는 &lt;em&gt;iterable&lt;/em&gt; 의 업데이트 값입니다 . 선택적 &lt;em&gt;이니셜 라이저&lt;/em&gt; 가 있으면 계산에서 이터 러블 항목 앞에 배치되고 이터 러블이 비어있을 때 기본값으로 사용됩니다. 경우 &lt;em&gt;초기화가&lt;/em&gt; 제공되지 않고 &lt;em&gt;반복 가능한이&lt;/em&gt; 하나의 항목이 들어있는 첫 번째 항목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f6b8050ae59615c4994444f8cdf9e2812e29cae" translate="yes" xml:space="preserve">
          <source>Apply this handler&amp;rsquo;s filters to the record and return &lt;code&gt;True&lt;/code&gt; if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be emitted. If one returns a false value, the handler will not emit the record.</source>
          <target state="translated">이 핸들러의 필터를 레코드에 적용 하고 레코드가 처리 될 경우 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 필터 중 하나가 잘못된 값을 반환 할 때까지 필터를 차례로 참조합니다. 둘 중 어느 것도 잘못된 값을 반환하지 않으면 레코드가 생성됩니다. 거짓 값을 반환하면 처리기는 레코드를 내 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75727d4b37b8d6f61c121aa55945e43277e79623" translate="yes" xml:space="preserve">
          <source>Apply this logger&amp;rsquo;s filters to the record and return &lt;code&gt;True&lt;/code&gt; if the record is to be processed. The filters are consulted in turn, until one of them returns a false value. If none of them return a false value, the record will be processed (passed to handlers). If one returns a false value, no further processing of the record occurs.</source>
          <target state="translated">이 로거의 필터를 레코드에 적용 하고 레코드를 처리하려면 &lt;code&gt;True&lt;/code&gt; 를 리턴 하십시오. 필터 중 하나가 잘못된 값을 반환 할 때까지 필터를 차례로 참조합니다. 둘 중 하나라도 잘못된 값을 반환하지 않으면 레코드가 처리됩니다 (핸들러로 전달됨). 잘못된 값을 반환하면 더 이상 레코드를 처리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f5f8992ee05391b7dd15844b0a81da4dcbca1d1a" translate="yes" xml:space="preserve">
          <source>Apply, test or remove a POSIX lock on an open file descriptor. &lt;em&gt;fd&lt;/em&gt; is an open file descriptor. &lt;em&gt;cmd&lt;/em&gt; specifies the command to use - one of &lt;a href=&quot;#os.F_LOCK&quot;&gt;&lt;code&gt;F_LOCK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.F_TLOCK&quot;&gt;&lt;code&gt;F_TLOCK&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#os.F_ULOCK&quot;&gt;&lt;code&gt;F_ULOCK&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#os.F_TEST&quot;&gt;&lt;code&gt;F_TEST&lt;/code&gt;&lt;/a&gt;. &lt;em&gt;len&lt;/em&gt; specifies the section of the file to lock.</source>
          <target state="translated">열린 파일 디스크립터에서 POSIX 잠금을 적용, 테스트 또는 제거하십시오. &lt;em&gt;fd&lt;/em&gt; 는 열린 파일 디스크립터입니다. &lt;em&gt;cmd&lt;/em&gt; 는 &lt;a href=&quot;#os.F_LOCK&quot;&gt; &lt;code&gt;F_LOCK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.F_TLOCK&quot;&gt; &lt;code&gt;F_TLOCK&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#os.F_ULOCK&quot;&gt; &lt;code&gt;F_ULOCK&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#os.F_TEST&quot;&gt; &lt;code&gt;F_TEST&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하도록 명령을 지정합니다 . &lt;em&gt;len&lt;/em&gt; 은 잠글 파일 섹션을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="83c16cf7fbf4a6d50f42643443798c0192cc0915" translate="yes" xml:space="preserve">
          <source>Applying the reverse conversion to &lt;code&gt;3740.0&lt;/code&gt; gives a different hexadecimal string representing the same number:</source>
          <target state="translated">&lt;code&gt;3740.0&lt;/code&gt; 에 역변환을 적용하면 동일한 숫자를 나타내는 다른 16 진 문자열이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="06bee686a5eaf240f9c56fe230e927f0bbd2a171" translate="yes" xml:space="preserve">
          <source>Applying the same patch to every test method</source>
          <target state="translated">모든 테스트 방법에 동일한 패치 적용</target>
        </trans-unit>
        <trans-unit id="c570ce78a064ac6afc5df19b2e24947c18c38dc5" translate="yes" xml:space="preserve">
          <source>Approximating &lt;a href=&quot;#importlib.import_module&quot;&gt;&lt;code&gt;importlib.import_module()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">근사 &lt;a href=&quot;#importlib.import_module&quot;&gt; &lt;code&gt;importlib.import_module()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="aa559da736898dbd0d15602df291a370ff954c58" translate="yes" xml:space="preserve">
          <source>Archive names should be relative to the archive root, that is, they should not start with a path separator.</source>
          <target state="translated">아카이브 이름은 아카이브 루트에 상대적이어야합니다. 즉, 경로 구분 기호로 시작해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="4e93a940c9f8e4f679d6284bd8a795953316844a" translate="yes" xml:space="preserve">
          <source>Archiving example</source>
          <target state="translated">보관 예</target>
        </trans-unit>
        <trans-unit id="9655f90a40f38717dd6a2cdaf52344b6f73b99eb" translate="yes" xml:space="preserve">
          <source>Archiving example with &lt;em&gt;base_dir&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;base_dir을&lt;/em&gt; 사용한 아카이브 예제&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c6824fef37d7d6af51ce46cec76775f0abf31cfe" translate="yes" xml:space="preserve">
          <source>Archiving example with base_dir</source>
          <target state="translated">base_dir을 사용한 아카이브 예제</target>
        </trans-unit>
        <trans-unit id="0c2ca1a37605ad24f1be144c9f7d4cb1b3101631" translate="yes" xml:space="preserve">
          <source>Archiving operations</source>
          <target state="translated">보관 작업</target>
        </trans-unit>
        <trans-unit id="71f392576d7e147141bf396686950b09802b28f4" translate="yes" xml:space="preserve">
          <source>Arg list too long</source>
          <target state="translated">인수 목록이 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="8126f6e897947aa2bcce9fdc2c65455309bc87d1" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;flags&lt;/em&gt; takes the &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;bitwise OR&lt;/a&gt; of option flags. See section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;. Only &amp;ldquo;reporting flags&amp;rdquo; can be used.</source>
          <target state="translated">인수 &lt;em&gt;플래그&lt;/em&gt; 는 옵션 플래그 의 &lt;a href=&quot;https://docs.python.org/3.8/reference/expressions.html#bitwise&quot;&gt;비트 단위 OR&lt;/a&gt; 을 사용합니다. &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 . &quot;보고 플래그&quot;만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11697c2fb890c0f6657adb297715eca2a57c6b85" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;flags&lt;/em&gt; takes the &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#bitwise&quot;&gt;bitwise OR&lt;/a&gt; of option flags. See section &lt;a href=&quot;#doctest-options&quot;&gt;Option Flags&lt;/a&gt;. Only &amp;ldquo;reporting flags&amp;rdquo; can be used.</source>
          <target state="translated">인수 &lt;em&gt;플래그&lt;/em&gt; 는 옵션 플래그 의 &lt;a href=&quot;https://docs.python.org/3.9/reference/expressions.html#bitwise&quot;&gt;비트 단위 OR&lt;/a&gt; 을 사용합니다. &lt;a href=&quot;#doctest-options&quot;&gt;옵션 플래그&lt;/a&gt; 섹션을 참조하십시오 . &quot;보고 플래그&quot;만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49cda49e510f79a25d5fe2cd3ec5f12c16ca5615" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;module&lt;/em&gt; is a module object, or dotted name of a module, containing the object whose doctests are of interest. Argument &lt;em&gt;name&lt;/em&gt; is the name (within the module) of the object with the doctests of interest. The result is a string, containing the object&amp;rsquo;s docstring converted to a Python script, as described for &lt;a href=&quot;#doctest.script_from_examples&quot;&gt;&lt;code&gt;script_from_examples()&lt;/code&gt;&lt;/a&gt; above. For example, if module &lt;code&gt;a.py&lt;/code&gt; contains a top-level function &lt;code&gt;f()&lt;/code&gt;, then</source>
          <target state="translated">인수 &lt;em&gt;모듈&lt;/em&gt; 은 doctest가 관심있는 객체를 포함하는 모듈 객체 또는 모듈의 점으로 구분 된 이름입니다. 인수 &lt;em&gt;이름&lt;/em&gt; 은 관심이있는 doctest를 가진 오브젝트의 이름 (모듈 내)입니다. 결과는 위의 &lt;a href=&quot;#doctest.script_from_examples&quot;&gt; &lt;code&gt;script_from_examples()&lt;/code&gt; &lt;/a&gt; 설명 된대로 Python 스크립트로 변환 된 객체의 docstring을 포함하는 문자열 입니다. 예를 들어, 모듈의 경우 &lt;code&gt;a.py&lt;/code&gt; 는 최상위 기능 포함 &lt;code&gt;f()&lt;/code&gt; 한 다음,</target>
        </trans-unit>
        <trans-unit id="d13ab8175963907a3c38cd5c0e397fdc5a88b925" translate="yes" xml:space="preserve">
          <source>Argument &lt;em&gt;s&lt;/em&gt; is a string containing doctest examples. The string is converted to a Python script, where doctest examples in &lt;em&gt;s&lt;/em&gt; are converted to regular code, and everything else is converted to Python comments. The generated script is returned as a string. For example,</source>
          <target state="translated">인수 &lt;em&gt;들&lt;/em&gt; doctest가 예를 포함하는 문자열입니다. 문자열은 Python 스크립트로 변환됩니다. 여기서 &lt;em&gt;s의&lt;/em&gt; doctest 예제는 일반 코드로 변환되고 다른 모든 것은 Python 주석으로 변환됩니다. 생성 된 스크립트는 문자열로 반환됩니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="dc60f0a9ed6b8901fa4738eb86c947f1aba137a8" translate="yes" xml:space="preserve">
          <source>Argument abbreviations (prefix matching)</source>
          <target state="translated">인수 약어 (접두사 일치)</target>
        </trans-unit>
        <trans-unit id="646f35c0fe5203eb12ebdfc5f6722d5f4ee8b9f2" translate="yes" xml:space="preserve">
          <source>Argument groups</source>
          <target state="translated">인수 그룹</target>
        </trans-unit>
        <trans-unit id="3c66f14d2ce5db0e563f7a0a9cea03ef993a86f3" translate="yes" xml:space="preserve">
          <source>Argument names are not part of the specification, and only the arguments of &lt;a href=&quot;functions#open&quot;&gt;&lt;code&gt;open()&lt;/code&gt;&lt;/a&gt; are intended to be used as keyword arguments.</source>
          <target state="translated">인수 이름은 사양의 일부가 아니며 &lt;a href=&quot;functions#open&quot;&gt; &lt;code&gt;open()&lt;/code&gt; &lt;/a&gt; 인수 만 키워드 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6331038cb6dd518cc8a1c33aa6d56e471c0a5793" translate="yes" xml:space="preserve">
          <source>ArgumentParser objects</source>
          <target state="translated">ArgumentParser 객체</target>
        </trans-unit>
        <trans-unit id="81018876e5e0fb20f6d9b1140eb03c00025d7bd7" translate="yes" xml:space="preserve">
          <source>ArgumentParser objects usually associate a single command-line argument with a single action to be taken. The &lt;code&gt;nargs&lt;/code&gt; keyword argument associates a different number of command-line arguments with a single action. The supported values are:</source>
          <target state="translated">ArgumentParser 객체는 일반적으로 단일 명령 줄 인수를 단일 액션과 연결합니다. &lt;code&gt;nargs&lt;/code&gt; 키워드 인수는 단일 작업과 명령 줄 인수의 다른 번호를 연결합니다. 지원되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="74013187b9b262d759763c71b93fc2050badc103" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;file&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt;, &lt;em&gt;encoding&lt;/em&gt;, &lt;em&gt;errors&lt;/em&gt;, &lt;em&gt;strict&lt;/em&gt; and &lt;em&gt;buffers&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Unpickler&quot;&gt;&lt;code&gt;Unpickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;file&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; , &lt;em&gt;encoding&lt;/em&gt; , &lt;em&gt;errors&lt;/em&gt; , &lt;em&gt;strict&lt;/em&gt; 및 &lt;em&gt;buffer&lt;/em&gt; 는 &lt;a href=&quot;#pickle.Unpickler&quot;&gt; &lt;code&gt;Unpickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="d89665ba13ee62d24ea7f2b734e91ef581e6bf8d" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;file&lt;/em&gt;, &lt;em&gt;protocol&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt; and &lt;em&gt;buffer_callback&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;file&lt;/em&gt; , &lt;em&gt;protocol&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; 및 &lt;em&gt;buffer_callback&lt;/em&gt; 은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="062cac0907e3b6761cd5955db7e55e88c29370c5" translate="yes" xml:space="preserve">
          <source>Arguments &lt;em&gt;protocol&lt;/em&gt;, &lt;em&gt;fix_imports&lt;/em&gt; and &lt;em&gt;buffer_callback&lt;/em&gt; have the same meaning as in the &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">인수 &lt;em&gt;protocol&lt;/em&gt; , &lt;em&gt;fix_imports&lt;/em&gt; 및 &lt;em&gt;buffer_callback&lt;/em&gt; 은 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 생성자 와 동일한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="abe50e0f8895e96e60e7ed8a520f00b347b19db9" translate="yes" xml:space="preserve">
          <source>Arguments are as for &lt;a href=&quot;#http.cookiejar.FileCookieJar.save&quot;&gt;&lt;code&gt;save()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">인수는 &lt;a href=&quot;#http.cookiejar.FileCookieJar.save&quot;&gt; &lt;code&gt;save()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31b8834506fb3b7c5be5a3ce85e8e0c3db7c0b3f" translate="yes" xml:space="preserve">
          <source>Arguments are delimited by white space, which is either a space or a tab.</source>
          <target state="translated">인수는 공백 또는 탭인 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="ca383ab55205e5fb89e07118c8e14e4621db4341" translate="yes" xml:space="preserve">
          <source>Arguments containing &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">다음을 포함하는 인수 &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7d8d9a6376cd495ec8cafea6a5b8bff545de70d" translate="yes" xml:space="preserve">
          <source>Arguments for which &lt;a href=&quot;#inspect.Signature.bind&quot;&gt;&lt;code&gt;Signature.bind()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#inspect.Signature.bind_partial&quot;&gt;&lt;code&gt;Signature.bind_partial()&lt;/code&gt;&lt;/a&gt; relied on a default value are skipped. However, if needed, use &lt;a href=&quot;#inspect.BoundArguments.apply_defaults&quot;&gt;&lt;code&gt;BoundArguments.apply_defaults()&lt;/code&gt;&lt;/a&gt; to add them.</source>
          <target state="translated">&lt;a href=&quot;#inspect.Signature.bind&quot;&gt; &lt;code&gt;Signature.bind()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#inspect.Signature.bind_partial&quot;&gt; &lt;code&gt;Signature.bind_partial()&lt;/code&gt; &lt;/a&gt; 이 기본값에 의존 하는 인수 는 건너 뜁니다. 그러나 필요한 경우 &lt;a href=&quot;#inspect.BoundArguments.apply_defaults&quot;&gt; &lt;code&gt;BoundArguments.apply_defaults()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cc5642db0a84a9bfcf6fa6b2be3d81eb1124eeef" translate="yes" xml:space="preserve">
          <source>Arguments read from a file must by default be one per line (but see also &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt;&lt;code&gt;convert_arg_line_to_args()&lt;/code&gt;&lt;/a&gt;) and are treated as if they were in the same place as the original file referencing argument on the command line. So in the example above, the expression &lt;code&gt;['-f', 'foo', '@args.txt']&lt;/code&gt; is considered equivalent to the expression &lt;code&gt;['-f', 'foo', '-f', 'bar']&lt;/code&gt;.</source>
          <target state="translated">파일에서 읽은 인수는 기본적으로 한 줄에 하나씩 있어야하지만 ( &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt; &lt;code&gt;convert_arg_line_to_args()&lt;/code&gt; &lt;/a&gt; 참조) 명령 줄에서 원래 파일 참조 인수와 같은 위치에있는 것처럼 처리됩니다. 따라서 위의 예에서 &lt;code&gt;['-f', 'foo', '@args.txt']&lt;/code&gt; 표현식은 &lt;code&gt;['-f', 'foo', '-f', 'bar']&lt;/code&gt; 표현식과 동등한 것으로 간주됩니다 . .</target>
        </trans-unit>
        <trans-unit id="254fe913b44f0083c86b3a72eb64233d6c9c9037" translate="yes" xml:space="preserve">
          <source>Arguments that are read from a file (see the &lt;em&gt;fromfile_prefix_chars&lt;/em&gt; keyword argument to the &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; constructor) are read one argument per line. &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt;&lt;code&gt;convert_arg_line_to_args()&lt;/code&gt;&lt;/a&gt; can be overridden for fancier reading.</source>
          <target state="translated">파일에서 읽은 인수 ( &lt;em&gt;fromfile_prefix_chars&lt;/em&gt; 키워드 인수를 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 생성자 참조)는 한 줄에 하나의 인수를 읽습니다. 더 빠른 읽기를 위해 &lt;a href=&quot;#argparse.ArgumentParser.convert_arg_line_to_args&quot;&gt; &lt;code&gt;convert_arg_line_to_args()&lt;/code&gt; &lt;/a&gt; 를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c888f0156e119be7fcf794112bbc633d3a855af" translate="yes" xml:space="preserve">
          <source>Arguments, return values and exceptions raised should be the same as for &lt;code&gt;http_error_default()&lt;/code&gt;.</source>
          <target state="translated">인수, 리턴 값 및 예외는 &lt;code&gt;http_error_default()&lt;/code&gt; 와 동일해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="05d9f54c2dee44d1764ce455fe2d7d6a602d3b2c" translate="yes" xml:space="preserve">
          <source>Arithmetic mean (&amp;ldquo;average&amp;rdquo;) of data.</source>
          <target state="translated">데이터의 산술 평균 (&amp;ldquo;평균&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="5509c94c0f9f738717633e15c4c8dbc85e63a4c9" translate="yes" xml:space="preserve">
          <source>ArithmeticError</source>
          <target state="translated">ArithmeticError</target>
        </trans-unit>
        <trans-unit id="00bda803d743e23213c7aa7e2ecbc5b4d57d34e7" translate="yes" xml:space="preserve">
          <source>Arrange for &lt;code&gt;callback(pid, returncode, *args)&lt;/code&gt; to be called when a process with PID equal to &lt;em&gt;pid&lt;/em&gt; terminates. Specifying another callback for the same process replaces the previous handler.</source>
          <target state="translated">PID가 &lt;em&gt;pid 인&lt;/em&gt; 프로세스가 종료 될 때 &lt;code&gt;callback(pid, returncode, *args)&lt;/code&gt; 이 호출되도록 배열하십시오 . 동일한 프로세스에 다른 콜백을 지정하면 이전 핸들러가 바뀝니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e83bc7d750aaf3109a4f2191f8a594db7bc12dc" translate="yes" xml:space="preserve">
          <source>Arrange for &lt;em&gt;func&lt;/em&gt; to be called in the specified executor.</source>
          <target state="translated">주선 &lt;em&gt;FUNC&lt;/em&gt; 지정된 실행기에서 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ce67aeaeb955aba8123768b6b67cd81cceff896b" translate="yes" xml:space="preserve">
          <source>Arrange the given list of classes into a hierarchy of nested lists. Where a nested list appears, it contains classes derived from the class whose entry immediately precedes the list. Each entry is a 2-tuple containing a class and a tuple of its base classes. If the &lt;em&gt;unique&lt;/em&gt; argument is true, exactly one entry appears in the returned structure for each class in the given list. Otherwise, classes using multiple inheritance and their descendants will appear multiple times.</source>
          <target state="translated">주어진 클래스 목록을 중첩 된 목록의 계층 구조로 배열하십시오. 중첩 된 목록이 나타나면 목록 바로 앞에 항목이있는 클래스에서 파생 된 클래스가 포함됩니다. 각 항목은 클래스와 기본 클래스의 튜플을 포함하는 2 개의 튜플입니다. 는 IF &lt;em&gt;고유의&lt;/em&gt; 인수가 true, 정확히 하나 개의 항목이 주어진 목록의 각 클래스에 대한 반환 된 구조에 나타납니다. 그렇지 않으면 다중 상속을 사용하는 클래스와 그 하위 항목이 여러 번 나타납니다.</target>
        </trans-unit>
        <trans-unit id="e09bcef1e1561563a4c3e831676e473af1795dff" translate="yes" xml:space="preserve">
          <source>Array objects support the ordinary sequence operations of indexing, slicing, concatenation, and multiplication. When using slice assignment, the assigned value must be an array object with the same type code; in all other cases, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised. Array objects also implement the buffer interface, and may be used wherever &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are supported.</source>
          <target state="translated">배열 객체는 인덱싱, 슬라이싱, 연결 및 곱셈의 일반적인 시퀀스 작업을 지원합니다. 슬라이스 할당을 사용할 때 할당 된 값은 유형 코드가 동일한 배열 객체 여야합니다. 다른 모든 경우에는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열 객체는 또한 버퍼 인터페이스를 구현하며 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 가 지원 되는 모든 곳에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5629452c562743594978bfd2aa7bcc43bf09bd7f" translate="yes" xml:space="preserve">
          <source>Array objects support the ordinary sequence operations of indexing, slicing, concatenation, and multiplication. When using slice assignment, the assigned value must be an array object with the same type code; in all other cases, &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised. Array objects also implement the buffer interface, and may be used wherever &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; are supported.</source>
          <target state="translated">배열 객체는 인덱싱, 슬라이싱, 연결 및 곱셈의 일반적인 시퀀스 작업을 지원합니다. 슬라이스 할당을 사용할 때 할당 된 값은 동일한 유형 코드를 가진 배열 객체 여야합니다. 다른 모든 경우에는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 배열 객체는 또한 버퍼 인터페이스를 구현하며 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 가 지원 되는 모든 곳에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a038e3af2ef2f9438b219a899eb40b5d237a4ed2" translate="yes" xml:space="preserve">
          <source>Array subclass constructors accept positional arguments, used to initialize the elements in order.</source>
          <target state="translated">배열 서브 클래스 생성자는 요소를 순서대로 초기화하는 데 사용되는 위치 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="2116ae0173d1a47165ce7b4c6dd99787a4f44df7" translate="yes" xml:space="preserve">
          <source>Arrays and pointers</source>
          <target state="translated">배열과 포인터</target>
        </trans-unit>
        <trans-unit id="d2ba2d6827acb128b9bc6dce24cfef791a15ff8e" translate="yes" xml:space="preserve">
          <source>Arrays are sequences, containing a fixed number of instances of the same type.</source>
          <target state="translated">배열은 동일한 유형의 고정 된 수의 인스턴스를 포함하는 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="ea1bebde72fbc4b9eac4d8bc3c178b395db87608" translate="yes" xml:space="preserve">
          <source>Arrow keys and</source>
          <target state="translated">화살표 키와</target>
        </trans-unit>
        <trans-unit id="492a48af0242c28b406dd17c1e3f267f5f7d0dde" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt;, return a string containing a printable representation of an object, but escape the non-ASCII characters in the string returned by &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;\x&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt; or &lt;code&gt;\U&lt;/code&gt; escapes. This generates a string similar to that returned by &lt;a href=&quot;#repr&quot;&gt;&lt;code&gt;repr()&lt;/code&gt;&lt;/a&gt; in Python 2.</source>
          <target state="translated">대로 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 문자열에 비 ASCII 문자를 객체의 인쇄 가능한 표현을 포함하는 문자열을 반환하지만 탈출 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 사용하여 &lt;code&gt;\x&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; 또는 &lt;code&gt;\U&lt;/code&gt; 이스케이프합니다. 파이썬 2에서 &lt;a href=&quot;#repr&quot;&gt; &lt;code&gt;repr()&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 것과 비슷한 문자열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="02f76a37b3c37f88ec864fc817fca31de5c8cd6a" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;__enter__&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; invoked, this method can be used to cover part of an &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation with a context manager&amp;rsquo;s own &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">마찬가지로 &lt;code&gt;__enter__&lt;/code&gt; 가 되어 &lt;em&gt;있지&lt;/em&gt; 호출이 방법은 표지 부분에 사용될 수있다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자 자체로 구현 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="4fd9aad41fb0d98af1b5721b9ec8f46889133ea0" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;__enter__&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; invoked, this method can be used to cover part of an &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation with a context manager&amp;rsquo;s own &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">마찬가지로 &lt;code&gt;__enter__&lt;/code&gt; 가 되어 &lt;em&gt;있지&lt;/em&gt; 호출이 방법은 표지 부분에 사용될 수있다 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 콘텍스트 관리자 자체로 구현 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="21a1436804ffd6271fbdf496e469190ad95cfadb" translate="yes" xml:space="preserve">
          <source>As IPv4 does not define a shorthand notation for addresses with octets set to zero, these two attributes are always the same as &lt;code&gt;str(addr)&lt;/code&gt; for IPv4 addresses. Exposing these attributes makes it easier to write display code that can handle both IPv4 and IPv6 addresses.</source>
          <target state="translated">IPv4는 옥텟이 0으로 설정된 주소에 대한 속기 표기법을 정의하지 않으므로이 두 속성은 항상 IPv4 주소의 &lt;code&gt;str(addr)&lt;/code&gt; 과 동일 합니다. 이러한 속성을 노출하면 IPv4 및 IPv6 주소를 모두 처리 할 수있는 디스플레이 코드를보다 쉽게 ​​작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01b75b6a03e85825e5ae6f5174dafbcc20884f22" translate="yes" xml:space="preserve">
          <source>As UTF-8 is an 8-bit encoding no BOM is required and any &lt;code&gt;U+FEFF&lt;/code&gt; character in the decoded string (even if it&amp;rsquo;s the first character) is treated as a &lt;code&gt;ZERO
WIDTH NO-BREAK SPACE&lt;/code&gt;.</source>
          <target state="translated">UTF-8은 8 비트 인코딩이므로 BOM이 필요하지 않으며 디코딩 된 문자열의 &lt;code&gt;U+FEFF&lt;/code&gt; 문자 (첫 번째 문자 임에도 불구하고)는 &lt;code&gt;ZERO WIDTH NO-BREAK SPACE&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="e93d4b1e7a80c62c1fe29ce1183609ea319edc6b" translate="yes" xml:space="preserve">
          <source>As a basic example, below is a simple HTML parser that uses the &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt;&lt;code&gt;HTMLParser&lt;/code&gt;&lt;/a&gt; class to print out start tags, end tags, and data as they are encountered:</source>
          <target state="translated">기본적인 예로, 아래는 &lt;a href=&quot;#html.parser.HTMLParser&quot;&gt; &lt;code&gt;HTMLParser&lt;/code&gt; &lt;/a&gt; 클래스를 사용하여 시작 태그, 종료 태그 및 데이터가 발견 될 때 인쇄 하는 간단한 HTML 파서입니다 .</target>
        </trans-unit>
        <trans-unit id="56cc68f817847f0888385ee2f0ae8a8820897e0f" translate="yes" xml:space="preserve">
          <source>As a consequence, the list &lt;code&gt;[1, 2]&lt;/code&gt; is considered equal to &lt;code&gt;[1.0, 2.0]&lt;/code&gt;, and similarly for tuples.</source>
          <target state="translated">결과적으로,리스트 &lt;code&gt;[1, 2]&lt;/code&gt; 는 &lt;code&gt;[1.0, 2.0]&lt;/code&gt; 과 같 으며 튜플과 유사하게 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c47037d0ed57ce0ffcb9e6f5f456d8a5dfad7c5" translate="yes" xml:space="preserve">
          <source>As a convenience &lt;em&gt;addr_spec&lt;/em&gt; can be specified instead of &lt;em&gt;username&lt;/em&gt; and &lt;em&gt;domain&lt;/em&gt;, in which case &lt;em&gt;username&lt;/em&gt; and &lt;em&gt;domain&lt;/em&gt; will be parsed from the &lt;em&gt;addr_spec&lt;/em&gt;. An &lt;em&gt;addr_spec&lt;/em&gt; must be a properly RFC quoted string; if it is not &lt;code&gt;Address&lt;/code&gt; will raise an error. Unicode characters are allowed and will be property encoded when serialized. However, per the RFCs, unicode is &lt;em&gt;not&lt;/em&gt; allowed in the username portion of the address.</source>
          <target state="translated">편의상 &lt;em&gt;username&lt;/em&gt; 과 &lt;em&gt;domain&lt;/em&gt; 대신 &lt;em&gt;addr_spec을&lt;/em&gt; 지정할 수 있으며 ,이 경우 &lt;em&gt;addr_spec&lt;/em&gt; 에서 &lt;em&gt;username&lt;/em&gt; 과 &lt;em&gt;domain&lt;/em&gt; 이 구문 분석됩니다 . &lt;em&gt;addr_spec은&lt;/em&gt; 제대로 RFC 인용 문자열이어야합니다; &lt;code&gt;Address&lt;/code&gt; 가 아닌 경우 오류가 발생합니다. 유니 코드 문자는 허용되며 직렬화 할 때 속성 인코딩됩니다. 그러나 RFC 에 따라 주소의 사용자 이름 부분에는 유니 코드가 허용 &lt;em&gt;되지&lt;/em&gt; 않습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="56d9575dc7f90bc34c436a75f7caf3eeeecd477e" translate="yes" xml:space="preserve">
          <source>As a convenience for processing lists of addresses that consist of a mixture of groups and single addresses, a &lt;code&gt;Group&lt;/code&gt; may also be used to represent single addresses that are not part of a group by setting &lt;em&gt;display_name&lt;/em&gt; to &lt;code&gt;None&lt;/code&gt; and providing a list of the single address as &lt;em&gt;addresses&lt;/em&gt;.</source>
          <target state="translated">그룹과 단일 주소의 혼합으로 구성된 주소 목록을 처리하기위한 편의상 &lt;code&gt;Group&lt;/code&gt; 은 &lt;em&gt;display_name&lt;/em&gt; 을 &lt;code&gt;None&lt;/code&gt; 으로 설정 하고 단일 주소 목록을 다음과 같이 제공하여 그룹의 일부가 아닌 단일 주소를 나타내는 데 사용될 수도 있습니다. &lt;em&gt;주소&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="21c6d9923ff5341e64ead3588bfe1b0fc8708eec" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the methods &lt;a href=&quot;email.message#email.message.EmailMessage.as_bytes&quot;&gt;&lt;code&gt;as_bytes()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;bytes(aMessage)&lt;/code&gt; (a.k.a. &lt;a href=&quot;email.message#email.message.EmailMessage.__bytes__&quot;&gt;&lt;code&gt;__bytes__()&lt;/code&gt;&lt;/a&gt;), which simplify the generation of a serialized binary representation of a message object. For more detail, see &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 는&lt;/a&gt; 방법의 제공 &lt;a href=&quot;email.message#email.message.EmailMessage.as_bytes&quot;&gt; &lt;code&gt;as_bytes()&lt;/code&gt; &lt;/a&gt; 와 &lt;code&gt;bytes(aMessage)&lt;/code&gt; (일명 &lt;a href=&quot;email.message#email.message.EmailMessage.__bytes__&quot;&gt; &lt;code&gt;__bytes__()&lt;/code&gt; &lt;/a&gt; ) 메시지 객체의 직렬화 이진 표현의 생성을 간소화한다. 자세한 내용은 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4abff2ddf7e07b5dde53a45acae67c7d73f15471" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; provides the methods &lt;a href=&quot;email.message#email.message.EmailMessage.as_string&quot;&gt;&lt;code&gt;as_string()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;str(aMessage)&lt;/code&gt; (a.k.a. &lt;a href=&quot;email.message#email.message.EmailMessage.__str__&quot;&gt;&lt;code&gt;__str__()&lt;/code&gt;&lt;/a&gt;), which simplify the generation of a formatted string representation of a message object. For more detail, see &lt;a href=&quot;email.message#module-email.message&quot;&gt;&lt;code&gt;email.message&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">편의상, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; 이&lt;/a&gt; 방법 제공 &lt;a href=&quot;email.message#email.message.EmailMessage.as_string&quot;&gt; &lt;code&gt;as_string()&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;str(aMessage)&lt;/code&gt; (일명 &lt;a href=&quot;email.message#email.message.EmailMessage.__str__&quot;&gt; &lt;code&gt;__str__()&lt;/code&gt; &lt;/a&gt; ) 메시지 객체의 포맷 문자열 표현의 생성을 간소화한다. 자세한 내용은 &lt;a href=&quot;email.message#module-email.message&quot;&gt; &lt;code&gt;email.message&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="702d8b69bc2e4520c3ea7fda0210ac4d16730354" translate="yes" xml:space="preserve">
          <source>As a convenience, it is allowed to call this method more than once; only the first call, however, will have an effect.</source>
          <target state="translated">편의상이 메소드를 두 번 이상 호출 할 수 있습니다. 그러나 첫 번째 전화 만 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="246fcbe17d21c864d76f20a8ea7b1030891cbcc5" translate="yes" xml:space="preserve">
          <source>As a default namespace, if &lt;em&gt;globs&lt;/em&gt; is not specified.</source>
          <target state="translated">&lt;em&gt;globs&lt;/em&gt; 가 지정되지 않은 경우 기본 네임 스페이스로 .</target>
        </trans-unit>
        <trans-unit id="59fca4637f2c6a11c94c0115101f5eb5fe7f8b54" translate="yes" xml:space="preserve">
          <source>As a hint: &lt;em&gt;ptype&lt;/em&gt; is &lt;code&gt;'Uniprocessor Free'&lt;/code&gt; on single processor NT machines and &lt;code&gt;'Multiprocessor Free'&lt;/code&gt; on multi processor machines. The &lt;em&gt;&amp;lsquo;Free&amp;rsquo;&lt;/em&gt; refers to the OS version being free of debugging code. It could also state &lt;em&gt;&amp;lsquo;Checked&amp;rsquo;&lt;/em&gt; which means the OS version uses debugging code, i.e. code that checks arguments, ranges, etc.</source>
          <target state="translated">힌트 : &lt;em&gt;ptype&lt;/em&gt; 은 단일 프로세서 NT 시스템에서 &lt;code&gt;'Uniprocessor Free'&lt;/code&gt; 이고 다중 프로세서 시스템에서 &lt;code&gt;'Multiprocessor Free'&lt;/code&gt; 입니다. &lt;em&gt;'무료'&lt;/em&gt; 코드를 디버깅이없는 것으로 OS 버전을 의미합니다. 또한 OS 버전이 디버깅 코드, 즉 인수, 범위 등을 확인하는 코드를 사용한다는 것을 의미하는 &lt;em&gt;'Checked'라고 표시&lt;/em&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="01542f6485eff7fcd66532527eb2903905db20bd" translate="yes" xml:space="preserve">
          <source>As a last resort, the current working directory.</source>
          <target state="translated">최후의 수단으로 현재 작업 디렉토리.</target>
        </trans-unit>
        <trans-unit id="4394d88d5506fb6bad90992f89785a34f016a9f1" translate="yes" xml:space="preserve">
          <source>As a practical example, a web application can symmetrically sign cookies sent to users and later verify them to make sure they weren&amp;rsquo;t tampered with:</source>
          <target state="translated">실용적인 예로, 웹 응용 프로그램은 사용자에게 전송 된 쿠키에 대칭 적으로 서명하고 나중에 쿠키가 변경되지 않았는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7a3250916881530139f1d3c3f521304a2d00f953" translate="yes" xml:space="preserve">
          <source>As a resource for sharing data across processes, shared memory blocks may outlive the original process that created them. When one process no longer needs access to a shared memory block that might still be needed by other processes, the &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt; method should be called. When a shared memory block is no longer needed by any process, the &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.unlink&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt; method should be called to ensure proper cleanup.</source>
          <target state="translated">프로세스간에 데이터를 공유하기위한 리소스로서 공유 메모리 블록은이를 생성 한 원래 프로세스보다 오래 지속될 수 있습니다. 한 프로세스가 더 이상 다른 프로세스에 필요할 수있는 공유 메모리 블록에 액세스 할 필요가 없으면 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다. 프로세스에서 공유 메모리 블록이 더 이상 필요하지 않으면 적절한 정리를 위해 &lt;a href=&quot;#multiprocessing.shared_memory.SharedMemory.unlink&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; 메소드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="461cbf814397c1a6ad159d386793e5950747ea9b" translate="yes" xml:space="preserve">
          <source>As a result, these tables are exposed as functions, not as data structures. There are two kinds of tables in the RFC: sets and mappings. For a set, &lt;a href=&quot;#module-stringprep&quot;&gt;&lt;code&gt;stringprep&lt;/code&gt;&lt;/a&gt; provides the &amp;ldquo;characteristic function&amp;rdquo;, i.e. a function that returns &lt;code&gt;True&lt;/code&gt; if the parameter is part of the set. For mappings, it provides the mapping function: given the key, it returns the associated value. Below is a list of all functions available in the module.</source>
          <target state="translated">결과적으로이 테이블은 데이터 구조가 아니라 함수로 노출됩니다. RFC에는 두 가지 종류의 테이블 인 집합과 매핑이 있습니다. 세트의 경우, &lt;a href=&quot;#module-stringprep&quot;&gt; &lt;code&gt;stringprep&lt;/code&gt; &lt;/a&gt; 은 &quot;특성 함수&quot;, 즉 매개 변수가 세트의 일부인 경우 &lt;code&gt;True&lt;/code&gt; 를 리턴하는 함수를 제공합니다 . 맵핑의 경우 맵핑 기능을 제공합니다. 키가 제공되면 연관된 값을 리턴합니다. 아래는 모듈에서 사용 가능한 모든 기능의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2a184ffa1e02bb553c3cf1bb5908fd5b4956ff6b" translate="yes" xml:space="preserve">
          <source>As a shortcut, &lt;code&gt;python -m unittest&lt;/code&gt; is the equivalent of &lt;code&gt;python -m unittest discover&lt;/code&gt;. If you want to pass arguments to test discovery the &lt;code&gt;discover&lt;/code&gt; sub-command must be used explicitly.</source>
          <target state="translated">바로 가기로서, &lt;code&gt;python -m unittest&lt;/code&gt; 하는 것과 동일 &lt;code&gt;python -m unittest discover&lt;/code&gt; . 감지를 테스트하기 위해 인수를 전달하려면 &lt;code&gt;discover&lt;/code&gt; 하위 명령을 명시 적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8c6052cb2b7ab711a2dfe70683f2ac20c152dc62" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can pass the first chunk of data to update directly to the constructor as the positional argument:</source>
          <target state="translated">바로 가기로, 첫 번째 데이터 청크를 전달하여 위치 인수로 생성자에 직접 업데이트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="589b7e27763c67c7426c653620d97a4afe45eed8" translate="yes" xml:space="preserve">
          <source>As a shorthand for this type, &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; can be used to annotate arguments of any of the types mentioned above.</source>
          <target state="translated">이 유형의 줄임말로, &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 는 위에서 언급 한 유형의 인수에 주석을 달기 위해 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edc30d222e457c2b86d38c6dc2682bd1cf49fbc5" translate="yes" xml:space="preserve">
          <source>As a single multi-line string it looks like this:</source>
          <target state="translated">단일 여러 줄 문자열로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31fec187f046cbb0fe0fcc91b7f32ecb2bd751ff" translate="yes" xml:space="preserve">
          <source>As an &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt;&lt;code&gt;Element&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;root&lt;/code&gt; has a tag and a dictionary of attributes:</source>
          <target state="translated">AS를 &lt;a href=&quot;#xml.etree.ElementTree.Element&quot;&gt; &lt;code&gt;Element&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;root&lt;/code&gt; 태그 및 속성의 사전을 가지고 :</target>
        </trans-unit>
        <trans-unit id="f8f3227359947ab2ce5b9947bd2e229fe5f93f58" translate="yes" xml:space="preserve">
          <source>As an added bonus you no longer need to keep a reference to the &lt;code&gt;patcher&lt;/code&gt; object.</source>
          <target state="translated">추가 보너스로 더 이상 &lt;code&gt;patcher&lt;/code&gt; 객체에 대한 참조를 유지할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="b503ab5544f8b7e846527fe7cd3425f0b5545263" translate="yes" xml:space="preserve">
          <source>As an alternative to using the &lt;code&gt;request()&lt;/code&gt; method described above, you can also send your request step by step, by using the four functions below.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;request()&lt;/code&gt; 메소드 를 사용하는 대신 아래 네 가지 함수를 사용하여 단계별로 요청을 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7336776d38139cf85922861d97a6c8dfca4d4e8" translate="yes" xml:space="preserve">
          <source>As an example, here are two useful aliases (especially when placed in the &lt;code&gt;.pdbrc&lt;/code&gt; file):</source>
          <target state="translated">예를 들어 다음은 두 가지 유용한 별칭입니다 (특히 &lt;code&gt;.pdbrc&lt;/code&gt; 파일 에있을 때 ).</target>
        </trans-unit>
        <trans-unit id="5a80b839cbf77be14d284871859db2716a2d8281" translate="yes" xml:space="preserve">
          <source>As an example, here is a simple way to synchronize a client and server thread:</source>
          <target state="translated">예를 들어, 클라이언트와 서버 스레드를 동기화하는 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0f4562ba3c72351908cae38e3fc969623aaf1135" translate="yes" xml:space="preserve">
          <source>As an example, let&amp;rsquo;s change the Combobox for the default theme a bit:</source>
          <target state="translated">예를 들어, 기본 테마의 콤보 박스를 약간 변경해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="4228081bb4db5df72a0d8ad128755e932ebc79ee" translate="yes" xml:space="preserve">
          <source>As an example, the following calls to &lt;a href=&quot;#os.spawnlp&quot;&gt;&lt;code&gt;spawnlp()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.spawnvpe&quot;&gt;&lt;code&gt;spawnvpe()&lt;/code&gt;&lt;/a&gt; are equivalent:</source>
          <target state="translated">예를 들어, &lt;a href=&quot;#os.spawnlp&quot;&gt; &lt;code&gt;spawnlp()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.spawnvpe&quot;&gt; &lt;code&gt;spawnvpe()&lt;/code&gt; &lt;/a&gt; 대한 다음 호출 은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba4b1a6703f8b07e5a6b60e4bad30c91c5890466" translate="yes" xml:space="preserve">
          <source>As an example, the following code could be used to read an email message from a file on disk and pass it to the system &lt;code&gt;sendmail&lt;/code&gt; program on a Unix system:</source>
          <target state="translated">예를 들어, 다음 코드를 사용하여 디스크의 파일에서 전자 메일 메시지를 읽고 Unix 시스템 의 시스템 &lt;code&gt;sendmail&lt;/code&gt; 프로그램으로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbacbe7504a62ca3305f0051ceceb7ce7683b37" translate="yes" xml:space="preserve">
          <source>As an implementation detail, most modules have the name &lt;code&gt;__builtins__&lt;/code&gt; made available as part of their globals. The value of &lt;code&gt;__builtins__&lt;/code&gt; is normally either this module or the value of this module&amp;rsquo;s &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt;&lt;code&gt;__dict__&lt;/code&gt;&lt;/a&gt; attribute. Since this is an implementation detail, it may not be used by alternate implementations of Python.</source>
          <target state="translated">구현 세부 사항으로 대부분의 모듈은 &lt;code&gt;__builtins__&lt;/code&gt; 라는 이름을 전역의 일부로 제공합니다. &lt;code&gt;__builtins__&lt;/code&gt; 값 은 일반적으로이 모듈 &lt;a href=&quot;stdtypes#object.__dict__&quot;&gt; &lt;code&gt;__dict__&lt;/code&gt; &lt;/a&gt; 모듈의 __dict__ 특성 값입니다 . 이것은 구현 세부 사항이므로 파이썬의 대체 구현에서는 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c7b885f679999067032935a1aa6716b565ddb72" translate="yes" xml:space="preserve">
          <source>As at any time a re-negotiation is possible, a call to &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; can also cause write operations.</source>
          <target state="translated">재협상이 가능할 때마다 &lt;a href=&quot;#ssl.SSLSocket.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 호출로 인해 쓰기 작업이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fd487951e11f4d42348b340f0a9fb430d37c5cc" translate="yes" xml:space="preserve">
          <source>As at any time a re-negotiation is possible, a call to &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt;&lt;code&gt;write()&lt;/code&gt;&lt;/a&gt; can also cause read operations.</source>
          <target state="translated">재협상이 가능할 때마다 &lt;a href=&quot;#ssl.SSLSocket.write&quot;&gt; &lt;code&gt;write()&lt;/code&gt; &lt;/a&gt; 호출로 인해 읽기 작업이 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e24aa9e1ac5aea4c36f22d36193b3afce59ac93" translate="yes" xml:space="preserve">
          <source>As bytearray objects are mutable, they support the &lt;a href=&quot;#typesseq-mutable&quot;&gt;mutable&lt;/a&gt; sequence operations in addition to the common bytes and bytearray operations described in &lt;a href=&quot;#bytes-methods&quot;&gt;Bytes and Bytearray Operations&lt;/a&gt;.</source>
          <target state="translated">이 ByteArray 오브젝트가 변하는, 그들은지지 &lt;a href=&quot;#typesseq-mutable&quot;&gt;변경할&lt;/a&gt; 에 기재된 일반적인 바이트 된 ByteArray 조작 이외에 시퀀스 연산 &lt;a href=&quot;#bytes-methods&quot;&gt;바이트 오퍼레이션이 ByteArray&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78bf9d41f9b029450b419cb811cff375582f4159" translate="yes" xml:space="preserve">
          <source>As described before, SQLite supports only a limited set of types natively. To use other Python types with SQLite, you must &lt;strong&gt;adapt&lt;/strong&gt; them to one of the sqlite3 module&amp;rsquo;s supported types for SQLite: one of NoneType, int, float, str, bytes.</source>
          <target state="translated">앞에서 설명한 것처럼 SQLite는 기본적으로 제한된 유형의 집합 만 지원합니다. SQLite와 함께 다른 Python 유형을 사용하려면 SQLite 에 대해 sqlite3 모듈에서 지원되는 유형 중 하나에 NoneType, int, float, str, bytes 중 하나를 &lt;strong&gt;적용&lt;/strong&gt; 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="12104d6983d2c0ac8c4e8e3db3bbb26e8a81d6cd" translate="yes" xml:space="preserve">
          <source>As explained in the previous section, foreign functions can be accessed as attributes of loaded shared libraries. The function objects created in this way by default accept any number of arguments, accept any ctypes data instances as arguments, and return the default result type specified by the library loader. They are instances of a private class:</source>
          <target state="translated">이전 섹션에서 설명한 것처럼 외부 함수는로드 된 공유 라이브러리의 속성으로 액세스 할 수 있습니다. 기본적으로이 방식으로 작성된 함수 오브젝트는 여러 개의 인수를 허용하고 ctypes 데이터 인스턴스를 인수로 승인하며 라이브러리 로더가 지정한 기본 결과 유형을 리턴합니다. 개인 클래스의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="c1c8f40732d97a4b4e90b1a6e8a0be872ac0ea63" translate="yes" xml:space="preserve">
          <source>As far as possible one should try to avoid shifting large amounts of data between processes.</source>
          <target state="translated">가능한 한 프로세스간에 많은 양의 데이터가 이동되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="1dbfa2bc97572579991ca5c4ddb17267e21f80e3" translate="yes" xml:space="preserve">
          <source>As has been mentioned before, all Python types except integers, strings, and bytes objects have to be wrapped in their corresponding &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type, so that they can be converted to the required C data type:</source>
          <target state="translated">앞에서 언급했듯이 정수, 문자열 및 바이트 객체를 제외한 모든 Python 유형은 해당 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 유형 으로 랩핑되어 필요한 C 데이터 유형으로 변환 될 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ddf55edc3a51e93aacbc734fc2d7fe5eb787249" translate="yes" xml:space="preserve">
          <source>As initialized upon program startup, the first item of this list, &lt;code&gt;path[0]&lt;/code&gt;, is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), &lt;code&gt;path[0]&lt;/code&gt; is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted &lt;em&gt;before&lt;/em&gt; the entries inserted as a result of &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-21&quot;&gt;&lt;code&gt;PYTHONPATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로그램 시작시 초기화 된대로이 목록의 첫 번째 항목 인 &lt;code&gt;path[0]&lt;/code&gt; 은 Python 인터프리터를 호출하는 데 사용 된 스크립트가 포함 된 디렉토리입니다. 스크립트 디렉토리를 사용할 수없는 경우 (예 : 인터프리터가 대화식으로 호출되거나 표준 입력에서 스크립트를 읽는 경우) &lt;code&gt;path[0]&lt;/code&gt; 은 빈 문자열로, 현재 디렉토리에서 모듈을 먼저 검색하도록 Python에 지시합니다. 스크립트 디렉토리는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-21&quot;&gt; &lt;code&gt;PYTHONPATH&lt;/code&gt; &lt;/a&gt; 의 결과로 삽입 된 항목 &lt;em&gt;앞에&lt;/em&gt; 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="56a04625be80324cea19908dff1bffa8f839b261" translate="yes" xml:space="preserve">
          <source>As initialized upon program startup, the first item of this list, &lt;code&gt;path[0]&lt;/code&gt;, is the directory containing the script that was used to invoke the Python interpreter. If the script directory is not available (e.g. if the interpreter is invoked interactively or if the script is read from standard input), &lt;code&gt;path[0]&lt;/code&gt; is the empty string, which directs Python to search modules in the current directory first. Notice that the script directory is inserted &lt;em&gt;before&lt;/em&gt; the entries inserted as a result of &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-22&quot;&gt;&lt;code&gt;PYTHONPATH&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">프로그램 시작시 초기화 된대로이 목록의 첫 번째 항목 인 &lt;code&gt;path[0]&lt;/code&gt; 은 Python 인터프리터를 호출하는 데 사용 된 스크립트를 포함하는 디렉토리입니다. 스크립트 디렉토리를 사용할 수없는 경우 (예 : 인터프리터가 대화 형으로 호출되거나 스크립트가 표준 입력에서 읽혀지는 경우) &lt;code&gt;path[0]&lt;/code&gt; 은 빈 문자열이며, 이는 Python이 먼저 현재 디렉토리에서 모듈을 검색하도록 지시합니다. &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONPATH&quot; id=&quot;index-22&quot;&gt; &lt;code&gt;PYTHONPATH&lt;/code&gt; &lt;/a&gt; 의 결과로 삽입 된 항목 &lt;em&gt;앞에&lt;/em&gt; 스크립트 디렉토리가 삽입 됩니다.</target>
        </trans-unit>
        <trans-unit id="19b1c3ec635acfaf81b14d105d3a7b1195ceafe9" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, a variable annotation wrapped in ClassVar indicates that a given attribute is intended to be used as a class variable and should not be set on instances of that class. Usage:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-18&quot;&gt;&lt;strong&gt;PEP 526에&lt;/strong&gt;&lt;/a&gt; 도입 된대로 ClassVar에 래핑 된 변수 주석은 주어진 속성이 클래스 변수로 사용되도록 의도되었으며 해당 클래스의 인스턴스에 설정되지 않아야 함을 나타냅니다. 용법:</target>
        </trans-unit>
        <trans-unit id="6d02dd5a1c0be670a5afec6d8bf7ade0cbe0a443" translate="yes" xml:space="preserve">
          <source>As introduced in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt;, a variable annotation wrapped in ClassVar indicates that a given attribute is intended to be used as a class variable and should not be set on instances of that class. Usage:</source>
          <target state="translated">&lt;a href=&quot;https://www.python.org/dev/peps/pep-0526&quot; id=&quot;index-22&quot;&gt;&lt;strong&gt;PEP 526&lt;/strong&gt;&lt;/a&gt; 에서 소개 된 바와 같이 , ClassVar로 래핑 된 변수 주석은 주어진 속성이 클래스 변수로 사용되도록 의도되었으며 해당 클래스의 인스턴스에 설정되어서는 안됨을 나타냅니다. 용법:</target>
        </trans-unit>
        <trans-unit id="b975573d762213d718d91e5a19d0201d6f4a860f" translate="yes" xml:space="preserve">
          <source>As is the case with all named tuples, the subclass has a few additional methods and attributes that are particularly useful. One such method is &lt;code&gt;_replace()&lt;/code&gt;. The &lt;code&gt;_replace()&lt;/code&gt; method will return a new ParseResult object replacing specified fields with new values.</source>
          <target state="translated">모든 명명 된 튜플의 경우와 마찬가지로 서브 클래스는 특히 유용한 몇 가지 추가 메소드 및 속성을 갖습니다. 그러한 방법 중 하나는 &lt;code&gt;_replace()&lt;/code&gt; 입니다. &lt;code&gt;_replace()&lt;/code&gt; 메소드는 새로운 값으로 지정된 필드를 대체하는 새로운 ParseResult 객체를 리턴한다.</target>
        </trans-unit>
        <trans-unit id="1c24eca1bdc966d5e836feb3ab27d1d9ed3eb23f" translate="yes" xml:space="preserve">
          <source>As long as the view exists, the &lt;a href=&quot;#io.BytesIO&quot;&gt;&lt;code&gt;BytesIO&lt;/code&gt;&lt;/a&gt; object cannot be resized or closed.</source>
          <target state="translated">보기가 존재하는 한 &lt;a href=&quot;#io.BytesIO&quot;&gt; &lt;code&gt;BytesIO&lt;/code&gt; &lt;/a&gt; 개체는 크기를 조정하거나 닫을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="610fcdc735062bf431e7a9e2ee300d06d531c84b" translate="yes" xml:space="preserve">
          <source>As mentioned above, if a child process has put items on a queue (and it has not used &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt;&lt;code&gt;JoinableQueue.cancel_join_thread&lt;/code&gt;&lt;/a&gt;), then that process will not terminate until all buffered items have been flushed to the pipe.</source>
          <target state="translated">위에서 언급 한 것처럼 하위 프로세스가 큐에 항목을 넣은 경우 (그리고 &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt; &lt;code&gt;JoinableQueue.cancel_join_thread&lt;/code&gt; 를&lt;/a&gt; 사용하지 않은 경우 ), 버퍼링 된 모든 항목이 파이프로 플러시 될 때까지 해당 프로세스가 종료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c946dacfc8f875db22dfcdba42153aefbf4569f0" translate="yes" xml:space="preserve">
          <source>As mentioned above, when doing concurrent programming it is usually best to avoid using shared state as far as possible. This is particularly true when using multiple processes.</source>
          <target state="translated">위에서 언급했듯이 동시 프로그래밍을 할 때는 가능한 한 공유 상태를 사용하지 않는 것이 가장 좋습니다. 여러 프로세스를 사용할 때 특히 그렇습니다.</target>
        </trans-unit>
        <trans-unit id="741a8166c57402ebadd253e7254391864f2e0259" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;a href=&quot;io#io-overview&quot;&gt;Overview&lt;/a&gt;, Python distinguishes between binary and text I/O. Files opened in binary mode (including &lt;code&gt;'b'&lt;/code&gt; in the &lt;em&gt;mode&lt;/em&gt; argument) return contents as &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects without any decoding. In text mode (the default, or when &lt;code&gt;'t'&lt;/code&gt; is included in the &lt;em&gt;mode&lt;/em&gt; argument), the contents of the file are returned as &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, the bytes having been first decoded using a platform-dependent encoding or using the specified &lt;em&gt;encoding&lt;/em&gt; if given.</source>
          <target state="translated">&lt;a href=&quot;io#io-overview&quot;&gt;Overview&lt;/a&gt; 에서 언급했듯이 Python은 이진과 텍스트 I / O를 구분합니다. 이진 모드로 열린 파일 ( &lt;em&gt;mode&lt;/em&gt; 인수 에 &lt;code&gt;'b'&lt;/code&gt; 포함 ) 은 디코딩없이 내용을 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체 로 반환 합니다. 텍스트 모드 (기본값 또는 &lt;code&gt;'t'&lt;/code&gt; 가 &lt;em&gt;mode&lt;/em&gt; 인수에 포함 된 경우 )에서 파일의 내용은 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 으로 반환되며 , 바이트는 플랫폼 종속 인코딩을 사용하거나 지정된 경우 지정된 &lt;em&gt;인코딩을&lt;/em&gt; 사용하여 먼저 디코딩되었습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="554761a2dd1c786ee19c7c8d095e92534e85fcea" translate="yes" xml:space="preserve">
          <source>As mentioned in the introduction, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; has grown to have three primary uses:</source>
          <target state="translated">소개에서 언급했듯이 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 다음과 같은 세 가지 주요 용도로 성장했습니다.</target>
        </trans-unit>
        <trans-unit id="2dd3237ecb3ed79cf4cebba9859ab17d40aea008" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=7159&quot;&gt;the errata for RFC 7159&lt;/a&gt;, JSON permits literal U+2028 (LINE SEPARATOR) and U+2029 (PARAGRAPH SEPARATOR) characters in strings, whereas JavaScript (as of ECMAScript Edition 5.1) does not.</source>
          <target state="translated">&lt;a href=&quot;https://www.rfc-editor.org/errata_search.php?rfc=7159&quot;&gt;RFC 7159의 정오표&lt;/a&gt; 에서 언급했듯이 JSON은 문자열에서 리터럴 U + 2028 (LINE SEPARATOR) 및 U + 2029 (PARAGRAPH SEPARATOR) 문자를 허용하지만 JavaScript (ECMAScript Edition 5.1 기준)는 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1d391aeb07828e2c8ece6409fe0c3895c39bf56" translate="yes" xml:space="preserve">
          <source>As noted in the documentation of &lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt;&lt;code&gt;ExitStack.push()&lt;/code&gt;&lt;/a&gt;, this method can be useful in cleaning up an already allocated resource if later steps in the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation fail.</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt; &lt;code&gt;ExitStack.push()&lt;/code&gt; &lt;/a&gt; 문서에서 언급 했듯이이 메소드는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 구현 의 이후 단계가 실패 할 경우 이미 할당 된 리소스를 정리하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64b8dfa9189fa9c6b65ee7c6f6f91e92dfd48dc4" translate="yes" xml:space="preserve">
          <source>As noted in the documentation of &lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt;&lt;code&gt;ExitStack.push()&lt;/code&gt;&lt;/a&gt;, this method can be useful in cleaning up an already allocated resource if later steps in the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt;&lt;code&gt;__enter__()&lt;/code&gt;&lt;/a&gt; implementation fail.</source>
          <target state="translated">&lt;a href=&quot;#contextlib.ExitStack.push&quot;&gt; &lt;code&gt;ExitStack.push()&lt;/code&gt; &lt;/a&gt; 문서에서 언급 했듯이이 메서드는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__enter__&quot;&gt; &lt;code&gt;__enter__()&lt;/code&gt; &lt;/a&gt; 구현 의 이후 단계가 실패 할 경우 이미 할당 된 리소스를 정리하는 데 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a4749ff1ae4127c8c5d53e09d2473530212eedd" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.pathconf(fd, name)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.pathconf(fd, name)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="254ec21e59cc0a2f51b3d99a3106cbbf6e86b501" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.stat(fd)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.stat(fd)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="de72d09fd1ee5572d4a2be6e2e876c81871f619b" translate="yes" xml:space="preserve">
          <source>As of Python 3.3, this is equivalent to &lt;code&gt;os.stat(path, dir_fd=dir_fd,
follow_symlinks=False)&lt;/code&gt;.</source>
          <target state="translated">Python 3.3 &lt;code&gt;os.stat(path, dir_fd=dir_fd, follow_symlinks=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="020b6b46db7feae3d90b1504ca1411e18c36a07a" translate="yes" xml:space="preserve">
          <source>As our examples shows, you have to be careful with what you allow to be unpickled. Therefore if security is a concern, you may want to consider alternatives such as the marshalling API in &lt;a href=&quot;xmlrpc.client#module-xmlrpc.client&quot;&gt;&lt;code&gt;xmlrpc.client&lt;/code&gt;&lt;/a&gt; or third-party solutions.</source>
          <target state="translated">우리의 예에서 알 수 있듯이, 피클 링되지 않은 것을 조심해야합니다. 따라서 보안이 중요한 경우 &lt;a href=&quot;xmlrpc.client#module-xmlrpc.client&quot;&gt; &lt;code&gt;xmlrpc.client&lt;/code&gt; &lt;/a&gt; 의 마샬링 API 또는 타사 솔루션 과 같은 대안을 고려할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94873ca8fb7d049aa1f358ba21e1835b6d80677c" translate="yes" xml:space="preserve">
          <source>As permitted, though not required, by the RFC, this module&amp;rsquo;s serializer sets &lt;em&gt;ensure_ascii=True&lt;/em&gt; by default, thus escaping the output so that the resulting strings only contain ASCII characters.</source>
          <target state="translated">RFC에 의해 허용되지는 않지만이 모듈의 시리얼 라이저는 기본적으로 &lt;em&gt;ensure_ascii = True&lt;/em&gt; 를 설정하여 결과 문자열을 ASCII 문자 만 포함하도록 출력을 이스케이프합니다.</target>
        </trans-unit>
        <trans-unit id="ab552d0f5d2aaec29b8f53a32c1edd92d2547512" translate="yes" xml:space="preserve">
          <source>As required by the Python DB API Spec, the &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt;&lt;code&gt;rowcount&lt;/code&gt;&lt;/a&gt; attribute &amp;ldquo;is -1 in case no &lt;code&gt;executeXX()&lt;/code&gt; has been performed on the cursor or the rowcount of the last operation is not determinable by the interface&amp;rdquo;. This includes &lt;code&gt;SELECT&lt;/code&gt; statements because we cannot determine the number of rows a query produced until all rows were fetched.</source>
          <target state="translated">Python DB API 스펙에서 요구하는대로 &lt;a href=&quot;#sqlite3.Cursor.rowcount&quot;&gt; &lt;code&gt;rowcount&lt;/code&gt; &lt;/a&gt; 속성은 &quot; 커서에서 &lt;code&gt;executeXX()&lt;/code&gt; 가 수행되지 않았거나 인터페이스에서 마지막 작업의 행 수를 판별 할 수 없는 경우 -1 &quot;입니다. 모든 행을 페치 할 때까지 쿼리가 생성 한 행 수를 판별 할 수 없으므로 &lt;code&gt;SELECT&lt;/code&gt; 문 이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d9ef0be3fa5743d16dd6068d735d43da1ed1d14" translate="yes" xml:space="preserve">
          <source>As seen below, you usually mark the strings in your application that are candidates for translation, by wrapping them in a call to the &lt;code&gt;_()&lt;/code&gt; function, like this:</source>
          <target state="translated">아래에서 볼 수 있듯이 일반적으로 응용 프로그램에서 다음 과 같이 &lt;code&gt;_()&lt;/code&gt; 함수 에 대한 호출로 래핑하여 번역 후보 인 문자열을 표시합니다 .</target>
        </trans-unit>
        <trans-unit id="777c0664c56b282dce066ba8bdfa9c0f273bd6e5" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;a href=&quot;#decimal.getcontext&quot;&gt;&lt;code&gt;getcontext()&lt;/code&gt;&lt;/a&gt; function accesses the current context and allows the settings to be changed. This approach meets the needs of most applications.</source>
          <target state="translated">위에 표시된 것처럼 &lt;a href=&quot;#decimal.getcontext&quot;&gt; &lt;code&gt;getcontext()&lt;/code&gt; &lt;/a&gt; 함수는 현재 컨텍스트에 액세스하여 설정을 변경할 수 있습니다. 이 접근 방식은 대부분의 응용 프로그램 요구를 충족시킵니다.</target>
        </trans-unit>
        <trans-unit id="ca7a4ca36c98546dcbae60adf434cc1fdf31f390" translate="yes" xml:space="preserve">
          <source>As shown above, the &lt;code&gt;MISSING&lt;/code&gt; value is a sentinel object used to detect if the &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;default_factory&lt;/code&gt; parameters are provided. This sentinel is used because &lt;code&gt;None&lt;/code&gt; is a valid value for &lt;code&gt;default&lt;/code&gt;. No code should directly use the &lt;code&gt;MISSING&lt;/code&gt; value.</source>
          <target state="translated">위에 표시된 것처럼 &lt;code&gt;MISSING&lt;/code&gt; 값은 &lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;default_factory&lt;/code&gt; 매개 변수가 제공 되는지 감지하는 데 사용되는 센티넬 오브젝트 입니다. &lt;code&gt;None&lt;/code&gt; 은 &lt;code&gt;default&lt;/code&gt; 유효한 값 이므로이 센티넬이 사용됩니다 . 어떤 코드도 &lt;code&gt;MISSING&lt;/code&gt; 값을 직접 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="e77922c76564f11dd7e1353e59f5212f7c398d9d" translate="yes" xml:space="preserve">
          <source>As shown, &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; also makes it quite easy to use &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements to manage arbitrary resources that don&amp;rsquo;t natively support the context management protocol.</source>
          <target state="translated">표시된 것처럼 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 은 또한 컨텍스트 관리 프로토콜을 기본적으로 지원하지 않는 임의의 자원을 관리하기 위해 명령문 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 사용하기가 매우 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="5fb7bd38776b3eebef09256f660c5e1b512cbe36" translate="yes" xml:space="preserve">
          <source>As shown, &lt;a href=&quot;#contextlib.ExitStack&quot;&gt;&lt;code&gt;ExitStack&lt;/code&gt;&lt;/a&gt; also makes it quite easy to use &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements to manage arbitrary resources that don&amp;rsquo;t natively support the context management protocol.</source>
          <target state="translated">표시된대로 &lt;a href=&quot;#contextlib.ExitStack&quot;&gt; &lt;code&gt;ExitStack&lt;/code&gt; &lt;/a&gt; 을 사용 하면 컨텍스트 관리 프로토콜을 기본적으로 지원하지 않는 임의의 리소스를 관리하기 위해 문과 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 사용하기가 매우 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="afcd78e93b46d440282cd0af672c39772532099d" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;cProfile.Profile&lt;/code&gt; class cannot be calibrated, custom timer functions should be used with care and should be as fast as possible. For the best results with a custom timer, it might be necessary to hard-code it in the C source of the internal &lt;code&gt;_lsprof&lt;/code&gt; module.</source>
          <target state="translated">는 AS &lt;code&gt;cProfile.Profile&lt;/code&gt; 의 클래스를 보정 할 수 없습니다, 사용자 정의 타이머 기능은주의해서 사용해야합니다 가능한 한 빨리해야한다. 커스텀 타이머로 최상의 결과를 얻으려면 내부 &lt;code&gt;_lsprof&lt;/code&gt; 모듈 의 C 소스에 하드 코딩해야 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="45e79820db8ac841bcd7b5678fd84162e5edd5f6" translate="yes" xml:space="preserve">
          <source>As the circle is approximated by an inscribed regular polygon, &lt;em&gt;steps&lt;/em&gt; determines the number of steps to use. If not given, it will be calculated automatically. May be used to draw regular polygons.</source>
          <target state="translated">원이 내접 정다각형으로 근사 될 때, &lt;em&gt;단계들은&lt;/em&gt; 사용하기위한 단계의 수를 결정한다. 지정하지 않으면 자동으로 계산됩니다. 일반 다각형을 그리는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="471b958617fa3e20177a04beca298db4067ef76f" translate="yes" xml:space="preserve">
          <source>As the decorated function must be able to be called multiple times, the underlying context manager must support use in multiple &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements. If this is not the case, then the original construct with the explicit &lt;code&gt;with&lt;/code&gt; statement inside the function should be used.</source>
          <target state="translated">데코 레이팅 된 함수는 여러 번 호출 될 수 있어야하므로 기본 컨텍스트 관리자는 여러 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서의 사용을 지원해야합니다 . 그렇지 않은 경우 함수 내에 명시 적 &lt;code&gt;with&lt;/code&gt; 문이 있는 원래 구문을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb86e3413c4f286f84d17583ff8db93cd75dbf02" translate="yes" xml:space="preserve">
          <source>As the decorated function must be able to be called multiple times, the underlying context manager must support use in multiple &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statements. If this is not the case, then the original construct with the explicit &lt;code&gt;with&lt;/code&gt; statement inside the function should be used.</source>
          <target state="translated">데코 레이팅 된 함수는 여러 번 호출 될 수 있어야하므로 기본 컨텍스트 관리자는 여러 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문 에서 사용을 지원해야합니다 . 그렇지 않은 경우 함수 내부에 명시적인 &lt;code&gt;with&lt;/code&gt; 문이 있는 원래 구조를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="68dd2b46461463b5dc81b3ce8b1f5caf9be1fe6b" translate="yes" xml:space="preserve">
          <source>As the example shows, if an option is marked as &lt;code&gt;required&lt;/code&gt;, &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt;&lt;code&gt;parse_args()&lt;/code&gt;&lt;/a&gt; will report an error if that option is not present at the command line.</source>
          <target state="translated">예제에서 볼 수 있듯이 옵션이 &lt;code&gt;required&lt;/code&gt; 로 표시 되면 &lt;a href=&quot;#argparse.ArgumentParser.parse_args&quot;&gt; &lt;code&gt;parse_args()&lt;/code&gt; &lt;/a&gt; 는 해당 옵션이 명령 줄에없는 경우 오류를보고합니다.</target>
        </trans-unit>
        <trans-unit id="76e64b80b59b5f1ae7b48ded543b566b2c5fea6e" translate="yes" xml:space="preserve">
          <source>As the help string supports %-formatting, if you want a literal &lt;code&gt;%&lt;/code&gt; to appear in the help string, you must escape it as &lt;code&gt;%%&lt;/code&gt;.</source>
          <target state="translated">도움말 문자열이 %-포매팅을 지원하므로 리터럴 &lt;code&gt;%&lt;/code&gt; 를 도움말 문자열에 표시하려면이를 &lt;code&gt;%%&lt;/code&gt; 로 이스케이프해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a59b1810ad2366588e1560b21083e815a61d7702" translate="yes" xml:space="preserve">
          <source>As the output from the example shows, reusing a single stack object across multiple with statements works correctly, but attempting to nest them will cause the stack to be cleared at the end of the innermost with statement, which is unlikely to be desirable behaviour.</source>
          <target state="translated">예제의 결과에서 알 수 있듯이 여러 with 문에서 단일 스택 객체를 재사용하면 올바르게 작동하지만 중첩을 시도하면 가장 안쪽 with 문 끝에 스택이 지워 지므로 바람직한 동작이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7432cc881a9c7f8b1e82bf98956cfaf69b88ec94" translate="yes" xml:space="preserve">
          <source>As the previous example shows, you can add &lt;code&gt;...&lt;/code&gt; lines to your example containing only directives. This can be useful when an example is too long for a directive to comfortably fit on the same line:</source>
          <target state="translated">이전 예제에서 볼 수 있듯이 지시문 만 포함하는 예제에 &lt;code&gt;...&lt;/code&gt; 행을 추가 할 수 있습니다 . 지시문이 같은 행에 편안하게 들어가기에는 예제가 너무 긴 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bad0a4f610137a71fbd404f93777ff0fbaf5382a" translate="yes" xml:space="preserve">
          <source>As the python.org website uses &lt;em&gt;utf-8&lt;/em&gt; encoding as specified in its meta tag, we will use the same for decoding the bytes object.</source>
          <target state="translated">python.org 웹 사이트는 메타 태그에 지정된대로 &lt;em&gt;utf-8&lt;/em&gt; 인코딩을 사용하므로 bytes 객체를 디코딩 할 때도 &lt;em&gt;utf-8&lt;/em&gt; 인코딩을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f9ef874d7307cc69342eb69c015b2b52804bc24e" translate="yes" xml:space="preserve">
          <source>As we can easily check, our array is sorted now:</source>
          <target state="translated">쉽게 확인할 수 있듯이 이제 배열이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c23b38ddb6aef5ba6269faf72685d2b4793ec969" translate="yes" xml:space="preserve">
          <source>As we can see above, the API is pretty straightforward. The only bit of magic involves the &lt;code&gt;DEFAULT&lt;/code&gt; section which provides default values for all other sections &lt;a href=&quot;#id14&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. Note also that keys in sections are case-insensitive and stored in lowercase &lt;a href=&quot;#id14&quot; id=&quot;id2&quot;&gt;1&lt;/a&gt;.</source>
          <target state="translated">위에서 볼 수 있듯이 API는 매우 간단합니다. 마법의 유일한 비트는 다른 모든 섹션 &lt;a href=&quot;#id14&quot; id=&quot;id1&quot;&gt;1에&lt;/a&gt; 대한 기본값을 제공 하는 &lt;code&gt;DEFAULT&lt;/code&gt; 섹션과 관련이 있습니다 . 섹션의 키는 대소 문자를 구분하지 않으며 소문자 &lt;a href=&quot;#id14&quot; id=&quot;id2&quot;&gt;1로&lt;/a&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd35f4640dac53d4cba2d342193297bc4fce7dc6" translate="yes" xml:space="preserve">
          <source>As we shall see, pickle does not use directly the methods described above. In fact, these methods are part of the copy protocol which implements the &lt;a href=&quot;#object.__reduce__&quot;&gt;&lt;code&gt;__reduce__()&lt;/code&gt;&lt;/a&gt; special method. The copy protocol provides a unified interface for retrieving the data necessary for pickling and copying objects. &lt;a href=&quot;#id10&quot; id=&quot;id5&quot;&gt;4&lt;/a&gt;</source>
          <target state="translated">알다시피 피클은 위에서 설명한 방법을 직접 사용하지 않습니다. 실제로 이러한 메소드는 &lt;a href=&quot;#object.__reduce__&quot;&gt; &lt;code&gt;__reduce__()&lt;/code&gt; &lt;/a&gt; 특수 메소드 를 구현하는 복사 프로토콜의 일부입니다 . 복사 프로토콜은 객체를 선택하고 복사하는 데 필요한 데이터를 검색하기위한 통합 인터페이스를 제공합니다. &lt;a href=&quot;#id10&quot; id=&quot;id5&quot;&gt;4&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="debea2eb93150eb2d1b36d8b1bf25e4f62753e5c" translate="yes" xml:space="preserve">
          <source>As well as a decorator &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; can be used as a context manager in a with statement:</source>
          <target state="translated">데코레이터 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 with 문에서 컨텍스트 관리자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9da1c5bbe7d0c4d318b5718e8cf13b1be346dab" translate="yes" xml:space="preserve">
          <source>As well as attributes on the created mock attributes, like the &lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt;&lt;code&gt;return_value&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt;&lt;code&gt;side_effect&lt;/code&gt;&lt;/a&gt;, of child mocks can also be configured. These aren&amp;rsquo;t syntactically valid to pass in directly as keyword arguments, but a dictionary with these as keys can still be expanded into a &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; call using &lt;code&gt;**&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;#unittest.mock.Mock.return_value&quot;&gt; &lt;code&gt;return_value&lt;/code&gt; &lt;/a&gt; mock의 return_value 및 &lt;a href=&quot;#unittest.mock.Mock.side_effect&quot;&gt; &lt;code&gt;side_effect&lt;/code&gt; &lt;/a&gt; 와 같이 생성 된 mock 속성의 속성 도 구성 할 수 있습니다. 다음은 키워드 인수로 직접에서 통과 구문이 유효하지 않습니다,하지만 키와 같은 이들과 사전 여전히로 확장 될 수 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 사용하여 전화 &lt;code&gt;**&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f8beeb01a1af78f02464bc704487f07739d5804d" translate="yes" xml:space="preserve">
          <source>As well as being a path it is possible to pass a package name, for example &lt;code&gt;myproject.subpackage.test&lt;/code&gt;, as the start directory. The package name you supply will then be imported and its location on the filesystem will be used as the start directory.</source>
          <target state="translated">경로 일뿐만 아니라 패키지 이름 (예 : &lt;code&gt;myproject.subpackage.test&lt;/code&gt; )을 시작 디렉토리 로 전달할 수 있습니다 . 제공 한 패키지 이름을 가져오고 파일 시스템의 해당 위치가 시작 디렉토리로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ac654a9b0a771a253377851cbe7d9dcdd53aa08" translate="yes" xml:space="preserve">
          <source>As well as external objects, there is sometimes also a need to refer to objects in the configuration. This will be done implicitly by the configuration system for things that it knows about. For example, the string value &lt;code&gt;'DEBUG'&lt;/code&gt; for a &lt;code&gt;level&lt;/code&gt; in a logger or handler will automatically be converted to the value &lt;code&gt;logging.DEBUG&lt;/code&gt;, and the &lt;code&gt;handlers&lt;/code&gt;, &lt;code&gt;filters&lt;/code&gt; and &lt;code&gt;formatter&lt;/code&gt; entries will take an object id and resolve to the appropriate destination object.</source>
          <target state="translated">외부 객체뿐만 아니라 구성에서 객체를 참조해야 할 경우도 있습니다. 이것은 알고있는 것에 대해 구성 시스템에 의해 내재적으로 수행됩니다. 예를 들어, 문자열 값 &lt;code&gt;'DEBUG'&lt;/code&gt; A의 &lt;code&gt;level&lt;/code&gt; 로거 또는 핸들러가 자동으로 값으로 변환됩니다 &lt;code&gt;logging.DEBUG&lt;/code&gt; 하고, &lt;code&gt;handlers&lt;/code&gt; , &lt;code&gt;filters&lt;/code&gt; 및 &lt;code&gt;formatter&lt;/code&gt; 항목은 적절한 대상 객체에 대한 객체 ID와 결의를 취할 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a2e6cebd59a22f19c5763adb2176795f3405ba5" translate="yes" xml:space="preserve">
          <source>As well as tracking calls to themselves, mocks also track calls to methods and attributes, and &lt;em&gt;their&lt;/em&gt; methods and attributes:</source>
          <target state="translated">모의는 자신에 대한 호출을 추적 할뿐만 아니라 메소드 및 속성에 대한 호출과 &lt;em&gt;해당&lt;/em&gt; 메소드 및 속성 을 추적 합니다.</target>
        </trans-unit>
        <trans-unit id="eba8324196b8dfc54af3887d0a5dc2b00afccd66" translate="yes" xml:space="preserve">
          <source>As well as using &lt;em&gt;autospec&lt;/em&gt; through &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; there is a &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt;&lt;code&gt;create_autospec()&lt;/code&gt;&lt;/a&gt; for creating autospecced mocks directly:</source>
          <target state="translated">물론 사용으로 &lt;em&gt;autospec을&lt;/em&gt; 통해 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 있다 &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt; &lt;code&gt;create_autospec()&lt;/code&gt; &lt;/a&gt; 직접 autospecced 모의 객체를 생성은 :</target>
        </trans-unit>
        <trans-unit id="0630c32a8836c172a8afec7c1702dc1fc98e8c01" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; won&amp;rsquo;t display anything unless an example fails. If an example does fail, then the failing example(s) and the cause(s) of the failure(s) are printed to stdout, using the same format as &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 예를 들어 오류가 발생하지 않는 한 아무 것도 표시되지 않습니다. 예제가 실패하면 실패한 예제 및 실패의 원인이 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; 와 동일한 형식을 사용하여 stdout에 인쇄됩니다 .</target>
        </trans-unit>
        <trans-unit id="8d2f16ec04ec8da2a8b6d28bff1e96ae0730df2f" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt;&lt;code&gt;add()&lt;/code&gt;&lt;/a&gt;, parameter &lt;em&gt;message&lt;/em&gt; may be a &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; instance, an &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt;&lt;code&gt;email.message.Message&lt;/code&gt;&lt;/a&gt; instance, a string, a byte string, or a file-like object (which should be open in binary mode). If &lt;em&gt;message&lt;/em&gt; is an instance of the appropriate format-specific &lt;a href=&quot;#mailbox.Message&quot;&gt;&lt;code&gt;Message&lt;/code&gt;&lt;/a&gt; subclass (e.g., if it&amp;rsquo;s an &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt;&lt;code&gt;mboxMessage&lt;/code&gt;&lt;/a&gt; instance and this is an &lt;a href=&quot;#mailbox.mbox&quot;&gt;&lt;code&gt;mbox&lt;/code&gt;&lt;/a&gt; instance), its format-specific information is used. Otherwise, the format-specific information of the message that currently corresponds to &lt;em&gt;key&lt;/em&gt; is left unchanged.</source>
          <target state="translated">&lt;a href=&quot;#mailbox.Mailbox.add&quot;&gt; &lt;code&gt;add()&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 매개 변수 &lt;em&gt;메시지&lt;/em&gt; 는 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 인스턴스, &lt;a href=&quot;email.compat32-message#email.message.Message&quot;&gt; &lt;code&gt;email.message.Message&lt;/code&gt; &lt;/a&gt; 인스턴스, 문자열, 바이트 문자열 또는 파일과 유사한 객체 (바이너리 모드로 열려야 함) 일 수 있습니다. 경우 &lt;em&gt;메시지가&lt;/em&gt; 적절한 형식 별의의 인스턴스 &lt;a href=&quot;#mailbox.Message&quot;&gt; &lt;code&gt;Message&lt;/code&gt; &lt;/a&gt; 서브 클래스 (그것이 있다면 예를 들어, &lt;a href=&quot;#mailbox.mboxMessage&quot;&gt; &lt;code&gt;mboxMessage&lt;/code&gt; 의&lt;/a&gt; 인스턴스가이가있다 &lt;a href=&quot;#mailbox.mbox&quot;&gt; &lt;code&gt;mbox&lt;/code&gt; &lt;/a&gt; 예), 그 형식 별 정보가 사용됩니다. 그렇지 않으면 현재 &lt;em&gt;키에&lt;/em&gt; 해당하는 메시지의 형식 별 정보는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0bf2339fc3da041c7b40d65293bdd95b7f0f7885" translate="yes" xml:space="preserve">
          <source>As with a dictionary, you can use a section&amp;rsquo;s &lt;code&gt;get()&lt;/code&gt; method to provide fallback values:</source>
          <target state="translated">사전과 마찬가지로 섹션의 &lt;code&gt;get()&lt;/code&gt; 메소드를 사용하여 폴백 값을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57771b08d272fad9dc8b1be5068d86775d7fa3ca" translate="yes" xml:space="preserve">
          <source>As with all other objects in Python the old objects are only reclaimed after their reference counts drop to zero.</source>
          <target state="translated">파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에 만 ​​재생됩니다.</target>
        </trans-unit>
        <trans-unit id="de44bc643f497be8df1b37fe142eb3754e000e16" translate="yes" xml:space="preserve">
          <source>As with any &lt;code&gt;try&lt;/code&gt; statement based code, this can cause problems for development and review, because the setup code and the cleanup code can end up being separated by arbitrarily long sections of code.</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 문 기반 코드 와 마찬가지로 설치 코드와 정리 코드가 임의로 긴 코드 섹션으로 분리 될 수 있으므로 개발 및 검토에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3ab064145c449d1616c3eb8354b791e442472ff" translate="yes" xml:space="preserve">
          <source>As with any other mechanism that completely suppresses exceptions, this context manager should be used only to cover very specific errors where silently continuing with program execution is known to be the right thing to do.</source>
          <target state="translated">예외를 완전히 억제하는 다른 메커니즘과 마찬가지로이 컨텍스트 관리자는 프로그램 실행을 자동으로 계속하는 것이 올바른 것으로 알려진 매우 구체적인 오류를 처리하는 데만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="61ba626904718f435e8bb9195d72a3d4e176bd46" translate="yes" xml:space="preserve">
          <source>As with message in an mbox mailbox, MMDF messages are stored with the sender&amp;rsquo;s address and the delivery date in an initial line beginning with &amp;ldquo;From &amp;ldquo;. Likewise, flags that indicate the state of the message are typically stored in &lt;em&gt;Status&lt;/em&gt; and &lt;em&gt;X-Status&lt;/em&gt; headers.</source>
          <target state="translated">mbox 편지함에있는 메시지와 마찬가지로 MMDF 메시지는 보낸 사람의 주소와 배달 날짜와 함께 &quot;보낸 사람&quot;으로 시작하는 첫 줄에 저장됩니다. 마찬가지로, 메시지 상태를 나타내는 플래그는 일반적으로 &lt;em&gt;상태&lt;/em&gt; 및 &lt;em&gt;X- 상태&lt;/em&gt; 헤더에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="cdc2d00aa5d268d13b0deb99289a5e17c7efb442" translate="yes" xml:space="preserve">
          <source>As with other methods, case-sensitivity follows platform defaults:</source>
          <target state="translated">다른 방법과 마찬가지로 대소 문자 구분도 플랫폼 기본값을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="8bb7354faa685cfe016fc2268268a70658988eb5" translate="yes" xml:space="preserve">
          <source>As with other methods, case-sensitivity is observed:</source>
          <target state="translated">다른 방법과 마찬가지로 대소 문자 구분이 관찰됩니다.</target>
        </trans-unit>
        <trans-unit id="31db4d814a8ee3a9c296a0ac9ab18e1168c00cb9" translate="yes" xml:space="preserve">
          <source>As with string literals, bytes literals may also use a &lt;code&gt;r&lt;/code&gt; prefix to disable processing of escape sequences. See &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;String and Bytes literals&lt;/a&gt; for more about the various forms of bytes literal, including supported escape sequences.</source>
          <target state="translated">문자열 리터럴과 마찬가지로 바이트 리터럴도 &lt;code&gt;r&lt;/code&gt; 접두사를 사용하여 이스케이프 시퀀스 처리를 비활성화 할 수 있습니다 . 지원되는 이스케이프 시퀀스를 포함한 다양한 형식의 바이트 &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;리터럴에&lt;/a&gt; 대한 자세한 내용은 문자열 및 바이트 리터럴 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5ba3c5f5300a18dcc61c9484deef226967d8c18a" translate="yes" xml:space="preserve">
          <source>As with string literals, bytes literals may also use a &lt;code&gt;r&lt;/code&gt; prefix to disable processing of escape sequences. See &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#strings&quot;&gt;String and Bytes literals&lt;/a&gt; for more about the various forms of bytes literal, including supported escape sequences.</source>
          <target state="translated">문자열 리터럴과 마찬가지로 바이트 리터럴은 이스케이프 시퀀스 처리를 비활성화 하기 위해 &lt;code&gt;r&lt;/code&gt; 접두사를 사용할 수도 있습니다 . 지원되는 이스케이프 시퀀스를 포함하여 다양한 형식의 바이트 &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#strings&quot;&gt;리터럴에&lt;/a&gt; 대한 자세한 내용은 문자열 및 바이트 리터럴 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6084fcb644e26dce144964d5ce8fd1b644c1bcfd" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;#description&quot;&gt;description&lt;/a&gt; argument, the &lt;code&gt;epilog=&lt;/code&gt; text is by default line-wrapped, but this behavior can be adjusted with the &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; argument to &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">와 마찬가지로 &lt;a href=&quot;#description&quot;&gt;설명&lt;/a&gt; 인수의 &lt;code&gt;epilog=&lt;/code&gt; 텍스트는 기본 라인 포장에 의해이지만,이 문제는 조정할 수 있습니다 &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; 에 인수 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50d385a8286d57094c5ce3df7ad9daf11b5640f8" translate="yes" xml:space="preserve">
          <source>As with the &lt;a href=&quot;email.parser#module-email.parser&quot;&gt;&lt;code&gt;email.parser&lt;/code&gt;&lt;/a&gt; module, you aren&amp;rsquo;t limited to the functionality of the bundled generator; you could write one from scratch yourself. However the bundled generator knows how to generate most email in a standards-compliant way, should handle MIME and non-MIME email messages just fine, and is designed so that the bytes-oriented parsing and generation operations are inverses, assuming the same non-transforming &lt;a href=&quot;email.policy#module-email.policy&quot;&gt;&lt;code&gt;policy&lt;/code&gt;&lt;/a&gt; is used for both. That is, parsing the serialized byte stream via the &lt;a href=&quot;email.parser#email.parser.BytesParser&quot;&gt;&lt;code&gt;BytesParser&lt;/code&gt;&lt;/a&gt; class and then regenerating the serialized byte stream using &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt; should produce output identical to the input &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;. (On the other hand, using the generator on an &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; constructed by program may result in changes to the &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt;&lt;code&gt;EmailMessage&lt;/code&gt;&lt;/a&gt; object as defaults are filled in.)</source>
          <target state="translated">&lt;a href=&quot;email.parser#module-email.parser&quot;&gt; &lt;code&gt;email.parser&lt;/code&gt; &lt;/a&gt; 모듈 과 마찬가지로 번들 생성기의 기능에 제한되지 않습니다. 처음부터 직접 작성할 수 있습니다. 그러나 번들 생성기는 표준 호환 방식으로 대부분의 전자 메일을 생성하는 방법을 알고 있으며 MIME 및 비 MIME 전자 메일 메시지를 잘 처리해야하며 바이트 지향 구문 분석 및 생성 작업이 동일하지 않은 것으로 가정합니다. 변형 &lt;a href=&quot;email.policy#module-email.policy&quot;&gt; &lt;code&gt;policy&lt;/code&gt; &lt;/a&gt; 은 둘 다에 사용됩니다. 즉, &lt;a href=&quot;email.parser#email.parser.BytesParser&quot;&gt; &lt;code&gt;BytesParser&lt;/code&gt; &lt;/a&gt; 클래스 를 통해 직렬화 된 바이트 스트림을 구문 분석 한 후 &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; &lt;/a&gt; 를 사용하여 직렬화 된 바이트 스트림을 재생성 하면 입력 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 과 동일한 출력이 생성 됩니다. (반면, &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 에서 생성기를 사용하면프로그램에 의해 생성 되면 기본값이 채워짐에 따라 &lt;a href=&quot;email.message#email.message.EmailMessage&quot;&gt; &lt;code&gt;EmailMessage&lt;/code&gt; &lt;/a&gt; 객체 가 변경 될 수 있습니다 .)</target>
        </trans-unit>
        <trans-unit id="98b68bf763d9b565df24602f94e028fb7d75d354" translate="yes" xml:space="preserve">
          <source>As with the constructor for &lt;a href=&quot;#bz2.BZ2File&quot;&gt;&lt;code&gt;BZ2File&lt;/code&gt;&lt;/a&gt;, the &lt;em&gt;filename&lt;/em&gt; argument can be an actual filename (a &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; object), or an existing file object to read from or write to.</source>
          <target state="translated">생성자와 마찬가지로 &lt;a href=&quot;#bz2.BZ2File&quot;&gt; &lt;code&gt;BZ2File&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;파일 이름&lt;/em&gt; 인수는 실제 파일 이름 (A 할 수 있습니다 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 개체), 또는 나 쓰기에 읽을 수있는 기존 파일 개체를.</target>
        </trans-unit>
        <trans-unit id="39b89ac3cbb6042a6b76daccce240847a7e0deae" translate="yes" xml:space="preserve">
          <source>As with the normal socket object, &lt;em&gt;address&lt;/em&gt; is a tuple with the first element the host to connect to, and the second the port number.</source>
          <target state="translated">일반 소켓 객체와 마찬가지로 &lt;em&gt;address&lt;/em&gt; 는 호스트가 연결하는 첫 번째 요소와 두 번째 포트 번호가 포함 된 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="f590c8191e52a5707968f655cd53f953a854a829" translate="yes" xml:space="preserve">
          <source>As you can see, we can treat a config parser much like a dictionary. There are differences, &lt;a href=&quot;#mapping-protocol-access&quot;&gt;outlined later&lt;/a&gt;, but the behavior is very close to what you would expect from a dictionary.</source>
          <target state="translated">보시다시피, 구성 파서는 사전처럼 취급 할 수 있습니다. 차이점은 &lt;a href=&quot;#mapping-protocol-access&quot;&gt;나중에 설명&lt;/a&gt; 하지만 동작은 사전에서 기대하는 것과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="59f904f27b756361ae89156e1ce717db987f76ba" translate="yes" xml:space="preserve">
          <source>As you&amp;rsquo;d expect, the legal values for &lt;em&gt;someAction&lt;/em&gt; will depend on the widget&amp;rsquo;s class: &lt;code&gt;.fred disable&lt;/code&gt; works if fred is a button (fred gets greyed out), but does not work if fred is a label (disabling of labels is not supported in Tk).</source>
          <target state="translated">예상 한 바와 같이 &lt;em&gt;someAction&lt;/em&gt; 의 유효한 값 은 위젯 클래스에 따라 다릅니다. &lt;code&gt;.fred disable&lt;/code&gt; 은 fred가 버튼 인 경우 작동하지만 (fred는 회색으로 표시됨) fred가 레이블 인 경우 작동하지 않습니다 (레이블 사용 안함은 지원되지 않음). Tk에서).</target>
        </trans-unit>
        <trans-unit id="61b9f99dea4285cc76b6c48cda8a14e52d2b891d" translate="yes" xml:space="preserve">
          <source>As your collection of doctest&amp;rsquo;ed modules grows, you&amp;rsquo;ll want a way to run all their doctests systematically. &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; provides two functions that can be used to create &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; test suites from modules and text files containing doctests. To integrate with &lt;a href=&quot;unittest#module-unittest&quot;&gt;&lt;code&gt;unittest&lt;/code&gt;&lt;/a&gt; test discovery, include a &lt;code&gt;load_tests()&lt;/code&gt; function in your test module:</source>
          <target state="translated">doctest'ed 모듈의 컬렉션이 증가함에 따라 모든 doctest를 체계적으로 실행할 수있는 방법이 필요합니다. &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 모듈 및 doctest를 포함하는 텍스트 파일에서 &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트 스위트 를 작성하는 데 사용할 수있는 두 가지 기능을 제공합니다 . &lt;a href=&quot;unittest#module-unittest&quot;&gt; &lt;code&gt;unittest&lt;/code&gt; &lt;/a&gt; 테스트 감지 와 통합하려면 테스트 모듈에 &lt;code&gt;load_tests()&lt;/code&gt; 함수를 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="2a9978f5d754841b336538c4c5a01a51bbcd2678" translate="yes" xml:space="preserve">
          <source>Assert that &lt;em&gt;iter&lt;/em&gt; is deallocated after iterating.</source>
          <target state="translated">주장 &lt;em&gt;ITER는&lt;/em&gt; 반복하는 후 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="fd264d50fb4b9eeefc754b5a58a5fcba3dedc28e" translate="yes" xml:space="preserve">
          <source>Assert that running the interpreter with &lt;em&gt;args&lt;/em&gt; and optional environment variables &lt;em&gt;env_vars&lt;/em&gt; fails (&lt;code&gt;rc != 0&lt;/code&gt;) and return a &lt;code&gt;(return code,
stdout, stderr)&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 및 선택적 환경 변수 &lt;em&gt;env_vars를 사용&lt;/em&gt; 하여 인터프리터 실행이 실패하고 ( &lt;code&gt;rc != 0&lt;/code&gt; ) &lt;code&gt;(return code, stdout, stderr)&lt;/code&gt; 튜플을 리턴한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e0d6e30e5daa962c493e2c53bfd3e5bd71e7f71" translate="yes" xml:space="preserve">
          <source>Assert that running the interpreter with &lt;em&gt;args&lt;/em&gt; and optional environment variables &lt;em&gt;env_vars&lt;/em&gt; succeeds (&lt;code&gt;rc == 0&lt;/code&gt;) and return a &lt;code&gt;(return code,
stdout, stderr)&lt;/code&gt; tuple.</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 및 선택적 환경 변수 &lt;em&gt;env_vars를 사용&lt;/em&gt; 하여 인터프리터를 실행 하면 ( &lt;code&gt;rc == 0&lt;/code&gt; ) 성공 하고 &lt;code&gt;(return code, stdout, stderr)&lt;/code&gt; 튜플을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f8fb3abe58177e5028044ca5b20cc140fb7d71a8" translate="yes" xml:space="preserve">
          <source>Assert that the &lt;code&gt;__all__&lt;/code&gt; variable of &lt;em&gt;module&lt;/em&gt; contains all public names.</source>
          <target state="translated">&lt;em&gt;모듈&lt;/em&gt; 의 &lt;code&gt;__all__&lt;/code&gt; 변수에 모든 공용 이름이 포함되어 있다고 가정하십시오 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55a3005fb29b0592036701f49249b35f6fe4e576" translate="yes" xml:space="preserve">
          <source>Assert that the last await was with the specified arguments.</source>
          <target state="translated">마지막 대기가 지정된 인수와 함께 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="0ab3c9a0f942a4e5218663ad1728f419192ba180" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited at least once. Note that this is separate from the object having been called, the &lt;code&gt;await&lt;/code&gt; keyword must be used:</source>
          <target state="translated">모의가 적어도 한 번 기다렸다 고 주장하십시오. 이것은 호출 된 객체와 별개이므로 &lt;code&gt;await&lt;/code&gt; 키워드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="559c5d43237366024e3609d35920dccb6c140415" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited exactly once and with the specified arguments.</source>
          <target state="translated">모의가 정확히 한 번, 지정된 인수로 기다리고 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="5ad7deeafb38bd4aeb17622c34aa957e7bdb88a1" translate="yes" xml:space="preserve">
          <source>Assert that the mock was awaited exactly once.</source>
          <target state="translated">모의가 정확히 한 번 기다렸다 고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="1f4df423286b9ac2be8365c78eafe1774099f5f2" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called at least once.</source>
          <target state="translated">모의가 한 번 이상 호출되었다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3324ced759f5d86b62cf891c7da413bc53b68560" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called exactly once and that that call was with the specified arguments.</source>
          <target state="translated">모의가 정확히 한 번 호출되었고 해당 호출이 지정된 인수와 함께 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="5bf57493612b2763417d96c9bf7967affcea4272" translate="yes" xml:space="preserve">
          <source>Assert that the mock was called exactly once.</source>
          <target state="translated">모의가 정확히 한 번 호출되었다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3db0fab7867c814616ac71a3a5143ce2dff5900d" translate="yes" xml:space="preserve">
          <source>Assert that the mock was never awaited.</source>
          <target state="translated">모의를 기다리지 않았다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="c1c646d111dcc42ccae26bbe43d3ddada473ab0f" translate="yes" xml:space="preserve">
          <source>Assert the mock has been awaited with the specified calls. The &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt;&lt;code&gt;await_args_list&lt;/code&gt;&lt;/a&gt; list is checked for the awaits.</source>
          <target state="translated">지정된 호출로 모의가 대기되었다고 가정하십시오. &lt;a href=&quot;#unittest.mock.AsyncMock.await_args_list&quot;&gt; &lt;code&gt;await_args_list&lt;/code&gt; &lt;/a&gt; 목록이 기다리고 점검한다.</target>
        </trans-unit>
        <trans-unit id="aeceb688911f6dcdcfa555a84d22383aa56d4db7" translate="yes" xml:space="preserve">
          <source>Assert the mock has ever been awaited with the specified arguments.</source>
          <target state="translated">지정된 인수로 모의가 기다리고 있다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="3d67cb9aa133440c8ea1ec7d7cc69fcf71038d22" translate="yes" xml:space="preserve">
          <source>Assert the mock was never called.</source>
          <target state="translated">모의가 불려지지 않았다고 주장하십시오.</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="096ae7879fe3ac7e3285826b7966eb892e08f3e2" translate="yes" xml:space="preserve">
          <source>Assign a Python function or another callable to this attribute. The callable will be called with three or more arguments:</source>
          <target state="translated">이 함수에 파이썬 함수 또는 다른 호출 가능 함수를 할당하십시오. 콜 러블은 세 개 이상의 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2d6b37186bcf31c990ffb06dcf0507a39bd37db6" translate="yes" xml:space="preserve">
          <source>Assign a ctypes type to specify the result type of the foreign function. Use &lt;code&gt;None&lt;/code&gt; for &lt;code&gt;void&lt;/code&gt;, a function not returning anything.</source>
          <target state="translated">외부 함수의 결과 유형을 지정하려면 ctypes 유형을 지정하십시오. 아무것도 반환하지 않는 함수 인 &lt;code&gt;void&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="87af2d9b58846a93bc5651822c3deea453207ca5" translate="yes" xml:space="preserve">
          <source>Assign a tuple of ctypes types to specify the argument types that the function accepts. Functions using the &lt;code&gt;stdcall&lt;/code&gt; calling convention can only be called with the same number of arguments as the length of this tuple; functions using the C calling convention accept additional, unspecified arguments as well.</source>
          <target state="translated">함수가 허용하는 인수 유형을 지정하려면 ctypes 유형의 튜플을 지정하십시오. &lt;code&gt;stdcall&lt;/code&gt; 호출 규칙을 사용하는 함수 는이 튜플의 길이와 동일한 수의 인수로만 호출 할 수 있습니다. C 호출 규칙을 사용하는 함수는 지정되지 않은 추가 인수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="24cd252fad6840a721b5d763b587fe334065ad54" translate="yes" xml:space="preserve">
          <source>Assigning a new value to instances of the pointer types &lt;a href=&quot;#ctypes.c_char_p&quot;&gt;&lt;code&gt;c_char_p&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ctypes.c_wchar_p&quot;&gt;&lt;code&gt;c_wchar_p&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#ctypes.c_void_p&quot;&gt;&lt;code&gt;c_void_p&lt;/code&gt;&lt;/a&gt; changes the &lt;em&gt;memory location&lt;/em&gt; they point to, &lt;em&gt;not the contents&lt;/em&gt; of the memory block (of course not, because Python bytes objects are immutable):</source>
          <target state="translated">포인터 유형 &lt;a href=&quot;#ctypes.c_char_p&quot;&gt; &lt;code&gt;c_char_p&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ctypes.c_wchar_p&quot;&gt; &lt;code&gt;c_wchar_p&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ctypes.c_void_p&quot;&gt; &lt;code&gt;c_void_p&lt;/code&gt; 의&lt;/a&gt; 인스턴스에 새 값을 지정 하면 메모리 블록 &lt;em&gt;의 내용&lt;/em&gt; 이 &lt;em&gt;아니라&lt;/em&gt; 그들이 가리키는 &lt;em&gt;메모리 위치가&lt;/em&gt; 변경 됩니다 (물론 파이썬 바이트 오브젝트는 변경할 수 없기 때문에).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ad21f0fedcc6176cc70cb700d98f976d15416af" translate="yes" xml:space="preserve">
          <source>Assigning another &lt;a href=&quot;#ctypes.c_int&quot;&gt;&lt;code&gt;c_int&lt;/code&gt;&lt;/a&gt; instance to the pointer&amp;rsquo;s contents attribute would cause the pointer to point to the memory location where this is stored:</source>
          <target state="translated">다른 &lt;a href=&quot;#ctypes.c_int&quot;&gt; &lt;code&gt;c_int&lt;/code&gt; &lt;/a&gt; 인스턴스를 포인터의 contents 속성에 할당 하면 포인터가 저장된 메모리 위치를 가리키게됩니다.</target>
        </trans-unit>
        <trans-unit id="0b02ed6e18cfc24fbfbfe9a5ea607ee75077dc86" translate="yes" xml:space="preserve">
          <source>Assigning to an integer index changes the pointed to value:</source>
          <target state="translated">정수 색인에 지정하면 지정된 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="d425ffd0dc0c03777b86385bf81e964839a8b08e" translate="yes" xml:space="preserve">
          <source>Assignment statements in Python do not copy objects, they create bindings between a target and an object. For collections that are mutable or contain mutable items, a copy is sometimes needed so one can change one copy without changing the other. This module provides generic shallow and deep copy operations (explained below).</source>
          <target state="translated">파이썬에서 대 입문은 객체를 복사하지 않고 대상과 객체 사이에 바인딩을 만듭니다. 변경 가능하거나 변경 가능한 항목이 포함 된 컬렉션의 경우 복사본이 필요할 수 있으므로 다른 복사본을 변경하지 않고 한 복사본을 변경할 수 있습니다. 이 모듈은 일반적인 얕은 복사 및 깊은 복사 작업을 제공합니다 (아래 설명).</target>
        </trans-unit>
        <trans-unit id="8e44ce9ac8ed3d578e4f315bbe0851d670b4c1ce" translate="yes" xml:space="preserve">
          <source>Assignment to these attributes should not be necessary other than in rare circumstances in a &lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt;&lt;code&gt;CookiePolicy&lt;/code&gt;&lt;/a&gt; method. The class does not enforce internal consistency, so you should know what you&amp;rsquo;re doing if you do that.</source>
          <target state="translated">&lt;a href=&quot;#http.cookiejar.CookiePolicy&quot;&gt; &lt;code&gt;CookiePolicy&lt;/code&gt; &lt;/a&gt; 메서드 에서 드문 경우를 제외하고 이러한 특성에 할당 할 필요는 없습니다 . 수업은 내부 일관성을 강요하지 않으므로 그렇게 할 경우 수행중인 작업을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="88cccee59dd04afc77be1302263482ef8771b4eb" translate="yes" xml:space="preserve">
          <source>Assignments to items in &lt;code&gt;os.environ&lt;/code&gt; are automatically translated into corresponding calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt;; however, calls to &lt;a href=&quot;#os.putenv&quot;&gt;&lt;code&gt;putenv()&lt;/code&gt;&lt;/a&gt; don&amp;rsquo;t update &lt;code&gt;os.environ&lt;/code&gt;, so it is actually preferable to assign to items of &lt;code&gt;os.environ&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;os.environ&lt;/code&gt; 의 항목에 대한 할당 은 자동으로 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 에 대한 해당 호출로 변환됩니다 . 그러나 &lt;a href=&quot;#os.putenv&quot;&gt; &lt;code&gt;putenv()&lt;/code&gt; &lt;/a&gt; 호출은 &lt;code&gt;os.environ&lt;/code&gt; 을 업데이트하지 않으므로 실제로 &lt;code&gt;os.environ&lt;/code&gt; 항목에 할당하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4bdbb7b0403c9ed5b42c0c1a8e706970ef50e63c" translate="yes" xml:space="preserve">
          <source>Associate &lt;em&gt;dialect&lt;/em&gt; with &lt;em&gt;name&lt;/em&gt;. &lt;em&gt;name&lt;/em&gt; must be a string. The dialect can be specified either by passing a sub-class of &lt;a href=&quot;#csv.Dialect&quot;&gt;&lt;code&gt;Dialect&lt;/code&gt;&lt;/a&gt;, or by &lt;em&gt;fmtparams&lt;/em&gt; keyword arguments, or both, with keyword arguments overriding parameters of the dialect. For full details about the dialect and formatting parameters, see section &lt;a href=&quot;#csv-fmt-params&quot;&gt;Dialects and Formatting Parameters&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;방언&lt;/em&gt; 을 &lt;em&gt;name&lt;/em&gt; 과 연결하십시오 . &lt;em&gt;이름&lt;/em&gt; 은 문자열이어야합니다. &lt;a href=&quot;#csv.Dialect&quot;&gt; &lt;code&gt;Dialect&lt;/code&gt; &lt;/a&gt; 의 하위 클래스를 전달 하거나 &lt;em&gt;fmtparams&lt;/em&gt; 키워드 인수 또는 둘 다를 사용하여 방언의 매개 변수를 재정의하는 키워드 인수를 사용하여 방언을 지정할 수 있습니다. 방언 및 서식 매개 변수에 대한 자세한 내용은 섹션을 참조 &lt;a href=&quot;#csv-fmt-params&quot;&gt;방언 및 서식 매개 변수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f3bcabdd04e1667230d7f6889c5454cd909ae99" translate="yes" xml:space="preserve">
          <source>Associates a value with a specified key.</source>
          <target state="translated">값을 지정된 키와 연관시킵니다.</target>
        </trans-unit>
        <trans-unit id="57c2abf791222401df793e61a9b604ada26f9510" translate="yes" xml:space="preserve">
          <source>Associates level &lt;em&gt;level&lt;/em&gt; with text &lt;em&gt;levelName&lt;/em&gt; in an internal dictionary, which is used to map numeric levels to a textual representation, for example when a &lt;a href=&quot;#logging.Formatter&quot;&gt;&lt;code&gt;Formatter&lt;/code&gt;&lt;/a&gt; formats a message. This function can also be used to define your own levels. The only constraints are that all levels used must be registered using this function, levels should be positive integers and they should increase in increasing order of severity.</source>
          <target state="translated">내부 사전에서 레벨 &lt;em&gt;레벨&lt;/em&gt; 을 텍스트 &lt;em&gt;levelName&lt;/em&gt; 과 연관 시킵니다. 예를 들어 &lt;a href=&quot;#logging.Formatter&quot;&gt; &lt;code&gt;Formatter&lt;/code&gt; &lt;/a&gt; 가 메시지를 형식화 할 때 숫자 레벨을 텍스트 표시에 맵핑 합니다. 이 기능을 사용하여 자신 만의 레벨을 정의 할 수도 있습니다. 사용되는 모든 레벨은이 함수를 사용하여 등록해야하며 레벨은 양의 정수 여야하며 심각도의 증가에 따라 증가해야한다는 제약이 있습니다.</target>
        </trans-unit>
        <trans-unit id="99867ade566e46b388e954ef09df2f75d1038b85" translate="yes" xml:space="preserve">
          <source>Assume authentication as &lt;em&gt;user&lt;/em&gt;. Allows an authorised administrator to proxy into any user&amp;rsquo;s mailbox.</source>
          <target state="translated">&lt;em&gt;user로&lt;/em&gt; 인증을 가정하십시오 . 권한있는 관리자가 사용자의 사서함에 프록시를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="26bb7ee1e82bfd124b995cad27c9d2ea8e6c6188" translate="yes" xml:space="preserve">
          <source>Assume the end of the document. That will check well-formedness conditions that can be checked only at the end, invoke handlers, and may clean up resources allocated during parsing.</source>
          <target state="translated">문서의 끝을 가정하십시오. 그러면 끝에서만 확인할 수있는 올바른 형식의 조건을 확인하고 핸들러를 호출하며 구문 분석 중에 할당 된 자원을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a6fb61e671a32cacd481771d74554c4616cd64b" translate="yes" xml:space="preserve">
          <source>Assuming the Python code above is saved into a file called &lt;code&gt;prog.py&lt;/code&gt;, it can be run at the command line and provides useful help messages:</source>
          <target state="translated">위의 Python 코드가 &lt;code&gt;prog.py&lt;/code&gt; 파일에 저장되어 있다고 가정하면 명령 행에서 실행할 수 있으며 유용한 도움말 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="17acdde866027b94b28efa16a0a09a1e51553c63" translate="yes" xml:space="preserve">
          <source>Assuming the associated lock is recursive (which it is by default) you can instead do</source>
          <target state="translated">연관된 잠금이 재귀 적이라고 가정하면 (기본적으로) 대신 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="005edc07fe911b0da3e54105325e3a3dbe1f1711" translate="yes" xml:space="preserve">
          <source>Assuming your script has no syntax errors, yet it does not work, you have no choice but to read the next section.</source>
          <target state="translated">스크립트에 구문 오류가 없지만 작동하지 않는 경우 다음 섹션을 읽을 수 밖에 없습니다.</target>
        </trans-unit>
        <trans-unit id="f329190d0fd15344dac730aabc63c032720e1284" translate="yes" xml:space="preserve">
          <source>Asterisk</source>
          <target state="translated">Asterisk</target>
        </trans-unit>
        <trans-unit id="f5e07612cc5bcc0cfaeae3b9a0358117f2681619" translate="yes" xml:space="preserve">
          <source>Asychronously run a function in a separate OS thread.</source>
          <target state="translated">별도의 OS 스레드에서 비동기식으로 함수를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1bd5673736a4b97f46b75295ed686c6410f3f563" translate="yes" xml:space="preserve">
          <source>Async and await</source>
          <target state="translated">비동기 및 대기</target>
        </trans-unit>
        <trans-unit id="7011bcb2a149d047c8ec7153896517a23adc9f65" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O</source>
          <target state="translated">비동기식 I / O</target>
        </trans-unit>
        <trans-unit id="76a9f4eccd2719060ed9b323830b0077d403caed" translate="yes" xml:space="preserve">
          <source>Asynchronous Mixins</source>
          <target state="translated">비동기 믹스 인</target>
        </trans-unit>
        <trans-unit id="104c39ddd5b87efe32adc15b6d214b9332b179b7" translate="yes" xml:space="preserve">
          <source>Asynchronous iteration methods: &lt;code&gt;__aiter__&lt;/code&gt; and &lt;code&gt;__anext__&lt;/code&gt;</source>
          <target state="translated">비동기 반복 방법 : &lt;code&gt;__aiter__&lt;/code&gt; 및 &lt;code&gt;__anext__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b14c98bb24b89858352c275883aab384afdbd313" translate="yes" xml:space="preserve">
          <source>Asynchronous programming</source>
          <target state="translated">비동기 프로그래밍</target>
        </trans-unit>
        <trans-unit id="209a40d7b9cbb542c52bb05184d751a0e19a14bd" translate="yes" xml:space="preserve">
          <source>Asynchronous programming is different from classic &amp;ldquo;sequential&amp;rdquo; programming.</source>
          <target state="translated">비동기식 프로그래밍은 일반적인 &quot;순차적&quot;프로그래밍과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="120004888d9e7b45090be61175fabb0ddafb7dcc" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.getaddrinfo&quot;&gt;&lt;code&gt;socket.getaddrinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.getaddrinfo&quot;&gt; &lt;code&gt;socket.getaddrinfo()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="9704ec7e27d093412e9ffd17b2f9417c95ee49f0" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.getnameinfo&quot;&gt;&lt;code&gt;socket.getnameinfo()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.getnameinfo&quot;&gt; &lt;code&gt;socket.getnameinfo()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="e75a6e60c21cef60290f8db343e2dd2f1b6b1276" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.socket.connect&quot;&gt;&lt;code&gt;socket.connect()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket.connect&quot;&gt; &lt;code&gt;socket.connect()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="e50fde5f44e91a6cb4dcbfaaaadebf896e7d84b9" translate="yes" xml:space="preserve">
          <source>Asynchronous version of &lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt;&lt;code&gt;socket.sendfile()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;socket#socket.socket.sendfile&quot;&gt; &lt;code&gt;socket.sendfile()&lt;/code&gt; &lt;/a&gt; 의 비동기 버전 .</target>
        </trans-unit>
        <trans-unit id="8bcb500e2adace81f9483ea905e903583d45817b" translate="yes" xml:space="preserve">
          <source>Asynchronously run function &lt;em&gt;func&lt;/em&gt; in a separate thread.</source>
          <target state="translated">별도의 스레드에서 함수 &lt;em&gt;func&lt;/em&gt; 를 비동기 적으로 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="a23dd13ee19c13bb7c352d2501d29036e264def5" translate="yes" xml:space="preserve">
          <source>At &lt;a href=&quot;#zoneinfo-data-runtime-config&quot;&gt;runtime&lt;/a&gt;, the search path can be manipulated using the &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt;&lt;code&gt;reset_tzpath()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">에서 &lt;a href=&quot;#zoneinfo-data-runtime-config&quot;&gt;런타임&lt;/a&gt; 검색 경로는 사용하여 조작 할 수 있습니다 &lt;a href=&quot;#zoneinfo.reset_tzpath&quot;&gt; &lt;code&gt;reset_tzpath()&lt;/code&gt; &lt;/a&gt; 함수를.</target>
        </trans-unit>
        <trans-unit id="03e876b72734198f8efacaee16cfa51b70b11561" translate="yes" xml:space="preserve">
          <source>At least one of the following options must be specified when invoking &lt;a href=&quot;#module-trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#cmdoption-trace-l&quot;&gt;&lt;code&gt;--listfuncs&lt;/code&gt;&lt;/a&gt; option is mutually exclusive with the &lt;a href=&quot;#cmdoption-trace-t&quot;&gt;&lt;code&gt;--trace&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; options. When &lt;a href=&quot;#cmdoption-trace-l&quot;&gt;&lt;code&gt;--listfuncs&lt;/code&gt;&lt;/a&gt; is provided, neither &lt;a href=&quot;#cmdoption-trace-c&quot;&gt;&lt;code&gt;--count&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;#cmdoption-trace-t&quot;&gt;&lt;code&gt;--trace&lt;/code&gt;&lt;/a&gt; are accepted, and vice versa.</source>
          <target state="translated">&lt;a href=&quot;#module-trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 다음 옵션 중 하나 이상을 지정해야합니다 . &lt;a href=&quot;#cmdoption-trace-l&quot;&gt; &lt;code&gt;--listfuncs&lt;/code&gt; 의&lt;/a&gt; 옵션과 상호 배타적입니다 &lt;a href=&quot;#cmdoption-trace-t&quot;&gt; &lt;code&gt;--trace&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 옵션을 제공합니다. 때 &lt;a href=&quot;#cmdoption-trace-l&quot;&gt; &lt;code&gt;--listfuncs&lt;/code&gt; 는&lt;/a&gt; ,도 제공 &lt;a href=&quot;#cmdoption-trace-c&quot;&gt; &lt;code&gt;--count&lt;/code&gt; &lt;/a&gt; 도 &lt;a href=&quot;#cmdoption-trace-t&quot;&gt; &lt;code&gt;--trace&lt;/code&gt; 은&lt;/a&gt; 받아, 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="005c763745673715312660addc3a03a01b8c8624" translate="yes" xml:space="preserve">
          <source>At normal program termination (for instance, if &lt;a href=&quot;sys#sys.exit&quot;&gt;&lt;code&gt;sys.exit()&lt;/code&gt;&lt;/a&gt; is called or the main module&amp;rsquo;s execution completes), all functions registered are called in last in, first out order. The assumption is that lower level modules will normally be imported before higher level modules and thus must be cleaned up later.</source>
          <target state="translated">정상적인 프로그램 종료시 (예를 들어, &lt;a href=&quot;sys#sys.exit&quot;&gt; &lt;code&gt;sys.exit()&lt;/code&gt; &lt;/a&gt; 가 호출되거나 주 모듈의 실행이 완료된 경우) 등록 된 모든 함수는 마지막 순서대로 먼저 호출됩니다. 일반적으로 하위 모듈은 상위 모듈보다 먼저 가져 오기 때문에 나중에 정리해야합니다.</target>
        </trans-unit>
        <trans-unit id="4212a7fb6907badcb796ef9f8a9820ede2ad461f" translate="yes" xml:space="preserve">
          <source>At object creation time, using keyword arguments</source>
          <target state="translated">키워드 인수를 사용하여 객체 생성시</target>
        </trans-unit>
        <trans-unit id="b9dffbcc195db46cf07fd560bf9cf819a6052dfc" translate="yes" xml:space="preserve">
          <source>At runtime, &lt;code&gt;isinstance(x, T)&lt;/code&gt; will raise &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. In general, &lt;a href=&quot;functions#isinstance&quot;&gt;&lt;code&gt;isinstance()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#issubclass&quot;&gt;&lt;code&gt;issubclass()&lt;/code&gt;&lt;/a&gt; should not be used with types.</source>
          <target state="translated">런타임시 &lt;code&gt;isinstance(x, T)&lt;/code&gt; 는 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다. 일반적으로 &lt;a href=&quot;functions#isinstance&quot;&gt; &lt;code&gt;isinstance()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#issubclass&quot;&gt; &lt;code&gt;issubclass()&lt;/code&gt; &lt;/a&gt; 는 유형과 함께 사용하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="86ca4076074ecbdd662b657c7418c10266e2fae5" translate="yes" xml:space="preserve">
          <source>At the end of the module, there is a test section that contains a more extensive example of usage.</source>
          <target state="translated">모듈의 끝에는보다 광범위한 사용 예제가 포함 된 테스트 섹션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="73eae57537773d1ac17b68b2f125d8fe89f21f11" translate="yes" xml:space="preserve">
          <source>At the highest level, the transport is concerned with &lt;em&gt;how&lt;/em&gt; bytes are transmitted, while the protocol determines &lt;em&gt;which&lt;/em&gt; bytes to transmit (and to some extent when).</source>
          <target state="translated">최상위 레벨에서, 상기 전송이 염려되는 &lt;em&gt;방법&lt;/em&gt; 프로토콜 결정하면서, 바이트들이 전송 &lt;em&gt;되는&lt;/em&gt; (언제, 어느 정도까지)로 송신 바이트.</target>
        </trans-unit>
        <trans-unit id="7b93ef8974634ba1eeddb05cd6f4fb7beae6e9cc" translate="yes" xml:space="preserve">
          <source>At the moment, there is only one possible parameter:</source>
          <target state="translated">현재 가능한 매개 변수는 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="8578bb4b0c201f731d20286e27c500875b32217c" translate="yes" xml:space="preserve">
          <source>At the operating system level, sockets in &lt;em&gt;timeout mode&lt;/em&gt; are internally set in non-blocking mode. Also, the blocking and timeout modes are shared between file descriptors and socket objects that refer to the same network endpoint. This implementation detail can have visible consequences if e.g. you decide to use the &lt;a href=&quot;#socket.socket.fileno&quot;&gt;&lt;code&gt;fileno()&lt;/code&gt;&lt;/a&gt; of a socket.</source>
          <target state="translated">운영 체제 레벨에서 &lt;em&gt;시간 종료 모드의&lt;/em&gt; 소켓 은 내부적으로 비 블로킹 모드로 설정됩니다. 또한 차단 및 시간 종료 모드는 파일 설명자와 동일한 네트워크 엔드 포인트를 참조하는 소켓 오브젝트간에 공유됩니다. 예를 들어 , 소켓 의 &lt;a href=&quot;#socket.socket.fileno&quot;&gt; &lt;code&gt;fileno()&lt;/code&gt; &lt;/a&gt; 를 사용하기로 결정한 경우이 구현 세부 사항은 가시적 인 결과를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="de79fa22e86445c74c1c60a24771c2ff1fcf7262" translate="yes" xml:space="preserve">
          <source>At the point where the generator yields, the block nested in the &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement is executed. The generator is then resumed after the block is exited. If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; statement to trap the error (if any), or ensure that some cleanup takes place. If an exception is trapped merely in order to log it or to perform some action (rather than to suppress it entirely), the generator must reraise that exception. Otherwise the generator context manager will indicate to the &lt;code&gt;with&lt;/code&gt; statement that the exception has been handled, and execution will resume with the statement immediately following the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">생성기가 생성되는 시점에서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 중첩 된 블록 이 실행됩니다. 그런 다음 블록이 종료 된 후 생성기가 다시 시작됩니다. 처리되지 않은 예외가 블록에서 발생하면 수율이 발생한 지점에서 발생기 내부에서 다시 발생합니다. 따라서 &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.8/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 문을 사용하여 오류를 잡거나 (정리 된 경우) 정리할 수 있습니다. 예외를 기록하기 위해 또는 예외를 완전히 억제하지 않고 일부 작업을 수행하기 위해 예외가 발생하는 경우 생성기는 해당 예외를 다시 발생시켜야합니다. 그렇지 않으면 발전기 컨텍스트 관리자는로 표시됩니다 &lt;code&gt;with&lt;/code&gt; 예외가 처리되었다고 선언하면 &lt;code&gt;with&lt;/code&gt; 문 바로 뒤에 나오는 문으로 실행이 다시 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="4680ce2767581e01529e2346cba283fd88f47fee" translate="yes" xml:space="preserve">
          <source>At the point where the generator yields, the block nested in the &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt;&lt;code&gt;with&lt;/code&gt;&lt;/a&gt; statement is executed. The generator is then resumed after the block is exited. If an unhandled exception occurs in the block, it is reraised inside the generator at the point where the yield occurred. Thus, you can use a &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt;&lt;code&gt;try&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt;&lt;code&gt;except&lt;/code&gt;&lt;/a&gt;&amp;hellip;&lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt;&lt;code&gt;finally&lt;/code&gt;&lt;/a&gt; statement to trap the error (if any), or ensure that some cleanup takes place. If an exception is trapped merely in order to log it or to perform some action (rather than to suppress it entirely), the generator must reraise that exception. Otherwise the generator context manager will indicate to the &lt;code&gt;with&lt;/code&gt; statement that the exception has been handled, and execution will resume with the statement immediately following the &lt;code&gt;with&lt;/code&gt; statement.</source>
          <target state="translated">생성기가 양보하는 지점에서 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#with&quot;&gt; &lt;code&gt;with&lt;/code&gt; &lt;/a&gt; 문에 중첩 된 블록 이 실행됩니다. 생성기는 블록이 종료 된 후 다시 시작됩니다. 처리되지 않은 예외가 블록에서 발생하면 수익률이 발생한 지점에서 생성기 내부에서 다시 발생합니다. 따라서 &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#try&quot;&gt; &lt;code&gt;try&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#except&quot;&gt; &lt;code&gt;except&lt;/code&gt; &lt;/a&gt; &amp;hellip; &lt;a href=&quot;https://docs.python.org/3.9/reference/compound_stmts.html#finally&quot;&gt; &lt;code&gt;finally&lt;/code&gt; &lt;/a&gt; 문을 사용하여 오류를 포착하거나 (있는 경우) 일부 정리가 수행되도록 할 수 있습니다. 예외를 기록하거나 일부 작업을 수행하기 위해 (완전히 억제하는 대신) 예외가 트랩 된 경우 생성기는 해당 예외를 다시 발생시켜야합니다. 그렇지 않으면 발전기 컨텍스트 관리자는로 표시됩니다 &lt;code&gt;with&lt;/code&gt; 예외가 처리 된 문, 그리고 실행은 문 바로 다음에 재개 &lt;code&gt;with&lt;/code&gt; 문.</target>
        </trans-unit>
        <trans-unit id="2f936198137a924a78693853317db45f419b314f" translate="yes" xml:space="preserve">
          <source>At the time of this writing there are docstring dictionaries in German and in Italian. (Requests please to &lt;a href=&quot;mailto:glingl%40aon.at&quot;&gt;glingl@aon.at&lt;/a&gt;.)</source>
          <target state="translated">이 글을 쓰는 시점에는 독어와 이탈리아어로 된 docstring 사전이 있습니다. ( &lt;a href=&quot;mailto:glingl%40aon.at&quot;&gt;glingl@aon.at에&lt;/a&gt; 요청하십시오 .)</target>
        </trans-unit>
        <trans-unit id="bd54bc6b94be573dbc110a2ed3dd2570d7474e92" translate="yes" xml:space="preserve">
          <source>At the top of the I/O hierarchy is the abstract base class &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. It defines the basic interface to a stream. Note, however, that there is no separation between reading and writing to streams; implementations are allowed to raise &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt;&lt;code&gt;UnsupportedOperation&lt;/code&gt;&lt;/a&gt; if they do not support a given operation.</source>
          <target state="translated">I / O 계층의 맨 위에는 추상 기본 클래스 &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 가&lt;/a&gt; 있습니다. 스트림에 대한 기본 인터페이스를 정의합니다. 그러나 스트림에 대한 읽기와 쓰기는 분리되지 않습니다. 구현이 지정된 작업을 지원하지 않으면 &lt;a href=&quot;#io.UnsupportedOperation&quot;&gt; &lt;code&gt;UnsupportedOperation&lt;/code&gt; 을&lt;/a&gt; 발생시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="546ddf033018c3a7e711de15f41a05346f8ae2b5" translate="yes" xml:space="preserve">
          <source>At the top of the stack are either &lt;code&gt;NULL&lt;/code&gt; (pushed by &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt;&lt;code&gt;BEGIN_FINALLY&lt;/code&gt;&lt;/a&gt;) or 6 values pushed if an exception has been raised in the with block. Below is the context manager&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt;&lt;code&gt;__aexit__()&lt;/code&gt;&lt;/a&gt; bound method.</source>
          <target state="translated">스택의 맨 위에는 &lt;code&gt;NULL&lt;/code&gt; ( &lt;a href=&quot;#opcode-BEGIN_FINALLY&quot;&gt; &lt;code&gt;BEGIN_FINALLY&lt;/code&gt; 에&lt;/a&gt; 의해 푸시 됨 ) 또는 with 블록에서 예외가 발생한 경우 6 개의 값이 푸시됩니다. 아래는 컨텍스트 관리자의 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__aexit__&quot;&gt; &lt;code&gt;__aexit__()&lt;/code&gt; &lt;/a&gt; 바운드 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="3a9ec1befa4a5306b468dc7e8631beee73bd6981" translate="yes" xml:space="preserve">
          <source>At this point, you can remove the application name from the registry as a source of event log entries. However, if you do this, you will not be able to see the events as you intended in the Event Log Viewer - it needs to be able to access the registry to get the .dll name. The current version does not do this.</source>
          <target state="translated">이때 레지스트리에서 응용 프로그램 이름을 이벤트 로그 항목의 소스로 제거 할 수 있습니다. 그러나이 작업을 수행하면 이벤트 로그 뷰어에서 의도 한대로 이벤트를 볼 수 없습니다. 레지스트리에 액세스하여 .dll 이름을 가져와야합니다. 현재 버전은이 작업을 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77945ec79bafc1b696c30defadbc717e1a79af37" translate="yes" xml:space="preserve">
          <source>At unpickling time, some methods like &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement &lt;a href=&quot;#object.__getnewargs__&quot;&gt;&lt;code&gt;__getnewargs__()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt;&lt;code&gt;__getnewargs_ex__()&lt;/code&gt;&lt;/a&gt; to establish such an invariant; otherwise, neither &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; will be called.</source>
          <target state="translated">피클 링 해제시 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 메소드 가 인스턴스에서 호출 될 수 있습니다. 이러한 메소드가 일부 내부 불변에 의존하는 경우, 유형은 이러한 불변을 설정하기 위해 &lt;a href=&quot;#object.__getnewargs__&quot;&gt; &lt;code&gt;__getnewargs__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#object.__getnewargs_ex__&quot;&gt; &lt;code&gt;__getnewargs_ex__()&lt;/code&gt; &lt;/a&gt; 를 구현해야합니다 . 그렇지 않으면 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 가 호출 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="318d3dfbb35956ce0abcc8243ea0ae78bda19078" translate="yes" xml:space="preserve">
          <source>At unpickling time, some methods like &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt;&lt;code&gt;__setattr__()&lt;/code&gt;&lt;/a&gt; may be called upon the instance. In case those methods rely on some internal invariant being true, the type should implement &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt;&lt;code&gt;__new__()&lt;/code&gt;&lt;/a&gt; to establish such an invariant, as &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt;&lt;code&gt;__init__()&lt;/code&gt;&lt;/a&gt; is not called when unpickling an instance.</source>
          <target state="translated">언 피클 링 시간에 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__setattr__&quot;&gt; &lt;code&gt;__setattr__()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 메서드 가 인스턴스에서 호출 될 수 있습니다. 이러한 메서드가 내부 불변이 참인 경우 유형은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__new__&quot;&gt; &lt;code&gt;__new__()&lt;/code&gt; &lt;/a&gt; 를 구현 하여 인스턴스를 언 피클 할 때 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__init__&quot;&gt; &lt;code&gt;__init__()&lt;/code&gt; &lt;/a&gt; 가 호출되지 않으므로 이러한 불변을 설정 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="eb9837a1d06939ed7ea8bb756a82ada0870d4850" translate="yes" xml:space="preserve">
          <source>Attach a mock as an attribute of this one, replacing its name and parent. Calls to the attached mock will be recorded in the &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt;&lt;code&gt;method_calls&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt;&lt;code&gt;mock_calls&lt;/code&gt;&lt;/a&gt; attributes of this one.</source>
          <target state="translated">이 속성을 모의 이름과 부모로 바꾸십시오. 첨부 된 mock에 대한 호출 은 this 의 &lt;a href=&quot;#unittest.mock.Mock.method_calls&quot;&gt; &lt;code&gt;method_calls&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#unittest.mock.Mock.mock_calls&quot;&gt; &lt;code&gt;mock_calls&lt;/code&gt; &lt;/a&gt; 속성에 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="b00d5eac33db6facb2e7b7a2c2ed13c7c2c1b486" translate="yes" xml:space="preserve">
          <source>Attach the watcher to an event loop.</source>
          <target state="translated">감시자를 이벤트 루프에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="8968365a321bb5b470f5dd2910dc56d308443a45" translate="yes" xml:space="preserve">
          <source>Attaches the callable &lt;em&gt;fn&lt;/em&gt; to the future. &lt;em&gt;fn&lt;/em&gt; will be called, with the future as its only argument, when the future is cancelled or finishes running.</source>
          <target state="translated">호출 가능한 &lt;em&gt;fn&lt;/em&gt; 을 미래 에 연결합니다 . 미래가 유일한 인수로서 미래가 취소되거나 실행이 완료되면 &lt;em&gt;fn&lt;/em&gt; 이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2de4844092811a250638c499c463f6e1183dadac" translate="yes" xml:space="preserve">
          <source>Attaching Mocks as Attributes</source>
          <target state="translated">Mocks를 속성으로 첨부</target>
        </trans-unit>
        <trans-unit id="05d7b70d5d34350cfab01a5105b6cadb19208146" translate="yes" xml:space="preserve">
          <source>Attempt to cancel the call. If the call is currently being executed or finished running and cannot be cancelled then the method will return &lt;code&gt;False&lt;/code&gt;, otherwise the call will be cancelled and the method will return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">통화를 취소하려고합니다. 호출이 현재 실행 중이거나 실행이 끝나고 취소 할 수없는 경우 메소드는 &lt;code&gt;False&lt;/code&gt; 를 리턴 하고 그렇지 않으면 호출이 취소되고 메소드는 &lt;code&gt;True&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="a94ab803dbe317473c0a7010ac4289475d2e741b" translate="yes" xml:space="preserve">
          <source>Attempt to find the loader to handle &lt;em&gt;fullname&lt;/em&gt; within &lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 내에서 &lt;em&gt;전체 이름&lt;/em&gt; 을 처리 할 로더를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="87e96da2c623edd35028d89720f05572c7ca81a6" translate="yes" xml:space="preserve">
          <source>Attempt to find the spec to handle &lt;em&gt;fullname&lt;/em&gt; within &lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt;&lt;code&gt;path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#importlib.machinery.FileFinder.path&quot;&gt; &lt;code&gt;path&lt;/code&gt; &lt;/a&gt; 내에서 &lt;em&gt;전체 이름&lt;/em&gt; 을 처리 할 스펙을 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="d2ad8c10f0d76337b6eb760519bcf124aa2fa5b5" translate="yes" xml:space="preserve">
          <source>Attempt to read and parse an iterable of filenames, returning a list of filenames which were successfully parsed.</source>
          <target state="translated">반복 가능한 파일 이름을 읽고 구문 분석하여 성공적으로 구문 분석 된 파일 이름 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cec2196c119a8750bee0a499c586caefe53531d9" translate="yes" xml:space="preserve">
          <source>Attempt to set up a connection to the listener which is using address &lt;em&gt;address&lt;/em&gt;, returning a &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주소 &lt;em&gt;주소를&lt;/em&gt; 사용하는 리스너에 대한 연결을 설정 하여 &lt;a href=&quot;#multiprocessing.connection.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; 을&lt;/a&gt; 리턴하려고 합니다 .</target>
        </trans-unit>
        <trans-unit id="bcfcda249f8236d3c4a374364c689dafac6d094d" translate="yes" xml:space="preserve">
          <source>Attempting to create a member with the same name as an already defined attribute (another member, a method, etc.) or attempting to create an attribute with the same name as a member is not allowed.</source>
          <target state="translated">이미 정의 된 속성 (다른 멤버, 메소드 등)과 동일한 이름의 멤버를 작성하거나 멤버와 동일한 이름의 속성을 작성하려는 시도는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="582daf17ef09c37849d7cd683a4bf531834c0538" translate="yes" xml:space="preserve">
          <source>Attempting to decompress data after the end of stream is reached raises an &lt;code&gt;EOFError&lt;/code&gt;. Any data found after the end of the stream is ignored and saved in the &lt;a href=&quot;#bz2.BZ2Decompressor.unused_data&quot;&gt;&lt;code&gt;unused_data&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">스트림 끝에 도달 한 후 데이터 압축 해제를 시도하면 &lt;code&gt;EOFError&lt;/code&gt; 가 발생 합니다. 스트림 끝 이후에 발견 된 모든 데이터는 무시되고 &lt;a href=&quot;#bz2.BZ2Decompressor.unused_data&quot;&gt; &lt;code&gt;unused_data&lt;/code&gt; &lt;/a&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="0b665a0261d8155c9a7fef41d1c6d0fafe94af38" translate="yes" xml:space="preserve">
          <source>Attempting to decompress data after the end of stream is reached raises an &lt;code&gt;EOFError&lt;/code&gt;. Any data found after the end of the stream is ignored and saved in the &lt;a href=&quot;#lzma.LZMADecompressor.unused_data&quot;&gt;&lt;code&gt;unused_data&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">스트림 끝에 도달 한 후 데이터 압축 해제를 시도하면 &lt;code&gt;EOFError&lt;/code&gt; 가 발생 합니다. 스트림 끝 이후에 발견 된 모든 데이터는 무시되고 &lt;a href=&quot;#lzma.LZMADecompressor.unused_data&quot;&gt; &lt;code&gt;unused_data&lt;/code&gt; &lt;/a&gt; 속성에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e681818ae46e966f6a5519bb892f806874ff3de9" translate="yes" xml:space="preserve">
          <source>Attempting to hash an immutable sequence that contains unhashable values will result in &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">해싱 불가능한 값을 포함하는 불변 시퀀스를 해시하려고하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4315a818f5b166adfafe5e6b5bedd0f534c2d06f" translate="yes" xml:space="preserve">
          <source>Attempting to link in too many shared libraries</source>
          <target state="translated">너무 많은 공유 라이브러리에서 링크를 시도</target>
        </trans-unit>
        <trans-unit id="5c1642b2606e4707280aebbdbf990340b047aa2c" translate="yes" xml:space="preserve">
          <source>Attempting to mix &lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; data with &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt; in a single function call will result in a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; being raised, while attempting to pass in non-ASCII byte values will trigger &lt;a href=&quot;exceptions#UnicodeDecodeError&quot;&gt;&lt;code&gt;UnicodeDecodeError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 함수 호출에서 &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 데이터를 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 또는 바이트 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 과 혼합하려고 시도 하면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 가 발생하고 ASCII가 아닌 바이트 값을 전달하면 &lt;a href=&quot;exceptions#UnicodeDecodeError&quot;&gt; &lt;code&gt;UnicodeDecodeError&lt;/code&gt; &lt;/a&gt; 가 트리거 됩니다.</target>
        </trans-unit>
        <trans-unit id="f6184f80184272af2a3f2d6c0b9b164e1af53cf1" translate="yes" xml:space="preserve">
          <source>Attempting to pass an invalid interval timer will cause an &lt;a href=&quot;#signal.ItimerError&quot;&gt;&lt;code&gt;ItimerError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유효하지 않은 간격 타이머를 전달하려고하면 &lt;a href=&quot;#signal.ItimerError&quot;&gt; &lt;code&gt;ItimerError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="6e116626d01e2573360701151c730543d251d466" translate="yes" xml:space="preserve">
          <source>Attempting to remove a file descriptor that was never registered causes a &lt;a href=&quot;exceptions#KeyError&quot;&gt;&lt;code&gt;KeyError&lt;/code&gt;&lt;/a&gt; exception to be raised.</source>
          <target state="translated">등록되지 않은 파일 설명자를 제거하려고하면 &lt;a href=&quot;exceptions#KeyError&quot;&gt; &lt;code&gt;KeyError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3488e5797ae34b2740e12aca784ebb804aa2a11a" translate="yes" xml:space="preserve">
          <source>Attempting to remove a file descriptor that was never registered is safely ignored.</source>
          <target state="translated">등록되지 않은 파일 설명자를 제거하려고 시도해도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="413a8b0ee7fbafdd8b138da7cc28cc290a17232c" translate="yes" xml:space="preserve">
          <source>Attempts to parse a date according to the rules in &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt;. however, some mailers don&amp;rsquo;t follow that format as specified, so &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt; tries to guess correctly in such cases. &lt;em&gt;date&lt;/em&gt; is a string containing an &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; date, such as &lt;code&gt;&quot;Mon, 20 Nov 1995 19:12:08 -0500&quot;&lt;/code&gt;. If it succeeds in parsing the date, &lt;a href=&quot;#email.utils.parsedate&quot;&gt;&lt;code&gt;parsedate()&lt;/code&gt;&lt;/a&gt; returns a 9-tuple that can be passed directly to &lt;a href=&quot;time#time.mktime&quot;&gt;&lt;code&gt;time.mktime()&lt;/code&gt;&lt;/a&gt;; otherwise &lt;code&gt;None&lt;/code&gt; will be returned. Note that indexes 6, 7, and 8 of the result tuple are not usable.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 의 규칙에 따라 날짜를 구문 분석하려고 시도합니다 . 그러나 일부 메일러는 지정된 형식을 따르지 않으므로 &lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 는 이러한 경우 올바르게 추측하려고합니다. &lt;em&gt;date&lt;/em&gt; 는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2822.html&quot; id=&quot;index-3&quot;&gt;&lt;strong&gt;RFC 2822&lt;/strong&gt;&lt;/a&gt; 날짜를 포함하는 문자열입니다 ( 예 : &lt;code&gt;&quot;Mon, 20 Nov 1995 19:12:08 -0500&quot;&lt;/code&gt; . 이 날짜를 구문 분석에 성공하면, &lt;a href=&quot;#email.utils.parsedate&quot;&gt; &lt;code&gt;parsedate()&lt;/code&gt; &lt;/a&gt; 에 직접 전달 될 수있는 9 튜플 반환 &lt;a href=&quot;time#time.mktime&quot;&gt; &lt;code&gt;time.mktime()&lt;/code&gt; &lt;/a&gt; ; 그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 이 반환됩니다. 결과 튜플의 인덱스 6, 7, 8은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f8f0a192956c468d1f05450c3d0f99e1ed3eb87" translate="yes" xml:space="preserve">
          <source>Attempts to pickle unpicklable objects will raise the &lt;a href=&quot;#pickle.PicklingError&quot;&gt;&lt;code&gt;PicklingError&lt;/code&gt;&lt;/a&gt; exception; when this happens, an unspecified number of bytes may have already been written to the underlying file. Trying to pickle a highly recursive data structure may exceed the maximum recursion depth, a &lt;a href=&quot;exceptions#RecursionError&quot;&gt;&lt;code&gt;RecursionError&lt;/code&gt;&lt;/a&gt; will be raised in this case. You can carefully raise this limit with &lt;a href=&quot;sys#sys.setrecursionlimit&quot;&gt;&lt;code&gt;sys.setrecursionlimit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택할 수없는 객체를 피클하려고하면 &lt;a href=&quot;#pickle.PicklingError&quot;&gt; &lt;code&gt;PicklingError&lt;/code&gt; &lt;/a&gt; 예외가 발생합니다. 이 경우, 지정되지 않은 바이트 수가 이미 기본 파일에 기록되었을 수 있습니다. 높은 재귀 데이터 구조를 피클하려고하면 최대 재귀 깊이를 초과 할 수 &lt;a href=&quot;exceptions#RecursionError&quot;&gt; &lt;code&gt;RecursionError&lt;/code&gt; &lt;/a&gt; 경우 RecursionError 가 발생합니다. &lt;a href=&quot;sys#sys.setrecursionlimit&quot;&gt; &lt;code&gt;sys.setrecursionlimit()&lt;/code&gt; &lt;/a&gt; 사용 하여이 제한을 신중하게 올릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b271428a65f77bc781cd47b969a5bc6e419af63a" translate="yes" xml:space="preserve">
          <source>Attention: &lt;em&gt;speed&lt;/em&gt; = 0 means that &lt;em&gt;no&lt;/em&gt; animation takes place. forward/back makes turtle jump and likewise left/right make the turtle turn instantly.</source>
          <target state="translated">주의 : &lt;em&gt;speed&lt;/em&gt; = 0은 애니메이션이 발생 &lt;em&gt;하지 않음을&lt;/em&gt; 의미합니다 . 앞으로 / 뒤로 거북이가 점프하고 왼쪽 / 오른쪽으로 거북이가 즉시 회전합니다.</target>
        </trans-unit>
        <trans-unit id="4704ccf5d9826a4b8c3ff2f628be8f9ea11d5c58" translate="yes" xml:space="preserve">
          <source>Attr Objects</source>
          <target state="translated">Attr 객체</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="f6a291a4083dcfd41b19b0b5972f9a151abebd51" translate="yes" xml:space="preserve">
          <source>Attribute access, e.g. &lt;code&gt;d.keys&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is a node, typically a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;attr&lt;/code&gt; is a bare string giving the name of the attribute, and &lt;code&gt;ctx&lt;/code&gt; is &lt;a href=&quot;#ast.Load&quot;&gt;&lt;code&gt;Load&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#ast.Store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#ast.Del&quot;&gt;&lt;code&gt;Del&lt;/code&gt;&lt;/a&gt; according to how the attribute is acted on.</source>
          <target state="translated">속성 액세스, 예 : &lt;code&gt;d.keys&lt;/code&gt; . &lt;code&gt;value&lt;/code&gt; 는 노드이며 일반적으로 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 입니다. &lt;code&gt;attr&lt;/code&gt; 은 속성의 이름을 제공하는 베어 문자열이며, &lt;code&gt;ctx&lt;/code&gt; 는 속성이 작동하는 방식에 따라 &lt;a href=&quot;#ast.Load&quot;&gt; &lt;code&gt;Load&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#ast.Store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#ast.Del&quot;&gt; &lt;code&gt;Del&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fd11efd3b2bb215beb5fe4deac5b15c31b49871e" translate="yes" xml:space="preserve">
          <source>Attribute name</source>
          <target state="translated">속성 이름</target>
        </trans-unit>
        <trans-unit id="44b0ecb440f33452e3b57f0fc1355b5b83b53b65" translate="yes" xml:space="preserve">
          <source>Attribute value nodes on element nodes.</source>
          <target state="translated">요소 노드의 속성 값 노드</target>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="79c3aeb6146abe2231f5b89a475ab249029d088e" translate="yes" xml:space="preserve">
          <source>Attributes and methods for customizing the WSGI environment:</source>
          <target state="translated">WSGI 환경을 사용자 정의하기위한 속성 및 메소드 :</target>
        </trans-unit>
        <trans-unit id="e9b663bf28955d0808f846d124c86b6d0183b33f" translate="yes" xml:space="preserve">
          <source>Attributes and methods on a &lt;code&gt;os.DirEntry&lt;/code&gt; instance are as follows:</source>
          <target state="translated">&lt;code&gt;os.DirEntry&lt;/code&gt; 인스턴스의 속성 및 메소드 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73692911ebd863a9a87e4961881d432666982309" translate="yes" xml:space="preserve">
          <source>Attributes are created on demand when you access them by name. Accessing the same attribute will always return the same object. The objects returned have a sensible repr so that test failure messages are readable.</source>
          <target state="translated">이름으로 속성에 액세스하면 요청시 속성이 작성됩니다. 동일한 속성에 액세스하면 항상 동일한 객체가 반환됩니다. 반환 된 객체는 테스트 실패 메시지를 읽을 수 있도록 적절한 repr을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="101df875704c7152821017f27b87995406582c71" translate="yes" xml:space="preserve">
          <source>Attributes plus return values and side effects can be set on child mocks using standard dot notation and unpacking a dictionary in the method call:</source>
          <target state="translated">표준 점 표기법을 사용하고 메소드 호출에서 사전 포장 풀기를 사용하여 자식 모의에 속성과 반환 값 및 부작용을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c886066a950b07e9817b943cf62493312e7bdd7" translate="yes" xml:space="preserve">
          <source>Attributes set when an exception is catched:</source>
          <target state="translated">예외가 발견 될 때 설정되는 속성 :</target>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="5c7c68f4b64e821cb3bb3f3f760a898c036a3f74" translate="yes" xml:space="preserve">
          <source>Audio Device Objects</source>
          <target state="translated">오디오 장치 객체</target>
        </trans-unit>
        <trans-unit id="16176810d7decb98eb62c4c87a10dd432035c88f" translate="yes" xml:space="preserve">
          <source>Audio device objects also support several read-only attributes:</source>
          <target state="translated">오디오 장치 개체는 여러 가지 읽기 전용 특성도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6e947bb134465c1c6a6e453065d0c48e8ca8c64a" translate="yes" xml:space="preserve">
          <source>Audio files have a number of parameters that describe the audio data. The sampling rate or frame rate is the number of times per second the sound is sampled. The number of channels indicate if the audio is mono, stereo, or quadro. Each frame consists of one sample per channel. The sample size is the size in bytes of each sample. Thus a frame consists of &lt;code&gt;nchannels * samplesize&lt;/code&gt; bytes, and a second&amp;rsquo;s worth of audio consists of &lt;code&gt;nchannels * samplesize * framerate&lt;/code&gt; bytes.</source>
          <target state="translated">오디오 파일에는 오디오 데이터를 설명하는 여러 매개 변수가 있습니다. 샘플링 속도 또는 프레임 속도는 사운드가 샘플링되는 초당 횟수입니다. 채널 수는 오디오가 모노, 스테레오 또는 쿼드로인지를 나타냅니다. 각 프레임은 채널당 하나의 샘플로 구성됩니다. 샘플 크기는 각 샘플의 크기 (바이트)입니다. 따라서 프레임은 &lt;code&gt;nchannels * samplesize&lt;/code&gt; 바이트)로 구성되며 1 초 분량의 오디오는 &lt;code&gt;nchannels * samplesize * framerate&lt;/code&gt; 바이트) 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff3e0d680200101f6f9f4009685f904d7888a4b5" translate="yes" xml:space="preserve">
          <source>Audit event</source>
          <target state="translated">감사 이벤트</target>
        </trans-unit>
        <trans-unit id="14c2893dc5aedb9cac7688ec4357a58cad8f48e8" translate="yes" xml:space="preserve">
          <source>Audit events table</source>
          <target state="translated">감사 이벤트 테이블</target>
        </trans-unit>
        <trans-unit id="929db3b0bd47cefe7a1842f9fc90bc8e40629a8d" translate="yes" xml:space="preserve">
          <source>Augmented assignment, such as &lt;code&gt;a += 1&lt;/code&gt;. In the following example, &lt;code&gt;target&lt;/code&gt; is a &lt;a href=&quot;#ast.Name&quot;&gt;&lt;code&gt;Name&lt;/code&gt;&lt;/a&gt; node for &lt;code&gt;x&lt;/code&gt; (with the &lt;a href=&quot;#ast.Store&quot;&gt;&lt;code&gt;Store&lt;/code&gt;&lt;/a&gt; context), &lt;code&gt;op&lt;/code&gt; is &lt;a href=&quot;#ast.Add&quot;&gt;&lt;code&gt;Add&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;value&lt;/code&gt; is a &lt;a href=&quot;#ast.Constant&quot;&gt;&lt;code&gt;Constant&lt;/code&gt;&lt;/a&gt; with value for 1.</source>
          <target state="translated">&lt;code&gt;a += 1&lt;/code&gt; 과 같은 증강 할당 . 다음 예제에서 &lt;code&gt;target&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; ( &lt;a href=&quot;#ast.Store&quot;&gt; &lt;code&gt;Store&lt;/code&gt; &lt;/a&gt; 컨텍스트 포함) 의 &lt;a href=&quot;#ast.Name&quot;&gt; &lt;code&gt;Name&lt;/code&gt; &lt;/a&gt; 노드 이고 &lt;code&gt;op&lt;/code&gt; 는 &lt;a href=&quot;#ast.Add&quot;&gt; &lt;code&gt;Add&lt;/code&gt; &lt;/a&gt; 이며 &lt;code&gt;value&lt;/code&gt; 는 값 이 1 인 &lt;a href=&quot;#ast.Constant&quot;&gt; &lt;code&gt;Constant&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6922a9610304991071bd728c3a287a51b532d68c" translate="yes" xml:space="preserve">
          <source>Authenticate command &amp;mdash; requires response processing.</source>
          <target state="translated">인증 명령-응답 처리가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8ccb8a1076f255643cd045f9684ad5f445deae31" translate="yes" xml:space="preserve">
          <source>Authentication is supported, using the regular SMTP mechanism. When using a Unix socket, LMTP generally don&amp;rsquo;t support or require any authentication, but your mileage might vary.</source>
          <target state="translated">일반 SMTP 메커니즘을 사용하여 인증이 지원됩니다. Unix 소켓을 사용할 때 LMTP는 일반적으로 인증을 지원하거나 요구하지 않지만 마일리지는 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="34762561a060645d5e694a00f5c15f22688272cc" translate="yes" xml:space="preserve">
          <source>Authentication keys</source>
          <target state="translated">인증 키</target>
        </trans-unit>
        <trans-unit id="b6d03350228ac0bf7f8b015328effcfd7281fdb3" translate="yes" xml:space="preserve">
          <source>Auto-negotiate the highest protocol version like &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, but only support client-side &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; connections. The protocol enables &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt;&lt;code&gt;CERT_REQUIRED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt;&lt;code&gt;check_hostname&lt;/code&gt;&lt;/a&gt; by default.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 같은 최고 프로토콜 버전을 자동 협상 하지만 클라이언트 측 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 연결 만 지원 합니다. 이 프로토콜은 기본적으로 &lt;a href=&quot;#ssl.CERT_REQUIRED&quot;&gt; &lt;code&gt;CERT_REQUIRED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#ssl.SSLContext.check_hostname&quot;&gt; &lt;code&gt;check_hostname&lt;/code&gt; &lt;/a&gt; 을 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="b1b09a77c9093ba1c2df03bc5d6beeb4959883e7" translate="yes" xml:space="preserve">
          <source>Auto-negotiate the highest protocol version like &lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt;&lt;code&gt;PROTOCOL_TLS&lt;/code&gt;&lt;/a&gt;, but only support server-side &lt;a href=&quot;#ssl.SSLSocket&quot;&gt;&lt;code&gt;SSLSocket&lt;/code&gt;&lt;/a&gt; connections.</source>
          <target state="translated">&lt;a href=&quot;#ssl.PROTOCOL_TLS&quot;&gt; &lt;code&gt;PROTOCOL_TLS&lt;/code&gt; &lt;/a&gt; 와 같은 최고 프로토콜 버전을 자동 협상 하지만 서버 측 &lt;a href=&quot;#ssl.SSLSocket&quot;&gt; &lt;code&gt;SSLSocket&lt;/code&gt; &lt;/a&gt; 연결 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="f47c5ab52bbe1a984f857a4d21dd996e64a02f48" translate="yes" xml:space="preserve">
          <source>Auto-open Stack Viewer</source>
          <target state="translated">자동 열기 스택 뷰어</target>
        </trans-unit>
        <trans-unit id="197be9c04cb2e21653d60342178244091efa77b8" translate="yes" xml:space="preserve">
          <source>Auto-speccing solves this problem. You can either pass &lt;code&gt;autospec=True&lt;/code&gt; to &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; / &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt;&lt;code&gt;patch.object()&lt;/code&gt;&lt;/a&gt; or use the &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt;&lt;code&gt;create_autospec()&lt;/code&gt;&lt;/a&gt; function to create a mock with a spec. If you use the &lt;code&gt;autospec=True&lt;/code&gt; argument to &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; then the object that is being replaced will be used as the spec object. Because the speccing is done &amp;ldquo;lazily&amp;rdquo; (the spec is created as attributes on the mock are accessed) you can use it with very complex or deeply nested objects (like modules that import modules that import modules) without a big performance hit.</source>
          <target state="translated">자동 지정은이 문제를 해결합니다. 당신도 전달할 수 있습니다 &lt;code&gt;autospec=True&lt;/code&gt; 에 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#unittest.mock.patch.object&quot;&gt; &lt;code&gt;patch.object()&lt;/code&gt; &lt;/a&gt; 하거나 사용 &lt;a href=&quot;#unittest.mock.create_autospec&quot;&gt; &lt;code&gt;create_autospec()&lt;/code&gt; &lt;/a&gt; 스펙과 실물 크기의 모형을 만드는 기능. &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;autospec=True&lt;/code&gt; 인수를 사용하면 교체중인 객체가 사양 객체로 사용됩니다. 지정이 &quot;게으르게&quot;수행되므로 (모형의 속성에 액세스 할 때 지정됨) 성능이 크게 저하되지 않고 매우 복잡하거나 깊이 중첩 된 개체 (예 : 모듈을 가져 오는 모듈을 가져 오는 모듈)와 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61da791d8a006bda906f9ae1ff768b72eb7dc76" translate="yes" xml:space="preserve">
          <source>Automatic indentation</source>
          <target state="translated">자동 들여 쓰기</target>
        </trans-unit>
        <trans-unit id="6403e37e9140843598c5440d1e8bc72de007ae50" translate="yes" xml:space="preserve">
          <source>Automatically determine how many times to call &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 호출 횟수를 자동으로 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4d5117dbfc630c5ff47b8c4726c276df15d1bd1e" translate="yes" xml:space="preserve">
          <source>Autospeccing</source>
          <target state="translated">Autospeccing</target>
        </trans-unit>
        <trans-unit id="aae79d454597517030f9ce7ec36250067a2b9f35" translate="yes" xml:space="preserve">
          <source>Autospeccing is based on the existing &lt;code&gt;spec&lt;/code&gt; feature of mock. It limits the api of mocks to the api of an original object (the spec), but it is recursive (implemented lazily) so that attributes of mocks only have the same api as the attributes of the spec. In addition mocked functions / methods have the same call signature as the original so they raise a &lt;a href=&quot;exceptions#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; if they are called incorrectly.</source>
          <target state="translated">자동 &lt;code&gt;spec&lt;/code&gt; 은 기존 모의 사양 기능을 기반으로합니다 . 모의 API를 원본 객체 (사양)의 API로 제한하지만 재귀 (게으르게 구현 됨)하여 모의 속성은 사양의 속성과 동일한 api를 갖습니다. 또한 조롱 된 함수 / 메서드는 원본과 동일한 호출 서명을 가지므로 잘못 호출되면 &lt;a href=&quot;exceptions#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 가&lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e04a76e0651512ad3b1c9b3855e894e52bacec7" translate="yes" xml:space="preserve">
          <source>Auxiliary method for getting a filename in a canonical form, that is, as a case-normalized (on case-insensitive filesystems) absolute path, stripped of surrounding angle brackets.</source>
          <target state="translated">파일 이름을 정식 형식, 즉 대소 문자를 구분하지 않는 파일 시스템에서 절대 경로로 사용하여 주변 꺾쇠 괄호를 제거하는 보조 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d15ede98b9b5686d60eb679c69ff709aea96450e" translate="yes" xml:space="preserve">
          <source>Availability: SQLite 3.6.11 or higher</source>
          <target state="translated">가용성 : SQLite 3.6.11 이상</target>
        </trans-unit>
        <trans-unit id="0648a25bb67f0b4d3be9ad2e32d5343d5884c667" translate="yes" xml:space="preserve">
          <source>Availability: Systems with the &lt;code&gt;madvise()&lt;/code&gt; system call.</source>
          <target state="translated">가용성 : &lt;code&gt;madvise()&lt;/code&gt; 시스템 호출이있는 시스템.</target>
        </trans-unit>
        <trans-unit id="fcc09c1546fd2002ad5bda6442ec6858c4d44e94" translate="yes" xml:space="preserve">
          <source>Availability: Systems with the madvise() system call.</source>
          <target state="translated">가용성 : madvise () 시스템 호출이있는 시스템.</target>
        </trans-unit>
        <trans-unit id="c9fcd2b619f3ed9f21f2ae1dc44a712e8e0c1b0c" translate="yes" xml:space="preserve">
          <source>Availability: Tk 8.6</source>
          <target state="translated">가용성 : Tk 8.6</target>
        </trans-unit>
        <trans-unit id="fb3bce3637a32f6ce35b6791b2442a57507592a0" translate="yes" xml:space="preserve">
          <source>Availability: Tk 8.6.</source>
          <target state="translated">가용성 : Tk 8.6.</target>
        </trans-unit>
        <trans-unit id="dad7b53c45f37c3a8f080b151e9238c41b4b613e" translate="yes" xml:space="preserve">
          <source>Availability: if the ncurses library is used.</source>
          <target state="translated">가용성 : ncurses 라이브러리가 사용 된 경우.</target>
        </trans-unit>
        <trans-unit id="90ede860852b2d88bce6f917c8c626dd1ebd0863" translate="yes" xml:space="preserve">
          <source>Available Context Managers</source>
          <target state="translated">사용 가능한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="e8fb788cf6307a8cd78a358b3227f7e4460f4896" translate="yes" xml:space="preserve">
          <source>Available Functions</source>
          <target state="translated">사용 가능한 기능</target>
        </trans-unit>
        <trans-unit id="886aad58c06c842c7cf3407ff5f794bccc525568" translate="yes" xml:space="preserve">
          <source>Available Types</source>
          <target state="translated">사용 가능한 유형</target>
        </trans-unit>
        <trans-unit id="c1743168e4383b0ceeb14b5166304e0f0f3be9ec" translate="yes" xml:space="preserve">
          <source>Available for read</source>
          <target state="translated">읽기 가능</target>
        </trans-unit>
        <trans-unit id="247b0d4f98d15c3f067f1f036f9a2288ba9508e3" translate="yes" xml:space="preserve">
          <source>Available for write</source>
          <target state="translated">쓰기 가능</target>
        </trans-unit>
        <trans-unit id="d5cbfc01dab58f33d6399bdf92d34e12742cc326" translate="yes" xml:space="preserve">
          <source>Available on Unix and Windows. The default on Windows and macOS.</source>
          <target state="translated">Unix 및 Windows에서 사용 가능합니다. Windows 및 macOS의 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="5bd9dd81c594faef45bb68cd8e2f6b57306afbb3" translate="yes" xml:space="preserve">
          <source>Available on Unix only. The default on Unix.</source>
          <target state="translated">유닉스에서만 사용 가능합니다. 유닉스의 기본값.</target>
        </trans-unit>
        <trans-unit id="8b289188b8156e0915761af80089ec725b1d7c5e" translate="yes" xml:space="preserve">
          <source>Available on Unix platforms which support passing file descriptors over Unix pipes.</source>
          <target state="translated">Unix 파이프를 통한 파일 디스크립터 전달을 지원하는 Unix 플랫폼에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f6c3e2a80c9a11385439b399a1bbc1528532103f" translate="yes" xml:space="preserve">
          <source>Averages and measures of central location</source>
          <target state="translated">중심 위치의 평균 및 측정</target>
        </trans-unit>
        <trans-unit id="63dece88439aa338ed47cd03f066290634af6ebb" translate="yes" xml:space="preserve">
          <source>Avoid shared state</source>
          <target state="translated">공유 상태를 피하십시오</target>
        </trans-unit>
        <trans-unit id="49cd5a5cd25205ca8554e1312e26ecf321d1c177" translate="yes" xml:space="preserve">
          <source>Avoid terminating processes</source>
          <target state="translated">프로세스 종료 방지</target>
        </trans-unit>
        <trans-unit id="9dfd80c478c083df370ff07aeddda8591a1285bc" translate="yes" xml:space="preserve">
          <source>Awaitables</source>
          <target state="translated">Awaitables</target>
        </trans-unit>
        <trans-unit id="da49b3337696e8a2b4c64d3033aa0a3a5fbc2d3f" translate="yes" xml:space="preserve">
          <source>Awaiting on a coroutine. The following snippet of code will print &amp;ldquo;hello&amp;rdquo; after waiting for 1 second, and then print &amp;ldquo;world&amp;rdquo; after waiting for &lt;em&gt;another&lt;/em&gt; 2 seconds:</source>
          <target state="translated">코 루틴을 기다리고 있습니다. 다음 코드 스 니펫은 1 초 동안 기다린 후 &quot;hello&quot;를 인쇄하고 2 초 &lt;em&gt;더&lt;/em&gt; 기다린 후 &quot;world&quot;를 인쇄합니다 .</target>
        </trans-unit>
        <trans-unit id="d09738049226150f62d909b1178a56d0dfe67bbd" translate="yes" xml:space="preserve">
          <source>Aware and Naive Objects</source>
          <target state="translated">인식하고 순진한 객체</target>
        </trans-unit>
        <trans-unit id="708e5124ff648e8126313adce762960fdf915375" translate="yes" xml:space="preserve">
          <source>BLAKE2</source>
          <target state="translated">BLAKE2</target>
        </trans-unit>
        <trans-unit id="9bc500c21c3285144fc28bd0e912a7783b167e8c" translate="yes" xml:space="preserve">
          <source>BLAKE2 can be personalized by passing bytes to the &lt;em&gt;person&lt;/em&gt; argument:</source>
          <target state="translated">BLAKE2는 &lt;em&gt;person&lt;/em&gt; 인수에 바이트를 전달하여 개인화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c571b2356698c401ae7c55f2f7327fe7d7dcc208" translate="yes" xml:space="preserve">
          <source>BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to 32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without changing the size of output, we can tell BLAKE2b to produce 20-byte digests:</source>
          <target state="translated">BLAKE2는 BLAKE2b의 경우 최대 64 바이트, BLAKE2의 경우 최대 32 바이트의 다이제스트 크기를 구성 할 수 있습니다. 예를 들어, 출력 크기를 변경하지 않고 SHA-1을 BLAKE2b로 바꾸려면 BLAKE2b에 20 바이트 다이제스트를 생성하도록 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eef9c659e49da103106b41ae1c8a79320baba6dc" translate="yes" xml:space="preserve">
          <source>BLAKE2 specification defines constant lengths for salt and personalization parameters, however, for convenience, this implementation accepts byte strings of any size up to the specified length. If the length of the parameter is less than specified, it is padded with zeros, thus, for example, &lt;code&gt;b'salt'&lt;/code&gt; and &lt;code&gt;b'salt\x00'&lt;/code&gt; is the same value. (This is not the case for &lt;em&gt;key&lt;/em&gt;.)</source>
          <target state="translated">BLAKE2 스펙은 솔트 및 개인화 매개 변수에 대해 일정한 길이를 정의하지만 편의상이 구현에서는 지정된 길이까지 모든 크기의 바이트 문자열을 허용합니다. 매개 변수의 길이가 지정된 길이보다 작 으면 0으로 채워 지므로 예를 들어 &lt;code&gt;b'salt'&lt;/code&gt; 및 &lt;code&gt;b'salt\x00'&lt;/code&gt; 은 동일한 값입니다. (이것은의 경우에는 해당되지 않습니다 &lt;em&gt;키&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="cd2ef75abf83ba49f622d80373a85346c04a5b37" translate="yes" xml:space="preserve">
          <source>BLAKE2 supports &lt;strong&gt;keyed mode&lt;/strong&gt; (a faster and simpler replacement for &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;HMAC&lt;/a&gt;), &lt;strong&gt;salted hashing&lt;/strong&gt;, &lt;strong&gt;personalization&lt;/strong&gt;, and &lt;strong&gt;tree hashing&lt;/strong&gt;.</source>
          <target state="translated">BLAKE2는 &lt;strong&gt;키 모드&lt;/strong&gt; ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash-based_message_authentication_code&quot;&gt;HMAC를&lt;/a&gt; 위한 더 빠르고 간단한 대체 ), &lt;strong&gt;솔트 해싱&lt;/strong&gt; , &lt;strong&gt;개인화&lt;/strong&gt; 및 &lt;strong&gt;트리 해싱을 지원&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cc708fbeac5b1cf0a46d24793514cf456186e0b0" translate="yes" xml:space="preserve">
          <source>BLAKE2b</source>
          <target state="translated">BLAKE2b</target>
        </trans-unit>
        <trans-unit id="b5b58babc24a9c4ee1a0847d9544ddb7d16f7c8f" translate="yes" xml:space="preserve">
          <source>BLAKE2s</source>
          <target state="translated">BLAKE2s</target>
        </trans-unit>
        <trans-unit id="e0e381dd5fc1fcdbadce37e6a061ba49795a568d" translate="yes" xml:space="preserve">
          <source>BMP files</source>
          <target state="translated">BMP 파일</target>
        </trans-unit>
        <trans-unit id="a42a05330f8bf46c41ac1665544187ff109c2243" translate="yes" xml:space="preserve">
          <source>Babyl is a single-file mailbox format used by the Rmail mail user agent included with Emacs. The beginning of a message is indicated by a line containing the two characters Control-Underscore (&lt;code&gt;'\037'&lt;/code&gt;) and Control-L (&lt;code&gt;'\014'&lt;/code&gt;). The end of a message is indicated by the start of the next message or, in the case of the last message, a line containing a Control-Underscore (&lt;code&gt;'\037'&lt;/code&gt;) character.</source>
          <target state="translated">Babyl은 Emacs에 포함 된 Rmail 메일 사용자 에이전트가 사용하는 단일 파일 사서함 형식입니다. 메시지의 시작은 Control-Underscore ( &lt;code&gt;'\037'&lt;/code&gt; )와 Control-L ( &lt;code&gt;'\014'&lt;/code&gt; ) 두 문자를 포함하는 줄로 표시됩니다 . 메시지의 끝은 다음 메시지의 시작 또는 마지막 메시지의 경우 Control-Underscore ( &lt;code&gt;'\037'&lt;/code&gt; ) 문자를 포함하는 줄로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="51e1b906cbdb74be5ef8d171c417a6f96c704e55" translate="yes" xml:space="preserve">
          <source>Back tab</source>
          <target state="translated">뒷면 탭</target>
        </trans-unit>
        <trans-unit id="fcf84c7c42731b104d6bb1ee61a75ed5dec2fca1" translate="yes" xml:space="preserve">
          <source>Back up your cookies before saving if you have cookies whose loss / corruption would be inconvenient (there are some subtleties which may lead to slight changes in the file over a load / save round-trip).</source>
          <target state="translated">손실 / 손상이 불편한 쿠키가있는 경우 저장하기 전에 쿠키를 백업하십시오 (로드 / 저장 왕복으로 파일이 약간 변경 될 수있는 미묘한 부분이 있습니다).</target>
        </trans-unit>
        <trans-unit id="f7cabb8d741c7dccd3373c3e1b45a4517c4bc9a5" translate="yes" xml:space="preserve">
          <source>Backend function used by &lt;a href=&quot;#curses.resizeterm&quot;&gt;&lt;code&gt;resizeterm()&lt;/code&gt;&lt;/a&gt;, performing most of the work; when resizing the windows, &lt;a href=&quot;#curses.resize_term&quot;&gt;&lt;code&gt;resize_term()&lt;/code&gt;&lt;/a&gt; blank-fills the areas that are extended. The calling application should fill in these areas with appropriate data. The &lt;code&gt;resize_term()&lt;/code&gt; function attempts to resize all windows. However, due to the calling convention of pads, it is not possible to resize these without additional interaction with the application.</source>
          <target state="translated">대부분의 작업을 수행하는 &lt;a href=&quot;#curses.resizeterm&quot;&gt; &lt;code&gt;resizeterm()&lt;/code&gt; &lt;/a&gt; 에서 사용하는 백엔드 함수 . 창 크기를 조정할 때 &lt;a href=&quot;#curses.resize_term&quot;&gt; &lt;code&gt;resize_term()&lt;/code&gt; &lt;/a&gt; 은 확장 된 영역을 공백으로 채 웁니다. 발신 애플리케이션은 이러한 영역을 적절한 데이터로 채워야합니다. &lt;code&gt;resize_term()&lt;/code&gt; 함수를 시도 모든 창 크기를 조정합니다. 그러나 패드의 호출 규칙으로 인해 응용 프로그램과의 추가 상호 작용없이 크기를 조정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ad8d0fed9a547cc64ffb221201642666f0011ab4" translate="yes" xml:space="preserve">
          <source>Background, details, hints, tips and caveats</source>
          <target state="translated">배경, 세부 사항, 힌트, 팁 및 경고</target>
        </trans-unit>
        <trans-unit id="d761e5a62561f09ed0d44ad1cb46328e1f217a6f" translate="yes" xml:space="preserve">
          <source>Backslashes are interpreted literally, unless they immediately precede a double quotation mark.</source>
          <target state="translated">백 슬래시는 큰 따옴표가 바로 앞에 오지 않는 한 문자 그대로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="a3b4e1ecc274bf718cbbd8a1a3fe637f6e1d74f9" translate="yes" xml:space="preserve">
          <source>Backspace (unreliable)</source>
          <target state="translated">백 스페이스 (신뢰할 수 없음)</target>
        </trans-unit>
        <trans-unit id="e55f2cbe5dc4e91bd91593c8be3a8399315bbfdf" translate="yes" xml:space="preserve">
          <source>Backward-compatible usage:</source>
          <target state="translated">이전 버전과 호환되는 사용법 :</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">잘못된 주소</target>
        </trans-unit>
        <trans-unit id="becfc2da6183284441f36b6385c24b70a600038b" translate="yes" xml:space="preserve">
          <source>Bad file descriptor error example</source>
          <target state="translated">잘못된 파일 설명자 오류 예</target>
        </trans-unit>
        <trans-unit id="a9ac5297b2f804cdafa5d88f5e271e340ba5cf37" translate="yes" xml:space="preserve">
          <source>Bad file number</source>
          <target state="translated">잘못된 파일 번호</target>
        </trans-unit>
        <trans-unit id="d42cb962824573639b58c8ac6238174cbbe0902e" translate="yes" xml:space="preserve">
          <source>Bad font file format</source>
          <target state="translated">잘못된 글꼴 파일 형식</target>
        </trans-unit>
        <trans-unit id="09b7225a7007de0840d3002393babbaf7c304ea8" translate="yes" xml:space="preserve">
          <source>Baltic languages</source>
          <target state="translated">발트 어</target>
        </trans-unit>
        <trans-unit id="5e5a05a8b84deb1f27d7d9a68b519e2daa6a3749" translate="yes" xml:space="preserve">
          <source>Barrier Objects</source>
          <target state="translated">배리어 객체</target>
        </trans-unit>
        <trans-unit id="c5376071164581eb584cba9b3620cf0285ee49f3" translate="yes" xml:space="preserve">
          <source>Barry Warsaw</source>
          <target state="translated">배리 바르샤바</target>
        </trans-unit>
        <trans-unit id="cbfa89884cf762b2c8452214a9cb7c8b56848102" translate="yes" xml:space="preserve">
          <source>Base Protocol</source>
          <target state="translated">기본 프로토콜</target>
        </trans-unit>
        <trans-unit id="e7847ef64ed125924cd719af4769f2b49be1f954" translate="yes" xml:space="preserve">
          <source>Base Protocols</source>
          <target state="translated">기본 프로토콜</target>
        </trans-unit>
        <trans-unit id="b1fa70ba520aae580db170cd80267cedd66c66af" translate="yes" xml:space="preserve">
          <source>Base Transport</source>
          <target state="translated">기본 운송</target>
        </trans-unit>
        <trans-unit id="0f7c08675f792982cba4bf468bb32f3974d128d6" translate="yes" xml:space="preserve">
          <source>Base category for warnings about deprecated features when those warnings are intended for end users of applications that are written in Python.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 범주는 해당 경고가 Python으로 작성된 응용 프로그램의 최종 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ded4acb00e3e9a0e2c6d819d2be38745cb197828" translate="yes" xml:space="preserve">
          <source>Base category for warnings about deprecated features when those warnings are intended for other Python developers (ignored by default, unless triggered by code in &lt;code&gt;__main__&lt;/code&gt;).</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 범주는 다른 Python 개발자를위한 경고입니다 ( &lt;code&gt;__main__&lt;/code&gt; 의 코드로 트리거되지 않는 한 기본적으로 무시 됨 ).</target>
        </trans-unit>
        <trans-unit id="aecd2a13287ac24c073616d7be9ca1bac4b820e3" translate="yes" xml:space="preserve">
          <source>Base category for warnings about dubious runtime features.</source>
          <target state="translated">모호한 런타임 기능에 대한 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="adbf72d780c57a442a1d40e971f0bafb4ba000b7" translate="yes" xml:space="preserve">
          <source>Base category for warnings about dubious syntactic features.</source>
          <target state="translated">모호한 구문 기능에 대한 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="b961e19180b568120a243fe8a965f885400f3963" translate="yes" xml:space="preserve">
          <source>Base category for warnings about features that will be deprecated in the future (ignored by default).</source>
          <target state="translated">향후 더 이상 사용되지 않을 기능에 대한 경고의 기본 범주입니다 (기본적으로 무시 됨).</target>
        </trans-unit>
        <trans-unit id="271b2d511f8d7cb0d37d60a7165a2a6be096fb2d" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 관련 경고의 기본 범주입니다 .</target>
        </trans-unit>
        <trans-unit id="e56c87eafe934bdffdcf80bbda3a3f1bafd3951a" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to Unicode.</source>
          <target state="translated">유니 코드와 관련된 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="8aca1ccdde79b14ca072dd8196fe1a8eaa20e816" translate="yes" xml:space="preserve">
          <source>Base category for warnings related to resource usage.</source>
          <target state="translated">자원 사용과 관련된 경고의 기본 범주입니다.</target>
        </trans-unit>
        <trans-unit id="9db12d86e6ccca93eb8b1b63e07ce33c90af51f7" translate="yes" xml:space="preserve">
          <source>Base category for warnings triggered during the process of importing a module (ignored by default).</source>
          <target state="translated">모듈을 가져 오는 과정에서 트리거되는 경고의 기본 범주 (기본적으로 무시 됨).</target>
        </trans-unit>
        <trans-unit id="62c7f7b7e6449dee51da32f88ce059c9f0a6e133" translate="yes" xml:space="preserve">
          <source>Base class for C callable foreign functions.</source>
          <target state="translated">C 호출 가능 외부 함수의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="93b278fdd49d1caec7588ea1619ab8693a3d6aea" translate="yes" xml:space="preserve">
          <source>Base class for all &lt;a href=&quot;#module-tarfile&quot;&gt;&lt;code&gt;tarfile&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">모든 &lt;a href=&quot;#module-tarfile&quot;&gt; &lt;code&gt;tarfile&lt;/code&gt; &lt;/a&gt; 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="83a2ff960e585bade07c251fc6907e1766bfdcea" translate="yes" xml:space="preserve">
          <source>Base class for all exceptions that include an SMTP error code. These exceptions are generated in some instances when the SMTP server returns an error code. The error code is stored in the &lt;code&gt;smtp_code&lt;/code&gt; attribute of the error, and the &lt;code&gt;smtp_error&lt;/code&gt; attribute is set to the error message.</source>
          <target state="translated">SMTP 오류 코드가 포함 된 모든 예외의 기본 클래스입니다. 이러한 예외는 SMTP 서버가 오류 코드를 반환 할 때 일부 경우에 생성됩니다. 오류 코드는 오류의 &lt;code&gt;smtp_code&lt;/code&gt; 속성에 저장되며 &lt;code&gt;smtp_error&lt;/code&gt; 속성은 오류 메시지로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bc4d1cfe65641ccd75006d6cb0c5273ca53b06fc" translate="yes" xml:space="preserve">
          <source>Base class for all other &lt;a href=&quot;#module-configparser&quot;&gt;&lt;code&gt;configparser&lt;/code&gt;&lt;/a&gt; exceptions.</source>
          <target state="translated">다른 모든 &lt;a href=&quot;#module-configparser&quot;&gt; &lt;code&gt;configparser&lt;/code&gt; &lt;/a&gt; 예외의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2e79acf9343097cfca004b026b1e289b6e81d9e7" translate="yes" xml:space="preserve">
          <source>Base class for all other exceptions from this module.</source>
          <target state="translated">이 모듈의 다른 모든 예외에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="0094874eb16d8f35c44e0f11faca44e7bc129804" translate="yes" xml:space="preserve">
          <source>Base class for all transports. Contains methods that all asyncio transports share.</source>
          <target state="translated">모든 운송의 기본 클래스. 모든 비동기 전송이 공유하는 메소드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bc8dc0e5d7f463652bc46330f069074014733a53" translate="yes" xml:space="preserve">
          <source>Base class for binary streams that support some kind of buffering. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">어떤 종류의 버퍼링을 지원하는 이진 스트림의 기본 클래스입니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="111505a2e2f1c5d720f4dbb20b18464824cc26d2" translate="yes" xml:space="preserve">
          <source>Base class for content managers. Provides the standard registry mechanisms to register converters between MIME content and other representations, as well as the &lt;code&gt;get_content&lt;/code&gt; and &lt;code&gt;set_content&lt;/code&gt; dispatch methods.</source>
          <target state="translated">컨텐츠 관리자를위한 기본 클래스. &lt;code&gt;get_content&lt;/code&gt; 및 &lt;code&gt;set_content&lt;/code&gt; 디스패치 메소드 뿐만 아니라 MIME 컨텐츠와 다른 표시간에 변환기를 등록하기위한 표준 레지스트리 메커니즘을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="77e0fa5fb9d9cb92c49e07f64d986e277b736562" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스이기도 한 열거 상수를 작성하기위한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="bc4710022b4a59f7309e498f9784b89980698d53" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that can be combined using the bitwise operations without losing their &lt;a href=&quot;#enum.Flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt; membership.</source>
          <target state="translated">&lt;a href=&quot;#enum.Flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt; 멤버십 을 잃지 않고 비트 단위 연산을 사용하여 결합 할 수있는 열거 상수를 작성하기위한 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="8067a9d2bd64f504a0ed0bf642eba1d2667cdb0d" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants that can be combined using the bitwise operators without losing their &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; membership. &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버십 을 잃지 않고 비트 연산자를 사용하여 결합 할 수있는 열거 상수를 작성하기위한 기본 클래스입니다 . &lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버도 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="49651f12dd69e9fc5b9eb9a491dae1396c8f4820" translate="yes" xml:space="preserve">
          <source>Base class for creating enumerated constants. See section &lt;a href=&quot;#functional-api&quot;&gt;Functional API&lt;/a&gt; for an alternate construction syntax.</source>
          <target state="translated">열거 된 상수를 만들기위한 기본 클래스입니다. 대체 구문에 대해서는 &lt;a href=&quot;#functional-api&quot;&gt;기능적 API&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8496250f8d316f4c2fb71bb6afeaf2db8d55ba5" translate="yes" xml:space="preserve">
          <source>Base class for exceptions raised when problems occur performing string interpolation.</source>
          <target state="translated">문자열 보간 수행시 문제가 발생할 때 발생하는 예외의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7a8cc99e6dd0fa75e5d9d18d1e2f0b6d159ef64b" translate="yes" xml:space="preserve">
          <source>Base class for opening and reading URLs. Unless you need to support opening objects using schemes other than &lt;code&gt;http:&lt;/code&gt;, &lt;code&gt;ftp:&lt;/code&gt;, or &lt;code&gt;file:&lt;/code&gt;, you probably want to use &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">URL을 열고 읽는 기본 클래스입니다. &lt;code&gt;http:&lt;/code&gt; , &lt;code&gt;ftp:&lt;/code&gt; 또는 &lt;code&gt;file:&lt;/code&gt; 이외의 스키마를 사용하여 객체 열기를 지원하지 않는 한 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 를 사용하고 싶을 것입니다 .</target>
        </trans-unit>
        <trans-unit id="aa942d873b8cc2045025e1cba883f43a926d1060" translate="yes" xml:space="preserve">
          <source>Base class for other signals and a subclass of &lt;a href=&quot;exceptions#ArithmeticError&quot;&gt;&lt;code&gt;ArithmeticError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자료의 다른 신호 클래스의 서브 클래스 &lt;a href=&quot;exceptions#ArithmeticError&quot;&gt; &lt;code&gt;ArithmeticError&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d78011d81daf58732134a6e10362b07bb6ae789f" translate="yes" xml:space="preserve">
          <source>Base class for policy objects.</source>
          <target state="translated">정책 개체의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="37baa2206d896a594f1f8aa5a3db8477752589d1" translate="yes" xml:space="preserve">
          <source>Base class for protocol classes. Protocol classes are defined like this:</source>
          <target state="translated">프로토콜 클래스의 기본 클래스 프로토콜 클래스는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6a52a47b306d18d17af6700a5e02d334eea68489" translate="yes" xml:space="preserve">
          <source>Base class for raw binary I/O. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">원시 이진 I / O의 기본 클래스입니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c30962a539a3522164dd18b568addcfb57b7dc0a" translate="yes" xml:space="preserve">
          <source>Base class for raw binary streams. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">원시 바이너리 스트림의 기본 클래스입니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공용 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec5274c46b7e76247d7c11c675e64556818455ea" translate="yes" xml:space="preserve">
          <source>Base class for syntax errors related to incorrect indentation. This is a subclass of &lt;a href=&quot;#SyntaxError&quot;&gt;&lt;code&gt;SyntaxError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잘못된 들여 쓰기와 관련된 구문 오류의 기본 클래스입니다. &lt;a href=&quot;#SyntaxError&quot;&gt; &lt;code&gt;SyntaxError&lt;/code&gt; &lt;/a&gt; 의 서브 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="f8034f1f619a25403ea22ca32afe23c323c69db0" translate="yes" xml:space="preserve">
          <source>Base class for text streams. This class provides a character and line based interface to stream I/O. It inherits &lt;a href=&quot;#io.IOBase&quot;&gt;&lt;code&gt;IOBase&lt;/code&gt;&lt;/a&gt;. There is no public constructor.</source>
          <target state="translated">텍스트 스트림의 기본 클래스입니다. 이 클래스는 스트림 I / O를위한 문자 및 라인 기반 인터페이스를 제공합니다. &lt;a href=&quot;#io.IOBase&quot;&gt; &lt;code&gt;IOBase&lt;/code&gt; 를&lt;/a&gt; 상속 합니다 . 공개 생성자가 없습니다.</target>
        </trans-unit>
        <trans-unit id="115592b440ded17229a2be8652ec1583576bd6be" translate="yes" xml:space="preserve">
          <source>Base class for the dialogs defined in the other modules listed here.</source>
          <target state="translated">여기에 나열된 다른 모듈에 정의 된 대화 상자의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1a767590a449f53c349f02ce7bd8efd407590883" translate="yes" xml:space="preserve">
          <source>Base class for warning categories.</source>
          <target state="translated">경고 범주의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="30e62bee9558e07fac538cacc23a8c4434dcd550" translate="yes" xml:space="preserve">
          <source>Base class for warnings about deprecated features when those warnings are intended for end users of applications that are written in Python.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 클래스는 해당 경고가 Python으로 작성된 응용 프로그램의 최종 사용자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="bef4dbd3cc05db0caaef10bd33d535aef6000686" translate="yes" xml:space="preserve">
          <source>Base class for warnings about deprecated features when those warnings are intended for other Python developers.</source>
          <target state="translated">더 이상 사용되지 않는 기능에 대한 경고의 기본 클래스는 해당 경고가 다른 Python 개발자를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1d911ad966f332393c3708556614e73ed1cbd284" translate="yes" xml:space="preserve">
          <source>Base class for warnings about dubious runtime behavior.</source>
          <target state="translated">모호한 런타임 동작에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ed11da738626db6bc66dc76605890a35049a6b1f" translate="yes" xml:space="preserve">
          <source>Base class for warnings about dubious syntax.</source>
          <target state="translated">모호한 구문에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1e39f8ab9b8f97932eee2df10cc6b10cd8aec138" translate="yes" xml:space="preserve">
          <source>Base class for warnings about features which are obsolete and expected to be deprecated in the future, but are not deprecated at the moment.</source>
          <target state="translated">더 이상 사용되지 않으며 향후 폐기 될 예정이지만 현재 폐기되지는 않을 기능에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="9dda81dec15bfcd224d1e4d932c986e759a07e6a" translate="yes" xml:space="preserve">
          <source>Base class for warnings about probable mistakes in module imports.</source>
          <target state="translated">모듈 가져 오기에서 발생할 수있는 실수에 대한 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a020b0a894b4052b6ee113d3143b9d2aef84bb79" translate="yes" xml:space="preserve">
          <source>Base class for warnings generated by user code.</source>
          <target state="translated">사용자 코드로 생성 된 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b307ddcc59f65f2e18cfc4a546c8cbf5e9483f01" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;stdtypes#bytearray&quot;&gt;&lt;code&gt;bytearray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;stdtypes#bytearray&quot;&gt; &lt;code&gt;bytearray&lt;/code&gt; &lt;/a&gt; 관련 경고의 기본 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="14f1306f10d78b1a318d2d99f7741e21a1990aab" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to Unicode.</source>
          <target state="translated">유니 코드와 관련된 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="63ad316f901fe1156baedc6cf362aaa798a4fe84" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to resource usage.</source>
          <target state="translated">리소스 사용과 관련된 경고의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="d1c1a39f6eb8799e6d29048479dd3cf5cc598666" translate="yes" xml:space="preserve">
          <source>Base class for warnings related to resource usage. Ignored by the default warning filters.</source>
          <target state="translated">자원 사용과 관련된 경고의 기본 클래스입니다. 기본 경고 필터에 의해 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="b1dd274748a920e7e6b6531ecc973725498ebb54" translate="yes" xml:space="preserve">
          <source>Base class of the dialog controls. &lt;em&gt;dlg&lt;/em&gt; is the dialog object the control belongs to, and &lt;em&gt;name&lt;/em&gt; is the control&amp;rsquo;s name.</source>
          <target state="translated">대화 상자 컨트롤의 기본 클래스. &lt;em&gt;dlg&lt;/em&gt; 는 컨트롤이 속한 대화 상자 개체이고 &lt;em&gt;name&lt;/em&gt; 은 컨트롤의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8f20f1270a9dcc163b4e1c85af830ebcf1500698" translate="yes" xml:space="preserve">
          <source>Base class which can be inherited by SAX parsers.</source>
          <target state="translated">SAX 파서에 의해 상속 될 수있는 기본 클래스.</target>
        </trans-unit>
        <trans-unit id="597d1d5f179914ea7470a3760bd8ee3a2400c1bc" translate="yes" xml:space="preserve">
          <source>Base classes</source>
          <target state="translated">기본 수업</target>
        </trans-unit>
        <trans-unit id="f532cd83f6f9947116baa3849ec23355cdfb324d" translate="yes" xml:space="preserve">
          <source>Base exception class used for all specific DOM exceptions. This exception class cannot be directly instantiated.</source>
          <target state="translated">모든 특정 DOM 예외에 사용되는 기본 예외 클래스. 이 예외 클래스는 직접 인스턴스화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f00864be99f44fa68097e7a11c50dc2553483317" translate="yes" xml:space="preserve">
          <source>Base interface for most objects in a document.</source>
          <target state="translated">문서에서 대부분의 객체에 대한 기본 인터페이스.</target>
        </trans-unit>
        <trans-unit id="0691eb22ac03b573f0c69a50a9e4abca05842012" translate="yes" xml:space="preserve">
          <source>Base protocol with methods that all protocols share.</source>
          <target state="translated">모든 프로토콜이 공유하는 방법이있는 기본 프로토콜.</target>
        </trans-unit>
        <trans-unit id="0433583846f35c2ba0aec03a821f97c49d6fc91d" translate="yes" xml:space="preserve">
          <source>BaseException</source>
          <target state="translated">BaseException</target>
        </trans-unit>
        <trans-unit id="2139b25cc7ba47829b2613ecd5640b728063f573" translate="yes" xml:space="preserve">
          <source>BaseException.args</source>
          <target state="translated">BaseException.args</target>
        </trans-unit>
        <trans-unit id="f8a3365a764654373607fbb6ccc5794d20c265b0" translate="yes" xml:space="preserve">
          <source>BaseException.with_traceback()</source>
          <target state="translated">BaseException.with_traceback()</target>
        </trans-unit>
        <trans-unit id="74d736dbe7da7ac2d79279fada28cb6cbb8192ea" translate="yes" xml:space="preserve">
          <source>BaseHandler Objects</source>
          <target state="translated">BaseHandler 객체</target>
        </trans-unit>
        <trans-unit id="34ce97d8702b53323f2a4a2c72c66dc5a0eb4e72" translate="yes" xml:space="preserve">
          <source>BaseRotatingHandler</source>
          <target state="translated">BaseRotatingHandler</target>
        </trans-unit>
        <trans-unit id="7348670742e76aaa11d877df8fca9b83a11d1757" translate="yes" xml:space="preserve">
          <source>Basic API</source>
          <target state="translated">기본 API</target>
        </trans-unit>
        <trans-unit id="dac6b24f78471a132bc9a7ec7774530351b54fb0" translate="yes" xml:space="preserve">
          <source>Basic Example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="9a289e7dff9101f26b8dc18725557c4f9fdf82bd" translate="yes" xml:space="preserve">
          <source>Basic Examples</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="0d3f6e8e2e15cd0179d1216f1c988e44f90d868e" translate="yes" xml:space="preserve">
          <source>Basic Tutorial</source>
          <target state="translated">기본 튜토리얼</target>
        </trans-unit>
        <trans-unit id="b20cbc384159fd820ed034fd3615298ec09f5902" translate="yes" xml:space="preserve">
          <source>Basic Usage</source>
          <target state="translated">기본 사용법</target>
        </trans-unit>
        <trans-unit id="03cdc9f64fd1c085bb10854b62f123e70ce40ba7" translate="yes" xml:space="preserve">
          <source>Basic Widgets</source>
          <target state="translated">기본 위젯</target>
        </trans-unit>
        <trans-unit id="af90dc70fae02c63e1b5bfb27dfff83393f621b5" translate="yes" xml:space="preserve">
          <source>Basic dialogs and convenience functions.</source>
          <target state="translated">기본 대화 상자 및 편의 기능.</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="cfd84c756956f6869f891f756d2ed679a18b4696" translate="yes" xml:space="preserve">
          <source>Basic examples:</source>
          <target state="translated">기본 예 :</target>
        </trans-unit>
        <trans-unit id="c58a44745c80d118117b0a04466e564264a9e678" translate="yes" xml:space="preserve">
          <source>Basic interface for resolving entities. If you create an object implementing this interface, then register the object with your Parser, the parser will call the method in your object to resolve all external entities.</source>
          <target state="translated">엔티티 해결을위한 기본 인터페이스. 이 인터페이스를 구현하는 객체를 만든 다음 파서에 객체를 등록하면 파서는 객체의 메소드를 호출하여 모든 외부 엔티티를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="dc42d64e6761d3023d0a23567aa37e8faeed769a" translate="yes" xml:space="preserve">
          <source>Basic skipping looks like this:</source>
          <target state="translated">기본 건너 뛰기는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="955f12253b570691dddd89d6664ff86c6ffea525" translate="yes" xml:space="preserve">
          <source>Basic turtle commands such as &lt;a href=&quot;turtle#turtle.forward&quot;&gt;&lt;code&gt;forward()&lt;/code&gt;&lt;/a&gt; are added to a &lt;a href=&quot;#cmd.Cmd&quot;&gt;&lt;code&gt;Cmd&lt;/code&gt;&lt;/a&gt; subclass with method named &lt;code&gt;do_forward()&lt;/code&gt;. The argument is converted to a number and dispatched to the turtle module. The docstring is used in the help utility provided by the shell.</source>
          <target state="translated">&lt;a href=&quot;turtle#turtle.forward&quot;&gt; &lt;code&gt;forward()&lt;/code&gt; &lt;/a&gt; 와 같은 기본 터틀 명령 은 &lt;code&gt;do_forward()&lt;/code&gt; 라는 메소드 를 사용하여 &lt;a href=&quot;#cmd.Cmd&quot;&gt; &lt;code&gt;Cmd&lt;/code&gt; &lt;/a&gt; 서브 클래스에 추가됩니다 . 인수는 숫자로 변환되어 turtle 모듈로 전달됩니다. docstring은 쉘에서 제공하는 도움말 유틸리티에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="168929183d2470cb5fd9c8ab272eed288ccb698d" translate="yes" xml:space="preserve">
          <source>Basic use</source>
          <target state="translated">기본 사용</target>
        </trans-unit>
        <trans-unit id="de3816b07b2c1c67b6c5d0b0c0ef9af019f07757" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;em&gt;followlinks&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; can lead to infinite recursion if a link points to a parent directory of itself. &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; does not keep track of the directories it visited already.</source>
          <target state="translated">링크가 자체의 상위 디렉토리를 가리키는 경우 &lt;em&gt;후속 링크&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정 하면 무한 재귀로 이어질 수 있습니다. &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 는 이미 방문한 디렉토리를 추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c4d410bcf0f1e8b0447d1481b24eeff8e98f8899" translate="yes" xml:space="preserve">
          <source>Be careful to not use this module where deadlock might occur from a thread being created that blocks waiting for another thread to be created. This often occurs with blocking I/O.</source>
          <target state="translated">다른 스레드가 작성 될 때까지 대기하는 것을 막는 스레드 작성시 교착 상태가 발생할 수있는 경우이 모듈을 사용하지 마십시오. 이것은 종종 I / O 차단과 함께 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d1cc029ce668972e8e992f6e3aa06dc274e72815" translate="yes" xml:space="preserve">
          <source>Be forewarned about how &lt;code&gt;init=False&lt;/code&gt; fields work during a call to &lt;a href=&quot;#dataclasses.replace&quot;&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/a&gt;. They are not copied from the source object, but rather are initialized in &lt;code&gt;__post_init__()&lt;/code&gt;, if they&amp;rsquo;re initialized at all. It is expected that &lt;code&gt;init=False&lt;/code&gt; fields will be rarely and judiciously used. If they are used, it might be wise to have alternate class constructors, or perhaps a custom &lt;code&gt;replace()&lt;/code&gt; (or similarly named) method which handles instance copying.</source>
          <target state="translated">&lt;a href=&quot;#dataclasses.replace&quot;&gt; &lt;code&gt;replace()&lt;/code&gt; &lt;/a&gt; 호출 중에 &lt;code&gt;init=False&lt;/code&gt; 필드가 작동 하는 방식에 대해 미리 알고 있어야 합니다. 그것들은 소스 객체에서 복사되는 것이 아니라, 초기화 된 경우 &lt;code&gt;__post_init__()&lt;/code&gt; 에서 초기화됩니다. &lt;code&gt;init=False&lt;/code&gt; 필드는 드물고 신중하게 사용될 것으로 예상 됩니다. 그것들이 사용된다면, 대체 클래스 생성자, 또는 인스턴스 복사를 처리 하는 커스텀 &lt;code&gt;replace()&lt;/code&gt; (또는 비슷한 이름의) 메소드 를 갖는 것이 현명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abae3c10b04d3f45674d8d84138847d156e5d77c" translate="yes" xml:space="preserve">
          <source>Be very cautious when modifying mailboxes that might be simultaneously changed by some other process. The safest mailbox format to use for such tasks is Maildir; try to avoid using single-file formats such as mbox for concurrent writing. If you&amp;rsquo;re modifying a mailbox, you &lt;em&gt;must&lt;/em&gt; lock it by calling the &lt;a href=&quot;#mailbox.Mailbox.lock&quot;&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#mailbox.Mailbox.unlock&quot;&gt;&lt;code&gt;unlock()&lt;/code&gt;&lt;/a&gt; methods &lt;em&gt;before&lt;/em&gt; reading any messages in the file or making any changes by adding or deleting a message. Failing to lock the mailbox runs the risk of losing messages or corrupting the entire mailbox.</source>
          <target state="translated">다른 프로세스에 의해 동시에 변경 될 수있는 사서함을 수정할 때는 매우주의해야합니다. 이러한 작업에 가장 안전한 사서함 형식은 Maildir입니다. 동시 쓰기에 mbox와 같은 단일 파일 형식을 사용하지 마십시오. 사서함을 수정하는 경우 파일의 메시지를 읽거나 메시지를 추가하거나 삭제하여 변경 &lt;em&gt;하기 전에 &lt;/em&gt;&lt;a href=&quot;#mailbox.Mailbox.lock&quot;&gt; &lt;code&gt;lock()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#mailbox.Mailbox.unlock&quot;&gt; &lt;code&gt;unlock()&lt;/code&gt; &lt;/a&gt; 메서드 를 호출하여 사서함을 잠 &lt;em&gt;가야합니다&lt;/em&gt; . 사서함을 잠그지 않으면 메시지가 손실되거나 전체 사서함이 손상 될 위험이 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c0c1fe83f49ee94713ba4bebb01d2337218d28eb" translate="yes" xml:space="preserve">
          <source>Be warned that you should calibrate the profiler class for the timer function that you choose (see &lt;a href=&quot;#profile-calibration&quot;&gt;Calibration&lt;/a&gt;). For most machines, a timer that returns a lone integer value will provide the best results in terms of low overhead during profiling. (&lt;a href=&quot;os#os.times&quot;&gt;&lt;code&gt;os.times()&lt;/code&gt;&lt;/a&gt; is &lt;em&gt;pretty&lt;/em&gt; bad, as it returns a tuple of floating point values). If you want to substitute a better timer in the cleanest fashion, derive a class and hardwire a replacement dispatch method that best handles your timer call, along with the appropriate calibration constant.</source>
          <target state="translated">선택한 타이머 기능에 대한 프로파일 러 클래스를 교정해야합니다 ( &lt;a href=&quot;#profile-calibration&quot;&gt;교정&lt;/a&gt; 참조 ). 대부분의 컴퓨터에서 고독 정수 값을 반환하는 타이머는 프로파일 링 중 오버 헤드가 적다는 점에서 최상의 결과를 제공합니다. ( &lt;a href=&quot;os#os.times&quot;&gt; &lt;code&gt;os.times()&lt;/code&gt; &lt;/a&gt; 는 부동 소수점 값의 튜플을 반환하기 때문에 &lt;em&gt;꽤&lt;/em&gt; 나쁩니다). 더 깨끗한 타이머를 가장 깨끗한 방식으로 대체하려면 클래스를 도출하고 적절한 교정 상수와 함께 타이머 호출을 가장 잘 처리하는 대체 디스패치 메소드를 배선하십시오.</target>
        </trans-unit>
        <trans-unit id="fb941ef4dc684b044e6e45b9283386b1eb3e83df" translate="yes" xml:space="preserve">
          <source>Bear in mind that a process that has put items in a queue will wait before terminating until all the buffered items are fed by the &amp;ldquo;feeder&amp;rdquo; thread to the underlying pipe. (The child process can call the &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt;&lt;code&gt;Queue.cancel_join_thread&lt;/code&gt;&lt;/a&gt; method of the queue to avoid this behaviour.)</source>
          <target state="translated">큐에 항목을 넣은 프로세스는 버퍼링 된 모든 항목이 &quot;피더&quot;스레드에 의해 기본 파이프로 공급 될 때까지 종료되기 전에 대기합니다. 하위 프로세스는 이 동작을 피하기 위해 큐 의 &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt; &lt;code&gt;Queue.cancel_join_thread&lt;/code&gt; &lt;/a&gt; 메소드를 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a4332bde329f74d1a7a1aff8d1cef2c7d17c810" translate="yes" xml:space="preserve">
          <source>Bear in mind that if code run in a child process tries to access a global variable, then the value it sees (if any) may not be the same as the value in the parent process at the time that &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt;&lt;code&gt;Process.start&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="translated">자식 프로세스에서 실행되는 코드가 전역 변수에 액세스하려고하면 보이는 값 (있는 경우)이 &lt;a href=&quot;#multiprocessing.Process.start&quot;&gt; &lt;code&gt;Process.start&lt;/code&gt; &lt;/a&gt; 가 호출 될 때 부모 프로세스의 값과 같지 않을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10e62a51dfa0dc36185ec273da331d0a6fb29a35" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#dir&quot;&gt;&lt;code&gt;dir()&lt;/code&gt;&lt;/a&gt; is supplied primarily as a convenience for use at an interactive prompt, it tries to supply an interesting set of names more than it tries to supply a rigorously or consistently defined set of names, and its detailed behavior may change across releases. For example, metaclass attributes are not in the result list when the argument is a class.</source>
          <target state="translated">때문에 &lt;a href=&quot;#dir&quot;&gt; &lt;code&gt;dir()&lt;/code&gt; &lt;/a&gt; 대화 형 프롬프트에서 사용의 편의를 주로 공급되고, 그것이 이름의 엄격 또는 일관되게 정의 세트를 제공하려고보다 더 많은 이름의 흥미로운 세트를 제공하려고, 그 상세한 동작은 릴리스에 따라 변경 될 수 있습니다. 예를 들어, 인수가 클래스 인 경우 메타 클래스 속성이 결과 목록에 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ed699fc6637c9326d06d5f91cf8cfe03647969a" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#enum.IntFlag&quot;&gt;&lt;code&gt;IntFlag&lt;/code&gt;&lt;/a&gt; members are also subclasses of &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; they can be combined with them:</source>
          <target state="translated">&lt;a href=&quot;#enum.IntFlag&quot;&gt; &lt;code&gt;IntFlag&lt;/code&gt; &lt;/a&gt; 멤버도 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; 의&lt;/a&gt; 서브 클래스 이므로 다음과 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4876b04dc65b9b21062f7a28c0edf2c6a14336" translate="yes" xml:space="preserve">
          <source>Because Enums are used to represent constants we recommend using UPPER_CASE names for enum members, and will be using that style in our examples.</source>
          <target state="translated">열거 형은 상수를 나타내는 데 사용되기 때문에 열거 형 멤버에 UPPER_CASE 이름을 사용하는 것이 좋으며 예제에서는 해당 스타일을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5676d312428ed566fc5e55055b04a8a487aa66cb" translate="yes" xml:space="preserve">
          <source>Because NIS exists only on Unix systems, this module is only available for Unix.</source>
          <target state="translated">NIS는 Unix 시스템에만 존재하므로이 모듈은 Unix에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="449b33e822195d1cb40d26026e8bbadbe72c580f" translate="yes" xml:space="preserve">
          <source>Because all asyncio subprocess functions are asynchronous and asyncio provides many tools to work with such functions, it is easy to execute and monitor multiple subprocesses in parallel. It is indeed trivial to modify the above example to run several commands simultaneously:</source>
          <target state="translated">모든 asyncio 하위 프로세스 기능은 비동기식이며 asyncio는 이러한 기능으로 작업 할 수있는 많은 도구를 제공하므로 여러 하위 프로세스를 병렬로 쉽게 실행하고 모니터링 할 수 있습니다. 위의 예제를 수정하여 여러 명령을 동시에 실행하는 것은 사소한 일입니다.</target>
        </trans-unit>
        <trans-unit id="cd024808dd20391db9a5d87efaaa473460d75e55" translate="yes" xml:space="preserve">
          <source>Because deep copy copies everything it may copy too much, such as data which is intended to be shared between copies.</source>
          <target state="translated">딥 카피는 카피간에 공유 할 데이터와 같이 모든 것을 카피하기 때문에 너무 많이 카피 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fe4a8056160b609c3f4db4e7d117d78cac2ac63" translate="yes" xml:space="preserve">
          <source>Because it requires the &lt;a href=&quot;termios#module-termios&quot;&gt;&lt;code&gt;termios&lt;/code&gt;&lt;/a&gt; module, it will work only on Unix.</source>
          <target state="translated">&lt;a href=&quot;termios#module-termios&quot;&gt; &lt;code&gt;termios&lt;/code&gt; &lt;/a&gt; 모듈 이 필요하기 때문에 Unix에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="512d82a1a965117bb846701b126fb31120198553" translate="yes" xml:space="preserve">
          <source>Because it&amp;rsquo;s so flexible, &lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt;&lt;code&gt;XMLPullParser&lt;/code&gt;&lt;/a&gt; can be inconvenient to use for simpler use-cases. If you don&amp;rsquo;t mind your application blocking on reading XML data but would still like to have incremental parsing capabilities, take a look at &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt;&lt;code&gt;iterparse()&lt;/code&gt;&lt;/a&gt;. It can be useful when you&amp;rsquo;re reading a large XML document and don&amp;rsquo;t want to hold it wholly in memory.</source>
          <target state="translated">&lt;a href=&quot;#xml.etree.ElementTree.XMLPullParser&quot;&gt; &lt;code&gt;XMLPullParser&lt;/code&gt; &lt;/a&gt; 는 매우 유연하기 때문에 더 단순한 사용 사례에 사용하기 불편할 수 있습니다. 응용 프로그램에서 XML 데이터 읽기를 차단하지 않아도 증분 구문 분석 기능을 사용하려면 &lt;a href=&quot;#xml.etree.ElementTree.iterparse&quot;&gt; &lt;code&gt;iterparse()&lt;/code&gt; &lt;/a&gt; 살펴보십시오 . 큰 XML 문서를 읽을 때 메모리에 완전히 저장하지 않으려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97e478af3d6ae73e7bc440c377cd0710be8dd209" translate="yes" xml:space="preserve">
          <source>Because magic methods are looked up differently from normal methods &lt;a href=&quot;#id9&quot; id=&quot;id7&quot;&gt;2&lt;/a&gt;, this support has been specially implemented. This means that only specific magic methods are supported. The supported list includes &lt;em&gt;almost&lt;/em&gt; all of them. If there are any missing that you need please let us know.</source>
          <target state="translated">매직 메소드는 일반 메소드 &lt;a href=&quot;#id9&quot; id=&quot;id7&quot;&gt;2&lt;/a&gt; 와 다르게 조회 되므로이 지원은 특별히 구현되었습니다. 즉, 특정 마법 방법 만 지원됩니다. 지원되는 목록에는 &lt;em&gt;거의&lt;/em&gt; 모든 것이 포함 됩니다. 누락 된 부분이 있으면 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="ff5644c87e7d8c8596308ff2c76d404cdc5f9f5e" translate="yes" xml:space="preserve">
          <source>Because many of the traps are enabled, this context is useful for debugging.</source>
          <target state="translated">많은 트랩이 사용 가능하므로이 컨텍스트는 디버깅에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0682abf783b1442ff30ccebb13d38ee0bde7ce7f" translate="yes" xml:space="preserve">
          <source>Because mocks auto-create attributes on demand, and allow you to call them with arbitrary arguments, if you misspell one of these assert methods then your assertion is gone:</source>
          <target state="translated">mock은 필요에 따라 속성을 자동 생성하고 임의의 인수로 속성을 호출 할 수 있으므로 이러한 어설트 메서드 중 하나를 잘못 입력하면 어설 션이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="d2f324a634323f6253d750beb01677494c624217" translate="yes" xml:space="preserve">
          <source>Because most of the operations on any given type will be very similar, it can be useful to define a helper function which generates the forward and reverse instances of any given operator. For example, &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt;&lt;code&gt;fractions.Fraction&lt;/code&gt;&lt;/a&gt; uses:</source>
          <target state="translated">주어진 유형에 대한 대부분의 연산은 매우 유사하므로 주어진 연산자의 정방향 및 역방향 인스턴스를 생성하는 도우미 함수를 정의하는 것이 유용 할 수 있습니다. 예를 들어 &lt;a href=&quot;fractions#fractions.Fraction&quot;&gt; &lt;code&gt;fractions.Fraction&lt;/code&gt; &lt;/a&gt; 은 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f37e0b8c6e2c7fbb2cc8dfb353efdeb9905b90d4" translate="yes" xml:space="preserve">
          <source>Because multiple signatures (ie. overloading) is permitted, this method returns a list of signatures rather than a singleton.</source>
          <target state="translated">여러 서명 (예 : 오버로드)이 허용되므로이 메서드는 싱글 톤이 아닌 서명 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8d328dbf9ad55c5ef4fe48e9b55f65c19053b49" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing a specific timestamp in UTC is by calling &lt;code&gt;datetime.fromtimestamp(timestamp, tz=timezone.utc)&lt;/code&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하여 시간을 나타내는 것이 좋습니다. 따라서 UTC로 특정 타임 스탬프를 나타내는 객체를 만드는 권장 방법은 &lt;code&gt;datetime.fromtimestamp(timestamp, tz=timezone.utc)&lt;/code&gt; 를 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="6c258a614b92ea7ab843f0053cb8a4745997da95" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC. As such, the recommended way to create an object representing the current time in UTC is by calling &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하여 시간을 나타내는 것이 좋습니다. 따라서 UTC로 현재 시간을 나타내는 객체를 만드는 권장 방법은 &lt;code&gt;datetime.now(timezone.utc)&lt;/code&gt; 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f47a5630dcb74119e881ec10d145701d12e134d9" translate="yes" xml:space="preserve">
          <source>Because naive &lt;code&gt;datetime&lt;/code&gt; objects are treated by many &lt;code&gt;datetime&lt;/code&gt; methods as local times, it is preferred to use aware datetimes to represent times in UTC; as a result, using &lt;code&gt;utcfromtimetuple&lt;/code&gt; may give misleading results. If you have a naive &lt;code&gt;datetime&lt;/code&gt; representing UTC, use &lt;code&gt;datetime.replace(tzinfo=timezone.utc)&lt;/code&gt; to make it aware, at which point you can use &lt;a href=&quot;#datetime.datetime.timetuple&quot;&gt;&lt;code&gt;datetime.timetuple()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">순진한 &lt;code&gt;datetime&lt;/code&gt; 객체는 많은 &lt;code&gt;datetime&lt;/code&gt; 메서드에 의해 현지 시간으로 처리 되므로 UTC로 인식 된 날짜 시간을 사용하는 것이 좋습니다. 결과적으로 &lt;code&gt;utcfromtimetuple&lt;/code&gt; 을 사용 하면 잘못된 결과 를 초래할 수 있습니다. UTC를 나타내는 순진한 &lt;code&gt;datetime&lt;/code&gt; 이있는 경우 &lt;code&gt;datetime.replace(tzinfo=timezone.utc)&lt;/code&gt; 를 사용하여 알 수 있도록하십시오 . 그러면 &lt;a href=&quot;#datetime.datetime.timetuple&quot;&gt; &lt;code&gt;datetime.timetuple()&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05c1292e4567d219d1d4e44f189debf054b0b060" translate="yes" xml:space="preserve">
          <source>Because of Python semantics, a shelf cannot know when a mutable persistent-dictionary entry is modified. By default modified objects are written &lt;em&gt;only&lt;/em&gt; when assigned to the shelf (see &lt;a href=&quot;#shelve-example&quot;&gt;Example&lt;/a&gt;). If the optional &lt;em&gt;writeback&lt;/em&gt; parameter is set to &lt;code&gt;True&lt;/code&gt;, all entries accessed are also cached in memory, and written back on &lt;a href=&quot;#shelve.Shelf.sync&quot;&gt;&lt;code&gt;sync()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#shelve.Shelf.close&quot;&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/a&gt;; this can make it handier to mutate mutable entries in the persistent dictionary, but, if many entries are accessed, it can consume vast amounts of memory for the cache, and it can make the close operation very slow since all accessed entries are written back (there is no way to determine which accessed entries are mutable, nor which ones were actually mutated).</source>
          <target state="translated">파이썬 시맨틱으로 인해 선반은 변경 가능한 영구 사전 항목이 수정 된시기를 알 수 없습니다. 기본적으로 수정 된 개체는 선반에 할당 된 경우 &lt;em&gt;에만&lt;/em&gt; 작성 &lt;em&gt;됩니다&lt;/em&gt; ( &lt;a href=&quot;#shelve-example&quot;&gt;예&lt;/a&gt; 참조 ). 선택적 &lt;em&gt;쓰기 저장&lt;/em&gt; 매개 변수가 &lt;code&gt;True&lt;/code&gt; 로 설정되면 액세스 된 모든 항목도 메모리에 캐시되고 &lt;a href=&quot;#shelve.Shelf.sync&quot;&gt; &lt;code&gt;sync()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#shelve.Shelf.close&quot;&gt; &lt;code&gt;close()&lt;/code&gt; &lt;/a&gt; 에 다시 기록됩니다.; 이로 인해 영속 사전에서 변경 가능한 항목을 변경하는 것이 더 쉬워 질 수 있지만, 많은 항목에 액세스하는 경우 캐시를 위해 방대한 양의 메모리를 소비 할 수 있으며 모든 액세스 된 항목이 다시 기록되므로 닫기 조작이 매우 느려질 수 있습니다 ( 어떤 액세스 가능한 항목이 변경 가능한지 또는 실제로 어떤 항목이 변경되었는지 확인할 방법이 없습니다).</target>
        </trans-unit>
        <trans-unit id="8a25338cf8065d3938e8ff0b097c26f981ba9436" translate="yes" xml:space="preserve">
          <source>Because of the way Tk handles the X option database, after Tix has been has imported and inited, it is not possible to reset the color schemes and font sets using the &lt;code&gt;tix_config()&lt;/code&gt; method. Instead, the &lt;a href=&quot;#tkinter.tix.tixCommand.tix_resetoptions&quot;&gt;&lt;code&gt;tix_resetoptions()&lt;/code&gt;&lt;/a&gt; method must be used.</source>
          <target state="translated">Tk가 X 옵션 데이터베이스를 처리하는 방식으로 인해 Tix를 가져 와서 초기화 한 후에 &lt;code&gt;tix_config()&lt;/code&gt; 메소드를 사용하여 색상 구성표 및 글꼴 세트를 재설정 할 수 없습니다 . 대신 &lt;a href=&quot;#tkinter.tix.tixCommand.tix_resetoptions&quot;&gt; &lt;code&gt;tix_resetoptions()&lt;/code&gt; &lt;/a&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="80d71e1d1d10cd40808346877ec280d341096ac6" translate="yes" xml:space="preserve">
          <source>Because of the way mock attributes are stored you can&amp;rsquo;t directly attach a &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt;&lt;code&gt;PropertyMock&lt;/code&gt;&lt;/a&gt; to a mock object. Instead you can attach it to the mock type object:</source>
          <target state="translated">모의 속성이 저장되는 방식으로 인해 &lt;a href=&quot;#unittest.mock.PropertyMock&quot;&gt; &lt;code&gt;PropertyMock&lt;/code&gt; &lt;/a&gt; 을 모의 객체에 직접 연결할 수 없습니다 . 대신 모의 유형 객체에 첨부 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5e20bbafee23cd5f05c72608abea4eaae32bb05" translate="yes" xml:space="preserve">
          <source>Because package metadata is not available through &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt; searches, or package loaders directly, the metadata for a package is found through import system &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#finders-and-loaders&quot;&gt;finders&lt;/a&gt;. To find a distribution package&amp;rsquo;s metadata, &lt;code&gt;importlib.metadata&lt;/code&gt; queries the list of &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-meta-path-finder&quot;&gt;meta path finders&lt;/a&gt; on &lt;a href=&quot;sys#sys.meta_path&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">패키지 메타 데이터는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; &lt;/a&gt; 검색 또는 패키지 로더를 통해 직접 사용할 수 없기 때문에 패키지의 메타 데이터는 가져 오기 시스템 &lt;a href=&quot;https://docs.python.org/3.9/reference/import.html#finders-and-loaders&quot;&gt;파인더를&lt;/a&gt; 통해 찾을 수 있습니다. 배포 패키지의 메타 데이터를 찾기 위해 &lt;code&gt;importlib.metadata&lt;/code&gt; 는 &lt;a href=&quot;sys#sys.meta_path&quot;&gt; &lt;code&gt;sys.meta_path&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-meta-path-finder&quot;&gt;메타 경로 파인더&lt;/a&gt; 목록을 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="400e21a04dc1ea4ab9991dc7b7931687ece1123f" translate="yes" xml:space="preserve">
          <source>Because package metadata is not available through &lt;code&gt;sys.path&lt;/code&gt; searches, or package loaders directly, the metadata for a package is found through import system &lt;a href=&quot;https://docs.python.org/3/reference/import.html#finders-and-loaders&quot;&gt;finders&lt;/a&gt;. To find a distribution package&amp;rsquo;s metadata, &lt;code&gt;importlib.metadata&lt;/code&gt; queries the list of &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-meta-path-finder&quot;&gt;meta path finders&lt;/a&gt; on &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.meta_path&quot;&gt;sys.meta_path&lt;/a&gt;.</source>
          <target state="translated">패키지 메타 데이터는 &lt;code&gt;sys.path&lt;/code&gt; 검색 또는 패키지 로더를 통해 직접 사용할 수 없으므로 패키지의 메타 데이터는 import system &lt;a href=&quot;https://docs.python.org/3/reference/import.html#finders-and-loaders&quot;&gt;finders를&lt;/a&gt; 통해 찾을 수 있습니다. 배포 패키지의 메타 데이터를 찾기 위해 &lt;code&gt;importlib.metadata&lt;/code&gt; 는 &lt;a href=&quot;https://docs.python.org/3/library/sys.html#sys.meta_path&quot;&gt;sys.meta_path&lt;/a&gt; 에서 &lt;a href=&quot;https://docs.python.org/3/glossary.html#term-meta-path-finder&quot;&gt;메타 경로 파인더&lt;/a&gt; 목록을 쿼리합니다 .</target>
        </trans-unit>
        <trans-unit id="d55b59f6bf0508d0270277c6f73d5728e5bbe79f" translate="yes" xml:space="preserve">
          <source>Because portions of the configuration are passed through &lt;a href=&quot;functions#eval&quot;&gt;&lt;code&gt;eval()&lt;/code&gt;&lt;/a&gt;, use of this function may open its users to a security risk. While the function only binds to a socket on &lt;code&gt;localhost&lt;/code&gt;, and so does not accept connections from remote machines, there are scenarios where untrusted code could be run under the account of the process which calls &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;. Specifically, if the process calling &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; runs on a multi-user machine where users cannot trust each other, then a malicious user could arrange to run essentially arbitrary code in a victim user&amp;rsquo;s process, simply by connecting to the victim&amp;rsquo;s &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; socket and sending a configuration which runs whatever code the attacker wants to have executed in the victim&amp;rsquo;s process. This is especially easy to do if the default port is used, but not hard even if a different port is used). To avoid the risk of this happening, use the &lt;code&gt;verify&lt;/code&gt; argument to &lt;a href=&quot;#logging.config.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt; to prevent unrecognised configurations from being applied.</source>
          <target state="translated">구성의 일부가 &lt;a href=&quot;functions#eval&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 통해 전달 되므로이 함수를 사용하면 사용자가 보안 위험에 노출 될 수 있습니다. 이 함수는 &lt;code&gt;localhost&lt;/code&gt; 의 소켓에만 바인딩 되므로 원격 시스템의 연결을 허용하지 않지만, &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 을 호출하는 프로세스의 계정으로 신뢰할 수없는 코드가 실행될 수있는 시나리오가 있습니다 . 특히, &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 호출하는 프로세스 가 사용자가 서로를 신뢰할 수없는 다중 사용자 컴퓨터에서 실행되는 경우 악의적 인 사용자는 피해자의 &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 에 연결하여 피해자의 사용자 프로세스에서 본질적으로 임의의 코드를 실행하도록 조정할 수 있습니다.공격자가 피해자의 프로세스에서 실행하고자하는 모든 코드를 실행하는 구성을 전송합니다. 이것은 기본 포트가 사용되는 경우에 특히 쉽지만 다른 포트를 사용하더라도 어렵지 않습니다). 이러한 상황의 위험을 피하려면 &lt;code&gt;verify&lt;/code&gt; 인수를 사용하여 &lt;a href=&quot;#logging.config.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 으로 인식 할 수없는 구성이 적용되지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="5624fe7445294e1d731602dabe55a2ad5baa3be9" translate="yes" xml:space="preserve">
          <source>Because pseudo-terminal handling is highly platform dependent, there is code to do it only for Linux. (The Linux code is supposed to work on other platforms, but hasn&amp;rsquo;t been tested yet.)</source>
          <target state="translated">의사 터미널 처리는 플랫폼에 따라 크게 달라 지므로 Linux에서만 처리하는 코드가 있습니다. (Linux 코드는 다른 플랫폼에서 작동하지만 아직 테스트되지는 않았습니다.)</target>
        </trans-unit>
        <trans-unit id="d26513ebec365d3c671c97db0de645fa9c2e3b1f" translate="yes" xml:space="preserve">
          <source>Because strings cannot represent binary data, the &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; class must convert any binary data in any message it flattens to an ASCII compatible format, by converting them to an ASCII compatible &lt;em&gt;Content-Transfer_Encoding&lt;/em&gt;. Using the terminology of the email RFCs, you can think of this as &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; serializing to an I/O stream that is not &amp;ldquo;8 bit clean&amp;rdquo;. In other words, most applications will want to be using &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt;&lt;code&gt;BytesGenerator&lt;/code&gt;&lt;/a&gt;, and not &lt;a href=&quot;#email.generator.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열은 이진 데이터를 나타낼 수 없으므로 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 클래스는 병합하는 모든 메시지의 이진 데이터를 ASCII 호환 &lt;em&gt;Content-Transfer_Encoding&lt;/em&gt; 으로 변환하여 ASCII 호환 형식으로 변환해야합니다 . 이메일 RFC의 용어를 사용하면이를 &quot;8 비트 클린&quot;이 아닌 I / O 스트림으로 직렬화하는 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 로 생각할 수 있습니다 . 즉, 대부분의 응용 프로그램은 &lt;a href=&quot;#email.generator.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 가&lt;/a&gt; 아닌 &lt;a href=&quot;#email.generator.BytesGenerator&quot;&gt; &lt;code&gt;BytesGenerator&lt;/code&gt; 를&lt;/a&gt; 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="89da8e115c0fb8ba5661a24d5093eacb1e6421a5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;#module-shelve&quot;&gt;&lt;code&gt;shelve&lt;/code&gt;&lt;/a&gt; module is backed by &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt;, it is insecure to load a shelf from an untrusted source. Like with pickle, loading a shelf can execute arbitrary code.</source>
          <target state="translated">때문에 &lt;a href=&quot;#module-shelve&quot;&gt; &lt;code&gt;shelve&lt;/code&gt; &lt;/a&gt; 모듈에 연동 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; , 신뢰 소스로부터 선반로드 불안정하다. 피클과 마찬가지로 선반을로드하면 임의 코드가 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73d13ce7f4ddc06362be70a3eb8a64c34f10a0b7" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;os.DirEntry&lt;/code&gt; methods can make operating system calls, they may also raise &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt;. If you need very fine-grained control over errors, you can catch &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; when calling one of the &lt;code&gt;os.DirEntry&lt;/code&gt; methods and handle as appropriate.</source>
          <target state="translated">때문에 &lt;code&gt;os.DirEntry&lt;/code&gt; 의 방법은 시스템 호출을 운영 할 수 있습니다, 그들은 또한 제기 할 수 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; 을&lt;/a&gt; . 오류에 대한 매우 세밀한 제어가 필요한 경우 &lt;code&gt;os.DirEntry&lt;/code&gt; 메소드 중 하나를 호출 할 때 &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 를 포착 하고 적절하게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="f5cc4736c7fbeafded92a9d1efa62626a33de504" translate="yes" xml:space="preserve">
          <source>Because the default behavior of &lt;code&gt;Message.__setitem__&lt;/code&gt; is to append the value to the list of headers, it is easy to create duplicate headers without realizing it. This method allows certain headers to be limited in the number of instances of that header that may be added to a &lt;code&gt;Message&lt;/code&gt; programmatically. (The limit is not observed by the parser, which will faithfully produce as many headers as exist in the message being parsed.)</source>
          <target state="translated">&lt;code&gt;Message.__setitem__&lt;/code&gt; 의 기본 동작은 헤더 목록에 값을 추가하는 것이므로 중복 헤더를 실현하지 않고 쉽게 만들 수 있습니다. 이 방법을 사용하면 특정 헤더를 프로그래밍 방식 으로 &lt;code&gt;Message&lt;/code&gt; 추가 할 수있는 해당 헤더의 인스턴스 수로 제한 할 수 있습니다 . 파서는이 제한을 준수하지 않으므로 구문 분석중인 메시지에 존재하는만큼의 헤더를 충실하게 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e508e7ca842cae56ee0fee2a7255d491cd76f437" translate="yes" xml:space="preserve">
          <source>Because the file name does not end with &lt;code&gt;.py&lt;/code&gt;, &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; infers that it must be run with &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt;, not &lt;a href=&quot;#doctest.testmod&quot;&gt;&lt;code&gt;testmod()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">파일 이름이로 끝나지 않기 때문에 &lt;code&gt;.py&lt;/code&gt; , &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; 가&lt;/a&gt; 그것을 실행해야한다고 추론한다 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; ,하지 &lt;a href=&quot;#doctest.testmod&quot;&gt; &lt;code&gt;testmod()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bdfdaaeb849970dad8f9e9818061fb878cb7999" translate="yes" xml:space="preserve">
          <source>Because the format depends on the current locale, care should be taken when making assumptions about the output value. Field orderings will vary (for example, &amp;ldquo;month/day/year&amp;rdquo; versus &amp;ldquo;day/month/year&amp;rdquo;), and the output may contain Unicode characters encoded using the locale&amp;rsquo;s default encoding (for example, if the current locale is &lt;code&gt;ja_JP&lt;/code&gt;, the default encoding could be any one of &lt;code&gt;eucJP&lt;/code&gt;, &lt;code&gt;SJIS&lt;/code&gt;, or &lt;code&gt;utf-8&lt;/code&gt;; use &lt;a href=&quot;locale#locale.getlocale&quot;&gt;&lt;code&gt;locale.getlocale()&lt;/code&gt;&lt;/a&gt; to determine the current locale&amp;rsquo;s encoding).</source>
          <target state="translated">형식은 현재 로케일에 따라 다르므로 출력 값에 대해 가정 할 때주의해야합니다. 필드 순서는 다양하며 (예 : &quot;월 / 일 / 년&quot;대 &quot;일 / 월 / 년&quot;) 출력에는 로케일의 기본 인코딩을 사용하여 인코딩 된 유니 코드 문자가 포함될 수 있습니다 (예 : 현재 로케일이 &lt;code&gt;ja_JP&lt;/code&gt; 이면 기본 인코딩은 중 하나가 될 수 있습니다 &lt;code&gt;eucJP&lt;/code&gt; , &lt;code&gt;SJIS&lt;/code&gt; , 또는 &lt;code&gt;utf-8&lt;/code&gt; 을 사용; &lt;a href=&quot;locale#locale.getlocale&quot;&gt; &lt;code&gt;locale.getlocale()&lt;/code&gt; &lt;/a&gt; 현재의 로케일의 인코딩을 결정하기 위해).</target>
        </trans-unit>
        <trans-unit id="19cc5a3ec7f1feac3debf6aac3103f1d83152c83" translate="yes" xml:space="preserve">
          <source>Because the module uses &lt;strong&gt;/bin/sh&lt;/strong&gt; command lines, a POSIX or compatible shell for &lt;a href=&quot;os#os.system&quot;&gt;&lt;code&gt;os.system()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;os#os.popen&quot;&gt;&lt;code&gt;os.popen()&lt;/code&gt;&lt;/a&gt; is required.</source>
          <target state="translated">모듈은 &lt;strong&gt;/ bin / sh&lt;/strong&gt; 명령 행을 사용하므로 &lt;a href=&quot;os#os.system&quot;&gt; &lt;code&gt;os.system()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;os#os.popen&quot;&gt; &lt;code&gt;os.popen()&lt;/code&gt; &lt;/a&gt; 대한 POSIX 또는 호환 쉘 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3f1f9af0dfdfed0a5be1b6b9e51ad5d7c030fac2" translate="yes" xml:space="preserve">
          <source>Because the pattern is passed into &lt;code&gt;load_tests&lt;/code&gt; the package is free to continue (and potentially modify) test discovery. A &amp;lsquo;do nothing&amp;rsquo; &lt;code&gt;load_tests&lt;/code&gt; function for a test package would look like:</source>
          <target state="translated">패턴이 &lt;code&gt;load_tests&lt;/code&gt; 로 전달 되므로 패키지는 테스트 발견을 계속하고 잠재적으로 수정할 수 있습니다. 테스트 패키지에 대한 '아무것도하지 않음' &lt;code&gt;load_tests&lt;/code&gt; 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7eeaba1ce3974d485fc10bfd66f07a672724c5b" translate="yes" xml:space="preserve">
          <source>Because the traps are disabled, this context is useful for applications that prefer to have result value of &lt;code&gt;NaN&lt;/code&gt; or &lt;code&gt;Infinity&lt;/code&gt; instead of raising exceptions. This allows an application to complete a run in the presence of conditions that would otherwise halt the program.</source>
          <target state="translated">트랩이 비활성화되어 있으므로이 컨텍스트는 예외를 발생시키는 대신 &lt;code&gt;NaN&lt;/code&gt; 또는 &lt;code&gt;Infinity&lt;/code&gt; 의 결과 값을 선호하는 응용 프로그램에 유용합니다 . 이렇게하면 응용 프로그램이 프로그램을 중지시키는 조건이있는 상태에서 실행을 완료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f8021b79e3f19e12b4eea6f7791f976cf9c551" translate="yes" xml:space="preserve">
          <source>Because this function has rather complex behavior (especially when custom event loop policies are in use), using the &lt;a href=&quot;#asyncio.get_running_loop&quot;&gt;&lt;code&gt;get_running_loop()&lt;/code&gt;&lt;/a&gt; function is preferred to &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt; in coroutines and callbacks.</source>
          <target state="translated">이 함수는 다소 복잡한 동작 (특히 사용자 정의 이벤트 루프 정책을 사용중인 경우) 을 &lt;a href=&quot;#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; 코 루틴 및 콜백에서 &lt;a href=&quot;#asyncio.get_running_loop&quot;&gt; &lt;code&gt;get_running_loop()&lt;/code&gt; &lt;/a&gt; 함수를 사용하는 것이 get_event_loop () 보다 선호됩니다 .</target>
        </trans-unit>
        <trans-unit id="945f996940a3d1a131b75aea9889abba3eb63002" translate="yes" xml:space="preserve">
          <source>Because this is a naive &lt;code&gt;datetime&lt;/code&gt; it will be interpreted as a UTC timestamp, and the resulting value will have a timezone of &lt;code&gt;-0000&lt;/code&gt;. Much more useful is to use the &lt;a href=&quot;email.utils#email.utils.localtime&quot;&gt;&lt;code&gt;localtime()&lt;/code&gt;&lt;/a&gt; function from the &lt;a href=&quot;email.utils#module-email.utils&quot;&gt;&lt;code&gt;utils&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">이것은 순진한 &lt;code&gt;datetime&lt;/code&gt; 이므로 UTC 타임 스탬프로 해석되며 결과 값의 시간대는 &lt;code&gt;-0000&lt;/code&gt; 입니다. &lt;a href=&quot;email.utils#module-email.utils&quot;&gt; &lt;code&gt;utils&lt;/code&gt; &lt;/a&gt; 모듈 에서 &lt;a href=&quot;email.utils#email.utils.localtime&quot;&gt; &lt;code&gt;localtime()&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것이 훨씬 더 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="aa017ba24b44b99db1534c67404110bcb6547224" translate="yes" xml:space="preserve">
          <source>Beep the PC&amp;rsquo;s speaker. The &lt;em&gt;frequency&lt;/em&gt; parameter specifies frequency, in hertz, of the sound, and must be in the range 37 through 32,767. The &lt;em&gt;duration&lt;/em&gt; parameter specifies the number of milliseconds the sound should last. If the system is not able to beep the speaker, &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">PC 스피커에서 경고음을냅니다. &lt;em&gt;주파수&lt;/em&gt; 파라미터 지정 음향 헤르쯔 주파수, 및 32,767 내지 37이어야한다. &lt;em&gt;duration&lt;/em&gt; 매개 변수는 사운드가 &lt;em&gt;지속&lt;/em&gt; 되는 &lt;em&gt;시간 (&lt;/em&gt; 밀리 초)을 지정합니다. 시스템에서 스피커에서 경고음을 낼 수 없으면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="20b32ebd2fd01cdbc476b447b812c4f108a6392b" translate="yes" xml:space="preserve">
          <source>Before &lt;a href=&quot;#itertools.product&quot;&gt;&lt;code&gt;product()&lt;/code&gt;&lt;/a&gt; runs, it completely consumes the input iterables, keeping pools of values in memory to generate the products. Accordingly, it only useful with finite inputs.</source>
          <target state="translated">&lt;a href=&quot;#itertools.product&quot;&gt; &lt;code&gt;product()&lt;/code&gt; &lt;/a&gt; 가 실행 되기 전에 제품 을 생성하기 위해 메모리에 값 풀을 유지하면서 입력 이터 러블을 완전히 소비합니다. 따라서 유한 입력에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9decded3226de91a3370052bd429264360dba835" translate="yes" xml:space="preserve">
          <source>Before I explain how auto-speccing works, here&amp;rsquo;s why it is needed.</source>
          <target state="translated">자동 지정의 작동 방식을 설명하기 전에 이것이 필요한 이유입니다.</target>
        </trans-unit>
        <trans-unit id="648ed538fe4d41e0992f761cec23ce4dc2546702" translate="yes" xml:space="preserve">
          <source>Before Python 3.6, when printing a dict, Python did not guarantee that the key-value pairs was printed in any particular order.</source>
          <target state="translated">Python 3.6 이전에는 dict를 인쇄 할 때 키-값 쌍이 특정 순서로 인쇄되었음을 보증하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="46d337986d57f221ecbc2aaa26bd0ab430008b76" translate="yes" xml:space="preserve">
          <source>Before the end of the stream is reached, this will be &lt;code&gt;b&quot;&quot;&lt;/code&gt;.</source>
          <target state="translated">스트림의 끝에 도달하기 전에 &lt;code&gt;b&quot;&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48c0f47c1261299c0864a67fc685c6a3005db48e" translate="yes" xml:space="preserve">
          <source>Before we move on calling functions with other parameter types, we have to learn more about &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; data types.</source>
          <target state="translated">다른 매개 변수 유형을 사용하여 함수를 호출하기 전에 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 데이터 유형 에 대해 자세히 학습해야합니다 .</target>
        </trans-unit>
        <trans-unit id="483be28c0eaadf9f1aa628c534f11b5e079a5451" translate="yes" xml:space="preserve">
          <source>Before you can write to or read from an audio device, you must call three methods in the correct order:</source>
          <target state="translated">오디오 장치에 쓰거나 읽 기 전에 올바른 순서로 세 가지 방법을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="c68a6e6a64dac6bce2f425b8bf2ec3d1606a381e" translate="yes" xml:space="preserve">
          <source>Beg (beginning)</source>
          <target state="translated">구걸 (시작)</target>
        </trans-unit>
        <trans-unit id="40f9d4d10702ae8642d1d7383cb9d28d940dec80" translate="yes" xml:space="preserve">
          <source>Begin autoincrement mode: schedules a recurring timer event that calls &lt;a href=&quot;#tkinter.ttk.Progressbar.step&quot;&gt;&lt;code&gt;Progressbar.step()&lt;/code&gt;&lt;/a&gt; every &lt;em&gt;interval&lt;/em&gt; milliseconds. If omitted, &lt;em&gt;interval&lt;/em&gt; defaults to 50 milliseconds.</source>
          <target state="translated">자동 증가 모드 시작 : &lt;em&gt;간격 (&lt;/em&gt; 밀리 초 &lt;a href=&quot;#tkinter.ttk.Progressbar.step&quot;&gt; &lt;code&gt;Progressbar.step()&lt;/code&gt; &lt;/a&gt; 마다 Progressbar.step () 을 호출하는 반복 타이머 이벤트를 예약합니다 . 생략하면 &lt;em&gt;interval의&lt;/em&gt; 기본값은 50 밀리 초입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1fa1a5c3ae45577ab117ab821ac5874e521c6ac6" translate="yes" xml:space="preserve">
          <source>Begin by writing &lt;code&gt;import cgi&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;import cgi&lt;/code&gt; 를 작성하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="d21290f4ef30d771e174960f4bd7877417e7b443" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping.</source>
          <target state="translated">접두사 URI 네임 스페이스 매핑의 범위를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="df80a1098d80f4a77aa0c5fa9359c3f1b5d396a4" translate="yes" xml:space="preserve">
          <source>Behavior is the same as in &lt;a href=&quot;threading#threading.Lock.release&quot;&gt;&lt;code&gt;threading.Lock.release()&lt;/code&gt;&lt;/a&gt; except that when invoked on an unlocked lock, a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">동작은 잠금 해제 된 잠금에서 호출 될 때 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 라는 점을 제외하고 &lt;a href=&quot;threading#threading.Lock.release&quot;&gt; &lt;code&gt;threading.Lock.release()&lt;/code&gt; &lt;/a&gt; 동일합니다. 가 발생 .</target>
        </trans-unit>
        <trans-unit id="aa8a60766ac333f80dc11610250a1865830afb33" translate="yes" xml:space="preserve">
          <source>Behind the scenes, the &lt;a href=&quot;#ctypes.pointer&quot;&gt;&lt;code&gt;pointer()&lt;/code&gt;&lt;/a&gt; function does more than simply create pointer instances, it has to create pointer &lt;em&gt;types&lt;/em&gt; first. This is done with the &lt;a href=&quot;#ctypes.POINTER&quot;&gt;&lt;code&gt;POINTER()&lt;/code&gt;&lt;/a&gt; function, which accepts any &lt;a href=&quot;#module-ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; type, and returns a new type:</source>
          <target state="translated">배후에서, &lt;a href=&quot;#ctypes.pointer&quot;&gt; &lt;code&gt;pointer()&lt;/code&gt; &lt;/a&gt; 함수는 단순히 포인터 인스턴스를 만드는 것보다 먼저 포인터 &lt;em&gt;유형&lt;/em&gt; 을 만들어야 합니다. 이것은 모든 &lt;a href=&quot;#module-ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 을 허용 하는 &lt;a href=&quot;#ctypes.POINTER&quot;&gt; &lt;code&gt;POINTER()&lt;/code&gt; &lt;/a&gt; 함수 로 수행됩니다. 유형 하고 새로운 유형을 반환하는 .</target>
        </trans-unit>
        <trans-unit id="bca285402106aa0f0f7b601a2f8df4f157534b63" translate="yes" xml:space="preserve">
          <source>Being able to tell if a line of input completes a Python statement: in short, telling whether to print &amp;lsquo;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;&amp;rsquo; or &amp;lsquo;&lt;code&gt;...&lt;/code&gt;&amp;rsquo; next.</source>
          <target state="translated">입력 줄이 파이썬 문장을 완성하는지 알 수 있음 : 간단히 말해서 ' &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; '또는 ' &lt;code&gt;...&lt;/code&gt; '다음.</target>
        </trans-unit>
        <trans-unit id="d4198662a72fd519a4f968a74051bafac710dc07" translate="yes" xml:space="preserve">
          <source>Bell</source>
          <target state="translated">Bell</target>
        </trans-unit>
        <trans-unit id="f8c124cc977ebefe3c2c86720bb514be851e243e" translate="yes" xml:space="preserve">
          <source>Below are some examples of typical usage of the &lt;a href=&quot;#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">다음은 &lt;a href=&quot;#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법에 대한 몇 가지 예입니다. 모듈 .</target>
        </trans-unit>
        <trans-unit id="5d357b659dbe283278a24199979dd7871083127a" translate="yes" xml:space="preserve">
          <source>Below is a table mapping various &lt;a href=&quot;os#module-os&quot;&gt;&lt;code&gt;os&lt;/code&gt;&lt;/a&gt; functions to their corresponding &lt;a href=&quot;#pathlib.PurePath&quot;&gt;&lt;code&gt;PurePath&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;#pathlib.Path&quot;&gt;&lt;code&gt;Path&lt;/code&gt;&lt;/a&gt; equivalent.</source>
          <target state="translated">아래는 다양한 &lt;a href=&quot;os#module-os&quot;&gt; &lt;code&gt;os&lt;/code&gt; &lt;/a&gt; 함수를 해당하는 &lt;a href=&quot;#pathlib.PurePath&quot;&gt; &lt;code&gt;PurePath&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;#pathlib.Path&quot;&gt; &lt;code&gt;Path&lt;/code&gt; &lt;/a&gt; 해당 항목에 매핑하는 표 입니다.</target>
        </trans-unit>
        <trans-unit id="ab4a051ee0b5f6099448f93c169d9e07992b08e7" translate="yes" xml:space="preserve">
          <source>Below is an example session with logging turned on:</source>
          <target state="translated">다음은 로깅이 설정된 세션 예입니다.</target>
        </trans-unit>
        <trans-unit id="a1129a8f113198207df5b47176143371497861ab" translate="yes" xml:space="preserve">
          <source>Below is an example where a number of ctypes objects are modified by a child process:</source>
          <target state="translated">다음은 많은 ctypes 객체가 자식 프로세스에 의해 수정되는 예입니다.</target>
        </trans-unit>
        <trans-unit id="3e802043d7d026781c9db6d85cb3061d11ca8b23" translate="yes" xml:space="preserve">
          <source>Besides the methods described below, the &lt;code&gt;ttk.Widget&lt;/code&gt; supports the methods &lt;code&gt;tkinter.Widget.cget()&lt;/code&gt; and &lt;code&gt;tkinter.Widget.configure()&lt;/code&gt;.</source>
          <target state="translated">아래에 설명 된 메소드 외에도 &lt;code&gt;ttk.Widget&lt;/code&gt; 은 &lt;code&gt;tkinter.Widget.cget()&lt;/code&gt; 및 &lt;code&gt;tkinter.Widget.configure()&lt;/code&gt; 메소드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="2e1367870fdc44f776287e47700c866b325754e2" translate="yes" xml:space="preserve">
          <source>Besides the methods inherited from &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt;&lt;code&gt;Widget&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;Widget.cget()&lt;/code&gt;, &lt;code&gt;Widget.configure()&lt;/code&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt;&lt;code&gt;Widget.instate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt;&lt;code&gt;Widget.state()&lt;/code&gt;&lt;/a&gt;, and the following inherited from &lt;code&gt;Entry&lt;/code&gt;: &lt;code&gt;Entry.bbox()&lt;/code&gt;, &lt;code&gt;Entry.delete()&lt;/code&gt;, &lt;code&gt;Entry.icursor()&lt;/code&gt;, &lt;code&gt;Entry.index()&lt;/code&gt;, &lt;code&gt;Entry.insert()&lt;/code&gt;, &lt;code&gt;Entry.selection()&lt;/code&gt;, &lt;code&gt;Entry.xview()&lt;/code&gt;, it has some other methods, described at &lt;code&gt;ttk.Combobox&lt;/code&gt;.</source>
          <target state="translated">로부터 상속 된 메소드 이외에 &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;Widget.cget()&lt;/code&gt; , &lt;code&gt;Widget.configure()&lt;/code&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt; &lt;code&gt;Widget.instate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt; &lt;code&gt;Widget.state()&lt;/code&gt; &lt;/a&gt; , 상기로부터 상속 다음 &lt;code&gt;Entry&lt;/code&gt; : &lt;code&gt;Entry.bbox()&lt;/code&gt; , &lt;code&gt;Entry.delete()&lt;/code&gt; , &lt;code&gt;Entry.icursor()&lt;/code&gt; , &lt;code&gt;Entry.index()&lt;/code&gt; , &lt;code&gt;Entry.insert()&lt;/code&gt; , &lt;code&gt;Entry.selection()&lt;/code&gt; , &lt;code&gt;Entry.xview()&lt;/code&gt; 에는 &lt;code&gt;ttk.Combobox&lt;/code&gt; 에 설명 된 다른 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f831523d7c6cadde7e0cb39c81a22ba24bb9ec" translate="yes" xml:space="preserve">
          <source>Besides the methods inherited from &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt;&lt;code&gt;Widget&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;Widget.cget()&lt;/code&gt;, &lt;code&gt;Widget.configure()&lt;/code&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt;&lt;code&gt;Widget.identify()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt;&lt;code&gt;Widget.instate()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt;&lt;code&gt;Widget.state()&lt;/code&gt;&lt;/a&gt;, and the following inherited from &lt;code&gt;Entry&lt;/code&gt;: &lt;code&gt;Entry.bbox()&lt;/code&gt;, &lt;code&gt;Entry.delete()&lt;/code&gt;, &lt;code&gt;Entry.icursor()&lt;/code&gt;, &lt;code&gt;Entry.index()&lt;/code&gt;, &lt;code&gt;Entry.insert()&lt;/code&gt;, &lt;code&gt;Entry.xview()&lt;/code&gt;, it has some other methods, described at &lt;code&gt;ttk.Spinbox&lt;/code&gt;.</source>
          <target state="translated">로부터 상속 된 메소드 이외에 &lt;a href=&quot;#tkinter.ttk.Widget&quot;&gt; &lt;code&gt;Widget&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;Widget.cget()&lt;/code&gt; , &lt;code&gt;Widget.configure()&lt;/code&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.identify&quot;&gt; &lt;code&gt;Widget.identify()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#tkinter.ttk.Widget.instate&quot;&gt; &lt;code&gt;Widget.instate()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#tkinter.ttk.Widget.state&quot;&gt; &lt;code&gt;Widget.state()&lt;/code&gt; &lt;/a&gt; , 상기로부터 상속 다음 &lt;code&gt;Entry&lt;/code&gt; : &lt;code&gt;Entry.bbox()&lt;/code&gt; , &lt;code&gt;Entry.delete()&lt;/code&gt; , &lt;code&gt;Entry.icursor()&lt;/code&gt; , &lt;code&gt;Entry.index()&lt;/code&gt; , &lt;code&gt;Entry.insert()&lt;/code&gt; , &lt;code&gt;Entry.xview()&lt;/code&gt; 에는 &lt;code&gt;ttk.Spinbox&lt;/code&gt; 에 설명 된 다른 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c3ff9eb01f9273b0084e00951f1623a111bedef" translate="yes" xml:space="preserve">
          <source>Besides, only the main thread is allowed to set a new signal handler.</source>
          <target state="translated">게다가 메인 스레드 만이 새로운 시그널 핸들러를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49aeffbbcfcc4f4ba7dd665a66bd39194335e4c7" translate="yes" xml:space="preserve">
          <source>Besides, only the main thread of the main interpreter is allowed to set a new signal handler.</source>
          <target state="translated">게다가 메인 인터프리터의 메인 스레드 만이 새로운 시그널 핸들러를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf8d3be729847deb19b6a44bdd74975d6befe47c" translate="yes" xml:space="preserve">
          <source>Besides, the &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt;&lt;code&gt;read()&lt;/code&gt;&lt;/a&gt; method does not have a default implementation that defers to &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt;&lt;code&gt;readinto()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">게다가, &lt;a href=&quot;#io.BufferedIOBase.read&quot;&gt; &lt;code&gt;read()&lt;/code&gt; &lt;/a&gt; 메소드에는 &lt;a href=&quot;#io.BufferedIOBase.readinto&quot;&gt; &lt;code&gt;readinto()&lt;/code&gt; &lt;/a&gt; 를 연기하는 기본 구현이 없습니다. .</target>
        </trans-unit>
        <trans-unit id="e83a3ab69e9fd0abbfb55d96374f52bcbc103b5f" translate="yes" xml:space="preserve">
          <source>Best defaults</source>
          <target state="translated">최선의 기본값</target>
        </trans-unit>
        <trans-unit id="a5e1caaf3a558a5215965e11aae5b2c42a62435b" translate="yes" xml:space="preserve">
          <source>Best practice is to omit the traceback stack, unless it adds significant documentation value to the example. So the last example is probably better as:</source>
          <target state="translated">모범 사례 값이 예제에 추가되지 않는 한 역 추적 스택을 생략하는 것이 가장 좋습니다. 따라서 마지막 예는 다음과 같이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fb8df3d1388d60aad85d2be198e574d70525685d" translate="yes" xml:space="preserve">
          <source>Beta distribution. Conditions on the parameters are &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; and &lt;code&gt;beta &amp;gt; 0&lt;/code&gt;. Returned values range between 0 and 1.</source>
          <target state="translated">베타 배포. 매개 변수의 조건은 &lt;code&gt;alpha &amp;gt; 0&lt;/code&gt; 및 &lt;code&gt;beta &amp;gt; 0&lt;/code&gt; 입니다. 반환 된 값의 범위는 0과 1입니다.</target>
        </trans-unit>
        <trans-unit id="d8ba6dd6cc0d2b6353ea52b89942547287c30fad" translate="yes" xml:space="preserve">
          <source>Better to inherit than pickle/unpickle</source>
          <target state="translated">피클 / 피클 링보다 상속하는 것이 좋습니다</target>
        </trans-unit>
        <trans-unit id="9c1dda353e343c24e7708a72b54529d23347826a" translate="yes" xml:space="preserve">
          <source>Between -999999999 and 999999999 inclusive</source>
          <target state="translated">-999999999 ~ 999999999 사이</target>
        </trans-unit>
        <trans-unit id="b6c74a472b928b3de7f142f2f611644179e766ce" translate="yes" xml:space="preserve">
          <source>Between 0 and 86399 inclusive</source>
          <target state="translated">0에서 86399 사이</target>
        </trans-unit>
        <trans-unit id="954ca93f131384b9558ca914d678c167bd92e718" translate="yes" xml:space="preserve">
          <source>Between 0 and 999999 inclusive</source>
          <target state="translated">0에서 999999 사이</target>
        </trans-unit>
        <trans-unit id="ed2cf7c590b6e7f609a00c26affc3a6e2749ead7" translate="yes" xml:space="preserve">
          <source>Between 1 and 12 inclusive.</source>
          <target state="translated">1에서 12 사이.</target>
        </trans-unit>
        <trans-unit id="08bfcd2e1cae8c1d62e31e45c7e3c998b88e587e" translate="yes" xml:space="preserve">
          <source>Between 1 and the number of days in the given month of the given year.</source>
          <target state="translated">1과 주어진 연도의 주어진 달의 일 수 사이.</target>
        </trans-unit>
        <trans-unit id="74437956ab6159c55badf4bbc91e7ad2175fad4e" translate="yes" xml:space="preserve">
          <source>Between &lt;a href=&quot;#datetime.MINYEAR&quot;&gt;&lt;code&gt;MINYEAR&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt;&lt;code&gt;MAXYEAR&lt;/code&gt;&lt;/a&gt; inclusive.</source>
          <target state="translated">사이 &lt;a href=&quot;#datetime.MINYEAR&quot;&gt; &lt;code&gt;MINYEAR&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#datetime.MAXYEAR&quot;&gt; &lt;code&gt;MAXYEAR&lt;/code&gt; &lt;/a&gt; 포괄적으로.</target>
        </trans-unit>
        <trans-unit id="4c36aee3637e0b2b5bfaa0e70a4ebeb4eee3c90f" translate="yes" xml:space="preserve">
          <source>Between the sending side and the receiving side, the communications system is free to implement its own transfer mechanism for out-of-band buffers. Potential optimizations include the use of shared memory or datatype-dependent compression.</source>
          <target state="translated">송신 측과 수신 측 사이에서, 통신 시스템은 대역 외 버퍼를위한 자체 전송 메커니즘을 자유롭게 구현할 수있다. 잠재적 인 최적화에는 공유 메모리 또는 데이터 유형 종속 압축 사용이 ​​포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dc3aa2f92c76e508acf2bfaca08ad2ba1baa2d87" translate="yes" xml:space="preserve">
          <source>Beware of replacing &lt;a href=&quot;sys#sys.stdin&quot;&gt;&lt;code&gt;sys.stdin&lt;/code&gt;&lt;/a&gt; with a &amp;ldquo;file like object&amp;rdquo;</source>
          <target state="translated">&lt;a href=&quot;sys#sys.stdin&quot;&gt; &lt;code&gt;sys.stdin&lt;/code&gt; &lt;/a&gt; 을&amp;ldquo;file like object&amp;rdquo; 로 바꾸지 마십시오.</target>
        </trans-unit>
        <trans-unit id="c9a0688daec7baa0367d0ff67569d3d33eb4a71a" translate="yes" xml:space="preserve">
          <source>Beyond &lt;code&gt;sys.argv&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sys.argv&lt;/code&gt; 너머</target>
        </trans-unit>
        <trans-unit id="892bf0fc9ced21536073b10f72d8a317557e88d9" translate="yes" xml:space="preserve">
          <source>Binary Data</source>
          <target state="translated">이진 데이터</target>
        </trans-unit>
        <trans-unit id="74dc05f939b4de6df10ded1ad85cd87cf64bc9f7" translate="yes" xml:space="preserve">
          <source>Binary Data Services</source>
          <target state="translated">이진 데이터 서비스</target>
        </trans-unit>
        <trans-unit id="077a15b13db556c78b4bfbf28994d6f478f129e0" translate="yes" xml:space="preserve">
          <source>Binary I/O</source>
          <target state="translated">이진 I / O</target>
        </trans-unit>
        <trans-unit id="0c9ab2e214f4e3d68626fcb0f6f6f4976f56998f" translate="yes" xml:space="preserve">
          <source>Binary I/O (also called &lt;em&gt;buffered I/O&lt;/em&gt;) expects &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; and produces &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects. No encoding, decoding, or newline translation is performed. This category of streams can be used for all kinds of non-text data, and also when manual control over the handling of text data is desired.</source>
          <target state="translated">(또한 바이너리 I / O &lt;em&gt;버퍼 I / O는&lt;/em&gt; ) 기대 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;객체 바이트 - 같은&lt;/a&gt; 및 생산 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체. 인코딩, 디코딩 또는 개행 변환이 수행되지 않습니다. 이 범주의 스트림은 모든 종류의 텍스트가 아닌 데이터에 사용될 수 있으며 텍스트 데이터 처리를 수동으로 제어해야하는 경우에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="670fe96f19bc636b28e8bbfc569f0fe00c664e38" translate="yes" xml:space="preserve">
          <source>Binary I/O (also called &lt;em&gt;buffered I/O&lt;/em&gt;) expects &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like objects&lt;/a&gt; and produces &lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt; objects. No encoding, decoding, or newline translation is performed. This category of streams can be used for all kinds of non-text data, and also when manual control over the handling of text data is desired.</source>
          <target state="translated">(또한 바이너리 I / O &lt;em&gt;버퍼 I / O는&lt;/em&gt; ) 기대 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;객체 바이트 - 같은&lt;/a&gt; 및 생산 &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; 객체. 인코딩, 디코딩 또는 개행 변환이 수행되지 않습니다. 이 범주의 스트림은 모든 종류의 텍스트가 아닌 데이터에 사용할 수 있으며 텍스트 데이터 처리를 수동으로 제어해야하는 경우에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d18c326fb8b019f2ba7dcc08e612917c6ba14d2" translate="yes" xml:space="preserve">
          <source>Binary Objects</source>
          <target state="translated">이진 객체</target>
        </trans-unit>
        <trans-unit id="9cf3342675aa01229892e963ccc770d42fd0df53" translate="yes" xml:space="preserve">
          <source>Binary Sequence Types &amp;mdash; &lt;code&gt;bytes&lt;/code&gt;, &lt;code&gt;bytearray&lt;/code&gt;, &lt;code&gt;memoryview&lt;/code&gt;</source>
          <target state="translated">이진 시퀀스 유형 &amp;mdash; &lt;code&gt;bytes&lt;/code&gt; , &lt;code&gt;bytearray&lt;/code&gt; , &lt;code&gt;memoryview&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5926a354af36f8d3a781a27eef2ef8a43ed8d3ed" translate="yes" xml:space="preserve">
          <source>Binary Sequence Types &amp;mdash; bytes, bytearray, memoryview</source>
          <target state="translated">이진 시퀀스 유형 &amp;mdash; 바이트, 바이트 배열, 메모 리뷰</target>
        </trans-unit>
        <trans-unit id="3926624312f99b7ac129db6c0c454a3ff48903bd" translate="yes" xml:space="preserve">
          <source>Binary Transforms</source>
          <target state="translated">이진 변환</target>
        </trans-unit>
        <trans-unit id="21fe5e3cd9c91723a039c52415394d9d03534dd3" translate="yes" xml:space="preserve">
          <source>Binary buffered objects (instances of &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedRandom&quot;&gt;&lt;code&gt;BufferedRandom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.BufferedRWPair&quot;&gt;&lt;code&gt;BufferedRWPair&lt;/code&gt;&lt;/a&gt;) are not reentrant. While reentrant calls will not happen in normal situations, they can arise from doing I/O in a &lt;a href=&quot;signal#module-signal&quot;&gt;&lt;code&gt;signal&lt;/code&gt;&lt;/a&gt; handler. If a thread tries to re-enter a buffered object which it is already accessing, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised. Note this doesn&amp;rsquo;t prohibit a different thread from entering the buffered object.</source>
          <target state="translated">이진 버퍼링 된 객체 ( &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedRandom&quot;&gt; &lt;code&gt;BufferedRandom&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedRWPair&quot;&gt; &lt;code&gt;BufferedRWPair&lt;/code&gt; 의&lt;/a&gt; 인스턴스 )는 재진입 할 ​​수 없습니다. 재진입 호출은 정상적인 상황에서는 발생하지 않지만 &lt;a href=&quot;signal#module-signal&quot;&gt; &lt;code&gt;signal&lt;/code&gt; &lt;/a&gt; 처리기 에서 I / O를 수행하면 발생할 수 있습니다 . 스레드가 이미 액세스중인 버퍼링 된 개체를 다시 입력하려고하면 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다. 이것은 다른 스레드가 버퍼링 된 객체에 들어가는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4406f8baf70aa1a1308d895faa78af8d9e41d899" translate="yes" xml:space="preserve">
          <source>Binary buffered objects (instances of &lt;a href=&quot;#io.BufferedReader&quot;&gt;&lt;code&gt;BufferedReader&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedWriter&quot;&gt;&lt;code&gt;BufferedWriter&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#io.BufferedRandom&quot;&gt;&lt;code&gt;BufferedRandom&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#io.BufferedRWPair&quot;&gt;&lt;code&gt;BufferedRWPair&lt;/code&gt;&lt;/a&gt;) protect their internal structures using a lock; it is therefore safe to call them from multiple threads at once.</source>
          <target state="translated">이진 버퍼링 된 객체 ( &lt;a href=&quot;#io.BufferedReader&quot;&gt; &lt;code&gt;BufferedReader&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedWriter&quot;&gt; &lt;code&gt;BufferedWriter&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#io.BufferedRandom&quot;&gt; &lt;code&gt;BufferedRandom&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#io.BufferedRWPair&quot;&gt; &lt;code&gt;BufferedRWPair&lt;/code&gt; 의&lt;/a&gt; 인스턴스) )는 잠금을 사용하여 내부 구조를 보호합니다. 따라서 여러 스레드에서 한 번에 호출하는 것이 안전합니다.</target>
        </trans-unit>
        <trans-unit id="62f7f2783ce89c5bb6d5fe79cd3bd1c11179b462" translate="yes" xml:space="preserve">
          <source>Binary data in any form.</source>
          <target state="translated">모든 형태의 이진 데이터.</target>
        </trans-unit>
        <trans-unit id="b418b66c57a5a2313398824ab306a08b3b9421cc" translate="yes" xml:space="preserve">
          <source>Binary files are buffered in fixed-size chunks; the size of the buffer is chosen using a heuristic trying to determine the underlying device&amp;rsquo;s &amp;ldquo;block size&amp;rdquo; and falling back on &lt;a href=&quot;io#io.DEFAULT_BUFFER_SIZE&quot;&gt;&lt;code&gt;io.DEFAULT_BUFFER_SIZE&lt;/code&gt;&lt;/a&gt;. On many systems, the buffer will typically be 4096 or 8192 bytes long.</source>
          <target state="translated">이진 파일은 고정 크기 청크로 버퍼링됩니다. 버퍼의 크기는 기본 장치의 &quot;블록 크기&quot;를 결정하고 &lt;a href=&quot;io#io.DEFAULT_BUFFER_SIZE&quot;&gt; &lt;code&gt;io.DEFAULT_BUFFER_SIZE&lt;/code&gt; 로&lt;/a&gt; 떨어지는 휴리스틱을 사용하여 선택됩니다 . 많은 시스템에서 버퍼의 길이는 일반적으로 4096 또는 8192 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="6b48357f7d4a42846626a5244d044b564edfcf86" translate="yes" xml:space="preserve">
          <source>Binary format. Outputs the number in base 2.</source>
          <target state="translated">이진 형식. 밑이 2 인 숫자를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="82f1ab06b67bdfb6757c6103375f928cf440f008" translate="yes" xml:space="preserve">
          <source>Binary operations remove the top of the stack (TOS) and the second top-most stack item (TOS1) from the stack. They perform the operation, and put the result back on the stack.</source>
          <target state="translated">이진 작업은 스택에서 스택 상단 (TOS)과 두 번째 최상위 스택 항목 (TOS1)을 제거합니다. 그들은 작업을 수행하고 결과를 다시 스택에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="343454e4d9b2acf169be0d953fb0fb79d39cb3cc" translate="yes" xml:space="preserve">
          <source>Binary operations that mix &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; instances with &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; return the type of the first operand. For example: &lt;code&gt;frozenset('ab') |
set('bc')&lt;/code&gt; returns an instance of &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이진 작업은 믹스 것을 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 과 인스턴스 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; 는&lt;/a&gt; 첫 번째 피연산자의 형태를 돌려줍니다. 예를 들면 다음과 같습니다. &lt;code&gt;frozenset('ab') | set('bc')&lt;/code&gt; 는 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 의 인스턴스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9c441e1be7900ba6369f9d1e8b770e422d0ae553" translate="yes" xml:space="preserve">
          <source>Binary operator tokens.</source>
          <target state="translated">이진 연산자 토큰.</target>
        </trans-unit>
        <trans-unit id="1606bce466a3fb6e4e13c59af6b1a64d90c92104" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to key-press event of key if key is given, or to any key-press-event if no key is given. Remark: in order to be able to register key-events, TurtleScreen must have focus. (See method &lt;a href=&quot;#turtle.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">키가 주어진 경우 키 누르기 이벤트에 키를, 키가없는 경우 키 누르기 이벤트에 &lt;em&gt;재미&lt;/em&gt; 를 바인드하십시오 . 비고 : 주요 이벤트를 등록하려면 TurtleScreen에 포커스가 있어야합니다. &lt;a href=&quot;#turtle.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c360811010b1ba8b6a9cf0d69579acc60a3e6bac" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to key-release event of key. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, event bindings are removed. Remark: in order to be able to register key-events, TurtleScreen must have the focus. (See method &lt;a href=&quot;#turtle.listen&quot;&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 키의 키 릴리스 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 이벤트 바인딩이 제거됩니다. 비고 : 주요 이벤트를 등록하려면 TurtleScreen에 포커스가 있어야합니다. &lt;a href=&quot;#turtle.listen&quot;&gt; &lt;code&gt;listen()&lt;/code&gt; &lt;/a&gt; 메소드를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="88250fa997071f51f9a8c6f6b2b0aff6f79ab7aa" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-button-release events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 버튼 릴리스 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8981cb59d50b3e142bec1ed6694170c1d04c3e93" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-click events on this screen. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 화면에서 마우스 클릭 이벤트에. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="eae217269ecbcd53a0c67a6d42f2541196eef9ba" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-click events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed. Example for the anonymous turtle, i.e. the procedural way:</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 클릭 이벤트에. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다. 익명의 거북이의 예, 즉 절차 적 방법 :</target>
        </trans-unit>
        <trans-unit id="f2c696385e54300e88da723431117d0a4a8e9d3c" translate="yes" xml:space="preserve">
          <source>Bind &lt;em&gt;fun&lt;/em&gt; to mouse-move events on this turtle. If &lt;em&gt;fun&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, existing bindings are removed.</source>
          <target state="translated">바인딩 &lt;em&gt;재미&lt;/em&gt; 이 거북이에 마우스 이동 이벤트. 하면 &lt;em&gt;재미가&lt;/em&gt; 없다 &lt;code&gt;None&lt;/code&gt; , 기존 바인딩이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="8afe0450ccf1ed51bd4d76038ec0971fe964de5c" translate="yes" xml:space="preserve">
          <source>Bind a callback for the given event &lt;em&gt;sequence&lt;/em&gt; to the tag &lt;em&gt;tagname&lt;/em&gt;. When an event is delivered to an item, the callbacks for each of the item&amp;rsquo;s tags option are called.</source>
          <target state="translated">주어진 이벤트 &lt;em&gt;시퀀스&lt;/em&gt; 에 대한 콜백을 &lt;em&gt;tagname&lt;/em&gt; 태그에 바인딩합니다 . 이벤트가 항목에 전달되면 각 항목의 태그 옵션에 대한 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="62a0e995f722ce9bd473d6c69d16b2dc42dd47fe" translate="yes" xml:space="preserve">
          <source>Bind a unix socket, raising &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt;&lt;code&gt;unittest.SkipTest&lt;/code&gt;&lt;/a&gt; if &lt;a href=&quot;exceptions#PermissionError&quot;&gt;&lt;code&gt;PermissionError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;a href=&quot;exceptions#PermissionError&quot;&gt; &lt;code&gt;PermissionError&lt;/code&gt; &lt;/a&gt; 가 발생 하면 &lt;a href=&quot;unittest#unittest.SkipTest&quot;&gt; &lt;code&gt;unittest.SkipTest&lt;/code&gt; 를&lt;/a&gt; 발생시켜 유닉스 소켓을 바인딩합니다 .</target>
        </trans-unit>
        <trans-unit id="3ec9eed3827520279516114577184ceeb4151b81" translate="yes" xml:space="preserve">
          <source>Bind bye() method to mouse clicks on the Screen.</source>
          <target state="translated">bye () 메서드를 화면에서 마우스 클릭에 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="efbdacada9d39467e2d8f8e1aba79f1562fdc7db" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt; to the argument names of the Python function or method &lt;em&gt;func&lt;/em&gt;, as if it was called with them. For bound methods, bind also the first argument (typically named &lt;code&gt;self&lt;/code&gt;) to the associated instance. A dict is returned, mapping the argument names (including the names of the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;**&lt;/code&gt; arguments, if any) to their values from &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt;. In case of invoking &lt;em&gt;func&lt;/em&gt; incorrectly, i.e. whenever &lt;code&gt;func(*args, **kwds)&lt;/code&gt; would raise an exception because of incompatible signature, an exception of the same type and the same or similar message is raised. For example:</source>
          <target state="translated">&lt;em&gt;args&lt;/em&gt; 와 &lt;em&gt;kwds&lt;/em&gt; 를 &lt;em&gt;마치&lt;/em&gt; 파이썬 함수 나 메소드 &lt;em&gt;func&lt;/em&gt; 의 인수 이름에 바인딩 된 &lt;em&gt;것처럼&lt;/em&gt; 바인딩 합니다. 바인딩 된 메서드의 경우 첫 번째 인수 (일반적으로 &lt;code&gt;self&lt;/code&gt; )도 연결된 인스턴스에 바인딩 합니다. 인수 이름 ( &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;**&lt;/code&gt; 인수 의 이름 포함 )을 &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwds&lt;/em&gt; 의 값에 맵핑하여 dict가 리턴 됩니다. &lt;code&gt;func(*args, **kwds)&lt;/code&gt; 가 호환되지 않는 서명으로 인해 func (* args, ** kwds) 가 예외를 발생시킬 때마다 &lt;em&gt;func를&lt;/em&gt; 잘못 호출하는 경우 , 동일한 유형 및 동일하거나 유사한 메시지의 예외가 발생합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="466b061fcff1561dff2e7055a677ac36776d8605" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;domain&lt;/em&gt; to &lt;em&gt;codeset&lt;/em&gt;, changing the encoding of byte strings returned by the &lt;a href=&quot;#gettext.lgettext&quot;&gt;&lt;code&gt;lgettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.ldgettext&quot;&gt;&lt;code&gt;ldgettext()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#gettext.lngettext&quot;&gt;&lt;code&gt;lngettext()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#gettext.ldngettext&quot;&gt;&lt;code&gt;ldngettext()&lt;/code&gt;&lt;/a&gt; functions. If &lt;em&gt;codeset&lt;/em&gt; is omitted, then the current binding is returned.</source>
          <target state="translated">&lt;a href=&quot;#gettext.lgettext&quot;&gt; &lt;code&gt;lgettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.ldgettext&quot;&gt; &lt;code&gt;ldgettext()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#gettext.lngettext&quot;&gt; &lt;code&gt;lngettext()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#gettext.ldngettext&quot;&gt; &lt;code&gt;ldngettext()&lt;/code&gt; &lt;/a&gt; 함수가 반환 한 바이트 문자열의 인코딩을 변경 하여 &lt;em&gt;도메인&lt;/em&gt; 을 &lt;em&gt;codeset에&lt;/em&gt; 바인딩합니다 . 경우 &lt;em&gt;코드 세트가&lt;/em&gt; 생략되어, 현재 반환 바인딩.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="971f75ed3a8b9b21ee56302a74bf55b47cdbf22e" translate="yes" xml:space="preserve">
          <source>Bind the &lt;em&gt;domain&lt;/em&gt; to the locale directory &lt;em&gt;localedir&lt;/em&gt;. More concretely, &lt;a href=&quot;#module-gettext&quot;&gt;&lt;code&gt;gettext&lt;/code&gt;&lt;/a&gt; will look for binary &lt;code&gt;.mo&lt;/code&gt; files for the given domain using the path (on Unix): &lt;code&gt;&lt;em&gt;localedir&lt;/em&gt;/&lt;em&gt;language&lt;/em&gt;/LC_MESSAGES/&lt;em&gt;domain&lt;/em&gt;.mo&lt;/code&gt;, where &lt;em&gt;language&lt;/em&gt; is searched for in the environment variables &lt;code id=&quot;index-0&quot;&gt;LANGUAGE&lt;/code&gt;, &lt;code id=&quot;index-1&quot;&gt;LC_ALL&lt;/code&gt;, &lt;code id=&quot;index-2&quot;&gt;LC_MESSAGES&lt;/code&gt;, and &lt;code id=&quot;index-3&quot;&gt;LANG&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;em&gt;도메인&lt;/em&gt; 을 로케일 디렉토리 &lt;em&gt;localedir에&lt;/em&gt; 바인드하십시오 . 보다 구체적으로 &lt;a href=&quot;#module-gettext&quot;&gt; &lt;code&gt;gettext&lt;/code&gt; &lt;/a&gt; 는 경로 (유닉스에서)를 사용하여 지정된 도메인의 바이너리 &lt;code&gt;.mo&lt;/code&gt; 파일을 찾습니다 . &lt;code&gt;&lt;em&gt;localedir&lt;/em&gt;/&lt;em&gt;language&lt;/em&gt;/LC_MESSAGES/&lt;em&gt;domain&lt;/em&gt;.mo&lt;/code&gt; . 여기서 환경 변수 &lt;code id=&quot;index-0&quot;&gt;LANGUAGE&lt;/code&gt; , &lt;code id=&quot;index-1&quot;&gt;LC_ALL&lt;/code&gt; , &lt;code id=&quot;index-2&quot;&gt;LC_MESSAGES&lt;/code&gt; 및 &lt;code id=&quot;index-3&quot;&gt;LANG&lt;/code&gt; 에서 &lt;em&gt;언어&lt;/em&gt; 를 검색합니다. 각기.</target>
        </trans-unit>
        <trans-unit id="6ef7c31f3723921d8fdf4d1ae7e78f574951d17b" translate="yes" xml:space="preserve">
          <source>Bind the socket to &lt;em&gt;address&lt;/em&gt;. The socket must not already be bound. (The format of &lt;em&gt;address&lt;/em&gt; depends on the address family &amp;mdash; refer to the &lt;a href=&quot;socket#module-socket&quot;&gt;&lt;code&gt;socket&lt;/code&gt;&lt;/a&gt; documentation for more information.) To mark the socket as re-usable (setting the &lt;code&gt;SO_REUSEADDR&lt;/code&gt; option), call the &lt;a href=&quot;#asyncore.dispatcher&quot;&gt;&lt;code&gt;dispatcher&lt;/code&gt;&lt;/a&gt; object&amp;rsquo;s &lt;code&gt;set_reuse_addr()&lt;/code&gt; method.</source>
          <target state="translated">소켓을 &lt;em&gt;주소에&lt;/em&gt; 바인드하십시오 . 소켓이 이미 바인드되어 있지 않아야합니다. ( &lt;em&gt;주소&lt;/em&gt; 형식은 &lt;em&gt;주소&lt;/em&gt; 패밀리에 따라 다릅니다 . 자세한 내용 은 &lt;a href=&quot;socket#module-socket&quot;&gt; &lt;code&gt;socket&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.) 소켓을 재사용 가능으로 표시하려면 ( &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 옵션 설정 ) &lt;a href=&quot;#asyncore.dispatcher&quot;&gt; &lt;code&gt;dispatcher&lt;/code&gt; &lt;/a&gt; 오브젝트의 &lt;code&gt;set_reuse_addr()&lt;/code&gt; 메소드를 호출하십시오 .</target>
        </trans-unit>
        <trans-unit id="04f4492e920673119f99caa126daf7111e8679ef" translate="yes" xml:space="preserve">
          <source>Bind the socket to &lt;em&gt;address&lt;/em&gt;. The socket must not already be bound. (The format of &lt;em&gt;address&lt;/em&gt; depends on the address family &amp;mdash; see above.)</source>
          <target state="translated">소켓을 &lt;em&gt;주소에&lt;/em&gt; 바인드하십시오 . 소켓이 이미 바인드되어 있지 않아야합니다. &lt;em&gt;주소&lt;/em&gt; 형식은 &lt;em&gt;주소&lt;/em&gt; 패밀리에 따라 다릅니다 (위 참조).</target>
        </trans-unit>
        <trans-unit id="de75e0400dc3db591ad5734f114577fa0875a522" translate="yes" xml:space="preserve">
          <source>Bind the socket to a free port and return the port number. Relies on ephemeral ports in order to ensure we are using an unbound port. This is important as many tests may be running simultaneously, especially in a buildbot environment. This method raises an exception if the &lt;code&gt;sock.family&lt;/code&gt; is &lt;a href=&quot;socket#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;sock.type&lt;/code&gt; is &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt;&lt;code&gt;SOCK_STREAM&lt;/code&gt;&lt;/a&gt;, and the socket has &lt;code&gt;SO_REUSEADDR&lt;/code&gt; or &lt;code&gt;SO_REUSEPORT&lt;/code&gt; set on it. Tests should never set these socket options for TCP/IP sockets. The only case for setting these options is testing multicasting via multiple UDP sockets.</source>
          <target state="translated">소켓을 빈 포트에 바인딩하고 포트 번호를 반환하십시오. 언 바운드 포트를 사용하기 위해 임시 포트에 의존합니다. 많은 테스트가 동시에 빌드 봇 환경에서 동시에 실행될 수 있으므로 중요합니다. &lt;code&gt;sock.family&lt;/code&gt; 가 &lt;a href=&quot;socket#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;sock.type&lt;/code&gt; 이 &lt;a href=&quot;socket#socket.SOCK_STREAM&quot;&gt; &lt;code&gt;SOCK_STREAM&lt;/code&gt; &lt;/a&gt; 이고 소켓에 &lt;code&gt;SO_REUSEADDR&lt;/code&gt; 또는 &lt;code&gt;SO_REUSEPORT&lt;/code&gt; 가 설정된 경우이 메소드는 예외를 발생시킵니다 . 테스트는 TCP / IP 소켓에 대해 이러한 소켓 옵션을 설정하지 않아야합니다. 이러한 옵션을 설정하는 유일한 경우는 여러 UDP 소켓을 통한 멀티 캐스팅을 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1fd8b3b29ad1340858fecc05585a82b44392fdd8" translate="yes" xml:space="preserve">
          <source>Bindings and Events</source>
          <target state="translated">바인딩 및 이벤트</target>
        </trans-unit>
        <trans-unit id="f86116810e0f75c5cdd1a62f7f2104592005bc20" translate="yes" xml:space="preserve">
          <source>Bit fields in structures and unions</source>
          <target state="translated">구조와 공용체의 비트 필드</target>
        </trans-unit>
        <trans-unit id="320415496f3946f94011e0ced3cddcdc515c3da5" translate="yes" xml:space="preserve">
          <source>Bit-mask</source>
          <target state="translated">Bit-mask</target>
        </trans-unit>
        <trans-unit id="10b264ac40d76c9c94d3cc50bd7202a39865e32f" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract a character</source>
          <target state="translated">문자를 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="0b5b215b81a34d81da07b12a57a05ded49214f16" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract attributes</source>
          <target state="translated">속성을 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="2061b16edd78d2e593621fabec13afb636e32ce9" translate="yes" xml:space="preserve">
          <source>Bit-mask to extract color-pair field information</source>
          <target state="translated">색상 쌍 필드 정보를 추출하는 비트 마스크</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">비트와</target>
        </trans-unit>
        <trans-unit id="5fef320a5b6e9f946d0c0be2f1804caae7326297" translate="yes" xml:space="preserve">
          <source>Bitwise Exclusive Or</source>
          <target state="translated">비트 단위 독점 또는</target>
        </trans-unit>
        <trans-unit id="92108ddfd25fd3b1ca3cfcbb1ac3acde1d93a1d2" translate="yes" xml:space="preserve">
          <source>Bitwise Inversion</source>
          <target state="translated">비트 반전</target>
        </trans-unit>
        <trans-unit id="c6d024785d8011a85a2c45a248d86ff4be52b077" translate="yes" xml:space="preserve">
          <source>Bitwise Operations on Integer Types</source>
          <target state="translated">정수 유형의 비트 단위 연산</target>
        </trans-unit>
        <trans-unit id="5b0861023775ab83f9aeb2c2b3492420398fae85" translate="yes" xml:space="preserve">
          <source>Bitwise Or</source>
          <target state="translated">비트 단위 또는</target>
        </trans-unit>
        <trans-unit id="2e17feeadb67d1865e9a3b140b95f9721af9f8fa" translate="yes" xml:space="preserve">
          <source>Bitwise operations only make sense for integers. The result of bitwise operations is calculated as though carried out in two&amp;rsquo;s complement with an infinite number of sign bits.</source>
          <target state="translated">비트 단위 연산은 정수에만 의미가 있습니다. 비트 단위 연산의 결과는 무한한 수의 부호 비트로 2의 보수로 수행되는 것처럼 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b406fb57b29fc76f71864fbb37f0238045f84d9d" translate="yes" xml:space="preserve">
          <source>Black</source>
          <target state="translated">Black</target>
        </trans-unit>
        <trans-unit id="480135dda7d845bc82b347dfaa91bf347ee099af" translate="yes" xml:space="preserve">
          <source>Blink mode</source>
          <target state="translated">깜박임 모드</target>
        </trans-unit>
        <trans-unit id="cfbe395b6ff593ced03bac36c099d59799a6252c" translate="yes" xml:space="preserve">
          <source>Block device required</source>
          <target state="translated">필요한 블록 장치</target>
        </trans-unit>
        <trans-unit id="40f4277d9e2e9642b7c7082b91e613d62eab845f" translate="yes" xml:space="preserve">
          <source>Block device.</source>
          <target state="translated">장치를 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="2bb009addf624a9cc048897e81f81ead20e469bf" translate="yes" xml:space="preserve">
          <source>Block for &lt;em&gt;delay&lt;/em&gt; seconds.</source>
          <target state="translated">&lt;em&gt;지연 시간&lt;/em&gt; 동안 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="8fb197cebcc8478cf7165d9dc1e9b4feeed49cd6" translate="yes" xml:space="preserve">
          <source>Block until all items in the queue have been gotten and processed.</source>
          <target state="translated">대기열의 모든 항목을 가져 와서 처리 할 때까지 차단하십시오.</target>
        </trans-unit>
        <trans-unit id="5c76bb4026cbe07b72909b50d70c6d76ce00a1bf" translate="yes" xml:space="preserve">
          <source>Block until all items in the queue have been received and processed.</source>
          <target state="translated">대기열의 모든 항목이 수신되어 처리 될 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="4270873346fe4ac8413b26a31ec9f3e286371ccc" translate="yes" xml:space="preserve">
          <source>Block until the internal flag is true. If the internal flag is true on entry, return immediately. Otherwise, block until another thread calls &lt;a href=&quot;#threading.Event.set&quot;&gt;&lt;code&gt;set()&lt;/code&gt;&lt;/a&gt; to set the flag to true, or until the optional timeout occurs.</source>
          <target state="translated">내부 플래그가 true가 될 때까지 차단하십시오. 시작시 내부 플래그가 true이면 즉시 리턴하십시오. 그렇지 않으면 다른 스레드가 &lt;a href=&quot;#threading.Event.set&quot;&gt; &lt;code&gt;set()&lt;/code&gt; &lt;/a&gt; 을 호출 하여 플래그를 true로 설정하거나 선택적 시간 종료가 발생할 때까지 차단 하십시오.</target>
        </trans-unit>
        <trans-unit id="d2058396a2147f5165863444e9ce5b13713a8108" translate="yes" xml:space="preserve">
          <source>Blocking (CPU-bound) code should not be called directly. For example, if a function performs a CPU-intensive calculation for 1 second, all concurrent asyncio Tasks and IO operations would be delayed by 1 second.</source>
          <target state="translated">블로킹 (CPU- 바운드) 코드는 직접 호출하면 안됩니다. 예를 들어, 함수가 1 초 동안 CPU를 많이 사용하는 계산을 수행하면 모든 동시 asyncio 작업 및 IO 작업이 1 초 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="323ffdcd95156ec320100a2972820824ccb6d91f" translate="yes" xml:space="preserve">
          <source>BlockingIOError</source>
          <target state="translated">BlockingIOError</target>
        </trans-unit>
        <trans-unit id="92a08db9399061aa0f5eacfe511b7a6126dc9df0" translate="yes" xml:space="preserve">
          <source>BlockingIOError.characters_written</source>
          <target state="translated">BlockingIOError.characters_written</target>
        </trans-unit>
        <trans-unit id="dddf0e18cab12f3c2b4594834412adc72d47d3d6" translate="yes" xml:space="preserve">
          <source>Blocks until all items in the queue have been gotten and processed.</source>
          <target state="translated">대기열의 모든 항목을 가져 와서 처리 할 때까지 차단합니다.</target>
        </trans-unit>
        <trans-unit id="7d44bc449c2a26374800a503f10f3d8949505f40" translate="yes" xml:space="preserve">
          <source>Blue</source>
          <target state="translated">Blue</target>
        </trans-unit>
        <trans-unit id="15913dcb3fc24a61ba6adcc4afcd21df3d2a5af6" translate="yes" xml:space="preserve">
          <source>Body-encode the string &lt;em&gt;string&lt;/em&gt;.</source>
          <target state="translated">문자열 &lt;em&gt;string을&lt;/em&gt; 본문으로 인코딩하십시오 .</target>
        </trans-unit>
        <trans-unit id="6718f0f90ac337fe59d6d08c1ec08dbb38b7cc92" translate="yes" xml:space="preserve">
          <source>Bold mode</source>
          <target state="translated">볼드 모드</target>
        </trans-unit>
        <trans-unit id="beddf259d4873df4879b851076af94752cb94065" translate="yes" xml:space="preserve">
          <source>Book by John Grayson (ISBN 1-884777-81-3).</source>
          <target state="translated">존 그레이슨 (ISBN 1-884777-81-3)이 예약 함.</target>
        </trans-unit>
        <trans-unit id="5deb34b87b8d065639971c2d9e0fede0fcbaa391" translate="yes" xml:space="preserve">
          <source>Book by John Ousterhout, the inventor of Tcl.</source>
          <target state="translated">Tcl의 발명가 인 John Ousterhout가 예약합니다.</target>
        </trans-unit>
        <trans-unit id="cba993e6c506a168367bd3edaf5e342b70b7db99" translate="yes" xml:space="preserve">
          <source>Book by Mark Lutz, has excellent coverage of Tkinter.</source>
          <target state="translated">마크 루츠 (Mark Lutz)가 예약했으며, Tkinter에 대한 뛰어난 커버리지를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="51b03cb2dbfc1444695bab06adfaeb141fdc235f" translate="yes" xml:space="preserve">
          <source>Book by Mark Roseman about building attractive and modern graphical user interfaces with Python and Tkinter.</source>
          <target state="translated">Python 및 Tkinter를 사용하여 매력적이고 현대적인 그래픽 사용자 인터페이스를 구축하는 방법에 대해 Mark Roseman이 예약하십시오.</target>
        </trans-unit>
        <trans-unit id="786bfd749778b9b25aa01178659c90f4e19011ff" translate="yes" xml:space="preserve">
          <source>Bookkeeping functions</source>
          <target state="translated">부기 기능</target>
        </trans-unit>
        <trans-unit id="f8a8b062c380ba221961a2f8e03c873f4208921d" translate="yes" xml:space="preserve">
          <source>Boolean Operations &amp;mdash; &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;not&lt;/code&gt;</source>
          <target state="translated">부울 작업 - &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;not&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="21e36e8bd93b3ea3b4b742ce8bb2a6ec3b2ab721" translate="yes" xml:space="preserve">
          <source>Boolean Values</source>
          <target state="translated">부울 값</target>
        </trans-unit>
        <trans-unit id="88306a31305db52140bbd33e277c2a177ea102f3" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether or not the module&amp;rsquo;s &amp;ldquo;origin&amp;rdquo; attribute refers to a loadable location.</source>
          <target state="translated">모듈의 &quot;origin&quot;속성이로드 가능한 위치를 나타내는 지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="524796582178b3ce40400d6b1bce1725e41cb620" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the device has been closed.</source>
          <target state="translated">장치가 닫혔는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="3b8b1c68be3b092bc5a2b53c093951beb9f55cb0" translate="yes" xml:space="preserve">
          <source>Boolean operator tokens.</source>
          <target state="translated">부울 연산자 토큰.</target>
        </trans-unit>
        <trans-unit id="7ae5f84c90d6d770c192b8c5eb2f83cd02192067" translate="yes" xml:space="preserve">
          <source>Boolean that should be set before &lt;a href=&quot;#http.server.BaseHTTPRequestHandler.handle_one_request&quot;&gt;&lt;code&gt;handle_one_request()&lt;/code&gt;&lt;/a&gt; returns, indicating if another request may be expected, or if the connection should be shut down.</source>
          <target state="translated">&lt;a href=&quot;#http.server.BaseHTTPRequestHandler.handle_one_request&quot;&gt; &lt;code&gt;handle_one_request()&lt;/code&gt; &lt;/a&gt; 반환 되기 전에 설정해야하는 부울 로, 다른 요청이 필요한지 또는 연결을 종료해야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="33269d07fca93166bdf65e0bd7b3092befe1aa4a" translate="yes" xml:space="preserve">
          <source>Boolean value of &lt;code&gt;Enum&lt;/code&gt; classes and members</source>
          <target state="translated">&lt;code&gt;Enum&lt;/code&gt; 클래스 및 멤버 의 부울 값</target>
        </trans-unit>
        <trans-unit id="cb62ebe2f6b3f6e458c9478ab40f08a930df3242" translate="yes" xml:space="preserve">
          <source>Boolean value that is normally &lt;code&gt;False&lt;/code&gt;, but is set to &lt;code&gt;True&lt;/code&gt; if an &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt;&lt;code&gt;enable()&lt;/code&gt;&lt;/a&gt; command is successfully issued for the &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; capability.</source>
          <target state="translated">일반적으로 부울 값입니다 &lt;code&gt;False&lt;/code&gt; 하지만 설정되어 &lt;code&gt;True&lt;/code&gt; 는 IF &lt;a href=&quot;#imaplib.IMAP4.enable&quot;&gt; &lt;code&gt;enable()&lt;/code&gt; &lt;/a&gt; 명령이 성공적으로 발행되어 &lt;code&gt;UTF8=ACCEPT&lt;/code&gt; 능력을.</target>
        </trans-unit>
        <trans-unit id="3d12838d2902df351d82539f77e5196fe220e18b" translate="yes" xml:space="preserve">
          <source>Boolean value. If &lt;code&gt;True&lt;/code&gt;, increment and decrement buttons will cycle from the &lt;code&gt;to&lt;/code&gt; value to the &lt;code&gt;from&lt;/code&gt; value or the &lt;code&gt;from&lt;/code&gt; value to the &lt;code&gt;to&lt;/code&gt; value, respectively.</source>
          <target state="translated">부울 값. 만약 &lt;code&gt;True&lt;/code&gt; , 증가 및 감소 버튼 것이다로부터주기 &lt;code&gt;to&lt;/code&gt; 받는 값 &lt;code&gt;from&lt;/code&gt; 값 또는 &lt;code&gt;from&lt;/code&gt; 받는 값 &lt;code&gt;to&lt;/code&gt; 값이 각각.</target>
        </trans-unit>
        <trans-unit id="9245a6ae2d0c51a552e5f3f9fc78c7e345278524" translate="yes" xml:space="preserve">
          <source>Boolean value. If set, the widget selection is linked to the Window Manager selection (which can be returned by invoking Misc.selection_get, for example).</source>
          <target state="translated">부울 값. 설정된 경우 위젯 선택은 창 관리자 선택에 연결됩니다 (예 : Misc.selection_get을 호출하여 리턴 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="2fa9e93e36190ed14338b888b01919ba853c4130" translate="yes" xml:space="preserve">
          <source>Boolean values are the two constant objects &lt;code&gt;False&lt;/code&gt; and &lt;code&gt;True&lt;/code&gt;. They are used to represent truth values (although other values can also be considered false or true). In numeric contexts (for example when used as the argument to an arithmetic operator), they behave like the integers 0 and 1, respectively. The built-in function &lt;a href=&quot;functions#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; can be used to convert any value to a Boolean, if the value can be interpreted as a truth value (see section &lt;a href=&quot;#truth&quot;&gt;Truth Value Testing&lt;/a&gt; above).</source>
          <target state="translated">부울 값은 두 개의 상수 객체 &lt;code&gt;False&lt;/code&gt; 및 &lt;code&gt;True&lt;/code&gt; 입니다. 그것들은 진리 값을 나타내는 데 사용됩니다 (다른 값도 거짓 또는 참으로 간주 될 수 있음). 숫자 컨텍스트 (예 : 산술 연산자의 인수로 사용되는 경우)에서는 각각 정수 0과 1처럼 동작합니다. 값을 진리 값으로 해석 할 수있는 경우 내장 함수 &lt;a href=&quot;functions#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt; 을 사용하여 값을 부울로 변환 할 수 있습니다 ( 위의 &lt;a href=&quot;#truth&quot;&gt;진리 값 테스트&lt;/a&gt; 섹션 참조 ).</target>
        </trans-unit>
        <trans-unit id="d18c0bfba1757c5e30d0bc7a733fee5173697958" translate="yes" xml:space="preserve">
          <source>Boolean, &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">부울, &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="720fd7e99ee4b1def571b8830a99782dae891a6d" translate="yes" xml:space="preserve">
          <source>Bootstraps &lt;code&gt;pip&lt;/code&gt; into the current or designated environment.</source>
          <target state="translated">부트 스트랩 은 현재 환경이나 지정된 환경으로 &lt;code&gt;pip&lt;/code&gt; 니다.</target>
        </trans-unit>
        <trans-unit id="71d8f86363b63766bbf05a4f680a13a4e028d724" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt;&lt;code&gt;create_subprocess_exec()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt;&lt;code&gt;create_subprocess_shell()&lt;/code&gt;&lt;/a&gt; functions return instances of the &lt;em&gt;Process&lt;/em&gt; class. &lt;em&gt;Process&lt;/em&gt; is a high-level wrapper that allows communicating with subprocesses and watching for their completion.</source>
          <target state="translated">두 &lt;a href=&quot;#asyncio.create_subprocess_exec&quot;&gt; &lt;code&gt;create_subprocess_exec()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#asyncio.create_subprocess_shell&quot;&gt; &lt;code&gt;create_subprocess_shell()&lt;/code&gt; &lt;/a&gt; 함수는 인스턴스 반환 &lt;em&gt;프로세스&lt;/em&gt; 클래스. &lt;em&gt;프로세스&lt;/em&gt; 는 하위 프로세스와 통신하고 완료를 감시 할 수있는 고급 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0678a3c848604f505fcb4b2ec36b17b684c82040" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#patch&quot;&gt;patch&lt;/a&gt; and &lt;a href=&quot;#patch-object&quot;&gt;patch.object&lt;/a&gt; correctly patch and restore descriptors: class methods, static methods and properties. You should patch these on the &lt;em&gt;class&lt;/em&gt; rather than an instance. They also work with &lt;em&gt;some&lt;/em&gt; objects that proxy attribute access, like the &lt;a href=&quot;http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198&quot;&gt;django settings object&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#patch&quot;&gt;patch&lt;/a&gt; 및 &lt;a href=&quot;#patch-object&quot;&gt;patch.object는&lt;/a&gt; 모두 설명자 (클래스 메소드, 정적 메소드 및 특성)를 올바르게 패치하고 복원합니다. 인스턴스가 아닌 &lt;em&gt;클래스&lt;/em&gt; 에서 패치해야 합니다. 또한 &lt;a href=&quot;http://www.voidspace.org.uk/python/weblog/arch_d7_2010_12_04.shtml#e1198&quot;&gt;django settings object&lt;/a&gt; 와 같이 속성 액세스를 프록시 하는 &lt;em&gt;일부&lt;/em&gt; 객체 와 함께 작동 합니다 .</target>
        </trans-unit>
        <trans-unit id="76150bda2b159ac2e4297d9994115a0259b6b98e" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;#set&quot;&gt;&lt;code&gt;set&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#frozenset&quot;&gt;&lt;code&gt;frozenset&lt;/code&gt;&lt;/a&gt; support set to set comparisons. Two sets are equal if and only if every element of each set is contained in the other (each is a subset of the other). A set is less than another set if and only if the first set is a proper subset of the second set (is a subset, but is not equal). A set is greater than another set if and only if the first set is a proper superset of the second set (is a superset, but is not equal).</source>
          <target state="translated">두 &lt;a href=&quot;#set&quot;&gt; &lt;code&gt;set&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#frozenset&quot;&gt; &lt;code&gt;frozenset&lt;/code&gt; &lt;/a&gt; 세트 비교에 지원 세트입니다. 각 세트의 모든 요소가 다른 세트에 포함 된 경우에만 두 세트가 동일합니다 (각 세트는 다른 세트의 하위 세트 임). 첫 번째 세트가 두 번째 세트의 적절한 서브 세트 인 경우에만 세트가 다른 세트보다 작습니다 (하위 서브 세트이지만 같지 않음). 첫 번째 세트가 두 번째 세트의 적절한 수퍼 세트 인 경우에만 (세트는 수퍼 세트이지만 같지 않은 경우) 세트는 다른 세트보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="da97eda7ef7c14e12c43a76638620729271ea928" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#hasattr&quot;&gt;&lt;code&gt;hasattr()&lt;/code&gt;&lt;/a&gt; can trigger code execution when fetching or checking for the existence of attributes. Descriptors, like properties, will be invoked and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; may be called.</source>
          <target state="translated">두 &lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#hasattr&quot;&gt; &lt;code&gt;hasattr()&lt;/code&gt; &lt;/a&gt; 가져 오는 또는 속성의 존재 여부를 검사 할 때 코드 실행을 트리거 할 수 있습니다. 속성과 같은 설명자가 호출되고 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6378a682eec1b6aafdd9cf2087b6ced6760eeb7a" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;functions#getattr&quot;&gt;&lt;code&gt;getattr()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;functions#hasattr&quot;&gt;&lt;code&gt;hasattr()&lt;/code&gt;&lt;/a&gt; can trigger code execution when fetching or checking for the existence of attributes. Descriptors, like properties, will be invoked and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt;&lt;code&gt;__getattr__()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt;&lt;code&gt;__getattribute__()&lt;/code&gt;&lt;/a&gt; may be called.</source>
          <target state="translated">&lt;a href=&quot;functions#getattr&quot;&gt; &lt;code&gt;getattr()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;functions#hasattr&quot;&gt; &lt;code&gt;hasattr()&lt;/code&gt; &lt;/a&gt; 모두 속성의 존재 여부를 가져 오거나 확인할 때 코드 실행을 트리거 할 수 있습니다. 속성과 같은 설명자가 호출되고 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattr__&quot;&gt; &lt;code&gt;__getattr__()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__getattribute__&quot;&gt; &lt;code&gt;__getattribute__()&lt;/code&gt; &lt;/a&gt; 가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc6402ce03954c13678974692e26ec34f0d6f91d" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; and Netscape cookies are covered. RFC 2965 handling is switched off by default.</source>
          <target state="translated">모두 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-14&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 및 Netscape 쿠키가 적용됩니다. RFC 2965 처리는 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70830bd6073fa55b1bb77c2a936de0cd6ec08ac0" translate="yes" xml:space="preserve">
          <source>Both &lt;em&gt;input_charset&lt;/em&gt; and &lt;em&gt;output_charset&lt;/em&gt; must have Unicode codec entries in the module&amp;rsquo;s character set-to-codec mapping; use &lt;a href=&quot;#email.charset.add_codec&quot;&gt;&lt;code&gt;add_codec()&lt;/code&gt;&lt;/a&gt; to add codecs the module does not know about. See the &lt;a href=&quot;codecs#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s documentation for more information.</source>
          <target state="translated">&lt;em&gt;input_charset&lt;/em&gt; 및 &lt;em&gt;output_charset&lt;/em&gt; 에는 모두 모듈의 문자 집합 코덱 매핑에 유니 코드 코덱 항목이 있어야합니다. &lt;a href=&quot;#email.charset.add_codec&quot;&gt; &lt;code&gt;add_codec()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 모듈이 모르는 코덱을 추가하십시오. 자세한 내용은 &lt;a href=&quot;codecs#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; 모듈 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ead411397e614cee6d46ba321f1ee1902f0d3551" translate="yes" xml:space="preserve">
          <source>Both binary and decimal floating point are implemented in terms of published standards. While the built-in float type exposes only a modest portion of its capabilities, the decimal module exposes all required parts of the standard. When needed, the programmer has full control over rounding and signal handling. This includes an option to enforce exact arithmetic by using exceptions to block any inexact operations.</source>
          <target state="translated">이진 및 십진 부동 소수점은 모두 공개 된 표준에 따라 구현됩니다. 내장 된 float 유형은 기능의 일부만 노출하지만 10 진수 모듈은 표준의 모든 필수 부분을 노출합니다. 필요한 경우 프로그래머는 반올림 및 신호 처리를 완벽하게 제어 할 수 있습니다. 여기에는 예외를 사용하여 부정확 한 연산을 차단하여 정확한 산술을 시행하는 옵션이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="412827b4525eb3aa564b3e476acee9a6c164827a" translate="yes" xml:space="preserve">
          <source>Both bytes and bytearray objects support the &lt;a href=&quot;#typesseq-common&quot;&gt;common&lt;/a&gt; sequence operations. They interoperate not just with operands of the same type, but with any &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands.</source>
          <target state="translated">바이트와 ​​바이트 배열 객체는 &lt;a href=&quot;#typesseq-common&quot;&gt;공통&lt;/a&gt; 시퀀스 연산을 지원합니다 . 그들은 같은 유형의 피연산자뿐만 아니라 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​같은 객체&lt;/a&gt; 와도 상호 운용 됩니다. 이러한 유연성으로 인해 오류없이 작업에서 자유롭게 혼합 할 수 있습니다. 그러나 결과의 반환 유형은 피연산자의 순서에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b726eeef2b94c2c79f2826c463146ce420620ef3" translate="yes" xml:space="preserve">
          <source>Both bytes and bytearray objects support the &lt;a href=&quot;#typesseq-common&quot;&gt;common&lt;/a&gt; sequence operations. They interoperate not just with operands of the same type, but with any &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;bytes-like object&lt;/a&gt;. Due to this flexibility, they can be freely mixed in operations without causing errors. However, the return type of the result may depend on the order of operands.</source>
          <target state="translated">bytes 및 bytearray 객체는 모두 &lt;a href=&quot;#typesseq-common&quot;&gt;공통&lt;/a&gt; 시퀀스 작업을 지원합니다 . 동일한 유형의 피연산자뿐만 아니라 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-bytes-like-object&quot;&gt;바이트와 ​​유사한 객체&lt;/a&gt; 와도 상호 운용 됩니다. 이러한 유연성으로 인해 오류없이 작업에 자유롭게 혼합 될 수 있습니다. 그러나 결과의 반환 유형은 피연산자의 순서에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906dcaa49ef8791b7ba8c7a06dc1b0bb61aebfb9" translate="yes" xml:space="preserve">
          <source>Both functions return a &lt;code&gt;Document&lt;/code&gt; object representing the content of the document.</source>
          <target state="translated">두 함수 모두 &lt;code&gt;Document&lt;/code&gt; 반환 의 내용을 나타내는 객체를 .</target>
        </trans-unit>
        <trans-unit id="9308f7b7021d711fb78ce76e026ff4c70b252ac9" translate="yes" xml:space="preserve">
          <source>Both of these factory functions are called with the result type as first argument, and the callback functions expected argument types as the remaining arguments.</source>
          <target state="translated">이러한 팩토리 함수는 결과 유형을 첫 번째 인수로 사용하고 콜백 함수는 인수 유형을 나머지 인수로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="da4ed773045485a36fd9e210e667a5f7330053db" translate="yes" xml:space="preserve">
          <source>Both parameters are raw strings of the names. &lt;code&gt;asname&lt;/code&gt; can be &lt;code&gt;None&lt;/code&gt; if the regular name is to be used.</source>
          <target state="translated">두 매개 변수는 이름의 원시 문자열입니다. 일반 이름이 사용되는 경우 &lt;code&gt;asname&lt;/code&gt; 은 &lt;code&gt;None&lt;/code&gt; 이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e40771c73ac3142db1cd6a2924473530d9c63415" translate="yes" xml:space="preserve">
          <source>Both patterns and strings to be searched can be Unicode strings (&lt;a href=&quot;stdtypes#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;) as well as 8-bit strings (&lt;a href=&quot;stdtypes#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;). However, Unicode strings and 8-bit strings cannot be mixed: that is, you cannot match a Unicode string with a byte pattern or vice-versa; similarly, when asking for a substitution, the replacement string must be of the same type as both the pattern and the search string.</source>
          <target state="translated">검색 할 패턴과 문자열은 모두 8 비트 문자열 ( &lt;a href=&quot;stdtypes#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; )뿐만 아니라 유니 코드 문자열 ( &lt;a href=&quot;stdtypes#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; ) 일 수 있습니다. ) . 그러나 유니 코드 문자열과 8 비트 문자열은 혼합 될 수 없습니다. 즉, 유니 코드 문자열을 바이트 패턴과 일치시킬 수 없으며 그 반대도 마찬가지입니다. 마찬가지로 대체를 요청할 때 대체 문자열은 패턴 및 검색 문자열과 동일한 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="60524711bf7cd6ddd3a6f75407a2f25953c838b6" translate="yes" xml:space="preserve">
          <source>Both the &lt;a href=&quot;#module-profile&quot;&gt;&lt;code&gt;profile&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#module-cProfile&quot;&gt;&lt;code&gt;cProfile&lt;/code&gt;&lt;/a&gt; modules provide the following functions:</source>
          <target state="translated">양쪽 &lt;a href=&quot;#module-profile&quot;&gt; &lt;code&gt;profile&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#module-cProfile&quot;&gt; &lt;code&gt;cProfile&lt;/code&gt; &lt;/a&gt; 모듈 다음 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a8fa6107edcf0d7fe5de5f35cf96f9376975a492" translate="yes" xml:space="preserve">
          <source>Both the HTTP and HTTPS transports support the URL syntax extension for HTTP Basic Authentication: &lt;code&gt;http://user:pass@host:port/path&lt;/code&gt;. The &lt;code&gt;user:pass&lt;/code&gt; portion will be base64-encoded as an HTTP &amp;lsquo;Authorization&amp;rsquo; header, and sent to the remote server as part of the connection process when invoking an XML-RPC method. You only need to use this if the remote server requires a Basic Authentication user and password. If an HTTPS URL is provided, &lt;em&gt;context&lt;/em&gt; may be &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt;&lt;code&gt;ssl.SSLContext&lt;/code&gt;&lt;/a&gt; and configures the SSL settings of the underlying HTTPS connection.</source>
          <target state="translated">HTTP 및 HTTPS 전송은 모두 HTTP 기본 인증을위한 URL 구문 확장을 지원합니다 ( &lt;code&gt;http://user:pass@host:port/path&lt;/code&gt; . &lt;code&gt;user:pass&lt;/code&gt; 부분은 HTTP &quot;허가&quot;헤더로서 Base64로 인코딩 및 XML-RPC 메소드를 호출 할 때 연결 프로세스의 일환으로 원격 서버로 전송 될 것이다. 원격 서버에 기본 인증 사용자 및 비밀번호가 필요한 경우에만이를 사용해야합니다. HTTPS URL이 제공되는 경우 &lt;em&gt;컨텍스트&lt;/em&gt; 는 &lt;a href=&quot;ssl#ssl.SSLContext&quot;&gt; &lt;code&gt;ssl.SSLContext&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 . 기본 HTTPS 연결의 SSL 설정을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="e1cca2d2cf2cc882468f5dfa827706c1805375d8" translate="yes" xml:space="preserve">
          <source>Both the regular Netscape cookie protocol and the protocol defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; are handled. RFC 2965 handling is switched off by default. &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; cookies are parsed as Netscape cookies and subsequently treated either as Netscape or RFC 2965 cookies according to the &amp;lsquo;policy&amp;rsquo; in effect. Note that the great majority of cookies on the Internet are Netscape cookies. &lt;a href=&quot;#module-http.cookiejar&quot;&gt;&lt;code&gt;http.cookiejar&lt;/code&gt;&lt;/a&gt; attempts to follow the de-facto Netscape cookie protocol (which differs substantially from that set out in the original Netscape specification), including taking note of the &lt;code&gt;max-age&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cookie-attributes introduced with RFC 2965.</source>
          <target state="translated">일반 Netscape 쿠키 프로토콜과 &lt;a href=&quot;https://tools.ietf.org/html/rfc2965.html&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;RFC 2965&lt;/strong&gt;&lt;/a&gt; 에 의해 정의 된 프로토콜 이 모두 처리됩니다. RFC 2965 처리는 기본적으로 해제되어 있습니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2109.html&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;RFC 2109&lt;/strong&gt;&lt;/a&gt; 쿠키는 Netscape 쿠키로 구문 분석 된 후 사실상 '정책'에 따라 Netscape 또는 RFC 2965 쿠키로 처리됩니다. 인터넷 쿠키의 대부분은 Netscape 쿠키입니다. &lt;a href=&quot;#module-http.cookiejar&quot;&gt; &lt;code&gt;http.cookiejar&lt;/code&gt; &lt;/a&gt; 는 RFC 2965에 도입 된 &lt;code&gt;max-age&lt;/code&gt; 및 &lt;code&gt;port&lt;/code&gt; 쿠키 속성 을 기록하는 것을 포함하여 사실상 Netscape 쿠키 프로토콜 (원래 Netscape 사양에서 설정 한 것과 실질적으로 다른)을 따르려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="7dbcf66e0e3c0a5508b03432a2f3df368782d85e" translate="yes" xml:space="preserve">
          <source>Both ways are described in section &lt;a href=&quot;#sqlite3-module-contents&quot;&gt;Module functions and constants&lt;/a&gt;, in the entries for the constants &lt;a href=&quot;#sqlite3.PARSE_DECLTYPES&quot;&gt;&lt;code&gt;PARSE_DECLTYPES&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#sqlite3.PARSE_COLNAMES&quot;&gt;&lt;code&gt;PARSE_COLNAMES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 가지 방법 모두 상수 &lt;a href=&quot;#sqlite3.PARSE_DECLTYPES&quot;&gt; &lt;code&gt;PARSE_DECLTYPES&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#sqlite3.PARSE_COLNAMES&quot;&gt; &lt;code&gt;PARSE_COLNAMES&lt;/code&gt; &lt;/a&gt; 에 대한 항목에서 &lt;a href=&quot;#sqlite3-module-contents&quot;&gt;모듈 함수 및 상수&lt;/a&gt; 섹션에 설명되어 있습니다. 있습니다.</target>
        </trans-unit>
        <trans-unit id="cce7f2f2f0dc525117a70d581d9c335212145e5b" translate="yes" xml:space="preserve">
          <source>Bottom</source>
          <target state="translated">Bottom</target>
        </trans-unit>
        <trans-unit id="e1dbd823dfdfc2d17617830a8f74f4d932681cc4" translate="yes" xml:space="preserve">
          <source>Bottom-left corner</source>
          <target state="translated">왼쪽 하단</target>
        </trans-unit>
        <trans-unit id="80aa1874eb99dccda2276381f9f4ffdec7143eaf" translate="yes" xml:space="preserve">
          <source>Bottom-right corner</source>
          <target state="translated">오른쪽 하단</target>
        </trans-unit>
        <trans-unit id="b2e002ea925c38ed1d57bf37ef5d40426841b702" translate="yes" xml:space="preserve">
          <source>Bounded Semaphore is a version of &lt;a href=&quot;#asyncio.Semaphore&quot;&gt;&lt;code&gt;Semaphore&lt;/code&gt;&lt;/a&gt; that raises a &lt;a href=&quot;exceptions#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt; in &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt;&lt;code&gt;release()&lt;/code&gt;&lt;/a&gt; if it increases the internal counter above the initial &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">경계 세마포어는 내부 카운터가 초기 &lt;em&gt;값&lt;/em&gt; 보다 증가하면 &lt;a href=&quot;#asyncio.Semaphore.release&quot;&gt; &lt;code&gt;release()&lt;/code&gt; &lt;/a&gt; 에서 &lt;a href=&quot;exceptions#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 를 발생 시키는 &lt;a href=&quot;#asyncio.Semaphore&quot;&gt; &lt;code&gt;Semaphore&lt;/code&gt; &lt;/a&gt; 의 버전입니다&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f27d46d2bc64f4ff7fc02b97b058167483c819b5" translate="yes" xml:space="preserve">
          <source>Bounded length deques provide functionality similar to the &lt;code&gt;tail&lt;/code&gt; filter in Unix:</source>
          <target state="translated">바운드 길이 디케는 &lt;code&gt;tail&lt;/code&gt; 과 유사한 기능을 제공합니다. Unix 필터 .</target>
        </trans-unit>
        <trans-unit id="a2756e8ad9a82c890a07dc2ba959f75c6165deec" translate="yes" xml:space="preserve">
          <source>BoundedSemaphore</source>
          <target state="translated">BoundedSemaphore</target>
        </trans-unit>
        <trans-unit id="db506c7b5783724a0ae667647def25dde4ac8c16" translate="yes" xml:space="preserve">
          <source>Branch-Call-Jump (BCJ) filters:</source>
          <target state="translated">BCJ (Branch-Call-Jump) 필터 :</target>
        </trans-unit>
        <trans-unit id="6818e738c2b21bdaaa174d945a5a8d955f9b4660" translate="yes" xml:space="preserve">
          <source>Break internal references within the DOM so that it will be garbage collected on versions of Python without cyclic GC. Even when cyclic GC is available, using this can make large amounts of memory available sooner, so calling this on DOM objects as soon as they are no longer needed is good practice. This only needs to be called on the &lt;code&gt;Document&lt;/code&gt; object, but may be called on child nodes to discard children of that node.</source>
          <target state="translated">주기적 GC없이 파이썬 버전에서 가비지 수집되도록 DOM 내에서 내부 참조를 해제하십시오. 주기적 GC가 사용 가능하더라도이를 사용하면 대량의 메모리를 더 빨리 사용할 수 있으므로 더 이상 필요하지 않은 즉시 DOM 오브젝트에서이를 호출하는 것이 좋습니다. &lt;code&gt;Document&lt;/code&gt; 객체 에서만 호출 하면되지만 해당 노드의 하위를 삭제하기 위해 하위 노드에서 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="057f53976b47c840e7d4ea51556fe76a4983b160" translate="yes" xml:space="preserve">
          <source>Break key (unreliable)</source>
          <target state="translated">브레이크 키 (신뢰할 수 없음)</target>
        </trans-unit>
        <trans-unit id="26d339cfcc10acc619584ccfcecd8aee58a08229" translate="yes" xml:space="preserve">
          <source>Breakpoints are indexed by number through a list called &lt;code&gt;bpbynumber&lt;/code&gt; and by &lt;code&gt;(file, line)&lt;/code&gt; pairs through &lt;code&gt;bplist&lt;/code&gt;. The former points to a single instance of class &lt;a href=&quot;#bdb.Breakpoint&quot;&gt;&lt;code&gt;Breakpoint&lt;/code&gt;&lt;/a&gt;. The latter points to a list of such instances since there may be more than one breakpoint per line.</source>
          <target state="translated">중단 점은 &lt;code&gt;bpbynumber&lt;/code&gt; 라는 목록을 통해 번호로, bplist 를 통해 &lt;code&gt;(file, line)&lt;/code&gt; 쌍으로 &lt;code&gt;bplist&lt;/code&gt; 됩니다. 전자는 &lt;a href=&quot;#bdb.Breakpoint&quot;&gt; &lt;code&gt;Breakpoint&lt;/code&gt; &lt;/a&gt; 클래스의 단일 인스턴스를 가리 킵니다 . 후자는 줄당 하나 이상의 중단 점이있을 수 있으므로 이러한 인스턴스 목록을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="b10a6960c4012f359c0ce6bee9b19ff172792a7d" translate="yes" xml:space="preserve">
          <source>Brent Welch&amp;rsquo;s encyclopedic book.</source>
          <target state="translated">브렌트 웰치의 백과 사전.</target>
        </trans-unit>
        <trans-unit id="5457d94057ed4418eb771b358e421dae5522d307" translate="yes" xml:space="preserve">
          <source>Broadly speaking, &lt;code&gt;d.strftime(fmt)&lt;/code&gt; acts like the &lt;a href=&quot;time#module-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt; module&amp;rsquo;s &lt;code&gt;time.strftime(fmt, d.timetuple())&lt;/code&gt; although not all objects support a &lt;code&gt;timetuple()&lt;/code&gt; method.</source>
          <target state="translated">일반적으로 &lt;code&gt;d.strftime(fmt)&lt;/code&gt; 은 모든 객체가 &lt;code&gt;timetuple()&lt;/code&gt; 메서드를 지원하지는 않지만 &lt;a href=&quot;time#module-time&quot;&gt; &lt;code&gt;time&lt;/code&gt; &lt;/a&gt; 모듈의 &lt;code&gt;time.strftime(fmt, d.timetuple())&lt;/code&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">깨진 파이프</target>
        </trans-unit>
        <trans-unit id="f987aa52401269ae9bd2277e6533a55308a7fc04" translate="yes" xml:space="preserve">
          <source>Broken pipe: write to pipe with no readers.</source>
          <target state="translated">깨진 파이프 : 판독기없이 파이프에 씁니다.</target>
        </trans-unit>
        <trans-unit id="46eaefda847b8f294ab091c272ac7c3caec75b7d" translate="yes" xml:space="preserve">
          <source>BrokenPipeError</source>
          <target state="translated">BrokenPipeError</target>
        </trans-unit>
        <trans-unit id="65cda754ede1327c252b27907e2e257c94decd6f" translate="yes" xml:space="preserve">
          <source>Browser Controller Objects</source>
          <target state="translated">브라우저 컨트롤러 객체</target>
        </trans-unit>
        <trans-unit id="a327e47ded8f65f6d258b4a730e569ee168be6db" translate="yes" xml:space="preserve">
          <source>Browser controllers provide these methods which parallel three of the module-level convenience functions:</source>
          <target state="translated">브라우저 컨트롤러는 다음 세 가지 모듈 수준 편의 기능과 유사한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="cce48398db484398ea1c477d2844426c417b73bf" translate="yes" xml:space="preserve">
          <source>Buffer overflow</source>
          <target state="translated">버퍼 오버 플로우</target>
        </trans-unit>
        <trans-unit id="52b12a6415af8c93a85ddb213e23fb21922c5ef9" translate="yes" xml:space="preserve">
          <source>Buffer size in bytes for sending a file-like message body.</source>
          <target state="translated">파일과 같은 메시지 본문을 보내기위한 버퍼 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="25d5353daf56aa3d45af53312311f4d3864fffdd" translate="yes" xml:space="preserve">
          <source>Buffer the bytes &lt;em&gt;data&lt;/em&gt; for transmission to the client. It&amp;rsquo;s okay if this method actually transmits the data; &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt;&lt;code&gt;BaseHandler&lt;/code&gt;&lt;/a&gt; just separates write and flush operations for greater efficiency when the underlying system actually has such a distinction.</source>
          <target state="translated">클라이언트로 전송하기 위해 바이트 &lt;em&gt;데이터&lt;/em&gt; 를 버퍼링하십시오 . 이 방법이 실제로 데이터를 전송해도 괜찮습니다. &lt;a href=&quot;#wsgiref.handlers.BaseHandler&quot;&gt; &lt;code&gt;BaseHandler&lt;/code&gt; &lt;/a&gt; 는 쓰기 및 플러시 작업을 분리하여 기본 시스템에 실제로 이러한 구별이있을 때 효율성을 향상시킵니다.</target>
        </trans-unit>
        <trans-unit id="657141fd493f1544370d627da1300193e53e95d7" translate="yes" xml:space="preserve">
          <source>Buffer underflow</source>
          <target state="translated">버퍼 언더 플로</target>
        </trans-unit>
        <trans-unit id="686e3ac1e8c5ee3c1c5629d53729cf9e049cd6ce" translate="yes" xml:space="preserve">
          <source>BufferError</source>
          <target state="translated">BufferError</target>
        </trans-unit>
        <trans-unit id="c7b39b7a30837e3319a6b2c6ed8a735c8561e2c6" translate="yes" xml:space="preserve">
          <source>Buffered I/O streams provide a higher-level interface to an I/O device than raw I/O does.</source>
          <target state="translated">버퍼링 된 I / O 스트림은 원시 I / O보다 I / O 장치에 더 높은 수준의 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="959e8e27a1a7517d9d6fea8d34bd9b957b635286" translate="yes" xml:space="preserve">
          <source>Buffered Protocols can be used with any event loop method that supports &lt;a href=&quot;#streaming-protocols&quot;&gt;Streaming Protocols&lt;/a&gt;.</source>
          <target state="translated">버퍼링 된 프로토콜은 &lt;a href=&quot;#streaming-protocols&quot;&gt;스트리밍 프로토콜&lt;/a&gt; 을 지원하는 모든 이벤트 루프 방법과 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="574102792f7c7c7e47baae36d954590700cb065f" translate="yes" xml:space="preserve">
          <source>Buffered Streaming Protocols</source>
          <target state="translated">버퍼링 된 스트리밍 프로토콜</target>
        </trans-unit>
        <trans-unit id="b311ee6c0f812e0972743c0b62829df0f807921a" translate="yes" xml:space="preserve">
          <source>Buffered Streams</source>
          <target state="translated">버퍼링 된 스트림</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="e2a08d31bdd8d081756ba38c56ba4d641e93dc37" translate="yes" xml:space="preserve">
          <source>Build a pair of connected socket objects using the given address family, socket type, and protocol number. Address family, socket type, and protocol number are as for the &lt;a href=&quot;#socket.socket&quot;&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/a&gt; function above. The default family is &lt;a href=&quot;#socket.AF_UNIX&quot;&gt;&lt;code&gt;AF_UNIX&lt;/code&gt;&lt;/a&gt; if defined on the platform; otherwise, the default is &lt;a href=&quot;#socket.AF_INET&quot;&gt;&lt;code&gt;AF_INET&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 주소 패밀리, 소켓 유형 및 프로토콜 번호를 사용하여 연결된 소켓 오브젝트 쌍을 빌드하십시오. 주소 패밀리, 소켓 유형 및 프로토콜 번호는 위 의 &lt;a href=&quot;#socket.socket&quot;&gt; &lt;code&gt;socket()&lt;/code&gt; &lt;/a&gt; 함수와 같습니다. 플랫폼에 정의 된 경우 기본 제품군은 &lt;a href=&quot;#socket.AF_UNIX&quot;&gt; &lt;code&gt;AF_UNIX&lt;/code&gt; &lt;/a&gt; 입니다. 그렇지 않으면 기본값은 &lt;a href=&quot;#socket.AF_INET&quot;&gt; &lt;code&gt;AF_INET&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6e9656b5fcacde2351e066c227427c3e012c98d2" translate="yes" xml:space="preserve">
          <source>Building XML documents</source>
          <target state="translated">XML 문서 작성</target>
        </trans-unit>
        <trans-unit id="9fa5c035dd72ed1a6c59d2333e838d715c597849" translate="yes" xml:space="preserve">
          <source>Building generic types</source>
          <target state="translated">일반 유형 빌드</target>
        </trans-unit>
        <trans-unit id="bd6340131dc0513bc11d497bc3d1cf2f8b579961" translate="yes" xml:space="preserve">
          <source>Built-in Constants</source>
          <target state="translated">내장 상수</target>
        </trans-unit>
        <trans-unit id="82e330488e4f4db6f630ff4b0e83b77d370d478e" translate="yes" xml:space="preserve">
          <source>Built-in Exceptions</source>
          <target state="translated">내장 예외</target>
        </trans-unit>
        <trans-unit id="d2c05904ba07a6ff264de1d75f78c6ff5dce9860" translate="yes" xml:space="preserve">
          <source>Built-in Functions</source>
          <target state="translated">내장 함수</target>
        </trans-unit>
        <trans-unit id="9383071c87bb3c0b8b13c806952ce07e9c48a3bd" translate="yes" xml:space="preserve">
          <source>Built-in Types</source>
          <target state="translated">내장 타입</target>
        </trans-unit>
        <trans-unit id="f2f9b8a4a5c37edcd59988672dfcfd3c6c2d4a94" translate="yes" xml:space="preserve">
          <source>Bulgarian, Byelorussian, Macedonian, Russian, Serbian</source>
          <target state="translated">불가리아어, 벨로루시 아어, 마케도니아 어, 러시아어, 세르비아어</target>
        </trans-unit>
        <trans-unit id="484a7d24c1efecafaa0613f78c13ce044b371cb5" translate="yes" xml:space="preserve">
          <source>Bus error (bad memory access).</source>
          <target state="translated">버스 오류 (잘못된 메모리 액세스).</target>
        </trans-unit>
        <trans-unit id="f07f4711cba2866b61759ea0e7b48922ec7fe786" translate="yes" xml:space="preserve">
          <source>But for strings with more than &lt;code&gt;sys.float_info.dig&lt;/code&gt; significant digits, this isn&amp;rsquo;t always true:</source>
          <target state="translated">그러나 유효 숫자 가 &lt;code&gt;sys.float_info.dig&lt;/code&gt; 이상인 문자열의 경우 항상 그런 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="004c5cf93a775636561b365abba996971a9aedc3" translate="yes" xml:space="preserve">
          <source>But if we pass a &lt;em&gt;buffer_callback&lt;/em&gt; and then give back the accumulated buffers when unserializing, we are able to get back the original object:</source>
          <target state="translated">그러나 &lt;em&gt;buffer_callback&lt;/em&gt; 을 전달하면&lt;em&gt;&lt;/em&gt; 다음 직렬화 해제시 누적 된 버퍼를 반환하면 원래 객체를 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9a6dc0dea2456e6fdbe63316e135e168e69bbbc" translate="yes" xml:space="preserve">
          <source>But this is allowed:</source>
          <target state="translated">그러나 이것은 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="bcc92d564bd4808e09d06300f9cf1c685ab17806" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;installed package&amp;rdquo; we generally mean a third-party package installed into Python&amp;rsquo;s &lt;code&gt;site-packages&lt;/code&gt; directory via tools such as &lt;a href=&quot;https://pypi.org/project/pip/&quot;&gt;pip&lt;/a&gt;. Specifically, it means a package with either a discoverable &lt;code&gt;dist-info&lt;/code&gt; or &lt;code&gt;egg-info&lt;/code&gt; directory, and metadata defined by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 566&lt;/strong&gt;&lt;/a&gt; or its older specifications. By default, package metadata can live on the file system or in zip archives on &lt;a href=&quot;sys#sys.path&quot;&gt;&lt;code&gt;sys.path&lt;/code&gt;&lt;/a&gt;. Through an extension mechanism, the metadata can live almost anywhere.</source>
          <target state="translated">&quot;설치된 패키지&quot;란 일반적 으로 &lt;a href=&quot;https://pypi.org/project/pip/&quot;&gt;pip&lt;/a&gt; 와 같은 도구를 통해 Python의 &lt;code&gt;site-packages&lt;/code&gt; 디렉토리에 설치된 타사 패키지를 의미합니다 . 특히, 검색 가능한 &lt;code&gt;dist-info&lt;/code&gt; 또는 &lt;code&gt;egg-info&lt;/code&gt; 디렉터리와 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566&quot; id=&quot;index-0&quot;&gt;&lt;strong&gt;PEP 566&lt;/strong&gt;&lt;/a&gt; 또는 이전 사양에 의해 정의 된 메타 데이터가 있는 패키지를 의미합니다 . 기본적으로 패키지 메타 데이터는 파일 시스템 또는 &lt;a href=&quot;sys#sys.path&quot;&gt; &lt;code&gt;sys.path&lt;/code&gt; 의&lt;/a&gt; zip 아카이브에있을 수 있습니다. 확장 메커니즘을 통해 메타 데이터는 거의 모든 위치에있을 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4a6147a8ef54b0c6f733b2e259793dcd5ecdd996" translate="yes" xml:space="preserve">
          <source>By &amp;ldquo;installed package&amp;rdquo; we generally mean a third-party package installed into Python&amp;rsquo;s &lt;code&gt;site-packages&lt;/code&gt; directory via tools such as &lt;a href=&quot;https://pypi.org/project/pip/&quot;&gt;pip&lt;/a&gt;. Specifically, it means a package with either a discoverable &lt;code&gt;dist-info&lt;/code&gt; or &lt;code&gt;egg-info&lt;/code&gt; directory, and metadata defined by &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566/&quot;&gt;PEP 566&lt;/a&gt; or its older specifications. By default, package metadata can live on the file system or in zip archives on &lt;code&gt;sys.path&lt;/code&gt;. Through an extension mechanism, the metadata can live almost anywhere.</source>
          <target state="translated">&amp;ldquo;설치된 패키지&amp;rdquo;란 일반적 으로 &lt;a href=&quot;https://pypi.org/project/pip/&quot;&gt;pip&lt;/a&gt; 와 같은 도구를 통해 Python의 &lt;code&gt;site-packages&lt;/code&gt; 디렉토리에 설치된 타사 패키지를 의미합니다 . 특히, 검색 가능한 &lt;code&gt;dist-info&lt;/code&gt; 또는 &lt;code&gt;egg-info&lt;/code&gt; 디렉토리와 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0566/&quot;&gt;PEP 566&lt;/a&gt; 또는 이전 사양으로 정의 된 메타 데이터가 있는 패키지를 의미합니다 . 기본적으로 패키지 메타 데이터는 파일 시스템 또는 &lt;code&gt;sys.path&lt;/code&gt; 의 zip 아카이브에있을 수 있습니다. 확장 메커니즘을 통해 메타 데이터는 거의 모든 곳에 살 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb6eed428fae77be28a2a3bf7fc36fab40ed7e17" translate="yes" xml:space="preserve">
          <source>By combining together these and similar commands, intricate shapes and pictures can easily be drawn.</source>
          <target state="translated">이러한 명령과 유사한 명령을 함께 사용하면 복잡한 모양과 그림을 쉽게 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="286ee8278fd8ab4e0bb68f3b03113179bc8da4c6" translate="yes" xml:space="preserve">
          <source>By contrast, if you create the SSL context by calling the &lt;a href=&quot;#ssl.SSLContext&quot;&gt;&lt;code&gt;SSLContext&lt;/code&gt;&lt;/a&gt; constructor yourself, it will not have certificate validation nor hostname checking enabled by default. If you do so, please read the paragraphs below to achieve a good security level.</source>
          <target state="translated">반대로 &lt;a href=&quot;#ssl.SSLContext&quot;&gt; &lt;code&gt;SSLContext&lt;/code&gt; &lt;/a&gt; 생성자를 직접 호출하여 SSL 컨텍스트를 작성하면 기본적으로 인증서 유효성 검증이나 호스트 이름 확인이 사용되지 않습니다. 그렇게 할 경우 보안 수준을 높이려면 아래 단락을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="4925b83b2b2b23aaf1c66fff18b8c0029cc678e1" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#module-shutil&quot;&gt;&lt;code&gt;shutil&lt;/code&gt;&lt;/a&gt; provides these formats:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#module-shutil&quot;&gt; &lt;code&gt;shutil&lt;/code&gt; &lt;/a&gt; 은 다음 형식을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a442e6847fcb81d8e12f5ccd5522ffb613f8b302" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#unittest.mock.patch&quot;&gt;&lt;code&gt;patch()&lt;/code&gt;&lt;/a&gt; will fail to replace attributes that don&amp;rsquo;t exist. If you pass in &lt;code&gt;create=True&lt;/code&gt;, and the attribute doesn&amp;rsquo;t exist, patch will create the attribute for you when the patched function is called, and delete it again after the patched function has exited. This is useful for writing tests against attributes that your production code creates at runtime. It is off by default because it can be dangerous. With it switched on you can write passing tests against APIs that don&amp;rsquo;t actually exist!</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#unittest.mock.patch&quot;&gt; &lt;code&gt;patch()&lt;/code&gt; &lt;/a&gt; 는 존재하지 않는 속성을 대체하지 못합니다. &lt;code&gt;create=True&lt;/code&gt; 를 전달 하고 속성이 존재하지 않으면 패치 된 함수가 호출 될 때 patch가 속성을 작성하고 패치 된 함수가 종료 된 후 다시 삭제합니다. 프로덕션 코드가 런타임에 생성하는 속성에 대해 테스트를 작성하는 데 유용합니다. 위험 할 수 있으므로 기본적으로 해제되어 있습니다. 이 기능을 켜면 실제로 존재하지 않는 API에 대한 통과 테스트를 작성할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="e11f6ec8c72c6430bc9c389fb2edfddc8c054485" translate="yes" xml:space="preserve">
          <source>By default Unicode alphanumerics are the ones used in Unicode patterns, but this can be changed by using the &lt;a href=&quot;#re.ASCII&quot;&gt;&lt;code&gt;ASCII&lt;/code&gt;&lt;/a&gt; flag. Word boundaries are determined by the current locale if the &lt;a href=&quot;#re.LOCALE&quot;&gt;&lt;code&gt;LOCALE&lt;/code&gt;&lt;/a&gt; flag is used. Inside a character range, &lt;code&gt;\b&lt;/code&gt; represents the backspace character, for compatibility with Python&amp;rsquo;s string literals.</source>
          <target state="translated">기본적으로 유니 코드 영숫자는 유니 코드 패턴에 사용되는 문자이지만 &lt;a href=&quot;#re.ASCII&quot;&gt; &lt;code&gt;ASCII&lt;/code&gt; &lt;/a&gt; 플래그 를 사용하여 변경할 수 있습니다 . &lt;a href=&quot;#re.LOCALE&quot;&gt; &lt;code&gt;LOCALE&lt;/code&gt; &lt;/a&gt; 플래그가 사용되는 경우 현재 로케일에 의해 단어 경계가 결정 됩니다. 문자 범위 내에서 &lt;code&gt;\b&lt;/code&gt; 는 백 스페이스 문자를 나타내며 Python의 문자열 리터럴과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="a555dcde94361baeb4a969d6e2aba5d45aab6d18" translate="yes" xml:space="preserve">
          <source>By default all tasks for the current event loop are returned. If &lt;em&gt;loop&lt;/em&gt; is &lt;code&gt;None&lt;/code&gt;, the &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt; function is used to get the current loop.</source>
          <target state="translated">기본적으로 현재 이벤트 루프에 대한 모든 작업이 반환됩니다. 경우 &lt;em&gt;루프가&lt;/em&gt; 없는 &lt;code&gt;None&lt;/code&gt; 상기 &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; 함수는 전류 루프를 얻기 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="348aa774128c8876086cc6859a2d1a237faf35da" translate="yes" xml:space="preserve">
          <source>By default asyncio is configured to use &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt;&lt;code&gt;SelectorEventLoop&lt;/code&gt;&lt;/a&gt; on Unix and &lt;a href=&quot;#asyncio.ProactorEventLoop&quot;&gt;&lt;code&gt;ProactorEventLoop&lt;/code&gt;&lt;/a&gt; on Windows.</source>
          <target state="translated">기본적으로 asyncio는 Unix 에서는 &lt;a href=&quot;#asyncio.SelectorEventLoop&quot;&gt; &lt;code&gt;SelectorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용 하고 Windows에서는 &lt;a href=&quot;#asyncio.ProactorEventLoop&quot;&gt; &lt;code&gt;ProactorEventLoop&lt;/code&gt; &lt;/a&gt; 를 사용하도록 구성되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbe8db946f6c4039aedf3337f510e5fb4d84a3b8" translate="yes" xml:space="preserve">
          <source>By default asyncio runs in production mode. In order to ease the development asyncio has a &lt;em&gt;debug mode&lt;/em&gt;.</source>
          <target state="translated">기본적으로 asyncio는 프로덕션 모드에서 실행됩니다. 개발을 용이하게하기 위해 asyncio에는 &lt;em&gt;디버그 모드가&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2d0e2958afe24ad181976d5e62c588dde7221db" translate="yes" xml:space="preserve">
          <source>By default functions are assumed to return the C &lt;code&gt;int&lt;/code&gt; type. Other return types can be specified by setting the &lt;code&gt;restype&lt;/code&gt; attribute of the function object.</source>
          <target state="translated">기본적으로 함수는 C &lt;code&gt;int&lt;/code&gt; 유형 을 리턴한다고 가정 합니다. 함수 객체 의 &lt;code&gt;restype&lt;/code&gt; 속성을 설정하여 다른 반환 유형을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83606b363ba65c4bdc94a570461388ab6e60c908" translate="yes" xml:space="preserve">
          <source>By default if a process is not the creator of the queue then on exit it will attempt to join the queue&amp;rsquo;s background thread. The process can call &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt;&lt;code&gt;cancel_join_thread()&lt;/code&gt;&lt;/a&gt; to make &lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt;&lt;code&gt;join_thread()&lt;/code&gt;&lt;/a&gt; do nothing.</source>
          <target state="translated">프로세스가 큐의 작성자가 아닌 경우 기본적으로 종료시 큐의 백그라운드 스레드에 참여하려고 시도합니다. 프로세스는 &lt;a href=&quot;#multiprocessing.Queue.cancel_join_thread&quot;&gt; &lt;code&gt;cancel_join_thread()&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;a href=&quot;#multiprocessing.Queue.join_thread&quot;&gt; &lt;code&gt;join_thread()&lt;/code&gt; &lt;/a&gt; 가 아무것도하지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2235fc8bdd0df529b51b9b98a249362b87248fd8" translate="yes" xml:space="preserve">
          <source>By default many of the protocol methods are required to return objects of a specific type. These methods are preconfigured with a default return value, so that they can be used without you having to do anything if you aren&amp;rsquo;t interested in the return value. You can still &lt;em&gt;set&lt;/em&gt; the return value manually if you want to change the default.</source>
          <target state="translated">기본적으로 특정 유형의 객체를 반환하려면 많은 프로토콜 방법이 필요합니다. 이 메소드는 기본 리턴 값으로 사전 구성되어 있으므로 리턴 값에 관심이없는 경우 아무 것도하지 않아도 사용할 수 있습니다. 기본값을 변경하려는 경우에도 반환 값을 수동으로 &lt;em&gt;설정할&lt;/em&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47e5ba4cdbf45dc6469e9b93a83211483f2c3df3" translate="yes" xml:space="preserve">
          <source>By default this runner shows &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#PendingDeprecationWarning&quot;&gt;&lt;code&gt;PendingDeprecationWarning&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#ImportWarning&quot;&gt;&lt;code&gt;ImportWarning&lt;/code&gt;&lt;/a&gt; even if they are &lt;a href=&quot;warnings#warning-ignored&quot;&gt;ignored by default&lt;/a&gt;. Deprecation warnings caused by &lt;a href=&quot;#deprecated-aliases&quot;&gt;deprecated unittest methods&lt;/a&gt; are also special-cased and, when the warning filters are &lt;code&gt;'default'&lt;/code&gt; or &lt;code&gt;'always'&lt;/code&gt;, they will appear only once per-module, in order to avoid too many warning messages. This behavior can be overridden using Python&amp;rsquo;s &lt;code&gt;-Wd&lt;/code&gt; or &lt;code&gt;-Wa&lt;/code&gt; options (see &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;Warning control&lt;/a&gt;) and leaving &lt;em&gt;warnings&lt;/em&gt; to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 러너는 &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#PendingDeprecationWarning&quot;&gt; &lt;code&gt;PendingDeprecationWarning&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#ImportWarning&quot;&gt; &lt;code&gt;ImportWarning&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;warnings#warning-ignored&quot;&gt; 을 기본적으로 무시&lt;/a&gt; 하더라도 표시합니다 . &lt;a href=&quot;#deprecated-aliases&quot;&gt;더 이상 사용되지 않는 unittest 메소드&lt;/a&gt; 에 의해 사용 되는 더 이상 사용되지 않는 경고 도 특별한 경우이며 경고 필터가 &lt;code&gt;'default'&lt;/code&gt; 또는 &lt;code&gt;'always'&lt;/code&gt; 인 경우 경고 메시지가 너무 많지 않도록 모듈 당 한 번만 표시됩니다. 이 동작은 Python의 &lt;code&gt;-Wd&lt;/code&gt; 또는 &lt;code&gt;-Wa&lt;/code&gt; 옵션 ( &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#using-on-warnings&quot;&gt;경고 제어&lt;/a&gt; 참조 )을 사용하여 무시 하고 &lt;em&gt;경고&lt;/em&gt; 를 &lt;code&gt;None&lt;/code&gt; 남겨 둘 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffe1ee682848dcbf8b31aad1ec757414332a0eb9" translate="yes" xml:space="preserve">
          <source>By default this runner shows &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt;&lt;code&gt;DeprecationWarning&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#PendingDeprecationWarning&quot;&gt;&lt;code&gt;PendingDeprecationWarning&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt;&lt;code&gt;ResourceWarning&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;exceptions#ImportWarning&quot;&gt;&lt;code&gt;ImportWarning&lt;/code&gt;&lt;/a&gt; even if they are &lt;a href=&quot;warnings#warning-ignored&quot;&gt;ignored by default&lt;/a&gt;. Deprecation warnings caused by &lt;a href=&quot;#deprecated-aliases&quot;&gt;deprecated unittest methods&lt;/a&gt; are also special-cased and, when the warning filters are &lt;code&gt;'default'&lt;/code&gt; or &lt;code&gt;'always'&lt;/code&gt;, they will appear only once per-module, in order to avoid too many warning messages. This behavior can be overridden using Python&amp;rsquo;s &lt;code&gt;-Wd&lt;/code&gt; or &lt;code&gt;-Wa&lt;/code&gt; options (see &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#using-on-warnings&quot;&gt;Warning control&lt;/a&gt;) and leaving &lt;em&gt;warnings&lt;/em&gt; to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기본적으로이 실행기는 &lt;a href=&quot;warnings#warning-ignored&quot;&gt;기본적으로 무시&lt;/a&gt; 되더라도 &lt;a href=&quot;exceptions#DeprecationWarning&quot;&gt; &lt;code&gt;DeprecationWarning&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#PendingDeprecationWarning&quot;&gt; &lt;code&gt;PendingDeprecationWarning&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;exceptions#ResourceWarning&quot;&gt; &lt;code&gt;ResourceWarning&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;exceptions#ImportWarning&quot;&gt; &lt;code&gt;ImportWarning&lt;/code&gt; &lt;/a&gt; 을 표시합니다 . &lt;a href=&quot;#deprecated-aliases&quot;&gt;더 이상 사용되지 않는 unittest 메서드&lt;/a&gt; 로 인한 지원 중단 경고 도 특수한 경우이며 경고 필터가 &lt;code&gt;'default'&lt;/code&gt; 또는 &lt;code&gt;'always'&lt;/code&gt; 인 경우 너무 많은 경고 메시지를 피하기 위해 모듈 당 한 번만 표시됩니다. 이 동작은 Python의 &lt;code&gt;-Wd&lt;/code&gt; 또는 &lt;code&gt;-Wa&lt;/code&gt; 옵션 ( &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#using-on-warnings&quot;&gt;경고 제어&lt;/a&gt; 참조 )을 사용하여 무시 하고 &lt;em&gt;경고&lt;/em&gt; 를 &lt;code&gt;None&lt;/code&gt; 으로 남겨 둘 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5ae01e3d2789afe7d1a9556247cf9d3863cbe4da" translate="yes" xml:space="preserve">
          <source>By default this skips private attributes beginning with &amp;lsquo;_&amp;rsquo; but includes all magic methods, i.e. those starting and ending in &amp;lsquo;__&amp;rsquo;.</source>
          <target state="translated">기본적으로 이것은 '_'로 시작하는 개인 속성을 건너 뛰지 만 모든 마법 메서드, 즉 '__'로 시작하고 끝나는 모든 마법 메서드를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="52f7dbe5b41ae8611a2810a429a49fbad90c7410" translate="yes" xml:space="preserve">
          <source>By default when using &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt;&lt;code&gt;getboolean()&lt;/code&gt;&lt;/a&gt;, config parsers consider the following values &lt;code&gt;True&lt;/code&gt;: &lt;code&gt;'1'&lt;/code&gt;, &lt;code&gt;'yes'&lt;/code&gt;, &lt;code&gt;'true'&lt;/code&gt;, &lt;code&gt;'on'&lt;/code&gt; and the following values &lt;code&gt;False&lt;/code&gt;: &lt;code&gt;'0'&lt;/code&gt;, &lt;code&gt;'no'&lt;/code&gt;, &lt;code&gt;'false'&lt;/code&gt;, &lt;code&gt;'off'&lt;/code&gt;. You can override this by specifying a custom dictionary of strings and their Boolean outcomes. For example:</source>
          <target state="translated">기본적으로 사용하는 경우 &lt;a href=&quot;#configparser.ConfigParser.getboolean&quot;&gt; &lt;code&gt;getboolean()&lt;/code&gt; &lt;/a&gt; , 설정 파서는 다음과 같은 값을 고려 &lt;code&gt;True&lt;/code&gt; : &lt;code&gt;'1'&lt;/code&gt; , &lt;code&gt;'yes'&lt;/code&gt; , &lt;code&gt;'true'&lt;/code&gt; , &lt;code&gt;'on'&lt;/code&gt; 다음 값 &lt;code&gt;False&lt;/code&gt; : &lt;code&gt;'0'&lt;/code&gt; , &lt;code&gt;'no'&lt;/code&gt; , &lt;code&gt;'false'&lt;/code&gt; , &lt;code&gt;'off'&lt;/code&gt; . 문자열의 사용자 정의 사전과 부울 결과를 지정하여이를 재정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="21b2fa9e8bd653d25936c1ef6f64b883a8409f29" translate="yes" xml:space="preserve">
          <source>By default you will not get any tracebacks in user-defined functions, aggregates, converters, authorizer callbacks etc. If you want to debug them, you can call this function with &lt;em&gt;flag&lt;/em&gt; set to &lt;code&gt;True&lt;/code&gt;. Afterwards, you will get tracebacks from callbacks on &lt;code&gt;sys.stderr&lt;/code&gt;. Use &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt; to disable the feature again.</source>
          <target state="translated">기본적으로 사용자 정의 함수, 집계, 변환기, 권한 부 여기 콜백 등에 대한 추적은 없습니다. 디버그하려는 경우 &lt;em&gt;플래그&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정 하여이 함수를 호출 할 수 있습니다 . 그런 다음 &lt;code&gt;sys.stderr&lt;/code&gt; 의 콜백에서 추적을 얻습니다 . 사용 &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; 다시 기능을 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f132014d689a5cf73b7e430ffb2dcd6bdf06fb85" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; calculates the usage message from the arguments it contains:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 는 포함 된 인수에서 사용 메시지를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="024605f88e757d67ce6f6e4fd5acb4d11c9a071b" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; groups command-line arguments into &amp;ldquo;positional arguments&amp;rdquo; and &amp;ldquo;optional arguments&amp;rdquo; when displaying help messages. When there is a better conceptual grouping of arguments than this default one, appropriate groups can be created using the &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt;&lt;code&gt;add_argument_group()&lt;/code&gt;&lt;/a&gt; method:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; 는&lt;/a&gt; 도움말 메시지를 표시 할 때 명령 줄 인수를 &quot;위치 인수&quot;및 &quot;선택적 인수&quot;로 그룹화합니다. 이 디폴트보다 인수의 개념적 그룹화가 더 나은 경우 &lt;a href=&quot;#argparse.ArgumentParser.add_argument_group&quot;&gt; &lt;code&gt;add_argument_group()&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 적절한 그룹을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32cb386527e775896cd057a28fa7c4bd40470da8" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; objects read command-line arguments in as simple strings. However, quite often the command-line string should instead be interpreted as another type, like a &lt;a href=&quot;functions#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;functions#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;type&lt;/code&gt; keyword argument of &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt;&lt;code&gt;add_argument()&lt;/code&gt;&lt;/a&gt; allows any necessary type-checking and type conversions to be performed. Common built-in types and functions can be used directly as the value of the &lt;code&gt;type&lt;/code&gt; argument:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 객체는 명령 줄 인수를 간단한 문자열로 읽습니다. 그러나 종종 명령 행 문자열은 &lt;a href=&quot;functions#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;functions#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 와 같은 다른 유형으로 해석되어야합니다 . &lt;a href=&quot;#argparse.ArgumentParser.add_argument&quot;&gt; &lt;code&gt;add_argument()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;type&lt;/code&gt; 키워드 인수를 사용하면 필요한 유형 검사 및 유형 변환을 수행 할 수 있습니다. 일반적인 내장 타입과 함수는 &lt;code&gt;type&lt;/code&gt; 인자 의 값으로 직접 사용될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="94b437bedcb22203818d42f82de4da353c13eba3" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt; objects use &lt;code&gt;sys.argv[0]&lt;/code&gt; to determine how to display the name of the program in help messages. This default is almost always desirable because it will make the help messages match how the program was invoked on the command line. For example, consider a file named &lt;code&gt;myprogram.py&lt;/code&gt; with the following code:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#argparse.ArgumentParser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt; 객체는 &lt;code&gt;sys.argv[0]&lt;/code&gt; 을 사용하여 도움말 메시지에 프로그램 이름을 표시하는 방법을 결정합니다. 이 기본값은 도움말 메시지가 명령 행에서 프로그램이 호출 된 방식과 일치하도록하기 때문에 거의 항상 바람직합니다. 예를 들어, 다음 코드와 함께 &lt;code&gt;myprogram.py&lt;/code&gt; 라는 파일을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="bb58169c2afcd07d3793490e9bfb11ff16d131cb" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; will not implicitly add a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method unless it is safe to do so. Neither will it add or change an existing explicitly defined &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Setting the class attribute &lt;code&gt;__hash__ = None&lt;/code&gt; has a specific meaning to Python, as described in the &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 는 안전한 경우가 아니라면 암시 적으로 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드를 추가하지 않습니다 . 기존의 명시 적으로 정의 된 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드를 추가하거나 변경하지도 않습니다 . &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 클래스 속성 &lt;code&gt;__hash__ = None&lt;/code&gt; 설정은 Python에 특정한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b3d4b25fbd6a7584fd2bda12b7dee94351f4abb3" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#dataclasses.dataclass&quot;&gt;&lt;code&gt;dataclass()&lt;/code&gt;&lt;/a&gt; will not implicitly add a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method unless it is safe to do so. Neither will it add or change an existing explicitly defined &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; method. Setting the class attribute &lt;code&gt;__hash__ = None&lt;/code&gt; has a specific meaning to Python, as described in the &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt;&lt;code&gt;__hash__()&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#dataclasses.dataclass&quot;&gt; &lt;code&gt;dataclass()&lt;/code&gt; &lt;/a&gt; 는 안전한 경우가 아니면 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드를 암시 적으로 추가하지 않습니다 . 또한 명시 적으로 정의 된 기존 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 메서드를 추가하거나 변경하지 않습니다 . 클래스 속성 &lt;code&gt;__hash__ = None&lt;/code&gt; 설정은 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__hash__&quot;&gt; &lt;code&gt;__hash__()&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 Python에 특정한 의미를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="ddd4450bf8d89a24f78314fc96e96f3a51a2cfe1" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#doctest.testfile&quot;&gt;&lt;code&gt;testfile()&lt;/code&gt;&lt;/a&gt; looks for files in the calling module&amp;rsquo;s directory. See section &lt;a href=&quot;#doctest-basic-api&quot;&gt;Basic API&lt;/a&gt; for a description of the optional arguments that can be used to tell it to look for files in other locations.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#doctest.testfile&quot;&gt; &lt;code&gt;testfile()&lt;/code&gt; &lt;/a&gt; 은 호출 모듈의 디렉토리에서 파일을 찾습니다. 다른 위치에서 파일을 찾도록 지시하는 데 사용할 수있는 선택적 인수에 대한 설명은 &lt;a href=&quot;#doctest-basic-api&quot;&gt;기본 API&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f5935e8f63ee8aab7d9c10c622d79fc87c370ea" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#os.walk&quot;&gt;&lt;code&gt;walk()&lt;/code&gt;&lt;/a&gt; will not walk down into symbolic links that resolve to directories. Set &lt;em&gt;followlinks&lt;/em&gt; to &lt;code&gt;True&lt;/code&gt; to visit directories pointed to by symlinks, on systems that support them.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#os.walk&quot;&gt; &lt;code&gt;walk()&lt;/code&gt; &lt;/a&gt; 는 디렉토리로 해석되는 심볼릭 링크로 들어 가지 않습니다. 심볼릭 링크가 가리키는 디렉토리를 지원하는 시스템에서 &lt;em&gt;팔로우 링크&lt;/em&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정 하십시오.</target>
        </trans-unit>
        <trans-unit id="bc029c94a9abc8785480c4cc10cbe10a76a8afe0" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; temporarily turns off &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-garbage-collection&quot;&gt;garbage collection&lt;/a&gt; during the timing. The advantage of this approach is that it makes independent timings more comparable. The disadvantage is that GC may be an important component of the performance of the function being measured. If so, GC can be re-enabled as the first statement in the &lt;em&gt;setup&lt;/em&gt; string. For example:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 는 타이밍 동안 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-garbage-collection&quot;&gt;가비지 수집을&lt;/a&gt; 일시적으로 해제 합니다. 이 방법의 장점은 독립적 인 타이밍을 더 비교할 수 있다는 것입니다. 단점은 GC가 측정되는 기능 수행의 중요한 구성 요소 일 수 있다는 것입니다. 그렇다면 GC를 &lt;em&gt;설정&lt;/em&gt; 문자열 의 첫 번째 문장으로 다시 활성화 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b90ba17cb5f8a8a6266285e3345bbcee3dd5e688" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt;&lt;code&gt;timeit()&lt;/code&gt;&lt;/a&gt; temporarily turns off &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-garbage-collection&quot;&gt;garbage collection&lt;/a&gt; during the timing. The advantage of this approach is that it makes independent timings more comparable. The disadvantage is that GC may be an important component of the performance of the function being measured. If so, GC can be re-enabled as the first statement in the &lt;em&gt;setup&lt;/em&gt; string. For example:</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#timeit.Timer.timeit&quot;&gt; &lt;code&gt;timeit()&lt;/code&gt; &lt;/a&gt; 은 타이밍 동안 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-garbage-collection&quot;&gt;가비지 수집을&lt;/a&gt; 일시적으로 해제 합니다. 이 접근 방식의 장점은 독립적 인 타이밍을 더 비슷하게 만든다는 것입니다. 단점은 GC가 측정되는 기능 성능의 중요한 구성 요소가 될 수 있다는 것입니다. 그렇다면 GC를 &lt;em&gt;설정&lt;/em&gt; 문자열 의 첫 번째 문으로 다시 활성화 할 수 있습니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="11d5d8210634b80549b5b63361003e12a84937bc" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;pip&lt;/code&gt; is installed into the current virtual environment (if one is active) or into the system site packages (if there is no active virtual environment). The installation location can be controlled through two additional command line options:</source>
          <target state="translated">기본적으로 &lt;code&gt;pip&lt;/code&gt; 는 현재 가상 환경 (활성화 된 경우) 또는 시스템 사이트 패키지 (활성 가상 환경이없는 경우)에 설치됩니다. 설치 위치는 두 가지 추가 명령 줄 옵션을 통해 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e04756eee7f0460d985177205e10b1a23503c069" translate="yes" xml:space="preserve">
          <source>By default, &lt;em&gt;check_same_thread&lt;/em&gt; is &lt;a href=&quot;constants#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; and only the creating thread may use the connection. If set &lt;a href=&quot;constants#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;, the returned connection may be shared across multiple threads. When using multiple threads with the same connection writing operations should be serialized by the user to avoid data corruption.</source>
          <target state="translated">기본적으로 &lt;em&gt;check_same_thread&lt;/em&gt; 는 &lt;a href=&quot;constants#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 이며 작성 스레드 만 연결을 사용할 수 있습니다. &lt;a href=&quot;constants#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; 로&lt;/a&gt; 설정 하면 반환 된 연결이 여러 스레드에서 공유 될 수 있습니다. 동일한 연결로 여러 스레드를 사용하는 경우 데이터 손상을 피하기 위해 사용자가 쓰기 작업을 직렬화해야합니다.</target>
        </trans-unit>
        <trans-unit id="9796dc7a23b90b4d977cc10e77473ff593a1938d" translate="yes" xml:space="preserve">
          <source>By default, &lt;em&gt;prefix&lt;/em&gt; is added to all lines that do not consist solely of whitespace (including any line endings).</source>
          <target state="translated">기본적으로 &lt;em&gt;접두사&lt;/em&gt; 는 공백으로 만 구성되지 않은 모든 행 (행 끝 포함)에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="fc4ca20bdc6fbea8397ef04133950e8434765b2e" translate="yes" xml:space="preserve">
          <source>By default, ArgumentParser objects add an option which simply displays the parser&amp;rsquo;s help message. For example, consider a file named &lt;code&gt;myprogram.py&lt;/code&gt; containing the following code:</source>
          <target state="translated">기본적으로 ArgumentParser 객체는 파서의 도움말 메시지를 간단히 표시하는 옵션을 추가합니다. 예를 들어, 다음 코드를 포함하는 &lt;code&gt;myprogram.py&lt;/code&gt; 라는 파일을 생각해보십시오 .</target>
        </trans-unit>
        <trans-unit id="746866251cfb3e555774dcd8af3a46db19750c77" translate="yes" xml:space="preserve">
          <source>By default, C types are represented in the machine&amp;rsquo;s native format and byte order, and properly aligned by skipping pad bytes if necessary (according to the rules used by the C compiler).</source>
          <target state="translated">기본적으로 C 유형은 컴퓨터의 기본 형식 및 바이트 순서로 표시되며 필요한 경우 패드 바이트를 건너 뛰어 (C 컴파일러에서 사용하는 규칙에 따라) 올바르게 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="3512445457ee9e1000f6118054d51f83a71dc8bb" translate="yes" xml:space="preserve">
          <source>By default, IDLE executes user code in a separate subprocess via a socket, which uses the internal loopback interface. This connection is not externally visible and no data is sent to or received from the Internet. If firewall software complains anyway, you can ignore it.</source>
          <target state="translated">기본적으로 IDLE은 내부 루프백 인터페이스를 사용하는 소켓을 통해 별도의 하위 프로세스에서 사용자 코드를 실행합니다. 이 연결은 외부에서 볼 수 없으며 인터넷으로 데이터를 보내거나받지 않습니다. 방화벽 소프트웨어가 어쨌든 불평하면 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb79819df474427622fdc62a2ac6ec7a2e31bb5" translate="yes" xml:space="preserve">
          <source>By default, IDLE runs user code in a separate OS process rather than in the user interface process that runs the shell and editor. In the execution process, it replaces &lt;code&gt;sys.stdin&lt;/code&gt;, &lt;code&gt;sys.stdout&lt;/code&gt;, and &lt;code&gt;sys.stderr&lt;/code&gt; with objects that get input from and send output to the Shell window. The original values stored in &lt;code&gt;sys.__stdin__&lt;/code&gt;, &lt;code&gt;sys.__stdout__&lt;/code&gt;, and &lt;code&gt;sys.__stderr__&lt;/code&gt; are not touched, but may be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">기본적으로 IDLE은 쉘 및 편집기를 실행하는 사용자 인터페이스 프로세스가 아닌 별도의 OS 프로세스에서 사용자 코드를 실행합니다. 실행 프로세스에서 &lt;code&gt;sys.stdin&lt;/code&gt; , &lt;code&gt;sys.stdout&lt;/code&gt; 및 &lt;code&gt;sys.stderr&lt;/code&gt; 을 입력하여 Shell 창으로 출력을 보내는 객체로 바꿉니다 . &lt;code&gt;sys.__stdin__&lt;/code&gt; , &lt;code&gt;sys.__stdout__&lt;/code&gt; 및 &lt;code&gt;sys.__stderr__&lt;/code&gt; 저장된 원래 값 은 건드리지 않지만 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4338c28f624cd168dc6e6a993f6edcf0b0caa8e8" translate="yes" xml:space="preserve">
          <source>By default, IIS gives a &lt;code&gt;PATH_INFO&lt;/code&gt; that duplicates the &lt;code&gt;SCRIPT_NAME&lt;/code&gt; at the front, causing problems for WSGI applications that wish to implement routing. This handler strips any such duplicated path.</source>
          <target state="translated">기본적으로 IIS는 전면에 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 을 복제 하는 &lt;code&gt;PATH_INFO&lt;/code&gt; 를 제공하여 라우팅을 구현하려는 WSGI 응용 프로그램에 문제를 일으 킵니다. 이 핸들러는 이러한 중복 경로를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="34a08824cf61e85f3edd280a072e1ba951239abf" translate="yes" xml:space="preserve">
          <source>By default, Pdb sets a handler for the SIGINT signal (which is sent when the user presses</source>
          <target state="translated">기본적으로 Pdb는 SIGINT 신호에 대한 핸들러를 설정합니다 (사용자가 누를 때 전송 됨)</target>
        </trans-unit>
        <trans-unit id="e4fc14c745c41ff2c1c0f6a1f3b4203d646932e6" translate="yes" xml:space="preserve">
          <source>By default, Python does not emit any warning:</source>
          <target state="translated">기본적으로 Python은 경고를 표시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43d58b5909b4209e333296709be9cee88202e059" translate="yes" xml:space="preserve">
          <source>By default, Python installs several warning filters, which can be overridden by the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; command-line option, the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable and calls to &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Python은 여러 경고 필터를 설치합니다.이 경고 필터는 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션 인 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; &lt;/a&gt; 환경 변수로 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 하고 filterwarnings ()를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d68d125a82e363e01456961fa33c1b3dc16a8eb" translate="yes" xml:space="preserve">
          <source>By default, Python installs several warning filters, which can be overridden by the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt;&lt;code&gt;-W&lt;/code&gt;&lt;/a&gt; command-line option, the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-3&quot;&gt;&lt;code&gt;PYTHONWARNINGS&lt;/code&gt;&lt;/a&gt; environment variable and calls to &lt;a href=&quot;#warnings.filterwarnings&quot;&gt;&lt;code&gt;filterwarnings()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Python은 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#cmdoption-w&quot;&gt; &lt;code&gt;-W&lt;/code&gt; &lt;/a&gt; 명령 줄 옵션, &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONWARNINGS&quot; id=&quot;index-3&quot;&gt; &lt;code&gt;PYTHONWARNINGS&lt;/code&gt; &lt;/a&gt; 환경 변수 및 &lt;a href=&quot;#warnings.filterwarnings&quot;&gt; &lt;code&gt;filterwarnings()&lt;/code&gt; &lt;/a&gt; 호출로 재정의 할 수있는 여러 경고 필터를 설치합니다 .</target>
        </trans-unit>
        <trans-unit id="194edc12a70011820b7389989028ffc9cc56fa43" translate="yes" xml:space="preserve">
          <source>By default, Rmail displays only visible headers. The &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt;&lt;code&gt;BabylMessage&lt;/code&gt;&lt;/a&gt; class, though, uses the original headers because they are more complete. Visible headers may be accessed explicitly if desired.</source>
          <target state="translated">기본적으로 Rmail은 보이는 헤더 만 표시합니다. 그러나 &lt;a href=&quot;#mailbox.BabylMessage&quot;&gt; &lt;code&gt;BabylMessage&lt;/code&gt; &lt;/a&gt; 클래스는 더 완전하기 때문에 원래 헤더를 사용합니다. 원하는 경우 가시적 인 헤더에 명시 적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1631d9dffd1975805f1afb15caa3c01281e60e0" translate="yes" xml:space="preserve">
          <source>By default, Structure and Union fields are aligned in the same way the C compiler does it. It is possible to override this behavior by specifying a &lt;code&gt;_pack_&lt;/code&gt; class attribute in the subclass definition. This must be set to a positive integer and specifies the maximum alignment for the fields. This is what &lt;code&gt;#pragma pack(n)&lt;/code&gt; also does in MSVC.</source>
          <target state="translated">기본적으로 Structure 및 Union 필드는 C 컴파일러와 동일한 방식으로 정렬됩니다. 서브 클래스 정의에 &lt;code&gt;_pack_&lt;/code&gt; class 속성 을 지정하여이 동작을 대체 할 수 있습니다 . 양의 정수로 설정해야하며 필드의 최대 정렬을 지정합니다. 이것은 무엇인가 &lt;code&gt;#pragma pack(n)&lt;/code&gt; 도 MSVC에서 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6eb82dd6665f910dee0adea7123f213a064029b" translate="yes" xml:space="preserve">
          <source>By default, a pickler object will not have a &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt;&lt;code&gt;dispatch_table&lt;/code&gt;&lt;/a&gt; attribute, and it will instead use the global dispatch table managed by the &lt;a href=&quot;copyreg#module-copyreg&quot;&gt;&lt;code&gt;copyreg&lt;/code&gt;&lt;/a&gt; module. However, to customize the pickling for a specific pickler object one can set the &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt;&lt;code&gt;dispatch_table&lt;/code&gt;&lt;/a&gt; attribute to a dict-like object. Alternatively, if a subclass of &lt;a href=&quot;#pickle.Pickler&quot;&gt;&lt;code&gt;Pickler&lt;/code&gt;&lt;/a&gt; has a &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt;&lt;code&gt;dispatch_table&lt;/code&gt;&lt;/a&gt; attribute then this will be used as the default dispatch table for instances of that class.</source>
          <target state="translated">기본적으로 피커 객체에는 &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt; &lt;code&gt;dispatch_table&lt;/code&gt; &lt;/a&gt; 속성이 없으며 대신 &lt;a href=&quot;copyreg#module-copyreg&quot;&gt; &lt;code&gt;copyreg&lt;/code&gt; &lt;/a&gt; 모듈이 관리하는 전역 디스패치 테이블을 사용합니다 . 그러나 특정 피커 객체에 대한 피클 링을 사용자 정의하기 위해 &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt; &lt;code&gt;dispatch_table&lt;/code&gt; &lt;/a&gt; 속성을 dict-like 객체로 설정할 수 있습니다 . 또는 &lt;a href=&quot;#pickle.Pickler&quot;&gt; &lt;code&gt;Pickler&lt;/code&gt; &lt;/a&gt; 의 서브 클래스에 &lt;a href=&quot;#pickle.Pickler.dispatch_table&quot;&gt; &lt;code&gt;dispatch_table&lt;/code&gt; &lt;/a&gt; 속성 이있는 경우 해당 클래스의 인스턴스에 대한 기본 디스패치 테이블로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53801121724a8b51bc2f424f971489d6286912cc" translate="yes" xml:space="preserve">
          <source>By default, a trace of an allocated memory block only stores the most recent frame (1 frame). To store 25 frames at startup: set the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt;&lt;/a&gt; environment variable to &lt;code&gt;25&lt;/code&gt;, or use the &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;tracemalloc=25&lt;/code&gt; command line option.</source>
          <target state="translated">기본적으로 할당 된 메모리 블록의 트레이스는 가장 최근의 프레임 (1 프레임) 만 저장합니다. 시작시 25 개의 프레임을 저장하려면 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt; &lt;/a&gt; 환경 변수를 &lt;code&gt;25&lt;/code&gt; 로 설정하거나 &lt;a href=&quot;https://docs.python.org/3.8/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tracemalloc=25&lt;/code&gt; 명령 행 옵션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="235f1643814d54cc51678475522595afc16e865c" translate="yes" xml:space="preserve">
          <source>By default, a trace of an allocated memory block only stores the most recent frame (1 frame). To store 25 frames at startup: set the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-1&quot;&gt;&lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt;&lt;/a&gt; environment variable to &lt;code&gt;25&lt;/code&gt;, or use the &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt;&lt;code&gt;-X&lt;/code&gt;&lt;/a&gt;&lt;code&gt;tracemalloc=25&lt;/code&gt; command line option.</source>
          <target state="translated">기본적으로 할당 된 메모리 블록의 추적은 가장 최근 프레임 (1 프레임) 만 저장합니다. 시작시 25 개 프레임 저장 : &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#envvar-PYTHONTRACEMALLOC&quot; id=&quot;index-1&quot;&gt; &lt;code&gt;PYTHONTRACEMALLOC&lt;/code&gt; &lt;/a&gt; 환경 변수를 &lt;code&gt;25&lt;/code&gt; 로 설정하거나 &lt;a href=&quot;https://docs.python.org/3.9/using/cmdline.html#id5&quot;&gt; &lt;code&gt;-X&lt;/code&gt; &lt;/a&gt; &lt;code&gt;tracemalloc=25&lt;/code&gt; 명령 줄 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="20f9c9b32bdc318c5c18acd3766a8add6de519ab" translate="yes" xml:space="preserve">
          <source>By default, accepts the name of a module and prints the source of that module. A class or function within the module can be printed instead by appended a colon and the qualified name of the target object.</source>
          <target state="translated">기본적으로 모듈 이름을 승인하고 해당 모듈의 소스를 인쇄합니다. 대신 콜론과 대상 오브젝트의 규정 된 이름을 추가하여 모듈 내의 클래스 또는 함수를 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaec6d27e5f37d0c8c91b7a089060ddcb01dba03" translate="yes" xml:space="preserve">
          <source>By default, all keys in sections are accessible in a case-insensitive manner &lt;a href=&quot;#id14&quot; id=&quot;id10&quot;&gt;1&lt;/a&gt;. E.g. &lt;code&gt;for option in parser[&quot;section&quot;]&lt;/code&gt; yields only &lt;code&gt;optionxform&lt;/code&gt;&amp;rsquo;ed option key names. This means lowercased keys by default. At the same time, for a section that holds the key &lt;code&gt;'a'&lt;/code&gt;, both expressions return &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">기본적으로 섹션의 모든 키는 대소 문자를 구분하지 않는 방식으로 액세스 할 수 있습니다 &lt;a href=&quot;#id14&quot; id=&quot;id10&quot;&gt;1&lt;/a&gt; . 예 &lt;code&gt;for option in parser[&quot;section&quot;]&lt;/code&gt; 들어 파서 [ &quot;섹션&quot;]의 옵션 은 &lt;code&gt;optionxform&lt;/code&gt; 옵션 키 이름 만 생성 합니다. 이것은 기본적으로 소문자 키를 의미합니다. 동시에 키가있는 섹션의 경우 &lt;code&gt;'a'&lt;/code&gt; 의 경우 두 표현식 모두 &lt;code&gt;True&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c2c533a2bae92633bb096ca2ac9b6447f1dac0ff" translate="yes" xml:space="preserve">
          <source>By default, all keys must be present in a TypedDict. It is possible to override this by specifying totality. Usage:</source>
          <target state="translated">기본적으로 모든 키는 TypedDict에 있어야합니다. totality를 지정하여이를 재정의 할 수 있습니다. 용법:</target>
        </trans-unit>
        <trans-unit id="df77a2f5e1f9b841bf3693ba08d7b2ecd3c51127" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines either a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bool__&quot;&gt;&lt;code&gt;__bool__()&lt;/code&gt;&lt;/a&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; method that returns zero, when called with the object. &lt;a href=&quot;#id12&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; Here are most of the built-in objects considered false:</source>
          <target state="translated">기본적으로 객체의 클래스 정의 중 하나를하지 않는 한 진정한 간주됩니다 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bool__&quot;&gt; &lt;code&gt;__bool__()&lt;/code&gt; &lt;/a&gt; 메소드가 반환하는 &lt;code&gt;False&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 객체로 호출 할 때, 0을 리턴하는 것이 방법. &lt;a href=&quot;#id12&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 거짓으로 간주되는 대부분의 내장 객체는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0d59253386482a6284666394f1f4661fa312626" translate="yes" xml:space="preserve">
          <source>By default, an object is considered true unless its class defines either a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__bool__&quot;&gt;&lt;code&gt;__bool__()&lt;/code&gt;&lt;/a&gt; method that returns &lt;code&gt;False&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__len__&quot;&gt;&lt;code&gt;__len__()&lt;/code&gt;&lt;/a&gt; method that returns zero, when called with the object. &lt;a href=&quot;#id12&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; Here are most of the built-in objects considered false:</source>
          <target state="translated">기본적으로 개체는 진정한 고려의 클래스 정의 중 하나를하지 않는 한 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__bool__&quot;&gt; &lt;code&gt;__bool__()&lt;/code&gt; &lt;/a&gt; 메소드가 반환하는 &lt;code&gt;False&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__len__&quot;&gt; &lt;code&gt;__len__()&lt;/code&gt; &lt;/a&gt; 객체로 호출 할 때, 0을 리턴하는 것이 방법. &lt;a href=&quot;#id12&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 다음은 거짓으로 간주되는 대부분의 내장 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3ea474f9f38dc663c8a08f500f58696344e668cc" translate="yes" xml:space="preserve">
          <source>By default, attempting to patch a function in a module (or a method or an attribute in a class) that does not exist will fail with &lt;a href=&quot;exceptions#AttributeError&quot;&gt;&lt;code&gt;AttributeError&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본적으로 존재하지 않는 모듈 (또는 클래스의 메소드 또는 속성)에서 함수를 패치하려고하면 실패합니다. &lt;a href=&quot;exceptions#AttributeError&quot;&gt; &lt;code&gt;AttributeError&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="ba6f8ccaf5287f458e74dcc3c521955c22632ec1" translate="yes" xml:space="preserve">
          <source>By default, each time &lt;a href=&quot;#module-doctest&quot;&gt;&lt;code&gt;doctest&lt;/code&gt;&lt;/a&gt; finds a docstring to test, it uses a &lt;em&gt;shallow copy&lt;/em&gt; of &lt;code&gt;M&lt;/code&gt;&amp;rsquo;s globals, so that running tests doesn&amp;rsquo;t change the module&amp;rsquo;s real globals, and so that one test in &lt;code&gt;M&lt;/code&gt; can&amp;rsquo;t leave behind crumbs that accidentally allow another test to work. This means examples can freely use any names defined at top-level in &lt;code&gt;M&lt;/code&gt;, and names defined earlier in the docstring being run. Examples cannot see names defined in other docstrings.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#module-doctest&quot;&gt; &lt;code&gt;doctest&lt;/code&gt; &lt;/a&gt; 는 테스트 할 docstring을 찾을 때마다 &lt;code&gt;M&lt;/code&gt; 전역 의 &lt;em&gt;얕은 사본&lt;/em&gt; 을 사용 하므로 테스트를 실행해도 모듈의 실제 전역이 변경되지 않으며 &lt;code&gt;M&lt;/code&gt; 에서 하나의 테스트가 수행됩니다. 부스러기를 남길 수 없습니다. 실수로 다른 테스트를 수행 할 수 있습니다. 이것은 예제가 &lt;code&gt;M&lt;/code&gt; 의 최상위 레벨에 정의 된 이름과 실행중인 docstring에 앞서 정의 된 이름을 자유롭게 사용할 수 있음을 의미 합니다. 예는 다른 문서 문자열에 정의 된 이름을 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dced44bdbcc5d88045afe23f3049d96083bbec3f" translate="yes" xml:space="preserve">
          <source>By default, enumerations allow multiple names as aliases for the same value. When this behavior isn&amp;rsquo;t desired, the following decorator can be used to ensure each value is used only once in the enumeration:</source>
          <target state="translated">기본적으로 열거는 여러 값을 동일한 값의 별칭으로 허용합니다. 이 동작이 필요하지 않은 경우 다음 데코레이터를 사용하여 각 값이 열거에서 한 번만 사용되도록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ab285e785eb1c48a8796719be9a670c6e97df9b" translate="yes" xml:space="preserve">
          <source>By default, errors from the &lt;a href=&quot;#os.scandir&quot;&gt;&lt;code&gt;scandir()&lt;/code&gt;&lt;/a&gt; call are ignored. If optional argument &lt;em&gt;onerror&lt;/em&gt; is specified, it should be a function; it will be called with one argument, an &lt;a href=&quot;exceptions#OSError&quot;&gt;&lt;code&gt;OSError&lt;/code&gt;&lt;/a&gt; instance. It can report the error to continue with the walk, or raise the exception to abort the walk. Note that the filename is available as the &lt;code&gt;filename&lt;/code&gt; attribute of the exception object.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#os.scandir&quot;&gt; &lt;code&gt;scandir()&lt;/code&gt; &lt;/a&gt; 호출 의 오류 는 무시됩니다. 선택적 인수 &lt;em&gt;onerror&lt;/em&gt; 가 지정되면 함수 여야합니다. &lt;a href=&quot;exceptions#OSError&quot;&gt; &lt;code&gt;OSError&lt;/code&gt; &lt;/a&gt; 인스턴스 라는 하나의 인수로 호출됩니다 . 보행을 계속하려면 오류를보고하거나 보행을 중단하기 위해 예외를 제기 할 수 있습니다. 파일 이름은 예외 객체 의 &lt;code&gt;filename&lt;/code&gt; 속성으로 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="936f21d2588c2a060ae9ea52d1267f952c5ea2bf" translate="yes" xml:space="preserve">
          <source>By default, for best performance, the &lt;em&gt;errors&lt;/em&gt; argument is only checked at the first encoding/decoding error and the &lt;em&gt;encoding&lt;/em&gt; argument is sometimes ignored for empty strings.</source>
          <target state="translated">기본적으로 최상의 성능을 위해 &lt;em&gt;errors&lt;/em&gt; 인수는 첫 번째 인코딩 / 디코딩 오류에서만 확인되며 빈 문자열에 대해 &lt;em&gt;인코딩&lt;/em&gt; 인수가 무시되는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5fd2a1ebe99a0d3917c731d7846b7f02865b33d" translate="yes" xml:space="preserve">
          <source>By default, if an expected output block contains a line containing only the string &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt;, then that line will match a blank line in the actual output. Because a genuinely blank line delimits the expected output, this is the only way to communicate that a blank line is expected. When &lt;a href=&quot;#doctest.DONT_ACCEPT_BLANKLINE&quot;&gt;&lt;code&gt;DONT_ACCEPT_BLANKLINE&lt;/code&gt;&lt;/a&gt; is specified, this substitution is not allowed.</source>
          <target state="translated">기본적으로 예상되는 출력 블록에 &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; 문자열 만 포함 된 행이 포함 된 경우 해당 행은 실제 출력의 빈 행과 일치합니다. 실제로 빈 줄은 예상 출력을 제한하기 때문에 빈 줄이 예상된다는 것을 전달하는 유일한 방법입니다. 언제&lt;a href=&quot;#doctest.DONT_ACCEPT_BLANKLINE&quot;&gt; &lt;code&gt;DONT_ACCEPT_BLANKLINE&lt;/code&gt; 가&lt;/a&gt; 지정이 대체는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f2508fc55ad92f5457b99f4d98df22c95e511d0e" translate="yes" xml:space="preserve">
          <source>By default, if an expected output block contains just &lt;code&gt;1&lt;/code&gt;, an actual output block containing just &lt;code&gt;1&lt;/code&gt; or just &lt;code&gt;True&lt;/code&gt; is considered to be a match, and similarly for &lt;code&gt;0&lt;/code&gt; versus &lt;code&gt;False&lt;/code&gt;. When &lt;a href=&quot;#doctest.DONT_ACCEPT_TRUE_FOR_1&quot;&gt;&lt;code&gt;DONT_ACCEPT_TRUE_FOR_1&lt;/code&gt;&lt;/a&gt; is specified, neither substitution is allowed. The default behavior caters to that Python changed the return type of many functions from integer to boolean; doctests expecting &amp;ldquo;little integer&amp;rdquo; output still work in these cases. This option will probably go away, but not for several years.</source>
          <target state="translated">기본적으로 예상 출력 블록에 &lt;code&gt;1&lt;/code&gt; 이 포함 된 경우 실제 출력 블록에 &lt;code&gt;1&lt;/code&gt; 만 포함 또는 &lt;code&gt;True&lt;/code&gt; 만 이 일치하는 것으로 간주되며 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;False&lt;/code&gt; 도 유사하게 간주됩니다 . 때 &lt;a href=&quot;#doctest.DONT_ACCEPT_TRUE_FOR_1&quot;&gt; &lt;code&gt;DONT_ACCEPT_TRUE_FOR_1&lt;/code&gt; &lt;/a&gt; 을 지정 대체가 허용되지 않습니다. 기본 동작은 파이썬이 많은 함수의 반환 유형을 정수에서 부울로 변경 한 것입니다. 이 경우 &quot;작은 정수&quot;출력이 필요한 doctest는 여전히 작동합니다. 이 옵션은 아마도 사라질 것이지만 몇 년 동안은 사라지지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f9b9cb578b338579d6cbb60c27b43fc1a3cceffa" translate="yes" xml:space="preserve">
          <source>By default, no arguments are passed to &lt;em&gt;target&lt;/em&gt;.</source>
          <target state="translated">기본적으로 인수는 &lt;em&gt;대상&lt;/em&gt; 으로 전달되지 않습니다&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="008b3b178e4b68b1e60ef93709f10afc91405af4" translate="yes" xml:space="preserve">
          <source>By default, or when &lt;em&gt;pages&lt;/em&gt; is either &lt;code&gt;0&lt;/code&gt; or a negative integer, the entire database is copied in a single step; otherwise the method performs a loop copying up to &lt;em&gt;pages&lt;/em&gt; pages at a time.</source>
          <target state="translated">기본적으로 또는 &lt;em&gt;페이지&lt;/em&gt; 가 &lt;code&gt;0&lt;/code&gt; 이거나 음수 인 경우 전체 데이터베이스가 단일 단계로 복사됩니다. 그렇지 않으면 메소드는 최대 &lt;em&gt;페이지&lt;/em&gt; 까지 루프 복사를 수행 &lt;em&gt;합니다.&lt;/em&gt; 는 한 번에 페이지 .</target>
        </trans-unit>
        <trans-unit id="7fb1ffcd7df10e13bd50a132b07d1a02253cb944" translate="yes" xml:space="preserve">
          <source>By default, server binds itself to all interfaces. The option &lt;code&gt;-b/--bind&lt;/code&gt; specifies a specific address to which it should bind. Both IPv4 and IPv6 addresses are supported. For example, the following command causes the server to bind to localhost only:</source>
          <target state="translated">기본적으로 서버는 모든 인터페이스에 바인드합니다. &lt;code&gt;-b/--bind&lt;/code&gt; 옵션 은 바인딩 할 특정 주소를 지정합니다. IPv4 및 IPv6 주소가 모두 지원됩니다. 예를 들어 다음 명령을 사용하면 서버가 로컬 호스트에만 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="77eeefe6f3c358b478358f7fcd4bb93cba700b29" translate="yes" xml:space="preserve">
          <source>By default, server uses the current directory. The option &lt;code&gt;-d/--directory&lt;/code&gt; specifies a directory to which it should serve the files. For example, the following command uses a specific directory:</source>
          <target state="translated">기본적으로 서버는 현재 디렉토리를 사용합니다. &lt;code&gt;-d/--directory&lt;/code&gt; 옵션 은 파일을 제공 할 디렉토리를 지정합니다. 예를 들어 다음 명령은 특정 디렉토리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="301b7f7ac742594093987dfcc029e8f93e2dbe64" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; data format uses a relatively compact binary representation. If you need optimal size characteristics, you can efficiently &lt;a href=&quot;archiving&quot;&gt;compress&lt;/a&gt; pickled data.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 데이터 형식은 비교적 컴팩트 한 이진 표현을 사용합니다. 최적의 크기 특성이 필요한 경우 효율적으로&lt;a href=&quot;archiving&quot;&gt; 압축&lt;/a&gt; 할 수 있습니다 절인 데이터를 .</target>
        </trans-unit>
        <trans-unit id="094a33ba83d7519f725e162343187dcd2696de2d" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#module-sqlite3&quot;&gt;&lt;code&gt;sqlite3&lt;/code&gt;&lt;/a&gt; module uses its &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; class for the connect call. You can, however, subclass the &lt;a href=&quot;#sqlite3.Connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; class and make &lt;a href=&quot;#sqlite3.connect&quot;&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/a&gt; use your class instead by providing your class for the &lt;em&gt;factory&lt;/em&gt; parameter.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#module-sqlite3&quot;&gt; &lt;code&gt;sqlite3&lt;/code&gt; &lt;/a&gt; 모듈은 연결 호출에 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 클래스를 사용합니다. 그러나 &lt;a href=&quot;#sqlite3.Connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 클래스를 서브 클래 싱하고 &lt;a href=&quot;#sqlite3.connect&quot;&gt; &lt;code&gt;connect()&lt;/code&gt; &lt;/a&gt; 만들 수 있습니다.&lt;em&gt; 팩토리&lt;/em&gt; 매개 변수에 클래스를 제공하여 클래스를 대신 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6462d732918c01c641bc37dfaab3963a19f0d248" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt; class sends a &lt;em&gt;User-Agent&lt;/em&gt; header of &lt;code&gt;urllib/VVV&lt;/code&gt;, where &lt;em&gt;VVV&lt;/em&gt; is the &lt;a href=&quot;urllib#module-urllib&quot;&gt;&lt;code&gt;urllib&lt;/code&gt;&lt;/a&gt; version number. Applications can define their own &lt;em&gt;User-Agent&lt;/em&gt; header by subclassing &lt;a href=&quot;#urllib.request.URLopener&quot;&gt;&lt;code&gt;URLopener&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt;&lt;code&gt;FancyURLopener&lt;/code&gt;&lt;/a&gt; and setting the class attribute &lt;a href=&quot;#urllib.request.URLopener.version&quot;&gt;&lt;code&gt;version&lt;/code&gt;&lt;/a&gt; to an appropriate string value in the subclass definition.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt; 클래스는 &lt;code&gt;urllib/VVV&lt;/code&gt; 의 &lt;em&gt;User-Agent&lt;/em&gt; 헤더를 보냅니다. 여기서 &lt;em&gt;VVV&lt;/em&gt; 는 &lt;a href=&quot;urllib#module-urllib&quot;&gt; &lt;code&gt;urllib&lt;/code&gt; &lt;/a&gt; 버전 번호입니다. 애플리케이션은 &lt;a href=&quot;#urllib.request.URLopener&quot;&gt; &lt;code&gt;URLopener&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#urllib.request.FancyURLopener&quot;&gt; &lt;code&gt;FancyURLopener&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱 하고 클래스 속성을 설정하여 고유 한 &lt;em&gt;User-Agent&lt;/em&gt; 헤더를 정의 할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;a href=&quot;#urllib.request.URLopener.version&quot;&gt; &lt;code&gt;version&lt;/code&gt; &lt;/a&gt; 서브 클래 싱하고 서브 클래스 정의에서 을 적절한 문자열 값으로 .</target>
        </trans-unit>
        <trans-unit id="24a0dabed54df7a1b18bb8440a0376bac5366831" translate="yes" xml:space="preserve">
          <source>By default, the &lt;em&gt;errors&lt;/em&gt; argument is not checked for best performances, but only used at the first decoding error. Enable the &lt;a href=&quot;devmode#devmode&quot;&gt;Python Development Mode&lt;/a&gt;, or use a debug build to check &lt;em&gt;errors&lt;/em&gt;.</source>
          <target state="translated">기본적으로 &lt;em&gt;errors&lt;/em&gt; 인수는 최상의 성능을 위해 확인되지 않고 첫 번째 디코딩 오류에서만 사용됩니다. &lt;a href=&quot;devmode#devmode&quot;&gt;Python 개발 모드를&lt;/a&gt; 활성화 하거나 디버그 빌드를 사용하여 &lt;em&gt;오류&lt;/em&gt; 를 확인 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9c9bf05ff10e8d81625ba313ef44e9675125f4fd" translate="yes" xml:space="preserve">
          <source>By default, the &lt;em&gt;errors&lt;/em&gt; argument is not checked for best performances, but only used at the first encoding error. Enable the &lt;a href=&quot;devmode#devmode&quot;&gt;Python Development Mode&lt;/a&gt;, or use a debug build to check &lt;em&gt;errors&lt;/em&gt;.</source>
          <target state="translated">기본적으로 &lt;em&gt;errors&lt;/em&gt; 인수는 최상의 성능을 위해 확인되지 않고 첫 번째 인코딩 오류에서만 사용됩니다. &lt;a href=&quot;devmode#devmode&quot;&gt;Python 개발 모드를&lt;/a&gt; 활성화 하거나 디버그 빌드를 사용하여 &lt;em&gt;오류&lt;/em&gt; 를 확인 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3680d558cfec6850bcf6d9a77a8cad55df9c5560" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;href&lt;/strong&gt; attribute is treated as a file name. You can use custom loaders to override this behaviour. Also note that the standard helper does not support XPointer syntax.</source>
          <target state="translated">기본적으로 &lt;strong&gt; href&lt;/strong&gt; 속성은 파일 이름으로 취급됩니다. 사용자 정의 로더를 사용하여이 동작을 대체 할 수 있습니다. 또한 표준 도우미는 XPointer 구문을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d10ea8597ea642766854d45414b54ceba2e795c6" translate="yes" xml:space="preserve">
          <source>By default, the Python traceback is written to &lt;a href=&quot;sys#sys.stderr&quot;&gt;&lt;code&gt;sys.stderr&lt;/code&gt;&lt;/a&gt;. To see tracebacks, applications must be run in the terminal. A log file can alternatively be passed to &lt;a href=&quot;#faulthandler.enable&quot;&gt;&lt;code&gt;faulthandler.enable()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로 Python 추적은 &lt;a href=&quot;sys#sys.stderr&quot;&gt; &lt;code&gt;sys.stderr&lt;/code&gt; 에&lt;/a&gt; 작성됩니다 . 역 추적을 보려면 터미널에서 응용 프로그램을 실행해야합니다. 대신에 로그 파일을 전달할 수 있습니다&lt;a href=&quot;#faulthandler.enable&quot;&gt; &lt;code&gt;faulthandler.enable()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="920a6566848376fec069ad7573aa5aa7bb437561" translate="yes" xml:space="preserve">
          <source>By default, the class also implements the parse method of the XMLReader interface using the feed, close and reset methods of the IncrementalParser interface as a convenience to SAX 2.0 driver writers.</source>
          <target state="translated">기본적으로이 클래스는 SAX 2.0 드라이버 작성자의 편의를 위해 IncrementalParser 인터페이스의 피드, 닫기 및 재설정 메소드를 사용하여 XMLReader 인터페이스의 구문 분석 메소드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="c77b39dd4b69e05f235e3b85ecffeea127e6edc1" translate="yes" xml:space="preserve">
          <source>By default, the description will be line-wrapped so that it fits within the given space. To change this behavior, see the &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; argument.</source>
          <target state="translated">기본적으로 설명은 줄 바꿈되어 주어진 공간 내에 맞습니다. 이 동작을 변경하려면 &lt;a href=&quot;#formatter-class&quot;&gt;formatter_class&lt;/a&gt; 인수를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72cdb093d0d5c4a0811bf0713c0a0594ccf746c2" translate="yes" xml:space="preserve">
          <source>By default, the diff control lines (those with &lt;code&gt;***&lt;/code&gt; or &lt;code&gt;---&lt;/code&gt;) are created with a trailing newline. This is helpful so that inputs created from &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;io.IOBase.readlines()&lt;/code&gt;&lt;/a&gt; result in diffs that are suitable for use with &lt;a href=&quot;io#io.IOBase.writelines&quot;&gt;&lt;code&gt;io.IOBase.writelines()&lt;/code&gt;&lt;/a&gt; since both the inputs and outputs have trailing newlines.</source>
          <target state="translated">기본적으로 diff 제어 라인 ( &lt;code&gt;***&lt;/code&gt; 또는 &lt;code&gt;---&lt;/code&gt; 이있는 )은 후행 줄 바꿈으로 작성됩니다. 이것은 &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;io.IOBase.readlines()&lt;/code&gt; &lt;/a&gt; 에서 생성 된 입력 이 diff와 함께 사용하기에 적합한 diff를 만들도록 도와줍니다&lt;a href=&quot;io#io.IOBase.writelines&quot;&gt; &lt;code&gt;io.IOBase.writelines()&lt;/code&gt; &lt;/a&gt;입력은 입력과 출력 모두 끝에 줄 바꿈이 있기 때문에 io.IOBase.writelines ().</target>
        </trans-unit>
        <trans-unit id="701fa93323cbf8ce2e905edfa806eadfe2ba9ee4" translate="yes" xml:space="preserve">
          <source>By default, the diff control lines (those with &lt;code&gt;---&lt;/code&gt;, &lt;code&gt;+++&lt;/code&gt;, or &lt;code&gt;@@&lt;/code&gt;) are created with a trailing newline. This is helpful so that inputs created from &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt;&lt;code&gt;io.IOBase.readlines()&lt;/code&gt;&lt;/a&gt; result in diffs that are suitable for use with &lt;a href=&quot;io#io.IOBase.writelines&quot;&gt;&lt;code&gt;io.IOBase.writelines()&lt;/code&gt;&lt;/a&gt; since both the inputs and outputs have trailing newlines.</source>
          <target state="translated">기본적으로 diff 컨트롤 라인 ( &lt;code&gt;---&lt;/code&gt; , &lt;code&gt;+++&lt;/code&gt; 또는 &lt;code&gt;@@&lt;/code&gt; 인 라인 )은 후행 줄 바꿈으로 만들어집니다. &lt;a href=&quot;io#io.IOBase.readlines&quot;&gt; &lt;code&gt;io.IOBase.readlines()&lt;/code&gt; &lt;/a&gt; 에서 생성 된 입력은 입력과 출력 모두 끝에 줄 바꿈이 있기 때문에 &lt;a href=&quot;io#io.IOBase.writelines&quot;&gt; &lt;code&gt;io.IOBase.writelines()&lt;/code&gt; &lt;/a&gt; 와 함께 사용하기에 적합한 diff를 생성하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="195dae096c798b9d4b95b13edb7f663ede7d0d8a" translate="yes" xml:space="preserve">
          <source>By default, the result of packing a given C struct includes pad bytes in order to maintain proper alignment for the C types involved; similarly, alignment is taken into account when unpacking. This behavior is chosen so that the bytes of a packed struct correspond exactly to the layout in memory of the corresponding C struct. To handle platform-independent data formats or omit implicit pad bytes, use &lt;code&gt;standard&lt;/code&gt; size and alignment instead of &lt;code&gt;native&lt;/code&gt; size and alignment: see &lt;a href=&quot;#struct-alignment&quot;&gt;Byte Order, Size, and Alignment&lt;/a&gt; for details.</source>
          <target state="translated">기본적으로 주어진 C 구조체를 패킹 한 결과에는 관련된 C 유형에 대한 적절한 정렬을 유지하기 위해 패드 바이트가 포함됩니다. 마찬가지로 포장을 풀 때 정렬이 고려됩니다. 패킹 된 구조체의 바이트가 해당 C 구조체의 메모리에있는 레이아웃과 정확히 일치하도록이 동작이 선택됩니다. 암시 패드 바이트를 생략 핸들 플랫폼 독립적 인 데이터 포맷하거나, 사용 &lt;code&gt;standard&lt;/code&gt; 크기 및 정렬 대신 &lt;code&gt;native&lt;/code&gt; 크기와 정렬 : 참조 &lt;a href=&quot;#struct-alignment&quot;&gt;바이트 순서, 크기 및 정렬을&lt;/a&gt; 자세한 내용은.</target>
        </trans-unit>
        <trans-unit id="2f8d31485f1cf87f768e5f2e59061661f7d4b972" translate="yes" xml:space="preserve">
          <source>By default, the scripts &lt;code&gt;pipX&lt;/code&gt; and &lt;code&gt;pipX.Y&lt;/code&gt; will be installed (where X.Y stands for the current version of Python).</source>
          <target state="translated">기본적으로 &lt;code&gt;pipX&lt;/code&gt; 및 &lt;code&gt;pipX.Y&lt;/code&gt; 스크립트 가 설치됩니다 (XY는 현재 Python 버전을 나타냄).</target>
        </trans-unit>
        <trans-unit id="fdf79e7494f0c8e40aa022f705fa4a17ed0f4359" translate="yes" xml:space="preserve">
          <source>By default, the scripts &lt;code&gt;pipX&lt;/code&gt; and &lt;code&gt;pipX.Y&lt;/code&gt; will be installed (where X.Y stands for the version of Python used to invoke &lt;code&gt;ensurepip&lt;/code&gt;). The scripts installed can be controlled through two additional command line options:</source>
          <target state="translated">기본적으로 &lt;code&gt;pipX&lt;/code&gt; 및 &lt;code&gt;pipX.Y&lt;/code&gt; 스크립트 가 설치됩니다 (XY는 &lt;code&gt;ensurepip&lt;/code&gt; 를 호출하는 데 사용되는 Python 버전을 나타냄) ). 설치된 스크립트는 두 가지 추가 명령 줄 옵션을 통해 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5200803235e477dfe23987b607e2285ed5feca81" translate="yes" xml:space="preserve">
          <source>By default, the sub-window will extend from the specified position to the lower right corner of the window.</source>
          <target state="translated">기본적으로 하위 창은 지정된 위치에서 창의 오른쪽 하단으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="3b06468131c77687172a2610a996c3423867c90f" translate="yes" xml:space="preserve">
          <source>By default, the window will extend from the specified position to the lower right corner of the screen.</source>
          <target state="translated">기본적으로 창은 지정된 위치에서 화면 오른쪽 하단으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="9477a9bea084d85882bf3b402a08fa167abb59ff" translate="yes" xml:space="preserve">
          <source>By default, this function will return the data as encoded bytes. The actual encoding of the output data may depend on the command being invoked, so the decoding to text will often need to be handled at the application level.</source>
          <target state="translated">기본적으로이 함수는 데이터를 인코딩 된 바이트로 반환합니다. 출력 데이터의 실제 인코딩은 호출되는 명령에 따라 달라질 수 있으므로 텍스트 디코딩은 종종 응용 프로그램 수준에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="31f19246d0599116d8e34379c8cd902758801c53" translate="yes" xml:space="preserve">
          <source>By default, unpickling will import any class or function that it finds in the pickle data. For many applications, this behaviour is unacceptable as it permits the unpickler to import and invoke arbitrary code. Just consider what this hand-crafted pickle data stream does when loaded:</source>
          <target state="translated">기본적으로 피클 링 해제는 피클 데이터에서 찾은 모든 클래스 또는 함수를 가져옵니다. 많은 응용 프로그램에서이 동작은 피클 러가 임의 코드를 가져 와서 호출 할 수 있으므로 허용되지 않습니다. 이 수제 피클 데이터 스트림을로드 할 때 수행하는 작업을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3ef1793786e54340ce8bfbe17daf119d10d21483" translate="yes" xml:space="preserve">
          <source>By default, version 3 pickles are used to serialize values. The version of the pickle protocol can be specified with the &lt;em&gt;protocol&lt;/em&gt; parameter.</source>
          <target state="translated">기본적으로 버전 3 피클은 값을 직렬화하는 데 사용됩니다. pickle 프로토콜의 버전은 &lt;em&gt;protocol&lt;/em&gt; 매개 변수 로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b38308bfeb6ea74147739e7c4c985e750ec529ef" translate="yes" xml:space="preserve">
          <source>By default, version 3 pickles are used to serialize values. The version of the pickle protocol can be specified with the &lt;em&gt;protocol&lt;/em&gt; parameter. See the &lt;a href=&quot;pickle#module-pickle&quot;&gt;&lt;code&gt;pickle&lt;/code&gt;&lt;/a&gt; documentation for a discussion of the pickle protocols.</source>
          <target state="translated">기본적으로 버전 3 피클은 값을 직렬화하는 데 사용됩니다. pickle 프로토콜의 버전은 &lt;em&gt;protocol&lt;/em&gt; 매개 변수 로 지정할 수 있습니다 . 피클 프로토콜에 대한 설명은 &lt;a href=&quot;pickle#module-pickle&quot;&gt; &lt;code&gt;pickle&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eff56d0e72b6ce61e999e3149679525f60cc22e6" translate="yes" xml:space="preserve">
          <source>By default, wake up one thread waiting on this condition, if any. If the calling thread has not acquired the lock when this method is called, a &lt;a href=&quot;exceptions#RuntimeError&quot;&gt;&lt;code&gt;RuntimeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">기본적으로이 조건에서 대기중인 하나의 스레드를 깨 웁니다 (있는 경우). 이 메소드가 호출 될 때 호출 스레드가 잠금을 획득하지 않은 경우 &lt;a href=&quot;exceptions#RuntimeError&quot;&gt; &lt;code&gt;RuntimeError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="854aa6f56f9c0d27436b46f46a4a43f383857560" translate="yes" xml:space="preserve">
          <source>By default, when reading from &lt;code&gt;/dev/random&lt;/code&gt;, &lt;a href=&quot;#os.getrandom&quot;&gt;&lt;code&gt;getrandom()&lt;/code&gt;&lt;/a&gt; blocks if no random bytes are available, and when reading from &lt;code&gt;/dev/urandom&lt;/code&gt;, it blocks if the entropy pool has not yet been initialized.</source>
          <target state="translated">기본적으로 읽는 경우 &lt;code&gt;/dev/random&lt;/code&gt; , &lt;a href=&quot;#os.getrandom&quot;&gt; &lt;code&gt;getrandom()&lt;/code&gt; &lt;/a&gt; 에는 난수 바이트를 사용할 수없는 경우 블록을, 그리고에서 읽을 때 &lt;code&gt;/dev/urandom&lt;/code&gt; , 차단은 엔트로피 수영장이 아직 초기화되어 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="7b516742d0bb1873f6652a665f55b4757162ced1" translate="yes" xml:space="preserve">
          <source>By reading and writing only large chunks of data even when the user asks for a single byte, buffered I/O hides any inefficiency in calling and executing the operating system&amp;rsquo;s unbuffered I/O routines. The gain depends on the OS and the kind of I/O which is performed. For example, on some modern OSes such as Linux, unbuffered disk I/O can be as fast as buffered I/O. The bottom line, however, is that buffered I/O offers predictable performance regardless of the platform and the backing device. Therefore, it is almost always preferable to use buffered I/O rather than unbuffered I/O for binary data.</source>
          <target state="translated">사용자가 단일 바이트를 요청할 때에도 큰 데이터 청크 만 읽고 쓰면 버퍼 된 I / O는 운영 체제의 버퍼되지 않은 I / O 루틴을 호출하고 실행하는 데있어 비 효율성을 숨 깁니다. 게인은 OS 및 수행되는 I / O 종류에 따라 다릅니다. 예를 들어 Linux와 같은 일부 최신 OS에서 버퍼되지 않은 디스크 I / O는 버퍼 된 I / O만큼 빠를 수 있습니다. 그러나 결론적으로 버퍼링 된 I / O는 플랫폼과 백업 장치에 관계없이 예측 가능한 성능을 제공한다는 것입니다. 따라서 이진 데이터에는 버퍼되지 않은 I / O보다는 버퍼 된 I / O를 사용하는 것이 거의 항상 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="dd46034571b47794a0bda9d3d583cb9fd6cb5cec" translate="yes" xml:space="preserve">
          <source>By returning true values, these callbacks can suppress exceptions the same way context manager &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; methods can.</source>
          <target state="translated">이 콜백은 true 값을 반환함으로써 컨텍스트 관리자 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메소드 와 동일한 방식으로 예외를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07389109df8d85f0cfe4e8ae88013d95963809e8" translate="yes" xml:space="preserve">
          <source>By returning true values, these callbacks can suppress exceptions the same way context manager &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt;&lt;code&gt;__exit__()&lt;/code&gt;&lt;/a&gt; methods can.</source>
          <target state="translated">true 값을 반환함으로써 이러한 콜백은 컨텍스트 관리자 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__exit__&quot;&gt; &lt;code&gt;__exit__()&lt;/code&gt; &lt;/a&gt; 메서드 와 동일한 방식으로 예외를 억제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e560960e3ca3501b7d01f95836df6c7554b4bf3e" translate="yes" xml:space="preserve">
          <source>By setting &lt;em&gt;salt&lt;/em&gt; parameter users can introduce randomization to the hash function. Randomized hashing is useful for protecting against collision attacks on the hash function used in digital signatures.</source>
          <target state="translated">&lt;em&gt;salt&lt;/em&gt; 매개 변수 를 설정 하면 해시 함수에 임의 화를 도입 할 수 있습니다. 무작위 해싱은 디지털 서명에 사용 된 해시 함수에 대한 충돌 공격을 방지하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="32fe99c22402d3f9cd7abfeb71dfafa391c5a113" translate="yes" xml:space="preserve">
          <source>By using a custom event loop policy, the behavior of &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt;&lt;code&gt;get_event_loop()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;asyncio-eventloop#asyncio.set_event_loop&quot;&gt;&lt;code&gt;set_event_loop()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;asyncio-eventloop#asyncio.new_event_loop&quot;&gt;&lt;code&gt;new_event_loop()&lt;/code&gt;&lt;/a&gt; functions can be customized.</source>
          <target state="translated">사용자 정의 이벤트 루프 정책을 사용하여 &lt;a href=&quot;asyncio-eventloop#asyncio.get_event_loop&quot;&gt; &lt;code&gt;get_event_loop()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;asyncio-eventloop#asyncio.set_event_loop&quot;&gt; &lt;code&gt;set_event_loop()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;asyncio-eventloop#asyncio.new_event_loop&quot;&gt; &lt;code&gt;new_event_loop()&lt;/code&gt; &lt;/a&gt; 함수의 동작을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b091b4f9c8ca0872cda8cde6431e148f093daeaf" translate="yes" xml:space="preserve">
          <source>Byte Order, Size, and Alignment</source>
          <target state="translated">바이트 순서, 크기 및 정렬</target>
        </trans-unit>
        <trans-unit id="8a0d6d3439bd2ad80ce89b16b070f185d6471f83" translate="yes" xml:space="preserve">
          <source>Byte index at which an error occurred.</source>
          <target state="translated">에러가 발생한 바이트 인덱스.</target>
        </trans-unit>
        <trans-unit id="1cc655c3485fc15dd7ca0afb59d9aa38bd081838" translate="yes" xml:space="preserve">
          <source>Byte offset to the file header.</source>
          <target state="translated">파일 헤더에 대한 바이트 오프셋.</target>
        </trans-unit>
        <trans-unit id="8333e6eadb360031f488d25d73b03263c17d5cd1" translate="yes" xml:space="preserve">
          <source>Byte order</source>
          <target state="translated">바이트 순서</target>
        </trans-unit>
        <trans-unit id="4597d8ef411d59e1d9be06348c147c4dc042b844" translate="yes" xml:space="preserve">
          <source>Byte-compile a single source file.</source>
          <target state="translated">단일 소스 파일을 바이트 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="8f44d65c941475def9c425dea9272a82770ad20f" translate="yes" xml:space="preserve">
          <source>Byte-compile all the &lt;code&gt;.py&lt;/code&gt; files found along &lt;code&gt;sys.path&lt;/code&gt;. Return a true value if all the files compiled successfully, and a false value otherwise.</source>
          <target state="translated">&lt;code&gt;sys.path&lt;/code&gt; 에있는 모든 &lt;code&gt;.py&lt;/code&gt; 파일을 바이트 컴파일하십시오 . 모든 파일이 성공적으로 컴파일되면 true를 반환하고 그렇지 않으면 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d77f09e0e7b15c9cb3b575a00f1091dc029bc527" translate="yes" xml:space="preserve">
          <source>Bytearray Objects</source>
          <target state="translated">바이트 배열 객체</target>
        </trans-unit>
        <trans-unit id="f3f31d2587c2659748200906697b7e426ebe3937" translate="yes" xml:space="preserve">
          <source>Bytecode analysis</source>
          <target state="translated">바이트 코드 분석</target>
        </trans-unit>
        <trans-unit id="29c3e8776cc54b4a3d00a06a3057380e1328a8bd" translate="yes" xml:space="preserve">
          <source>Bytes (any object that follows the &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; or has &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bytes__&quot;&gt;&lt;code&gt;__bytes__()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이트 ( &lt;a href=&quot;https://docs.python.org/3.8/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜&lt;/a&gt; 을 &lt;a href=&quot;https://docs.python.org/3.8/reference/datamodel.html#object.__bytes__&quot;&gt; &lt;code&gt;__bytes__()&lt;/code&gt; &lt;/a&gt; 거나 __bytes __ () 가 있는 모든 객체 )</target>
        </trans-unit>
        <trans-unit id="dc7b82a1c67cd7fdb773f18fb987493810bcff8a" translate="yes" xml:space="preserve">
          <source>Bytes (any object that follows the &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;buffer protocol&lt;/a&gt; or has &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__bytes__&quot;&gt;&lt;code&gt;__bytes__()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이트 ( &lt;a href=&quot;https://docs.python.org/3.9/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 프로토콜&lt;/a&gt; 을 &lt;a href=&quot;https://docs.python.org/3.9/reference/datamodel.html#object.__bytes__&quot;&gt; &lt;code&gt;__bytes__()&lt;/code&gt; &lt;/a&gt; 거나 __bytes __ () 가 있는 모든 객체 ).</target>
        </trans-unit>
        <trans-unit id="87b953d5d72682cb2132578bfed73b5853f4110b" translate="yes" xml:space="preserve">
          <source>Bytes (converts any Python object using &lt;code&gt;repr(obj).encode('ascii','backslashreplace)&lt;/code&gt;).</source>
          <target state="translated">바이트 ( &lt;code&gt;repr(obj).encode('ascii','backslashreplace)&lt;/code&gt; 사용하여 모든 Python 객체를 변환합니다 .)</target>
        </trans-unit>
        <trans-unit id="240fc4227ac064b6af55b8039b1a8a4d447e7719" translate="yes" xml:space="preserve">
          <source>Bytes Objects</source>
          <target state="translated">바이트 객체</target>
        </trans-unit>
        <trans-unit id="691d2567928500c0d6dcc3954f0ec2324402cb5d" translate="yes" xml:space="preserve">
          <source>Bytes and Bytearray Operations</source>
          <target state="translated">바이트 및 바이트 배열 연산</target>
        </trans-unit>
        <trans-unit id="7df78136784a7bc228bd395f315bea3a22a1309a" translate="yes" xml:space="preserve">
          <source>Bytes objects (&lt;code&gt;bytes&lt;/code&gt;/&lt;code&gt;bytearray&lt;/code&gt;) have one unique built-in operation: the &lt;code&gt;%&lt;/code&gt; operator (modulo). This is also known as the bytes &lt;em&gt;formatting&lt;/em&gt; or &lt;em&gt;interpolation&lt;/em&gt; operator. Given &lt;code&gt;format % values&lt;/code&gt; (where &lt;em&gt;format&lt;/em&gt; is a bytes object), &lt;code&gt;%&lt;/code&gt; conversion specifications in &lt;em&gt;format&lt;/em&gt; are replaced with zero or more elements of &lt;em&gt;values&lt;/em&gt;. The effect is similar to using the &lt;code&gt;sprintf()&lt;/code&gt; in the C language.</source>
          <target state="translated">바이트 객체 ( &lt;code&gt;bytes&lt;/code&gt; / &lt;code&gt;bytearray&lt;/code&gt; )에는 고유 한 내장 연산이 있습니다 : &lt;code&gt;%&lt;/code&gt; 연산자 (모듈로). 바이트 &lt;em&gt;포맷팅&lt;/em&gt; 또는 &lt;em&gt;보간&lt;/em&gt; 연산자 라고도합니다 . 감안 &lt;code&gt;format % values&lt;/code&gt; (여기서 &lt;em&gt;포맷&lt;/em&gt; bytes 객체이다) &lt;code&gt;%&lt;/code&gt; 의 에 변환 스펙 &lt;em&gt;포맷은&lt;/em&gt; 0 개 이상의 원소로 치환되는 &lt;em&gt;값&lt;/em&gt; . 이 효과는 C 언어에서 &lt;code&gt;sprintf()&lt;/code&gt; 를 사용하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0abcedbcee06f3e9a3a9f49f28bb8293fda9dbce" translate="yes" xml:space="preserve">
          <source>Bytes objects are immutable sequences of single bytes. Since many major binary protocols are based on the ASCII text encoding, bytes objects offer several methods that are only valid when working with ASCII compatible data and are closely related to string objects in a variety of other ways.</source>
          <target state="translated">바이트 객체는 단일 바이트의 불변 시퀀스입니다. 많은 주요 이진 프로토콜은 ASCII 텍스트 인코딩을 기반으로하기 때문에 바이트 객체는 ASCII 호환 데이터로 작업 할 때만 유효하고 다양한 방법으로 문자열 객체와 밀접한 관련이있는 여러 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="47d7f1da06c57177341c3d9ef2119c5d7eaec765" translate="yes" xml:space="preserve">
          <source>Bytes objects can also be created with literals, see &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;String and Bytes literals&lt;/a&gt;.</source>
          <target state="translated">바이트 객체는 리터럴을 사용하여 만들 수도 있습니다 ( &lt;a href=&quot;https://docs.python.org/3.8/reference/lexical_analysis.html#strings&quot;&gt;문자열 및 바이트 리터럴&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="5788b743017e2ad56183056bf128f2cd77af475e" translate="yes" xml:space="preserve">
          <source>Bytes objects can also be created with literals, see &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#strings&quot;&gt;String and Bytes literals&lt;/a&gt;.</source>
          <target state="translated">Bytes 객체는 리터럴을 사용하여 생성 할 수도 있습니다 . &lt;a href=&quot;https://docs.python.org/3.9/reference/lexical_analysis.html#strings&quot;&gt;String 및 Bytes 리터럴을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f91b8d8bed8c0993bf0eb2d6b6ee7a3409cd568f" translate="yes" xml:space="preserve">
          <source>Bytes version of &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt;: a &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mapping&quot;&gt;mapping&lt;/a&gt; object representing the environment as byte strings. &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; are synchronized (modify &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; updates &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt;, and vice versa).</source>
          <target state="translated">&lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; 의&lt;/a&gt; 바이트 버전 : 환경을 바이트 문자열로 나타내는 &lt;a href=&quot;https://docs.python.org/3.8/glossary.html#term-mapping&quot;&gt;맵핑&lt;/a&gt; 오브젝트. &lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; &lt;/a&gt; 가 동기화됩니다 ( &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; &lt;/a&gt; 업데이트 &lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; &lt;/a&gt; 수정 및 그 반대).</target>
        </trans-unit>
        <trans-unit id="9cc583b53680a3f7ed79a980ea7403e317ec981c" translate="yes" xml:space="preserve">
          <source>Bytes version of &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt;: a &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mapping&quot;&gt;mapping&lt;/a&gt; object representing the environment as byte strings. &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; are synchronized (modify &lt;a href=&quot;#os.environb&quot;&gt;&lt;code&gt;environb&lt;/code&gt;&lt;/a&gt; updates &lt;a href=&quot;#os.environ&quot;&gt;&lt;code&gt;environ&lt;/code&gt;&lt;/a&gt;, and vice versa).</source>
          <target state="translated">&lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; 의&lt;/a&gt; 바이트 버전 : 환경을 바이트 문자열로 나타내는 &lt;a href=&quot;https://docs.python.org/3.9/glossary.html#term-mapping&quot;&gt;매핑&lt;/a&gt; 객체. &lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; &lt;/a&gt; 가 동기화됩니다 ( &lt;a href=&quot;#os.environb&quot;&gt; &lt;code&gt;environb&lt;/code&gt; &lt;/a&gt; 업데이트 &lt;a href=&quot;#os.environ&quot;&gt; &lt;code&gt;environ&lt;/code&gt; &lt;/a&gt; 수정 및 그 반대로).</target>
        </trans-unit>
        <trans-unit id="4c17a08f748a73c44dbe27e96cafd97e19083491" translate="yes" xml:space="preserve">
          <source>BytesWarning</source>
          <target state="translated">BytesWarning</target>
        </trans-unit>
        <trans-unit id="53cd5afff77d718a16da7a261addfd2e7a746175" translate="yes" xml:space="preserve">
          <source>C Type</source>
          <target state="translated">C 타입</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C 타입</target>
        </trans-unit>
        <trans-unit id="23c8bef685fe7f8e5ab76b80f3a180f9b6022855" translate="yes" xml:space="preserve">
          <source>C++ programmers should note that Python&amp;rsquo;s virtual base class concept is not the same as C++&amp;rsquo;s.</source>
          <target state="translated">C ++ 프로그래머는 Python의 가상 기본 클래스 개념이 C ++과 동일하지 않다는 점에 유의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1034f70b6f9ddd2bcb58956fc970e5f50cec8bd2" translate="yes" xml:space="preserve">
          <source>C-Backspace</source>
          <target state="translated">C-Backspace</target>
        </trans-unit>
        <trans-unit id="235d9f2cf895c1719d46fc1198d0f621032d1477" translate="yes" xml:space="preserve">
          <source>C-Del</source>
          <target state="translated">C-Del</target>
        </trans-unit>
        <trans-unit id="a13b54dca6c09f524e525a2fe3f23ea99ba36108" translate="yes" xml:space="preserve">
          <source>C-End</source>
          <target state="translated">C-End</target>
        </trans-unit>
        <trans-unit id="eeebc65079beba3a90a4b5d6ba9a80053cb89d1e" translate="yes" xml:space="preserve">
          <source>C-Home</source>
          <target state="translated">C-Home</target>
        </trans-unit>
        <trans-unit id="75d3584877ad5e6927fb88c6d65c9ed11fe39a60" translate="yes" xml:space="preserve">
          <source>C-LeftArrow</source>
          <target state="translated">C-LeftArrow</target>
        </trans-unit>
        <trans-unit id="81723ec83c08ca03bcaaa0d427499d1e5f788151" translate="yes" xml:space="preserve">
          <source>C-RightArrow</source>
          <target state="translated">C-RightArrow</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="b3b7965656c0921692a30673d7781acd51c4eed9" translate="yes" xml:space="preserve">
          <source>C-c</source>
          <target state="translated">C-c</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
