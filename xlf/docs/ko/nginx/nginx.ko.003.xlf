<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="nginx">
    <body>
      <group id="nginx">
        <trans-unit id="82942f126b0385ee6491da6127f9b25821cde44c" translate="yes" xml:space="preserve">
          <source>Expire timers by calling &lt;code&gt;ngx_event_expire_timers()&lt;/code&gt;. The timer tree is iterated from the leftmost element to the right until an unexpired timeout is found. For each expired node the &lt;code&gt;timedout&lt;/code&gt; event flag is set, the &lt;code&gt;timer_set&lt;/code&gt; flag is reset, and the event handler is called</source>
          <target state="translated">&lt;code&gt;ngx_event_expire_timers()&lt;/code&gt; 를 호출하여 타이머를 만료하십시오 . 타이머 트리는 만료되지 않은 시간 초과가 발견 될 때까지 가장 왼쪽의 요소에서 오른쪽으로 반복됩니다. 만료 된 각 노드에 대해 &lt;code&gt;timedout&lt;/code&gt; 이벤트 플래그가 설정되고 &lt;code&gt;timer_set&lt;/code&gt; 플래그가 재설정되며 이벤트 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="ae5fccd8dcd8fc317f8edfc8259af86cd2967a29" translate="yes" xml:space="preserve">
          <source>Expressions</source>
          <target state="translated">Expressions</target>
        </trans-unit>
        <trans-unit id="686938a8c95ddd954e18600e50b331335c2f99d4" translate="yes" xml:space="preserve">
          <source>Feature: &lt;a href=&quot;https://nodejs.org/api/crypto.html#crypto_class_hash&quot;&gt;Node.js style&lt;/a&gt;&lt;code&gt;Crypto&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;a href=&quot;https://nodejs.org/api/crypto.html#crypto_class_hash&quot;&gt;Node.js 스타일 &lt;/a&gt; &lt;code&gt;Crypto&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="26db0c9ebf672f8a2157c979fc8d2f2a7345ea07" translate="yes" xml:space="preserve">
          <source>Feature: &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_file_system&quot;&gt;Node.js style&lt;/a&gt;&lt;code&gt;File system&lt;/code&gt; access methods: &lt;code&gt;fs.readFile()&lt;/code&gt;, &lt;code&gt;fs.readFileSync()&lt;/code&gt;, &lt;code&gt;fs.appendFile()&lt;/code&gt;, &lt;code&gt;fs.appendFileSync()&lt;/code&gt;, &lt;code&gt;fs.writeFile()&lt;/code&gt;, &lt;code&gt;fs.writeFileSync()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;https://nodejs.org/api/fs.html#fs_file_system&quot;&gt;Node.js 스타일 &lt;/a&gt; &lt;code&gt;File system&lt;/code&gt; 액세스 방법 : &lt;code&gt;fs.readFile()&lt;/code&gt; , &lt;code&gt;fs.readFileSync()&lt;/code&gt; , &lt;code&gt;fs.appendFile()&lt;/code&gt; , &lt;code&gt;fs.appendFileSync()&lt;/code&gt; , &lt;code&gt;fs.writeFile()&lt;/code&gt; , &lt;code&gt;fs.writeFileSync()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e8567c5824762ec02d173d761889e3ec6f80cc9" translate="yes" xml:space="preserve">
          <source>Feature: &lt;a href=&quot;reference#string_bytesfrom&quot;&gt;&lt;code&gt;String.bytesFrom()&lt;/code&gt;&lt;/a&gt; method (decoding &lt;code&gt;hex&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;base64url&lt;/code&gt; into a byte string).</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#string_bytesfrom&quot;&gt; &lt;code&gt;String.bytesFrom()&lt;/code&gt; &lt;/a&gt; 메서드 ( &lt;code&gt;hex&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;base64url&lt;/code&gt; 을 바이트 문자열로 디코딩 ).</target>
        </trans-unit>
        <trans-unit id="b475560eb1a061303fc29dc0f51469d34822b5b0" translate="yes" xml:space="preserve">
          <source>Feature: &lt;a href=&quot;reference#string_bytesfrom&quot;&gt;String.bytesFrom()&lt;/a&gt; method (decoding &lt;code&gt;hex&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;base64url&lt;/code&gt; into a byte string).</source>
          <target state="translated">특징 : &lt;a href=&quot;reference#string_bytesfrom&quot;&gt;String.bytesFrom ()&lt;/a&gt; 메소드 ( &lt;code&gt;hex&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;base64url&lt;/code&gt; 을 바이트 문자열로 디코딩 ).</target>
        </trans-unit>
        <trans-unit id="a8130c23da3379b9e3e4de97d275a4adc17e68d3" translate="yes" xml:space="preserve">
          <source>Feature: &lt;a href=&quot;reference#string_padstart&quot;&gt;String.padStart()&lt;/a&gt; and &lt;a href=&quot;reference#string_padend&quot;&gt;String.padEnd()&lt;/a&gt; methods.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#string_padstart&quot;&gt;String.padStart ()&lt;/a&gt; 및 &lt;a href=&quot;reference#string_padend&quot;&gt;String.padEnd ()&lt;/a&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="eb48a7c197cde1e52bf67ae9d747a6be9000d30c" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Array.of()&lt;/code&gt;, &lt;code&gt;Array.prototype.fill()&lt;/code&gt;, &lt;code&gt;Array.prototype.find()&lt;/code&gt;, &lt;code&gt;Array.prototype.findIndex()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;Array.of()&lt;/code&gt; , &lt;code&gt;Array.prototype.fill()&lt;/code&gt; , &lt;code&gt;Array.prototype.find()&lt;/code&gt; , &lt;code&gt;Array.prototype.findIndex()&lt;/code&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="a0b7128a3d89ea098802ea27a9508a30d0b6183f" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Error&lt;/code&gt;, &lt;code&gt;EvalError&lt;/code&gt;, &lt;code&gt;InternalError&lt;/code&gt;, &lt;code&gt;RangeError&lt;/code&gt;, &lt;code&gt;ReferenceError&lt;/code&gt;, &lt;code&gt;SyntaxError&lt;/code&gt;, &lt;code&gt;TypeError&lt;/code&gt;, &lt;code&gt;URIError&lt;/code&gt; objects.</source>
          <target state="translated">기능 : &lt;code&gt;Error&lt;/code&gt; , &lt;code&gt;EvalError&lt;/code&gt; , &lt;code&gt;InternalError&lt;/code&gt; , &lt;code&gt;RangeError&lt;/code&gt; , &lt;code&gt;ReferenceError&lt;/code&gt; , &lt;code&gt;SyntaxError&lt;/code&gt; , &lt;code&gt;TypeError&lt;/code&gt; , &lt;code&gt;URIError&lt;/code&gt; 객체.</target>
        </trans-unit>
        <trans-unit id="eae1040c145850f9c2f78efb6a78bc4717881a1a" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Object.defineProperty()&lt;/code&gt;, &lt;code&gt;Object.defineProperties()&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;Object.defineProperty()&lt;/code&gt; , &lt;code&gt;Object.defineProperties()&lt;/code&gt; , &lt;code&gt;Object.getOwnPropertyDescriptor()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="11d9d3c73dce6340923a9260299449313af2b8fe" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Object.getPrototypeOf()&lt;/code&gt;, &lt;code&gt;Object.prototype.isPrototypeOf()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;Object.getPrototypeOf()&lt;/code&gt; , &lt;code&gt;Object.prototype.isPrototypeOf()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="75e075015e6d9c41a822e73006ccd5352e393dcc" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Object.keys()&lt;/code&gt;, &lt;code&gt;Object.prototype.hasOwnProperty()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;Object.keys()&lt;/code&gt; , &lt;code&gt;Object.prototype.hasOwnProperty()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="236b8502be33ea6d2af05a120c0b5bf17c8dd39f" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;Object.preventExtensions()&lt;/code&gt;, &lt;code&gt;Object.isExtensible()&lt;/code&gt;, &lt;code&gt;Object.freeze()&lt;/code&gt;, &lt;code&gt;Object.isFrozen()&lt;/code&gt;, &lt;code&gt;Object.seal()&lt;/code&gt;, &lt;code&gt;Object.isSealed()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;Object.preventExtensions()&lt;/code&gt; , &lt;code&gt;Object.isExtensible()&lt;/code&gt; , &lt;code&gt;Object.freeze()&lt;/code&gt; , &lt;code&gt;Object.isFrozen()&lt;/code&gt; , &lt;code&gt;Object.seal()&lt;/code&gt; , &lt;code&gt;Object.isSealed()&lt;/code&gt; 메서드.</target>
        </trans-unit>
        <trans-unit id="bdf937865d70c9e60dfb914e62e78e5e206d9581" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;String.padStart()&lt;/code&gt; and &lt;code&gt;String.padEnd()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;String.padStart()&lt;/code&gt; 및 &lt;code&gt;String.padEnd()&lt;/code&gt; 메서드.</target>
        </trans-unit>
        <trans-unit id="98cdff023a1ea3880ed0018df9eecaa9a54717fe" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;console.log()&lt;/code&gt; and &lt;code&gt;console.help()&lt;/code&gt; methods in interactive shell.</source>
          <target state="translated">기능 : 대화식 쉘의 &lt;code&gt;console.log()&lt;/code&gt; 및 &lt;code&gt;console.help()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="b87dd0e60e7427efccbe070b66255fbc7227e3db" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;console.time()&lt;/code&gt; and &lt;code&gt;console.timeEnd()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;console.time()&lt;/code&gt; 및 &lt;code&gt;console.timeEnd()&lt;/code&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="7167ad2d56aad105a91afc37ea54b591d7327812" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;for-in&lt;/code&gt; loops support variable declaration.</source>
          <target state="translated">기능 : &lt;code&gt;for&lt;/code&gt; 및 &lt;code&gt;for-in&lt;/code&gt; 루프는 변수 선언을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7936934d94e6d24eb476832e689df3b4d09d6adc" translate="yes" xml:space="preserve">
          <source>Feature: &lt;code&gt;setTimeout()&lt;/code&gt; and &lt;code&gt;clearTimeout()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : &lt;code&gt;setTimeout()&lt;/code&gt; 및 &lt;code&gt;clearTimeout()&lt;/code&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="96e9b8eed8568affd21d5bc258877b736c43e340" translate="yes" xml:space="preserve">
          <source>Feature: Byte string to &lt;code&gt;hex&lt;/code&gt;, &lt;code&gt;base64&lt;/code&gt;, &lt;code&gt;base64url&lt;/code&gt; encodings.</source>
          <target state="translated">기능 : 바이트 문자열을 &lt;code&gt;hex&lt;/code&gt; , &lt;code&gt;base64&lt;/code&gt; , &lt;code&gt;base64url&lt;/code&gt; 인코딩으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="bad15df805bdeb690470fd1e9fef54b3aab622cf" translate="yes" xml:space="preserve">
          <source>Feature: ES6 &lt;code&gt;Math&lt;/code&gt; methods.</source>
          <target state="translated">특징 : ES6 &lt;code&gt;Math&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="033eeb5e2dc299e3b4414d27b946042b6ac63fb8" translate="yes" xml:space="preserve">
          <source>Feature: HTTP &lt;a href=&quot;reference#r_internal_redirect&quot;&gt;internalRedirect()&lt;/a&gt; method.</source>
          <target state="translated">기능 : HTTP &lt;a href=&quot;reference#r_internal_redirect&quot;&gt;internalRedirect ()&lt;/a&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="78377604ab6ad3ea4c693bd57069171b26dcd9c2" translate="yes" xml:space="preserve">
          <source>Feature: HTTP &lt;code&gt;return()&lt;/code&gt; method.</source>
          <target state="translated">기능 : HTTP &lt;code&gt;return()&lt;/code&gt; 메서드</target>
        </trans-unit>
        <trans-unit id="4719a33cdd186f24658aab7b38c2def72d04d351" translate="yes" xml:space="preserve">
          <source>Feature: HTTP &lt;code&gt;subrequest()&lt;/code&gt; method.</source>
          <target state="translated">기능 : HTTP &lt;code&gt;subrequest()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="5fe84fd411c12d90490695d415ef1522dd9bad2e" translate="yes" xml:space="preserve">
          <source>Feature: HTTP and stream &lt;code&gt;warn()&lt;/code&gt; and &lt;code&gt;error()&lt;/code&gt; methods.</source>
          <target state="translated">기능 : HTTP 및 스트림 &lt;code&gt;warn()&lt;/code&gt; 및 &lt;code&gt;error()&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="c9a87f241196d649bc83c9e66c4e47d8817c8019" translate="yes" xml:space="preserve">
          <source>Feature: HTTP request body getter.</source>
          <target state="translated">기능 : HTTP 요청 본문 게터.</target>
        </trans-unit>
        <trans-unit id="55881c8990a04908eec6b5e8d56f39904a392d4f" translate="yes" xml:space="preserve">
          <source>Feature: Interactive shell.</source>
          <target state="translated">기능 : 대화식 쉘.</target>
        </trans-unit>
        <trans-unit id="92a053e1f5910196868f312460437d8e29bee706" translate="yes" xml:space="preserve">
          <source>Feature: JSON object.</source>
          <target state="translated">기능 : JSON 객체.</target>
        </trans-unit>
        <trans-unit id="da3bbb842168674996d216c7b1f7ea915424af2b" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#fs_renamesync&quot;&gt;&lt;code&gt;fs.renameSync()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#fs_renamesync&quot;&gt; &lt;code&gt;fs.renameSync()&lt;/code&gt; &lt;/a&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="0f9f846b421df65964e3f011a9e84dc448d283cd" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#global_process&quot;&gt;&lt;code&gt;process&lt;/code&gt;&lt;/a&gt; global object.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#global_process&quot;&gt; &lt;code&gt;process&lt;/code&gt; &lt;/a&gt; 전역 객체를 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="7f379646275718d8455de66c576f7e29ab27cc2c" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#object_entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#object_entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; 메소드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0e7671044222768c1e0ef19fc73470435e2f68c9" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#object_values&quot;&gt;&lt;code&gt;Object.values()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#object_values&quot;&gt; &lt;code&gt;Object.values()&lt;/code&gt; &lt;/a&gt; 메소드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="75160bb1e83d7f6c25aae9a1ba2518158fc89cbd" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#process&quot;&gt;&lt;code&gt;process&lt;/code&gt;&lt;/a&gt; global object.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#process&quot;&gt; &lt;code&gt;process&lt;/code&gt; &lt;/a&gt; 전역 개체 추가 .</target>
        </trans-unit>
        <trans-unit id="c2c94b304fdd1163ad17b6a1868d2bdb8313e3a9" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#querystring&quot;&gt;&lt;code&gt;Query String&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#querystring&quot;&gt; &lt;code&gt;Query String&lt;/code&gt; &lt;/a&gt; 모듈 추가 .</target>
        </trans-unit>
        <trans-unit id="50f9e3da4d3c78947e4aa416230a21c91491846f" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;reference#textdecoder&quot;&gt;&lt;code&gt;TextDecoder()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference#textencoder&quot;&gt;&lt;code&gt;TextEncoder()&lt;/code&gt;&lt;/a&gt; implementation.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#textdecoder&quot;&gt; &lt;code&gt;TextDecoder()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference#textencoder&quot;&gt; &lt;code&gt;TextEncoder()&lt;/code&gt; &lt;/a&gt; 구현이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="42f4429b087051892e2f6c2510fb8b9933d69f87" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;a href=&quot;typescript&quot;&gt;TypeScript&lt;/a&gt; API description.</source>
          <target state="translated">기능 : &lt;a href=&quot;typescript&quot;&gt;TypeScript&lt;/a&gt; API 설명이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a7eecb95bb5b7694a30a1655bd55647dabbe4dcd" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;%TypedArray%.prototype.sort()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;%TypedArray%.prototype.sort()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51202b8c3e12fe864ecb35520d435100b44c5942" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;%TypedArray%&lt;/code&gt; remaining methods. The following methods were added: &lt;code&gt;from()&lt;/code&gt;, &lt;code&gt;of()&lt;/code&gt;.</source>
          <target state="translated">기능 : 나머지 &lt;code&gt;%TypedArray%&lt;/code&gt; 메서드를 추가했습니다 . 다음 메소드가 추가되었습니다 : &lt;code&gt;from()&lt;/code&gt; , &lt;code&gt;of()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50eed0eef48a8188fdeaa07524a3926d6a936f15" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Array.prototype.copyWithin()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Array.prototype.copyWithin()&lt;/code&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d4bd212e2a3bc175072879896fa54c772ef696fa" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;ArrayBuffer&lt;/code&gt; support. Thanks to Tiago Natel de Moura.</source>
          <target state="translated">기능 : &lt;code&gt;ArrayBuffer&lt;/code&gt; 지원 추가 . Tiago Natel de Moura에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="b10f7b9253e16c2b04d169fc26346787c409cc12" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Buffer&lt;/code&gt; object implementation.</source>
          <target state="translated">기능 : &lt;code&gt;Buffer&lt;/code&gt; 객체 구현 추가 .</target>
        </trans-unit>
        <trans-unit id="1573fcfd9be8e91ce28cf3980016d6cd6ccee444" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;DataView&lt;/code&gt; object.</source>
          <target state="translated">기능 : &lt;code&gt;DataView&lt;/code&gt; 개체 추가 .</target>
        </trans-unit>
        <trans-unit id="4a07a6316bccbdb76b7f37460bc4cf59e132567c" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Function.prototype.length&lt;/code&gt;.</source>
          <target state="translated">기능 : 추가 &lt;code&gt;Function.prototype.length&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="cc3de3671e7d80f31a47cc9e4593a9abea68cd4a" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Number.prototype.toExponential()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Number.prototype.toExponential()&lt;/code&gt; 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="32b662c58dfecf66b6e87172915d1d36c6d2df5e" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Number.prototype.toFixed()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Number.prototype.toFixed()&lt;/code&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="45a48ffbf980f1c3dbd75703f77156d0c67104c3" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Number.prototype.toPrecision()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Number.prototype.toPrecision()&lt;/code&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="aac3d335c848035e1789a9ade21e156a86639058" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.assign()&lt;/code&gt;.</source>
          <target state="translated">기능 : 추가 된 &lt;code&gt;Object.assign()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9386774411eaa858f2569fdd1d4a449b420dffab" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.entries()&lt;/code&gt; method.</source>
          <target state="translated">기능 : &lt;code&gt;Object.entries()&lt;/code&gt; 메서드 추가 .</target>
        </trans-unit>
        <trans-unit id="2aec8114be7a780eae286f79cc3b91761becc0a5" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.getOwnPropertyDescriptors()&lt;/code&gt;. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : &lt;code&gt;Object.getOwnPropertyDescriptors()&lt;/code&gt; 추가 . Artem S. Povalyukhin에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="44a4683fadec9184877fa866514378f2962b6c05" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt;. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">특징 : 추가 &lt;code&gt;Object.getOwnPropertyNames()&lt;/code&gt; . Artem S. Povalyukhin에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="eb5097e21b1004f32183894216796eeed4a3d4a6" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.is()&lt;/code&gt;. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : &lt;code&gt;Object.is()&lt;/code&gt; 추가 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="7a1a84ec5261c616caac4f1379d4c8e815e5d1a7" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.prototype.propertyIsEnumerable()&lt;/code&gt;.</source>
          <target state="translated">특징 : 추가 &lt;code&gt;Object.prototype.propertyIsEnumerable()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b16cc4a09b22d81f61296cb47377e7537fc7975" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.setPrototypeOf()&lt;/code&gt;. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : &lt;code&gt;Object.setPrototypeOf()&lt;/code&gt; 추가 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="6b8284169b181d881e37826bcd9f1de66e2de834" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object.values()&lt;/code&gt; method.</source>
          <target state="translated">기능 : &lt;code&gt;Object.values()&lt;/code&gt; 메서드 추가 .</target>
        </trans-unit>
        <trans-unit id="3065ad2ad94c34e4c32f75aa29bc734c5b48d5c3" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Object&lt;/code&gt; shorthand methods and computed property names. Thanks to 洪志道 (Hong Zhi Dao) and Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 추가 된 &lt;code&gt;Object&lt;/code&gt; 약식 메서드 및 계산 된 속성 이름. 洪志 道 (Hong Zhi Dao)와 Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="08b01854a9c9a1e98799d5839123846fd3338dad" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Promise&lt;/code&gt; support for &lt;a href=&quot;reference#r_subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;. If a callback is not provided, &lt;a href=&quot;reference#r_subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt; returns an ordinary &lt;code&gt;Promise&lt;/code&gt; object that resolves to a subrequest response object.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#r_subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 대한 &lt;code&gt;Promise&lt;/code&gt; 지원 추가 . 콜백이 제공되지 않으면 &lt;a href=&quot;reference#r_subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 는 하위 요청 응답 객체 로 확인되는 일반 &lt;code&gt;Promise&lt;/code&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4c74e6b5fc47e75aaf192c28c7573ee985ffafab" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;Promise&lt;/code&gt; support. Implemented according to the specification without: &lt;code&gt;Promise.all()&lt;/code&gt;, &lt;code&gt;Promise.allSettled()&lt;/code&gt;, &lt;code&gt;Promise.race()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Promise&lt;/code&gt; 지원 추가 . 사양에 따라 &lt;code&gt;Promise.all()&lt;/code&gt; , &lt;code&gt;Promise.allSettled()&lt;/code&gt; , &lt;code&gt;Promise.race()&lt;/code&gt; 없이 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="d01595394b4315c7dbf74ec6e987f6000cb3d060" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;RegExp.prototype[Symbol.replace]&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;RegExp.prototype[Symbol.replace]&lt;/code&gt; 추가 .</target>
        </trans-unit>
        <trans-unit id="f16742b8e971eab16a552382172a4270f3a97cb2" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;String.prototype.trimEnd()&lt;/code&gt; and &lt;code&gt;String.prototype.trimStart()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;String.prototype.trimEnd()&lt;/code&gt; 및 &lt;code&gt;String.prototype.trimStart()&lt;/code&gt; 추가됨 .</target>
        </trans-unit>
        <trans-unit id="5c521b1341e371e6bb78306c091f247c4fabf91c" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;js_import&lt;/code&gt; directive for &lt;a href=&quot;../http/ngx_http_js_module#js_import&quot;&gt;http&lt;/a&gt; and &lt;a href=&quot;../stream/ngx_stream_js_module#js_import&quot;&gt;stream&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;../http/ngx_http_js_module#js_import&quot;&gt;http&lt;/a&gt; 및 &lt;a href=&quot;../stream/ngx_stream_js_module#js_import&quot;&gt;stream에&lt;/a&gt; 대한 &lt;code&gt;js_import&lt;/code&gt; 지시문 추가 .</target>
        </trans-unit>
        <trans-unit id="3c75f91e9ce6c9a9810055aa3e6093e794ba21dc" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;promises&lt;/code&gt; API for &lt;a href=&quot;reference#njs_api_fs&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt; module. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#njs_api_fs&quot;&gt; &lt;code&gt;fs&lt;/code&gt; &lt;/a&gt; 모듈에 대한 &lt;code&gt;promises&lt;/code&gt; API 추가 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="8dd323d019930f4543dfcd662ecc4cb0fb2935c6" translate="yes" xml:space="preserve">
          <source>Feature: added &lt;code&gt;setImmediate()&lt;/code&gt; method.</source>
          <target state="translated">기능 : &lt;code&gt;setImmediate()&lt;/code&gt; 메소드가 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="c5082398d70d0caa800e724261dd94385b9a7c1f" translate="yes" xml:space="preserve">
          <source>Feature: added array length setter.</source>
          <target state="translated">기능 : 배열 길이 설정 기가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="e425299b81b6b0eb05d772409cbdf3b2687fe456" translate="yes" xml:space="preserve">
          <source>Feature: added arrow functions support. Thanks to 洪志道 (Hong Zhi Dao) and Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 추가 된 화살표 기능 지원. 洪志 道 (Hong Zhi Dao)와 Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="ebdcd535c6d447fa3108a2575b9ae52f22cc1cc2" translate="yes" xml:space="preserve">
          <source>Feature: added block scoped function definitions support.</source>
          <target state="translated">기능 : 추가 된 블록 범위 기능 정의 지원.</target>
        </trans-unit>
        <trans-unit id="963ccc1b3d8ab909be5dee246c08a420b9727e0e" translate="yes" xml:space="preserve">
          <source>Feature: added detached mode for &lt;a href=&quot;reference#r_subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;. Responses to detached subrequests are ignored. Unlike ordinary subrequests, a detached subrequest can be created inside a variable handler.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#r_subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 대한 분리 모드 추가 . 분리 된 하위 요청에 대한 응답은 무시됩니다. 일반 하위 요청과 달리 분리 된 하위 요청은 변수 핸들러 내에서 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc750ac6a33f2e713585b6b5f53899500da7bf25" translate="yes" xml:space="preserve">
          <source>Feature: added externals support for &lt;code&gt;JSON.stringify()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;JSON.stringify()&lt;/code&gt; 대한 외부 지원 추가 .</target>
        </trans-unit>
        <trans-unit id="78a3c3d6a6694c1434ab9632c33a9c55c9c4a02d" translate="yes" xml:space="preserve">
          <source>Feature: added generic implementation of &lt;code&gt;Array.prototype.fill()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;Array.prototype.fill()&lt;/code&gt; 의 일반 구현이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="69818c047dbb6618f1fc6c89e610954121c236ae" translate="yes" xml:space="preserve">
          <source>Feature: added getter/setter literal support. Thanks to 洪志道 (Hong Zhi Dao) and Artem S. Povalyukhin.</source>
          <target state="translated">기능 : getter / setter 리터럴 지원 추가. 洪志 道 (Hong Zhi Dao)와 Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="f016008244bd05d3f78555e323d77c2f46a3a28a" translate="yes" xml:space="preserve">
          <source>Feature: added initial &lt;code&gt;Symbol&lt;/code&gt; support. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 초기 &lt;code&gt;Symbol&lt;/code&gt; 지원 추가 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="0fc2064309557b92100c490438279be0fe09b098" translate="yes" xml:space="preserve">
          <source>Feature: added initial ES6 modules support. Default import and default export statements are supported. Thanks to 洪志道 (Hong Zhi Dao).</source>
          <target state="translated">기능 : 초기 ES6 모듈 지원 추가. 기본 가져 오기 및 기본 내보내기 문이 지원됩니다. 洪志 道 (홍지 다오)에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="3ff5c1d5a807bf634f2545d9755a374e1f5719c3" translate="yes" xml:space="preserve">
          <source>Feature: added initial Typed-arrays support. Thanks to Tiago Natel de Moura.</source>
          <target state="translated">기능 : 초기 유형 배열 지원 추가. Tiago Natel de Moura에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="fda054542bcf7323a67f97c460639a1f8831aac6" translate="yes" xml:space="preserve">
          <source>Feature: added labels support.</source>
          <target state="translated">기능 : 추가 된 레이블 지원.</target>
        </trans-unit>
        <trans-unit id="65476eb705c828c5e010db3569ac852d1ced05dc" translate="yes" xml:space="preserve">
          <source>Feature: added new &lt;code&gt;Function()&lt;/code&gt; support.</source>
          <target state="translated">기능 : 새로운 &lt;code&gt;Function()&lt;/code&gt; 지원 추가 .</target>
        </trans-unit>
        <trans-unit id="150803f9443bae9b3491085df7ea967e40efa543" translate="yes" xml:space="preserve">
          <source>Feature: added remaining methods for &lt;code&gt;%TypedArray%.prototype&lt;/code&gt;. The following methods were added: &lt;code&gt;every()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;findIndex()&lt;/code&gt;, &lt;code&gt;forEach()&lt;/code&gt;, &lt;code&gt;includes()&lt;/code&gt;, &lt;code&gt;indexOf()&lt;/code&gt;, &lt;code&gt;lastIndexOf()&lt;/code&gt;, &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;reduce()&lt;/code&gt;, &lt;code&gt;reduceRight()&lt;/code&gt;, &lt;code&gt;reverse()&lt;/code&gt;, &lt;code&gt;some()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;%TypedArray%.prototype&lt;/code&gt; 대한 나머지 메서드를 추가 했습니다 . 다음 메소드가 추가되었습니다 : &lt;code&gt;every()&lt;/code&gt; , &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;find()&lt;/code&gt; , &lt;code&gt;findIndex()&lt;/code&gt; , &lt;code&gt;forEach()&lt;/code&gt; , &lt;code&gt;includes()&lt;/code&gt; , &lt;code&gt;indexOf()&lt;/code&gt; , &lt;code&gt;lastIndexOf()&lt;/code&gt; , &lt;code&gt;map()&lt;/code&gt; , &lt;code&gt;reduce()&lt;/code&gt; , &lt;code&gt;reduceRight()&lt;/code&gt; , &lt;code&gt;reverse()&lt;/code&gt; , &lt;code&gt;some()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0939c7272a4b4c88638c095965c01e9c2ee6abf3" translate="yes" xml:space="preserve">
          <source>Feature: added runtime support for property getter/setter. Thanks to 洪志道 (Hong Zhi Dao) and Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 속성 getter / setter에 대한 런타임 지원이 추가되었습니다. 洪志 道 (Hong Zhi Dao)와 Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="58edecce7be92229069e7a6547bf1f18bcde8e3c" translate="yes" xml:space="preserve">
          <source>Feature: added script arguments support in CLI.</source>
          <target state="translated">기능 : CLI에서 추가 된 스크립트 인수 지원.</target>
        </trans-unit>
        <trans-unit id="19a3150be2c327cc0ee6f33dd045b670f911ce07" translate="yes" xml:space="preserve">
          <source>Feature: added shebang support in CLI.</source>
          <target state="translated">기능 : CLI에서 shebang 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="1870418cda6b99e907d03c2707059291faf098d7" translate="yes" xml:space="preserve">
          <source>Feature: added support for &lt;code&gt;ArrayBuffer&lt;/code&gt; in &lt;a href=&quot;reference#textdecoder_decode&quot;&gt;&lt;code&gt;TextDecoder.prototype.decode()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">특징 : 지원이 추가 &lt;code&gt;ArrayBuffer&lt;/code&gt; 에서 &lt;a href=&quot;reference#textdecoder_decode&quot;&gt; &lt;code&gt;TextDecoder.prototype.decode()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a98f02277eb0643f2708ccf5c290ba48564b320c" translate="yes" xml:space="preserve">
          <source>Feature: added support for &lt;code&gt;Buffer&lt;/code&gt; object in &lt;a href=&quot;reference#crypto&quot;&gt;&lt;code&gt;crypto&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#crypto&quot;&gt; &lt;code&gt;crypto&lt;/code&gt; &lt;/a&gt; 방법 에서 &lt;code&gt;Buffer&lt;/code&gt; 개체에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4e39e933d7d06742ec27609ca2f712f20f9e53da" translate="yes" xml:space="preserve">
          <source>Feature: added support for &lt;code&gt;Buffer&lt;/code&gt; object in &lt;a href=&quot;reference#njs_api_fs&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#njs_api_fs&quot;&gt; &lt;code&gt;fs&lt;/code&gt; &lt;/a&gt; 메서드 에서 &lt;code&gt;Buffer&lt;/code&gt; 개체에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="aad078a1d2bcd5845bc155b87a1c075ea7e69c2c" translate="yes" xml:space="preserve">
          <source>Feature: added support for RegExp &lt;code&gt;groups&lt;/code&gt; object (ES9).</source>
          <target state="translated">기능 : RegExp &lt;code&gt;groups&lt;/code&gt; 개체 (ES9)에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="021b008724878b2c7c5f82c32dfc7e3870ca84df" translate="yes" xml:space="preserve">
          <source>Feature: added support for building with GNU Readline library.</source>
          <target state="translated">기능 : GNU Readline 라이브러리를 사용한 빌드 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b780c3b8a2759acc43b62c6ad275a25b828e356f" translate="yes" xml:space="preserve">
          <source>Feature: added support for delete operation in &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; 에서 삭제 작업에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ec33fa1d2202b8decc36ae1a22ab901d15f4686e" translate="yes" xml:space="preserve">
          <source>Feature: added support for labels in &lt;code&gt;console.time()&lt;/code&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;console.time()&lt;/code&gt; 에 레이블 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="45f41e91b544367d2adfb25526a8b8e83b1c01fd" translate="yes" xml:space="preserve">
          <source>Feature: added support for module mode execution in CLI. In module mode global, this is unavailable.</source>
          <target state="translated">기능 : CLI에서 모듈 모드 실행에 대한 지원이 추가되었습니다. 글로벌 모듈 모드에서는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3fb968b6d609ecadde830e87d109fee88bece4b1" translate="yes" xml:space="preserve">
          <source>Feature: added support for multi-value headers in &lt;a href=&quot;reference#r_headers_in&quot;&gt;&lt;code&gt;r.headersIn{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#r_headers_in&quot;&gt; &lt;code&gt;r.headersIn{}&lt;/code&gt; &lt;/a&gt; 다중 값 헤더에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f965fb30baee4f0fcf69adc80ac679b126f9b391" translate="yes" xml:space="preserve">
          <source>Feature: added support for multi-value headers in &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; 에 다중 값 헤더에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6f002bd64557c1ce5e7bf249a9084093661129c6" translate="yes" xml:space="preserve">
          <source>Feature: added support for numeric separators (ES12).</source>
          <target state="translated">기능 : 숫자 구분 기호 (ES12)에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="30f0b51c96c4a2850b96b37e0438b292b3f4cb48" translate="yes" xml:space="preserve">
          <source>Feature: added support for setting nginx variables.</source>
          <target state="translated">기능 : nginx 변수 설정에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bbcdbeaf76649e711e28ca90c15c31644102a3dc" translate="yes" xml:space="preserve">
          <source>Feature: added support for shorthand property names for Object literals.</source>
          <target state="translated">기능 : 객체 리터럴에 대한 속기 속성 이름에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="d922c19aebafc6645a8b2f01a4ca52ea07eab496" translate="yes" xml:space="preserve">
          <source>Feature: added support for template literals. Thanks to 洪志道 (Hong Zhi Dao) and Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 템플릿 리터럴에 대한 지원이 추가되었습니다. 洪志 道 (Hong Zhi Dao)와 Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="5c30d3aa432b3558fbc81bd72b9ff32cbcac975f" translate="yes" xml:space="preserve">
          <source>Feature: added support of binary literals.</source>
          <target state="translated">기능 : 이진 리터럴에 대한 지원이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="afbe44ea335d154ff8afc20a30964daa7c5e9e6a" translate="yes" xml:space="preserve">
          <source>Feature: added the &lt;code&gt;js_path&lt;/code&gt; directive for &lt;a href=&quot;../http/ngx_http_js_module#js_path&quot;&gt;http&lt;/a&gt; and &lt;a href=&quot;../stream/ngx_stream_js_module#js_path&quot;&gt;stream&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;a href=&quot;../http/ngx_http_js_module#js_path&quot;&gt;http&lt;/a&gt; 및 &lt;a href=&quot;../stream/ngx_stream_js_module#js_path&quot;&gt;stream에&lt;/a&gt; 대한 &lt;code&gt;js_path&lt;/code&gt; 지시문을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="3e4d59f2b3052d89ec43ab63d33a6b89c644516a" translate="yes" xml:space="preserve">
          <source>Feature: added the pretty string representation for values.</source>
          <target state="translated">기능 : 값에 대한 예쁜 문자열 표현을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="c0526bf58f8f7d84094f9b36c2f11e729fed8637" translate="yes" xml:space="preserve">
          <source>Feature: allowing variables and functions to be redeclared.</source>
          <target state="translated">기능 : 변수 및 함수를 다시 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68c01fb8ac78e5a5db536cf6d352a5933e076002" translate="yes" xml:space="preserve">
          <source>Feature: arguments object support.</source>
          <target state="translated">특징 : 인수 객체 지원.</target>
        </trans-unit>
        <trans-unit id="bfbc3a5a85edb91ab6d8d78dab14f6ea63143f3f" translate="yes" xml:space="preserve">
          <source>Feature: converting externals values to native js objects.</source>
          <target state="translated">기능 : 외부 값을 네이티브 js 객체로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="792758345e0da2443e3685546f00a17e8da9fc94" translate="yes" xml:space="preserve">
          <source>Feature: correctly parsing floating point numbers.</source>
          <target state="translated">기능 : 부동 소수점 숫자를 올바르게 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="86d3cd4dad082e0200a79309242cc3ffa7e73734" translate="yes" xml:space="preserve">
          <source>Feature: correctly printing floating point numbers.</source>
          <target state="translated">기능 : 부동 소수점 숫자를 올바르게 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="cb1e94e3de7ddfb0b5307ac460d47ec768616348" translate="yes" xml:space="preserve">
          <source>Feature: executing command from command line arguments.</source>
          <target state="translated">기능 : 명령 행 인수에서 명령 실행</target>
        </trans-unit>
        <trans-unit id="9c333591ddd771c14fc03760d3fd4ea948895270" translate="yes" xml:space="preserve">
          <source>Feature: exponentiation operators.</source>
          <target state="translated">특징 : 지수 연산자.</target>
        </trans-unit>
        <trans-unit id="c0246bb0e9e9e58e2c6f0fd8c4f1c95cd2a9bf52" translate="yes" xml:space="preserve">
          <source>Feature: extended &lt;a href=&quot;reference#njs_api_fs&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt; module. Added &lt;a href=&quot;reference#fs_accesssync&quot;&gt;&lt;code&gt;access()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#fs_symlinksync&quot;&gt;&lt;code&gt;symlink()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#fs_unlinksync&quot;&gt;&lt;code&gt;unlink()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#fs_realpathsync&quot;&gt;&lt;code&gt;realpath()&lt;/code&gt;&lt;/a&gt;, and friends. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 확장 된 &lt;a href=&quot;reference#njs_api_fs&quot;&gt; &lt;code&gt;fs&lt;/code&gt; &lt;/a&gt; 모듈. 추가 &lt;a href=&quot;reference#fs_accesssync&quot;&gt; &lt;code&gt;access()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#fs_symlinksync&quot;&gt; &lt;code&gt;symlink()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#fs_unlinksync&quot;&gt; &lt;code&gt;unlink()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#fs_realpathsync&quot;&gt; &lt;code&gt;realpath()&lt;/code&gt; &lt;/a&gt; , 친구. Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="b12b1f1d846559dc7455b8d3a827dac332dbadc2" translate="yes" xml:space="preserve">
          <source>Feature: extended &lt;a href=&quot;reference#njs_api_fs&quot;&gt;&lt;code&gt;fs&lt;/code&gt;&lt;/a&gt; module. Added &lt;a href=&quot;reference#fs_mkdirsync&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#fs_readdirsync&quot;&gt;&lt;code&gt;readdir()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#fs_rmdirsync&quot;&gt;&lt;code&gt;rmdir()&lt;/code&gt;&lt;/a&gt;, and friends.</source>
          <target state="translated">기능 : 확장 된 &lt;a href=&quot;reference#njs_api_fs&quot;&gt; &lt;code&gt;fs&lt;/code&gt; &lt;/a&gt; 모듈. 추가 &lt;a href=&quot;reference#fs_mkdirsync&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#fs_readdirsync&quot;&gt; &lt;code&gt;readdir()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#fs_rmdirsync&quot;&gt; &lt;code&gt;rmdir()&lt;/code&gt; &lt;/a&gt; , 친구.</target>
        </trans-unit>
        <trans-unit id="b4b61ed44e94fcfeae6096656e9420e06abc98c1" translate="yes" xml:space="preserve">
          <source>Feature: extending &lt;code&gt;Object.defineProperty()&lt;/code&gt; spec conformance.</source>
          <target state="translated">기능 : &lt;code&gt;Object.defineProperty()&lt;/code&gt; 사양 준수 확장</target>
        </trans-unit>
        <trans-unit id="aac7d4fa3cb7a52c38a1b7220dedc4319b8b2fd5" translate="yes" xml:space="preserve">
          <source>Feature: hexadecimal (&lt;code&gt;0x1123&lt;/code&gt;) literals support.</source>
          <target state="translated">기능 : 16 진 ( &lt;code&gt;0x1123&lt;/code&gt; ) 리터럴 지원.</target>
        </trans-unit>
        <trans-unit id="a04a116ba5748b0498b1bd3333f00b43a45b7a0e" translate="yes" xml:space="preserve">
          <source>Feature: improved &lt;a href=&quot;reference#fs_mkdirsync&quot;&gt;&lt;code&gt;fs.mkdir()&lt;/code&gt;&lt;/a&gt; to support recursive directory creation. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 재귀 디렉토리 생성을 지원하도록 &lt;a href=&quot;reference#fs_mkdirsync&quot;&gt; &lt;code&gt;fs.mkdir()&lt;/code&gt; &lt;/a&gt; 이 개선되었습니다 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="0e96af77c2eb49d40b425fb5fb723f18c8165d1f" translate="yes" xml:space="preserve">
          <source>Feature: improved &lt;a href=&quot;reference#fs_rmdirsync&quot;&gt;&lt;code&gt;fs.rmdir()&lt;/code&gt;&lt;/a&gt; to support recursive directory removal. Thanks to Artem S. Povalyukhin.</source>
          <target state="translated">기능 : 재귀 디렉토리 제거를 지원하도록 &lt;a href=&quot;reference#fs_rmdirsync&quot;&gt; &lt;code&gt;fs.rmdir()&lt;/code&gt; &lt;/a&gt; 이 개선되었습니다 . Artem S. Povalyukhin에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="34ab66ea47ffd916ab412e582c10c6ea1973d683" translate="yes" xml:space="preserve">
          <source>Feature: interactive shell by default if &lt;code&gt;libedit&lt;/code&gt; is available.</source>
          <target state="translated">기능 : &lt;code&gt;libedit&lt;/code&gt; 를 사용할 수있는 경우 기본적으로 대화식 쉘 .</target>
        </trans-unit>
        <trans-unit id="204ab079211d2bb3e70216d046888729422a05ba" translate="yes" xml:space="preserve">
          <source>Feature: interactive shell prints backtrace on exception.</source>
          <target state="translated">기능 : 대화식 쉘은 예외시 역 추적을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="490ad9606e24a82d159b3313db21100b0ac14ebb" translate="yes" xml:space="preserve">
          <source>Feature: introduced &lt;code&gt;raw headers&lt;/code&gt; API: &lt;a href=&quot;reference#r_raw_headers_in&quot;&gt;&lt;code&gt;r.rawHeadersIn{}&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;reference#r_raw_headers_out&quot;&gt;&lt;code&gt;r.rawHeadersOut{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능 : &lt;code&gt;raw headers&lt;/code&gt; API 도입 : &lt;a href=&quot;reference#r_raw_headers_in&quot;&gt; &lt;code&gt;r.rawHeadersIn{}&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;reference#r_raw_headers_out&quot;&gt; &lt;code&gt;r.rawHeadersOut{}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="faa39c5a40f7fd455eb8c9157451ccde0a285fb7" translate="yes" xml:space="preserve">
          <source>Feature: introduced UTF-8 decoder according to &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG&lt;/a&gt; encoding spec.</source>
          <target state="translated">기능 : &lt;a href=&quot;https://encoding.spec.whatwg.org/&quot;&gt;WHATWG&lt;/a&gt; 인코딩 사양 에 따라 UTF-8 디코더를 도입했습니다 .</target>
        </trans-unit>
        <trans-unit id="26fe633260e90ebbcf8dcc90d8eee05bff6a0d8f" translate="yes" xml:space="preserve">
          <source>Feature: introduced compact form of backtraces to handle stack overflows.</source>
          <target state="translated">기능 : 스택 오버플로를 처리하기위한 소형 형태의 역 추적을 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="df8b461dbbb6569b6b74427347126c72f15438bb" translate="yes" xml:space="preserve">
          <source>Feature: introduced line level backtrace.</source>
          <target state="translated">기능 : 라인 레벨 역 추적 도입.</target>
        </trans-unit>
        <trans-unit id="ae631b3b53e4512487e97ada30798a6df0285aa5" translate="yes" xml:space="preserve">
          <source>Feature: introduced nullish coalescing operator.</source>
          <target state="translated">기능 : nullish 병합 연산자 도입.</target>
        </trans-unit>
        <trans-unit id="e9274b690ec89e21a47e5a73d50083b4e7caa1f3" translate="yes" xml:space="preserve">
          <source>Feature: introduced quiet mode for CLI to handle simple expressions from stdin.</source>
          <target state="translated">기능 : stdin의 간단한 표현식을 처리하기 위해 CLI에 자동 모드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="fae0c47d21b6729df7b22648c0c2bf1b12826df5" translate="yes" xml:space="preserve">
          <source>Feature: introduced sandboxing mode.</source>
          <target state="translated">기능 : 샌드 박싱 모드를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="c248c46509f048441c26930382f509b2a5e549ed" translate="yes" xml:space="preserve">
          <source>Feature: made all constructor properties configurable.</source>
          <target state="translated">기능 : 모든 생성자 속성을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec35a21c51753913fc0888a95cae72ac0e809b6" translate="yes" xml:space="preserve">
          <source>Feature: made configurable &lt;code&gt;length&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and most of built-in methods.</source>
          <target state="translated">기능 : 구성 가능한 &lt;code&gt;length&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 대부분의 기본 제공 방법을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="fd72596476e2e70895ae76c917ec5e712f83bc09" translate="yes" xml:space="preserve">
          <source>Feature: making &lt;code&gt;__proto__&lt;/code&gt; accessor descriptor of &lt;code&gt;Object&lt;/code&gt; instances mutable.</source>
          <target state="translated">기능 : &lt;code&gt;Object&lt;/code&gt; 인스턴스 의 &lt;code&gt;__proto__&lt;/code&gt; 접근 자 설명자를 변경 가능 하게 만들기</target>
        </trans-unit>
        <trans-unit id="b3dc417b19a78be8e702166d572420c7d8d25d23" translate="yes" xml:space="preserve">
          <source>Feature: making built-in prototypes mutable.</source>
          <target state="translated">기능 : 내장 프로토 타입을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a479d519d077bd41b4fb15cde12ee6a773dc57da" translate="yes" xml:space="preserve">
          <source>Feature: making global object mutable.</source>
          <target state="translated">기능 : 전역 객체를 변경 가능하게 만들기</target>
        </trans-unit>
        <trans-unit id="22f37c1150172683743e962a8e3188f96e2a7524" translate="yes" xml:space="preserve">
          <source>Feature: nested functions and function closures.</source>
          <target state="translated">기능 : 중첩 함수 및 함수 클로저.</target>
        </trans-unit>
        <trans-unit id="cc876562129be8e967d04a943a1c0dd15bdaaef2" translate="yes" xml:space="preserve">
          <source>Feature: nginx modules print backtrace on exception.</source>
          <target state="translated">기능 : nginx 모듈은 예외에 따라 역 추적을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="a7839c293ed1781618fcfd80bc8206a4ca905efe" translate="yes" xml:space="preserve">
          <source>Feature: non-integer fractions support.</source>
          <target state="translated">기능 : 정수가 아닌 분수 지원.</target>
        </trans-unit>
        <trans-unit id="d0ed34646b8c1af48e548ed8eeb2b1e64056a509" translate="yes" xml:space="preserve">
          <source>Feature: object level completions in interactive shell.</source>
          <target state="translated">기능 : 대화식 쉘에서 객체 레벨 완료.</target>
        </trans-unit>
        <trans-unit id="af2b932be226f6f1dcf1957c5298132df68284d8" translate="yes" xml:space="preserve">
          <source>Feature: octal literals support.</source>
          <target state="translated">기능 : 8 진 리터럴 지원.</target>
        </trans-unit>
        <trans-unit id="540cf3fb52b44d27eca1203e1d07d1212669e645" translate="yes" xml:space="preserve">
          <source>Feature: reporting file name and function name in disassembler output.</source>
          <target state="translated">기능 : 디스어셈블러 출력의 파일 이름 및 기능 이름보고.</target>
        </trans-unit>
        <trans-unit id="cbb941dc112abde95bf1c434c94cf987e572262a" translate="yes" xml:space="preserve">
          <source>Feature: reporting njs version by CLI.</source>
          <target state="translated">기능 : CLI로 njs 버전보고.</target>
        </trans-unit>
        <trans-unit id="8bf06619b79cb34faf5fe0e807a25b300be13ff1" translate="yes" xml:space="preserve">
          <source>Feature: rest parameters syntax (destructuring is not supported). Thanks to Alexander Pyshchev.</source>
          <target state="translated">기능 : 나머지 매개 변수 구문 (구조화는 지원되지 않음). Alexander Pyshchev에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="1172e79ab8f07168193e4398f7ecaff8ecf48e32" translate="yes" xml:space="preserve">
          <source>Feature: scientific notation (&lt;code&gt;3.35e10&lt;/code&gt;) literals support.</source>
          <target state="translated">특징 : 과학적 표기법 ( &lt;code&gt;3.35e10&lt;/code&gt; ) 리터럴 지원.</target>
        </trans-unit>
        <trans-unit id="6db63c9e6e878bc12e766a6baa9bf658647b0dc6" translate="yes" xml:space="preserve">
          <source>Feature: textual description for type converting exceptions.</source>
          <target state="translated">기능 : 유형 변환 예외에 대한 텍스트 설명.</target>
        </trans-unit>
        <trans-unit id="ddada8d8d1f8508b4630a3c2e3d2088725db1a35" translate="yes" xml:space="preserve">
          <source>Feature: various configure improvements.</source>
          <target state="translated">기능 : 다양한 구성 개선.</target>
        </trans-unit>
        <trans-unit id="87da6570e97d37c4d09af824350d7d32cd6b0c0a" translate="yes" xml:space="preserve">
          <source>Feature: writable most of built-in properties and methods.</source>
          <target state="translated">기능 : 대부분의 내장 속성 및 메서드를 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da232ab182c6a0bc6ce92507b2cf5e8e9e8c4e0" translate="yes" xml:space="preserve">
          <source>Field values of multi-value response headers (&lt;a href=&quot;changes#njs0.4.0&quot;&gt;0.4.0&lt;/a&gt;) can be set with the syntax:</source>
          <target state="translated">다중 값 응답 헤더 ( &lt;a href=&quot;changes#njs0.4.0&quot;&gt;0.4.0&lt;/a&gt; ) 의 필드 값은 다음 구문을 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd1ebe20dacd6ae2e75d30cfafe2625a9a05834f" translate="yes" xml:space="preserve">
          <source>Fields in &lt;code&gt;ngx_event_t&lt;/code&gt; include:</source>
          <target state="translated">&lt;code&gt;ngx_event_t&lt;/code&gt; 의 필드는 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35122f5af5c6720f2b90f4021e3a932245122a66" translate="yes" xml:space="preserve">
          <source>File Access Constants</source>
          <target state="translated">파일 액세스 상수</target>
        </trans-unit>
        <trans-unit id="a926222b8bec34819e069693ffbdca4d0b2f8b69" translate="yes" xml:space="preserve">
          <source>File System</source>
          <target state="translated">파일 시스템</target>
        </trans-unit>
        <trans-unit id="afdabcc15fdcb6db2739d3bf679a8edcc2e213be" translate="yes" xml:space="preserve">
          <source>File System Flags</source>
          <target state="translated">파일 시스템 플래그</target>
        </trans-unit>
        <trans-unit id="6ce6c512ea433a7fc5c8841628e7696cd0ff7f2b" translate="yes" xml:space="preserve">
          <source>Files</source>
          <target state="translated">Files</target>
        </trans-unit>
        <trans-unit id="705d9697ed2f8198b149449be7b3a9f4c1cb2382" translate="yes" xml:space="preserve">
          <source>Fills the Buffer with the specified &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt;. If the &lt;code&gt;&lt;i&gt;offset&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;end&lt;/i&gt;&lt;/code&gt; are not specified, the entire Buffer will be filled. The &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt; is coerced to &lt;code&gt;&lt;i&gt;uint32&lt;/i&gt;&lt;/code&gt; if it is not a &lt;code&gt;string&lt;/code&gt;, &lt;code&gt;Buffer&lt;/code&gt;, or &lt;code&gt;integer&lt;/code&gt;. If the resulting integer is greater than 255, the Buffer will be filled with &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt; and 255.</source>
          <target state="translated">버퍼를 지정된 &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt; 채 웁니다 . 경우 &lt;code&gt;&lt;i&gt;offset&lt;/i&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;i&gt;end&lt;/i&gt;&lt;/code&gt; 지정되지 않은 전체 버퍼가 채워집니다. &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt; 강제 변환됩니다 &lt;code&gt;&lt;i&gt;uint32&lt;/i&gt;&lt;/code&gt; 그것이 아닌 경우 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;Buffer&lt;/code&gt; , 또는 &lt;code&gt;integer&lt;/code&gt; . 결과 정수가 255보다 크면 버퍼는 &lt;code&gt;&lt;i&gt;value&lt;/i&gt;&lt;/code&gt; 과 255 로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="6a3e51a7512dc7e94baa162dcae36852e69ed04f" translate="yes" xml:space="preserve">
          <source>Finally, files can be read and &lt;a href=&quot;#sendfile&quot;&gt;sent&lt;/a&gt; using multi-threading (1.7.11), without blocking a worker process:</source>
          <target state="translated">마지막으로 작업자 프로세스를 차단하지 않고 멀티 스레딩 (1.7.11)을 사용하여 파일을 읽고 &lt;a href=&quot;#sendfile&quot;&gt;보낼&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d98be8ad7c4fb471c0fbbc3d56f2dee029f8a54a" translate="yes" xml:space="preserve">
          <source>Finally, we got it working:</source>
          <target state="translated">마지막으로 작동하게되었습니다.</target>
        </trans-unit>
        <trans-unit id="986fbd324e6c29173cef4348d337ddf249f4336a" translate="yes" xml:space="preserve">
          <source>Find the timeout that is closest to expiring, by calling &lt;code&gt;ngx_event_find_timer()&lt;/code&gt;. This function finds the leftmost node in the timer tree and returns the number of milliseconds until the node expires.</source>
          <target state="translated">&lt;code&gt;ngx_event_find_timer()&lt;/code&gt; 를 호출하여 만료에 가장 가까운 시간 초과를 찾으십시오 . 이 함수는 타이머 트리에서 가장 왼쪽에있는 노드를 찾고 노드가 만료 될 때까지 밀리 초 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ef2cfbe749e62c78b4187bd51938a69ef6cb8a66" translate="yes" xml:space="preserve">
          <source>First (assuming Node.js is installed and operational), let's create an empty project and install some dependencies; the commands below assume we are in the working directory:</source>
          <target state="translated">먼저 (Node.js가 설치되고 작동한다고 가정) 빈 프로젝트를 만들고 몇 가지 종속성을 설치해 보겠습니다. 아래 명령은 우리가 작업 디렉토리에 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="dff0c489b48961d76ed0987cf386a57e55dc2d0e" translate="yes" xml:space="preserve">
          <source>First of all &lt;code&gt;objs/ngx_auto_config.h&lt;/code&gt; file generated by configure should be included, because it defines a number of constants affecting various &lt;code&gt;#ifdef&lt;/code&gt;&amp;rsquo;s. After that, some basic types and definitions like &lt;code&gt;ngx_str_t&lt;/code&gt;, &lt;code&gt;ngx_table_elt_t&lt;/code&gt;, &lt;code&gt;ngx_uint_t&lt;/code&gt; etc. should be put at the beginning of the DTrace script. These definitions are compact, commonly used and unlikely to be frequently changed.</source>
          <target state="translated">configure에 의해 생성 된 모든 &lt;code&gt;objs/ngx_auto_config.h&lt;/code&gt; 파일은 다양한 &lt;code&gt;#ifdef&lt;/code&gt; 에 영향을주는 많은 상수를 정의하므로 포함되어야합니다 . 그런 다음 &lt;code&gt;ngx_str_t&lt;/code&gt; , &lt;code&gt;ngx_table_elt_t&lt;/code&gt; , &lt;code&gt;ngx_uint_t&lt;/code&gt; 등과 같은 일부 기본 유형 및 정의 는 DTrace 스크립트의 시작 부분에 있어야합니다. 이러한 정의는 간결하고 일반적으로 사용되며 자주 변경되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="827a34af389ee1f79a43d2558e608f1aa0d5bac4" translate="yes" xml:space="preserve">
          <source>First, create the &lt;code&gt;/data/www&lt;/code&gt; directory and put an &lt;code&gt;index.html&lt;/code&gt; file with any text content into it and create the &lt;code&gt;/data/images&lt;/code&gt; directory and place some images in it.</source>
          <target state="translated">먼저 &lt;code&gt;/data/www&lt;/code&gt; 디렉토리를 만들고 텍스트 내용 이있는 &lt;code&gt;index.html&lt;/code&gt; 파일을 넣고 &lt;code&gt;/data/images&lt;/code&gt; 디렉토리를 만들고 그 안에 이미지를 넣으 십시오.</target>
        </trans-unit>
        <trans-unit id="4d45917ea45ff768f563190869bb5d7488d2162c" translate="yes" xml:space="preserve">
          <source>First, define the proxied server by adding one more &lt;code&gt;server&lt;/code&gt; block to the nginx&amp;rsquo;s configuration file with the following contents:</source>
          <target state="translated">먼저 다음 내용으로 nginx의 구성 파일에 하나 이상의 &lt;code&gt;server&lt;/code&gt; 블록을 추가하여 프록시 서버를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="41bf1b3efa502fb6ae58355c66e9c03ce2afff6a" translate="yes" xml:space="preserve">
          <source>Following is an example of a simple body filter that counts the number of bytes in the body. The result is available as the &lt;code&gt;$counter&lt;/code&gt; variable which can be used in the access log.</source>
          <target state="translated">다음은 본문의 바이트 수를 계산하는 간단한 본문 필터의 예입니다. 결과는 액세스 로그에서 사용할 수있는 &lt;code&gt;$counter&lt;/code&gt; 변수로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="299090156134c39fff9325f6ccb8f600e61ce6d0" translate="yes" xml:space="preserve">
          <source>Following is the example of a preaccess phase handler.</source>
          <target state="translated">다음은 사전 액세스 단계 핸들러의 예입니다.</target>
        </trans-unit>
        <trans-unit id="b2113a7fe694496de426a529a280748126448ebc" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;debug&lt;/code&gt; logging to work, nginx needs to be built with &lt;code&gt;--with-debug&lt;/code&gt;, see &amp;ldquo;&lt;a href=&quot;debugging_log&quot;&gt;A debugging log&lt;/a&gt;&amp;rdquo;.</source>
          <target state="translated">들어 &lt;code&gt;debug&lt;/code&gt; 작업에 로깅, nginx를 필요가로 구축 할 &lt;code&gt;--with-debug&lt;/code&gt; 의 &quot; &lt;a href=&quot;debugging_log&quot;&gt;로그 디버깅&lt;/a&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="afa564787963593f8e25a14b059930fce720aded" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;default&lt;/code&gt; escaping, characters &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;, and other characters with values less than 32 (0.7.0) or above 126 (1.1.6) are escaped as &amp;ldquo;&lt;code&gt;\xXX&lt;/code&gt;&amp;rdquo;. If the variable value is not found, a hyphen (&amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;) will be logged.</source>
          <target state="translated">내용은 &lt;code&gt;default&lt;/code&gt; , 문자 &quot;탈출 &lt;code&gt;&quot;&lt;/code&gt; &quot;,&quot; &lt;code&gt;\&lt;/code&gt; &quot;적은 32 (0.7.0) 또는 (126) 위의 (1.1.6)에 비해 값 및 다른 문자로 이스케이프&quot; &lt;code&gt;\xXX&lt;/code&gt; &quot;. 변수의 값이 발견되지 않는 경우, 하이픈 ( &quot; &lt;code&gt;-&lt;/code&gt; &quot;)이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="607219c61531f5c6902c48f6086c23c12d639211" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;default&lt;/code&gt; escaping, characters &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo;, and other characters with values less than 32 or above 126 are escaped as &amp;ldquo;&lt;code&gt;\xXX&lt;/code&gt;&amp;rdquo;. If the variable value is not found, a hyphen (&amp;ldquo;&lt;code&gt;-&lt;/code&gt;&amp;rdquo;) will be logged.</source>
          <target state="translated">내용은 &lt;code&gt;default&lt;/code&gt; , 문자 &quot;탈출 &lt;code&gt;&quot;&lt;/code&gt; &quot;,&quot; &lt;code&gt;\&lt;/code&gt; &quot;이하 32 위 (126)로 이스케이프 값 및 기타 문자를&quot; &lt;code&gt;\xXX&lt;/code&gt; &quot;변수 값을 찾을 수없는 경우, 하이픈이. (&quot; &lt;code&gt;-&lt;/code&gt; &quot;) 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6a12156a6dd1931845911ce4fced7620bc0659f1" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;json&lt;/code&gt; escaping, all characters not allowed in JSON &lt;a href=&quot;https://tools.ietf.org/html/rfc8259#section-7&quot;&gt;strings&lt;/a&gt; will be escaped: characters &amp;ldquo;&lt;code&gt;&quot;&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo; are escaped as &amp;ldquo;&lt;code&gt;\&quot;&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;\\&lt;/code&gt;&amp;rdquo;, characters with values less than 32 are escaped as &amp;ldquo;&lt;code&gt;\n&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\r&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\t&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\b&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;\f&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;\u00XX&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">들어 &lt;code&gt;json&lt;/code&gt; 탈출, JSON의에서 허용되지 않는 모든 문자 &lt;a href=&quot;https://tools.ietf.org/html/rfc8259#section-7&quot;&gt;문자열은&lt;/a&gt; 이스케이프됩니다 문자 &quot; &lt;code&gt;&quot;&lt;/code&gt; &quot;와&quot; &lt;code&gt;\&lt;/code&gt; &quot;로 이스케이프&quot; &lt;code&gt;\&quot;&lt;/code&gt; &quot; &quot;와 &quot; &lt;code&gt;\\&lt;/code&gt; &quot;문자를 값으로 적은 32 이상과 같이 이스케이프 &quot; &lt;code&gt;\n&lt;/code&gt; &quot;, &amp;ldquo; &lt;code&gt;\r&lt;/code&gt; &amp;rdquo;,&amp;ldquo; &lt;code&gt;\t&lt;/code&gt; &amp;rdquo;,&amp;ldquo; &lt;code&gt;\b&lt;/code&gt; &amp;rdquo;,&amp;ldquo; &lt;code&gt;\f&lt;/code&gt; &amp;rdquo;또는&amp;ldquo; &lt;code&gt;\u00XX&lt;/code&gt; &amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="675c5160bb46cd68e24ab3e56fef13d671e2685c" translate="yes" xml:space="preserve">
          <source>For C strings, nginx uses the unsigned character type pointer &lt;code&gt;u_char *&lt;/code&gt;.</source>
          <target state="translated">C 문자열의 경우 nginx는 부호없는 문자 유형 포인터 &lt;code&gt;u_char *&lt;/code&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="04fe07c8a5b183fac020701310aa4131b54c4574" translate="yes" xml:space="preserve">
          <source>For FastCGI servers, it is required to set &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_keep_conn&quot;&gt;fastcgi_keep_conn&lt;/a&gt; for keepalive connections to work:</source>
          <target state="translated">FastCGI 서버의 경우 keepalive 연결이 작동하도록 &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_keep_conn&quot;&gt;fastcgi_keep_conn&lt;/a&gt; 을 설정 해야합니다.</target>
        </trans-unit>
        <trans-unit id="a1c6264724b3efb23b54b5127b2c44287486eb68" translate="yes" xml:space="preserve">
          <source>For HTTP, the &lt;a href=&quot;ngx_http_proxy_module#proxy_http_version&quot;&gt;proxy_http_version&lt;/a&gt; directive should be set to &amp;ldquo;&lt;code&gt;1.1&lt;/code&gt;&amp;rdquo; and the &amp;ldquo;Connection&amp;rdquo; header field should be cleared:</source>
          <target state="translated">HTTP의 경우 &lt;a href=&quot;ngx_http_proxy_module#proxy_http_version&quot;&gt;proxy_http_version&lt;/a&gt; 지시문을 &quot; &lt;code&gt;1.1&lt;/code&gt; &quot; 로 설정 하고 &quot;연결&quot;헤더 필드를 지워야합니다.</target>
        </trans-unit>
        <trans-unit id="c6fadbcdb8c64d5443e2aabb9fa81b2743318369" translate="yes" xml:space="preserve">
          <source>For Linux, nginx &lt;a href=&quot;https://nginx.org/en/linux_packages.html&quot;&gt;packages&lt;/a&gt; from nginx.org can be used.</source>
          <target state="translated">Linux의 경우 nginx.org의 nginx &lt;a href=&quot;https://nginx.org/en/linux_packages.html&quot;&gt;패키지&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53af671f04e60d2f649ac6f00f99bed92846e99f" translate="yes" xml:space="preserve">
          <source>For Linux, njs modules &lt;a href=&quot;https://nginx.org/en/linux_packages.html#dynmodules&quot;&gt;packages&lt;/a&gt; can be used:</source>
          <target state="translated">Linux의 경우 njs 모듈 &lt;a href=&quot;https://nginx.org/en/linux_packages.html#dynmodules&quot;&gt;패키지를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c100928fda6b30d201696db804df8d540b596ff8" translate="yes" xml:space="preserve">
          <source>For a matching request with a non-zero &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; argument, nginx will read the metadata from the file, prepare the stream with the requested time range, and send it to the client. This has the same overhead as described above.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 인수가 0이 아닌 일치하는 요청의 경우 nginx는 파일에서 메타 데이터를 읽고 요청 된 시간 범위로 스트림을 준비한 후 클라이언트로 보냅니다. 위에서 설명한 것과 동일한 오버 헤드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="08c84647b0b408c85c2ace6dd90661a8ea212785" translate="yes" xml:space="preserve">
          <source>For a resolution of the OCSP responder hostname, the &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver&lt;/a&gt; directive should also be specified.</source>
          <target state="translated">OCSP 응답자 호스트 이름을 확인하려면 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;해결 자&lt;/a&gt; 지시문도 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="bfdacad5b6ae8004496fb73793c817e76621770e" translate="yes" xml:space="preserve">
          <source>For allocating in shared memory, nginx provides the slab pool &lt;code&gt;ngx_slab_pool_t&lt;/code&gt; type. A slab pool for allocating memory is automatically created in each nginx shared zone. The pool is located in the beginning of the shared zone and can be accessed by the expression &lt;code&gt;(ngx_slab_pool_t *) shm_zone-&amp;gt;shm.addr&lt;/code&gt;. To allocate memory in a shared zone, call either &lt;code&gt;ngx_slab_alloc(pool, size)&lt;/code&gt; or &lt;code&gt;ngx_slab_calloc(pool, size)&lt;/code&gt;. To free memory, call &lt;code&gt;ngx_slab_free(pool, p)&lt;/code&gt;.</source>
          <target state="translated">공유 메모리에 할당하기 위해 nginx는 슬래브 풀 &lt;code&gt;ngx_slab_pool_t&lt;/code&gt; 유형을 제공합니다 . 메모리 할당을위한 슬래브 풀은 각 nginx 공유 영역에 자동으로 생성됩니다. 풀은 공유 영역의 시작 부분에 있으며 &lt;code&gt;(ngx_slab_pool_t *) shm_zone-&amp;gt;shm.addr&lt;/code&gt; 표현식으로 액세스 할 수 있습니다 . 공유 영역에 메모리를 할당하려면 &lt;code&gt;ngx_slab_alloc(pool, size)&lt;/code&gt; 또는 &lt;code&gt;ngx_slab_calloc(pool, size)&lt;/code&gt; 호출하십시오 . 메모리를 확보하려면 &lt;code&gt;ngx_slab_free(pool, p)&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a00615089094cab5ef566362e212246dddc44b9d" translate="yes" xml:space="preserve">
          <source>For case-insensitive operating systems such as macOS and Cygwin, matching with prefix strings ignores a case (0.7.7). However, comparison is limited to one-byte locales.</source>
          <target state="translated">macOS 및 Cygwin과 같이 대소 문자를 구분하지 않는 운영 체제의 경우 접두사 문자열과 일치하면 대소 문자 (0.7.7)가 무시됩니다. 그러나 비교는 1 바이트 로캘로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="6506cb746aaffa1b657cff38f7946abd04f36ca8" translate="yes" xml:space="preserve">
          <source>For dealing with the body of a client request, nginx provides the &lt;code&gt;ngx_http_read_client_request_body(r, post_handler)&lt;/code&gt; and &lt;code&gt;ngx_http_discard_request_body(r)&lt;/code&gt; functions. The first function reads the request body and makes it available via the &lt;code&gt;request_body&lt;/code&gt; request field. The second function instructs nginx to discard (read and ignore) the request body. One of these functions must be called for every request. Normally, the content handler makes the call.</source>
          <target state="translated">nginx는 클라이언트 요청의 본문을 처리 &lt;code&gt;ngx_http_read_client_request_body(r, post_handler)&lt;/code&gt; 및 &lt;code&gt;ngx_http_discard_request_body(r)&lt;/code&gt; 함수를 제공합니다. 첫 번째 함수는 요청 본문을 읽고 &lt;code&gt;request_body&lt;/code&gt; 요청 필드 를 통해 사용할 수있게 합니다. 두 번째 함수는 nginx에 요청 본문을 삭제 (읽기 및 무시)하도록 지시합니다. 모든 요청에 ​​대해이 함수 중 하나를 호출해야합니다. 일반적으로 컨텐츠 핸들러는 호출합니다.</target>
        </trans-unit>
        <trans-unit id="68dc474f00168a96e74762c996d745ea2571a8b7" translate="yes" xml:space="preserve">
          <source>For debug logging, the debug mask is checked as well. The debug masks are:</source>
          <target state="translated">디버그 로깅의 경우 디버그 마스크도 확인됩니다. 디버그 마스크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8734b7f809457505a457475ae1d68d3469e1b3dc" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;#status_zone&quot;&gt;status_zone&lt;/a&gt;:</source>
          <target state="translated">각 &lt;a href=&quot;#status_zone&quot;&gt;status_zone에&lt;/a&gt; 대해 :</target>
        </trans-unit>
        <trans-unit id="700664c7e54d5fa0d90f8cf910fbc1759f0940ea" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;../stream/ngx_stream_upstream_module#server&quot;&gt;server&lt;/a&gt; the following data are provided:</source>
          <target state="translated">각 &lt;a href=&quot;../stream/ngx_stream_upstream_module#server&quot;&gt;서버에&lt;/a&gt; 대해 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="14c41667ce121c96ecd6603520a885b0e1272f95" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;../stream/ngx_stream_upstream_module#zone&quot;&gt;dynamically configurable&lt;/a&gt;&lt;a href=&quot;../stream/ngx_stream_upstream_module#upstream&quot;&gt;group&lt;/a&gt;, the following data are provided:</source>
          <target state="translated">&lt;a href=&quot;../stream/ngx_stream_upstream_module#zone&quot;&gt;동적으로 구성 가능한&lt;/a&gt; 각 &lt;a href=&quot;../stream/ngx_stream_upstream_module#upstream&quot;&gt;그룹&lt;/a&gt; 에 대해 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="69da5b0ebf1d80c586c67e5f6b60c24efed62974" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;server&lt;/a&gt;, the following data are provided:</source>
          <target state="translated">각 &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;서버&lt;/a&gt; 마다 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7a77bca044c6ba16541ffb68c90363369153c71c" translate="yes" xml:space="preserve">
          <source>For each &lt;a href=&quot;ngx_http_upstream_module#zone&quot;&gt;dynamically configurable&lt;/a&gt;&lt;a href=&quot;ngx_http_upstream_module#upstream&quot;&gt;group&lt;/a&gt;, the following data are provided:</source>
          <target state="translated">&lt;a href=&quot;ngx_http_upstream_module#zone&quot;&gt;동적으로 구성 가능한&lt;/a&gt; 각 &lt;a href=&quot;ngx_http_upstream_module#upstream&quot;&gt;그룹&lt;/a&gt; 에 대해 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8e2bffbc982e7bc8f0a3ff1111f900b3c331966f" translate="yes" xml:space="preserve">
          <source>For each cache (configured by &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_path&quot;&gt;proxy_cache_path&lt;/a&gt; and the likes):</source>
          <target state="translated">각 캐시에 대해 ( &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_path&quot;&gt;proxy_cache_path&lt;/a&gt; 등으로 구성 ) :</target>
        </trans-unit>
        <trans-unit id="fd9cde7df42f256c913c3552fc78a80a39dc0bea" translate="yes" xml:space="preserve">
          <source>For each client HTTP request the &lt;code&gt;ngx_http_request_t&lt;/code&gt; object is created. Some of the fields of this object are:</source>
          <target state="translated">각 클라이언트 HTTP 요청에 대해 &lt;code&gt;ngx_http_request_t&lt;/code&gt; 객체가 생성됩니다. 이 객체의 일부 필드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3420db7ac6dcbb5b825c0d561180c075e0c85f06" translate="yes" xml:space="preserve">
          <source>For each logger, a severity level controls which messages are written to the log (only events assigned that level or higher are logged). The following severity levels are supported:</source>
          <target state="translated">각 로거에 대해 심각도 레벨은 로그에 기록 할 메시지를 제어합니다 (해당 레벨 이상으로 지정된 이벤트 만 기록됨). 다음과 같은 심각도 수준이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="e984723f00b592bf9d65340ab0da64ddb0f2cd50" translate="yes" xml:space="preserve">
          <source>For each media file, two URIs are supported:</source>
          <target state="translated">각 미디어 파일에 대해 두 개의 URI가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="9085cc79945409796e3e2fb8a3e8f76a66b1e049" translate="yes" xml:space="preserve">
          <source>For each memory slot size (8, 16, 32, 64, 128, etc.) the following data are provided:</source>
          <target state="translated">각 메모리 슬롯 크기 (8, 16, 32, 64, 128 등)에 대해 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bd197533ee1ab0af035cf6f84fc24990c000a7dd" translate="yes" xml:space="preserve">
          <source>For each shared memory zone that uses slab allocator:</source>
          <target state="translated">슬랩 할당자를 사용하는 각 공유 메모리 영역의 경우 :</target>
        </trans-unit>
        <trans-unit id="6db6725e9e7d5c088630e348048d1e73fc7657d3" translate="yes" xml:space="preserve">
          <source>For example,</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="435b787a84a2b47076d71049067a6e6626c08770" translate="yes" xml:space="preserve">
          <source>For example, a simplistic module called &lt;code&gt;ngx_foo_module&lt;/code&gt; might look like this:</source>
          <target state="translated">예를 들어, &lt;code&gt;ngx_foo_module&lt;/code&gt; 이라는 단순한 모듈 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03e0a338d833a09b21a73e8d6b1c2c68f4917423" translate="yes" xml:space="preserve">
          <source>For example, for the following command</source>
          <target state="translated">예를 들어 다음 명령의 경우</target>
        </trans-unit>
        <trans-unit id="e2533a77d2b505b45b79f3f154f88f0119abbaeb" translate="yes" xml:space="preserve">
          <source>For example, for the following query string</source>
          <target state="translated">예를 들어, 다음 쿼리 문자열의 경우</target>
        </trans-unit>
        <trans-unit id="6dafcee529b52b7f0ca001083ac8369edcf3b639" translate="yes" xml:space="preserve">
          <source>For example, if a client requests a playlist &lt;code&gt;http://example.com/hls/test.mp4.m3u8?a=1&amp;amp;b=2&lt;/code&gt;, the arguments &lt;code&gt;a=1&lt;/code&gt; and &lt;code&gt;b=2&lt;/code&gt; will be added to URIs of fragments after the arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt;:</source>
          <target state="translated">예를 들어 클라이언트가 재생 목록 &lt;code&gt;http://example.com/hls/test.mp4.m3u8?a=1&amp;amp;b=2&lt;/code&gt; 를 요청 하면 인수 &lt;code&gt;a=1&lt;/code&gt; 및 &lt;code&gt;b=2&lt;/code&gt; 가 인수 뒤에 조각의 URI에 추가됩니다. &lt;code&gt;start&lt;/code&gt; 과 &lt;code&gt;end&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="650bcb42f47eae3b539e082742e7cdaee0d6082e" translate="yes" xml:space="preserve">
          <source>For example, if the following response is received from the authentication server:</source>
          <target state="translated">예를 들어 인증 서버에서 다음과 같은 응답이 수신 된 경우 :</target>
        </trans-unit>
        <trans-unit id="c355eff1e01766f457841662d03bedf7248f67ae" translate="yes" xml:space="preserve">
          <source>For example, in the following configuration, SSL handshakes with server names other than &lt;code&gt;example.com&lt;/code&gt; are rejected:</source>
          <target state="translated">예를 들어, 다음 구성에서는 &lt;code&gt;example.com&lt;/code&gt; 이 아닌 서버 이름을 가진 SSL 핸드 셰이크 가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="4f0e597329dfe54d8de6f3ac4731ae7bfc82ca4b" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; header can be accessed with the syntax &lt;code&gt;headersIn.foo&lt;/code&gt; or &lt;code&gt;headersIn['Foo']&lt;/code&gt;</source>
          <target state="translated">예를 들어, &lt;code&gt;Foo&lt;/code&gt; 헤더는 &lt;code&gt;headersIn.foo&lt;/code&gt; 또는 &lt;code&gt;headersIn['Foo']&lt;/code&gt; 구문으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b4abc1cf8cc420d0015b4b0ba6dd94a3b8426033" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;Foo&lt;/code&gt; header can be accessed with the syntax &lt;code&gt;headersOut.foo&lt;/code&gt; or &lt;code&gt;headersOut['Foo']&lt;/code&gt;</source>
          <target state="translated">예를 들어, &lt;code&gt;Foo&lt;/code&gt; 헤더는 &lt;code&gt;headersOut.foo&lt;/code&gt; 또는 &lt;code&gt;headersOut['Foo']&lt;/code&gt; 구문으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="136f353541c86f934fc5dd57721c2fb2554a5285" translate="yes" xml:space="preserve">
          <source>For example, the directives</source>
          <target state="translated">예를 들어, 지시문</target>
        </trans-unit>
        <trans-unit id="53687e61aaa51c7ff5c34e42b5c91d7776b3efb7" translate="yes" xml:space="preserve">
          <source>For example, to add a new primary server, send:</source>
          <target state="translated">예를 들어, 새로운 기본 서버를 추가하려면 다음을 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="306ba38feb030c21da964d27c870de8084bf2907" translate="yes" xml:space="preserve">
          <source>For example, to stop nginx processes with waiting for the worker processes to finish serving current requests, the following command can be executed:</source>
          <target state="translated">예를 들어 작업자 프로세스가 현재 요청을 처리하기를 기다리는 동안 nginx 프로세스를 중지하려면 다음 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b97cdf94b7248b5e0a892fe4c59131db1ec6c6" translate="yes" xml:space="preserve">
          <source>For example, to view the configuration of the whole group, send:</source>
          <target state="translated">예를 들어, 전체 그룹의 구성을 보려면 다음을 전송하십시오.</target>
        </trans-unit>
        <trans-unit id="0606ca9cd8729c7d8e1c01a3f64969002a396c93" translate="yes" xml:space="preserve">
          <source>For example, with the following request headers:</source>
          <target state="translated">예를 들어 다음 요청 헤더를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb601856ba3ea7dd01b7c721a6ac123424eec250" translate="yes" xml:space="preserve">
          <source>For general purposes, nginx code uses two integer types, &lt;code&gt;ngx_int_t&lt;/code&gt; and &lt;code&gt;ngx_uint_t&lt;/code&gt;, which are typedefs for &lt;code&gt;intptr_t&lt;/code&gt; and &lt;code&gt;uintptr_t&lt;/code&gt; respectively.</source>
          <target state="translated">일반적으로 nginx 코드는 &lt;code&gt;ngx_int_t&lt;/code&gt; 및 &lt;code&gt;ngx_uint_t&lt;/code&gt; 의 두 정수 유형을 사용 하는데 , 각각 &lt;code&gt;intptr_t&lt;/code&gt; 및 &lt;code&gt;uintptr_t&lt;/code&gt; 에 대한 typedef입니다 .</target>
        </trans-unit>
        <trans-unit id="4ef276a8e5ba7cbeca3fcbfdb86e4fd3b38833ba" translate="yes" xml:space="preserve">
          <source>For getting the list of all running nginx processes, the &lt;code&gt;ps&lt;/code&gt; utility may be used, for example, in the following way:</source>
          <target state="translated">실행중인 모든 nginx 프로세스 목록을 가져 오기 위해 &lt;code&gt;ps&lt;/code&gt; 유틸리티를 예를 들어 다음과 같은 방식으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4772fd6fff73949591b66a3a8982ef5972c4b40d" translate="yes" xml:space="preserve">
          <source>For gzip compression to work, nginx must be built with the zlib library.</source>
          <target state="translated">gzip 압축이 작동하려면 zgin 라이브러리로 nginx를 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e30eb87add475e2252919721d4b1f4e927c7a38" translate="yes" xml:space="preserve">
          <source>For input and output operations buffers are linked in chains. A chain is a sequence of chain links of type &lt;code&gt;ngx_chain_t&lt;/code&gt;, defined as follows:</source>
          <target state="translated">입력 및 출력 작업의 경우 버퍼는 체인으로 연결됩니다. 체인은 다음과 같이 &lt;code&gt;ngx_chain_t&lt;/code&gt; 유형의 체인 링크 시퀀스입니다 .</target>
        </trans-unit>
        <trans-unit id="345134aa7a27373f58392eb8bcc11b07f24843c0" translate="yes" xml:space="preserve">
          <source>For input/output operations, nginx provides the buffer type &lt;code&gt;ngx_buf_t&lt;/code&gt;. Normally, it's used to hold data to be written to a destination or read from a source. A buffer can reference data in memory or in a file and it's technically possible for a buffer to reference both at the same time. Memory for the buffer is allocated separately and is not related to the buffer structure &lt;code&gt;ngx_buf_t&lt;/code&gt;.</source>
          <target state="translated">입 / 출력 조작의 경우 nginx는 버퍼 유형 &lt;code&gt;ngx_buf_t&lt;/code&gt; 를 제공합니다 . 일반적으로 대상에 쓰거나 소스에서 읽을 데이터를 보유하는 데 사용됩니다. 버퍼는 메모리 나 파일에서 데이터를 참조 할 수 있으며 버퍼가 동시에 두 가지를 모두 참조 할 수 있습니다. 버퍼에 대한 메모리는 별도로 할당되며 버퍼 구조 &lt;code&gt;ngx_buf_t&lt;/code&gt; 와 관련이 없습니다 .</target>
        </trans-unit>
        <trans-unit id="4478aa524a06d8d6fb1372b88d8ff0d16e407e87" translate="yes" xml:space="preserve">
          <source>For logging nginx uses &lt;code&gt;ngx_log_t&lt;/code&gt; objects. The nginx logger supports several types of output:</source>
          <target state="translated">로깅 nginx는 &lt;code&gt;ngx_log_t&lt;/code&gt; 객체를 사용 합니다. nginx 로거는 여러 유형의 출력을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3068f46ec21f649252e13f46bd3e30c34b5168c2" translate="yes" xml:space="preserve">
          <source>For more information on sending signals to nginx, see &lt;a href=&quot;control&quot;&gt;Controlling nginx&lt;/a&gt;.</source>
          <target state="translated">nginx로 신호를 보내는 방법에 대한 자세한 내용은 nginx &lt;a href=&quot;control&quot;&gt;제어를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe07a3ef1ac91027a84a13365af0c10d073e2e36" translate="yes" xml:space="preserve">
          <source>For nested claims and claims including a dot (&amp;ldquo;.&amp;rdquo;), the value of the variable cannot be evaluated; the &lt;a href=&quot;#auth_jwt_claim_set&quot;&gt;auth_jwt_claim_set&lt;/a&gt; directive should be used instead.</source>
          <target state="translated">점 ( &quot;.&quot;)을 포함하는 중첩 된 클레임 및 클레임의 경우 변수 값을 평가할 수 없습니다. &lt;a href=&quot;#auth_jwt_claim_set&quot;&gt;auth_jwt_claim_set의&lt;/a&gt; 지시문을 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="101aa69cff9c9a92cda3d1a75756357904ae9cff" translate="yes" xml:space="preserve">
          <source>For objects whose &lt;code&gt;valueOf()&lt;/code&gt; function returns a value not strictly equal to object, returns &lt;code&gt;Buffer.from(object.valueOf()&lt;/code&gt;, &lt;code&gt;offsetOrEncoding&lt;/code&gt;, &lt;code&gt;length&lt;/code&gt;).</source>
          <target state="translated">그 객체 &lt;code&gt;valueOf()&lt;/code&gt; 함수의 리턴 값이 엄격 오브젝트와 동일한 반품 &lt;code&gt;Buffer.from(object.valueOf()&lt;/code&gt; , &lt;code&gt;offsetOrEncoding&lt;/code&gt; , &lt;code&gt;length&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eb190a0f4c47bdcff224c3640a27216ffe1ae14e" translate="yes" xml:space="preserve">
          <source>For scripts that process &lt;code&gt;POST&lt;/code&gt; requests, the following three parameters are also required:</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 요청 을 처리하는 스크립트의 경우 다음 세 가지 매개 변수도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a0b1c81491c2979f11ed7decd064ec41321a1865" translate="yes" xml:space="preserve">
          <source>For some phases, return codes are treated in a slightly different way. At the content phase, any return code other that &lt;code&gt;NGX_DECLINED&lt;/code&gt; is considered a finalization code. Any return code from the location content handlers is considered a finalization code. At the access phase, in &lt;a href=&quot;../http/ngx_http_core_module#satisfy&quot;&gt;satisfy any&lt;/a&gt; mode, any return code other than &lt;code&gt;NGX_OK&lt;/code&gt;, &lt;code&gt;NGX_DECLINED&lt;/code&gt;, &lt;code&gt;NGX_AGAIN&lt;/code&gt;, &lt;code&gt;NGX_DONE&lt;/code&gt; is considered a denial. If no subsequent access handlers allow or deny access with a different code, the denial code will become the finalization code.</source>
          <target state="translated">일부 단계의 경우 리턴 코드가 약간 다르게 처리됩니다. 컨텐츠 단계에서 &lt;code&gt;NGX_DECLINED&lt;/code&gt; 이외의 리턴 코드 는 완료 코드로 간주됩니다. 위치 컨텐츠 핸들러의 리턴 코드는 완료 코드로 간주됩니다. 액세스 단계에서 &lt;a href=&quot;../http/ngx_http_core_module#satisfy&quot;&gt;모든&lt;/a&gt; 모드 를 만족하면 &lt;code&gt;NGX_OK&lt;/code&gt; , &lt;code&gt;NGX_DECLINED&lt;/code&gt; , &lt;code&gt;NGX_AGAIN&lt;/code&gt; , &lt;code&gt;NGX_DONE&lt;/code&gt; 이외의 리턴 코드 는 거부 된 것으로 간주됩니다. 후속 액세스 핸들러가 다른 코드로 액세스를 허용하거나 거부하지 않으면 거부 코드가 최종 코드가됩니다.</target>
        </trans-unit>
        <trans-unit id="97372b5d73aad02ad79fd7c28376a0361e3c9b73" translate="yes" xml:space="preserve">
          <source>For standard response headers that accept only a single field value such as &amp;ldquo;Content-Type&amp;rdquo;, only the last element of the array will take effect. Field values of the &amp;ldquo;Set-Cookie&amp;rdquo; response header are always returned as an array. Duplicate field values in &amp;ldquo;Age&amp;rdquo;, &amp;ldquo;Content-Encoding&amp;rdquo;, &amp;ldquo;Content-Length&amp;rdquo;, &amp;ldquo;Content-Type&amp;rdquo;, &amp;ldquo;ETag&amp;rdquo;, &amp;ldquo;Expires&amp;rdquo;, &amp;ldquo;Last-Modified&amp;rdquo;, &amp;ldquo;Location&amp;rdquo;, &amp;ldquo;Retry-After&amp;rdquo; response headers are ignored. Duplicate field values in all other response headers are separated by commas.</source>
          <target state="translated">&quot;Content-Type&quot;과 같은 단일 필드 값만 허용하는 표준 응답 헤더의 경우 배열의 마지막 요소 만 적용됩니다. &quot;Set-Cookie&quot;응답 헤더의 필드 값은 항상 배열로 반환됩니다. &quot;Age&quot;, &quot;Content-Encoding&quot;, &quot;Content-Length&quot;, &quot;Content-Type&quot;, &quot;ETag&quot;, &quot;Expires&quot;, &quot;Last-Modified&quot;, &quot;Location&quot;, &quot;Retry-After&quot;응답에 중복 된 필드 값이 있습니다. 헤더는 무시됩니다. 다른 모든 응답 헤더의 중복 필드 값은 쉼표로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="75132660f52d992763ade42482198d52c013b686" translate="yes" xml:space="preserve">
          <source>For the 401 error, the client also receives the &amp;ldquo;WWW-Authenticate&amp;rdquo; header from the subrequest response.</source>
          <target state="translated">401 오류의 경우 클라이언트는 하위 요청 응답에서 &quot;WWW-Authenticate&quot;헤더도받습니다.</target>
        </trans-unit>
        <trans-unit id="a76b0e71389057f293958c576e6f2c851d123974" translate="yes" xml:space="preserve">
          <source>For the HTML &lt;a href=&quot;#autoindex_format&quot;&gt;format&lt;/a&gt;, specifies whether exact file sizes should be output in the directory listing, or rather rounded to kilobytes, megabytes, and gigabytes.</source>
          <target state="translated">HTML &lt;a href=&quot;#autoindex_format&quot;&gt;형식&lt;/a&gt; 의 경우 정확한 파일 크기가 디렉토리 목록에 출력되어야하는지 또는 킬로바이트, 메가 바이트 및 기가 바이트로 반올림되어야하는지 지정합니다.</target>
        </trans-unit>
        <trans-unit id="e41db186117b84a48bd419b9e0244fb4b1669dd1" translate="yes" xml:space="preserve">
          <source>For the HTML &lt;a href=&quot;#autoindex_format&quot;&gt;format&lt;/a&gt;, specifies whether times in the directory listing should be output in the local time zone or UTC.</source>
          <target state="translated">HTML &lt;a href=&quot;#autoindex_format&quot;&gt;형식의&lt;/a&gt; 경우 디렉토리 목록의 시간을 현지 시간대 또는 UTC로 출력해야하는지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3f0e9677a2f9c64d07fed362ba9dbd9940727f93" translate="yes" xml:space="preserve">
          <source>For the OCSP stapling to work, the certificate of the server certificate issuer should be known. If the &lt;a href=&quot;#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; file does not contain intermediate certificates, the certificate of the server certificate issuer should be present in the &lt;a href=&quot;#ssl_trusted_certificate&quot;&gt;ssl_trusted_certificate&lt;/a&gt; file.</source>
          <target state="translated">OCSP 스테이플 링이 작동하려면 서버 인증서 발행자의 인증서를 알아야합니다. 는 IF &lt;a href=&quot;#ssl_certificate&quot;&gt;ssl_certificate&lt;/a&gt; 파일이 중간 인증서가 포함되지 않은 서버 인증서 발급자의 인증서에 존재한다 &lt;a href=&quot;#ssl_trusted_certificate&quot;&gt;ssl_trusted_certificate의&lt;/a&gt; 파일입니다.</target>
        </trans-unit>
        <trans-unit id="8715049aebf0fdbbca531e53ef2da11ae318b7fe" translate="yes" xml:space="preserve">
          <source>For the OCSP validation to work, the &lt;a href=&quot;#ssl_verify_client&quot;&gt;ssl_verify_client&lt;/a&gt; directive should be set to &lt;code&gt;on&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt;.</source>
          <target state="translated">OCSP 유효성 검사가 작동하려면 &lt;a href=&quot;#ssl_verify_client&quot;&gt;ssl_verify_client&lt;/a&gt; 지시문을 &lt;code&gt;on&lt;/code&gt; 또는 &lt;code&gt;optional&lt;/code&gt; 로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="35c96514204e1b6a05170f6c3156a77d0980b264" translate="yes" xml:space="preserve">
          <source>For the SMTP, the response additionally takes into account the &amp;ldquo;Auth-Error-Code&amp;rdquo; header &amp;mdash; if exists, it is used as a response code in case of an error. Otherwise, the 535 5.7.0 code will be added to the &amp;ldquo;Auth-Status&amp;rdquo; header.</source>
          <target state="translated">SMTP의 경우 응답에는 &quot;Auth-Error-Code&quot;헤더가 추가로 고려됩니다. 존재하는 경우 오류 발생시 응답 코드로 사용됩니다. 그렇지 않으면 535 5.7.0 코드가 &quot;Auth-Status&quot;헤더에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="f752d089a4274c87a67b989ed529dd5aa2bbadb0" translate="yes" xml:space="preserve">
          <source>For the SSL/TLS client connection (1.7.11), the &amp;ldquo;Auth-SSL&amp;rdquo; header is added, and &amp;ldquo;Auth-SSL-Verify&amp;rdquo; will contain the result of client certificate verification, if &lt;a href=&quot;ngx_mail_ssl_module#ssl_verify_client&quot;&gt;enabled&lt;/a&gt;: &amp;ldquo;&lt;code&gt;SUCCESS&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;FAILED:&lt;/code&gt;&lt;code&gt;&lt;i&gt;reason&lt;/i&gt;&lt;/code&gt;&amp;rdquo;, and &amp;ldquo;&lt;code&gt;NONE&lt;/code&gt;&amp;rdquo; if a certificate was not present.</source>
          <target state="translated">SSL / TLS 클라이언트 연결 (1.7.11)의 경우 &quot;Auth-SSL&quot;헤더가 추가되고 &quot;Auth-SSL-Verify&quot;에는 &lt;a href=&quot;ngx_mail_ssl_module#ssl_verify_client&quot;&gt;활성화 된&lt;/a&gt; 경우 클라이언트 인증서 확인 결과가 포함됩니다 . &quot; &lt;code&gt;SUCCESS&lt;/code&gt; &quot;, &quot; &lt;code&gt;FAILED:&lt;/code&gt; &lt;code&gt;&lt;i&gt;reason&lt;/i&gt;&lt;/code&gt; &amp;rdquo;및 인증서가 없으면 &amp;ldquo; &lt;code&gt;NONE&lt;/code&gt; &amp;rdquo;입니다.</target>
        </trans-unit>
        <trans-unit id="7681cbbdf524858af1dbd287d9049459117f6aa8" translate="yes" xml:space="preserve">
          <source>For the requests &lt;a href=&quot;ngx_http_upstream_module#queue&quot;&gt;queue&lt;/a&gt;, the following data are provided:</source>
          <target state="translated">요청 &lt;a href=&quot;ngx_http_upstream_module#queue&quot;&gt;큐&lt;/a&gt; 에 대해 다음 데이터가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="95a8dcff251b6049979e3e2ae97cc86f1985dc94" translate="yes" xml:space="preserve">
          <source>For the second case, it is possible to use basic HTTP client functionality available in nginx. For example, &lt;a href=&quot;http://hg.nginx.org/nginx/file/tip/src/event/ngx_event_openssl_stapling.c&quot;&gt;OCSP module&lt;/a&gt; implements simple HTTP client.</source>
          <target state="translated">두 번째 경우, nginx에서 사용 가능한 기본 HTTP 클라이언트 기능을 사용할 수 있습니다. 예를 들어, &lt;a href=&quot;http://hg.nginx.org/nginx/file/tip/src/event/ngx_event_openssl_stapling.c&quot;&gt;OCSP 모듈&lt;/a&gt; 은 간단한 HTTP 클라이언트를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="69f0fec298f1aad90d05b8afbd93060863332cb5" translate="yes" xml:space="preserve">
          <source>For these reasons, it is better to use exact names where possible. For example, if the most frequently requested names of a server are &lt;code&gt;example.org&lt;/code&gt; and &lt;code&gt;www.example.org&lt;/code&gt;, it is more efficient to define them explicitly:</source>
          <target state="translated">이러한 이유로 가능한 경우 정확한 이름을 사용하는 것이 좋습니다. 예를 들어, 가장 자주 요청되는 서버 이름이 &lt;code&gt;example.org&lt;/code&gt; 및 &lt;code&gt;www.example.org&lt;/code&gt; 인 경우 명시 적으로 정의하는 것이 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="255502429c14c1d6e59f9f7f4fa29529e1994ac3" translate="yes" xml:space="preserve">
          <source>For third-party filter modules nginx provides a special slot &lt;code&gt;HTTP_AUX_FILTER_MODULES&lt;/code&gt;. To register a filter module in this slot, set the &lt;code&gt;ngx_module_type&lt;/code&gt; variable to &lt;code&gt;HTTP_AUX_FILTER&lt;/code&gt; in the module's configuration.</source>
          <target state="translated">타사 필터 모듈의 경우 nginx는 특수 슬롯 &lt;code&gt;HTTP_AUX_FILTER_MODULES&lt;/code&gt; 를 제공합니다 . 이 슬롯에 필터 모듈을 등록하려면 모듈 구성에서 &lt;code&gt;ngx_module_type&lt;/code&gt; 변수를 &lt;code&gt;HTTP_AUX_FILTER&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0765876f340908fed483ea5440b7a9def5a17882" translate="yes" xml:space="preserve">
          <source>For this directive to work, nginx needs to be built with &lt;code&gt;--with-debug&lt;/code&gt;, see &amp;ldquo;&lt;a href=&quot;debugging_log&quot;&gt;A debugging log&lt;/a&gt;&amp;rdquo;.</source>
          <target state="translated">이 지시문이 작동하려면 nginx를 &lt;code&gt;--with-debug&lt;/code&gt; 로 빌드해야합니다 .&amp;ldquo; &lt;a href=&quot;debugging_log&quot;&gt;디버깅 로그&lt;/a&gt; &amp;rdquo;를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3fbfbc07b72c4cdcdc1bd3bc98d1f2a1a006d497" translate="yes" xml:space="preserve">
          <source>For verification to work, the certificate of the server certificate issuer, the root certificate, and all intermediate certificates should be configured as trusted using the &lt;a href=&quot;#ssl_trusted_certificate&quot;&gt;ssl_trusted_certificate&lt;/a&gt; directive.</source>
          <target state="translated">확인이 작동하려면 &lt;a href=&quot;#ssl_trusted_certificate&quot;&gt;ssl_trusted_certificate&lt;/a&gt; 지시문을 사용하여 서버 인증서 발급자 인증서, 루트 인증서 및 모든 중간 인증서를 신뢰할 수있는 것으로 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="841f832857c780b47f478b4f21d34d8995af64b8" translate="yes" xml:space="preserve">
          <source>Formatting</source>
          <target state="translated">Formatting</target>
        </trans-unit>
        <trans-unit id="b547633ce5ef34ef1d0472e8fbe1dcd8d7fd81d1" translate="yes" xml:space="preserve">
          <source>FreeBSD / amd64;</source>
          <target state="translated">FreeBSD / amd64;</target>
        </trans-unit>
        <trans-unit id="d886838dc3e6c2a5fe8a21091aba647398a4bb5e" translate="yes" xml:space="preserve">
          <source>Full conversion tables from &lt;code&gt;koi8-r&lt;/code&gt; to &lt;code&gt;windows-1251&lt;/code&gt;, and from &lt;code&gt;koi8-r&lt;/code&gt; and &lt;code&gt;windows-1251&lt;/code&gt; to &lt;code&gt;utf-8&lt;/code&gt; are provided in the distribution files &lt;code&gt;conf/koi-win&lt;/code&gt;, &lt;code&gt;conf/koi-utf&lt;/code&gt;, and &lt;code&gt;conf/win-utf&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;koi8-r&lt;/code&gt; 에서 &lt;code&gt;windows-1251&lt;/code&gt; 로 , &lt;code&gt;koi8-r&lt;/code&gt; 및 &lt;code&gt;windows-1251&lt;/code&gt; 에서 &lt;code&gt;utf-8&lt;/code&gt; 로의 전체 변환 테이블 은 배포 파일 &lt;code&gt;conf/koi-win&lt;/code&gt; , &lt;code&gt;conf/koi-utf&lt;/code&gt; 및 &lt;code&gt;conf/win-utf&lt;/code&gt; 에 제공 됩니다.</target>
        </trans-unit>
        <trans-unit id="783b3a4fa645e1d384d22d5a58207cd9b609a77b" translate="yes" xml:space="preserve">
          <source>Function pointers inside structures have defined types ending with &amp;ldquo;&lt;code&gt;_pt&lt;/code&gt;&amp;rdquo;:</source>
          <target state="translated">구조체 안의 함수 포인터는&amp;ldquo; &lt;code&gt;_pt&lt;/code&gt; &amp;rdquo;로 끝나는 타입을 정의했습니다 .</target>
        </trans-unit>
        <trans-unit id="50b4093d513f8b5bccc158ffa36ed8a1d06e8ef6" translate="yes" xml:space="preserve">
          <source>Function used to decode percent-encoded characters in the query string, by default is &lt;a href=&quot;#querystring_unescape&quot;&gt;&lt;code&gt;querystring.unescape()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">쿼리 문자열에서 퍼센트 인코딩 된 문자를 디코딩하는 데 사용되는 함수는 기본적으로 &lt;a href=&quot;#querystring_unescape&quot;&gt; &lt;code&gt;querystring.unescape()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="9aa0110759f629a80777d06b669f1141dea9a455" translate="yes" xml:space="preserve">
          <source>Furthermore, it is possible to change the response code to another using the &amp;ldquo;&lt;code&gt;=&lt;/code&gt;&lt;code&gt;&lt;i&gt;response&lt;/i&gt;&lt;/code&gt;&amp;rdquo; syntax, for example:</source>
          <target state="translated">또한 &quot; &lt;code&gt;=&lt;/code&gt; &lt;code&gt;&lt;i&gt;response&lt;/i&gt;&lt;/code&gt; &quot;구문을 사용하여 응답 코드를 다른 코드로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08051995c434de1c4da94e508109529783f5c615" translate="yes" xml:space="preserve">
          <source>General information about nginx:</source>
          <target state="translated">nginx에 대한 일반 정보 :</target>
        </trans-unit>
        <trans-unit id="bf6bda4587aff077462187186bdf6576ccc550c7" translate="yes" xml:space="preserve">
          <source>General rules</source>
          <target state="translated">일반적인 규칙</target>
        </trans-unit>
        <trans-unit id="e8270841522e7cee8169b63b7ba31993395f435a" translate="yes" xml:space="preserve">
          <source>Generally, the configuration file may include several &lt;code&gt;server&lt;/code&gt; blocks &lt;a href=&quot;http/request_processing&quot;&gt;distinguished&lt;/a&gt; by ports on which they &lt;a href=&quot;http/ngx_http_core_module#listen&quot;&gt;listen&lt;/a&gt; to and by &lt;a href=&quot;http/server_names&quot;&gt;server names&lt;/a&gt;. Once nginx decides which &lt;code&gt;server&lt;/code&gt; processes a request, it tests the URI specified in the request&amp;rsquo;s header against the parameters of the &lt;code&gt;location&lt;/code&gt; directives defined inside the &lt;code&gt;server&lt;/code&gt; block.</source>
          <target state="translated">일반적으로 구성 파일에는 &lt;a href=&quot;http/ngx_http_core_module#listen&quot;&gt;청취&lt;/a&gt; 하는 포트 와 &lt;a href=&quot;http/server_names&quot;&gt;서버 이름으로 &lt;/a&gt;&lt;a href=&quot;http/request_processing&quot;&gt;구별&lt;/a&gt; 되는 여러 &lt;code&gt;server&lt;/code&gt; 블록 이 포함될 수 있습니다 . nginx가 요청을 처리하는 &lt;code&gt;server&lt;/code&gt; 결정 하면 &lt;code&gt;server&lt;/code&gt; 블록 내에 정의 된 &lt;code&gt;location&lt;/code&gt; 지시문 의 매개 변수와 비교하여 요청 헤더에 지정된 URI를 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="ec7194ca0b10e6688ba0d3d58095be4ff51a7c31" translate="yes" xml:space="preserve">
          <source>Get a particular key-value pair from the HTTP keyval zone.</source>
          <target state="translated">HTTP 키 영역에서 특정 키-값 쌍을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="734f62148c0a3106e06f747209d0897e0850d02e" translate="yes" xml:space="preserve">
          <source>Get a particular key-value pair from the stream keyval zone.</source>
          <target state="translated">스트림 키발 영역에서 특정 키-값 쌍을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f06244589ec9f0c33e09b0a1228505c957a807a9" translate="yes" xml:space="preserve">
          <source>Get autocompletion and API check in an editor</source>
          <target state="translated">편집기에서 자동 완성 및 API 확인 받기</target>
        </trans-unit>
        <trans-unit id="0a22d6488aa46d4064b8a0e0ed2aae936cd3505e" translate="yes" xml:space="preserve">
          <source>Given the request &lt;code&gt;r&lt;/code&gt; and previously compiled value &lt;code&gt;cv&lt;/code&gt;, the function evaluates the expression and writes the result to &lt;code&gt;res&lt;/code&gt;.</source>
          <target state="translated">요청 &lt;code&gt;r&lt;/code&gt; 과 이전에 컴파일 된 값 &lt;code&gt;cv&lt;/code&gt; 가 주어지면 함수는 표현식을 평가하고 결과를 &lt;code&gt;res&lt;/code&gt; 에 씁니다 .</target>
        </trans-unit>
        <trans-unit id="5f1184f7df96c5928092ad9c6b550699bf887826" translate="yes" xml:space="preserve">
          <source>Global</source>
          <target state="translated">Global</target>
        </trans-unit>
        <trans-unit id="2ff4e53e2b802e1ec127c83da80fa5fc4b5333fa" translate="yes" xml:space="preserve">
          <source>Global Variables</source>
          <target state="translated">글로벌 변수</target>
        </trans-unit>
        <trans-unit id="2fcc9ac8d2e8ff887e90c9f1f70247f2f1a7777a" translate="yes" xml:space="preserve">
          <source>Global objects (&lt;a href=&quot;changes#njs0.3.3&quot;&gt;0.3.3&lt;/a&gt;):</source>
          <target state="translated">전역 객체 ( &lt;a href=&quot;changes#njs0.3.3&quot;&gt;0.3.3&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="c6aff63863d0db02cfdc35fd58ba0911c8c04be0" translate="yes" xml:space="preserve">
          <source>Good response:</source>
          <target state="translated">좋은 반응 :</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="380eb30f2d5ab1cdac2a8d64b79d28cfa75198ff" translate="yes" xml:space="preserve">
          <source>HMAC</source>
          <target state="translated">HMAC</target>
        </trans-unit>
        <trans-unit id="36e351356310e10cb4423492c7c49aa71f680a74" translate="yes" xml:space="preserve">
          <source>HS256, HS384, HS512</source>
          <target state="translated">HS256, HS384, HS512</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="dc373d1615e508b4858b867d43e0776f99b36465" translate="yes" xml:space="preserve">
          <source>HTTP Cache:</source>
          <target state="translated">HTTP 캐시 :</target>
        </trans-unit>
        <trans-unit id="646eadf9846e7873fb73d85aa36a8426efed19be" translate="yes" xml:space="preserve">
          <source>HTTP Connections Limiting:</source>
          <target state="translated">HTTP 연결 제한 :</target>
        </trans-unit>
        <trans-unit id="72e85157b8fea9582074d981dede048488ef099b" translate="yes" xml:space="preserve">
          <source>HTTP Keyval Shared Memory Zone:</source>
          <target state="translated">HTTP Keyval 공유 메모리 영역 :</target>
        </trans-unit>
        <trans-unit id="98a4a60d73b49755ea7160538792a5ebdfe273ca" translate="yes" xml:space="preserve">
          <source>HTTP Location Zone:</source>
          <target state="translated">HTTP 위치 영역 :</target>
        </trans-unit>
        <trans-unit id="59ff88c88f9daf0e877e2283fd349062ed6242f1" translate="yes" xml:space="preserve">
          <source>HTTP Request</source>
          <target state="translated">HTTP 요청</target>
        </trans-unit>
        <trans-unit id="465284c0962dce3cd6add86b01ccd64450ef0af2" translate="yes" xml:space="preserve">
          <source>HTTP Requests Rate Limiting:</source>
          <target state="translated">HTTP 요청 속도 제한 :</target>
        </trans-unit>
        <trans-unit id="838707913e8950f96d75766787d0b1701912c617" translate="yes" xml:space="preserve">
          <source>HTTP Requests to External Services</source>
          <target state="translated">외부 서비스에 대한 HTTP 요청</target>
        </trans-unit>
        <trans-unit id="d8d995b34e7bc38ec4167ce63decefe2ad7fc95a" translate="yes" xml:space="preserve">
          <source>HTTP Requests:</source>
          <target state="translated">HTTP 요청 :</target>
        </trans-unit>
        <trans-unit id="fb15ed4fd18a5de0ca60c7cc6780dc4b340978e5" translate="yes" xml:space="preserve">
          <source>HTTP Server Zone:</source>
          <target state="translated">HTTP 서버 영역 :</target>
        </trans-unit>
        <trans-unit id="8b78a78cec8d37fb951bc28db15831a17edf8a06" translate="yes" xml:space="preserve">
          <source>HTTP Upstream Server:</source>
          <target state="translated">HTTP 업스트림 서버 :</target>
        </trans-unit>
        <trans-unit id="b94143cc9f3f5dc195478552e81ba01d9c5a10a9" translate="yes" xml:space="preserve">
          <source>HTTP Upstream:</source>
          <target state="translated">HTTP 업스트림 :</target>
        </trans-unit>
        <trans-unit id="0368090100595fbfea27e2441b032069cdbf0855" translate="yes" xml:space="preserve">
          <source>HTTP error code.</source>
          <target state="translated">HTTP 오류 코드</target>
        </trans-unit>
        <trans-unit id="8c20c5c9b0462db071d6fc9c0e5b911321ede49f" translate="yes" xml:space="preserve">
          <source>HTTP method, by default the &lt;code&gt;GET&lt;/code&gt; method is used</source>
          <target state="translated">HTTP 메소드, 기본적으로 &lt;code&gt;GET&lt;/code&gt; 메소드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f82a1e5f981c58920ab0bb0550f092da97b9e9fd" translate="yes" xml:space="preserve">
          <source>HTTP method, read-only</source>
          <target state="translated">HTTP 메소드, 읽기 전용</target>
        </trans-unit>
        <trans-unit id="d52b8fab8c9c689643deec957f0d017ef684972a" translate="yes" xml:space="preserve">
          <source>HTTP request header fields are passed to a FastCGI server as parameters. In applications and scripts running as FastCGI servers, these parameters are usually made available as environment variables. For example, the &amp;ldquo;User-Agent&amp;rdquo; header field is passed as the &lt;code&gt;HTTP_USER_AGENT&lt;/code&gt; parameter. In addition to HTTP request header fields, it is possible to pass arbitrary parameters using the &lt;a href=&quot;#fastcgi_param&quot;&gt;fastcgi_param&lt;/a&gt; directive.</source>
          <target state="translated">HTTP 요청 헤더 필드는 매개 변수로 FastCGI 서버에 전달됩니다. FastCGI 서버로 실행되는 응용 프로그램 및 스크립트에서 이러한 매개 변수는 일반적으로 환경 변수로 제공됩니다. 예를 들어 &quot;User-Agent&quot;헤더 필드는 &lt;code&gt;HTTP_USER_AGENT&lt;/code&gt; 매개 변수 로 전달됩니다 . HTTP 요청 헤더 필드 외에도 &lt;a href=&quot;#fastcgi_param&quot;&gt;fastcgi_param&lt;/a&gt; 지시문을 사용하여 임의의 매개 변수를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd5a5554e576418b958ab25603434f91bb52cf83" translate="yes" xml:space="preserve">
          <source>HTTP version, read-only</source>
          <target state="translated">HTTP 버전, 읽기 전용</target>
        </trans-unit>
        <trans-unit id="75b926336fd46dceb48d81514699838aea2b6c84" translate="yes" xml:space="preserve">
          <source>HTTPS server optimization</source>
          <target state="translated">HTTPS 서버 최적화</target>
        </trans-unit>
        <trans-unit id="327af10f8c8e5d299d53d62e446d10a2780b143e" translate="yes" xml:space="preserve">
          <source>HUP</source>
          <target state="translated">HUP</target>
        </trans-unit>
        <trans-unit id="b81c4c9d53cdffd241261b0c9e46272b03b95efc" translate="yes" xml:space="preserve">
          <source>Handling a request &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; is more complex. It is matched by the prefix location &amp;ldquo;&lt;code&gt;/&lt;/code&gt;&amp;rdquo; only, therefore, it is handled by this location. Then the &lt;a href=&quot;ngx_http_index_module#index&quot;&gt;index&lt;/a&gt; directive tests for the existence of index files according to its parameters and the &amp;ldquo;&lt;code&gt;root /data/www&lt;/code&gt;&amp;rdquo; directive. If the file &lt;code&gt;/data/www/index.html&lt;/code&gt; does not exist, and the file &lt;code&gt;/data/www/index.php&lt;/code&gt; exists, then the directive does an internal redirect to &amp;ldquo;&lt;code&gt;/index.php&lt;/code&gt;&amp;rdquo;, and nginx searches the locations again as if the request had been sent by a client. As we saw before, the redirected request will eventually be handled by the FastCGI server.</source>
          <target state="translated">&quot; &lt;code&gt;/&lt;/code&gt; &quot; 요청을 처리하는 것이 더 복잡합니다. 접두사 위치&amp;ldquo; &lt;code&gt;/&lt;/code&gt; &amp;rdquo;만 일치하므로이 위치에서 처리됩니다. 그런 다음 &lt;a href=&quot;ngx_http_index_module#index&quot;&gt;색인&lt;/a&gt; 지시문은 매개 변수 및 &quot; &lt;code&gt;root /data/www&lt;/code&gt; &quot;지시문 에 따라 색인 파일이 있는지 테스트 합니다. 파일의 경우 &lt;code&gt;/data/www/index.html&lt;/code&gt; 이 존재하지 않으며, 파일 &lt;code&gt;/data/www/index.php&lt;/code&gt; 이 존재, 다음 지시어는 &quot;내부 리디렉션하지 &lt;code&gt;/index.php&lt;/code&gt; 로 다시&quot;및 nginx를 검색 위치를 클라이언트가 요청을 보낸 경우 앞에서 본 것처럼 리디렉션 된 요청은 결국 FastCGI 서버에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="873507a022b58de26a88deae87268cbd8d6af5b1" translate="yes" xml:space="preserve">
          <source>Hash</source>
          <target state="translated">Hash</target>
        </trans-unit>
        <trans-unit id="a13cd4be49a3b71f8ab645c5d2a99fdbb1716da2" translate="yes" xml:space="preserve">
          <source>Hash table functions are declared in &lt;code&gt;src/core/ngx_hash.h&lt;/code&gt;. Both exact and wildcard matching are supported. The latter requires extra setup and is described in a separate section below.</source>
          <target state="translated">해시 테이블 함수는 &lt;code&gt;src/core/ngx_hash.h&lt;/code&gt; 에 선언되어 있습니다. 정확한 일치와 와일드 카드 일치가 모두 지원됩니다. 후자는 추가 설정이 필요하며 아래의 별도 섹션에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e55130dfa404eeaae0743aea14ba09094dec1b9" translate="yes" xml:space="preserve">
          <source>Header field names are not converted to lower case, duplicate field values are not merged.</source>
          <target state="translated">헤더 필드 이름은 소문자로 변환되지 않으며 중복 필드 값은 병합되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="372bb225eb027feec0232495eaeef2b4be9349a5" translate="yes" xml:space="preserve">
          <source>Header files should include the so called &quot;header protection&quot;:</source>
          <target state="translated">헤더 파일에는 소위 &quot;헤더 보호&quot;가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="fd1386b626a2d0a1d2083e294997c662999585a0" translate="yes" xml:space="preserve">
          <source>Header filters</source>
          <target state="translated">헤더 필터</target>
        </trans-unit>
        <trans-unit id="209860c0683964e6198e2507d1f81236c601eac8" translate="yes" xml:space="preserve">
          <source>Header lines sent to a client have the prefix &amp;ldquo;&lt;code&gt;sent_http_&lt;/code&gt;&amp;rdquo;, for example, &lt;code&gt;$sent_http_content_range&lt;/code&gt;.</source>
          <target state="translated">클라이언트에 전송 된 헤더 행의 접두어는 &quot; &lt;code&gt;sent_http_&lt;/code&gt; &quot;입니다 (예 : &lt;code&gt;$sent_http_content_range&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a736084a1d93a79112d65f3144a774a43aeaa05" translate="yes" xml:space="preserve">
          <source>Health check is passed if:</source>
          <target state="translated">다음과 같은 경우 건강 검진이 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="87398e24ea58e8cafa77352da02409bcf395978d" translate="yes" xml:space="preserve">
          <source>Health checks</source>
          <target state="translated">건강 검진</target>
        </trans-unit>
        <trans-unit id="c6828cfbc333a631b3dffbd456481159ba7fc74a" translate="yes" xml:space="preserve">
          <source>Health checks can also be configured to test data obtained from the server. Tests are configured separately using the &lt;a href=&quot;#match&quot;&gt;match&lt;/a&gt; directive and referenced in the &lt;code&gt;match&lt;/code&gt; parameter of the &lt;a href=&quot;#health_check&quot;&gt;health_check&lt;/a&gt; directive.</source>
          <target state="translated">서버에서 얻은 데이터를 테스트하도록 상태 확인을 구성 할 수도 있습니다. 테스트는 &lt;a href=&quot;#match&quot;&gt;match&lt;/a&gt; 지시문을 사용하여 별도로 구성되며 &lt;a href=&quot;#health_check&quot;&gt;health_check&lt;/a&gt; 지시문 의 &lt;code&gt;match&lt;/code&gt; 매개 변수 에서 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="e4fd621b2a738b9c80528ae6ba0387b5355d443c" translate="yes" xml:space="preserve">
          <source>Health checks can be configured for the UDP protocol:</source>
          <target state="translated">UDP 프로토콜에 대한 상태 확인을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="872067677b3cfb7c5f0da65256e79e696da60534" translate="yes" xml:space="preserve">
          <source>Health checks can be configured to test the status code of a response, presence of certain header fields and their values, and the body contents. Tests are configured separately using the &lt;a href=&quot;#match&quot;&gt;match&lt;/a&gt; directive and referenced in the &lt;code&gt;match&lt;/code&gt; parameter of the &lt;a href=&quot;#health_check&quot;&gt;health_check&lt;/a&gt; directive:</source>
          <target state="translated">상태 점검은 응답의 상태 코드, 특정 헤더 필드 및 해당 값의 존재 및 본문 내용을 테스트하도록 구성 할 수 있습니다. 테스트는 &lt;a href=&quot;#match&quot;&gt;match&lt;/a&gt; 지시문을 사용하여 별도로 구성되며 &lt;a href=&quot;#health_check&quot;&gt;health_check&lt;/a&gt; 지시문 의 &lt;code&gt;match&lt;/code&gt; 매개 변수 에서 참조됩니다 .</target>
        </trans-unit>
        <trans-unit id="977169a2f56615065497cd1735f54129679d50ec" translate="yes" xml:space="preserve">
          <source>Heap</source>
          <target state="translated">Heap</target>
        </trans-unit>
        <trans-unit id="0a4d55a8d778e5022fab701977c5d840bbc486d0" translate="yes" xml:space="preserve">
          <source>Hello World</source>
          <target state="translated">안녕하세요 월드</target>
        </trans-unit>
        <trans-unit id="eb2b5f8e13d3308691d7960d4d635e1cf01bb3ec" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;ccv&lt;/code&gt; holds all parameters that are required to initialize the complex value &lt;code&gt;cv&lt;/code&gt;:</source>
          <target state="translated">여기에서 &lt;code&gt;ccv&lt;/code&gt; 는 복합 값 &lt;code&gt;cv&lt;/code&gt; 를 초기화하는 데 필요한 모든 매개 변수를 보유합니다 .</target>
        </trans-unit>
        <trans-unit id="eb897774693d7ee2f7c41d70e838958ed40277a4" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;cf&lt;/code&gt; is a pointer to nginx configuration and &lt;code&gt;name&lt;/code&gt; points to a string containing the variable name. The function returns &lt;code&gt;NGX_ERROR&lt;/code&gt; on error or a valid index otherwise, which is typically stored somewhere in the module's configuration for future use.</source>
          <target state="translated">여기서 &lt;code&gt;cf&lt;/code&gt; 는 nginx 구성에 대한 포인터이며 &lt;code&gt;name&lt;/code&gt; 은 변수 이름이 포함 된 문자열을 가리 킵니다. 이 함수는 오류가 발생하면 &lt;code&gt;NGX_ERROR&lt;/code&gt; 를 반환 하거나 그렇지 않으면 유효한 인덱스를 반환합니다.이 인덱스는 일반적으로 나중에 사용하기 위해 모듈 구성의 어딘가에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="6295679b32b6dca413cc16ef54a9f4ed28793a8e" translate="yes" xml:space="preserve">
          <source>Here, a client IP address serves as a key. Note that instead of &lt;code&gt;$remote_addr&lt;/code&gt;, the &lt;code&gt;$binary_remote_addr&lt;/code&gt; variable is used here. The &lt;code&gt;$remote_addr&lt;/code&gt; variable&amp;rsquo;s size can vary from 7 to 15 bytes. The stored state occupies either 32 or 64 bytes of memory on 32-bit platforms and always 64 bytes on 64-bit platforms. The &lt;code&gt;$binary_remote_addr&lt;/code&gt; variable&amp;rsquo;s size is always 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses. The stored state always occupies 32 or 64 bytes on 32-bit platforms and 64 bytes on 64-bit platforms. One megabyte zone can keep about 32 thousand 32-byte states or about 16 thousand 64-byte states. If the zone storage is exhausted, the server will return the &lt;a href=&quot;#limit_conn_status&quot;&gt;error&lt;/a&gt; to all further requests.</source>
          <target state="translated">여기서 클라이언트 IP 주소는 키 역할을합니다. 대신 주 &lt;code&gt;$remote_addr&lt;/code&gt; 의 &lt;code&gt;$binary_remote_addr&lt;/code&gt; 변수가 여기에 사용됩니다. &lt;code&gt;$remote_addr&lt;/code&gt; 변수의 크기는 7 ~ 15 바이트 다를 수 있습니다. 저장된 상태는 32 비트 플랫폼에서 32 바이트 또는 64 바이트의 메모리를 차지하고 64 비트 플랫폼에서는 항상 64 바이트를 차지합니다. &lt;code&gt;$binary_remote_addr&lt;/code&gt; 변수의 크기는 항상 IPv4 주소 4 바이트 또는 IPv6 주소에 대한 16 바이트입니다. 저장된 상태는 항상 32 비트 플랫폼에서 32 또는 64 바이트를, 64 비트 플랫폼에서 64 바이트를 차지합니다. 1MB 영역은 약 32,000 개의 32 바이트 상태 또는 약 16,000 개의 64 바이트 상태를 유지할 수 있습니다. 영역 저장소가 소진되면 서버는 모든 추가 요청에 &lt;a href=&quot;#limit_conn_status&quot;&gt;오류&lt;/a&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="1c7cfbb7c3b1f0ade8fb7351e26e87fb690bad9a" translate="yes" xml:space="preserve">
          <source>Here, the key is a client IP address set by the &lt;code&gt;$binary_remote_addr&lt;/code&gt; variable. The size of &lt;code&gt;$binary_remote_addr&lt;/code&gt; is 4 bytes for IPv4 addresses or 16 bytes for IPv6 addresses. The stored state always occupies 32 or 64 bytes on 32-bit platforms and 64 bytes on 64-bit platforms. One megabyte zone can keep about 32 thousand 32-byte states or about 16 thousand 64-byte states. If the zone storage is exhausted, the server will close the connection.</source>
          <target state="translated">여기서 키는 &lt;code&gt;$binary_remote_addr&lt;/code&gt; 변수로 설정된 클라이언트 IP 주소입니다 . &lt;code&gt;$binary_remote_addr&lt;/code&gt; 의 크기는 IPv4 주소의 경우 4 바이트, IPv6 주소의 경우 16 바이트입니다. 저장된 상태는 항상 32 비트 플랫폼에서 32 또는 64 바이트를, 64 비트 플랫폼에서 64 바이트를 차지합니다. 1MB 영역은 약 32,000 개의 32 바이트 상태 또는 약 16,000 개의 64 바이트 상태를 유지할 수 있습니다. 영역 저장소가 소진되면 서버가 연결을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="90e8486701336d3b9f59f96ca1c67b56ca56e52f" translate="yes" xml:space="preserve">
          <source>Here, the module name &lt;code&gt;http&lt;/code&gt; is used as a namespace while accessing exports. If the imported module contains &lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;http.foo&lt;/code&gt; is used to refer to it.</source>
          <target state="translated">여기서 모듈 이름 &lt;code&gt;http&lt;/code&gt; 는 내보내기에 액세스하는 동안 네임 스페이스로 사용됩니다. 가져온 모듈이 포함되어있는 경우 &lt;code&gt;foo()&lt;/code&gt; , &lt;code&gt;http.foo&lt;/code&gt; 는 그것을 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="30843cca80fd23660795c3e3738e4edb5a04f6d7" translate="yes" xml:space="preserve">
          <source>Here, the module name &lt;code&gt;stream&lt;/code&gt; is used as a namespace while accessing exports. If the imported module contains &lt;code&gt;foo()&lt;/code&gt;, &lt;code&gt;stream.foo&lt;/code&gt; is used to refer to it.</source>
          <target state="translated">여기서 모듈 이름 &lt;code&gt;stream&lt;/code&gt; 은 내보내기에 액세스하는 동안 네임 스페이스로 사용됩니다. 가져온 모듈이 포함되어있는 경우 &lt;code&gt;foo()&lt;/code&gt; , &lt;code&gt;stream.foo&lt;/code&gt; 는 그것을 참조하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb758feac83bfb29acfe14ce0e7a89d8ea01913d" translate="yes" xml:space="preserve">
          <source>Here, the route is taken from the &amp;ldquo;&lt;code&gt;JSESSIONID&lt;/code&gt;&amp;rdquo; cookie if present in a request. Otherwise, the route from the URI is used.</source>
          <target state="translated">여기서 요청에있는 경우 &quot; &lt;code&gt;JSESSIONID&lt;/code&gt; &quot;쿠키 에서 경로를 가져옵니다 . 그렇지 않으면 URI의 경로가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4080d483f672c2faab5837c2b122762694132116" translate="yes" xml:space="preserve">
          <source>Here, the server name is set to an empty string that will match requests without the &amp;ldquo;Host&amp;rdquo; header field, and a special nginx&amp;rsquo;s non-standard code 444 is returned that closes the connection.</source>
          <target state="translated">여기서 서버 이름은 &quot;Host&quot;헤더 필드가없는 요청과 일치하는 빈 문자열로 설정되며 연결을 닫는 특수 nginx의 비표준 코드 444가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6082baf71eedc019c872b8d2f5c4133cda8094f4" translate="yes" xml:space="preserve">
          <source>Here, the states are kept in a 10 megabyte zone &amp;ldquo;one&amp;rdquo;, and an average request processing rate for this zone cannot exceed 1 request per second.</source>
          <target state="translated">여기서 상태는 10MB 영역 &quot;1&quot;로 유지되며이 영역의 평균 요청 처리 속도는 초당 1 개의 요청을 초과 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ac8f6c15c955f3b23aaa97ab5ab40d6e05ba2838" translate="yes" xml:space="preserve">
          <source>Highest-priority SRV records (records with the same lowest-number priority value) are resolved as primary servers, the rest of SRV records are resolved as backup servers. If the &lt;a href=&quot;#backup&quot;&gt;backup&lt;/a&gt; parameter is specified for the server, high-priority SRV records are resolved as backup servers, the rest of SRV records are ignored.</source>
          <target state="translated">우선 순위가 가장 높은 SRV 레코드 (번호가 가장 낮은 우선 순위 값이 동일한 레코드)는 기본 서버로 해석되고 나머지 SRV 레코드는 백업 서버로 해석됩니다. 서버에 &lt;a href=&quot;#backup&quot;&gt;백업&lt;/a&gt; 매개 변수를 지정하면 우선 순위가 높은 SRV 레코드가 백업 서버로 해석되고 나머지 SRV 레코드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="71d1440a57fe3055a56aa06d17a2e5270417ab3b" translate="yes" xml:space="preserve">
          <source>Hostname of the resolved server. The hostname is assigned automatically and cannot be changed.</source>
          <target state="translated">해결 된 서버의 호스트 이름 호스트 이름은 자동으로 할당되며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1757ee8015a8c251c332071799105e755f08fd37" translate="yes" xml:space="preserve">
          <source>How many times the server became unavailable for client connections (state &amp;ldquo;&lt;code&gt;unavail&lt;/code&gt;&amp;rdquo;) due to the number of unsuccessful attempts reaching the &lt;a href=&quot;../stream/ngx_stream_upstream_module#max_fails&quot;&gt;max_fails&lt;/a&gt; threshold.</source>
          <target state="translated">&lt;a href=&quot;../stream/ngx_stream_upstream_module#max_fails&quot;&gt;max_fails&lt;/a&gt; 임계 값 에 도달하지 못한 시도 횟수로 인해 서버가 클라이언트 연결에 사용할 수없는 횟수 (상태 &quot; &lt;code&gt;unavail&lt;/code&gt; &quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="5ed3247b9ed58be10b80ad1850880f3f803c92f7" translate="yes" xml:space="preserve">
          <source>How many times the server became unavailable for client requests (state &amp;ldquo;&lt;code&gt;unavail&lt;/code&gt;&amp;rdquo;) due to the number of unsuccessful attempts reaching the &lt;a href=&quot;ngx_http_upstream_module#max_fails&quot;&gt;max_fails&lt;/a&gt; threshold.</source>
          <target state="translated">&lt;a href=&quot;ngx_http_upstream_module#max_fails&quot;&gt;max_fails&lt;/a&gt; 임계 값 에 도달하지 못한 시도 횟수로 인해 서버가 클라이언트 요청에 사용할 수없는 횟수 (상태 &quot; &lt;code&gt;unavail&lt;/code&gt; &quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="86b979979e84e11ea982e3df1b466045d99f9b03" translate="yes" xml:space="preserve">
          <source>How many times the server became unhealthy (state &amp;ldquo;&lt;code&gt;unhealthy&lt;/code&gt;&amp;rdquo;).</source>
          <target state="translated">몇 번 서버 (상태 &quot;건강에 해로운되었다 &lt;code&gt;unhealthy&lt;/code&gt; &quot;).</target>
        </trans-unit>
        <trans-unit id="a3d6a424409dcdb938bf8080f6fa522c73fad230" translate="yes" xml:space="preserve">
          <source>How nginx processes a TCP/UDP session</source>
          <target state="translated">nginx가 TCP / UDP 세션을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="0b1e403621e39f5fd62191a955ac613b641dab03" translate="yes" xml:space="preserve">
          <source>How nginx processes a request</source>
          <target state="translated">nginx가 요청을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="4bc716af70df567d37043a0786c94796ecbd792d" translate="yes" xml:space="preserve">
          <source>How to prevent processing requests with undefined server names</source>
          <target state="translated">정의되지 않은 서버 이름으로 요청을 처리하지 못하게하는 방법</target>
        </trans-unit>
        <trans-unit id="0ccf3c0e6d75a1363a41c1fa2aee92092546eb7c" translate="yes" xml:space="preserve">
          <source>How-To</source>
          <target state="translated">How-To</target>
        </trans-unit>
        <trans-unit id="9b0181e81f05ce54b0cf87b6c113034089971d0e" translate="yes" xml:space="preserve">
          <source>However, if the SNI-enabled nginx is linked dynamically to an OpenSSL library without SNI support, nginx displays the warning:</source>
          <target state="translated">그러나 SNI 지원 nginx가 SNI 지원없이 OpenSSL 라이브러리에 동적으로 링크되면 nginx는 다음과 같은 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="99c3f9b4869b6de1a489f31e3482baee6f89a057" translate="yes" xml:space="preserve">
          <source>However, if this field is not present in a client request header then nothing will be passed. In such a case it is better to use the &lt;code&gt;$host&lt;/code&gt; variable - its value equals the server name in the &amp;ldquo;Host&amp;rdquo; request header field or the primary server name if this field is not present:</source>
          <target state="translated">그러나이 필드가 클라이언트 요청 헤더에 없으면 아무것도 전달되지 않습니다. 이러한 경우 &lt;code&gt;$host&lt;/code&gt; 변수 를 사용하는 것이 좋습니다. 이 값이&amp;ldquo;Host&amp;rdquo;요청 헤더 필드의 서버 이름 또는이 필드가없는 경우 기본 서버 이름과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ec97186659278d82ecb2f3f9a96c59bd94f8bfa2" translate="yes" xml:space="preserve">
          <source>However, such usage should be limited to simple cases (like the above), since the digital references can easily be overwritten.</source>
          <target state="translated">그러나 디지털 레퍼런스를 쉽게 덮어 쓸 수 있기 때문에 이러한 사용은 위와 같은 간단한 경우로 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="fdf962ebb2ed3364751c39ab6ebf56694539fa84" translate="yes" xml:space="preserve">
          <source>I/O events</source>
          <target state="translated">I / O 이벤트</target>
        </trans-unit>
        <trans-unit id="c9f9d285fbda0238baeddbc6c75d48ca1b121a48" translate="yes" xml:space="preserve">
          <source>IPv6 addresses (0.7.36) are specified in square brackets:</source>
          <target state="translated">IPv6 주소 (0.7.36)는 대괄호로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="c28fe0b84bd564763c18f7f87659a6e469e0704a" translate="yes" xml:space="preserve">
          <source>IPv6 addresses (0.7.58) are specified in square brackets:</source>
          <target state="translated">IPv6 주소 (0.7.58)는 대괄호로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d59e7452ec939ca836bc3969a8d0bd20efd6e0e4" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are specified in square brackets:</source>
          <target state="translated">IPv6 주소는 대괄호로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="56f8d1eafca9734e6e11ed8d49fde17bf03293a5" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are supported starting from versions 1.3.0 and 1.2.1.</source>
          <target state="translated">IPv6 주소는 버전 1.3.0 및 1.2.1부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="abec331d8858b85575020654b4dea6c8d14e57a5" translate="yes" xml:space="preserve">
          <source>IPv6 addresses are supported starting from versions 1.3.2 and 1.2.2.</source>
          <target state="translated">IPv6 주소는 버전 1.3.2 및 1.2.2부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="c37e9ceaef532b489b503c4d9bd1a504b1fc938b" translate="yes" xml:space="preserve">
          <source>IPv6 prefixes are supported starting from versions 1.3.10 and 1.2.7.</source>
          <target state="translated">IPv6 접두사는 버전 1.3.10 및 1.2.7부터 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2be35bbc3fdf0b7a4ee1006b55940d59fdc372b0" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#accept_mutex&quot;&gt;accept_mutex&lt;/a&gt; is enabled, specifies the maximum time during which a worker process will try to restart accepting new connections if another worker process is currently accepting new connections.</source>
          <target state="translated">경우 &lt;a href=&quot;#accept_mutex&quot;&gt;accept_mutex가&lt;/a&gt; 활성화되어, 작업자 프로세스가 다른 작업자 프로세스가 현재 새로운 연결을 허용하는 경우 새로운 연결을 허용 다시 시작을 시도하는 동안 최대 시간을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="729768543d9f4a04272d605cfe73e5351fc3b67c" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#aio&quot;&gt;aio&lt;/a&gt; is enabled, specifies whether it is used for writing files. Currently, this only works when using &lt;code&gt;aio threads&lt;/code&gt; and is limited to writing temporary files with data received from proxied servers.</source>
          <target state="translated">&lt;a href=&quot;#aio&quot;&gt;aio&lt;/a&gt; 가 활성화 된 경우 파일 쓰기에 사용할지 여부를 지정합니다. 현재 이것은 &lt;code&gt;aio threads&lt;/code&gt; 사용할 때만 작동 하며 프록시 서버에서 수신 한 데이터로 임시 파일을 작성하는 것으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9b231f05706e7ab967b25a11ae3c9b694b0281d8" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#keepalive&quot;&gt;idle keepalive&lt;/a&gt; connections, multiple &lt;a href=&quot;../ngx_core_module#worker_processes&quot;&gt;workers&lt;/a&gt;, and the &lt;a href=&quot;#zone&quot;&gt;shared memory&lt;/a&gt; are enabled, the total number of active and idle connections to the proxied server may exceed the &lt;code&gt;max_conns&lt;/code&gt; value.</source>
          <target state="translated">경우 &lt;a href=&quot;#keepalive&quot;&gt;유휴 연결 유지&lt;/a&gt; 연결, 다수의 &lt;a href=&quot;../ngx_core_module#worker_processes&quot;&gt;근로자&lt;/a&gt; 및 &lt;a href=&quot;#zone&quot;&gt;공유 메모리가&lt;/a&gt; 활성화의 프록시 서버에 활성 및 유휴 연결의 총 수는 초과 할 수 &lt;code&gt;max_conns&lt;/code&gt; 값입니다.</target>
        </trans-unit>
        <trans-unit id="904c8175edef8527cdcc862271051817cb65e869" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#xclient&quot;&gt;XCLIENT&lt;/a&gt; is also enabled, then the &lt;code&gt;XCLIENT&lt;/code&gt; command will not send the &lt;code&gt;LOGIN&lt;/code&gt; parameter.</source>
          <target state="translated">경우 &lt;a href=&quot;#xclient&quot;&gt;X 클라이언트는&lt;/a&gt; 또한 활성화 한 다음 &lt;code&gt;XCLIENT&lt;/code&gt; 명령을 전송하지 않습니다 &lt;code&gt;LOGIN&lt;/code&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="d7e3db022799fd3be5e02a20b7e91c3c71653deb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;i&gt;uri&lt;/i&gt;&lt;/code&gt; processing leads to an error, the status code of the last occurred error is returned to the client.</source>
          <target state="translated">경우 &lt;code&gt;&lt;i&gt;uri&lt;/i&gt;&lt;/code&gt; 오류로 처리 리드, 마지막으로 발생한 오류의 상태 코드는 클라이언트에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="39fda52fe72b2f1dcb27af5facf90cb48a9bc326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;XCLIENT&lt;/code&gt; is disabled then nginx passes the &lt;code&gt;EHLO&lt;/code&gt; command with the &lt;a href=&quot;ngx_mail_core_module#server_name&quot;&gt;server name&lt;/a&gt; when connecting to the backend if the client has passed &lt;code&gt;EHLO&lt;/code&gt;, or &lt;code&gt;HELO&lt;/code&gt; with the server name, otherwise.</source>
          <target state="translated">&lt;code&gt;XCLIENT&lt;/code&gt; 가 비활성화 되면 nginx는 클라이언트가 &lt;code&gt;EHLO&lt;/code&gt; 를 통과 한 경우 백엔드에 연결 하거나 서버 이름을 가진 &lt;code&gt;HELO&lt;/code&gt; 를 전달 하면 &lt;a href=&quot;ngx_mail_core_module#server_name&quot;&gt;서버 이름&lt;/a&gt; 과 함께 &lt;code&gt;EHLO&lt;/code&gt; 명령을 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="69574bbf35070098a73af9dffad8fe6cc0bd6d8c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;XCLIENT&lt;/code&gt; is enabled then nginx passes the following commands when connecting to the backend:</source>
          <target state="translated">&lt;code&gt;XCLIENT&lt;/code&gt; 가 활성화 되면 nginx는 백엔드에 연결할 때 다음 명령을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="20db931d85d8e017f720b885949e21348c7d7fdc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;accept_mutex&lt;/code&gt; is enabled, worker processes will accept new connections by turn. Otherwise, all worker processes will be notified about new connections, and if volume of new connections is low, some of the worker processes may just waste system resources.</source>
          <target state="translated">경우 &lt;code&gt;accept_mutex&lt;/code&gt; 가 활성화되어, 작업자 프로세스가 회전하여 새로운 연결을 받아 들일 것입니다. 그렇지 않으면 모든 작업자 프로세스에 새 연결에 대한 알림이 표시되고 새 연결의 양이 적 으면 일부 작업자 프로세스가 시스템 리소스를 낭비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5a032c049007be51572209ff8b2df11b3a88906" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alias&lt;/code&gt; is used inside a location defined with a regular expression then such regular expression should contain captures and &lt;code&gt;alias&lt;/code&gt; should refer to these captures (0.7.40), for example:</source>
          <target state="translated">정규식으로 정의 된 위치 내에서 &lt;code&gt;alias&lt;/code&gt; 을 사용하는 경우 이러한 정규식에는 캡처가 포함되어야하고 &lt;code&gt;alias&lt;/code&gt; 은 이러한 캡처 (0.7.40)를 참조해야합니다.</target>
        </trans-unit>
        <trans-unit id="f754fd66ce606b49b5912e20d58c3d4fed1f7b09" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;multi_accept&lt;/code&gt; is disabled, a worker process will accept one new connection at a time. Otherwise, a worker process will accept all new connections at a time.</source>
          <target state="translated">경우 &lt;code&gt;multi_accept&lt;/code&gt; 가 비활성화되어, 작업자 프로세스는 한 번에 하나의 새로운 연결을 받아 들일 것입니다. 그렇지 않으면 작업자 프로세스는 한 번에 모든 새로운 연결을 수락합니다.</target>
        </trans-unit>
        <trans-unit id="7883139ddeab43e88b1ff6922f6ff9661a256cd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;options&lt;/code&gt; is a string, then it holds the subrequest arguments string. Otherwise, &lt;code&gt;options&lt;/code&gt; is expected to be an object with the following keys:</source>
          <target state="translated">경우 &lt;code&gt;options&lt;/code&gt; 문자열이며, 다음은 subrequest 인수 문자열을 보유하고 있습니다. 그렇지 않으면 &lt;code&gt;options&lt;/code&gt; 은 다음 키가있는 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="7488481f800be4221b9d5672226be64004126cb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;proxy_pass&lt;/code&gt; is specified without a URI, the request URI is passed to the server in the same form as sent by a client when the original request is processed, or the full normalized request URI is passed when processing the changed URI:</source>
          <target state="translated">경우 &lt;code&gt;proxy_pass&lt;/code&gt; 가 URI로없이 지정된 원래 요청이 처리 될 때, 상기 요청 URI는 클라이언트에 의해 전송 된 것과 동일한 형태로 서버에 전달하거나, 변경 URI를 처리 할 때의 전체 정규화 요청 URI가 전달된다 :</target>
        </trans-unit>
        <trans-unit id="1c29d9630ab7135088817667439aa390e5a4e733" translate="yes" xml:space="preserve">
          <source>If HUP is sent to the master process, the output becomes:</source>
          <target state="translated">HUP가 마스터 프로세스로 전송되면 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ff3b0f13c81272371163fc583096e572eb5957d5" translate="yes" xml:space="preserve">
          <source>If PHP was built with the &lt;code&gt;--enable-force-cgi-redirect&lt;/code&gt; configuration parameter, the &lt;code&gt;REDIRECT_STATUS&lt;/code&gt; parameter should also be passed with the value &amp;ldquo;200&amp;rdquo;:</source>
          <target state="translated">PHP가 &lt;code&gt;--enable-force-cgi-redirect&lt;/code&gt; 구성 매개 변수 로 빌드 된 경우 &lt;code&gt;REDIRECT_STATUS&lt;/code&gt; 매개 변수도&amp;ldquo;200&amp;rdquo;값으로 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="308dd8928ed04b956c81dc9e080b6da939096263" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;i&gt;replacement&lt;/i&gt;&lt;/code&gt; string includes the new request arguments, the previous request arguments are appended after them. If this is undesired, putting a question mark at the end of a replacement string avoids having them appended, for example:</source>
          <target state="translated">경우 &lt;code&gt;&lt;i&gt;replacement&lt;/i&gt;&lt;/code&gt; 문자열이 새로운 요청 인수를 포함, 이전 요청 인수는 그 이후에 추가됩니다. 이것이 바람직하지 않은 경우, 대체 문자열의 끝에 물음표를 넣으면 다음과 같이 추가하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="3b29898c09de7c4c7f46a4d5d4bf27afac3ab980" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;i&gt;text&lt;/i&gt;&lt;/code&gt; contains variables, their values are substituted. A regular expression can contain positional and named captures that can later be used through variables, for example:</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;text&lt;/i&gt;&lt;/code&gt; 에 변수가 포함되어 있으면 해당 값이 대체됩니다. 정규식에는 다음과 같이 변수를 통해 나중에 사용할 수있는 위치 및 명명 된 캡처가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9c7156c0ffbf7557f0c59d12b38beacb9e850d" translate="yes" xml:space="preserve">
          <source>If a certificate bundle has not been added, only the server certificate #0 will be shown.</source>
          <target state="translated">인증서 번들이 추가되지 않은 경우 서버 인증서 # 0 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc7eb7f30209d2fc4729e4cfd1ad8923657994c" translate="yes" xml:space="preserve">
          <source>If a directive is specified inside the &lt;a href=&quot;ngx_http_core_module#location&quot;&gt;location&lt;/a&gt;, further processing of the request continues in this location.</source>
          <target state="translated">&lt;a href=&quot;ngx_http_core_module#location&quot;&gt;location&lt;/a&gt; 내에 지시문이 지정된 경우이 위치에서 요청의 추가 처리가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="ef1abdb4766ef1c4b5eaa1e80c8dc37c9a707ddf" translate="yes" xml:space="preserve">
          <source>If a domain name resolves to several addresses, all of them will be used in a round-robin fashion. In addition, an address can be specified as a &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;server group&lt;/a&gt;.</source>
          <target state="translated">도메인 이름이 여러 주소로 확인되면 모든 주소가 라운드 로빈 방식으로 사용됩니다. 또한 주소는 &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;서버 그룹&lt;/a&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="982ef0e5fa3ad62eaf6876922125fc3bb34d2f01" translate="yes" xml:space="preserve">
          <source>If a domain name resolves to several addresses, all of them will be used in a round-robin fashion. In addition, an address can be specified as a &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;server group&lt;/a&gt;.</source>
          <target state="translated">도메인 이름이 여러 주소로 확인되면 모든 주소가 라운드 로빈 방식으로 사용됩니다. 또한 주소는 &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;서버 그룹&lt;/a&gt; 으로 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59c38a1db055ba2f61be92c19807e23829aa26d7" translate="yes" xml:space="preserve">
          <source>If a health check fails, the server will be considered unhealthy. If several health checks are defined for the same group of servers, a single failure of any check will make the corresponding server be considered unhealthy. Client connections are not passed to unhealthy servers and servers in the &amp;ldquo;checking&amp;rdquo; state.</source>
          <target state="translated">상태 확인에 실패하면 서버가 비정상으로 간주됩니다. 동일한 서버 그룹에 대해 여러 가지 상태 확인이 정의 된 경우 한 번의 확인 실패로 해당 서버가 비정상으로 간주됩니다. 클라이언트 연결이 &quot;검사 중&quot;상태 인 비정상 서버 및 서버로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99cecc74276c88bd23b1bb427f540c7fa4a4a46b" translate="yes" xml:space="preserve">
          <source>If a health check fails, the server will be considered unhealthy. If several health checks are defined for the same group of servers, a single failure of any check will make the corresponding server be considered unhealthy. Client requests are not passed to unhealthy servers and servers in the &amp;ldquo;checking&amp;rdquo; state.</source>
          <target state="translated">상태 확인에 실패하면 서버가 비정상으로 간주됩니다. 동일한 서버 그룹에 대해 여러 가지 상태 확인이 정의 된 경우 한 번의 확인 실패로 해당 서버가 비정상으로 간주됩니다. 클라이언트 요청은 &quot;검사 중&quot;상태 인 비정상 서버 및 서버로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f300438fb9e02597f12cca9b9cd475dfabdf785c" translate="yes" xml:space="preserve">
          <source>If a large number of server names are defined, another error message will appear:</source>
          <target state="translated">많은 수의 서버 이름이 정의되면 다른 오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3282d19821bdede352887aac7b4d8502ad3e6ae7" translate="yes" xml:space="preserve">
          <source>If a large number of server names are defined, or unusually long server names are defined, tuning the &lt;a href=&quot;ngx_http_core_module#server_names_hash_max_size&quot;&gt;server_names_hash_max_size&lt;/a&gt; and &lt;a href=&quot;ngx_http_core_module#server_names_hash_bucket_size&quot;&gt;server_names_hash_bucket_size&lt;/a&gt; directives at the</source>
          <target state="translated">많은 수의 서버 이름이 정의되거나 비정상적으로 긴 서버 이름이 정의 된 경우 &lt;a href=&quot;ngx_http_core_module#server_names_hash_max_size&quot;&gt;server_names_hash_max_size&lt;/a&gt; 및 &lt;a href=&quot;ngx_http_core_module#server_names_hash_bucket_size&quot;&gt;server_names_hash_bucket_size&lt;/a&gt; 지시문을</target>
        </trans-unit>
        <trans-unit id="18bc3678330e1c4d477f59498ba8584f0d0180a6" translate="yes" xml:space="preserve">
          <source>If a link has a limited lifetime, the expiration time is set in seconds since Epoch (Thu, 01 Jan 1970 00:00:00 GMT). The value is specified in the expression after the MD5 hash, and is separated by a comma. The expiration time passed in a request is available through the &lt;code&gt;$secure_link_expires&lt;/code&gt; variable for a use in the &lt;a href=&quot;#secure_link_md5&quot;&gt;secure_link_md5&lt;/a&gt; directive. If the expiration time is not specified, a link has the unlimited lifetime.</source>
          <target state="translated">링크의 수명이 제한된 경우 만료 시간은 Epoch 이후 (초, 1970 년 1 월 1 일 00:00:00 GMT) 이후 초 단위로 설정됩니다. 값은 MD5 해시 뒤의 표현식에 지정되며 쉼표로 구분됩니다. 요청에 전달 된 만기 시간 은 &lt;a href=&quot;#secure_link_md5&quot;&gt;secure_link_md5&lt;/a&gt; 지시문 에서 사용하기 위해 &lt;code&gt;$secure_link_expires&lt;/code&gt; 변수를 통해 사용 가능 합니다. 만료 시간을 지정하지 않으면 링크 수명이 무제한입니다.</target>
        </trans-unit>
        <trans-unit id="54c3c2f8ade044ac7c18101134ad56e5e86923c5" translate="yes" xml:space="preserve">
          <source>If a location is defined by a prefix string that ends with the slash character, and requests are processed by one of &lt;a href=&quot;ngx_http_proxy_module#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt;, &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_pass&quot;&gt;fastcgi_pass&lt;/a&gt;, &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_pass&quot;&gt;uwsgi_pass&lt;/a&gt;, &lt;a href=&quot;ngx_http_scgi_module#scgi_pass&quot;&gt;scgi_pass&lt;/a&gt;, &lt;a href=&quot;ngx_http_memcached_module#memcached_pass&quot;&gt;memcached_pass&lt;/a&gt;, or &lt;a href=&quot;ngx_http_grpc_module#grpc_pass&quot;&gt;grpc_pass&lt;/a&gt;, then the special processing is performed. In response to a request with URI equal to this string, but without the trailing slash, a permanent redirect with the code 301 will be returned to the requested URI with the slash appended. If this is not desired, an exact match of the URI and location could be defined like this:</source>
          <target state="translated">위치가 슬래시 문자로 끝나는 접두사 문자열로 정의되고 요청이 &lt;a href=&quot;ngx_http_proxy_module#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; , &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_pass&quot;&gt;fastcgi_pass&lt;/a&gt; , &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_pass&quot;&gt;uwsgi_pass&lt;/a&gt; , &lt;a href=&quot;ngx_http_scgi_module#scgi_pass&quot;&gt;scgi_pass&lt;/a&gt; , &lt;a href=&quot;ngx_http_memcached_module#memcached_pass&quot;&gt;memcached_pass&lt;/a&gt; 또는 &lt;a href=&quot;ngx_http_grpc_module#grpc_pass&quot;&gt;grpc_pass 중 하나로&lt;/a&gt; 처리되면 특수 처리가 수행됩니다. 이 문자열과 같지만 후행 슬래시가없는 URI의 요청에 응답하여 슬래시가 추가 된 코드 301의 영구 리디렉션이 요청 된 URI로 반환됩니다. 이것이 바람직하지 않은 경우, URI와 위치의 정확한 일치는 다음과 같이 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5296c1ebb4e73e0dce03176d06e6e2468f77c585" translate="yes" xml:space="preserve">
          <source>If a matching request does not include the &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; arguments, there is no overhead, and the file is sent simply as a static resource. Some players also support byte-range requests, and thus do not require this module.</source>
          <target state="translated">일치하는 요청에 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 인수가 포함되어 있지 않으면 오버 헤드가없고 파일이 단순히 정적 자원으로 전송됩니다. 일부 플레이어는 바이트 범위 요청도 지원하므로이 모듈이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4743b80ad71b42e884bc34aa424f79ffbc5f6c3" translate="yes" xml:space="preserve">
          <source>If a regular expression includes the &amp;ldquo;&lt;code&gt;}&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;;&lt;/code&gt;&amp;rdquo; characters, the whole expressions should be enclosed in single or double quotes.</source>
          <target state="translated">정규식에 &quot; &lt;code&gt;}&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;;&lt;/code&gt; &amp;rdquo;문자의 경우 전체 표현식을 작은 따옴표 나 큰 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="edd8826b8cf0d84ee26e5b1ef80dbdb62ba18dfd" translate="yes" xml:space="preserve">
          <source>If a server is the only server for a listen port, then nginx will not test server names at all (and will not build the hash tables for the listen port). However, there is one exception. If a server name is a regular expression with captures, then nginx has to execute the expression to get the captures.</source>
          <target state="translated">서버가 청취 포트에 대한 유일한 서버 인 경우 nginx는 서버 이름을 전혀 테스트하지 않으며 청취 포트에 대한 해시 테이블을 작성하지 않습니다. 그러나 한 가지 예외가 있습니다. 서버 이름이 캡처가있는 정규식 인 경우 nginx는 캡처를 가져 오려면 표현식을 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c178ede12c9ed741cef1afa9dcb7f97fdac41cb" translate="yes" xml:space="preserve">
          <source>If a server name is defined as &amp;ldquo;&lt;code&gt;$hostname&lt;/code&gt;&amp;rdquo; (0.9.4), the machine&amp;rsquo;s hostname is used.</source>
          <target state="translated">서버 이름이 &quot; &lt;code&gt;$hostname&lt;/code&gt; &quot;(0.9.4) 으로 정의 된 경우 시스템의 호스트 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="95efb639d2fa8268b01c14517bef72315fd38342" translate="yes" xml:space="preserve">
          <source>If a source value matches one of the names of special parameters described below, it should be prefixed with the &amp;ldquo;&lt;code&gt;\&lt;/code&gt;&amp;rdquo; symbol.</source>
          <target state="translated">소스 값이 아래 설명 된 특수 매개 변수 이름 중 하나와 일치하면 접두사에 &quot; &lt;code&gt;\&lt;/code&gt; &quot;기호 가 붙어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d26ecff49cc23f00177e8061fcfd50153048d84b" translate="yes" xml:space="preserve">
          <source>If a third-party mp4 module was previously used, it should be disabled.</source>
          <target state="translated">타사 mp4 모듈을 이전에 사용한 경우 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="a4e1510ac95f73f787ee9685a90de9fe49e02179" translate="yes" xml:space="preserve">
          <source>If an HLS stream is protected with the &lt;a href=&quot;ngx_http_secure_link_module&quot;&gt;ngx_http_secure_link_module&lt;/a&gt; module, &lt;code&gt;$uri&lt;/code&gt; should not be used in the &lt;a href=&quot;ngx_http_secure_link_module#secure_link_md5&quot;&gt;secure_link_md5&lt;/a&gt; expression because this will cause errors when requesting the fragments. &lt;a href=&quot;ngx_http_map_module#map&quot;&gt;Base URI&lt;/a&gt; should be used instead of &lt;code&gt;$uri&lt;/code&gt; (&lt;code&gt;$hls_uri&lt;/code&gt; in the example):</source>
          <target state="translated">&lt;a href=&quot;ngx_http_secure_link_module&quot;&gt;Hng&lt;/a&gt; 스트림이 ngx_http_secure_link_module 모듈로 보호되는 경우 &lt;code&gt;$uri&lt;/code&gt; 는 &lt;a href=&quot;ngx_http_secure_link_module#secure_link_md5&quot;&gt;secure_link_md5&lt;/a&gt; 표현식에 사용하면 안됩니다 . 조각을 요청할 때 오류가 발생하기 때문입니다. &lt;code&gt;$uri&lt;/code&gt; ( 예제에서 &lt;code&gt;$hls_uri&lt;/code&gt; 대신 &lt;a href=&quot;ngx_http_map_module#map&quot;&gt;기본 URI를&lt;/a&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="98ac01778ff94b17ec547f83e18d4d395ae07fcd" translate="yes" xml:space="preserve">
          <source>If an error response is processed by a proxied server or a FastCGI/uwsgi/SCGI/gRPC server, and the server may return different response codes (e.g., 200, 302, 401 or 404), it is possible to respond with the code it returns:</source>
          <target state="translated">프록시 서버 또는 FastCGI / uwsgi / SCGI / gRPC 서버에서 오류 응답을 처리하고 서버가 다른 응답 코드 (예 : 200, 302, 401 또는 404)를 반환 할 수있는 경우 해당 코드로 응답 할 수 있습니다 보고:</target>
        </trans-unit>
        <trans-unit id="6cc5cf7d7ca8950af7421fff0ffa987d45aaa465" translate="yes" xml:space="preserve">
          <source>If an expression does not fit into single line, it is wrapped. The preferred point to break a line is a binary operator. The continuation line is lined up with the start of expression:</source>
          <target state="translated">식이 한 줄에 맞지 않으면 줄 바꿈됩니다. 줄을 끊는 가장 좋은 점은 이진 연산자입니다. 연속 줄은 표현식의 시작과 함께 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="7aa3005482753e3b2c474a273a82fa3d1968de95" translate="yes" xml:space="preserve">
          <source>If an upstream server cannot be selected immediately while processing a request, the request will be placed into the queue. The directive specifies the maximum &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; of requests that can be in the queue at the same time. If the queue is filled up, or the server to pass the request to cannot be selected within the time period specified in the &lt;code&gt;timeout&lt;/code&gt; parameter, the 502 (Bad Gateway) error will be returned to the client.</source>
          <target state="translated">요청을 처리하는 동안 업스트림 서버를 즉시 선택할 수 없으면 요청이 큐에 배치됩니다. 지시문 은 동시에 큐에있을 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; 있는 최대 요청 &lt;i&gt;수&lt;/i&gt; 를 지정합니다 . 큐가 채워지거나 &lt;code&gt;timeout&lt;/code&gt; 매개 변수에 지정된 기간 내에 요청을 전달할 서버를 선택할 수없는 경우 502 (Bad Gateway) 오류가 클라이언트에 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5ce2f914156342fb72466a5239f711205c528185" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;group&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt; access permissions are specified then &lt;code&gt;user&lt;/code&gt; permissions may be omitted:</source>
          <target state="translated">어떤 경우 &lt;code&gt;group&lt;/code&gt; 또는 &lt;code&gt;all&lt;/code&gt; 액세스 권한이 지정하는 &lt;code&gt;user&lt;/code&gt; 권한을 생략 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="2bb1e5e6fe896dc0ff6a76040b17e3fde466dcce" translate="yes" xml:space="preserve">
          <source>If any component of the pathname is a symbolic link, access to a file is denied.</source>
          <target state="translated">경로명의 구성 요소가 기호 링크 인 경우 파일에 대한 액세스가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="005a02195ba4426a77fb893348b2f34a65b4b7e2" translate="yes" xml:space="preserve">
          <source>If any of the specified substrings is found in the &amp;ldquo;User-Agent&amp;rdquo; request header field, the browser will be considered ancient. The special string &amp;ldquo;&lt;code&gt;netscape4&lt;/code&gt;&amp;rdquo; corresponds to the regular expression &amp;ldquo;&lt;code&gt;^Mozilla/[1-4]&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">&quot;User-Agent&quot;요청 헤더 필드에 지정된 하위 문자열이 있으면 브라우저는 고대로 간주됩니다. 특수 문자열 &quot; &lt;code&gt;netscape4&lt;/code&gt; &quot;는 정규식 &quot; &lt;code&gt;^Mozilla/[1-4]&lt;/code&gt; &quot;에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a4ec51f3dd81ffaca733bb296125afab4372707c" translate="yes" xml:space="preserve">
          <source>If any parameters are omitted, the corresponding cookie fields are not set.</source>
          <target state="translated">매개 변수를 생략하면 해당 쿠키 필드가 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b466585284f67046fb51ce5706c4e0ac87d6cc8" translate="yes" xml:space="preserve">
          <source>If caching is enabled, the header fields &amp;ldquo;If-Modified-Since&amp;rdquo;, &amp;ldquo;If-Unmodified-Since&amp;rdquo;, &amp;ldquo;If-None-Match&amp;rdquo;, &amp;ldquo;If-Match&amp;rdquo;, &amp;ldquo;Range&amp;rdquo;, and &amp;ldquo;If-Range&amp;rdquo; from the original request are not passed to the proxied server.</source>
          <target state="translated">캐싱이 활성화 된 경우 헤더 필드의 &quot;If-Modified-Since&quot;, &quot;If-Unmodified-Since&quot;, &quot;If-None-Match&quot;, &quot;If-Match&quot;, &quot;Range&quot;및 &quot;If-Range&quot; 원래 요청은 프록시 서버로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1052d5348593f446e220ed42cfffdc976a278ad7" translate="yes" xml:space="preserve">
          <source>If delaying of excessive requests while requests are being limited is not desired, the parameter &lt;code&gt;nodelay&lt;/code&gt; should be used:</source>
          <target state="translated">요청이 제한되는 동안 과도한 요청 지연이 바람직하지 않은 경우 매개 변수 &lt;code&gt;nodelay&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d7aa3181983cb18e1d081a1505cc8941709cec6f" translate="yes" xml:space="preserve">
          <source>If disabled, redirects issued by nginx will be relative.</source>
          <target state="translated">비활성화하면, nginx가 발행 한 리디렉션은 상대적입니다.</target>
        </trans-unit>
        <trans-unit id="983b6b8e51b702c28fd6a3cd711b654ade6cbc27" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;buffer&lt;/code&gt; or &lt;code&gt;gzip&lt;/code&gt; (1.3.10, 1.2.7) parameter is used, writes to log will be buffered.</source>
          <target state="translated">어느 경우 &lt;code&gt;buffer&lt;/code&gt; 또는 &lt;code&gt;gzip&lt;/code&gt; (1.3.10은, 1.2.7) 매개 변수가 사용되는 버퍼링한다 로그에 기록.</target>
        </trans-unit>
        <trans-unit id="1356b4adf2d22e853656fe55e68e5eed7dd22d87" translate="yes" xml:space="preserve">
          <source>If either the &lt;code&gt;buffer&lt;/code&gt; or &lt;code&gt;gzip&lt;/code&gt; parameter is used, writes to log will be buffered.</source>
          <target state="translated">어느 경우 &lt;code&gt;buffer&lt;/code&gt; 또는 &lt;code&gt;gzip&lt;/code&gt; 매개 변수를 사용하는, 버퍼링 할 로그에 기록.</target>
        </trans-unit>
        <trans-unit id="2a2d49dfc4522202a1d0573dc8bccb88cff6461d" translate="yes" xml:space="preserve">
          <source>If enabled, SSL handshakes in the &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; block will be rejected.</source>
          <target state="translated">활성화되면 &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 블록의 SSL 핸드 셰이크 가 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="d19dd0a15ae7e1366d7cdec704893ce305c416be" translate="yes" xml:space="preserve">
          <source>If enabled, final images will be interlaced. For JPEG, final images will be in &amp;ldquo;progressive JPEG&amp;rdquo; format.</source>
          <target state="translated">활성화하면 최종 이미지가 인터레이스됩니다. JPEG의 경우 최종 이미지는 &quot;프로그레시브 JPEG&quot;형식입니다.</target>
        </trans-unit>
        <trans-unit id="f1502751c09bd4f3fd411c73b1096955b9f54738" translate="yes" xml:space="preserve">
          <source>If enabled, suppresses the output of the &amp;ldquo;&lt;code&gt;[an error occurred while processing the directive]&lt;/code&gt;&amp;rdquo; string if an error occurred during SSI processing.</source>
          <target state="translated">사용 가능한 경우 SSI 처리 중에 오류가 발생 하면 &quot; &lt;code&gt;[an error occurred while processing the directive]&lt;/code&gt; &quot;문자열 의 출력을 억제합니다 .</target>
        </trans-unit>
        <trans-unit id="9ae5f9a65d77416dbe6a9e2aec9ee874f7d0ac71" translate="yes" xml:space="preserve">
          <source>If identifiers are issued by multiple servers (services), each service should be assigned its own &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; to ensure that client identifiers are unique. For version 1 cookies, the default value is zero. For version 2 cookies, the default value is the number composed from the last four octets of the server&amp;rsquo;s IP address.</source>
          <target state="translated">여러 서버 (서비스)에서 식별자를 발급 한 경우 클라이언트 식별자가 고유하도록 각 서비스에 고유 &lt;code&gt;&lt;i&gt;number&lt;/i&gt;&lt;/code&gt; 를 할당해야합니다 . 버전 1 쿠키의 경우 기본값은 0입니다. 버전 2 쿠키의 경우 기본값은 서버 IP 주소의 마지막 4 옥텟으로 구성된 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="84126538ea8cabfbc50450afbb7a886017f0ea59" translate="yes" xml:space="preserve">
          <source>If it is required to process requests without the &amp;ldquo;Host&amp;rdquo; header field in a &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; block which is not the default, an empty name should be specified:</source>
          <target state="translated">기본값이 아닌 &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 블록 에서 &quot;호스트&quot;헤더 필드없이 요청을 처리 해야하는 경우 빈 이름을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0998296d68e276573eaab79243bc6bcfbd9a7590" translate="yes" xml:space="preserve">
          <source>If nginx fails to start and displays the error message:</source>
          <target state="translated">nginx가 시작되지 않고 오류 메시지가 표시되는 경우 :</target>
        </trans-unit>
        <trans-unit id="dc87080f823ebf8f177578b32253dadc70ca6ad8" translate="yes" xml:space="preserve">
          <source>If no &lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; is defined in a &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; block then nginx uses the empty name as the server name.</source>
          <target state="translated">&lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; 이 &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 블록에 정의되어 있지 않으면 nginx는 빈 이름을 서버 이름으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6f8a5c98d5a8cc548cb1e592042ddaa7ed1ca953" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;encoding&lt;/code&gt; is specified, returns a specified Unicode string or byte string as in ECMAScript.</source>
          <target state="translated">&lt;code&gt;encoding&lt;/code&gt; 을 지정 하지 않으면 ECMAScript에서와 같이 지정된 유니 코드 문자열 또는 바이트 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e211877ecfb30fc82ec7b2aaa5d7102f1ba593c" translate="yes" xml:space="preserve">
          <source>If not disabled, processing of these header fields has the following effect:</source>
          <target state="translated">비활성화하지 않으면 이러한 헤더 필드를 처리하면 다음과 같은 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7343b180a1ccb94a728c2a6b2f892e4a9ecbd03a" translate="yes" xml:space="preserve">
          <source>If one of the servers needs to be temporarily removed, it should be marked with the &lt;code&gt;down&lt;/code&gt; parameter in order to preserve the current hashing of client IP addresses.</source>
          <target state="translated">서버 중 하나를 일시적으로 제거해야하는 경우 클라이언트 IP 주소의 현재 해싱을 유지하려면 &lt;code&gt;down&lt;/code&gt; 매개 변수 로 표시해야 합니다.</target>
        </trans-unit>
        <trans-unit id="5e020079fbcac77c2f0c10d2021741f953d475cb" translate="yes" xml:space="preserve">
          <source>If only &lt;code&gt;&lt;i&gt;address&lt;/i&gt;&lt;/code&gt; is given, the port 80 is used.</source>
          <target state="translated">&lt;code&gt;&lt;i&gt;address&lt;/i&gt;&lt;/code&gt; 만 제공하면 포트 80이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d456a94c88b9bbeb3fb7071dce61b411b5ab137" translate="yes" xml:space="preserve">
          <source>If only caching &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; is specified</source>
          <target state="translated">캐싱 &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; 만 지정된 경우</target>
        </trans-unit>
        <trans-unit id="097bc0fe15084cfa49e2a0c35e6927ffc1900fa8" translate="yes" xml:space="preserve">
          <source>If possible, the transmission of client data will be postponed until nginx has at least &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; bytes of data to send. The zero value disables postponing data transmission.</source>
          <target state="translated">가능하면 클라이언트 데이터의 전송은 nginx가 전송할 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 바이트 이상이 될 때까지 연기됩니다 . 값이 0이면 데이터 전송 연기가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7c06ef229ebc200b91738979797ddb976d7fc721" translate="yes" xml:space="preserve">
          <source>If proxying SMTP does not require authentication, the request will look as follows:</source>
          <target state="translated">프록시 SMTP에 인증이 필요하지 않은 경우 요청은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6035fea47ac92b2554fa92ea3287871b98f514c1" translate="yes" xml:space="preserve">
          <source>If recursive search is disabled then instead of the original client address that matches one of the trusted addresses, the last address sent in &amp;ldquo;X-Forwarded-For&amp;rdquo; will be used. If recursive search is enabled then instead of the original client address that matches one of the trusted addresses, the last non-trusted address sent in &amp;ldquo;X-Forwarded-For&amp;rdquo; will be used.</source>
          <target state="translated">재귀 검색이 비활성화 된 경우 신뢰할 수있는 주소 중 하나와 일치하는 원래 클라이언트 주소 대신 &quot;X-Forwarded-For&quot;에 전송 된 마지막 주소가 사용됩니다. 재귀 검색을 사용하는 경우 신뢰할 수있는 주소 중 하나와 일치하는 원래 클라이언트 주소 대신 &quot;X-Forwarded-For&quot;에 전송 된 마지막 신뢰할 수없는 주소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d9dcc834dfc68c5a9a73eb1943968616767875aa" translate="yes" xml:space="preserve">
          <source>If recursive search is disabled, the original client address that matches one of the trusted addresses is replaced by the last address sent in the request header field defined by the &lt;a href=&quot;#real_ip_header&quot;&gt;real_ip_header&lt;/a&gt; directive. If recursive search is enabled, the original client address that matches one of the trusted addresses is replaced by the last non-trusted address sent in the request header field.</source>
          <target state="translated">재귀 검색을 사용하지 않으면 신뢰할 수있는 주소 중 하나와 일치하는 원래 클라이언트 주소가 &lt;a href=&quot;#real_ip_header&quot;&gt;real_ip_header&lt;/a&gt; 지시문으로 정의 된 요청 헤더 필드에 전송 된 마지막 주소로 바뀝니다 . 재귀 검색을 사용하는 경우 신뢰할 수있는 주소 중 하나와 일치하는 원래 클라이언트 주소가 요청 헤더 필드에 전송 된 신뢰할 수없는 마지막 주소로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="4c19111451d6b71829727a883c2e30f18b58fb2b" translate="yes" xml:space="preserve">
          <source>If requests without the &amp;ldquo;Host&amp;rdquo; header field should not be allowed, a server that just drops the requests can be defined:</source>
          <target state="translated">&quot;Host&quot;헤더 필드가없는 요청이 허용되지 않아야하는 경우 요청을 삭제하는 서버를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fb68a52317415949eecf3722547bae58eb47523" translate="yes" xml:space="preserve">
          <source>If several keys are specified, only the first key is used to encrypt TLS session tickets. This allows configuring key rotation, for example:</source>
          <target state="translated">여러 키가 지정되면 첫 번째 키만 TLS 세션 티켓을 암호화하는 데 사용됩니다. 이를 통해 키 회전을 구성 할 수 있습니다 (예 :</target>
        </trans-unit>
        <trans-unit id="a4ddc26eed0b4b2118d459279d3fc6279d05b99a" translate="yes" xml:space="preserve">
          <source>If several tests are specified, the response matches only if it matches all tests.</source>
          <target state="translated">여러 테스트가 지정된 경우 모든 테스트와 일치하는 경우에만 응답이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="65de2649b49032ca3b3d491fc9bc861a1ad0da5b" translate="yes" xml:space="preserve">
          <source>If some part of the &amp;ldquo;&lt;code&gt;for&lt;/code&gt;&amp;rdquo; statement is omitted, this is indicated by the &amp;ldquo;&lt;code&gt;/* void */&lt;/code&gt;&amp;rdquo; comment:</source>
          <target state="translated">&quot; &lt;code&gt;for&lt;/code&gt; &quot;문의 일부를 생략하면 &quot; &lt;code&gt;/* void */&lt;/code&gt; &quot;주석으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e8908fec25ed867990ac104b1a3180ba9325c056" translate="yes" xml:space="preserve">
          <source>If some special functionality is required, not available with packages and ports, nginx can also be compiled from source files. While more flexible, this approach may be complex for a beginner. For more information, see &lt;a href=&quot;configure&quot;&gt;Building nginx from Sources&lt;/a&gt;.</source>
          <target state="translated">패키지 및 포트에서 사용할 수없는 특수 기능이 필요한 경우 소스 파일에서 nginx를 컴파일 할 수도 있습니다. 더 유연하지만이 방법은 초보자에게는 복잡 할 수 있습니다. 자세한 정보 &lt;a href=&quot;configure&quot;&gt;는 소스에서 nginx 빌드를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="392196546126d88213abe63c83e9dbc7216db854" translate="yes" xml:space="preserve">
          <source>If someone makes a request using an IP address instead of a server name, the &amp;ldquo;Host&amp;rdquo; request header field will contain the IP address and the request can be handled using the IP address as the server name:</source>
          <target state="translated">누군가가 서버 이름 대신 IP 주소를 사용하여 요청하면 &quot;호스트&quot;요청 헤더 필드에 IP 주소가 포함되며 IP 주소를 서버 이름으로 사용하여 요청을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6418150e7560bd0291f930f9b9959c6d2a87d277" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only HTTP keyval zone names are output.</source>
          <target state="translated">&quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 HTTP 키 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="9342dfa1ce21aaefa3002a1d91a5f6f6e6848fec" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only HTTP keyval zone names will be output.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;fields&lt;/code&gt; &amp;rdquo;값이 비어 있으면 HTTP keyval 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="1ba0b3ba2cd1a954339c25e2fa7cfe28b028d9a2" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only stream keyval zone names are output.</source>
          <target state="translated">&quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 스트림 키발 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="659fe0e45b668e6f085d263a135e89192771bddb" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only stream keyval zone names will be output.</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;fields&lt;/code&gt; &amp;rdquo;값이 비어 있으면 스트림 키발 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="82b179e6d5ea543f80edb451131dae69ae0eaf39" translate="yes" xml:space="preserve">
          <source>If the &amp;ldquo;Auth-User&amp;rdquo; header exists in the response, it overrides the username used to authenticate with the backend.</source>
          <target state="translated">응답에 &quot;Auth-User&quot;헤더가 있으면 백엔드로 인증하는 데 사용되는 사용자 이름을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="4bbc85f8cc9ac253367af9866e9a2c00fcc19c1c" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#fastcgi_cache_key&quot;&gt;cache key&lt;/a&gt; of a purge request ends with an asterisk (&amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo;), all cache entries matching the wildcard key will be removed from the cache. However, these entries will remain on the disk until they are deleted for either &lt;a href=&quot;#fastcgi_cache_path&quot;&gt;inactivity&lt;/a&gt;, or processed by the &lt;a href=&quot;#purger&quot;&gt;cache purger&lt;/a&gt; (1.7.12), or a client attempts to access them.</source>
          <target state="translated">제거 요청 의 &lt;a href=&quot;#fastcgi_cache_key&quot;&gt;캐시 키&lt;/a&gt; 가 별표 (&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;)로 끝나면 와일드 카드 키와 일치하는 모든 캐시 항목이 캐시에서 제거됩니다. 그러나 이러한 항목은 &lt;a href=&quot;#fastcgi_cache_path&quot;&gt;비활성 상태&lt;/a&gt; 로 삭제 되거나 &lt;a href=&quot;#purger&quot;&gt;캐시 제거기&lt;/a&gt; (1.7.12)에 의해 처리 되거나 클라이언트가 해당 항목에 액세스하려고 시도 할 때까지 디스크에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0627e4747b216d4f1966eb76fe49f9beaa1b254" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#proxy_cache_key&quot;&gt;cache key&lt;/a&gt; of a purge request ends with an asterisk (&amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo;), all cache entries matching the wildcard key will be removed from the cache. However, these entries will remain on the disk until they are deleted for either &lt;a href=&quot;#proxy_cache_path&quot;&gt;inactivity&lt;/a&gt;, or processed by the &lt;a href=&quot;#purger&quot;&gt;cache purger&lt;/a&gt; (1.7.12), or a client attempts to access them.</source>
          <target state="translated">제거 요청 의 &lt;a href=&quot;#proxy_cache_key&quot;&gt;캐시 키&lt;/a&gt; 가 별표 (&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;)로 끝나면 와일드 카드 키와 일치하는 모든 캐시 항목이 캐시에서 제거됩니다. 그러나 이러한 항목은 &lt;a href=&quot;#proxy_cache_path&quot;&gt;비활성 상태&lt;/a&gt; 로 삭제 되거나 &lt;a href=&quot;#purger&quot;&gt;캐시 제거기&lt;/a&gt; (1.7.12)에 의해 처리 되거나 클라이언트가 해당 항목에 액세스하려고 시도 할 때까지 디스크에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="6774c34ad8ba74a023de464c7b54cc5397568d10" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#scgi_cache_key&quot;&gt;cache key&lt;/a&gt; of a purge request ends with an asterisk (&amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo;), all cache entries matching the wildcard key will be removed from the cache. However, these entries will remain on the disk until they are deleted for either &lt;a href=&quot;#scgi_cache_path&quot;&gt;inactivity&lt;/a&gt;, or processed by the &lt;a href=&quot;#purger&quot;&gt;cache purger&lt;/a&gt; (1.7.12), or a client attempts to access them.</source>
          <target state="translated">제거 요청 의 &lt;a href=&quot;#scgi_cache_key&quot;&gt;캐시 키&lt;/a&gt; 가 별표 (&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;)로 끝나면 와일드 카드 키와 일치하는 모든 캐시 항목이 캐시에서 제거됩니다. 그러나 이러한 항목은 &lt;a href=&quot;#scgi_cache_path&quot;&gt;비활성 상태&lt;/a&gt; 로 삭제 되거나 &lt;a href=&quot;#purger&quot;&gt;캐시 제거기&lt;/a&gt; (1.7.12)에 의해 처리 되거나 클라이언트가 해당 항목에 액세스하려고 시도 할 때까지 디스크에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78ae48f1f8af47a153c6800a7efa2c6177c77b1" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;#uwsgi_cache_key&quot;&gt;cache key&lt;/a&gt; of a purge request ends with an asterisk (&amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo;), all cache entries matching the wildcard key will be removed from the cache. However, these entries will remain on the disk until they are deleted for either &lt;a href=&quot;#uwsgi_cache_path&quot;&gt;inactivity&lt;/a&gt;, or processed by the &lt;a href=&quot;#purger&quot;&gt;cache purger&lt;/a&gt; (1.7.12), or a client attempts to access them.</source>
          <target state="translated">제거 요청 의 &lt;a href=&quot;#uwsgi_cache_key&quot;&gt;캐시 키&lt;/a&gt; 가 별표 (&amp;ldquo; &lt;code&gt;*&lt;/code&gt; &amp;rdquo;)로 끝나면 와일드 카드 키와 일치하는 모든 캐시 항목이 캐시에서 제거됩니다. 그러나 이러한 항목은 &lt;a href=&quot;#uwsgi_cache_path&quot;&gt;비활성 상태&lt;/a&gt; 로 삭제 되거나 &lt;a href=&quot;#purger&quot;&gt;캐시 제거기&lt;/a&gt; (1.7.12)에 의해 처리 되거나 클라이언트가 해당 항목에 액세스하려고 시도 할 때까지 디스크에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="de53b821afda939dc06986c294b159b0d7e6c78d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;always&lt;/code&gt; parameter is specified (1.7.5), the header field will be added regardless of the response code.</source>
          <target state="translated">경우 &lt;code&gt;always&lt;/code&gt; 매개 변수 (1.7.5)를 지정, 헤더 필드에 관계없이 응답 코드의 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5855ca6c135a708ee218a8ad90ec21b3b54a9129" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;always&lt;/code&gt; parameter is specified the specified field will be added regardless of the response code.</source>
          <target state="translated">경우 &lt;code&gt;always&lt;/code&gt; 매개 변수가 지정된 특정 필드에 관계없이 응답 코드의 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8a9d60fd0c5a2dc8c68a18b2eb12626102b86ccf" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;connect&lt;/code&gt; parameter is specified, time to &lt;a href=&quot;#var_upstream_connect_time&quot;&gt;connect&lt;/a&gt; to the upstream server is used. If the &lt;code&gt;first_byte&lt;/code&gt; parameter is specified, time to receive the &lt;a href=&quot;#var_upstream_first_byte_time&quot;&gt;first byte&lt;/a&gt; of data is used. If the &lt;code&gt;last_byte&lt;/code&gt; is specified, time to receive the &lt;a href=&quot;#var_upstream_session_time&quot;&gt;last byte&lt;/a&gt; of data is used. If the &lt;code&gt;inflight&lt;/code&gt; parameter is specified (1.11.6), incomplete connections are also taken into account.</source>
          <target state="translated">상기 중간 &lt;code&gt;connect&lt;/code&gt; 매개 변수를 지정, 시간이하는 &lt;a href=&quot;#var_upstream_connect_time&quot;&gt;연결&lt;/a&gt; 에 사용되는 업스트림 서버에. 경우] &lt;code&gt;first_byte&lt;/code&gt; 의 매개 변수를 지정 시간은 수신 &lt;a href=&quot;#var_upstream_first_byte_time&quot;&gt;첫 번째 바이트&lt;/a&gt; 의 데이터가 사용된다. 경우 &lt;code&gt;last_byte&lt;/code&gt; 가 지정되어, 시간이받을 &lt;a href=&quot;#var_upstream_session_time&quot;&gt;마지막 바이트&lt;/a&gt; 의 데이터가 사용됩니다. &lt;code&gt;inflight&lt;/code&gt; 매개 변수가 지정 되면 (1.11.6) 불완전한 연결도 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="9566bfa8ea97d442f7b3edc26e2654cb1c0fc534" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;consistent&lt;/code&gt; parameter is specified, the &lt;a href=&quot;https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients&quot;&gt;ketama&lt;/a&gt; consistent hashing method will be used instead. The method ensures that only a few keys will be remapped to different servers when a server is added to or removed from the group. This helps to achieve a higher cache hit ratio for caching servers. The method is compatible with the &lt;a href=&quot;https://metacpan.org/pod/Cache::Memcached::Fast&quot;&gt;Cache::Memcached::Fast&lt;/a&gt; Perl library with the &lt;code&gt;&lt;i&gt;ketama_points&lt;/i&gt;&lt;/code&gt; parameter set to 160.</source>
          <target state="translated">경우 &lt;code&gt;consistent&lt;/code&gt; 매개 변수가 지정되면, &lt;a href=&quot;https://www.metabrew.com/article/libketama-consistent-hashing-algo-memcached-clients&quot;&gt;ketama&lt;/a&gt; 일관된 해싱 방법이 대신 사용됩니다. 이 방법을 사용하면 서버가 그룹에 추가되거나 그룹에서 제거 될 때 몇 개의 키만 다른 서버로 다시 매핑됩니다. 이는 캐싱 서버에 대해 더 높은 캐시 적중률을 달성하는 데 도움이됩니다. 이 메소드는 &lt;code&gt;&lt;i&gt;ketama_points&lt;/i&gt;&lt;/code&gt; 매개 변수가 160으로 설정된 &lt;a href=&quot;https://metacpan.org/pod/Cache::Memcached::Fast&quot;&gt;Cache :: Memcached :: Fast&lt;/a&gt; Perl 라이브러리와 호환됩니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="7bc32979ae8bad8ce39a0bab16a68be9e1367416" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;gzip&lt;/code&gt; parameter is used, then the buffered data will be compressed before writing to the file. The compression level can be set between 1 (fastest, less compression) and 9 (slowest, best compression). By default, the buffer size is equal to 64K bytes, and the compression level is set to 1. Since the data is compressed in atomic blocks, the log file can be decompressed or read by &amp;ldquo;&lt;code&gt;zcat&lt;/code&gt;&amp;rdquo; at any time.</source>
          <target state="translated">경우] &lt;code&gt;gzip&lt;/code&gt; 매개 변수를 사용하는, 버퍼링 된 데이터가 파일에 기록되기 전에 압축된다. 압축 수준은 1 (가장 빠름, 압축률 낮음)과 9 (가장 느리게, 최고 압축률) 사이에서 설정할 수 있습니다. 기본적으로 버퍼 크기는 64K 바이트이며 압축 수준은 1로 설정됩니다. 데이터가 원자 블록으로 압축되므로 언제든지 &quot; &lt;code&gt;zcat&lt;/code&gt; &quot;를 사용 하여 로그 파일을 압축 해제하거나 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af6230db24a7a17ed61d8dc8d5343eb86b8046c1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;header&lt;/code&gt; parameter is specified, time to receive the &lt;a href=&quot;#var_upstream_header_time&quot;&gt;response header&lt;/a&gt; is used. If the &lt;code&gt;last_byte&lt;/code&gt; parameter is specified, time to receive the &lt;a href=&quot;#var_upstream_response_time&quot;&gt;full response&lt;/a&gt; is used. If the &lt;code&gt;inflight&lt;/code&gt; parameter is specified (1.11.6), incomplete requests are also taken into account.</source>
          <target state="translated">경우 &lt;code&gt;header&lt;/code&gt; 매개 변수를 지정, 수신 시간 &lt;a href=&quot;#var_upstream_header_time&quot;&gt;응답 헤더가&lt;/a&gt; 사용됩니다. 경우 &lt;code&gt;last_byte&lt;/code&gt; 매개 변수를 지정, 수신 시간이 &lt;a href=&quot;#var_upstream_response_time&quot;&gt;전체 응답은&lt;/a&gt; 사용됩니다. &lt;code&gt;inflight&lt;/code&gt; 매개 변수가 지정 되면 (1.11.6) 불완전한 요청도 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="3652406238ede803d82cbd4b84101d87e1a4b68e" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;proxy_pass&lt;/code&gt; directive is specified with a URI, then when a request is passed to the server, the part of a &lt;a href=&quot;ngx_http_core_module#location&quot;&gt;normalized&lt;/a&gt; request URI matching the location is replaced by a URI specified in the directive:</source>
          <target state="translated">경우] &lt;code&gt;proxy_pass&lt;/code&gt; 의 지시가 URI로 지정된 후, 요청을 서버에 전달 될 때, 부분 &lt;a href=&quot;ngx_http_core_module#location&quot;&gt;정규화&lt;/a&gt; URI가 위치 일치 요청 지시자에 지정된 URI에 의해 대체된다 :</target>
        </trans-unit>
        <trans-unit id="0397a9e7ba6c9db8b1f98bcbb0c54daa70124c7b" translate="yes" xml:space="preserve">
          <source>If the client request method is listed in this directive then the response will be cached. &amp;ldquo;&lt;code&gt;GET&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;HEAD&lt;/code&gt;&amp;rdquo; methods are always added to the list, though it is recommended to specify them explicitly. See also the &lt;a href=&quot;#fastcgi_no_cache&quot;&gt;fastcgi_no_cache&lt;/a&gt; directive.</source>
          <target state="translated">클라이언트 요청 메소드가이 지정 문에 나열되면 응답이 캐시됩니다. &quot; &lt;code&gt;GET&lt;/code&gt; &quot;및 &quot; &lt;code&gt;HEAD&lt;/code&gt; &quot;메소드는 항상 목록에 추가되지만 명시 적으로 지정하는 것이 좋습니다. &lt;a href=&quot;#fastcgi_no_cache&quot;&gt;fastcgi_no_cache&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="40a5276109d083a1485ea39c34f899e5d259264d" translate="yes" xml:space="preserve">
          <source>If the client request method is listed in this directive then the response will be cached. &amp;ldquo;&lt;code&gt;GET&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;HEAD&lt;/code&gt;&amp;rdquo; methods are always added to the list, though it is recommended to specify them explicitly. See also the &lt;a href=&quot;#proxy_no_cache&quot;&gt;proxy_no_cache&lt;/a&gt; directive.</source>
          <target state="translated">클라이언트 요청 메소드가이 지정 문에 나열되면 응답이 캐시됩니다. &quot; &lt;code&gt;GET&lt;/code&gt; &quot;및 &quot; &lt;code&gt;HEAD&lt;/code&gt; &quot;메소드는 항상 목록에 추가되지만 명시 적으로 지정하는 것이 좋습니다. &lt;a href=&quot;#proxy_no_cache&quot;&gt;proxy_no_cache&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="59687835b9b292d1e23719ee7902646fb3b8a06c" translate="yes" xml:space="preserve">
          <source>If the client request method is listed in this directive then the response will be cached. &amp;ldquo;&lt;code&gt;GET&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;HEAD&lt;/code&gt;&amp;rdquo; methods are always added to the list, though it is recommended to specify them explicitly. See also the &lt;a href=&quot;#scgi_no_cache&quot;&gt;scgi_no_cache&lt;/a&gt; directive.</source>
          <target state="translated">클라이언트 요청 메소드가이 지정 문에 나열되면 응답이 캐시됩니다. &quot; &lt;code&gt;GET&lt;/code&gt; &quot;및 &quot; &lt;code&gt;HEAD&lt;/code&gt; &quot;메소드는 항상 목록에 추가되지만 명시 적으로 지정하는 것이 좋습니다. &lt;a href=&quot;#scgi_no_cache&quot;&gt;scgi_no_cache&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a014826becefb2647d55ba9416ec3465d6c6114" translate="yes" xml:space="preserve">
          <source>If the client request method is listed in this directive then the response will be cached. &amp;ldquo;&lt;code&gt;GET&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;HEAD&lt;/code&gt;&amp;rdquo; methods are always added to the list, though it is recommended to specify them explicitly. See also the &lt;a href=&quot;#uwsgi_no_cache&quot;&gt;uwsgi_no_cache&lt;/a&gt; directive.</source>
          <target state="translated">클라이언트 요청 메소드가이 지정 문에 나열되면 응답이 캐시됩니다. &quot; &lt;code&gt;GET&lt;/code&gt; &quot;및 &quot; &lt;code&gt;HEAD&lt;/code&gt; &quot;메소드는 항상 목록에 추가되지만 명시 적으로 지정하는 것이 좋습니다. &lt;a href=&quot;#uwsgi_no_cache&quot;&gt;uwsgi_no_cache&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="edb2c299ac010d517b9d801b00e1125fb1679013" translate="yes" xml:space="preserve">
          <source>If the currently allocated amount of memory is not large enough to accommodate the new elements, a new block of memory is allocated and the existing elements are copied to it. The new memory block is normally twice as large as the existing one.</source>
          <target state="translated">현재 할당 된 메모리 양이 새 요소를 수용 할만큼 충분히 크지 않으면 새 메모리 블록이 할당되고 기존 요소가 여기에 복사됩니다. 새 메모리 블록은 일반적으로 기존 메모리 블록의 두 배입니다.</target>
        </trans-unit>
        <trans-unit id="b9031026d5719d075f63eb8c0d874d8209b8a7ff" translate="yes" xml:space="preserve">
          <source>If the directive is not present then either &lt;code&gt;*:80&lt;/code&gt; is used if nginx runs with the superuser privileges, or &lt;code&gt;*:8000&lt;/code&gt; otherwise.</source>
          <target state="translated">지시어가 없으면 nginx가 수퍼 유저 권한으로 실행되면 &lt;code&gt;*:80&lt;/code&gt; 이 사용되고 그렇지 않으면 &lt;code&gt;*:8000&lt;/code&gt; 이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb61d6bbefb86cdd797e4d9882b4b3d540ec55b6" translate="yes" xml:space="preserve">
          <source>If the directive is not set, the protocol can be detected automatically based on the well-known port specified in the &lt;a href=&quot;#listen&quot;&gt;listen&lt;/a&gt; directive:</source>
          <target state="translated">지시문이 설정되지 않은 경우, &lt;a href=&quot;#listen&quot;&gt;청취&lt;/a&gt; 지시문에 지정된 잘 알려진 포트를 기반으로 프로토콜을 자동으로 감지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b0774a7b32816743ecbfd0403e8ef6c02f6b4a1" translate="yes" xml:space="preserve">
          <source>If the directive is not specified, the machine&amp;rsquo;s hostname is used.</source>
          <target state="translated">지정 문을 지정하지 않으면 머신의 호스트 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4dcad1ba4725b71ca3b645a5d4d35a255a38b018" translate="yes" xml:space="preserve">
          <source>If the directive is set to a non-zero value, nginx will try to minimize the number of send operations on client sockets by using either &lt;code&gt;NOTE_LOWAT&lt;/code&gt; flag of the &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; method or the &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; socket option. In both cases the specified &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; is used.</source>
          <target state="translated">지시문이 0이 아닌 값으로 설정되면, nginx는 &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; 메소드 의 &lt;code&gt;NOTE_LOWAT&lt;/code&gt; 플래그 또는 &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; 소켓 옵션 을 사용하여 클라이언트 소켓에서 전송 조작 수를 최소화하려고 시도합니다 . 두 경우 모두 지정된 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 가 사용됩니다.&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="982648fecec0148dea6602265537b19306fe680f" translate="yes" xml:space="preserve">
          <source>If the directive is set to a non-zero value, nginx will try to minimize the number of send operations on outgoing connections to a FastCGI server by using either &lt;code&gt;NOTE_LOWAT&lt;/code&gt; flag of the &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; method, or the &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; socket option, with the specified &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">지시문이 0이 아닌 값으로 설정되면, nginx는 &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; 메소드 의 &lt;code&gt;NOTE_LOWAT&lt;/code&gt; 플래그 또는 지정된 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 의 &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; 소켓 옵션 을 사용하여 FastCGI 서버로의 송신 연결에서 전송 조작 수를 최소화하려고 시도합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="07f3323fad0986a89fb5940d0e1889e598a42bc4" translate="yes" xml:space="preserve">
          <source>If the directive is set to a non-zero value, nginx will try to minimize the number of send operations on outgoing connections to a proxied server by using either &lt;code&gt;NOTE_LOWAT&lt;/code&gt; flag of the &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; method, or the &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; socket option, with the specified &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">지시문이 0이 아닌 값으로 설정되면, nginx는 &lt;a href=&quot;../events#kqueue&quot;&gt;kqueue&lt;/a&gt; 메소드 의 &lt;code&gt;NOTE_LOWAT&lt;/code&gt; 플래그 또는 지정된 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 의 &lt;code&gt;SO_SNDLOWAT&lt;/code&gt; 소켓 옵션 을 사용하여 프록시 서버로 나가는 연결에서 전송 조작 수를 최소화하려고 시도합니다 .&lt;i&gt;&lt;/i&gt;</target>
        </trans-unit>
        <trans-unit id="e4d58ef4f3d45344a46a3d23324e09b29fb0c4f9" translate="yes" xml:space="preserve">
          <source>If the directive is specified on the &lt;a href=&quot;#server&quot;&gt;server&lt;/a&gt; level, its value is only used if a server is a default one. The value specified also applies to all virtual servers listening on the same address and port.</source>
          <target state="translated">지시문이 &lt;a href=&quot;#server&quot;&gt;서버&lt;/a&gt; 수준에서 지정된 경우 해당 값은 서버가 기본 명령 인 경우에만 사용됩니다. 지정된 값은 동일한 주소와 포트에서 수신 대기하는 모든 가상 서버에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="dd557fb12cdfd627ff6e2109cffa99b4bbc18fc7" translate="yes" xml:space="preserve">
          <source>If the directive is specified with &lt;code&gt;if_not_empty&lt;/code&gt; (1.1.11) then such a parameter will be passed to the server only if its value is not empty:</source>
          <target state="translated">지시문이 &lt;code&gt;if_not_empty&lt;/code&gt; (1.1.11)로 지정된 경우 해당 매개 변수는 값이 비어 있지 않은 경우에만 서버로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b5d920dfc53ac7ec5266a1ecd8867c984c9ee15d" translate="yes" xml:space="preserve">
          <source>If the directive&amp;rsquo;s parameter is set to &amp;ldquo;&lt;code&gt;$hostname&lt;/code&gt;&amp;rdquo; (0.9.4), the machine&amp;rsquo;s hostname is inserted.</source>
          <target state="translated">지시문의 매개 변수가 &quot; &lt;code&gt;$hostname&lt;/code&gt; &quot;(0.9.4)으로 설정되면 시스템의 호스트 이름이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="675adf87eb4b135448159349c27202a657088ac4" translate="yes" xml:space="preserve">
          <source>If the file is modified significantly, the list of authors should be updated, the new author is added to the top.</source>
          <target state="translated">파일이 크게 수정되면 작성자 목록이 업데이트되어야하며 새 저자가 맨 위에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="86d93cfd6032c3e52905a27ace75407f39db9516" translate="yes" xml:space="preserve">
          <source>If the header does not include the &amp;ldquo;X-Accel-Expires&amp;rdquo; field, parameters of caching may be set in the header fields &amp;ldquo;Expires&amp;rdquo; or &amp;ldquo;Cache-Control&amp;rdquo;.</source>
          <target state="translated">헤더에 &quot;X-Accel-Expires&quot;필드가 포함되어 있지 않으면 캐싱 매개 변수가 헤더 필드 &quot;Expires&quot;또는 &quot;Cache-Control&quot;에 설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0774e356f6838d1c47e4df5346ef62f47a71716" translate="yes" xml:space="preserve">
          <source>If the header includes the &amp;ldquo;Set-Cookie&amp;rdquo; field, such a response will not be cached.</source>
          <target state="translated">헤더에 &quot;Set-Cookie&quot;필드가 포함되어 있으면 해당 응답이 캐시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87c3741228fc7ea5462bfa1d05cb485a6de6210f" translate="yes" xml:space="preserve">
          <source>If the header includes the &amp;ldquo;Vary&amp;rdquo; field with the special value &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo;, such a response will not be cached (1.7.7). If the header includes the &amp;ldquo;Vary&amp;rdquo; field with another value, such a response will be cached taking into account the corresponding request header fields (1.7.7).</source>
          <target state="translated">헤더에 특수 값 &quot; &lt;code&gt;*&lt;/code&gt; &quot;인 &quot;Vary&quot;필드가 포함되어 있으면 이러한 응답이 캐시되지 않습니다 (1.7.7). 헤더에 다른 값을 가진 &quot;Vary&quot;필드가 포함 된 경우 해당 요청 헤더 필드 (1.7.7)를 고려하여 이러한 응답이 캐시됩니다.</target>
        </trans-unit>
        <trans-unit id="721e8c92cfb74eb0eab73197244f8c7e72584da7" translate="yes" xml:space="preserve">
          <source>If the last request passed to the FastCGI server for populating a new cache element has not completed for the specified &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt;, one more request may be passed to the FastCGI server.</source>
          <target state="translated">새 캐시 요소를 채우기 위해 FastCGI 서버로 전달 된 마지막 요청이 지정된 &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; 완료되지 않은 경우 하나 이상의 요청이 FastCGI 서버로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3cbe21dcab84151a00d1bb3d0b0f131396f47eb" translate="yes" xml:space="preserve">
          <source>If the last request passed to the SCGI server for populating a new cache element has not completed for the specified &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt;, one more request may be passed to the SCGI server.</source>
          <target state="translated">새 캐시 요소를 채우기 위해 SCGI 서버로 전달 된 마지막 요청이 지정된 &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; 완료되지 않은 경우 SCGI 서버로 하나 이상의 요청이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19f901f83bd7982b7bae0f9e81068054e0372a22" translate="yes" xml:space="preserve">
          <source>If the last request passed to the proxied server for populating a new cache element has not completed for the specified &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt;, one more request may be passed to the proxied server.</source>
          <target state="translated">새 캐시 요소를 채우기 위해 프록시 서버로 전달 된 마지막 요청이 지정된 &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; 완료되지 않은 경우 프록시 서버로 하나 이상의 요청이 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b89a7506225a63b6708cc2cbee85de2b58aea6d" translate="yes" xml:space="preserve">
          <source>If the last request passed to the uwsgi server for populating a new cache element has not completed for the specified &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt;, one more request may be passed to the uwsgi server.</source>
          <target state="translated">새 캐시 요소를 채우기 위해 uwsgi 서버로 전달 된 마지막 요청이 지정된 &lt;code&gt;&lt;i&gt;time&lt;/i&gt;&lt;/code&gt; 완료되지 않은 경우 하나 이상의 요청이 uwsgi 서버로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7da1c61fc6ca55a47120f91458109902a0c4eec7" translate="yes" xml:space="preserve">
          <source>If the longest matching prefix location has the &amp;ldquo;&lt;code&gt;^~&lt;/code&gt;&amp;rdquo; modifier then regular expressions are not checked.</source>
          <target state="translated">일치하는 가장 긴 접두사 위치에 &quot; &lt;code&gt;^~&lt;/code&gt; &quot;수정자가 있으면 정규식이 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cd5aeca2681939e50ed513e9fe218e9db7a2af4" translate="yes" xml:space="preserve">
          <source>If the mark is set, it is compared with the first padding symbol in the base64 representation of the client identifier passed in a cookie. If they do not match, the cookie is resent with the specified mark, expiration time, and &amp;ldquo;P3P&amp;rdquo; header.</source>
          <target state="translated">마크가 설정되면 쿠키에 전달 된 클라이언트 식별자의 base64 표현에서 첫 번째 패딩 기호와 비교됩니다. 일치하지 않으면 쿠키는 지정된 표시, 만료 시간 및 &quot;P3P&quot;헤더로 다시 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="55624d9719c14adc63b5c7d7e2ccd4b3b95ae5ad" translate="yes" xml:space="preserve">
          <source>If the name &lt;a href=&quot;ngx_mail_core_module#resolver&quot;&gt;found&lt;/a&gt; by the client IP address points to the same address, it is passed in the &lt;code&gt;NAME&lt;/code&gt; parameter of the &lt;code&gt;XCLIENT&lt;/code&gt; command. If the name could not be found, points to a different address, or &lt;a href=&quot;ngx_mail_core_module#resolver&quot;&gt;resolver&lt;/a&gt; is not specified, the &lt;code&gt;[UNAVAILABLE]&lt;/code&gt; is passed in the &lt;code&gt;NAME&lt;/code&gt; parameter. If an error has occurred in the process of resolving, the &lt;code&gt;[TEMPUNAVAIL]&lt;/code&gt; value is used.</source>
          <target state="translated">클라이언트 IP 주소가 &lt;a href=&quot;ngx_mail_core_module#resolver&quot;&gt;찾은&lt;/a&gt; 이름 이 동일한 주소를 가리키는 경우 &lt;code&gt;XCLIENT&lt;/code&gt; 명령 의 &lt;code&gt;NAME&lt;/code&gt; 매개 변수에 전달됩니다 . 이름을 찾을 수 없거나 다른 주소를 가리 키거나 &lt;a href=&quot;ngx_mail_core_module#resolver&quot;&gt;리졸버&lt;/a&gt; 를 지정하지 않으면 &lt;code&gt;[UNAVAILABLE]&lt;/code&gt; 이 &lt;code&gt;NAME&lt;/code&gt; 매개 변수에 전달됩니다 . 해결 과정에서 오류가 발생하면 &lt;code&gt;[TEMPUNAVAIL]&lt;/code&gt; 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3cd90f996cc167bc039a4e96c4440d76c1e964" translate="yes" xml:space="preserve">
          <source>If the new master process exits then the old master process discards the &lt;code&gt;.oldbin&lt;/code&gt; suffix from the file name with the process ID.</source>
          <target state="translated">새 마스터 프로세스가 종료되면 이전 마스터 프로세스는 프로세스 ID를 가진 파일 이름에서 &lt;code&gt;.oldbin&lt;/code&gt; 접미 부를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="51c3b1e824d2823de4b663078ac653ef5dfb4686" translate="yes" xml:space="preserve">
          <source>If the parameter is not &lt;code&gt;off&lt;/code&gt;, defines one or more additional flags for the cookie: &lt;code&gt;secure&lt;/code&gt;, &lt;code&gt;httponly&lt;/code&gt;, &lt;code&gt;samesite=strict&lt;/code&gt;, &lt;code&gt;samesite=lax&lt;/code&gt;, &lt;code&gt;samesite=none&lt;/code&gt;.</source>
          <target state="translated">매개 변수가 &lt;code&gt;off&lt;/code&gt; 가 아닌 경우 쿠키에 대해 하나 이상의 추가 플래그를 정의합니다 : &lt;code&gt;secure&lt;/code&gt; , &lt;code&gt;httponly&lt;/code&gt; , &lt;code&gt;samesite=strict&lt;/code&gt; , &lt;code&gt;samesite=lax&lt;/code&gt; , &lt;code&gt;samesite=none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f805dfd047a9d7d6d648b301e208b506b800ddd6" translate="yes" xml:space="preserve">
          <source>If the parameter is not &lt;code&gt;off&lt;/code&gt;, enables the cookie marking mechanism and sets the character used as a mark. This mechanism is used to add or change &lt;a href=&quot;#userid_p3p&quot;&gt;userid_p3p&lt;/a&gt; and/or a cookie expiration time while preserving the client identifier. A mark can be any letter of the English alphabet (case-sensitive), digit, or the &amp;ldquo;&lt;code&gt;=&lt;/code&gt;&amp;rdquo; character.</source>
          <target state="translated">매개 변수가 &lt;code&gt;off&lt;/code&gt; 가 아닌 경우 쿠키 표시 메커니즘을 사용하고 표시로 사용되는 문자를 설정하십시오. 이 메커니즘은 클라이언트 식별자를 유지하면서 &lt;a href=&quot;#userid_p3p&quot;&gt;userid_p3p&lt;/a&gt; 및 / 또는 쿠키 만료 시간 을 추가하거나 변경하는 데 사용됩니다 . 표시는 영어 알파벳 (대소 문자 구분), 숫자 또는 &quot; &lt;code&gt;=&lt;/code&gt; &quot;문자의 문자 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a60b70572a54169dd2861fbf2d966144e7ec3e" translate="yes" xml:space="preserve">
          <source>If the requested link passes the authenticity check, the &lt;code&gt;$secure_link&lt;/code&gt; variable is set to the link extracted from the request URI. Otherwise, the &lt;code&gt;$secure_link&lt;/code&gt; variable is set to an empty string.</source>
          <target state="translated">요청 된 링크가 인증 검사를 통과하면 &lt;code&gt;$secure_link&lt;/code&gt; 변수가 요청 URI에서 추출 된 링크로 설정됩니다. 그렇지 않으면 &lt;code&gt;$secure_link&lt;/code&gt; 변수가 빈 문자열로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ebb74a55409692573fb1274eaa09800d24848a33" translate="yes" xml:space="preserve">
          <source>If the server certificate and the bundle have been concatenated in the wrong order, nginx will fail to start and will display the error message:</source>
          <target state="translated">서버 인증서와 번들이 잘못된 순서로 연결된 경우 nginx가 시작되지 않고 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9a597c861b1ae0ebf1c66516842ce94920842af5" translate="yes" xml:space="preserve">
          <source>If the service name contains one or more dots, then the name is constructed by joining the service prefix and the server name. For example, to look up the &lt;code&gt;_http._tcp.backend.example.com&lt;/code&gt; and &lt;code&gt;server1.backend.example.com&lt;/code&gt; SRV records, it is necessary to specify the directives:</source>
          <target state="translated">서비스 이름에 점이 하나 이상 있으면 서비스 접두사와 서버 이름을 결합하여 이름을 구성합니다. 예를 들어 &lt;code&gt;_http._tcp.backend.example.com&lt;/code&gt; 및 &lt;code&gt;server1.backend.example.com&lt;/code&gt; SRV 레코드 를 찾으 려면 지시문을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a1aa22bc6d2fdb42307f5914853af82e172f915" translate="yes" xml:space="preserve">
          <source>If the service name does not contain a dot (&amp;ldquo;&lt;code&gt;.&lt;/code&gt;&amp;rdquo;), then the &lt;a href=&quot;https://tools.ietf.org/html/rfc2782&quot;&gt;RFC&lt;/a&gt;-compliant name is constructed and the TCP protocol is added to the service prefix. For example, to look up the &lt;code&gt;_http._tcp.backend.example.com&lt;/code&gt; SRV record, it is necessary to specify the directive:</source>
          <target state="translated">서비스 이름에 점 (&amp;ldquo; &lt;code&gt;.&lt;/code&gt; &amp;rdquo;)이 포함되어 있지 않으면 &lt;a href=&quot;https://tools.ietf.org/html/rfc2782&quot;&gt;RFC&lt;/a&gt; 호환 이름이 구성되고 TCP 프로토콜이 서비스 접두사에 추가됩니다. 예를 들어, &lt;code&gt;_http._tcp.backend.example.com&lt;/code&gt; SRV 레코드 를 찾으 려면 지시문을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="59ba16135ad93cfe19d2dfaa40ce7a3c05dc4036" translate="yes" xml:space="preserve">
          <source>If the source value matches more than one of the specified variants, e.g. both a mask and a regular expression match, the first matching variant will be chosen, in the following order of priority:</source>
          <target state="translated">소스 값이 지정된 변형 중 하나 이상 (예 : 마스크 및 정규식 일치)과 일치하는 경우 첫 번째 일치 변형이 다음 우선 순위에 따라 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="0077384c616480ad08900cd417444ba85c4159f3" translate="yes" xml:space="preserve">
          <source>If the specified regular expression matches a request URI, URI is changed as specified in the &lt;code&gt;&lt;i&gt;replacement&lt;/i&gt;&lt;/code&gt; string. The &lt;code&gt;rewrite&lt;/code&gt; directives are executed sequentially in order of their appearance in the configuration file. It is possible to terminate further processing of the directives using flags. If a replacement string starts with &amp;ldquo;&lt;code&gt;http://&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;https://&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;$scheme&lt;/code&gt;&amp;rdquo;, the processing stops and the redirect is returned to a client.</source>
          <target state="translated">지정된 정규식이 요청 URI와 일치하면 &lt;code&gt;&lt;i&gt;replacement&lt;/i&gt;&lt;/code&gt; 문자열에 지정된대로 URI가 변경됩니다 . &lt;code&gt;rewrite&lt;/code&gt; 지침은 구성 파일에서 자신의 외모 순서대로 순차적으로 실행됩니다. 플래그를 사용하여 지시문의 추가 처리를 종료 할 수 있습니다. 대체 문자열이 &quot; &lt;code&gt;http://&lt;/code&gt; &quot;, &quot; &lt;code&gt;https://&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;$scheme&lt;/code&gt; &quot;으로 시작하면 처리가 중지되고 리디렉션이 클라이언트로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5bdc064808ed9cc206ced38d586ac50d0b14294f" translate="yes" xml:space="preserve">
          <source>If the synchronization is enabled, removal of key-value pairs (no matter &lt;a href=&quot;../http/ngx_http_api_module#patchStreamKeyvalZoneKeyValue&quot;&gt;one&lt;/a&gt; or &lt;a href=&quot;../http/ngx_http_api_module#deleteStreamKeyvalZoneData&quot;&gt;all&lt;/a&gt;) will be performed only on a target cluster node. The same key-value pairs on other cluster nodes will be removed upon &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">동기화가 사용 가능한 경우 키 값 쌍 ( &lt;a href=&quot;../http/ngx_http_api_module#patchStreamKeyvalZoneKeyValue&quot;&gt;하나&lt;/a&gt; 또는 &lt;a href=&quot;../http/ngx_http_api_module#deleteStreamKeyvalZoneData&quot;&gt;모두에&lt;/a&gt; 상관없이) 제거 는 대상 클러스터 노드에서만 수행됩니다. 다른 클러스터 노드에서 동일한 키-값 쌍은 &lt;code&gt;timeout&lt;/code&gt; 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="84ff6d646ace9ae4206c9fee9c481c3bbad50807" translate="yes" xml:space="preserve">
          <source>If the synchronization is enabled, removal of key-value pairs (no matter &lt;a href=&quot;ngx_http_api_module#patchHttpKeyvalZoneKeyValue&quot;&gt;one&lt;/a&gt; or &lt;a href=&quot;ngx_http_api_module#deleteHttpKeyvalZoneData&quot;&gt;all&lt;/a&gt;) will be performed only on a target cluster node. The same key-value pairs on other cluster nodes will be removed upon &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">동기화가 사용 가능한 경우 키 값 쌍 ( &lt;a href=&quot;ngx_http_api_module#patchHttpKeyvalZoneKeyValue&quot;&gt;하나&lt;/a&gt; 또는 &lt;a href=&quot;ngx_http_api_module#deleteHttpKeyvalZoneData&quot;&gt;모두에&lt;/a&gt; 상관없이) 제거 는 대상 클러스터 노드에서만 수행됩니다. 다른 클러스터 노드에서 동일한 키-값 쌍은 &lt;code&gt;timeout&lt;/code&gt; 제거됩니다 .</target>
        </trans-unit>
        <trans-unit id="df725002b7849115cc060dbff14332b34282b365" translate="yes" xml:space="preserve">
          <source>If the value of a header field is an empty string then this field will not be passed to a gRPC server:</source>
          <target state="translated">헤더 필드의 값이 빈 문자열이면이 필드는 gRPC 서버로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="586d2e3e2741c0b7bff7688281ebffdf2357dbd8" translate="yes" xml:space="preserve">
          <source>If the value of a header field is an empty string then this field will not be passed to a proxied server:</source>
          <target state="translated">헤더 필드의 값이 빈 문자열이면이 필드는 프록시 서버로 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f6254c6181b10f8e68ff824b64b629e2f458c76" translate="yes" xml:space="preserve">
          <source>If the value of a variable does not represent a valid IP address then the &amp;ldquo;&lt;code&gt;255.255.255.255&lt;/code&gt;&amp;rdquo; address is used.</source>
          <target state="translated">변수 값이 유효한 IP 주소를 나타내지 않으면 &quot; &lt;code&gt;255.255.255.255&lt;/code&gt; &quot;주소가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="430ee52ce40b387a99e6fce6a9b61901ded575d3" translate="yes" xml:space="preserve">
          <source>If the variable is set to a non-empty string that is not &amp;ldquo;&lt;code&gt;0&lt;/code&gt;&amp;rdquo;, the client identifiers are reset. The special value &amp;ldquo;&lt;code&gt;log&lt;/code&gt;&amp;rdquo; additionally leads to the output of messages about the reset identifiers to the &lt;a href=&quot;../ngx_core_module#error_log&quot;&gt;error_log&lt;/a&gt;.</source>
          <target state="translated">변수가 &quot; &lt;code&gt;0&lt;/code&gt; &quot; 이 아닌 비어 있지 않은 문자열 로 설정되면 클라이언트 식별자가 재설정됩니다. 특수 값 &quot; &lt;code&gt;log&lt;/code&gt; &quot;는 또한 재설정 식별자에 대한 메시지를 &lt;a href=&quot;../ngx_core_module#error_log&quot;&gt;error_log로 출력&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6e4586c7c5c46a7928148ed4727eb576f67e1558" translate="yes" xml:space="preserve">
          <source>If the zone storage is exhausted, the least recently used state is removed. Even if after that a new state cannot be created, the request is terminated with an &lt;a href=&quot;#limit_req_status&quot;&gt;error&lt;/a&gt;.</source>
          <target state="translated">영역 저장소가 소진되면 가장 최근에 사용한 상태가 제거됩니다. 그 후에 새 상태를 만들 수 없더라도 요청은 &lt;a href=&quot;#limit_req_status&quot;&gt;오류&lt;/a&gt; 와 함께 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dfa7a4014b7bdf02fc82c8201689b774477e945" translate="yes" xml:space="preserve">
          <source>If the zone storage is exhausted, the least recently used state is removed. If even after that a new state cannot be created, the request is terminated with an &lt;a href=&quot;#limit_req_status&quot;&gt;error&lt;/a&gt;.</source>
          <target state="translated">영역 저장소가 소진되면 가장 최근에 사용 된 상태가 제거됩니다. 그 후에도 새 상태를 만들 수없는 경우 요청은 &lt;a href=&quot;#limit_req_status&quot;&gt;오류&lt;/a&gt; 와 함께 종료됩니다 .</target>
        </trans-unit>
        <trans-unit id="4e80be18cad39c3e00074a3d3ec2e8a7a37e1858" translate="yes" xml:space="preserve">
          <source>If there are matches, captures can be accessed as follows:</source>
          <target state="translated">일치하는 항목이 있으면 다음과 같이 캡처에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40afdf9cbce49af4b9c667aedd69d3ac9dffa544" translate="yes" xml:space="preserve">
          <source>If there is no &amp;ldquo;Auth-Wait&amp;rdquo; header, an error will be returned and the connection will be closed. The current implementation allocates memory for each authentication attempt. The memory is freed only at the end of a session. Therefore, the number of invalid authentication attempts in a single session must be limited &amp;mdash; the server must respond without the &amp;ldquo;Auth-Wait&amp;rdquo; header after 10-20 attempts (the attempt number is passed in the &amp;ldquo;Auth-Login-Attempt&amp;rdquo; header).</source>
          <target state="translated">&quot;Auth-Wait&quot;헤더가 없으면 오류가 반환되고 연결이 닫힙니다. 현재 구현은 각 인증 시도에 대해 메모리를 할당합니다. 메모리는 세션이 끝날 때만 해제됩니다. 따라서 단일 세션에서 유효하지 않은 인증 시도 횟수를 제한해야합니다. 10-20 회 시도 후 서버가 &quot;Auth-Wait&quot;헤더없이 응답해야합니다 (시도 번호는 &quot;Auth-Login-Attempt&quot;헤더에 전달됨) .</target>
        </trans-unit>
        <trans-unit id="6862706e49f77400696abcd85849c567006dca42" translate="yes" xml:space="preserve">
          <source>If there is no need to change URI and method during internal redirection it is possible to pass error processing into a named location:</source>
          <target state="translated">내부 경로 재 지정 중에 URI 및 메소드를 변경할 필요가없는 경우 오류 처리를 이름 지정된 위치로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2419b6667cb58c2e10229510cd607df9f9341db5" translate="yes" xml:space="preserve">
          <source>If there is only a single server in a group, &lt;code&gt;max_fails&lt;/code&gt;, &lt;code&gt;fail_timeout&lt;/code&gt; and &lt;code&gt;slow_start&lt;/code&gt; parameters are ignored, and such a server will never be considered unavailable.</source>
          <target state="translated">그룹에 단일 서버 만있는 경우 &lt;code&gt;max_fails&lt;/code&gt; , &lt;code&gt;fail_timeout&lt;/code&gt; 및 &lt;code&gt;slow_start&lt;/code&gt; 매개 변수는 무시되며 이러한 서버를 사용할 수없는 것으로 간주하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9cf0bdfbdaa3fd01d857963bc26a5b695f53cc5e" translate="yes" xml:space="preserve">
          <source>If there is the need to tie a client to a particular application server &amp;mdash; in other words, make the client&amp;rsquo;s session &amp;ldquo;sticky&amp;rdquo; or &amp;ldquo;persistent&amp;rdquo; in terms of always trying to select a particular server &amp;mdash; the ip-hash load balancing mechanism can be used.</source>
          <target state="translated">클라이언트를 특정 응용 프로그램 서버에 연결해야하는 경우 (즉, 항상 특정 서버를 선택하려는 관점에서 클라이언트의 세션을 &quot;고정&quot;또는 &quot;지속적&quot;으로 설정) ip-hash로드 밸런싱 메커니즘은 다음과 같습니다. 익숙한.</target>
        </trans-unit>
        <trans-unit id="718fb8046b928005a371145395b4e14e560adf17" translate="yes" xml:space="preserve">
          <source>If upgrade was successful, then the QUIT signal should be sent to the old master process, and only new processes will stay:</source>
          <target state="translated">업그레이드가 완료되면 QUIT 신호가 이전 마스터 프로세스로 전송되어야하며 새 프로세스 만 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="803f3de67e47b52e3a4f2c08b7b8bfb2359b690f" translate="yes" xml:space="preserve">
          <source>If zero value is specified, no response is expected. However, if a response is received and the session is still not finished, the response will be handled.</source>
          <target state="translated">0 값을 지정하면 응답이 예상되지 않습니다. 그러나 응답이 수신되고 세션이 여전히 완료되지 않으면 응답이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="eadd505da49e326e0042a49887bbb70c7ef49eb1" translate="yes" xml:space="preserve">
          <source>Imports a module that implements location and variable handlers in njs. The &lt;code&gt;export_name&lt;/code&gt; is used as a namespace to access module functions. If the &lt;code&gt;export_name&lt;/code&gt; is not specified, the module name will be used as a namespace.</source>
          <target state="translated">njs에서 위치 및 변수 핸들러를 구현하는 모듈을 가져옵니다. &lt;code&gt;export_name&lt;/code&gt; 는 접속 모듈의 기능에 공간으로서 사용된다. 경우 &lt;code&gt;export_name&lt;/code&gt; 가 지정되지 않은 모듈 이름은 네임 스페이스로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="266f54e06b503e0a3645d0c6331654a7ad98bfab" translate="yes" xml:space="preserve">
          <source>Improvement: Unicode case tables updated to version 12.1.</source>
          <target state="translated">개선 : 유니 코드 케이스 테이블이 버전 12.1로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="ecc28ef2ed9a82048971f93d11ad5945470beae1" translate="yes" xml:space="preserve">
          <source>Improvement: added UTF8 validation for string literals.</source>
          <target state="translated">개선 : 문자열 리터럴에 대한 UTF8 유효성 검사가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="74b1af5bb232eddaf92937c5e650b4e8c00be839" translate="yes" xml:space="preserve">
          <source>Improvement: added exception strings where appropriate.</source>
          <target state="translated">개선 : 적절한 경우 예외 문자열을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="ee03d7947832f2c3c0ca3773c24ade923d514491" translate="yes" xml:space="preserve">
          <source>Improvement: added information about illegal token in number parsing.</source>
          <target state="translated">개선 : 숫자 구문 분석에서 불법 토큰에 대한 정보가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a663d86051767f7c102e4d2d9c24cbcb2ffbf8e" translate="yes" xml:space="preserve">
          <source>Improvement: added memory-sanitizer support.</source>
          <target state="translated">개선 : 메모리 살균제 지원 추가.</target>
        </trans-unit>
        <trans-unit id="12760b4fd51e758601ddc11d6dc2e688bde38b7e" translate="yes" xml:space="preserve">
          <source>Improvement: added support for multiple arguments in &lt;code&gt;console.log()&lt;/code&gt;.</source>
          <target state="translated">개선 : &lt;code&gt;console.log()&lt;/code&gt; 에서 여러 인수에 대한 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="be15984e7dae36ef6b8c1325d95574aabe3b580a" translate="yes" xml:space="preserve">
          <source>Improvement: added support for null as a second argument of &lt;a href=&quot;reference#r_subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : &lt;a href=&quot;reference#r_subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 null 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="9d08c449a725f8993803511615c057ea2c0024f4" translate="yes" xml:space="preserve">
          <source>Improvement: added support for null as a second argument of &lt;a href=&quot;reference#subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : &lt;a href=&quot;reference#subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 null 지원이 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="09b2c4aefb7cd1b3b441c2dcd7b3884c039bc30d" translate="yes" xml:space="preserve">
          <source>Improvement: added the debug for the returned status code in &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; handler</source>
          <target state="translated">개선 : &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; 핸들러 에 반환 된 상태 코드에 대한 디버그가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="b82b4188021637916ddde8463d571e3c82989908" translate="yes" xml:space="preserve">
          <source>Improvement: allowed uppercased &lt;code&gt;O&lt;/code&gt; in octal literal values.</source>
          <target state="translated">개선 : 8 진 리터럴 값에서 대문자 &lt;code&gt;O&lt;/code&gt; 를 허용했습니다 .</target>
        </trans-unit>
        <trans-unit id="288240faee07724f6df0cb6ada2f4bc3cb590619" translate="yes" xml:space="preserve">
          <source>Improvement: arguments validation for configure script.</source>
          <target state="translated">개선 : 구성 스크립트에 대한 인수 유효성 검사.</target>
        </trans-unit>
        <trans-unit id="9e9b5b7717389ef0f80b559a2f03e23eeb2bfd85" translate="yes" xml:space="preserve">
          <source>Improvement: code generator refactored and simplified.</source>
          <target state="translated">개선 : 코드 생성기가 리팩토링되고 단순화되었습니다.</target>
        </trans-unit>
        <trans-unit id="ecf3167a6549202747de0b2fb5c009c3ad7cd1ca" translate="yes" xml:space="preserve">
          <source>Improvement: code related to function invocation is refactored. Thanks to 洪志道 (Hong Zhi Dao).</source>
          <target state="translated">개선 : 함수 호출과 관련된 코드가 리팩토링되었습니다. 洪志 道 (홍지 다오)에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="4b60473ab58f9e1892fc8c7bca20ac667ff38eff" translate="yes" xml:space="preserve">
          <source>Improvement: code related to parsing of objects, variables and functions is refactored. Thanks to 洪志道 (Hong Zhi Dao).</source>
          <target state="translated">개선 : 객체, 변수 및 함수의 구문 분석과 관련된 코드가 리팩토링되었습니다. 洪志 道 (홍지 다오)에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="c75327b67795dcc63cca0cbb0582ad418422c1b0" translate="yes" xml:space="preserve">
          <source>Improvement: code related to variables is refactored. Thanks to 洪志道 (Hong Zhi Dao).</source>
          <target state="translated">개선 : 변수와 ​​관련된 코드가 리팩토링되었습니다. 洪志 道 (홍지 다오)에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="ffbf475bd73df9c260b40b85517b37790e342911" translate="yes" xml:space="preserve">
          <source>Improvement: getting of special response headers in &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : 특수 응답 헤더의 점점 &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8e5a492dc182cfe91f35646cca92f8851037e064" translate="yes" xml:space="preserve">
          <source>Improvement: getting special headers from &lt;a href=&quot;reference#r_headers_in&quot;&gt;&lt;code&gt;r.headersIn{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : &lt;a href=&quot;reference#r_headers_in&quot;&gt; &lt;code&gt;r.headersIn{}&lt;/code&gt; &lt;/a&gt; 에서 특수 헤더 가져 오기 .</target>
        </trans-unit>
        <trans-unit id="63f2342ab3c7e6ab6058cfe208b42b0154874b9b" translate="yes" xml:space="preserve">
          <source>Improvement: handling non-array values in &lt;code&gt;Array.prototype.slice()&lt;/code&gt;.</source>
          <target state="translated">개선 : 비 배열 값을 처리 &lt;code&gt;Array.prototype.slice()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365bec288bf711f4349e8819e2cd91a6c977a9e8" translate="yes" xml:space="preserve">
          <source>Improvement: improved iteration over &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt; with duplicates.</source>
          <target state="translated">개선 : 중복 된 &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; 대한 반복 개선 .</target>
        </trans-unit>
        <trans-unit id="9139f34812ed5c171dd1dee91d4dae2413400fcb" translate="yes" xml:space="preserve">
          <source>Improvement: improved iteration over &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt; with special headers.</source>
          <target state="translated">개선 : 특수 헤더를 사용하여 &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; 대한 반복을 개선했습니다 .</target>
        </trans-unit>
        <trans-unit id="a0f609af0e7d56a3e51630e0d13fc0dea2a7da34" translate="yes" xml:space="preserve">
          <source>Improvement: improved logging for &lt;a href=&quot;../http/ngx_http_js_module#js_set&quot;&gt;js_set&lt;/a&gt; and &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; directives.</source>
          <target state="translated">개선 : &lt;a href=&quot;../http/ngx_http_js_module#js_set&quot;&gt;js_set&lt;/a&gt; 및 &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; 지시문에 대한 로깅이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5b586cff5bf715aa5f2c7d405c55c1c79d1dc80e" translate="yes" xml:space="preserve">
          <source>Improvement: improved wording for primitive type conversion exception.</source>
          <target state="translated">개선 : 기본 유형 변환 예외에 대한 표현이 향상되었습니다.</target>
        </trans-unit>
        <trans-unit id="df68cfbedd91a6556e34b0daec3279fe2e1c94d4" translate="yes" xml:space="preserve">
          <source>Improvement: improved wording for various exceptions.</source>
          <target state="translated">개선 : 다양한 예외에 대한 표현이 개선되었습니다.</target>
        </trans-unit>
        <trans-unit id="463971550630e9feec81a67e41cb489696194f37" translate="yes" xml:space="preserve">
          <source>Improvement: introduced memory-efficient ordinary arrays.</source>
          <target state="translated">개선 : 메모리 효율적인 일반 어레이를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="840deab4e2349f5251a2bcd1d3df816bb112140c" translate="yes" xml:space="preserve">
          <source>Improvement: large-value output improved in &lt;code&gt;console.log()&lt;/code&gt;.</source>
          <target state="translated">개선 : &lt;code&gt;console.log()&lt;/code&gt; 에서 큰 값의 출력이 향상되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e8656de1c10ff5a05aa7f5b2475753e56f84dd92" translate="yes" xml:space="preserve">
          <source>Improvement: lexer refactoring.</source>
          <target state="translated">개선 : 렉서 리팩토링.</target>
        </trans-unit>
        <trans-unit id="3219aaa9a17c405b8c63a3ef90f3da0f7544485d" translate="yes" xml:space="preserve">
          <source>Improvement: limiting recursion depth while compiling.</source>
          <target state="translated">개선 : 컴파일하는 동안 재귀 깊이를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="19b5a807e99af6ca00ca35d6d61c214bf2b61911" translate="yes" xml:space="preserve">
          <source>Improvement: making &lt;code&gt;prototype&lt;/code&gt; property of function instances writable.</source>
          <target state="translated">개선 : 함수 인스턴스의 &lt;code&gt;prototype&lt;/code&gt; 속성을 쓰기 가능하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e1006902833565a889426bc26716413201c1a1b6" translate="yes" xml:space="preserve">
          <source>Improvement: moved constructors and top-level objects to global object.</source>
          <target state="translated">개선 : 생성자와 최상위 개체를 전역 개체로 이동했습니다.</target>
        </trans-unit>
        <trans-unit id="5b7e81b701dce4ecaf9dfcc878fdf639cbc25cf7" translate="yes" xml:space="preserve">
          <source>Improvement: moved njs vm to the &lt;code&gt;main&lt;/code&gt; configuration.</source>
          <target state="translated">개선 : njs vm을 &lt;code&gt;main&lt;/code&gt; 구성 으로 이동했습니다 .</target>
        </trans-unit>
        <trans-unit id="04f4cda76b496306c729710ff60cd334d50f0ac3" translate="yes" xml:space="preserve">
          <source>Improvement: moving global functions to the global object.</source>
          <target state="translated">개선 : 전역 함수를 전역 개체로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="75890099d48cc8a2dd306ffa2f529d17dc063d21" translate="yes" xml:space="preserve">
          <source>Improvement: parser is refactored. Thanks to 洪志道 (Hong Zhi Dao).</source>
          <target state="translated">개선 : 파서는 리팩토링됩니다. 洪志 道 (홍지 다오)에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="625a738a9eaab6b79ee573449f82194c156d562e" translate="yes" xml:space="preserve">
          <source>Improvement: parser refactoring.</source>
          <target state="translated">개선 : 파서 ​​리팩토링.</target>
        </trans-unit>
        <trans-unit id="a879931e12ce5ae4bdb92ee3e51914fa5b3eb72c" translate="yes" xml:space="preserve">
          <source>Improvement: public header &lt;code&gt;cleanup. njscript.h&lt;/code&gt; is renamed to &lt;code&gt;njs.h&lt;/code&gt;.</source>
          <target state="translated">개선 : 공개 헤더 &lt;code&gt;cleanup. njscript.h&lt;/code&gt; 로 이름이 변경됩니다 &lt;code&gt;njs.h&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70257654bfd8c52d405c54e13f4f8aadab2c5612" translate="yes" xml:space="preserve">
          <source>Improvement: refactored JSON methods.</source>
          <target state="translated">개선 : 리팩토링 된 JSON 메서드.</target>
        </trans-unit>
        <trans-unit id="1d915073478bf9ed6bc14329ed16095cb4a24485" translate="yes" xml:space="preserve">
          <source>Improvement: refactored iteration over external objects.</source>
          <target state="translated">개선 : 외부 개체에 대한 리팩토링 된 반복.</target>
        </trans-unit>
        <trans-unit id="0f252cce21b1cf14e3caf75254bad2205166b80a" translate="yes" xml:space="preserve">
          <source>Improvement: reporting filenames in exceptions.</source>
          <target state="translated">개선 : 예외적으로 파일 이름보고.</target>
        </trans-unit>
        <trans-unit id="5f5d7340bd5e87678ba1b177bec40b6afcdc2fe3" translate="yes" xml:space="preserve">
          <source>Improvement: setting special response headers in &lt;a href=&quot;reference#r_headers_out&quot;&gt;&lt;code&gt;r.headersOut{}&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : 특수 응답 헤더를 설정 &lt;a href=&quot;reference#r_headers_out&quot;&gt; &lt;code&gt;r.headersOut{}&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="518964d65e2f1daea2c74fbf90f79f186ee87bff" translate="yes" xml:space="preserve">
          <source>Improvement: setting status code to 500 by default in the &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; handler</source>
          <target state="translated">개선 : &lt;a href=&quot;../http/ngx_http_js_module#js_content&quot;&gt;js_content&lt;/a&gt; 핸들러 에서 기본적으로 상태 코드를 500으로 설정</target>
        </trans-unit>
        <trans-unit id="5244c99e9eaa55fcbc868e808227f16bd8c5b6be" translate="yes" xml:space="preserve">
          <source>Improvement: string output improved in &lt;code&gt;console.log()&lt;/code&gt; in a compliant way (without escaping and quotes).</source>
          <target state="translated">개선 : 호환되는 방식으로 &lt;code&gt;console.log()&lt;/code&gt; 에서 문자열 출력이 개선되었습니다 (이스케이프 및 따옴표 제외).</target>
        </trans-unit>
        <trans-unit id="9a6e89c94a9ebe5cf7de8d4eec0aeafbaf203213" translate="yes" xml:space="preserve">
          <source>Improvement: using ES6 version of &lt;code&gt;ToInt32()&lt;/code&gt;, &lt;code&gt;ToUint32()&lt;/code&gt;, &lt;code&gt;ToLength()&lt;/code&gt;.</source>
          <target state="translated">개선 : ES6 버전의 &lt;code&gt;ToInt32()&lt;/code&gt; , &lt;code&gt;ToUint32()&lt;/code&gt; , &lt;code&gt;ToLength()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03a29bb71918fd2448277a1bccc35525c7de2f6d" translate="yes" xml:space="preserve">
          <source>Improvement: working with unknown methods in &lt;a href=&quot;reference#r_subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : &lt;a href=&quot;reference#r_subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 에서 알 수없는 메서드 작업 .</target>
        </trans-unit>
        <trans-unit id="9d1072bac89bc74384d87024c7833cc69143a9bc" translate="yes" xml:space="preserve">
          <source>Improvement: working with unknown methods in &lt;a href=&quot;reference#subrequest&quot;&gt;&lt;code&gt;r.subrequest()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">개선 : &lt;a href=&quot;reference#subrequest&quot;&gt; &lt;code&gt;r.subrequest()&lt;/code&gt; &lt;/a&gt; 에서 알 수없는 메소드로 작업 .</target>
        </trans-unit>
        <trans-unit id="f1aee9e99a1e8ff82f054f69a561e9377085225b" translate="yes" xml:space="preserve">
          <source>In HTTP/2 and SPDY, each concurrent request is considered a separate connection.</source>
          <target state="translated">HTTP / 2 및 SPDY에서 각 동시 요청은 별도의 연결로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0ccc62ab8fd3760a75073544bed118930b1c4205" translate="yes" xml:space="preserve">
          <source>In addition to that, HTTP code should include</source>
          <target state="translated">그 외에도 HTTP 코드에는 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="2cd91b0955775bcd29afe30f4fb35a8117ac4d57" translate="yes" xml:space="preserve">
          <source>In addition, a &lt;code&gt;&lt;i&gt;URL&lt;/i&gt;&lt;/code&gt; for temporary redirect with the code 302 can be specified as the sole parameter. Such a parameter should start with the &amp;ldquo;&lt;code&gt;http://&lt;/code&gt;&amp;rdquo;, &amp;ldquo;&lt;code&gt;https://&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;$scheme&lt;/code&gt;&amp;rdquo; string. A &lt;code&gt;&lt;i&gt;URL&lt;/i&gt;&lt;/code&gt; can contain variables.</source>
          <target state="translated">또한, 코드 (302)를 갖는 임시 리다이렉트를위한 &lt;code&gt;&lt;i&gt;URL&lt;/i&gt;&lt;/code&gt; 이 유일한 파라미터로서 지정 될 수있다. 이러한 매개 변수는 &quot; &lt;code&gt;http://&lt;/code&gt; &quot;, &quot; &lt;code&gt;https://&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;$scheme&lt;/code&gt; &quot;문자열로 시작해야합니다. &lt;code&gt;&lt;i&gt;URL&lt;/i&gt;&lt;/code&gt; 은 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd8fd9462824838a32405aaafa45dd44e5a72e31" translate="yes" xml:space="preserve">
          <source>In addition, a charset can be set in the &amp;ldquo;X-Accel-Charset&amp;rdquo; response header field. This capability can be disabled using the &lt;a href=&quot;ngx_http_proxy_module#proxy_ignore_headers&quot;&gt;proxy_ignore_headers&lt;/a&gt;, &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_ignore_headers&quot;&gt;fastcgi_ignore_headers&lt;/a&gt;, &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_ignore_headers&quot;&gt;uwsgi_ignore_headers&lt;/a&gt;, &lt;a href=&quot;ngx_http_scgi_module#scgi_ignore_headers&quot;&gt;scgi_ignore_headers&lt;/a&gt;, and &lt;a href=&quot;ngx_http_grpc_module#grpc_ignore_headers&quot;&gt;grpc_ignore_headers&lt;/a&gt; directives.</source>
          <target state="translated">또한&amp;ldquo;X-Accel-Charset&amp;rdquo;응답 헤더 필드에서 문자 세트를 설정할 수 있습니다. 이 기능은 &lt;a href=&quot;ngx_http_proxy_module#proxy_ignore_headers&quot;&gt;proxy_ignore_headers&lt;/a&gt; , &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_ignore_headers&quot;&gt;fastcgi_ignore_headers&lt;/a&gt; , &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_ignore_headers&quot;&gt;uwsgi_ignore_headers&lt;/a&gt; , &lt;a href=&quot;ngx_http_scgi_module#scgi_ignore_headers&quot;&gt;scgi_ignore_headers&lt;/a&gt; 및 &lt;a href=&quot;ngx_http_grpc_module#grpc_ignore_headers&quot;&gt;grpc_ignore_headers&lt;/a&gt; 지시문을 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1cb671fc4157590e2d462ad91286482915549db3" translate="yes" xml:space="preserve">
          <source>In addition, all active keys and information about data are stored in a shared memory zone, whose &lt;code&gt;&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; are configured by the &lt;code&gt;keys_zone&lt;/code&gt; parameter. One megabyte zone can store about 8 thousand keys.</source>
          <target state="translated">또한 모든 활성 키와 데이터에 대한 정보는 공유 메모리 영역에 저장되며 &lt;code&gt;&lt;i&gt;name&lt;/i&gt;&lt;/code&gt; 과 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 는 &lt;code&gt;keys_zone&lt;/code&gt; 매개 변수 로 구성됩니다 . 1MB 영역에는 약 8 천 개의 키를 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f832b0d1d9c47932c1976724daa31d007372021b" translate="yes" xml:space="preserve">
          <source>In addition, it is possible to specify a time of day using the &amp;ldquo;&lt;code&gt;@&lt;/code&gt;&amp;rdquo; prefix (0.7.9, 0.6.34):</source>
          <target state="translated">또한 &quot; &lt;code&gt;@&lt;/code&gt; &quot;접두사 (0.7.9, 0.6.34) 를 사용하여 시간을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41ac2cb2061d8da4e237f23d229c4b8d1e5b683c" translate="yes" xml:space="preserve">
          <source>In addition, the &lt;code&gt;any&lt;/code&gt; parameter can be specified to cache any responses:</source>
          <target state="translated">또한 &lt;code&gt;any&lt;/code&gt; 매개 변수를 지정하여 응답을 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddfdb87d9583c1767561b5879ef25cafafd743e3" translate="yes" xml:space="preserve">
          <source>In addition, the server name can be passed together with the port of the proxied server:</source>
          <target state="translated">또한 서버 이름은 프록시 서버의 포트와 함께 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="440471bb6a92e4385a0e2a01435da31cc7cd7e84" translate="yes" xml:space="preserve">
          <source>In addition, there are more directives and parameters that control server load balancing in nginx, e.g. &lt;a href=&quot;ngx_http_proxy_module#proxy_next_upstream&quot;&gt;proxy_next_upstream&lt;/a&gt;, &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;backup&lt;/a&gt;, &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;down&lt;/a&gt;, and &lt;a href=&quot;ngx_http_upstream_module#keepalive&quot;&gt;keepalive&lt;/a&gt;. For more information please check our &lt;a href=&quot;../index&quot;&gt;reference documentation&lt;/a&gt;.</source>
          <target state="translated">또한 nginx의 서버로드 밸런싱을 제어하는 ​​지시문 및 매개 변수가 더 있습니다 (예 : &lt;a href=&quot;ngx_http_proxy_module#proxy_next_upstream&quot;&gt;proxy_next_upstream&lt;/a&gt; , &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;backup&lt;/a&gt; , &lt;a href=&quot;ngx_http_upstream_module#server&quot;&gt;down&lt;/a&gt; 및 &lt;a href=&quot;ngx_http_upstream_module#keepalive&quot;&gt;keepalive)&lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;../index&quot;&gt;참조 문서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9523a4f3b030da3e671ef82dddf3dbecac95a836" translate="yes" xml:space="preserve">
          <source>In case of an error, the output is as follows:</source>
          <target state="translated">오류가 발생한 경우 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa37c96b62d786640dfcee408cdd5ebd99b7d52d" translate="yes" xml:space="preserve">
          <source>In case something does not work as expected, you may try to find out the reason in &lt;code&gt;access.log&lt;/code&gt; and &lt;code&gt;error.log&lt;/code&gt; files in the directory &lt;code&gt;/usr/local/nginx/logs&lt;/code&gt; or &lt;code&gt;/var/log/nginx&lt;/code&gt;.</source>
          <target state="translated">예상대로 작동하지 않는 경우 &lt;code&gt;/usr/local/nginx/logs&lt;/code&gt; 또는 &lt;code&gt;/var/log/nginx&lt;/code&gt; 디렉토리의 &lt;code&gt;access.log&lt;/code&gt; 및 &lt;code&gt;error.log&lt;/code&gt; 파일에서 이유를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="6b029a860f5aec53b40c2dac21945824ec0c154a" translate="yes" xml:space="preserve">
          <source>In catch-all server examples the strange name &amp;ldquo;&lt;code&gt;_&lt;/code&gt;&amp;rdquo; can be seen:</source>
          <target state="translated">포괄 서버 예에서 이상한 이름&amp;ldquo; &lt;code&gt;_&lt;/code&gt; &amp;rdquo;을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9dfcb4426267969dcb08d8873669c3da8bc2431" translate="yes" xml:space="preserve">
          <source>In contrast to the certificate set by &lt;a href=&quot;#ssl_client_certificate&quot;&gt;ssl_client_certificate&lt;/a&gt;, the list of these certificates will not be sent to clients.</source>
          <target state="translated">&lt;a href=&quot;#ssl_client_certificate&quot;&gt;ssl_client_certificate로&lt;/a&gt; 설정된 인증서와 달리이 인증서 목록은 클라이언트로 전송되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="40b5d2410e9008b2a9ea9e2865b0926c633f6ec7" translate="yes" xml:space="preserve">
          <source>In nginx a list is a sequence of arrays, optimized for inserting a potentially large number of items. The &lt;code&gt;ngx_list_t&lt;/code&gt; list type is defined as follows:</source>
          <target state="translated">nginx에서 목록은 잠재적으로 많은 수의 항목을 삽입하도록 최적화 된 일련의 배열입니다. &lt;code&gt;ngx_list_t&lt;/code&gt; 의 다음과 같은 목록 유형이 정의된다 :</target>
        </trans-unit>
        <trans-unit id="21a78c8c409d8c170afac33f9e92dc746fbde8a9" translate="yes" xml:space="preserve">
          <source>In nginx a queue is an intrusive doubly linked list, with each node defined as follows:</source>
          <target state="translated">nginx에서 큐는 각 노드가 다음과 같이 정의 된 침입 이중 링크 목록입니다.</target>
        </trans-unit>
        <trans-unit id="21e265174a9c7ab8309e97cd2e88bf8e237ebfb4" translate="yes" xml:space="preserve">
          <source>In nginx an HTTP response is produced by sending the response header followed by the optional response body. Both header and body are passed through a chain of filters and eventually get written to the client socket. An nginx module can install its handler into the header or body filter chain and process the output coming from the previous handler.</source>
          <target state="translated">nginx에서 HTTP 응답은 응답 헤더와 선택적 응답 본문을 전송하여 생성됩니다. 헤더와 본문 모두 필터 체인을 통과하여 결국 클라이언트 소켓에 기록됩니다. nginx 모듈은 핸들러를 헤더 또는 바디 필터 체인에 설치하고 이전 핸들러에서 나오는 출력을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="fb39089e2299bbb96d84437e9309d82e17adec7f" translate="yes" xml:space="preserve">
          <source>In order for NTLM authentication to work, it is necessary to enable keepalive connections to upstream servers. The &lt;a href=&quot;ngx_http_proxy_module#proxy_http_version&quot;&gt;proxy_http_version&lt;/a&gt; directive should be set to &amp;ldquo;&lt;code&gt;1.1&lt;/code&gt;&amp;rdquo; and the &amp;ldquo;Connection&amp;rdquo; header field should be cleared:</source>
          <target state="translated">NTLM 인증이 작동하려면 업스트림 서버에 대한 연결 유지 기능을 활성화해야합니다. &lt;a href=&quot;ngx_http_proxy_module#proxy_http_version&quot;&gt;proxy_http_version의&lt;/a&gt; 지침이 &quot;로 설정해야합니다 &lt;code&gt;1.1&lt;/code&gt; &quot;과 &quot;연결&quot;헤더 필드가 삭제한다 :</target>
        </trans-unit>
        <trans-unit id="d894d9e83a7d26ab434a03a7226f576691376802" translate="yes" xml:space="preserve">
          <source>In order for Perl to recompile the modified modules during reconfiguration, it should be built with the &lt;code&gt;-Dusemultiplicity=yes&lt;/code&gt; or &lt;code&gt;-Dusethreads=yes&lt;/code&gt; parameters. Also, to make Perl leak less memory at run time, it should be built with the &lt;code&gt;-Dusemymalloc=no&lt;/code&gt; parameter. To check the values of these parameters in an already built Perl (preferred values are specified in the example), run:</source>
          <target state="translated">재구성 중에 Perl이 수정 된 모듈을 재 컴파일하려면 &lt;code&gt;-Dusemultiplicity=yes&lt;/code&gt; 또는 &lt;code&gt;-Dusethreads=yes&lt;/code&gt; 매개 변수를 사용하여 빌드해야합니다 . 또한 런타임시 Perl의 메모리 누수를 &lt;code&gt;-Dusemymalloc=no&lt;/code&gt; 면 -Dusemymalloc = no 매개 변수를 사용하여 빌드해야합니다 . 이미 빌드 된 Perl에서 이러한 매개 변수의 값을 확인하려면 (예제에서 바람직한 값이 지정됨) 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="32932950e5f849bf2f45d63930164523a0e7c33f" translate="yes" xml:space="preserve">
          <source>In order for a subrequest to return the required range, the &lt;code&gt;$slice_range&lt;/code&gt; variable should be &lt;a href=&quot;ngx_http_proxy_module#proxy_set_header&quot;&gt;passed&lt;/a&gt; to the proxied server as the &lt;code&gt;Range&lt;/code&gt; request header field. If &lt;a href=&quot;ngx_http_proxy_module#proxy_cache&quot;&gt;caching&lt;/a&gt; is enabled, &lt;code&gt;$slice_range&lt;/code&gt; should be added to the &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_key&quot;&gt;cache key&lt;/a&gt; and caching of responses with 206 status code should be &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_valid&quot;&gt;enabled&lt;/a&gt;.</source>
          <target state="translated">하위 요청이 필요한 범위를 리턴하려면 &lt;code&gt;$slice_range&lt;/code&gt; 변수가 &lt;code&gt;Range&lt;/code&gt; 요청 헤더 필드 로 프록시 서버에 &lt;a href=&quot;ngx_http_proxy_module#proxy_set_header&quot;&gt;전달&lt;/a&gt; 되어야 합니다. 경우 &lt;a href=&quot;ngx_http_proxy_module#proxy_cache&quot;&gt;캐싱이&lt;/a&gt; 활성화되어, &lt;code&gt;$slice_range&lt;/code&gt; 받는 사람을 추가해야 &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_key&quot;&gt;캐시 키&lt;/a&gt; 206 상태 코드가 응답의 캐시하면해야 &lt;a href=&quot;ngx_http_proxy_module#proxy_cache_valid&quot;&gt;사용 가능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3a6732083c63116f0aeb286b9ce41edcd9d88fd" translate="yes" xml:space="preserve">
          <source>In order for nginx to re-read the configuration file, a HUP signal should be sent to the master process. The master process first checks the syntax validity, then tries to apply new configuration, that is, to open log files and new listen sockets. If this fails, it rolls back changes and continues to work with old configuration. If this succeeds, it starts new worker processes, and sends messages to old worker processes requesting them to shut down gracefully. Old worker processes close listen sockets and continue to service old clients. After all clients are serviced, old worker processes are shut down.</source>
          <target state="translated">nginx가 구성 파일을 다시 읽으려면 마스터 프로세스로 HUP 신호를 보내야합니다. 마스터 프로세스는 먼저 구문 유효성을 검사 한 다음 새 구성을 적용합니다. 즉, 로그 파일과 새 청취 소켓을 엽니 다. 이것이 실패하면 변경 사항을 롤백하고 이전 구성으로 계속 작업합니다. 이것이 성공하면 새 작업자 프로세스를 시작하고 이전 작업자 프로세스로 메시지를 보내서 정상적으로 종료하도록 요청합니다. 이전 작업자 프로세스는 청취 소켓을 닫고 이전 클라이언트에 계속 서비스를 제공합니다. 모든 클라이언트에 서비스가 제공되면 기존 작업자 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="4dc8191883ef822a655f33f3e279582f45e9ad34" translate="yes" xml:space="preserve">
          <source>In order for the &lt;code&gt;resolve&lt;/code&gt; parameter to work, the &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;resolver&lt;/a&gt; directive must be specified in the &lt;a href=&quot;ngx_stream_core_module#stream&quot;&gt;stream&lt;/a&gt; block. Example:</source>
          <target state="translated">위해서는 &lt;code&gt;resolve&lt;/code&gt; 작업에 매개 변수의 &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;리졸버&lt;/a&gt; 지시어는 지정해야합니다 &lt;a href=&quot;ngx_stream_core_module#stream&quot;&gt;스트림&lt;/a&gt; 블록. 예:</target>
        </trans-unit>
        <trans-unit id="4df63a27480305d15d5c14524f511e3f71f54899" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required (1.13.8) as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the FastCGI server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스 (1.13.8)가 필요하지 않으며 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . 또한 FastCGI 서버의 네트워크 트래픽을 가로 채도록 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce65969e1cdf3f2b4302fb4c22caa2c32a900c49" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required (1.13.8) as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the SCGI server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스 (1.13.8)가 필요하지 않으며 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . SCGI 서버의 네트워크 트래픽을 가로 채기 위해 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb68a7bdaf1ffd5b0cca11269798ca9e55878164" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required (1.13.8) as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the memcached server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스 (1.13.8)가 필요하지 않으며 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . memcached 서버의 네트워크 트래픽을 가로 채도록 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="5ee08ad7e21475bb73ffb352c331d9a00e82e0e5" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required (1.13.8) as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the proxied server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스 (1.13.8)가 필요하지 않으며 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . 프록시 서버의 네트워크 트래픽을 가로 채도록 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="e630baac52154bdac982c02089151f967c587235" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required (1.13.8) as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the uwsgi server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스 (1.13.8)가 필요하지 않으며 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . uwsgi 서버의 네트워크 트래픽을 가로 채기 위해 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ff1211a85b3f3a44af85e0548a3f991aff89e3bb" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, it is usually necessary to run nginx worker processes with the &lt;a href=&quot;../ngx_core_module#user&quot;&gt;superuser&lt;/a&gt; privileges. On Linux it is not required as if the &lt;code&gt;transparent&lt;/code&gt; parameter is specified, worker processes inherit the &lt;code&gt;CAP_NET_RAW&lt;/code&gt; capability from the master process. It is also necessary to configure kernel routing table to intercept network traffic from the gRPC server.</source>
          <target state="translated">이 매개 변수가 작동하려면 일반적으로 &lt;a href=&quot;../ngx_core_module#user&quot;&gt;수퍼 유저&lt;/a&gt; 권한으로 nginx 작업자 프로세스를 실행해야합니다 . Linux에서는 &lt;code&gt;transparent&lt;/code&gt; 매개 변수가 지정된 것처럼 작업자 프로세스가 필요하지 않습니다 . 작업자 프로세스 는 마스터 프로세스에서 &lt;code&gt;CAP_NET_RAW&lt;/code&gt; 기능을 상속합니다 . gRPC 서버의 네트워크 트래픽을 가로 채도록 커널 라우팅 테이블을 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="ca0339426ab3a3b01999e91aa74f055c021fadaa" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, the &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver&lt;/a&gt; directive must be specified in the &lt;a href=&quot;ngx_http_core_module#http&quot;&gt;http&lt;/a&gt; block. Example:</source>
          <target state="translated">이 매개 변수가 작동하려면 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;리졸버&lt;/a&gt; 지시문이 &lt;a href=&quot;ngx_http_core_module#http&quot;&gt;http&lt;/a&gt; 블록 에 지정되어야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="a91452076ae50e92bfa25907603030bd31d1f7f4" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, the &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;resolver&lt;/a&gt; directive must be specified in the &lt;a href=&quot;ngx_stream_core_module#stream&quot;&gt;stream&lt;/a&gt; block. Example:</source>
          <target state="translated">이 매개 변수가 작동하려면 &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;리졸버&lt;/a&gt; 지시문이 &lt;a href=&quot;ngx_stream_core_module#stream&quot;&gt;스트림&lt;/a&gt; 블록 에 지정되어야합니다 . 예:</target>
        </trans-unit>
        <trans-unit id="9c350824fa252a508c80eb62c25d6188a6da8dec" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, the &lt;code&gt;resolver&lt;/code&gt; directive must be specified in the &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;http&lt;/a&gt; block or in the corresponding &lt;a href=&quot;#resolver&quot;&gt;upstream&lt;/a&gt; block.</source>
          <target state="translated">이 매개 변수가 작동하려면 &lt;code&gt;resolver&lt;/code&gt; 지시문이 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;http&lt;/a&gt; 블록 또는 해당 &lt;a href=&quot;#resolver&quot;&gt;업스트림&lt;/a&gt; 블록에 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd6e75883e124954f8937c95d16a16e4acd61c16" translate="yes" xml:space="preserve">
          <source>In order for this parameter to work, the &lt;code&gt;resolver&lt;/code&gt; directive must be specified in the &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;stream&lt;/a&gt; block or in the corresponding &lt;a href=&quot;#resolver&quot;&gt;upstream&lt;/a&gt; block.</source>
          <target state="translated">이 매개 변수가 작동하려면 &lt;code&gt;resolver&lt;/code&gt; 지시문이 &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;스트림&lt;/a&gt; 블록 또는 해당 &lt;a href=&quot;#resolver&quot;&gt;업스트림&lt;/a&gt; 블록에 지정되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7234ee35927ab215b81c4f9622ec54bd44925da" translate="yes" xml:space="preserve">
          <source>In order to rotate log files, they need to be renamed first. After that USR1 signal should be sent to the master process. The master process will then re-open all currently open log files and assign them an unprivileged user under which the worker processes are running, as an owner. After successful re-opening, the master process closes all open files and sends the message to worker process to ask them to re-open files. Worker processes also open new files and close old files right away. As a result, old files are almost immediately available for post processing, such as compression.</source>
          <target state="translated">로그 파일을 회전 시키려면 먼저 이름을 바꿔야합니다. 그런 다음 USR1 신호를 마스터 프로세스로 보내야합니다. 그런 다음 마스터 프로세스는 현재 열려있는 모든 로그 파일을 다시 열고 작업자 프로세스가 실행중인 권한이없는 사용자를 소유자로 지정합니다. 성공적으로 다시 열면 마스터 프로세스는 열려있는 모든 파일을 닫고 작업자 프로세스에 메시지를 보내 파일을 다시 열도록 요청합니다. 작업자 프로세스는 또한 새 파일을 열고 오래된 파일을 즉시 닫습니다. 결과적으로 압축과 같은 사후 처리를 위해 이전 파일을 거의 즉시 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea6f78ed3c06e6cb78999961b866128b70036fc8" translate="yes" xml:space="preserve">
          <source>In order to upgrade the server executable, the new executable file should be put in place of an old file first. After that USR2 signal should be sent to the master process. The master process first renames its file with the process ID to a new file with the &lt;code&gt;.oldbin&lt;/code&gt; suffix, e.g. &lt;code&gt;/usr/local/nginx/logs/nginx.pid.oldbin&lt;/code&gt;, then starts a new executable file that in turn starts new worker processes:</source>
          <target state="translated">서버 실행 파일을 업그레이드하려면 먼저 새 파일 대신 새 실행 파일을 배치해야합니다. 그런 다음 USR2 신호를 마스터 프로세스로 보내야합니다. 마스터 프로세스는 먼저 프로세스 ID가있는 파일의 이름을 &lt;code&gt;.oldbin&lt;/code&gt; 접미 부가 있는 새 파일 ( 예 : &lt;code&gt;/usr/local/nginx/logs/nginx.pid.oldbin&lt;/code&gt; )로 바꾼 다음 새 실행 파일을 시작하여 새 작업자 프로세스를 시작합니다. :</target>
        </trans-unit>
        <trans-unit id="67c1a639266e38a12737ca58557ff92b0202fcb0" translate="yes" xml:space="preserve">
          <source>In order to use SNI in nginx, it must be supported in both the OpenSSL library with which the nginx binary has been built as well as the library to which it is being dynamically linked at run time. OpenSSL supports SNI since 0.9.8f version if it was built with config option</source>
          <target state="translated">nginx에서 SNI를 사용하려면 nginx 바이너리가 빌드 된 OpenSSL 라이브러리와 런타임시 동적으로 링크되는 라이브러리 모두에서 SNI를 지원해야합니다. OpenSSL은 구성 옵션으로 빌드 된 경우 0.9.8f 버전부터 SNI를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="190be725c0cd512ac4257379a00ec488657027d5" translate="yes" xml:space="preserve">
          <source>In some cases, the part of a request URI to be replaced cannot be determined:</source>
          <target state="translated">어떤 경우에는 교체 할 요청 URI 부분을 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a588e840b01b89cf4873fd7325ac33f2ebd75e2c" translate="yes" xml:space="preserve">
          <source>In such a case, all possible values of a variable need to be present in the configuration at least once in the form of the &lt;a href=&quot;#charset_map&quot;&gt;charset_map&lt;/a&gt;, &lt;a href=&quot;#charset&quot;&gt;charset&lt;/a&gt;, or &lt;a href=&quot;#source_charset&quot;&gt;source_charset&lt;/a&gt; directives. For &lt;code&gt;utf-8&lt;/code&gt;, &lt;code&gt;windows-1251&lt;/code&gt;, and &lt;code&gt;koi8-r&lt;/code&gt; charsets, it is sufficient to include the files &lt;code&gt;conf/koi-win&lt;/code&gt;, &lt;code&gt;conf/koi-utf&lt;/code&gt;, and &lt;code&gt;conf/win-utf&lt;/code&gt; into configuration. For other charsets, simply making a fictitious conversion table works, for example:</source>
          <target state="translated">이러한 경우 변수의 모든 가능한 값은 &lt;a href=&quot;#charset_map&quot;&gt;charset_map&lt;/a&gt; , &lt;a href=&quot;#charset&quot;&gt;charset&lt;/a&gt; 또는 &lt;a href=&quot;#source_charset&quot;&gt;source_charset&lt;/a&gt; 지시문 의 형태로 구성에 적어도 한 번 존재해야합니다 . 들어 &lt;code&gt;utf-8&lt;/code&gt; , &lt;code&gt;windows-1251&lt;/code&gt; 및 &lt;code&gt;koi8-r&lt;/code&gt; 캐릭터 세트, 파일을 포함하기에 충분하다 &lt;code&gt;conf/koi-win&lt;/code&gt; , &lt;code&gt;conf/koi-utf&lt;/code&gt; 및 &lt;code&gt;conf/win-utf&lt;/code&gt; 구성에 있습니다. 다른 문자 집합의 경우 가상의 변환 테이블을 만들면됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c74cbeeec525e150d7f36ab7cc2b9e16fcfc9e1c" translate="yes" xml:space="preserve">
          <source>In such a case, first try to set &lt;a href=&quot;ngx_http_core_module#server_names_hash_max_size&quot;&gt;server_names_hash_max_size&lt;/a&gt; to a number close to the number of server names. Only if this does not help, or if nginx&amp;rsquo;s start time is unacceptably long, try to increase &lt;a href=&quot;ngx_http_core_module#server_names_hash_bucket_size&quot;&gt;server_names_hash_bucket_size&lt;/a&gt;.</source>
          <target state="translated">이러한 경우 먼저 &lt;a href=&quot;ngx_http_core_module#server_names_hash_max_size&quot;&gt;server_names_hash_max_size&lt;/a&gt; 를 서버 이름 수에 가까운 숫자 로 설정 하십시오. 이것이 도움이되지 않거나 nginx의 시작 시간이 허용 할 수 없을 정도로 긴 경우에만 &lt;a href=&quot;ngx_http_core_module#server_names_hash_bucket_size&quot;&gt;server_names_hash_bucket_size&lt;/a&gt; 를 늘리십시오 .</target>
        </trans-unit>
        <trans-unit id="bfe146824fe7250619f45417c5989f9770680868" translate="yes" xml:space="preserve">
          <source>In the event that all threads in the pool are busy, a new task will wait in the queue. The &lt;code&gt;max_queue&lt;/code&gt; parameter limits the number of tasks allowed to be waiting in the queue. By default, up to 65536 tasks can wait in the queue. When the queue overflows, the task is completed with an error.</source>
          <target state="translated">풀의 모든 스레드가 사용중인 경우 새 작업이 대기열에서 대기합니다. &lt;code&gt;max_queue&lt;/code&gt; 매개 변수는 큐에서 대기 할 수 작업의 수를 제한합니다. 기본적으로 최대 65536 개의 작업이 대기열에서 대기 할 수 있습니다. 대기열이 넘치면 작업이 오류와 함께 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="1ed10351510576744b588e4d6421d7c07b4fa63d" translate="yes" xml:space="preserve">
          <source>In the example above, there are 3 instances of the same application running on srv1-srv3. When the load balancing method is not specifically configured, it defaults to round-robin. All requests are &lt;a href=&quot;ngx_http_proxy_module#proxy_pass&quot;&gt; proxied&lt;/a&gt; to the server group myapp1, and nginx applies HTTP load balancing to distribute the requests.</source>
          <target state="translated">위의 예에서 srv1-srv3에서 실행중인 동일한 응용 프로그램의 3 개의 인스턴스가 있습니다. 로드 밸런싱 방법이 구체적으로 구성되지 않은 경우 기본적으로 라운드 로빈입니다. 모든 요청은 서버 그룹 myapp1 로 &lt;a href=&quot;ngx_http_proxy_module#proxy_pass&quot;&gt;프록시&lt;/a&gt; 되며 nginx는 HTTP로드 밸런싱을 적용하여 요청을 분배합니다.</target>
        </trans-unit>
        <trans-unit id="ddadb1a21f675ae6a55e832be45d3edcfd078d49" translate="yes" xml:space="preserve">
          <source>In the example, the &lt;code&gt;httponly&lt;/code&gt; flag is added to the cookie &lt;code&gt;one&lt;/code&gt;, for all other cookies the &lt;code&gt;samesite=strict&lt;/code&gt; flag is added and the &lt;code&gt;secure&lt;/code&gt; flag is deleted.</source>
          <target state="translated">예에서 &lt;code&gt;httponly&lt;/code&gt; 플래그가 쿠키 &lt;code&gt;one&lt;/code&gt; 에 추가되고 다른 모든 쿠키에 대해 &lt;code&gt;samesite=strict&lt;/code&gt; 플래그가 추가되고 &lt;code&gt;secure&lt;/code&gt; 플래그가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="afc7578672b2c9f7e2d1ac6dc8446487d225c686" translate="yes" xml:space="preserve">
          <source>In the example, the upstream server creates a session by setting the cookie &amp;ldquo;&lt;code&gt;EXAMPLECOOKIE&lt;/code&gt;&amp;rdquo; in the response. Further requests with this cookie will be passed to the same server. If the server cannot process the request, the new server is selected as if the client has not been bound yet.</source>
          <target state="translated">이 예에서 업스트림 서버 는 응답에 쿠키 &quot; &lt;code&gt;EXAMPLECOOKIE&lt;/code&gt; &quot;를 설정하여 세션을 만듭니다 . 이 쿠키에 대한 추가 요청은 동일한 서버로 전달됩니다. 서버가 요청을 처리 할 수 ​​없으면 클라이언트가 아직 바인드되지 않은 것처럼 새 서버가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b8432fba576fbc6a638e49f2488a4d75819d819c" translate="yes" xml:space="preserve">
          <source>In the examples above, the server weights are not configured which means that all specified servers are treated as equally qualified for a particular load balancing method.</source>
          <target state="translated">위의 예에서 서버 가중치는 구성되지 않았습니다. 즉, 지정된 모든 서버가 특정로드 밸런싱 방법에 대해 동일하게 규정 된 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="7eb611f6b423de2f1dcd866a6885561409036ae9" translate="yes" xml:space="preserve">
          <source>In the first case, the best is to use &lt;a href=&quot;#http_subrequests&quot;&gt;subrequests API&lt;/a&gt;. Instead of directly accessing external service, you declare a location in nginx configuration and direct your subrequest to this location. This location is not limited to &lt;a href=&quot;../http/ngx_http_proxy_module#proxy_pass&quot;&gt;proxying&lt;/a&gt; requests, but may contain other nginx directives. An example of such approach is the &lt;a href=&quot;../http/ngx_http_auth_request_module#auth_request&quot;&gt;auth_request&lt;/a&gt; directive implemented in &lt;a href=&quot;http://hg.nginx.org/nginx/file/tip/src/http/modules/ngx_http_auth_request_module.c&quot;&gt;ngx_http_auth_request module&lt;/a&gt;.</source>
          <target state="translated">첫 번째 경우 &lt;a href=&quot;#http_subrequests&quot;&gt;하위 요청 API&lt;/a&gt; 를 사용하는 것이 가장 좋습니다 . 외부 서비스에 직접 액세스하는 대신 nginx 구성에서 위치를 선언하고 하위 요청을이 위치로 보냅니다. 이 위치는 &lt;a href=&quot;../http/ngx_http_proxy_module#proxy_pass&quot;&gt;프록시&lt;/a&gt; 요청으로 제한되지 않지만 다른 nginx 지시문을 포함 할 수 있습니다. 이러한 접근 방식의 예는이다 &lt;a href=&quot;../http/ngx_http_auth_request_module#auth_request&quot;&gt;auth_request의&lt;/a&gt; 구현 지시자 &lt;a href=&quot;http://hg.nginx.org/nginx/file/tip/src/http/modules/ngx_http_auth_request_module.c&quot;&gt;ngx_http_auth_request 모듈&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f00c733671a04000a05bf717e25acf161719f5a" translate="yes" xml:space="preserve">
          <source>In the following example,</source>
          <target state="translated">다음 예에서</target>
        </trans-unit>
        <trans-unit id="44d5404d38c293b8436ec353e3b2c1e5d349b8c3" translate="yes" xml:space="preserve">
          <source>In the modern nginx versions variables &lt;a href=&quot;ngx_http_core_module#var_status&quot;&gt;$status&lt;/a&gt; (1.3.2, 1.2.2), &lt;a href=&quot;ngx_http_core_module#var_bytes_sent&quot;&gt;$bytes_sent&lt;/a&gt; (1.3.8, 1.2.5), &lt;a href=&quot;ngx_http_core_module#var_connection&quot;&gt;$connection&lt;/a&gt; (1.3.8, 1.2.5), &lt;a href=&quot;ngx_http_core_module#var_connection_requests&quot;&gt;$connection_requests&lt;/a&gt; (1.3.8, 1.2.5), &lt;a href=&quot;ngx_http_core_module#var_msec&quot;&gt;$msec&lt;/a&gt; (1.3.9, 1.2.6), &lt;a href=&quot;ngx_http_core_module#var_request_time&quot;&gt;$request_time&lt;/a&gt; (1.3.9, 1.2.6), &lt;a href=&quot;ngx_http_core_module#var_pipe&quot;&gt;$pipe&lt;/a&gt; (1.3.12, 1.2.7), &lt;a href=&quot;ngx_http_core_module#var_request_length&quot;&gt;$request_length&lt;/a&gt; (1.3.12, 1.2.7), &lt;a href=&quot;ngx_http_core_module#var_time_iso8601&quot;&gt;$time_iso8601&lt;/a&gt; (1.3.12, 1.2.7), and &lt;a href=&quot;ngx_http_core_module#var_time_local&quot;&gt;$time_local&lt;/a&gt; (1.3.12, 1.2.7) are also available as common variables.</source>
          <target state="translated">최신 nginx 버전에서 변수 &lt;a href=&quot;ngx_http_core_module#var_status&quot;&gt;$ status&lt;/a&gt; (1.3.2, 1.2.2), &lt;a href=&quot;ngx_http_core_module#var_bytes_sent&quot;&gt;$ bytes_sent&lt;/a&gt; (1.3.8, 1.2.5), &lt;a href=&quot;ngx_http_core_module#var_connection&quot;&gt;$ connection&lt;/a&gt; (1.3.8, 1.2.5), &lt;a href=&quot;ngx_http_core_module#var_connection_requests&quot;&gt;$ connection_requests&lt;/a&gt; (1.3.8, 1.2) .5), &lt;a href=&quot;ngx_http_core_module#var_msec&quot;&gt;$ msec&lt;/a&gt; (1.3.9, 1.2.6), &lt;a href=&quot;ngx_http_core_module#var_request_time&quot;&gt;$ request_time&lt;/a&gt; (1.3.9, 1.2.6), &lt;a href=&quot;ngx_http_core_module#var_pipe&quot;&gt;$ pipe&lt;/a&gt; (1.3.12, 1.2.7), &lt;a href=&quot;ngx_http_core_module#var_request_length&quot;&gt;$ request_length&lt;/a&gt; (1.3.12, 1.2.7) ), &lt;a href=&quot;ngx_http_core_module#var_time_iso8601&quot;&gt;$ time_iso8601&lt;/a&gt; (1.3.12, 1.2.7) 및 &lt;a href=&quot;ngx_http_core_module#var_time_local&quot;&gt;$ time_local&lt;/a&gt; (1.3.12, 1.2.7)도 공통 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5de96290f7f64baf89fe5d7c5924ef047a16b051" translate="yes" xml:space="preserve">
          <source>In these cases, &lt;code&gt;proxy_pass&lt;/code&gt; should be specified without a URI.</source>
          <target state="translated">이러한 경우 &lt;code&gt;proxy_pass&lt;/code&gt; 는 URI없이 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="30d691c21ced9a1760582c70fb335d364b99ae56" translate="yes" xml:space="preserve">
          <source>In this case, by default, the response code 302 is returned to the client. It can only be changed to one of the redirect status codes (301, 302, 303, 307, and 308).</source>
          <target state="translated">이 경우 기본적으로 응답 코드 302가 클라이언트로 반환됩니다. 리디렉션 상태 코드 (301, 302, 303, 307 및 308) 중 하나로 만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f02d27f8126b68d3f00ef1cfdef042eabaf3e0a0" translate="yes" xml:space="preserve">
          <source>In this case, if URI is specified in the directive, it is passed to the server as is, replacing the original request URI.</source>
          <target state="translated">이 경우 지시문에 URI가 지정된 경우 원래 요청 URI를 대체하여 그대로 서버로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b766946bfbabe9bd74304bf4901eb2f1d8481c09" translate="yes" xml:space="preserve">
          <source>In this case, the URI specified in the directive is ignored and the full changed request URI is passed to the server.</source>
          <target state="translated">이 경우 지시문에 지정된 URI는 무시되고 변경된 전체 요청 URI가 서버로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="9647ac737aabc51e20dad37f39bb76df4a020dfd" translate="yes" xml:space="preserve">
          <source>In this case, the absence of ICMP &amp;ldquo;&lt;code&gt;Destination Unreachable&lt;/code&gt;&amp;rdquo; message is expected in reply to the sent string &amp;ldquo;&lt;code&gt;nginx health check&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">이 경우, 전송 된 문자열 &quot; &lt;code&gt;nginx health check&lt;/code&gt; &quot; 에 대한 응답으로 ICMP &quot; &lt;code&gt;Destination Unreachable&lt;/code&gt; &quot;메시지가 없을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="8feff15f970e5b3db6be7fadf081e59bf5a87c05" translate="yes" xml:space="preserve">
          <source>In this case, the directive value should be increased to the next power of two:</source>
          <target state="translated">이 경우 지시 값을 다음 2의 제곱으로 늘려야합니다.</target>
        </trans-unit>
        <trans-unit id="ddc8e46485e8c4b1c10e390c0123cff84a29090d" translate="yes" xml:space="preserve">
          <source>In this case, the server name is searched among the described &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;server groups&lt;/a&gt;, and, if not found, is determined using a &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;resolver&lt;/a&gt;.</source>
          <target state="translated">이 경우 서버 이름은 설명 된 &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;서버 그룹&lt;/a&gt; 중에서 검색 되며, 발견되지 않은 경우 &lt;a href=&quot;ngx_stream_core_module#resolver&quot;&gt;리졸버를&lt;/a&gt; 사용하여 판별됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c87a59f397d3247d9616de1eca261f2236eb283" translate="yes" xml:space="preserve">
          <source>In this case, the value of the &amp;ldquo;&lt;code&gt;srv_id&lt;/code&gt;&amp;rdquo; cookie will be either &lt;code&gt;&lt;i&gt;a&lt;/i&gt;&lt;/code&gt; or &lt;code&gt;&lt;i&gt;b&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">이 경우&amp;ldquo; &lt;code&gt;srv_id&lt;/code&gt; &amp;rdquo;쿠키 의 값은 &lt;code&gt;&lt;i&gt;a&lt;/i&gt;&lt;/code&gt; 또는 &lt;code&gt;&lt;i&gt;b&lt;/i&gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="01c3b55e4db584bc6d9c96832ec34c5895cf40d3" translate="yes" xml:space="preserve">
          <source>In this configuration nginx tests only the request&amp;rsquo;s header field &amp;ldquo;Host&amp;rdquo; to determine which server the request should be routed to. If its value does not match any server name, or the request does not contain this header field at all, then nginx will route the request to the default server for this port. In the configuration above, the default server is the first one &amp;mdash; which is nginx&amp;rsquo;s standard default behaviour. It can also be set explicitly which server should be default, with the &lt;code&gt;default_server&lt;/code&gt; parameter in the &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;listen&lt;/a&gt; directive:</source>
          <target state="translated">이 구성에서 nginx는 요청의 헤더 필드 &quot;Host&quot;만 테스트하여 요청을 라우팅 할 서버를 결정합니다. 해당 값이 서버 이름과 일치하지 않거나 요청에이 헤더 필드가 전혀 없으면 nginx는 요청을이 포트의 기본 서버로 라우팅합니다. 위의 구성에서 기본 서버는 첫 번째 서버이며 이는 nginx의 표준 기본 동작입니다. 또한 함께 기본적해야하는 서버를 명시 적으로 설정 될 수있다 &lt;code&gt;default_server&lt;/code&gt; 의 (가)에서 매개 변수 &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;들을&lt;/a&gt; 지시 :</target>
        </trans-unit>
        <trans-unit id="eba7d987bfefa06e58f923f334f4d7028fa1372d" translate="yes" xml:space="preserve">
          <source>In this configuration, &lt;code&gt;sendfile()&lt;/code&gt; is called with the &lt;code&gt;SF_NODISKIO&lt;/code&gt; flag which causes it not to block on disk I/O, but, instead, report back that the data are not in memory. nginx then initiates an asynchronous data load by reading one byte. On the first read, the FreeBSD kernel loads the first 128K bytes of a file into memory, although next reads will only load data in 16K chunks. This can be changed using the &lt;a href=&quot;#read_ahead&quot;&gt;read_ahead&lt;/a&gt; directive.</source>
          <target state="translated">이 구성에서 &lt;code&gt;sendfile()&lt;/code&gt; 은 &lt;code&gt;SF_NODISKIO&lt;/code&gt; 플래그 와 함께 호출되어 디스크 I / O를 차단하지 않고 대신 데이터가 메모리에 있지 않다고보고합니다. 그런 다음 nginx는 1 바이트를 읽음으로써 비동기 데이터로드를 시작합니다. 첫 번째 읽기에서 FreeBSD 커널은 파일의 첫 128K 바이트를 메모리에로드하지만 다음 읽기는 16K 청크의 데이터 만로드합니다. &lt;a href=&quot;#read_ahead&quot;&gt;read_ahead&lt;/a&gt; 지시문을 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="38b535bf4526e82cf4d779b56b719f3b745097d7" translate="yes" xml:space="preserve">
          <source>In this configuration, nginx first tests the IP address and port of the request against the &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;listen&lt;/a&gt; directives of the &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; blocks. It then tests the &amp;ldquo;Host&amp;rdquo; header field of the request against the &lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; entries of the &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; blocks that matched the IP address and port. If the server name is not found, the request will be processed by the default server. For example, a request for &lt;code&gt;www.example.com&lt;/code&gt; received on the 192.168.1.1:80 port will be handled by the default server of the 192.168.1.1:80 port, i.e., by the first server, since there is no &lt;code&gt;www.example.com&lt;/code&gt; defined for this port.</source>
          <target state="translated">이 구성에서 nginx는 먼저 &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 블록 의 &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;청취&lt;/a&gt; 지시문에 대해 요청의 IP 주소와 포트를 테스트합니다 . 그런 다음 IP 주소 및 포트와 일치하는 &lt;a href=&quot;ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 블록 의 &lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; 항목에 대해 요청의 &quot;Host&quot;헤더 필드를 테스트합니다 . 서버 이름이 없으면 기본 서버에서 요청을 처리합니다. 예를 들어,에 대한 요청 &lt;code&gt;www.example.com&lt;/code&gt; 더가 없기 때문에 192.168.1.1:80 포트에서 수신은, 첫 번째 서버에 의해, 즉 192.168.1.1:80 포트의 기본 서버에 의해 처리됩니다 &lt;code&gt;www.example.com&lt;/code&gt; 이 포트에 대해 .com이 정의되었습니다.</target>
        </trans-unit>
        <trans-unit id="86330969c97e7c379c3409d48f2519dcdf158c92" translate="yes" xml:space="preserve">
          <source>In this example the subject (&amp;ldquo;</source>
          <target state="translated">이 예에서 주제 (&amp;ldquo;</target>
        </trans-unit>
        <trans-unit id="5396964e2a59202fdc11c4214cc42ec19227bc98" translate="yes" xml:space="preserve">
          <source>In this example, the response is split into 1-megabyte cacheable slices.</source>
          <target state="translated">이 예에서 응답은 1MB 캐시 가능 슬라이스로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="8a0875e16fe4cd558e2d8e940b9b28e07bd4e6a5" translate="yes" xml:space="preserve">
          <source>In this example, we will use the &lt;a href=&quot;https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto&quot;&gt;helloworld.proto&lt;/a&gt; file from the gRPC examples. Our goal is to create two messages: &lt;code&gt;HelloRequest&lt;/code&gt; and &lt;code&gt;HelloResponse&lt;/code&gt;. We will use the &lt;a href=&quot;https://github.com/protobufjs/protobuf.js/blob/master/README.md#reflection-vs-static-code&quot;&gt;static&lt;/a&gt; mode of protobufjs instead of dynamically generating classes, because njs doesn't support adding new functions dynamically due to security considerations.</source>
          <target state="translated">이 예에서는 gRPC 예의 &lt;a href=&quot;https://github.com/grpc/grpc/blob/master/examples/protos/helloworld.proto&quot;&gt;helloworld.proto&lt;/a&gt; 파일을 사용합니다 . 우리의 목표는 &lt;code&gt;HelloRequest&lt;/code&gt; 와 &lt;code&gt;HelloResponse&lt;/code&gt; 라는 두 개의 메시지를 만드는 것입니다 . njs는 보안 고려 사항으로 인해 동적으로 새 함수를 추가하는 것을 지원하지 않기 때문에 동적으로 클래스를 생성하는 대신 protobufjs 의 &lt;a href=&quot;https://github.com/protobufjs/protobuf.js/blob/master/README.md#reflection-vs-static-code&quot;&gt;정적&lt;/a&gt; 모드를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a0780c9fb3d4c47fab0dbc306dfe829132d430ea" translate="yes" xml:space="preserve">
          <source>In this guide, we use njs &lt;a href=&quot;cli&quot;&gt;cli&lt;/a&gt; in all examples for the sake of simplicity. In real life, you will be using nginx njs module to run your code.</source>
          <target state="translated">이 가이드에서는 단순성을 위해 모든 예제에서 njs &lt;a href=&quot;cli&quot;&gt;cli&lt;/a&gt; 를 사용 합니다. 실생활에서는 nginx njs 모듈을 사용하여 코드를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ddf8ac58aa898ca5b58ffe4db3a5508e59ab4974" translate="yes" xml:space="preserve">
          <source>In this guide, we will use two relatively large npm-hosted libraries:</source>
          <target state="translated">이 가이드에서는 상대적으로 큰 두 개의 npm 호스팅 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6695cf724b2ff9cef71a3fb9ed7cf4e1abc1621a" translate="yes" xml:space="preserve">
          <source>In versions 1.7.3, 1.7.7, and 1.11.10 cache header format has been changed. Previously cached responses will be considered invalid after upgrading to a newer nginx version.</source>
          <target state="translated">버전 1.7.3, 1.7.7 및 1.11.10 캐시 헤더 형식이 변경되었습니다. 최신 nginx 버전으로 업그레이드 한 후 이전에 캐시 된 응답은 유효하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d5bf53ed48bc0948bbc95e42025e2f40bc151459" translate="yes" xml:space="preserve">
          <source>In versions from 0.7.1 to 0.8.41, if a request matched the prefix location without the &amp;ldquo;&lt;code&gt;=&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;^~&lt;/code&gt;&amp;rdquo; modifiers, the search also terminated and regular expressions were not checked.</source>
          <target state="translated">0.7.1 ~ 0.8.41 버전에서 요청이 &quot; &lt;code&gt;=&lt;/code&gt; &quot;및 &quot; &lt;code&gt;^~&lt;/code&gt; &quot;수정자가 없는 접두사 위치와 일치 하면 검색도 종료되고 정규식이 검사되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="2ec0c1acdbf96fff02aaf8aa772ba758d08e5bcd" translate="yes" xml:space="preserve">
          <source>In versions prior to 0.8.21 this parameter is named simply &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">0.8.21 이전 버전에서는이 매개 변수의 이름이 단순히 &lt;code&gt;default&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5ae2a5617793ebeb79d0fb7d09c86c57b8dff6a1" translate="yes" xml:space="preserve">
          <source>In versions prior to 0.8.21, they could only be specified in the &lt;code&gt;listen&lt;/code&gt; directive together with the &lt;code&gt;default&lt;/code&gt; parameter.</source>
          <target state="translated">0.8.21 이전 버전에서는 &lt;code&gt;default&lt;/code&gt; 매개 변수 와 함께 &lt;code&gt;listen&lt;/code&gt; 지시문 에서만 지정할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="3a2ffefd4d857e4c3928db6f5124c4730bbaac59" translate="yes" xml:space="preserve">
          <source>In versions prior to 1.5.9, responses in SPDY connections could not be &lt;a href=&quot;ngx_http_core_module#limit_rate&quot;&gt;rate limited&lt;/a&gt;.</source>
          <target state="translated">1.5.9 이전 버전에서는 SPDY 연결의 응답 &lt;a href=&quot;ngx_http_core_module#limit_rate&quot;&gt;속도를 제한&lt;/a&gt; 할 수 없었습니다 .</target>
        </trans-unit>
        <trans-unit id="2f5314bb88ef4033cb43b5d6a3c94437e5b7f585" translate="yes" xml:space="preserve">
          <source>In versions prior to 1.7.5, the directive syntax required an arbitrary argument, for example, &amp;ldquo;&lt;code&gt;stub_status on&lt;/code&gt;&amp;rdquo;.</source>
          <target state="translated">1.7.5 이전 버전에서는 지시문 구문에 임의의 인수 (예 : &quot; &lt;code&gt;stub_status on&lt;/code&gt; &quot;)가 필요했습니다.</target>
        </trans-unit>
        <trans-unit id="8f7ec1b2fe01ad3c188feb12a4b15b6ea7487a3d" translate="yes" xml:space="preserve">
          <source>Inappropriate use of this option may have its security &lt;a href=&quot;http://man7.org/linux/man-pages/man7/socket.7.html&quot;&gt;implications&lt;/a&gt;.</source>
          <target state="translated">이 옵션을 잘못 사용하면 보안에 &lt;a href=&quot;http://man7.org/linux/man-pages/man7/socket.7.html&quot;&gt;영향을 줄&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b05e5f0322faba479f0f3c37cf7e2e6f8e866b7e" translate="yes" xml:space="preserve">
          <source>Include files</source>
          <target state="translated">파일 포함</target>
        </trans-unit>
        <trans-unit id="9045983cbdbf806a171a94a2f52af7b16e1e1876" translate="yes" xml:space="preserve">
          <source>Includes another &lt;code&gt;&lt;i&gt;file&lt;/i&gt;&lt;/code&gt;, or files matching the specified &lt;code&gt;&lt;i&gt;mask&lt;/i&gt;&lt;/code&gt;, into configuration. Included files should consist of syntactically correct directives and blocks.</source>
          <target state="translated">다른 &lt;code&gt;&lt;i&gt;file&lt;/i&gt;&lt;/code&gt; 또는 지정된 &lt;code&gt;&lt;i&gt;mask&lt;/i&gt;&lt;/code&gt; 와 일치하는 파일 을 구성에 포함합니다. 포함 된 파일은 구문 상 올바른 지시문과 블록으로 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3806eb9e4d97457d4b3246b0d579de8fa4e6c33b" translate="yes" xml:space="preserve">
          <source>Includes the result of another request into a response. The command has the following parameters:</source>
          <target state="translated">다른 요청의 결과를 응답에 포함합니다. 이 명령에는 다음과 같은 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1bc5e7e5c04eebb69a6e2da261405b45aaa9749" translate="yes" xml:space="preserve">
          <source>Increases sharpness of the final image. The sharpness percentage can exceed 100. The zero value disables sharpening. Parameter value can contain variables.</source>
          <target state="translated">최종 이미지의 선명도를 높입니다. 선명도 백분율은 100을 초과 할 수 있습니다. 0 값은 선명 화를 비활성화합니다. 매개 변수 값은 변수를 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b95416ec28494191c299733854973a7e99bab4a1" translate="yes" xml:space="preserve">
          <source>Indicates whether the client request body is mirrored. When enabled, the client request body will be read prior to creating mirror subrequests. In this case, unbuffered client request body proxying set by the &lt;a href=&quot;ngx_http_proxy_module#proxy_request_buffering&quot;&gt;proxy_request_buffering&lt;/a&gt;, &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_request_buffering&quot;&gt;fastcgi_request_buffering&lt;/a&gt;, &lt;a href=&quot;ngx_http_scgi_module#scgi_request_buffering&quot;&gt;scgi_request_buffering&lt;/a&gt;, and &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_request_buffering&quot;&gt;uwsgi_request_buffering&lt;/a&gt; directives will be disabled.</source>
          <target state="translated">클라이언트 요청 본문이 미러링되는지 여부를 나타냅니다. 사용 가능한 경우 미러 서브 요청을 작성하기 전에 클라이언트 요청 본문을 읽습니다. 이 경우 &lt;a href=&quot;ngx_http_proxy_module#proxy_request_buffering&quot;&gt;proxy_request_buffering&lt;/a&gt; , &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_request_buffering&quot;&gt;fastcgi_request_buffering&lt;/a&gt; , &lt;a href=&quot;ngx_http_scgi_module#scgi_request_buffering&quot;&gt;scgi_request_buffering&lt;/a&gt; 및 &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_request_buffering&quot;&gt;uwsgi_request_buffering&lt;/a&gt; 지시문으로 설정된 버퍼되지 않은 클라이언트 요청 본문 프록시 가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="2ba8e87a86276a4ce4c2023e2bd804d18133b72e" translate="yes" xml:space="preserve">
          <source>Indicates whether the header fields of the original request are passed to the FastCGI server. See also the &lt;a href=&quot;#fastcgi_pass_request_body&quot;&gt;fastcgi_pass_request_body&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청의 헤더 필드가 FastCGI 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#fastcgi_pass_request_body&quot;&gt;fastcgi_pass_request_body&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="46fd80e907bab4e1113d026c7311121497a573e7" translate="yes" xml:space="preserve">
          <source>Indicates whether the header fields of the original request are passed to the SCGI server. See also the &lt;a href=&quot;#scgi_pass_request_body&quot;&gt;scgi_pass_request_body&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청의 헤더 필드가 SCGI 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#scgi_pass_request_body&quot;&gt;scgi_pass_request_body&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="381c25a48d8e6a476b250dc7d86140c0fdcdc25a" translate="yes" xml:space="preserve">
          <source>Indicates whether the header fields of the original request are passed to the proxied server.</source>
          <target state="translated">원래 요청의 헤더 필드가 프록시 서버로 전달되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b17a739abf08651c828b789df9d9ae697e4ee1ca" translate="yes" xml:space="preserve">
          <source>Indicates whether the header fields of the original request are passed to the uwsgi server. See also the &lt;a href=&quot;#uwsgi_pass_request_body&quot;&gt;uwsgi_pass_request_body&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청의 헤더 필드가 uwsgi 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#uwsgi_pass_request_body&quot;&gt;uwsgi_pass_request_body&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a16087ff5e7d770a23a9c9949e5baa063cc4c29" translate="yes" xml:space="preserve">
          <source>Indicates whether the original request body is passed to the FastCGI server. See also the &lt;a href=&quot;#fastcgi_pass_request_headers&quot;&gt;fastcgi_pass_request_headers&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청 본문이 FastCGI 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#fastcgi_pass_request_headers&quot;&gt;fastcgi_pass_request_headers&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="64f42c60f35f5e7d80ca5fc9dcdef54bfbb07240" translate="yes" xml:space="preserve">
          <source>Indicates whether the original request body is passed to the SCGI server. See also the &lt;a href=&quot;#scgi_pass_request_headers&quot;&gt;scgi_pass_request_headers&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청 본문이 SCGI 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#scgi_pass_request_headers&quot;&gt;scgi_pass_request_headers&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7ed9024280e9cb4d93ecb08ca4041b3be51fc313" translate="yes" xml:space="preserve">
          <source>Indicates whether the original request body is passed to the proxied server.</source>
          <target state="translated">원래 요청 본문이 프록시 서버로 전달되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="26cc6fb8f208ea99eaeeaba6202efa8f150a395a" translate="yes" xml:space="preserve">
          <source>Indicates whether the original request body is passed to the uwsgi server. See also the &lt;a href=&quot;#uwsgi_pass_request_headers&quot;&gt;uwsgi_pass_request_headers&lt;/a&gt; directive.</source>
          <target state="translated">원래 요청 본문이 uwsgi 서버로 전달되는지 여부를 나타냅니다. &lt;a href=&quot;#uwsgi_pass_request_headers&quot;&gt;uwsgi_pass_request_headers&lt;/a&gt; 지시문 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fc943be6378cd49efa3b286db579065c03cf2078" translate="yes" xml:space="preserve">
          <source>Indicates whether to look for each string to replace once or repeatedly.</source>
          <target state="translated">교체 할 각 문자열을 찾아야하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a64292826ef2667e8a2a9b0f607cdef4902d8ef2" translate="yes" xml:space="preserve">
          <source>Indicates whether to pass the error message obtained during the authentication on the backend to the client.</source>
          <target state="translated">백엔드에서 인증하는 동안 얻은 오류 메시지를 클라이언트에 전달할지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1fb5c2f714283c222aef131cc4f21a84ef43f985" translate="yes" xml:space="preserve">
          <source>Individual worker processes can be controlled with signals as well, though it is not required. The supported signals are:</source>
          <target state="translated">필요하지는 않지만 개별 작업자 프로세스도 신호로 제어 할 수 있습니다. 지원되는 신호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afaa1fdcec54bcd6180c1383ddcf694a754c3e40" translate="yes" xml:space="preserve">
          <source>Initially, the main request is active.</source>
          <target state="translated">처음에는 기본 요청이 활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="830defcc4bcc3af8285609c247eea75a4c96bace" translate="yes" xml:space="preserve">
          <source>Installation on FreeBSD</source>
          <target state="translated">FreeBSD에 설치</target>
        </trans-unit>
        <trans-unit id="22bb541dc6bc6ad8a4376cb73aaf6c129294f841" translate="yes" xml:space="preserve">
          <source>Installation on Linux</source>
          <target state="translated">리눅스에 설치</target>
        </trans-unit>
        <trans-unit id="a57976ed941c206f161b07d9b258affe2868f1d9" translate="yes" xml:space="preserve">
          <source>Installing as a Linux package</source>
          <target state="translated">Linux 패키지로 설치</target>
        </trans-unit>
        <trans-unit id="ca98ef2d18bbb94eac217dcda54b785675b648c3" translate="yes" xml:space="preserve">
          <source>Installing nginx</source>
          <target state="translated">nginx 설치</target>
        </trans-unit>
        <trans-unit id="f9e6d8dbbfeaabf14c3c8b092dcfad8e866bd661" translate="yes" xml:space="preserve">
          <source>Installs a Perl handler for the specified variable.</source>
          <target state="translated">지정된 변수에 대한 Perl 핸들러를 설치합니다.</target>
        </trans-unit>
        <trans-unit id="1eeb76a01d425a876b1893278cc936ff64d2e3f4" translate="yes" xml:space="preserve">
          <source>Instead of creating a new thread for each task, nginx implements a &lt;a href=&quot;../ngx_core_module#thread_pool&quot;&gt;thread_pool&lt;/a&gt; strategy. Multiple thread pools may be configured for different purposes (for example, performing I/O on different sets of disks). Each thread pool is created at startup and contains a limited number of threads that process a queue of tasks. When a task is completed, a predefined completion handler is called.</source>
          <target state="translated">nginx는 각 작업마다 새로운 스레드를 생성하는 대신 &lt;a href=&quot;../ngx_core_module#thread_pool&quot;&gt;thread_pool&lt;/a&gt; 전략을 구현합니다 . 여러 스레드 풀이 다른 목적으로 구성 될 수 있습니다 (예 : 다른 디스크 세트에서 I / O 수행). 각 스레드 풀은 시작시 작성되며 태스크 큐를 처리하는 제한된 수의 스레드를 포함합니다. 작업이 완료되면 사전 정의 된 완료 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="365ae55cb62bd4d3e2455e93e39e17507cffd1bf" translate="yes" xml:space="preserve">
          <source>Instead of dealing with malloc/free approach which is error prone, learn how to use nginx &lt;a href=&quot;#pool&quot;&gt;pools&lt;/a&gt;. A pool is created and tied to an object - &lt;a href=&quot;#http_conf&quot;&gt;configuration&lt;/a&gt;, &lt;a href=&quot;#cycle&quot;&gt;cycle&lt;/a&gt;, &lt;a href=&quot;#connection&quot;&gt;connection&lt;/a&gt;, or &lt;a href=&quot;#http_request&quot;&gt;HTTP request&lt;/a&gt;. When the object is destroyed, the associated pool is destroyed too. So when working with an object, it is possible to allocate the amount needed from the corresponding pool and don't care about freeing memory even in case of errors.</source>
          <target state="translated">오류가 발생하기 쉬운 malloc / free 접근법을 처리하는 대신 nginx &lt;a href=&quot;#pool&quot;&gt;풀&lt;/a&gt; 사용 방법을 배우십시오 . 풀이 만들어져 개체 &lt;a href=&quot;#http_conf&quot;&gt;구성&lt;/a&gt; , &lt;a href=&quot;#cycle&quot;&gt;주기&lt;/a&gt; , &lt;a href=&quot;#connection&quot;&gt;연결&lt;/a&gt; 또는 &lt;a href=&quot;#http_request&quot;&gt;HTTP 요청에 &lt;/a&gt;연결 됩니다. 객체가 파괴되면 관련 풀도 파괴됩니다. 따라서 객체로 작업 할 때 해당 풀에서 필요한 양을 할당 할 수 있으며 오류가 발생하더라도 메모리를 확보하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="504864385d123883aeb2e747997f455d1f162a01" translate="yes" xml:space="preserve">
          <source>Instructs whether cache entries that match a &lt;a href=&quot;#fastcgi_cache_purge&quot;&gt;wildcard key&lt;/a&gt; will be removed from the disk by the cache purger (1.7.12). Setting the parameter to &lt;code&gt;on&lt;/code&gt; (default is &lt;code&gt;off&lt;/code&gt;) will activate the &amp;ldquo;cache purger&amp;rdquo; process that permanently iterates through all cache entries and deletes the entries that match the wildcard key.</source>
          <target state="translated">&lt;a href=&quot;#fastcgi_cache_purge&quot;&gt;와일드 카드 키&lt;/a&gt; 와 일치하는 캐시 항목이 캐시 제거기 (1.7.12)에 의해 디스크에서 제거 되는지 여부를 지시합니다 . 매개 변수를 &lt;code&gt;on&lt;/code&gt; (기본값은 &lt;code&gt;off&lt;/code&gt; ) 으로 설정하면 모든 캐시 항목을 영구적으로 반복하고 와일드 카드 키와 일치하는 항목을 삭제하는 &quot;캐시 제거기&quot;프로세스가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="90ab5e9b05f8d8200c7659e1cd7fb067d3b90b0c" translate="yes" xml:space="preserve">
          <source>Instructs whether cache entries that match a &lt;a href=&quot;#proxy_cache_purge&quot;&gt;wildcard key&lt;/a&gt; will be removed from the disk by the cache purger (1.7.12). Setting the parameter to &lt;code&gt;on&lt;/code&gt; (default is &lt;code&gt;off&lt;/code&gt;) will activate the &amp;ldquo;cache purger&amp;rdquo; process that permanently iterates through all cache entries and deletes the entries that match the wildcard key.</source>
          <target state="translated">&lt;a href=&quot;#proxy_cache_purge&quot;&gt;와일드 카드 키&lt;/a&gt; 와 일치하는 캐시 항목이 캐시 제거기 (1.7.12)에 의해 디스크에서 제거 되는지 여부를 지시합니다 . 매개 변수를 &lt;code&gt;on&lt;/code&gt; (기본값은 &lt;code&gt;off&lt;/code&gt; ) 으로 설정하면 모든 캐시 항목을 영구적으로 반복하고 와일드 카드 키와 일치하는 항목을 삭제하는 &quot;캐시 제거기&quot;프로세스가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5a9aaa2524527db194c03f8ba6125dc5c871a1" translate="yes" xml:space="preserve">
          <source>Instructs whether cache entries that match a &lt;a href=&quot;#scgi_cache_purge&quot;&gt;wildcard key&lt;/a&gt; will be removed from the disk by the cache purger (1.7.12). Setting the parameter to &lt;code&gt;on&lt;/code&gt; (default is &lt;code&gt;off&lt;/code&gt;) will activate the &amp;ldquo;cache purger&amp;rdquo; process that permanently iterates through all cache entries and deletes the entries that match the wildcard key.</source>
          <target state="translated">&lt;a href=&quot;#scgi_cache_purge&quot;&gt;와일드 카드 키&lt;/a&gt; 와 일치하는 캐시 항목이 캐시 제거기 (1.7.12)에 의해 디스크에서 제거 되는지 여부를 지시합니다 . 매개 변수를 &lt;code&gt;on&lt;/code&gt; (기본값은 &lt;code&gt;off&lt;/code&gt; ) 으로 설정하면 모든 캐시 항목을 영구적으로 반복하고 와일드 카드 키와 일치하는 항목을 삭제하는 &quot;캐시 제거기&quot;프로세스가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="7d262e3fa0fd8ccbfbfa45d5d7e103e9c46218e2" translate="yes" xml:space="preserve">
          <source>Instructs whether cache entries that match a &lt;a href=&quot;#uwsgi_cache_purge&quot;&gt;wildcard key&lt;/a&gt; will be removed from the disk by the cache purger (1.7.12). Setting the parameter to &lt;code&gt;on&lt;/code&gt; (default is &lt;code&gt;off&lt;/code&gt;) will activate the &amp;ldquo;cache purger&amp;rdquo; process that permanently iterates through all cache entries and deletes the entries that match the wildcard key.</source>
          <target state="translated">&lt;a href=&quot;#uwsgi_cache_purge&quot;&gt;와일드 카드 키&lt;/a&gt; 와 일치하는 캐시 항목이 캐시 제거기 (1.7.12)에 의해 디스크에서 제거 되는지 여부를 지시합니다 . 매개 변수를 &lt;code&gt;on&lt;/code&gt; (기본값은 &lt;code&gt;off&lt;/code&gt; ) 으로 설정하면 모든 캐시 항목을 영구적으로 반복하고 와일드 카드 키와 일치하는 항목을 삭제하는 &quot;캐시 제거기&quot;프로세스가 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="724b5422dc05c791b8cf0befd732972c0409722e" translate="yes" xml:space="preserve">
          <source>Integers</source>
          <target state="translated">Integers</target>
        </trans-unit>
        <trans-unit id="0df795c709bef2c10ca638eb82b821a023b8fec3" translate="yes" xml:space="preserve">
          <source>Internal Implementation</source>
          <target state="translated">내부 구현</target>
        </trans-unit>
        <trans-unit id="7c18d101768819650022703d309d09de77a757cd" translate="yes" xml:space="preserve">
          <source>Internal Redirect</source>
          <target state="translated">내부 리디렉션</target>
        </trans-unit>
        <trans-unit id="ec6365d1aa54df042bc6a6b2b502d05b3a8e4842" translate="yes" xml:space="preserve">
          <source>Internal implementation of the interval depends on the method used:</source>
          <target state="translated">간격의 내부 구현은 사용 된 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="44981251410f7dba87d1ea4b2463e26056ae1813" translate="yes" xml:space="preserve">
          <source>Internal nginx error code.</source>
          <target state="translated">내부 nginx 오류 코드.</target>
        </trans-unit>
        <trans-unit id="745991d6216ddebb862203158ed712a638c361fa" translate="yes" xml:space="preserve">
          <source>Internationalized domain names (&lt;a href=&quot;https://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;IDNs&lt;/a&gt;) should be specified using an ASCII (Punycode) representation in the &lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; directive:</source>
          <target state="translated">다국어 도메인 이름 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Internationalized_domain_name&quot;&gt;IDN&lt;/a&gt; )은 &lt;a href=&quot;ngx_http_core_module#server_name&quot;&gt;server_name&lt;/a&gt; 지시문 에서 ASCII (Punycode) 표현을 사용하여 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c388fdaa1c1e1a1748a3b067d43230ffe79d0a3" translate="yes" xml:space="preserve">
          <source>Internationalized names</source>
          <target state="translated">국제화 된 이름</target>
        </trans-unit>
        <trans-unit id="0d44a4aaf72ac5ad0b351d60ca882b7531697334" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of 64-bit numbers and swaps byte order in-place. Throws an error if &lt;a href=&quot;#buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 8.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 64 비트 숫자의 배열로 해석 하고 그 자리에서 바이트 순서를 바꿉니다. &lt;a href=&quot;#buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 8의 배수가 아닌 경우 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="c9334f62b287158b541948e8db6654c88cd00532" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 16-bit numbers and swaps the byte order in-place. Throws an error if &lt;a href=&quot;#buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 2.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 16 비트 숫자의 배열로 해석 하고 그 자리에서 바이트 순서를 바꿉니다. &lt;a href=&quot;#buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 2의 배수가 아니면 오류를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="7bd79100c752fa5cfaba36e5e235025593eb6808" translate="yes" xml:space="preserve">
          <source>Interprets &lt;code&gt;buf&lt;/code&gt; as an array of unsigned 32-bit numbers and swaps the byte order in-place. Throws an error if &lt;a href=&quot;#buf_length&quot;&gt;&lt;code&gt;buf.length&lt;/code&gt;&lt;/a&gt; is not a multiple of 4.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 를 부호없는 32 비트 숫자의 배열로 해석 하고 그 자리에서 바이트 순서를 바꿉니다. &lt;a href=&quot;#buf_length&quot;&gt; &lt;code&gt;buf.length&lt;/code&gt; &lt;/a&gt; 가 4의 배수가 아닌 경우 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="7bd049295151ed062f1e5a1fd0137742be65e3b4" translate="yes" xml:space="preserve">
          <source>Introduction article on DTrace pid provider</source>
          <target state="translated">DTrace pid provider 소개 기사</target>
        </trans-unit>
        <trans-unit id="b3fd41aec7e954839fdf7f085957e6ce3c7193e0" translate="yes" xml:space="preserve">
          <source>Is it possible to implement a desired feature using already &lt;a href=&quot;../index&quot;&gt;available modules&lt;/a&gt;?</source>
          <target state="translated">이미 &lt;a href=&quot;../index&quot;&gt;사용 가능한 모듈을&lt;/a&gt; 사용하여 원하는 기능을 구현할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="fa3baf4801e02e7a943f03d778d885ec9b13752f" translate="yes" xml:space="preserve">
          <source>Is it possible to solve an issue using built-in scripting languages, such as &lt;a href=&quot;../http/ngx_http_perl_module&quot;&gt;Perl&lt;/a&gt; or &lt;a href=&quot;../njs/index&quot;&gt;njs&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;../http/ngx_http_perl_module&quot;&gt;Perl&lt;/a&gt; 또는 &lt;a href=&quot;../njs/index&quot;&gt;njs&lt;/a&gt; 와 같은 내장 스크립팅 언어를 사용하여 문제를 해결할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="1a04b02f39b647d542666abb927b1d67ddde22c0" translate="yes" xml:space="preserve">
          <source>It allows this server to process requests without the &amp;ldquo;Host&amp;rdquo; header field &amp;mdash; instead of the default server &amp;mdash; for the given address:port pair. This is the default setting.</source>
          <target state="translated">이 서버는 지정된 주소 : 포트 쌍에 대해 &quot;기본&quot;서버 대신 &quot;호스트&quot;헤더 필드없이 요청을 처리 할 수 ​​있습니다. 이것이 기본 설정입니다.</target>
        </trans-unit>
        <trans-unit id="1860d651ff3cdd834e35458565c1f6849186309e" translate="yes" xml:space="preserve">
          <source>It handles requests with the &lt;code&gt;start&lt;/code&gt; argument in the request URI&amp;rsquo;s query string specially, by sending back the contents of a file starting from the requested byte offset and with the prepended FLV header.</source>
          <target state="translated">요청 된 바이트 오프셋에서 시작하고 앞에 붙은 FLV 헤더로 파일의 내용을 다시 보내어 요청 URI의 쿼리 문자열에서 &lt;code&gt;start&lt;/code&gt; 인수로 요청을 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="0752ce6c879f21c8a30e870d4f9aed5b0b2ab6e9" translate="yes" xml:space="preserve">
          <source>It is also possible to enable the debugging log for &lt;a href=&quot;ngx_core_module#debug_connection&quot;&gt;selected client addresses&lt;/a&gt; only:</source>
          <target state="translated">&lt;a href=&quot;ngx_core_module#debug_connection&quot;&gt;선택한 클라이언트 주소에&lt;/a&gt; 대해서만 디버깅 로그를 활성화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ec33d96c5e72e1f7b4c1be6e4f48bac2137c472" translate="yes" xml:space="preserve">
          <source>It is also possible to influence nginx load balancing algorithms even further by using server weights.</source>
          <target state="translated">서버 가중치를 사용하여 nginx로드 밸런싱 알고리즘에 더욱 영향을 줄 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="564eb48211bb1d169059e0a0dd4f0f39cd411aaf" translate="yes" xml:space="preserve">
          <source>It is also possible to redirect a request to a new location at any point by calling one of &lt;code&gt;ngx_http_internal_redirect(r, uri, args)&lt;/code&gt; or &lt;code&gt;ngx_http_named_location(r, name)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ngx_http_internal_redirect(r, uri, args)&lt;/code&gt; 또는 &lt;code&gt;ngx_http_named_location(r, name)&lt;/code&gt; 중 하나를 호출하여 언제든지 새로운 위치로 요청을 리디렉션 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d449aafd2c8ee6edeaba70efe3d1894c3e82153" translate="yes" xml:space="preserve">
          <source>It is also possible to specify an empty server name (0.7.11):</source>
          <target state="translated">빈 서버 이름 (0.7.11)을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4326d05fbd07996aa94e584363ae402400918eb6" translate="yes" xml:space="preserve">
          <source>It is also possible to use URL redirects for error processing:</source>
          <target state="translated">오류 처리를 위해 URL 리디렉션을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f8c135e1d7443c69a312c7377eb9198c3f155dd" translate="yes" xml:space="preserve">
          <source>It is also possible to use regular expressions in server names, preceding the name with a tilde (&amp;ldquo;&lt;code&gt;~&lt;/code&gt;&amp;rdquo;):</source>
          <target state="translated">이름 앞에 물결표 (&amp;ldquo; &lt;code&gt;~&lt;/code&gt; &amp;rdquo;)를 붙여 서버 이름에 정규식을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="51fdfe7d8ea9d7c401a96c9ece22077ad004544b" translate="yes" xml:space="preserve">
          <source>It is better to place a certificate file with several names and its private key file at the</source>
          <target state="translated">여러 이름의 인증서 파일과 개인 키 파일을</target>
        </trans-unit>
        <trans-unit id="163c23c33a3d389e289985c8e43a6ba310343f8c" translate="yes" xml:space="preserve">
          <source>It is possible to add wildcard keys using the &lt;code&gt;NGX_HASH_WILDCARD_KEY&lt;/code&gt; flag:</source>
          <target state="translated">&lt;code&gt;NGX_HASH_WILDCARD_KEY&lt;/code&gt; 플래그를 사용하여 와일드 카드 키를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0af7d7e636d1585bc1961c84bdb6d89b12ecb499" translate="yes" xml:space="preserve">
          <source>It is possible to configure a single server that handles both HTTP and HTTPS requests:</source>
          <target state="translated">HTTP 및 HTTPS 요청을 모두 처리하는 단일 서버를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a73ca1ef8bd9f80e80223929073bfb7218b993c" translate="yes" xml:space="preserve">
          <source>It is possible to offload into a separate thread tasks that would otherwise block the nginx worker process. For example, nginx can be configured to use threads to perform &lt;a href=&quot;../http/ngx_http_core_module#aio&quot;&gt;file I/O&lt;/a&gt;. Another use case is a library that doesn't have asynchronous interface and thus cannot be normally used with nginx. Keep in mind that the threads interface is a helper for the existing asynchronous approach to processing client connections, and by no means intended as a replacement.</source>
          <target state="translated">nginx 작업자 프로세스를 차단하는 별도의 스레드 작업으로 오프로드 할 수 있습니다. 예를 들어, nginx는 스레드를 사용하여 &lt;a href=&quot;../http/ngx_http_core_module#aio&quot;&gt;파일 I / O&lt;/a&gt; 를 수행하도록 구성 할 수 있습니다 . 또 다른 유스 케이스는 비동기 인터페이스가 없으므로 일반적으로 nginx와 함께 사용할 수없는 라이브러리입니다. 스레드 인터페이스는 클라이언트 연결 처리에 대한 기존의 비동기식 접근 방식을위한 도우미이며 결코 교체 용이 아님을 명심하십시오.</target>
        </trans-unit>
        <trans-unit id="2080dbfeed98435c058e5958a50db2cb3e37b236" translate="yes" xml:space="preserve">
          <source>It is possible to specify either a redirect URL (for codes 301, 302, 303, 307, and 308) or the response body text (for other codes) as the second argument</source>
          <target state="translated">리디렉션 URL (코드 301, 302, 303, 307 및 308의 경우) 또는 응답 본문 텍스트 (다른 ​​코드의 경우)를 두 번째 인수로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4d6d80fee4e68f8eb5e4c2ab3f266cc17fceae" translate="yes" xml:space="preserve">
          <source>It is possible to specify several stylesheets. They will be applied sequentially in the specified order.</source>
          <target state="translated">여러 스타일 시트를 지정할 수 있습니다. 지정된 순서대로 순차적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="22a85a31e995d653da7c704bac60514b07e77d04" translate="yes" xml:space="preserve">
          <source>It is possible to use nginx as a very efficient HTTP load balancer to distribute traffic to several application servers and to improve performance, scalability and reliability of web applications with nginx.</source>
          <target state="translated">nginx를 매우 효율적인 HTTP 로드 밸런서로 사용하여 트래픽을 여러 응용 프로그램 서버로 분산하고, nginx를 통한 웹 응용 프로그램의 성능, 확장성 및 안정성을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cdfa291112d44446b1c5d3f0ba587c077d9eb25" translate="yes" xml:space="preserve">
          <source>It is recommended to avoid using threads in nginx because it will definitely break things: most nginx functions are not thread-safe. It is expected that a thread will be executing only system calls and thread-safe library functions. If you need to run some code that is not related to client request processing, the proper way is to schedule a timer in the &lt;code&gt;init_process&lt;/code&gt; module handler and perform required actions in timer handler. Internally nginx makes use of &lt;a href=&quot;#threads&quot;&gt;threads&lt;/a&gt; to boost IO-related operations, but this is a special case with a lot of limitations.</source>
          <target state="translated">nginx에서 스레드를 사용하지 않는 것이 좋습니다. 대부분의 nginx 함수는 스레드로부터 안전하지 않습니다. 스레드는 시스템 호출 및 스레드 안전 라이브러리 함수 만 실행합니다. 클라이언트 요청 처리와 관련이없는 일부 코드를 실행해야하는 경우 올바른 방법은 &lt;code&gt;init_process&lt;/code&gt; 모듈 핸들러 에서 타이머를 스케줄하고 타이머 핸들러에서 필요한 조치를 수행하는 것입니다. 내부적으로 nginx는 &lt;a href=&quot;#threads&quot;&gt;스레드&lt;/a&gt; 를 사용 하여 IO 관련 작업을 향상 시키지만 많은 제한이있는 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="488680f4614db9e5c11b2bd3e7f601ebbac30e48" translate="yes" xml:space="preserve">
          <source>It is similarly possible to use weights with the least-connected and ip-hash load balancing in the recent versions of nginx.</source>
          <target state="translated">최신 버전의 nginx에서 최소 연결 및 ip-hash로드 밸런싱으로 가중치를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01bd8dfa9d686876c22b2cb8763b6885d3d947ff" translate="yes" xml:space="preserve">
          <source>It makes sense to specify the extensions supported by the IMAP backends to which the clients are proxied (if these extensions are related to commands used after the authentication, when nginx transparently proxies a client connection to the backend).</source>
          <target state="translated">클라이언트가 프록시되는 IMAP 백엔드에서 지원하는 확장을 지정하는 것이 좋습니다 (이 확장이 인증 후 사용 된 명령과 관련이있는 경우, nginx가 투명하게 클라이언트 연결을 백엔드에 프록시 할 때).</target>
        </trans-unit>
        <trans-unit id="b3102688be1ec987e49d3801b5047e1d7d4157b0" translate="yes" xml:space="preserve">
          <source>It makes sense to specify the extensions supported by the MTA to which the clients are proxied (if these extensions are related to commands used after the authentication, when nginx transparently proxies the client connection to the backend).</source>
          <target state="translated">클라이언트가 프록시되는 MTA가 지원하는 확장을 지정하는 것이 좋습니다 (이 확장이 인증 후 사용 된 명령과 관련이있는 경우, nginx가 클라이언트 연결을 백엔드에 투명하게 프록시 할 때).</target>
        </trans-unit>
        <trans-unit id="cb912421577eadc3aa9f950ff0d4eaee76565418" translate="yes" xml:space="preserve">
          <source>It makes sense to specify the extensions supported by the POP3 backends to which the clients are proxied (if these extensions are related to commands used after the authentication, when nginx transparently proxies the client connection to the backend).</source>
          <target state="translated">클라이언트가 프록시되는 POP3 백엔드에서 지원하는 확장을 지정하는 것이 좋습니다 (이 확장이 인증 후 사용 된 명령과 관련이있는 경우, nginx가 클라이언트 연결을 백엔드에 투명하게 프록시 할 때).</target>
        </trans-unit>
        <trans-unit id="02ce498191579d9754a111ff64a0f9a1709da4c8" translate="yes" xml:space="preserve">
          <source>It returns &lt;code&gt;NGX_ERROR&lt;/code&gt; in case of internal error (for example, failed memory allocation) or &lt;code&gt;NGX_OK&lt;/code&gt; otherwise. To learn the status of variable evaluation, inspect the flags in &lt;code&gt;ngx_http_variable_value_t&lt;/code&gt; (see the description &lt;a href=&quot;#http_existing_variables&quot;&gt;above&lt;/a&gt;).</source>
          <target state="translated">이것은 반환 &lt;code&gt;NGX_ERROR&lt;/code&gt; 를 내부 오류 (예를 들면, 메모리 할당 실패) 또는시 &lt;code&gt;NGX_OK&lt;/code&gt; 그렇지. 변수 평가 상태를 확인하려면 &lt;code&gt;ngx_http_variable_value_t&lt;/code&gt; 의 플래그를 검사하십시오 ( &lt;a href=&quot;#http_existing_variables&quot;&gt;위&lt;/a&gt; 설명 참조 ).</target>
        </trans-unit>
        <trans-unit id="8079fc42441e5d0fa9058568d8c789330856482b" translate="yes" xml:space="preserve">
          <source>It should be kept in mind that due to the HTTPS protocol limitations for maximum interoperability virtual servers should listen on &lt;a href=&quot;configuring_https_servers#name_based_https_servers&quot;&gt;different IP addresses&lt;/a&gt;.</source>
          <target state="translated">최대 상호 운용성을위한 HTTPS 프로토콜 제한으로 인해 가상 서버는 &lt;a href=&quot;configuring_https_servers#name_based_https_servers&quot;&gt;다른 IP 주소를&lt;/a&gt; 수신해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="807f813af7b88ff756dff310080291d337fbca89" translate="yes" xml:space="preserve">
          <source>It should be kept in mind that this number includes all connections (e.g. connections with proxied servers, among others), not only connections with clients. Another consideration is that the actual number of simultaneous connections cannot exceed the current limit on the maximum number of open files, which can be changed by &lt;a href=&quot;#worker_rlimit_nofile&quot;&gt;worker_rlimit_nofile&lt;/a&gt;.</source>
          <target state="translated">이 숫자에는 클라이언트와의 연결뿐만 아니라 모든 연결 (예 : 프록시 서버와의 연결)이 포함됩니다. 또 다른 고려 사항은 실제 동시 연결 수가 최대 열린 파일 수에 대한 현재 한계를 초과 할 수 없으며 &lt;a href=&quot;#worker_rlimit_nofile&quot;&gt;worker_rlimit_nofile에&lt;/a&gt; 의해 변경 될 수 있다는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f283577b2ccdcbf04a62dc0687228cb3cb69f15a" translate="yes" xml:space="preserve">
          <source>It should be noted that if a response is received in a subrequest then the conversion from the response charset to the main request charset is always performed, regardless of the &lt;code&gt;override_charset&lt;/code&gt; directive setting.</source>
          <target state="translated">하위 요청에서 응답이 수신되면 &lt;code&gt;override_charset&lt;/code&gt; 지시문 설정에 관계없이 응답 문자 세트에서 기본 요청 문자 세트로의 변환이 항상 수행 됩니다.</target>
        </trans-unit>
        <trans-unit id="75650cff981801640e80d5234163c088b5e1ddae" translate="yes" xml:space="preserve">
          <source>It should be noted that in the example above DTrace requires some knowledge about the &lt;code&gt;ngx_http_process_request&lt;/code&gt; structure. Unfortunately while it is possible to use a specific &lt;code&gt;#include&lt;/code&gt; directive in the DTrace script and then pass it to a C preprocessor (with the &lt;code&gt;-C&lt;/code&gt; flag), that doesn&amp;rsquo;t really work. Due to a lot of cross dependencies, almost all nginx header files have to be included. In turn, based on &lt;code&gt;configure&lt;/code&gt; script settings, nginx headers will include PCRE, OpenSSL and a variety of system header files. While in theory all those header files related to a specific nginx build might be included in DTrace script preprocessing and compilation, in reality DTrace script most probably will fail to compile because of unknown syntax in some header files.</source>
          <target state="translated">위의 예에서 DTrace는 &lt;code&gt;ngx_http_process_request&lt;/code&gt; 구조 에 대한 지식이 필요합니다 . 불행히도 DTrace 스크립트에서 특정 &lt;code&gt;#include&lt;/code&gt; 지시문 을 사용하고 이를 C 전 처리기 ( &lt;code&gt;-C&lt;/code&gt; 플래그 사용)에 전달할 수 는 있지만 실제로는 작동하지 않습니다. 많은 상호 종속성으로 인해 거의 모든 nginx 헤더 파일이 포함되어야합니다. 차례로 &lt;code&gt;configure&lt;/code&gt; 를 기반으로스크립트 설정에서 nginx 헤더에는 PCRE, OpenSSL 및 다양한 시스템 헤더 파일이 포함됩니다. 이론적으로 특정 nginx 빌드와 관련된 모든 헤더 파일이 DTrace 스크립트 전처리 및 컴파일에 포함될 수 있지만 실제로 DTrace 스크립트는 일부 헤더 파일의 구문이 알려지지 않아 컴파일에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="6df820dc2ed28b4b0311df6f7e80a6382dd5165d" translate="yes" xml:space="preserve">
          <source>It should be noted that the old master process does not close its listen sockets, and it can be managed to start its worker processes again if needed. If for some reason the new executable file works unacceptably, one of the following can be done:</source>
          <target state="translated">이전 마스터 프로세스는 청취 소켓을 닫지 않으며 필요한 경우 작업자 프로세스를 다시 시작하도록 관리 할 수 ​​있습니다. 어떤 이유로 새 실행 파일이 허용되지 않으면 다음 중 하나를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d47731c746faeaac66145bdca8e7f4d6246455f" translate="yes" xml:space="preserve">
          <source>It should be noted that timed out keep-alive connections are closed normally.</source>
          <target state="translated">시간 초과 연결 유지 연결은 정상적으로 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="767f1d710d68e3f6197ad2a0b2dbb8aa0bf94eba" translate="yes" xml:space="preserve">
          <source>It should be noted that using an index file causes an internal redirect, and the request can be processed in a different location. For example, with the following configuration:</source>
          <target state="translated">색인 파일을 사용하면 내부 경로 재 지정이 발생하며 요청은 다른 위치에서 처리 될 수 있습니다. 예를 들어 다음 구성을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="22f8c6b004ae9e320c235445eca3dab1d5c516eb" translate="yes" xml:space="preserve">
          <source>It should be particularly noted that the &lt;code&gt;keepalive&lt;/code&gt; directive does not limit the total number of connections to upstream servers that an nginx worker process can open. The &lt;code&gt;&lt;i&gt;connections&lt;/i&gt;&lt;/code&gt; parameter should be set to a number small enough to let upstream servers process new incoming connections as well.</source>
          <target state="translated">특히 주목해야한다 &lt;code&gt;keepalive&lt;/code&gt; 지시가의 nginx 작업자 프로세스가 열 수있는 서버를 상류 연결의 총 수를 제한하지 않습니다. &lt;code&gt;&lt;i&gt;connections&lt;/i&gt;&lt;/code&gt; 업스트림 서버를 수 있도록 수있을 정도로 작은으로 설정해야 매개 변수는 아니라 새 들어오는 연결을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="73f8a66cb43e6cbb1730603a48a8fc76b8c53cba" translate="yes" xml:space="preserve">
          <source>It will be a match for requests starting with &lt;code&gt;/images/&lt;/code&gt; (&lt;code&gt;location /&lt;/code&gt; also matches such requests, but has shorter prefix).</source>
          <target state="translated">&lt;code&gt;/images/&lt;/code&gt; 시작하는 요청과 일치합니다 ( &lt;code&gt;location /&lt;/code&gt; 또한 해당 요청과 일치하지만 접두사가 더 짧습니다).</target>
        </trans-unit>
        <trans-unit id="031a4e76f0b39d0df073d934da5fc48da8d737e5" translate="yes" xml:space="preserve">
          <source>JSON</source>
          <target state="translated">JSON</target>
        </trans-unit>
        <trans-unit id="302e3e4f4565ce9b50c814a45e29a4d3634d3c0f" translate="yes" xml:space="preserve">
          <source>Keep alignment identical among different structures in the file. A structure that points to itself has the name, ending with &amp;ldquo;&lt;code&gt;_s&lt;/code&gt;&amp;rdquo;. Adjacent structure definitions are separated with two empty lines:</source>
          <target state="translated">파일의 다른 구조간에 정렬을 동일하게 유지하십시오. 자체를 가리키는 구조의 이름은 &quot; &lt;code&gt;_s&lt;/code&gt; &quot;로 끝납니다 . 인접한 구조 정의는 두 개의 빈 줄로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="f5025143a89e9b224781aa62468c0e2c91c66496" translate="yes" xml:space="preserve">
          <source>Known Issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="b05203cf89b60eb36609a1a8b7f3cafe0927486a" translate="yes" xml:space="preserve">
          <source>Known issues</source>
          <target state="translated">알려진 문제</target>
        </trans-unit>
        <trans-unit id="2228985493d9e43e461c7be5525529248735ad9c" translate="yes" xml:space="preserve">
          <source>Labels</source>
          <target state="translated">Labels</target>
        </trans-unit>
        <trans-unit id="919d2bb6225a8f1db8f2b2daf03d37ffeacbd75a" translate="yes" xml:space="preserve">
          <source>Labels are surrounded with empty lines and are indented at the previous level:</source>
          <target state="translated">레이블은 빈 줄로 둘러싸여 있으며 이전 레벨에서 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="fd58fa9befbddd5828629a74e280d882468b2a2a" translate="yes" xml:space="preserve">
          <source>Last but not least it is necessary to add definitions of two member structures (&lt;code&gt;ngx_http_headers_in_t&lt;/code&gt;, &lt;code&gt;ngx_http_headers_out_t&lt;/code&gt;), declarations of callback functions and definitions of constants.</source>
          <target state="translated">마지막으로 두 개의 멤버 구조 ( &lt;code&gt;ngx_http_headers_in_t&lt;/code&gt; , &lt;code&gt;ngx_http_headers_out_t&lt;/code&gt; ), 콜백 함수 선언 및 상수 정의에 대한 정의를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="aeb89b6eedfdbf0bde5384a031b47f04b68d9d10" translate="yes" xml:space="preserve">
          <source>Last but not least, &lt;a href=&quot;https://www.nginx.com/products/application-load-balancing/&quot;&gt; application load balancing&lt;/a&gt;, &lt;a href=&quot;https://www.nginx.com/products/application-health-checks/&quot;&gt; application health checks&lt;/a&gt;, &lt;a href=&quot;https://www.nginx.com/products/live-activity-monitoring/&quot;&gt; activity monitoring&lt;/a&gt; and &lt;a href=&quot;https://www.nginx.com/products/on-the-fly-reconfiguration/&quot;&gt; on-the-fly reconfiguration&lt;/a&gt; of server groups are available as part of our paid NGINX Plus subscriptions.</source>
          <target state="translated">마지막으로, &lt;a href=&quot;https://www.nginx.com/products/application-load-balancing/&quot;&gt;응용 프로그램 부하 분산&lt;/a&gt; , &lt;a href=&quot;https://www.nginx.com/products/application-health-checks/&quot;&gt;응용 프로그램 상태 확인&lt;/a&gt; , &lt;a href=&quot;https://www.nginx.com/products/live-activity-monitoring/&quot;&gt;활동 모니터링&lt;/a&gt; 및&lt;a href=&quot;https://www.nginx.com/products/on-the-fly-reconfiguration/&quot;&gt;&lt;/a&gt; 유료 NGINX Plus 가입의 일부로 서버 그룹의 즉각적인 재구성 이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="eac9ef0ee34afc7025b1de86c68f69648d6c279f" translate="yes" xml:space="preserve">
          <source>Least connected load balancing</source>
          <target state="translated">최소 연결 로드 밸런싱</target>
        </trans-unit>
        <trans-unit id="33ebc367d371ffd35495e36cb61d734551e732a9" translate="yes" xml:space="preserve">
          <source>Least-connected load balancing in nginx is activated when the &lt;a href=&quot;ngx_http_upstream_module#least_conn&quot;&gt; least_conn&lt;/a&gt; directive is used as part of the server group configuration:</source>
          <target state="translated">nginx에서 최소 연결로드 밸런싱이 최소 &lt;a href=&quot;ngx_http_upstream_module#least_conn&quot;&gt;_conn&lt;/a&gt;서버 그룹 구성의 일부로 지시문을 사용 .</target>
        </trans-unit>
        <trans-unit id="0eeb8d3faf68bcc1b581a94886e68794327920f8" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s illustrate the above by an example:</source>
          <target state="translated">위의 예를 예로 들어 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="36f6da3e0c880eca422b63dede4f2d516cc5799b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s illustrate this by example. Imagine that nginx is run on FreeBSD and the command</source>
          <target state="translated">이것을 예로 들어 설명하겠습니다. nginx가 FreeBSD와 명령에서 실행된다고 상상해보십시오</target>
        </trans-unit>
        <trans-unit id="a04f8801fd6c22091f0c522f8763dfff6c9d610b" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at a more complex configuration where some virtual servers listen on different addresses:</source>
          <target state="translated">일부 가상 서버가 다른 주소에서 수신 대기하는보다 복잡한 구성을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="49886e718ce7f3956fc1fc8367b775cde536d7d7" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s use DTrace script example above and see what structure definitions it needs to work properly.</source>
          <target state="translated">위의 DTrace 스크립트 예제를 사용하고 제대로 작동하는 데 필요한 구조 정의를 보자.</target>
        </trans-unit>
        <trans-unit id="4a8cef2fcce8f7f06cd4dd458cde5b340186739f" translate="yes" xml:space="preserve">
          <source>Let's call our code at the end of a file:</source>
          <target state="translated">파일 끝에있는 코드를 호출 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="33e65cc383aa12ce04daaa11f32f72dd0284e757" translate="yes" xml:space="preserve">
          <source>Let's run the file using node to make sure things still work:</source>
          <target state="translated">노드를 사용하여 파일을 실행하여 계속 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSD 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="59bd6e1cf6b8ff76fb7668142a281b55bcdd5868" translate="yes" xml:space="preserve">
          <source>Limits allowed HTTP methods inside a location. The &lt;code&gt;&lt;i&gt;method&lt;/i&gt;&lt;/code&gt; parameter can be one of the following: &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;, &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt;, &lt;code&gt;MKCOL&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;MOVE&lt;/code&gt;, &lt;code&gt;OPTIONS&lt;/code&gt;, &lt;code&gt;PROPFIND&lt;/code&gt;, &lt;code&gt;PROPPATCH&lt;/code&gt;, &lt;code&gt;LOCK&lt;/code&gt;, &lt;code&gt;UNLOCK&lt;/code&gt;, or &lt;code&gt;PATCH&lt;/code&gt;. Allowing the &lt;code&gt;GET&lt;/code&gt; method makes the &lt;code&gt;HEAD&lt;/code&gt; method also allowed. Access to other methods can be limited using the &lt;a href=&quot;ngx_http_access_module&quot;&gt;ngx_http_access_module&lt;/a&gt;, &lt;a href=&quot;ngx_http_auth_basic_module&quot;&gt;ngx_http_auth_basic_module&lt;/a&gt;, and &lt;a href=&quot;ngx_http_auth_jwt_module&quot;&gt;ngx_http_auth_jwt_module&lt;/a&gt; (1.13.10) modules directives:</source>
          <target state="translated">위치 내에서 허용되는 HTTP 메서드를 제한합니다. &lt;code&gt;&lt;i&gt;method&lt;/i&gt;&lt;/code&gt; : 매개 변수는 다음 중 하나가 될 수 &lt;code&gt;GET&lt;/code&gt; , &lt;code&gt;HEAD&lt;/code&gt; , &lt;code&gt;POST&lt;/code&gt; , &lt;code&gt;PUT&lt;/code&gt; , &lt;code&gt;DELETE&lt;/code&gt; , &lt;code&gt;MKCOL&lt;/code&gt; , &lt;code&gt;COPY&lt;/code&gt; , &lt;code&gt;MOVE&lt;/code&gt; , &lt;code&gt;OPTIONS&lt;/code&gt; , &lt;code&gt;PROPFIND&lt;/code&gt; , &lt;code&gt;PROPPATCH&lt;/code&gt; , &lt;code&gt;LOCK&lt;/code&gt; , &lt;code&gt;UNLOCK&lt;/code&gt; 또는 &lt;code&gt;PATCH&lt;/code&gt; . &lt;code&gt;GET&lt;/code&gt; 메소드를 허용하면 &lt;code&gt;HEAD&lt;/code&gt; 메소드도 허용됩니다. &lt;a href=&quot;ngx_http_access_module&quot;&gt;ngx_http_access_module&lt;/a&gt; 사용하여 다른 방법에 대한 액세스를 제한 할 수 있습니다. , &lt;a href=&quot;ngx_http_auth_basic_module&quot;&gt;ngx_http_auth_basic_module을&lt;/a&gt;및 &lt;a href=&quot;ngx_http_auth_jwt_module&quot;&gt;ngx_http_auth_jwt_module&lt;/a&gt; (1.13.10) 모듈 지시문 :</target>
        </trans-unit>
        <trans-unit id="73300f26ab7825675eccec7bc8a6e284a4c400c8" translate="yes" xml:space="preserve">
          <source>Limits the &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; of data written to a temporary file at a time, when buffering of responses from the FastCGI server to temporary files is enabled. By default, &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; is limited by two buffers set by the &lt;a href=&quot;#fastcgi_buffer_size&quot;&gt;fastcgi_buffer_size&lt;/a&gt; and &lt;a href=&quot;#fastcgi_buffers&quot;&gt;fastcgi_buffers&lt;/a&gt; directives. The maximum size of a temporary file is set by the &lt;a href=&quot;#fastcgi_max_temp_file_size&quot;&gt;fastcgi_max_temp_file_size&lt;/a&gt; directive.</source>
          <target state="translated">FastCGI 서버에서 임시 파일로의 응답 버퍼링이 사용 가능한 경우 한 번에 임시 파일에 기록되는 데이터 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 를 제한합니다 . 기본적으로 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 는 &lt;a href=&quot;#fastcgi_buffer_size&quot;&gt;fastcgi_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;#fastcgi_buffers&quot;&gt;fastcgi_buffers&lt;/a&gt; 지시문으로 설정된 두 개의 버퍼로 제한됩니다 . 임시 파일의 최대 크기는 &lt;a href=&quot;#fastcgi_max_temp_file_size&quot;&gt;fastcgi_max_temp_file_size&lt;/a&gt; 지시문에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d93809fc567c3d49889c7bf969db4a42392b0f6c" translate="yes" xml:space="preserve">
          <source>Limits the &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; of data written to a temporary file at a time, when buffering of responses from the SCGI server to temporary files is enabled. By default, &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; is limited by two buffers set by the &lt;a href=&quot;#scgi_buffer_size&quot;&gt;scgi_buffer_size&lt;/a&gt; and &lt;a href=&quot;#scgi_buffers&quot;&gt;scgi_buffers&lt;/a&gt; directives. The maximum size of a temporary file is set by the &lt;a href=&quot;#scgi_max_temp_file_size&quot;&gt;scgi_max_temp_file_size&lt;/a&gt; directive.</source>
          <target state="translated">SCGI 서버에서 임시 파일로의 응답 버퍼링이 활성화 된 경우 한 번에 임시 파일에 기록되는 데이터 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 를 제한합니다 . 기본적으로 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 는 &lt;a href=&quot;#scgi_buffer_size&quot;&gt;scgi_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;#scgi_buffers&quot;&gt;scgi_buffers&lt;/a&gt; 지시문으로 설정된 두 개의 버퍼로 제한됩니다 . 임시 파일의 최대 크기는 &lt;a href=&quot;#scgi_max_temp_file_size&quot;&gt;scgi_max_temp_file_size&lt;/a&gt; 지시문에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef00f6e30c1752717a7317533f229737b82c49ee" translate="yes" xml:space="preserve">
          <source>Limits the &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; of data written to a temporary file at a time, when buffering of responses from the proxied server to temporary files is enabled. By default, &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; is limited by two buffers set by the &lt;a href=&quot;#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt; and &lt;a href=&quot;#proxy_buffers&quot;&gt;proxy_buffers&lt;/a&gt; directives. The maximum size of a temporary file is set by the &lt;a href=&quot;#proxy_max_temp_file_size&quot;&gt;proxy_max_temp_file_size&lt;/a&gt; directive.</source>
          <target state="translated">프록시 서버에서 임시 파일로의 응답 버퍼링이 사용 가능한 경우 한 번에 임시 파일에 기록되는 데이터 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 를 제한합니다 . 기본적으로 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 는 &lt;a href=&quot;#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;#proxy_buffers&quot;&gt;proxy_buffers&lt;/a&gt; 지시문으로 설정된 두 개의 버퍼로 제한됩니다 . 임시 파일의 최대 크기는 &lt;a href=&quot;#proxy_max_temp_file_size&quot;&gt;proxy_max_temp_file_size&lt;/a&gt; 지시문에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="d6ca26e13a7b910183acde5cfe35c77e9ffa1e0a" translate="yes" xml:space="preserve">
          <source>Limits the &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; of data written to a temporary file at a time, when buffering of responses from the uwsgi server to temporary files is enabled. By default, &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; is limited by two buffers set by the &lt;a href=&quot;#uwsgi_buffer_size&quot;&gt;uwsgi_buffer_size&lt;/a&gt; and &lt;a href=&quot;#uwsgi_buffers&quot;&gt;uwsgi_buffers&lt;/a&gt; directives. The maximum size of a temporary file is set by the &lt;a href=&quot;#uwsgi_max_temp_file_size&quot;&gt;uwsgi_max_temp_file_size&lt;/a&gt; directive.</source>
          <target state="translated">uwsgi 서버에서 임시 파일로의 응답 버퍼링이 사용 가능한 경우 한 번에 임시 파일에 기록되는 데이터 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 를 제한합니다 . 기본적으로 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 는 &lt;a href=&quot;#uwsgi_buffer_size&quot;&gt;uwsgi_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;#uwsgi_buffers&quot;&gt;uwsgi_buffers&lt;/a&gt; 지시문으로 설정된 두 개의 버퍼로 제한됩니다 . 임시 파일의 최대 크기는 &lt;a href=&quot;#uwsgi_max_temp_file_size&quot;&gt;uwsgi_max_temp_file_size&lt;/a&gt; 지시문에 의해 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="358d1e314b0fba6c39c2bf8a8910543f9f9a9639" translate="yes" xml:space="preserve">
          <source>Limits the maximum allowed number of ranges in byte-range requests. Requests that exceed the limit are processed as if there were no byte ranges specified. By default, the number of ranges is not limited. The zero value disables the byte-range support completely.</source>
          <target state="translated">바이트 범위 요청에서 허용되는 최대 범위 수를 제한합니다. 한계를 초과하는 요청은 지정된 바이트 범위가없는 것처럼 처리됩니다. 기본적으로 범위 수는 제한되지 않습니다. 값이 0이면 바이트 범위 지원이 완전히 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="a3e1826a357ad2ac8f90e6af4db8a5a45884865c" translate="yes" xml:space="preserve">
          <source>Limits the maximum number of concurrent &lt;a href=&quot;#http2_push&quot;&gt;push&lt;/a&gt; requests in a connection.</source>
          <target state="translated">연결에서 최대 동시 &lt;a href=&quot;#http2_push&quot;&gt;푸시&lt;/a&gt; 요청 수를 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="1e5ec6b364490c3b94a18663f65138fb82893368" translate="yes" xml:space="preserve">
          <source>Limits the maximum size of an &lt;a href=&quot;https://tools.ietf.org/html/rfc7541&quot;&gt;HPACK&lt;/a&gt;-compressed request header field. The limit applies equally to both name and value. Note that if Huffman encoding is applied, the actual size of decompressed name and value strings may be larger. For most requests, the default limit should be enough.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7541&quot;&gt;HPACK&lt;/a&gt; 압축 요청 헤더 필드 의 최대 크기를 제한합니다 . 제한은 이름과 값 모두에 동일하게 적용됩니다. 허프만 인코딩을 적용하면 압축 해제 된 이름 및 값 문자열의 실제 크기가 더 커질 수 있습니다. 대부분의 요청에는 기본 제한으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="9d1cda155ffc1febef9233a7fe2b40fafc77e0de" translate="yes" xml:space="preserve">
          <source>Limits the maximum size of the entire request header list after &lt;a href=&quot;https://tools.ietf.org/html/rfc7541&quot;&gt;HPACK&lt;/a&gt; decompression. For most requests, the default limit should be enough.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7541&quot;&gt;HPACK&lt;/a&gt; 압축 해제 후 전체 요청 헤더 목록의 최대 크기를 제한합니다 . 대부분의 요청에는 기본 제한으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="37fc7e87164f475d9f594eb107ff48a54f2fdb43" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a connection to the &lt;a href=&quot;#proxy_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#proxy_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 연결을 전달할 수있는 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="7f48a588ed9ee9f7cc393b60912052a329c93daa" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#fastcgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#fastcgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="df8f9ff0c89526b1a4d6d4ee00cd86560a7758b5" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#grpc_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#grpc_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="ec8a965bbcf730faaf101f643b3e8ef051049719" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#memcached_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#memcached_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="64d97ffd3e112438253f8c959d2ce86be9198393" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#proxy_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#proxy_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="c79b9b1a63aab4469269e39b72748a590ace0f37" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#scgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#scgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="59c2caa12b575f5a9c642f750deb0f3637836161" translate="yes" xml:space="preserve">
          <source>Limits the number of possible tries for passing a request to the &lt;a href=&quot;#uwsgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#uwsgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 요청을 전달할 수있는 시도 횟수를 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="c115408aa5e6f2ab59d485e6a196d49c79903018" translate="yes" xml:space="preserve">
          <source>Limits the rate of response transmission to a client. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if a client simultaneously opens two connections, the overall rate will be twice as much as the specified limit.</source>
          <target state="translated">클라이언트로의 응답 전송 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 제한은 요청마다 설정되므로 클라이언트가 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="aebe94c522db58dc826bf6cb79379da929342af8" translate="yes" xml:space="preserve">
          <source>Limits the rate of response transmission to a client. The rate is limited based on the average bitrate of the MP4 file served. To calculate the rate, the bitrate is multiplied by the specified &lt;code&gt;&lt;i&gt;factor&lt;/i&gt;&lt;/code&gt;. The special value &amp;ldquo;&lt;code&gt;on&lt;/code&gt;&amp;rdquo; corresponds to the factor of 1.1. The special value &amp;ldquo;&lt;code&gt;off&lt;/code&gt;&amp;rdquo; disables rate limiting. The limit is set per a request, and so if a client simultaneously opens two connections, the overall rate will be twice as much as the specified limit.</source>
          <target state="translated">클라이언트로의 응답 전송 속도를 제한합니다. 제공되는 MP4 파일의 평균 비트 전송률에 따라 속도가 제한됩니다. 속도를 계산하기 위해 비트 전송률에 지정된 &lt;code&gt;&lt;i&gt;factor&lt;/i&gt;&lt;/code&gt; 를 곱합니다 . 특수 값 &quot; &lt;code&gt;on&lt;/code&gt; &quot;은 1.1의 계수에 해당합니다. 특수 값 &quot; &lt;code&gt;off&lt;/code&gt; &quot;는 속도 제한을 비활성화합니다. 제한은 요청마다 설정되므로 클라이언트가 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="e393479657ef00004dba8bfe85cdb6bc27d0ec07" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the data from the client. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a connection, so if the client simultaneously opens two connections, the overall rate will be twice as much as the specified limit.</source>
          <target state="translated">클라이언트에서 데이터를 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 연결 당 제한이 설정되므로 클라이언트가 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="76bb99134123c0132d06debe6938c305f5a4be99" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the data from the proxied server. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a connection, so if nginx simultaneously opens two connections to the proxied server, the overall rate will be twice as much as the specified limit.</source>
          <target state="translated">프록시 서버에서 데이터를 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 제한은 연결마다 설정되므로 nginx가 프록시 서버에 대한 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다.</target>
        </trans-unit>
        <trans-unit id="e138628abb1c415705268f28a75f308c0f5ab746" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the response from the FastCGI server. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if nginx simultaneously opens two connections to the FastCFI server, the overall rate will be twice as much as the specified limit. The limitation works only if &lt;a href=&quot;#fastcgi_buffering&quot;&gt;buffering&lt;/a&gt; of responses from the FastCGI server is enabled.</source>
          <target state="translated">FastCGI 서버에서 응답을 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 한도는 요청마다 설정되므로 nginx가 FastCFI 서버에 대한 두 개의 연결을 동시에 열면 전체 속도는 지정된 한도의 두 배가됩니다. 이 제한은 FastCGI 서버의 응답 &lt;a href=&quot;#fastcgi_buffering&quot;&gt;버퍼링&lt;/a&gt; 이 활성화 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d4ca986ca5fe5856cfa1ad6088fcad3d4bd0464c" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the response from the SCGI server. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if nginx simultaneously opens two connections to the SCGI server, the overall rate will be twice as much as the specified limit. The limitation works only if &lt;a href=&quot;#scgi_buffering&quot;&gt;buffering&lt;/a&gt; of responses from the SCGI server is enabled.</source>
          <target state="translated">SCGI 서버에서 응답을 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 제한은 요청마다 설정되므로 nginx가 SCGI 서버에 대한 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다. 이 제한은 SCGI 서버의 응답 &lt;a href=&quot;#scgi_buffering&quot;&gt;버퍼링&lt;/a&gt; 이 활성화 된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="0d1afea50f655be2d6715d1790303cae5630546e" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the response from the proxied server. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if nginx simultaneously opens two connections to the proxied server, the overall rate will be twice as much as the specified limit. The limitation works only if &lt;a href=&quot;#proxy_buffering&quot;&gt;buffering&lt;/a&gt; of responses from the proxied server is enabled.</source>
          <target state="translated">프록시 서버에서 응답을 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 제한은 요청마다 설정되므로 nginx가 프록시 서버에 대한 두 개의 연결을 동시에 열면 전체 속도는 지정된 제한의 두 배가됩니다. 프록시 서버의 응답 &lt;a href=&quot;#proxy_buffering&quot;&gt;버퍼링&lt;/a&gt; 이 활성화 된 경우에만 제한이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="d7286c0e9bd7dceaf9ffa00a68a04e8b6a8ea776" translate="yes" xml:space="preserve">
          <source>Limits the speed of reading the response from the uwsgi server. The &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; is specified in bytes per second. The zero value disables rate limiting. The limit is set per a request, and so if nginx simultaneously opens two connections to the uwsgi server, the overall rate will be twice as much as the specified limit. The limitation works only if &lt;a href=&quot;#uwsgi_buffering&quot;&gt;buffering&lt;/a&gt; of responses from the uwsgi server is enabled.</source>
          <target state="translated">uwsgi 서버에서 응답을 읽는 속도를 제한합니다. &lt;code&gt;&lt;i&gt;rate&lt;/i&gt;&lt;/code&gt; 초당 바이트 단위로 지정됩니다. 0 값은 속도 제한을 비활성화합니다. 한도는 요청마다 설정되므로 nginx가 uwsgi 서버에 대한 두 개의 연결을 동시에 열면 전체 속도는 지정된 한도의 두 배가됩니다. uwsgi 서버의 응답 &lt;a href=&quot;#uwsgi_buffering&quot;&gt;버퍼링&lt;/a&gt; 이 활성화 된 경우에만 제한이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="bd7a91f89bd89474db8834625ca4c4da70240104" translate="yes" xml:space="preserve">
          <source>Limits the time allowed to pass a connection to the &lt;a href=&quot;#proxy_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">&lt;a href=&quot;#proxy_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 연결을 전달할 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="f50379fff22984ec4c5b26853957868d24d253ca" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#fastcgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#fastcgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="3b2d0410d729c65b40c77210cc15a07677debac0" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#grpc_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#grpc_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="2171b3812cc4f54b5b000b0e55745285f4689653" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#memcached_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#memcached_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="e751449962ce2bfe5abf84c5adc16148506f6f70" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#proxy_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#proxy_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="09ac29ad7d0af730527d8eb9388955f09a1c4ff8" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#scgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#scgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="c7b05d730f5efd1c4cbd7cb3e0ac2569ce525123" translate="yes" xml:space="preserve">
          <source>Limits the time during which a request can be passed to the &lt;a href=&quot;#uwsgi_next_upstream&quot;&gt;next server&lt;/a&gt;. The &lt;code&gt;0&lt;/code&gt; value turns off this limitation.</source>
          <target state="translated">요청이 &lt;a href=&quot;#uwsgi_next_upstream&quot;&gt;다음 서버&lt;/a&gt; 로 전달 될 수있는 시간을 제한 합니다 . &lt;code&gt;0&lt;/code&gt; 값이 제한을 해제.</target>
        </trans-unit>
        <trans-unit id="b28419de763bb45150fc0d38bf46c5a3f95ffb3f" translate="yes" xml:space="preserve">
          <source>Limits which fields of SSL statistics will be output.</source>
          <target state="translated">출력 될 SSL 통계 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="32211d2305a2dca45d7117a77bcf04ed4e768c43" translate="yes" xml:space="preserve">
          <source>Limits which fields of cache zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only names of cache zones are output.</source>
          <target state="translated">캐시 영역의 출력 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 캐시 영역의 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="7cb0ba00cd8617c1e7cc705c7b4ff14291d09207" translate="yes" xml:space="preserve">
          <source>Limits which fields of cache zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only names of cache zones will be output.</source>
          <target state="translated">출력 할 캐시 영역의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 캐시 영역의 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="fb0b1c7b04c8f9df59d3522a2bd9b5c71d7f8964" translate="yes" xml:space="preserve">
          <source>Limits which fields of client HTTP requests statistics will be output.</source>
          <target state="translated">출력 할 클라이언트 HTTP 요청 통계의 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="ba8b4d994256fe298ed5f85c09004c820ab6b3bd" translate="yes" xml:space="preserve">
          <source>Limits which fields of limit_conn zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only zone names will be output.</source>
          <target state="translated">limit_conn 영역의 출력 할 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="52676a2de3de8f9051f1af108b1a17a66c7c6595" translate="yes" xml:space="preserve">
          <source>Limits which fields of limit_req zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only zone names will be output.</source>
          <target state="translated">limit_req 영역이 출력 될 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="854e9c4c0c6b64164aa423b37b6e269294fec484" translate="yes" xml:space="preserve">
          <source>Limits which fields of location zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only zone names will be output.</source>
          <target state="translated">출력 할 위치 영역의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="c4f60b1cf7d2a39fa3296aafa1f9bc7c174927bc" translate="yes" xml:space="preserve">
          <source>Limits which fields of nginx running instance will be output.</source>
          <target state="translated">nginx 실행 인스턴스의 어떤 필드가 출력 될지를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bb728e3b1549f84cacc90a2cbab15e410076a8b2" translate="yes" xml:space="preserve">
          <source>Limits which fields of resolvers statistics will be output.</source>
          <target state="translated">리졸버 통계가 출력 될 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="bd53bd6369913b3c8ff221b5156d54237e06387f" translate="yes" xml:space="preserve">
          <source>Limits which fields of server zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only server zone names are output.</source>
          <target state="translated">출력 될 서버 영역의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 서버 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="b1048869ad50a42298298857231174388a85f23a" translate="yes" xml:space="preserve">
          <source>Limits which fields of server zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only server zone names will be output.</source>
          <target state="translated">출력 할 서버 영역의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어있는 경우 서버 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3558057807cc55a7b861e5e76cf7e8b5b9b592" translate="yes" xml:space="preserve">
          <source>Limits which fields of slab zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only zone names are output.</source>
          <target state="translated">슬래브 영역의 어떤 필드가 출력 될지를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="d51f544bc65ce036a887e944339b458ec89a6e7c" translate="yes" xml:space="preserve">
          <source>Limits which fields of slab zones will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, then only zone names will be output.</source>
          <target state="translated">출력 될 슬래브 영역의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 영역 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="cf30553d761fe06ef07d18a14c67d2bd0a02e531" translate="yes" xml:space="preserve">
          <source>Limits which fields of the &lt;a href=&quot;../stream/ngx_stream_limit_conn_module#limit_conn_zone&quot;&gt;limit_conn zone&lt;/a&gt; will be output.</source>
          <target state="translated">&lt;a href=&quot;../stream/ngx_stream_limit_conn_module#limit_conn_zone&quot;&gt;limit_conn 영역의&lt;/a&gt; 출력 할 필드를 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="185cb5200478e07dde7b6879b347bf6226e604b4" translate="yes" xml:space="preserve">
          <source>Limits which fields of the &lt;a href=&quot;ngx_http_limit_conn_module#limit_conn_zone&quot;&gt;limit_conn zone&lt;/a&gt; will be output.</source>
          <target state="translated">&lt;a href=&quot;ngx_http_limit_conn_module#limit_conn_zone&quot;&gt;limit_conn 영역의&lt;/a&gt; 출력 할 필드를 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="1a5ece4558399573b5ec363689a4e36b9c07e58f" translate="yes" xml:space="preserve">
          <source>Limits which fields of the &lt;a href=&quot;ngx_http_limit_req_module#limit_req_zone&quot;&gt;limit_req zone&lt;/a&gt; will be output.</source>
          <target state="translated">&lt;a href=&quot;ngx_http_limit_req_module#limit_req_zone&quot;&gt;limit_req 영역의&lt;/a&gt; 출력 할 필드를 제한 합니다.</target>
        </trans-unit>
        <trans-unit id="4b06b29a8a684acce09200a2447a78749fc69f73" translate="yes" xml:space="preserve">
          <source>Limits which fields of the cache zone will be output.</source>
          <target state="translated">캐시 영역의 출력 할 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="04fb68f5bd34d26c8cdbb49fa027cc6c95568cf9" translate="yes" xml:space="preserve">
          <source>Limits which fields of the connections statistics will be output.</source>
          <target state="translated">연결 통계의 출력 할 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="5256c852664231bf0733546e73a375ca7070ac5c" translate="yes" xml:space="preserve">
          <source>Limits which fields of the location zone will be output.</source>
          <target state="translated">출력 할 위치 영역의 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="b799a3c517beba7271a8999fcc7d85d94b274092" translate="yes" xml:space="preserve">
          <source>Limits which fields of the resolver zone will be output (requests, responses, or both).</source>
          <target state="translated">출력 할 리졸버 영역의 필드 (요청, 응답 또는 둘 다)를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="b3fb2914c395188a965d78548054fc74003e7784" translate="yes" xml:space="preserve">
          <source>Limits which fields of the server zone will be output.</source>
          <target state="translated">출력 될 서버 영역의 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="0b16f217a6e7c43d43f0e0689abcaf1c92d1517c" translate="yes" xml:space="preserve">
          <source>Limits which fields of the slab zone will be output.</source>
          <target state="translated">슬래브 영역의 출력 할 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="9a2a650d3299c13761d36b545e78d60bc73a2dae" translate="yes" xml:space="preserve">
          <source>Limits which fields of the upstream server group will be output.</source>
          <target state="translated">업스트림 서버 그룹의 출력 할 필드를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="8430f4505541134d2e95d8e3c00c19e5d901ed52" translate="yes" xml:space="preserve">
          <source>Limits which fields of upstream server groups will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, only names of upstreams are output.</source>
          <target state="translated">업스트림 서버 그룹의 출력 할 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 업스트림 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="a03e1248f192f7d50b333fc7dba4b1cfb6ad1cbb" translate="yes" xml:space="preserve">
          <source>Limits which fields of upstream server groups will be output. If the &amp;ldquo;&lt;code&gt;fields&lt;/code&gt;&amp;rdquo; value is empty, only names of upstreams will be output.</source>
          <target state="translated">출력 할 업스트림 서버 그룹의 필드를 제한합니다. &quot; &lt;code&gt;fields&lt;/code&gt; &quot;값이 비어 있으면 업스트림의 이름 만 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="92c506808f77c2e395de440b0ef94f52232962e6" translate="yes" xml:space="preserve">
          <source>Link to reference documentation.</source>
          <target state="translated">참조 문서에 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="c3508916d0f82d594277f30c743647de2f6416f7" translate="yes" xml:space="preserve">
          <source>Linux / x86, amd64, arm64, ppc64el;</source>
          <target state="translated">Linux / x86, amd64, arm64, ppc64el;</target>
        </trans-unit>
        <trans-unit id="a1fffaaafb7cc996685bceb829c053cc4f7de43d" translate="yes" xml:space="preserve">
          <source>List</source>
          <target state="translated">List</target>
        </trans-unit>
        <trans-unit id="9e9efedec5540d108622b75711f7e18bb405a353" translate="yes" xml:space="preserve">
          <source>Lists are primarily used for HTTP input and output headers.</source>
          <target state="translated">목록은 주로 HTTP 입력 및 출력 헤더에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf307b18e94df52459ed11214ea433ec9ce054f8" translate="yes" xml:space="preserve">
          <source>Lists do not support item removal. However, when needed, items can internally be marked as missing without actually being removed from the list. For example, to mark HTTP output headers (which are stored as &lt;code&gt;ngx_table_elt_t&lt;/code&gt; objects) as missing, set the &lt;code&gt;hash&lt;/code&gt; field in &lt;code&gt;ngx_table_elt_t&lt;/code&gt; to zero. Items marked in this way are explicitly skipped when the headers are iterated over.</source>
          <target state="translated">목록은 항목 제거를 지원하지 않습니다. 그러나 필요한 경우 실제로 목록에서 제거하지 않고 내부적으로 항목을 누락 된 것으로 표시 할 수 있습니다. 예를 들어 &lt;code&gt;ngx_table_elt_t&lt;/code&gt; 객체 로 저장된 HTTP 출력 헤더 를 누락 된 &lt;code&gt;ngx_table_elt_t&lt;/code&gt; 하려면 ngx_table_elt_t 의 &lt;code&gt;hash&lt;/code&gt; 필드 를 0으로 설정하십시오 . 이 방법으로 표시된 항목은 헤더를 반복 할 때 명시 적으로 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="0a9162e66c4a1bb0d5451856137e306b410d8bfd" translate="yes" xml:space="preserve">
          <source>Load Balancing with NGINX and NGINX Plus</source>
          <target state="translated">NGINX 및 NGINX Plus를 사용한로드 밸런싱</target>
        </trans-unit>
        <trans-unit id="9cf1dd293a2fa573f73290017439309a34d5aee7" translate="yes" xml:space="preserve">
          <source>Load Balancing with NGINX and NGINX Plus part 2</source>
          <target state="translated">NGINX 및 NGINX Plus 2 부로로드 밸런싱</target>
        </trans-unit>
        <trans-unit id="6afb192e8876001093b7d61830ada7231e1990f5" translate="yes" xml:space="preserve">
          <source>Load balancing</source>
          <target state="translated">로드 밸런싱</target>
        </trans-unit>
        <trans-unit id="5821a8921354dc44dc83626343f94f3b25659f18" translate="yes" xml:space="preserve">
          <source>Load balancing across multiple application instances is a commonly used technique for optimizing resource utilization, maximizing throughput, reducing latency, and ensuring fault-tolerant configurations.</source>
          <target state="translated">여러 애플리케이션 인스턴스에서 로드 밸런싱은 리소스 사용률을 최적화하고, 처리량을 최대화하며, 대기 시간을 줄이고, 내결함성 구성을 보장하기 위해 일반적으로 사용되는 기술입니다.</target>
        </trans-unit>
        <trans-unit id="ec08dc7f6b87f1d10f3e35790a4bafd1ed49ad0c" translate="yes" xml:space="preserve">
          <source>Load balancing methods</source>
          <target state="translated">로드 밸런싱 방법</target>
        </trans-unit>
        <trans-unit id="baa86519f58161e80bba3f69d261d5f13fe6430a" translate="yes" xml:space="preserve">
          <source>Loads a dynamic module.</source>
          <target state="translated">동적 모듈을로드합니다.</target>
        </trans-unit>
        <trans-unit id="3ddd384870331f977a1b6db2f71c5e922ecf8b23" translate="yes" xml:space="preserve">
          <source>Location configuration &amp;mdash; Applies to a single &lt;code&gt;location&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt; or &lt;code&gt;limit_except&lt;/code&gt; block. Functions as location-specific settings for a module.</source>
          <target state="translated">위치 구성 - 단일 적용 &lt;code&gt;location&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; 또는 &lt;code&gt;limit_except&lt;/code&gt; 블록. 모듈의 위치 별 설정으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="57003616863fe634c645e342ee9080681e419c5f" translate="yes" xml:space="preserve">
          <source>Logging</source>
          <target state="translated">Logging</target>
        </trans-unit>
        <trans-unit id="06baf31f71c9a66e920110b4381e3c102a80306b" translate="yes" xml:space="preserve">
          <source>Logging the Number of Requests Per Client</source>
          <target state="translated">클라이언트 당 요청 수 기록</target>
        </trans-unit>
        <trans-unit id="330fc00ea3142b1dd46c33f4d7ca3ba2afe0339c" translate="yes" xml:space="preserve">
          <source>Logging to a cyclic memory buffer</source>
          <target state="translated">순환 메모리 버퍼에 로깅</target>
        </trans-unit>
        <trans-unit id="fdac771f1ba5d9c1c7c854a7da91601c0fa29440" translate="yes" xml:space="preserve">
          <source>Logging to syslog</source>
          <target state="translated">syslog에 로깅</target>
        </trans-unit>
        <trans-unit id="9096ea94c0d730062612c17137ade9b6d79fa8f6" translate="yes" xml:space="preserve">
          <source>Logging to syslog is available since version 1.7.1. As part of our &lt;a href=&quot;http://nginx.com/products/&quot;&gt;commercial subscription&lt;/a&gt; logging to syslog is available since version 1.5.3.</source>
          <target state="translated">syslog에 로깅은 버전 1.7.1부터 사용 가능합니다. syslog 에 대한 &lt;a href=&quot;http://nginx.com/products/&quot;&gt;상용 가입&lt;/a&gt; 로깅 의 일부로 버전 1.5.3부터 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e2bb0d6e3d26e08975da78ff7d91e1f79618f83" translate="yes" xml:space="preserve">
          <source>Logging to the memory buffer on the &lt;code&gt;debug&lt;/code&gt; level does not have significant impact on performance even under high load. In this case, the log can be extracted using a &lt;code&gt;gdb&lt;/code&gt; script like the following one:</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 레벨 에서 메모리 버퍼에 로깅하는 것은 로드가 높은 경우에도 성능에 큰 영향을 미치지 않습니다. 이 경우 다음과 같은 &lt;code&gt;gdb&lt;/code&gt; 스크립트를 사용하여 로그를 추출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="241d239f527a9349b5c1751807bde552ed65e244" translate="yes" xml:space="preserve">
          <source>Macro names start from &lt;code&gt;ngx_&lt;/code&gt; or &lt;code&gt;NGX_&lt;/code&gt; (or more specific) prefix. Macro names for constants are uppercase. Parameterized macros and macros for initializers are lowercase. The macro name and value are separated by at least two spaces:</source>
          <target state="translated">매크로 이름은 &lt;code&gt;ngx_&lt;/code&gt; 또는 &lt;code&gt;NGX_&lt;/code&gt; (또는보다 구체적인) 접두사로 시작합니다. 상수의 매크로 이름은 대문자입니다. 이니셜 라이저의 매개 변수화 된 매크로 및 매크로는 소문자입니다. 매크로 이름과 값은 두 개 이상의 공백으로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="513c150041b3e2d3c01bd1710f4ba27ff4952673" translate="yes" xml:space="preserve">
          <source>Mail code should include</source>
          <target state="translated">메일 코드는 다음을 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="3b892b254153ecbb8fbbf6d4247a87eea462aeee" translate="yes" xml:space="preserve">
          <source>Main configuration &amp;mdash; Applies to the entire &lt;code&gt;http&lt;/code&gt; block. Functions as global settings for a module.</source>
          <target state="translated">기본 구성 &amp;mdash; 전체 &lt;code&gt;http&lt;/code&gt; 에 적용 블록에 . 모듈의 전역 설정으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="492fa154b43976cf5f6a0e3828acc6a96f3e80dd" translate="yes" xml:space="preserve">
          <source>Make sure this works as expected, and then run it with njs:</source>
          <target state="translated">이것이 예상대로 작동하는지 확인한 다음 njs로 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="16664838c5cf5829996b220c1a63751f1f18349d" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a FastCGI server originate from the specified local IP address with an optional port (1.11.2). Parameter value can contain variables (1.3.12). The special value &lt;code&gt;off&lt;/code&gt; (1.3.12) cancels the effect of the &lt;code&gt;fastcgi_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">FastCGI 서버로 나가는 연결은 선택적 포트 (1.11.2)를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 파라미터 값은 변수 (1.3.12)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; (1.3.12)는 &lt;code&gt;fastcgi_bind&lt;/code&gt; 의 영향을 취소합니다 는 이전 구성 수준에서 상속 된 지시문 하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="10bad8a0866e1448a97a53fb6813f80c0a4727c5" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a gRPC server originate from the specified local IP address with an optional port. Parameter value can contain variables. The special value &lt;code&gt;off&lt;/code&gt; cancels the effect of the &lt;code&gt;grpc_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">gRPC 서버로 나가는 연결은 선택적 포트를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 매개 변수 값은 변수를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; 는 이전 구성 수준에서 상속 된 &lt;code&gt;grpc_bind&lt;/code&gt; 지시문 의 효과를 취소하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="b6fb06bd55e8ffbc3dd885a64c0dee975f69f5f4" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a memcached server originate from the specified local IP address with an optional port (1.11.2). Parameter value can contain variables (1.3.12). The special value &lt;code&gt;off&lt;/code&gt; (1.3.12) cancels the effect of the &lt;code&gt;memcached_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">memcached 서버로 나가는 연결은 선택적 포트 (1.11.2)를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 파라미터 값은 변수 (1.3.12)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; (1.3.12)는 &lt;code&gt;memcached_bind&lt;/code&gt; 의 영향을 취소합니다 는 이전 구성 수준에서 상속 된 지시문 하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="966d3dd5ff17e74b8636fa37121c9857e041caf7" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a proxied server originate from the specified local IP &lt;code&gt;&lt;i&gt;address&lt;/i&gt;&lt;/code&gt;. Parameter value can contain variables (1.11.2). The special value &lt;code&gt;off&lt;/code&gt; cancels the effect of the &lt;code&gt;proxy_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address.</source>
          <target state="translated">프록시 서버로 나가는 연결은 지정된 로컬 IP &lt;code&gt;&lt;i&gt;address&lt;/i&gt;&lt;/code&gt; 에서 시작됩니다 . 매개 변수 값은 변수 (1.11.2)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; 는 이전 구성 수준에서 상속 된 &lt;code&gt;proxy_bind&lt;/code&gt; 지시문 의 효과를 취소하여 시스템이 로컬 IP 주소를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="4f3517a796086aedcfc06e505525bb8b01f3a923" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a proxied server originate from the specified local IP address with an optional port (1.11.2). Parameter value can contain variables (1.3.12). The special value &lt;code&gt;off&lt;/code&gt; (1.3.12) cancels the effect of the &lt;code&gt;proxy_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">프록시 서버로 나가는 연결은 선택적 포트 (1.11.2)를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 파라미터 값은 변수 (1.3.12)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; (1.3.12)는 &lt;code&gt;proxy_bind&lt;/code&gt; 의 영향을 취소합니다 는 이전 구성 수준에서 상속 된 지시문 하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="8cad3bfee67afd3aac5926ddd0f36ec1a0bd4dcc" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to a uwsgi server originate from the specified local IP address with an optional port (1.11.2). Parameter value can contain variables (1.3.12). The special value &lt;code&gt;off&lt;/code&gt; (1.3.12) cancels the effect of the &lt;code&gt;uwsgi_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">uwsgi 서버로 나가는 연결은 선택적 포트 (1.11.2)를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 파라미터 값은 변수 (1.3.12)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; (1.3.12) 는 이전 구성 수준에서 상속 된 &lt;code&gt;uwsgi_bind&lt;/code&gt; 지시문 의 효과를 취소 하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="36e966ad283367a7ad3967c83a6529ec7a513444" translate="yes" xml:space="preserve">
          <source>Makes outgoing connections to an SCGI server originate from the specified local IP address with an optional port (1.11.2). Parameter value can contain variables (1.3.12). The special value &lt;code&gt;off&lt;/code&gt; (1.3.12) cancels the effect of the &lt;code&gt;scgi_bind&lt;/code&gt; directive inherited from the previous configuration level, which allows the system to auto-assign the local IP address and port.</source>
          <target state="translated">SCGI 서버로 나가는 연결은 선택적 포트 (1.11.2)를 사용하여 지정된 로컬 IP 주소에서 시작됩니다. 파라미터 값은 변수 (1.3.12)를 포함 할 수 있습니다. 특수 값 &lt;code&gt;off&lt;/code&gt; (1.3.12)는 &lt;code&gt;scgi_bind&lt;/code&gt; 의 영향을 취소합니다 는 이전 구성 수준에서 상속 된 지시문 하여 시스템이 로컬 IP 주소 및 포트를 자동 할당 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="f2545a26e31bdc431ccfa33b09fc23aacb8cc212" translate="yes" xml:space="preserve">
          <source>Mandatory phase where data is actually processed, usually &lt;a href=&quot;ngx_stream_proxy_module&quot;&gt;proxied&lt;/a&gt; to &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;upstream&lt;/a&gt; servers, or a specified value is &lt;a href=&quot;ngx_stream_return_module&quot;&gt;returned&lt;/a&gt; to a client.</source>
          <target state="translated">실제로 데이터가 처리되는 필수 단계는, 일반적으로 &lt;a href=&quot;ngx_stream_proxy_module&quot;&gt;프록시&lt;/a&gt; 에 &lt;a href=&quot;ngx_stream_upstream_module&quot;&gt;업스트림&lt;/a&gt; 서버 또는 소정의 값이 &lt;a href=&quot;ngx_stream_return_module&quot;&gt;반환 된&lt;/a&gt; 클라이언트에게.</target>
        </trans-unit>
        <trans-unit id="a749c4601446c4188ecc7013b7a0413a828729b0" translate="yes" xml:space="preserve">
          <source>Manipulating response headers</source>
          <target state="translated">응답 헤더 조작</target>
        </trans-unit>
        <trans-unit id="2d0436f8f6874249f4b4d5888c2f83ba9f44d2d0" translate="yes" xml:space="preserve">
          <source>Manual Memory Management</source>
          <target state="translated">수동 메모리 관리</target>
        </trans-unit>
        <trans-unit id="ac2e48cdabca9e36953b4871e7c905a433ea3841" translate="yes" xml:space="preserve">
          <source>Maps file name extensions to MIME types of responses. Extensions are case-insensitive. Several extensions can be mapped to one type, for example:</source>
          <target state="translated">파일 이름 확장자를 MIME 유형의 응답에 매핑합니다. 확장은 대소 문자를 구분하지 않습니다. 예를 들어 여러 확장을 한 유형에 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6770fb48f47bee270387296f98f7c3597d06b06e" translate="yes" xml:space="preserve">
          <source>Matches a string against a &lt;code&gt;regexp&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 과 문자열을 일치 시킵니다. 시킵니다.</target>
        </trans-unit>
        <trans-unit id="adf38d2ee8b58f39923cebc5f2a3ac27bf6e4c96" translate="yes" xml:space="preserve">
          <source>Members of the cycle include:</source>
          <target state="translated">사이클 멤버는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2c56cf0404e558423fa4f11ac70af7d1c32d29d9" translate="yes" xml:space="preserve">
          <source>Memory Slot:</source>
          <target state="translated">메모리 슬롯 :</target>
        </trans-unit>
        <trans-unit id="1c5536b98ab016fe61807564b4a34c80211a7613" translate="yes" xml:space="preserve">
          <source>Memory management</source>
          <target state="translated">메모리 관리</target>
        </trans-unit>
        <trans-unit id="545187b03e45b20e4367b3d2b1082e270cff3e30" translate="yes" xml:space="preserve">
          <source>Microsoft Visual C compiler. Microsoft Visual Studio&lt;sup&gt;&amp;reg;&lt;/sup&gt; 8 and 10 are known to work.</source>
          <target state="translated">Microsoft Visual C 컴파일러. Microsoft Visual &lt;sup&gt;Studio&amp;reg;&lt;/sup&gt; 8 및 10이 작동하는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="88515312927f05350056437bc3a2fd434cc1258c" translate="yes" xml:space="preserve">
          <source>Minimal configuration:</source>
          <target state="translated">최소 구성 :</target>
        </trans-unit>
        <trans-unit id="5439de003b0bc5c690c03c6e03d0ec9aac43cc58" translate="yes" xml:space="preserve">
          <source>Miscellaneous names</source>
          <target state="translated">기타 이름</target>
        </trans-unit>
        <trans-unit id="4a89cf0af26560f11b44ce20c6fbfe7b5add0880" translate="yes" xml:space="preserve">
          <source>Mixed name-based and IP-based virtual servers</source>
          <target state="translated">혼합 이름 기반 및 IP 기반 가상 서버</target>
        </trans-unit>
        <trans-unit id="1b32c18b40fe060ae8baa65dc466ad13c0ac84c7" translate="yes" xml:space="preserve">
          <source>Modern standard language constructions</source>
          <target state="translated">현대 표준 언어 구성</target>
        </trans-unit>
        <trans-unit id="0521e9a1d6c574cf746589e52559489d177c73c2" translate="yes" xml:space="preserve">
          <source>Modifies settings of a particular server in a stream upstream server group. Server parameters are specified in the JSON format.</source>
          <target state="translated">스트림 업스트림 서버 그룹에서 특정 서버의 설정을 수정합니다. 서버 매개 변수는 JSON 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="bcb5d5cade98c1044daf87f11c3a8482e9843f5c" translate="yes" xml:space="preserve">
          <source>Modifies settings of a particular server in an HTTP upstream server group. Server parameters are specified in the JSON format.</source>
          <target state="translated">HTTP 업스트림 서버 그룹에서 특정 서버의 설정을 수정합니다. 서버 매개 변수는 JSON 형식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="88013b8a6e79372e7883fcf126f7ee2a23e3f4bb" translate="yes" xml:space="preserve">
          <source>Module ngx_google_perftools_module</source>
          <target state="translated">모듈 ngx_google_perftools_module</target>
        </trans-unit>
        <trans-unit id="bd2e53ed07d3dc200b9e67756aa33a7403afad72" translate="yes" xml:space="preserve">
          <source>Module ngx_http_access_module</source>
          <target state="translated">모듈 ngx_http_access_module</target>
        </trans-unit>
        <trans-unit id="974c471e88e6385842195e33e7442b2953c6eae6" translate="yes" xml:space="preserve">
          <source>Module ngx_http_addition_module</source>
          <target state="translated">모듈 ngx_http_addition_module</target>
        </trans-unit>
        <trans-unit id="1ff831f5211124076cb8379752bb5600f940d0cb" translate="yes" xml:space="preserve">
          <source>Module ngx_http_api_module</source>
          <target state="translated">모듈 ngx_http_api_module</target>
        </trans-unit>
        <trans-unit id="774be4cb913e5e939499547c073ca19858497124" translate="yes" xml:space="preserve">
          <source>Module ngx_http_auth_basic_module</source>
          <target state="translated">모듈 ngx_http_auth_basic_module</target>
        </trans-unit>
        <trans-unit id="a2ecf92de2d6a49f286fe1fde4cb21bf7889e586" translate="yes" xml:space="preserve">
          <source>Module ngx_http_auth_jwt_module</source>
          <target state="translated">모듈 ngx_http_auth_jwt_module</target>
        </trans-unit>
        <trans-unit id="de60fad87e9cd4ba445c8e384de16fae3eff4286" translate="yes" xml:space="preserve">
          <source>Module ngx_http_auth_request_module</source>
          <target state="translated">모듈 ngx_http_auth_request_module</target>
        </trans-unit>
        <trans-unit id="21937998193b5439c24f22ba829948566e8f99e2" translate="yes" xml:space="preserve">
          <source>Module ngx_http_autoindex_module</source>
          <target state="translated">모듈 ngx_http_autoindex_module</target>
        </trans-unit>
        <trans-unit id="85813d8bd6a4bf218a54b7fd98ff3412fce80992" translate="yes" xml:space="preserve">
          <source>Module ngx_http_browser_module</source>
          <target state="translated">모듈 ngx_http_browser_module</target>
        </trans-unit>
        <trans-unit id="18cb7ec1679332e1e27519522443e1f77cf06c56" translate="yes" xml:space="preserve">
          <source>Module ngx_http_charset_module</source>
          <target state="translated">모듈 ngx_http_charset_module</target>
        </trans-unit>
        <trans-unit id="93aca24a8dac8db59b01c26a99ecdd611db03bc1" translate="yes" xml:space="preserve">
          <source>Module ngx_http_core_module</source>
          <target state="translated">모듈 ngx_http_core_module</target>
        </trans-unit>
        <trans-unit id="97ba46c2bf6bbc6ab55ba27932e4e69736f09833" translate="yes" xml:space="preserve">
          <source>Module ngx_http_dav_module</source>
          <target state="translated">모듈 ngx_http_dav_module</target>
        </trans-unit>
        <trans-unit id="2d774b0647922679ce748be7d32b531280fba52a" translate="yes" xml:space="preserve">
          <source>Module ngx_http_empty_gif_module</source>
          <target state="translated">모듈 ngx_http_empty_gif_module</target>
        </trans-unit>
        <trans-unit id="1e0921899ceda8494fdf61083bfd916286bec122" translate="yes" xml:space="preserve">
          <source>Module ngx_http_f4f_module</source>
          <target state="translated">모듈 ngx_http_f4f_module</target>
        </trans-unit>
        <trans-unit id="0eb5b9cc28ac11f8e5401e1750db39cabd283429" translate="yes" xml:space="preserve">
          <source>Module ngx_http_fastcgi_module</source>
          <target state="translated">모듈 ngx_http_fastcgi_module</target>
        </trans-unit>
        <trans-unit id="9391b3a45add03e37ffc3de73167ba8892d90d18" translate="yes" xml:space="preserve">
          <source>Module ngx_http_flv_module</source>
          <target state="translated">모듈 ngx_http_flv_module</target>
        </trans-unit>
        <trans-unit id="4fd5f679dabfbefb076e3ff40a0d2e702d9634bd" translate="yes" xml:space="preserve">
          <source>Module ngx_http_geo_module</source>
          <target state="translated">모듈 ngx_http_geo_module</target>
        </trans-unit>
        <trans-unit id="f5ef418ee9e68a2914420ab5722d12c569567221" translate="yes" xml:space="preserve">
          <source>Module ngx_http_geoip_module</source>
          <target state="translated">모듈 ngx_http_geoip_module</target>
        </trans-unit>
        <trans-unit id="0d8a3e85fc394c7463fbc8ec0926cc4a0d5e7902" translate="yes" xml:space="preserve">
          <source>Module ngx_http_grpc_module</source>
          <target state="translated">모듈 ngx_http_grpc_module</target>
        </trans-unit>
        <trans-unit id="927babba1032e702e3769ef650f2aa1c6b921756" translate="yes" xml:space="preserve">
          <source>Module ngx_http_gunzip_module</source>
          <target state="translated">모듈 ngx_http_gunzip_module</target>
        </trans-unit>
        <trans-unit id="5ca491b02ab8121c3ca4b30ec50782d40285432d" translate="yes" xml:space="preserve">
          <source>Module ngx_http_gzip_module</source>
          <target state="translated">모듈 ngx_http_gzip_module</target>
        </trans-unit>
        <trans-unit id="804cba51d4fea10c41d743fa1cae0b983d7bea57" translate="yes" xml:space="preserve">
          <source>Module ngx_http_gzip_static_module</source>
          <target state="translated">모듈 ngx_http_gzip_static_module</target>
        </trans-unit>
        <trans-unit id="1058d583e7a5204d56ccacc24da56448d1bc877f" translate="yes" xml:space="preserve">
          <source>Module ngx_http_headers_module</source>
          <target state="translated">모듈 ngx_http_headers_module</target>
        </trans-unit>
        <trans-unit id="fee2727ff2c0479eb693fc59bf9b01e537818d25" translate="yes" xml:space="preserve">
          <source>Module ngx_http_hls_module</source>
          <target state="translated">모듈 ngx_http_hls_module</target>
        </trans-unit>
        <trans-unit id="e4030aa2e43b09f2ad55667e6e16f164e3c4c5a3" translate="yes" xml:space="preserve">
          <source>Module ngx_http_image_filter_module</source>
          <target state="translated">모듈 ngx_http_image_filter_module</target>
        </trans-unit>
        <trans-unit id="a49d342c830cc421ab4c1391db01c55fb2119f9a" translate="yes" xml:space="preserve">
          <source>Module ngx_http_index_module</source>
          <target state="translated">모듈 ngx_http_index_module</target>
        </trans-unit>
        <trans-unit id="12132bdc178e73867671e987de746e6229c9edf2" translate="yes" xml:space="preserve">
          <source>Module ngx_http_js_module</source>
          <target state="translated">모듈 ngx_http_js_module</target>
        </trans-unit>
        <trans-unit id="c59faf17c97374cca368f0c5591c571b5348a068" translate="yes" xml:space="preserve">
          <source>Module ngx_http_keyval_module</source>
          <target state="translated">모듈 ngx_http_keyval_module</target>
        </trans-unit>
        <trans-unit id="11fc4101eccb63d3f15737f1d63f5fa63d00ec8a" translate="yes" xml:space="preserve">
          <source>Module ngx_http_limit_conn_module</source>
          <target state="translated">모듈 ngx_http_limit_conn_module</target>
        </trans-unit>
        <trans-unit id="83ab7e25826d319f94262e3d689086fe964bd4fa" translate="yes" xml:space="preserve">
          <source>Module ngx_http_limit_req_module</source>
          <target state="translated">모듈 ngx_http_limit_req_module</target>
        </trans-unit>
        <trans-unit id="0283f05349997b72a3124bfe948073ad339c7454" translate="yes" xml:space="preserve">
          <source>Module ngx_http_log_module</source>
          <target state="translated">모듈 ngx_http_log_module</target>
        </trans-unit>
        <trans-unit id="c960d31ff8028c5344293e0345c971c3b87fb155" translate="yes" xml:space="preserve">
          <source>Module ngx_http_map_module</source>
          <target state="translated">모듈 ngx_http_map_module</target>
        </trans-unit>
        <trans-unit id="cf3a57c9f32618e705604b8d7049c20b4aeddcdf" translate="yes" xml:space="preserve">
          <source>Module ngx_http_memcached_module</source>
          <target state="translated">모듈 ngx_http_memcached_module</target>
        </trans-unit>
        <trans-unit id="e124e9f7f9ea4b0d8d579d8b7124aad5d37e1d5e" translate="yes" xml:space="preserve">
          <source>Module ngx_http_mirror_module</source>
          <target state="translated">모듈 ngx_http_mirror_module</target>
        </trans-unit>
        <trans-unit id="0f6533a78b877edaa319f158fdaaabd04ccea5dd" translate="yes" xml:space="preserve">
          <source>Module ngx_http_mp4_module</source>
          <target state="translated">모듈 ngx_http_mp4_module</target>
        </trans-unit>
        <trans-unit id="0f0bdbd9b10e53ced97f123768e6d8b869ef417f" translate="yes" xml:space="preserve">
          <source>Module ngx_http_perl_module</source>
          <target state="translated">모듈 ngx_http_perl_module</target>
        </trans-unit>
        <trans-unit id="cfbe74e177386d2435013459b2970680593d2f14" translate="yes" xml:space="preserve">
          <source>Module ngx_http_proxy_module</source>
          <target state="translated">모듈 ngx_http_proxy_module</target>
        </trans-unit>
        <trans-unit id="9eda280c6cb8aeb12273d80f42b3db9ce36b4106" translate="yes" xml:space="preserve">
          <source>Module ngx_http_random_index_module</source>
          <target state="translated">모듈 ngx_http_random_index_module</target>
        </trans-unit>
        <trans-unit id="87c921f2188d6de35f6d458d4a8564360b470bf9" translate="yes" xml:space="preserve">
          <source>Module ngx_http_realip_module</source>
          <target state="translated">모듈 ngx_http_realip_module</target>
        </trans-unit>
        <trans-unit id="d7e6d8cd63b8cbaae10d1270df22078249c10757" translate="yes" xml:space="preserve">
          <source>Module ngx_http_referer_module</source>
          <target state="translated">모듈 ngx_http_referer_module</target>
        </trans-unit>
        <trans-unit id="a1d90605b829cd7141255d1adba55c7b3df4be9b" translate="yes" xml:space="preserve">
          <source>Module ngx_http_rewrite_module</source>
          <target state="translated">모듈 ngx_http_rewrite_module</target>
        </trans-unit>
        <trans-unit id="de58aa32f0efc796710a56df6893195af2575917" translate="yes" xml:space="preserve">
          <source>Module ngx_http_scgi_module</source>
          <target state="translated">모듈 ngx_http_scgi_module</target>
        </trans-unit>
        <trans-unit id="cee0457362d79dda601e8f55d6467b386a3a7891" translate="yes" xml:space="preserve">
          <source>Module ngx_http_secure_link_module</source>
          <target state="translated">모듈 ngx_http_secure_link_module</target>
        </trans-unit>
        <trans-unit id="22bf46eea81ac347a1828d4f5d6b6961b174e7fe" translate="yes" xml:space="preserve">
          <source>Module ngx_http_session_log_module</source>
          <target state="translated">모듈 ngx_http_session_log_module</target>
        </trans-unit>
        <trans-unit id="0ca45ce6cf636587ce600130381620a0ab116116" translate="yes" xml:space="preserve">
          <source>Module ngx_http_slice_module</source>
          <target state="translated">모듈 ngx_http_slice_module</target>
        </trans-unit>
        <trans-unit id="d901ebf97d88e6367191c2bfcf62829c3ba0dfd7" translate="yes" xml:space="preserve">
          <source>Module ngx_http_spdy_module</source>
          <target state="translated">모듈 ngx_http_spdy_module</target>
        </trans-unit>
        <trans-unit id="ddcccbdeb6f2764c39ba818bbed823e4d40b909d" translate="yes" xml:space="preserve">
          <source>Module ngx_http_split_clients_module</source>
          <target state="translated">모듈 ngx_http_split_clients_module</target>
        </trans-unit>
        <trans-unit id="2c4ecb34cacd1421e378294ef15b7fbba55b9e69" translate="yes" xml:space="preserve">
          <source>Module ngx_http_ssi_module</source>
          <target state="translated">모듈 ngx_http_ssi_module</target>
        </trans-unit>
        <trans-unit id="78c0456cefd3acbd81ddad1dde2a77a27f15132c" translate="yes" xml:space="preserve">
          <source>Module ngx_http_ssl_module</source>
          <target state="translated">모듈 ngx_http_ssl_module</target>
        </trans-unit>
        <trans-unit id="3326c67172fd6c419b763c3b0bde2cb21fc6e054" translate="yes" xml:space="preserve">
          <source>Module ngx_http_status_module</source>
          <target state="translated">모듈 ngx_http_status_module</target>
        </trans-unit>
        <trans-unit id="0398ee81e36a353255fc0253db211a5b6e88532f" translate="yes" xml:space="preserve">
          <source>Module ngx_http_stub_status_module</source>
          <target state="translated">모듈 ngx_http_stub_status_module</target>
        </trans-unit>
        <trans-unit id="2a031449ff77e49f1ee4ff3dc7b7a11193d5512c" translate="yes" xml:space="preserve">
          <source>Module ngx_http_sub_module</source>
          <target state="translated">모듈 ngx_http_sub_module</target>
        </trans-unit>
        <trans-unit id="1a19b60c5672b502e9d197a63abf120545af8bdf" translate="yes" xml:space="preserve">
          <source>Module ngx_http_upstream_conf_module</source>
          <target state="translated">모듈 ngx_http_upstream_conf_module</target>
        </trans-unit>
        <trans-unit id="4b8a167b2cc678ab3e186f138be5ae97a9751145" translate="yes" xml:space="preserve">
          <source>Module ngx_http_upstream_hc_module</source>
          <target state="translated">모듈 ngx_http_upstream_hc_module</target>
        </trans-unit>
        <trans-unit id="4d2b6b16a6243eacd8cb61c3c924fdb1921a4307" translate="yes" xml:space="preserve">
          <source>Module ngx_http_upstream_module</source>
          <target state="translated">모듈 ngx_http_upstream_module</target>
        </trans-unit>
        <trans-unit id="e7018eb2142d31791388e9f972d11fa2435e0fab" translate="yes" xml:space="preserve">
          <source>Module ngx_http_userid_module</source>
          <target state="translated">모듈 ngx_http_userid_module</target>
        </trans-unit>
        <trans-unit id="61c32694df6da6ff769a7a563177fb7bf4228dd6" translate="yes" xml:space="preserve">
          <source>Module ngx_http_uwsgi_module</source>
          <target state="translated">모듈 ngx_http_uwsgi_module</target>
        </trans-unit>
        <trans-unit id="4ff9b40d8cf0b22e3337f81e92b072811382b517" translate="yes" xml:space="preserve">
          <source>Module ngx_http_v2_module</source>
          <target state="translated">모듈 ngx_http_v2_module</target>
        </trans-unit>
        <trans-unit id="aa16d095a6bf2380b296d41838431426a7569ec2" translate="yes" xml:space="preserve">
          <source>Module ngx_http_xslt_module</source>
          <target state="translated">모듈 ngx_http_xslt_module</target>
        </trans-unit>
        <trans-unit id="3f135c5e5330c4096d24bd05f0e7b60329eebdef" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_auth_http_module</source>
          <target state="translated">모듈 ngx_mail_auth_http_module</target>
        </trans-unit>
        <trans-unit id="6c988d2495e155b1cc788ad3d32859180eff68c9" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_core_module</source>
          <target state="translated">모듈 ngx_mail_core_module</target>
        </trans-unit>
        <trans-unit id="f2e3fb75ce0b4309002497df70ff28502bbe63ef" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_imap_module</source>
          <target state="translated">모듈 ngx_mail_imap_module</target>
        </trans-unit>
        <trans-unit id="d01b1544b29ee4fe98d825ecc91a03caea0d1e40" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_pop3_module</source>
          <target state="translated">모듈 ngx_mail_pop3_module</target>
        </trans-unit>
        <trans-unit id="221f9d6bc3f1498f7b97b67533c5aa38ee275747" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_proxy_module</source>
          <target state="translated">모듈 ngx_mail_proxy_module</target>
        </trans-unit>
        <trans-unit id="8c05b575d6285c22c45d8f4422320c69c64cf5dd" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_smtp_module</source>
          <target state="translated">모듈 ngx_mail_smtp_module</target>
        </trans-unit>
        <trans-unit id="6d893c35711946ee718f22395d1ed1d78bfada47" translate="yes" xml:space="preserve">
          <source>Module ngx_mail_ssl_module</source>
          <target state="translated">모듈 ngx_mail_ssl_module</target>
        </trans-unit>
        <trans-unit id="eb6a08b3dd47aed580798c1e0664dbd741465f69" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_access_module</source>
          <target state="translated">모듈 ngx_stream_access_module</target>
        </trans-unit>
        <trans-unit id="c2ea545c0ef85fb060679a09de26f23db2014b54" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_core_module</source>
          <target state="translated">모듈 ngx_stream_core_module</target>
        </trans-unit>
        <trans-unit id="5e712921e545d4ef816e302a0bf293f9e6819240" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_geo_module</source>
          <target state="translated">모듈 ngx_stream_geo_module</target>
        </trans-unit>
        <trans-unit id="8f5320a2139c740892476a9b86753000090d88a7" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_geoip_module</source>
          <target state="translated">모듈 ngx_stream_geoip_module</target>
        </trans-unit>
        <trans-unit id="f6dbdbb98f86546cec57c6e32f4c22b79d3a546d" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_js_module</source>
          <target state="translated">모듈 ngx_stream_js_module</target>
        </trans-unit>
        <trans-unit id="10641bc9620c63fabece7fbfa0896cf639518338" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_keyval_module</source>
          <target state="translated">모듈 ngx_stream_keyval_module</target>
        </trans-unit>
        <trans-unit id="e7a1f3034f3c677e867596864e18704c7c3e10cc" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_limit_conn_module</source>
          <target state="translated">모듈 ngx_stream_limit_conn_module</target>
        </trans-unit>
        <trans-unit id="25a2efc281b92403f939bb34bea0a0e14cb4640e" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_log_module</source>
          <target state="translated">모듈 ngx_stream_log_module</target>
        </trans-unit>
        <trans-unit id="45cdffac01f2dec71872655d090b8f44144b8500" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_map_module</source>
          <target state="translated">모듈 ngx_stream_map_module</target>
        </trans-unit>
        <trans-unit id="a977463ae66df2b03f74ec765a2db71cd90a2ebc" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_proxy_module</source>
          <target state="translated">모듈 ngx_stream_proxy_module</target>
        </trans-unit>
        <trans-unit id="7f589675d9ba3baef2bd98aa96ed630e8c962dee" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_realip_module</source>
          <target state="translated">모듈 ngx_stream_realip_module</target>
        </trans-unit>
        <trans-unit id="def015d5199b17800410f5beeb205dce2e06d93d" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_return_module</source>
          <target state="translated">모듈 ngx_stream_return_module</target>
        </trans-unit>
        <trans-unit id="d630030cf7767fb0af0990f58c6b15f80329e68a" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_set_module</source>
          <target state="translated">모듈 ngx_stream_set_module</target>
        </trans-unit>
        <trans-unit id="10f8afc37f9a6a4e1b72112050084f9550335820" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_split_clients_module</source>
          <target state="translated">모듈 ngx_stream_split_clients_module</target>
        </trans-unit>
        <trans-unit id="d537a0b325879d3ee629c951b8b6af4fa38afab1" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_ssl_module</source>
          <target state="translated">모듈 ngx_stream_ssl_module</target>
        </trans-unit>
        <trans-unit id="c3862808a012daefe54ab506015c254917d02b52" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_ssl_preread_module</source>
          <target state="translated">모듈 ngx_stream_ssl_preread_module</target>
        </trans-unit>
        <trans-unit id="6eb912700f9a790ac00507e2cd7a46809261048a" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_upstream_hc_module</source>
          <target state="translated">모듈 ngx_stream_upstream_hc_module</target>
        </trans-unit>
        <trans-unit id="10b888a4230bcdd57787143856a1645c761dbd1d" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_upstream_module</source>
          <target state="translated">모듈 ngx_stream_upstream_module</target>
        </trans-unit>
        <trans-unit id="c4fb1aed2da4101447e89dbdc3883a077922758a" translate="yes" xml:space="preserve">
          <source>Module ngx_stream_zone_sync_module</source>
          <target state="translated">모듈 ngx_stream_zone_sync_module</target>
        </trans-unit>
        <trans-unit id="04e9462c0ff02bb9032b92abd45881a3c7e15fb7" translate="yes" xml:space="preserve">
          <source>Modules</source>
          <target state="translated">Modules</target>
        </trans-unit>
        <trans-unit id="c4ab44db78b917f04d5e5d06ce351cc77b211c14" translate="yes" xml:space="preserve">
          <source>Modules are not supported, so we've received an exception. To overcome this issue, let's use &lt;code&gt;browserify&lt;/code&gt; or other similar tool.</source>
          <target state="translated">모듈이 지원되지 않으므로 예외가 발생했습니다. 이 문제를 극복하기 위해 &lt;code&gt;browserify&lt;/code&gt; 또는 기타 유사한 도구를 사용해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="9f4e82c216273a4bb357144bb3a9f86836460253" translate="yes" xml:space="preserve">
          <source>Modules are the building blocks of nginx, and most of its functionality is implemented as modules. The module source file must contain a global variable of type &lt;code&gt;ngx_module_t&lt;/code&gt;, which is defined as follows:</source>
          <target state="translated">모듈은 nginx의 구성 요소이며 대부분의 기능은 모듈로 구현됩니다. 모듈 소스 파일은 &lt;code&gt;ngx_module_t&lt;/code&gt; 유형의 글로벌 변수를 포함해야 하며 , 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="330bd664dbcc73385e21f6f926466605155bc1eb" translate="yes" xml:space="preserve">
          <source>Modules reference</source>
          <target state="translated">모듈 참조</target>
        </trans-unit>
        <trans-unit id="4d6d5e022cb37e3f0390870c6db4c3629fd96f43" translate="yes" xml:space="preserve">
          <source>Most &amp;ldquo;&lt;code&gt;for&lt;/code&gt;&amp;rdquo; loops are formatted like this:</source>
          <target state="translated">대부분의&amp;ldquo; &lt;code&gt;for&lt;/code&gt; &amp;rdquo;루프는 다음과 같이 포맷됩니다 :</target>
        </trans-unit>
        <trans-unit id="9351734e208a864aac0795a47ce4720757534054" translate="yes" xml:space="preserve">
          <source>Most functions in nginx return the following codes:</source>
          <target state="translated">nginx의 대부분의 함수는 다음 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ec0958671ab7fad54bfeb7743e831ebacb1df09b" translate="yes" xml:space="preserve">
          <source>Most nginx allocations are done in pools. Memory allocated in an nginx pool is freed automatically when the pool is destroyed. This provides good allocation performance and makes memory control easy.</source>
          <target state="translated">대부분의 nginx 할당은 풀에서 수행됩니다. 풀이 파괴되면 nginx 풀에 할당 된 메모리가 자동으로 해제됩니다. 이는 우수한 할당 성능을 제공하고 메모리 제어를 용이하게합니다.</target>
        </trans-unit>
        <trans-unit id="64ad40477c733712530f7c2b73cac21de9dc62c0" translate="yes" xml:space="preserve">
          <source>Multiple files that reference each other and their dependencies</source>
          <target state="translated">서로를 참조하는 여러 파일 및 해당 종속성</target>
        </trans-unit>
        <trans-unit id="8aff801ba9b21d852b8e0f85d4d4f54e87177dc8" translate="yes" xml:space="preserve">
          <source>Multiple files that reference each other, and their dependencies</source>
          <target state="translated">서로를 참조하는 여러 파일 및 해당 종속성</target>
        </trans-unit>
        <trans-unit id="5ea83ee082da0f84a2be51cf26c4608dba5f2dbb" translate="yes" xml:space="preserve">
          <source>Multiple units can be combined in a single value by specifying them in the order from the most to the least significant, and optionally separated by whitespace. For example, &amp;ldquo;&lt;code&gt;1h 30m&lt;/code&gt;&amp;rdquo; specifies the same time as &amp;ldquo;&lt;code&gt;90m&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;5400s&lt;/code&gt;&amp;rdquo;. A value without a suffix means seconds. It is recommended to always specify a suffix.</source>
          <target state="translated">다중 단위는 최상위에서 최하위 순서로 지정하고 선택적으로 공백으로 구분하여 단일 값으로 결합 될 수 있습니다. 예를 들어, &quot; &lt;code&gt;1h 30m&lt;/code&gt; &quot;은 &quot; &lt;code&gt;90m&lt;/code&gt; &quot;또는 &quot; &lt;code&gt;5400s&lt;/code&gt; &quot; 와 같은 시간을 지정합니다 . 접미사가없는 값은 초를 의미합니다. 항상 접미사를 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d478ed1fc084a2cf47c74cc30d416bce4bdcf1d1" translate="yes" xml:space="preserve">
          <source>Name of nginx build.</source>
          <target state="translated">nginx 빌드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="b6a011e6994891af49a48aa0fcc8c97d038fdc8b" translate="yes" xml:space="preserve">
          <source>Name-based HTTPS servers</source>
          <target state="translated">이름 기반 HTTPS 서버</target>
        </trans-unit>
        <trans-unit id="2488d617c5210f1a5c2875bf58b71af9545c6229" translate="yes" xml:space="preserve">
          <source>Name-based virtual servers</source>
          <target state="translated">이름 기반 가상 서버</target>
        </trans-unit>
        <trans-unit id="4eaf528ae695f51490814748b42c8c7555346a37" translate="yes" xml:space="preserve">
          <source>Named captures in regular expressions create variables (0.8.25) that can later be used in other directives:</source>
          <target state="translated">정규식의 명명 된 캡처는 나중에 다른 지시문에서 사용할 수있는 변수 (0.8.25)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d87be1c0be72b48ee812d123d40cc04d09240d5c" translate="yes" xml:space="preserve">
          <source>Named regular expression server name captures have been supported since 0.8.25.</source>
          <target state="translated">명명 된 정규식 서버 이름 캡처는 0.8.25부터 지원되었습니다.</target>
        </trans-unit>
        <trans-unit id="1e91748557010f07119a40ac844fcae91cc2e7a3" translate="yes" xml:space="preserve">
          <source>Networking</source>
          <target state="translated">Networking</target>
        </trans-unit>
        <trans-unit id="3f6887c6776aaf0b815483b508ab74c08cb2064b" translate="yes" xml:space="preserve">
          <source>New methods and properties: &lt;a href=&quot;reference#s_on&quot;&gt;&lt;code&gt;s.on()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#s_off&quot;&gt;&lt;code&gt;s.off()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#s_allow&quot;&gt;&lt;code&gt;s.allow()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#s_done&quot;&gt;&lt;code&gt;s.done()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#s_decline&quot;&gt;&lt;code&gt;s.decline()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;reference#s_deny&quot;&gt;&lt;code&gt;s.deny()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 메서드 및 속성 : &lt;a href=&quot;reference#s_on&quot;&gt; &lt;code&gt;s.on()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#s_off&quot;&gt; &lt;code&gt;s.off()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#s_allow&quot;&gt; &lt;code&gt;s.allow()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#s_done&quot;&gt; &lt;code&gt;s.done()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#s_decline&quot;&gt; &lt;code&gt;s.decline()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;reference#s_deny&quot;&gt; &lt;code&gt;s.deny()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a0a3f0fa2a801a998e439aaafdd45831e1486e6" translate="yes" xml:space="preserve">
          <source>New methods and properties: &lt;a href=&quot;reference#s_on&quot;&gt;s.on()&lt;/a&gt;, &lt;a href=&quot;reference#s_off&quot;&gt;s.off()&lt;/a&gt;, &lt;a href=&quot;reference#s_allow&quot;&gt;s.allow()&lt;/a&gt;, &lt;a href=&quot;reference#s_done&quot;&gt;s.done()&lt;/a&gt;, &lt;a href=&quot;reference#s_decline&quot;&gt;s.decline()&lt;/a&gt;, &lt;a href=&quot;reference#s_deny&quot;&gt;s.deny()&lt;/a&gt;.</source>
          <target state="translated">새로운 메소드 및 속성 : &lt;a href=&quot;reference#s_on&quot;&gt;s.on ()&lt;/a&gt; , &lt;a href=&quot;reference#s_off&quot;&gt;s.off ()&lt;/a&gt; , &lt;a href=&quot;reference#s_allow&quot;&gt;s.allow ()&lt;/a&gt; , &lt;a href=&quot;reference#s_done&quot;&gt;s.done ()&lt;/a&gt; , &lt;a href=&quot;reference#s_decline&quot;&gt;s.decline ()&lt;/a&gt; , &lt;a href=&quot;reference#s_deny&quot;&gt;s.deny ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab2d35c9c03fcda6e8885c22621fc6c12c2d88bd" translate="yes" xml:space="preserve">
          <source>Next, add the second &lt;code&gt;location&lt;/code&gt; block:</source>
          <target state="translated">다음으로 두 번째 &lt;code&gt;location&lt;/code&gt; 블록을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="10b364c5f1abcdd2215ae029b6542522088ec245" translate="yes" xml:space="preserve">
          <source>Next, open the configuration file. The default configuration file already includes several examples of the &lt;code&gt;server&lt;/code&gt; block, mostly commented out. For now comment out all such blocks and start a new &lt;code&gt;server&lt;/code&gt; block:</source>
          <target state="translated">그런 다음 구성 파일을 엽니 다. 기본 구성 파일에는 이미 주석 처리 된 &lt;code&gt;server&lt;/code&gt; 블록 의 몇 가지 예가 이미 포함되어 있습니다 . 지금은 그러한 모든 블록을 주석 처리하고 새 &lt;code&gt;server&lt;/code&gt; 블록을 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="9e565081111697f5ee9ecf221ad4f114bac3052f" translate="yes" xml:space="preserve">
          <source>Next, the library is installed and the JavaScript code implementing message marshalling is generated from the protocol definition:</source>
          <target state="translated">다음으로 라이브러리가 설치되고 메시지 마샬링을 구현하는 JavaScript 코드가 프로토콜 정의에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="105a9dacabb7949784885270e8b7aeb98ff5e90d" translate="yes" xml:space="preserve">
          <source>Next, use the server configuration from the previous section and modify it to make it a proxy server configuration. In the first &lt;code&gt;location&lt;/code&gt; block, put the &lt;a href=&quot;http/ngx_http_proxy_module#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; directive with the protocol, name and port of the proxied server specified in the parameter (in our case, it is &lt;code&gt;http://localhost:8080&lt;/code&gt;):</source>
          <target state="translated">다음으로 이전 섹션의 서버 구성을 사용하여 프록시 서버 구성으로 수정하십시오. 첫 번째 &lt;code&gt;location&lt;/code&gt; 블록 에서 매개 변수에 지정된 프록시 서버의 프로토콜, 이름 및 포트와 함께 &lt;a href=&quot;http/ngx_http_proxy_module#proxy_pass&quot;&gt;proxy_pass&lt;/a&gt; 지시문을 넣으십시오 (이 경우 &lt;code&gt;http://localhost:8080&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a4305f98f741023725b82f18917a491837ce51c4" translate="yes" xml:space="preserve">
          <source>Next, we process it with &lt;code&gt;browserify&lt;/code&gt; to get all dependencies into a single file:</source>
          <target state="translated">다음으로 모든 종속성을 단일 파일로 가져 오기 위해 &lt;code&gt;browserify&lt;/code&gt; 로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="e40202d56a2fb9f49e889a59d16cd72a89030bb2" translate="yes" xml:space="preserve">
          <source>Next, we process the file with webpack, which itself invokes babel:</source>
          <target state="translated">다음으로, 자체적으로 babel을 호출하는 webpack으로 파일을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fda7f23390e34a400a68512abbf4469239deee7c" translate="yes" xml:space="preserve">
          <source>Nginx provides the following logging macros:</source>
          <target state="translated">Nginx는 다음과 같은 로깅 매크로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4409732d73a82066174fa92e4f17dfa91d36e83e" translate="yes" xml:space="preserve">
          <source>Normally, loggers are created by existing nginx code from &lt;code&gt;error_log&lt;/code&gt; directives and are available at nearly every stage of processing in cycle, configuration, client connection and other objects.</source>
          <target state="translated">일반적으로 로거는 &lt;code&gt;error_log&lt;/code&gt; 지시문의 기존 nginx 코드로 작성되며 주기, 구성, 클라이언트 연결 및 기타 객체의 거의 모든 처리 단계에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="446d201e5f2aa789ba3545722e1d60e73f45512e" translate="yes" xml:space="preserve">
          <source>Not all connections are counted. A connection is counted only if it has a request being processed by the server and the whole request header has already been read.</source>
          <target state="translated">모든 연결이 계산되는 것은 아닙니다. 서버에서 요청을 처리하고 있고 전체 요청 헤더를 이미 읽은 경우에만 연결이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c6a29df76331ddb3c5c51a38bb4f8a09d67da17c" translate="yes" xml:space="preserve">
          <source>Note that accepting HTTP/2 connections over TLS requires the &amp;ldquo;Application-Layer Protocol Negotiation&amp;rdquo; (ALPN) TLS extension support, which is available only since &lt;a href=&quot;http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&gt; version 1.0.2. Using the &amp;ldquo;Next Protocol Negotiation&amp;rdquo; (NPN) TLS extension for this purpose (available since OpenSSL version 1.0.1) is not guaranteed to work.</source>
          <target state="translated">TLS를 통한 HTTP / 2 연결을 허용하려면&amp;ldquo;ALPN (Application-Layer Protocol Negotiation)&amp;rdquo;TLS 확장 지원이 필요하며 &lt;a href=&quot;http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&gt; 버전 1.0.2 이후에만 사용할 수 있습니다 . 이 목적을 위해 &quot;NPN (Next Protocol Negotiation)&quot;TLS 확장 (OpenSSL 버전 1.0.1부터 사용 가능)을 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f8d36436b28ec17be9d64c8d1ccf6ae0e312720" translate="yes" xml:space="preserve">
          <source>Note that adding or removing a server from the group may result in remapping most of the keys to different servers. The method is compatible with the &lt;a href=&quot;https://metacpan.org/pod/Cache::Memcached&quot;&gt;Cache::Memcached&lt;/a&gt; Perl library.</source>
          <target state="translated">그룹에서 서버를 추가하거나 제거하면 대부분의 키가 다른 서버로 다시 매핑 될 수 있습니다. 이 방법은 &lt;a href=&quot;https://metacpan.org/pod/Cache::Memcached&quot;&gt;Cache :: Memcached&lt;/a&gt; Perl 라이브러리 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0f7c74d88eb10167c23f7be97173b8b50127d2f8" translate="yes" xml:space="preserve">
          <source>Note that after rebuilding Perl with the new &lt;code&gt;-Dusemultiplicity=yes&lt;/code&gt; or &lt;code&gt;-Dusethreads=yes&lt;/code&gt; parameters, all binary Perl modules will have to be rebuilt as well &amp;mdash; they will just stop working with the new Perl.</source>
          <target state="translated">새로운 &lt;code&gt;-Dusemultiplicity=yes&lt;/code&gt; 또는 &lt;code&gt;-Dusethreads=yes&lt;/code&gt; 매개 변수를 사용하여 Perl을 재 구축 한 후 모든 바이너리 Perl 모듈도 재 구축해야합니다. 새로운 Perl에 대한 작업은 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="2de66fbda8de798f64c92af5cc95fc19d29a4bc7" translate="yes" xml:space="preserve">
          <source>Note that compression is essential for the correct matching of prefix string and regular expression locations. Without it, the &amp;ldquo;&lt;code&gt;//scripts/one.php&lt;/code&gt;&amp;rdquo; request would not match</source>
          <target state="translated">접두사 문자열과 정규식 위치를 올바르게 일치 시키려면 압축이 필수적입니다. 그렇지 않으면 &quot; &lt;code&gt;//scripts/one.php&lt;/code&gt; &quot;요청이 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a181a1d22075da3a9ab965a402534634dbe996ec" translate="yes" xml:space="preserve">
          <source>Note that configuring OpenSSL directly might result in unexpected behavior.</source>
          <target state="translated">OpenSSL을 직접 구성하면 예기치 않은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b16d253505bc8935fc321d1976c2e1537fb3ab8e" translate="yes" xml:space="preserve">
          <source>Note that for HTTP connections &lt;code&gt;ngx_connection_t&lt;/code&gt;'s &lt;code&gt;data&lt;/code&gt; field points back to the request. Such requests are called active, as opposed to the other requests tied to the connection. An active request is used to handle client connection events and is allowed to output its response to the client. Normally, each request becomes active at some point so that it can send its output.</source>
          <target state="translated">HTTP 연결의 경우 &lt;code&gt;ngx_connection_t&lt;/code&gt; 의 &lt;code&gt;data&lt;/code&gt; 필드는 다시 요청을 가리 킵니다. 이러한 요청은 연결에 연결된 다른 요청과 달리 활성이라고합니다. 활성 요청은 클라이언트 연결 이벤트를 처리하는 데 사용되며 클라이언트에 응답을 출력 할 수 있습니다. 일반적으로 각 요청은 특정 시점에서 활성화되어 출력을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5fa8793473ea97041dca7bd72b4351c81193fb2" translate="yes" xml:space="preserve">
          <source>Note that in order to accept both &lt;a href=&quot;ngx_http_ssl_module&quot;&gt;HTTPS&lt;/a&gt; and SPDY connections simultaneously on the same port, &lt;a href=&quot;http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&gt; library used should support &amp;ldquo;Next Protocol Negotiation&amp;rdquo; TLS extension, available since OpenSSL version 1.0.1.</source>
          <target state="translated">동일한 포트에서 &lt;a href=&quot;ngx_http_ssl_module&quot;&gt;HTTPS&lt;/a&gt; 와 SPDY 연결을 동시에 허용하려면 사용 된 &lt;a href=&quot;http://www.openssl.org&quot;&gt;OpenSSL&lt;/a&gt; 라이브러리가 OpenSSL 버전 1.0.1부터 사용 가능한&amp;ldquo;다음 프로토콜 협상&amp;rdquo;TLS 확장을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="7567424b34e3898d59c6eeb000ca38c3196e2706" translate="yes" xml:space="preserve">
          <source>Note that in this example generated code is not wrapped into function and we do not need to call it explicitly. The result is in the &quot;&lt;code&gt;dist&lt;/code&gt;&quot; directory:</source>
          <target state="translated">이 예제에서 생성 된 코드는 함수로 래핑되지 않으며 명시 적으로 호출 할 필요가 없습니다. 결과는 &quot; &lt;code&gt;dist&lt;/code&gt; &quot;디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d7d455c8da45bfa61d5c056cc98ea8dfdcd6650" translate="yes" xml:space="preserve">
          <source>Note that locations of all types test only a URI part of request line without arguments. This is done because arguments in the query string may be given in several ways, for example:</source>
          <target state="translated">모든 유형의 위치는 인수없이 요청 라인의 URI 부분 만 테스트합니다. 쿼리 문자열의 인수는 다음과 같은 여러 가지 방법으로 제공 될 수 있기 때문에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6370a35f6e7b981099507859d70d6f5b6ca74792" translate="yes" xml:space="preserve">
          <source>Note that redefining the log without also specifying the &lt;code&gt;debug&lt;/code&gt; level will disable the debugging log. In the example below, redefining the log on the &lt;a href=&quot;http/ngx_http_core_module#server&quot;&gt;server&lt;/a&gt; level disables the debugging log for this server:</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 수준을 지정하지 않고 로그를 다시 정의 하면 디버깅 로그가 비활성화됩니다. 아래 예에서 &lt;a href=&quot;http/ngx_http_core_module#server&quot;&gt;서버&lt;/a&gt; 수준 의 로그를 재정의하면 이 서버에 대한 디버깅 로그가 비활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="915de56bec6ddce4e2dcecaf7312f01c95c72b60" translate="yes" xml:space="preserve">
          <source>Note that the default server is a property of the listen port and not of the server name. More about this later.</source>
          <target state="translated">기본 서버는 청취 포트의 속성이며 서버 이름이 아닙니다. 나중에 이것에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="6a505504002f05ac229ee19f4cf337dc57f70052" translate="yes" xml:space="preserve">
          <source>Note that there are no instructions for the &lt;a href=&quot;ngx_http_core_module#limit_rate&quot;&gt;limit_rate&lt;/a&gt; directive above as it is unrelated to the &lt;code&gt;ngx_http_rewrite_module&lt;/code&gt; module. A separate configuration is created for the &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; block. If the condition holds true, a request is assigned this configuration where &lt;code&gt;limit_rate&lt;/code&gt; equals to 10k.</source>
          <target state="translated">&lt;code&gt;ngx_http_rewrite_module&lt;/code&gt; 모듈 과 관련 이 없으므로 위 의 &lt;a href=&quot;ngx_http_core_module#limit_rate&quot;&gt;limit_rate&lt;/a&gt; 지시문에 대한 지시 사항이 없습니다 . &lt;a href=&quot;#if&quot;&gt;if&lt;/a&gt; 블록에 대해 별도의 구성이 작성 됩니다 . 조건이 true 인 경우 &lt;code&gt;limit_rate&lt;/code&gt; 가 10k 인 이 구성에 요청이 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="601131a63a7189835433443c490b64237b906c34" translate="yes" xml:space="preserve">
          <source>Note that using variables implies that a certificate will be loaded for each SSL handshake, and this may have a negative impact on performance.</source>
          <target state="translated">변수를 사용한다는 것은 각 SSL 핸드 셰이크에 대해 인증서가로드됨을 의미하며 이는 성능에 부정적인 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4334d4bba51b1ffcd7a4809d7c78713c58bc3892" translate="yes" xml:space="preserve">
          <source>Note we are using &quot;&lt;code&gt;production&lt;/code&gt;&quot; mode. In this mode webpack does not use &quot;&lt;code&gt;eval&lt;/code&gt;&quot; construction not supported by njs. The referenced &lt;code&gt;load.js&lt;/code&gt; file is our entry point:</source>
          <target state="translated">&quot; &lt;code&gt;production&lt;/code&gt; &quot;모드를 사용하고 있습니다. 이 모드에서 webpack은 njs에서 지원하지 않는 &quot; &lt;code&gt;eval&lt;/code&gt; &quot;구성을 사용하지 않습니다 . 참조 된 &lt;code&gt;load.js&lt;/code&gt; 파일은 우리의 진입 점입니다.</target>
        </trans-unit>
        <trans-unit id="650e1847f59ac68e38655d83311ff572ce0167e3" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how nginx chooses a</source>
          <target state="translated">이제 nginx가 어떻게 a를 선택하는지 봅시다</target>
        </trans-unit>
        <trans-unit id="8415fbf092c3f3345480abb862c6c25f6bfbf94a" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s look at how requests would be processed in the configuration above:</source>
          <target state="translated">이제 위의 구성에서 요청이 처리되는 방식을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="1833a91463b5f11e16bf37bff7b77369ebfb7a5f" translate="yes" xml:space="preserve">
          <source>Now let's proceed further with njs:</source>
          <target state="translated">이제 njs로 더 진행해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6101250ca1afcc59baf36ca28be6209c3291e540" translate="yes" xml:space="preserve">
          <source>Numeric conversion</source>
          <target state="translated">숫자 변환</target>
        </trans-unit>
        <trans-unit id="2883f191bc5ebfdc16c0813eff659b35363ea69b" translate="yes" xml:space="preserve">
          <source>Object</source>
          <target state="translated">Object</target>
        </trans-unit>
        <trans-unit id="3c78860cb4a101e5f89badf75b7af980cab6f5eb" translate="yes" xml:space="preserve">
          <source>Offsets may be also specified in gigabytes using &lt;code&gt;g&lt;/code&gt; or &lt;code&gt;G&lt;/code&gt; suffixes.</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 또는 &lt;code&gt;G&lt;/code&gt; 접미사를 사용하여 오프셋을 기가 바이트로 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32c19f03a77e6bc0c2a56a1369389148a6a45cf6" translate="yes" xml:space="preserve">
          <source>Often modules need to perform an HTTP call to some external service. A common mistake is to use some external library, such as libcurl, to perform the HTTP request. It is absolutely unnecessary to bring a huge amount of external (probably &lt;a href=&quot;#using_libraries&quot;&gt;blocking&lt;/a&gt;!) code for the task which can be accomplished by nginx itself.</source>
          <target state="translated">종종 모듈은 일부 외부 서비스에 대한 HTTP 호출을 수행해야합니다. 일반적인 실수는 libcurl과 같은 일부 외부 라이브러리를 사용하여 HTTP 요청을 수행하는 것입니다. nginx 자체로 수행 할 수있는 작업을 위해 대량의 외부 (아마도 &lt;a href=&quot;#using_libraries&quot;&gt;차단&lt;/a&gt; !) 코드 를 가져올 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="078d7df589c0b1dac601be8ce10ccf95f482561d" translate="yes" xml:space="preserve">
          <source>Often, a developer wants to use 3rd-party code, usually available as a library of some kind. In the JavaScript world, the concept of a module is relatively new, so there was no standard until recently. Many platforms (browsers) still don't support modules, which makes code reuse harder. This article describes ways to reuse &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; code in njs.</source>
          <target state="translated">종종 개발자는 일반적으로 일종의 라이브러리로 제공되는 타사 코드를 사용하려고합니다. 자바 스크립트 세계에서 모듈의 개념은 비교적 새롭기 때문에 최근까지 표준이 없었습니다. 많은 플랫폼 (브라우저)이 여전히 모듈을 지원하지 않으므로 코드 재사용이 더 어려워집니다. 이 기사에서는 njs에서 &lt;a href=&quot;https://nodejs.org/&quot;&gt;Node.js&lt;/a&gt; 코드 를 재사용하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="ed80d60a0265f450419735f939f6cbf346faa5ce" translate="yes" xml:space="preserve">
          <source>On FreeBSD, AIO can be used starting from FreeBSD 4.3. Prior to FreeBSD 11.0, AIO can either be linked statically into a kernel:</source>
          <target state="translated">FreeBSD에서는 FreeBSD 4.3부터 AIO를 사용할 수 있습니다. FreeBSD 11.0 이전에는 AIO를 커널에 정적으로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8d46fd044c1c3b659f41afa82ef1b23b15e331" translate="yes" xml:space="preserve">
          <source>On FreeBSD, nginx can be installed either from the &lt;a href=&quot;http://www.freebsd.org/doc/handbook/pkgng-intro.html&quot;&gt;packages&lt;/a&gt; or through the &lt;a href=&quot;http://www.freebsd.org/doc/handbook/ports-using.html&quot;&gt;ports&lt;/a&gt; system. The ports system provides greater flexibility, allowing selection among a wide range of options. The port will compile nginx with the specified options and install it.</source>
          <target state="translated">FreeBSD에서 nginx는 &lt;a href=&quot;http://www.freebsd.org/doc/handbook/pkgng-intro.html&quot;&gt;패키지&lt;/a&gt; 또는 &lt;a href=&quot;http://www.freebsd.org/doc/handbook/ports-using.html&quot;&gt;포트&lt;/a&gt; 시스템을 통해 설치할 수 있습니다 . 포트 시스템은 더 큰 유연성을 제공하여 광범위한 옵션 중에서 선택할 수 있습니다. 포트는 지정된 옵션으로 nginx를 컴파일하고 설치합니다.</target>
        </trans-unit>
        <trans-unit id="6da75b8882d1e086108348cfac07440efabb6b01" translate="yes" xml:space="preserve">
          <source>On FreeBSD, the &lt;code&gt;fcntl(O_READAHEAD,&lt;/code&gt;&lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt;&lt;code&gt;)&lt;/code&gt; system call, supported since FreeBSD 9.0-CURRENT, is used. FreeBSD 7 has to be &lt;a href=&quot;http://sysoev.ru/freebsd/patch.readahead.txt&quot;&gt;patched&lt;/a&gt;.</source>
          <target state="translated">FreeBSD에서는 FreeBSD 9.0-CURRENT부터 지원되는 &lt;code&gt;fcntl(O_READAHEAD,&lt;/code&gt; &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; &lt;code&gt;)&lt;/code&gt; 시스템 호출이 사용됩니다. FreeBSD 7은 &lt;a href=&quot;http://sysoev.ru/freebsd/patch.readahead.txt&quot;&gt;패치&lt;/a&gt; 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b00b606f2d7a6897992591fcdb698976fd6665e7" translate="yes" xml:space="preserve">
          <source>On Linux, &lt;a href=&quot;#directio&quot;&gt;directio&lt;/a&gt; can only be used for reading blocks that are aligned on 512-byte boundaries (or 4K for XFS). File&amp;rsquo;s unaligned end is read in blocking mode. The same holds true for byte range requests and for FLV requests not from the beginning of a file: reading of unaligned data at the beginning and end of a file will be blocking.</source>
          <target state="translated">Linux에서 &lt;a href=&quot;#directio&quot;&gt;directio&lt;/a&gt; 는 512 바이트 경계에 정렬 된 블록 (또는 XFS의 경우 4K)을 읽는 데만 사용할 수 있습니다. 차단 모드에서 파일의 정렬되지 않은 끝을 읽습니다. 바이트 범위 요청 및 파일 시작이 아닌 FLV 요청에 대해서도 마찬가지입니다. 파일의 시작과 끝에서 정렬되지 않은 데이터를 읽는 것이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="4d622d36013f628b11e81c38e7eecae1aa140c2d" translate="yes" xml:space="preserve">
          <source>On Linux, AIO can be used starting from kernel version 2.6.22. Also, it is necessary to enable &lt;a href=&quot;#directio&quot;&gt;directio&lt;/a&gt;, or otherwise reading will be blocking:</source>
          <target state="translated">Linux에서는 커널 버전 2.6.22부터 AIO를 사용할 수 있습니다. 또한 &lt;a href=&quot;#directio&quot;&gt;directio&lt;/a&gt; 를 활성화해야합니다. 그렇지 않으면 읽기가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="c8e295e098a5746d5b600d521bc5cb97fcfb15b9" translate="yes" xml:space="preserve">
          <source>On Linux, the &lt;code&gt;posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)&lt;/code&gt; system call is used, and so the &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; parameter is ignored.</source>
          <target state="translated">Linux에서는 &lt;code&gt;posix_fadvise(0, 0, 0, POSIX_FADV_SEQUENTIAL)&lt;/code&gt; 시스템 호출이 사용되므로 &lt;code&gt;&lt;i&gt;size&lt;/i&gt;&lt;/code&gt; 매개 변수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="af7a765b1360717bdb06e1ff30d455346e907462" translate="yes" xml:space="preserve">
          <source>On UNIX, the &lt;code&gt;&lt;i&gt;md5&lt;/i&gt;&lt;/code&gt; request argument value can be obtained as:</source>
          <target state="translated">UNIX에서 &lt;code&gt;&lt;i&gt;md5&lt;/i&gt;&lt;/code&gt; 요청 인수 값은 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c26c1a9c0709eb6de05d673cc3ac27cc0b5b84a" translate="yes" xml:space="preserve">
          <source>On UNIX, the hash value for this example can be obtained as:</source>
          <target state="translated">UNIX에서이 예제의 해시 값은 다음과 같이 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="595231ba17967729ff77264018bbd9c272546592" translate="yes" xml:space="preserve">
          <source>On systems that do not support opening of directories only for search, to use these parameters it is required that worker processes have read permissions for all directories being checked.</source>
          <target state="translated">검색 전용 디렉토리 열기를 지원하지 않는 시스템에서 이러한 매개 변수를 사용하려면 작업자 프로세스에 검사중인 모든 디렉토리에 대한 읽기 권한이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="53d11a61e43de28f334640395142186d93e6200d" translate="yes" xml:space="preserve">
          <source>On versions prior to 0.9.1, redirects can be made with:</source>
          <target state="translated">0.9.1 이전 버전에서는 다음을 사용하여 리디렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4da4a0e9af64b26d40b39fcba56a57d072f83943" translate="yes" xml:space="preserve">
          <source>Once the master process receives the signal to reload configuration, it checks the syntax validity of the new configuration file and tries to apply the configuration provided in it. If this is a success, the master process starts new worker processes and sends messages to old worker processes, requesting them to shut down. Otherwise, the master process rolls back the changes and continues to work with the old configuration. Old worker processes, receiving a command to shut down, stop accepting new connections and continue to service current requests until all such requests are serviced. After that, the old worker processes exit.</source>
          <target state="translated">마스터 프로세스가 구성을 다시로드하라는 신호를 수신하면 새 구성 파일의 구문 유효성을 검사하고 제공된 구성을 적용하려고합니다. 이것이 성공하면 마스터 프로세스는 새 작업자 프로세스를 시작하고 이전 작업자 프로세스에 메시지를 보내 종료하도록 요청합니다. 그렇지 않으면 마스터 프로세스는 변경 사항을 롤백하고 이전 구성으로 계속 작업합니다. 이전 작업자 프로세스, 종료 명령을 수신하고 새 연결 수락을 중지하고 이러한 요청이 모두 처리 될 때까지 현재 요청을 계속 처리합니다. 그런 다음 이전 작업자 프로세스가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="9ddd788df7eeadb3af4a850af142a0b0f6279478" translate="yes" xml:space="preserve">
          <source>One of the common scenarios for using DTrace with nginx is the following: attach to the nginx worker process to log request lines and request start times. The corresponding function to attach is &lt;code&gt;ngx_http_process_request()&lt;/code&gt;, and the argument in question is a pointer to the &lt;code&gt;ngx_http_request_t&lt;/code&gt; structure. DTrace script for such request logging can be as simple as:</source>
          <target state="translated">nginx와 함께 DTrace를 사용하는 일반적인 시나리오 중 하나는 다음과 같습니다. nginx 작업자 프로세스에 연결하여 요청 라인 및 요청 시작 시간을 기록합니다. 첨부 할 해당 함수는 &lt;code&gt;ngx_http_process_request()&lt;/code&gt; 이며 해당 인수는 &lt;code&gt;ngx_http_request_t&lt;/code&gt; 구조에 대한 포인터 입니다. 이러한 요청 로깅을위한 DTrace 스크립트는 다음과 같이 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a224de4f9d7b7383f3556cb406386539e0d4f7" translate="yes" xml:space="preserve">
          <source>One of the frequent uses of nginx is setting it up as a proxy server, which means a server that receives requests, passes them to the proxied servers, retrieves responses from them, and sends them to the clients.</source>
          <target state="translated">nginx의 빈번한 사용 중 하나는 프록시 서버로 설정하는 것인데, 이는 요청을 수신하여 프록시 서버로 전달하고 응답을 검색하여 클라이언트로 보내는 서버를 의미하는 서버를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="0f7b26b2ce5d8f0de0d591099bb07f9a3ed7a664" translate="yes" xml:space="preserve">
          <source>One of the old worker processes with PID 33129 still continues to work. After some time it exits:</source>
          <target state="translated">PID 33129를 사용하는 기존 작업자 프로세스 중 하나가 계속 작동합니다. 얼마 후 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="5e69e05b4cd613ffc1c42c258f79462e2066a14a" translate="yes" xml:space="preserve">
          <source>One of the processes is the master process and another is the worker process. If nginx does not start, look for the reason in the error log file &lt;code&gt;logs\error.log&lt;/code&gt;. If the log file has not been created, the reason for this should be reported in the Windows Event Log. If an error page is displayed instead of the expected page, also look for the reason in the &lt;code&gt;logs\error.log&lt;/code&gt; file.</source>
          <target state="translated">프로세스 중 하나는 마스터 프로세스이고 다른 프로세스는 작업자 프로세스입니다. nginx가 시작되지 않으면 오류 로그 파일 &lt;code&gt;logs\error.log&lt;/code&gt; 에서 이유를 찾으십시오 . 로그 파일이 작성되지 않은 경우 그 이유는 Windows 이벤트 로그에보고되어야합니다. 예상 페이지 대신 오류 페이지가 표시되면 &lt;code&gt;logs\error.log&lt;/code&gt; 파일 에서 이유를 찾으십시오 .</target>
        </trans-unit>
        <trans-unit id="65e7744a042fc074d8027c3fc8b751f3785227c0" translate="yes" xml:space="preserve">
          <source>One should bear in mind that passing a request to the next server is only possible if nothing has been sent to a client yet. That is, if an error or timeout occurs in the middle of the transferring of a response, fixing this is impossible.</source>
          <target state="translated">다음 서버로 요청을 전달하는 것은 아직 클라이언트에게 아무것도 전송되지 않은 경우에만 가능합니다. 즉, 응답 전송 도중 오류나 시간 초과가 발생하면이를 수정하는 것이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="bee0d4ef7eb28ed3981e2c3a6f098a0b2e4ca918" translate="yes" xml:space="preserve">
          <source>Only &amp;ldquo;&lt;code&gt;http://&lt;/code&gt;&amp;rdquo; OCSP responders are supported:</source>
          <target state="translated">&amp;ldquo; &lt;code&gt;http://&lt;/code&gt; &amp;rdquo;OCSP 응답자 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="8dbf445eedc2a8b0b21058d3e677c6abbe2905d9" translate="yes" xml:space="preserve">
          <source>Only OpenSSL 1.0.2 or higher supports separate &lt;a href=&quot;configuring_https_servers#chains&quot;&gt;certificate chains&lt;/a&gt; for different certificates. With older versions, only one certificate chain can be used.</source>
          <target state="translated">OpenSSL 1.0.2 이상 만 서로 다른 인증서에 대해 별도의 &lt;a href=&quot;configuring_https_servers#chains&quot;&gt;인증서 체인&lt;/a&gt; 을 지원합니다 . 이전 버전에서는 하나의 인증서 체인 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df39d623a8bd6bef003d04f9b162d90600354d45" translate="yes" xml:space="preserve">
          <source>Only OpenSSL 1.0.2 or higher supports separate certificate chains for different certificates. With older versions, only one certificate chain can be used.</source>
          <target state="translated">OpenSSL 1.0.2 이상 만 서로 다른 인증서에 대해 별도의 인증서 체인을 지원합니다. 이전 버전에서는 하나의 인증서 체인 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6443dc13d804e5b440738a7053a85607c8831533" translate="yes" xml:space="preserve">
          <source>Only byte strings can be converted to different encodings. For example, a string cannot be encoded to &lt;code&gt;hex&lt;/code&gt; directly:</source>
          <target state="translated">바이트 문자열 만 다른 인코딩으로 변환 할 수 있습니다. 예를 들어 문자열은 &lt;code&gt;hex&lt;/code&gt; 직접 인코딩 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3a44ad5c6700625bc744708ca5d8bce5f633129c" translate="yes" xml:space="preserve">
          <source>Only domain names can be passed in SNI, however some browsers may erroneously pass an IP address of the server as its name if a request includes literal IP address. One should not rely on this.</source>
          <target state="translated">SNI에는 도메인 이름 만 전달할 수 있지만 요청에 리터럴 IP 주소가 포함 된 경우 일부 브라우저가 서버의 IP 주소를 이름으로 잘못 전달할 수 있습니다. 이것에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="83f592d04d471125798463afa4a15531dafbc15f" translate="yes" xml:space="preserve">
          <source>Only one level of nesting is currently supported. The command has the following parameter:</source>
          <target state="translated">현재 한 수준의 중첩 만 지원됩니다. 이 명령에는 다음과 같은 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ce530dd8e66ad94d3874630e6a402448d1c5464" translate="yes" xml:space="preserve">
          <source>Only the first 256k of the response body are examined.</source>
          <target state="translated">응답 본문의 첫 256k 만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="624c6c03a4eef08de0d1212e8d117fd50006f46e" translate="yes" xml:space="preserve">
          <source>Only the first &lt;a href=&quot;ngx_stream_proxy_module#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt; bytes of data obtained from the server are examined.</source>
          <target state="translated">서버에서 얻은 첫 번째 &lt;a href=&quot;ngx_stream_proxy_module#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt; 바이트의 데이터 만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="36f9522bcb1dc90d1d63a85899758411e1e166de" translate="yes" xml:space="preserve">
          <source>Only the following codes could be returned before version 0.7.51: 204, 400, 402 &amp;mdash; 406, 408, 410, 411, 413, 416, and 500 &amp;mdash; 504.</source>
          <target state="translated">버전 0.7.51 이전에는 204, 400, 402 &amp;mdash; 406, 408, 410, 411, 413, 416 및 500 &amp;mdash; 504 코드 만 반환 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf5e093149fa15365c797b12b39a00d5ec3a138" translate="yes" xml:space="preserve">
          <source>Optimization</source>
          <target state="translated">Optimization</target>
        </trans-unit>
        <trans-unit id="b3cf670b4cd53291eab7084eb54459c65288db12" translate="yes" xml:space="preserve">
          <source>Other codes are considered successful finalization codes and might activate the request writer to finish sending the response body. Once the body is completely sent, the request &lt;code&gt;count&lt;/code&gt; is decremented. If it reaches zero, the request is destroyed, but the client connection can still be used for other requests. If &lt;code&gt;count&lt;/code&gt; is positive, there are unfinished activities within the request, which will be finalized at a later point.</source>
          <target state="translated">다른 코드는 성공적인 종료 코드로 간주되며 요청 작성기를 활성화하여 응답 본문 전송을 완료 할 수 있습니다. 본문이 완전히 전송되면 요청 &lt;code&gt;count&lt;/code&gt; 가 감소합니다. 0에 도달하면 요청이 삭제되지만 클라이언트 연결은 다른 요청에 계속 사용할 수 있습니다. 경우 &lt;code&gt;count&lt;/code&gt; 긍정적, 나중에에 완료 될 것이다 요청, 내 미완성 활동이있다.</target>
        </trans-unit>
        <trans-unit id="41ed4ec81c43288c78533c338a4c6d47a115a1bc" translate="yes" xml:space="preserve">
          <source>Other string functions are nginx-specific</source>
          <target state="translated">다른 문자열 함수는 nginx에 따라 다릅니다</target>
        </trans-unit>
        <trans-unit id="43539155696cfdb670a881c70430463a71be8f6a" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;code&gt;options&lt;/code&gt; is expected to be an object with the following keys:</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;options&lt;/code&gt; 은 다음 키가있는 객체가 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="209745a6c2578fa439ca738b24293764eb32679d" translate="yes" xml:space="preserve">
          <source>Outputs the value of a variable. The command has the following parameters:</source>
          <target state="translated">변수의 값을 출력합니다. 이 명령에는 다음과 같은 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd84dd935fd4f1e0c7dc44f40efd5b205c11b5d9" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;ngx_stream_proxy_module#proxy_timeout&quot;&gt;proxy_timeout&lt;/a&gt; value for health checks.</source>
          <target state="translated">상태 확인에 대한 &lt;a href=&quot;ngx_stream_proxy_module#proxy_timeout&quot;&gt;proxy_timeout&lt;/a&gt; 값을 재정의 합니다.</target>
        </trans-unit>
        <trans-unit id="12d7b7601f875d6b59b17fedf97a757d1a73dbd8" translate="yes" xml:space="preserve">
          <source>Overrides the URL of the OCSP responder specified in the &amp;ldquo;&lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.2.1&quot;&gt;Authority Information Access&lt;/a&gt;&amp;rdquo; certificate extension for &lt;a href=&quot;#ssl_ocsp&quot;&gt;validation&lt;/a&gt; of client certificates.</source>
          <target state="translated">클라이언트 인증서 &lt;a href=&quot;#ssl_ocsp&quot;&gt;유효성 검사&lt;/a&gt; 를 위해 &quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.2.1&quot;&gt;기관 정보 액세스&lt;/a&gt; &quot;인증서 확장에 지정된 OCSP 응답자의 URL을 재정의합니다 .</target>
        </trans-unit>
        <trans-unit id="30956c34294fda22aa2c49d9b60faca2d9452612" translate="yes" xml:space="preserve">
          <source>Overrides the URL of the OCSP responder specified in the &amp;ldquo;&lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.2.1&quot;&gt;Authority Information Access&lt;/a&gt;&amp;rdquo; certificate extension.</source>
          <target state="translated">&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc5280#section-4.2.2.1&quot;&gt;기관 정보 액세스&lt;/a&gt; &quot;인증서 확장에 지정된 OCSP 응답자의 URL을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="6505fb6cb3d9e92f68ef8c0e1d61d7f592b26dd7" translate="yes" xml:space="preserve">
          <source>PCRE JIT can speed up processing of regular expressions significantly.</source>
          <target state="translated">PCRE JIT는 정규식 처리 속도를 크게 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a837860a036b4f28321b03089e42844cbc726e6b" translate="yes" xml:space="preserve">
          <source>PID of the worker process</source>
          <target state="translated">작업자 프로세스의 PID</target>
        </trans-unit>
        <trans-unit id="f3db0385c25c5560fbfafe9942c025588b7a2132" translate="yes" xml:space="preserve">
          <source>Parameter value can contain variables (1.17.0). It may be useful in cases where rate should be limited depending on a certain condition:</source>
          <target state="translated">매개 변수 값은 변수 (1.17.0)를 포함 할 수 있습니다. 특정 조건에 따라 속도를 제한해야하는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="02f7f392d361f654f1d08d8fa1b649439412291f" translate="yes" xml:space="preserve">
          <source>Parameter value can contain variables (1.17.8). In this case, if an address is specified as a domain name, the name is searched among the described &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;server groups&lt;/a&gt;, and, if not found, is determined using a &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver&lt;/a&gt;.</source>
          <target state="translated">매개 변수 값은 변수 (1.17.8)를 포함 할 수 있습니다. 이 경우 주소가 도메인 이름으로 지정되면 설명 된 &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;서버 그룹&lt;/a&gt; 중에서 이름을 검색 하고 찾을 수없는 경우 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;리졸버를&lt;/a&gt; 사용하여 이름을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="ebdbe3f857b56da39607dc27e90670f916b2ffb9" translate="yes" xml:space="preserve">
          <source>Parameter value can contain variables. In this case, if an address is specified as a domain name, the name is searched among the described &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;server groups&lt;/a&gt;, and, if not found, is determined using a &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver&lt;/a&gt;.</source>
          <target state="translated">매개 변수 값은 변수를 포함 할 수 있습니다. 이 경우, 주소가 도메인 이름으로 지정된 경우, 이름은 설명 된 &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;서버 그룹&lt;/a&gt; 중에서 검색 되며, 찾을 수없는 경우 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;확인자를&lt;/a&gt; 사용하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="bec7fc3774b04901f3fa374013fe921916df04bc" translate="yes" xml:space="preserve">
          <source>Parameter value can contain variables. In this case, if an address is specified as a domain name, the name is searched among the described server groups, and, if not found, is determined using a &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver&lt;/a&gt;.</source>
          <target state="translated">매개 변수 값은 변수를 포함 할 수 있습니다. 이 경우, 주소가 도메인 이름으로 지정된 경우, 이름은 설명 된 서버 그룹 중에서 검색되며, 찾을 수없는 경우 &lt;a href=&quot;ngx_http_core_module#resolver&quot;&gt;resolver를&lt;/a&gt; 사용하여 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eeee98750f33cbffaeac15159e30b9114ed6039" translate="yes" xml:space="preserve">
          <source>Parameters &lt;code&gt;on&lt;/code&gt; and &lt;code&gt;if_not_owner&lt;/code&gt; add a processing overhead.</source>
          <target state="translated">&lt;code&gt;on&lt;/code&gt; 및 &lt;code&gt;if_not_owner&lt;/code&gt; 매개 변수 는 처리 오버 헤드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="502a90e4f23d4e19602b6f2ef19cc7f14148f5c9" translate="yes" xml:space="preserve">
          <source>Parameters Passed to a FastCGI Server</source>
          <target state="translated">FastCGI 서버로 전달되는 매개 변수</target>
        </trans-unit>
        <trans-unit id="e8c4a4a549aaa8d130248ec73f8c6226f5432358" translate="yes" xml:space="preserve">
          <source>Parameters can be as follows:</source>
          <target state="translated">매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c62ca915db061750611bcdfb24f8045ff0f0f95e" translate="yes" xml:space="preserve">
          <source>Parameters can either be specified separately, or grouped in a single line using the &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; delimiter. If a parameter includes the &amp;ldquo;&lt;code&gt;:&lt;/code&gt;&amp;rdquo; character, it should be escaped as &amp;ldquo;&lt;code&gt;%3A&lt;/code&gt;&amp;rdquo;. Also, &lt;code&gt;libxslt&lt;/code&gt; requires to enclose parameters that contain non-alphanumeric characters into single or double quotes, for example:</source>
          <target state="translated">매개 변수는 별도로 지정하거나&amp;ldquo; &lt;code&gt;:&lt;/code&gt; &amp;rdquo;구분 기호를 사용하여 한 줄로 그룹화 할 수 있습니다 . 매개 변수에 &quot; &lt;code&gt;:&lt;/code&gt; &quot;문자가 포함 된 경우 &quot; &lt;code&gt;%3A&lt;/code&gt; &quot; 로 이스케이프되어야합니다 . 또한 &lt;code&gt;libxslt&lt;/code&gt; 는 영숫자가 아닌 문자를 포함하는 매개 변수를 작은 따옴표 나 큰 따옴표로 묶어야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3ba5a3cbbabe4ab5f3edbd3a386d32b72c2bad04" translate="yes" xml:space="preserve">
          <source>Parameters common for all methods:</source>
          <target state="translated">모든 방법에 공통적 인 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="59ea799800e951914bbd4c173657fa31377de616" translate="yes" xml:space="preserve">
          <source>Parameters inside the &lt;code&gt;map&lt;/code&gt; block specify a mapping between source and resulting values.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; 블록 내의 매개 변수 는 소스와 결과 값 사이의 맵핑을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="78fd345ae86a4ea1ea7bd125a2ecd2e2de6968a6" translate="yes" xml:space="preserve">
          <source>Parameters of caching can also be set directly in the response header. This has higher priority than setting of caching time using the directive.</source>
          <target state="translated">캐싱 매개 변수는 응답 헤더에서 직접 설정할 수도 있습니다. 지시문을 사용한 캐싱 시간 설정보다 우선 순위가 높습니다.</target>
        </trans-unit>
        <trans-unit id="c3b5e5bf63e1996a5ed8dae916db62eb74ba6acd" translate="yes" xml:space="preserve">
          <source>Parent server ID of the resolved server. The ID is assigned automatically and cannot be changed.</source>
          <target state="translated">해결 된 서버의 상위 서버 ID ID는 자동으로 할당되며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ee421106640b5826eebeeedd2d468fe11c8de33" translate="yes" xml:space="preserve">
          <source>Parses the query string URL and returns an object.</source>
          <target state="translated">쿼리 문자열 URL을 구문 분석하고 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c1b95b1e060899e9d8da0fe7d256756b8ca63e0" translate="yes" xml:space="preserve">
          <source>Passing a connection to the next server can be limited by &lt;a href=&quot;#proxy_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#proxy_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로의 연결 &lt;a href=&quot;#proxy_next_upstream_tries&quot;&gt;은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#proxy_next_upstream_timeout&quot;&gt;시간&lt;/a&gt; 에 따라 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="aedd8abdccf4d529a68b1fa5ba2ece8980eaad47" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#fastcgi_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#fastcgi_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#fastcgi_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#fastcgi_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca002d58a3c0f32481b5363e0274ef1ffc7c306a" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#grpc_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#grpc_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#grpc_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#grpc_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5fd0fe49b521cfb5e49767d2559dc1989b1e9a27" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#memcached_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#memcached_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#memcached_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#memcached_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2dfc0b91490d4e9c24a45f3ac16e8426649b547e" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#proxy_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#proxy_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#proxy_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#proxy_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="993ed4d4f883dbc6ef78d581e467bb5d148303f8" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#scgi_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#scgi_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#scgi_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#scgi_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48dd74d6b46ffd3fe42490869b72fd6792443a01" translate="yes" xml:space="preserve">
          <source>Passing a request to the next server can be limited by &lt;a href=&quot;#uwsgi_next_upstream_tries&quot;&gt;the number of tries&lt;/a&gt; and by &lt;a href=&quot;#uwsgi_next_upstream_timeout&quot;&gt;time&lt;/a&gt;.</source>
          <target state="translated">다음 서버로 요청을 전달하는 &lt;a href=&quot;#uwsgi_next_upstream_tries&quot;&gt;것은 시도 횟수&lt;/a&gt; 와 &lt;a href=&quot;#uwsgi_next_upstream_timeout&quot;&gt;시간에&lt;/a&gt; 의해 제한 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d61fb8b420f13e4bcd8d797763fb34470df2a2b8" translate="yes" xml:space="preserve">
          <source>People who during their shared hosting life used to configure</source>
          <target state="translated">공유 호스팅 수명 동안 구성하는 데 사용 된 사람들</target>
        </trans-unit>
        <trans-unit id="31186b0c721d0b891df19158f8fb313fb1de36e7" translate="yes" xml:space="preserve">
          <source>Performs URL encoding of the given &lt;code&gt;string&lt;/code&gt;, returns an escaped query string. The method is used by &lt;a href=&quot;#querystring_stringify&quot;&gt;&lt;code&gt;querystring.stringify()&lt;/code&gt;&lt;/a&gt; and should not be used directly.</source>
          <target state="translated">주어진 &lt;code&gt;string&lt;/code&gt; 의 URL 인코딩을 수행 하고 이스케이프 된 쿼리 문자열을 반환합니다. 이 메서드는 &lt;a href=&quot;#querystring_stringify&quot;&gt; &lt;code&gt;querystring.stringify()&lt;/code&gt; &lt;/a&gt; 사용되며 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="7fa93baef7e2259e6c22bca029690d5b055c2b25" translate="yes" xml:space="preserve">
          <source>Performs a conditional inclusion. The following commands are supported:</source>
          <target state="translated">조건부 포함을 수행합니다. 다음 명령이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="b47b0f9ce8a56d303bbafa1c3170f94e03f9c725" translate="yes" xml:space="preserve">
          <source>Performs decoding of URL percent-encoded characters of the &lt;code&gt;string&lt;/code&gt;, returns an unescaped query string. The method is used by &lt;a href=&quot;#querystring_parse&quot;&gt;&lt;code&gt;querystring.parse()&lt;/code&gt;&lt;/a&gt; and should not be used directly.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 의 URL 퍼센트 인코딩 문자 디코딩을 수행 하고 이스케이프 처리되지 않은 쿼리 문자열을 반환합니다. 이 메서드는 &lt;a href=&quot;#querystring_parse&quot;&gt; &lt;code&gt;querystring.parse()&lt;/code&gt; &lt;/a&gt; 사용되며 직접 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="8552f289f18dacdf1368b32892fbcd731fde3093" translate="yes" xml:space="preserve">
          <source>Perl 5.10 compatible syntax, supported since PCRE-7.0</source>
          <target state="translated">PCRE-7.0부터 지원되는 Perl 5.10 호환 구문</target>
        </trans-unit>
        <trans-unit id="f78bdcefc24b555559dec529284d1cf609c1260b" translate="yes" xml:space="preserve">
          <source>Perl, if you want to build OpenSSL&lt;sup&gt;&amp;reg;&lt;/sup&gt; and nginx with SSL support. For example &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; or &lt;a href=&quot;http://strawberryperl.com&quot;&gt;Strawberry Perl&lt;/a&gt;.</source>
          <target state="translated">SSL을 지원 하는 OpenSSL &lt;sup&gt;&amp;reg;&lt;/sup&gt; 및 nginx 를 빌드하려는 경우 Perl . 예를 들어 &lt;a href=&quot;http://www.activestate.com/activeperl&quot;&gt;ActivePerl&lt;/a&gt; 또는 &lt;a href=&quot;http://strawberryperl.com&quot;&gt;Strawberry Perl&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e2fcb2647a9af35eaf1df340a2b2c8f3107f075" translate="yes" xml:space="preserve">
          <source>Permits passing &lt;a href=&quot;#fastcgi_hide_header&quot;&gt;otherwise disabled&lt;/a&gt; header fields from a FastCGI server to a client.</source>
          <target state="translated">&lt;a href=&quot;#fastcgi_hide_header&quot;&gt;그렇지 않으면 비활성화 된&lt;/a&gt; 헤더 필드를 FastCGI 서버에서 클라이언트로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d19c11197d024dc5103d1f15a1355c57f3960de" translate="yes" xml:space="preserve">
          <source>Permits passing &lt;a href=&quot;#grpc_hide_header&quot;&gt;otherwise disabled&lt;/a&gt; header fields from a gRPC server to a client.</source>
          <target state="translated">gRPC 서버에서 클라이언트로 &lt;a href=&quot;#grpc_hide_header&quot;&gt;달리 비활성화 된&lt;/a&gt; 헤더 필드를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57b9dd4aeb60ef7c1b6ad8e5b340bbcd53b28c17" translate="yes" xml:space="preserve">
          <source>Permits passing &lt;a href=&quot;#proxy_hide_header&quot;&gt;otherwise disabled&lt;/a&gt; header fields from a proxied server to a client.</source>
          <target state="translated">프록시 서버에서 클라이언트로 &lt;a href=&quot;#proxy_hide_header&quot;&gt;달리 비활성화 된&lt;/a&gt; 헤더 필드를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a13da424cfbcb7f4836b8212434b68b562e4f1" translate="yes" xml:space="preserve">
          <source>Permits passing &lt;a href=&quot;#scgi_hide_header&quot;&gt;otherwise disabled&lt;/a&gt; header fields from an SCGI server to a client.</source>
          <target state="translated">&lt;a href=&quot;#scgi_hide_header&quot;&gt;달리 비활성화 된&lt;/a&gt; 헤더 필드를 SCGI 서버에서 클라이언트로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e4c081e318e8fa7abd47b86822089529bd5223a" translate="yes" xml:space="preserve">
          <source>Permits passing &lt;a href=&quot;#uwsgi_hide_header&quot;&gt;otherwise disabled&lt;/a&gt; header fields from a uwsgi server to a client.</source>
          <target state="translated">통과 허가 &lt;a href=&quot;#uwsgi_hide_header&quot;&gt;그렇지 않으면 비활성화&lt;/a&gt; 클라이언트로 uwsgi 서버에서 헤더 필드를.</target>
        </trans-unit>
        <trans-unit id="c76ea3ad850340e22aade0de39ec43e495956797" translate="yes" xml:space="preserve">
          <source>Phase handlers are expected to return specific codes:</source>
          <target state="translated">위상 핸들러는 다음과 같은 특정 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1299c5da4d36f7c6543acebafdc41ccf1b565939" translate="yes" xml:space="preserve">
          <source>Phases</source>
          <target state="translated">Phases</target>
        </trans-unit>
        <trans-unit id="f3c7744d6b88b42d49ac58a00d76714bba945fe0" translate="yes" xml:space="preserve">
          <source>Platform-specific APIs</source>
          <target state="translated">플랫폼 별 API</target>
        </trans-unit>
        <trans-unit id="3ae2c2ab560ee9396868e39d4cc2c80645dcca81" translate="yes" xml:space="preserve">
          <source>Please note that most of the variables will have empty values when used with health checks.</source>
          <target state="translated">상태 확인과 함께 사용하면 대부분의 변수에 빈 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0099fdb41b20bc684c20322562c835e9aa5e22bd" translate="yes" xml:space="preserve">
          <source>Please note that this will limit access to all methods &lt;strong&gt;except&lt;/strong&gt; GET and HEAD.</source>
          <target state="translated">이는 GET 및 HEAD를 &lt;strong&gt;제외한&lt;/strong&gt; 모든 메소드에 대한 액세스를 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="2873f7f45acd93b2185be226c51316d30b60fba0" translate="yes" xml:space="preserve">
          <source>Please note that with round-robin or least-connected load balancing, each subsequent client&amp;rsquo;s request can be potentially distributed to a different server. There is no guarantee that the same client will be always directed to the same server.</source>
          <target state="translated">라운드 로빈 또는 최소 연결 부하 분산을 사용하면 이후의 각 클라이언트 요청이 다른 서버로 분산 될 수 있습니다. 동일한 클라이언트가 항상 동일한 서버로 연결될 것이라는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a5b14fc10103a5687b6862d3e52810e28822aaf" translate="yes" xml:space="preserve">
          <source>Pointers are explicitly compared to &lt;code&gt;NULL&lt;/code&gt; (not &lt;code&gt;0&lt;/code&gt;):</source>
          <target state="translated">포인터는 명시 적으로 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 &lt;code&gt;0&lt;/code&gt; 과 비교됩니다 .</target>
        </trans-unit>
        <trans-unit id="778627418cb4b30cdfe47281afdbf30f1a173700" translate="yes" xml:space="preserve">
          <source>Pool</source>
          <target state="translated">Pool</target>
        </trans-unit>
        <trans-unit id="b8f82152fedd75a4a9923f8bf5623bebdae65ece" translate="yes" xml:space="preserve">
          <source>Port ranges (1.15.10) are specified with the first and last port separated by a hyphen:</source>
          <target state="translated">포트 범위 (1.15.10)는 첫 번째 포트와 마지막 포트를 하이픈으로 구분하여 지정합니다.</target>
        </trans-unit>
        <trans-unit id="62435c5f99c54a9243d8506f9978744ee5729e11" translate="yes" xml:space="preserve">
          <source>Possible future enhancements</source>
          <target state="translated">향후 개선 가능</target>
        </trans-unit>
        <trans-unit id="9c6a0c395807e3433a17140b90c66a4a3ab664a0" translate="yes" xml:space="preserve">
          <source>Possible responses:</source>
          <target state="translated">가능한 답변 :</target>
        </trans-unit>
        <trans-unit id="2fc5815b6a4a78d30f1fddc4cf16bcbeaf73e575" translate="yes" xml:space="preserve">
          <source>Posted events</source>
          <target state="translated">게시 된 이벤트</target>
        </trans-unit>
        <trans-unit id="5018a100839e3806d77ed5aa4b9aec78591f9a6e" translate="yes" xml:space="preserve">
          <source>Pre-built &lt;a href=&quot;https://nginx.org/en/linux_packages.html&quot;&gt;Linux&lt;/a&gt; packages provide out-of-the-box support for debugging log with the &lt;code&gt;nginx-debug&lt;/code&gt; binary (1.9.8) which can be run using commands</source>
          <target state="translated">사전 빌드 된 &lt;a href=&quot;https://nginx.org/en/linux_packages.html&quot;&gt;Linux&lt;/a&gt; 패키지는 명령을 사용하여 실행할 수있는 &lt;code&gt;nginx-debug&lt;/code&gt; 바이너리 (1.9.8)로 로그 디버깅을위한 기본 지원을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="ea40acfa8199f2f5fac55591f887b6d9fbda8918" translate="yes" xml:space="preserve">
          <source>Pre-emptively sends (&lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;pushes&lt;/a&gt;) a request to the specified &lt;code&gt;&lt;i&gt;uri&lt;/i&gt;&lt;/code&gt; along with the response to the original request. Only relative URIs with absolute path will be processed, for example:</source>
          <target state="translated">중고 예방 적 (전송 &lt;a href=&quot;https://tools.ietf.org/html/rfc7540#section-8.2&quot;&gt;푸시를&lt;/a&gt; 지정하는 요청) &lt;code&gt;&lt;i&gt;uri&lt;/i&gt;&lt;/code&gt; 원래의 요청에 대한 응답과 함께. 절대 경로가있는 상대 URI 만 처리됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="8ab292b079797532185c3339e2d3bca94dcd3171" translate="yes" xml:space="preserve">
          <source>Preliminary check for access. The &lt;a href=&quot;ngx_stream_limit_conn_module&quot;&gt;ngx_stream_limit_conn_module&lt;/a&gt; and &lt;a href=&quot;ngx_stream_set_module&quot;&gt;ngx_stream_set_module&lt;/a&gt; modules are invoked at this phase.</source>
          <target state="translated">액세스를위한 예비 점검. &lt;a href=&quot;ngx_stream_limit_conn_module&quot;&gt;ngx_stream_limit_conn_module&lt;/a&gt; 및 &lt;a href=&quot;ngx_stream_set_module&quot;&gt;ngx_stream_set_module&lt;/a&gt; 모듈은이 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="46fec83cee33c96793f4840bbc8a39f30cbbe386" translate="yes" xml:space="preserve">
          <source>Preliminary check for access. The &lt;a href=&quot;ngx_stream_limit_conn_module&quot;&gt;ngx_stream_limit_conn_module&lt;/a&gt; module is invoked at this phase.</source>
          <target state="translated">접근을위한 예비 점검. &lt;a href=&quot;ngx_stream_limit_conn_module&quot;&gt;ngx_stream_limit_conn_module&lt;/a&gt; 모듈은이 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="690b8706d3e1f79bde61f6dc644048c260a4aafe" translate="yes" xml:space="preserve">
          <source>Preprocessor</source>
          <target state="translated">Preprocessor</target>
        </trans-unit>
        <trans-unit id="eed036e414a34a0c245858652e6d88f14c3faefb" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
          <target state="translated">Prerequisites</target>
        </trans-unit>
        <trans-unit id="39508f9eb0f4608781c6357701ef0f850ac31139" translate="yes" xml:space="preserve">
          <source>Presentation at nginx.conf 2018</source>
          <target state="translated">nginx.conf 2018에서 프레젠테이션</target>
        </trans-unit>
        <trans-unit id="adef4f4b9461e3e8e2f89308f210e7e6808d7119" translate="yes" xml:space="preserve">
          <source>Prior to 0.7.14 SSL could not be enabled selectively for individual listening sockets, as shown above. SSL could only be enabled for the entire server using the &lt;a href=&quot;ngx_http_ssl_module#ssl&quot;&gt;ssl&lt;/a&gt; directive, making it impossible to set up a single HTTP/HTTPS server. The &lt;code&gt;ssl&lt;/code&gt; parameter of the &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;listen&lt;/a&gt; directive was added to solve this issue. The use of the &lt;a href=&quot;ngx_http_ssl_module#ssl&quot;&gt;ssl&lt;/a&gt; directive in modern versions is thus discouraged.</source>
          <target state="translated">0.7.14 이전에는 위에 표시된대로 개별 청취 소켓에 대해 SSL을 선택적으로 사용할 수 없었습니다. SSL은 &lt;a href=&quot;ngx_http_ssl_module#ssl&quot;&gt;ssl&lt;/a&gt; 지시문을 사용하여 전체 서버에 대해서만 사용할 수 있으므로 단일 HTTP / HTTPS 서버를 설정할 수 없습니다. &lt;a href=&quot;ngx_http_core_module#listen&quot;&gt;청취&lt;/a&gt; 지시문 의 &lt;code&gt;ssl&lt;/code&gt; 매개 변수 가이 문제를 해결하기 위해 추가되었습니다. 따라서 최신 버전에서 &lt;a href=&quot;ngx_http_ssl_module#ssl&quot;&gt;ssl&lt;/a&gt; 지시문을 사용 하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2a1bcbbcaef344c57e256c4cad8ad5209835d1d4" translate="yes" xml:space="preserve">
          <source>Prior to version 1.1.18, the value &lt;code&gt;safari&lt;/code&gt; matched all Safari and Safari-like browsers on all operating systems, and keep-alive connections with them were disabled by default.</source>
          <target state="translated">버전 1.1.18 이전에는 &lt;code&gt;safari&lt;/code&gt; 값이 모든 운영 체제의 모든 Safari 및 Safari와 유사한 브라우저와 일치했으며 기본적으로 연결 유지 연결이 비활성화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8224e984175a9e1e3119cf797205a5089e7f746" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.0, builtin parameters were used by default.</source>
          <target state="translated">버전 1.11.0 이전에는 기본적으로 내장 매개 변수가 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="a5414ce3b4c1ea87adc46335be59ebdcc5c41d8d" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.0, the &lt;code&gt;prime256v1&lt;/code&gt; curve was used by default.</source>
          <target state="translated">버전 1.11.0 이전에는 기본적으로 &lt;code&gt;prime256v1&lt;/code&gt; 곡선이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="bb4ad9de2ba3fe1902e9d58e55eb0dd0ac62be57" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.3, the default value was &lt;code&gt;on&lt;/code&gt;.</source>
          <target state="translated">버전 1.11.3 이전의 기본값은 &lt;code&gt;on&lt;/code&gt; 이었습니다 .</target>
        </trans-unit>
        <trans-unit id="72d580afe3f548f4300147c071b4d580d18db6a3" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.5, this parameter was available as part of our &lt;a href=&quot;http://nginx.com/products/&quot;&gt;commercial subscription&lt;/a&gt;.</source>
          <target state="translated">버전 1.11.5 이전에는이 ​​매개 변수가 &lt;a href=&quot;http://nginx.com/products/&quot;&gt;상용 구독의&lt;/a&gt; 일부로 제공되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1a117c63c6d0ea7768c1e3d200515a0c3a92ee1f" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.6, incomplete connections were taken into account by default.</source>
          <target state="translated">버전 1.11.6 이전에는 기본적으로 불완전한 연결이 고려되었습니다.</target>
        </trans-unit>
        <trans-unit id="694949775465a37da6f11b0ed64a5b4c80755c03" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.6, incomplete requests were taken into account by default.</source>
          <target state="translated">버전 1.11.6 이전에는 불완전한 요청이 기본적으로 고려되었습니다.</target>
        </trans-unit>
        <trans-unit id="da131d1990affc2690f1573d76788517e43ca52a" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.6, the variable name was &lt;code&gt;$ssl_client_i_dn&lt;/code&gt;.</source>
          <target state="translated">버전 1.11.6 이전의 변수 이름은 &lt;code&gt;$ssl_client_i_dn&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="448439664c0b232923b50fc403e082936dd48d9c" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.6, the variable name was &lt;code&gt;$ssl_client_s_dn&lt;/code&gt;.</source>
          <target state="translated">버전 1.11.6 이전의 변수 이름은 &lt;code&gt;$ssl_client_s_dn&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3837f89cad6e7bd0082543e9d9d08b3fc2012ba6" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.7, by default, UDP health check required a &lt;a href=&quot;#hc_match&quot;&gt;match&lt;/a&gt; block with the &lt;a href=&quot;#match_send&quot;&gt;send&lt;/a&gt; and &lt;a href=&quot;#match_expect&quot;&gt;expect&lt;/a&gt; parameters.</source>
          <target state="translated">버전 1.11.7 이전에는 기본적으로 UDP 상태 확인 에 &lt;a href=&quot;#match_send&quot;&gt;send&lt;/a&gt; 및 &lt;a href=&quot;#match_expect&quot;&gt;expect&lt;/a&gt; 매개 변수가 있는 &lt;a href=&quot;#hc_match&quot;&gt;일치&lt;/a&gt; 블록이 필요했습니다 .</target>
        </trans-unit>
        <trans-unit id="c21cb37f52a6a32a1980ebf615c7392b03b2fa11" translate="yes" xml:space="preserve">
          <source>Prior to version 1.11.7, the &amp;ldquo;&lt;code&gt;FAILED&lt;/code&gt;&amp;rdquo; result did not contain the &lt;code&gt;&lt;i&gt;reason&lt;/i&gt;&lt;/code&gt; string.</source>
          <target state="translated">버전 1.11.7 이전에는 &quot; &lt;code&gt;FAILED&lt;/code&gt; &quot;결과에 &lt;code&gt;&lt;i&gt;reason&lt;/i&gt;&lt;/code&gt; 문자열이 포함되지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="8402fb579d19d95a42e184bc856752d4c79e6e49" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.10, only the results of responses obtained using the &lt;a href=&quot;ngx_http_proxy_module&quot;&gt;ngx_http_proxy_module&lt;/a&gt;, &lt;a href=&quot;ngx_http_memcached_module&quot;&gt;ngx_http_memcached_module&lt;/a&gt;, &lt;a href=&quot;ngx_http_fastcgi_module&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt; (1.5.6), &lt;a href=&quot;ngx_http_uwsgi_module&quot;&gt;ngx_http_uwsgi_module&lt;/a&gt; (1.5.6), and &lt;a href=&quot;ngx_http_scgi_module&quot;&gt;ngx_http_scgi_module&lt;/a&gt; (1.5.6) modules could be written into variables. The maximum size of the response was set with the &lt;a href=&quot;ngx_http_proxy_module#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt;, &lt;a href=&quot;ngx_http_memcached_module#memcached_buffer_size&quot;&gt;memcached_buffer_size&lt;/a&gt;, &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_buffer_size&quot;&gt;fastcgi_buffer_size&lt;/a&gt;, &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_buffer_size&quot;&gt;uwsgi_buffer_size&lt;/a&gt;, and &lt;a href=&quot;ngx_http_scgi_module#scgi_buffer_size&quot;&gt;scgi_buffer_size&lt;/a&gt; directives.</source>
          <target state="translated">버전 1.13.10 이전에는 &lt;a href=&quot;ngx_http_proxy_module&quot;&gt;ngx_http_proxy_module&lt;/a&gt; , &lt;a href=&quot;ngx_http_memcached_module&quot;&gt;ngx_http_memcached_module&lt;/a&gt; , &lt;a href=&quot;ngx_http_fastcgi_module&quot;&gt;ngx_http_fastcgi_module&lt;/a&gt; (1.5.6), &lt;a href=&quot;ngx_http_uwsgi_module&quot;&gt;ngx_http_uwsgi_module&lt;/a&gt; (1.5.6) 및 &lt;a href=&quot;ngx_http_scgi_module&quot;&gt;ngx_http_scgi_module&lt;/a&gt; (1.5.6) 모듈을 사용하여 얻은 응답 결과 만 변수에 쓸 수있었습니다. 응답의 최대 크기는 &lt;a href=&quot;ngx_http_proxy_module#proxy_buffer_size&quot;&gt;proxy_buffer_size&lt;/a&gt; , &lt;a href=&quot;ngx_http_memcached_module#memcached_buffer_size&quot;&gt;memcached_buffer_size&lt;/a&gt; , &lt;a href=&quot;ngx_http_fastcgi_module#fastcgi_buffer_size&quot;&gt;fastcgi_buffer_size&lt;/a&gt; , &lt;a href=&quot;ngx_http_uwsgi_module#uwsgi_buffer_size&quot;&gt;uwsgi_buffer_size&lt;/a&gt; 및 &lt;a href=&quot;ngx_http_scgi_module#scgi_buffer_size&quot;&gt;scgi_buffer_size&lt;/a&gt; 지시문으로 설정되었습니다.</target>
        </trans-unit>
        <trans-unit id="bee4b70a4821718004780abd3b7c9dbaec6846d8" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.3, the configuration was accessible only via a special location handled by &lt;a href=&quot;../http/ngx_http_upstream_conf_module#upstream_conf&quot;&gt;upstream_conf&lt;/a&gt;.</source>
          <target state="translated">버전 1.13.3 이전에는 &lt;a href=&quot;../http/ngx_http_upstream_conf_module#upstream_conf&quot;&gt;upstream_conf가&lt;/a&gt; 처리하는 특수 위치를 통해서만 구성에 액세스 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="aa2d2ef5e03a3e0afbda527c9407cf8991a262ac" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.3, the configuration was accessible only via a special location handled by &lt;a href=&quot;ngx_http_upstream_conf_module#upstream_conf&quot;&gt;upstream_conf&lt;/a&gt;.</source>
          <target state="translated">버전 1.13.3 이전에는 &lt;a href=&quot;ngx_http_upstream_conf_module#upstream_conf&quot;&gt;upstream_conf가&lt;/a&gt; 처리하는 특수 위치를 통해서만 구성에 액세스 할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="6346fcecae7e942ca92f4cffbd19a7ba8f9cd8f9" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.6, the parameter could be changed only with the &lt;a href=&quot;ngx_http_api_module&quot;&gt;API&lt;/a&gt; module.</source>
          <target state="translated">버전 1.13.6 이전에는 &lt;a href=&quot;ngx_http_api_module&quot;&gt;API&lt;/a&gt; 모듈 에서만 매개 변수를 변경할 수있었습니다 .</target>
        </trans-unit>
        <trans-unit id="95f5f225fad2e412bb9d993a128518afda9cfade" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.7, only HS256, RS256, ES256 algorithms were supported.</source>
          <target state="translated">버전 1.13.7 이전에는 HS256, RS256, ES256 알고리즘 만 지원되었습니다.</target>
        </trans-unit>
        <trans-unit id="5a53b7293052cf3e11f9fccaba40ba8897f47670" translate="yes" xml:space="preserve">
          <source>Prior to version 1.13.7, only one key name could be specified, and the result was undefined for arrays.</source>
          <target state="translated">버전 1.13.7 이전에는 하나의 키 이름 만 지정할 수 있었고 결과는 배열에 대해 정의되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="810e6fdc2bba496155329ff10cd547934a45db76" translate="yes" xml:space="preserve">
          <source>Prior to version 1.3.4, if this parameter was omitted then the operating system&amp;rsquo;s settings were in effect for the socket.</source>
          <target state="translated">버전 1.3.4 이전에이 매개 변수를 생략하면 운영 체제의 설정이 소켓에 적용되었습니다.</target>
        </trans-unit>
        <trans-unit id="0731982d2a6dd59c46e5623c55f5f4237234ec2a" translate="yes" xml:space="preserve">
          <source>Prior to version 1.5.13, the default value depended on the size of the processor&amp;rsquo;s cache line.</source>
          <target state="translated">버전 1.5.13 이전의 기본값은 프로세서 캐시 라인의 크기에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="4c8ce26c76f3b6b3996216182323ec95d8bab55e" translate="yes" xml:space="preserve">
          <source>Prior to version 1.5.13, the default value was 512.</source>
          <target state="translated">버전 1.5.13 이전의 기본값은 512였습니다.</target>
        </trans-unit>
        <trans-unit id="866f3cd54b48049b677067cd6383fc7b5f20ffbc" translate="yes" xml:space="preserve">
          <source>Prior to version 1.7.6, a &lt;code&gt;&lt;i&gt;key&lt;/i&gt;&lt;/code&gt; could contain exactly one variable.</source>
          <target state="translated">버전 1.7.6 이전에는 &lt;code&gt;&lt;i&gt;key&lt;/i&gt;&lt;/code&gt; 정확히 하나의 변수가 포함될 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="20c8ee11395e298935fc3fd57b20ff6cb5e77753" translate="yes" xml:space="preserve">
          <source>Prior to version 1.9.5, the default value was 1 32k.</source>
          <target state="translated">버전 1.9.5 이전의 기본값은 1 32k입니다.</target>
        </trans-unit>
        <trans-unit id="8573eb79ea2e655a211288294c0d6723a7c2bc35" translate="yes" xml:space="preserve">
          <source>Prior to version 1.9.8, the default value was 256 on all platforms.</source>
          <target state="translated">버전 1.9.8 이전의 모든 플랫폼에서 기본값은 256이었습니다.</target>
        </trans-unit>
        <trans-unit id="12f4c13a6a06f999cc56eb966c94f71ef2658a3f" translate="yes" xml:space="preserve">
          <source>Process</source>
          <target state="translated">Process</target>
        </trans-unit>
        <trans-unit id="5df0bc5493352bb48a5c9d96843c5072972f58fd" translate="yes" xml:space="preserve">
          <source>Process I/O events by calling a handler, specific to the event notification mechanism, chosen by nginx configuration. This handler waits for at least one I/O event to happen, but only until the next timeout expires. When a read or write event occurs, the &lt;code&gt;ready&lt;/code&gt; flag is set and the event's handler is called. For Linux, the &lt;code&gt;ngx_epoll_process_events()&lt;/code&gt; handler is normally used, which calls &lt;code&gt;epoll_wait()&lt;/code&gt; to wait for I/O events.</source>
          <target state="translated">nginx 구성에 의해 선택된 이벤트 알림 메커니즘에 특정한 핸들러를 호출하여 I / O 이벤트를 처리합니다. 이 핸들러는 하나 이상의 I / O 이벤트가 발생할 때까지 대기하지만 다음 시간 종료가 만료 될 때까지만 대기합니다. 읽기 또는 쓰기 이벤트가 발생하면 &lt;code&gt;ready&lt;/code&gt; 플래그가 설정되고 이벤트 핸들러가 호출됩니다. Linux의 경우 &lt;code&gt;ngx_epoll_process_events()&lt;/code&gt; 핸들러가 일반적으로 사용되는데,이 핸들러는 &lt;code&gt;epoll_wait()&lt;/code&gt; 를 호출 하여 I / O 이벤트를 기다립니다.</target>
        </trans-unit>
        <trans-unit id="5bf423d74bede80a66825b0acedca92838917c6e" translate="yes" xml:space="preserve">
          <source>Process posted events by calling &lt;code&gt;ngx_event_process_posted()&lt;/code&gt;. The function repeatedly removes the first element from the posted events queue and calls the element's handler, until the queue is empty.</source>
          <target state="translated">&lt;code&gt;ngx_event_process_posted()&lt;/code&gt; 를 호출하여 게시 된 이벤트를 처리하십시오 . 이 함수는 게시 된 이벤트 큐에서 첫 번째 요소를 반복적으로 제거하고 큐가 비워 질 때까지 요소의 핸들러를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ed7308bb59f2876220e45299939d241199595df2" translate="yes" xml:space="preserve">
          <source>Processes</source>
          <target state="translated">Processes</target>
        </trans-unit>
        <trans-unit id="95ff03e101f25646d7f09c7ead39f8bbc4153cb0" translate="yes" xml:space="preserve">
          <source>Processes:</source>
          <target state="translated">Processes:</target>
        </trans-unit>
        <trans-unit id="53a896dbbde99b110e547215013f71cae4f5dfa1" translate="yes" xml:space="preserve">
          <source>Processing of one or more of these response header fields can be disabled using the &lt;a href=&quot;#fastcgi_ignore_headers&quot;&gt;fastcgi_ignore_headers&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#fastcgi_ignore_headers&quot;&gt;fastcgi_ignore_headers&lt;/a&gt; 지시문을 사용하여 이러한 응답 헤더 필드 중 하나 이상의 처리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1ff1091cd40fb5b39b859c5a65dc190ca0289f99" translate="yes" xml:space="preserve">
          <source>Processing of one or more of these response header fields can be disabled using the &lt;a href=&quot;#proxy_ignore_headers&quot;&gt;proxy_ignore_headers&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#proxy_ignore_headers&quot;&gt;proxy_ignore_headers&lt;/a&gt; 지시문을 사용하여 이러한 응답 헤더 필드 중 하나 이상의 처리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b84eac9cbf459536bc79dcf47605b67818df94e" translate="yes" xml:space="preserve">
          <source>Processing of one or more of these response header fields can be disabled using the &lt;a href=&quot;#scgi_ignore_headers&quot;&gt;scgi_ignore_headers&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#scgi_ignore_headers&quot;&gt;scgi_ignore_headers&lt;/a&gt; 지시문을 사용하여 이러한 응답 헤더 필드 중 하나 이상의 처리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abf72e18113b6b2bde71c09f946fc32c14ef42ea" translate="yes" xml:space="preserve">
          <source>Processing of one or more of these response header fields can be disabled using the &lt;a href=&quot;#uwsgi_ignore_headers&quot;&gt;uwsgi_ignore_headers&lt;/a&gt; directive.</source>
          <target state="translated">&lt;a href=&quot;#uwsgi_ignore_headers&quot;&gt;uwsgi_ignore_headers&lt;/a&gt; 지시문을 사용하여 이러한 응답 헤더 필드 중 하나 이상의 처리를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fc68f20ecfe6943adeb2e669c2592f02493f9a8" translate="yes" xml:space="preserve">
          <source>Profiles will be stored as &lt;code&gt;/path/to/profile.&amp;lt;worker_pid&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">프로필은 &lt;code&gt;/path/to/profile.&amp;lt;worker_pid&amp;gt;&lt;/code&gt; 로 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="03fd6d5335988afcffd6dd1054f30f5c0a0c90e7" translate="yes" xml:space="preserve">
          <source>Protobufjs</source>
          <target state="translated">Protobufjs</target>
        </trans-unit>
        <trans-unit id="1ed77c3f7ffc41a33eadccef5727dc7c97079235" translate="yes" xml:space="preserve">
          <source>Protocol</source>
          <target state="translated">Protocol</target>
        </trans-unit>
        <trans-unit id="8486b83141c9e2932e695878fb2aa907ede58110" translate="yes" xml:space="preserve">
          <source>Provides the configuration file context in which the HTTP server directives are specified.</source>
          <target state="translated">HTTP 서버 지시문이 지정된 구성 파일 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8351441556c27c9eac7121828dfb3cef8efcf206" translate="yes" xml:space="preserve">
          <source>Provides the configuration file context in which the directives that affect connection processing are specified.</source>
          <target state="translated">연결 처리에 영향을주는 지시문이 지정되는 구성 파일 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f0e51a5de1d6f02918fc6f6a487defec06470b18" translate="yes" xml:space="preserve">
          <source>Provides the configuration file context in which the mail server directives are specified.</source>
          <target state="translated">메일 서버 지시문이 지정된 구성 파일 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="bf21ad6a4f703ff8e30116fb851d0d7e5d613bc3" translate="yes" xml:space="preserve">
          <source>Provides the configuration file context in which the stream server directives are specified.</source>
          <target state="translated">스트림 서버 지시문이 지정된 구성 파일 컨텍스트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a206b239c5eb6d95a2d7ecac787f33fc83a8fc1a" translate="yes" xml:space="preserve">
          <source>Pseudo-streaming works in alliance with a compatible Flash player. The player sends an HTTP request to the server with the start time specified in the query string argument (named simply &lt;code&gt;start&lt;/code&gt; and specified in seconds), and the server responds with the stream such that its start position corresponds to the requested time, for example:</source>
          <target state="translated">의사 스트리밍은 호환 가능한 Flash 플레이어와 동맹하여 작동합니다. 플레이어는 쿼리 문자열 인수에 지정된 시작 시간 (단순 &lt;code&gt;start&lt;/code&gt; 및 초로 지정됨 )으로 HTTP 요청을 서버에 전송 하고 서버는 시작 위치가 요청 된 시간과 일치하도록 스트림으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="428865fb09126c208995dcfe798898707750fb68" translate="yes" xml:space="preserve">
          <source>Put &lt;code&gt;*.d.ts&lt;/code&gt; files to a place where you editor can find it.</source>
          <target state="translated">넣어 &lt;code&gt;*.d.ts&lt;/code&gt; 의 당신 편집기가 찾을 수있는 장소에 파일을.</target>
        </trans-unit>
        <trans-unit id="993f7288171ad0caa9248ddf4ea6491358d00562" translate="yes" xml:space="preserve">
          <source>Puts the &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;http&lt;/a&gt; upstream server into the &amp;ldquo;draining&amp;rdquo; mode (1.7.5). In this mode, only requests &lt;a href=&quot;ngx_http_upstream_module#sticky&quot;&gt;bound&lt;/a&gt; to the server will be proxied to it.</source>
          <target state="translated">두고 &lt;a href=&quot;ngx_http_upstream_module&quot;&gt;HTTP&lt;/a&gt; 은 &quot;배수&quot;모드 (1.7.5)에 업스트림 서버. 이 모드에서는 서버에 &lt;a href=&quot;ngx_http_upstream_module#sticky&quot;&gt;바인딩 된&lt;/a&gt; 요청 만 프록시됩니다.</target>
        </trans-unit>
        <trans-unit id="2e620fef64b221e206820a50637e6026d065fbb5" translate="yes" xml:space="preserve">
          <source>Python compatible syntax, supported since PCRE-4.0</source>
          <target state="translated">PCRE-4.0부터 지원되는 Python 호환 구문</target>
        </trans-unit>
        <trans-unit id="5860c8458788e44e7636fa364548e067049a0d7b" translate="yes" xml:space="preserve">
          <source>QUIT</source>
          <target state="translated">QUIT</target>
        </trans-unit>
        <trans-unit id="fc58d1871ca5b0c182173d616404a1ecb2d6c3fd" translate="yes" xml:space="preserve">
          <source>Query String</source>
          <target state="translated">쿼리 문자열</target>
        </trans-unit>
        <trans-unit id="d325fcd919384f395c02751e03d2cd0288b98cca" translate="yes" xml:space="preserve">
          <source>Queue</source>
          <target state="translated">Queue</target>
        </trans-unit>
        <trans-unit id="6893515d8d8210cd6951825230df8c066f42b8f0" translate="yes" xml:space="preserve">
          <source>RS256, RS384, RS512</source>
          <target state="translated">RS256, RS384, RS512</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
