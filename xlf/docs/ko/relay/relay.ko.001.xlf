<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="f9287b3fad8f092d74f4ec6aadb5a29cf9ba2e63" translate="yes" xml:space="preserve">
          <source>&amp;copy; 2013&amp;ndash;present Facebook Inc.</source>
          <target state="translated">&amp;copy; 2013&amp;ndash; 현재 Facebook Inc.</target>
        </trans-unit>
        <trans-unit id="ac2bb4599b07dd7b4cea35d8e273b367c0b66305" translate="yes" xml:space="preserve">
          <source>* Modern API doesn't support mutation fragments. You might have to inline the mutation fragments from your legacy mutation in the fragment of the component.</source>
          <target state="translated">* 최신 API는 돌연변이 조각을 지원하지 않습니다. 구성 요소 조각에서 기존 돌연변이의 돌연변이 조각을 인라인해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c225bfc176636425ea153120adefbee642d75cea" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;createFragmentContainer&lt;/code&gt;&lt;/a&gt; returns a basic container that cannot fetch additional data beyond what is declared in its fragment(s). Relay Modern also provides more advanced containers for dynamic use cases (which were previously handled in Relay Classic via &lt;code&gt;setVariables&lt;/code&gt;):</source>
          <target state="translated">&lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;createFragmentContainer&lt;/code&gt; &lt;/a&gt; 는 프래그먼트에 선언 된 것 이상의 추가 데이터를 가져올 수없는 기본 컨테이너를 반환합니다. Relay Modern은 또한 동적 사용 사례를위한 고급 컨테이너를 제공합니다 (이전에 &lt;code&gt;setVariables&lt;/code&gt; 를 통해 Relay Classic에서 처리됨).</target>
        </trans-unit>
        <trans-unit id="77688ea0d1fdf22bab3df470e72bfe7de6cb4724" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome Extension&lt;/a&gt; creates a Relay tab in the developer tools interface for debugging apps in Chrome</source>
          <target state="translated">&lt;a href=&quot;https://chrome.google.com/webstore/detail/relay-devtools/oppikflppfjfdpjimpdadhelffjpciba&quot;&gt;Chrome 확장 프로그램&lt;/a&gt; 은 개발자 도구 인터페이스에 Chrome에서 앱 디버깅을위한 릴레이 탭을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="fad91719b9218a6ae11551221b84fc32086535ed" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React&lt;/a&gt; allows views to be defined as components where every component is responsible for rendering a part of the UI. Composing other components is how to build complex UIs. Each React component doesn't need to know the inner workings of the composed components.</source>
          <target state="translated">&lt;a href=&quot;https://facebook.github.io/react/&quot;&gt;React를&lt;/a&gt; 사용하면 모든 구성 요소가 UI의 일부를 렌더링하는 뷰를 구성 요소로 정의 할 수 있습니다. 다른 구성 요소를 구성하는 것은 복잡한 UI를 작성하는 방법입니다. 각 React 컴포넌트는 작성된 컴포넌트의 내부 작동을 알 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="a1980b0d9659b15299523fce23afa9e64733250c" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;Electron App&lt;/a&gt; that connects to React Native apps running Relay</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-debugger/tree/master/react-native-shell&quot;&gt;&lt;/a&gt;Relay를 실행하는 React Native 앱에 연결되는 Electron 앱</target>
        </trans-unit>
        <trans-unit id="0f80ef8cc2241c7509e6613ced8779935dc25b6f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; manages the execution of the GraphQL query. It sends the query with given variables, parses the response, saves the data to the internal cache, and finally renders the view.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; 는 GraphQL 쿼리의 실행을 관리합니다. 주어진 변수로 쿼리를 보내고 응답을 구문 분석하고 데이터를 내부 캐시에 저장 한 다음 뷰를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="cfac86ab065f686a94d7eabf085884e964606374" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;createRefetchContainer&lt;/code&gt;&lt;/a&gt; is a variation of &lt;code&gt;createFragmentContainer&lt;/code&gt; that addresses the &quot;see more&quot; use case, where a subset of data is rendered initially and then additional data is fetched on demand. Refetch containers initially fetch data for their fragments just like fragment containers, but also offer a &lt;code&gt;refetch()&lt;/code&gt; method by which additional data can be fetched, or the container can be re-rendered to read data using different variables.</source>
          <target state="translated">&lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;createRefetchContainer&lt;/code&gt; &lt;/a&gt; 는&quot;자세한 정보보기&quot;사용 사례를 처리하는 &lt;code&gt;createFragmentContainer&lt;/code&gt; 의 변형으로, 데이터의 하위 집합이 처음에 렌더링 된 후 추가 데이터가 요청시 페치됩니다. 리 페치 컨테이너는 처음에 프래그먼트 컨테이너와 마찬가지로 프래그먼트에 대한 데이터를 페치하지만추가 데이터를 페치하거나 다른 변수를 사용하여 데이터를 읽도록 컨테이너를 다시 렌더링 할 수있는 &lt;code&gt;refetch()&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6f0afa9606f188df5aa2880a96f0796da66589e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;relay-compat&quot;&gt;Compat mode&lt;/a&gt; allows the Relay Modern APIs to be incrementally adopted in an existing Relay app. This approach enables the following features compared to Relay Classic:</source>
          <target state="translated">&lt;a href=&quot;relay-compat&quot;&gt;Compat 모드&lt;/a&gt; 에서는 Relay Modern API를 기존 Relay 앱에서 점진적으로 채택 할 수 있습니다. 이 방법을 사용하면 Relay Classic과 비교하여 다음 기능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cc7b1d6acf9a6a36373b7d2788a819c007a696a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; receives a &lt;code&gt;user&lt;/code&gt; prop with plain JavaScript data - objects, arrays, strings - and renders as usual.</source>
          <target state="translated">&lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 는 일반 JavaScript 데이터 (개체, 배열, 문자열 )가 포함 된 &lt;code&gt;user&lt;/code&gt; 소품을 받고 평소와 같이 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="115b4c121f9af58bd42ac1ea726c7c948a8dafc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;@connection&lt;/code&gt; directive</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; 지시어</target>
        </trans-unit>
        <trans-unit id="b5d3bbc3f0308d432f9237679fd4198f106ffc51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was queued for commit but another transaction with the same collision key failed. All transactions in the collision queue, including this one, have been failed. Transaction can be recommitted or rolled back.</source>
          <target state="translated">&lt;code&gt;COLLISION_COMMIT_FAILED&lt;/code&gt; &amp;mdash; 트랜잭션이 커밋 대기 중이지만 충돌 키가 동일한 다른 트랜잭션이 실패했습니다. 이를 포함하여 충돌 큐의 모든 트랜잭션이 실패했습니다. 트랜잭션을 다시 커밋하거나 롤백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8093d07e77e9be3790d54f76445c918f46849774" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; Transaction is waiting for the server to respond.</source>
          <target state="translated">&lt;code&gt;COMMITTING&lt;/code&gt; &amp;mdash; 트랜잭션이 서버의 응답을 기다리고 있습니다.</target>
        </trans-unit>
        <trans-unit id="72fc89ccfca88827066da906d579a404ab74ce01" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; Transaction was sent to the server for comitting but failed.</source>
          <target state="translated">&lt;code&gt;COMMIT_FAILED&lt;/code&gt; &amp;mdash; 커밋 을 위해 트랜잭션이 서버로 전송되었지만 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="3ea90f9f79de8b7da5c3c317bc9a5b13f75106bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; Transaction was committed but another transaction with the same collision key is pending, so the transaction has been queued to send to the server.</source>
          <target state="translated">&lt;code&gt;COMMIT_QUEUED&lt;/code&gt; &amp;mdash; 트랜잭션이 커밋되었지만 충돌 키가 동일한 다른 트랜잭션이 보류 중이므로 트랜잭션이 서버로 전송되도록 대기했습니다.</target>
        </trans-unit>
        <trans-unit id="1f3d026fc6b13bd99ef80b56496208f62a08c9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Component&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Component&lt;/code&gt; 렌더링 할 조각과보기를 정의하는 구성 요소 릴레이 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="bfead01c2b218e3cb68f309d9651d5634bcc584a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Container&lt;/code&gt; Relay container that defines fragments and the view to render.</source>
          <target state="translated">&lt;code&gt;Container&lt;/code&gt; 조각과 렌더링 할 뷰를 정의하는 릴레이 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="d52ff52d23e6ad23c71ab30789b670011882899f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;PaginationContainer&lt;/code&gt; is designed to simplify the workflow of loading more items in a list -- in many cases, we don't want to fetch all the data at once but lazily load more data. It relies on a GraphQL server exposing connections in a standardized way. For a detailed spec, please check out &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;this page&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;PaginationContainer&lt;/code&gt; 는 목록에 더 많은 항목을로드하는 워크 플로를 단순화하도록 설계되었습니다. 대부분의 경우 모든 데이터를 한 번에 가져오고 싶지 않지만 더 많은 데이터를 느리게로드하고 싶습니다. 표준화 된 방식으로 연결을 노출시키는 GraphQL 서버에 의존합니다. 자세한 사양은 &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;이 페이지&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5406da34447a5b22b7d56f6fce92e419b505424" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; is the root of a Relay tree. It takes a query, fetches the data and calls the &lt;code&gt;render&lt;/code&gt; callback with the data.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 는 릴레이 트리의 루트입니다. 쿼리를 받아 데이터를 가져오고 데이터와 함께 &lt;code&gt;render&lt;/code&gt; 콜백을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="593061a9841e95181922e32bf061e078ec44605a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;QueryRenderer&lt;/code&gt; supports rendering small amounts of data directly, instead of requiring a container to access data. &lt;a href=&quot;fragment-container&quot;&gt;Containers&lt;/a&gt; are optional and can be used as your application grows in size and complexity.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 는 컨테이너가 데이터에 액세스하지 않아도 적은 양의 데이터를 직접 렌더링 할 수 있도록 지원합니다. &lt;a href=&quot;fragment-container&quot;&gt;컨테이너&lt;/a&gt; 는 선택 사항이며 응용 프로그램의 크기와 복잡성이 증가함에 따라 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcadb6bea3b3b49c5e438342092e725abab0a3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; doesn't provide any bells and whistles such as fat queries or tracked queries (that is, automatic synthesis at runtime of the mutation query to be sent to the server), instead having the user define a static and explicit query. Restricting yourself to the low-level API is a useful preparatory step that will help you ready your codebase for migration to the new static Relay core. In the meantime, if you want those dynamic features, you can opt in to the higher-level &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 은 사용자가 정적 및 명시 적 쿼리를 정의하도록하는 대신 뚱뚱한 쿼리 또는 추적 된 쿼리 (즉, 돌연변이 쿼리 실행시 자동 합성)와 같은 종과 휘파람을 제공하지 않습니다. 저수준 API로 자신을 제한하는 것은 새로운 정적 릴레이 코어로 마이그레이션하기 위해 코드베이스를 준비하는 데 도움이되는 유용한 준비 단계입니다. 그 동안 이러한 동적 기능을 원하면 상위 수준의 &lt;code&gt;Relay.Mutation&lt;/code&gt; API 를 사용하도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9dbe21f8c1dda099d24350958022ccc0bb3f410" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; is a low-level API for modeling a GraphQL mutation.</source>
          <target state="translated">&lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 은 GraphQL 돌연변이 모델링을위한 저수준 API입니다.</target>
        </trans-unit>
        <trans-unit id="127b1aff45435298c344787323bda31e37d71df8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.QL&lt;/code&gt; objects are used by the following APIs:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; 객체는 다음 API에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7e9cc4a6100437d109392de9c4dd32579e5bef54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay.Renderer&lt;/code&gt; can then orchestrate the fetching of the queries; diffing them against cached data, fetching any missing information, updating the cache, and finally rendering &lt;code&gt;StoryContainer&lt;/code&gt; once the data is available. The default is to render nothing while data is fetching, but the loading view can be customized via the &lt;code&gt;render&lt;/code&gt; prop. Just as React allows developers to render views without directly manipulating the underlying view, Relay and &lt;code&gt;Relay.Renderer&lt;/code&gt; remove the need to directly communicate with the network.</source>
          <target state="translated">&lt;code&gt;Relay.Renderer&lt;/code&gt; 그런 다음 Relay.Renderer 는 쿼리 페치를 오케스트레이션 할 수 있습니다. 캐시 된 데이터와 비교, 누락 된 정보 가져 오기, 캐시 업데이트 및 데이터가 사용 가능 &lt;code&gt;StoryContainer&lt;/code&gt; 렌더링 합니다. 기본값은 데이터를 가져 오는 동안 아무 것도 렌더링하지 않는 것입니다,하지만로드 뷰는을 통해 사용자 정의 할 수 있습니다 &lt;code&gt;render&lt;/code&gt; 소품. React를 사용하면 개발자가 기본 뷰를 직접 조작하지 않고도 뷰를 렌더링 할 수있는 것처럼 Relay 및 &lt;code&gt;Relay.Renderer&lt;/code&gt; 는 네트워크와 직접 통신 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="af18c48993c9562a944639b49a29f4455950bbaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Relay&lt;/code&gt; is the entry point to the Relay library. If you're using one of the prebuilt packages it's available as a global; if you're using CommonJS modules you can &lt;code&gt;require()&lt;/code&gt; it.</source>
          <target state="translated">&lt;code&gt;Relay&lt;/code&gt; 는 릴레이 라이브러리의 진입 점입니다. 사전 빌드 된 패키지 중 하나를 사용하는 경우 글로벌로 제공됩니다. CommonJS 모듈을 사용하는 경우 &lt;code&gt;require()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c66e5b2f381152669b034d6f6167ad8cf6ed012" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayContainer&lt;/code&gt; is a higher-order React component that lets a React component encode its data requirements.</source>
          <target state="translated">&lt;code&gt;RelayContainer&lt;/code&gt; 는 React 구성 요소가 데이터 요구 사항을 인코딩 할 수있게하는 상위 React 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="df2d84ab4a50cd1673857a423e00806293940147" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationRequest&lt;/code&gt; encapsulates a mutation that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendMutation&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayMutationRequest&lt;/code&gt; 는 Relay가 서버로 전송해야하는 돌연변이를 캡슐화합니다. &lt;code&gt;sendMutation&lt;/code&gt; 메소드 를 통해 네트워크 계층에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4dc52a29a31a839078a5cad953c9628f74f0f0c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; can return one of the following strings:</source>
          <target state="translated">&lt;code&gt;RelayMutationTransaction.getStatus&lt;/code&gt; 는 다음 문자열 중 하나를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="242d9ea8a1f2fba8d773760a8233ecf37bf7b5f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;RelayQueryRequest&lt;/code&gt; encapsulates a query that Relay needs to send to the server. They are made available to network layers via the &lt;code&gt;sendQueries&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;RelayQueryRequest&lt;/code&gt; 는 Relay가 서버로 보내야하는 쿼리를 캡슐화합니다. &lt;code&gt;sendQueries&lt;/code&gt; 메소드 를 통해 네트워크 계층에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df62ea345a45d0a5fabcd2fdbf901148c6e5a8b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; Transaction hasn't yet been sent to the server. Transaction can be committed or rolled back.</source>
          <target state="translated">&lt;code&gt;UNCOMMITTED&lt;/code&gt; &amp;mdash; 트랜잭션이 아직 서버로 전송되지 않았습니다. 트랜잭션은 커밋되거나 롤백 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50a52e374bfb1a67a3f6d2363ba22492f2e2e80d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the different optimisticUpdater/updater configurations. It provides a convenient way to specify the &lt;code&gt;updater&lt;/code&gt; behavior.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : 다른 optimisticUpdater / updater 구성을 포함하는 배열. &lt;code&gt;updater&lt;/code&gt; 동작 을 지정하는 편리한 방법을 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="7cc60f97e29bfb6ea62a807eae2cc5e7a17f3eb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;configs&lt;/code&gt;: an array containing the updater configurations. It is the same as &lt;a href=&quot;mutations#configs&quot;&gt;&lt;code&gt;configs&lt;/code&gt;&lt;/a&gt; in &lt;code&gt;commitMutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;configs&lt;/code&gt; : 업데이터 구성을 포함하는 배열입니다. 그것은과 동일 &lt;a href=&quot;mutations#configs&quot;&gt; &lt;code&gt;configs&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;commitMutation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9394dd3d6a30c68a04fbce9521aacc5342c5da92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior:
string}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore).</source>
          <target state="translated">&lt;code&gt;connectionInfo: Array&amp;lt;{key: string, filters?: Variables, rangeBehavior: string}&amp;gt;&lt;/code&gt; : 연결 키를 포함하는 객체의 배열, 선택적 필터를 포함하는 객체 및 예상되는 동작에 따라 범위 동작 (추가, 추가, 또는 무시).</target>
        </trans-unit>
        <trans-unit id="43c66a2069ec0b2d4be35833e1ae8977d9b93edf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt;: An array of objects containing a connection key and optionally filters.</source>
          <target state="translated">&lt;code&gt;connectionKeys: Array&amp;lt;{key: string, filters?: Variables}&amp;gt;&lt;/code&gt; : 연결 키 및 선택적으로 필터를 포함하는 객체의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="d19b3e482db84864f686a4ee3759da01773329b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt;: The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string | Array&amp;lt;string&amp;gt;&lt;/code&gt; : 제거 된 노드의 DataID를 포함하는 응답의 필드 이름 또는 연결에서 제거 된 노드의 경로</target>
        </trans-unit>
        <trans-unit id="e977f6b2b4f562aa7af31b00751819ad50d520ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;deletedIDFieldName: string&lt;/code&gt;: The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">&lt;code&gt;deletedIDFieldName: string&lt;/code&gt; : 삭제 된 노드의 DataID를 포함하는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="22bd764f98c24605fee21c6e86534a102d352d4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;edgeName: string&lt;/code&gt;: The field name in the response that represents the newly created edge</source>
          <target state="translated">&lt;code&gt;edgeName: string&lt;/code&gt; : 새로 생성 된 모서리를 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="b7ab967dc3d9dac41042965f33de5bbacae6b0e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;environment&lt;/code&gt; An instance of `Relay.Environment` or any object that implements the `RelayEnvironment` interface.</source>
          <target state="translated">&lt;code&gt;environment&lt;/code&gt; `Relay.Environment`의 인스턴스 또는`RelayEnvironment` 인터페이스를 구현하는 객체.</target>
        </trans-unit>
        <trans-unit id="6a65d389a718020e07ebee40da7bdd44c16a4420" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;filters&lt;/code&gt;: An object containing GraphQL calls e.g. &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;filters&lt;/code&gt; : GraphQL 호출을 포함하는 객체입니다. 예 : &lt;code&gt;const filters = {'orderby': 'chronological'};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41eb5ef20bb9fe4e11e5a7ba243c250838991a3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; Whether to send a server request regardless of data available on the client.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 클라이언트에서 사용 가능한 데이터에 관계없이 서버 요청을 보낼지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="d556d0cc8a6f2287f3af67eacd90ec1629094411" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; can be called with an empty set of partial variables, meaning it can trigger a refresh of the currently rendered set of data.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 는 빈 부분 변수 세트로 호출 할 수 있으며, 이는 현재 렌더링 된 데이터 세트의 새로 고침을 트리거 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7c4e5ec515c48d1d775f76f1e41f31d520e97786" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;forceFetch&lt;/code&gt; is similar to &lt;code&gt;setVariables&lt;/code&gt; because it is also used to change the data requirements by altering &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;forceFetch&lt;/code&gt; 는 &lt;code&gt;variables&lt;/code&gt; 를 변경하여 데이터 요구 사항을 변경하는 데에도 사용되므로 &lt;code&gt;setVariables&lt;/code&gt; 와 유사 합니다 .</target>
        </trans-unit>
        <trans-unit id="78c6f70e52f47838301be68f3a7fc35ddbd14be0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;fragments&lt;/code&gt; Declare the component's data requirements using fragments.</source>
          <target state="translated">&lt;code&gt;fragments&lt;/code&gt; 사용하여 구성 요소의 데이터 요구 사항을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="ffcebb96656094f38726e63b34eb65150f50c9ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; Get a reference to a container fragment for inclusion in a parent fragment.</source>
          <target state="translated">&lt;code&gt;getFragment(name[, vars])&lt;/code&gt; 부모 조각에 포함 할 컨테이너 조각에 대한 참조를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="4d2af946a8f787de1546269d02d1783ad16d7ce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;initialVariables&lt;/code&gt; The initial set of variable values available to this component's fragments.</source>
          <target state="translated">&lt;code&gt;initialVariables&lt;/code&gt; 이 컴포넌트의 프래그먼트에 사용 가능한 초기 변수 값 세트입니다.</target>
        </trans-unit>
        <trans-unit id="563c728f73a72af11f9bfebcd489b1605c4ad5b4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mutation&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged mutation query.</source>
          <target state="translated">&lt;code&gt;mutation&lt;/code&gt; : &lt;code&gt;graphql&lt;/code&gt; 태그 된 돌연변이 쿼리.</target>
        </trans-unit>
        <trans-unit id="b6a934fa0ef96a565381122a89d9aee1a4fba9dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed when the subscription is closed by the peer without error.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : 구독자가 피어에 의해 오류없이 닫힐 때 실행되는 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a715680a7bcdc7a8e18cff64218bee6c4c5f714a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onCompleted&lt;/code&gt;: a callback function executed with the 'raw' response and errors from the server after the in-memory Relay store is updated with the &lt;code&gt;updater&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;onCompleted&lt;/code&gt; : 릴레이 저장소가 업데이트 된 메모리 후에 서버로부터 '원료'응답 오류 실행할 콜백 함수 &lt;code&gt;updater&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e17c27700518dd0a0d9e3907f0ead05f610d8e4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay encounters an error.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : Relay에 오류가 발생하면 실행되는 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="5632405e91380cb8466949662b4346c6b8f63bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onError&lt;/code&gt;: a callback function executed when Relay or the server encounters an error processing the subscription.</source>
          <target state="translated">&lt;code&gt;onError&lt;/code&gt; : 릴레이 또는 서버에서 구독 처리 오류가 발생하면 실행되는 콜백 함수입니다.</target>
        </trans-unit>
        <trans-unit id="13f38fe85bb18ed69b3110347c91c063ca63f296" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">&lt;code&gt;onFailure&lt;/code&gt; 돌연변이가 실패하면 onFailure 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="34b282489eb2fc659bf8f182ecccfa58a4f98bbf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onNext&lt;/code&gt;: a callback function executed each time a response is received from the server, with the raw GraphQL response payload.</source>
          <target state="translated">&lt;code&gt;onNext&lt;/code&gt; : Raw GraphQL 응답 페이로드와 함께 서버에서 응답을받을 때마다 콜백 함수가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="b0c18e8b6186d7338bef8b15b59ec6ca63cd0225" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded.</source>
          <target state="translated">&lt;code&gt;onSuccess&lt;/code&gt; 돌연변이가 성공하면 onSuccess 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="5a1dc36be8e9a3f9069b3ce5c93735b18dee1d9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticResponse&lt;/code&gt;: an object conforming to the mutation's response type definition. If provided, the optimistic response will be normalized to the proxy store before &lt;code&gt;optimisticUpdater&lt;/code&gt; is executed. We suggest you provide an &lt;code&gt;optimisticResponse&lt;/code&gt; for two benefits:</source>
          <target state="translated">&lt;code&gt;optimisticResponse&lt;/code&gt; : 돌연변이의 반응 유형 정의를 따르는 객체. 제공되는 경우 낙관적 응답은 &lt;code&gt;optimisticUpdater&lt;/code&gt; 가 실행 되기 전에 프록시 저장소로 정규화됩니다 . 다음 두 가지 이점에 대해 &lt;code&gt;optimisticResponse&lt;/code&gt; 을 제공하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ace8dc4f2ade074a4518666a5d5ce3fc892c20c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;optimisticUpdater&lt;/code&gt;: a function that takes in a proxy of the in-memory Relay store. In this function, the client defines 'how to' update the store through the proxy in an imperative way.</source>
          <target state="translated">&lt;code&gt;optimisticUpdater&lt;/code&gt; : 메모리 내 릴레이 저장소의 프록시를 취하는 기능입니다. 이 기능에서 클라이언트는 프록시를 통해 상점을 반드시 업데이트하는 '방법'을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="b45ed0f29925a557b65dfee5d20499e8f93783ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parentID: string&lt;/code&gt;: The DataID of the parent node that contains the connection.</source>
          <target state="translated">&lt;code&gt;parentID: string&lt;/code&gt; : 연결이 포함 된 상위 노드의 DataID입니다.</target>
        </trans-unit>
        <trans-unit id="90d6f234e369d7056e4a4a384ce4d56b75c66508" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt;: An array containing the field names between the parent and the connection, including the parent and the connection.</source>
          <target state="translated">&lt;code&gt;pathToConnection: Array&amp;lt;string&amp;gt;&lt;/code&gt; : 부모와 연결을 포함하여 부모와 연결 사이의 필드 이름을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ca3a99f863b6d6006d89f122d91acd2466426ca1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pendingVariables&lt;/code&gt; contains the set of variables that are being used to fetch the new props, i.e. when &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; or &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; are called and the corresponding request is in flight.</source>
          <target state="translated">&lt;code&gt;pendingVariables&lt;/code&gt; 에는 새 소품을 가져 오는 데 사용되는 변수 세트 &lt;code&gt;this.props.relay.setVariables()&lt;/code&gt; 예 : this.props.relay.setVariables () 또는 &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt; 가 호출되고 해당 요청이 진행중인 경우) 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="5294d02523abdadc7890c4089fd2d771e0103adf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment or previous variable values.</source>
          <target state="translated">&lt;code&gt;prepareVariables&lt;/code&gt; 런타임 환경 또는 이전 변수 값을 기반으로 변수를 수정하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="85e836212ec7a6f4cf39b03986865be121a0bbd5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` or `Relay.Route` that defines the query roots.</source>
          <target state="translated">&lt;code&gt;queryConfig&lt;/code&gt; `QueryConfig` 또는 조회 루트를 정의하는`Relay.Route`.</target>
        </trans-unit>
        <trans-unit id="32d83449d21fcdf971b3e1c1d76474fe6f62d3af" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;refetchVariables&lt;/code&gt; is either a bag of variables or a function that takes in the previous fragment variables and returns new variables.</source>
          <target state="translated">&lt;code&gt;refetchVariables&lt;/code&gt; 는 변수 모음 이거나 이전 조각 변수를 가져 와서 새 변수를 반환하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="4ae4f5a5447be2154beefea2867a35b518a781d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;render&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 데이터 요구 사항이 충족 될 때 렌더링 하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="55e1260e99e337d383bed6b4b9c2df2228a1e749" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFailure&lt;/code&gt; Called to render when data failed to be fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; 데이터를 이행하지 못한 경우 렌더링하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a6131b3d70611a404b4ea7dd80f5758c5105f7c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderFetched&lt;/code&gt; Called to render when data requirements are fulfilled.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 데이터 요구 사항이 충족 될 때 렌더링하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1901f50529efd372e2c626214284f332709348a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderLoading&lt;/code&gt; Called to render when data requirements are being fulfilled.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; 데이터 요구 사항이 충족 될 때 렌더링하기 위해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b0fe2435dec450eee6998923c41267267d40d7d3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;renderVariables&lt;/code&gt; is an optional param that tells Relay which variables to use at when the component is re-rendered after fetching. Without this, the &lt;code&gt;refetchVariables&lt;/code&gt; will be used. You might use this for more advanced usage, for example, to implement pagination, where you would fetch an additional page with variables like &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt;, but you would then render the full collection with &lt;code&gt;{first: 10}&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderVariables&lt;/code&gt; 는 가져 오기 후에 컴포넌트를 다시 렌더링 할 때 사용할 변수를 Relay에 알려주는 선택적 매개 변수입니다. 이것이 없으면 &lt;code&gt;refetchVariables&lt;/code&gt; 가 사용됩니다. 예를 들어 &lt;code&gt;{first: 5, after: '...'}&lt;/code&gt; 와 같은 변수가있는 추가 페이지를 가져 오는 페이지 매김을 구현하는 등의 고급 사용법에이를 사용할 수 있지만 &lt;code&gt;{first: 10}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef4511de2692e7e2831022f07230dabf3496cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;route&lt;/code&gt; Route that defines the query roots.</source>
          <target state="translated">&lt;code&gt;route&lt;/code&gt; 쿼리 루트를 정의하는 경로입니다.</target>
        </trans-unit>
        <trans-unit id="de20a20a67577265acad0e1c8760490f6ae7d671" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setVariables&lt;/code&gt; does not immediately mutate &lt;code&gt;variables&lt;/code&gt;, but creates a pending state transition. &lt;code&gt;variables&lt;/code&gt; will continue returning the previous values until &lt;code&gt;this.props&lt;/code&gt; has been populated with data that fulfills the new variable values.</source>
          <target state="translated">&lt;code&gt;setVariables&lt;/code&gt; 는 &lt;code&gt;variables&lt;/code&gt; 즉시 변경하지 않지만 보류 상태 전이를 작성합니다. &lt;code&gt;variables&lt;/code&gt; 는 &lt;code&gt;this.props&lt;/code&gt; 가 새 변수 값을 충족하는 데이터로 채워질 때까지 이전 값을 계속 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="943d019e3b13e343df13a6484ab6136c7156b4e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shouldComponentUpdate&lt;/code&gt; Optionally override RelayContainer's default implementation of `shouldComponentUpdate`.</source>
          <target state="translated">&lt;code&gt;shouldComponentUpdate&lt;/code&gt; 필요에 따라 RelayContainer의 기본 구현 인`shouldComponentUpdate`를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c12be4a70a038cd4741cb2b9e30195491469abee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid Relay container.</source>
          <target state="translated">&lt;code&gt;static Container: ReactPropTypeValidator&lt;/code&gt; 소품이 유효한 릴레이 컨테이너임을 주장하는 소품 유형 유효성 검사기.</target>
        </trans-unit>
        <trans-unit id="3b4467abcecc2f5f6147438c2f223473973407a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; A prop type validator asserting that a prop is a valid route.</source>
          <target state="translated">&lt;code&gt;static QueryConfig: ReactPropTypeValidator&lt;/code&gt; prop이 유효한 라우트임을 주장하는 prop 유형 유효성 검증기.</target>
        </trans-unit>
        <trans-unit id="40e983f1da84aaeb0774f71c8242e17b35be1f2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; Adds a MutationTransaction to the queue without committing it.</source>
          <target state="translated">&lt;code&gt;static applyUpdate(mutation, callbacks)&lt;/code&gt; 큐에 커밋하지 않고 MutationTransaction을 큐에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b4d03961b864a4ab573535d598407abfc411cce4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; Initiate processing of a mutation.</source>
          <target state="translated">&lt;code&gt;static commitUpdate(mutation, callbacks)&lt;/code&gt; 돌연변이 처리를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="9eebf1a07ed283d2bbed2b968ffb38df36fad9ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; Create a static mutation</source>
          <target state="translated">&lt;code&gt;static create(mutation, variables, environment)&lt;/code&gt; 정적 돌연변이 생성</target>
        </trans-unit>
        <trans-unit id="658d18c4b39964f6d9e02a8d4f13d6ca5179a919" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; Creates a Relay Container.</source>
          <target state="translated">&lt;code&gt;static createContainer(Component, ContainerConfig)&lt;/code&gt; 릴레이 컨테이너를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ac50a770322cba5b662ec0bbf60235d57453db96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; Create a static mutation that accepts a &quot;files&quot; object</source>
          <target state="translated">&lt;code&gt;static createWithFiles(mutation, variables, files, environment)&lt;/code&gt; &quot;files&quot;객체를 받아들이는 정적 돌연변이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a985a4f33765191da82de5eb97d6c665b299a3b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static fragments&lt;/code&gt; Declare this mutation's data dependencies here</source>
          <target state="translated">&lt;code&gt;static fragments&lt;/code&gt; 이 돌연변이의 데이터 의존성을 여기에 선언</target>
        </trans-unit>
        <trans-unit id="a1697fb2f2da73763242483e979b5b34e6797e53" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static initialVariables&lt;/code&gt; A default set of variables to make available to this mutation's fragment builders</source>
          <target state="translated">&lt;code&gt;static initialVariables&lt;/code&gt; 이 돌연변이의 프래그먼트 빌더가 사용할 수있는 기본 변수 세트</target>
        </trans-unit>
        <trans-unit id="9ac61312fa144b893336d3bbdf88826d0034494e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; Customize how queries and mutations are sent to the server.</source>
          <target state="translated">&lt;code&gt;static injectNetworkLayer(networkLayer)&lt;/code&gt; 쿼리 및 돌연변이가 서버로 전송되는 방식을 사용자 정의합니다.</target>
        </trans-unit>
        <trans-unit id="49b31e2fd0ee618819eb9668ad9fab057dc448c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; Configure when Relay processing occurs.</source>
          <target state="translated">&lt;code&gt;static injectTaskScheduler(scheduler)&lt;/code&gt; 릴레이 처리시기를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="3e8afe33d507124df2cb20b712a24c4d395ceeb6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static isContainer(Component)&lt;/code&gt; Determine if a given object is a Relay.Container.</source>
          <target state="translated">&lt;code&gt;static isContainer(Component)&lt;/code&gt; 지정된 객체가 Relay.Container인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="7938dae1f9d2455348151916c16933ea1c4109f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static paramDefinitions&lt;/code&gt; Declare the expected parameters.</source>
          <target state="translated">&lt;code&gt;static paramDefinitions&lt;/code&gt; 예상되는 매개 변수를 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="047db3ec3d910088d59dd144e9064188d5d64b54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareParams&lt;/code&gt; Declare additional parameters or conversion for parameters.</source>
          <target state="translated">&lt;code&gt;static prepareParams&lt;/code&gt; 추가 매개 변수를 선언하거나 매개 변수를 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b2b9762a4218dc52cee63114d0eee0ed5d04c5f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static prepareVariables&lt;/code&gt; A method to modify the variables based on the runtime environment, previous variables, or the meta route</source>
          <target state="translated">&lt;code&gt;static prepareVariables&lt;/code&gt; 런타임 환경, 이전 변수 또는 메타 라우트를 기반으로 변수를 수정하는 방법</target>
        </trans-unit>
        <trans-unit id="2b49e3d2f4dae0d69deb0f6c24085a44cc8a3c5a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static queries&lt;/code&gt; Declare the set of query roots.</source>
          <target state="translated">&lt;code&gt;static queries&lt;/code&gt; 쿼리 루트 세트를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="0c43ab95deb00b1e6ba46964ae86ac05d717b874" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;static routeName&lt;/code&gt; Declare the name of this route class.</source>
          <target state="translated">&lt;code&gt;static routeName&lt;/code&gt; 이 라우트 클래스의 이름을 선언하십시오.</target>
        </trans-unit>
        <trans-unit id="91acf728df7357ed2ba9977f2e4aae1aa271198d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;subscription&lt;/code&gt;: the &lt;code&gt;graphql&lt;/code&gt; tagged subscription query.</source>
          <target state="translated">&lt;code&gt;subscription&lt;/code&gt; : &lt;code&gt;graphql&lt;/code&gt; 태그 구독 쿼리.</target>
        </trans-unit>
        <trans-unit id="12ff8bacf233237929ba38ec484648a655ad7959" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; can be called to update a subset or all of the variables at the same time. In return, Relay will use the new variables to attempt to fulfill the new fragment. This may involve sending a request to the server if data is not already available on the client.</source>
          <target state="translated">&lt;code&gt;this.props.relay.setVariables&lt;/code&gt; 를 호출하여 서브 세트 또는 모든 변수를 동시에 업데이트 할 수 있습니다. 그 대가로 Relay는 새 변수를 사용하여 새 조각을 이행하려고 시도합니다. 클라이언트에서 데이터를 아직 사용할 수없는 경우 서버에 요청을 보내는 것이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c005f6461f75206bcbc927906f1de20a4cf2e450" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exports the following API to execute the refetch query:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 는 다음 API를 내 보내서 페치 조회를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="7d9577972a7c4a8c614b22a037eaeff82248e3f0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.relay&lt;/code&gt; exposes the following APIs:</source>
          <target state="translated">&lt;code&gt;this.props.relay&lt;/code&gt; 는 다음 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3d07b37e84a778ceb1461d9bbc1f056984d50a27" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;this.props.setVariables&lt;/code&gt; from the old API does not have a direct equivalent in the new API. A big reason for this change is that the new core no longer tracks how to refetch any specific sub-tree from the query. This makes the new core a lot faster, but requires explicit queries for how to fetch new data. Check out these four different scenarios:</source>
          <target state="translated">&lt;code&gt;this.props.setVariables&lt;/code&gt; 이전 API의 this.props.setVariables 는 새 API와 직접적으로 동일하지 않습니다. 이 변경의 큰 이유는 새 코어가 더 이상 쿼리에서 특정 하위 트리를 다시 가져 오는 방법을 추적하지 않기 때문입니다. 이를 통해 새로운 코어가 훨씬 빨라지지만 새로운 데이터를 가져 오는 방법에 대한 명시적인 쿼리가 필요합니다. 이 네 가지 시나리오를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="25ab1a5db284767b82e6bbe83b1d6bb7782d76cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: a function that updates the in-memory Relay store based on the &lt;strong&gt;real&lt;/strong&gt; server response. When the server response comes back, Relay first reverts any changes introduced by &lt;code&gt;optimisticUpdater&lt;/code&gt; or &lt;code&gt;optimisticResponse&lt;/code&gt; and then applies the &lt;code&gt;updater&lt;/code&gt; to the store.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : &lt;strong&gt;실제&lt;/strong&gt; 서버 응답을 기반으로 메모리 내 릴레이 저장소를 업데이트하는 기능입니다 . 서버 응답이 다시 시작되면 Relay는 먼저 &lt;code&gt;optimisticUpdater&lt;/code&gt; 또는 &lt;code&gt;optimisticResponse&lt;/code&gt; 에 의해 도입 된 변경 사항을 되 돌린 다음 &lt;code&gt;updater&lt;/code&gt; 을 상점에 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="9e752995a456f07b23c9c5955036c90c0eaa7d48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updater&lt;/code&gt;: an optional function that can supply custom logic for updating the in-memory Relay store based on the server response.</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; : 서버 응답을 기반으로 메모리 내 릴레이 저장소를 업데이트하기위한 사용자 지정 논리를 제공 할 수있는 선택적 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ed67a9853586c7a825bf549e62d6668d890318cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt; contains the set of variables that was used to fetch the current set of props.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; 에는 현재 소품 세트를 가져 오는 데 사용 된 변수 세트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="7e388933696fbe367df975da86d5ab73799cb8d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the mutation.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : 돌연변이에 필요한 변수를 포함하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="6e219c17510eb13b16577519ca778d9468c7499a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;variables&lt;/code&gt;: an object that contains the variables needed for the subscription.</source>
          <target state="translated">&lt;code&gt;variables&lt;/code&gt; : 구독에 필요한 변수가 들어있는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a3d9fd11099be9837becddb07ecac412bfe16922" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt; is deprecated. Use &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt;&lt;code&gt;babel-plugin-relay&lt;/code&gt;&lt;/a&gt; with Relay Classic.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; 은 더 이상 사용되지 않습니다. Relay Classic과 함께 &lt;a href=&quot;babel-plugin-relay#using-with-relay-classic&quot;&gt; &lt;code&gt;babel-plugin-relay&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="885b12f18c1ce790e1ceb37bdac14666bf969046" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Container Specification&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;컨테이너 사양&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dc48bdb0f1a664344b42c6cc9f80bf54c93c0af" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Methods&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="372322cdb4339a090833f173c5459433d9f3a2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties and Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;특성 및 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2e24a7da3b4c78d1c9bb8ad4a5672d259fcf1c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Properties&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Properties&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b288f7cf5165d63b23f3a477f7c62696473947e3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Props&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Props&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c13abeef99d46d6cc5a5891d80bde92ef26cfbac" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Static Methods&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;정적 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f0677ff5e5e4c313a098291e00353714c69a25eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql-up&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphcool/graphql-up&quot;&gt;graphql 업&lt;/a&gt;&lt;/strong&gt; 에&lt;a href=&quot;https://www.npmjs.com/package/graphql-up&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a854faa5d5c2fb2a3f2a62f519c3dae0ea44c47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;특급 - graphql&lt;/a&gt;&lt;/strong&gt; 에&lt;a href=&quot;https://www.npmjs.com/package/express-graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6882e7b1150b43a134cd9463ab13037397e9d8a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-JS&lt;/a&gt;&lt;/strong&gt; 에&lt;a href=&quot;https://www.npmjs.com/package/graphql&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4615a7abdf175713f1dd713a45e9b36b49db0dd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt;&lt;/strong&gt; on &lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt;npm&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql 릴레이-JS&lt;/a&gt;&lt;/strong&gt; 에&lt;a href=&quot;https://www.npmjs.com/package/graphql-relay&quot;&gt; NPM&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="57698c2dcaa9317f5b6564784890d536ca0db31a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt;Quickstart tutorial&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://www.graph.cool/&quot;&gt;Graphcool&lt;/a&gt;&lt;/strong&gt; (&lt;a href=&quot;https://www.graph.cool/docs/quickstart/&quot;&gt; 빠른 시작 자습서&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="3ff63fe8231293f18f4614046a48a3f375957330" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; An optimistic update may only be applied once.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 낙관적 업데이트는 한 번만 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a6c17b257e2cfbdb037b374e043ded0a3a0687b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Equivalent &lt;code&gt;applyUpdate&lt;/code&gt; and &lt;code&gt;commitUpdate&lt;/code&gt; methods are also provided on the &lt;code&gt;this.props.relay&lt;/code&gt; prop that is passed to components by &lt;code&gt;Relay.Container&lt;/code&gt;. These dispatch mutations in the context of the currently active &lt;code&gt;Relay.Environment&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;주 :&lt;/strong&gt; 등가 &lt;code&gt;applyUpdate&lt;/code&gt; 및 &lt;code&gt;commitUpdate&lt;/code&gt; 방법이 또한 상에 제공된다 &lt;code&gt;this.props.relay&lt;/code&gt; 의해 부품에 전달되는 소품 &lt;code&gt;Relay.Container&lt;/code&gt; . 현재 활성화 된 &lt;code&gt;Relay.Environment&lt;/code&gt; 와 관련하여 이러한 파견 돌연변이 .</target>
        </trans-unit>
        <trans-unit id="3d08f9d41d143a0795971f924c815549c54cd145" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Container&lt;/strong&gt; lets components declare fragments.</source>
          <target state="translated">&lt;strong&gt;Relay.Container를&lt;/strong&gt; 사용하면 구성 요소에서 조각을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90f9832c4e0fd7965e487450fd253cb3d30e8335" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Renderer&lt;/strong&gt; is a replacement for &lt;code&gt;Relay.RootContainer&lt;/code&gt; that composes a &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; and performs data fetching for a given &lt;code&gt;queryConfig&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.Renderer는&lt;/strong&gt; 를 대체 &lt;code&gt;Relay.RootContainer&lt;/code&gt; 작곡 &lt;code&gt;Relay.ReadyStateRenderer&lt;/code&gt; 소정 위해 페치 및 수행 데이터 &lt;code&gt;queryConfig&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4e196f3c49ca550a94a96a6bd405ee5ae569ab33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; accepts three optional callbacks as props that give us more fine-grained control over the render behavior.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 렌더링 동작을보다 세밀하게 제어 할 수있는 3 개의 선택적 콜백을 소품으로 허용합니다.</target>
        </trans-unit>
        <trans-unit id="39c403bfc5a5ae739fbb717b4e88e8b5cb484d46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; also supports the &lt;code&gt;onReadyStateChange&lt;/code&gt; prop which lets us receive fine-grained events as they occur while fulfilling the data requirements.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 &lt;code&gt;onReadyStateChange&lt;/code&gt; prop을 지원 하여 데이터 요구 사항을 충족하면서 세분화 된 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d6f9d2435421026549fceef7e0844d153a49bfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt; for a given &lt;code&gt;route&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 지정된 &lt;code&gt;route&lt;/code&gt; 대해 &lt;code&gt;Component&lt;/code&gt; 인스턴스를 렌더링하는 데 필요한 데이터를 수행하려고하는 React 구성 요소입니다 .</target>
        </trans-unit>
        <trans-unit id="a2469cd762b58409f3e67b96bf307621bbbfad9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; is a React component that, given a &lt;code&gt;Component&lt;/code&gt; and a &lt;code&gt;route&lt;/code&gt;, attempts to fulfill the data required in order to render an instance of &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer는&lt;/strong&gt; A가 주어진, 해당 구성 요소 반작용이다 &lt;code&gt;Component&lt;/code&gt; 및 &lt;code&gt;route&lt;/code&gt; 데이터를 완수하기 위해 시도의 인스턴스 렌더링하기 위해 필요한 &lt;code&gt;Component&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3a1abc25b49b43dce645669aa17f103661474d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; renders the loading state whenever it cannot immediately fulfill data needed to render. This often happens on the initial render, but it can also happen if either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; changes.</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer는&lt;/strong&gt; 렌더링에 필요한 데이터를 즉시 이행 할 수 없을 때마다 로딩 상태를 렌더링합니다. 이것은 종종 초기 렌더링에서 발생하지만 &lt;code&gt;Component&lt;/code&gt; 또는 &lt;code&gt;route&lt;/code&gt; 변경되는 경우에도 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="81df685053c0d0bd1d2397325ab50c0f55f7ca06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Relay.Route&lt;/strong&gt; lets us declare query roots.</source>
          <target state="translated">&lt;strong&gt;Relay.Route를&lt;/strong&gt; 사용하면 쿼리 루트를 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d333726339af1440c557b36d8dd062e5747d248a" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;QueryRenderer&lt;/code&gt; is a React component, so it can be rendered anywhere that a React component can be rendered, not just at the top level. A &lt;code&gt;QueryRenderer&lt;/code&gt; can be rendered &lt;em&gt;within&lt;/em&gt; other Relay components, for example to lazily fetch additional data for a popover. However, a &lt;code&gt;QueryRenderer&lt;/code&gt; will not start loading its data until it is mounted, so nested &lt;code&gt;QueryRenderer&lt;/code&gt; components can lead to avoidable request waterfalls if used unnecessarily.</source>
          <target state="translated">&lt;code&gt;QueryRenderer&lt;/code&gt; 는 최상위 수준에서뿐만 아니라, 렌더링 할 수있는 구성 요소 반작용 모든 위치에 렌더링 할 수 있도록하는 구성 요소 반작용이다. &lt;code&gt;QueryRenderer&lt;/code&gt; 가 렌더링 할 수있는 &lt;em&gt;내&lt;/em&gt; 느리게 팝 오버에 대한 추가 데이터를 가져, 예를 들면, 다른 릴레이 요소. 그러나 &lt;code&gt;QueryRenderer&lt;/code&gt; 는 마운트 될 때까지 데이터로드를 시작하지 않으므로 중첩 된 &lt;code&gt;QueryRenderer&lt;/code&gt; 구성 요소는 불필요하게 사용되는 경우 요청 범위를 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27c70649f28d5c13e5a545686407c1d433b45c24" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is used to append additional children to the mutation query. You may need to use this, for example, to fetch fields on a new object created by the mutation (and which Relay would normally not attempt to fetch because it has not previously fetched anything for that object).</source>
          <target state="translated">&lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 설정은 돌연변이 쿼리에 추가 자녀를 추가하는 데 사용됩니다. 예를 들어, 돌연변이에 의해 생성 된 새 객체의 필드를 가져 오기 위해 (및 이전에 해당 객체에 대해 아무것도 가져 오지 않았기 때문에 릴레이가 페치하려고 시도하지 않는) 필드를 가져와야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0405a3f3745cc21b6e57c41715133d0cedd35b4" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;RefetchContainer&lt;/code&gt; first renders like a regular &lt;a href=&quot;fragment-container&quot;&gt;&lt;code&gt;FragmentContainer&lt;/code&gt;&lt;/a&gt;, but has the option to execute a new query with different variables and render the response of that query instead when the request comes back.</source>
          <target state="translated">&lt;code&gt;RefetchContainer&lt;/code&gt; 는 첫 번째 정규처럼 렌더링 &lt;a href=&quot;fragment-container&quot;&gt; &lt;code&gt;FragmentContainer&lt;/code&gt; &lt;/a&gt; ,하지만 서로 다른 변수로 새 쿼리를 실행하고 요청이 돌아 오면 대신 해당 쿼리의 응답을 렌더링 할 수있는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b6b1500d0098058dc174f969740040bdd6fdf14" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;renderLoading&lt;/code&gt; callback can simulate the default behavior by returning &lt;code&gt;undefined&lt;/code&gt;. Notice that this is different from a &lt;code&gt;renderLoading&lt;/code&gt; callback that returns &lt;code&gt;null&lt;/code&gt;, which would render nothing whenever data is loading, even if there was a previous view rendered.</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; 의 콜백 반환하여 기본 동작을 시뮬레이션 할 수 있습니다 &lt;code&gt;undefined&lt;/code&gt; . 이는 &lt;code&gt;null&lt;/code&gt; 을 반환 하는 &lt;code&gt;renderLoading&lt;/code&gt; 콜백과 다르므로 이전 뷰가 렌더링 된 경우에도 데이터가로드 될 때마다 아무 것도 렌더링하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59bd5b6c5b1f4d50bad57e4bae0c86bf7e63ff03" translate="yes" xml:space="preserve">
          <source>A Complete Example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="584bb673c7430dcef36b698acb079dd72be2262f" translate="yes" xml:space="preserve">
          <source>A GraphQL Schema</source>
          <target state="translated">GraphQL 스키마</target>
        </trans-unit>
        <trans-unit id="b1a1d3fc840a0a6e5e8ca2b278d7769c45a98c33" translate="yes" xml:space="preserve">
          <source>A GraphQL Server</source>
          <target state="translated">GraphQL 서버</target>
        </trans-unit>
        <trans-unit id="a7ee882612fb64b227df291f19a923de85574e53" translate="yes" xml:space="preserve">
          <source>A GraphQL schema describes your data model, and provides a GraphQL server with an associated set of resolve methods that know how to fetch data. We will use &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-js&lt;/a&gt; and &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql-relay-js&lt;/a&gt; to build our schema.</source>
          <target state="translated">GraphQL 스키마는 데이터 모델을 설명하고 데이터를 가져 오는 방법을 알고있는 관련 해결 방법 세트를 GraphQL 서버에 제공합니다. 우리는 사용 &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;graphql-JS&lt;/a&gt; 와 &lt;a href=&quot;https://github.com/graphql/graphql-relay-js&quot;&gt;graphql 릴레이-JS를&lt;/a&gt; 우리의 스키마를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6d86fdd10ea1168eecc22cdc48b9e22a21ad2d" translate="yes" xml:space="preserve">
          <source>A complete example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="1b0ee223956194b51488ec093f18ce49cf32ed77" translate="yes" xml:space="preserve">
          <source>A description of how to page through connections.</source>
          <target state="translated">연결을 통해 페이징하는 방법에 대한 설명</target>
        </trans-unit>
        <trans-unit id="97b03c635c48a56b721c11e955de7b0b12f2ab52" translate="yes" xml:space="preserve">
          <source>A description of your data model with an associated set of resolve methods that know how to fetch any data your application could ever need.</source>
          <target state="translated">응용 프로그램에 필요한 데이터를 가져 오는 방법을 알고있는 관련 해결 방법 세트가있는 데이터 모델에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="cab997b4cd24ec902e4b83aaf3bf43dce9ec7836" translate="yes" xml:space="preserve">
          <source>A faction has many ships in the Star Wars universe. Relay contains functionality to make manipulating one-to-many relationships easy, using a standardized way of expressing these one-to-many relationships. This standard connection model offers ways of slicing and paginating through the connection.</source>
          <target state="translated">진영은 스타 워즈 세계에 많은 배를 가지고 있습니다. 릴레이에는 이러한 일대 다 관계를 표현하는 표준화 된 방법을 사용하여 일대 다 관계를 쉽게 조작 할 수있는 기능이 포함되어 있습니다. 이 표준 연결 모델은 연결을 통해 슬라이싱 및 페이지 매김 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ac6dbe38242ad9f607665dc6e4fa2db4283cdd16" translate="yes" xml:space="preserve">
          <source>A map between a &lt;code&gt;fieldName&lt;/code&gt; in the response and one or more DataIDs in the store.</source>
          <target state="translated">응답 의 &lt;code&gt;fieldName&lt;/code&gt; 과 상점의 하나 이상의 DataID 사이의 맵 .</target>
        </trans-unit>
        <trans-unit id="6d94fea08321dcd17e29b42a404746fc50da107f" translate="yes" xml:space="preserve">
          <source>A map between printed, dot-separated GraphQL calls &lt;em&gt;in alphabetical order&lt;/em&gt; and the behavior we want Relay to exhibit when adding the new edge to connections under the influence of those calls or a function accepting an array of connection arguments, returning that behavior.</source>
          <target state="translated">&lt;em&gt;알파벳순으로&lt;/em&gt; 인쇄 된 점으로 구분 된 GraphQL 호출 과 해당 호출 또는 연결 인수 배열을 허용하는 함수의 영향으로 연결에 새 모서리를 추가 할 때 릴레이가 표시 할 동작 사이의 맵 으로 해당 동작을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1cccdfbe7fde630bea189ab2f8f17ca043aff9a4" translate="yes" xml:space="preserve">
          <source>A mechanism for refetching an object.</source>
          <target state="translated">객체를 다시 가져 오는 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="dd1a050f9a41554bdba5570ef7cbd29c8928f1fa" translate="yes" xml:space="preserve">
          <source>A naming convention of &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; for fragments is advised. This restriction is required while migrating from classic to modern APIs to allow for cross-compatibility.</source>
          <target state="translated">프래그먼트에 대한 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 의 명명 규칙 이 권장됩니다. 상호 호환성을 위해 클래식 API에서 최신 API로 마이그레이션하는 동안이 제한이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b4223851fbff0df13ddb07d4c23c59818ab413eb" translate="yes" xml:space="preserve">
          <source>A normalized cache ensures that the &lt;em&gt;cache&lt;/em&gt; is consistent. But what about our views? Ideally, our React views would always reflect the current information from the cache.</source>
          <target state="translated">정규화 된 캐시는 &lt;em&gt;캐시의&lt;/em&gt; 일관성을 보장합니다 . 그러나 우리의 견해는 어떻습니까? 이상적으로 React 뷰는 항상 캐시의 현재 정보를 반영합니다.</target>
        </trans-unit>
        <trans-unit id="921546babe023949163725db08488e51b22729dc" translate="yes" xml:space="preserve">
          <source>A number of more detailed usage examples can be found &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;in the test suite&lt;/a&gt;.</source>
          <target state="translated">더 자세한 사용법 예제는 &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/react-relay/classic/mutation/__tests__/RelayGraphQLMutation-test.js&quot;&gt;테스트 스위트에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7bf37966659d061a8f053bad6bab73f29aaece2b" translate="yes" xml:space="preserve">
          <source>A parent component will pass in a reference to some &lt;code&gt;User&lt;/code&gt; &quot;record&quot;.</source>
          <target state="translated">상위 컴포넌트는 일부 &lt;code&gt;User&lt;/code&gt; &quot;레코드&quot; 에 대한 참조를 전달 합니다.</target>
        </trans-unit>
        <trans-unit id="3024b82cc133bf6a9ef4feda5d9be663e786bae2" translate="yes" xml:space="preserve">
          <source>A polyfilled environment for Relay using &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; to support older browsers might look like:</source>
          <target state="translated">이전 브라우저를 지원하기 위해 &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; 를 사용하는 Relay의 폴리 필 환경 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61d2ab53d28c9ffa3a83c917db0c7132ab0ec11a" translate="yes" xml:space="preserve">
          <source>A reference for translating between the Relay Classic and Relay Modern APIs.</source>
          <target state="translated">Relay Classic과 Relay Modern API 간의 번역에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="0b8683fbbd3c98251a45756a2f2f8175837a100c" translate="yes" xml:space="preserve">
          <source>A simple database</source>
          <target state="translated">간단한 데이터베이스</target>
        </trans-unit>
        <trans-unit id="40cf8919ea34c404a49fa4a02115691af647ed4f" translate="yes" xml:space="preserve">
          <source>A simple example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="dd8ebc46434f8d14a177b5c72d5934bab414bb47" translate="yes" xml:space="preserve">
          <source>A simpler, more predictable mutation API. The restrictions on mutation queries from Relay Classic are also removed: mutation queries are static, fields can be arbitrarily nested, and may use arbitrary arguments.</source>
          <target state="translated">더 단순하고 예측 가능한 돌연변이 API. Relay Classic의 돌연변이 쿼리에 대한 제한도 제거됩니다. 돌연변이 쿼리는 정적이며 필드는 임의로 중첩 될 수 있으며 임의의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="789d37a7cd03e8b6bdc2af935f5617d2f61be663" translate="yes" xml:space="preserve">
          <source>A standard response is to &quot;just use immutable data structures&quot; &amp;mdash; but let's see what would happen if we did:</source>
          <target state="translated">표준 응답은 &quot;불변의 데이터 구조 만 사용&quot;하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e5e4cf2d26ffa89b62883fa16b09362f316c9090" translate="yes" xml:space="preserve">
          <source>A summary of the improvements and new features in Relay Modern.</source>
          <target state="translated">Relay Modern의 개선 사항 및 새로운 기능에 대한 요약.</target>
        </trans-unit>
        <trans-unit id="95da6cd41846ca1d215d52c18cb18c520fe5b668" translate="yes" xml:space="preserve">
          <source>A working copy of the treasure hunt can be found in the &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;relay-examples&lt;/a&gt; repository.</source>
          <target state="translated">보물 찾기의 작업 사본은 &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;릴레이 예제&lt;/a&gt; 저장소 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1aec4806edaa35984901f978cbb068b50698edb4" translate="yes" xml:space="preserve">
          <source>API Cheatsheet</source>
          <target state="translated">API 치트 시트</target>
        </trans-unit>
        <trans-unit id="2c3de2092b0a547759dcfed154c12293c6bfa562" translate="yes" xml:space="preserve">
          <source>API and Runtime</source>
          <target state="translated">API 및 런타임</target>
        </trans-unit>
        <trans-unit id="42949c00e99b70b6ffba23e406246cfa31564e49" translate="yes" xml:space="preserve">
          <source>Achieving View Consistency</source>
          <target state="translated">뷰 일관성 달성</target>
        </trans-unit>
        <trans-unit id="81f2d6f8bacd029d8646faa85a14672311eb28b5" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins your .babelrc file. See &lt;a href=&quot;babel-plugin-relay&quot;&gt;the docs&lt;/a&gt; if upgrading an existing Relay app.</source>
          <target state="translated">플러그인 목록에 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 를 추가 하십시오. .babelrc 파일. 기존 릴레이 앱을 업그레이드하는 경우 &lt;a href=&quot;babel-plugin-relay&quot;&gt;문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a60bf5aa8ddfd89ba31ac71650847ae24721ce0" translate="yes" xml:space="preserve">
          <source>Add the variable to the queries that use the fragment and pass it in when fetching the query. For this it can be useful to have a module with a collection of variables for your product.</source>
          <target state="translated">조각을 사용하는 쿼리에 변수를 추가하고 쿼리를 가져올 때 변수를 전달하십시오. 이를 위해 제품에 대한 변수 모음이있는 모듈을 갖는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a4d555b6a81430095f4070dee6163a543de304b" translate="yes" xml:space="preserve">
          <source>Adding a &lt;code&gt;handlerProvider&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;handlerProvider&lt;/code&gt; 추가</target>
        </trans-unit>
        <trans-unit id="c313de6babf318503fdf433e2471023cd78a727c" translate="yes" xml:space="preserve">
          <source>Additional Options</source>
          <target state="translated">추가 옵션</target>
        </trans-unit>
        <trans-unit id="94c2eff0e92e7480eb248740c04ee58edd887616" translate="yes" xml:space="preserve">
          <source>Additionally, you need a directory containing &lt;code&gt;.js&lt;/code&gt; files that use the &lt;code&gt;graphql&lt;/code&gt; tag to describe GraphQL queries and fragments. Let's call this &lt;code&gt;./src&lt;/code&gt;.</source>
          <target state="translated">또한 &lt;code&gt;graphql&lt;/code&gt; 태그를 사용하여 GraphQL 쿼리 및 조각을 설명 하는 &lt;code&gt;.js&lt;/code&gt; 파일이 포함 된 디렉토리가 필요합니다 . 이것을 &lt;code&gt;./src&lt;/code&gt; 라고합시다 .</target>
        </trans-unit>
        <trans-unit id="e7c13cb060f72ef8e06bc9f0779c54871d13ff35" translate="yes" xml:space="preserve">
          <source>Advanced Mutation Example</source>
          <target state="translated">고급 돌연변이 예</target>
        </trans-unit>
        <trans-unit id="5126940d744a6dff391a643edf858b06f00785ed" translate="yes" xml:space="preserve">
          <source>Advanced usage</source>
          <target state="translated">고급 사용법</target>
        </trans-unit>
        <trans-unit id="78bdcba5217f6a92239c4e8dde28377bb7815364" translate="yes" xml:space="preserve">
          <source>After initially fetching this story our cache might be as follows. Note that the story and comment both link to the same record as &lt;code&gt;author&lt;/code&gt;:</source>
          <target state="translated">이 스토리를 처음 가져온 후 캐시는 다음과 같습니다. 이야기와 의견은 모두 &lt;code&gt;author&lt;/code&gt; 와 동일한 레코드에 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="cefb28e5c89ebf89740e7f56f62c4e404d2462a6" translate="yes" xml:space="preserve">
          <source>All data is fetched in a single round trip.</source>
          <target state="translated">모든 데이터는 한 번의 왕복으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="40454335b535c042b908582ab2dd06293106ac63" translate="yes" xml:space="preserve">
          <source>All of the mutations we've performed so far have waited on a response from the server before updating the client-side store. Relay offers us a chance to craft an optimistic response of the same shape based on what we expect the server's response to be in the event of a successful mutation.</source>
          <target state="translated">지금까지 수행 한 모든 변이는 클라이언트 측 저장소를 업데이트하기 전에 서버의 응답을 기다렸습니다. Relay는 성공적인 돌연변이가 발생할 경우 서버의 응답이 무엇인지에 따라 동일한 형태의 낙관적 응답을 만들 수있는 기회를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6e5ef228d93a867965453c9210e08a5fc6427932" translate="yes" xml:space="preserve">
          <source>Alternatively a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; can also be used.</source>
          <target state="translated">또는 &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; 를&lt;/a&gt; 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cb1f93043bd5b1e4766b2a5f1a916dfbf98f41c" translate="yes" xml:space="preserve">
          <source>Alternatively, you can install &lt;code&gt;relay-compiler&lt;/code&gt; globally so you can access it directly:</source>
          <target state="translated">또는 &lt;code&gt;relay-compiler&lt;/code&gt; 전체적으로 설치 하여 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7be8aae845923a0feac81e1f7b4b0b1b6931db" translate="yes" xml:space="preserve">
          <source>Although the response is hierarchical, we'll cache it by flattening all the records. Here is an example of how Relay would cache this query response:</source>
          <target state="translated">응답은 계층 적이지만 모든 레코드를 병합하여 캐시합니다. 다음은 Relay가이 쿼리 응답을 캐시하는 방법의 예입니다.</target>
        </trans-unit>
        <trans-unit id="c6ec18663142d1b37b9759d8f91cf8ac740a2752" translate="yes" xml:space="preserve">
          <source>An area we've gotten a lot of questions on was mutations and their configs. Relay Modern introduces a new mutation API that allows records and fields to be updated in a more direct manner.</source>
          <target state="translated">우리가 많은 질문을 한 영역은 돌연변이와 그 구성이었습니다. Relay Modern은 레코드와 필드를보다 직접적인 방식으로 업데이트 할 수있는 새로운 돌연변이 API를 도입했습니다.</target>
        </trans-unit>
        <trans-unit id="16a242bdcfab9509fa528a20336ea8be61d5d155" translate="yes" xml:space="preserve">
          <source>An array containing the field names between the parent and the connection, including the parent and the connection</source>
          <target state="translated">부모와 연결을 포함하여 부모와 연결 사이의 필드 이름을 포함하는 배열</target>
        </trans-unit>
        <trans-unit id="ab5c749afdc7ed704bf1427839cff1f6c54727ed" translate="yes" xml:space="preserve">
          <source>An example using &lt;code&gt;fetch&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;fetch&lt;/code&gt; 를 사용하는 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecb9a82e766e01fb5997898864c15b00f3207e54" translate="yes" xml:space="preserve">
          <source>An instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; encapsulates an in-memory cache of GraphQL data and a network layer that provides access to your GraphQL server. The Environment object is typically not used by developers directly, instead it is passed to each &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, which uses the environment to access, modify, and fetch data. Within a container, the current environment can be accessed via &lt;code&gt;this.props.relay.environment&lt;/code&gt;. This is most commonly used to &lt;a href=&quot;mutations&quot;&gt;execute a mutation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-environment&quot;&gt;릴레이 환경&lt;/a&gt; 의 인스턴스는 GraphQL 데이터의 인 메모리 캐시와 GraphQL 서버에 대한 액세스를 제공하는 네트워크 계층을 캡슐화합니다. 환경 객체는 일반적으로 개발자가 직접 사용하지 않고 환경을 사용하여 데이터를 액세스, 수정 및 가져 오는 각 &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; 로 전달됩니다 . 컨테이너 내에서 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 를 통해 현재 환경에 액세스 할 수 있습니다 . 이것은 &lt;a href=&quot;mutations&quot;&gt;돌연변이&lt;/a&gt; 를 실행하는 데 가장 일반적으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="6dd9dc1929b158a9c5ea7752c056cc104664b1ef" translate="yes" xml:space="preserve">
          <source>An object that conforms to the &lt;code&gt;Relay.Environment&lt;/code&gt; interface, such as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">그 목적에 부합 &lt;code&gt;Relay.Environment&lt;/code&gt; 의 같은 인터페이스 &lt;code&gt;Relay.Store&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac7cf5ea35aac5de7114e6afc02d20f82b3316f0" translate="yes" xml:space="preserve">
          <source>An optional &lt;code&gt;onReadyStateChange&lt;/code&gt; callback can be supplied to respond to the events involved with the data fulfillment.</source>
          <target state="translated">데이터 이행과 관련된 이벤트에 응답하기 위해 선택적 &lt;code&gt;onReadyStateChange&lt;/code&gt; 콜백을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7303f03f73c25d8e0d64d93962d92858e7741e4b" translate="yes" xml:space="preserve">
          <source>And here's a possible response:</source>
          <target state="translated">가능한 답변은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="369fe458331664a040bf70efbb8b99da198958aa" translate="yes" xml:space="preserve">
          <source>And this fragment can then be used to define the Story container:</source>
          <target state="translated">그런 다음이 단편을 사용하여 Story 컨테이너를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="605ea43af6ae69ff62a257b6fd0223b045c71edf" translate="yes" xml:space="preserve">
          <source>Any field in the payload that can be correlated by DataID with one or more records in the client-side store will be merged with the record(s) in the store.</source>
          <target state="translated">클라이언트 측 상점의 하나 이상의 레코드와 DataID로 상관 될 수있는 페이로드의 모든 필드는 상점의 레코드와 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="cfe1cdd7971ecdf1250f379fc5280623f121ecd7" translate="yes" xml:space="preserve">
          <source>Any props that we pass to the constructor of a mutation will become available to its instance methods as &lt;code&gt;this.props&lt;/code&gt;. Like in components used within Relay containers, props for which a corresponding fragment has been defined will be populated by Relay with query data:</source>
          <target state="translated">돌연변이 생성자에 전달하는 소품은 인스턴스 메소드에서 &lt;code&gt;this.props&lt;/code&gt; 로 사용할 수있게됩니다 . 릴레이 컨테이너 내에서 사용되는 구성 요소에서와 같이 해당 프래그먼트가 정의 된 소품은 쿼리 데이터로 Relay에 의해 채워집니다.</target>
        </trans-unit>
        <trans-unit id="2c3c3b69096651daf12db619c2e7045eb0884046" translate="yes" xml:space="preserve">
          <source>Any server can be taught to load a schema and speak GraphQL. Our &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;examples&lt;/a&gt; use Express.</source>
          <target state="translated">모든 서버는 스키마를로드하고 GraphQL을 말할 수 있습니다. 우리의 &lt;a href=&quot;https://github.com/relayjs/relay-examples&quot;&gt;예&lt;/a&gt; 는 Express를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8a830514fbc11a8668a4369e6666ef8944337af6" translate="yes" xml:space="preserve">
          <source>Applications must supply a &lt;a href=&quot;network-layer&quot;&gt;Network Layer&lt;/a&gt; when creating an instance of a Relay Environment. The network layer is an object conforming to a simple interface through which Relay can execute queries, mutations, and subscriptions. Essentially, this object teaches Relay how to talk to your GraphQL server.</source>
          <target state="translated">릴레이 환경의 인스턴스를 만들 때 응용 프로그램은 &lt;a href=&quot;network-layer&quot;&gt;네트워크 계층을&lt;/a&gt; 제공해야합니다 . 네트워크 계층은 Relay가 쿼리, 돌연변이 및 구독을 실행할 수있는 간단한 인터페이스를 준수하는 객체입니다. 기본적으로이 객체는 Relay가 GraphQL 서버와 통신하는 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="dd4d4251ad9eea93ba8b6656973531a29f150428" translate="yes" xml:space="preserve">
          <source>Array fields</source>
          <target state="translated">배열 필드</target>
        </trans-unit>
        <trans-unit id="f3aab73669ac6dc9de81f7b41eeb64591c4e0ee7" translate="yes" xml:space="preserve">
          <source>As an example, we can log each mutation that is sent to the server as follows:</source>
          <target state="translated">예를 들어, 서버로 전송 된 각 돌연변이를 다음과 같이 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93df315a58852563161dbb62a33b18e1c4b63051" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay containers declare data requirements as GraphQL fragments. This means that, for example, &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; can be embedded not only in &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt;, but any container that fetches a field of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">우리가 배운 것처럼 릴레이 컨테이너는 데이터 요구 사항을 GraphQL 조각으로 선언합니다. 예를 들어 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 는 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 뿐만 아니라 &lt;code&gt;User&lt;/code&gt; 유형의 필드를 가져 오는 컨테이너에도 포함 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="923622cbd0c4bbb9c49d319a01f53817606d02a1" translate="yes" xml:space="preserve">
          <source>As we've learned, Relay fragment containers declare data requirements as GraphQL fragments. We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; fragment in a GraphQL query.</source>
          <target state="translated">우리가 배운대로 Relay 프래그먼트 컨테이너는 데이터 요구 사항을 GraphQL 프래그먼트로 선언합니다. 우리는 Relay가 이러한 구성 요소에 대한 데이터 요구 사항을 충족하고 렌더링 할 수 있도록 거의 준비가되었습니다. 그러나 한 가지 문제가 있습니다. GraphQL로 데이터를 실제로 가져 오려면 쿼리 루트가 필요합니다. 예를 들어, GraphQL 쿼리에서 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 조각 을 접지해야 합니다.</target>
        </trans-unit>
        <trans-unit id="6a71de49f031297e07457bef14ae0f8572e55b44" translate="yes" xml:space="preserve">
          <source>At this point, you can delete everything up until &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt;.</source>
          <target state="translated">이 시점에서 &lt;code&gt;queryType&lt;/code&gt; in &lt;code&gt;./data/schema.js&lt;/code&gt; 까지 모든 것을 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="207aae1b1d93e0ae663b416c543d4e3848a98ef0" translate="yes" xml:space="preserve">
          <source>Authoring a schema</source>
          <target state="translated">스키마 작성</target>
        </trans-unit>
        <trans-unit id="3eb220f88ae787a8eafb5d737da557d0ab6ff6ca" translate="yes" xml:space="preserve">
          <source>Babel Relay Plugin</source>
          <target state="translated">바벨 릴레이 플러그인</target>
        </trans-unit>
        <trans-unit id="0351d5a9ef82b115e9ed00101cebdddfe0dbad30" translate="yes" xml:space="preserve">
          <source>Base React Component</source>
          <target state="translated">기본 반응 성분</target>
        </trans-unit>
        <trans-unit id="a6551059bdb95efc2dfbc4b7c2ce6ccc9fcd0365" translate="yes" xml:space="preserve">
          <source>Before going any further, we need to serialize our executable schema to JSON for use by the Relay.QL transpiler, then start up the server. From the command line:</source>
          <target state="translated">더 진행하기 전에 Relay.QL 트랜스 파일러에서 사용할 수 있도록 실행 가능 스키마를 JSON으로 직렬화 한 다음 서버를 시작해야합니다. 명령 행에서 :</target>
        </trans-unit>
        <trans-unit id="97cecb9e6bdc8256a26df17eef65a9b41e163cee" translate="yes" xml:space="preserve">
          <source>Before taking a deep dive into the mutations API, let's look at a complete example. Here, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; to create a custom mutation that we can use to like a story.</source>
          <target state="translated">돌연변이 API에 대해 자세히 알아보기 전에 전체 예를 살펴 보겠습니다. 여기에서는 스토리를 좋아하는 데 사용할 수있는 사용자 지정 돌연변이를 만들기 위해 &lt;code&gt;Relay.Mutation&lt;/code&gt; 을 서브 클래 싱 합니다.</target>
        </trans-unit>
        <trans-unit id="949c7a85f6d836f247f0195b7eaa99f0c336e992" translate="yes" xml:space="preserve">
          <source>Behaviors can be one of &lt;code&gt;'append'&lt;/code&gt;, &lt;code&gt;'ignore'&lt;/code&gt;, &lt;code&gt;'prepend'&lt;/code&gt;, &lt;code&gt;'refetch'&lt;/code&gt;, or &lt;code&gt;'remove'&lt;/code&gt;.</source>
          <target state="translated">동작은 &lt;code&gt;'append'&lt;/code&gt; , &lt;code&gt;'ignore'&lt;/code&gt; , &lt;code&gt;'prepend'&lt;/code&gt; , &lt;code&gt;'refetch'&lt;/code&gt; 또는 &lt;code&gt;'remove'&lt;/code&gt; 중 하나 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a13e0d17d14c44107ca60ab513e5d71d5662c000" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Faction&lt;/code&gt; and &lt;code&gt;Ship&lt;/code&gt; have identifiers that we can use to refetch them. We expose this capability to Relay through the &lt;code&gt;Node&lt;/code&gt; interface and the &lt;code&gt;node&lt;/code&gt; field on the root query type.</source>
          <target state="translated">&lt;code&gt;Faction&lt;/code&gt; 과 &lt;code&gt;Ship&lt;/code&gt; 에는 모두 이를 반입하는 데 사용할 수있는 식별자가 있습니다. 루트 쿼리 유형 의 &lt;code&gt;Node&lt;/code&gt; 인터페이스 및 &lt;code&gt;node&lt;/code&gt; 필드를 통해이 기능을 릴레이에 노출 합니다.</target>
        </trans-unit>
        <trans-unit id="3148373f94223f76742328ea5464dd9f30817fe7" translate="yes" xml:space="preserve">
          <source>But now, we can also create routes for arbitrary user IDs. For example, if we wanted to construct a route that fetched data for a user defined by the &lt;code&gt;userID&lt;/code&gt; query parameter, we might use:</source>
          <target state="translated">그러나 이제 임의의 사용자 ID에 대한 경로를 만들 수도 있습니다. 예를 들어, &lt;code&gt;userID&lt;/code&gt; 쿼리 매개 변수로 정의 된 사용자에 대한 데이터를 가져 오는 경로를 구성 하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1862f3355eff810374142f7e656f80df21c55213" translate="yes" xml:space="preserve">
          <source>By convention, mutations are named as verbs, their inputs are the name with &quot;Input&quot; appended at the end, and they return an object that is the name with &quot;Payload&quot; appended.</source>
          <target state="translated">일반적으로 돌연변이는 동사로 이름이 지정되고 입력은 끝에 &quot;Input&quot;이 추가 된 이름이며 &quot;Payload&quot;가 추가 된 이름의 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="178b930518b904dbc5bd0f441c18fc870aac28c3" translate="yes" xml:space="preserve">
          <source>By default, Relay assumes that GraphQL is served at &lt;code&gt;/graphql&lt;/code&gt; relative to the origin where our application is served. This can be re-configured by injecting a custom instantiation of the default network layer.</source>
          <target state="translated">기본적으로 Relay는 GraphQL이 응용 프로그램이 제공되는 원본을 기준으로 &lt;code&gt;/graphql&lt;/code&gt; 에 제공되는 것으로 가정합니다 . 기본 네트워크 계층의 사용자 지정 인스턴스를 주입하여 다시 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c01482f7fe504d2a5e3cc944236d88811dd8d351" translate="yes" xml:space="preserve">
          <source>By default, nothing is rendered while loading data for the initial render. If a previous set of &lt;code&gt;Component&lt;/code&gt; and &lt;code&gt;route&lt;/code&gt; were fulfilled and rendered, the default behavior is to continue rendering the previous view.</source>
          <target state="translated">기본적으로 초기 렌더링에 대한 데이터를로드하는 동안 아무것도 렌더링되지 않습니다. 이전 &lt;code&gt;Component&lt;/code&gt; 및 &lt;code&gt;route&lt;/code&gt; 세트 가 이행되고 렌더링 된 경우 기본 동작은 이전보기를 계속 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4375c1481c81a0b6d8e08ac19523704d5d4da90b" translate="yes" xml:space="preserve">
          <source>Cache Consistency</source>
          <target state="translated">캐시 일관성</target>
        </trans-unit>
        <trans-unit id="14776554d5693e023c3ac7a5a65e4a5058537dfe" translate="yes" xml:space="preserve">
          <source>Cache Updates</source>
          <target state="translated">캐시 업데이트</target>
        </trans-unit>
        <trans-unit id="eed1812845bba88a7ea96dc0731ed87a6365fcc0" translate="yes" xml:space="preserve">
          <source>Caching A Graph</source>
          <target state="translated">그래프 캐싱</target>
        </trans-unit>
        <trans-unit id="c3fbd240479228aa26381115ef997022e9773856" translate="yes" xml:space="preserve">
          <source>Call this to optimistically apply an update to the store.</source>
          <target state="translated">상점에 업데이트를 낙관적으로 적용하려면이를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="ef28016b715246d53e3c0aef32bef448a5df1961" translate="yes" xml:space="preserve">
          <source>Call this to send the mutation to the server.</source>
          <target state="translated">서버에 변이를 보내려면 이것을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="36653c1ff08edcb50e3d0e9893272cf6219ebfe7" translate="yes" xml:space="preserve">
          <source>Callers must provide an appropriate &lt;code&gt;query&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. As per the GraphQL Relay Specification:</source>
          <target state="translated">호출자는 적절한 &lt;code&gt;query&lt;/code&gt; 와 &lt;code&gt;variables&lt;/code&gt; 제공해야합니다 . GraphQL 릴레이 사양에 따라 :</target>
        </trans-unit>
        <trans-unit id="ec585c24a23bd7001c34d954b9fe9b0796cec5f2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; with a record from &lt;code&gt;this.props&lt;/code&gt; will return whether that given record is affected by an optimistic mutation. It allows the component to render local optimistic changes differently from data that has successfully synchronized with the server.</source>
          <target state="translated">&lt;code&gt;this.props&lt;/code&gt; 의 레코드로 &lt;code&gt;hasOptimisticUpdate&lt;/code&gt; 를 호출 하면 해당 레코드가 낙관적 돌연변이의 영향을 받는지 여부를 리턴합니다. 구성 요소가 서버와 성공적으로 동기화 된 데이터와 다른 부분적으로 로컬 낙관적 변경 사항을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e92933047a9a8b8023050178520d6236fd1d0bd" translate="yes" xml:space="preserve">
          <source>Calling Component Instance Methods</source>
          <target state="translated">컴포넌트 인스턴스 메소드 호출</target>
        </trans-unit>
        <trans-unit id="539001ff0ade75c366a1d2f2ae990718f2b4bd9b" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Classic Environment (&lt;code&gt;Store&lt;/code&gt; in &lt;code&gt;react-relay/classic&lt;/code&gt;) use:</source>
          <target state="translated">클래식 환경 사용 캔 QueryRenderer ( &lt;code&gt;Store&lt;/code&gt; 에서가 &lt;code&gt;react-relay/classic&lt;/code&gt; 사용) :</target>
        </trans-unit>
        <trans-unit id="4aacaa8308c0d89cb19bc6280f172bcb3027eef8" translate="yes" xml:space="preserve">
          <source>Can QueryRenderer using Modern Environment use:</source>
          <target state="translated">최신 환경을 사용하는 QueryRenderer는 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1003218887eb40c1f0a58bc7b7505d15f23175bf" translate="yes" xml:space="preserve">
          <source>Can React Classic Component use:</source>
          <target state="translated">클래식 컴포넌트 사용에 반응 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="84238b1b418a17b213190530f83d669483ad4f99" translate="yes" xml:space="preserve">
          <source>Can React Compat Component use:</source>
          <target state="translated">Compat Component 사용에 반응 할 수 있음 :</target>
        </trans-unit>
        <trans-unit id="1c53c8d6a82f41f51bcb44a951f6d42bbd674773" translate="yes" xml:space="preserve">
          <source>Can React Modern Component use:</source>
          <target state="translated">최신 컴포넌트 사용에 반응 할 수 있음 :</target>
        </trans-unit>
        <trans-unit id="ce811e756a396388182f7a8551a77979cea636ea" translate="yes" xml:space="preserve">
          <source>Can RelayRootContainer use:</source>
          <target state="translated">RelayRootContainer를 사용할 수 있습니까 :</target>
        </trans-unit>
        <trans-unit id="918e312c8dc15e096c8aa60a584cd24fb9b592cd" translate="yes" xml:space="preserve">
          <source>Changing Arguments</source>
          <target state="translated">인수 변경</target>
        </trans-unit>
        <trans-unit id="51cdd39226322d9d0efb448c0d03eb64cb6c777d" translate="yes" xml:space="preserve">
          <source>Changing one thing in a system can have a ripple effect that causes other things to change in turn. Imagine a mutation that we can use to accept a friend request. This can have wide implications:</source>
          <target state="translated">시스템에서 한 가지를 변경하면 다른 것들이 차례로 변경되는 파급 효과가 발생할 수 있습니다. 친구 요청을 수락하는 데 사용할 수있는 돌연변이를 상상해보십시오. 이것은 광범위한 의미를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb73c6b849ccfd7df64b939d3890bbba8b94e10a" translate="yes" xml:space="preserve">
          <source>Classic Component</source>
          <target state="translated">클래식 구성 요소</target>
        </trans-unit>
        <trans-unit id="9e402ea82ec577f1a7b994361d91b4f9ac1cf510" translate="yes" xml:space="preserve">
          <source>Classic Mutation</source>
          <target state="translated">클래식 돌연변이</target>
        </trans-unit>
        <trans-unit id="76be385c076bd3cf6a0e76bbefee914b22199f01" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;&amp;lt;RelayRootContainer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9450d4893299b4475b958954ce614f6339c011c9" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;Relay.createContainer&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;Relay.createContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdacd86df881f947250264b6f74153f74ca2e17b" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;this.props.relay.commitUpdate(mutation...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4496ce0ff60c519ddb23c737b94a8c3d0f8fae44" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;this.props.relay.forceFetch()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4718307cda6ad09eb778eec75ee2c5f20cd45961" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;this.props.relay.setVariable({count: prevCount + pageSize}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a88cd760542eea1905cd9d8225750e276c483cde" translate="yes" xml:space="preserve">
          <source>Classic: &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</source>
          <target state="translated">클래식 : &lt;code&gt;this.props.relay.setVariable({foo: bar}...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6f5633b3ae0188027fabbde415e0f3fcc71e6c3" translate="yes" xml:space="preserve">
          <source>Client Caching</source>
          <target state="translated">클라이언트 캐싱</target>
        </trans-unit>
        <trans-unit id="d4d64d5c478ea7fd0df7b8579f158dc6ea90455b" translate="yes" xml:space="preserve">
          <source>Client Schema Extensions (Experimental)</source>
          <target state="translated">클라이언트 스키마 확장 (실험)</target>
        </trans-unit>
        <trans-unit id="a359c7ebffb6706034dbf0f013aa73bcc550292c" translate="yes" xml:space="preserve">
          <source>Comparing Relay Classic and Relay Modern</source>
          <target state="translated">릴레이 클래식과 릴레이 모던 비교</target>
        </trans-unit>
        <trans-unit id="c54dbbae41b051460dcc8e3c9aa6f310af3f2775" translate="yes" xml:space="preserve">
          <source>Compat Component</source>
          <target state="translated">Compat 컴포넌트</target>
        </trans-unit>
        <trans-unit id="2171ca54b3db409d7e88bfa689ea2ab5583955c6" translate="yes" xml:space="preserve">
          <source>Compat Mode</source>
          <target state="translated">Compat 모드</target>
        </trans-unit>
        <trans-unit id="ef1a53514cc801546fdbf4bd01e2b4b764618f78" translate="yes" xml:space="preserve">
          <source>Compat Mutation</source>
          <target state="translated">Compat Mutation</target>
        </trans-unit>
        <trans-unit id="7ae7318a99d95f75927a3ae6b936e04d175cc04e" translate="yes" xml:space="preserve">
          <source>Compatibility Cheatsheet</source>
          <target state="translated">호환성 치트 시트</target>
        </trans-unit>
        <trans-unit id="6d9f235cb9c7c65f0cf0b1b0814cadde6d86abcb" translate="yes" xml:space="preserve">
          <source>Compatibility Mode</source>
          <target state="translated">호환 모드</target>
        </trans-unit>
        <trans-unit id="89e9d1be17321688f8d0501eb1a3bf2c6ca26c3e" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL Cursor Connections&lt;/a&gt; spec.</source>
          <target state="translated">서버의 동작 방식에 대한 자세한 내용은 &lt;a href=&quot;https://facebook.github.io/relay/graphql/connections.htm&quot;&gt;GraphQL 커서 연결&lt;/a&gt; 사양 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="29619ae00dc1b1f13f0d8573c5ca62184c0a6a94" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL Input Object Mutations&lt;/a&gt; spec.</source>
          <target state="translated">서버의 동작 방식에 대한 자세한 내용은 &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL 입력 객체 돌연변이&lt;/a&gt; 사양 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd80bd3e0728573910ceff942d6bf05bb7333573" translate="yes" xml:space="preserve">
          <source>Complete details on how the server should behave are available in the &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL Object Identification&lt;/a&gt; spec.</source>
          <target state="translated">서버의 동작 방식에 대한 자세한 내용은 &lt;a href=&quot;https://facebook.github.io/relay/graphql/objectidentification.htm&quot;&gt;GraphQL 객체 식별&lt;/a&gt; 사양 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c92c529e0731c57efd7550480196484040b33c3e" translate="yes" xml:space="preserve">
          <source>Component</source>
          <target state="translated">Component</target>
        </trans-unit>
        <trans-unit id="725a4ffad64df11f9defa669f85ec107f9dc492d" translate="yes" xml:space="preserve">
          <source>Component and Route</source>
          <target state="translated">구성 요소 및 경로</target>
        </trans-unit>
        <trans-unit id="94c5c072cfb48e6d9ea12f613a057a202a5c287b" translate="yes" xml:space="preserve">
          <source>Components can change their data requirements by using &lt;code&gt;setVariables&lt;/code&gt; to request an update to the current set of &lt;code&gt;variables&lt;/code&gt;.</source>
          <target state="translated">구성 요소는 &lt;code&gt;setVariables&lt;/code&gt; 를 사용 하여 현재 &lt;code&gt;variables&lt;/code&gt; 집합에 대한 업데이트를 요청 하여 데이터 요구 사항을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31ae8b82fb482703d4497f95cafdbd464174a12e" translate="yes" xml:space="preserve">
          <source>Components can inspect pending mutations on any record (i.e. data made available in props with a corresponding fragment). Calling &lt;code&gt;getPendingTransactions&lt;/code&gt; with a record will return a list of the pending mutation transactions that affect that particular record.</source>
          <target state="translated">구성 요소는 모든 레코드에서 보류중인 돌연변이를 검사 할 수 있습니다 (예 : 해당 프래그먼트가있는 소품에서 사용 가능한 데이터). 레코드와 함께 &lt;code&gt;getPendingTransactions&lt;/code&gt; 를 호출 하면 해당 특정 레코드에 영향을 미치는 보류중인 돌연변이 트랜잭션 목록이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="deee480cd52fae7c121c1d7b8b86ecda66617156" translate="yes" xml:space="preserve">
          <source>Composing Fragments</source>
          <target state="translated">조각 구성</target>
        </trans-unit>
        <trans-unit id="2a321a9ac4f3111d95368aba4e87b1917d75348e" translate="yes" xml:space="preserve">
          <source>Composing Views - It's Plain React</source>
          <target state="translated">작곡보기-평범한 반응</target>
        </trans-unit>
        <trans-unit id="723e2c15fe85b32b7d864e21eb29e93116b04e14" translate="yes" xml:space="preserve">
          <source>Composing child component fragments in a parent fragment.</source>
          <target state="translated">부모 조각에서 자식 구성 요소 조각을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="f82641d3cbab73b5e585b20db3196f350cb839d5" translate="yes" xml:space="preserve">
          <source>Composing fragments defined as local variables.</source>
          <target state="translated">지역 변수로 정의 된 조각 구성.</target>
        </trans-unit>
        <trans-unit id="114b9abd3f0b27b8a9b5084318c5af838acdb163" translate="yes" xml:space="preserve">
          <source>Composing the data descriptions.</source>
          <target state="translated">데이터 설명 작성</target>
        </trans-unit>
        <trans-unit id="59d6b2067a223146a5ead92a4c5fe072d43c9a1e" translate="yes" xml:space="preserve">
          <source>Composing the fragments of child components is discussed in detail in the &lt;a href=&quot;guides-containers&quot;&gt;Containers Guide&lt;/a&gt;, but here's a quick example:</source>
          <target state="translated">하위 구성 요소 조각 구성은 &lt;a href=&quot;guides-containers&quot;&gt;컨테이너 안내서&lt;/a&gt; 에서 자세히 설명 하지만 다음은 간단한 예입니다.</target>
        </trans-unit>
        <trans-unit id="a7b041783bd841c2982c635611a14b9b0478fc32" translate="yes" xml:space="preserve">
          <source>Composing the view logic, and</source>
          <target state="translated">뷰 로직 구성</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="9d60520748b88da0348eeb8f6543f6f98cdbd262" translate="yes" xml:space="preserve">
          <source>Conditional fields</source>
          <target state="translated">조건부 필드</target>
        </trans-unit>
        <trans-unit id="6355cff1e61b5cd688cec493b080516655b2ac6a" translate="yes" xml:space="preserve">
          <source>Configs</source>
          <target state="translated">Configs</target>
        </trans-unit>
        <trans-unit id="6512ee1541e9a6c52d5bf7cf465332e8df25ea3c" translate="yes" xml:space="preserve">
          <source>Connection</source>
          <target state="translated">Connection</target>
        </trans-unit>
        <trans-unit id="81ea0a30d213381b26e05bce9c491003535b147a" translate="yes" xml:space="preserve">
          <source>Consider an input with a server-defined placeholder text and an imperative method to focus the input node:</source>
          <target state="translated">서버에서 정의한 자리 표시 자 텍스트와 입력 노드에 초점을 맞추기위한 명령 방식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="1956d506ca97255f5713770475161b61eb6cde73" translate="yes" xml:space="preserve">
          <source>Consider rendering the text and comments of a story along with the corresponding author names and photos. Here's the GraphQL query:</source>
          <target state="translated">이야기의 텍스트와 의견을 해당 저자 이름과 사진과 함께 렌더링하는 것을 고려하십시오. GraphQL 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e6443af99d2f470f50affd5057bf48db2d09dae4" translate="yes" xml:space="preserve">
          <source>Container</source>
          <target state="translated">Container</target>
        </trans-unit>
        <trans-unit id="0d5a8d03518c194626d6e3e124e7de20c17a7fe5" translate="yes" xml:space="preserve">
          <source>Container Composition</source>
          <target state="translated">컨테이너 구성</target>
        </trans-unit>
        <trans-unit id="b625b62c69e181700306e0871c20a6c94eaa2510" translate="yes" xml:space="preserve">
          <source>Container Specification</source>
          <target state="translated">컨테이너 사양</target>
        </trans-unit>
        <trans-unit id="dfe33c87ae0783b9497dae2f22418a5e90385aa4" translate="yes" xml:space="preserve">
          <source>Container.getFragment()</source>
          <target state="translated">Container.getFragment()</target>
        </trans-unit>
        <trans-unit id="e040a458f46532a90ec69fa0b4bfc33ba151c98b" translate="yes" xml:space="preserve">
          <source>Containers</source>
          <target state="translated">Containers</target>
        </trans-unit>
        <trans-unit id="4b51306faf49817c8299a221a2777da9319cb8d3" translate="yes" xml:space="preserve">
          <source>Containers are Higher-Order Components</source>
          <target state="translated">컨테이너는 더 높은 주문 구성 요소입니다</target>
        </trans-unit>
        <trans-unit id="46e795775ec1e8e3e71a6a5641d35b084e19a5a9" translate="yes" xml:space="preserve">
          <source>Containers can define a &lt;code&gt;prepareVariables&lt;/code&gt; method which provides the opportunity to modify the variables that are available to fragments. The new variables can be generated based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist) in addition to the runtime environment.</source>
          <target state="translated">컨테이너는 프래그먼트에 사용 가능한 변수를 수정할 수있는 기회를 제공 하는 &lt;code&gt;prepareVariables&lt;/code&gt; 메소드를 정의 할 수 있습니다 . 런타임 환경 외에 이전 변수 (또는 이전 변수 가없는 경우 &lt;code&gt;initialVariables&lt;/code&gt; )를 기반으로 새 변수를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad0eb4a22e44d99ae045c52ec3f202dc664a29f9" translate="yes" xml:space="preserve">
          <source>Containers declare data requirements on &lt;code&gt;fragments&lt;/code&gt; using GraphQL fragments.</source>
          <target state="translated">컨테이너에 데이터 요구 선언 &lt;code&gt;fragments&lt;/code&gt; GraphQL 단편을 사용한다.</target>
        </trans-unit>
        <trans-unit id="8928f5de2a918d60f1bbb5d72e6a68cb7502e86a" translate="yes" xml:space="preserve">
          <source>Convenience method that wraps the constructor, passing some default parameters and returning an instance.</source>
          <target state="translated">생성자를 래핑하고 일부 기본 매개 변수를 전달하고 인스턴스를 반환하는 편의 메서드입니다.</target>
        </trans-unit>
        <trans-unit id="dd226f43ba5c8ff842931a3ca2796d7c444510a9" translate="yes" xml:space="preserve">
          <source>Conversion Playbook</source>
          <target state="translated">변환 플레이 북</target>
        </trans-unit>
        <trans-unit id="aca075e23eed144339279d097d6fa88dc0718ec3" translate="yes" xml:space="preserve">
          <source>Conversion Scripts</source>
          <target state="translated">변환 스크립트</target>
        </trans-unit>
        <trans-unit id="e93c185376ad3e3749d528694597be4eb780596d" translate="yes" xml:space="preserve">
          <source>Create a mutation instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some props. Note that &lt;code&gt;this.props&lt;/code&gt; is &lt;em&gt;not&lt;/em&gt; available inside the constructor function, but are set for all the methods mentioned below (&lt;code&gt;getCollisionKey&lt;/code&gt;, &lt;code&gt;getOptimisticResponse&lt;/code&gt;, etc). This restriction is due to the fact that mutation props may depend on data from the RelayEnvironment, which isn't known until the mutation is applied with &lt;code&gt;applyUpdate&lt;/code&gt; or &lt;code&gt;commitUpdate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드 를 사용하여 선택적으로 소품을 전달 하여 돌연변이 인스턴스를 만듭니다 . 참고 &lt;code&gt;this.props&lt;/code&gt; 가 있다 &lt;em&gt;하지&lt;/em&gt; 생성자 함수 내부 가능하지만, 방법 (아래에 언급 된 모든 설정 &lt;code&gt;getCollisionKey&lt;/code&gt; , &lt;code&gt;getOptimisticResponse&lt;/code&gt; 등). 이 제한은 돌연변이 소품이 RelayEnvironment의 데이터에 의존 할 수 있기 때문입니다. 이는 &lt;code&gt;applyUpdate&lt;/code&gt; 가 applyUpdate 또는 &lt;code&gt;commitUpdate&lt;/code&gt; 로 적용될 때까지 알려지지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="70fb5b0ec1a182be6e0a0d9950900f7bbb367668" translate="yes" xml:space="preserve">
          <source>Create a route instance using the &lt;code&gt;new&lt;/code&gt; keyword, optionally passing it some params.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 키워드 를 사용하여 경로 인스턴스를 작성하고 선택적으로 일부 매개 변수를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="22330ce575ca322006e65a1cba21c0878bcce956" translate="yes" xml:space="preserve">
          <source>Creates a new Relay Container - see the &lt;a href=&quot;guides-containers&quot;&gt;Container Guide&lt;/a&gt; for more details and examples.</source>
          <target state="translated">새 릴레이 컨테이너를 만듭니다 . 자세한 내용과 예제 는 &lt;a href=&quot;guides-containers&quot;&gt;컨테이너 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="cc084a8dfcc6a7bce1de7aefac278e961edc50ea" translate="yes" xml:space="preserve">
          <source>Currently the easiest way to create a network layer is via a helper from the &lt;code&gt;relay-runtime&lt;/code&gt; package:</source>
          <target state="translated">현재 네트워크 계층을 만드는 가장 쉬운 방법은 &lt;code&gt;relay-runtime&lt;/code&gt; 패키지 의 도우미를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="461be9b9f59ebf2cd3bfe288b44d41bb20a992dc" translate="yes" xml:space="preserve">
          <source>Custom HTTP headers can be configured by providing a &lt;code&gt;headers&lt;/code&gt; object:</source>
          <target state="translated">&lt;code&gt;headers&lt;/code&gt; 객체 를 제공하여 사용자 정의 HTTP 헤더를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e441c87bb7618c55b15a3915a29a65fc20c0d1cd" translate="yes" xml:space="preserve">
          <source>Custom Network Layers</source>
          <target state="translated">커스텀 네트워크 레이어</target>
        </trans-unit>
        <trans-unit id="c604943e72b71d4741cddde2419706b8dc35d372" translate="yes" xml:space="preserve">
          <source>Custom Routing and More</source>
          <target state="translated">맞춤형 라우팅 및 기타</target>
        </trans-unit>
        <trans-unit id="3fe80ac6912200b4e6e928a52d6c87fd5c777197" translate="yes" xml:space="preserve">
          <source>Custom network layers must conform to the following &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface. Although the default network layer is an instantiable class that accepts some configuration, this is not a requirement of an injected network layer.</source>
          <target state="translated">사용자 지정 네트워크 계층은 다음 &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; 인터페이스를 준수해야합니다 . 기본 네트워크 계층은 일부 구성을 허용하는 인스턴스화 가능 클래스이지만 주입 된 네트워크 계층의 요구 사항은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="342f49485ae8bc8e1ade62ea93e337457051f472" translate="yes" xml:space="preserve">
          <source>Custom network layers that must conform to the &lt;code&gt;RelayNetworkLayer&lt;/code&gt; interface.</source>
          <target state="translated">&lt;code&gt;RelayNetworkLayer&lt;/code&gt; 인터페이스를 준수해야하는 사용자 지정 네트워크 계층 .</target>
        </trans-unit>
        <trans-unit id="74c9c9c8ea99084415bd2064a41ac8fc43148678" translate="yes" xml:space="preserve">
          <source>Data Components aka Containers</source>
          <target state="translated">데이터 구성 요소 일명 컨테이너</target>
        </trans-unit>
        <trans-unit id="682fde2c24e47bc1edbae33948606de2438e015b" translate="yes" xml:space="preserve">
          <source>Data Dependencies With GraphQL</source>
          <target state="translated">GraphQL을 통한 데이터 종속성</target>
        </trans-unit>
        <trans-unit id="b8344c50bb3999d69b17cd5abd2f78e4f029419a" translate="yes" xml:space="preserve">
          <source>Data Masking</source>
          <target state="translated">데이터 마스킹</target>
        </trans-unit>
        <trans-unit id="7054bcb2316977418a434163d17919c53dc34953" translate="yes" xml:space="preserve">
          <source>Data fetched as a result of a &lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; config is not written into the client store, but you can add code that processes it in the &lt;code&gt;onSuccess&lt;/code&gt; callback that you pass into &lt;code&gt;commitUpdate()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;REQUIRED_CHILDREN&lt;/code&gt; 구성 의 결과로 가져온 데이터 는 클라이언트 저장소에 기록되지 않지만 &lt;code&gt;commitUpdate()&lt;/code&gt; 로 전달되는 &lt;code&gt;onSuccess&lt;/code&gt; 콜백 에서 처리하는 코드를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="af0a7349a2e7fc64dce9051e92bfe24510a15ba4" translate="yes" xml:space="preserve">
          <source>Data-Fetching APIs</source>
          <target state="translated">데이터 가져 오기 API</target>
        </trans-unit>
        <trans-unit id="303a7cb486f5bdd65204f79dab8db7f52fcbe4b2" translate="yes" xml:space="preserve">
          <source>Data/View Consistency</source>
          <target state="translated">데이터 / 뷰 일관성</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="ed85a15e615bc7cc2aa9ef71ae94ad5fcb7456cf" translate="yes" xml:space="preserve">
          <source>Debugging Programmatically</source>
          <target state="translated">프로그래밍 방식으로 디버깅</target>
        </trans-unit>
        <trans-unit id="45cae91f4ddfa0491f43cb639f9ed34ee522658d" translate="yes" xml:space="preserve">
          <source>Debugging Visually</source>
          <target state="translated">시각적으로 디버깅</target>
        </trans-unit>
        <trans-unit id="f33d59090001ed2c388b4cc1db43054af86f06dd" translate="yes" xml:space="preserve">
          <source>Default Network Layer</source>
          <target state="translated">기본 네트워크 계층</target>
        </trans-unit>
        <trans-unit id="20f0fc44b4326d9865c55f56d274d841f7d0587e" translate="yes" xml:space="preserve">
          <source>DefaultNetworkLayer (static property)</source>
          <target state="translated">DefaultNetworkLayer (정적 속성)</target>
        </trans-unit>
        <trans-unit id="af5bf36afc63e00856e220e9305692ac4cae2b78" translate="yes" xml:space="preserve">
          <source>Design a fat query that covers every possible field that could change:</source>
          <target state="translated">변경 가능한 모든 가능한 필드를 다루는 팻 쿼리를 설계하십시오.</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="ef7942184e9ad574a626b6cd3619cdb041e9c029" translate="yes" xml:space="preserve">
          <source>During this migration, use the &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; tools and APIs to work with both Relay Classic and Relay Modern.</source>
          <target state="translated">이 마이그레이션 중에 &lt;a href=&quot;relay-compat&quot;&gt;Relay Compat&lt;/a&gt; 도구 및 API를 사용하여 Relay Classic 및 Relay Modern과 함께 작동하십시오.</target>
        </trans-unit>
        <trans-unit id="7c5b3fea8b3510ceda05e64bba7877572b147261" translate="yes" xml:space="preserve">
          <source>Each &lt;code&gt;RelayMutationTransaction&lt;/code&gt; has methods to check the status of the mutation and provide ways to rollback or resend the mutation as needed.</source>
          <target state="translated">각 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 에는 돌연변이 상태를 확인하고 필요에 따라 돌연변이를 롤백하거나 재전송하는 방법을 제공하는 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd362bb1462055d845230a17457c0b8e8d86a3b8" translate="yes" xml:space="preserve">
          <source>Either an instance of &lt;code&gt;Relay.Route&lt;/code&gt; or an object with the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;queries&lt;/code&gt;, and optionally the &lt;code&gt;params&lt;/code&gt; properties.</source>
          <target state="translated">&lt;code&gt;Relay.Route&lt;/code&gt; 인스턴스 또는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;queries&lt;/code&gt; 및 선택적으로 &lt;code&gt;params&lt;/code&gt; 속성을 가진 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="d443a1185575c125d61e0af393b044d7b06ef572" translate="yes" xml:space="preserve">
          <source>Environment</source>
          <target state="translated">Environment</target>
        </trans-unit>
        <trans-unit id="b887632c87cffc81f6686f76c25016e576fb2182" translate="yes" xml:space="preserve">
          <source>Even though we have access to the &lt;code&gt;data&lt;/code&gt; object in &lt;code&gt;renderFetched&lt;/code&gt;, the actual data is intentionally opaque. This prevents the &lt;code&gt;renderFetched&lt;/code&gt; from creating an implicit dependency on the fragments declared by &lt;code&gt;Component&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 의 &lt;code&gt;data&lt;/code&gt; 객체에 액세스 할 수 있지만 실제 데이터는 의도적으로 불투명합니다. 이것에 의해, &lt;code&gt;renderFetched&lt;/code&gt; 가 &lt;code&gt;Component&lt;/code&gt; 에 의해 선언 된 프래그먼트에 암묵적인 의존성을 만들 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="47edfe63fdfee7ee20d0d17ccd2198d126f5e61d" translate="yes" xml:space="preserve">
          <source>Examples on how to migrate &lt;code&gt;this.props.setVariables&lt;/code&gt; calls from the old API.</source>
          <target state="translated">이전 API에서 &lt;code&gt;this.props.setVariables&lt;/code&gt; 호출 을 마이그레이션하는 방법에 대한 예제</target>
        </trans-unit>
        <trans-unit id="dba94b198da2fb33fd23ea18f305f3d0a3ec1059" translate="yes" xml:space="preserve">
          <source>Extensible Core</source>
          <target state="translated">확장 가능한 코어</target>
        </trans-unit>
        <trans-unit id="2dd50f5706aa755699729587eac1b10f1cff5f0e" translate="yes" xml:space="preserve">
          <source>FIELDS_CHANGE</source>
          <target state="translated">FIELDS_CHANGE</target>
        </trans-unit>
        <trans-unit id="48bf3bbfe2cde9b89a0197b2bfecef97b15ae5d4" translate="yes" xml:space="preserve">
          <source>Fetching Data</source>
          <target state="translated">데이터를 가져 오는 중</target>
        </trans-unit>
        <trans-unit id="9fa4dbe72754c9ca8a7a48295981890f655e2aba" translate="yes" xml:space="preserve">
          <source>Fetching Data For a View</source>
          <target state="translated">뷰를위한 데이터 페치</target>
        </trans-unit>
        <trans-unit id="ec6417097316a1a14f3a999d488c8c77877598bd" translate="yes" xml:space="preserve">
          <source>Fetching Data from the Server</source>
          <target state="translated">서버에서 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="a342eda81c049d657e5bd1f80671b4b62b62acba" translate="yes" xml:space="preserve">
          <source>Fetching all the data for a view hierarchy.</source>
          <target state="translated">뷰 계층에 대한 모든 데이터를 가져 오는 중입니다.</target>
        </trans-unit>
        <trans-unit id="448b955ee10782eac37b116fa4e7872f8363dbf4" translate="yes" xml:space="preserve">
          <source>Fewer Requirements around Routing</source>
          <target state="translated">라우팅 관련 요구 사항 감소</target>
        </trans-unit>
        <trans-unit id="6c0e1cc40fccace9c870f52b415d915d429a858c" translate="yes" xml:space="preserve">
          <source>Finally, let's tie it all together in &lt;code&gt;./js/components/App.js&lt;/code&gt;:</source>
          <target state="translated">마지막으로 &lt;code&gt;./js/components/App.js&lt;/code&gt; 에 모두 묶어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="794475575e8e8e88251415839f49042175570f60" translate="yes" xml:space="preserve">
          <source>Finally, we construct our schema (whose starting query type is the query type we defined above) and export it.</source>
          <target state="translated">마지막으로 스키마 (구문 쿼리 유형은 위에서 정의한 쿼리 유형 임)를 구성하고 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f5d8e52e096ba49348c23c94d52fb5128a53fc82" translate="yes" xml:space="preserve">
          <source>Finds or creates a single record associated with a mutable record. This is a shortcut to &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; with &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; should the associated record be non-existant.</source>
          <target state="translated">변경 가능한 레코드와 연관된 단일 레코드를 찾거나 작성합니다. 이 바로 가기입니다 &lt;code&gt;RelayRecordProxy.getLinkedRecord&lt;/code&gt; 와 &lt;code&gt;RelayRecordProxy.setLinkedRecord&lt;/code&gt; 은 관련 기록이 존재하지 않는해야한다.</target>
        </trans-unit>
        <trans-unit id="d4726e1215a3598f0b285dcd1fdabf31356a5b5b" translate="yes" xml:space="preserve">
          <source>First, install the plugin (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">먼저 플러그인을 설치하십시오 (일반적으로 &lt;code&gt;devDependency&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9ee7304a030b3188f69053199e1aa24d2c7e6c40" translate="yes" xml:space="preserve">
          <source>First, let's take a look at the &lt;code&gt;environment&lt;/code&gt; input. To perform the mutation on the correct &lt;code&gt;environment&lt;/code&gt; with the relevant data, it's a good idea to use the &lt;code&gt;environment&lt;/code&gt; used to render the components. It's accessible at &lt;code&gt;this.props.relay.environment&lt;/code&gt; from the component.</source>
          <target state="translated">먼저 &lt;code&gt;environment&lt;/code&gt; 입력을 살펴 보겠습니다 . 관련 데이터를 사용하여 올바른 &lt;code&gt;environment&lt;/code&gt; 에서 돌연변이를 수행하려면 구성 요소를 렌더링하는 데 사용되는 &lt;code&gt;environment&lt;/code&gt; 을 사용하는 것이 좋습니다 . 컴포넌트의 &lt;code&gt;this.props.relay.environment&lt;/code&gt; 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3aab624101e00feee75c13777205ffcca8d11b0" translate="yes" xml:space="preserve">
          <source>First, you need &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;watchman&lt;/a&gt; installed:</source>
          <target state="translated">먼저 &lt;a href=&quot;https://facebook.github.io/watchman&quot;&gt;워치 맨이&lt;/a&gt; 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a54de1cc9f2aff2bed1cf76593938b1ded20fcf" translate="yes" xml:space="preserve">
          <source>Flat Routes</source>
          <target state="translated">평평한 경로</target>
        </trans-unit>
        <trans-unit id="995180ea866af99054ca25768d4bd2ff5d5c8968" translate="yes" xml:space="preserve">
          <source>Flow Type Generation</source>
          <target state="translated">흐름 유형 생성</target>
        </trans-unit>
        <trans-unit id="c46edacfc204a583603ecb9b72b53c55f60dbc6a" translate="yes" xml:space="preserve">
          <source>For a complete example of how to load a &lt;code&gt;schema.js&lt;/code&gt; file, run the introspection query to get schema information, and save it to a JSON file, check out the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;starter kit&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;schema.js&lt;/code&gt; 파일 을로드하는 방법에 대한 전체 예 를 보려면 내부 검사 쿼리를 실행하여 스키마 정보를 가져 와서 JSON 파일에 저장하고 &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit/blob/master/scripts/updateSchema.js&quot;&gt;스타터 키트를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="cfe4ba012b2b664f6e8a52e5430ca8b838d37291" translate="yes" xml:space="preserve">
          <source>For a simple application that's already a nice improvement.</source>
          <target state="translated">이미 개선 된 간단한 응용 프로그램입니다.</target>
        </trans-unit>
        <trans-unit id="96c534ed5280cce92d6b2b0550da3496f193200e" translate="yes" xml:space="preserve">
          <source>For example, &lt;code&gt;rangeBehaviors&lt;/code&gt; could be written this way:</source>
          <target state="translated">예를 들어 &lt;code&gt;rangeBehaviors&lt;/code&gt; 는 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4999f2258aff41aa7c828698a3d72fe291b86eb2" translate="yes" xml:space="preserve">
          <source>For example, a network layer can be a simple object that conforms to the interface:</source>
          <target state="translated">예를 들어, 네트워크 계층은 인터페이스를 따르는 간단한 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ffcdf17f2ad817cd3da93a900284bc63c193056" translate="yes" xml:space="preserve">
          <source>For example, given the two files:</source>
          <target state="translated">예를 들어, 두 파일이 주어지면 :</target>
        </trans-unit>
        <trans-unit id="12bad1fdad02e0f5d5569bcccc232e7c8357d9c5" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;currentDate&lt;/code&gt; is set in &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;variables&lt;/code&gt;, then $currentDate may be referenced in any fragment included in the &lt;code&gt;QueryRenderer&lt;/code&gt;&lt;code&gt;query&lt;/code&gt;.</source>
          <target state="translated">예를 들어, &lt;code&gt;currentDate&lt;/code&gt; 가 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;variables&lt;/code&gt; 설정된 경우 $ currentDate는 &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;code&gt;query&lt;/code&gt; 포함 된 모든 조각에서 참조 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1178c99ccfd9629da7c347f69a733ccb2674242f" translate="yes" xml:space="preserve">
          <source>For examples of more complex optimistic updates, including adding and removing from a list, see the &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;Relay Modern Todo example app&lt;/a&gt;.</source>
          <target state="translated">목록에서 추가 및 제거를 포함하여보다 복잡한 낙관적 업데이트의 &lt;a href=&quot;https://github.com/relayjs/relay-examples/tree/master/todo&quot;&gt;예&lt;/a&gt; 는 Relay Modern Todo 예제 앱을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a82abfdd90416cbeaffe64d3e50d78377188efce" translate="yes" xml:space="preserve">
          <source>For more complex use-cases, you may wish to perform custom logic to update Relay's in-memory cache when each subscription response is received. To do so, pass an &lt;code&gt;updater&lt;/code&gt; function:</source>
          <target state="translated">보다 복잡한 사용 사례의 경우 각 구독 응답을받을 때 릴레이의 메모리 내 캐시를 업데이트하는 사용자 지정 논리를 수행 할 수 있습니다. 이렇게하려면 &lt;code&gt;updater&lt;/code&gt; 기능을 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ac9b5543bc0f49df0cfb3a851760d47fc555d44" translate="yes" xml:space="preserve">
          <source>For more complicated mutations, &lt;code&gt;optimisticUpdater&lt;/code&gt; and &lt;code&gt;updater&lt;/code&gt; can be the same function.</source>
          <target state="translated">보다 복잡한 돌연변이의 경우 &lt;code&gt;optimisticUpdater&lt;/code&gt; 와 &lt;code&gt;updater&lt;/code&gt; 는 동일한 기능 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1137480158b92303f1522341248742d418f8a480" translate="yes" xml:space="preserve">
          <source>For more details on creating a Network, see the &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer guide&lt;/a&gt;.</source>
          <target state="translated">네트워크 생성에 대한 자세한 내용은 &lt;a href=&quot;network-layer&quot;&gt;NetworkLayer 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf88bc6b3b6a4c187092ec351a5b1077c1d26272" translate="yes" xml:space="preserve">
          <source>For new Relay apps or existing apps that have been fully converted to the Compat API, the Relay Modern runtime can be enabled to activate even more features. In addition to those described above, this includes:</source>
          <target state="translated">Compat API로 완전히 변환 된 새로운 Relay 앱 또는 기존 앱의 경우 Relay Modern 런타임을 활성화하여 더 많은 기능을 활성화 할 수 있습니다. 위에서 설명한 것 외에도 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="18fbf073a81951774f334f655935c2dac6e6377a" translate="yes" xml:space="preserve">
          <source>Force Fetching</source>
          <target state="translated">강제 가져 오기</target>
        </trans-unit>
        <trans-unit id="96bbe9b850cec5fbab27d61fde4b1fa63d06e24d" translate="yes" xml:space="preserve">
          <source>Force Fetching with Data from the Client</source>
          <target state="translated">클라이언트에서 데이터를 사용하여 강제로 가져 오기</target>
        </trans-unit>
        <trans-unit id="bbba84135de6b052c2210e74e0cc5b2a9d359ddb" translate="yes" xml:space="preserve">
          <source>Found</source>
          <target state="translated">Found</target>
        </trans-unit>
        <trans-unit id="365b08de44008517ff803d0c36a644ac290dba44" translate="yes" xml:space="preserve">
          <source>Found offers integration with Relay Modern and Relay Classic via &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt;. Found Relay runs queries for matched routes in parallel, and supports fetching Relay data in parallel with downloading async bundles from code splitting when using Relay Modern.</source>
          <target state="translated">Found는 &lt;a href=&quot;https://github.com/4Catalyzer/found-relay&quot;&gt;Found Relay&lt;/a&gt; 를 통해 Relay Modern 및 Relay Classic과의 통합을 제공합니다 . Found Relay는 일치 된 경로에 대한 쿼리를 병렬로 실행하고 Relay Modern을 사용할 때 코드 분할에서 비동기 번들을 다운로드하는 것과 동시에 Relay 데이터 페치를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="e58abca7c5abd6b02071e05687c03305e61f7adb" translate="yes" xml:space="preserve">
          <source>Fragment Composition</source>
          <target state="translated">조각 구성</target>
        </trans-unit>
        <trans-unit id="4c9b8ee7dc2184d0aab89be194eb15b57be40cef" translate="yes" xml:space="preserve">
          <source>Fragment composition is achieved via ES6 template string interpolation and &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">조각 구성은 ES6 템플릿 문자열 보간 및 &lt;code&gt;getFragment&lt;/code&gt; 를 통해 달성됩니다 .</target>
        </trans-unit>
        <trans-unit id="99eb0c4810611d5c803d75a7ca10220fd2d2cfea" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;User&lt;/code&gt; that is required by &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">조각 구성도 비슷하게 작동합니다. 부모 컨테이너의 조각은 각 자식의 조각을 구성합니다. 이 경우 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 은 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 에 필요한 &lt;code&gt;User&lt;/code&gt; 에 대한 정보를 가져와야합니다 .</target>
        </trans-unit>
        <trans-unit id="f4c1ec38ec0f0411751ca1a7fa59d2e3f75e878a" translate="yes" xml:space="preserve">
          <source>Fragment composition works similarly &amp;mdash; a parent container's fragment composes the fragment for each of its children. In this case, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; needs to fetch information about the &lt;code&gt;Todo&lt;/code&gt;s that are required by &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">조각 구성도 비슷하게 작동합니다. 부모 컨테이너의 조각은 각 자식의 조각을 구성합니다. 이 경우, &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 에 관한 정보를 가져 오기 위해 필요한 &lt;code&gt;Todo&lt;/code&gt; 에 필요한 S &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7eb65ef2204b222cba330bf9518e103ffff4a9" translate="yes" xml:space="preserve">
          <source>Fragment variables</source>
          <target state="translated">조각 변수</target>
        </trans-unit>
        <trans-unit id="6c4797fcf380c1ad929a06c044c27ce633b8a89b" translate="yes" xml:space="preserve">
          <source>FragmentContainer</source>
          <target state="translated">FragmentContainer</target>
        </trans-unit>
        <trans-unit id="e8e4adae3ec551af9e8edf80d04fd880f87f33b9" translate="yes" xml:space="preserve">
          <source>Fragments can be composed in one of two ways:</source>
          <target state="translated">단편은 다음 두 가지 방법 중 하나로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec5c60b97bf9a572f6951db4d37f812151af82e" translate="yes" xml:space="preserve">
          <source>Fragments can be embedded within other fragments or queries. For example, the above fragment could be used to fetch user &lt;code&gt;123&lt;/code&gt;'s profile photo:</source>
          <target state="translated">조각은 다른 조각이나 쿼리 내에 포함될 수 있습니다. 예를 들어, 위의 조각을 사용하여 사용자 &lt;code&gt;123&lt;/code&gt; 님 의 프로필 사진 을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5749ddc88402f36f29ad8ff8b7fc5a5626b02527" translate="yes" xml:space="preserve">
          <source>Fragments may also compose other fragments that are assigned to local variables:</source>
          <target state="translated">조각은 지역 변수에 지정된 다른 조각을 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b32b8542e4c8854b05455c0b114c2bdced713ad" translate="yes" xml:space="preserve">
          <source>Garbage Collection</source>
          <target state="translated">가비지 콜렉션</target>
        </trans-unit>
        <trans-unit id="13e8bde6a75cc8bafc18233096a72b0f6248985e" translate="yes" xml:space="preserve">
          <source>General-purpose tools for building a GraphQL schema using JavaScript</source>
          <target state="translated">JavaScript를 사용하여 GraphQL 스키마를 빌드하기위한 범용 도구</target>
        </trans-unit>
        <trans-unit id="2b67d1eb9affe329c622f0576365f0ee268cf097" translate="yes" xml:space="preserve">
          <source>Gets a fragment reference for use in a parent's query fragment.</source>
          <target state="translated">부모의 쿼리 조각에 사용할 조각 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="efadaa65e42a5128618d6d70d6e5f16a32ea9213" translate="yes" xml:space="preserve">
          <source>Gets a reference to a child container's fragment for inclusion in a parent fragment.</source>
          <target state="translated">부모 프래그먼트에 포함하기 위해 자식 컨테이너의 프래그먼트에 대한 참조를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bab08a8b8e5697e21edf5ba8471a6d2976e052d5" translate="yes" xml:space="preserve">
          <source>Gets a string name used to refer to this request for printing debug output.</source>
          <target state="translated">디버그 출력 인쇄 요청을 참조하는 데 사용되는 문자열 이름을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c66f9fff87afddb71ece32a2129c20b745b3303d" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL mutation.</source>
          <target state="translated">GraphQL 돌연변이의 문자열 표현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f2fb6164e4d92fdf7bb9de20c1488df58f14ec49" translate="yes" xml:space="preserve">
          <source>Gets a string representation of the GraphQL query.</source>
          <target state="translated">GraphQL 쿼리의 문자열 표현을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="abe1bcf50d4649b6cc620e50d25b565688c7d9a1" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this mutation. These identifiers are useful for assigning response payloads to their corresponding mutations when sent in a single GraphQL request.</source>
          <target state="translated">이 돌연변이에 대한 고유 식별자를 가져옵니다. 이 식별자는 단일 GraphQL 요청으로 전송 될 때 응답 페이로드를 해당 돌연변이에 할당하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="96e072f6fa8b2d20b9da83302dbda948494674bf" translate="yes" xml:space="preserve">
          <source>Gets a unique identifier for this query. These identifiers are useful for assigning response payloads to their corresponding queries when sent in a single GraphQL request.</source>
          <target state="translated">이 쿼리의 고유 식별자를 가져옵니다. 이 식별자는 단일 GraphQL 요청으로 전송 될 때 응답 페이로드를 해당 쿼리에 할당하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="5406c8eaf62c01411092558cd572b43c5b89bfa6" translate="yes" xml:space="preserve">
          <source>Gets an optional map from name to File objects.</source>
          <target state="translated">이름에서 File 객체로의 선택적지도를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="118b9b0bfba623072bfed30c4a7c6d4b769ead2a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the mutation. These variables should be serialized and send in the GraphQL request.</source>
          <target state="translated">돌연변이가 사용하는 변수를 가져옵니다. 이러한 변수는 직렬화되어 GraphQL 요청으로 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="5f68839c1e374f581aaccfdd2584db85f5d5531a" translate="yes" xml:space="preserve">
          <source>Gets the variables used by the query. These variables should be serialized and sent in the GraphQL request.</source>
          <target state="translated">쿼리에서 사용하는 변수를 가져옵니다. 이러한 변수는 직렬화되어 GraphQL 요청에서 전송되어야합니다.</target>
        </trans-unit>
        <trans-unit id="010b85ad56b34c34c7c2a3b2436c740e30428ed5" translate="yes" xml:space="preserve">
          <source>Getting Started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="76e7a3a3f9c225fe820ba7e9cff10ea2a73b79a1" translate="yes" xml:space="preserve">
          <source>Getting started</source>
          <target state="translated">시작하기</target>
        </trans-unit>
        <trans-unit id="8b19260759d77673b9a877795f157d4044253944" translate="yes" xml:space="preserve">
          <source>Given a connection, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">연결, 응답 페이로드의 하나 이상의 DataID 및 상위와 연결 사이의 경로가 주어지면 Relay는 연결에서 노드를 제거하지만 연관된 레코드는 상점에 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="e48271c6488ce169319e6996a17416ab8db56489" translate="yes" xml:space="preserve">
          <source>Given a deletedIDFieldName, Relay will remove the node(s) from the connection.</source>
          <target state="translated">deletedIDFieldName이 주어지면 Relay는 연결에서 노드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="47de81551f168ce6aed9196d0adf126b977177b6" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and one or more DataIDs in the response payload, Relay will remove the node(s) from the connection and delete the associated record(s) from the store.</source>
          <target state="translated">응답 페이로드에 상위, 연결 및 하나 이상의 DataID가 제공되면 Relay는 연결에서 노드를 제거하고 상점에서 연관된 레코드를 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="a51dc0bfb8bd3ee42a7194ed76f6218686158817" translate="yes" xml:space="preserve">
          <source>Given a parent, a connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior specified.</source>
          <target state="translated">부모, 연결 및 응답 페이로드 릴레이에서 새로 작성된 에지의 이름이 지정된 범위 동작에 따라 노드를 상점에 추가하고 연결에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="524a22d3cb952e409df0e138141726ed755fe115" translate="yes" xml:space="preserve">
          <source>Given a parent, connectionKeys, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</source>
          <target state="translated">부모, connectionKeys, 응답 페이로드의 하나 이상의 DataID 및 부모와 연결 사이의 경로가 주어지면 Relay는 연결에서 노드를 제거하지만 연관된 레코드는 상점에 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="6c8602a6c8072fdb24f4522613cbc2f7cfcca2ed" translate="yes" xml:space="preserve">
          <source>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</source>
          <target state="translated">부모에게 연결에 대한 정보 및 응답 페이로드 릴레이에서 새로 작성된 에지의 이름이 상점에 노드를 추가하고 connectionInfo에 지정된 범위 동작에 따라 연결에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="1d0fa81ee1013085b7d63ff166408f30527ff41a" translate="yes" xml:space="preserve">
          <source>Given the plain React component and a GraphQL fragment, we can now define a &lt;code&gt;Container&lt;/code&gt; to tell Relay about this component's data requirements. Let's look at the code first and then see what's happening:</source>
          <target state="translated">일반 React 컴포넌트와 GraphQL 프래그먼트가 주어지면 이제이 컴포넌트의 데이터 요구 사항에 대해 Relay에 알리는 &lt;code&gt;Container&lt;/code&gt; 를 정의 할 수 있습니다 . 먼저 코드를보고 무슨 일이 일어나는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="3e96a8e96d952292ce981325cfa1fcff52e52c7e" translate="yes" xml:space="preserve">
          <source>Given these real-world constraints, the approach in GraphQL is for clients to query for things that may change after a mutation. But what exactly do we put in that query? During the development of Relay we explored several ideas &amp;mdash; let's look at them briefly in order to understand why Relay uses the approach that it does:</source>
          <target state="translated">이러한 실제 제약 조건이 주어지면 GraphQL의 접근 방식은 클라이언트가 돌연변이 후 변경 될 수있는 것을 쿼리하는 것입니다. 그러나 우리는 정확히 그 쿼리에 무엇을 넣습니까? Relay를 개발하는 동안 몇 가지 아이디어를 살펴 보았습니다. Relay가 그 방식을 사용하는 이유를 이해하기 위해 몇 가지 아이디어를 간단히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="e4eb1ab683c392399fa825b2dea3b7e5f8189912" translate="yes" xml:space="preserve">
          <source>GraphQL</source>
          <target state="translated">GraphQL</target>
        </trans-unit>
        <trans-unit id="d1104d2d1c77df98433b7b7cb498cfbba782bab4" translate="yes" xml:space="preserve">
          <source>GraphQL Relay Specification</source>
          <target state="translated">GraphQL 릴레이 사양</target>
        </trans-unit>
        <trans-unit id="2462160d86cfb1c5d092d0aa517b3b680333ccb3" translate="yes" xml:space="preserve">
          <source>GraphQL Schema</source>
          <target state="translated">GraphQL 스키마</target>
        </trans-unit>
        <trans-unit id="37f3b6a18cf42e1932e52d60a342d388f522602a" translate="yes" xml:space="preserve">
          <source>GraphQL Subscriptions &amp;amp; Live Queries</source>
          <target state="translated">GraphQL 구독 및 라이브 쿼리</target>
        </trans-unit>
        <trans-unit id="6884fbda0403c3eb6a361b276df83698590e1779" translate="yes" xml:space="preserve">
          <source>GraphQL is designed to support a wide range of data access patterns. In order to understand the structure of an application's data, Relay requires that you follow certain conventions when defining your schema. These are documented in the &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification&lt;/a&gt;.</source>
          <target state="translated">GraphQL은 광범위한 데이터 액세스 패턴을 지원하도록 설계되었습니다. 응용 프로그램 데이터의 구조를 이해하려면 릴레이에서 스키마를 정의 할 때 특정 규칙을 따라야합니다. 이것들은 &lt;a href=&quot;graphql-relay-specification&quot;&gt;GraphQL Relay Specification에&lt;/a&gt; 문서화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="55711b09c6616aea30b39a64a358b0d9490999c3" translate="yes" xml:space="preserve">
          <source>GraphQL presents new ways for clients to fetch data by focusing on the needs of product developers and client applications. It provides a way for developers to specify the precise data needed for a view and enables a client to fetch that data in a single network request. Compared to traditional approaches such as REST, GraphQL helps applications to fetch data more efficiently (compared to resource-oriented REST approaches) and avoid duplication of server logic (which can occur with custom endpoints). Furthermore, GraphQL helps developers to decouple product code and server logic. For example, a product can fetch more or less information without requiring a change to every relevant server endpoint. It's a great way to fetch data.</source>
          <target state="translated">GraphQL은 클라이언트가 제품 개발자 및 클라이언트 응용 프로그램의 요구에 초점을 맞춰 데이터를 가져올 수있는 새로운 방법을 제시합니다. 개발자가 뷰에 필요한 정확한 데이터를 지정할 수있는 방법을 제공하며 클라이언트가 단일 네트워크 요청으로 해당 데이터를 가져올 수 있습니다. REST와 같은 기존의 접근 방식과 비교하여 GraphQL은 응용 프로그램이 데이터를보다 효율적으로 (자원 지향 REST 접근 방식과 비교하여) 가져오고 서버 로직 (사용자 정의 엔드 포인트에서 발생할 수 있음)의 중복을 피할 수 있도록 도와줍니다. 또한 GraphQL을 통해 개발자는 제품 코드와 서버 논리를 분리 할 수 ​​있습니다. 예를 들어, 제품은 모든 관련 서버 엔드 포인트를 변경하지 않고도 더 많거나 적은 정보를 가져올 수 있습니다. 데이터를 가져 오는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cd5d1ec7247a2826222f29ae64e2e192abb30c33" translate="yes" xml:space="preserve">
          <source>GraphQL provides a powerful tool for building efficient, decoupled client applications. Relay builds on this functionality to provide a framework for &lt;strong&gt;declarative data-fetching&lt;/strong&gt;. By separating &lt;em&gt;what&lt;/em&gt; data to fetch from &lt;em&gt;how&lt;/em&gt; it is fetched, Relay helps developers build applications that are robust, transparent, and performant by default. It's a great complement to the component-centric way of thinking championed by React. While each of these technologies &amp;mdash; React, Relay, and GraphQL &amp;mdash; are powerful on their own, the combination is a &lt;strong&gt;UI platform&lt;/strong&gt; that allows us to &lt;em&gt;move fast&lt;/em&gt; and &lt;em&gt;ship high-quality apps at scale&lt;/em&gt;.</source>
          <target state="translated">GraphQL은 효율적인 분리 된 클라이언트 응용 프로그램을 구축 할 수있는 강력한 도구를 제공합니다. Relay는이 기능을 기반으로 &lt;strong&gt;선언적 데이터 페치에&lt;/strong&gt; 대한 프레임 워크를 제공합니다 . 분리함으로써 &lt;em&gt;어떤&lt;/em&gt; 데이터에서 가져 오는 &lt;em&gt;방법&lt;/em&gt; 은 페치, 릴레이는 개발자가 기본적으로 강력한 투명하고 확대됨에있는 응용 프로그램을 구축 할 수 있습니다. React가지지하는 구성 요소 중심 사고 방식을 보완합니다. 이러한 각 기술 (React, Relay 및 GraphQL)은 자체적으로 강력하지만이 조합은 우리가 &lt;em&gt;빠르게 이동&lt;/em&gt; 하고 &lt;em&gt;고품질 앱을 대규모 &lt;/em&gt;&lt;em&gt;로 &lt;/em&gt;&lt;strong&gt;제공&lt;/strong&gt; 할 수 있는 &lt;strong&gt;UI 플랫폼&lt;/strong&gt; 입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1745637b6e7ac2208886e0fe73413f315dc1d52e" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">기능을 강조하기 위해 스타일을 무시하는 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 의 기본 구현은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c7acba2d971e69e956adf8a6ecc2371b0bf96df3" translate="yes" xml:space="preserve">
          <source>Here's a basic implementation of &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; that ignores styling in order to highlight the functionality:</source>
          <target state="translated">다음 은 기능을 강조하기 위해 스타일을 무시하는 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 의 기본 구현입니다 .</target>
        </trans-unit>
        <trans-unit id="dbbbbf44b31cd11738f96ef61375f12e9722988b" translate="yes" xml:space="preserve">
          <source>Here's an example of this mutation in use by a &lt;code&gt;LikeButton&lt;/code&gt; component:</source>
          <target state="translated">&lt;code&gt;LikeButton&lt;/code&gt; 구성 요소 에서 사용중인이 돌연변이의 예는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="385d7c0cfbb336e0125f7ea51dde1cd3078887da" translate="yes" xml:space="preserve">
          <source>Here's an example query that fetches a story's text and its author's name:</source>
          <target state="translated">다음은 스토리의 텍스트와 작성자 이름을 가져 오는 쿼리 예입니다.</target>
        </trans-unit>
        <trans-unit id="0694e515f41dabfcc348f2df0677999ef99af1ea" translate="yes" xml:space="preserve">
          <source>Here's what happens when the container is rendered:</source>
          <target state="translated">컨테이너가 렌더링 될 때 발생하는 상황은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2284d040f5091f510de37a154536196310f9c02d" translate="yes" xml:space="preserve">
          <source>Hint</source>
          <target state="translated">Hint</target>
        </trans-unit>
        <trans-unit id="05531ed7907681dd3a6ac4e94e82348c1af49264" translate="yes" xml:space="preserve">
          <source>Historically, Relay started out internally at Facebook as a routing framework. However, Relay no longer makes any assumptions about routing, and works with a variety of routing options.</source>
          <target state="translated">역사적으로 Relay는 Facebook에서 라우팅 프레임 워크로 내부적으로 시작했습니다. 그러나 Relay는 더 이상 라우팅에 대한 가정을하지 않으며 다양한 라우팅 옵션과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f96c9aa85d59b7983b33495b149e7fee5f7bf418" translate="yes" xml:space="preserve">
          <source>Hm. There were no more ships; guess there were only five in the system for the rebels. It would have been nice to know that we'd reached the end of the connection, without having to do another round trip in order to verify that. The connection model exposes this capability with a type called &lt;code&gt;PageInfo&lt;/code&gt;. So let's issue the two queries that got us ships again, but this time ask for &lt;code&gt;hasNextPage&lt;/code&gt;:</source>
          <target state="translated">흠. 더 이상 배가 없었습니다. 반란군을위한 시스템은 5 명 밖에 없다고 생각합니다. 그것을 확인하기 위해 다른 왕복 여행을하지 않고도 연결이 끝났다는 것을 알게되면 좋을 것입니다. 연결 모델은이 기능을 &lt;code&gt;PageInfo&lt;/code&gt; 라는 유형으로 노출합니다 . 다시 배송을 요청한 두 가지 쿼리를 실행 해 보겠습니다. 이번에는 &lt;code&gt;hasNextPage&lt;/code&gt; 를 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2d977e2354e1f199b20eba8fe4202828b60baf5" translate="yes" xml:space="preserve">
          <source>However components using the Relay Modern API (&lt;code&gt;'react-relay'&lt;/code&gt;) and the Relay Classic API (&lt;code&gt;'react-relay/classic'&lt;/code&gt;) cannot be used with each other.</source>
          <target state="translated">그러나 Relay Modern API ( &lt;code&gt;'react-relay'&lt;/code&gt; )와 Relay Classic API ( &lt;code&gt;'react-relay/classic'&lt;/code&gt; )를 사용하는 구성 요소는 서로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f6bd5564a2d8d3eed39f5285b27795de9e86379" translate="yes" xml:space="preserve">
          <source>However the Relay Compiler also automatically generates flow types, as &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;type comments&lt;/a&gt;. To import the types:</source>
          <target state="translated">그러나 릴레이 컴파일러는 자동으로 흐름 &lt;a href=&quot;https://flow.org/en/docs/types/comments/&quot;&gt;설명&lt;/a&gt; 을 형식 설명 으로 생성 합니다. 유형을 가져 오려면</target>
        </trans-unit>
        <trans-unit id="10b177310affbe7aa4dd35d3f040c504f1597c28" translate="yes" xml:space="preserve">
          <source>However, Relay Modern expects modern JavaScript global types (&lt;code&gt;Map&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt;, &lt;code&gt;Promise&lt;/code&gt;, &lt;code&gt;Object.assign&lt;/code&gt;) to be defined. If you support older browsers and devices which may not yet provide these natively, consider including a global polyfill in your bundled application, such as &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; or &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt;.</source>
          <target state="translated">그러나 Relay Modern은 최신 JavaScript 전역 유형 ( &lt;code&gt;Map&lt;/code&gt; , &lt;code&gt;Set&lt;/code&gt; , &lt;code&gt;Promise&lt;/code&gt; , &lt;code&gt;Object.assign&lt;/code&gt; )이 정의 될 것으로 예상 합니다. 아직 기본적으로 제공하지 않는 구형 브라우저 및 장치를 지원하는 경우 번들 애플리케이션에 &lt;a href=&quot;https://github.com/zloirock/core-js&quot;&gt;core-js&lt;/a&gt; 또는 &lt;a href=&quot;https://babeljs.io/docs/usage/polyfill/&quot;&gt;babel-polyfill&lt;/a&gt; 과 같은 전역 폴리 필을 포함시키는 것을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="44a07f8e11c88d99ebfa0ba8926d9d2bf8daec90" translate="yes" xml:space="preserve">
          <source>However, the fragment could also fetch each of user &lt;code&gt;123&lt;/code&gt;'s friends' profile photos:</source>
          <target state="translated">그러나 프래그먼트는 각 사용자 &lt;code&gt;123&lt;/code&gt; 명의 친구 프로필 사진을 가져올 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd69a4732fe12702d5ff5838852eb29e4a9e2e02" translate="yes" xml:space="preserve">
          <source>Idea</source>
          <target state="translated">Idea</target>
        </trans-unit>
        <trans-unit id="3bd280c6059870c93a4668954d90f25f6c6ff4e2" translate="yes" xml:space="preserve">
          <source>If a &quot;force fetch&quot; occurs and there is insufficient data on the client, the same behavior as &lt;strong&gt;Fetching Data from the Server&lt;/strong&gt; can be expected. However, if a &quot;force fetch&quot; occurs and there &lt;em&gt;is&lt;/em&gt; sufficient data on the client to render, we can expect the following behavior:</source>
          <target state="translated">&quot;강제 반입&quot;이 발생하고 클라이언트에 데이터가 충분하지 않은 &lt;strong&gt;경우 서버에서 데이터 페치&lt;/strong&gt; 와 동일한 동작 이 예상 될 수 있습니다. 는 &quot;힘을 가져가&quot;발생하고있을 경우, &lt;em&gt;이다&lt;/em&gt; 클라이언트에서 충분한 데이터를 렌더링하기 위해, 우리는 다음과 같은 동작을 기대할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="7ed138709fbda62e44a180d5f323c654e6cc766a" translate="yes" xml:space="preserve">
          <source>If a fragment uses variables that are determined at runtime, &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;see below&lt;/a&gt;.</source>
          <target state="translated">프래그먼트가 런타임에 결정된 변수를 사용하는 경우 &lt;a href=&quot;#note-determining-variable-values-at-runtime&quot;&gt;아래를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9c5dc5ba510b8cc7e8340243c616a8461f6de45a" translate="yes" xml:space="preserve">
          <source>If a server request results in a failure to load data, we can expect the following behavior:</source>
          <target state="translated">서버 요청으로 인해 데이터를로드하지 못하면 다음과 같은 동작이 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="500f13b73830f97ef3d0785c40a8e9be8e6865fb" translate="yes" xml:space="preserve">
          <source>If an error occurs that prevents &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; from fetching the data required for rendering &lt;code&gt;Component&lt;/code&gt;, nothing will be rendered by default. Error handling behavior can be configured by supplying a callback to the &lt;code&gt;renderFailure&lt;/code&gt; prop:</source>
          <target state="translated">&lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 가 &lt;code&gt;Component&lt;/code&gt; 렌더링에 필요한 데이터를 가져 오지 못하게하는 오류가 발생하면 기본적으로 아무것도 렌더링 되지 않습니다. &lt;code&gt;renderFailure&lt;/code&gt; prop에 콜백을 제공하여 오류 처리 동작을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4eb5b8214d4c82b80af57f3c1c0471dea0d3c7b" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;Component&lt;/code&gt; or &lt;code&gt;route&lt;/code&gt; ever changes, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will immediately start attempting to fulfill the new data requirements.</source>
          <target state="translated">어느 경우 &lt;code&gt;Component&lt;/code&gt; 또는 &lt;code&gt;route&lt;/code&gt; 적 변화, &lt;strong&gt;Relay.RootContainer는&lt;/strong&gt; 즉시 새로운 데이터 요구 사항을 충족하려고 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e7c4473f87af75e4695d24734fbf44e9808a4049" translate="yes" xml:space="preserve">
          <source>If insufficient data on the client leads Relay to send a server request for more data, we can expect the following behavior:</source>
          <target state="translated">클라이언트의 데이터가 충분하지 않으면 Relay가 더 많은 데이터를 요청하는 서버 요청을 보내면 다음과 같은 동작이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7125117da9f12ab4891151c4ede73bbfc431ad0" translate="yes" xml:space="preserve">
          <source>If no request is in flight pendingVariables is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">대기중인 요청이 없으면 pendingVariables가 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e94ccf62b4c7fbeeff1884ed8210524c0aaf3f8f" translate="yes" xml:space="preserve">
          <source>If not supplied, a unique collision key is derived (meaning that the created mutation will be independent and not collide with any other).</source>
          <target state="translated">제공되지 않은 경우 고유 한 충돌 키가 생성됩니다 (즉, 생성 된 돌연변이는 독립적이며 다른 충돌과 충돌하지 않음).</target>
        </trans-unit>
        <trans-unit id="9f1093c79885887f1a46e11c2dbc9de6bfd2239c" translate="yes" xml:space="preserve">
          <source>If sufficient data is available on the client such that Relay does not need to send a server request, we can expect the following behavior:</source>
          <target state="translated">Relay가 서버 요청을 보낼 필요가없는 충분한 데이터가 클라이언트에서 사용 가능한 경우 다음과 같은 동작을 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1753e3219d9e6a6f6bf62bc19a7f313caa79226f" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available already.</source>
          <target state="translated">제공되고 true로 설정되면 클라이언트의 데이터가 이미 사용 가능한지 여부에 관계없이 항상 서버에 데이터 요청이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="b8cb57719ab0a4774595aab7b466840e3a324de3" translate="yes" xml:space="preserve">
          <source>If supplied and set to true, a request for data will always be made to the server regardless of whether data on the client is available to immediately fulfill the data requirements.</source>
          <target state="translated">제공되고 true로 설정되면 클라이언트의 데이터를 사용하여 데이터 요구 사항을 즉시 충족시킬 수 있는지 여부에 관계없이 항상 서버에 데이터 요청이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="9652265c2b29a20de6e20099f7748481a1d4b122" translate="yes" xml:space="preserve">
          <source>If the Relay part of an application is some widget or single view as part of a larger application, you don't need any routing. You can just render a &lt;code&gt;QueryRenderer&lt;/code&gt; somewhere on the page to fetch and render the data you need there. This option is simple and should be used when sufficient.</source>
          <target state="translated">응용 프로그램의 릴레이 부분이 더 큰 응용 프로그램의 일부인 일부 위젯 또는 단일 뷰인 경우 라우팅이 필요하지 않습니다. 넌 그냥 렌더링 할 수 &lt;code&gt;QueryRenderer&lt;/code&gt; 의 가져올 페이지에 어딘가를하고 데이터를 렌더링 거기가 필요. 이 옵션은 간단하며 충분할 때 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c687f957f6123e9a6702a53723c6fbcdd75a426" translate="yes" xml:space="preserve">
          <source>If the callback returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered (e.g. when transitioning from one &lt;code&gt;queryConfig&lt;/code&gt; to another).</source>
          <target state="translated">콜백이 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 이전에 렌더링 된 뷰 (또는 이전 뷰가없는 경우 아무것도 아님)가 렌더링됩니다 (예 : 하나의 &lt;code&gt;queryConfig&lt;/code&gt; 에서 다른 queryConfig 로 전환 할 때 ).</target>
        </trans-unit>
        <trans-unit id="fa97f983a844f15bf5a18032a6bd22f04fd47eea" translate="yes" xml:space="preserve">
          <source>If the component doesn't actually use &lt;code&gt;setVariables()&lt;/code&gt;, and just uses &lt;code&gt;initialVariables&lt;/code&gt; to share values between JS and GraphQL, there are two alternative approaches:</source>
          <target state="translated">컴포넌트가 실제로 &lt;code&gt;setVariables()&lt;/code&gt; 사용하지 않고 &lt;code&gt;initialVariables&lt;/code&gt; 만 사용 하여 JS와 GraphQL간에 값을 공유하는 경우 두 가지 대안이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f707589cc2da01315091844b3b383efdccb634c" translate="yes" xml:space="preserve">
          <source>If the mutation defines an optimistic payload - a set of data to apply locally while waiting for the server response - Relay applies this change and updates any affected React components (note that optimistic updates do not overwrite known server data in the cache).</source>
          <target state="translated">돌연변이가 서버 응답을 기다리는 동안 로컬에 적용 할 데이터 세트 인 낙관적 페이로드를 정의하는 경우 릴레이는이 변경 사항을 적용하고 영향을받는 React 구성 요소를 업데이트합니다 (낙관적 업데이트는 캐시의 알려진 서버 데이터를 덮어 쓰지 않습니다).</target>
        </trans-unit>
        <trans-unit id="9d815af768aaeea304d01b0f060f4bcc34f6f6e5" translate="yes" xml:space="preserve">
          <source>If the mutation would not 'collide' (overlap) with other pending mutations - as specified by its &lt;code&gt;getCollisionKey&lt;/code&gt; implementation - it is sent to the server. If it would conflict, it is enqueued until conflicting mutations have completed.</source>
          <target state="translated">돌연변이가 &lt;code&gt;getCollisionKey&lt;/code&gt; 구현에 의해 지정된 다른 보류중인 돌연변이와 '충돌'하지 않으면 (중복) 서버로 전송됩니다. 충돌하는 경우 충돌하는 돌연변이가 완료 될 때까지 대기열에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e86698a9dbbdbb49974d25aeca449ae1fbb9e654" translate="yes" xml:space="preserve">
          <source>If the render callback is not supplied, the default behavior is to render the container if data is available, the existing view if one exists, or nothing.</source>
          <target state="translated">렌더 콜백이 제공되지 않은 경우 기본 동작은 데이터를 사용할 수 있거나 기존 뷰가 존재하는 경우 컨테이너가없는 경우 컨테이너를 렌더링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1a73cc6d4c2d46fb79932c374ed9da299d065e97" translate="yes" xml:space="preserve">
          <source>If there is no &lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; suffix, the &lt;code&gt;data&lt;/code&gt; prop name will be used:</source>
          <target state="translated">&lt;code&gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 접미사 가없는 경우 &lt;code&gt;data&lt;/code&gt; 소품 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="62768ad0f3d9c4db4330d79d61d8599e64fd7a9c" translate="yes" xml:space="preserve">
          <source>If we do the same thing with the Empire, we'll find that it returns a different ID, and we can refetch it as well:</source>
          <target state="translated">Empire와 동일한 작업을 수행하면 다른 ID를 반환하고 다시 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="62f00a1501647642fb670b9befaa1fb2d5b19d8f" translate="yes" xml:space="preserve">
          <source>If we provide to a mutation a method that conforms to the signature described above, it will be given the opportunity to modify the fragment builders' variables, based on the previous variables (or the &lt;code&gt;initialVariables&lt;/code&gt; if no previous ones exist), the meta route, and the runtime environment. Whatever variables this method returns will become available to this mutation's fragment builders.</source>
          <target state="translated">위에서 설명한 서명을 따르는 방법을 돌연변이에 제공하면 이전 변수 (또는 이전 변수 가없는 경우 &lt;code&gt;initialVariables&lt;/code&gt; ), 메타 경로, 런타임 환경. 이 메소드가 리턴하는 변수는이 돌연변이의 프래그먼트 빌더가 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="29d042cd073944a1316b1c84fe494fc214ee7caa" translate="yes" xml:space="preserve">
          <source>If we replace &lt;code&gt;2&lt;/code&gt; with a new immutable record, we'll also get a new immutable instance of the cache object. However, records &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; are untouched. Because the data is normalized, we can't tell that &lt;code&gt;story&lt;/code&gt;'s contents have changed just by looking at the &lt;code&gt;story&lt;/code&gt; record alone.</source>
          <target state="translated">&lt;code&gt;2&lt;/code&gt; 를 새로운 불변 ​​레코드로 교체 하면 캐시 객체의 새로운 불변 ​​인스턴스도 얻게됩니다. 그러나 레코드 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;3&lt;/code&gt; 은 변경되지 않습니다. 데이터가 표준화되어 있기 때문에, 우리는 말할 수없는 &lt;code&gt;story&lt;/code&gt; 의 내용이 바로보고 변경 한 &lt;code&gt;story&lt;/code&gt; 만 기록을.</target>
        </trans-unit>
        <trans-unit id="3442e671845ad2d6f63d621dcbdd2a0032b009d1" translate="yes" xml:space="preserve">
          <source>If we wanted to create an instance of this route for arbitrary users, we can subclass the &lt;code&gt;Relay.Route&lt;/code&gt; abstract class. &lt;code&gt;Relay.Route&lt;/code&gt; makes it easy to define a set of queries and required parameters to be re-used multiple times:</source>
          <target state="translated">임의의 사용자를 위해이 경로의 인스턴스를 만들고자한다면 &lt;code&gt;Relay.Route&lt;/code&gt; 추상 클래스를 서브 클래 싱 할 수 있습니다 . &lt;code&gt;Relay.Route&lt;/code&gt; 를 사용하면 여러 번 재사용 할 쿼리 및 필수 매개 변수 세트를 쉽게 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b62113e72e08231a01f5d4a07e448ee27964d21" translate="yes" xml:space="preserve">
          <source>If you find you need to do something unique (like generate types that conform to an older version of flow, or to parse non-javascript source files), you can build your own version of the Compiler by swapping in your own &lt;code&gt;FileWriter&lt;/code&gt; and &lt;code&gt;ASTCache&lt;/code&gt;, or by adding on an additional &lt;code&gt;IRTransform&lt;/code&gt;. Note, the internal APIs of the &lt;code&gt;RelayCompiler&lt;/code&gt; are under constant iteration, so rolling your own version may lead to incompatibilities with future releases.</source>
          <target state="translated">이전 버전의 흐름을 따르는 유형을 생성하거나 자바 스크립트가 아닌 소스 파일을 구문 분석하는 등 고유 한 작업을 수행해야하는 경우 고유 한 &lt;code&gt;FileWriter&lt;/code&gt; 및 &lt;code&gt;ASTCache&lt;/code&gt; 에서 교체하여 고유 한 버전의 컴파일러를 빌드 할 수 있습니다 . 또는 추가 &lt;code&gt;IRTransform&lt;/code&gt; 을 추가 하여 . &lt;code&gt;RelayCompiler&lt;/code&gt; 의 내부 API는 일정하게 반복되므로 자체 버전을 롤링하면 향후 릴리스와 호환되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7224441b6f15886cd449f3742b23181788ee9b99" translate="yes" xml:space="preserve">
          <source>If you wish to provide your own &lt;code&gt;handlerProvider&lt;/code&gt;, you can do so:</source>
          <target state="translated">자체 &lt;code&gt;handlerProvider&lt;/code&gt; 를 제공하려는 경우 다음 을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a21b30f5b3a1b121343f35b747fe542d51dbf3" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;createRefetchContainer&lt;/code&gt; then your &lt;code&gt;refetch&lt;/code&gt; method may also update these variables to render with new values.</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;refetch&lt;/code&gt; 메소드는 이러한 변수를 업데이트하여 새 값으로 렌더링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ccc0940cec44b44c366f2d98c395662eb2f306c" translate="yes" xml:space="preserve">
          <source>If you're using a different GraphQL server implementation, we recommend adapting the above example to load the schema from your GraphQL server (e.g. via an HTTP request) and then save the result as JSON.</source>
          <target state="translated">다른 GraphQL 서버 구현을 사용하는 경우, 위의 예를 사용하여 GraphQL 서버에서 스키마를로드 한 다음 (예 : HTTP 요청을 통해) 결과를 JSON으로 저장하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2e76567f0db1f25cdaed090474feff64180bb110" translate="yes" xml:space="preserve">
          <source>Imagine we have a simple application that fetches a list of stories, and some details about each one. Here's how that might look in resource-oriented REST:</source>
          <target state="translated">스토리 목록과 각 스토리에 대한 세부 사항을 가져 오는 간단한 애플리케이션이 있다고 가정하십시오. 다음은 리소스 지향 REST에서 어떻게 보일 수 있는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="448e3d99f5bde0fa9efac34be83b204ae98c345a" translate="yes" xml:space="preserve">
          <source>Implement this method in cases where the mutator configuration needed to handle the optimistic response needs to be different than the one that handles the server response.</source>
          <target state="translated">낙관적 응답을 처리하는 데 필요한 mutator 구성이 서버 응답을 처리하는 것과 달라야하는 경우이 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="62181f13d4fff5bed161f01ef77d8db655301bec" translate="yes" xml:space="preserve">
          <source>Implement this method to craft an optimistic response having the same shape as the server response payload. This optimistic response will be used to preemptively update the client cache before the server returns, giving the impression that the mutation completed instantaneously.</source>
          <target state="translated">이 방법을 구현하여 서버 응답 페이로드와 동일한 모양의 낙관적 응답을 작성하십시오. 이 낙관적 응답은 서버가 리턴하기 전에 클라이언트 캐시를 사전에 업데이트하여 돌연변이가 즉시 완료되었다는 인상을주기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="24bc32f306fba32d2cbf91f2cd1999f36a16435a" translate="yes" xml:space="preserve">
          <source>Implement this method to return a collision key. Relay will send any mutations having the same collision key to the server serially and in-order.</source>
          <target state="translated">충돌 키를 반환하려면이 방법을 구현하십시오. 릴레이는 충돌 키가 동일한 돌연변이를 서버에 순차적으로 순차적으로 보냅니다.</target>
        </trans-unit>
        <trans-unit id="1e3fee95e387e2e4175f4c37de616bb736c7491c" translate="yes" xml:space="preserve">
          <source>Implement this method to return a map of &lt;code&gt;File&lt;/code&gt; objects to upload as part of a mutation.</source>
          <target state="translated">이 메소드를 구현 하여 돌연변이의 일부로 업로드 할 &lt;code&gt;File&lt;/code&gt; 객체 의 맵을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="48d0a56a8bcb298a554f5516aac54d6f77d81acd" translate="yes" xml:space="preserve">
          <source>Implement this method to return true when the supplied options are supported by this network layer. This is used to declare which features the network layer supports.</source>
          <target state="translated">제공된 옵션이이 네트워크 계층에서 지원 될 때 true를 리턴하도록이 메소드를 구현하십시오. 네트워크 계층이 지원하는 기능을 선언하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b153e451079dd8470ac1e1681b4c8e4668b52b86" translate="yes" xml:space="preserve">
          <source>Implement this method to send mutations to the server. When the server response is obtained, this method must either call &lt;code&gt;mutationRequest.resolve&lt;/code&gt; with the response data, or &lt;code&gt;mutationRequest.reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">서버에 돌연변이를 보내려면이 방법을 구현하십시오. 서버 응답이 확보되면이 메소드는 응답 데이터로 &lt;code&gt;mutationRequest.resolve&lt;/code&gt; 를 호출 하거나 &lt;code&gt;Error&lt;/code&gt; 오브젝트로 &lt;code&gt;mutationRequest.reject&lt;/code&gt; 를 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1d31efc29644775c604543b99db2b73a14120012" translate="yes" xml:space="preserve">
          <source>Implement this method to send queries to the server. For each query request, when the server response is received, this method must either call &lt;code&gt;resolve&lt;/code&gt; with the response data, or &lt;code&gt;reject&lt;/code&gt; with an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">서버에 쿼리를 보내려면이 방법을 구현하십시오. 각 쿼리 요청에 대해 서버 응답이 수신되면이 메소드는 응답 데이터로 &lt;code&gt;resolve&lt;/code&gt; 를 호출 하거나 &lt;code&gt;Error&lt;/code&gt; 오브젝트로 &lt;code&gt;reject&lt;/code&gt; 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1774e52d0e556763970083c582a2823556fad1d9" translate="yes" xml:space="preserve">
          <source>Implement this required method to design a &amp;lsquo;fat query&amp;rsquo; &amp;ndash; one that represents every field in your data model that could change as a result of this mutation.</source>
          <target state="translated">이 변이의 결과로 변경 될 수있는 데이터 모델의 모든 필드를 나타내는 '지방 쿼리'를 설계하기 위해이 필수 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="55c82c1ede81ef7c75eb0f5ad805b7c8131bec8a" translate="yes" xml:space="preserve">
          <source>Implement this required method to give Relay instructions on how to use the response payload from each mutation to update the client-side store.</source>
          <target state="translated">클라이언트 측 저장소를 업데이트하기 위해 각 돌연변이의 응답 페이로드를 사용하는 방법에 대한 릴레이 지침을 제공하기 위해이 필수 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="17378e1f66fb4d758998ffc792b8f969174e1a87" translate="yes" xml:space="preserve">
          <source>Implement this required method to prepare variables to be used as input to the mutation.</source>
          <target state="translated">돌연변이에 대한 입력으로 사용할 변수를 준비하려면이 필수 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="e0d5783849893b65928056a3e01f878a4ebb371a" translate="yes" xml:space="preserve">
          <source>Implement this required method to return a GraphQL mutation operation that represents the mutation to be performed.</source>
          <target state="translated">수행 할 돌연변이를 나타내는 GraphQL 돌연변이 연산을 반환하기 위해이 필요한 방법을 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="d8c789b0ff99a369ebb08eda75d64a2002a8918e" translate="yes" xml:space="preserve">
          <source>Importing generated definitions</source>
          <target state="translated">생성 된 정의 가져 오기</target>
        </trans-unit>
        <trans-unit id="a8c0b4ec0c84b678651530ba2d81f9beb98a2561" translate="yes" xml:space="preserve">
          <source>In GraphQL, &lt;strong&gt;queries&lt;/strong&gt; declare fields that exist on the root query type. For example, the following query might fetch the name of the user with an &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">GraphQL에서 &lt;strong&gt;쿼리&lt;/strong&gt; 는 루트 쿼리 유형에 존재하는 필드를 선언합니다. 예를 들어 다음 쿼리는 &lt;code&gt;id&lt;/code&gt; 가 &lt;code&gt;123&lt;/code&gt; 인 사용자 이름을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42cc08262fb0bb543ca0770499256c848ef63cb2" translate="yes" xml:space="preserve">
          <source>In React Native, we can schedule Relay processing so as to avoid interrupting touch gestures as follows:</source>
          <target state="translated">React Native에서는 다음과 같이 터치 제스처가 중단되지 않도록 릴레이 처리를 예약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5187bfb626e29a7807af4b6499d8505f13e32b2" translate="yes" xml:space="preserve">
          <source>In React, rendering a view requires two inputs: the &lt;em&gt;component&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; DOM (UI) node to render into. Rendering Relay containers is similar: we need a &lt;em&gt;container&lt;/em&gt; to render, and a &lt;em&gt;root&lt;/em&gt; in the graph from which to start our query. We also must ensure that the queries for the container are executed and may want to show a loading indicator while data is being fetched. Similar to &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt;, Relay provides &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; for this purpose. The container is the item to render, and the queryConfig provides queries that specify &lt;em&gt;which&lt;/em&gt; item to fetch. Here's how we might render &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">React에서 뷰 를 렌더링하려면 렌더링 할 &lt;em&gt;컴포넌트&lt;/em&gt; 와 렌더링 할 &lt;em&gt;루트&lt;/em&gt; DOM (UI) 노드 라는 두 가지 입력이 필요합니다 . 렌더링 릴레이 컨테이너는 비슷합니다. 렌더링 할 &lt;em&gt;컨테이너&lt;/em&gt; 와 쿼리를 시작할 그래프 의 &lt;em&gt;루트&lt;/em&gt; 가 필요 합니다. 또한 컨테이너에 대한 쿼리가 실행되고 데이터를 가져 오는 동안로드 표시기를 표시 할 수 있어야합니다. &lt;code&gt;ReactDOM.render(component, domNode)&lt;/code&gt; 와 유사하게 Relay는이를 위해 &lt;code&gt;&amp;lt;Relay.Renderer Container={...} queryConfig={...}&amp;gt;&lt;/code&gt; 를 제공합니다. 컨테이너는 렌더링 할 항목이며 queryConfig는 가져올 항목을 지정 &lt;em&gt;하는&lt;/em&gt; 쿼리를 제공합니다 . 렌더링 방법은 다음과 같습니다. &lt;code&gt;&amp;lt;StoryContainer&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4f9d43e8de662b43a98bf53a133be5a295724798" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;user&lt;/code&gt; prop.</source>
          <target state="translated">릴레이에서 데이터 종속성은 &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL을&lt;/a&gt; 사용하여 설명됩니다 . 들면 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 다음, 종속성이 표현 될 수있다. 이는 구성 요소가 &lt;code&gt;user&lt;/code&gt; 소품에 기대 한 형태와 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1084307d05023abf80689279ae0f77b70f810919" translate="yes" xml:space="preserve">
          <source>In Relay, data dependencies are described using &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL&lt;/a&gt;. For &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt;, the dependency can be expressed as follows. Note that this exactly matches the shape that the component expected for the &lt;code&gt;item&lt;/code&gt; prop.</source>
          <target state="translated">릴레이에서 데이터 종속성은 &lt;a href=&quot;https://github.com/facebook/graphql&quot;&gt;GraphQL을&lt;/a&gt; 사용하여 설명됩니다 . 들면 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 다음, 종속성이 표현 될 수있다. 이는 구성 요소가 &lt;code&gt;item&lt;/code&gt; 소품에 대해 예상 한 모양과 정확히 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="8218e7619ef161652f44088010026d35f36055e0" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;QueryRenderer&lt;/strong&gt; so check out that section for more details.</source>
          <target state="translated">릴레이에서 쿼리의 루트는 &lt;strong&gt;QueryRenderer에&lt;/strong&gt; 의해 정의 되므로 자세한 내용은 해당 섹션을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="30d65c55146011871e1262a4566a24588803dc0d" translate="yes" xml:space="preserve">
          <source>In Relay, the root of a query is defined by a &lt;strong&gt;Route&lt;/strong&gt;. Continue to learn about Relay routes.</source>
          <target state="translated">릴레이에서 쿼리의 루트는 &lt;strong&gt;Route에&lt;/strong&gt; 의해 정의됩니다 . 릴레이 경로에 대해 계속 배우십시오.</target>
        </trans-unit>
        <trans-unit id="c21389450ed39ca7f4877ce1712aa3326324e6a9" translate="yes" xml:space="preserve">
          <source>In a resource-oriented REST system, we can maintain a &lt;strong&gt;response cache&lt;/strong&gt; based on URIs:</source>
          <target state="translated">자원 지향 REST 시스템 에서 URI를 기반으로 &lt;strong&gt;응답 캐시&lt;/strong&gt; 를 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ddc4813b133487bd46b76268444d4db66fd4598c" translate="yes" xml:space="preserve">
          <source>In a simple mutation, you only need &lt;code&gt;mutation&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;:</source>
          <target state="translated">간단한 돌연변이에서는 &lt;code&gt;mutation&lt;/code&gt; 와 &lt;code&gt;variables&lt;/code&gt; 만 필요 합니다 .</target>
        </trans-unit>
        <trans-unit id="753db9b3fed6b02e90a81f5ecfd3b20ecf1201c5" translate="yes" xml:space="preserve">
          <source>In a simple subscription, you only need &lt;code&gt;subscription&lt;/code&gt; and &lt;code&gt;variables&lt;/code&gt;. This is appropriate when you are only changing the properties of existing records that can be identified by their &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">간단한 구독에서는 &lt;code&gt;subscription&lt;/code&gt; 과 &lt;code&gt;variables&lt;/code&gt; 만 필요 합니다 . &lt;code&gt;id&lt;/code&gt; 로 식별 할 수있는 기존 레코드의 특성 만 변경하는 경우에 적합합니다 .</target>
        </trans-unit>
        <trans-unit id="2d35beb84697160944c091bfc4ea7475ddba8bba" translate="yes" xml:space="preserve">
          <source>In addition to the bin script, the &lt;code&gt;relay-compiler&lt;/code&gt; package also &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;exports library code&lt;/a&gt; which you may use to create more complex configurations for the compiler, or to extend the compiler with your own custom output.</source>
          <target state="translated">bin 스크립트 외에도 &lt;code&gt;relay-compiler&lt;/code&gt; 패키지는 컴파일러에 대한보다 복잡한 구성을 작성하거나 고유 한 사용자 정의 출력으로 컴파일러를 확장하는 데 사용할 수있는 &lt;a href=&quot;https://github.com/facebook/relay/blob/master/packages/relay-compiler/RelayCompilerPublic.js&quot;&gt;라이브러리 코드&lt;/a&gt; 를 내 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="1ee7cb663ba30043049419a3987f32bf98b8e3b6" translate="yes" xml:space="preserve">
          <source>In order to incrementally convert an existing codebase, we will need to use the Relay Modern API while continuing to use the Relay Classic runtime until all components are converted.</source>
          <target state="translated">기존 코드베이스를 증분 변환하려면 모든 구성 요소가 변환 될 때까지 Relay Classic 런타임을 계속 사용하면서 Relay Modern API를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b06055f46a51395cce09c8715fc83f412863f99f" translate="yes" xml:space="preserve">
          <source>In order to know how to access your GraphQL server, Relay Modern requires developers to provide an object implementing the &lt;code&gt;NetworkLayer&lt;/code&gt; interface when creating an instance of a &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. The environment uses this network layer to execute queries, mutations, and (if your server supports them) subscriptions. This allows developers to use whatever transport (HTTP, WebSockets, etc) and authentication is most appropriate for their application, decoupling the environment from the particulars of each application's network configuration.</source>
          <target state="translated">GraphQL 서버에 액세스하는 방법을 알기 위해 Relay Modern은 개발자가 &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; 인스턴스를 생성 할 때 &lt;code&gt;NetworkLayer&lt;/code&gt; 인터페이스를 구현하는 객체를 제공해야합니다 . 환경은이 네트워크 계층을 사용하여 쿼리, 돌연변이 및 (서버에서 지원하는 경우) 구독을 실행합니다. 이를 통해 개발자는 모든 전송 (HTTP, WebSockets 등)을 사용할 수 있으며 인증은 해당 응용 프로그램에 가장 적합한 인증을 사용하여 각 응용 프로그램의 네트워크 구성의 특정 환경과 환경을 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3a7aba64216b1cd4d2d2e3ad530a1f3188fad50d" translate="yes" xml:space="preserve">
          <source>In order to resolve a fragment into an array of objects you have to use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive.</source>
          <target state="translated">단편을 객체 배열로 해석하려면 &lt;code&gt;@relay(plural: true)&lt;/code&gt; 지시문 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e6f38813eb9d2dd5b73b9500e984665cfcbc9419" translate="yes" xml:space="preserve">
          <source>In our experience, the overwhelming majority of products want one specific behavior: fetch &lt;em&gt;all&lt;/em&gt; the data for a view hierarchy while displaying a loading indicator, and then render the &lt;em&gt;entire&lt;/em&gt; view once the data is ready.</source>
          <target state="translated">경험상 압도적 인 대다수의 제품은 하나의 특정 동작을 원합니다 .로드 표시기를 표시하면서 뷰 계층 구조에 대한 &lt;em&gt;모든&lt;/em&gt; 데이터를 가져온 다음 데이터가 준비되면 &lt;em&gt;전체&lt;/em&gt; 뷰 를 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="6a8da0b71c4c64aea6ae6834a91b9401918c3e7e" translate="yes" xml:space="preserve">
          <source>In that last example, think of &lt;code&gt;$format&lt;/code&gt; and &lt;code&gt;variables.format&lt;/code&gt; as the same value.</source>
          <target state="translated">마지막 예제에서 &lt;code&gt;$format&lt;/code&gt; 과 &lt;code&gt;variables.format&lt;/code&gt; 을 같은 값 으로 생각 하십시오.</target>
        </trans-unit>
        <trans-unit id="3888fb491d2876bafea276807002a772ce2740fc" translate="yes" xml:space="preserve">
          <source>In the diagram above:</source>
          <target state="translated">위 다이어그램에서 :</target>
        </trans-unit>
        <trans-unit id="fafabc5dfb7d6fbb341fd52614abab0575f4bf79" translate="yes" xml:space="preserve">
          <source>In the example below, the &lt;code&gt;user&lt;/code&gt; prop will include the data for &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;name&lt;/code&gt; fields wherever &lt;code&gt;...Component_internUser&lt;/code&gt; is included, instead of Relay's normal behavior to mask those fields.</source>
          <target state="translated">아래 예에서 &lt;code&gt;user&lt;/code&gt; 소품은 릴레이의 일반적인 동작 대신 해당 필드를 숨기는 대신 &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;name&lt;/code&gt; 필드에 대한 데이터를 포함합니다. &lt;code&gt;...Component_internUser&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b3b357ad1aa217f6b814380c122b67ca81691203" translate="yes" xml:space="preserve">
          <source>In the future, advanced capabilities in Relay may be dependent on the network layer being able to support certain features.</source>
          <target state="translated">앞으로 Relay의 고급 기능은 특정 기능을 지원할 수있는 네트워크 계층에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9e71215ab64e7c01402f6a78301e1bc8b38923" translate="yes" xml:space="preserve">
          <source>In this article we'll explore what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems. Along the way we'll look at the design decisions behind Relay and see that it's not just a GraphQL client but also a framework for &lt;em&gt;declarative data-fetching&lt;/em&gt;. Let's start at the beginning and fetch some data!</source>
          <target state="translated">이 기사에서는 GraphQL 클라이언트 프레임 워크를 구축하는 것이 무엇을 의미하는지와 더 전통적인 REST 시스템의 클라이언트와 비교하는 방법을 살펴 보겠습니다. 그 과정에서 Relay의 디자인 결정을 살펴보고 GraphQL 클라이언트뿐만 아니라 &lt;em&gt;선언적인 데이터 페칭을&lt;/em&gt; 위한 프레임 워크임을 알 수 있습니다. 처음부터 시작해서 데이터를 가져 오자!</target>
        </trans-unit>
        <trans-unit id="88a02e183add9d1c24413aa47baf530897708969" translate="yes" xml:space="preserve">
          <source>In this example the Route should be initialized with a &lt;code&gt;userID&lt;/code&gt; which gets passed on to the query. That &lt;code&gt;userID&lt;/code&gt; variable will automatically be passed down to the top-level container and can be used there if needed. Further the top-level RelayContainer is expected to have a &lt;code&gt;user&lt;/code&gt; fragment with the fields to be queried.</source>
          <target state="translated">이 예에서 Route는 쿼리로 전달 되는 &lt;code&gt;userID&lt;/code&gt; 로 초기화되어야 합니다. 해당 &lt;code&gt;userID&lt;/code&gt; 변수는 자동으로 최상위 컨테이너로 전달되며 필요한 경우 사용할 수 있습니다. 또한 최상위 RelayContainer에는 쿼리 할 필드 가있는 &lt;code&gt;user&lt;/code&gt; 조각 이있을 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="8e65c0999502b8d880342481e43745e86b87bd15" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; will be fetched for the intial render.</source>
          <target state="translated">이 예제에서는 초기 렌더링을 위해 &lt;code&gt;profilePicture(size: 50)&lt;/code&gt; 를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b029685528e8da2f8ce2cf427c32ff8fbbf0ee00" translate="yes" xml:space="preserve">
          <source>In this example, create an inspector object based on the same source as passed into your &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt;. Later you can use this inspector object to inspect records. Inspector is only available in the development build.</source>
          <target state="translated">이 예제에서는 &lt;a href=&quot;relay-environment&quot;&gt;Relay Environment&lt;/a&gt; 로 전달 된 것과 동일한 소스를 기반으로 인스펙터 객체를 만듭니다 . 나중에이 관리자 개체를 사용하여 레코드를 검사 할 수 있습니다. 인스펙터는 개발 빌드에서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1907e8aedfd3075f12c9bb08511b6424b05151" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;width&lt;/code&gt; of the rendered image will always correspond to the &lt;code&gt;$size&lt;/code&gt; variable used to fetch the current version of &lt;code&gt;profilePicture.uri&lt;/code&gt;.</source>
          <target state="translated">이 예제 에서 렌더링 된 이미지 의 &lt;code&gt;width&lt;/code&gt; 는 항상 &lt;code&gt;profilePicture.uri&lt;/code&gt; 의 현재 버전을 가져 오는 데 사용되는 &lt;code&gt;$size&lt;/code&gt; 변수에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="86e6e74d266fdaa434ba59fe220a17114ef82453" translate="yes" xml:space="preserve">
          <source>In this example, the fields associated with the &lt;code&gt;ship&lt;/code&gt; fragment will be made available on &lt;code&gt;this.props.ship&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;ship&lt;/code&gt; 프래그먼트 와 관련된 필드 는 &lt;code&gt;this.props.ship&lt;/code&gt; 에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="85172d5db32fabb64291c47b382ebcc9097ed293" translate="yes" xml:space="preserve">
          <source>In this example, whenever &lt;code&gt;Parent&lt;/code&gt; is fetched, &lt;code&gt;Child&lt;/code&gt;'s fragment will also be fetched. When rendering, &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; will only have access to the &lt;code&gt;props.foo.id&lt;/code&gt; field; data from the child fragment will be &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;masked&lt;/em&gt;&lt;/a&gt;. By default, &lt;code&gt;childFragment&lt;/code&gt; will use its corresponding initial variables. Relay will fetch &lt;code&gt;photo(size: 64)&lt;/code&gt;. When &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; is rendered it will also make the initial variables available as &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;Parent&lt;/code&gt; 가 페치 될 때마다 &lt;code&gt;Child&lt;/code&gt; 프래그먼트도 페치됩니다. 렌더링 할 때 &lt;code&gt;&amp;lt;Parent&amp;gt;&lt;/code&gt; 는 &lt;code&gt;props.foo.id&lt;/code&gt; 필드 에만 액세스 할 수 있습니다 . 하위 프래그먼트의 데이터가 &lt;a href=&quot;http://facebook.github.io/relay/docs/thinking-in-relay.html#data-masking&quot;&gt;&lt;em&gt;마스킹&lt;/em&gt;&lt;/a&gt; 됩니다. 기본적으로 &lt;code&gt;childFragment&lt;/code&gt; 는 해당 초기 변수를 사용합니다. 릴레이는 &lt;code&gt;photo(size: 64)&lt;/code&gt; 을 가져옵니다 . &lt;code&gt;&amp;lt;Child&amp;gt;&lt;/code&gt; 가 렌더링 되면 &lt;code&gt;props.relay.variables = {size: 64}&lt;/code&gt; 로 초기 변수를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="79f26e8bd2ce0d98aed5c314fad80d4d64f729d8" translate="yes" xml:space="preserve">
          <source>In this example, whenever a picture with a new size is being loaded a spinner is displayed instead of the picture.</source>
          <target state="translated">이 예에서는 새로운 크기의 그림이로드 될 때마다 그림 대신 스피너가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="11c9642bf0d68f60f8223631d67d9ed8e587f204" translate="yes" xml:space="preserve">
          <source>In this particular example, the only field that the &lt;code&gt;LikeButton&lt;/code&gt; cares about is &lt;code&gt;viewerDoesLike&lt;/code&gt;. That field will form part of the tracked query that Relay will intersect with the fat query of &lt;code&gt;LikeStoryMutation&lt;/code&gt; to determine what fields to request as part of the server's response payload for the mutation. Another component elsewhere in the application might be interested in the likers count, or the like sentence. Since those fields will automatically be added to Relay's tracked query, the &lt;code&gt;LikeButton&lt;/code&gt; need not worry about requesting them explicitly.</source>
          <target state="translated">이 특정 예제에서 &lt;code&gt;LikeButton&lt;/code&gt; 이 관심 을 갖는 유일한 필드 는 &lt;code&gt;viewerDoesLike&lt;/code&gt; 입니다. 이 필드는 릴레이가 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 의 팻 쿼리와 교차 하여 돌연변이에 대한 서버의 응답 페이로드의 일부로 요청할 필드를 결정 하는 추적 쿼리의 일부를 형성 합니다. 애플리케이션의 다른 곳에서 다른 구성 요소는 유사 자 수 또는 이와 유사한 문장에 관심이있을 수 있습니다. 이러한 필드는 Relay의 추적 쿼리에 자동으로 추가되므로 &lt;code&gt;LikeButton&lt;/code&gt; 은 명시 적으로 요청하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="877c9e959c13a50bd6cd2c0684ab7d5def3e1397" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will build a game using GraphQL mutations. The goal of the game is to find a hidden treasure in a grid of 9 squares. We will give players three tries to find the treasure. This should give us an end-to-end look at Relay &amp;ndash; from the GraphQL schema on the server, to the React application on the client.</source>
          <target state="translated">이 튜토리얼에서는 GraphQL 돌연변이를 사용하여 게임을 빌드합니다. 이 게임의 목표는 9 개의 사각형 격자에서 숨겨진 보물을 찾는 것입니다. 우리는 플레이어에게 보물을 찾으려고 시도합니다. 이를 통해 서버의 GraphQL 스키마에서 클라이언트의 React 응용 프로그램에 이르기까지 Relay에 대한 전반적인 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1f61deb9bd75956e5146dd965f4efa1acf76ef5" translate="yes" xml:space="preserve">
          <source>Incrementally modernize your Relay Classic app in these steps:</source>
          <target state="translated">다음 단계에 따라 Relay Classic 앱을 점차 현대화하십시오.</target>
        </trans-unit>
        <trans-unit id="0e8c879968a7b304e9792c15d95365ae89d2aa45" translate="yes" xml:space="preserve">
          <source>Injectable Custom Field Handlers</source>
          <target state="translated">주사 가능한 커스텀 필드 핸들러</target>
        </trans-unit>
        <trans-unit id="e69c600fe29f0ed75880fd3b696888c254caf34f" translate="yes" xml:space="preserve">
          <source>Inline Fragments</source>
          <target state="translated">인라인 조각</target>
        </trans-unit>
        <trans-unit id="1889c37693175c0225de5e6837f2ed3f9f529fe3" translate="yes" xml:space="preserve">
          <source>Inline the value in the GraphQL query, potentially annotating with a GraphQL comment (i.e. &lt;code&gt;# PAGE_SIZE&lt;/code&gt;).</source>
          <target state="translated">GraphQL 쿼리에 값을 인라인하여 GraphQL 주석으로 주석을 달 수 있습니다 (예 : &lt;code&gt;# PAGE_SIZE&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0de09ec0beb82594d04ee09d8aeb812d06a3d58b" translate="yes" xml:space="preserve">
          <source>Install the latest version of Relay from the &lt;a href=&quot;relay-modern&quot;&gt;getting started guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;relay-modern&quot;&gt;시작 안내서&lt;/a&gt; 에서 최신 버전의 Relay를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="6603c8ba1e08fe9cd6b6dad35da64e9d939e1d23" translate="yes" xml:space="preserve">
          <source>Integration options are available for open-source routing libraries that can instead fetch data for nested routes in parallel. In many of these cases, using a batching network layer can bring additional benefits in avoiding sending multiple HTTP requests.</source>
          <target state="translated">중첩 된 경로에 대한 데이터를 병렬로 가져올 수있는 오픈 소스 라우팅 라이브러리에 통합 옵션을 사용할 수 있습니다. 이러한 대부분의 경우 배치 네트워크 계층을 사용하면 여러 HTTP 요청을 보내지 않아도되는 추가적인 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba3a36612e2c9eeb3ee746032e0c52004c3b84f8" translate="yes" xml:space="preserve">
          <source>Integration with Relay Classic for React Router v2 or v3 is available via &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt;&lt;code&gt;react-router-relay&lt;/code&gt;&lt;/a&gt;, which will aggregate the queries for matched routes, and request data for all routes in parallel.</source>
          <target state="translated">React Router v2 또는 v3 용 Relay Classic과의 통합은 &lt;a href=&quot;https://github.com/relay-tools/react-router-relay&quot;&gt; &lt;code&gt;react-router-relay&lt;/code&gt; &lt;/a&gt; 를 통해 제공되며 , 일치하는 경로에 대한 쿼리를 집계하고 모든 경로에 대한 데이터를 병렬로 요청합니다.</target>
        </trans-unit>
        <trans-unit id="ca6f57623e58b4619d24d2a4a11fc39e22aace3a" translate="yes" xml:space="preserve">
          <source>Introduction to Relay Modern</source>
          <target state="translated">현대 릴레이 소개</target>
        </trans-unit>
        <trans-unit id="cdaf67797686a7d4a210975b6064cb3ac3259374" translate="yes" xml:space="preserve">
          <source>It is also assumed that the reader is already familiar with &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars&lt;/a&gt;; if not, the 1977 version of Star Wars is a good place to start, though the 1997 Special Edition will serve for the purposes of this document.</source>
          <target state="translated">또한 독자는 이미 &lt;a href=&quot;https://en.wikipedia.org/wiki/Star_Wars&quot;&gt;Star Wars에&lt;/a&gt; 익숙하다고 가정합니다 . 그렇지 않다면 1977 버전의 Star Wars가 시작하기에 좋은 곳이지만 1997 Special Edition은이 문서의 목적을 위해 사용될 것입니다.</target>
        </trans-unit>
        <trans-unit id="df2797c242fbac686a5646e3f8d0990c4c69631c" translate="yes" xml:space="preserve">
          <source>It is assumed that the reader is already familiar with GraphQL; if not, the README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; is a good place to start.</source>
          <target state="translated">독자는 이미 GraphQL에 익숙하다고 가정합니다. 그렇지 않다면 README for &lt;a href=&quot;https://github.com/graphql/graphql-js&quot;&gt;GraphQL.js&lt;/a&gt; 를 시작하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="efecd775937b634754af4f65cbef5c8b4a7d96ba" translate="yes" xml:space="preserve">
          <source>It returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">&lt;code&gt;dispose()&lt;/code&gt; 를 호출 하여 리 페치를 취소 할 수 있는 &lt;code&gt;Disposable&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="196589ac6e2b21bbd604e37c3b6f49f22ed50655" translate="yes" xml:space="preserve">
          <source>JavaScript environment requirements</source>
          <target state="translated">자바 스크립트 환경 요구 사항</target>
        </trans-unit>
        <trans-unit id="0b490a2df160ed0c71b8320c42d90d77b3406679" translate="yes" xml:space="preserve">
          <source>JavaScript helpers for defining connections between data, and mutations, in a way that smoothly integrates with Relay.</source>
          <target state="translated">Relay와 원활하게 통합되는 방식으로 데이터와 돌연변이 간의 연결을 정의하는 JavaScript 도우미.</target>
        </trans-unit>
        <trans-unit id="3763226e2b043a56c9ba7559341b0774c3ea862d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it is typically considered an &lt;strong&gt;anti-pattern&lt;/strong&gt; to create a single fragment shared across many containers. Abusing this directive could result in over-fetching in your application.</source>
          <target state="translated">많은 컨테이너에서 공유되는 단일 프래그먼트를 생성하는 것은 일반적으로 &lt;strong&gt;안티 패턴&lt;/strong&gt; 으로 간주됩니다 . 이 지시문을 남용하면 응용 프로그램에서 오버 페치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25fe5a3c2698d53807ead685c86822cf47cc3073" translate="yes" xml:space="preserve">
          <source>Learn how to use &lt;code&gt;onReadyStateChange&lt;/code&gt; in our next guide, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;.</source>
          <target state="translated">다음 가이드 인 &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt; 에서 &lt;code&gt;onReadyStateChange&lt;/code&gt; 사용 방법에 대해 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="4a4f4fc8ca8973cbce4f7744b6aee5bccdaab0f6" translate="yes" xml:space="preserve">
          <source>Let's associate the mutation we just created with the root mutation type:</source>
          <target state="translated">방금 생성 한 변이를 루트 변이 유형과 연관 시키십시오.</target>
        </trans-unit>
        <trans-unit id="f8acb98279c7a33b14354f6c3ef2bfe03f2deca1" translate="yes" xml:space="preserve">
          <source>Let's craft an optimistic response for the &lt;code&gt;LikeStoryMutation&lt;/code&gt; example above:</source>
          <target state="translated">위 의 &lt;code&gt;LikeStoryMutation&lt;/code&gt; 예제에 대한 낙관적 응답을 작성해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ba32433c3c054db31c3adabcaef06296860fad94" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">이제 알아 보자 방법을 통해이 작품 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 구성하는 구성 요소 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 를 위에서.</target>
        </trans-unit>
        <trans-unit id="89835a8e4dc90be9c02f2fb3d5af523e7de7cee2" translate="yes" xml:space="preserve">
          <source>Let's explore how this works via a &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component that composes the &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; from above.</source>
          <target state="translated">위에서 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 을 구성 하는 &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 컴포넌트를 통해 이것이 어떻게 작동하는지 살펴 보자 .</target>
        </trans-unit>
        <trans-unit id="8eb1ff4062deba895e97692f949a6733e97ad5f6" translate="yes" xml:space="preserve">
          <source>Let's look at some product use-cases to understand how we incorporated these ideas into Relay. We'll assume a basic familiarity with React.</source>
          <target state="translated">이러한 아이디어를 Relay에 통합 한 방법을 이해하기 위해 일부 제품 사용 사례를 살펴 보겠습니다. 우리는 React에 대한 기본 지식을 가정합니다.</target>
        </trans-unit>
        <trans-unit id="839d4a2135069fbb40df14cc776556712d98fa6a" translate="yes" xml:space="preserve">
          <source>Let's open up the starter kit's schema, and replace the database imports with the ones we just created:</source>
          <target state="translated">스타터 키트의 스키마를 열고 데이터베이스 가져 오기를 방금 작성한 것으로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a72ca83abcd8602717039b5f64a5b5a2b89c81e1" translate="yes" xml:space="preserve">
          <source>Let's see this in action, and query for the ID of the rebels:</source>
          <target state="translated">이것을 실제로 살펴보고 반란군의 ID를 쿼리하십시오.</target>
        </trans-unit>
        <trans-unit id="c673a2bcf682f78fa812bcbefa0360994ed37548" translate="yes" xml:space="preserve">
          <source>Let's start a project using the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; as a base.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;릴레이 스타터 키트&lt;/a&gt; 를 기본으로 사용하여 프로젝트를 시작합시다 .</target>
        </trans-unit>
        <trans-unit id="a71dc4b410048806e0d1bbd75c4e909652f2f534" translate="yes" xml:space="preserve">
          <source>Let's take the rebels, and ask for their first ship:</source>
          <target state="translated">반란군을 데리고 첫 배를 요청합시다 :</target>
        </trans-unit>
        <trans-unit id="510f4b78cd5f8fbd49c14a5834839d1ab18bb893" translate="yes" xml:space="preserve">
          <source>Let's tweak the file &lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; to anchor our game to the &lt;code&gt;game&lt;/code&gt; root field of the schema:</source>
          <target state="translated">&lt;code&gt;./js/routes/AppHomeRoute.js&lt;/code&gt; 파일을 조정하여 게임을 스키마 의 &lt;code&gt;game&lt;/code&gt; 루트 필드에 고정 시키십시오.</target>
        </trans-unit>
        <trans-unit id="cc5b2a062f05dd148b4ef24c76639416ebcc59f3" translate="yes" xml:space="preserve">
          <source>Licensed under the BSD License.</source>
          <target state="translated">BSD 라이센스에 따라 라이센스가 부여되었습니다.</target>
        </trans-unit>
        <trans-unit id="8882f419c30a0460f51c5ec6edaf87949c2d7459" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;updater&lt;/code&gt;, there is no need to provide &lt;code&gt;optimisticUpdater&lt;/code&gt; for simple mutations (field change).</source>
          <target state="translated">&lt;code&gt;updater&lt;/code&gt; 와 마찬가지로 간단한 돌연변이 (필드 변경) 를 위해 &lt;code&gt;optimisticUpdater&lt;/code&gt; 를 제공 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="35b9502f3f76f952801534521de9830a54b15a16" translate="yes" xml:space="preserve">
          <source>Like it can be done with &lt;a href=&quot;guides-containers&quot;&gt;Relay containers&lt;/a&gt;, we can prepare variables for use by our mutation's fragment builders, based on the previous variables and the runtime environment.</source>
          <target state="translated">&lt;a href=&quot;guides-containers&quot;&gt;릴레이 컨테이너&lt;/a&gt; 로 수행 할 수있는 것처럼 이전 변수와 런타임 환경을 기반으로 돌연변이의 조각 빌더가 사용할 변수를 준비 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3715b94c23f4ec20e0da2f29449a3c4646b3d581" translate="yes" xml:space="preserve">
          <source>Like most of the Relay APIs, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; attempts to resolve data using the client store before sending a request to the server. If we instead wanted to force a server request even if data is available on the client, we could use the &lt;code&gt;forceFetch&lt;/code&gt; boolean prop.</source>
          <target state="translated">대부분의 Relay API와 마찬가지로 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 서버에 요청을 보내기 전에 클라이언트 저장소를 사용하여 데이터를 &lt;strong&gt;확인&lt;/strong&gt; 하려고합니다. 대신 클라이언트에서 데이터를 사용할 수있는 경우에도 서버 요청을 강제 실행하려면 &lt;code&gt;forceFetch&lt;/code&gt; 부울 소품을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f856144ecb9d05326c6d97badc1a9b834b075ac1" translate="yes" xml:space="preserve">
          <source>Like the GraphQL URI, the timeout and retry behavior can be configured:</source>
          <target state="translated">GraphQL URI와 마찬가지로 시간 초과 및 재시도 동작을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a466fb1a66e2ac77ce3c14782794ae94365211" translate="yes" xml:space="preserve">
          <source>Managing asynchronous state transitions and coordinating concurrent requests.</source>
          <target state="translated">비동기 상태 전이 관리 및 동시 요청 조정</target>
        </trans-unit>
        <trans-unit id="52b2066f0ecc6504fa0d1683e70c5884d55a8b13" translate="yes" xml:space="preserve">
          <source>Managing errors.</source>
          <target state="translated">오류 관리</target>
        </trans-unit>
        <trans-unit id="7e4ac6803c9159c694f63d089cb06b2519c16aba" translate="yes" xml:space="preserve">
          <source>Methods</source>
          <target state="translated">Methods</target>
        </trans-unit>
        <trans-unit id="9973640b391cb4b42f93e3afba3395c46f6a7823" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay Classic 앱을 Relay Modern으로 마이그레이션 할 때는 처음부터 다시 작성할 필요가 없습니다. 대신 작동하는 앱을 계속 유지하면서 한 번에 하나의 구성 요소를 Relay Modern API로 변환하십시오. 모든 구성 요소가 변환되면 더 작고 빠른 Relay Modern 런타임을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a496d014360b49f4df7da034a0313b6a98aa03a1" translate="yes" xml:space="preserve">
          <source>Migrating a Relay Classic app to Relay Modern doesn't require rewriting from scratch. Instead, you can convert one component at a time to the Relay Modern API while continuing to have a working app. Once all components have been converted, the smaller and faster Relay Modern runtime can be used.</source>
          <target state="translated">Relay Classic 앱을 Relay Modern으로 마이그레이션 할 때는 처음부터 다시 작성할 필요가 없습니다. 대신 작동하는 앱을 계속 유지하면서 한 번에 하나의 구성 요소를 Relay Modern API로 변환 할 수 있습니다. 모든 구성 요소가 변환되면 더 작고 빠른 Relay Modern 런타임을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89ca9763c43ac3c5a6b549a8936812ce36f490d5" translate="yes" xml:space="preserve">
          <source>Migrating to Relay Modern</source>
          <target state="translated">현대 릴레이로 마이그레이션</target>
        </trans-unit>
        <trans-unit id="a2d0fdbac2d058cc7df5b6a959221d8c7b0c5956" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;createRefetchContainer&lt;/code&gt;</source>
          <target state="translated">최신 &lt;code&gt;createRefetchContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04ddebd72b3485cb649586cd882bbc4a0abdd841" translate="yes" xml:space="preserve">
          <source>Modern &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">페이지 매김 컨테이너의 최신 &lt;code&gt;this.props.relay.loadMore(pageSize...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb7d95f729e7a3975428e61ddb5eb7d7241b4fd9" translate="yes" xml:space="preserve">
          <source>Modern Component</source>
          <target state="translated">현대 부품</target>
        </trans-unit>
        <trans-unit id="43dee33213cedaefc62f54e39a529109b27d00fd" translate="yes" xml:space="preserve">
          <source>Modern Mutation</source>
          <target state="translated">현대 돌연변이</target>
        </trans-unit>
        <trans-unit id="f4c44d48df48d618739f0b3ad40791ec870c9181" translate="yes" xml:space="preserve">
          <source>Modern Runtime</source>
          <target state="translated">현대 런타임</target>
        </trans-unit>
        <trans-unit id="d9c1afdc6ae257e230b98cd64d31e69e21611588" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</source>
          <target state="translated">현대 : &lt;code&gt;&amp;lt;QueryRenderer&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a5e6e8b97a1927e12c72c467f5aebd11a8b3d28" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</source>
          <target state="translated">현대 : &lt;code&gt;commitMutation(this.props.relay.environment, {mutation...})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="08b3c5d91eb7d6d9c801374dc1e47b603bba9b4b" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createFragmentContainer&lt;/code&gt;</source>
          <target state="translated">현대 : &lt;code&gt;createFragmentContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f02b7506a9375f3a261dab66ee915f347b72fd85" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;createPaginationContainer&lt;/code&gt;</source>
          <target state="translated">현대 : &lt;code&gt;createPaginationContainer&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c48a2a55168fdc7ce4613937fb203cff48a67840" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">최신 : 리 페치 컨테이너의 &lt;code&gt;this.props.relay.refetch({foo: bar}...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="189e341013a3594080b144a6999f9577b74abee9" translate="yes" xml:space="preserve">
          <source>Modern: &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt; in a Pagination Container</source>
          <target state="translated">최신 : 페이지 매김 컨테이너의 &lt;code&gt;this.props.relay.refetchConnection(...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b11a8c01d122a0561a2dbd1098a225c3e43e4308" translate="yes" xml:space="preserve">
          <source>Most applications will create a single Environment instance and use it throughout. In specific situations, however, you may want to create multiple environments for different purposes. For example, you may create a new environment instance whenever the user logs in or out in order to prevent data for different users being cached together. Similarly, a server rendered application may create a new environment instance per request, so that each request gets its own cache and user data does not overlap. Alternatively, you might have multiple products or features within a larger application, and you want each one to have product-specific network-handling or caching.</source>
          <target state="translated">대부분의 응용 프로그램은 단일 환경 인스턴스를 만들어 전체 환경에서 사용합니다. 그러나 특정 상황에서는 다른 목적으로 여러 환경을 만들 수 있습니다. 예를 들어, 다른 사용자의 데이터가 함께 캐시되지 않도록 사용자가 로그인하거나 로그 아웃 할 때마다 새 환경 인스턴스를 작성할 수 있습니다. 마찬가지로 서버 렌더링 응용 프로그램은 요청마다 새로운 환경 인스턴스를 만들 수 있으므로 각 요청에 고유 한 캐시가 있고 사용자 데이터가 겹치지 않습니다. 또는 더 큰 응용 프로그램 내에 여러 제품 또는 기능이있을 수 있으며 각 제품 또는 네트워크에 제품 별 네트워크 처리 또는 캐싱이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="01c289d32b7203303850eb1c7dd2fdae6842ce3a" translate="yes" xml:space="preserve">
          <source>Must be a valid &lt;code&gt;RelayContainer&lt;/code&gt;. Relay will attempt to fulfill its data requirements before rendering it.</source>
          <target state="translated">유효한 &lt;code&gt;RelayContainer&lt;/code&gt; 이어야합니다 . 릴레이는 데이터를 렌더링하기 전에 데이터 요구 사항을 충족 시키려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="13bcc5c25bae00735d267b69807a37eb90d90472" translate="yes" xml:space="preserve">
          <source>Mutation</source>
          <target state="translated">Mutation</target>
        </trans-unit>
        <trans-unit id="c55f198bc8c7844e5e05f72964532f5dace071a0" translate="yes" xml:space="preserve">
          <source>Mutation props</source>
          <target state="translated">변이 소품</target>
        </trans-unit>
        <trans-unit id="00a7fb731451c41a484b7591ece27f55c474ec0e" translate="yes" xml:space="preserve">
          <source>Mutations</source>
          <target state="translated">Mutations</target>
        </trans-unit>
        <trans-unit id="731fdeead88e01d93d0976eb789d77d6c8ba6428" translate="yes" xml:space="preserve">
          <source>Mutator configuration</source>
          <target state="translated">뮤 테이터 구성</target>
        </trans-unit>
        <trans-unit id="aeecae05e67a82b3d9ddc32f18bafb250167d7b8" translate="yes" xml:space="preserve">
          <source>NODE_DELETE</source>
          <target state="translated">NODE_DELETE</target>
        </trans-unit>
        <trans-unit id="bef32b44309c819256ef91505f3ce46153114806" translate="yes" xml:space="preserve">
          <source>Nested Routes</source>
          <target state="translated">중첩 경로</target>
        </trans-unit>
        <trans-unit id="67269d974acb388f118a96d5b0eb90541c783c5f" translate="yes" xml:space="preserve">
          <source>Nested routes with Relay data dependencies introduce an additional complication. While it's possible to render a &lt;code&gt;QueryRenderer&lt;/code&gt; per route, doing so will lead to request waterfalls in the general case where parent routes do not render their child routes until the data for those parent routes are available. This generally leads to an unnecessary additional delay in loading the data for the page, but may be acceptable for small applications or for applications with shallow route trees.</source>
          <target state="translated">릴레이 데이터 종속성이있는 중첩 된 경로는 추가 복잡성을 유발합니다. 라우트마다 &lt;code&gt;QueryRenderer&lt;/code&gt; 를 렌더링 할 수 있지만 , 그렇게하면 일반적으로 상위 라우트가 해당 상위 라우트에 대한 데이터를 사용할 수있을 때까지 하위 라우트를 렌더링하지 않는 경우 폭포를 요청하게됩니다. 이로 인해 일반적으로 페이지에 대한 데이터를로드 할 때 불필요한 추가 지연이 발생하지만 소규모 응용 프로그램이나 얕은 경로 트리가있는 응용 프로그램에는 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e403f095e27b7f00c62a3bd59aa377165b5a4c" translate="yes" xml:space="preserve">
          <source>Network Layer</source>
          <target state="translated">네트워크 계층</target>
        </trans-unit>
        <trans-unit id="87869155f5f3484fd0f094292d35a709172baa8a" translate="yes" xml:space="preserve">
          <source>Network layer</source>
          <target state="translated">네트워크 계층</target>
        </trans-unit>
        <trans-unit id="f41f095614dba0f32736c3af7fc6b7b54e8b4b7f" translate="yes" xml:space="preserve">
          <source>Never mutate &lt;code&gt;this.props.relay.variables&lt;/code&gt; directly as it will not trigger data to be fetched properly. Treat &lt;code&gt;this.props.relay.variables&lt;/code&gt; as if it were immutable, just like props.</source>
          <target state="translated">&lt;code&gt;this.props.relay.variables&lt;/code&gt; 를 직접 변경하지 마십시오 . 데이터가 올바르게 페치되도록 트리거하지 않습니다. &lt;code&gt;this.props.relay.variables&lt;/code&gt; 를 props처럼 불변 인 것처럼 취급하십시오 .</target>
        </trans-unit>
        <trans-unit id="a945aa9cbd03a748373e539cadd72f60595b9951" translate="yes" xml:space="preserve">
          <source>New in Relay Modern</source>
          <target state="translated">Relay Modern의 새로운 기능</target>
        </trans-unit>
        <trans-unit id="34d3ac7ad9c7ff0b33bb48c822077feedfac1008" translate="yes" xml:space="preserve">
          <source>Next, install the compiler (typically as a &lt;code&gt;devDependency&lt;/code&gt;):</source>
          <target state="translated">다음으로 컴파일러를 설치하십시오 (일반적으로 &lt;code&gt;devDependency&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b11d6766a232735ae2588359ce0e697727bb4a84" translate="yes" xml:space="preserve">
          <source>Next, let's create a file in &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; and create subclass of &lt;code&gt;Relay.Mutation&lt;/code&gt; called &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; to hold our mutation implementation:</source>
          <target state="translated">다음으로 &lt;code&gt;./js/mutations/CheckHidingSpotForTreasureMutation.js&lt;/code&gt; 에 파일을 만들고 &lt;code&gt;Relay.Mutation&lt;/code&gt; 이라는 &lt;code&gt;CheckHidingSpotForTreasureMutation&lt;/code&gt; 서브 클래스를 만들어 돌연변이 구현을 유지해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="8d0415201da41a689310dea9dfd9de53cb8630b3" translate="yes" xml:space="preserve">
          <source>Next, let's define a node interface and type. We only need to provide a way for Relay to map from an object to the GraphQL type associated with that object, and from a global ID to the object it points to:</source>
          <target state="translated">다음으로 노드 인터페이스와 유형을 정의하겠습니다. Relay가 오브젝트에서 오브젝트와 연관된 GraphQL 유형으로, 글로벌 ID에서 오브젝트로 가리키는 오브젝트로 맵핑하는 방법 만 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="adc67eef09450d30c9ae37eeb2376e191eb49c0d" translate="yes" xml:space="preserve">
          <source>Next, let's define our game and hiding spot types, and the fields that are available on each.</source>
          <target state="translated">다음으로, 게임과 은닉 스팟 유형 및 각각에 사용 가능한 필드를 정의하겠습니다.</target>
        </trans-unit>
        <trans-unit id="816c52fd2bdd94a63cd0944823a6c0aa9384c103" translate="yes" xml:space="preserve">
          <source>No</source>
          <target state="translated">No</target>
        </trans-unit>
        <trans-unit id="5b3016b7b65c75156425ea4affe66b9292dbd049" translate="yes" xml:space="preserve">
          <source>No Routing</source>
          <target state="translated">라우팅 없음</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="ded70becacd440a8a5293ee572a86c4c58319833" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; will continue to be false.</source>
          <target state="translated">참고 &lt;code&gt;ready&lt;/code&gt; 및 &lt;code&gt;done&lt;/code&gt; 거짓이 될 것.</target>
        </trans-unit>
        <trans-unit id="7c2002c29e0fca7efc2e3f32bc61fca5000503d9" translate="yes" xml:space="preserve">
          <source>Note that it is &lt;em&gt;highly&lt;/em&gt; recommended that &lt;code&gt;Relay.Container&lt;/code&gt;s define their own fragments and avoid sharing inline &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; values between containers or files. If you find yourself wanting to share inline fragments, it's likely a sign that it's time to refactor and introduce a new container.</source>
          <target state="translated">이 것을 참고 &lt;em&gt;높은&lt;/em&gt; 것이 좋습니다 &lt;code&gt;Relay.Container&lt;/code&gt; 의 자신의 조각을 정의하고 피하기 공유 인라인 &lt;code&gt;var fragment = Relay.QL...&lt;/code&gt; 용기 또는 파일 사이의 값. 인라인 조각을 공유하려는 경우 새 컨테이너를 리팩토링하고 소개해야 할 때입니다.</target>
        </trans-unit>
        <trans-unit id="6251d7c444bd5ea65a8e620b067b7ace419f0985" translate="yes" xml:space="preserve">
          <source>Note that this approach requires &lt;em&gt;n+1&lt;/em&gt; requests to the server: 1 to fetch the list, and &lt;em&gt;n&lt;/em&gt; to fetch each item. With GraphQL we can fetch the same data in a single network request to the server (without creating a custom endpoint that we'd then have to maintain):</source>
          <target state="translated">이 방법을 사용하려면 서버에 대한 &lt;em&gt;n + 1&lt;/em&gt; 요청 이 필요 합니다. 1은 목록 을 가져오고 &lt;em&gt;n&lt;/em&gt; 은 각 항목을 가져옵니다. GraphQL을 사용하면 단일 네트워크 요청에서 동일한 데이터를 서버로 가져올 수 있습니다 (사용자 지정 엔드 포인트를 만들지 않고도 유지 관리해야 함).</target>
        </trans-unit>
        <trans-unit id="41a9a091d399394a5944c5c0a394fb244440e004" translate="yes" xml:space="preserve">
          <source>Note that this is a basic example to help you get started. This example could be extended with additional features such as request/response caching (enabled e.g. when &lt;code&gt;cacheConfig.force&lt;/code&gt; is false) and uploading form data for mutations (the &lt;code&gt;uploadables&lt;/code&gt; parameter).</source>
          <target state="translated">시작하는 데 도움이되는 기본 예입니다. 이 예제는 요청 / 응답 캐싱 (예 : &lt;code&gt;cacheConfig.force&lt;/code&gt; 가 false 인 경우) 및 돌연변이에 대한 양식 데이터 업로드 ( &lt;code&gt;uploadables&lt;/code&gt; 매개 변수) 와 같은 추가 기능으로 확장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18e979539b69c286787704dcc6ebc81753f2b6c9" translate="yes" xml:space="preserve">
          <source>Note that this normalized cache structure allows overlapping results to be cached without duplication. Each record is stored once regardless of how it is fetched. Let's return to the earlier example of inconsistent data and see how this cache helps in that scenario.</source>
          <target state="translated">이 정규화 된 캐시 구조를 사용하면 중복없이 겹치는 결과를 캐시 할 수 있습니다. 각 레코드는 가져 오는 방법에 관계없이 한 번 저장됩니다. 일치하지 않는 데이터의 이전 예로 돌아가서 해당 시나리오에서이 캐시가 어떻게 도움이되는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6a3998469edc7ffa18da69953898b4c848c54481" translate="yes" xml:space="preserve">
          <source>Note that this solution will also work for &lt;em&gt;writes&lt;/em&gt;: any update to the cache will notify the affected views, and writes are just another thing that updates the cache.</source>
          <target state="translated">이 솔루션은 &lt;em&gt;쓰기&lt;/em&gt; 에도 적용됩니다. 캐시를 업데이트하면 영향을받는보기에 알리고 쓰기는 캐시를 업데이트하는 또 다른 것입니다.</target>
        </trans-unit>
        <trans-unit id="ac8054c10594bdd95e89a5e8a8673034de9d793b" translate="yes" xml:space="preserve">
          <source>Note that when composing fragments, the type of the composed fragment must match the field on the parent in which it is embedded. For example, it wouldn't make sense to embed a fragment of type &lt;code&gt;Story&lt;/code&gt; into a parent's field of type &lt;code&gt;User&lt;/code&gt;. Relay and GraphQL will provide helpful error messages if you get this wrong (and if they aren't helpful, let us know!).</source>
          <target state="translated">프래그먼트를 작성할 때 작성된 프래그먼트의 유형은 해당 프래그먼트가 포함 된 상위의 필드와 일치해야합니다. 예를 들어 &lt;code&gt;Story&lt;/code&gt; 유형의 조각을 &lt;code&gt;User&lt;/code&gt; 유형의 부모 필드에 포함시키는 것은 의미가 없습니다 . Relay 및 GraphQL은이 오류가 발생하면 유용한 오류 메시지를 제공합니다 (도움이되지 않으면 알려주세요).</target>
        </trans-unit>
        <trans-unit id="0cb3b8bd044c603524ff2409189dcccf98b3f39b" translate="yes" xml:space="preserve">
          <source>Note: Determining variable values at runtime</source>
          <target state="translated">참고 : 런타임시 변수 값 결정</target>
        </trans-unit>
        <trans-unit id="6eb6c807aac98e74096f64d7f8585ee557b93a39" translate="yes" xml:space="preserve">
          <source>Note: In most cases, it is possible to rely on the default singleton instance of the environment, which is exposed as &lt;code&gt;Relay.Store&lt;/code&gt;.</source>
          <target state="translated">참고 : 대부분의 경우 &lt;code&gt;Relay.Store&lt;/code&gt; 로 노출되는 환경의 기본 싱글 톤 인스턴스에 의존 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06bd725e4a6c3e529d4b86297fa0d602b821e04c" translate="yes" xml:space="preserve">
          <source>Note: This method may only be called once per instance.</source>
          <target state="translated">참고 :이 메소드는 인스턴스 당 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e48b33fadd08f907218ada431ccb61eb2d094e" translate="yes" xml:space="preserve">
          <source>Notice that it immediately executes the next task. Relay manages the order of tasks to ensure a proper order of operations - the scheduler can't skip or reorder tasks, only decide when to execute the next one.</source>
          <target state="translated">다음 작업을 즉시 실행합니다. 릴레이는 작업 순서를 관리하여 적절한 작업 순서를 보장합니다. 스케줄러는 작업을 건너 뛰거나 순서를 바꿀 수 없으며 다음 작업을 실행할시기 만 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c79f05d35d0a7eb36506bd3ab33a1f2773cfa554" translate="yes" xml:space="preserve">
          <source>Notice that the cursor is a base64 string. That's the pattern from earlier: the server is reminding us that this is an opaque string. We can pass this string back to the server as the &lt;code&gt;after&lt;/code&gt; argument to the &lt;code&gt;ships&lt;/code&gt; field, which will let us ask for the next three ships after the last one in the previous result:</source>
          <target state="translated">커서는 base64 문자열입니다. 서버는 우리에게 이것이 불투명 한 문자열임을 상기시켜줍니다. 이 문자열을 &lt;code&gt;ships&lt;/code&gt; 필드에 대한 &lt;code&gt;after&lt;/code&gt; 인수로 서버에 다시 전달할 수 있습니다. 그러면 이전 결과에서 마지막 선박 다음에 다음 3 척을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3aca59c767d5ed557222dbb5b8557469ae3a4a7f" translate="yes" xml:space="preserve">
          <source>Notice that we're querying for data that &lt;em&gt;may&lt;/em&gt; have changed as a result of the mutation. An obvious question is: why can't the server just tell us what changed? The answer is: it's complicated. GraphQL abstracts over &lt;em&gt;any&lt;/em&gt; data storage layer (or an aggregation of multiple sources), and works with any programming language. Furthermore, the goal of GraphQL is to provide data in a form that is useful to product developers building a view.</source>
          <target state="translated">돌연변이로 인해 변경되었을 &lt;em&gt;수&lt;/em&gt; 있는 데이터를 쿼리하고 &lt;em&gt;있습니다&lt;/em&gt; . 명백한 질문은 서버가 왜 무엇이 바뀌 었는지 말해 줄 수 없는가입니다. 답은 복잡합니다. GraphQL은 &lt;em&gt;모든&lt;/em&gt; 데이터 스토리지 계층 (또는 여러 소스의 집합)을 추상화 하고 모든 프로그래밍 언어와 함께 작동합니다. 또한 GraphQL의 목표는 뷰를 작성하는 제품 개발자에게 유용한 형식으로 데이터를 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="056ee5771da852e979294339f6d61f3371dc9784" translate="yes" xml:space="preserve">
          <source>Now Relay will both fetch the larger photo size &lt;em&gt;and&lt;/em&gt;&lt;code&gt;Child&lt;/code&gt; will know to render it.</source>
          <target state="translated">이제 릴레이는 모두 큰 사진 크기를 가져옵니다 &lt;em&gt;과 &lt;/em&gt; &lt;code&gt;Child&lt;/code&gt; 를 렌더링하는 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="359fab9a105cb172833a57b904a4f78ae21bf6b3" translate="yes" xml:space="preserve">
          <source>Now Relay will fetch the photo with size 128 - but the &lt;code&gt;Child&lt;/code&gt; container won't magically know about this variable. We have to tell it by passing the variable value as a prop:</source>
          <target state="translated">이제 릴레이는 크기가 128 인 사진을 가져옵니다. 그러나 &lt;code&gt;Child&lt;/code&gt; 컨테이너는이 변수에 대해 마 법적으로 알지 못합니다. 변수 값을 소품으로 전달하여 알려줘야합니다.</target>
        </trans-unit>
        <trans-unit id="8f4ea81858f10f7f357b3da216fb14eb06c577cc" translate="yes" xml:space="preserve">
          <source>Now let's associate these types with the root query type.</source>
          <target state="translated">이제 이러한 유형을 루트 쿼리 유형과 연관 시키십시오.</target>
        </trans-unit>
        <trans-unit id="ee5dbc563862c37bd2eddab0d2faa5a3c1303875" translate="yes" xml:space="preserve">
          <source>Now let's take a closer look at the &lt;code&gt;config&lt;/code&gt;:</source>
          <target state="translated">이제 &lt;code&gt;config&lt;/code&gt; 자세히 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c63c75c8f04bcbaded3abd8323247dbc014c15ac" translate="yes" xml:space="preserve">
          <source>Now that we've gone through this tutorial, let's dive into what it means to build a GraphQL client framework and how this compares to clients for more traditional REST systems.</source>
          <target state="translated">이 튜토리얼을 살펴 보았으므로 GraphQL 클라이언트 프레임 워크를 구축하는 것이 무엇을 의미하는지와 더 전통적인 REST 시스템의 클라이언트와 비교하는 방법에 대해 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3c8e0a4e6791c0f1c68af7b94cb67e9dddbecd93" translate="yes" xml:space="preserve">
          <source>Now we can instantiate a &lt;code&gt;ProfileRoute&lt;/code&gt; that fetches data for user &lt;code&gt;123&lt;/code&gt;:</source>
          <target state="translated">이제 사용자 &lt;code&gt;123&lt;/code&gt; 의 데이터를 가져 오는 &lt;code&gt;ProfileRoute&lt;/code&gt; 를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3cbdecefa56176a7edca66548a54ce86a3ed688" translate="yes" xml:space="preserve">
          <source>Now, requests for previously cached data can be answered immediately without making a network request. This is a practical approach to improving the perceived performance of an application. However, this method of caching can cause problems with data consistency.</source>
          <target state="translated">이제 네트워크 요청없이 이전에 캐시 된 데이터에 대한 요청에 즉시 응답 할 수 있습니다. 이것은 응용 프로그램의 인식 된 성능을 향상시키는 실질적인 접근 방식입니다. 그러나이 캐싱 방법은 데이터 일관성에 문제를 일으킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7d436121cc7de83cd8afcc9e5b08145f88e3d72" translate="yes" xml:space="preserve">
          <source>Object Identification</source>
          <target state="translated">객체 식별</target>
        </trans-unit>
        <trans-unit id="509d0e819f7363f119680482f06c06df5503cfc0" translate="yes" xml:space="preserve">
          <source>On the Relay Container the prop &lt;code&gt;bars&lt;/code&gt; will be an array instead of an object.</source>
          <target state="translated">릴레이 컨테이너에서 prop &lt;code&gt;bars&lt;/code&gt; 는 객체 대신 배열입니다.</target>
        </trans-unit>
        <trans-unit id="258ab7d6dd3b683b7bd3f1f1a9e4c26dc064e05d" translate="yes" xml:space="preserve">
          <source>On the other hand, GraphQL &lt;strong&gt;fragments&lt;/strong&gt; declare fields that exist on any arbitrary type. For example, the following fragment fetches the profile picture URI for &lt;em&gt;some&lt;/em&gt;&lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">반면에 GraphQL &lt;strong&gt;조각&lt;/strong&gt; 은 임의의 유형에 존재하는 필드를 선언합니다. 예를 들어 다음 조각은 &lt;em&gt;일부 &lt;/em&gt; &lt;code&gt;User&lt;/code&gt; 에 대한 프로필 사진 URI를 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="e77ad76d86248c3f5b3430ab7a50cf954c824781" translate="yes" xml:space="preserve">
          <source>Once a few or all of your views are using &lt;code&gt;QueryRenderer&lt;/code&gt;, &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; could be replaced with a &lt;code&gt;RelayModernEnvironment&lt;/code&gt;. Keep in mind that &lt;code&gt;RelayModernEnvironment&lt;/code&gt; and &lt;code&gt;Store&lt;/code&gt; do not share any data. You might want to hold off on this step until views that have significant data overlap can be switched over at the same time. This step is what unlocks the perf wins for your app. Apps using the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; get to send persisted query IDs instead of the full query strings to the server, as well as much more optimized data normalizing and processing.</source>
          <target state="translated">귀하의 의견의 일부 또는 전부가 사용되면 &lt;code&gt;QueryRenderer&lt;/code&gt; , &lt;code&gt;Store&lt;/code&gt; 에서 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 로 대체 될 수 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; . 있다는 사실을 숙지 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 및 &lt;code&gt;Store&lt;/code&gt; 데이터를 공유하지 않습니다. 중요한 데이터 겹침이있는 뷰를 동시에 전환 할 수있을 때까지이 단계를 보류 할 수 있습니다. 이 단계는 앱의 성능을 향상시키는 것입니다. &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 를 사용하는 앱 은 전체 쿼리 문자열 대신 지속 쿼리 ID를 서버에 보내고 최적화 된 데이터 정규화 및 처리를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="aa26441141ed7039f7d3b90dda06bb5985300871" translate="yes" xml:space="preserve">
          <source>Once all the components and mutations have been converted to use the Relay Modern APIs, convert to using &lt;code&gt;QueryRenderer&lt;/code&gt; instead of using &lt;code&gt;Relay.Renderer&lt;/code&gt; or &lt;code&gt;Relay.RootContainer&lt;/code&gt;. You may supply &lt;code&gt;Store&lt;/code&gt; from &lt;code&gt;'react-relay/classic'&lt;/code&gt; as the &lt;code&gt;environment&lt;/code&gt; for most cases.</source>
          <target state="translated">모든 구성 요소와 돌연변이가 Relay Modern API를 사용하도록 변환되면 &lt;code&gt;Relay.Renderer&lt;/code&gt; 또는 &lt;code&gt;Relay.RootContainer&lt;/code&gt; 대신 &lt;code&gt;QueryRenderer&lt;/code&gt; 를 사용하여 변환 하십시오 . 대부분의 경우 &lt;code&gt;environment&lt;/code&gt; 으로 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 에서 &lt;code&gt;Store&lt;/code&gt; 를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="526a2470452cfa759c69b07a4cdac3145513395b" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;error&lt;/code&gt; set to an &lt;code&gt;Error&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 가 &lt;code&gt;Error&lt;/code&gt; 개체로 설정 되면</target>
        </trans-unit>
        <trans-unit id="d30a28f0a20b5fda3d127c2ba900c1393a0c802c" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true, but &lt;code&gt;stale&lt;/code&gt; set to false.</source>
          <target state="translated">와 일단 &lt;code&gt;ready&lt;/code&gt; 및 &lt;code&gt;done&lt;/code&gt; True로 설정하지만 &lt;code&gt;stale&lt;/code&gt; false로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c510443cbc7ffd35f869abc94218360943f66d9e" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; and &lt;code&gt;done&lt;/code&gt; set to true.</source>
          <target state="translated">와 일단 &lt;code&gt;ready&lt;/code&gt; 및 &lt;code&gt;done&lt;/code&gt; True로 설정.</target>
        </trans-unit>
        <trans-unit id="9b048c01bc7fa82617b39cb08502f943e54b8d4a" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt; set to false.</source>
          <target state="translated">&lt;code&gt;ready&lt;/code&gt; 가 false로 설정 되면</target>
        </trans-unit>
        <trans-unit id="fe545c0159939d91c25a89db650c07bece33f470" translate="yes" xml:space="preserve">
          <source>Once with &lt;code&gt;ready&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, and &lt;code&gt;stale&lt;/code&gt; set to true.</source>
          <target state="translated">와 일단 &lt;code&gt;ready&lt;/code&gt; , &lt;code&gt;done&lt;/code&gt; , 그리고 &lt;code&gt;stale&lt;/code&gt; true로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="c8f5f6a359004092335c67ac77552d54cac29a5a" translate="yes" xml:space="preserve">
          <source>Once you have an environment, you can pass it in to your &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; instance, or into mutations via the &lt;code&gt;commitUpdate&lt;/code&gt; function (see &quot;&lt;a href=&quot;mutations&quot;&gt;Mutations&lt;/a&gt;&quot;).</source>
          <target state="translated">환경이 확보되면, 환경을 &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; 인스턴스로 전달하거나 &lt;code&gt;commitUpdate&lt;/code&gt; 함수 를 통해 돌연변이로 전달할 수 있습니다 ( &quot; &lt;a href=&quot;mutations&quot;&gt;돌연변이&lt;/a&gt; &quot; 참조 ).</target>
        </trans-unit>
        <trans-unit id="3445237f2d0762c974ff895551ac18ecb7b0fd39" translate="yes" xml:space="preserve">
          <source>One of the big ideas behind the new API is that execution can be made a lot more efficient by moving work ahead-of-time: from the runtime of the app to the build-time. As such, changes to GraphQL fragments require a build step to regenerate a set of artifacts. More on &lt;a href=&quot;relay-compiler&quot;&gt;the Relay Compiler&lt;/a&gt;.</source>
          <target state="translated">새로운 API의 가장 큰 아이디어 중 하나는 작업을 앱의 런타임에서 빌드 타임으로 미리 이동하여 실행을 훨씬 효율적으로 수행 할 수 있다는 것입니다. 따라서 GraphQL 조각을 변경하면 일련의 아티팩트를 재생성하는 빌드 단계가 필요합니다. &lt;a href=&quot;relay-compiler&quot;&gt;릴레이 컴파일러&lt;/a&gt; 에 대한 추가 정보 .</target>
        </trans-unit>
        <trans-unit id="ad501b8fa6c8a155c72db2494b37eb05a27af8e5" translate="yes" xml:space="preserve">
          <source>One solution is to have a root component fetch the data for all its children. However, this would introduce coupling: every change to a component would require changing &lt;em&gt;any&lt;/em&gt; root component that might render it, and often some components between it and the root. This coupling could mean a greater chance for bugs and slow the pace of development. Ultimately, this approach doesn't take advantage of React's component model. The natural place for specifying data-dependencies was in &lt;em&gt;components&lt;/em&gt;.</source>
          <target state="translated">한 가지 해결책은 루트 구성 요소가 모든 하위 항목의 데이터를 가져 오도록하는 것입니다. 그러나 이것은 커플 링을 도입합니다. 구성 요소를 변경할 때마다 구성 요소를 렌더링 할 수 &lt;em&gt;있는&lt;/em&gt; 루트 구성 요소와 종종 구성 요소와 루트 사이의 일부 구성 요소를 변경해야합니다. 이러한 결합은 버그 발생 가능성이 높아지고 개발 속도가 느려질 수 있습니다. 궁극적으로이 접근법은 React의 컴포넌트 모델을 이용하지 않습니다. 데이터 종속성을 지정하는 자연스러운 장소는 &lt;em&gt;components&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6b5a7ba3ecdf80b9b9c9285e7c15e081d2c4cfd9" translate="yes" xml:space="preserve">
          <source>One thing is left in the example above &amp;mdash; implementing &lt;code&gt;setSize()&lt;/code&gt;, which should change the photo's size when the slider values changes. In addition to passing the results of each query to the component, Relay also provides a &lt;code&gt;relay&lt;/code&gt; prop that has Relay-specific methods and metadata. These include &lt;code&gt;variables&lt;/code&gt; &amp;mdash; the active variables used to fetch the current &lt;code&gt;props&lt;/code&gt; &amp;mdash; and &lt;code&gt;setVariables()&lt;/code&gt; &amp;mdash; a callback that can be used to request data for different variable values.</source>
          <target state="translated">위의 예 에는 슬라이더 크기가 변경 될 때 사진 크기를 변경해야하는 &lt;code&gt;setSize()&lt;/code&gt; 구현이 남아 있습니다. 컴포넌트 각 질의의 결과를 전달하는 것 외에도, 릴레이 또한 제공 &lt;code&gt;relay&lt;/code&gt; 릴레이 특정 방법 및 메타 데이터가 소품. 여기에는 &lt;code&gt;variables&lt;/code&gt; 현재 &lt;code&gt;props&lt;/code&gt; 을 가져 오는 데 사용되는 활성 변수 &lt;code&gt;setVariables()&lt;/code&gt; 와 setVariables () ( 다른 변수 값에 대한 데이터를 요청하는 데 사용할 수있는 콜백)가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="43ec0f0f8cb785cd4021b95098b6011da01043b4" translate="yes" xml:space="preserve">
          <source>Only fields specified by these fragments will be populated in &lt;code&gt;this.props&lt;/code&gt; when the component is rendered. This ensures that there are no implicit dependencies from a component on its parent component or any child components.</source>
          <target state="translated">컴포넌트가 렌더링 될 때 이러한 조각으로 지정된 필드 만 &lt;code&gt;this.props&lt;/code&gt; 에 채워집니다 . 따라서 상위 구성 요소 또는 하위 구성 요소의 구성 요소로부터 내재 된 종속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="544901021486ff794813761281a30a85a9ea2561" translate="yes" xml:space="preserve">
          <source>Optimistic updates</source>
          <target state="translated">낙관적 업데이트</target>
        </trans-unit>
        <trans-unit id="75e97d82c2ab23fae3c5ae0de671aad8aaab254b" translate="yes" xml:space="preserve">
          <source>Optimistically updating the UI while waiting for the server to respond to mutations.</source>
          <target state="translated">서버가 돌연변이에 응답 할 때까지 UI를 최적으로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="a30573ebcc5462272b8ba6828cf0b15e88284677" translate="yes" xml:space="preserve">
          <source>Option 1: Re-fetch everything that the app has ever queried. Even though only a small subset of this data will actually change, we'll still have to wait for the server to execute the &lt;em&gt;entire&lt;/em&gt; query, wait to download the results, and wait to process them again. This is very inefficient.</source>
          <target state="translated">옵션 1 : 앱이 쿼리 한 모든 것을 다시 가져옵니다. 이 데이터의 작은 하위 집합 만 실제로 변경 될지라도 서버가 &lt;em&gt;전체&lt;/em&gt; 쿼리 를 실행할 때까지 기다렸다가 결과를 다운로드 한 후 다시 처리 할 때까지 기다려야합니다. 이것은 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7c7f0ed28de8faafd0afd103f17d025324ed7cc5" translate="yes" xml:space="preserve">
          <source>Option 2: Re-fetch only the queries required by actively rendered views. This is a slight improvement over option 1. However, cached data that &lt;em&gt;isn't&lt;/em&gt; currently being viewed won't be updated. Unless this data is somehow marked as stale or evicted from the cache subsequent queries will read outdated information.</source>
          <target state="translated">옵션 2 : 적극적으로 렌더링 된 뷰에 필요한 쿼리 만 다시 가져옵니다. 이것은 옵션 1보다 약간 개선 된 것입니다. 그러나 현재보고 &lt;em&gt;있지 않은&lt;/em&gt; 캐시 된 데이터 &lt;em&gt;는&lt;/em&gt; 업데이트되지 않습니다. 이 데이터가 어떤 식 으로든 오래된 것으로 표시되거나 캐시에서 제거되지 않으면 후속 쿼리는 오래된 정보를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="1fc54acb388aaf56464909787927f5c9cc6c305b" translate="yes" xml:space="preserve">
          <source>Option 3: Re-fetch a fixed list of fields that &lt;em&gt;may&lt;/em&gt; change after the mutation. We'll call this list a &lt;strong&gt;fat query&lt;/strong&gt;. We found this to also be inefficient because typical applications only render a subset of the fat query, but this approach would require fetching all of those fields.</source>
          <target state="translated">옵션 3 : 돌연변이 후 변경 &lt;em&gt;될 수&lt;/em&gt; 있는 고정 필드 목록을 다시 가져옵니다 . 이 목록을 &lt;strong&gt;팻 쿼리라고&lt;/strong&gt; 합니다. 일반적인 응용 프로그램은 팻 쿼리의 하위 집합 만 렌더링하기 때문에이 방법도 비효율적 인 것으로 나타 났지만이 방법을 사용하려면 해당 필드를 모두 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="4be11d572e3b53b4fc22dae76efc2d670f4be4bb" translate="yes" xml:space="preserve">
          <source>Option 4 (Relay): Re-fetch the intersection of what may change (the fat query) and the data in the cache. In addition to the cache of data Relay also remembers the queries used to fetch each item. These are called &lt;strong&gt;tracked queries&lt;/strong&gt;. By intersecting the tracked and fat queries, Relay can query exactly the set of information the application needs to update and nothing more.</source>
          <target state="translated">옵션 4 (릴레이) : 변경 될 수있는 항목 (뚱뚱한 쿼리)과 캐시의 데이터의 교집합을 다시 가져옵니다. 데이터 캐시 외에도 Relay는 각 항목을 가져 오는 데 사용 된 쿼리를 기억합니다. 이를 &lt;strong&gt;추적 쿼리&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; . 추적 된 쿼리와 뚱뚱한 쿼리를 교차시킴으로써 Relay는 응용 프로그램이 업데이트해야하는 정보를 정확하게 쿼리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="6718713de12ca02e84822e47bd7f3094f39d3c0a" translate="yes" xml:space="preserve">
          <source>Optionally install globally</source>
          <target state="translated">선택적으로 글로벌 설치</target>
        </trans-unit>
        <trans-unit id="b30829da1c673e16f6adae2f5da589d2b2d65970" translate="yes" xml:space="preserve">
          <source>Optionally, follow up with a call to &lt;code&gt;commit()&lt;/code&gt; to send the mutation to the server.</source>
          <target state="translated">선택적으로, 서버에 돌연변이를 보내기 위해 &lt;code&gt;commit()&lt;/code&gt; 호출을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3a603142c92a8b820560fb3bf1b12553420c3f4e" translate="yes" xml:space="preserve">
          <source>Optionally, precede with a call to &lt;code&gt;applyOptimistic()&lt;/code&gt; to apply an update optimistically to the store.</source>
          <target state="translated">선택적으로, 상점에 낙관적으로 업데이트를 적용 하려면 &lt;code&gt;applyOptimistic()&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="ae17e1897a8cc791f789d5b34d32406b1c727d64" translate="yes" xml:space="preserve">
          <source>Or this way, with the same results:</source>
          <target state="translated">또는 같은 방법으로이 방법으로 :</target>
        </trans-unit>
        <trans-unit id="50300a6866222e559def812f5df571c9176ba61e" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#defaultnetworklayer-static-property&quot;&gt;DefaultNetworkLayer를&lt;/a&gt; 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="fd55d4fdc76dc273300987b3c56489168f507c74" translate="yes" xml:space="preserve">
          <source>Overriding Fragment Variables</source>
          <target state="translated">조각 변수 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="100325b8d6de92dc6ff09cd2c078133755bf274f" translate="yes" xml:space="preserve">
          <source>Pagination</source>
          <target state="translated">Pagination</target>
        </trans-unit>
        <trans-unit id="1847eac49f0862bab8cf4f3614ad739655005e7f" translate="yes" xml:space="preserve">
          <source>Pagination Container</source>
          <target state="translated">페이지 매김 컨테이너</target>
        </trans-unit>
        <trans-unit id="66cd194918cca0919b19b5c19a6632d8edf7c051" translate="yes" xml:space="preserve">
          <source>PaginationContainer</source>
          <target state="translated">PaginationContainer</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="5a9a81786a3cd10e92834a3ac1d48bcd7f39e6e3" translate="yes" xml:space="preserve">
          <source>Please note that the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; plugin should run before other plugins or presets to ensure the &lt;code&gt;graphql&lt;/code&gt; template literals are correctly transformed. See Babel's &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;documentation on this topic&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; 템플릿 리터럴이 올바르게 변환 되도록 하려면 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 플러그인을 다른 플러그인이나 사전 설정보다 먼저 실행해야합니다 . &lt;a href=&quot;https://babeljs.io/docs/plugins/#plugin-preset-ordering&quot;&gt;이 주제에 대한&lt;/a&gt; Babel의 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="02a0a62fe61678e8a433343395761ce593ca76c7" translate="yes" xml:space="preserve">
          <source>Please note that this replaces the &lt;a href=&quot;guides-babel-plugin&quot;&gt;older Babel Relay plugin&lt;/a&gt;. It is not necessary to include both plugins.</source>
          <target state="translated">이것은 &lt;a href=&quot;guides-babel-plugin&quot;&gt;이전 Babel Relay 플러그인을&lt;/a&gt; 대체합니다 . 두 플러그인을 모두 포함 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c6a15b9b600a39666d059f44d5e217d0eadd28f6" translate="yes" xml:space="preserve">
          <source>Populating The Cache</source>
          <target state="translated">캐시 채우기</target>
        </trans-unit>
        <trans-unit id="9ef1894fd67a6660f9dc545b85fdd7563a957682" translate="yes" xml:space="preserve">
          <source>Populating the cache involves walking a hierarchical GraphQL response and creating or updating normalized cache records. At first it may seem that the response alone is sufficient to process the response, but in fact this is only true for very simple queries. Consider &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; &amp;mdash; how should we store &lt;code&gt;photo&lt;/code&gt;? Using &lt;code&gt;photo&lt;/code&gt; as the field name in the cache won't work because a different query might fetch the same field but with different argument values (e.g. &lt;code&gt;photo(size: 64) {...}&lt;/code&gt;). A similar issue occurs with pagination. If we fetch the 11th to 20th stories with &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt;, these new results should be &lt;em&gt;appended&lt;/em&gt; to the existing list.</source>
          <target state="translated">캐시를 채우려면 계층 적 GraphQL 응답을 수행하고 정규화 된 캐시 레코드를 작성하거나 업데이트해야합니다. 처음에는 응답만으로는 응답을 처리하기에 충분하지만 실제로는 매우 간단한 쿼리에만 해당됩니다. 고려 &lt;code&gt;user(id: &quot;456&quot;) { photo(size: 32) { uri } }&lt;/code&gt; - 우리가 어떻게 저장해야 &lt;code&gt;photo&lt;/code&gt; ? 사용하여 &lt;code&gt;photo&lt;/code&gt; 다른 쿼리가 있지만 다른 인수 값과 같은 필드를 가져올 수 있기 때문에 작동하지 않습니다 캐시에있는 필드 이름 (예 : &lt;code&gt;photo(size: 64) {...}&lt;/code&gt; ). 페이지 매김과 비슷한 문제가 발생합니다. &lt;code&gt;stories(first: 10, offset: 10)&lt;/code&gt; 11 ~ 20 번째 스토리를 가져 오면 이러한 새로운 결과가 기존 목록에 &lt;em&gt;추가&lt;/em&gt; 되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="178213e972c712d32c9b754e0fae0660405a3262" translate="yes" xml:space="preserve">
          <source>Processing the schema</source>
          <target state="translated">스키마 처리</target>
        </trans-unit>
        <trans-unit id="9fb705d5e8095ddb73ff47bd5a3af904d3ea97b5" translate="yes" xml:space="preserve">
          <source>PropTypes</source>
          <target state="translated">PropTypes</target>
        </trans-unit>
        <trans-unit id="bc6c88db2f0703a9e2461a4a8060ccf1cb881998" translate="yes" xml:space="preserve">
          <source>Properties</source>
          <target state="translated">Properties</target>
        </trans-unit>
        <trans-unit id="1100c030f3dc539b64e7700624cabb080430dd57" translate="yes" xml:space="preserve">
          <source>Properties and Methods</source>
          <target state="translated">특성 및 방법</target>
        </trans-unit>
        <trans-unit id="e5561bc237fb41709bb2e8b651d704c1664ae03e" translate="yes" xml:space="preserve">
          <source>Props</source>
          <target state="translated">Props</target>
        </trans-unit>
        <trans-unit id="32bb9f0eed56ead65c951dc161935d4389c8dfcc" translate="yes" xml:space="preserve">
          <source>QL</source>
          <target state="translated">QL</target>
        </trans-unit>
        <trans-unit id="0fa0f7a77beffe015e3dbe50d9707a0cef073bae" translate="yes" xml:space="preserve">
          <source>Queries vs. Fragments</source>
          <target state="translated">쿼리 대 조각</target>
        </trans-unit>
        <trans-unit id="715a8fe94c1d42fc9dfbb4b5057bd51288856fd1" translate="yes" xml:space="preserve">
          <source>Query Naming Convention</source>
          <target state="translated">쿼리 명명 규칙</target>
        </trans-unit>
        <trans-unit id="0f4abb2dc94c20672b1e17a54e1138df9766d152" translate="yes" xml:space="preserve">
          <source>Query Renderer</source>
          <target state="translated">쿼리 렌더러</target>
        </trans-unit>
        <trans-unit id="64c6ced3f69ca25be02a6b4eb81804275f87ea3e" translate="yes" xml:space="preserve">
          <source>QueryConfig</source>
          <target state="translated">QueryConfig</target>
        </trans-unit>
        <trans-unit id="92ed502ab1f6d9e04d58803b1ef2281c76306e49" translate="yes" xml:space="preserve">
          <source>QueryRenderer</source>
          <target state="translated">QueryRenderer</target>
        </trans-unit>
        <trans-unit id="004b0b56745c5867ceb6c95eccae46bc9634eca6" translate="yes" xml:space="preserve">
          <source>Queuing mutations to avoid race conditions.</source>
          <target state="translated">경쟁 조건을 피하기 위해 큐잉 돌연변이.</target>
        </trans-unit>
        <trans-unit id="455083cac2ae96eabe3895762b6080aa09e6afa4" translate="yes" xml:space="preserve">
          <source>Quick Start</source>
          <target state="translated">빠른 시작</target>
        </trans-unit>
        <trans-unit id="c22fa04a8b6a77a7856984111524e39134e2d44d" translate="yes" xml:space="preserve">
          <source>RANGE_ADD</source>
          <target state="translated">RANGE_ADD</target>
        </trans-unit>
        <trans-unit id="a5c0b5daae0eddce515d43e69bbf8ebe6c085aa7" translate="yes" xml:space="preserve">
          <source>RANGE_DELETE</source>
          <target state="translated">RANGE_DELETE</target>
        </trans-unit>
        <trans-unit id="65b00e2a3b97ba71c6979a03111363ff814865c1" translate="yes" xml:space="preserve">
          <source>REQUIRED_CHILDREN</source>
          <target state="translated">REQUIRED_CHILDREN</target>
        </trans-unit>
        <trans-unit id="5ca02c4d8d1e211afacc19bb40a490a44ae66f21" translate="yes" xml:space="preserve">
          <source>React Native Configuration</source>
          <target state="translated">네이티브 구성 반응</target>
        </trans-unit>
        <trans-unit id="55a38b3edc3904e22c3fddf2b60febe07b47d508" translate="yes" xml:space="preserve">
          <source>React Router</source>
          <target state="translated">반응 라우터</target>
        </trans-unit>
        <trans-unit id="6bb70948dc19f1bb32a259898fca2dfd714e7448" translate="yes" xml:space="preserve">
          <source>React and Relay support creating arbitrarily complex applications through &lt;em&gt;composition&lt;/em&gt;. Larger components can be created by composing smaller components, helping us to create modular, robust applications. There are two aspects to composing components in Relay:</source>
          <target state="translated">React and Relay는 &lt;em&gt;컴포지션을&lt;/em&gt; 통해 임의로 복잡한 응용 프로그램을 만들 수 있도록 지원 합니다. 더 작은 구성 요소를 구성하여 더 큰 구성 요소를 만들 수 있으므로 모듈 식의 강력한 응용 프로그램을 만들 수 있습니다. Relay에서 컴포넌트를 구성하는 데는 두 가지 측면이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b75cb8007be8e88622c14d5835273832c1645c5" translate="yes" xml:space="preserve">
          <source>React component classes may have methods, often accessed via &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt;. Since Relay composes these component instances in a container, you need to use the &lt;code&gt;componentRef&lt;/code&gt; prop to access them:</source>
          <target state="translated">React 컴포넌트 클래스에는 종종 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;refs&lt;/a&gt; 를 통해 액세스되는 메소드가있을 수 있습니다 . Relay는 컨테이너에 이러한 구성 요소 인스턴스를 작성하므로 &lt;code&gt;componentRef&lt;/code&gt; 소품을 사용하여 액세스해야합니다.</target>
        </trans-unit>
        <trans-unit id="4414b37377cdce419545fa9b20f3ee40db7ae79f" translate="yes" xml:space="preserve">
          <source>Reading From Cache</source>
          <target state="translated">캐시에서 읽기</target>
        </trans-unit>
        <trans-unit id="65ef251f859a908e6a35bac8ecaf436651601f86" translate="yes" xml:space="preserve">
          <source>Reads the value of an attribute on a record by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">필드 이름과 사전 정의 된 인수 값을 나타내는 객체로 레코드의 속성 값을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="e3c57930509c5101e93fa1b560decb910e955968" translate="yes" xml:space="preserve">
          <source>Ready State</source>
          <target state="translated">준비 상태</target>
        </trans-unit>
        <trans-unit id="e276b1dc6fd5b2e2feab8b52644788511fadacad" translate="yes" xml:space="preserve">
          <source>Ready State Change</source>
          <target state="translated">준비 상태 변경</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="a3c412dd10a0e8cb0c1899aa86989fec9f2b0413" translate="yes" xml:space="preserve">
          <source>RefetchContainer</source>
          <target state="translated">RefetchContainer</target>
        </trans-unit>
        <trans-unit id="638e5005315e0cabef699577f78933ca4cc7db6a" translate="yes" xml:space="preserve">
          <source>Refetching Data (aka &quot;See More&quot;)</source>
          <target state="translated">데이터 반입 (일명 &quot;추가 정보&quot;)</target>
        </trans-unit>
        <trans-unit id="47f437a4450523abebb9b8a6327af806c6dfe250" translate="yes" xml:space="preserve">
          <source>Related APIs</source>
          <target state="translated">관련 API</target>
        </trans-unit>
        <trans-unit id="9f537f977fa2ecd1f91ff057ce1667e98ab04729" translate="yes" xml:space="preserve">
          <source>Relay</source>
          <target state="translated">Relay</target>
        </trans-unit>
        <trans-unit id="88dd507e8359bb2fd7a7702cfdc9ffaecb218c8a" translate="yes" xml:space="preserve">
          <source>Relay Classic API</source>
          <target state="translated">릴레이 클래식 API</target>
        </trans-unit>
        <trans-unit id="d6764a98d68a0f585f067a880fb7f047e42e5295" translate="yes" xml:space="preserve">
          <source>Relay Classic Guides</source>
          <target state="translated">릴레이 클래식 가이드</target>
        </trans-unit>
        <trans-unit id="aef721f4de8f071bed34bec165e9e8e9422d904c" translate="yes" xml:space="preserve">
          <source>Relay Classic Interfaces</source>
          <target state="translated">릴레이 클래식 인터페이스</target>
        </trans-unit>
        <trans-unit id="8ee884f2695bfbad6a7a6dae4d48bf3348965934" translate="yes" xml:space="preserve">
          <source>Relay Compat</source>
          <target state="translated">릴레이 Compat</target>
        </trans-unit>
        <trans-unit id="c546e3c1729605fb70a2db1deb7870608f3445c7" translate="yes" xml:space="preserve">
          <source>Relay Compat is part of &lt;code&gt;'react-relay'&lt;/code&gt; which allows you to do exactly this, providing an identical API to Relay Modern, while allowing interoperability with both runtimes.</source>
          <target state="translated">Relay Compat은 &lt;code&gt;'react-relay'&lt;/code&gt; 의 일부로 , 정확하게이를 수행 할 수있게함으로써 Relay Modern과 동일한 API를 제공하면서 두 런타임과의 상호 운용성을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="ddef7758830f719ed90adce373f8f83b9acf721d" translate="yes" xml:space="preserve">
          <source>Relay Compiler</source>
          <target state="translated">릴레이 컴파일러</target>
        </trans-unit>
        <trans-unit id="be2b89d58206687eafd6b5f1f94bb37fb0baa8fb" translate="yes" xml:space="preserve">
          <source>Relay Containers</source>
          <target state="translated">릴레이 컨테이너</target>
        </trans-unit>
        <trans-unit id="e0d9a631ef93e7ccb54370c0af336f421599b386" translate="yes" xml:space="preserve">
          <source>Relay DevTools is tool designed to help developers inspect their Relay state and understand how store changes overtime. Relay DevTools ships in two ways:</source>
          <target state="translated">Relay DevTools는 개발자가 릴레이 상태를 검사하고 시간이 지남에 따라 상점 변경을 이해하도록 돕기 위해 설계된 도구입니다. Relay DevTools는 두 가지 방법으로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="426c398ee54f1b774dac3a903f0125ae20a5c9e6" translate="yes" xml:space="preserve">
          <source>Relay Documentation</source>
          <target state="translated">릴레이 문서</target>
        </trans-unit>
        <trans-unit id="1443cd7ff63d89730c443bd7786d90a6df7d1998" translate="yes" xml:space="preserve">
          <source>Relay Environment</source>
          <target state="translated">릴레이 환경</target>
        </trans-unit>
        <trans-unit id="d699ddf70a567d16a64d34cd746d0cc2172e4ec9" translate="yes" xml:space="preserve">
          <source>Relay Modern</source>
          <target state="translated">현대 릴레이</target>
        </trans-unit>
        <trans-unit id="125aa7abbb0a0bc142817f98c7e32cd828f1f474" translate="yes" xml:space="preserve">
          <source>Relay Modern comes with automatic Flow type generation for the fragments used in Relay containers based on the GraphQL schema. Using these Flow types can help make an application less error-prone, by ensuring all possible &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;undefined&lt;/code&gt; cases are considered even if they don't happen frequently.</source>
          <target state="translated">Relay Modern은 GraphQL 스키마를 기반으로 릴레이 컨테이너에 사용되는 프래그먼트에 대해 자동 흐름 유형 생성 기능을 제공합니다. 이러한 흐름 유형을 사용하면 발생 가능한 모든 &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 사례가 자주 발생하지 않더라도 고려 되도록하여 응용 프로그램에서 오류 발생 가능성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="fe351802f53838c0d3ff7ec944643ab9992b7020" translate="yes" xml:space="preserve">
          <source>Relay Modern containers combine standard React components with a description of their data requirements, expressed as one or more GraphQL fragments. Each container is itself a standard React component that can be rendered using the standard React API (e.g. &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt;). When rendered, a container will read the data for its fragment from the Relay cache. As the fragment data changes - for example due to a mutation, subscription, or updated query response - the container will automatically re-render the component.</source>
          <target state="translated">계전기 현대 컨테이너는 표준 React 구성 요소를 하나 이상의 GraphQL 조각으로 표현 된 데이터 요구 사항에 대한 설명과 결합합니다. 각 컨테이너 자체는 표준 React API를 사용하여 렌더링 할 수있는 표준 React 구성 요소입니다 (예 : &lt;code&gt;&amp;lt;YourComponent prop={...} /&amp;gt;&lt;/code&gt; ). 렌더링 될 때 컨테이너는 릴레이 캐시에서 해당 조각에 대한 데이터를 읽습니다. 예를 들어 돌연변이, 구독 또는 업데이트 된 쿼리 응답으로 인해 조각 데이터가 변경되면 컨테이너는 구성 요소를 자동으로 다시 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="b783df53e509475b97db41df7f512b5cdf7adf0d" translate="yes" xml:space="preserve">
          <source>Relay Modern enables a variety of new features. Some are available via the Compat API, while others require upgrading fully to the Modern runtime. See &lt;a href=&quot;new-in-relay-modern&quot;&gt;what's new in Relay Modern&lt;/a&gt; for more details.</source>
          <target state="translated">Relay Modern은 다양한 새로운 기능을 가능하게합니다. 일부는 Compat API를 통해 사용 가능하지만 다른 일부는 최신 런타임으로 완전히 업그레이드해야합니다. 자세한 &lt;a href=&quot;new-in-relay-modern&quot;&gt;내용은 Relay Modern의 새로운 기능&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="02ee7840306dae496dace1fe86750e32e8b8c807" translate="yes" xml:space="preserve">
          <source>Relay Modern is a new version of Relay designed from the ground up to be easier to use, more extensible and, most of all, able to improve performance on mobile devices. Relay Modern accomplishes this with static queries and ahead-of-time code generation.</source>
          <target state="translated">Relay Modern은 처음부터 사용하기 쉽고, 확장 가능하며, 무엇보다도 모바일 장치의 성능을 향상시킬 수 있도록 설계된 새로운 버전의 Relay입니다. Relay Modern은 정적 쿼리와 사전 코드 생성을 통해이를 달성합니다.</target>
        </trans-unit>
        <trans-unit id="451008aa294b51a951e1a6a9073f36b4296c782c" translate="yes" xml:space="preserve">
          <source>Relay Modern requires a Babel plugin to convert GraphQL to runtime artifacts:</source>
          <target state="translated">Relay Modern은 GraphQL을 런타임 아티팩트로 변환하려면 Babel 플러그인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0d2944c329394a1cfc563059eabe3a8681e7e2bc" translate="yes" xml:space="preserve">
          <source>Relay Modern supports GraphQL Subscriptions, using the imperative update API to allow modifications to the store whenever a payload is received. It also features experimental support for GraphQL Live Queries via polling.</source>
          <target state="translated">Relay Modern은 명령 업데이트 API를 사용하여 페이로드가 수신 될 때마다 상점을 수정할 수 있도록하는 GraphQL 구독을 지원합니다. 또한 폴링을 통한 GraphQL 라이브 쿼리에 대한 실험 지원 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="372f8f866ff79038477865a8b1e68cc2436d4212" translate="yes" xml:space="preserve">
          <source>Relay Modern supports the following directives</source>
          <target state="translated">Relay Modern은 다음 지시문을 지원합니다</target>
        </trans-unit>
        <trans-unit id="4fcb24b9dcd43c8532db4d056e1af150670c742a" translate="yes" xml:space="preserve">
          <source>Relay Modern uses the Relay Compiler to convert &lt;code&gt;graphql&lt;/code&gt; literals into generated files that live alongside your source files.</source>
          <target state="translated">Relay Modern은 Relay Compiler를 사용하여 &lt;code&gt;graphql&lt;/code&gt; 리터럴을 소스 파일과 함께 존재하는 생성 된 파일로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="604519e05335c47d085692b3d5c93c6c0cf24a81" translate="yes" xml:space="preserve">
          <source>Relay Modern's ahead-of-time compilation requires the new Relay Compiler:</source>
          <target state="translated">Relay Modern의 사전 컴파일에는 새로운 릴레이 컴파일러가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d344ad7e0e46f9326c5126f3f06dc4800f23f6c8" translate="yes" xml:space="preserve">
          <source>Relay Modern's core is essentially an un-opinionated store for GraphQL data. It can be used independent of rendering views using React and can be extended to be used with other frameworks.</source>
          <target state="translated">Relay Modern의 핵심은 본질적으로 GraphQL 데이터를위한 비 소위 저장소입니다. React를 사용하여 렌더링 뷰와 독립적으로 사용할 수 있으며 다른 프레임 워크와 함께 사용하도록 확장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="881bc62d6225c769dfa7c14c7288aba40be25da2" translate="yes" xml:space="preserve">
          <source>Relay Specification</source>
          <target state="translated">릴레이 사양</target>
        </trans-unit>
        <trans-unit id="48799f13f2ac51d5720b5a4e683e4a8844cdd877" translate="yes" xml:space="preserve">
          <source>Relay allows developers to annotate their React components with data dependencies by creating &lt;strong&gt;containers&lt;/strong&gt;. These are regular React components that wrap the originals. A key design constraint is that React components are meant to be reusable, so Relay containers must be too. For example, a &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; component might implement a view for rendering any &lt;code&gt;Story&lt;/code&gt; item. The actual story to render would be determined by the data passed to the component: &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt;. The equivalent in GraphQL are &lt;strong&gt;fragments&lt;/strong&gt;: named query snippets that specify what data to fetch &lt;em&gt;for an object of a given type&lt;/em&gt;. We might describe the data needed by &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">개발자는 릴레이를 통해 &lt;strong&gt;컨테이너&lt;/strong&gt; 를 생성하여 데이터 종속성으로 React 구성 요소에 주석을 달 수 있습니다 . 이것들은 원본을 감싸는 일반적인 React 구성 요소입니다. 주요 설계 제약은 React 구성 요소를 재사용 할 수 있어야하므로 릴레이 컨테이너도 사용해야한다는 것입니다. 예를 들어 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 구성 요소는 &lt;code&gt;Story&lt;/code&gt; 항목 을 렌더링하기위한보기를 구현할 수 있습니다 . 렌더링 할 실제 스토리는 &lt;code&gt;&amp;lt;Story story={ ... } /&amp;gt;&lt;/code&gt; 구성 요소에 전달 된 데이터에 의해 결정됩니다 . GraphQL과 동등한 것은 &lt;strong&gt;프래그먼트&lt;/strong&gt; 들이다 : &lt;em&gt;주어진 타입의 객체에 대해&lt;/em&gt; 어떤 데이터를 가져올 지 지정하는 명명 된 쿼리 스 니펫 . &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 에 필요한 데이터 를 다음과 같이 설명 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="254c939fb761720339a3dd3ad863697bebf60c3f" translate="yes" xml:space="preserve">
          <source>Relay also goes further: it uses opaque identifiers on &lt;code&gt;props&lt;/code&gt; to validate that we've explicitly fetched the data for a component before rendering it. If &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; renders &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; but forgets to include its fragment, Relay will warn that the data for &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; is missing. In fact, Relay will warn &lt;em&gt;even if&lt;/em&gt; some other component happened to fetch the same data required by &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt;. This warning tells us that although things &lt;em&gt;might&lt;/em&gt; work now they're highly likely to break later.</source>
          <target state="translated">또한 릴레이는 더 나아가서 &lt;code&gt;props&lt;/code&gt; 에 불투명 한 식별자를 사용 하여 렌더링하기 전에 구성 요소의 데이터를 명시 적으로 가져 왔는지 확인합니다. 경우 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 렌더링 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 그러나 잊어 그 단편을 포함하는, 릴레이의 데이터 것을 경고한다 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 없습니다. 실제로, 다른 구성 요소가 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 에 필요한 동일한 데이터를 가져 &lt;em&gt;오더라도&lt;/em&gt; Relay는 경고 &lt;em&gt;를 표시합니다&lt;/em&gt; . 이 경고는 현재 작동 &lt;em&gt;할 수&lt;/em&gt; 있지만 나중에 중단 될 가능성이 높다는 것을 나타냅니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c212579d453e98cbd0a4dcbacffef8088e5ab28f" translate="yes" xml:space="preserve">
          <source>Relay also lets us completely replace the default network layer.</source>
          <target state="translated">릴레이는 또한 기본 네트워크 계층을 완전히 대체 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="f200764a518868ca3b31ea98a1353b5d9f2dd1fc" translate="yes" xml:space="preserve">
          <source>Relay can be thought of as two parts which work together: an API for building data-driven components and a runtime which fetches and stores data from GraphQL to populate your app. Relay Modern brings both a new API and a new runtime.</source>
          <target state="translated">릴레이는 함께 작동하는 두 부분으로 생각할 수 있습니다. 데이터 중심 구성 요소를 빌드하기위한 API와 GraphQL에서 데이터를 가져와 저장하여 앱을 채우는 런타임입니다. Relay Modern은 새로운 API와 새로운 런타임을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="edc443fe11fe9992f4eb82855f77153b4705147b" translate="yes" xml:space="preserve">
          <source>Relay containers are created using &lt;code&gt;Relay.createContainer&lt;/code&gt;.</source>
          <target state="translated">릴레이 컨테이너는 &lt;code&gt;Relay.createContainer&lt;/code&gt; 를 사용하여 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="2748ac007f286936a91fb67b3ca6e11462a7fe21" translate="yes" xml:space="preserve">
          <source>Relay containers are higher-order components &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; is a function that takes a React component as input and returns a new component as output. This means that the container can manage data fetching and resolution logic without interfering with the &lt;code&gt;state&lt;/code&gt; of the inner component.</source>
          <target state="translated">릴레이 컨테이너는 상위 컴포넌트입니다. &amp;mdash; &lt;code&gt;Relay.createContainer&lt;/code&gt; 는 React 컴포넌트를 입력으로 사용하고 새 컴포넌트를 출력으로 리턴하는 함수입니다. 이는 컨테이너가 내부 구성 요소 의 &lt;code&gt;state&lt;/code&gt; 를 방해하지 않고 데이터 페치 및 분석 로직을 관리 할 수 ​​있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="1c357d13b1cce8a1c46ccc30afeeb5fd2f902c5a" translate="yes" xml:space="preserve">
          <source>Relay containers provide a static &lt;code&gt;getFragment()&lt;/code&gt; method that returns a reference to that component's fragment:</source>
          <target state="translated">릴레이 컨테이너는 해당 컴포넌트의 단편에 대한 참조를 리턴 하는 정적 &lt;code&gt;getFragment()&lt;/code&gt; 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5a410cc37e6396592aa37827cec122428cb2d984" translate="yes" xml:space="preserve">
          <source>Relay couples React with GraphQL and develops the idea of encapsulation further. It allows components to specify what data they need and the Relay framework provides the data. This makes the data needs of inner components opaque and allows composition of those needs. Thinking about what data an app needs becomes localized to the component making it easier to reason about what fields are needed or no longer needed.</source>
          <target state="translated">릴레이 커플 링은 GraphQL과 반응하고 캡슐화 아이디어를 더욱 발전시킵니다. 구성 요소가 필요한 데이터를 지정하고 릴레이 프레임 워크가 데이터를 제공 할 수 있습니다. 이것은 내부 구성 요소의 데이터 요구를 불투명하게하고 그 요구를 구성 할 수있게합니다. 앱에 필요한 데이터에 대해 생각하면 구성 요소에 맞게 현지화되므로 어떤 필드가 필요하거나 더 이상 필요하지 않은지 쉽게 추론 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="934fd827600b774b11b92dcf9269d690870fb9bb" translate="yes" xml:space="preserve">
          <source>Relay ensures that this data is available before the component is rendered.</source>
          <target state="translated">릴레이는 구성 요소를 렌더링하기 전에이 데이터를 사용할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="b556a8542493c85c6ab714e7efdb1e48fb0c7ece" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to create subscriptions.</source>
          <target state="translated">릴레이는 다음 API를 노출하여 구독을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8076714ed2f663c62d9c70223ceef029bffc6fc4" translate="yes" xml:space="preserve">
          <source>Relay exposes the following APIs to perform mutations.</source>
          <target state="translated">Relay는 다음 API를 노출시켜 돌연변이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9a9f6b192104115130a465f5d1b347425625bd6d" translate="yes" xml:space="preserve">
          <source>Relay fragments, mutations, and queries must be specified using ES6 template literals tagged with &lt;code&gt;Relay.QL&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;Relay.QL&lt;/code&gt; 태그가 지정된 ES6 템플릿 리터럴을 사용하여 릴레이 조각, 돌연변이 및 쿼리를 지정해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f94ab02e4b36f1c69a9b192786b3451a5578f530" translate="yes" xml:space="preserve">
          <source>Relay has a network layer abstraction that separates mutations and queries from the actual machinery that sends requests to the GraphQL server. This gives us the flexibility to configure or even completely replace the default network layer via injection.</source>
          <target state="translated">릴레이에는 요청과 GraphQL 서버로 전송하는 실제 기계에서 돌연변이와 쿼리를 분리하는 네트워크 계층 추상화가 있습니다. 이는 주입을 통해 기본 네트워크 계층을 구성하거나 완전히 대체 할 수있는 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3e093a4c47e1f292b6f2a4693a9f28a6e839881f" translate="yes" xml:space="preserve">
          <source>Relay implements several variations of &lt;strong&gt;query traversal&lt;/strong&gt;: operations that walk a query alongside some other data such as the cache or a response payload. For example, when a query is fetched Relay performs a &quot;diff&quot; traversal to determine what fields are missing (much like React diffs virtual DOM trees). This can reduce the amount of data fetched in many common cases and even allow Relay to avoid network requests at all when queries are fully cached.</source>
          <target state="translated">릴레이 는 캐시 또는 응답 페이로드와 같은 다른 데이터와 함께 &lt;strong&gt;쿼리를 이동&lt;/strong&gt; 하는 여러 가지 &lt;strong&gt;쿼리 탐색&lt;/strong&gt; : 변형을 구현 합니다. 예를 들어, 쿼리가 페치 될 때 릴레이는 &quot;diff&quot;순회를 수행하여 누락 된 필드를 판별합니다 (React가 가상 DOM 트리와 다름). 이렇게하면 많은 경우에 페치되는 데이터 양이 줄어들고 쿼리가 완전히 캐시 될 때 릴레이가 네트워크 요청을 전혀 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f7225f6558a177e37be9ba84410fe63b32cde06" translate="yes" xml:space="preserve">
          <source>Relay introduces two new classes of objects: &lt;code&gt;RelayContainer&lt;/code&gt; and &lt;code&gt;Relay.Route&lt;/code&gt;. &lt;code&gt;Relay.PropTypes&lt;/code&gt; provides prop validators used to assert that props are of these types.</source>
          <target state="translated">Relay는 두 가지 새로운 클래스의 객체를 소개합니다 : &lt;code&gt;RelayContainer&lt;/code&gt; 및 &lt;code&gt;Relay.Route&lt;/code&gt; . &lt;code&gt;Relay.PropTypes&lt;/code&gt; 는 소품이 이러한 유형임을 주장하는 데 사용되는 소품 유효성 검사기를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="97f52c1bbd17e02a2c6367d7476a6ac21c258276" translate="yes" xml:space="preserve">
          <source>Relay is pre-configured to use a default network layer that works with &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt;. This default network layer is exposed via &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt;.</source>
          <target state="translated">릴레이는 &lt;a href=&quot;https://github.com/graphql/express-graphql&quot;&gt;express-graphql&lt;/a&gt; 과 함께 작동하는 기본 네트워크 계층을 사용하도록 미리 구성되어 있습니다 . 이 기본 네트워크 계층은 &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 를 통해 노출됩니다 .</target>
        </trans-unit>
        <trans-unit id="54171fd2fa20a9c4bec1be11d3879a92bfa7df55" translate="yes" xml:space="preserve">
          <source>Relay makes use of GraphQL mutations; operations that enable us to mutate data on the client and server. To create a mutation for use in our app, we subclass &lt;code&gt;Relay.Mutation&lt;/code&gt; and implement, at minimum, the four abstract methods listed below.</source>
          <target state="translated">계전기는 GraphQL 돌연변이를 사용합니다. 클라이언트와 서버의 데이터를 변경하는 작업 앱에서 사용할 돌연변이를 만들기 위해 &lt;code&gt;Relay.Mutation&lt;/code&gt; 을 서브 클래 싱 하고 최소한 아래 나열된 네 가지 추상 메서드를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8dd31c1805e052611332ba16c37162381a4a626a" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig.</source>
          <target state="translated">릴레이 라우트는 실제로 URL 라우팅 특정 로직을 구현하거나 History API를 사용하지 않습니다. 앞으로 RelayRoute의 이름을 RelayQueryRoots 또는 RelayQueryConfig로 바꿀 것입니다.</target>
        </trans-unit>
        <trans-unit id="589e99096a0b6781ff51073c2234321dc486a027" translate="yes" xml:space="preserve">
          <source>Relay routes don't really implement any URL routing specific logic or work with History API. In the future we will maybe rename RelayRoute to be something more like RelayQueryRoots or RelayQueryConfig. For more information around why Relay doesn't provide URL-routing features, and suggestions for such solutions, see &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;this post&lt;/a&gt;.</source>
          <target state="translated">릴레이 라우트는 실제로 URL 라우팅 특정 로직을 구현하지 않거나 History API와 함께 작동하지 않습니다. 앞으로 RelayRoute의 이름을 RelayQueryRoots 또는 RelayQueryConfig로 바꿀 것입니다. Relay가 URL 라우팅 기능을 제공하지 않는 이유와 이러한 솔루션에 대한 제안 사항에 대한 자세한 내용은 &lt;a href=&quot;https://medium.com/@cpojer/relay-and-routing-36b5439bad9&quot;&gt;이 게시물을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef480060aa47ef1a958a5c003bdd30a4e3354405" translate="yes" xml:space="preserve">
          <source>Relay speaks to GraphQL servers through a network layer. The &lt;a href=&quot;guides-network-layer&quot;&gt;network layer&lt;/a&gt; that ships with Relay is compatible with express-graphql out of the box, and will continue to evolve as we add new features to the transport.</source>
          <target state="translated">릴레이는 네트워크 계층을 통해 GraphQL 서버와 통신합니다. Relay와 함께 제공 되는 &lt;a href=&quot;guides-network-layer&quot;&gt;네트워크 계층&lt;/a&gt; 은 기본적으로 express-graphql과 호환되며 전송에 새로운 기능을 추가함에 따라 계속 발전 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="256546be326de4c5533a50332088277d259f1856" translate="yes" xml:space="preserve">
          <source>Relay updates the component whenever the underlying data has changed.</source>
          <target state="translated">릴레이는 기본 데이터가 변경 될 때마다 구성 요소를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="7f2f7458912547fdfa17a726b3bd42f898c10724" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;Babel&lt;/strong&gt; plugin to convert &lt;code&gt;graphql&lt;/code&gt; literals into requires of the code generated by Relay Compiler.</source>
          <target state="translated">Relay는 &lt;strong&gt;Babel&lt;/strong&gt; 플러그인을 사용하여 &lt;code&gt;graphql&lt;/code&gt; 리터럴을 Relay Compiler가 생성 한 코드 요구 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="9cbd2a4fac093602e7724812345c1426293f1cd9" translate="yes" xml:space="preserve">
          <source>Relay uses a &lt;strong&gt;babel&lt;/strong&gt; plugin to convert from &lt;code&gt;Relay.QL&lt;/code&gt; string templates to JavaScript code that describes each query and includes data from the GraphQL schema.</source>
          <target state="translated">Relay는 &lt;strong&gt;babel&lt;/strong&gt; 플러그인을 사용하여 &lt;code&gt;Relay.QL&lt;/code&gt; 문자열 템플릿에서 각 쿼리를 설명하고 GraphQL 스키마의 데이터를 포함하는 JavaScript 코드 로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="5ab5569c1247a6342fa21f23bd4fe7b1d8d672c4" translate="yes" xml:space="preserve">
          <source>Relay uses a common pattern for mutations, where they are root fields on the mutation type with a single argument, &lt;code&gt;input&lt;/code&gt;, and where the input and output both contain a client mutation identifier used to reconcile requests and responses.</source>
          <target state="translated">릴레이는 돌연변이에 공통 패턴을 사용합니다. 여기서 돌연변이는 단일 인수 인 &lt;code&gt;input&lt;/code&gt; 이 포함 된 돌연변이 유형의 루트 필드 이며 입력 및 출력에는 모두 요청 및 응답을 조정하는 데 사용되는 클라이언트 돌연변이 식별자가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd4a65f25979a2d6ac22ff73e832b56882a6731f" translate="yes" xml:space="preserve">
          <source>Relay uses all of this functionality to build out abstractions around connections, to make these easy to work with efficiently without having to manually manage cursors on the client.</source>
          <target state="translated">릴레이는이 기능을 모두 사용하여 연결에 대한 추상화를 작성하므로 클라이언트에서 커서를 수동으로 관리하지 않고도 효율적으로 작업 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7215a332ba837f6189ba19038b406a179e835435" translate="yes" xml:space="preserve">
          <source>Relay uses routes to define entry points into a Relay application.</source>
          <target state="translated">릴레이는 경로를 사용하여 릴레이 응용 프로그램에 진입 점을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="e84f12bb76c08fcf1ebc1d56caf39b1024a1f70b" translate="yes" xml:space="preserve">
          <source>Relay v1.0 introduces the Relay Modern API:</source>
          <target state="translated">Relay v1.0에는 Relay Modern API가 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="7c3c5e271e633d2cf5f26344b18759ea44b95380" translate="yes" xml:space="preserve">
          <source>Relay wraps its core processing functions inside lightweight tasks, which by default are executed immediately (i.e. synchronously). In order to customize &lt;em&gt;when&lt;/em&gt; these tasks are run - for example to avoid interrupting an animation during a touch gesture - applications can provide a custom scheduling function.</source>
          <target state="translated">릴레이는 핵심 작업 기능을 가벼운 작업에 포함 시키며 기본적으로 즉시 (즉, 동 기적으로) 실행됩니다. 터치 제스처 중 애니메이션 중단을 방지하기 위해 이러한 작업이 실행되는 &lt;em&gt;시기&lt;/em&gt; 를 사용자 지정 하기 위해 응용 프로그램은 사용자 지정 예약 기능을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576baa5c970e0023c6b7f930fc5b22d07e80b876" translate="yes" xml:space="preserve">
          <source>Relay's approach to data-fetching is heavily inspired by our experience with React. In particular, React breaks complex interfaces into reusable &lt;strong&gt;components&lt;/strong&gt;, allowing developers to reason about discrete units of an application in isolation, and reducing the coupling between disparate parts of an application. Even more important is that these components are &lt;strong&gt;declarative&lt;/strong&gt;: they allow developers to specify &lt;em&gt;what&lt;/em&gt; the UI should look like for a given state, and not have to worry about &lt;em&gt;how&lt;/em&gt; to show that UI. Unlike previous approaches that used imperative commands to manipulate native views (e.g. the DOM), React uses a UI description to automatically determine the necessary commands.</source>
          <target state="translated">데이터 가져 오기에 대한 Relay의 접근 방식은 React에 대한 우리의 경험에서 많은 영감을 얻었습니다. 특히 React는 복잡한 인터페이스를 재사용 가능한 &lt;strong&gt;구성 요소&lt;/strong&gt; 로 분리하여 개발자가 개별 응용 프로그램 단위를 따로 추론하고 응용 프로그램의 개별 부분 간의 연결을 줄입니다. 더 중요한 것은 이러한 구성 요소가 &lt;strong&gt;선언적이라는 것입니다&lt;/strong&gt; . 즉, 개발자가 특정 상태에 대해 UI가 표시 될 모양 을 지정 &lt;em&gt;하고&lt;/em&gt; 해당 UI 를 표시하는 &lt;em&gt;방법&lt;/em&gt; 에 대해 걱정할 필요가 없습니다 . 네이티브 명령 (예 : DOM)을 조작하기 위해 명령형 명령을 사용한 이전의 접근 방식과 달리 React는 UI 설명을 사용하여 필요한 명령을 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6b33d0db31f7976b67c0c833688c3f1a2f3ed1a7" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation</source>
          <target state="translated">Relay.GraphQLMutation</target>
        </trans-unit>
        <trans-unit id="1dd1eeecd4591e6fc51ed50ccec4372072ef5f58" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#applyOptimistic()</source>
          <target state="translated">Relay.GraphQLMutation#applyOptimistic()</target>
        </trans-unit>
        <trans-unit id="778c7e41e609c680486529c141869bd60529ad4f" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#commit()</source>
          <target state="translated">Relay.GraphQLMutation#commit()</target>
        </trans-unit>
        <trans-unit id="3dd83b3b4baca74ae215635dc8057361bd27c698" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#constructor()</source>
          <target state="translated">Relay.GraphQLMutation#constructor()</target>
        </trans-unit>
        <trans-unit id="c60b9c934ff71ffb2a3ed3d72c60871bbe0e468e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation#rollback()</source>
          <target state="translated">Relay.GraphQLMutation#rollback()</target>
        </trans-unit>
        <trans-unit id="3340870222c54d4e58da2c45216a0f9201d39a18" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.create()</source>
          <target state="translated">Relay.GraphQLMutation.create()</target>
        </trans-unit>
        <trans-unit id="a23c2d405f689b19dfd1fd7c28df5c48a68add1e" translate="yes" xml:space="preserve">
          <source>Relay.GraphQLMutation.createWithFiles()</source>
          <target state="translated">Relay.GraphQLMutation.createWithFiles()</target>
        </trans-unit>
        <trans-unit id="03551f79ebf3cd05d7c2ceaa3bea55c92b64e6d0" translate="yes" xml:space="preserve">
          <source>Relay.Mutation</source>
          <target state="translated">Relay.Mutation</target>
        </trans-unit>
        <trans-unit id="3ba32adda774e85164beb595e60d2e216978176e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#constructor()</source>
          <target state="translated">Relay.Mutation#constructor()</target>
        </trans-unit>
        <trans-unit id="04100c1f256b9742428fc3ccbb91ce26474f7916" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getCollisionKey()</source>
          <target state="translated">Relay.Mutation#getCollisionKey()</target>
        </trans-unit>
        <trans-unit id="6239b4b0c4bd148ddc88ff80a2414323538280f1" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getConfigs()</source>
          <target state="translated">Relay.Mutation#getConfigs()</target>
        </trans-unit>
        <trans-unit id="ef63d6cc19f0b592de123cd60ec1e1b1998d6f17" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFatQuery()</source>
          <target state="translated">Relay.Mutation#getFatQuery()</target>
        </trans-unit>
        <trans-unit id="712207e70740181f3ab2120dc0f2bcc301c5f54e" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getFiles()</source>
          <target state="translated">Relay.Mutation#getFiles()</target>
        </trans-unit>
        <trans-unit id="e97a189b3ae9338d83696e14598b587f01455562" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getMutation()</source>
          <target state="translated">Relay.Mutation#getMutation()</target>
        </trans-unit>
        <trans-unit id="9ef4e47c4ce8d138fc8484b73b762f8325ab6d50" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticConfigs()</source>
          <target state="translated">Relay.Mutation#getOptimisticConfigs()</target>
        </trans-unit>
        <trans-unit id="9c72c0ca95feabd409adccf873cc396f84f49fa7" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getOptimisticResponse()</source>
          <target state="translated">Relay.Mutation#getOptimisticResponse()</target>
        </trans-unit>
        <trans-unit id="0407ffada104593511af47973fbf4f161321629f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation#getVariables()</source>
          <target state="translated">Relay.Mutation#getVariables()</target>
        </trans-unit>
        <trans-unit id="25241731d9b8a5e3bb893a8a7166ea0d07b29738" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.fragments</source>
          <target state="translated">Relay.Mutation.fragments</target>
        </trans-unit>
        <trans-unit id="b7852fe98838e6fc1d72feab70dfa349933b9a4f" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.getFragment()</source>
          <target state="translated">Relay.Mutation.getFragment()</target>
        </trans-unit>
        <trans-unit id="d9618c47616902c437879ab1fb98a8eb932feeeb" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.initialVariables</source>
          <target state="translated">Relay.Mutation.initialVariables</target>
        </trans-unit>
        <trans-unit id="88607afefb79afbc0a5c6c2204c3c59784086c6d" translate="yes" xml:space="preserve">
          <source>Relay.Mutation.prepareVariables</source>
          <target state="translated">Relay.Mutation.prepareVariables</target>
        </trans-unit>
        <trans-unit id="15cdd01f7f3228bf705c67fcca4cc7376e38847b" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes</source>
          <target state="translated">Relay.PropTypes</target>
        </trans-unit>
        <trans-unit id="0af8bcf2b06b250091c5a6a9f45a93a8ec335270" translate="yes" xml:space="preserve">
          <source>Relay.PropTypes.QueryConfig: ReactPropTypeValidator</source>
          <target state="translated">Relay.PropTypes.QueryConfig : ReactPropTypeValidator</target>
        </trans-unit>
        <trans-unit id="991536fff9faf615e80c1b42bfda61b3395074a1" translate="yes" xml:space="preserve">
          <source>Relay.QL</source>
          <target state="translated">Relay.QL</target>
        </trans-unit>
        <trans-unit id="e66127f684a064c2b23590835fd5fc4afce5e3bc" translate="yes" xml:space="preserve">
          <source>Relay.Renderer</source>
          <target state="translated">Relay.Renderer</target>
        </trans-unit>
        <trans-unit id="1e64d297283159c1fd5f3c0f4f7f2590f52aeaf0" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#Container</source>
          <target state="translated">Relay.Renderer#Container</target>
        </trans-unit>
        <trans-unit id="0f68d914b2de005998fdb01ba1b1095a495e227d" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#environment</source>
          <target state="translated">Relay.Renderer#environment</target>
        </trans-unit>
        <trans-unit id="8e4cc916528c14e528833e3f79df2da75fd53acb" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#forceFetch</source>
          <target state="translated">Relay.Renderer#forceFetch</target>
        </trans-unit>
        <trans-unit id="bf0a7bc1a436c9a32f0f42831033b65d5cfbaf43" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#onReadyStateChange</source>
          <target state="translated">Relay.Renderer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="9c4d750f130c80ae940ddef73d72538928767978" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#queryConfig</source>
          <target state="translated">Relay.Renderer#queryConfig</target>
        </trans-unit>
        <trans-unit id="ff227ea702919a6f75cb559ade588c7d11c20c78" translate="yes" xml:space="preserve">
          <source>Relay.Renderer#render</source>
          <target state="translated">Relay.Renderer#render</target>
        </trans-unit>
        <trans-unit id="2761fdabd570b4cb3fdee157bed2ad5cb9ae4930" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer</source>
          <target state="translated">Relay.RootContainer</target>
        </trans-unit>
        <trans-unit id="543cce18705fbddda91e09c015e6da78c821e550" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#Component</source>
          <target state="translated">Relay.RootContainer#Component</target>
        </trans-unit>
        <trans-unit id="4c1d8599b11aa80027feab65c33b5f34aece2fe8" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#forceFetch</source>
          <target state="translated">Relay.RootContainer#forceFetch</target>
        </trans-unit>
        <trans-unit id="69120820a45037f7a9e51a705842b61000d0ac96" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#onReadyStateChange</source>
          <target state="translated">Relay.RootContainer#onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="0b9faeb15a496f220a6b405a981a20f8ef453965" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFailure</source>
          <target state="translated">Relay.RootContainer#renderFailure</target>
        </trans-unit>
        <trans-unit id="7bd3ce353967f7aff355ff3522f40b703a8bd047" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderFetched</source>
          <target state="translated">Relay.RootContainer#renderFetched</target>
        </trans-unit>
        <trans-unit id="8e6dba1eefc9476de73a3eb76f6a4bb45f2d9827" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#renderLoading</source>
          <target state="translated">Relay.RootContainer#renderLoading</target>
        </trans-unit>
        <trans-unit id="a9647a1d13d1b00fb81a049cb69e0f50d9005610" translate="yes" xml:space="preserve">
          <source>Relay.RootContainer#route</source>
          <target state="translated">Relay.RootContainer#route</target>
        </trans-unit>
        <trans-unit id="2163890d6b8486ab713e8307739f1fc8ffdc4051" translate="yes" xml:space="preserve">
          <source>Relay.Route</source>
          <target state="translated">Relay.Route</target>
        </trans-unit>
        <trans-unit id="ec4ec0225d1b12f051db712106148d8b26db80c7" translate="yes" xml:space="preserve">
          <source>Relay.Route#constructor()</source>
          <target state="translated">Relay.Route#constructor()</target>
        </trans-unit>
        <trans-unit id="933d2afe910e8eed75954f1ef8511fc9c8104ede" translate="yes" xml:space="preserve">
          <source>Relay.Route.paramDefinitions</source>
          <target state="translated">Relay.Route.paramDefinitions</target>
        </trans-unit>
        <trans-unit id="be2c5425ec7dbd5886d4716f82a79360b73375a7" translate="yes" xml:space="preserve">
          <source>Relay.Route.prepareParams</source>
          <target state="translated">Relay.Route.prepareParams</target>
        </trans-unit>
        <trans-unit id="632587b7cd190cd1537600ee207e20b1ff9030d5" translate="yes" xml:space="preserve">
          <source>Relay.Route.queries</source>
          <target state="translated">Relay.Route.queries</target>
        </trans-unit>
        <trans-unit id="90af1f420232cc590b9eb96c3c9344d637dded41" translate="yes" xml:space="preserve">
          <source>Relay.Route.routeName</source>
          <target state="translated">Relay.Route.routeName</target>
        </trans-unit>
        <trans-unit id="596c88b6dd79bb8e709c7b945308e399ac2abc3a" translate="yes" xml:space="preserve">
          <source>Relay.Store</source>
          <target state="translated">Relay.Store</target>
        </trans-unit>
        <trans-unit id="1ca8451821663a9beeafb5041c9c0bfdf4aff046" translate="yes" xml:space="preserve">
          <source>Relay.Store.applyUpdate()</source>
          <target state="translated">Relay.Store.applyUpdate()</target>
        </trans-unit>
        <trans-unit id="23f95eef5a8ff15d45d59ef33e2757420f465ed8" translate="yes" xml:space="preserve">
          <source>Relay.Store.commitUpdate()</source>
          <target state="translated">Relay.Store.commitUpdate()</target>
        </trans-unit>
        <trans-unit id="5435b8d8380c04f42e516eb3bd9326e46359b1b6" translate="yes" xml:space="preserve">
          <source>Relay.createContainer()</source>
          <target state="translated">Relay.createContainer()</target>
        </trans-unit>
        <trans-unit id="12f5066f2601943d9aac424bb916a7d3e8a44732" translate="yes" xml:space="preserve">
          <source>Relay.injectNetworkLayer()</source>
          <target state="translated">Relay.injectNetworkLayer()</target>
        </trans-unit>
        <trans-unit id="1a735b56a61cab41febb27320e2f243ed493b94f" translate="yes" xml:space="preserve">
          <source>Relay.injectTaskScheduler()</source>
          <target state="translated">Relay.injectTaskScheduler()</target>
        </trans-unit>
        <trans-unit id="309387769d52bfb1d6f330d2a6e3ecd71ecb41e1" translate="yes" xml:space="preserve">
          <source>Relay.isContainer()</source>
          <target state="translated">Relay.isContainer()</target>
        </trans-unit>
        <trans-unit id="c772f86aadb639ca41aafc4ec6f52aaae43e0acf" translate="yes" xml:space="preserve">
          <source>RelayContainer</source>
          <target state="translated">RelayContainer</target>
        </trans-unit>
        <trans-unit id="76e743848043959a7f2bfa720b5616417bb798e1" translate="yes" xml:space="preserve">
          <source>RelayContainer implements a conservative default &lt;code&gt;shouldComponentUpdate&lt;/code&gt; that returns &lt;code&gt;false&lt;/code&gt; if no fragment props have changed and all other props are equal scalar values. This may block updates to components that receive data via context. To ensure an update in this case override the default behavior by specifying a &lt;code&gt;shouldComponentUpdate&lt;/code&gt; function.</source>
          <target state="translated">RelayContainer는 조각 소품이 변경되지 않고 다른 모든 소품이 동일한 스칼라 값인 경우 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 보수적 기본 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 구현 합니다. 컨텍스트를 통해 데이터를받는 구성 요소에 대한 업데이트를 차단할 수 있습니다. 이 경우 업데이트를 수행하려면 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 함수 를 지정하여 기본 동작을 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="83d048709f5073df975dc9c425226f037d2ced9a" translate="yes" xml:space="preserve">
          <source>RelayContainer#forceFetch()</source>
          <target state="translated">RelayContainer#forceFetch()</target>
        </trans-unit>
        <trans-unit id="12306a7598448404edb2c73ef03ebd3b1459df33" translate="yes" xml:space="preserve">
          <source>RelayContainer#fragments</source>
          <target state="translated">RelayContainer#fragments</target>
        </trans-unit>
        <trans-unit id="fa4bac3fc05c361b8142cf895c4dec7b9136e491" translate="yes" xml:space="preserve">
          <source>RelayContainer#getFragment()</source>
          <target state="translated">RelayContainer#getFragment()</target>
        </trans-unit>
        <trans-unit id="0f0d5c6a56d86ccbcf94f9197715dbb511dcccda" translate="yes" xml:space="preserve">
          <source>RelayContainer#getPendingTransactions()</source>
          <target state="translated">RelayContainer#getPendingTransactions()</target>
        </trans-unit>
        <trans-unit id="3583e47f56ed32f6527e40cae51e9cd4226d6b8a" translate="yes" xml:space="preserve">
          <source>RelayContainer#hasOptimisticUpdate()</source>
          <target state="translated">RelayContainer#hasOptimisticUpdate()</target>
        </trans-unit>
        <trans-unit id="f6baca904aa4a3f9af8b6cef6a7995ee09553ec3" translate="yes" xml:space="preserve">
          <source>RelayContainer#initialVariables</source>
          <target state="translated">RelayContainer#initialVariables</target>
        </trans-unit>
        <trans-unit id="67aea36b1c5b679f64f0d153f256c81a818ebe83" translate="yes" xml:space="preserve">
          <source>RelayContainer#pendingVariables</source>
          <target state="translated">RelayContainer#pendingVariables</target>
        </trans-unit>
        <trans-unit id="9cce83d93b864bd7fad1aa07826c61d9a6ef284e" translate="yes" xml:space="preserve">
          <source>RelayContainer#prepareVariables</source>
          <target state="translated">RelayContainer#prepareVariables</target>
        </trans-unit>
        <trans-unit id="ef93161b93af5f5e98d21bb920dbacc9ffd1f25e" translate="yes" xml:space="preserve">
          <source>RelayContainer#route</source>
          <target state="translated">RelayContainer#route</target>
        </trans-unit>
        <trans-unit id="707b6138cca39388519379f5f0473ddd29369f7f" translate="yes" xml:space="preserve">
          <source>RelayContainer#setVariables()</source>
          <target state="translated">RelayContainer#setVariables()</target>
        </trans-unit>
        <trans-unit id="13dc088a9a8f1b885a4b30d133ebfc79f65f8a56" translate="yes" xml:space="preserve">
          <source>RelayContainer#shouldComponentUpdate</source>
          <target state="translated">RelayContainer#shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="562b0d971d42af3b685406a662899de6e23e0ff8" translate="yes" xml:space="preserve">
          <source>RelayContainer#variables</source>
          <target state="translated">RelayContainer#variables</target>
        </trans-unit>
        <trans-unit id="cf0a077ddadfb043fbdeb8a931f05f97f9dec4db" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest</source>
          <target state="translated">RelayMutationRequest</target>
        </trans-unit>
        <trans-unit id="459733a291121fc4443f52543c52bf1ba049dc6a" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getDebugName()</source>
          <target state="translated">RelayMutationRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="e6aac4071918a71d5a4437bcf00846a0803cb431" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getFiles()</source>
          <target state="translated">RelayMutationRequest#getFiles()</target>
        </trans-unit>
        <trans-unit id="98f8235cb1f82e31b63e4abc739976992bfb5247" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getID()</source>
          <target state="translated">RelayMutationRequest#getID()</target>
        </trans-unit>
        <trans-unit id="aced70c9403a7f1d9071b6bdae3bf77f17f27954" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getQueryString()</source>
          <target state="translated">RelayMutationRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="f6fd4f67bc834b8917c668afd31ee438a325f452" translate="yes" xml:space="preserve">
          <source>RelayMutationRequest#getVariables()</source>
          <target state="translated">RelayMutationRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="20f8806483b79b8a279be2b49be8c750a67cdb41" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer</source>
          <target state="translated">RelayNetworkLayer</target>
        </trans-unit>
        <trans-unit id="7f0a8ef7b7a43a9933addcbaef565eff07884834" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendMutation()</source>
          <target state="translated">RelayNetworkLayer#sendMutation()</target>
        </trans-unit>
        <trans-unit id="67d40797657bd24a84a171e652a9bea818a15d96" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#sendQueries()</source>
          <target state="translated">RelayNetworkLayer#sendQueries()</target>
        </trans-unit>
        <trans-unit id="eacde2e3a9c41d29b2ee433848dfea8232a5d22a" translate="yes" xml:space="preserve">
          <source>RelayNetworkLayer#supports()</source>
          <target state="translated">RelayNetworkLayer#supports()</target>
        </trans-unit>
        <trans-unit id="5113dd07f144f50d7677810b044a345b89e66e0e" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest</source>
          <target state="translated">RelayQueryRequest</target>
        </trans-unit>
        <trans-unit id="4a9c272793946b8bdd3a09cdfbde6dc8574faf62" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getDebugName()</source>
          <target state="translated">RelayQueryRequest#getDebugName()</target>
        </trans-unit>
        <trans-unit id="481aa62146f5343b4ba1062802709201d6d4d7af" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getID()</source>
          <target state="translated">RelayQueryRequest#getID()</target>
        </trans-unit>
        <trans-unit id="0f467922406404a5eac2d6f11b736b9d66633025" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getQueryString()</source>
          <target state="translated">RelayQueryRequest#getQueryString()</target>
        </trans-unit>
        <trans-unit id="981023af3724c0e925cbc3f99f867f132178c714" translate="yes" xml:space="preserve">
          <source>RelayQueryRequest#getVariables()</source>
          <target state="translated">RelayQueryRequest#getVariables()</target>
        </trans-unit>
        <trans-unit id="8324e4ecabe765d0034c56fc8f4c857ecfa3e2ae" translate="yes" xml:space="preserve">
          <source>RelayRecordProxy</source>
          <target state="translated">RelayRecordProxy</target>
        </trans-unit>
        <trans-unit id="69b9a9d8ad89e9af43d214607d3ff0018325568c" translate="yes" xml:space="preserve">
          <source>RelayRecordStore</source>
          <target state="translated">RelayRecordStore</target>
        </trans-unit>
        <trans-unit id="8aa27a7e83012be706218f33db1f656ebf3d0b47" translate="yes" xml:space="preserve">
          <source>Render Callbacks</source>
          <target state="translated">콜백 렌더</target>
        </trans-unit>
        <trans-unit id="e066e80468f5234a1001137061731ae39a651ab5" translate="yes" xml:space="preserve">
          <source>Rendering</source>
          <target state="translated">Rendering</target>
        </trans-unit>
        <trans-unit id="db86b99e5c8c7fa5281608698558232d5c55e13b" translate="yes" xml:space="preserve">
          <source>Rendering Containers</source>
          <target state="translated">렌더링 컨테이너</target>
        </trans-unit>
        <trans-unit id="af597671c6dcfa1df34e2e38251238001351c84d" translate="yes" xml:space="preserve">
          <source>Repeatedly refetching information from the server can get quite slow. For example, navigating from the list of stories, to a list item, and back to the list of stories means we have to refetch the whole list. We'll solve this with the standard solution: &lt;em&gt;caching&lt;/em&gt;.</source>
          <target state="translated">서버에서 정보를 반복해서 다시 가져 오면 상당히 느려질 수 있습니다. 예를 들어 스토리 목록에서 목록 항목으로 이동하고 스토리 목록으로 다시 이동하면 전체 목록을 다시 가져와야합니다. 표준 솔루션 인 &lt;em&gt;캐싱으로&lt;/em&gt; 이를 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="3341adcc90aa2cf65b0ed4f78d46fafd5dfc9cd5" translate="yes" xml:space="preserve">
          <source>Requesting Different Data</source>
          <target state="translated">다른 데이터 요청</target>
        </trans-unit>
        <trans-unit id="b092a39c824d57357df89b0ece2eb1e4c9834cca" translate="yes" xml:space="preserve">
          <source>Require the Relay Compat API from &lt;code&gt;'react-relay/compat'&lt;/code&gt; and use it as you would Relay Modern. The components using Relay Compat can be referred to by both other Relay Modern and Relay Classic components.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; 의 Relay Compat API를 요구하고 Relay Modern과 같이 사용하십시오. Relay Compat를 사용하는 구성 요소는 다른 Relay Modern 및 Relay Classic 구성 요소에서 모두 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ac8791c7043a10705ecb741c56abf9848abf0a" translate="yes" xml:space="preserve">
          <source>Resolving Data from the Client</source>
          <target state="translated">클라이언트에서 데이터 해결</target>
        </trans-unit>
        <trans-unit id="3281bf767244e09b6483581e4d93f748c54eb136" translate="yes" xml:space="preserve">
          <source>Response-caching can also be applied to GraphQL. A basic approach would work similarly to the REST version. The text of the query itself can be used as a cache key:</source>
          <target state="translated">응답 캐싱은 GraphQL에도 적용 할 수 있습니다. 기본 접근 방식은 REST 버전과 유사하게 작동합니다. 쿼리 자체의 텍스트를 캐시 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81554eb7c1007a0bac823cb3e3ca325777b63f97" translate="yes" xml:space="preserve">
          <source>Retrieves record(s) associated with the given record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">주어진 레코드와 연관된 레코드를 검색하여 소스를 필드 이름 및 사전 정의 된 인수 값을 나타내는 오브젝트로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="e013c79a69f7fdde5c1472633a22316f0ef0ef72" translate="yes" xml:space="preserve">
          <source>Retrying failed requests.</source>
          <target state="translated">실패한 요청을 재 시도합니다.</target>
        </trans-unit>
        <trans-unit id="56de3c3d136f4071d757cabe4b6ed2c52a5dad01" translate="yes" xml:space="preserve">
          <source>Returns a proxy class for manipulating records from a record source, for example a query, mutation, or the store.</source>
          <target state="translated">레코드 소스 (예 : 쿼리, 돌연변이 또는 상점)에서 레코드를 조작하기위한 프록시 클래스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="91f8449d9fa8e9ef7aa99597a20ab0dcfe5b332a" translate="yes" xml:space="preserve">
          <source>Returns a read-only view of the store's internal RecordSource that holds all records.</source>
          <target state="translated">모든 레코드를 보유하는 상점 내부 RecordSource의 읽기 전용보기를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6a9d68c06d14e4ad8d6a81f1e355b118c27b1408" translate="yes" xml:space="preserve">
          <source>Returns the GraphQL type name for a given record.</source>
          <target state="translated">주어진 레코드에 대한 GraphQL 유형 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="384ac89b24069cf234b54ff56b3d6d5c565f33c7" translate="yes" xml:space="preserve">
          <source>Returns the globally unique identifier string for a record.</source>
          <target state="translated">레코드의 전역 고유 식별자 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7d0eb64e469d72e6ccf94d6d96498f73ad0e6f27" translate="yes" xml:space="preserve">
          <source>Reusable fragments to compose within the above use cases.</source>
          <target state="translated">위의 사용 사례 내에서 작성 가능한 재사용 가능한 조각.</target>
        </trans-unit>
        <trans-unit id="72e1985969f053f8609f492cf63340c5c4f7f3fc" translate="yes" xml:space="preserve">
          <source>Rolls back an optimistic mutation.</source>
          <target state="translated">낙관적 돌연변이를 롤백합니다.</target>
        </trans-unit>
        <trans-unit id="0dfddbb0a122d3a2969eb11e085210ba893e7399" translate="yes" xml:space="preserve">
          <source>Root Container</source>
          <target state="translated">루트 컨테이너</target>
        </trans-unit>
        <trans-unit id="1bf5197778bc12b8d4edfe1a0c2de1ced169d30b" translate="yes" xml:space="preserve">
          <source>RootContainer</source>
          <target state="translated">RootContainer</target>
        </trans-unit>
        <trans-unit id="4999528efe0f94f8f66b1dc05aad8ebaaae7b2be" translate="yes" xml:space="preserve">
          <source>Route</source>
          <target state="translated">Route</target>
        </trans-unit>
        <trans-unit id="52c021a7e89ad4e72cef6096b3c6424e78876574" translate="yes" xml:space="preserve">
          <source>Route is useful in providing the context which a component is being rendered in. It includes information about the &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;params&lt;/code&gt;, and &lt;code&gt;queries&lt;/code&gt; of the current route.</source>
          <target state="translated">경로는 구성 요소가 렌더링되는 컨텍스트를 제공하는 데 유용합니다. 여기에는 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;params&lt;/code&gt; 및 현재 경로의 &lt;code&gt;queries&lt;/code&gt; 에 대한 정보가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="03730e58401ef5d9e79d1f674df0a5f9cf756e33" translate="yes" xml:space="preserve">
          <source>Routes</source>
          <target state="translated">Routes</target>
        </trans-unit>
        <trans-unit id="0bd75f049435ac9bea4df8ce63749bdcfaaef9e4" translate="yes" xml:space="preserve">
          <source>Routes and Queries</source>
          <target state="translated">경로와 쿼리</target>
        </trans-unit>
        <trans-unit id="a476715db16204d7e6fb7743a314ee35337241d4" translate="yes" xml:space="preserve">
          <source>Routes are now optional: &lt;code&gt;QueryRenderer&lt;/code&gt; can be used without defining a route. More in the &lt;a href=&quot;routing&quot;&gt;routing guide&lt;/a&gt;.</source>
          <target state="translated">라우트는 이제 선택 사항입니다. 라우트 를 정의하지 않고 &lt;code&gt;QueryRenderer&lt;/code&gt; 를 사용할 수 있습니다. &lt;a href=&quot;routing&quot;&gt;라우팅 가이드&lt;/a&gt; 에서 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="ca283153940483bc802b34b41123871d483749c7" translate="yes" xml:space="preserve">
          <source>Routes are objects that define a set of root queries and input parameters. Here is a simple route that might be used to render user &lt;code&gt;123&lt;/code&gt;'s profile:</source>
          <target state="translated">경로는 루트 쿼리 및 입력 매개 변수 집합을 정의하는 개체입니다. 다음은 사용자 &lt;code&gt;123&lt;/code&gt; 의 프로필 을 렌더링하는 데 사용될 수있는 간단한 경로입니다 .</target>
        </trans-unit>
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">경로는 릴레이 응용 프로그램에 진입 점을 정의하는 역할을합니다. 그러나 라우트가 필요한 이유를 이해하려면 먼저 GraphQL 쿼리와 프래그먼트의 차이점을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">라우트는 생성자에 제공해야하는 매개 변수 이름 세트를 선언 할 수 있습니다. 또한 유효한 매개 변수 세트를 문서화하기에 편리한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">라우트는 &lt;code&gt;prepareParams&lt;/code&gt; 매개 변수를 사용 하여 기본 매개 변수를 제공하거나 전달 된 매개 변수를 통과, 변환 또는 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">라우트는 &lt;code&gt;Relay.QL&lt;/code&gt; 을 사용하여 쿼리 루트 세트를 선언해야합니다 . 이러한 쿼리는 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 의이 경로와 함께 사용되는 Relay 컨테이너에서 &lt;code&gt;queryName&lt;/code&gt; 이라는 일치하는 조각을 자동으로 작성 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">경로는 문자열 이름을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">라우트는 더 이상 Relay Modern의 쿼리 루트에 대해 알 필요가 없습니다. 릴레이 구성 요소는 &lt;code&gt;QueryRenderer&lt;/code&gt; 에 싸여있는 곳이면 어디든지 렌더링 할 수 있습니다 . 이는 라우팅 프레임 워크 선택에 더 많은 유연성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">릴레이 애플리케이션에서 GraphQL을 변경 한 후 릴레이 컴파일러를 실행하십시오. &lt;code&gt;yarn script&lt;/code&gt; 로 추가하는 것이 도움이 될 수 있습니다 . package.json 파일의 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 에 항목을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">스키마 JSON</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">인수 오브젝트에서 사용 가능한 메소드는 &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">인수 오브젝트에서 사용 가능한 메소드는 &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt; 생성자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;컨테이너&lt;/a&gt; : 릴레이 컨테이너</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;컨테이너&amp;gt; 다른 데이터 요청&lt;/a&gt; , &lt;a href=&quot;guides-ready-state&quot;&gt;준비 상태&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;돌연변이&amp;gt; 조각 변수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;돌연변이&amp;gt; 조각 변수&lt;/a&gt; 및 &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;돌연변이&amp;gt; 뮤 테이터 구성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;돌연변이&amp;gt; 팻 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-ready-state&quot;&gt;준비 상태&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;루트 컨테이너&amp;gt; 구성 요소 및 경로를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;루트 컨테이너&amp;gt; 강제 가져 오기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;루트 컨테이너&amp;gt; renderFailure&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;루트 컨테이너&amp;gt; renderFetched&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;루트 컨테이너&amp;gt; renderLoading&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-routes&quot;&gt;경로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes의 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL의 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-store&quot;&gt;저장 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-mutations&quot;&gt;돌연변이 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-network-layer&quot;&gt;네트워크 계층 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-routes&quot;&gt;Routes Guide를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">서버 오류</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay 설정</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">릴레이 컴파일러 설정</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">릴레이 컴파일러 설정</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay 설정</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">자세히보기</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">React 컴포넌트의 &lt;code&gt;render&lt;/code&gt; 메소드가 기본 뷰를 직접 수정하지 않는 방식과 유사하게 릴레이 컨테이너는 데이터를 직접 가져 오지 않습니다. 대신 컨테이너 는 렌더링에 필요한 데이터 &lt;em&gt;사양&lt;/em&gt; 을 선언합니다 . 릴레이는 렌더링 &lt;em&gt;전에이&lt;/em&gt; 데이터를 사용할 수 있음을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">더 간단한 돌연변이 API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">릴레이 컨테이너는 쿼리가 아닌 조각을 정의하므로 여러 컨텍스트에 쉽게 포함될 수 있습니다. React 구성 요소와 마찬가지로 릴레이 컨테이너는 재사용 성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">하나의 게임에는 많은 숨은 지점이있을 수 있으므로 서로 연결하는 데 사용할 수있는 연결을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">작은 번들 크기</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">지금까지 데이터 페치의 하위 레벨을 살펴보고 다양한 친숙한 개념이 GraphQL로 어떻게 변환되는지 살펴 보았습니다. 다음으로 물러서서 제품 개발자가 데이터 페치에 대해 자주 직면하는 몇 가지 높은 수준의 문제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">지금까지 우리는 GraphQL을 전형적인 REST 접근법의보다 효율적인 버전으로 사용하고 있습니다. GraphQL 버전의 두 가지 중요한 이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">지금까지 우리는 데이터를 쿼리하고 뷰를 최신 상태로 유지하는 프로세스를 살펴 봤지만 쓰기는 살펴 보지 않았습니다. GraphQL에서 쓰기를 &lt;strong&gt;mutations&lt;/strong&gt; 라고 합니다. 그것들을 부작용이있는 쿼리라고 생각할 수 있습니다. 주어진 스토리를 현재 사용자가 좋아하는 것으로 표시 할 수있는 돌연변이를 호출하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">지금까지 데이터 선언에 기여하는 두 가지 부분을 살펴 보았습니다.</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">따라서 &lt;code&gt;introduceShip&lt;/code&gt; 돌연변이를 위해 &lt;code&gt;IntroduceShipInput&lt;/code&gt; 및 &lt;code&gt;IntroduceShipPayload&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">이 캐시를 어떻게 사용합니까? 응답이 수신 될 때 캐시에 쓰는 것과 캐시에서 읽는 쿼리를 로컬로 수행 할 수 있는지 여부 &lt;code&gt;_cache.has(key)&lt;/code&gt; 위의 _cache.has (key) 와 같지만 그래프) 를 확인하는 두 가지 작업을 살펴 ​​보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">이제 우리는 우리 시스템에서 반란군의 ID를 알고 있습니다. 이제 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">따라서 선박에 대한 첫 번째 쿼리에서 GraphQL은 다음 페이지가 있다고 말했지만 다음 페이지에서는 연결이 끝났다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">일부 필드 (특히 페이지가 매겨진 데이터의 필드)는 이전에 가져온 데이터를 새로운 정보와 병합하기 위해 클라이언트에서 사후 처리가 필요할 수 있습니다. Relay Modern은 다양한 페이지 매김 패턴 및 기타 사용 사례를 처리하기 위해 이러한 필드를 처리하는 데 사용할 수있는 사용자 정의 필드 핸들러를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">때로는 부모가 자식 구성 요소의 기본 변수를 재정의해야합니다. 기본 64 대신 사진 크기가 128 인 &lt;code&gt;Child&lt;/code&gt; 를 렌더링한다고 가정합니다. 이렇게하려면 조각 &lt;em&gt;과&lt;/em&gt; 컨테이너 모두 사용자 지정 변수에 대해 알고 있어야합니다. &lt;em&gt;쿼리&lt;/em&gt; 에서 사용자 정의 변수를 설정하려면 &lt;code&gt;getFragment&lt;/code&gt; 에 두 번째 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">소스 파일</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">`Relay.Container`의 데이터 종속성을 GraphQL 조각으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">'Relay.Mutation'에 돌연변이 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">'Relay.Route'의 쿼리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; 모듈 ( &lt;code&gt;createFragmentContainer&lt;/code&gt; , &lt;code&gt;createRefetchContainer&lt;/code&gt; , &lt;code&gt;createPaginationContainer&lt;/code&gt; , &lt;code&gt;commitMutation&lt;/code&gt; ) 에서 Relay Modern API를 사용하도록 컴포넌트 및 돌연변이 변환을 시작하십시오 . 리프 구성 요소에서 위로 올라가는 것이 더 쉬울 것입니다. &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;변환 스크립트는&lt;/a&gt; 이 단계가 덜 지루한해야한다.</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">정적 방법</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">0 단계 : Relay v1.0 설치</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">1 단계 : 릴레이 Compat으로 증분 변환</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">2 단계 : &amp;lt;QueryRenderer&amp;gt; 소개</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">3 단계 : Relay Modern 런타임 소개</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">4 단계 : Relay Compat을 Relay Modern으로 교체하여 정리합니다.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">돌연변이를 예측할 수 있도록 주변 구조.</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호환 모드와 최신 모드에서 모두 지원됩니다. 페이지 매김 컨테이너를 사용할 때 Relay는 연결 필드에 &lt;code&gt;@connection&lt;/code&gt; 지시문 이 주석으로 표시 될 것으로 예상합니다. 자세한 정보 및 예는 &lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래식, 호환 및 현대 모드에서 지원됩니다. 자세한 사용법은 &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">단! 계속해서 다음 4 개를 줍시다!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">스위치 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 에 앱에 대한 참조를 &lt;code&gt;'react-relay'&lt;/code&gt; . 이는 앱이 불필요한 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 코드를 가져 오지 못하게하는 정리 단계에 가깝습니다 .</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">이 입력 인수에는 요청 및 응답을 조정하기위한 (문자열) &quot;clientMutationId&quot;특성이 포함되어야합니다 ( &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API 에 의해 자동으로 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">즉, 사용 된 &lt;code&gt;first&lt;/code&gt; 로 인수 &lt;code&gt;ships&lt;/code&gt; 첫 번째로 아래로 결과 집합을 슬라이스. 그러나 우리가 그것을 통해 페이지 매기기를 원한다면 어떨까요? 각 모서리에 커서를 노출시켜 페이지 매김에 사용할 수 있습니다. 이번에는 처음 두 개를 요청하고 커서도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 인터페이스와 &lt;code&gt;node&lt;/code&gt; 필드는이 refetching에 대한 전역 적으로 고유 한 ID를 가정합니다. 전역 고유 ID가없는 시스템은 일반적으로이 예에서 수행 된 유형별 ID와 유형을 결합하여이를 합성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 인터페이스는 단일 필드가 포함 &lt;code&gt;id&lt;/code&gt; A는, &lt;code&gt;ID!&lt;/code&gt; . &lt;code&gt;node&lt;/code&gt; 루트 필드는 단일 인수하는 소요 &lt;code&gt;ID!&lt;/code&gt; , &lt;code&gt;Node&lt;/code&gt; 를 반환합니다 . 이 두 가지가 함께 작동하여 리 페치를 허용합니다. 우리가 통과하면 &lt;code&gt;id&lt;/code&gt; 받는 그 필드에 리턴 &lt;code&gt;node&lt;/code&gt; 필드에, 우리는 개체 다시 얻을.</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">&lt;code&gt;applyUpdate&lt;/code&gt; 이 처럼 돌연변이를 추가 &lt;code&gt;update&lt;/code&gt; 하지만, 커밋하지 않습니다. 커밋 또는 롤백 할 수 있는 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-relay-plugin&lt;/code&gt; (가) 전에 실행해야합니다 &lt;code&gt;react-native&lt;/code&gt; 바벨 사전 설정을. 따라서 &lt;code&gt;.babelrc&lt;/code&gt; 에서 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 는 &lt;code&gt;babelRelayPlugin&lt;/code&gt; 뒤에 와야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">&lt;code&gt;commitUpdate&lt;/code&gt; 있어서 자속 작용 디스패치 유사하다. 릴레이는 다음과 같이 돌연변이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">&lt;code&gt;react-relay&lt;/code&gt; NPM 모듈을 포함하는 &lt;code&gt;react&lt;/code&gt; A와 &lt;em&gt;피어 의존성&lt;/em&gt; . 앱에서 React를 명시 적으로 종속성으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">&lt;code&gt;relay-compiler&lt;/code&gt; 스크립트는 .json 또는 .graphql 스키마 파일 중 하나에 GraphQL 스키마에 소스 파일뿐만 아니라 경로를 보유하고있는 디렉토리를 모두 필요로한다.</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; 의 : 콜백은 두 개의 인수로 호출 &lt;code&gt;Error&lt;/code&gt; 객체와 요청을 다시 시도 할 수있는 기능. 오류가 서버 응답에서 통신 된 서버 오류의 결과 인 경우 &lt;code&gt;error.source&lt;/code&gt; 에서 응답 페이로드를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 콜백은 항상 불려 &lt;code&gt;data&lt;/code&gt; 에서 객체 매핑 인수, &lt;code&gt;propName&lt;/code&gt; 쿼리 데이터. &lt;code&gt;renderFetched&lt;/code&gt; 콜백은 제공된 &lt;code&gt;Component&lt;/code&gt; 를 컴포넌트 와 함께 렌더링 할 것으로 예상 됩니다 (예 : &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX 스프레드 속성 기능 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">API는 전체적으로 더 단순하고 예측 가능합니다.</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">연결이 포함 된 상위 노드의 DataID입니다. 이 인수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">우리가 얻은 ID는 base64 문자열이었습니다. ID는 불투명하도록 설계되었습니다 ( &lt;code&gt;node&lt;/code&gt; 에서 &lt;code&gt;id&lt;/code&gt; 인수 로 전달되어야하는 유일한 것은 시스템의 일부 객체에서 &lt;code&gt;id&lt;/code&gt; 를 쿼리 한 결과 변경되지 않은 결과입니다 ). 문자열을 base64하는 것은 시청자에게 문자열은 불투명 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">릴레이 &quot;환경&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relay &quot;Environment&quot;는 Relay가 작동하기 위해 필요한 구성, 캐시 스토리지 및 네트워크 처리를 하나로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">릴레이 &quot;환경&quot;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">릴레이 &lt;code&gt;Store&lt;/code&gt; 는 돌연변이를 서버로 디스패치하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay Classic 및 Relay Compat 모드는 생성 된 컨텐츠를 인라인으로 생성하고 감지 된 GraphQL 유효성 검사 오류를 포착하여 기록 할 수 있으므로 런타임시 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">릴레이 컴파일러는 런타임에 정적으로 사용할 수있는 빌드 단계의 일부로 코드를 생성합니다. 쿼리를 미리 빌드함으로써 클라이언트의 JS 런타임은 쿼리 문자열을 생성 할 책임이 없으며 쿼리에서 복제 된 필드를 빌드 단계에서 병합하여 구문 분석 효율성을 향상시킬 수 있습니다. 쿼리를 서버에 유지할 수있는 경우 컴파일러의 코드 생성 프로세스는 쿼리 또는 돌연변이 텍스트를 고유 식별자로 변환하는 데 편리한 시간을 제공하여 필요한 업로드 바이트를 크게 줄입니다.</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Core는 클라이언트 스키마 확장에 대한 지원을 추가합니다. 이를 통해 Relay는 서버에서 가져온 데이터와 함께 일부 추가 정보를 편리하게 저장하고 서버에서 가져온 다른 필드와 같이 렌더링 할 수 있습니다. 이전에 측면에 Flux / Redux 매장이 필요했던 일부 사용 사례를 대체 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPM에 배포 된 Relay Modern 패키지는 널리 지원되는 ES5 버전의 JavaScript를 사용하여 가능한 많은 브라우저 환경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">릴레이 네트워크 계층</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">릴레이 런타임 번들은 릴레이 클래식 크기의 약 20 %입니다.</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">낙관적 업데이트가보다 세밀한 제어가 필요한 고급 에지 사례에서는 릴레이 저장소를 프로그래밍 방식으로 변경할 수 있습니다. 다음 API 메소드는 연결 및 단편을 변경하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">이 이야기의 저자는 그것에 대해서도 언급했습니다. 꽤 흔합니다. 이제 다른보기에서 작성자에 대한 새로운 정보를 가져오고 프로필 사진이 새로운 URI로 변경되었다고 상상해보십시오. 캐시 된 데이터에서 변경된 &lt;em&gt;유일한&lt;/em&gt; 부분은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">지금 시작하는 가장 좋은 방법은이 세 부분이 어떻게 결합하여 실제 사례를 만드는지 살펴 보는 것입니다. 다음 페이지의 자습서는 &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit를&lt;/a&gt; 사용하여 예제 응용 프로그램을 안내하여 릴레이 사용을 시작하는 방법에 대한 아이디어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">클라이언트와 서버가 분리되어 있습니다. 클라이언트 는 올바른 데이터를 리턴하기 위해 서버 엔드 포인트 에 &lt;em&gt;의존하는&lt;/em&gt; 대신 필요한 데이터를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4의 컴포넌트 기반 접근법은 중첩 된 라우트에 대한 데이터 요구 사항을 집계하는 것을 쉽게 허용하지 않으므로 요청 폭포가 &lt;code&gt;QueryRenderer&lt;/code&gt; 컴포넌트 를 중첩시키지 않도록하는 접근법을 쉽게 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">디버깅을 위해 &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; 라는 컨테이너 는 로컬 저장소에서 각 GraphQL 조각에 대한 응답을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">컨테이너는 각 프래그먼트의 결과 (다른 소품과 함께)를 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 컴포넌트로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">기본 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">여기서 지정한 기본값은 프래그먼트 빌더가 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">지금 시작하는 가장 쉬운 방법은 &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;릴레이 스타터 키트를 사용&lt;/a&gt; 하는 것입니다. 여기에는 스키마 파일 예제가 포함되어 있으며 쿼리를 변환 하도록 &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npm 모듈을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">위의 예제는 &lt;code&gt;handlerProvider&lt;/code&gt; 를 구성하지 않았습니다. 즉, 기본 공급자 가 제공됩니다. 릴레이 현대가의 부부와 함께 제공 내장에 자세히 규정 표준 GraphQL의 기능이 아닙니다 연결을 처리하기위한 특별한 기능 (와 핵심하지만 페이스 북에서 사용 매김 규칙의 집합 증대 핸들러 &lt;a href=&quot;graphql-connections&quot;&gt;사양 릴레이 커서 연결&lt;/a&gt; , Relay 자체에서 잘 지원됨) &lt;code&gt;viewer&lt;/code&gt; 필드 (표준 GraphQL 스키마 기능이 아니라 Facebook 내에서 광범위하게 사용되는 기능)</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">위의 예제는 클래식 컨테이너 API와 매우 유사하지만 최신 API에서는 &lt;code&gt;graphql&lt;/code&gt; 템플릿 리터럴을 두 번째 인수로 직접 전달할 수 있습니다 . 릴레이는 프래그먼트 명명 규칙 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 에 따라 프래그먼트 이름에서 프롭 이름을 유추합니다 . 아래 예는 위의 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">뚱뚱한 질문</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">삭제 된 노드의 DataID를 포함하는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">제거 된 노드의 DataID를 포함하는 응답의 필드 이름 또는 연결에서 제거 된 노드의 경로</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">연결을 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">새로 작성된 가장자리를 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">연결의 상위를 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">최종 데이터 선언은 다음 일반 GraphQL과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">첫 번째 질문은 스토리 목록에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">이 컴포넌트의 프래그먼트에 사용 가능한 초기 변수 값 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">가장 많이 사용되는 함수는 &lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt; 로 구성 요소를 데이터 선언으로 감 쌉니다.</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">돌연변이는 &quot;입력&quot;이라는 단일 인수를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">새로운 Relay Modern 코어는 이전 버전보다 가볍고 훨씬 빠릅니다. 정적 쿼리 작업을 위해 다시 설계되었으므로 더 많은 작업을 빌드 / 컴파일 시간으로 진행할 수 있습니다. Modern 코어는 동적 쿼리에 필요한 많은 복잡한 기능을 제거하여 훨씬 더 작습니다. 새로운 코어는 또한 빌드 타임에 생성 된 최적화 된 구문 분석 명령어 세트로 응답을 처리하는 데 훨씬 빠릅니다. 더 이상 동적 쿼리 생성에 필요한 정보를 추적하지 않아도되므로 릴레이 사용시 메모리 오버 헤드가 크게 줄어 듭니다. 이는 UI가 반응 적으로 느껴지도록 더 많은 메모리가 남아 있음을 의미합니다. Relay Modern은 지속 쿼리를 지원하여 전체 쿼리 텍스트에서 간단한 ID로 요청의 업로드 크기를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">다음 논리적 접근 방식은 데이터 가져 오기를 시작하는 수단으로 &lt;code&gt;render()&lt;/code&gt; 를 사용 하는 것입니다. 애플리케이션을 한 번만 렌더링하고 필요한 데이터를 확인한 후 해당 데이터를 가져 와서 다시 렌더링 할 수 있습니다. 이것은 훌륭하게 들리지만 문제는 &lt;em&gt;구성 요소가 데이터를 사용하여 렌더링 대상을 파악&lt;/em&gt; 한다는 &lt;em&gt;것입니다!&lt;/em&gt; 다시 말해, 데이터 가져 오기가 준비되도록해야합니다. 먼저 루트를 렌더링하고 필요한 데이터를 확인한 다음 하위를 렌더링하고 필요한 것을 트리에서 완전히 확인하십시오. 각 단계에서 네트워크 요청이 발생하면 렌더링에 느린 직렬 왕복이 필요합니다. 모든 데이터 요구 사항을 사전에 또는 &lt;em&gt;정적으로&lt;/em&gt; 결정할 수있는 방법이 필요했습니다 .</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">선택적 &lt;code&gt;config&lt;/code&gt; 매개 변수를 사용 하여 &lt;code&gt;Relay.Mutation&lt;/code&gt; API에 따라 &lt;code&gt;RANGE_ADD&lt;/code&gt; 또는 다른 유형의 돌연변이 를 구성 할 수 있습니다 . 릴레이에게 응답 처리 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">선택적 &lt;code&gt;config&lt;/code&gt; 매개 변수를 사용 하여 &lt;code&gt;Relay.Mutation&lt;/code&gt; API 와 유사한 &lt;code&gt;RANGE_ADD&lt;/code&gt; 또는 다른 유형의 돌연변이 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">위에 나열된 옵션은 전체가 아닙니다. Relay Modern과 잘 작동하는 다른 라우팅 솔루션을 알고 있다면 &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">페이지 매김 컨테이너는 연결 필드에 &lt;code&gt;@connection(key: ...)&lt;/code&gt; 지시문 으로 주석이 달릴 것으로 예상합니다. 여기서 &lt;code&gt;key&lt;/code&gt; 는 상위 필드 유형 &lt;code&gt;User&lt;/code&gt; 에서 고유 식별자가 될 것으로 예상됩니다 . 좋은 연습이 될 수 &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; . 기본적으로 릴레이는 사용자 제공 &lt;code&gt;key&lt;/code&gt; 와 필드의 모든 비 필터 변수를 기반으로 스토리지 키를 생성 합니다. 또한 릴레이는 고급 기능 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; 을 제공하여 스토리지 키를 생성하는 데 사용할 변수를 명시 적으로 지정할 수 있습니다. 특히 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; , 릴레이는 모든 변수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">플러그인 은 위의 스 니펫에서 스키마 &lt;code&gt;schemaData&lt;/code&gt; 를 이해해야합니다 . GraphQL 구현에 따라이 정보를 얻는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">이 예제의 전제는 GraphQL을 사용하여 원래 Star Wars 3 부작의 배와 진영에 대한 정보를 쿼리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">데이터 요구 사항을 선언하는 기본 방법은 &lt;code&gt;Relay.Container&lt;/code&gt; 를 사용하는 것입니다. React 구성 요소가 데이터 요구 사항을 인코딩 할 수 있도록하는 상위 React 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">데이터 요구 사항을 선언하는 기본 방법은 &lt;code&gt;createFragmentContainer&lt;/code&gt; 를 사용하는 것입니다. createFragmentContainer 는 React 컴포넌트가 데이터 요구 사항을 인코딩 할 수있게하는 상위 React 컴포넌트입니다.</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">아래에 나열된 특성 및 메소드 는 랩핑 된 React 컴포넌트의 &lt;code&gt;this.props.relay&lt;/code&gt; 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">쿼리는 &quot;clientMutationId&quot;를 하위 선택으로 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">추론과 같은 경우이다 &lt;code&gt;babel-plugin-relay&lt;/code&gt; 전과 실행되지 않습니다 &lt;code&gt;es2015-template-literals&lt;/code&gt; 변환이 제대로 Relay.QL 템플릿 리터럴을 변환하지 않습니다. 또한 Babel 6에서는 플러그인 순서를 제어 할 수 없습니다. 따라서 &lt;code&gt;.babelrc&lt;/code&gt; 의 플러그인이 .babelrc 프로젝트 &lt;code&gt;.babelrc&lt;/code&gt; 먼저로드 되는 React Native에서는 전체 변환 목록을 재정의하지 않고 Babel Relay 플러그인을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">런타임은 더 이상 참조되지 않는 캐시 된 데이터를 자동으로 제거하여 메모리 사용량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래에 설명 된 스키마는 Relay가 사용하는 GraphQL 서버가 구현해야하는 기능을 보여주기 위해 사용됩니다. 두 가지 핵심 유형은 스타 워즈 세계의 진영과 배이며, 진영에는 많은 배가 있습니다. 아래 스키마는 GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt; 의 출력입니다 .</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">두 번째 쿼리는 이러한 스토리 중 하나에 대한 정보를 다시 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">GraphQL을 캐싱하는 솔루션은 계층 적 응답을 평평한 &lt;strong&gt;레코드&lt;/strong&gt; 모음으로 정규화하는 것 입니다. 릴레이는이 캐시를 ID에서 레코드로의 맵으로 구현합니다. 각 레코드는 필드 이름에서 필드 값으로의 맵입니다. 레코드는 또한 다른 레코드에 연결될 수 있으며 (순환 그래프를 설명하도록 허용 함)이 링크는 최상위 맵을 다시 참조하는 특수한 값 유형으로 저장됩니다. 이 방법을 사용하면 각 서버 레코드 가 가져 오는 방법에 관계없이 &lt;em&gt;한 번&lt;/em&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">여기서 '변수'라는 용어는 이 돌연변이의 단편 제작자가 이용할 수있는 변수가 &lt;strong&gt;아니라&lt;/strong&gt; 서버 측 돌연변이에 대한 입력을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Relay가 GraphQL 서버에 대해 세 가지 핵심 가정은 다음을 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">두 가지 방법은 클라이언트에서 누락 된 필드 만 포함하는 쿼리를 보내는 대신 &lt;code&gt;forceFetch&lt;/code&gt; 가 각 조각을 다시 가져 오기 위해 요청을 보냅니다. 이렇게하면 구성 요소의 소품을 서버에서 새로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; 필드 의 값 이 변경되었습니다. 따라서 레코드 &lt;code&gt;2&lt;/code&gt; 도 변경되었습니다. 그리고 그게 다야. &lt;em&gt;캐시의&lt;/em&gt; 다른 것은 영향을받지 않습니다. 그러나 분명히 우리의 &lt;em&gt;견해&lt;/em&gt; 에는 업데이트가 반영되어야합니다. UI의 작성자 (스토리 작성자 및 댓글 작성자)는 새 사진을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">그런 다음 응용 프로그램 파일을 편집 한 후에는 &lt;code&gt;yarn run relay&lt;/code&gt; 를 실행 하여 새 파일을 생성하거나 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; 를 사용하여 컴파일러를 장기 프로세스로 실행하여 저장할 때마다 새 파일을 자동으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">그런 다음 응용 프로그램 파일을 편집 한 후 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; 을 실행하여 새 파일을 생성하거나 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; 는 저장할 때마다 새 파일을 자동으로 생성하는 장기 프로세스로 컴파일러를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">그런 다음 설정 한대로 &lt;code&gt;yarn run relay&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">그런 다음 .babelrc 파일의 플러그인 목록에 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 를 추가 하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">플랫 캐시로 뷰를 최신 상태로 유지하기위한 다양한 솔루션이 있습니다. Relay가 취하는 접근법은 각 UI보기에서 참조하는 ID 세트로의 맵핑을 유지하는 것입니다. 이 경우 스토리보기는 스토리 ( &lt;code&gt;1&lt;/code&gt; ), 저자 ( &lt;code&gt;2&lt;/code&gt; ) 및 주석 ( &lt;code&gt;3&lt;/code&gt; 및 기타) 에 대한 업데이트를 구독합니다 . 데이터를 캐시에 쓸 때 릴레이는 영향을받는 ID를 추적 하고 해당 ID를 구독 한보기 &lt;em&gt;만&lt;/em&gt; 알립니다 . 영향을받는 뷰는 다시 렌더링되고 영향을받지 않은 뷰는 더 나은 성능을 위해 다시 렌더링을 선택하지 않습니다 (릴레이는 안전하지만 효과적인 기본 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 제공합니다 ). 이 전략이 없다면 가장 작은 변화조차도 모든 견해가 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">단편을 포함한다 (또는 비아 쿼리에 정의 된 전역 변수를 사용하여 동적으로 변수의 초기 값을 설정하는 하나의 방법은 현재 지원가 &lt;code&gt;variables&lt;/code&gt; 온 &lt;code&gt;QueryRenderer&lt;/code&gt; 는 ).</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">따라서 GraphQL에 대한 정규화 된 응답 캐시는 페이로드와 쿼리를 병렬로 처리해야합니다. 예를 들어, 위 의 &lt;code&gt;photo&lt;/code&gt; 필드 는 필드 및 인수 값을 고유하게 식별하기 위해 &lt;code&gt;photo_size(32)&lt;/code&gt; 와 같은 생성 된 필드 이름으로 캐시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">이것들은 컨테이너가 일반 React 컴포넌트에서 &lt;code&gt;this.props.relay&lt;/code&gt; 로 제공 할 메소드와 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">이 기능은 몇 가지 일반적인 시나리오에서 사용할 수 있습니다. 나중에 검사하기 위해 클라이언트 상태를 로깅하거나 브라우저의 디버거에서 저장소를 대화식으로 파킹합니다.</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">릴레이 생각</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">GraphQL로 생각하기</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">이 콜백 소품은 다양한 데이터 분석 이벤트가 발생할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">이 콜백 소품은 다양한 데이터 분석 이벤트가 발생할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">이는 렌더링 된 데이터를로드 하는 &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; 를 조건부로 렌더링하여 업그레이드 할 수 있습니다 . 새로운 API를 사용하면 코드 오버 헤드가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">새 데이터를 가져 오는 데 사용할 정확한 쿼리를 지정할 수 있는 &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; 를 사용하여 업그레이드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">이로 인해 생성 된 파일이 &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; 에 나타나고 런타임 아티팩트 (Relay Store에서 읽고 쓰는 데 도움이 됨)와 유형이 안전한 코드를 작성하는 데 도움이되는 &lt;a href=&quot;https://flow.org/&quot;&gt;흐름 유형&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">이 예는이 세 가지 가정을 모두 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">이 예제는 포괄적이지는 않지만 라이브러리의보다 자세한 사양에 들어가기 전에 일부 핵심 내용을 제공하기 위해 이러한 핵심 가정을 빠르게 소개하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">이 팻 쿼리는 다른 GraphQL 쿼리와 비슷하지만 중요한 차이점이 있습니다. 이러한 필드 중 일부는 스칼라가 아닌 것으로 알고 있지만 ( &lt;code&gt;friendEdge&lt;/code&gt; 및 &lt;code&gt;friends&lt;/code&gt; 등 ) 하위 쿼리를 통해 하위 항목의 이름을 지정하지 않았습니다. 이러한 방법으로, 우리는 릴레이로 나타내는 &lt;em&gt;것도&lt;/em&gt; 그 비 스칼라 필드에서이 돌연변이의 결과로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">이것은 생성 된 파일의 &quot;게으른&quot;요구로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">이것은 즉시 호출되는 함수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">bin 스크립트 &lt;code&gt;relay-compiler&lt;/code&gt; 가 node_modules 폴더에 설치됩니다. &lt;code&gt;package.json&lt;/code&gt; 파일에 스크립트를 추가하여 yarn / npm 스크립트에서이를 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이는 연속적으로 더 많은 페이지의 데이터를 가져 와서 항목 콜렉션을 통해 페이지를 매기는 일반적인 시나리오에 맞게 조정 된 범용 리 페치 컨테이너의 특수화입니다. 자세한 내용은 &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">지금까지 수신 된 이벤트 배열입니다 (아래 &lt;code&gt;ReadyStateEvent&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">장애가있는 경우 &lt;code&gt;Error&lt;/code&gt; 의 인스턴스입니다 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">이것은 단순한 예일뿐입니다. 실제로 캐시는 일대 다 연관 및 페이지 매김을 처리해야합니다 (다른 것들 중에서도).</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">이 만드는 일반적인 생성자 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 의 옵션으로 인스턴스를 &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;callbacks&lt;/code&gt; 및 &lt;code&gt;collisionKey&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">이것은 제품 코드가 릴레이에서 돌연변이를 처리 할 수있는 가장 낮은 추상화 레벨이며 &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL 사양에&lt;/a&gt; 설명 된 돌연변이 작업 ( &quot;쓰기 후 페치&quot;)에 해당합니다 . 돌연변이, 입력 및 쿼리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 데이터 요구 사항이 렌더링 준비 가 된 경우에 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">이는 렌더링에 필요한 데이터의 하위 집합이 준비된 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">이는 단일 구성 요소 내에서 중첩되거나 재귀적인 데이터를 처리 할 때 중복 조각을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">이 방법은 적절한 오류 전파를 촉진하기 위해 선택적으로 약속을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">이 메소드는 &lt;code&gt;setVariables&lt;/code&gt; 의 부분 변수 세트 가 적용된 후에도 호출 됩니다. 반환 된 변수는 조각을 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">이 방법은 일괄 쿼리를 용이하게하여 네트워크 효율성을 향상시키기 위해 단일 쿼리 대신 쿼리 배열을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; 를 사용하도록 업그레이드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">이 스 니펫 은 데이터가 준비되는 즉시 &lt;code&gt;ScrollView&lt;/code&gt; 구성 요소 내에서 &lt;code&gt;ProfilePicture&lt;/code&gt; 를 렌더링 하도록 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">이 스 니펫 은 데이터를 가져와야 할 때마다 &quot;로드 중 ...&quot;텍스트를 렌더링 하도록 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">이렇게하면 &lt;code&gt;graphql&lt;/code&gt; 태그가 포함 된 해당 파일과 같은 위치에 일련의 &lt;code&gt;__generated__&lt;/code&gt; 디렉토리 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">그러면 이 특정 필드가 배열임을 &lt;code&gt;Relay.QL&lt;/code&gt; 에 알립니다 . 또한 조각에 복수 이름을 사용할 수도 있습니다 (예 : &lt;code&gt;bars&lt;/code&gt; 대신 &lt;code&gt;bar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">이렇게하면 생성 된 파일 세 개와 &lt;code&gt;__generated__&lt;/code&gt; 디렉토리 두 개가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">새로운 페이지 매김 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">새 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">데이터 요구 사항이 변경되는 새 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">릴레이 구성 요소의 새 루트를 추가하려면</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">기본 컴포넌트에서이 메소드를 호출하려면 먼저 릴레이 컨테이너에 &lt;code&gt;componentRef&lt;/code&gt; 함수를 제공하십시오 . 이것은 기본 React Component가 아니라 Relay 컨테이너 자체에 대한 참조를 제공하는 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 함수를 제공하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">돌연변이를 저 지르려면</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Relay Modern에서 환경 인스턴스를 만들려면 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">사용하려면 &lt;a href=&quot;relay-compat&quot;&gt;호환성 모드를&lt;/a&gt; , &lt;code&gt;relay-compiler&lt;/code&gt; 쿼리에 대한 명명 규칙을 간단을 적용합니다. 쿼리 이름은 &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; 이어야하며 여기서 &quot;&amp;lt;OperationType&amp;gt;&quot;은 &quot;Query&quot;, &quot;Mutation&quot;또는 &quot;Subscription&quot;중 하나입니다. 위의 쿼리 이름은 &lt;code&gt;ExampleQuery&lt;/code&gt; 이므로 &lt;code&gt;Example.js&lt;/code&gt; 에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">이 코드를 실행하려면 Relay는 스키마에 액세스해야합니다. 스키마는 너무 커서 애플리케이션 내부에 번들로 묶을 수 없습니다. 대신 이러한 &lt;code&gt;Relay.QL&lt;/code&gt; 템플릿 표현식은 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 을 통해 JavaScript 설명으로 변환됩니다 . 이 스키마 정보를 통해 Relay는 필드 인수 유형, 연결 또는 목록 인 필드 및 서버에서 레코드를 효율적으로 다시 가져 오는 방법과 같은 사항을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">구성 요소를 강제로 가져 오려면</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Relay 애플리케이션을 구축하려면 다음 세 가지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">인식 된 응답 성을 향상시키기 위해 서버의 응답이 다시 시작되기 전에 클라이언트가 예상되는 새 값을 반영하도록 즉시 업데이트하는 &quot;낙관적 업데이트&quot;를 수행 할 수 있습니다. 우리는 &lt;code&gt;optimisticResponse&lt;/code&gt; 를 제공하고 이를 &lt;code&gt;commitMutation&lt;/code&gt; 에 전달 하는 &lt;code&gt;config&lt;/code&gt; 추가함으로써이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">연결을 통해 페이지 매김</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">캐시에서 읽기 위해 쿼리를 수행하고 각 필드를 해결할 수 있습니다. 그러나 기다립니다 : GraphQL 서버가 쿼리를 처리 할 때와 &lt;em&gt;정확히&lt;/em&gt; 같습니다. 그리고 그건! 캐시에서 읽는 것은 실행기의 특수한 경우입니다. 티.</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">시작하려면 사용자의 프로필 사진과 사진 크기를 조정하는 슬라이더를 표시 하는 일반 React 버전의 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 구성 요소를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">시작하려면 &lt;code&gt;Todo&lt;/code&gt; 의 텍스트 및 완료 상태를 표시하는 일반 React 버전의 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 컴포넌트를 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">컴포넌트의 변수를 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">릴레이 컴파일러를 사용하려면 GraphQL 서버의 API를 설명하는 .graphql 또는 .json GraphQL 스키마 파일이 필요합니다. 일반적으로 이러한 파일은 서버 진실 소스의 로컬 표현이며 직접 편집되지 않습니다. 예를 들어 &lt;code&gt;schema.graphql&lt;/code&gt; 과 같은 schema.graphql 이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">우리가 데이터를 가져 오기 위해 서버로 보낼 수있는 본격적인 GraphQL 쿼리를 구성하지는이 조각을 사용하려면, 우리는 사용할 필요가 &lt;strong&gt;Relay.RootContainer을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">일반적인 릴레이 클래식 코드 :</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">전형적인 예전 코드 :</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">일반적으로 생성 된 정의를 가져올 필요가 없습니다. &lt;a href=&quot;babel-plugin-relay&quot;&gt;릴레이 바벨 플러그인은&lt;/a&gt; 변환합니다 &lt;code&gt;graphql&lt;/code&gt; 하는 리터럴 &lt;code&gt;require()&lt;/code&gt; 생성 된 파일을.</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">후드 아래에서 기본 네트워크 계층은 &lt;code&gt;fetch&lt;/code&gt; ( &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt; )를 사용합니다. &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 의 생성자 는 &lt;code&gt;fetch&lt;/code&gt; 가 허용하는 유효한 초기화 속성을 수락하는 선택적 두 번째 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">쿼리와 달리 돌연변이에 대한 실패한 요청은 자동으로 재 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">지금까지는 데이터를 가져 오는 쿼리를 수행하기 위해 GraphQL 엔드 포인트와 만 상호 작용했습니다. 이 가이드에서는 릴레이를 사용하여 데이터 저장소에 대한 쓰기와 변경된 필드 가져 오기로 구성된 돌연변이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">필드 이름 및 사전 정의 된 인수 값을 나타내는 오브젝트를 소스로 이동하여 변경 가능한 레코드와 연관된 레코드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">필드 이름과 사전 정의 된 인수 값을 나타내는 객체가 제공하는 가변 레코드 속성의 값을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">각 응답에서 클라이언트 업데이트</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">클라이언트를 낙관적으로 업데이트</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">쿼리 / 돌연변이 응답을받은 후 로컬 캐시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">프로그래밍 방식으로 상점 업데이트 (고급)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">반응 릴레이 v1.0.0으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">setVariables 업그레이드</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">&lt;code&gt;introspectionQuery&lt;/code&gt; 를 사용 하여 Babel Relay 플러그인에 대한 스키마 JSON 을 생성하고 &lt;code&gt;printSchema&lt;/code&gt; 를 사용하여 사용자가 읽을 수있는 유형 시스템 속기를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">다른 GraphQL 구현 사용</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">캐시 사용</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">&quot; &lt;a href=&quot;relay-compat&quot;&gt;호환 모드&lt;/a&gt; &quot; 에서 변환 중에 사용</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">Relay Classic과 함께 사용</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">View 구성은 여러분이 사용하는 &lt;em&gt;것과 정확히 일치&lt;/em&gt; 합니다. 릴레이 컨테이너는 표준 React 구성 요소입니다. &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 구성 요소 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">View 구성은 여러분이 사용하는 &lt;em&gt;것과 정확히 일치&lt;/em&gt; 합니다. 릴레이 컨테이너는 표준 React 구성 요소입니다. &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 컴포넌트 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">워밍업</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">변환 프로세스에 도움이되는 몇 가지 스크립트를 작성했습니다. &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt; 에서 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; prop 을 제공하여이 동작을 변경할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">각 변이의 응답을 사용하여 클라이언트 측 저장소를 업데이트하는 방법에 대한 구성 배열 형태로 Relay 명령을 제공 할 수 있습니다. 다음 돌연변이 유형 중 하나 이상으로 돌연변이를 구성하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">컨테이너와 마찬가지로 돌연변이의 데이터 의존성을 여기에 선언합니다. 이것은이 돌연변이의 낙관적 반응에 사용하고자하는 일련의 필드를 가져 오는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">보물을 숨길 곳, 보물의 숨은 곳을 확인하는 방법, 남은 차례를 추적하는 방법이 필요합니다. 이 튜토리얼의 목적 상 이러한 데이터를 메모리에 숨길 것입니다.</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">클라이언트 측 저장소를 업데이트하기 위해 각 돌연변이의 응답 페이로드를 사용하는 방법에 대한 릴레이 지침을 제공해야합니다. 다음 돌연변이 유형 중 하나 이상으로 돌연변이를 구성하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">우리는 궁극적으로 정적 메소드에 정착했습니다. 구성 요소는 뷰 트리와 별개로 데이터 종속성을 설명하는 쿼리 트리를 효과적으로 반환합니다. 그런 다음 릴레이는이 쿼리 트리를 사용하여 단일 단계에서 필요한 모든 정보를 가져 와서이를 사용하여 구성 요소를 렌더링 할 수 있습니다. 문제는 쿼리 트리를 설명하는 적절한 메커니즘과 서버에서 효율적으로 가져 오는 방법 (예 : 단일 네트워크 요청)을 찾는 것이 었습니다. GraphQL의 완벽한 유스 케이스는 특정 API를 지정하지 않고 &lt;em&gt;데이터 종속성을 data로 설명&lt;/em&gt; 하는 구문을 제공하기 때문 입니다. Promises and Observables는 대체 방법으로 제안되는 경우가 많지만 &lt;em&gt;불투명 한 명령&lt;/em&gt; 을 나타내며 쿼리 일괄 처리와 같은 다양한 최적화를 배제합니다.</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">이제 스토리에 액세스하는 방법에 따라 다른 &lt;code&gt;likeCount&lt;/code&gt; 가 표시됩니다. 첫 번째 쿼리를 사용하는 뷰에는 오래된 카운트가 표시되고 두 번째 쿼리를 사용하는 뷰에는 업데이트 된 카운트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">우리는 Relay가 이러한 구성 요소에 대한 데이터 요구 사항을 충족하고 렌더링 할 수 있도록 거의 준비가되었습니다. 그러나 한 가지 문제가 있습니다. GraphQL로 데이터를 실제로 가져 오려면 쿼리 루트가 필요합니다. 예를 들어, &lt;code&gt;User&lt;/code&gt; 유형의 콘크리트 노드에서 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 단편 을 접지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">GraphQL 스키마가 데이터가 디스크에 저장되는 형식과 약간 또는 실질적으로 다른 것이 일반적이라는 것을 알았습니다. 간단히 말해 : 기본 &lt;em&gt;데이터 스토리지&lt;/em&gt; (디스크)의 데이터 변경 사항과 &lt;em&gt;제품 가시적 스키마&lt;/em&gt; (GraphQL)의 데이터 변경 사항이 항상 1 : 1로 일치하는 것은 아닙니다 . 이것의 완벽한 예는 프라이버시입니다. &lt;code&gt;age&lt;/code&gt; 와 같은 사용자 대면 필드를 반환 하려면 데이터 스토리지 계층에서 수많은 레코드에 액세스하여 활성 사용자가 해당 &lt;code&gt;age&lt;/code&gt; 를 &lt;em&gt;볼&lt;/em&gt; 수 있는지 여부를 결정해야합니다 (나의 친구입니까? ? 내가 널 막았 니? 등).</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">우리는 명령형 API를 사용한 데이터 페칭에 대한 일반적인 접근 방식으로 인해 개발자가 이러한 비 필수 복잡성을 너무 많이 처리해야합니다. 예를 들어 &lt;em&gt;낙관적 UI 업데이트를&lt;/em&gt; 고려하십시오 . 서버 응답을 기다리는 동안 사용자에게 피드백을 제공하는 방법입니다. 해야 할 &lt;em&gt;일&lt;/em&gt; 의 논리는 매우 명확 할 수 있습니다. 사용자가 &quot;좋아요&quot;를 클릭하면 스토리를 좋아하는 것으로 표시하고 요청을 서버에 보냅니다. 그러나 구현은 종종 훨씬 더 복잡합니다. 명령 방식을 사용하려면 UI에 도달하고 버튼을 토글하고, 네트워크 요청을 시작하고, 필요한 경우 다시 시도하고, 실패하면 오류를 표시하고 (버튼을 토글 해제) 등의 모든 단계를 구현해야합니다. 데이터도 마찬가지입니다. -fetching : 지정 &lt;em&gt;어떤&lt;/em&gt; 데이터가 우리가 흔히 지시 필요&lt;em&gt;&lt;/em&gt;가져 오는 &lt;em&gt;방법&lt;/em&gt; 과 &lt;em&gt;시기&lt;/em&gt; . 다음으로 이러한 관심사를 &lt;strong&gt;Relay&lt;/strong&gt; 로 해결하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">릴레이 컨테이너 는 구성 요소가 렌더링 &lt;em&gt;되기 전에&lt;/em&gt; GraphQL 조각을 가져 오는 것을 확인했습니다 . 그러나 컨테이너는 또한 즉시 눈에 띄지 않는 또 다른 이점 인 &lt;strong&gt;데이터 마스킹을 제공&lt;/strong&gt; 합니다. 릴레이는 구성 요소가 &lt;code&gt;fragments&lt;/code&gt; 구체적으로 요청하는 데이터에만 액세스 할 수 있도록합니다 . 따라서 한 구성 요소가 Story의 &lt;code&gt;text&lt;/code&gt; 를 작성하고 다른 구성 요소 가 &lt;code&gt;author&lt;/code&gt; 하면 각 구성 요소 는 자신이 요청한 필드 &lt;em&gt;만&lt;/em&gt; 볼 수 있습니다 . 실제로 구성 요소는 &lt;em&gt;자식이&lt;/em&gt; 요청한 데이터를 볼 수도 없습니다 . 캡슐화가 깨질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">우리가 작성한 것은 모의 데이터베이스 인터페이스입니다. 이것을 실제 데이터베이스에 연결하는 것을 상상할 수 있지만 지금은 계속 진행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">무엇과 함께 작동합니까? 릴레이 컴 패트 ( &lt;code&gt;'react-relay/compat'&lt;/code&gt; )가 가장 유연합니다. Compat 구성 요소 및 돌연변이는 모든 것이 사용할 수 있습니다. Compat 구성 요소에는 모든 종류의 자식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">&quot;강제 반입&quot;인 경우 서버 요청이 완료되기 전에 클라이언트에서 데이터를 사용할 수있어 &lt;code&gt;ready&lt;/code&gt; 가 완료된 경우 에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">때 &lt;code&gt;forceFetch&lt;/code&gt; 가 사실이고 &lt;code&gt;renderFetched&lt;/code&gt; 가 가능한 클라이언트 데이터의 결과라고, &lt;code&gt;renderFetched&lt;/code&gt; 는 있는 두 번째 인수로 호출 &lt;code&gt;stale&lt;/code&gt; 부울 속성을. &lt;code&gt;stale&lt;/code&gt; 경우 속성은 true입니다 &lt;code&gt;renderFetched&lt;/code&gt; 가 강제 서버 요청이 완료되기 전에 호출된다.</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">때 &lt;code&gt;forceFetch&lt;/code&gt; 는 사실, &lt;strong&gt;Relay.RootContainer는&lt;/strong&gt; 항상 서버에 요청을 보낼 것입니다. 그러나 렌더링에 필요한 모든 데이터를 클라이언트에서도 사용할 수 &lt;code&gt;renderFetched&lt;/code&gt; 서버 요청이 완료되기 전에 여전히 renderFetched 가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Relay가 데이터를 충족 하면 현재 &quot;준비 상태&quot;를 설명하는 객체를 사용 하여 &lt;code&gt;onReadyStateChange&lt;/code&gt; 콜백이 한 번 이상 호출됩니다. 이 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">렌더링에 필요한 모든 데이터를 사용할 수있게되면 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 기본적으로 제공된 &lt;code&gt;Component&lt;/code&gt; 를 렌더링합니다 . 그러나 &lt;code&gt;renderFetched&lt;/code&gt; prop에 콜백을 제공하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">모든 데이터 요구 사항이 충족되면 &lt;code&gt;renderFetched&lt;/code&gt; 가 호출되어 뷰를 렌더링합니다. 이 콜백은 &lt;code&gt;data&lt;/code&gt; 를 렌더링 할 때 제공된 &lt;code&gt;Container&lt;/code&gt; 로 데이터 를 분산시킬 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">프로덕션 배포를위한 코드를 컴파일 할 때 유효성 검사 문제가 발생하면 즉시 플러그인이 구성되도록 할 수 있습니다. 다음 옵션을 사용하여 다양한 환경에 맞게 플러그인을 추가로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">데이터 요구 사항이 충족되지 않으면 뷰를 렌더링하기 위해 &lt;code&gt;renderFailure&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">데이터 요구 사항이 아직 충족되지 않은 경우 뷰를 렌더링하기 위해 &lt;code&gt;renderLoading&lt;/code&gt; 이 호출됩니다. 이것이 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 이전에 렌더링 된 뷰 (또는 이전 뷰가없는 경우 아무것도)가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">뚱뚱한 쿼리를 디자인 할 때는 현재 응용 프로그램에서 사용중인 데이터뿐만 아니라 돌연변이로 인해 변경 될 수있는 &lt;em&gt;모든&lt;/em&gt; 데이터를 고려 하십시오. 오버 페칭에 대해 걱정할 필요가 없습니다. 이 쿼리는 애플리케이션에 실제로 필요한 데이터의 '추적 쿼리'와 먼저 교차하지 않고 실행되지 않습니다. 팻 쿼리에서 필드를 생략하면 향후 새로운 데이터 종속성이있는 뷰를 추가하거나 기존 뷰에 새로운 데이터 종속성을 추가 할 때 데이터 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Relay Classic 앱을 Relay Modern으로 증분 변환 할 때 호환 모드를 사용하도록 구성된 경우 &lt;code&gt;graphql&lt;/code&gt; 리터럴을 &lt;em&gt;두&lt;/em&gt; 런타임 에서 &lt;em&gt;모두&lt;/em&gt; 사용할 수 있도록 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">쿼리를 보내면 15 초 시간 초과 후 자동으로 요청이 실패합니다. 또한 실패한 요청은 각각 1 초 지연과 3 초 지연으로 자동으로 두 번 재 시도됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
