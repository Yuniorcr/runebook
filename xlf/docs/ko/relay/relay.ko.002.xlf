<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="relay">
    <body>
      <group id="relay">
        <trans-unit id="330b3e499c3450d42634b5702213e434b7a82a41" translate="yes" xml:space="preserve">
          <source>Routes are responsible for defining the entry points into a Relay application. But in order to understand why routes are necessary, we must first understand the difference between GraphQL queries and fragments.</source>
          <target state="translated">경로는 릴레이 응용 프로그램에 진입 점을 정의하는 역할을합니다. 그러나 라우트가 필요한 이유를 이해하려면 먼저 GraphQL 쿼리와 프래그먼트의 차이점을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="ae0f139d125aa65c3494e803bdab2bfc2845048a" translate="yes" xml:space="preserve">
          <source>Routes can declare a set of parameter names that are required to be supplied to the constructor. This is also a convenient place to document the set of valid parameters.</source>
          <target state="translated">라우트는 생성자에 제공해야하는 매개 변수 이름 세트를 선언 할 수 있습니다. 또한 유효한 매개 변수 세트를 문서화하기에 편리한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="e5ec9f7b8ea16c97f062b9386937889c5390bd89" translate="yes" xml:space="preserve">
          <source>Routes can use &lt;code&gt;prepareParams&lt;/code&gt; to provide default parameters, or pass through, convert or suppress passed-in parameters.</source>
          <target state="translated">라우트는 &lt;code&gt;prepareParams&lt;/code&gt; 매개 변수를 사용 하여 기본 매개 변수를 제공하거나 전달 된 매개 변수를 통과, 변환 또는 억제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a04e20b09d66a6ec94b9fd8e8520062229d58d02" translate="yes" xml:space="preserve">
          <source>Routes must declare a set of query roots using &lt;code&gt;Relay.QL&lt;/code&gt;. These queries will automatically compose a matching fragment named &lt;code&gt;queryName&lt;/code&gt; on the Relay container used with this route on a &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">라우트는 &lt;code&gt;Relay.QL&lt;/code&gt; 을 사용하여 쿼리 루트 세트를 선언해야합니다 . 이러한 쿼리는 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 의이 경로와 함께 사용되는 Relay 컨테이너에서 &lt;code&gt;queryName&lt;/code&gt; 이라는 일치하는 조각을 자동으로 작성 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fd81fc06977ad2c7156abd14b5b9caa0f8c40fc2" translate="yes" xml:space="preserve">
          <source>Routes must define a string name.</source>
          <target state="translated">경로는 문자열 이름을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="380338bdec53655cfe9114fa55d7fe1d8bdbb27d" translate="yes" xml:space="preserve">
          <source>Routes no longer need to know anything about the query root in Relay Modern. Relay components can be rendered anywhere wrapped in a &lt;code&gt;QueryRenderer&lt;/code&gt;. This should bring more flexibility around picking routing frameworks.</source>
          <target state="translated">라우트는 더 이상 Relay Modern의 쿼리 루트에 대해 알 필요가 없습니다. 릴레이 구성 요소는 &lt;code&gt;QueryRenderer&lt;/code&gt; 에 싸여있는 곳이면 어디든지 렌더링 할 수 있습니다 . 이는 라우팅 프레임 워크 선택에 더 많은 유연성을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d15dd1bec2e055c5b177c9f869305ae6c54c9bb" translate="yes" xml:space="preserve">
          <source>Routing</source>
          <target state="translated">Routing</target>
        </trans-unit>
        <trans-unit id="15f12d3d79029156026af15a57e839303e093597" translate="yes" xml:space="preserve">
          <source>Run the Relay Compiler after making changes to any GraphQL in your Relay application. It may be helpful to add it as a &lt;code&gt;yarn script&lt;/code&gt;. Add an entry to &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; in your package.json file.</source>
          <target state="translated">릴레이 애플리케이션에서 GraphQL을 변경 한 후 릴레이 컴파일러를 실행하십시오. &lt;code&gt;yarn script&lt;/code&gt; 로 추가하는 것이 도움이 될 수 있습니다 . package.json 파일의 &lt;code&gt;&quot;scripts&quot;&lt;/code&gt; 에 항목을 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="3c5a064ba8a60e5ab65def399ab519978d73b564" translate="yes" xml:space="preserve">
          <source>Runtime Architecture</source>
          <target state="translated">런타임 아키텍처</target>
        </trans-unit>
        <trans-unit id="b5230ecdf4e78f0dd162281a0a78c6cdc853cbe8" translate="yes" xml:space="preserve">
          <source>Schema</source>
          <target state="translated">Schema</target>
        </trans-unit>
        <trans-unit id="1f0e625b220c0a58aba2033abe91bfe01285293e" translate="yes" xml:space="preserve">
          <source>Schema JSON</source>
          <target state="translated">스키마 JSON</target>
        </trans-unit>
        <trans-unit id="114b03b7a51c1001385ac516c6fa621d46453f66" translate="yes" xml:space="preserve">
          <source>Second, any subscriptions that do have overlapping data IDs are re-read, and the new/previous results are compared. If the result has not changed, the subscription is ignored (this can occur if a field of a record changed that is not relevant to the subscription's selector), otherwise processing continues.</source>
          <target state="translated">둘째, 데이터 ID가 겹치는 구독을 다시 읽고 새 / 이전 결과를 비교합니다. 결과가 변경되지 않은 경우 구독이 무시되고 (이는 구독의 선택기와 관련이없는 레코드 필드가 변경된 경우 발생할 수 있음) 그렇지 않으면 처리가 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="3e32d234cf8a398d348341552d4472b71aa02309" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; for methods available on the argument object.</source>
          <target state="translated">인수 오브젝트에서 사용 가능한 메소드는 &lt;a href=&quot;interfaces-relay-mutation-request&quot;&gt;RelayMutationRequest&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ba186dff4700bd97150240f3ab29c29fbc1b7fc5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; for methods available on the argument objects.</source>
          <target state="translated">인수 오브젝트에서 사용 가능한 메소드는 &lt;a href=&quot;interfaces-relay-query-request&quot;&gt;RelayQueryRequest&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="0ebcd737a1bf60dbd1447977c888467e35a467a0" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation &amp;gt; Constructor&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;#constructor&quot;&gt;GraphQLMutation&amp;gt; 생성자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb08c52e72850acd0139ed4cb2152c144c9e58eb" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51b02cf1878520658c9b88fe67978bf776e01dd9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation::getCollisionKey()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;api-reference-relay-mutation#getcollisionkey&quot;&gt;Relay.Mutation :: getCollisionKey ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8665daeb214113b0a6222a07deb324960005a817" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation::getConfigs()&lt;/a&gt;</source>
          <target state="translated">참고 : &lt;a href=&quot;api-reference-relay-mutation#getconfigs-abstract-method&quot;&gt;Relay.Mutation :: getConfigs ()&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9701bc69d708978bae12176bd6d6b49b6310b158" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#relay-containers&quot;&gt;Containers &amp;gt; Relay Containers&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-containers#relay-containers&quot;&gt;컨테이너&lt;/a&gt; : 릴레이 컨테이너</target>
        </trans-unit>
        <trans-unit id="f63708739a0519c20cb04d22aed0623da8910a3b" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;Containers &amp;gt; Requesting Different Data&lt;/a&gt;, &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-containers#requesting-different-data&quot;&gt;컨테이너&amp;gt; 다른 데이터 요청&lt;/a&gt; , &lt;a href=&quot;guides-ready-state&quot;&gt;준비 상태&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb81a25d0442cce928322c7171025b8b9f41ba2d" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;돌연변이&amp;gt; 조각 변수&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252cc9e75017b1ba4bc6a1cab81814c7c5e7b9c1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;Mutations &amp;gt; Fragment variables&lt;/a&gt; and &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#fragment-variables&quot;&gt;돌연변이&amp;gt; 조각 변수&lt;/a&gt; 및 &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c325d76133ada9407e339b00806d08a492686a72" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;Mutations &amp;gt; Mutator configuration&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#mutator-configuration&quot;&gt;돌연변이&amp;gt; 뮤 테이터 구성&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec1a4ead3e670cf9b7225817b2d5536e60b9dfc8" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic Updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f91e5359d2e437a1fabed213a7400919e36a4e8f" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;Mutations &amp;gt; Optimistic updates&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#optimistic-updates&quot;&gt;돌연변이&amp;gt; 낙관적 업데이트&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14ec07edd61e594362c3ba2c69cd02521e8cd7" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;Mutations &amp;gt; The fat query&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-mutations#the-fat-query&quot;&gt;돌연변이&amp;gt; 팻 쿼리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c9e106abf2efb7313ca2aef582895208bb3b4a9" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-ready-state&quot;&gt;Ready State&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-ready-state&quot;&gt;준비 상태&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d33a51e631c54521d230f0b77c33a0ffcb95a9e" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;Root Container &amp;gt; Component and Route&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-root-container#component-and-route&quot;&gt;루트 컨테이너&amp;gt; 구성 요소 및 경로를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ba9c7676225015beb8fcd0dc8154429cc521b19" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;Root Container &amp;gt; Force Fetching&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-root-container#force-fetching&quot;&gt;루트 컨테이너&amp;gt; 강제 가져 오기를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d475a6214b773e645b11e09318c20c3c31900a2" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;Root Container &amp;gt; renderFailure&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderfailure&quot;&gt;루트 컨테이너&amp;gt; renderFailure&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="592bf7ec077fdbfb9bb08cfe9e7520a4dc086e1c" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;Root Container &amp;gt; renderFetched&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderfetched&quot;&gt;루트 컨테이너&amp;gt; renderFetched&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6a187f3307739f3f97bdae9d053fcff505ffdeb1" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-root-container#renderloading&quot;&gt;Root Container &amp;gt; renderLoading&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;guides-root-container#renderloading&quot;&gt;루트 컨테이너&amp;gt; renderLoading&lt;/a&gt; 도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fcf798559587d9befe424605fcb71c2af445685" translate="yes" xml:space="preserve">
          <source>See also: &lt;a href=&quot;guides-routes&quot;&gt;Routes&lt;/a&gt;</source>
          <target state="translated">참조 : &lt;a href=&quot;guides-routes&quot;&gt;경로&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ebcb2b8f4a703f0b6653cd4eb5e389d3a9e4f41" translate="yes" xml:space="preserve">
          <source>See our relay-compiler section in our &lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;Installation and Setup guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;installation-and-setup#set-up-relay-compiler&quot;&gt;설치 및 설정 가이드&lt;/a&gt; 의 릴레이 컴파일러 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="ac40c2c295e0947fa5d231ce927c5f063044cb9e" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-proptypes&quot;&gt;PropTypes의 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db3136f0089c09e6cfa1ecac38be1bb1698a01e9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-ql&quot;&gt;Relay.QL의 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46ebdef898489cac49931005986e50860c184084" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;api-reference-relay-store&quot;&gt;Store API reference&lt;/a&gt;.</source>
          <target state="translated">참고 항목 &lt;a href=&quot;api-reference-relay-store&quot;&gt;저장 API 참조&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5e868bde5bb210d570e0bf68dfd4f714decc2503" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container docs&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;fragment-container#passing-arguments-to-a-fragment&quot;&gt;Fragment Container 문서&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="4011d8e185ce992ad373c12339d3c386a366a9d9" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-mutations&quot;&gt;Mutations Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-mutations&quot;&gt;돌연변이 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="85e710dc6095fa7ec6992d17389697e3d05b22af" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-network-layer&quot;&gt;Network Layer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-network-layer&quot;&gt;네트워크 계층 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f586115c09169458b9424f28db540ede9b2d7ddf" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-root-container&quot;&gt;RootContainer Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-root-container&quot;&gt;RootContainer 안내서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7e49836605664cff515afd9b044294d9e1deeee" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;guides-routes&quot;&gt;Routes Guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;guides-routes&quot;&gt;Routes Guide를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="076a9d109c3f1a2389e316e443efa40d8f78df54" translate="yes" xml:space="preserve">
          <source>Server Error</source>
          <target state="translated">서버 오류</target>
        </trans-unit>
        <trans-unit id="6b17482f3f882455ee584aa25321c5bdac980242" translate="yes" xml:space="preserve">
          <source>Set up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay 설정</target>
        </trans-unit>
        <trans-unit id="8a05cf798da4421d2bd58da023c7f3fb287cd45f" translate="yes" xml:space="preserve">
          <source>Set up relay-compiler</source>
          <target state="translated">릴레이 컴파일러 설정</target>
        </trans-unit>
        <trans-unit id="f72f8a571d6e8bf5eec6f1a2a44a50aeba5d7932" translate="yes" xml:space="preserve">
          <source>Setting up Relay Compiler</source>
          <target state="translated">릴레이 컴파일러 설정</target>
        </trans-unit>
        <trans-unit id="4d8e8804be8f7d9838f29acdb1972f43499e72bb" translate="yes" xml:space="preserve">
          <source>Setting up babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay 설정</target>
        </trans-unit>
        <trans-unit id="abeed86f05bd23992570bff235c3a5eea268d38d" translate="yes" xml:space="preserve">
          <source>Show More</source>
          <target state="translated">자세히보기</target>
        </trans-unit>
        <trans-unit id="c0d8810501ac79b3d67791d7c14301a445bdcd5c" translate="yes" xml:space="preserve">
          <source>Similar to how a React component's &lt;code&gt;render&lt;/code&gt; method does not directly modify native views, Relay containers do not directly fetch data. Instead, containers declare a &lt;em&gt;specification&lt;/em&gt; of the data needed to render. Relay guarantees that this data is available &lt;em&gt;before&lt;/em&gt; rendering.</source>
          <target state="translated">React 컴포넌트의 &lt;code&gt;render&lt;/code&gt; 메소드가 기본 뷰를 직접 수정하지 않는 방식과 유사하게 릴레이 컨테이너는 데이터를 직접 가져 오지 않습니다. 대신 컨테이너 는 렌더링에 필요한 데이터 &lt;em&gt;사양&lt;/em&gt; 을 선언합니다 . 릴레이는 렌더링 &lt;em&gt;전에이&lt;/em&gt; 데이터를 사용할 수 있음을 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="c15fa4b758d35cc97d9959bcc45edd294156d605" translate="yes" xml:space="preserve">
          <source>Simple Example</source>
          <target state="translated">간단한 예</target>
        </trans-unit>
        <trans-unit id="88286b84c7253d721eb28be982c48ae3b8c8564f" translate="yes" xml:space="preserve">
          <source>Simpler Mutation API</source>
          <target state="translated">더 간단한 돌연변이 API</target>
        </trans-unit>
        <trans-unit id="38b269b106dd0853215c15032c144a95de107505" translate="yes" xml:space="preserve">
          <source>Since Relay containers define fragments and not queries, they can be easily embedded in multiple contexts. Like React components, Relay containers are highly reusable.</source>
          <target state="translated">릴레이 컨테이너는 쿼리가 아닌 조각을 정의하므로 여러 컨텍스트에 쉽게 포함될 수 있습니다. React 구성 요소와 마찬가지로 릴레이 컨테이너는 재사용 성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="eed3231995e285304e7921a2b3b7268f678be407" translate="yes" xml:space="preserve">
          <source>Since one game can have many hiding spots, we need to create a connection that we can use to link them together.</source>
          <target state="translated">하나의 게임에는 많은 숨은 지점이있을 수 있으므로 서로 연결하는 데 사용할 수있는 연결을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="1bc4c3be89589c1b9cbd3e1e89f801487097b78c" translate="yes" xml:space="preserve">
          <source>Smaller Bundle Size</source>
          <target state="translated">작은 번들 크기</target>
        </trans-unit>
        <trans-unit id="eae26374639c4e0cc2a093a378a0ac3891ecab5b" translate="yes" xml:space="preserve">
          <source>So far we looked at the lower-level aspects of data-fetching and saw how various familiar concepts translate to GraphQL. Next, let's step back and look at some higher-level concerns that product developers often face around data-fetching:</source>
          <target state="translated">지금까지 데이터 페치의 하위 레벨을 살펴보고 다양한 친숙한 개념이 GraphQL로 어떻게 변환되는지 살펴 보았습니다. 다음으로 물러서서 제품 개발자가 데이터 페치에 대해 자주 직면하는 몇 가지 높은 수준의 문제를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d0fc3a75755e472cad5df2903a8721c7c36d0bc7" translate="yes" xml:space="preserve">
          <source>So far we're just using GraphQL as a more efficient version of typical REST approaches. Note two important benefits in the GraphQL version:</source>
          <target state="translated">지금까지 우리는 GraphQL을 전형적인 REST 접근법의보다 효율적인 버전으로 사용하고 있습니다. GraphQL 버전의 두 가지 중요한 이점에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="d2a06967c509756a257c5cfbc8a853322fb784a3" translate="yes" xml:space="preserve">
          <source>So far we've looked at the process of querying data and keeping views up to date, but we haven't looked at writes. In GraphQL, writes are called &lt;strong&gt;mutations&lt;/strong&gt;. We can think of them as queries with side effects. Here's an example of calling a mutation that might mark a given story as being liked by the current user:</source>
          <target state="translated">지금까지 우리는 데이터를 쿼리하고 뷰를 최신 상태로 유지하는 프로세스를 살펴 봤지만 쓰기는 살펴 보지 않았습니다. GraphQL에서 쓰기를 &lt;strong&gt;mutations&lt;/strong&gt; 라고 합니다. 그것들을 부작용이있는 쿼리라고 생각할 수 있습니다. 주어진 스토리를 현재 사용자가 좋아하는 것으로 표시 할 수있는 돌연변이를 호출하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5fb4c3d88d69385cf7a448a7c57e653bef0ce88f" translate="yes" xml:space="preserve">
          <source>So far, we've covered two pieces that each contribute to declaring data:</source>
          <target state="translated">지금까지 데이터 선언에 기여하는 두 가지 부분을 살펴 보았습니다.</target>
        </trans-unit>
        <trans-unit id="647475236d1bc60d884c2b35b08e1b42225bc0f4" translate="yes" xml:space="preserve">
          <source>So for our &lt;code&gt;introduceShip&lt;/code&gt; mutation, we create two types: &lt;code&gt;IntroduceShipInput&lt;/code&gt; and &lt;code&gt;IntroduceShipPayload&lt;/code&gt;:</source>
          <target state="translated">따라서 &lt;code&gt;introduceShip&lt;/code&gt; 돌연변이를 위해 &lt;code&gt;IntroduceShipInput&lt;/code&gt; 및 &lt;code&gt;IntroduceShipPayload&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b153876a947507c9e895bf7e190b67952746372" translate="yes" xml:space="preserve">
          <source>So how do we use this cache? Let's look at two operations: writing to the cache when a response is received, and reading from the cache to determine if a query can be fulfilled locally (the equivalent to &lt;code&gt;_cache.has(key)&lt;/code&gt; above, but for a graph).</source>
          <target state="translated">이 캐시를 어떻게 사용합니까? 응답이 수신 될 때 캐시에 쓰는 것과 캐시에서 읽는 쿼리를 로컬로 수행 할 수 있는지 여부 &lt;code&gt;_cache.has(key)&lt;/code&gt; 위의 _cache.has (key) 와 같지만 그래프) 를 확인하는 두 가지 작업을 살펴 ​​보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="ecc4d54395356b7b485a16f80a383e1e01836248" translate="yes" xml:space="preserve">
          <source>So now we know the ID of the Rebels in our system. We can now refetch them:</source>
          <target state="translated">이제 우리는 우리 시스템에서 반란군의 ID를 알고 있습니다. 이제 다시 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a920cd8724dc921d9d4f9bdbe2e23494f550470" translate="yes" xml:space="preserve">
          <source>So on the first query for ships, GraphQL told us there was a next page, but on the next one, it told us we'd reached the end of the connection.</source>
          <target state="translated">따라서 선박에 대한 첫 번째 쿼리에서 GraphQL은 다음 페이지가 있다고 말했지만 다음 페이지에서는 연결이 끝났다고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="7d3d5c6eef5a80a3513fea5675a4ae9df60ad431" translate="yes" xml:space="preserve">
          <source>Some fields - especially those for paginated data - can require post-processing on the client in order to merge previously fetched data with new information. Relay Modern supports custom field handlers that can be used to process these fields to work with various pagination patterns and other use cases.</source>
          <target state="translated">일부 필드 (특히 페이지가 매겨진 데이터의 필드)는 이전에 가져온 데이터를 새로운 정보와 병합하기 위해 클라이언트에서 사후 처리가 필요할 수 있습니다. Relay Modern은 다양한 페이지 매김 패턴 및 기타 사용 사례를 처리하기 위해 이러한 필드를 처리하는 데 사용할 수있는 사용자 정의 필드 핸들러를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="adccc4f5e80b41c5617710fc459b4ed3934af747" translate="yes" xml:space="preserve">
          <source>Sometimes a parent needs to override the default variables of a child component. Imagine that we want to render &lt;code&gt;Child&lt;/code&gt; above with a photo size of 128 instead of the default 64. To do this, we have to ensure that both the fragment &lt;em&gt;and&lt;/em&gt; the container know about the custom variable. To set a custom variable in the &lt;em&gt;query&lt;/em&gt;, use the second argument to &lt;code&gt;getFragment&lt;/code&gt;:</source>
          <target state="translated">때로는 부모가 자식 구성 요소의 기본 변수를 재정의해야합니다. 기본 64 대신 사진 크기가 128 인 &lt;code&gt;Child&lt;/code&gt; 를 렌더링한다고 가정합니다. 이렇게하려면 조각 &lt;em&gt;과&lt;/em&gt; 컨테이너 모두 사용자 지정 변수에 대해 알고 있어야합니다. &lt;em&gt;쿼리&lt;/em&gt; 에서 사용자 정의 변수를 설정하려면 &lt;code&gt;getFragment&lt;/code&gt; 에 두 번째 인수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e660d20bf684b576ae81f9c3a877a8d530b581ed" translate="yes" xml:space="preserve">
          <source>Source files</source>
          <target state="translated">소스 파일</target>
        </trans-unit>
        <trans-unit id="2d309b4d42e0ad4602d00da88f45cac2d3d11a5e" translate="yes" xml:space="preserve">
          <source>Specify the data dependencies of a `Relay.Container` as GraphQL fragments.</source>
          <target state="translated">`Relay.Container`의 데이터 종속성을 GraphQL 조각으로 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="21f0a8e08151b2997828c63fbaffbc197295bb3a" translate="yes" xml:space="preserve">
          <source>Specify the mutation field in a `Relay.Mutation`.</source>
          <target state="translated">'Relay.Mutation'에 돌연변이 필드를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="02293aef0bd0213bc1be111d67f416c9ddf1ebdf" translate="yes" xml:space="preserve">
          <source>Specify the queries of a `Relay.Route`.</source>
          <target state="translated">'Relay.Route'의 쿼리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="82c2f41708c8462a6d94834b8d39a6c652c2ac2b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;filters&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 및 &lt;code&gt;filters&lt;/code&gt; 지정 :</target>
        </trans-unit>
        <trans-unit id="066b54007a4c37add5703334fe870041528f5a58" translate="yes" xml:space="preserve">
          <source>Specifying just the &lt;code&gt;key&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 지정 :</target>
        </trans-unit>
        <trans-unit id="8c5f40f02b986c2adaf7800c3005c0afdbaaab33" translate="yes" xml:space="preserve">
          <source>Start converting your components and mutations to use the Relay Modern APIs from the &lt;code&gt;'react-relay/compat'&lt;/code&gt; module (&lt;code&gt;createFragmentContainer&lt;/code&gt;, &lt;code&gt;createRefetchContainer&lt;/code&gt;, &lt;code&gt;createPaginationContainer&lt;/code&gt;, &lt;code&gt;commitMutation&lt;/code&gt;). It will be easier to go from the leaf components up. The &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;conversion scripts&lt;/a&gt; should make this step less tedious.</source>
          <target state="translated">&lt;code&gt;'react-relay/compat'&lt;/code&gt; 모듈 ( &lt;code&gt;createFragmentContainer&lt;/code&gt; , &lt;code&gt;createRefetchContainer&lt;/code&gt; , &lt;code&gt;createPaginationContainer&lt;/code&gt; , &lt;code&gt;commitMutation&lt;/code&gt; ) 에서 Relay Modern API를 사용하도록 컴포넌트 및 돌연변이 변환을 시작하십시오 . 리프 구성 요소에서 위로 올라가는 것이 더 쉬울 것입니다. &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;변환 스크립트는&lt;/a&gt; 이 단계가 덜 지루한해야한다.</target>
        </trans-unit>
        <trans-unit id="6a5813201a4580fe5f1fbb25f1a522d4d505bf2d" translate="yes" xml:space="preserve">
          <source>Static Methods</source>
          <target state="translated">정적 방법</target>
        </trans-unit>
        <trans-unit id="49ff3956bbd054bfbc63e2eabd2a1088f21e282f" translate="yes" xml:space="preserve">
          <source>Step 0: Install Relay v1.0</source>
          <target state="translated">0 단계 : Relay v1.0 설치</target>
        </trans-unit>
        <trans-unit id="95c2707d7e8702851af5473310f89fd4c5bfea2a" translate="yes" xml:space="preserve">
          <source>Step 1: Incrementally convert to Relay Compat</source>
          <target state="translated">1 단계 : 릴레이 Compat으로 증분 변환</target>
        </trans-unit>
        <trans-unit id="d071bae177457e9183feaf0fc474e9686b0260a4" translate="yes" xml:space="preserve">
          <source>Step 2: Introduce &amp;lt;QueryRenderer&amp;gt;</source>
          <target state="translated">2 단계 : &amp;lt;QueryRenderer&amp;gt; 소개</target>
        </trans-unit>
        <trans-unit id="8176e519a1495162afbc0b02a0cc285793d9b9e6" translate="yes" xml:space="preserve">
          <source>Step 3: Introduce Relay Modern runtime</source>
          <target state="translated">3 단계 : Relay Modern 런타임 소개</target>
        </trans-unit>
        <trans-unit id="5465ead3d787f346532f42480c386d4eba31fbae" translate="yes" xml:space="preserve">
          <source>Step 4: Clean up by replacing Relay Compat with Relay Modern.</source>
          <target state="translated">4 단계 : Relay Compat을 Relay Modern으로 교체하여 정리합니다.</target>
        </trans-unit>
        <trans-unit id="0d8a7046c8d39d9cbd86abcdfb704b161a601f9e" translate="yes" xml:space="preserve">
          <source>Store</source>
          <target state="translated">Store</target>
        </trans-unit>
        <trans-unit id="aec0a8c625d33f2410286cd7972018e4c401dd0d" translate="yes" xml:space="preserve">
          <source>Store Operations</source>
          <target state="translated">매장 운영</target>
        </trans-unit>
        <trans-unit id="2e017d4c10eaa0f64c98ad2b1e9b9a9d85ad4822" translate="yes" xml:space="preserve">
          <source>Structure around mutations to make them predictable.</source>
          <target state="translated">돌연변이를 예측할 수 있도록 주변 구조.</target>
        </trans-unit>
        <trans-unit id="5697fd85adbd13bf85f28712f9a136e80cc8067e" translate="yes" xml:space="preserve">
          <source>Subscriptions</source>
          <target state="translated">Subscriptions</target>
        </trans-unit>
        <trans-unit id="501433bf93135f5b327aa2f2f9a8b9652febd9e8" translate="yes" xml:space="preserve">
          <source>Support for live queries where supported by the network/server.</source>
          <target state="translated">네트워크 / 서버에서 지원하는 경우 라이브 쿼리를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="13a5b46568a2ea322aa7b25ac8f48a520783301a" translate="yes" xml:space="preserve">
          <source>Supported in both compat and modern mode. When using the pagination container, Relay expects the connection field to be annotated with &lt;code&gt;@connection&lt;/code&gt; directive, for more detailed information and example, please go to &lt;a href=&quot;pagination-container#connection-directive&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">호환 모드와 최신 모드에서 모두 지원됩니다. 페이지 매김 컨테이너를 사용할 때 Relay는 연결 필드에 &lt;code&gt;@connection&lt;/code&gt; 지시문 이 주석으로 표시 될 것으로 예상합니다. 자세한 정보 및 예는 &lt;a href=&quot;pagination-container#connection-directive&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; 로 이동하십시오 .</target>
        </trans-unit>
        <trans-unit id="3ff1be67feaa88d4848ce4702f24046558ce5b24" translate="yes" xml:space="preserve">
          <source>Supported in classic, compat and modern mode. Detailed usage is explained in &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt;&lt;code&gt;Relay.QL&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">클래식, 호환 및 현대 모드에서 지원됩니다. 자세한 사용법은 &lt;a href=&quot;api-reference-relay-ql#array-fields&quot;&gt; &lt;code&gt;Relay.QL&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65d6a8d5361414a2749b7b32500d3781b01e64c3" translate="yes" xml:space="preserve">
          <source>Sweet! Let's keep going and get the next four!</source>
          <target state="translated">단! 계속해서 다음 4 개를 줍시다!</target>
        </trans-unit>
        <trans-unit id="28e2c6a12e1af3dcd74179eb09b97b7b134beae3" translate="yes" xml:space="preserve">
          <source>Switch the &lt;code&gt;'react-relay/compat'&lt;/code&gt; references in your app to &lt;code&gt;'react-relay'&lt;/code&gt;. This is more of a clean-up step that prevents your app from pulling in unnecessary &lt;code&gt;'react-relay/classic'&lt;/code&gt; code.</source>
          <target state="translated">스위치 &lt;code&gt;'react-relay/compat'&lt;/code&gt; 에 앱에 대한 참조를 &lt;code&gt;'react-relay'&lt;/code&gt; . 이는 앱이 불필요한 &lt;code&gt;'react-relay/classic'&lt;/code&gt; 코드를 가져 오지 못하게하는 정리 단계에 가깝습니다 .</target>
        </trans-unit>
        <trans-unit id="c64e9942fb642977fbd70ec197abeadd198f3103" translate="yes" xml:space="preserve">
          <source>Table of Contents:</source>
          <target state="translated">목차 :</target>
        </trans-unit>
        <trans-unit id="21d278837034557e7a9b46210d42d6e7b8075142" translate="yes" xml:space="preserve">
          <source>Terminology</source>
          <target state="translated">Terminology</target>
        </trans-unit>
        <trans-unit id="3965436aa1e25eb8c1a80de5c7180c888af16646" translate="yes" xml:space="preserve">
          <source>That input argument should contain a (string) &quot;clientMutationId&quot; property for the purposes of reconciling requests and responses (automatically added by the &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API).</source>
          <target state="translated">이 입력 인수에는 요청 및 응답을 조정하기위한 (문자열) &quot;clientMutationId&quot;특성이 포함되어야합니다 ( &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; API 에 의해 자동으로 추가됨 ).</target>
        </trans-unit>
        <trans-unit id="56c0a2575be8f36ad7f5d4d04acffdd56aaaf9ea" translate="yes" xml:space="preserve">
          <source>That used the &lt;code&gt;first&lt;/code&gt; argument to &lt;code&gt;ships&lt;/code&gt; to slice the result set down to the first one. But what if we wanted to paginate through it? On each edge, a cursor will be exposed that we can use to paginate. Let's ask for the first two this time, and get the cursor as well:</source>
          <target state="translated">즉, 사용 된 &lt;code&gt;first&lt;/code&gt; 로 인수 &lt;code&gt;ships&lt;/code&gt; 첫 번째로 아래로 결과 집합을 슬라이스. 그러나 우리가 그것을 통해 페이지 매기기를 원한다면 어떨까요? 각 모서리에 커서를 노출시켜 페이지 매김에 사용할 수 있습니다. 이번에는 처음 두 개를 요청하고 커서도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="cdaffd6461c67e56056afce77a9bd307eee56aef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface and &lt;code&gt;node&lt;/code&gt; field assume globally unique IDs for this refetching. A system without globally unique IDs can usually synthesize them by combining the type with the type-specific ID, which is what was done in this example.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 인터페이스와 &lt;code&gt;node&lt;/code&gt; 필드는이 refetching에 대한 전역 적으로 고유 한 ID를 가정합니다. 전역 고유 ID가없는 시스템은 일반적으로이 예에서 수행 된 유형별 ID와 유형을 결합하여이를 합성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4249e055d5de1ea8000faee39fa1425b4eb71404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Node&lt;/code&gt; interface contains a single field, &lt;code&gt;id&lt;/code&gt;, which is a &lt;code&gt;ID!&lt;/code&gt;. The &lt;code&gt;node&lt;/code&gt; root field takes a single argument, a &lt;code&gt;ID!&lt;/code&gt;, and returns a &lt;code&gt;Node&lt;/code&gt;. These two work in concert to allow refetching; if we pass the &lt;code&gt;id&lt;/code&gt; returned in that field to the &lt;code&gt;node&lt;/code&gt; field, we get the object back.</source>
          <target state="translated">&lt;code&gt;Node&lt;/code&gt; 인터페이스는 단일 필드가 포함 &lt;code&gt;id&lt;/code&gt; A는, &lt;code&gt;ID!&lt;/code&gt; . &lt;code&gt;node&lt;/code&gt; 루트 필드는 단일 인수하는 소요 &lt;code&gt;ID!&lt;/code&gt; , &lt;code&gt;Node&lt;/code&gt; 를 반환합니다 . 이 두 가지가 함께 작동하여 리 페치를 허용합니다. 우리가 통과하면 &lt;code&gt;id&lt;/code&gt; 받는 그 필드에 리턴 &lt;code&gt;node&lt;/code&gt; 필드에, 우리는 개체 다시 얻을.</target>
        </trans-unit>
        <trans-unit id="de66ff0a79b624dd454deb3e772e5fb7a040eb35" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordProxy&lt;/code&gt; serves as an interface to mutate records:</source>
          <target state="translated">&lt;code&gt;RecordProxy&lt;/code&gt; 는 개의 mutate 레코드에 대한 인터페이스로서 기능 :</target>
        </trans-unit>
        <trans-unit id="7b8b179aabf77ea5e811ea7880878bfdfa6368ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; is the type of the &lt;code&gt;store&lt;/code&gt; that &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt; receive as an argument. The following is the &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; interface:</source>
          <target state="translated">&lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; 은 의 유형입니다 &lt;code&gt;store&lt;/code&gt; 것을 &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt; &lt;code&gt;updater&lt;/code&gt; 기능을&lt;/a&gt; 인자로받을 수 있습니다. 다음은 &lt;code&gt;RecordSourceSelectorProxy&lt;/code&gt; 인터페이스입니다.</target>
        </trans-unit>
        <trans-unit id="858f5c2de227f30eaba7fc1f9d4f04ab2b8c2484" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;RelayCompiler&lt;/code&gt; module is a helper class that demonstrates one way of combining these primitives. It takes IR transforms, and given IR definitions, constructs a CompilerContext from them, transforming them, and generating output artifacts intended for use with Relay runtime.</source>
          <target state="translated">&lt;code&gt;RelayCompiler&lt;/code&gt; 의 모듈은 이러한 기본 요소를 결합하는 한 가지 방법을 보여줍니다 도우미 클래스입니다. IR 변환을 취하고 주어진 IR 정의에서 CompilerContext를 구성하고 변환하고 Relay 런타임과 함께 사용하기위한 출력 아티팩트를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a164901ca79b8b4a2a0866d3bc8b9028a8a90acb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Store&lt;/code&gt; is the source of truth for application data and provides the following core operations.</source>
          <target state="translated">&lt;code&gt;Store&lt;/code&gt; 애플리케이션 데이터에 대한 진리의 근원이며, 다음과 같은 핵심 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="69b82e1269cd3f5440edfdd8ab8e1cb4218f2a3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;applyUpdate&lt;/code&gt; adds a mutation just like &lt;code&gt;update&lt;/code&gt;, but does not commit it. It returns a &lt;code&gt;RelayMutationTransaction&lt;/code&gt; that can be committed or rollbacked.</source>
          <target state="translated">&lt;code&gt;applyUpdate&lt;/code&gt; 이 처럼 돌연변이를 추가 &lt;code&gt;update&lt;/code&gt; 하지만, 커밋하지 않습니다. 커밋 또는 롤백 할 수 있는 &lt;code&gt;RelayMutationTransaction&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c8a27cee9d1d9abe2e77bcb0c575a4357ce66c14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;babel-relay-plugin&lt;/code&gt; must run before the &lt;code&gt;react-native&lt;/code&gt; Babel preset. Thus, in &lt;code&gt;.babelrc&lt;/code&gt;&lt;code&gt;&quot;react-native&quot;&lt;/code&gt; must come after &lt;code&gt;babelRelayPlugin&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;babel-relay-plugin&lt;/code&gt; (가) 전에 실행해야합니다 &lt;code&gt;react-native&lt;/code&gt; 바벨 사전 설정을. 따라서 &lt;code&gt;.babelrc&lt;/code&gt; 에서 &lt;code&gt;&quot;react-native&quot;&lt;/code&gt; 는 &lt;code&gt;babelRelayPlugin&lt;/code&gt; 뒤에 와야 합니다.</target>
        </trans-unit>
        <trans-unit id="cf0346f82ced9502e9b07bb0b45a4c3bf97fc831" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;commitUpdate&lt;/code&gt; method is analogous to dispatching an action in Flux. Relay processes the mutation as follows:</source>
          <target state="translated">&lt;code&gt;commitUpdate&lt;/code&gt; 있어서 자속 작용 디스패치 유사하다. 릴레이는 다음과 같이 돌연변이를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1e1d2e828d0bd7ad1f6ddc74cb042c491b6885f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;graphql&lt;/code&gt; template tag provided by Relay serves as the mechanism to write queries, fragments, mutations or subscriptions in the &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL&lt;/a&gt; language. For example:</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; 릴레이 의해 제공된 템플릿 태그는 질의에서, 단편, 돌연변이 또는 서브 스크립 션을 작성하는기구로서 기능 &lt;a href=&quot;http://graphql.org/learn/&quot;&gt;GraphQL의&lt;/a&gt; 언어. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5916376d8984ac32cb4ef4378494b52a513ccdde" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;react-relay&lt;/code&gt; npm module includes &lt;code&gt;react&lt;/code&gt; as a &lt;em&gt;peer dependency&lt;/em&gt;. Your app should specify React as a dependency explicitly.</source>
          <target state="translated">&lt;code&gt;react-relay&lt;/code&gt; NPM 모듈을 포함하는 &lt;code&gt;react&lt;/code&gt; A와 &lt;em&gt;피어 의존성&lt;/em&gt; . 앱에서 React를 명시 적으로 종속성으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="687a2b2e72c0944702e22c85dfb54906ee9cc4a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;relay-compiler&lt;/code&gt; script requires both the directory which holds your source files as well as a path to your GraphQL schema in either a .json or .graphql schema file.</source>
          <target state="translated">&lt;code&gt;relay-compiler&lt;/code&gt; 스크립트는 .json 또는 .graphql 스키마 파일 중 하나에 GraphQL 스키마에 소스 파일뿐만 아니라 경로를 보유하고있는 디렉토리를 모두 필요로한다.</target>
        </trans-unit>
        <trans-unit id="09a465866585d4ac0fa1f3ec8871e9ae5a93fc4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFailure&lt;/code&gt; callback is called with two arguments: an &lt;code&gt;Error&lt;/code&gt; object and a function to retry the request. If the error was the result of a server error communicated in the server's response, the response payload is available for inspection on &lt;code&gt;error.source&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;renderFailure&lt;/code&gt; 의 : 콜백은 두 개의 인수로 호출 &lt;code&gt;Error&lt;/code&gt; 객체와 요청을 다시 시도 할 수있는 기능. 오류가 서버 응답에서 통신 된 서버 오류의 결과 인 경우 &lt;code&gt;error.source&lt;/code&gt; 에서 응답 페이로드를 검사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3fec68a6615738a8b02b918d7e606ef06cece0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;renderFetched&lt;/code&gt; callback is always called with a &lt;code&gt;data&lt;/code&gt; argument, which is an object mapping from &lt;code&gt;propName&lt;/code&gt; to query data. It is expected that the &lt;code&gt;renderFetched&lt;/code&gt; callback renders the supplied &lt;code&gt;Component&lt;/code&gt; with them (e.g. using the &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX spread attributes feature&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;renderFetched&lt;/code&gt; 콜백은 항상 불려 &lt;code&gt;data&lt;/code&gt; 에서 객체 매핑 인수, &lt;code&gt;propName&lt;/code&gt; 쿼리 데이터. &lt;code&gt;renderFetched&lt;/code&gt; 콜백은 제공된 &lt;code&gt;Component&lt;/code&gt; 를 컴포넌트 와 함께 렌더링 할 것으로 예상 됩니다 (예 : &lt;a href=&quot;https://facebook.github.io/react/docs/jsx-spread.html&quot;&gt;JSX 스프레드 속성 기능 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="fc694dd64cc47d448a84516c45884dcebf08a20c" translate="yes" xml:space="preserve">
          <source>The API is overall simpler and more predictable.</source>
          <target state="translated">API는 전체적으로 더 단순하고 예측 가능합니다.</target>
        </trans-unit>
        <trans-unit id="8e85966b9eda2ce8d0b649695a0687a896efc918" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createFragmentContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createFragmentContainer&lt;/code&gt; 의 결과로 생성 된 컴포넌트 는 다음 &lt;code&gt;props&lt;/code&gt; 을받습니다 .</target>
        </trans-unit>
        <trans-unit id="cf72a96b855224dd8974796498f53a592b116371" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createPaginationContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createPaginationContainer&lt;/code&gt; 의 결과로 생성 된 컴포넌트 는 다음 &lt;code&gt;props&lt;/code&gt; 을받습니다 .</target>
        </trans-unit>
        <trans-unit id="d4e8ac825308dd36be82a845d481fc8dfdffbd9f" translate="yes" xml:space="preserve">
          <source>The Component resulting from &lt;code&gt;createRefetchContainer&lt;/code&gt; will receive the following &lt;code&gt;props&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;createRefetchContainer&lt;/code&gt; 의 결과로 생성 된 컴포넌트 는 다음 &lt;code&gt;props&lt;/code&gt; 을받습니다 .</target>
        </trans-unit>
        <trans-unit id="a3270609e5596533f39e48f966bd5c2bc4660cc1" translate="yes" xml:space="preserve">
          <source>The DataID of the parent node that contains the connection. This argument is optional.</source>
          <target state="translated">연결이 포함 된 상위 노드의 DataID입니다. 이 인수는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="c4a8c9e60c4dd38c187162160297b7cec4fec7f9" translate="yes" xml:space="preserve">
          <source>The IDs we got back were base64 strings. IDs are designed to be opaque (the only thing that should be passed to the &lt;code&gt;id&lt;/code&gt; argument on &lt;code&gt;node&lt;/code&gt; is the unaltered result of querying &lt;code&gt;id&lt;/code&gt; on some object in the system), and base64ing a string is a useful convention in GraphQL to remind viewers that the string is an opaque identifier.</source>
          <target state="translated">우리가 얻은 ID는 base64 문자열이었습니다. ID는 불투명하도록 설계되었습니다 ( &lt;code&gt;node&lt;/code&gt; 에서 &lt;code&gt;id&lt;/code&gt; 인수 로 전달되어야하는 유일한 것은 시스템의 일부 객체에서 &lt;code&gt;id&lt;/code&gt; 를 쿼리 한 결과 변경되지 않은 결과입니다 ). 문자열을 base64하는 것은 시청자에게 문자열은 불투명 식별자입니다.</target>
        </trans-unit>
        <trans-unit id="7450121d3a10cfde0d27fedec5e7487c759f4cef" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot;</source>
          <target state="translated">릴레이 &quot;환경&quot;</target>
        </trans-unit>
        <trans-unit id="29a5b8d00ca84a6ecf522b93deabead7921f8457" translate="yes" xml:space="preserve">
          <source>The Relay &quot;Environment&quot; bundles together the configuration, cache storage, and network-handling that Relay needs in order to operate.</source>
          <target state="translated">Relay &quot;Environment&quot;는 Relay가 작동하기 위해 필요한 구성, 캐시 스토리지 및 네트워크 처리를 하나로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="04d65a89a2e8d48fa93bad9ecd0dc074fc69e421" translate="yes" xml:space="preserve">
          <source>The Relay &amp;quot;Environment&amp;quot;</source>
          <target state="translated">릴레이 &quot;환경&quot;</target>
        </trans-unit>
        <trans-unit id="ee388b82ec2168b63f7ecfa7840c723aabafb1e3" translate="yes" xml:space="preserve">
          <source>The Relay &lt;code&gt;Store&lt;/code&gt; provides an API for dispatching mutations to the server.</source>
          <target state="translated">릴레이 &lt;code&gt;Store&lt;/code&gt; 는 돌연변이를 서버로 디스패치하기위한 API를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8f70d28e27ab15f03147076b8dda3030c0a0078e" translate="yes" xml:space="preserve">
          <source>The Relay Classic and Relay Compat modes produce generated content inline and may catch and log any detected GraphQL validation errors, leaving those errors to be thrown at runtime.</source>
          <target state="translated">Relay Classic 및 Relay Compat 모드는 생성 된 컨텐츠를 인라인으로 생성하고 감지 된 GraphQL 유효성 검사 오류를 포착하여 기록 할 수 있으므로 런타임시 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="77da780670013088b3893d46cce4bc75359e000f" translate="yes" xml:space="preserve">
          <source>The Relay Compiler fully supports client-side schema extensions, which allows you to extend the server schema by defining additional GraphQL types and fields on the client. Relay expects the client schema to be located in your &lt;code&gt;--src&lt;/code&gt; directory.</source>
          <target state="translated">릴레이 컴파일러는 클라이언트 측 스키마 확장을 완벽하게 지원하므로 클라이언트에서 추가 GraphQL 유형 및 필드를 정의하여 서버 스키마를 확장 할 수 있습니다. Relay는 클라이언트 스키마가 &lt;code&gt;--src&lt;/code&gt; 디렉토리 에있을 것으로 예상합니다 .</target>
        </trans-unit>
        <trans-unit id="c019c5395f2cd9ca47232f5e8ed64fa398b7ada0" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which can then be referenced at runtime. By building the query ahead of time, the Relay's runtime is not responsible for generating a query string, and various optimizations can be performed on the query that could be too expensive at runtime (for example, fields that are duplicated in the query can be merged during the build step, to improve efficiency of processing the GraphQL response).</source>
          <target state="translated">릴레이 컴파일러는 런타임에 참조 할 수있는 빌드 단계의 일부로 코드를 생성합니다. 쿼리를 미리 빌드하면 Relay의 런타임이 쿼리 문자열 생성을 담당하지 않으며 런타임에 너무 비쌀 수있는 쿼리에 대해 다양한 최적화를 수행 할 수 있습니다 (예 : 쿼리에서 중복 된 필드를 병합 할 수 있음). 빌드 단계에서 GraphQL 응답 처리의 효율성을 향상시키기 위해).</target>
        </trans-unit>
        <trans-unit id="b710564e5046fb16b4d54484e5bd00a02c1c71b3" translate="yes" xml:space="preserve">
          <source>The Relay Compiler is responsible for generating code as part of a build step which, at runtime, can be used statically. By building the query ahead of time, the client's JS runtime is not responsible for generating a query string, and fields that are duplicated in the query can be merged during the build step, to improve parsing efficiency. If you have the ability to persist queries to your server, the compiler's code generation process provides a convenient time to convert a query or mutation's text into a unique identifier, which greatly reduces the upload bytes required.</source>
          <target state="translated">릴레이 컴파일러는 런타임에 정적으로 사용할 수있는 빌드 단계의 일부로 코드를 생성합니다. 쿼리를 미리 빌드함으로써 클라이언트의 JS 런타임은 쿼리 문자열을 생성 할 책임이 없으며 쿼리에서 복제 된 필드를 빌드 단계에서 병합하여 구문 분석 효율성을 향상시킬 수 있습니다. 쿼리를 서버에 유지할 수있는 경우 컴파일러의 코드 생성 프로세스는 쿼리 또는 돌연변이 텍스트를 고유 식별자로 변환하는 데 편리한 시간을 제공하여 필요한 업로드 바이트를 크게 줄입니다.</target>
        </trans-unit>
        <trans-unit id="63623a8a89bd3ad461c1fe2298a373e6892186d0" translate="yes" xml:space="preserve">
          <source>The Relay Modern Core adds support for client schema extensions. These allow Relay to conveniently store some extra information with data fetched from the server and be rendered like any other field fetched from the server. This should be able to replace some use cases that previously required a Flux/Redux store on the side.</source>
          <target state="translated">Relay Modern Core는 클라이언트 스키마 확장에 대한 지원을 추가합니다. 이를 통해 Relay는 서버에서 가져온 데이터와 함께 일부 추가 정보를 편리하게 저장하고 서버에서 가져온 다른 필드와 같이 렌더링 할 수 있습니다. 이전에 측면에 Flux / Redux 매장이 필요했던 일부 사용 사례를 대체 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7d5ac1a62f052029edc67e6900f799b310cde67" translate="yes" xml:space="preserve">
          <source>The Relay Modern packages distributed on NPM use the widely-supported ES5 version of JavaScript to support as many browser environments as possible.</source>
          <target state="translated">NPM에 배포 된 Relay Modern 패키지는 널리 지원되는 ES5 버전의 JavaScript를 사용하여 가능한 많은 브라우저 환경을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3f35b4d76fe696a95341841f45e165e3b0c6aad8" translate="yes" xml:space="preserve">
          <source>The Relay Network Layer</source>
          <target state="translated">릴레이 네트워크 계층</target>
        </trans-unit>
        <trans-unit id="6ac0bfad74e5d02ff492fbabe1206cbc172f8a94" translate="yes" xml:space="preserve">
          <source>The Relay Store can be used to programmatically update client-side data inside &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt;&lt;code&gt;updater&lt;/code&gt; functions&lt;/a&gt;. The following is a reference of the Relay Store interface.</source>
          <target state="translated">릴레이 저장소는 &lt;a href=&quot;mutations#using-updater-and-optimisticupdater&quot;&gt; &lt;code&gt;updater&lt;/code&gt; 함수&lt;/a&gt; 내에서 클라이언트 측 데이터를 프로그래밍 방식으로 업데이트하는 데 사용할 수 있습니다 . 다음은 Relay Store 인터페이스에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d750d1085b7a107c9c036e90d472c451b5fb59af" translate="yes" xml:space="preserve">
          <source>The Relay runtime bundle is roughly 20% of the size of Relay Classic.</source>
          <target state="translated">릴레이 런타임 번들은 릴레이 클래식 크기의 약 20 %입니다.</target>
        </trans-unit>
        <trans-unit id="d69ab39bff551c52cbb39536496919006e7104d5" translate="yes" xml:space="preserve">
          <source>The Relay runtime is a full-featured GraphQL client that is designed for high performance even on low-end mobile devices and is capable of scaling to large, complex apps. The runtime API is not intended to be used directly in product code, but rather to provide a foundation for building higher-level product APIs such as React/Relay. This foundation includes:</source>
          <target state="translated">Relay 런타임은 저가형 모바일 장치에서도 고성능을 위해 설계된 모든 기능을 갖춘 GraphQL 클라이언트이며 크고 복잡한 앱으로 확장 할 수 있습니다. 런타임 API는 제품 코드에서 직접 사용하기위한 것이 아니라 React / Relay와 같은 더 높은 수준의 제품 API를 빌드하기위한 기반을 제공하기위한 것입니다. 이 재단에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a2170027015b9ca88c5f922e040a93d95772d2c0" translate="yes" xml:space="preserve">
          <source>The Relay store can be mutated programatically in advanced edge cases when optimistic updates need more granular control. The following API methods are useful for mutating your connections and fragments.</source>
          <target state="translated">낙관적 업데이트가보다 세밀한 제어가 필요한 고급 에지 사례에서는 릴레이 저장소를 프로그래밍 방식으로 변경할 수 있습니다. 다음 API 메소드는 연결 및 단편을 변경하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0adc8d247f24c64744fe2ba30ece6da8fd08a649" translate="yes" xml:space="preserve">
          <source>The author of this story also commented on it &amp;mdash; quite common. Now imagine that some other view fetches new information about the author, and her profile photo has changed to a new URI. Here's the &lt;em&gt;only&lt;/em&gt; part of our cached data that changes:</source>
          <target state="translated">이 이야기의 저자는 그것에 대해서도 언급했습니다. 꽤 흔합니다. 이제 다른보기에서 작성자에 대한 새로운 정보를 가져오고 프로필 사진이 새로운 URI로 변경되었다고 상상해보십시오. 캐시 된 데이터에서 변경된 &lt;em&gt;유일한&lt;/em&gt; 부분은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="980a4b6788111d51d4fd5d3c6e5054ad267e5ae0" translate="yes" xml:space="preserve">
          <source>The best way to get started right now is to take a look at how these three parts come together to form a working example. The tutorial on the next page will lead you through an example application, using the &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt;, to give you an idea of how you can start using Relay on yours.</source>
          <target state="translated">지금 시작하는 가장 좋은 방법은이 세 부분이 어떻게 결합하여 실제 사례를 만드는지 살펴 보는 것입니다. 다음 페이지의 자습서는 &lt;a href=&quot;https://github.com/facebook/relay-starter-kit&quot;&gt;Relay Starter Kit를&lt;/a&gt; 사용하여 예제 응용 프로그램을 안내하여 릴레이 사용을 시작하는 방법에 대한 아이디어를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5bc022d566f4b68dd38c73222756f331714be645" translate="yes" xml:space="preserve">
          <source>The client and server are decoupled: the client specifies the data needed instead of &lt;em&gt;relying on&lt;/em&gt; the server endpoint to return the correct data.</source>
          <target state="translated">클라이언트와 서버가 분리되어 있습니다. 클라이언트 는 올바른 데이터를 리턴하기 위해 서버 엔드 포인트 에 &lt;em&gt;의존하는&lt;/em&gt; 대신 필요한 데이터를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="859e2dd0a260c19654088e28b4f5cf103b3156ab" translate="yes" xml:space="preserve">
          <source>The compiler is a set of modules designed to extract GraphQL documents from across a codebase, transform/optimize them, and generate build artifacts. Examples of common types of artifacts include optimized GraphQL to persist to your server, runtime representations of the queries for use with GraphQL clients such as the Relay runtime, or generated source code for use with GraphQL frameworks for compiled languages (Java/Swift/etc).</source>
          <target state="translated">컴파일러는 코드베이스에서 GraphQL 문서를 추출하고이를 변환 / 최적화하고 빌드 아티팩트를 생성하도록 설계된 모듈 세트입니다. 일반적인 유형의 아티팩트의 예로는 서버에 유지되도록 최적화 된 GraphQL, Relay 런타임과 같은 GraphQL 클라이언트와 함께 사용하기위한 쿼리의 런타임 표현, 컴파일 된 언어 (Java / Swift / etc) 용 GraphQL 프레임 워크와 함께 사용하기 위해 생성 된 소스 코드가 있습니다. .</target>
        </trans-unit>
        <trans-unit id="aa42964754dbecedd42dff5df9fe665b9c4e7306" translate="yes" xml:space="preserve">
          <source>The compiler module is composed of a set of core building blocks as well as a helper that packages them together in an easy to use API. Some of the main data types and modules in the compiler are as follows:</source>
          <target state="translated">컴파일러 모듈은 일련의 핵심 빌딩 블록과 사용하기 쉬운 API로 함께 패키지화하는 도우미로 구성됩니다. 컴파일러의 일부 주요 데이터 유형 및 모듈은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="00a902f03306b6ea1e1e2818025625742f4e212c" translate="yes" xml:space="preserve">
          <source>The component-based approach of React Router v4 does not readily allow for aggregating the data requirements for nested routes, and as such does not readily permit an approach that will avoid request waterfalls from nesting &lt;code&gt;QueryRenderer&lt;/code&gt; components.</source>
          <target state="translated">React Router v4의 컴포넌트 기반 접근법은 중첩 된 라우트에 대한 데이터 요구 사항을 집계하는 것을 쉽게 허용하지 않으므로 요청 폭포가 &lt;code&gt;QueryRenderer&lt;/code&gt; 컴포넌트 를 중첩시키지 않도록하는 접근법을 쉽게 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7298679167473c58332d417e6d2bd4de9988163d" translate="yes" xml:space="preserve">
          <source>The container &amp;mdash; named &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; for debugging &amp;mdash; will retrieve the response for each GraphQL fragment from the local store.</source>
          <target state="translated">디버깅을 위해 &lt;code&gt;Relay(ProfilePicture)&lt;/code&gt; 라는 컨테이너 는 로컬 저장소에서 각 GraphQL 조각에 대한 응답을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d147ef4301d6fa557024d99f96f08a499bbc3a4a" translate="yes" xml:space="preserve">
          <source>The container passes the results of each fragment (along with the other props) to the &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component.</source>
          <target state="translated">컨테이너는 각 프래그먼트의 결과 (다른 소품과 함께)를 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 컴포넌트로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="268b06824cede0c427a01e0d80dbe18daf1354c3" translate="yes" xml:space="preserve">
          <source>The default implementation is as follows:</source>
          <target state="translated">기본 구현은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf32b3124e1516fba4edb1784393b843530e0823" translate="yes" xml:space="preserve">
          <source>The defaults we specify here will become available to our fragment builders:</source>
          <target state="translated">여기서 지정한 기본값은 프래그먼트 빌더가 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="fe89d1880c282b0f84f7ad747dcf711ed35e9199" translate="yes" xml:space="preserve">
          <source>The easiest way to get started for now is with the &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;Relay Starter Kit&lt;/a&gt; - this includes an example schema file and configures the &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt;&lt;code&gt;babel-relay-plugin&lt;/code&gt;&lt;/a&gt; npm module to transpile queries.</source>
          <target state="translated">지금 시작하는 가장 쉬운 방법은 &lt;a href=&quot;https://github.com/relayjs/relay-starter-kit&quot;&gt;릴레이 스타터 키트를 사용&lt;/a&gt; 하는 것입니다. 여기에는 스키마 파일 예제가 포함되어 있으며 쿼리를 변환 하도록 &lt;a href=&quot;https://www.npmjs.com/package/babel-relay-plugin&quot;&gt; &lt;code&gt;babel-relay-plugin&lt;/code&gt; &lt;/a&gt; npm 모듈을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="0041bb913fb29f03cef5bab2b320b6add29c71a8" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a built-in handler that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself).</source>
          <target state="translated">위의 예제는 &lt;code&gt;handlerProvider&lt;/code&gt; 를 구성하지 않았으며 이는 기본값이 제공됨을 의미합니다. Relay Modern에는 연결 처리를위한 특수 기능으로 코어를 보강하는 내장 핸들러가 함께 제공됩니다 (표준 GraphQL 기능은 아니지만 Facebook에서 사용되는 일련의 페이지 매김 규칙이며 &lt;a href=&quot;https://relay.dev/graphql/connections.htm&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt; 에 자세히 지정되어 있습니다. -Relay 자체에서 지원).</target>
        </trans-unit>
        <trans-unit id="ef9027831057a9dfdeaac970a51f94ff44007267" translate="yes" xml:space="preserve">
          <source>The example above did not configure a &lt;code&gt;handlerProvider&lt;/code&gt;, which means that a default one will be provided. Relay Modern comes with a couple of built-in handlers that augment the core with special functionality for handling connections (which is not a standard GraphQL feature, but a set of pagination conventions used at Facebook, specified in detail in the &lt;a href=&quot;graphql-connections&quot;&gt;Relay Cursor Connections Specification&lt;/a&gt;, and well-supported by Relay itself) and the &lt;code&gt;viewer&lt;/code&gt; field (again, not a standard GraphQL schema feature, but one which has been conventionally used extensively within Facebook).</source>
          <target state="translated">위의 예제는 &lt;code&gt;handlerProvider&lt;/code&gt; 를 구성하지 않았습니다. 즉, 기본 공급자 가 제공됩니다. 릴레이 현대가의 부부와 함께 제공 내장에 자세히 규정 표준 GraphQL의 기능이 아닙니다 연결을 처리하기위한 특별한 기능 (와 핵심하지만 페이스 북에서 사용 매김 규칙의 집합 증대 핸들러 &lt;a href=&quot;graphql-connections&quot;&gt;사양 릴레이 커서 연결&lt;/a&gt; , Relay 자체에서 잘 지원됨) &lt;code&gt;viewer&lt;/code&gt; 필드 (표준 GraphQL 스키마 기능이 아니라 Facebook 내에서 광범위하게 사용되는 기능)</target>
        </trans-unit>
        <trans-unit id="4657e52da9059d7f3c2e9423e8542337bf25d573" translate="yes" xml:space="preserve">
          <source>The example above is very similar to the classic container API, but in the modern API we can just pass the &lt;code&gt;graphql&lt;/code&gt; template literal directly as the second argument. Relay will infer the prop name from the fragment name according to the fragment naming convention &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt;. The example below is equivalent to the one above:</source>
          <target state="translated">위의 예제는 클래식 컨테이너 API와 매우 유사하지만 최신 API에서는 &lt;code&gt;graphql&lt;/code&gt; 템플릿 리터럴을 두 번째 인수로 직접 전달할 수 있습니다 . 릴레이는 프래그먼트 명명 규칙 &lt;code&gt;&amp;lt;FileName&amp;gt;_&amp;lt;propName&amp;gt;&lt;/code&gt; 에 따라 프래그먼트 이름에서 프롭 이름을 유추합니다 . 아래 예는 위의 예와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1d30073e8f5f3cb9668f92d3d480a82b915306f9" translate="yes" xml:space="preserve">
          <source>The fat query</source>
          <target state="translated">뚱뚱한 질문</target>
        </trans-unit>
        <trans-unit id="9eb6dbc6b6ef5c5d8b4847ee0b1b967260b02889" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the deleted node</source>
          <target state="translated">삭제 된 노드의 DataID를 포함하는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="3ca688eaa1e1f955641e421703e810ed047c2005" translate="yes" xml:space="preserve">
          <source>The field name in the response that contains the DataID of the removed node, or the path to the node removed from the connection</source>
          <target state="translated">제거 된 노드의 DataID를 포함하는 응답의 필드 이름 또는 연결에서 제거 된 노드의 경로</target>
        </trans-unit>
        <trans-unit id="ba191931e9ab489b27a9f33f746bef212888dc1a" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the connection</source>
          <target state="translated">연결을 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="a1b90e077151b889c8402ab5f53851a0ff440462" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the newly created edge</source>
          <target state="translated">새로 작성된 가장자리를 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="f9886e317b707740faab57f9ea8a72831a041943" translate="yes" xml:space="preserve">
          <source>The field name in the response that represents the parent of the connection</source>
          <target state="translated">연결의 상위를 나타내는 응답의 필드 이름</target>
        </trans-unit>
        <trans-unit id="9edac1a03bde2552ba82cb38e1a432234c65b349" translate="yes" xml:space="preserve">
          <source>The final data declaration is equivalent to the following plain GraphQL:</source>
          <target state="translated">최종 데이터 선언은 다음 일반 GraphQL과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfe19d046a9f42c5d948f0aa018690d7ab173c0c" translate="yes" xml:space="preserve">
          <source>The first query was for a list of stories:</source>
          <target state="translated">첫 번째 질문은 스토리 목록에 대한 것입니다.</target>
        </trans-unit>
        <trans-unit id="097faf4942075ea29d235eddd8bf227710e8b427" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Disposable&lt;/code&gt; on which you could call &lt;code&gt;dispose()&lt;/code&gt; to cancel the refetch.</source>
          <target state="translated">이 함수는 &lt;code&gt;dispose()&lt;/code&gt; 를 호출 하여 refetch를 취소 할 수 있는 &lt;code&gt;Disposable&lt;/code&gt; 을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="74925f12cc72e89c1f9fb2151f85c26276ebca60" translate="yes" xml:space="preserve">
          <source>The function returns a &lt;code&gt;Promise&lt;/code&gt; that resolves with an object containing data obtained from the query.</source>
          <target state="translated">이 함수는 쿼리에서 얻은 데이터를 포함하는 개체로 해결 되는 &lt;code&gt;Promise&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="84ecd22bdcea1bdfd0329a697bfab6ff7e6e06a6" translate="yes" xml:space="preserve">
          <source>The high-level flow of data through the compiler is represented in the following diagram:</source>
          <target state="translated">컴파일러를 통한 높은 수준의 데이터 흐름은 다음 다이어그램에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d313c5be837c1f0e863c8d541edf651d250cb38" translate="yes" xml:space="preserve">
          <source>The initial set of variable values available to this component's fragments.</source>
          <target state="translated">이 컴포넌트의 프래그먼트에 사용 가능한 초기 변수 값 세트입니다.</target>
        </trans-unit>
        <trans-unit id="f7e74d01f7e6ff80db2700d9894a53e56b4a4d76" translate="yes" xml:space="preserve">
          <source>The most-used function is &lt;a href=&quot;#createcontainer-static-method&quot;&gt;&lt;code&gt;createContainer()&lt;/code&gt;&lt;/a&gt; which wraps components with data declarations.</source>
          <target state="translated">가장 많이 사용되는 함수는 &lt;a href=&quot;#createcontainer-static-method&quot;&gt; &lt;code&gt;createContainer()&lt;/code&gt; &lt;/a&gt; 로 구성 요소를 데이터 선언으로 감 쌉니다.</target>
        </trans-unit>
        <trans-unit id="6618aeb6f5361bcac94a3181ad8b6a8339b0abc1" translate="yes" xml:space="preserve">
          <source>The mutation should take a single argument named &quot;input&quot;.</source>
          <target state="translated">돌연변이는 &quot;입력&quot;이라는 단일 인수를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3c29d0940ced0048c0feb3200ee57be78138845" translate="yes" xml:space="preserve">
          <source>The new Relay Modern core is more light-weight and significantly faster than the previous version. It is redesigned to work with static queries, which allow us to push more work to build/compilation time. The Modern core is much smaller as a result of removing a lot of the complex features required for dynamic queries. The new core is also an order of magnitude faster in processing the response with an optimized parsing instruction set that is generated at build time. We no longer keep around tracking information needed for dynamic query generation, which drastically reduces the memory overhead of using Relay. This means more memory is left for making the UI feel responsive. Relay Modern also supports persisted queries, reducing the upload size of the request from the full query text to a simple id.</source>
          <target state="translated">새로운 Relay Modern 코어는 이전 버전보다 가볍고 훨씬 빠릅니다. 정적 쿼리 작업을 위해 다시 설계되었으므로 더 많은 작업을 빌드 / 컴파일 시간으로 진행할 수 있습니다. Modern 코어는 동적 쿼리에 필요한 많은 복잡한 기능을 제거하여 훨씬 더 작습니다. 새로운 코어는 또한 빌드 타임에 생성 된 최적화 된 구문 분석 명령어 세트로 응답을 처리하는 데 훨씬 빠릅니다. 더 이상 동적 쿼리 생성에 필요한 정보를 추적하지 않아도되므로 릴레이 사용시 메모리 오버 헤드가 크게 줄어 듭니다. 이는 UI가 반응 적으로 느껴지도록 더 많은 메모리가 남아 있음을 의미합니다. Relay Modern은 지속 쿼리를 지원하여 전체 쿼리 텍스트에서 간단한 ID로 요청의 업로드 크기를 줄입니다.</target>
        </trans-unit>
        <trans-unit id="bfe2b2be8025972db06fd439006437e8dca5cc49" translate="yes" xml:space="preserve">
          <source>The next logical approach is to use &lt;code&gt;render()&lt;/code&gt; as the means of initiating data-fetching. We could simply render the application once, see what data it needed, fetch that data, and render again. This sounds great, but the problem is that &lt;em&gt;components use data to figure out what to render!&lt;/em&gt; In other words, this would force data-fetching to be staged: first render the root and see what data it needs, then render its children and see what they need, all the way down the tree. If each stage incurs network request, rendering would require slow, serial roundtrips. We needed a way to determine all the data needs up-front or &lt;em&gt;statically&lt;/em&gt;.</source>
          <target state="translated">다음 논리적 접근 방식은 데이터 가져 오기를 시작하는 수단으로 &lt;code&gt;render()&lt;/code&gt; 를 사용 하는 것입니다. 애플리케이션을 한 번만 렌더링하고 필요한 데이터를 확인한 후 해당 데이터를 가져 와서 다시 렌더링 할 수 있습니다. 이것은 훌륭하게 들리지만 문제는 &lt;em&gt;구성 요소가 데이터를 사용하여 렌더링 대상을 파악&lt;/em&gt; 한다는 &lt;em&gt;것입니다!&lt;/em&gt; 다시 말해, 데이터 가져 오기가 준비되도록해야합니다. 먼저 루트를 렌더링하고 필요한 데이터를 확인한 다음 하위를 렌더링하고 필요한 것을 트리에서 완전히 확인하십시오. 각 단계에서 네트워크 요청이 발생하면 렌더링에 느린 직렬 왕복이 필요합니다. 모든 데이터 요구 사항을 사전에 또는 &lt;em&gt;정적으로&lt;/em&gt; 결정할 수있는 방법이 필요했습니다 .</target>
        </trans-unit>
        <trans-unit id="5b53cde5515b59c4d3a0131621b4782b7479a272" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, as per the &lt;code&gt;Relay.Mutation&lt;/code&gt; API. This tells Relay how to process the response.</source>
          <target state="translated">선택적 &lt;code&gt;config&lt;/code&gt; 매개 변수를 사용 하여 &lt;code&gt;Relay.Mutation&lt;/code&gt; API에 따라 &lt;code&gt;RANGE_ADD&lt;/code&gt; 또는 다른 유형의 돌연변이 를 구성 할 수 있습니다 . 릴레이에게 응답 처리 방법을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="3043696978b404d79349bb97fe99dc6847323bfb" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;config&lt;/code&gt; parameter can be used to configure a &lt;code&gt;RANGE_ADD&lt;/code&gt; or other type of mutation, similar to the &lt;code&gt;Relay.Mutation&lt;/code&gt; API.</source>
          <target state="translated">선택적 &lt;code&gt;config&lt;/code&gt; 매개 변수를 사용 하여 &lt;code&gt;Relay.Mutation&lt;/code&gt; API 와 유사한 &lt;code&gt;RANGE_ADD&lt;/code&gt; 또는 다른 유형의 돌연변이 를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a65fc26cbbecf69c5a0fe03882c96f57450485e1" translate="yes" xml:space="preserve">
          <source>The options listed above are not exhaustive. If you are aware of other routing solutions that work well with Relay Modern, &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;please let us know&lt;/a&gt;.</source>
          <target state="translated">위에 나열된 옵션은 전체가 아닙니다. Relay Modern과 잘 작동하는 다른 라우팅 솔루션을 알고 있다면 &lt;a href=&quot;https://github.com/facebook/relay/issues/new&quot;&gt;알려주십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e4e5487396fd07e7501191686f068ec10dba2a30" translate="yes" xml:space="preserve">
          <source>The pagination container expects the connection field to be annotated with a &lt;code&gt;@connection(key: ...)&lt;/code&gt; directive, where the &lt;code&gt;key&lt;/code&gt; is expected to be a unique identifier under the parent field type &lt;code&gt;User&lt;/code&gt;. A good practice could be &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt;. By default, Relay generates storage key based on the user-supplied &lt;code&gt;key&lt;/code&gt; and all non-filter variables of the field. Relay also provides an advanced feature &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; that allows you to explicitly specify which variables should be used to generate the storage key. Particularly, if you write &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt;, Relay will ignore all the variables.</source>
          <target state="translated">페이지 매김 컨테이너는 연결 필드에 &lt;code&gt;@connection(key: ...)&lt;/code&gt; 지시문 으로 주석이 달릴 것으로 예상합니다. 여기서 &lt;code&gt;key&lt;/code&gt; 는 상위 필드 유형 &lt;code&gt;User&lt;/code&gt; 에서 고유 식별자가 될 것으로 예상됩니다 . 좋은 연습이 될 수 &lt;code&gt;&amp;lt;ComponentName&amp;gt;_&amp;lt;fieldName | fieldAlias&amp;gt;&lt;/code&gt; . 기본적으로 릴레이는 사용자 제공 &lt;code&gt;key&lt;/code&gt; 와 필드의 모든 비 필터 변수를 기반으로 스토리지 키를 생성 합니다. 또한 릴레이는 고급 기능 &lt;code&gt;@connection(key: 'FriendsList_friends', filters:['orderBy', ...])&lt;/code&gt; 을 제공하여 스토리지 키를 생성하는 데 사용할 변수를 명시 적으로 지정할 수 있습니다. 특히 &lt;code&gt;@connection(key: ..., filters:[])&lt;/code&gt; , 릴레이는 모든 변수를 무시합니다.</target>
        </trans-unit>
        <trans-unit id="c30fe4d3ed3c530120fea7a2dc37c47a35768d8b" translate="yes" xml:space="preserve">
          <source>The plugin needs to understand your schema - &lt;code&gt;schemaData&lt;/code&gt; in the above snippet. There are two ways to get this information, depending on the GraphQL implementation.</source>
          <target state="translated">플러그인 은 위의 스 니펫에서 스키마 &lt;code&gt;schemaData&lt;/code&gt; 를 이해해야합니다 . GraphQL 구현에 따라이 정보를 얻는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="486acc4ff0b4938f682801c80ee8b2d7dd1df93e" translate="yes" xml:space="preserve">
          <source>The premise of the example is that we want to use GraphQL to query for information about ships and factions in the original Star Wars trilogy.</source>
          <target state="translated">이 예제의 전제는 GraphQL을 사용하여 원래 Star Wars 3 부작의 배와 진영에 대한 정보를 쿼리하려고합니다.</target>
        </trans-unit>
        <trans-unit id="1d83274a567a8154b4431388aa9d20ca339eaa3b" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;Relay.Container&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">데이터 요구 사항을 선언하는 기본 방법은 &lt;code&gt;Relay.Container&lt;/code&gt; 를 사용하는 것입니다. React 구성 요소가 데이터 요구 사항을 인코딩 할 수 있도록하는 상위 React 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="808db6b1b18bc85b64f9d26f1bddf44bf5968046" translate="yes" xml:space="preserve">
          <source>The primary way to declare data requirements is via &lt;code&gt;createFragmentContainer&lt;/code&gt; &amp;mdash; a higher-order React component that lets React components encode their data requirements.</source>
          <target state="translated">데이터 요구 사항을 선언하는 기본 방법은 &lt;code&gt;createFragmentContainer&lt;/code&gt; 를 사용하는 것입니다. createFragmentContainer 는 React 컴포넌트가 데이터 요구 사항을 인코딩 할 수있게하는 상위 React 컴포넌트입니다.</target>
        </trans-unit>
        <trans-unit id="444774c5f652cc1826eed622e4a92e2c3f0e2e4b" translate="yes" xml:space="preserve">
          <source>The properties and methods listed below can be accessed on &lt;code&gt;this.props.relay&lt;/code&gt; from the wrapped React component.</source>
          <target state="translated">아래에 나열된 특성 및 메소드 는 랩핑 된 React 컴포넌트의 &lt;code&gt;this.props.relay&lt;/code&gt; 에서 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e0742e86024158a29e56877db07e441903db2b90" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;@connection&lt;/code&gt; directive is to allow Relay to uniquely identify different connections under a parent type. The &lt;code&gt;@connection&lt;/code&gt; directive takes 2 arguments that help identify the connection:</source>
          <target state="translated">&lt;code&gt;@connection&lt;/code&gt; 지시문 의 목적은 Relay가 부모 유형에서 다른 연결을 고유하게 식별 할 수 있도록하는 것입니다. &lt;code&gt;@connection&lt;/code&gt; 의 지시어는 도움이 연결을 식별하는 것이이 개 인수를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="f9c7cfc24fbe1b8654256e17573b27f7600de24e" translate="yes" xml:space="preserve">
          <source>The query and response are traversed together, extracting the results into &lt;code&gt;Record&lt;/code&gt; objects which are added to a fresh &lt;code&gt;RecordSource&lt;/code&gt;.</source>
          <target state="translated">쿼리와 응답은 함께 순회되어 결과를 새로운 &lt;code&gt;RecordSource&lt;/code&gt; 에 추가 된 &lt;code&gt;Record&lt;/code&gt; 객체 로 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="6fb555f6bd692507da566c1e62919372415cf8fc" translate="yes" xml:space="preserve">
          <source>The query is fetched from the network.</source>
          <target state="translated">네트워크에서 쿼리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="595d44efe5adb2587c5aa09916b466fe64246e19" translate="yes" xml:space="preserve">
          <source>The query should request &quot;clientMutationId&quot; as a subselection.</source>
          <target state="translated">쿼리는 &quot;clientMutationId&quot;를 하위 선택으로 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcd6ab3548bb5d3b4f5a6f857ba30959f05237cb" translate="yes" xml:space="preserve">
          <source>The reasoning is that if &lt;code&gt;babel-plugin-relay&lt;/code&gt; does not run before the &lt;code&gt;es2015-template-literals&lt;/code&gt; transform, it will not transform the Relay.QL template literals correctly. Also in Babel 6, you can&amp;rsquo;t control plugin order. So in React Native, where plugins in &lt;code&gt;.babelrc&lt;/code&gt; are loaded before the projects &lt;code&gt;.babelrc&lt;/code&gt;, it&amp;rsquo;s impossible to use the Babel Relay Plugin without overriding the entire transform list.</source>
          <target state="translated">추론과 같은 경우이다 &lt;code&gt;babel-plugin-relay&lt;/code&gt; 전과 실행되지 않습니다 &lt;code&gt;es2015-template-literals&lt;/code&gt; 변환이 제대로 Relay.QL 템플릿 리터럴을 변환하지 않습니다. 또한 Babel 6에서는 플러그인 순서를 제어 할 수 없습니다. 따라서 &lt;code&gt;.babelrc&lt;/code&gt; 의 플러그인이 .babelrc 프로젝트 &lt;code&gt;.babelrc&lt;/code&gt; 먼저로드 되는 React Native에서는 전체 변환 목록을 재정의하지 않고 Babel Relay 플러그인을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e29f8bf44ff95dd21005f2f7bb6eccf4ec45e350" translate="yes" xml:space="preserve">
          <source>The result of using the &lt;code&gt;graphql&lt;/code&gt; template tag is a &lt;code&gt;GraphQLTaggedNode&lt;/code&gt;; a runtime representation of the GraphQL document which can be used to define &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt;, &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt;, &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt;, &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt;, etc.</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; 템플릿 태그 를 사용한 결과 는 &lt;code&gt;GraphQLTaggedNode&lt;/code&gt; 입니다 . &lt;a href=&quot;query-renderer&quot;&gt;Query Renderers&lt;/a&gt; , &lt;a href=&quot;fragment-container&quot;&gt;Fragment Containers&lt;/a&gt; , &lt;a href=&quot;refetch-container&quot;&gt;Refetch Containers&lt;/a&gt; , &lt;a href=&quot;pagination-container&quot;&gt;Pagination Containers&lt;/a&gt; 등 을 정의하는 데 사용할 수있는 GraphQL 문서의 런타임 표현입니다 .</target>
        </trans-unit>
        <trans-unit id="7803dad9067c5d50b3b4bf3ebacbfaade89ec277" translate="yes" xml:space="preserve">
          <source>The runtime automatically removes cached data that is no longer referenced, helping to reduce memory usage.</source>
          <target state="translated">런타임은 더 이상 참조되지 않는 캐시 된 데이터를 자동으로 제거하여 메모리 사용량을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="7502725bdbb2c17f80ff460d7924092be097b33c" translate="yes" xml:space="preserve">
          <source>The schema described below will be used to demonstrate the functionality that a GraphQL server used by Relay should implement. The two core types are a faction and a ship in the Star Wars universe, where a faction has many ships associated with it. The schema below is the output of the GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt;&lt;code&gt;schemaPrinter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아래에 설명 된 스키마는 Relay가 사용하는 GraphQL 서버가 구현해야하는 기능을 보여주기 위해 사용됩니다. 두 가지 핵심 유형은 스타 워즈 세계의 진영과 배이며, 진영에는 많은 배가 있습니다. 아래 스키마는 GraphQL.js &lt;a href=&quot;https://github.com/graphql/graphql-js/blob/master/src/utilities/schemaPrinter.js&quot;&gt; &lt;code&gt;schemaPrinter&lt;/code&gt; &lt;/a&gt; 의 출력입니다 .</target>
        </trans-unit>
        <trans-unit id="d1f4549e3c6f019d48ff8e76296ba821ef51f0c7" translate="yes" xml:space="preserve">
          <source>The second query refetched the information for one of those stories:</source>
          <target state="translated">두 번째 쿼리는 이러한 스토리 중 하나에 대한 정보를 다시 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="c7be7ec56f48de687831bf1d2b8ec095a4494b09" translate="yes" xml:space="preserve">
          <source>The set of IR documents forms a CompilerContext, which is then transformed and optimized.</source>
          <target state="translated">IR 문서 세트는 CompilerContext를 형성 한 다음 변환 및 최적화됩니다.</target>
        </trans-unit>
        <trans-unit id="e1ce127879727af2e2de7fc1ce77bce3c4f43c30" translate="yes" xml:space="preserve">
          <source>The solution to caching GraphQL is to normalize the hierarchical response into a flat collection of &lt;strong&gt;records&lt;/strong&gt;. Relay implements this cache as a map from IDs to records. Each record is a map from field names to field values. Records may also link to other records (allowing it to describe a cyclic graph), and these links are stored as a special value type that references back into the top-level map. With this approach each server record is stored &lt;em&gt;once&lt;/em&gt; regardless of how it is fetched.</source>
          <target state="translated">GraphQL을 캐싱하는 솔루션은 계층 적 응답을 평평한 &lt;strong&gt;레코드&lt;/strong&gt; 모음으로 정규화하는 것 입니다. 릴레이는이 캐시를 ID에서 레코드로의 맵으로 구현합니다. 각 레코드는 필드 이름에서 필드 값으로의 맵입니다. 레코드는 또한 다른 레코드에 연결될 수 있으며 (순환 그래프를 설명하도록 허용 함)이 링크는 최상위 맵을 다시 참조하는 특수한 값 유형으로 저장됩니다. 이 방법을 사용하면 각 서버 레코드 가 가져 오는 방법에 관계없이 &lt;em&gt;한 번&lt;/em&gt; 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="2238db3c2972a72399f41299cdb2bb500270de90" translate="yes" xml:space="preserve">
          <source>The term &amp;lsquo;variables&amp;rsquo; here refers to the input to the server-side mutation, &lt;strong&gt;not&lt;/strong&gt; to the variables made available to this mutation's fragment builders.</source>
          <target state="translated">여기서 '변수'라는 용어는 이 돌연변이의 단편 제작자가 이용할 수있는 변수가 &lt;strong&gt;아니라&lt;/strong&gt; 서버 측 돌연변이에 대한 입력을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="595203acdb212fda1237b7e11b4700b733a663ad" translate="yes" xml:space="preserve">
          <source>The three core assumptions that Relay makes about a GraphQL server are that it provides:</source>
          <target state="translated">Relay가 GraphQL 서버에 대해 세 가지 핵심 가정은 다음을 제공한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="80a872fa92f56ed5c31e04d7d32ff502b8f3fab1" translate="yes" xml:space="preserve">
          <source>The two methods differ in that instead of sending a query that includes only fields missing from the client, &lt;code&gt;forceFetch&lt;/code&gt; sends a request to refetch each and every fragment. This ensures that the props for the component are freshly fetched from the server.</source>
          <target state="translated">두 가지 방법은 클라이언트에서 누락 된 필드 만 포함하는 쿼리를 보내는 대신 &lt;code&gt;forceFetch&lt;/code&gt; 가 각 조각을 다시 가져 오기 위해 요청을 보냅니다. 이렇게하면 구성 요소의 소품을 서버에서 새로 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c4c5b50dcdfa847760bbbedcf52cb8e2ff536e6" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;photo&lt;/code&gt; field has changed; and therefore the record &lt;code&gt;2&lt;/code&gt; has also changed. And that's it. Nothing else in the &lt;em&gt;cache&lt;/em&gt; is affected. But clearly our &lt;em&gt;view&lt;/em&gt; needs to reflect the update: both instances of the author in the UI (as story author and comment author) need to show the new photo.</source>
          <target state="translated">&lt;code&gt;photo&lt;/code&gt; 필드 의 값 이 변경되었습니다. 따라서 레코드 &lt;code&gt;2&lt;/code&gt; 도 변경되었습니다. 그리고 그게 다야. &lt;em&gt;캐시의&lt;/em&gt; 다른 것은 영향을받지 않습니다. 그러나 분명히 우리의 &lt;em&gt;견해&lt;/em&gt; 에는 업데이트가 반영되어야합니다. UI의 작성자 (스토리 작성자 및 댓글 작성자)는 새 사진을 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="1232b961ddf31ef587aaa3e408f8aa3d44030a8f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, just run &lt;code&gt;yarn run relay&lt;/code&gt; to generate new files, or &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">그런 다음 응용 프로그램 파일을 편집 한 후에는 &lt;code&gt;yarn run relay&lt;/code&gt; 를 실행 하여 새 파일을 생성하거나 &lt;code&gt;yarn run relay -- --watch&lt;/code&gt; 를 사용하여 컴파일러를 장기 프로세스로 실행하여 저장할 때마다 새 파일을 자동으로 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="ef73d50cc222b2377dc0c600080db66496266f2f" translate="yes" xml:space="preserve">
          <source>Then after making edits to your application files, run &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; to generate new files, or &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; to run the compiler as a long-lived process which automatically generates new files whenever you save.</source>
          <target state="translated">그런 다음 응용 프로그램 파일을 편집 한 후 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql&lt;/code&gt; 을 실행하여 새 파일을 생성하거나 &lt;code&gt;relay-compiler --src ./src --schema path/schema.graphql --watch&lt;/code&gt; 는 저장할 때마다 새 파일을 자동으로 생성하는 장기 프로세스로 컴파일러를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="57a1f5033c269a68bc8794dc199b363a5c20cf8b" translate="yes" xml:space="preserve">
          <source>Then run &lt;code&gt;yarn run relay&lt;/code&gt; as set up before.</source>
          <target state="translated">그런 다음 설정 한대로 &lt;code&gt;yarn run relay&lt;/code&gt; 를 실행하십시오 .</target>
        </trans-unit>
        <trans-unit id="45b952755c02df6dff5e78f4c86d5e7d04e71f78" translate="yes" xml:space="preserve">
          <source>Then, add &lt;code&gt;&quot;relay&quot;&lt;/code&gt; to the list of plugins in your .babelrc file. For example:</source>
          <target state="translated">그런 다음 .babelrc 파일의 플러그인 목록에 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; 를 추가 하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa043b2e7bb17a1863151534669a087d81a912d9" translate="yes" xml:space="preserve">
          <source>There are a variety of solutions for keeping views up to date with a flattened cache. The approach that Relay takes is to maintain a mapping from each UI view to the set of IDs it references. In this case, the story view would subscribe to updates on the story (&lt;code&gt;1&lt;/code&gt;), the author (&lt;code&gt;2&lt;/code&gt;), and the comments (&lt;code&gt;3&lt;/code&gt; and any others). When writing data into the cache, Relay tracks which IDs are affected and notifies &lt;em&gt;only&lt;/em&gt; the views that are subscribed to those IDs. The affected views re-render, and unaffected views opt-out of re-rendering for better performance (Relay provides a safe but effective default &lt;code&gt;shouldComponentUpdate&lt;/code&gt;). Without this strategy, every view would re-render for even the tiniest change.</source>
          <target state="translated">플랫 캐시로 뷰를 최신 상태로 유지하기위한 다양한 솔루션이 있습니다. Relay가 취하는 접근법은 각 UI보기에서 참조하는 ID 세트로의 맵핑을 유지하는 것입니다. 이 경우 스토리보기는 스토리 ( &lt;code&gt;1&lt;/code&gt; ), 저자 ( &lt;code&gt;2&lt;/code&gt; ) 및 주석 ( &lt;code&gt;3&lt;/code&gt; 및 기타) 에 대한 업데이트를 구독합니다 . 데이터를 캐시에 쓸 때 릴레이는 영향을받는 ID를 추적 하고 해당 ID를 구독 한보기 &lt;em&gt;만&lt;/em&gt; 알립니다 . 영향을받는 뷰는 다시 렌더링되고 영향을받지 않은 뷰는 더 나은 성능을 위해 다시 렌더링을 선택하지 않습니다 (릴레이는 안전하지만 효과적인 기본 &lt;code&gt;shouldComponentUpdate&lt;/code&gt; 를 제공합니다 ). 이 전략이 없다면 가장 작은 변화조차도 모든 견해가 다시 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="19964f32b18bdaa18426e6241372ad8f6c37030a" translate="yes" xml:space="preserve">
          <source>There is currently only one supported way to set the initial value of a variable dynamically: using global variables defined on the query that includes the fragment (or via &lt;code&gt;variables&lt;/code&gt; on the &lt;code&gt;QueryRenderer&lt;/code&gt;).</source>
          <target state="translated">단편을 포함한다 (또는 비아 쿼리에 정의 된 전역 변수를 사용하여 동적으로 변수의 초기 값을 설정하는 하나의 방법은 현재 지원가 &lt;code&gt;variables&lt;/code&gt; 온 &lt;code&gt;QueryRenderer&lt;/code&gt; 는 ).</target>
        </trans-unit>
        <trans-unit id="9d42709663369aca59bb9f2ca4e4c05e806c0bb6" translate="yes" xml:space="preserve">
          <source>Therefore a typical data flow is as follows - note that this flow is managed automatically by higher-level APIs such as React/Relay. First a component will lookup the results of a selector against a record source (e.g. the store's canonical source):</source>
          <target state="translated">따라서 일반적인 데이터 흐름은 다음과 같습니다.이 흐름은 React / Relay와 같은 상위 수준 API에 의해 자동으로 관리됩니다. 먼저 컴포넌트는 레코드 소스 (예 : 상점의 표준 소스)에 대해 선택기의 결과를 조회합니다.</target>
        </trans-unit>
        <trans-unit id="7009a3cd68807292f00dff361667a386bda72fff" translate="yes" xml:space="preserve">
          <source>Therefore, a normalized response cache for GraphQL requires processing payloads and queries in parallel. For example, the &lt;code&gt;photo&lt;/code&gt; field from above might be cached with a generated field name such as &lt;code&gt;photo_size(32)&lt;/code&gt; in order to uniquely identify the field and its argument values.</source>
          <target state="translated">따라서 GraphQL에 대한 정규화 된 응답 캐시는 페이로드와 쿼리를 병렬로 처리해야합니다. 예를 들어, 위 의 &lt;code&gt;photo&lt;/code&gt; 필드 는 필드 및 인수 값을 고유하게 식별하기 위해 &lt;code&gt;photo_size(32)&lt;/code&gt; 와 같은 생성 된 필드 이름으로 캐시 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="046164a952e067900ed0105204b38b9650fcea6c" translate="yes" xml:space="preserve">
          <source>These are the methods and properties that the container will provide as &lt;code&gt;this.props.relay&lt;/code&gt; in the plain React component.</source>
          <target state="translated">이것들은 컨테이너가 일반 React 컴포넌트에서 &lt;code&gt;this.props.relay&lt;/code&gt; 로 제공 할 메소드와 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="5c8268547e740fb58d6875a6309af54d22de03e8" translate="yes" xml:space="preserve">
          <source>These features can be used in a couple of common scenarios: logging the client state for later inspection or interactively poking around the store from your browser's debugger.</source>
          <target state="translated">이 기능은 몇 가지 일반적인 시나리오에서 사용할 수 있습니다. 나중에 검사하기 위해 클라이언트 상태를 로깅하거나 브라우저의 디버거에서 저장소를 대화식으로 파킹합니다.</target>
        </trans-unit>
        <trans-unit id="1195afffc2435cbe5e7dac1ec74b6de7550b1719" translate="yes" xml:space="preserve">
          <source>Thinking In Relay</source>
          <target state="translated">릴레이 생각</target>
        </trans-unit>
        <trans-unit id="9e48341865426d82a3f397c5e1d57bc38bb5c5ba" translate="yes" xml:space="preserve">
          <source>Thinking in GraphQL</source>
          <target state="translated">GraphQL로 생각하기</target>
        </trans-unit>
        <trans-unit id="587e48e73d1fbcb3548410dad36aa1874f0eaaf5" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occur.</source>
          <target state="translated">이 콜백 소품은 다양한 데이터 분석 이벤트가 발생할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="83089afd24bef13575f73fb96b2667f2399b79e8" translate="yes" xml:space="preserve">
          <source>This callback prop is called as the various events of data resolution occurs.</source>
          <target state="translated">이 콜백 소품은 다양한 데이터 분석 이벤트가 발생할 때 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="a79b5038ef8c2e765648d6ba19aa3760d3f3486d" translate="yes" xml:space="preserve">
          <source>This can be upgraded by conditionally rendering a &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt; which will load the data once it is rendered. The code overhead of doing this is dramatically reduced with the new API.</source>
          <target state="translated">이는 렌더링 된 데이터를로드 하는 &lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; &lt;/a&gt; 를 조건부로 렌더링하여 업그레이드 할 수 있습니다 . 새로운 API를 사용하면 코드 오버 헤드가 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="6aa6b4ce32c479ca8e376d46b66428bac2d82d69" translate="yes" xml:space="preserve">
          <source>This can be upgraded by using a &lt;a href=&quot;refetch-container&quot;&gt;&lt;code&gt;RefetchContainer&lt;/code&gt;&lt;/a&gt; which allows you to specify the exact query to use to fetch the new data.</source>
          <target state="translated">새 데이터를 가져 오는 데 사용할 정확한 쿼리를 지정할 수 있는 &lt;a href=&quot;refetch-container&quot;&gt; &lt;code&gt;RefetchContainer&lt;/code&gt; &lt;/a&gt; 를 사용하여 업그레이드 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fa24150c2aafefe95a09ecc07832206180f13d5" translate="yes" xml:space="preserve">
          <source>This causes a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">이로 인해 생성 된 파일이 &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; 에 나타나고 런타임 아티팩트 (Relay Store에서 읽고 쓰는 데 도움이 됨)와 유형이 안전한 코드를 작성하는 데 도움이되는 &lt;a href=&quot;https://flow.org/&quot;&gt;흐름 유형&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9ea7bef6484a7c1cbe254ffda535079f7700daf" translate="yes" xml:space="preserve">
          <source>This document, together with &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; and &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler Architecture&lt;/a&gt;, describes the high-level architecture of Relay &quot;Modern&quot;. The intended audience includes developers interested in contributing to Relay, developers hoping to utilize the building blocks of Relay to create higher-level APIs, and anyone interested in understanding more about Relay internals. For developers wanting to learn more about &lt;em&gt;using&lt;/em&gt; Relay to build products, the other sections might be more helpful.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;runtime-architecture&quot;&gt;Runtime Architecture&lt;/a&gt; 및 &lt;a href=&quot;compiler-architecture&quot;&gt;Compiler &lt;/a&gt;Architecture 와 함께 Relay &quot;Modern&quot;의 고급 아키텍처에 대해 설명합니다. 대상에는 Relay에 기여하는 데 관심이있는 개발자, Relay의 빌딩 블록을 활용하여 더 높은 수준의 API를 만들려는 개발자, Relay 내부에 대해 더 많이 이해하는 데 관심이있는 모든 사람이 포함됩니다. Relay를 &lt;em&gt;사용하여&lt;/em&gt; 제품을 빌드 하는 방법에 대해 자세히 알아 보려는 개발자에게는 다른 섹션이 더 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74dbf4caec721ba1ccc2a6b88d7ee594184d8bbc" translate="yes" xml:space="preserve">
          <source>This example demonstrates all three of these assumptions.</source>
          <target state="translated">이 예는이 세 가지 가정을 모두 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9479e9ba5c11bcfea7c69c38843fdeb8dbbdfea5" translate="yes" xml:space="preserve">
          <source>This example is not comprehensive, but it is designed to quickly introduce these core assumptions, to provide some context before diving into the more detailed specification of the library.</source>
          <target state="translated">이 예제는 포괄적이지는 않지만 라이브러리의보다 자세한 사양에 들어가기 전에 일부 핵심 내용을 제공하기 위해 이러한 핵심 가정을 빠르게 소개하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="f185525936893aacea00cf71a3224c86985f3df6" translate="yes" xml:space="preserve">
          <source>This fat query looks like any other GraphQL query, with one important distinction. We know some of these fields to be non-scalar (like &lt;code&gt;friendEdge&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;) but notice that we have not named any of their children by way of a subquery. In this way, we indicate to Relay that &lt;em&gt;anything&lt;/em&gt; under those non-scalar fields may change as a result of this mutation.</source>
          <target state="translated">이 팻 쿼리는 다른 GraphQL 쿼리와 비슷하지만 중요한 차이점이 있습니다. 이러한 필드 중 일부는 스칼라가 아닌 것으로 알고 있지만 ( &lt;code&gt;friendEdge&lt;/code&gt; 및 &lt;code&gt;friends&lt;/code&gt; 등 ) 하위 쿼리를 통해 하위 항목의 이름을 지정하지 않았습니다. 이러한 방법으로, 우리는 릴레이로 나타내는 &lt;em&gt;것도&lt;/em&gt; 그 비 스칼라 필드에서이 돌연변이의 결과로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81b1261e20f66bafeb445251ddc3d3efb2158432" translate="yes" xml:space="preserve">
          <source>This fresh &lt;code&gt;RecordSource&lt;/code&gt; would then be published to the store:</source>
          <target state="translated">이 새로운 &lt;code&gt;RecordSource&lt;/code&gt; 는 스토어에 게시됩니다.</target>
        </trans-unit>
        <trans-unit id="61564f3549d718187ddfeb22e3808eafa802c07e" translate="yes" xml:space="preserve">
          <source>This gets converted into a &quot;lazy&quot; require of a generated file:</source>
          <target state="translated">이것은 생성 된 파일의 &quot;게으른&quot;요구로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="ea59f490525a696053dec758108ce2a68882aa64" translate="yes" xml:space="preserve">
          <source>This gets converted into an immediately-invoked function:</source>
          <target state="translated">이것은 즉시 호출되는 함수로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="01abddd8ac86ef6eb75568464191008b4ca72daa" translate="yes" xml:space="preserve">
          <source>This installs the bin script &lt;code&gt;relay-compiler&lt;/code&gt; in your node_modules folder. It's recommended to run this from a yarn/npm script by adding a script to your &lt;code&gt;package.json&lt;/code&gt; file:</source>
          <target state="translated">bin 스크립트 &lt;code&gt;relay-compiler&lt;/code&gt; 가 node_modules 폴더에 설치됩니다. &lt;code&gt;package.json&lt;/code&gt; 파일에 스크립트를 추가하여 yarn / npm 스크립트에서이를 실행하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="11a6b3482924983de73327e990f1793b755a9291" translate="yes" xml:space="preserve">
          <source>This is a specialization of the general-purpose refetch container that is tailored for the common scenario of paginating through a collection of items by fetching successively more pages of data. See &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;createPaginationContainer&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이는 연속적으로 더 많은 페이지의 데이터를 가져 와서 항목 콜렉션을 통해 페이지를 매기는 일반적인 시나리오에 맞게 조정 된 범용 리 페치 컨테이너의 특수화입니다. 자세한 내용은 &lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;createPaginationContainer&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d4db8c43d3a16c260f2c767a658dfa356471e9a7" translate="yes" xml:space="preserve">
          <source>This is an array of events received so far (see &lt;code&gt;ReadyStateEvent&lt;/code&gt; below).</source>
          <target state="translated">지금까지 수신 된 이벤트 배열입니다 (아래 &lt;code&gt;ReadyStateEvent&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="4d0129df19cfd202bd9745fb3f722df875299901" translate="yes" xml:space="preserve">
          <source>This is an instance of &lt;code&gt;Error&lt;/code&gt; if there is a failure. Otherwise, this is &lt;code&gt;null&lt;/code&gt;.</source>
          <target state="translated">장애가있는 경우 &lt;code&gt;Error&lt;/code&gt; 의 인스턴스입니다 . 그렇지 않은 경우는 &lt;code&gt;null&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="69752386ee76a26381a40e623b5c2ca8480c36c2" translate="yes" xml:space="preserve">
          <source>This is only a simple example: in reality the cache must handle one-to-many associations and pagination (among other things).</source>
          <target state="translated">이것은 단순한 예일뿐입니다. 실제로 캐시는 일대 다 연관 및 페이지 매김을 처리해야합니다 (다른 것들 중에서도).</target>
        </trans-unit>
        <trans-unit id="7b3c087bb51f2da841015c33dcb71977fe0212c4" translate="yes" xml:space="preserve">
          <source>This is the general constructor for creating &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; instances with optional &lt;code&gt;files&lt;/code&gt;, &lt;code&gt;callbacks&lt;/code&gt; and &lt;code&gt;collisionKey&lt;/code&gt; arguments.</source>
          <target state="translated">이 만드는 일반적인 생성자 &lt;code&gt;Relay.GraphQLMutation&lt;/code&gt; 의 옵션으로 인스턴스를 &lt;code&gt;files&lt;/code&gt; , &lt;code&gt;callbacks&lt;/code&gt; 및 &lt;code&gt;collisionKey&lt;/code&gt; 인수.</target>
        </trans-unit>
        <trans-unit id="ab97009210eccb9f3d5c90eae312fb3cfd66a060" translate="yes" xml:space="preserve">
          <source>This is the lowest level of abstraction at which product code may deal with mutations in Relay, and it corresponds to the mutation operation (&quot;a write followed by a fetch&quot;) described in &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;the GraphQL Specification&lt;/a&gt;. You specify the mutation, the inputs, and the query.</source>
          <target state="translated">이것은 제품 코드가 릴레이에서 돌연변이를 처리 할 수있는 가장 낮은 추상화 레벨이며 &lt;a href=&quot;https://facebook.github.io/relay/graphql/mutations.htm&quot;&gt;GraphQL 사양에&lt;/a&gt; 설명 된 돌연변이 작업 ( &quot;쓰기 후 페치&quot;)에 해당합니다 . 돌연변이, 입력 및 쿼리를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="71da35a87d2df91e0c17e3a05dce16632307fd68" translate="yes" xml:space="preserve">
          <source>This is true when &lt;em&gt;all&lt;/em&gt; data requirements are ready for rendering.</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 데이터 요구 사항이 렌더링 준비 가 된 경우에 해당됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb078cd30db73d188c6edca1d054b3822d3838fd" translate="yes" xml:space="preserve">
          <source>This is true when the subset of data required for rendering is ready.</source>
          <target state="translated">이는 렌더링에 필요한 데이터의 하위 집합이 준비된 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="12c08d7a8f7eb77071004758dca7ab969bb7d7cb" translate="yes" xml:space="preserve">
          <source>This is where GraphQL comes into play. Components specify one or multiple GraphQL fragments for some of their props describing their data requirements. Each GraphQL fragment has a unique name within an application which allows us to determine the query needed to fetch the full query tree in a build step and load all the required data in a single network request efficiently at runtime.</source>
          <target state="translated">이것이 GraphQL이 작동하는 곳입니다. 구성 요소는 데이터 요구 사항을 설명하는 일부 소품에 대해 하나 또는 여러 개의 GraphQL 조각을 지정합니다. 각 GraphQL 조각에는 애플리케이션 내에서 고유 한 이름이있어 빌드 단계에서 전체 쿼리 트리를 가져오고 런타임에 단일 네트워크 요청에서 필요한 모든 데이터를 효율적으로로드하는 데 필요한 쿼리를 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40d6df25c7774cfef7c19fa68f7bcd72dbf71d40" translate="yes" xml:space="preserve">
          <source>This may be helpful to reduce redundant fragments when dealing with nested or recursive data within a single Component.</source>
          <target state="translated">이는 단일 구성 요소 내에서 중첩되거나 재귀적인 데이터를 처리 할 때 중복 조각을 줄이는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d2596643eab3080985621c3e255ffe66dd1fb15" translate="yes" xml:space="preserve">
          <source>This method can optionally return a promise in order to facilitate proper error propagation.</source>
          <target state="translated">이 방법은 적절한 오류 전파를 촉진하기 위해 선택적으로 약속을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5a0085a036246ce072609380ef834dd25b9e599" translate="yes" xml:space="preserve">
          <source>This method is also called after the partial set of variables from &lt;code&gt;setVariables&lt;/code&gt; has been applied. The variables returned are used to populate the fragments.</source>
          <target state="translated">이 메소드는 &lt;code&gt;setVariables&lt;/code&gt; 의 부분 변수 세트 가 적용된 후에도 호출 됩니다. 반환 된 변수는 조각을 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0603bfcf101a33a1c1eed64335628df20ea3aa9c" translate="yes" xml:space="preserve">
          <source>This method receives an array of queries (instead of a single query) in order to facilitate batching queries to improve network efficiency.</source>
          <target state="translated">이 방법은 일괄 쿼리를 용이하게하여 네트워크 효율성을 향상시키기 위해 단일 쿼리 대신 쿼리 배열을 수신합니다.</target>
        </trans-unit>
        <trans-unit id="a87ccc42db63f2f52eeae29ff4feceb34933d42f" translate="yes" xml:space="preserve">
          <source>This should be upgraded to use a &lt;a href=&quot;pagination-container&quot;&gt;&lt;code&gt;PaginationContainer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt; &lt;code&gt;PaginationContainer&lt;/code&gt; &lt;/a&gt; 를 사용하도록 업그레이드해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a7bf020a941d10f70ab32528d56d8597a05d0895" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render &lt;code&gt;ProfilePicture&lt;/code&gt; within a &lt;code&gt;ScrollView&lt;/code&gt; component as soon as data is ready.</source>
          <target state="translated">이 스 니펫 은 데이터가 준비되는 즉시 &lt;code&gt;ScrollView&lt;/code&gt; 구성 요소 내에서 &lt;code&gt;ProfilePicture&lt;/code&gt; 를 렌더링 하도록 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 를 구성합니다 .</target>
        </trans-unit>
        <trans-unit id="70500d59ecc10d7cea4a148a7386cb41d2c4d0f0" translate="yes" xml:space="preserve">
          <source>This snippet configures &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; to render the &quot;Loading...&quot; text whenever it needs to fetch data.</source>
          <target state="translated">이 스 니펫 은 데이터를 가져와야 할 때마다 &quot;로드 중 ...&quot;텍스트를 렌더링 하도록 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="00b1b28bd3be2fa7e76055fd5d3f672dc5d7fda8" translate="yes" xml:space="preserve">
          <source>This will create a series of &lt;code&gt;__generated__&lt;/code&gt; directories that are co-located with the corresponding files containing &lt;code&gt;graphql&lt;/code&gt; tags.</source>
          <target state="translated">이렇게하면 &lt;code&gt;graphql&lt;/code&gt; 태그가 포함 된 해당 파일과 같은 위치에 일련의 &lt;code&gt;__generated__&lt;/code&gt; 디렉토리 가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="a737ccc7b583949623cef676beba937c7dc28a69" translate="yes" xml:space="preserve">
          <source>This will inform &lt;code&gt;Relay.QL&lt;/code&gt; that this particular field is an array. This will also allow you to use a plural name for the fragment (i.e. &lt;code&gt;bars&lt;/code&gt; instead of &lt;code&gt;bar&lt;/code&gt;).</source>
          <target state="translated">그러면 이 특정 필드가 배열임을 &lt;code&gt;Relay.QL&lt;/code&gt; 에 알립니다 . 또한 조각에 복수 이름을 사용할 수도 있습니다 (예 : &lt;code&gt;bars&lt;/code&gt; 대신 &lt;code&gt;bar&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2dcccc952811069ad73564d196e2e6f3b0ec664d" translate="yes" xml:space="preserve">
          <source>This would produce three generated files, and two &lt;code&gt;__generated__&lt;/code&gt; directories:</source>
          <target state="translated">이렇게하면 생성 된 파일 세 개와 &lt;code&gt;__generated__&lt;/code&gt; 디렉토리 두 개가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e7c9a4f20eb8494e45f8c514abfa27440507df5" translate="yes" xml:space="preserve">
          <source>To add a new paginating relay container</source>
          <target state="translated">새로운 페이지 매김 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="4afe3d419de5a0a7685601e4998733289b1a991a" translate="yes" xml:space="preserve">
          <source>To add a new relay container</source>
          <target state="translated">새 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="da88d2c6beb30dbb3f7e5c35d288e84155365752" translate="yes" xml:space="preserve">
          <source>To add a new relay container that has changing data requirements</source>
          <target state="translated">데이터 요구 사항이 변경되는 새 릴레이 컨테이너를 추가하려면</target>
        </trans-unit>
        <trans-unit id="b78283d8fe106afc67ec588e2762311c4df0a3bd" translate="yes" xml:space="preserve">
          <source>To add a new root for relay components</source>
          <target state="translated">릴레이 구성 요소의 새 루트를 추가하려면</target>
        </trans-unit>
        <trans-unit id="2cb466b85716cc24434b2a68c68d7668bbaceabb" translate="yes" xml:space="preserve">
          <source>To call this method on the underlying component, first provide a &lt;code&gt;componentRef&lt;/code&gt; function to the Relay container. This differs from providing a &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/a&gt; function which would provide a reference to the Relay container itself, not the underlying React Component.</source>
          <target state="translated">기본 컴포넌트에서이 메소드를 호출하려면 먼저 릴레이 컨테이너에 &lt;code&gt;componentRef&lt;/code&gt; 함수를 제공하십시오 . 이것은 기본 React Component가 아니라 Relay 컨테이너 자체에 대한 참조를 제공하는 &lt;a href=&quot;https://facebook.github.io/react/docs/refs-and-the-dom.html&quot;&gt; &lt;code&gt;ref&lt;/code&gt; &lt;/a&gt; 함수를 제공하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="65aa58a75ec1e39e9166d34dcff5d186dbe23e3a" translate="yes" xml:space="preserve">
          <source>To commit a mutation</source>
          <target state="translated">돌연변이를 저 지르려면</target>
        </trans-unit>
        <trans-unit id="89b06193bd6c9ce7d1f792c95362915c77c9675f" translate="yes" xml:space="preserve">
          <source>To create an environment instance in Relay Modern, use the &lt;code&gt;RelayModernEnvironment&lt;/code&gt; class:</source>
          <target state="translated">Relay Modern에서 환경 인스턴스를 만들려면 &lt;code&gt;RelayModernEnvironment&lt;/code&gt; 클래스를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="79a86851c1fad2bbe848185a0d8955e026baa0f4" translate="yes" xml:space="preserve">
          <source>To enable &lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;, &lt;code&gt;relay-compiler&lt;/code&gt; enforces a simple naming convention for your queries. Queries must be named as &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt;, where &quot;&amp;lt;OperationType&amp;gt;&quot; is one of &quot;Query&quot;, &quot;Mutation&quot;, or &quot;Subscription&quot;. The query above is named &lt;code&gt;ExampleQuery&lt;/code&gt; so should be placed in &lt;code&gt;Example.js&lt;/code&gt;.</source>
          <target state="translated">사용하려면 &lt;a href=&quot;relay-compat&quot;&gt;호환성 모드를&lt;/a&gt; , &lt;code&gt;relay-compiler&lt;/code&gt; 쿼리에 대한 명명 규칙을 간단을 적용합니다. 쿼리 이름은 &lt;code&gt;&amp;lt;FileName&amp;gt;&amp;lt;OperationType&amp;gt;&lt;/code&gt; 이어야하며 여기서 &quot;&amp;lt;OperationType&amp;gt;&quot;은 &quot;Query&quot;, &quot;Mutation&quot;또는 &quot;Subscription&quot;중 하나입니다. 위의 쿼리 이름은 &lt;code&gt;ExampleQuery&lt;/code&gt; 이므로 &lt;code&gt;Example.js&lt;/code&gt; 에 배치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="03ec37246eca3b43ea7ac7f76a27cbf7c5cb3d8b" translate="yes" xml:space="preserve">
          <source>To execute this code, Relay needs access to the schema - which can be too large to bundle inside the application. Instead, these &lt;code&gt;Relay.QL&lt;/code&gt; template expressions are transpiled into JavaScript descriptions via the &lt;code&gt;babel-relay-plugin&lt;/code&gt;. This schema information allows Relay to understand things like the types of field arguments, which fields are connections or lists, and how to efficiently refetch records from the server.</source>
          <target state="translated">이 코드를 실행하려면 Relay는 스키마에 액세스해야합니다. 스키마는 너무 커서 애플리케이션 내부에 번들로 묶을 수 없습니다. 대신 이러한 &lt;code&gt;Relay.QL&lt;/code&gt; 템플릿 표현식은 &lt;code&gt;babel-relay-plugin&lt;/code&gt; 을 통해 JavaScript 설명으로 변환됩니다 . 이 스키마 정보를 통해 Relay는 필드 인수 유형, 연결 또는 목록 인 필드 및 서버에서 레코드를 효율적으로 다시 가져 오는 방법과 같은 사항을 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be87ed7f838f24ecfdb363ea58800de8f9dfbc1" translate="yes" xml:space="preserve">
          <source>To force fetch a component</source>
          <target state="translated">구성 요소를 강제로 가져 오려면</target>
        </trans-unit>
        <trans-unit id="e7e54aa101836df2ce7d5415960a239df67598f0" translate="yes" xml:space="preserve">
          <source>To get started building Relay applications, you will need three things:</source>
          <target state="translated">Relay 애플리케이션을 구축하려면 다음 세 가지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="45fa77bbc0446347a81f6d5b23fa090e9c9d6856" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">인지 된 응답 성을 향상시키기 위해 서버의 응답이 돌아 오기 전에 예상되는 새로운 값을 반영하도록 클라이언트가 즉시 업데이트하는 &quot;낙관적 업데이트&quot;를 수행 할 수 있습니다. 이를 수행하는 가장 간단한 방법은 &lt;code&gt;optimisticResponse&lt;/code&gt; 를 제공하고 이를 &lt;code&gt;commitMutation&lt;/code&gt; 에 전달 하는 &lt;code&gt;config&lt;/code&gt; 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="2cf9a932987c095688d86461efe0eedbdc22d8b7" translate="yes" xml:space="preserve">
          <source>To improve perceived responsiveness, you may wish to perform an &quot;optimistic update&quot;, in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. We do this by providing an &lt;code&gt;optimisticResponse&lt;/code&gt; and adding it to the &lt;code&gt;config&lt;/code&gt; that we pass into &lt;code&gt;commitMutation&lt;/code&gt;:</source>
          <target state="translated">인식 된 응답 성을 향상시키기 위해 서버의 응답이 다시 시작되기 전에 클라이언트가 예상되는 새 값을 반영하도록 즉시 업데이트하는 &quot;낙관적 업데이트&quot;를 수행 할 수 있습니다. 우리는 &lt;code&gt;optimisticResponse&lt;/code&gt; 를 제공하고 이를 &lt;code&gt;commitMutation&lt;/code&gt; 에 전달 하는 &lt;code&gt;config&lt;/code&gt; 추가함으로써이를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="bebfedde59ec9253c14e34d042772cb6d964fce0" translate="yes" xml:space="preserve">
          <source>To paginate through a connection</source>
          <target state="translated">연결을 통해 페이지 매김</target>
        </trans-unit>
        <trans-unit id="b6033100545414ff9dedc545a14635be362e73ed" translate="yes" xml:space="preserve">
          <source>To read from the cache we can walk a query and resolve each field. But wait: that sounds &lt;em&gt;exactly&lt;/em&gt; like what a GraphQL server does when it processes a query. And it is! Reading from the cache is a special case of an executor where a) there's no need for user-defined field functions because all results come from a fixed data structure and b) results are always synchronous &amp;mdash; we either have the data cached or we don't.</source>
          <target state="translated">캐시에서 읽기 위해 쿼리를 수행하고 각 필드를 해결할 수 있습니다. 그러나 기다립니다 : GraphQL 서버가 쿼리를 처리 할 때와 &lt;em&gt;정확히&lt;/em&gt; 같습니다. 그리고 그건! 캐시에서 읽는 것은 실행기의 특수한 경우입니다. 티.</target>
        </trans-unit>
        <trans-unit id="e168ce7f96f9f96537f762eb07d59ca6c422e92d" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; component that displays the user's profile photo and a slider to adjust the photo's size.</source>
          <target state="translated">시작하려면 사용자의 프로필 사진과 사진 크기를 조정하는 슬라이더를 표시 하는 일반 React 버전의 &lt;code&gt;&amp;lt;ProfilePicture&amp;gt;&lt;/code&gt; 구성 요소를 만들어 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="fccbd6622bb8847d0929fc4851e9ea2b575ead73" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">시작하려면 &lt;code&gt;Todo&lt;/code&gt; 의 텍스트 및 완료 상태를 표시하는 일반 React 버전의 &lt;code&gt;&amp;lt;TodoItem&amp;gt;&lt;/code&gt; 컴포넌트를 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ac483e211ecf7cd1ac9ea59c0478cde75088452" translate="yes" xml:space="preserve">
          <source>To start, let's build the plain React version of a hypothetical &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; component that displays the text and completion status of a &lt;code&gt;Todo&lt;/code&gt;.</source>
          <target state="translated">시작하려면 &lt;code&gt;Todo&lt;/code&gt; 의 텍스트 및 완료 상태를 표시 하는 가상의 &lt;code&gt;&amp;lt;TodoItem /&amp;gt;&lt;/code&gt; 구성 요소 의 일반 React 버전을 빌드 해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="11ddeec9a3447606ae9ab043cf0ed78d26a53e7b" translate="yes" xml:space="preserve">
          <source>To update a variable for my component</source>
          <target state="translated">컴포넌트의 변수를 업데이트하려면</target>
        </trans-unit>
        <trans-unit id="3f1189857789cd58adacaebeec728b8e0afcce44" translate="yes" xml:space="preserve">
          <source>To use the Relay Compiler, you need either a .graphql or .json GraphQL schema file, describing your GraphQL server's API. Typically these files are local representations of a server source of truth and are not edited directly. For example, we might have a &lt;code&gt;schema.graphql&lt;/code&gt; like:</source>
          <target state="translated">릴레이 컴파일러를 사용하려면 GraphQL 서버의 API를 설명하는 .graphql 또는 .json GraphQL 스키마 파일이 필요합니다. 일반적으로 이러한 파일은 서버 진실 소스의 로컬 표현이며 직접 편집되지 않습니다. 예를 들어 &lt;code&gt;schema.graphql&lt;/code&gt; 과 같은 schema.graphql 이있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9be854f285feec3a5f3620acb9820d1d2c32fbd0" translate="yes" xml:space="preserve">
          <source>To use these pieces to construct a full-fledged GraphQL query that we can send to the server to fetch data, we need to use the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt;.</source>
          <target state="translated">우리가 데이터를 가져 오기 위해 서버로 보낼 수있는 본격적인 GraphQL 쿼리를 구성하지는이 조각을 사용하려면, 우리는 사용할 필요가 &lt;strong&gt;Relay.RootContainer을&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0cef4df4d340703594fc301669e90430e959441b" translate="yes" xml:space="preserve">
          <source>Transforms</source>
          <target state="translated">Transforms</target>
        </trans-unit>
        <trans-unit id="2701a94c0eb55cbd958a87dff3e959673ff1bf53" translate="yes" xml:space="preserve">
          <source>Tutorial</source>
          <target state="translated">Tutorial</target>
        </trans-unit>
        <trans-unit id="7634bede4230d278e0e78179b1dcae8473d4d33a" translate="yes" xml:space="preserve">
          <source>Types for working with queries and their results include:</source>
          <target state="translated">쿼리 및 그 결과 작업을위한 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f77a5658e80339ebafab29498f8ee4b43724b2e0" translate="yes" xml:space="preserve">
          <source>Typical Relay Classic code:</source>
          <target state="translated">일반적인 릴레이 클래식 코드 :</target>
        </trans-unit>
        <trans-unit id="95e39abda529007d77cea645d9c98a79ceba0779" translate="yes" xml:space="preserve">
          <source>Typical old code:</source>
          <target state="translated">전형적인 예전 코드 :</target>
        </trans-unit>
        <trans-unit id="5ea4501b4b61baf5dd246de000e69cf2c83ec128" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will convert the &lt;code&gt;graphql&lt;/code&gt; literals to &lt;code&gt;require()&lt;/code&gt; the generated files.</source>
          <target state="translated">일반적으로 생성 된 정의를 가져올 필요가 없습니다. &lt;a href=&quot;babel-plugin-relay&quot;&gt;릴레이 바벨 플러그인은&lt;/a&gt; 변환합니다 &lt;code&gt;graphql&lt;/code&gt; 하는 리터럴 &lt;code&gt;require()&lt;/code&gt; 생성 된 파일을.</target>
        </trans-unit>
        <trans-unit id="fe82c32a588b217dd555d86acd7cd881dee1801f" translate="yes" xml:space="preserve">
          <source>Typically you will not need to import your generated definitions. The &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;Relay Babel plugin&lt;/a&gt; will then convert the &lt;code&gt;graphql&lt;/code&gt; literals in your code into &lt;code&gt;require()&lt;/code&gt; calls for the generated files.</source>
          <target state="translated">일반적으로 생성 된 정의를 가져올 필요가 없습니다. &lt;a href=&quot;installation-and-setup#setup-babel-plugin-relay&quot;&gt;릴레이 바벨 플러그인&lt;/a&gt; 다음 변환합니다 &lt;code&gt;graphql&lt;/code&gt; 의 에 코드에서 리터럴을 &lt;code&gt;require()&lt;/code&gt; 생성 된 파일을 요구한다.</target>
        </trans-unit>
        <trans-unit id="43a4e34531ca0764965880501d0f8c89a74d18d5" translate="yes" xml:space="preserve">
          <source>Underneath the hood, the default network layer uses &lt;code&gt;fetch&lt;/code&gt; (&lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt;). The constructor for &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; takes an optional second argument that accepts any valid initialization property that &lt;code&gt;fetch&lt;/code&gt; accepts.</source>
          <target state="translated">후드 아래에서 기본 네트워크 계층은 &lt;code&gt;fetch&lt;/code&gt; ( &lt;a href=&quot;https://fetch.spec.whatwg.org&quot;&gt;Living Standard&lt;/a&gt; )를 사용합니다. &lt;code&gt;Relay.DefaultNetworkLayer&lt;/code&gt; 의 생성자 는 &lt;code&gt;fetch&lt;/code&gt; 가 허용하는 유효한 초기화 속성을 수락하는 선택적 두 번째 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="b2498fd787926326020b483e3523f960c30e4f9d" translate="yes" xml:space="preserve">
          <source>Unlike queries, failed requests for mutations are not automatically retried.</source>
          <target state="translated">쿼리와 달리 돌연변이에 대한 실패한 요청은 자동으로 재 시도되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fa7f90794261c83159eb4a91e2dfe23661dee9e6" translate="yes" xml:space="preserve">
          <source>Up until this point we have only interacted with the GraphQL endpoint to perform queries that fetch data. In this guide, you will learn how to use Relay to perform mutations &amp;ndash; operations that consist of writes to the data store followed by a fetch of any changed fields.</source>
          <target state="translated">지금까지는 데이터를 가져 오는 쿼리를 수행하기 위해 GraphQL 엔드 포인트와 만 상호 작용했습니다. 이 가이드에서는 릴레이를 사용하여 데이터 저장소에 대한 쓰기와 변경된 필드 가져 오기로 구성된 돌연변이를 수행하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="706a52f4ea94115123954122a8c78690d8a63036" translate="yes" xml:space="preserve">
          <source>Updater Configs</source>
          <target state="translated">업데이터 구성</target>
        </trans-unit>
        <trans-unit id="f2d05363c2e81a266183ca6ef8b7bd0bdbd8b278" translate="yes" xml:space="preserve">
          <source>Updates the records associated with a mutable record, transversing the source by field name and an object representing pre-defined argument values.</source>
          <target state="translated">필드 이름 및 사전 정의 된 인수 값을 나타내는 오브젝트를 소스로 이동하여 변경 가능한 레코드와 연관된 레코드를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="77357ed1c74dd26c490773b79c9c64db80714ee8" translate="yes" xml:space="preserve">
          <source>Updates the value of a mutable record's attribute given by the field name and an object representing pre-defined argument values.</source>
          <target state="translated">필드 이름과 사전 정의 된 인수 값을 나타내는 객체가 제공하는 가변 레코드 속성의 값을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="130a5ea1f38180314e9b7e8d2e0c0f8791af7800" translate="yes" xml:space="preserve">
          <source>Updating the client on each response</source>
          <target state="translated">각 응답에서 클라이언트 업데이트</target>
        </trans-unit>
        <trans-unit id="9c5f928161eaee0e6b37f9f04f9b99fffe3258b5" translate="yes" xml:space="preserve">
          <source>Updating the client optimistically</source>
          <target state="translated">클라이언트를 낙관적으로 업데이트</target>
        </trans-unit>
        <trans-unit id="683610f0bd36453d03467df7a76f50661ef6f8ac" translate="yes" xml:space="preserve">
          <source>Updating the local cache after receiving query/mutation responses.</source>
          <target state="translated">쿼리 / 돌연변이 응답을받은 후 로컬 캐시를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="5cbc715352505bf09eed712fc8faa91711d9dd6f" translate="yes" xml:space="preserve">
          <source>Updating the store programatically (advanced)</source>
          <target state="translated">프로그래밍 방식으로 상점 업데이트 (고급)</target>
        </trans-unit>
        <trans-unit id="b03854fc017532ee497460390d8d2a3a98701a8a" translate="yes" xml:space="preserve">
          <source>Upgrade to react-relay v1.0.0</source>
          <target state="translated">반응 릴레이 v1.0.0으로 업그레이드</target>
        </trans-unit>
        <trans-unit id="6f683dd933be22f58cc623c7fb6049182ce19997" translate="yes" xml:space="preserve">
          <source>Upgrading setVariables</source>
          <target state="translated">setVariables 업그레이드</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="64cfd0b3a8ed6125a106524eb46cf6330e091d8e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitLocalUpdate&lt;/code&gt; when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay &lt;code&gt;environment&lt;/code&gt; and an &lt;code&gt;updater&lt;/code&gt; function.</source>
          <target state="translated">반드시 변형을 실행하지 않고 로컬 저장소를 업데이트해야하는 경우 (예 : 디 바운스 된 작업의 경우) &lt;code&gt;commitLocalUpdate&lt;/code&gt; 를 사용하십시오 . 이 기능은 릴레이 &lt;code&gt;environment&lt;/code&gt; 과 &lt;code&gt;updater&lt;/code&gt; 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9443a1d180d1993141d5ed99d3c993a96f971b4c" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;commitMutation&lt;/code&gt; to create and execute mutations. &lt;code&gt;commitMutation&lt;/code&gt; has the following signature:</source>
          <target state="translated">사용 &lt;code&gt;commitMutation&lt;/code&gt; 을 돌연변이를 작성하고 실행할 수 있습니다. &lt;code&gt;commitMutation&lt;/code&gt; 에는 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="855b7cdc9a7b7eedbbade3460ffda75d84c0215a" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;introspectionQuery&lt;/code&gt; to generate a Schema JSON for the Babel Relay Plugin, and use &lt;code&gt;printSchema&lt;/code&gt; to generate a user readable type system shorthand:</source>
          <target state="translated">&lt;code&gt;introspectionQuery&lt;/code&gt; 를 사용 하여 Babel Relay 플러그인에 대한 스키마 JSON 을 생성하고 &lt;code&gt;printSchema&lt;/code&gt; 를 사용하여 사용자가 읽을 수있는 유형 시스템 속기를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9c04ab0245abf53d950383b659bb519121fdf39c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;graphql&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;graphql&lt;/code&gt; 사용</target>
        </trans-unit>
        <trans-unit id="dc3790d0260968db930a9c68e2f92f666400ec99" translate="yes" xml:space="preserve">
          <source>Using Other GraphQL Implementations</source>
          <target state="translated">다른 GraphQL 구현 사용</target>
        </trans-unit>
        <trans-unit id="ce363e86e1227248ffe7c0ac61d5dfa9beb38f62" translate="yes" xml:space="preserve">
          <source>Using The Cache</source>
          <target state="translated">캐시 사용</target>
        </trans-unit>
        <trans-unit id="7cc52f33aee5330befcd51c2b80f9fac7ea6a7af" translate="yes" xml:space="preserve">
          <source>Using during conversion in &quot;&lt;a href=&quot;relay-compat&quot;&gt;compatibility mode&lt;/a&gt;&quot;</source>
          <target state="translated">&quot; &lt;a href=&quot;relay-compat&quot;&gt;호환 모드&lt;/a&gt; &quot; 에서 변환 중에 사용</target>
        </trans-unit>
        <trans-unit id="410e9ae9e9ce0fe0fb15689548590810d66caa99" translate="yes" xml:space="preserve">
          <source>Using updater and optimisticUpdater</source>
          <target state="translated">업데이터 및 optimisticUpdater 사용</target>
        </trans-unit>
        <trans-unit id="4ca24372752ba964092860cbbff37a07dae71dd0" translate="yes" xml:space="preserve">
          <source>Using with Relay Classic</source>
          <target state="translated">Relay Classic과 함께 사용</target>
        </trans-unit>
        <trans-unit id="9ea691c61eebccf391fb8820180c4ca2beda5321" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are just standard React components. Here's the &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">뷰 컴포지션은 여러분이 익숙한 &lt;em&gt;그대로입니다.&lt;/em&gt; 릴레이 컨테이너는 표준 React 구성 요소 일뿐입니다. 다음은 &lt;code&gt;&amp;lt;TodoList /&amp;gt;&lt;/code&gt; 구성 요소입니다.</target>
        </trans-unit>
        <trans-unit id="f72b74b27018bdf2391222dafa0211db62f72ce0" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">View 구성은 여러분이 사용하는 &lt;em&gt;것과 정확히 일치&lt;/em&gt; 합니다. 릴레이 컨테이너는 표준 React 구성 요소입니다. &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 구성 요소 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="ff6f9fbff154a814e972c078a22c3cc9628815cf" translate="yes" xml:space="preserve">
          <source>View composition is &lt;em&gt;exactly&lt;/em&gt; what you're used to &amp;mdash; Relay containers are standard React components. Here's the &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; component:</source>
          <target state="translated">View 구성은 여러분이 사용하는 &lt;em&gt;것과 정확히 일치&lt;/em&gt; 합니다. 릴레이 컨테이너는 표준 React 구성 요소입니다. &lt;code&gt;&amp;lt;TodoList&amp;gt;&lt;/code&gt; 컴포넌트 는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1ebbd92b690622c06c90cfb9515becf2b5c48808" translate="yes" xml:space="preserve">
          <source>Warm up</source>
          <target state="translated">워밍업</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="ee4e2bfd72b7c80e3c41f3483341254dd5afffff" translate="yes" xml:space="preserve">
          <source>We built a few scripts to help you with the conversion process. Check them out at &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt;.</source>
          <target state="translated">변환 프로세스에 도움이되는 몇 가지 스크립트를 작성했습니다. &lt;a href=&quot;https://github.com/relayjs/relay-codemod&quot;&gt;https://github.com/relayjs/relay-codemod&lt;/a&gt; 에서 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5940197c590089a53a146cb165e633452c87b60e" translate="yes" xml:space="preserve">
          <source>We can change this behavior by supplying the &lt;code&gt;renderLoading&lt;/code&gt; prop:</source>
          <target state="translated">&lt;code&gt;renderLoading&lt;/code&gt; prop 을 제공하여이 동작을 변경할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="99418ef7bda442472813dd7c77c28063f221dc1b" translate="yes" xml:space="preserve">
          <source>We can create a &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; and define a new type called &lt;code&gt;Setting&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; 을 만들고 &lt;code&gt;Setting&lt;/code&gt; 이라는 새 유형을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="09384c922b7bcbae85b63823d4facb25583f0ebf" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a &lt;code&gt;configs&lt;/code&gt; array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</source>
          <target state="translated">클라이언트 측 저장소를 업데이트하기 위해 각 변형의 응답을 사용하는 방법 에 대한 &lt;code&gt;configs&lt;/code&gt; 배열 의 형태로 Relay 지침을 제공 할 수 있습니다. 다음 구성 유형 중 하나 이상으로 변형을 구성하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="0025d01a256751edcecba66775aa9098e4c29a78" translate="yes" xml:space="preserve">
          <source>We can give Relay instructions in the form of a config array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">각 변이의 응답을 사용하여 클라이언트 측 저장소를 업데이트하는 방법에 대한 구성 배열 형태로 Relay 명령을 제공 할 수 있습니다. 다음 돌연변이 유형 중 하나 이상으로 돌연변이를 구성하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8b225a6bc0d167f8b54e806d442a842dc3c15baa" translate="yes" xml:space="preserve">
          <source>We can then extend existing server types in the client schema &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; with our new &lt;code&gt;Setting&lt;/code&gt; type, like so:</source>
          <target state="translated">그런 다음 다음 과 같이 새로운 &lt;code&gt;Setting&lt;/code&gt; 유형으로 클라이언트 스키마 &lt;code&gt;./src/clientSchema.graphql&lt;/code&gt; 의 기존 서버 유형을 확장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8d988256976c56fbd9f26524c8c8f2411a181121" translate="yes" xml:space="preserve">
          <source>We declare our mutations' data dependencies here, just as we would with a container. This is particularly useful to ensure that a set of fields we might want to use in this mutation's optimistic response have been fetched.</source>
          <target state="translated">컨테이너와 마찬가지로 돌연변이의 데이터 의존성을 여기에 선언합니다. 이것은이 돌연변이의 낙관적 반응에 사용하고자하는 일련의 필드를 가져 오는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7466fdf0dcdc8961e68874158874a25c24afe7b" translate="yes" xml:space="preserve">
          <source>We need a place to hide our treasure, a way to check hiding spots for treasure, and a way to track our turns remaining. For the purposes of this tutorial, we'll hide these data in memory.</source>
          <target state="translated">보물을 숨길 곳, 보물의 숨은 곳을 확인하는 방법, 남은 차례를 추적하는 방법이 필요합니다. 이 튜토리얼의 목적 상 이러한 데이터를 메모리에 숨길 것입니다.</target>
        </trans-unit>
        <trans-unit id="65874d3946f2b63af172cee5a5b310c785e00be9" translate="yes" xml:space="preserve">
          <source>We need to give Relay instructions on how to use the response payload from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following mutation types:</source>
          <target state="translated">클라이언트 측 저장소를 업데이트하기 위해 각 돌연변이의 응답 페이로드를 사용하는 방법에 대한 릴레이 지침을 제공해야합니다. 다음 돌연변이 유형 중 하나 이상으로 돌연변이를 구성하여이를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8cbe01efa489ff5ceee170b9e46b9663c23a0b77" translate="yes" xml:space="preserve">
          <source>We ultimately settled on static methods; components would effectively return a query-tree, separate from the view-tree, describing their data dependencies. Relay could then use this query-tree to fetch all the information needed in a single stage and use it to render the components. The problem was finding an appropriate mechanism to describe the query-tree, and a way to efficiently fetch it from the server (i.e. in a single network request). This is the perfect use-case for GraphQL because it provides a syntax for &lt;em&gt;describing data-dependencies as data&lt;/em&gt;, without dictating any particular API. Note that Promises and Observables are often suggested as alternatives, but they represent &lt;em&gt;opaque commands&lt;/em&gt; and preclude various optimizations such as query batching.</source>
          <target state="translated">우리는 궁극적으로 정적 메소드에 정착했습니다. 구성 요소는 뷰 트리와 별개로 데이터 종속성을 설명하는 쿼리 트리를 효과적으로 반환합니다. 그런 다음 릴레이는이 쿼리 트리를 사용하여 단일 단계에서 필요한 모든 정보를 가져 와서이를 사용하여 구성 요소를 렌더링 할 수 있습니다. 문제는 쿼리 트리를 설명하는 적절한 메커니즘과 서버에서 효율적으로 가져 오는 방법 (예 : 단일 네트워크 요청)을 찾는 것이 었습니다. GraphQL의 완벽한 유스 케이스는 특정 API를 지정하지 않고 &lt;em&gt;데이터 종속성을 data로 설명&lt;/em&gt; 하는 구문을 제공하기 때문 입니다. Promises and Observables는 대체 방법으로 제안되는 경우가 많지만 &lt;em&gt;불투명 한 명령&lt;/em&gt; 을 나타내며 쿼리 일괄 처리와 같은 다양한 최적화를 배제합니다.</target>
        </trans-unit>
        <trans-unit id="69182ca2dfd5971872156968dd68015b5e288405" translate="yes" xml:space="preserve">
          <source>We'll now see different &lt;code&gt;likeCount&lt;/code&gt;s depending on how the story is accessed. A view that uses the first query will see an outdated count, while a view using the second query will see the updated count.</source>
          <target state="translated">이제 스토리에 액세스하는 방법에 따라 다른 &lt;code&gt;likeCount&lt;/code&gt; 가 표시됩니다. 첫 번째 쿼리를 사용하는 뷰에는 오래된 카운트가 표시되고 두 번째 쿼리를 사용하는 뷰에는 업데이트 된 카운트가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4a34c41bd9be871dd6a4b7a07724bb519fe92e77" translate="yes" xml:space="preserve">
          <source>We're almost ready to let Relay fulfill the data requirements for these components and render them. However, there is one problem. In order to actually fetch data with GraphQL, we need a query root. For example, we need to ground the &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; fragment in a concrete node of type &lt;code&gt;User&lt;/code&gt;.</source>
          <target state="translated">우리는 Relay가 이러한 구성 요소에 대한 데이터 요구 사항을 충족하고 렌더링 할 수 있도록 거의 준비가되었습니다. 그러나 한 가지 문제가 있습니다. GraphQL로 데이터를 실제로 가져 오려면 쿼리 루트가 필요합니다. 예를 들어, &lt;code&gt;User&lt;/code&gt; 유형의 콘크리트 노드에서 &lt;code&gt;&amp;lt;Profile&amp;gt;&lt;/code&gt; 단편 을 접지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f379242619731bf12c214370913f902c9dc56b87" translate="yes" xml:space="preserve">
          <source>We've found that it's common for the GraphQL schema to differ slightly or even substantially from the form in which data is stored on disk. Put simply: there isn't always a 1:1 correspondence between data changes in your underlying &lt;em&gt;data storage&lt;/em&gt; (disk) and data changes in your &lt;em&gt;product-visible schema&lt;/em&gt; (GraphQL). The perfect example of this is privacy: returning a user-facing field such as &lt;code&gt;age&lt;/code&gt; might require accessing numerous records in our data-storage layer to determine if the active user is even allowed to &lt;em&gt;see&lt;/em&gt; that &lt;code&gt;age&lt;/code&gt; (Are we friends? Is my age shared? Did I block you? etc.).</source>
          <target state="translated">GraphQL 스키마가 데이터가 디스크에 저장되는 형식과 약간 또는 실질적으로 다른 것이 일반적이라는 것을 알았습니다. 간단히 말해 : 기본 &lt;em&gt;데이터 스토리지&lt;/em&gt; (디스크)의 데이터 변경 사항과 &lt;em&gt;제품 가시적 스키마&lt;/em&gt; (GraphQL)의 데이터 변경 사항이 항상 1 : 1로 일치하는 것은 아닙니다 . 이것의 완벽한 예는 프라이버시입니다. &lt;code&gt;age&lt;/code&gt; 와 같은 사용자 대면 필드를 반환 하려면 데이터 스토리지 계층에서 수많은 레코드에 액세스하여 활성 사용자가 해당 &lt;code&gt;age&lt;/code&gt; 를 &lt;em&gt;볼&lt;/em&gt; 수 있는지 여부를 결정해야합니다 (나의 친구입니까? ? 내가 널 막았 니? 등).</target>
        </trans-unit>
        <trans-unit id="908ef03db4345c18068bb287000ab8108652ad6f" translate="yes" xml:space="preserve">
          <source>We've found that typical approaches to data-fetching &amp;mdash; with imperative APIs &amp;mdash; force developers to deal with too much of this non-essential complexity. For example, consider &lt;em&gt;optimistic UI updates&lt;/em&gt;. This is a way of giving the user feedback while waiting for a server response. The logic of &lt;em&gt;what&lt;/em&gt; to do can be quite clear: when the user clicks &quot;like&quot;, mark the story as being liked and send the request to the server. But the implementation is often much more complex. Imperative approaches require us to implement all of those steps: reach into the UI and toggle the button, initiate a network request, retry it if necessary, show an error if it fails (and untoggle the button), etc. The same goes for data-fetching: specifying &lt;em&gt;what&lt;/em&gt; data we need often dictates &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; it is fetched. Next, we'll explore our approach to solving these concerns with &lt;strong&gt;Relay&lt;/strong&gt;.</source>
          <target state="translated">우리는 명령형 API를 사용한 데이터 페칭에 대한 일반적인 접근 방식으로 인해 개발자가 이러한 비 필수 복잡성을 너무 많이 처리해야합니다. 예를 들어 &lt;em&gt;낙관적 UI 업데이트를&lt;/em&gt; 고려하십시오 . 서버 응답을 기다리는 동안 사용자에게 피드백을 제공하는 방법입니다. 해야 할 &lt;em&gt;일&lt;/em&gt; 의 논리는 매우 명확 할 수 있습니다. 사용자가 &quot;좋아요&quot;를 클릭하면 스토리를 좋아하는 것으로 표시하고 요청을 서버에 보냅니다. 그러나 구현은 종종 훨씬 더 복잡합니다. 명령 방식을 사용하려면 UI에 도달하고 버튼을 토글하고, 네트워크 요청을 시작하고, 필요한 경우 다시 시도하고, 실패하면 오류를 표시하고 (버튼을 토글 해제) 등의 모든 단계를 구현해야합니다. 데이터도 마찬가지입니다. -fetching : 지정 &lt;em&gt;어떤&lt;/em&gt; 데이터가 우리가 흔히 지시 필요&lt;em&gt;&lt;/em&gt;가져 오는 &lt;em&gt;방법&lt;/em&gt; 과 &lt;em&gt;시기&lt;/em&gt; . 다음으로 이러한 관심사를 &lt;strong&gt;Relay&lt;/strong&gt; 로 해결하는 방법을 살펴 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="c57df462a7e454e5b5d9c9c3be330abf92758a69" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in &lt;code&gt;fragments&lt;/code&gt; &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">릴레이 컨테이너 는 구성 요소가 렌더링 &lt;em&gt;되기 전에&lt;/em&gt; GraphQL 조각을 가져 오는 것을 확인했습니다 . 그러나 컨테이너는 또한 즉시 눈에 띄지 않는 또 다른 이점 인 &lt;strong&gt;데이터 마스킹을 제공&lt;/strong&gt; 합니다. 릴레이는 구성 요소가 &lt;code&gt;fragments&lt;/code&gt; 구체적으로 요청하는 데이터에만 액세스 할 수 있도록합니다 . 따라서 한 구성 요소가 Story의 &lt;code&gt;text&lt;/code&gt; 를 작성하고 다른 구성 요소 가 &lt;code&gt;author&lt;/code&gt; 하면 각 구성 요소 는 자신이 요청한 필드 &lt;em&gt;만&lt;/em&gt; 볼 수 있습니다 . 실제로 구성 요소는 &lt;em&gt;자식이&lt;/em&gt; 요청한 데이터를 볼 수도 없습니다 . 캡슐화가 깨질 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1d701dcb15b88a66be26dfbe21cdfc47c48bde8" translate="yes" xml:space="preserve">
          <source>We've seen that Relay containers ensure that GraphQL fragments are fetched &lt;em&gt;before&lt;/em&gt; the component is rendered. But containers also provide another benefit that isn't immediately obvious: &lt;strong&gt;data masking&lt;/strong&gt;. Relay only allows components to access data they specifically ask for in GraphQL fragments &amp;mdash; nothing more. So if one component queries for a Story's &lt;code&gt;text&lt;/code&gt;, and another for its &lt;code&gt;author&lt;/code&gt;, each can see &lt;em&gt;only&lt;/em&gt; the field that they asked for. In fact, components can't even see the data requested by their &lt;em&gt;children&lt;/em&gt;: that would also break encapsulation.</source>
          <target state="translated">릴레이 컨테이너 는 구성 요소가 렌더링 &lt;em&gt;되기 전에&lt;/em&gt; GraphQL 조각을 가져 오는 것을 확인했습니다 . 그러나 컨테이너는 &lt;strong&gt;데이터 마스킹&lt;/strong&gt; 이라는 또 다른 이점도 제공합니다 . Relay는 구성 요소가 GraphQL 조각에서 특별히 요청한 데이터에만 액세스 할 수 있도록 허용합니다. 따라서 한 구성 요소가 Story의 &lt;code&gt;text&lt;/code&gt; 쿼리 하고 다른 구성 요소 는 &lt;code&gt;author&lt;/code&gt; 쿼리하는 경우 각 구성 요소 는 요청한 필드 &lt;em&gt;만&lt;/em&gt; 볼 수 있습니다 . 사실, 구성 요소는 &lt;em&gt;자식이&lt;/em&gt; 요청한 데이터도 볼 수 없습니다.이 경우 캡슐화도 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="deaef06798309bf42fff99bdd598051728c38f5a" translate="yes" xml:space="preserve">
          <source>What we have written here is a mock database interface. We can imagine hooking this up to a real database, but for now let's move on.</source>
          <target state="translated">우리가 작성한 것은 모의 데이터베이스 인터페이스입니다. 이것을 실제 데이터베이스에 연결하는 것을 상상할 수 있지만 지금은 계속 진행하겠습니다.</target>
        </trans-unit>
        <trans-unit id="73a39c3a3d88bd8125f710502d024ae93180062d" translate="yes" xml:space="preserve">
          <source>What works with what? Relay Compat (&lt;code&gt;'react-relay/compat'&lt;/code&gt;) is the most flexible. Compat components and mutations can be used by everything. Compat components can also have any kind of children.</source>
          <target state="translated">무엇과 함께 작동합니까? 릴레이 컴 패트 ( &lt;code&gt;'react-relay/compat'&lt;/code&gt; )가 가장 유연합니다. Compat 구성 요소 및 돌연변이는 모든 것이 사용할 수 있습니다. Compat 구성 요소에는 모든 종류의 자식이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a097138ac94d8bfbf69d6920577e2b751982a49" translate="yes" xml:space="preserve">
          <source>When &quot;force fetching&quot;, this is true if &lt;code&gt;ready&lt;/code&gt; is true as a result of data being available on the client before the server request has completed.</source>
          <target state="translated">&quot;강제 반입&quot;인 경우 서버 요청이 완료되기 전에 클라이언트에서 데이터를 사용할 수있어 &lt;code&gt;ready&lt;/code&gt; 가 완료된 경우 에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="ec3ad126a1399587ee94fd174e76b0fbd442a34b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true and &lt;code&gt;renderFetched&lt;/code&gt; is called as a result of available client data, &lt;code&gt;renderFetched&lt;/code&gt; is called with a second argument that has a &lt;code&gt;stale&lt;/code&gt; boolean property. The &lt;code&gt;stale&lt;/code&gt; property is true if &lt;code&gt;renderFetched&lt;/code&gt; is called before the forced server request completes.</source>
          <target state="translated">때 &lt;code&gt;forceFetch&lt;/code&gt; 가 사실이고 &lt;code&gt;renderFetched&lt;/code&gt; 가 가능한 클라이언트 데이터의 결과라고, &lt;code&gt;renderFetched&lt;/code&gt; 는 있는 두 번째 인수로 호출 &lt;code&gt;stale&lt;/code&gt; 부울 속성을. &lt;code&gt;stale&lt;/code&gt; 경우 속성은 true입니다 &lt;code&gt;renderFetched&lt;/code&gt; 가 강제 서버 요청이 완료되기 전에 호출된다.</target>
        </trans-unit>
        <trans-unit id="eb41ea6dee1bf1db385774c4f83f62a51389acc5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;forceFetch&lt;/code&gt; is true, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will always send a request to the server. However, if all the data required to render is also available on the client, &lt;code&gt;renderFetched&lt;/code&gt; may still be called before the server request completes.</source>
          <target state="translated">때 &lt;code&gt;forceFetch&lt;/code&gt; 는 사실, &lt;strong&gt;Relay.RootContainer는&lt;/strong&gt; 항상 서버에 요청을 보낼 것입니다. 그러나 렌더링에 필요한 모든 데이터를 클라이언트에서도 사용할 수 &lt;code&gt;renderFetched&lt;/code&gt; 서버 요청이 완료되기 전에 여전히 renderFetched 가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e40c2b8419bc5119b554a06ad55e52a926e319f" translate="yes" xml:space="preserve">
          <source>When Relay fulfills data, the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback is called one or more times with an object that describes the current &quot;ready state&quot;. This object has the following properties:</source>
          <target state="translated">Relay가 데이터를 충족 하면 현재 &quot;준비 상태&quot;를 설명하는 객체를 사용 하여 &lt;code&gt;onReadyStateChange&lt;/code&gt; 콜백이 한 번 이상 호출됩니다. 이 객체에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="32bb09505d79ce543a4f26cb9022780cf39a8205" translate="yes" xml:space="preserve">
          <source>When all data necessary to render becomes available, &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; will render the supplied &lt;code&gt;Component&lt;/code&gt; by default. However, we can change this behavior by supplying a callback to the &lt;code&gt;renderFetched&lt;/code&gt; prop:</source>
          <target state="translated">렌더링에 필요한 모든 데이터를 사용할 수있게되면 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 는 기본적으로 제공된 &lt;code&gt;Component&lt;/code&gt; 를 렌더링합니다 . 그러나 &lt;code&gt;renderFetched&lt;/code&gt; prop에 콜백을 제공하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8c530641aad6dea0ce0a725ecb86984b969f2e6" translate="yes" xml:space="preserve">
          <source>When all data requirements are fulfilled, &lt;code&gt;renderFetched&lt;/code&gt; is called to render the view. This callback is expected to spread &lt;code&gt;data&lt;/code&gt; into the supplied &lt;code&gt;Container&lt;/code&gt; when rendering it.</source>
          <target state="translated">모든 데이터 요구 사항이 충족되면 &lt;code&gt;renderFetched&lt;/code&gt; 가 호출되어 뷰를 렌더링합니다. 이 콜백은 &lt;code&gt;data&lt;/code&gt; 를 렌더링 할 때 제공된 &lt;code&gt;Container&lt;/code&gt; 로 데이터 를 분산시킬 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="f5e881d6a25c5fe2f25b897803df81640312440a" translate="yes" xml:space="preserve">
          <source>When compiling code for production deployment, the plugin can be configured to immediately throw upon encountering a validation problem. The plugin can be further customized for different environments with the following options:</source>
          <target state="translated">프로덕션 배포를위한 코드를 컴파일 할 때 유효성 검사 문제가 발생하면 즉시 플러그인이 구성되도록 할 수 있습니다. 다음 옵션을 사용하여 다양한 환경에 맞게 플러그인을 추가로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fef005c4b23cdf975a02dadd67a2264bb2944197" translate="yes" xml:space="preserve">
          <source>When data requirements failed to be fulfilled, &lt;code&gt;renderFailure&lt;/code&gt; is called to render the view.</source>
          <target state="translated">데이터 요구 사항이 충족되지 않으면 뷰를 렌더링하기 위해 &lt;code&gt;renderFailure&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6cbba9204bbe45970c08910fca16574ce8a0cc" translate="yes" xml:space="preserve">
          <source>When data requirements have yet to be fulfilled, &lt;code&gt;renderLoading&lt;/code&gt; is called to render the view. If this returns &lt;code&gt;undefined&lt;/code&gt;, the previously rendered view (or nothing if there is no previous view) is rendered.</source>
          <target state="translated">데이터 요구 사항이 아직 충족되지 않은 경우 뷰를 렌더링하기 위해 &lt;code&gt;renderLoading&lt;/code&gt; 이 호출됩니다. 이것이 &lt;code&gt;undefined&lt;/code&gt; 를 반환 하면 이전에 렌더링 된 뷰 (또는 이전 뷰가없는 경우 아무것도)가 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd4594d265309e3ea2f8851c4e096213978657c" translate="yes" xml:space="preserve">
          <source>When defining a fragment for use with a Fragment container, you can use the &lt;code&gt;@relay(plural: true)&lt;/code&gt; directive to indicate that container expects the prop for that fragment to be a list of items instead of a single item. A query or parent that spreads a &lt;code&gt;@relay(plural: true)&lt;/code&gt; fragment should do so within a plural field (ie a field backed by a &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL list&lt;/a&gt;. For example:</source>
          <target state="translated">Fragment 컨테이너와 함께 사용할 조각을 정의 할 때 &lt;code&gt;@relay(plural: true)&lt;/code&gt; 지시문을 사용하여 컨테이너가 해당 조각의 prop이 단일 항목이 아닌 항목 목록이 될 것으로 예상 함을 나타낼 수 있습니다. &lt;code&gt;@relay(plural: true)&lt;/code&gt; 조각 을 확산하는 쿼리 또는 부모 는 복수 필드 ( 예 : &lt;a href=&quot;http://graphql.org/learn/schema/#lists-and-non-null&quot;&gt;GraphQL 목록에&lt;/a&gt; 의해 지원되는 필드) 내에서이를 수행해야 합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="619aba17233daa1e1d7ee5e3869b79e1331126b3" translate="yes" xml:space="preserve">
          <source>When defining a fragment, you can use the &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt;&lt;code&gt;@argumentDefinitions&lt;/code&gt;&lt;/a&gt; directive to specify any arguments, with potentially default values, that the fragment expects.</source>
          <target state="translated">프래그먼트를 정의 할 때 &lt;a href=&quot;graphql-in-relay#argumentdefinitions&quot;&gt; &lt;code&gt;@argumentDefinitions&lt;/code&gt; &lt;/a&gt; 지시문을 사용하여 프래그먼트가 예상하는 잠재적 인 기본값과 함께 인수를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48fe499e8a7f1e23dc6dcd982b4f071176b969ff" translate="yes" xml:space="preserve">
          <source>When designing a fat query, consider &lt;em&gt;all&lt;/em&gt; of the data that might change as a result of the mutation &amp;ndash; not just the data currently in use by your application. We don't need to worry about overfetching; this query is never executed without first intersecting it with a &amp;lsquo;tracked query&amp;rsquo; of the data our application actually needs. If we omit fields in the fat query, we might observe data inconsistencies in the future when we add views with new data dependencies, or add new data dependencies to existing views.</source>
          <target state="translated">뚱뚱한 쿼리를 디자인 할 때는 현재 응용 프로그램에서 사용중인 데이터뿐만 아니라 돌연변이로 인해 변경 될 수있는 &lt;em&gt;모든&lt;/em&gt; 데이터를 고려 하십시오. 오버 페칭에 대해 걱정할 필요가 없습니다. 이 쿼리는 애플리케이션에 실제로 필요한 데이터의 '추적 쿼리'와 먼저 교차하지 않고 실행되지 않습니다. 팻 쿼리에서 필드를 생략하면 향후 새로운 데이터 종속성이있는 뷰를 추가하거나 기존 뷰에 새로운 데이터 종속성을 추가 할 때 데이터 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d515b89284c6ce31950922a449ba18618a553f6" translate="yes" xml:space="preserve">
          <source>When incrementally converting a Relay Classic app to Relay Modern, &lt;code&gt;graphql&lt;/code&gt; literals can be translated to be usable by &lt;em&gt;both&lt;/em&gt; runtimes if configured to use compatibility mode:</source>
          <target state="translated">Relay Classic 앱을 Relay Modern으로 증분 변환 할 때 호환 모드를 사용하도록 구성된 경우 &lt;code&gt;graphql&lt;/code&gt; 리터럴을 &lt;em&gt;두&lt;/em&gt; 런타임 에서 &lt;em&gt;모두&lt;/em&gt; 사용할 수 있도록 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="902c49b06415e9d418fef8488cdcaad88a9be3b5" translate="yes" xml:space="preserve">
          <source>When it sends queries, it will automatically fail requests after a 15 second timeout. Also, failed requests are automatically retried twice, with a 1 second delay and a 3 second delay, respectively.</source>
          <target state="translated">쿼리를 보내면 15 초 시간 초과 후 자동으로 요청이 실패합니다. 또한 실패한 요청은 각각 1 초 지연과 3 초 지연으로 자동으로 두 번 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="c328250268c48757d266a5578f320e2cd118ae4e" translate="yes" xml:space="preserve">
          <source>When not nesting routes with Relay data dependencies, such as when using flat routes, it is sufficient to just render a &lt;code&gt;QueryRenderer&lt;/code&gt; for the parts of your application that require Relay data. You can also use the options below that integrate your routes with their data dependencies.</source>
          <target state="translated">플랫 라우트를 사용할 때와 같이 릴레이 데이터 종속성이있는 라우트를 중첩하지 않는 경우 릴레이 데이터가 필요한 애플리케이션 부분에 대해 &lt;code&gt;QueryRenderer&lt;/code&gt; 를 렌더링하는 것으로 충분합니다 . 아래의 옵션을 사용하여 경로를 데이터 종속성과 통합 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c958feb46013f0ddcda8fd3772356651d46f8e8a" translate="yes" xml:space="preserve">
          <source>When problems arise developers would need an insight into Relay's store. Relay provides a couple of tools to inspect the store and its records programmatically and visually.</source>
          <target state="translated">문제가 발생하면 개발자는 Relay의 상점에 대한 통찰력이 필요합니다. Relay는 상점 및 해당 레코드를 프로그래밍 방식 및 시각적으로 검사 할 수있는 몇 가지 도구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5d9ce00224dd61a4d32a2854970285a45cfbec29" translate="yes" xml:space="preserve">
          <source>When the &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; above is rendered, Relay will construct a query and send it to the GraphQL server. As soon as all required data has been fetched, &lt;code&gt;ProfilePicture&lt;/code&gt; will be rendered. Props with fragments will contain data that was fetched from the server.</source>
          <target state="translated">위 의 &lt;strong&gt;Relay.RootContainer&lt;/strong&gt; 가 렌더링되면 Relay는 쿼리를 생성하여 GraphQL 서버로 보냅니다. 필요한 모든 데이터를 가져 오면 &lt;code&gt;ProfilePicture&lt;/code&gt; 가 렌더링됩니다. 조각이있는 소품에는 서버에서 가져온 데이터가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c67a5c120de0df00997c004e146051bbad946df1" translate="yes" xml:space="preserve">
          <source>When the server response is received, one of the callbacks is invoked:</source>
          <target state="translated">서버 응답이 수신되면 콜백 중 하나가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="cea8475e3aa555845df5b9bb69835f08e0fe8ca8" translate="yes" xml:space="preserve">
          <source>When the transaction is committed and the response is received from the server, one of the callbacks is invoked: - &lt;code&gt;onSuccess&lt;/code&gt; is called if the mutation succeeded. - &lt;code&gt;onFailure&lt;/code&gt; is called if the mutation failed.</source>
          <target state="translated">트랜잭션이 커밋되고 서버에서 응답이 수신되면 콜백 중 하나가 호출됩니다.- 돌연변이가 성공하면 &lt;code&gt;onSuccess&lt;/code&gt; 가 호출됩니다. - 돌연변이가 실패하면 &lt;code&gt;onFailure&lt;/code&gt; 가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="15eef2fb6be75cc68d0e3ddb99ea3d827fbcd3d5" translate="yes" xml:space="preserve">
          <source>When this response is normalized, Relay can detect that this result overlaps with existing data based on its &lt;code&gt;id&lt;/code&gt;. Rather than create a new record, Relay will update the existing &lt;code&gt;123&lt;/code&gt; record. The new &lt;code&gt;likeCount&lt;/code&gt; is therefore available to &lt;em&gt;both&lt;/em&gt; queries, as well as any other query that might reference this story.</source>
          <target state="translated">이 응답이 정규화되면 Relay는이 결과가 &lt;code&gt;id&lt;/code&gt; 를 기반으로 기존 데이터와 겹치는 것을 감지 할 수 있습니다 . Relay는 새 레코드를 작성하지 않고 기존 &lt;code&gt;123&lt;/code&gt; 레코드를 업데이트합니다 . 새로운 &lt;code&gt;likeCount&lt;/code&gt; 는 하는 것이 가능하다 &lt;em&gt;모두&lt;/em&gt; 쿼리뿐만 아니라이 이야기를 참조 할 수있는 다른 쿼리.</target>
        </trans-unit>
        <trans-unit id="30790e3c432f6503a40e8e00ea839d4b3685867b" translate="yes" xml:space="preserve">
          <source>When upgrading an existing Relay app, replace all &lt;code&gt;require('react-relay')&lt;/code&gt; with &lt;code&gt;require('react-relay/classic')&lt;/code&gt; to continue to import the Relay Classic API.</source>
          <target state="translated">기존 Relay 앱을 업그레이드 할 때 Relay Classic API를 계속 가져 오려면 모든 &lt;code&gt;require('react-relay')&lt;/code&gt; 를 &lt;code&gt;require('react-relay/classic')&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="880864fa4e14c5e5caab7b10626e640aee6def2a" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;query-renderer&quot;&gt;&lt;code&gt;QueryRenderer&lt;/code&gt;&lt;/a&gt;, the restrictions on queries from Relay Classic are removed: queries may contain multiple root fields that use arbitrary arguments and return singular or plural values. The &lt;code&gt;viewer&lt;/code&gt; root field is now optional.</source>
          <target state="translated">&lt;a href=&quot;query-renderer&quot;&gt; &lt;code&gt;QueryRenderer&lt;/code&gt; 를&lt;/a&gt; 사용하면 Relay Classic의 쿼리에 대한 제한이 제거됩니다. 쿼리는 임의의 인수를 사용하고 단일 또는 복수 값을 반환하는 여러 루트 필드를 포함 할 수 있습니다. &lt;code&gt;viewer&lt;/code&gt; 루트 필드는 이제 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="eec48adcf595a6ca86caad379b181d97a2f010ca" translate="yes" xml:space="preserve">
          <source>When using the &lt;a href=&quot;pagination-container&quot;&gt;Pagination Container&lt;/a&gt;, Relay expects connection fields to be annotated with a &lt;code&gt;@connection&lt;/code&gt; directive. For more detailed information and an example, check out the &lt;a href=&quot;pagination-container#connection&quot;&gt;docs on using &lt;code&gt;@connection&lt;/code&gt; inside a Pagination Container&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;pagination-container&quot;&gt;페이지 매김 컨테이너를&lt;/a&gt; 사용할 때 Relay는 연결 필드가 &lt;code&gt;@connection&lt;/code&gt; 지시문 으로 주석 처리 될 것으로 예상합니다 . 자세한 정보와 예제 &lt;a href=&quot;pagination-container#connection&quot;&gt;는 Pagination Container 내부에서 &lt;/a&gt; &lt;code&gt;@connection&lt;/code&gt; 사용에 대한 문서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="bdabb7b5c56a4bc287f21143e07d2eb721a2af6c" translate="yes" xml:space="preserve">
          <source>When you provide these functions, this is roughly what happens during the mutation request:</source>
          <target state="translated">이러한 함수를 제공하면 대략적으로 변형 요청 중에 발생합니다.</target>
        </trans-unit>
        <trans-unit id="384e273feee00773d8ac2cb8c10110ccc823425a" translate="yes" xml:space="preserve">
          <source>Whenever Relay is fulfilling data requirements, it can be useful to know when certain events occur. For example, we might want to record how long it takes for data to be available, or we might want to log errors to the server. These events are available on most Relay APIs via the &lt;code&gt;onReadyStateChange&lt;/code&gt; callback.</source>
          <target state="translated">Relay가 데이터 요구 사항을 충족 할 때마다 특정 이벤트가 발생하는시기를 아는 것이 유용 할 수 있습니다. 예를 들어, 데이터를 사용할 수있는 시간을 기록하거나 서버에 오류를 기록 할 수 있습니다. 이러한 이벤트는 &lt;code&gt;onReadyStateChange&lt;/code&gt; 콜백을 통해 대부분의 Relay API에서 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8cd144d9041c40f96f66e2aa651ea3465a4503f" translate="yes" xml:space="preserve">
          <source>Wherever the inverse grammar serves you better, you can use &lt;code&gt;@skip(if: ...)&lt;/code&gt; instead of &lt;code&gt;@include(if: ...)&lt;/code&gt;.</source>
          <target state="translated">역 문법이 더 나은 곳 &lt;code&gt;@skip(if: ...)&lt;/code&gt; &lt;code&gt;@include(if: ...)&lt;/code&gt; 대신 @skip (if : ...)을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2f3e2838c0630aa2c4914a0c2d4e6ea23e0c95ac" translate="yes" xml:space="preserve">
          <source>Whether the request was aborted.</source>
          <target state="translated">요청이 중단되었는지 여부</target>
        </trans-unit>
        <trans-unit id="422efd22184fb3e6c495b98266ee159c3842165d" translate="yes" xml:space="preserve">
          <source>While typically Relay only provides the data for fields explicitly requested by a component's fragment, &lt;code&gt;@relay(mask: false)&lt;/code&gt; can be added to a fragment spread to not mask that data, recursively including the data from the fields of the referenced fragment.</source>
          <target state="translated">일반적으로 릴레이는 구성 요소의 조각에서 명시 적으로 요청한 필드에 대한 데이터 만 제공하지만 참조 조각의 필드의 데이터를 재귀 적으로 포함하여 &lt;code&gt;@relay(mask: false)&lt;/code&gt; 를 조각 스프레드에 추가하여 해당 데이터를 마스크하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff506c81a21b554c2790ef2e5a963a42aff57850" translate="yes" xml:space="preserve">
          <source>While you type queries as follows:</source>
          <target state="translated">다음과 같이 쿼리를 입력하는 동안 :</target>
        </trans-unit>
        <trans-unit id="0b57cc238bcb966947c54d303e25a36f527aba7b" translate="yes" xml:space="preserve">
          <source>While you type queries as:</source>
          <target state="translated">쿼리를 다음과 같이 입력하는 동안 :</target>
        </trans-unit>
        <trans-unit id="223f6c68b8dfddbadc2aa76589625320726b0252" translate="yes" xml:space="preserve">
          <source>Will cause a generated file to appear in &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt;, with both runtime artifacts (which help to read and write from the Relay Store) and &lt;a href=&quot;https://flow.org/&quot;&gt;Flow types&lt;/a&gt; to help you write type-safe code.</source>
          <target state="translated">생성 된 파일이 &lt;code&gt;./__generated__/MyComponent.graphql&lt;/code&gt; 에 나타나 도록 합니다. 런타임 아티팩트 (중계 저장소에서 읽고 쓰는 데 도움이 됨)와 형식 안전 코드를 작성하는 데 도움이되는 &lt;a href=&quot;https://flow.org/&quot;&gt;흐름 유형이 모두 포함&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="8d32def387eb6db627a1048487211194f68d2887" translate="yes" xml:space="preserve">
          <source>With GraphQL it is very common for the results of multiple queries to overlap. However, our response cache from the previous section doesn't account for this overlap &amp;mdash; it caches based on distinct queries. For example, if we issue a query to fetch stories:</source>
          <target state="translated">GraphQL을 사용하면 여러 쿼리 결과가 겹치는 것이 매우 일반적입니다. 그러나 이전 섹션의 응답 캐시는 이러한 오버랩을 설명하지 않으며 별도의 쿼리를 기반으로 캐시합니다. 예를 들어 스토리를 가져 오기 위해 쿼리를 발행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="326b4ac13e70484638c8e2c275bb7155ff73eafd" translate="yes" xml:space="preserve">
          <source>With a normalized response cache, a record would be created for each story in the list. The &lt;code&gt;stories&lt;/code&gt; field would store links to each of these records.</source>
          <target state="translated">표준화 된 응답 캐시를 사용하면 목록의 각 스토리에 대한 레코드가 작성됩니다. &lt;code&gt;stories&lt;/code&gt; 필드는 다음 각 레코드에 대한 링크를 저장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9443a9eb3d5ff45b05255468c9ca88197b385e42" translate="yes" xml:space="preserve">
          <source>With some additional configuration, the &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel plugin can also translate Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; literals. Most importantly, include a reference to your GraphQL Schema as either a json file or graphql schema file.</source>
          <target state="translated">일부 추가 구성을 통해 &lt;code&gt;&quot;relay&quot;&lt;/code&gt; babel 플러그인은 Relay Classic &lt;code&gt;Relay.QL&lt;/code&gt; 리터럴을 번역 할 수도 있습니다 . 가장 중요한 것은 GraphQL 스키마에 대한 참조를 json 파일 또는 graphql 스키마 파일로 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4fdf6745c6472ea632228aac1bf14006ef03d88" translate="yes" xml:space="preserve">
          <source>With the queries out of the way, let's start in on our only mutation: the one that spends a turn by checking a spot for treasure. Here, we define the input to the mutation (the id of a spot to check for treasure) and a list of all of the possible fields that the client might want updates about after the mutation has taken place. Finally, we implement a method that performs the underlying mutation.</source>
          <target state="translated">쿼리가 중단되면 우리의 유일한 돌연변이, 즉 보물의 자리를 확인하여 차례를 보내는 돌연변이에서 시작합시다. 여기, 우리는 돌연변이에 대한 입력 (보물을 확인하기위한 스팟의 id)과 돌연변이가 발생한 후 클라이언트가 업데이트를 원할 수있는 모든 가능한 필드의 목록을 정의합니다. 마지막으로, 우리는 기본 돌연변이를 수행하는 방법을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7ddd9cfe22f7c960a4c67535583b19ffb8497a42" translate="yes" xml:space="preserve">
          <source>With this input and payload, we can issue the following mutation:</source>
          <target state="translated">이 입력과 페이로드를 사용하면 다음과 같은 돌연변이를 일으킬 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dce3644542cd9fbd082b44d7cadd316ad1975d62" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">데이터 가져 오기에 대한 일반적인 접근 방식을 통해 두 구성 요소가 &lt;em&gt;암시 적 종속성&lt;/em&gt; 을 갖는 것이 일반적이라는 사실을 발견했습니다 . 예를 들어 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; 는 데이터를 가져 왔는지 직접 확인하지 않고 일부 데이터를 사용할 수 있습니다. 이 데이터는 종종 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; 와 같은 시스템의 다른 부분에서 가져옵니다 . 그런 다음 &lt;code&gt;&amp;lt;Story /&amp;gt;&lt;/code&gt; 를 변경 하고 해당 데이터 가져 오기 논리를 제거하면 &lt;code&gt;&amp;lt;StoryHeader /&amp;gt;&lt;/code&gt; 가 갑자기 설명 할 수 없을 정도로 중단됩니다. 이러한 유형의 버그는 특히 대규모 팀에서 개발 한 대규모 응용 프로그램에서 항상 즉시 드러나는 것은 아닙니다. 수동 및 자동 테스트는 많은 도움이 될 수 있습니다. 이것은 정확히 프레임 워크에 의해 더 잘 해결되는 유형의 체계적인 문제입니다.</target>
        </trans-unit>
        <trans-unit id="9e36e32aeb9398daa0c7117970d61b1237b724a3" translate="yes" xml:space="preserve">
          <source>With typical approaches to data-fetching we found that it was common for two components to have &lt;em&gt;implicit dependencies&lt;/em&gt;. For example &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; might use some data without directly ensuring that the data was fetched. This data would often be fetched by some other part of the system, such as &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt;. Then when we changed &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; and removed that data-fetching logic, &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; would suddenly and inexplicably break. These types of bugs are not always immediately apparent, especially in larger applications developed by larger teams. Manual and automated testing can only help so much: this is exactly the type of systematic problem that is better solved by a framework.</source>
          <target state="translated">데이터 가져 오기에 대한 일반적인 접근 방식을 통해 두 구성 요소가 &lt;em&gt;암시 적 종속성&lt;/em&gt; 을 갖는 것이 일반적이라는 것을 알았습니다 . 예를 들어 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 는 데이터를 가져 왔는지 직접 확인하지 않고 일부 데이터를 사용할 수 있습니다. 이 데이터는 종종 시스템의 다른 부분 (예 : &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; )에서 가져옵니다 . 그런 다음 &lt;code&gt;&amp;lt;Story&amp;gt;&lt;/code&gt; 를 변경 하고 해당 데이터 가져 오기 로직을 ​​제거하면 &lt;code&gt;&amp;lt;StoryHeader&amp;gt;&lt;/code&gt; 가 갑자기 그리고 예기치 않게 중단됩니다. 이러한 유형의 버그는 특히 대규모 팀에서 개발 한 대규모 응용 프로그램에서 항상 즉각적인 것은 아닙니다. 수동 및 자동 테스트는 많은 도움이 될 수 있습니다. 이는 프레임 워크로 더 잘 해결되는 시스템 문제의 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d7a484140f5f9f7f5427e1f2c44dbfc1d3ad9eea" translate="yes" xml:space="preserve">
          <source>Workflow</source>
          <target state="translated">Workflow</target>
        </trans-unit>
        <trans-unit id="5c338a274513fe1f278459839f0c78f7e6b91728" translate="yes" xml:space="preserve">
          <source>Writing the game</source>
          <target state="translated">게임 작성</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="1696149c59259541ba3a1d3a3c3c107fc68c94e9" translate="yes" xml:space="preserve">
          <source>Yes*</source>
          <target state="translated">Yes*</target>
        </trans-unit>
        <trans-unit id="d38ce88b105c03a9bcdfa9b0ae57cef87a38afbe" translate="yes" xml:space="preserve">
          <source>You can also pass variables to the mutation's fragment builder from the outer fragment that contains it.</source>
          <target state="translated">또한 돌연변이를 포함하는 외부 단편에서 변수를 돌연변이의 단편 빌더로 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a3a0a2cf926b5e31314761fde4d2b924ad01e95" translate="yes" xml:space="preserve">
          <source>You can conditionally include or skip a field based on the value of a boolean variable.</source>
          <target state="translated">부울 변수의 값을 기준으로 조건부로 필드를 포함하거나 건너 뛸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e39e4e019fcddf87d5963ed450c0a585f3ac5a5c" translate="yes" xml:space="preserve">
          <source>You can read more about &lt;code&gt;InteractionManager&lt;/code&gt; on the &lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API docs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://facebook.github.io/react-native/docs/interactionmanager.html&quot;&gt;React Native API 문서&lt;/a&gt; 에서 &lt;code&gt;InteractionManager&lt;/code&gt; 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1db4f1b561c182f757185de947874831706c7c3d" translate="yes" xml:space="preserve">
          <source>You can read more about the API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; interface.</source>
          <target state="translated">API &lt;a href=&quot;interfaces-relay-network-layer&quot;&gt;RelayNetworkLayer&lt;/a&gt; 인터페이스 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3732e8bd7b74351797baa672d29727cc8e4b2f3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;fetchQuery&lt;/code&gt; function to imperatively make GraphQL Requests. This is useful for cases where you want to make requests outside of React but still utilize the Relay store and network layer.</source>
          <target state="translated">&lt;code&gt;fetchQuery&lt;/code&gt; 함수를 사용하여 GraphQL 요청을 명령 적으로 만들 수 있습니다 . 이는 React 외부에서 요청을하지만 여전히 Relay 저장소와 네트워크 계층을 활용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="42ec8ab0bbfcf6ce2aa1efbd2295912061dec672" translate="yes" xml:space="preserve">
          <source>You don't have to mimic the entire response payload. Here, we've punted on the like sentence, since it's difficult to localize on the client side. When the server responds, Relay will treat its payload as the source of truth, but in the meantime, the optimistic response will be applied right away, allowing the people who use our product to enjoy instant feedback after having taken an action.</source>
          <target state="translated">전체 응답 페이로드를 모방 할 필요는 없습니다. 여기서는 클라이언트 쪽에서 현지화하기가 어렵 기 때문에 이와 비슷한 문장을 사용했습니다. 서버가 응답하면 Relay는 페이로드를 진실의 원천으로 취급하지만 그 동안 낙관적 응답이 즉시 적용되어 제품을 사용하는 사람들이 조치를 취한 후 즉각적인 피드백을 즐길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db948a53ed55bdbbd4fa17526586780dad70f601" translate="yes" xml:space="preserve">
          <source>You have to implement your own cache strategy. A simple solution is to use &lt;code&gt;QueryResponseCache&lt;/code&gt; (an in-memory cache):</source>
          <target state="translated">자신 만의 캐시 전략을 구현해야합니다. 간단한 해결책은 &lt;code&gt;QueryResponseCache&lt;/code&gt; (인 메모리 캐시) 를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1ae915d1a8b7fa12f92488b10423d30b2ad84e5" translate="yes" xml:space="preserve">
          <source>You will need to Configure your &lt;a href=&quot;networklayer&quot;&gt;Network&lt;/a&gt; to handle subscriptions. The below example uses &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws&lt;/a&gt;:</source>
          <target state="translated">구독을 처리하려면 &lt;a href=&quot;networklayer&quot;&gt;네트워크&lt;/a&gt; 를 구성해야합니다 . 아래 예제는 &lt;a href=&quot;https://github.com/apollographql/subscriptions-transport-ws&quot;&gt;subscriptions-transport-ws를 사용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13eb998680ecc627ba04d1e2c348b212888c8f5b" translate="yes" xml:space="preserve">
          <source>[1] Note that GraphQL itself does not impose this constraint, and Relay Runtime may also be used for schemas that do not conform to it. For example, both systems can be used to query a single denormalized table. However, many of the features that Relay Runtime provides, such as caching and normalization, work best when the data is represented as a normalized graph with stable identities for discrete pieces of information.</source>
          <target state="translated">[1] GraphQL 자체는이 제약을 부과하지 않으며 릴레이 런타임은이를 준수하지 않는 스키마에도 사용할 수 있습니다. 예를 들어 두 시스템 모두 비정규 화 된 단일 테이블을 쿼리하는 데 사용할 수 있습니다. 그러나 캐싱 및 정규화와 같이 Relay Runtime이 제공하는 많은 기능은 데이터가 개별 정보 조각에 대해 안정적인 ID가있는 정규화 된 그래프로 표시 될 때 가장 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7dd3288de30464c56940d838b494bb246d25a587" translate="yes" xml:space="preserve">
          <source>an edge representing the new friend will be added to the viewer's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">새 친구를 나타내는 가장자리가 뷰어의 &lt;code&gt;friends&lt;/code&gt; 연결에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="33f0663df214f396a65e31c63ea1758c4a24ba18" translate="yes" xml:space="preserve">
          <source>an edge representing the viewer will be added to the new friend's &lt;code&gt;friends&lt;/code&gt; connection</source>
          <target state="translated">뷰어를 나타내는 가장자리가 새로운 친구의 &lt;code&gt;friends&lt;/code&gt; 연결에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6a5703deebcf0535c19b19c1b0a27e8341e2ab4d" translate="yes" xml:space="preserve">
          <source>and then later refetch one of the stories whose &lt;code&gt;likeCount&lt;/code&gt; has since been incremented:</source>
          <target state="translated">그런 다음 &lt;code&gt;likeCount&lt;/code&gt; 가 증가한 스토리 중 하나를 다시 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="6abe6d9392071037cb6a695b9da8b68f203db531" translate="yes" xml:space="preserve">
          <source>and we get back</source>
          <target state="translated">우리는 돌아온다</target>
        </trans-unit>
        <trans-unit id="b74745ac136841f9501637f3fac7d913abeecf5d" translate="yes" xml:space="preserve">
          <source>and we'll get this result:</source>
          <target state="translated">그리고 우리는이 결과를 얻을 것입니다 :</target>
        </trans-unit>
        <trans-unit id="f30392ad1d35a35355bcc5ff5b7ab1c4aa4b6b4d" translate="yes" xml:space="preserve">
          <source>applyOptimistic</source>
          <target state="translated">applyOptimistic</target>
        </trans-unit>
        <trans-unit id="481baa434ed8570c01e3d78b4a058c1cea4ffea5" translate="yes" xml:space="preserve">
          <source>applyUpdate (static method)</source>
          <target state="translated">applyUpdate (정적 방법)</target>
        </trans-unit>
        <trans-unit id="e0d9b66d001ce91f916cb04de6514301d4191e1e" translate="yes" xml:space="preserve">
          <source>babel-plugin-relay</source>
          <target state="translated">babel-plugin-relay</target>
        </trans-unit>
        <trans-unit id="804dd7a640e28824ae34b133455831c85cafaa66" translate="yes" xml:space="preserve">
          <source>both people's friend count will increment</source>
          <target state="translated">두 사람의 친구 수가 증가합니다</target>
        </trans-unit>
        <trans-unit id="4015b57a143aec5156fd1444a017a32137a3fd0f" translate="yes" xml:space="preserve">
          <source>commit</source>
          <target state="translated">commit</target>
        </trans-unit>
        <trans-unit id="ef1bbfb7f634722c33aa4d7f3c325a4a29ea88d1" translate="yes" xml:space="preserve">
          <source>commitUpdate (static method)</source>
          <target state="translated">commitUpdate (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="8a1c1339801686eb9bf9a9ac5b4719b8c8b8fc9b" translate="yes" xml:space="preserve">
          <source>constructor</source>
          <target state="translated">constructor</target>
        </trans-unit>
        <trans-unit id="4b45c519aa27393b323501edc492900dac1e0a96" translate="yes" xml:space="preserve">
          <source>create (static method)</source>
          <target state="translated">작성 (정적 방법)</target>
        </trans-unit>
        <trans-unit id="db646ca2b7d259a49537f70fff30ff3c2c3c18c5" translate="yes" xml:space="preserve">
          <source>createContainer (static method)</source>
          <target state="translated">createContainer (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="2b28d0e79db5f9b1637a6d02fd886e0beb0a2a87" translate="yes" xml:space="preserve">
          <source>createWithFiles (static method)</source>
          <target state="translated">createWithFiles (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="42cdc1d74453884d8861396360329db1f2583a19" translate="yes" xml:space="preserve">
          <source>fetchQuery</source>
          <target state="translated">fetchQuery</target>
        </trans-unit>
        <trans-unit id="da32c19d5a974ead91be2f8fa59b4a9c03db9888" translate="yes" xml:space="preserve">
          <source>forceFetch</source>
          <target state="translated">forceFetch</target>
        </trans-unit>
        <trans-unit id="446ce95fe1412056ff2efb4a2eddeb9b14b5b57b" translate="yes" xml:space="preserve">
          <source>fragments</source>
          <target state="translated">fragments</target>
        </trans-unit>
        <trans-unit id="348bf71ffb0d4407dbcecd15dd012e9ca4e50ec6" translate="yes" xml:space="preserve">
          <source>fragments (static property)</source>
          <target state="translated">조각 (정적 속성)</target>
        </trans-unit>
        <trans-unit id="c7051a4ed355bcc5e03ff249da8ad3c8d98795de" translate="yes" xml:space="preserve">
          <source>getCollisionKey</source>
          <target state="translated">getCollisionKey</target>
        </trans-unit>
        <trans-unit id="9b9964fe7f200e2d2d723f2ce25c45e685f31c1a" translate="yes" xml:space="preserve">
          <source>getConfigs (abstract method)</source>
          <target state="translated">getConfigs (추상 메소드)</target>
        </trans-unit>
        <trans-unit id="1af4f339fc74cdc2a2f63e9dec4d5c78820395ab" translate="yes" xml:space="preserve">
          <source>getDataID(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</source>
          <target state="translated">getDataID () : &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;DataID&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0405ea062abe8cd4a0d287f9154a09079dc4bb4d" translate="yes" xml:space="preserve">
          <source>getDebugName</source>
          <target state="translated">getDebugName</target>
        </trans-unit>
        <trans-unit id="327b4db9411eb5735cd4d613988bd27603d51f28" translate="yes" xml:space="preserve">
          <source>getFatQuery (abstract method)</source>
          <target state="translated">getFatQuery (추상 메소드)</target>
        </trans-unit>
        <trans-unit id="97f9623a23d5717ffebb67278d55b1afd1ffd725" translate="yes" xml:space="preserve">
          <source>getFiles</source>
          <target state="translated">getFiles</target>
        </trans-unit>
        <trans-unit id="1778700a36f50cd423696eb753bb860799ac9b24" translate="yes" xml:space="preserve">
          <source>getFragment</source>
          <target state="translated">getFragment</target>
        </trans-unit>
        <trans-unit id="d7c3b79969b5a91a9a376dcbffb251e4515b3ce9" translate="yes" xml:space="preserve">
          <source>getFragment (static method)</source>
          <target state="translated">getFragment (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="e8166bd4ce0d5f8fe076afeb9c45240cc7d5f2b5" translate="yes" xml:space="preserve">
          <source>getID</source>
          <target state="translated">getID</target>
        </trans-unit>
        <trans-unit id="a73db9be39fc73bb1d8a15f030515c436d5a3453" translate="yes" xml:space="preserve">
          <source>getLinkedRecord(name: string, args?: ?Variables): ?RecordProxy</source>
          <target state="translated">getLinkedRecord (이름 : 문자열, 인수? :? 변수) :? RecordProxy</target>
        </trans-unit>
        <trans-unit id="88377de01a531764c854a5d87458832e26bb6d7d" translate="yes" xml:space="preserve">
          <source>getLinkedRecords(name: string, args?: ?Variables): ?Array&amp;lt;?RecordProxy&amp;gt;</source>
          <target state="translated">getLinkedRecords (이름 : 문자열, 인수? :? 변수) :? Array &amp;lt;? RecordProxy&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d7fde427ab020029d422a06dc9a3f3cf60a0f286" translate="yes" xml:space="preserve">
          <source>getMutation (abstract method)</source>
          <target state="translated">getMutation (추상 방법)</target>
        </trans-unit>
        <trans-unit id="c3d4160e6945293e656522a92a11fe8535c041eb" translate="yes" xml:space="preserve">
          <source>getOptimisticConfigs</source>
          <target state="translated">getOptimisticConfigs</target>
        </trans-unit>
        <trans-unit id="e35ed410633190979352fe6ee6d4d885c8a18598" translate="yes" xml:space="preserve">
          <source>getOptimisticResponse</source>
          <target state="translated">getOptimisticResponse</target>
        </trans-unit>
        <trans-unit id="6bd679f8ef0f8733bd010559ff42cbedeb5983bf" translate="yes" xml:space="preserve">
          <source>getOrCreateLinkedRecord(name: string, typeName: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">getOrCreateLinkedRecord (name : string, typeName : string, args ?:? Variables) : RecordProxy</target>
        </trans-unit>
        <trans-unit id="759956d4899d707dd6a33742489f969212a28756" translate="yes" xml:space="preserve">
          <source>getPendingTransactions</source>
          <target state="translated">getPendingTransactions</target>
        </trans-unit>
        <trans-unit id="5531a9db2f3b83555a0eff0afe4a7b4598c8f0de" translate="yes" xml:space="preserve">
          <source>getQueryString</source>
          <target state="translated">getQueryString</target>
        </trans-unit>
        <trans-unit id="5b70bfc75fe69a0ac1b8cf3046235fbb64e40599" translate="yes" xml:space="preserve">
          <source>getRootField(fieldName: string): ?RecordProxy</source>
          <target state="translated">getRootField (fieldName : 문자열) :? RecordProxy</target>
        </trans-unit>
        <trans-unit id="ab14bf198ad6c14dda7ba6cd7afe5b74fddbdc2e" translate="yes" xml:space="preserve">
          <source>getSource(): &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;RecordSource&lt;/a&gt;</source>
          <target state="translated">getSource () : &lt;a href=&quot;https://github.com/facebook/relay/blob/d0310d69012bba615dacf614319bcf47ee2a0f3f/packages/relay-runtime/ARCHITECTURE.md&quot;&gt;레코드 소스&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="264cb99bbdb88c3a503a7cd09445ab43ad54af52" translate="yes" xml:space="preserve">
          <source>getType(): RelayQLType</source>
          <target state="translated">getType () : RelayQLType</target>
        </trans-unit>
        <trans-unit id="f5807036ab312a725491c64183d61cf7b9babe1d" translate="yes" xml:space="preserve">
          <source>getValue(name: string, args?: ?Variables): mixed</source>
          <target state="translated">getValue (이름 : 문자열, 인수? :? 변수) : 혼합</target>
        </trans-unit>
        <trans-unit id="43f55a80a8e191422ce37e5ebd8264867fc6316d" translate="yes" xml:space="preserve">
          <source>getVariables</source>
          <target state="translated">getVariables</target>
        </trans-unit>
        <trans-unit id="4349f8288befeff38404853658acf2b002ad2746" translate="yes" xml:space="preserve">
          <source>getVariables (abstract method)</source>
          <target state="translated">getVariables (추상 방법)</target>
        </trans-unit>
        <trans-unit id="3cfab35ae11b2420cf0d4e4900fa11d44d7f4976" translate="yes" xml:space="preserve">
          <source>gives us</source>
          <target state="translated">우리에게 주어지다</target>
        </trans-unit>
        <trans-unit id="9fdcc7f29c59e6f9abaaab32c0a1a15b1b78226b" translate="yes" xml:space="preserve">
          <source>graphql</source>
          <target state="translated">graphql</target>
        </trans-unit>
        <trans-unit id="dde2cfc8d1d2de804008dfc4836831a0eccb8444" translate="yes" xml:space="preserve">
          <source>hasOptimisticUpdate</source>
          <target state="translated">hasOptimisticUpdate</target>
        </trans-unit>
        <trans-unit id="a205cb3bee524195c2fdce6610a417b6853a4c32" translate="yes" xml:space="preserve">
          <source>initialVariables</source>
          <target state="translated">initialVariables</target>
        </trans-unit>
        <trans-unit id="4bfbc265fe484eac76b0500e386617d6cf0e573e" translate="yes" xml:space="preserve">
          <source>initialVariables (static property)</source>
          <target state="translated">initialVariables (정적 속성)</target>
        </trans-unit>
        <trans-unit id="04dcd4fb3277dbb1127599ff7d32d5684b6a02dc" translate="yes" xml:space="preserve">
          <source>injectNetworkLayer (static method)</source>
          <target state="translated">injectNetworkLayer (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="0a776c5ca0800d03ca78f47f75e9eb834365d304" translate="yes" xml:space="preserve">
          <source>injectTaskScheduler (static method)</source>
          <target state="translated">injectTaskScheduler (정적 메소드)</target>
        </trans-unit>
        <trans-unit id="bc813ae20708b8a347a4d53fb6e91311ea7bb33d" translate="yes" xml:space="preserve">
          <source>isContainer (static method)</source>
          <target state="translated">isContainer (정적 방법)</target>
        </trans-unit>
        <trans-unit id="c53397edd355fc4e2d006653db94583eef513e6f" translate="yes" xml:space="preserve">
          <source>onReadyStateChange</source>
          <target state="translated">onReadyStateChange</target>
        </trans-unit>
        <trans-unit id="fb05074bc118e549bee00caf3b25aeedd2a23fb9" translate="yes" xml:space="preserve">
          <source>or: &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt; in a Refetch Container</source>
          <target state="translated">또는 : 페치 컨테이너의 &lt;code&gt;this.props.relay.refetch({}, {}, callback, {force: true})&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00525d7718b6def384814a704d781fd95161b685" translate="yes" xml:space="preserve">
          <source>paramDefinitions (static property)</source>
          <target state="translated">paramDefinitions (정적 속성)</target>
        </trans-unit>
        <trans-unit id="ab47b8a712d90d33736ca95a21ffd78e2edcbc43" translate="yes" xml:space="preserve">
          <source>pendingVariables</source>
          <target state="translated">pendingVariables</target>
        </trans-unit>
        <trans-unit id="46070ca5b7bac4a677b32597aa968e6707fb2947" translate="yes" xml:space="preserve">
          <source>prepareParams (static property)</source>
          <target state="translated">PreparingParams (정적 속성)</target>
        </trans-unit>
        <trans-unit id="4c8dd8321c7f8e03d9a33e3aac495748a5310da1" translate="yes" xml:space="preserve">
          <source>prepareVariables</source>
          <target state="translated">prepareVariables</target>
        </trans-unit>
        <trans-unit id="6399eda44b9a365d9ef2884378c34b3d150ac371" translate="yes" xml:space="preserve">
          <source>prepareVariables (static property)</source>
          <target state="translated">PreparingVariables (정적 속성)</target>
        </trans-unit>
        <trans-unit id="d32d93402de4dcb749f059cba43572aa23bd03dc" translate="yes" xml:space="preserve">
          <source>queries (static property)</source>
          <target state="translated">쿼리 (정적 속성)</target>
        </trans-unit>
        <trans-unit id="9dc632a4888b695f2a771b203d0887d10714caef" translate="yes" xml:space="preserve">
          <source>react-relay/classic</source>
          <target state="translated">react-relay/classic</target>
        </trans-unit>
        <trans-unit id="37eca5751d1f6d7dfe5688efc6d86da3dd09c16f" translate="yes" xml:space="preserve">
          <source>render</source>
          <target state="translated">render</target>
        </trans-unit>
        <trans-unit id="62f23262fcec4cdc5eb17faabb63e059d6950930" translate="yes" xml:space="preserve">
          <source>renderFailure</source>
          <target state="translated">renderFailure</target>
        </trans-unit>
        <trans-unit id="2afd39a75e88681d175b8553ff1dce06613384a5" translate="yes" xml:space="preserve">
          <source>renderFetched</source>
          <target state="translated">renderFetched</target>
        </trans-unit>
        <trans-unit id="5e3932629379610ab259e44527d32162c9392f0b" translate="yes" xml:space="preserve">
          <source>renderLoading</source>
          <target state="translated">renderLoading</target>
        </trans-unit>
        <trans-unit id="414e681ebabcd2f23de1f32468992b9c81c5f909" translate="yes" xml:space="preserve">
          <source>returns</source>
          <target state="translated">returns</target>
        </trans-unit>
        <trans-unit id="ff3a6f3b41f1c1e00b77429034bc912cfa7dd364" translate="yes" xml:space="preserve">
          <source>rollback</source>
          <target state="translated">rollback</target>
        </trans-unit>
        <trans-unit id="fc166eb81361ff31179cd3c83da3bfe088b851d3" translate="yes" xml:space="preserve">
          <source>route</source>
          <target state="translated">route</target>
        </trans-unit>
        <trans-unit id="e1d71ee40db65de4abc60e598cad15a41923e787" translate="yes" xml:space="preserve">
          <source>routeName (static property)</source>
          <target state="translated">routeName (정적 속성)</target>
        </trans-unit>
        <trans-unit id="9f1125a04ebb1449bdd323a60a2950db5accfb80" translate="yes" xml:space="preserve">
          <source>sendMutation</source>
          <target state="translated">sendMutation</target>
        </trans-unit>
        <trans-unit id="435568d9e02408d6788ecdc6be513d72ccc6cb61" translate="yes" xml:space="preserve">
          <source>sendQueries</source>
          <target state="translated">sendQueries</target>
        </trans-unit>
        <trans-unit id="2880123c67d1aaedb821f0f247cd4c6c4345aab8" translate="yes" xml:space="preserve">
          <source>setLinkedRecord(record: RecordProxy, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setLinkedRecord (레코드 : RecordProxy, 이름 : 문자열, 인수? :? 변수) : RecordProxy</target>
        </trans-unit>
        <trans-unit id="7dc0722d5b1e977d588c3edf8515b019e788c174" translate="yes" xml:space="preserve">
          <source>setLinkedRecords(records: Array&amp;lt;?RecordProxy&amp;gt;, name: string, args?: ?Variables ): RecordProxy</source>
          <target state="translated">setLinkedRecords (레코드 : Array &amp;lt;? RecordProxy&amp;gt;, name : string, args ?:? Variables) : RecordProxy</target>
        </trans-unit>
        <trans-unit id="9a58f84fd8486e41fd7dcfc4d34aa90c06019e22" translate="yes" xml:space="preserve">
          <source>setValue(value: mixed, name: string, args?: ?Variables): RecordProxy</source>
          <target state="translated">setValue (값 : 혼합, 이름 : 문자열, 인수? :? 변수) : RecordProxy</target>
        </trans-unit>
        <trans-unit id="5548ee17e1e709bc17eb0b6bc474907bee14447b" translate="yes" xml:space="preserve">
          <source>setVariables</source>
          <target state="translated">setVariables</target>
        </trans-unit>
        <trans-unit id="ae2633f3722560d2ad1ff74c21f50ef81ea6b153" translate="yes" xml:space="preserve">
          <source>shouldComponentUpdate</source>
          <target state="translated">shouldComponentUpdate</target>
        </trans-unit>
        <trans-unit id="8a14711da8b864c0b88fb3fe7e873c0b2894566e" translate="yes" xml:space="preserve">
          <source>supports</source>
          <target state="translated">supports</target>
        </trans-unit>
        <trans-unit id="09e391d372ecf222949d736538e76db78674604a" translate="yes" xml:space="preserve">
          <source>the viewer's friendship status with the requester will change</source>
          <target state="translated">요청자와의 시청자 상태가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="bc5af2310c7f15770a4ed0028648ce367e3e2ec0" translate="yes" xml:space="preserve">
          <source>variables</source>
          <target state="translated">variables</target>
        </trans-unit>
        <trans-unit id="87a0de569c57d54d8721ab12b504cc0797b8a57b" translate="yes" xml:space="preserve">
          <source>with these params:</source>
          <target state="translated">이 매개 변수와 함께 :</target>
        </trans-unit>
        <trans-unit id="edb0f5b1f639a3886e3180c47fe86c3a6a263842" translate="yes" xml:space="preserve">
          <source>yields</source>
          <target state="translated">yields</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
