<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="jquery">
    <body>
      <group id="jquery">
        <trans-unit id="24668f69e38ec30af5430ec57c38e4f3a360d781" translate="yes" xml:space="preserve">
          <source>Passing Event Data</source>
          <target state="translated">이벤트 데이터 전달</target>
        </trans-unit>
        <trans-unit id="be8d5a856c78d9ea61953d1aae50161b1479b08d" translate="yes" xml:space="preserve">
          <source>Passing a Function</source>
          <target state="translated">함수 전달</target>
        </trans-unit>
        <trans-unit id="94b296314bd220f16316eba73ac6a0293f79631e" translate="yes" xml:space="preserve">
          <source>Passing and handling event data works the same way as it does for &lt;code&gt;.on()&lt;/code&gt;.</source>
          <target state="translated">이벤트 데이터 전달 및 처리는 &lt;code&gt;.on()&lt;/code&gt; 과 동일한 방식으로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="79b9493aad121249c06485be783dab64a5565634" translate="yes" xml:space="preserve">
          <source>Passing data to the handler</source>
          <target state="translated">핸들러로 데이터 전달</target>
        </trans-unit>
        <trans-unit id="ff30533028ec97d95729586d791f43cc566b973b" translate="yes" xml:space="preserve">
          <source>Passing in a malformed JSON string results in a JavaScript exception being thrown. For example, the following are all invalid JSON strings:</source>
          <target state="translated">잘못된 JSON 문자열을 전달하면 JavaScript 예외가 발생합니다. 예를 들어, 다음은 모두 유효하지 않은 JSON 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0d0c656b1b2892a427f97eda703e8d098445da3c" translate="yes" xml:space="preserve">
          <source>Per-property Easing</source>
          <target state="translated">속성 별 완화</target>
        </trans-unit>
        <trans-unit id="9589684d53470a15aa562a26841a8da7dc6623de" translate="yes" xml:space="preserve">
          <source>Perform a custom animation of a set of CSS properties.</source>
          <target state="translated">CSS 속성 세트의 사용자 정의 애니메이션을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="7fbb6be2c9386631b75a15df0b73a775f134538b" translate="yes" xml:space="preserve">
          <source>Perform an asynchronous HTTP (Ajax) request.</source>
          <target state="translated">비동기 HTTP (Ajax) 요청을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e17b8a0e34bfa65fea451f6c53d2fcb021fcde57" translate="yes" xml:space="preserve">
          <source>Places a border around all list items that are children of &amp;lt;ul class=&quot;topnav&quot;&amp;gt; .</source>
          <target state="translated">&amp;lt;ul class = &quot;topnav&quot;&amp;gt;의 하위 항목 인 모든 목록 항목 주위에 테두리를 배치합니다.</target>
        </trans-unit>
        <trans-unit id="88e22ddf6d8a412676c8f0c76b426f4bc5fc842b" translate="yes" xml:space="preserve">
          <source>PlainObject</source>
          <target state="translated">PlainObject</target>
        </trans-unit>
        <trans-unit id="3180f052c4c83832239076f7eacc4313566a9114" translate="yes" xml:space="preserve">
          <source>Please note that although you can pass text nodes and comment nodes into a jQuery collection this way, most operations don't support them. The few that do will have an explicit note on their API documentation page.</source>
          <target state="translated">이런 방식으로 텍스트 노드와 주석 노드를 jQuery 컬렉션에 전달할 수 있지만 대부분의 작업은이를 지원하지 않습니다. 그 중 일부는 API 문서 페이지에 명시 적 메모가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bd1c35913397741b31109eaf3cbb050bdd82de0" translate="yes" xml:space="preserve">
          <source>Possible flags:</source>
          <target state="translated">가능한 플래그 :</target>
        </trans-unit>
        <trans-unit id="f8156ee9b4d1cf9712c808ab6f59d8c0e0265624" translate="yes" xml:space="preserve">
          <source>Post a form using Ajax and put results in a div</source>
          <target state="translated">Ajax를 사용하여 양식을 게시하고 결과를 div에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="8eda3141aabc4b52dc3c81a854edd4140396a7f3" translate="yes" xml:space="preserve">
          <source>Post to the test.php page and get content which has been returned in json format (&amp;lt;?php echo json_encode(array(&quot;name&quot;=&amp;gt;&quot;John&quot;,&quot;time&quot;=&amp;gt;&quot;2pm&quot;)); ?&amp;gt;).</source>
          <target state="translated">test.php 페이지에 게시하여 json 형식으로 반환 된 내용을 가져옵니다 (&amp;lt;? php echo json_encode (array ( &quot;name&quot;=&amp;gt; &quot;John&quot;, &quot;time&quot;=&amp;gt; &quot;2pm&quot;);?&amp;gt;)).</target>
        </trans-unit>
        <trans-unit id="f322b9f3495aba7144e876707bc47a2a7d952d9d" translate="yes" xml:space="preserve">
          <source>Prefilters are a perfect fit when custom options need to be handled. Given the following code, for example, a call to &lt;code&gt;$.ajax()&lt;/code&gt; would automatically abort a request to the same URL if the custom &lt;code&gt;abortOnRetry&lt;/code&gt; option is set to &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">사전 필터는 사용자 정의 옵션을 처리해야 할 때 가장 적합합니다. 예를 들어, 다음 코드가 제공되면 &lt;code&gt;$.ajax()&lt;/code&gt; 호출 하면 사용자 지정의 경우 동일한 URL에 대한 요청이 자동으로 중단됩니다. &lt;code&gt;abortOnRetry&lt;/code&gt; 옵션이 &lt;code&gt;true&lt;/code&gt; 로 설정된 합니다 .</target>
        </trans-unit>
        <trans-unit id="5bcb18ee1f9a94de27b30e82157a747c5b3e613a" translate="yes" xml:space="preserve">
          <source>Prefilters can also be used to modify existing options. For example, the following proxies cross-domain requests through https://mydomain.net/proxy/:</source>
          <target state="translated">사전 필터를 사용하여 기존 옵션을 수정할 수도 있습니다. 예를 들어 다음 프록시는 https://mydomain.net/proxy/를 통한 도메인 간 요청입니다.</target>
        </trans-unit>
        <trans-unit id="232e132d8704ff6d6a305ebb6baea10771f24387" translate="yes" xml:space="preserve">
          <source>Prepend all spans to the element with the ID &quot;foo&quot; (Check .prepend() documentation for more examples)</source>
          <target state="translated">ID가 &quot;foo&quot;인 요소에 모든 범위를 추가합니다 (자세한 내용은 .prepend () 설명서를 참조하십시오).</target>
        </trans-unit>
        <trans-unit id="3a1b005580f79d2b9feb9ee84fc3ad816f8ee6c6" translate="yes" xml:space="preserve">
          <source>Prepends a DOM Element to all paragraphs.</source>
          <target state="translated">모든 단락 앞에 DOM 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7cad6f704aab1d92b6effccc3995a5b6e6f987b2" translate="yes" xml:space="preserve">
          <source>Prepends a jQuery object (similar to an Array of DOM Elements) to all paragraphs.</source>
          <target state="translated">모든 단락 앞에 jQuery 객체 (DOM 요소 배열과 유사)를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="76f13c2409c82584ac6e5093150789bb63510be8" translate="yes" xml:space="preserve">
          <source>Prepends some HTML to all paragraphs.</source>
          <target state="translated">모든 단락 앞에 HTML을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="82f8527f6240b044a741cb8b663a0e5e11d03bde" translate="yes" xml:space="preserve">
          <source>Prevents other event handlers from being called.</source>
          <target state="translated">다른 이벤트 핸들러가 호출되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="0fd2d09f7e570399a076e57e7b952b3c96b2fef8" translate="yes" xml:space="preserve">
          <source>Prevents the event from bubbling up the DOM tree, preventing any parent handlers from being notified of the event.</source>
          <target state="translated">이벤트가 DOM 트리를 버블 링하지 못하도록하여 상위 핸들러에게 이벤트를 알리지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="bf21227c4464de1be5b8be0cedaef5b1eb6baf31" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.4, the arguments should be true Javascript Array objects; use &lt;code&gt;$.makeArray&lt;/code&gt; if they are not.</source>
          <target state="translated">jQuery 1.4 이전에는 인수가 true Javascript Array 객체 여야합니다. &lt;code&gt;$.makeArray&lt;/code&gt; 않으면 $ .makeArray를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b123d694309d3954b58e4e45e2e6f52607ff20e0" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.4.3 (starting in jQuery 1.4) the &lt;code&gt;.data()&lt;/code&gt; method completely replaced all data, instead of just extending the data object. If you are using third-party plugins it may not be advisable to completely replace the element's data object, since plugins may have also set data.</source>
          <target state="translated">jQuery 1.4.3 (jQuery 1.4에서 시작) 이전에는 &lt;code&gt;.data()&lt;/code&gt; 메소드가 데이터 오브젝트를 확장하는 대신 모든 데이터를 완전히 대체했습니다. 써드 파티 플러그인을 사용하는 경우 플러그인도 데이터를 설정했을 수 있으므로 요소의 데이터 오브젝트를 완전히 대체하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1530433b2facdd30bee4aad9ae661ef1b3234fda" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.4.3, &lt;code&gt;.data( obj )&lt;/code&gt; completely replaced all data. Since jQuery 1.4.3, data is instead extended by shallow merge.</source>
          <target state="translated">jQuery 1.4.3 이전에는 &lt;code&gt;.data( obj )&lt;/code&gt; 가 모든 데이터를 완전히 대체했습니다. jQuery 1.4.3부터 데이터는 대신 얕은 병합으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="fb40c73abf82d2ae0bf8b9f2097143bcdd0c6521" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.5, the global &lt;code&gt;.ajaxError()&lt;/code&gt; callback event had to be used in order to handle &lt;code&gt;$.getScript()&lt;/code&gt; errors:</source>
          <target state="translated">jQuery 1.5 이전에는 &lt;code&gt;$.getScript()&lt;/code&gt; 오류 를 처리하기 위해 전역 &lt;code&gt;.ajaxError()&lt;/code&gt; 콜백 이벤트를 사용해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="42d18165ce6b4de6e02584eb2f59175fe1d13460" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.7, in selector strings with positional selectors such as &lt;code&gt;:first&lt;/code&gt;, &lt;code&gt;:gt()&lt;/code&gt;, or &lt;code&gt;:even&lt;/code&gt;, the positional filtering is done against the jQuery object passed to &lt;code&gt;.is()&lt;/code&gt;, &lt;em&gt;not&lt;/em&gt; against the containing document. So for the HTML shown above, an expression such as &lt;code&gt;$( &quot;li:first&quot; ).is( &quot;li:last&quot; )&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, but &lt;code&gt;$( &quot;li:first-child&quot; ).is( &quot;li:last-child&quot; )&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. In addition, a bug in Sizzle prevented many positional selectors from working properly. These two factors made positional selectors almost unusable in filters.</source>
          <target state="translated">같은 위치 선택기와 선택기 문자열에서 jQuery를 1.7 이전 &lt;code&gt;:first&lt;/code&gt; , &lt;code&gt;:gt()&lt;/code&gt; , 또는 &lt;code&gt;:even&lt;/code&gt; 상기 위치 필터링에 전달 jQuery 오브젝트에 대해 수행되는 &lt;code&gt;.is()&lt;/code&gt; , &lt;em&gt;하지&lt;/em&gt; 포함하는 문서에 대해. 따라서 위에 표시된 HTML의 경우 &lt;code&gt;$( &quot;li:first&quot; ).is( &quot;li:last&quot; )&lt;/code&gt; 와 같은 표현식 은 &lt;code&gt;true&lt;/code&gt; 를 반환 하지만 &lt;code&gt;$( &quot;li:first-child&quot; ).is( &quot;li:last-child&quot; )&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 또한 Sizzle의 버그로 인해 많은 위치 선택기가 제대로 작동하지 못했습니다. 이 두 가지 요소로 인해 필터에서 위치 선택기가 거의 사용할 수 없게되었습니다.</target>
        </trans-unit>
        <trans-unit id="d6ee2d082684a3d606d94b34e878d67b987a0362" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.8, the &lt;code&gt;:eq(index)&lt;/code&gt; selector did &lt;em&gt;not&lt;/em&gt; accept a negative value for &lt;code&gt;index&lt;/code&gt; (though the &lt;a href=&quot;eq&quot;&gt;&lt;code&gt;.eq(index)&lt;/code&gt;&lt;/a&gt; method did).</source>
          <target state="translated">jQuery를 1.8 이전에, &lt;code&gt;:eq(index)&lt;/code&gt; 선택기 않았다 &lt;em&gt;하지&lt;/em&gt; 에 대한 음의 값 동의 &lt;code&gt;index&lt;/code&gt; 합니다 (하지만 &lt;a href=&quot;eq&quot;&gt; &lt;code&gt;.eq(index)&lt;/code&gt; &lt;/a&gt; 방법을했다).</target>
        </trans-unit>
        <trans-unit id="3a212e9e0e5070c7c9452ef703226665bf7ea108" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.8, the &lt;code&gt;:gt(index)&lt;/code&gt; selector did &lt;em&gt;not&lt;/em&gt; accept a negative value for &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">jQuery를 1.8 이전에, &lt;code&gt;:gt(index)&lt;/code&gt; 선택기 않았다 &lt;em&gt;하지&lt;/em&gt; 에 대한 음의 값 동의 &lt;code&gt;index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af3da3106e959302465ecda0b177352ad8bffd36" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.8, the &lt;code&gt;:lt(index)&lt;/code&gt; selector did &lt;em&gt;not&lt;/em&gt; accept a negative value for &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">jQuery를 1.8 이전에, &lt;code&gt;:lt(index)&lt;/code&gt; 선택기 않았다 &lt;em&gt;하지&lt;/em&gt; 에 대한 음의 값 동의 &lt;code&gt;index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8738bf3874c5692fd941d4379f8a846ab800608b" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.9, &lt;code&gt;$.parseJSON&lt;/code&gt; returned &lt;code&gt;null&lt;/code&gt; instead of throwing an error if it was passed an empty string, &lt;code&gt;null&lt;/code&gt;, or &lt;code&gt;undefined&lt;/code&gt;, even though those are not valid JSON.</source>
          <target state="translated">jQuery 1.9 이전에는 &lt;code&gt;$.parseJSON&lt;/code&gt; 이 유효한 JSON이 아니더라도 빈 문자열, &lt;code&gt;null&lt;/code&gt; 또는 &lt;code&gt;undefined&lt;/code&gt; 가 전달 된 경우 오류를 발생시키는 대신 &lt;code&gt;null&lt;/code&gt; 을 반환 했습니다 .</target>
        </trans-unit>
        <trans-unit id="d08f9318122f146f6802cf4161100074eebb1bc1" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.9, &lt;code&gt;.after()&lt;/code&gt; would attempt to add or change nodes in the current jQuery set if the first node in the set was not connected to a document, and in those cases return a new jQuery set rather than the original set. The method might or might not have returned a new result depending on the number or connectedness of its arguments! As of jQuery 1.9, &lt;code&gt;.after()&lt;/code&gt;, &lt;code&gt;.before()&lt;/code&gt;, and &lt;code&gt;.replaceWith()&lt;/code&gt; always return the original unmodified set. Attempting to use these methods on a node without a parent has no effect&amp;mdash;that is, neither the set nor the nodes it contains are changed.</source>
          <target state="translated">jQuery 1.9 이전에는 &lt;code&gt;.after()&lt;/code&gt; 는 세트의 첫 번째 노드가 문서에 연결되지 않은 경우 현재 jQuery 세트에서 노드를 추가하거나 변경하려고 시도한 경우 원래 세트가 아닌 새 jQuery 세트를 리턴합니다. 이 메소드는 인수의 수 또는 연결성에 따라 새로운 결과를 리턴하거나 리턴하지 않았을 수 있습니다! jQuery 1.9부터 &lt;code&gt;.after()&lt;/code&gt; , &lt;code&gt;.before()&lt;/code&gt; 및 &lt;code&gt;.replaceWith()&lt;/code&gt; 항상 수정되지 않은 원래 세트를 반환합니다. 부모가없는 노드에서 이러한 방법을 사용하려고해도 아무런 영향을 미치지 않습니다. 즉, 세트 나 노드에 포함 된 노드가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2cdd46443ef8cc4f83d8ffa807e15ca6f9d3e830" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.9, &lt;code&gt;.before()&lt;/code&gt; would attempt to add or change nodes in the current jQuery set if the first node in the set was not connected to a document, and in those cases return a new jQuery set rather than the original set. The method might or might not have returned a new result depending on the number or connectedness of its arguments! As of jQuery 1.9, &lt;code&gt;.after()&lt;/code&gt;, &lt;code&gt;.before()&lt;/code&gt;, and &lt;code&gt;.replaceWith()&lt;/code&gt; always return the original unmodified set. Attempting to use these methods on a node without a parent has no effect&amp;mdash;that is, neither the set nor the nodes it contains are changed.</source>
          <target state="translated">jQuery 1.9 이전에는 &lt;code&gt;.before()&lt;/code&gt; 는 세트의 첫 번째 노드가 문서에 연결되지 않은 경우 현재 jQuery 세트에서 노드를 추가하거나 변경하려고 시도한 경우 원래 세트가 아닌 새 jQuery 세트를 리턴합니다. 이 메소드는 인수의 수 또는 연결성에 따라 새로운 결과를 리턴하거나 리턴하지 않았을 수 있습니다! jQuery 1.9부터 &lt;code&gt;.after()&lt;/code&gt; , &lt;code&gt;.before()&lt;/code&gt; 및 &lt;code&gt;.replaceWith()&lt;/code&gt; 항상 수정되지 않은 원래 세트를 반환합니다. 부모가없는 노드에서 이러한 방법을 사용하려고해도 아무런 영향을 미치지 않습니다. 즉, 세트 나 노드에 포함 된 노드가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4b6d5d6b69a94dddcc6ea715db291c8faa64fec9" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 1.9, &lt;code&gt;.replaceWith()&lt;/code&gt; would attempt to add or change nodes in the current jQuery set if the first node in the set was not connected to a document, and in those cases return a new jQuery set rather than the original set. The method might or might not have returned a new result depending on the number or connectedness of its arguments! As of jQuery 1.9, &lt;code&gt;.after()&lt;/code&gt;, &lt;code&gt;.before()&lt;/code&gt;, and &lt;code&gt;.replaceWith()&lt;/code&gt; always return the original unmodified set. Attempting to use these methods on a node without a parent has no effect&amp;mdash;that is, neither the set nor the nodes it contains are changed.</source>
          <target state="translated">jQuery 1.9 이전에는 &lt;code&gt;.replaceWith()&lt;/code&gt; 는 세트의 첫 번째 노드가 문서에 연결되지 않은 경우 현재 jQuery 세트에서 노드를 추가하거나 변경하려고 시도한 경우 원래 세트가 아닌 새 jQuery 세트를 리턴합니다. 이 메소드는 인수의 수 또는 연결성에 따라 새로운 결과를 리턴하거나 리턴하지 않았을 수 있습니다! jQuery 1.9부터 &lt;code&gt;.after()&lt;/code&gt; , &lt;code&gt;.before()&lt;/code&gt; 및 &lt;code&gt;.replaceWith()&lt;/code&gt; 항상 수정되지 않은 원래 세트를 반환합니다. 부모가없는 노드에서 이러한 방법을 사용하려고해도 아무런 영향을 미치지 않습니다. 즉, 세트 나 노드에 포함 된 노드가 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="779026168e3049f2cac03a3a10cfd6a8fff5e6cf" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 3.0, this method was called &lt;code&gt;&lt;a href=&quot;jquery.unique&quot;&gt;jQuery.unique()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">jQuery 3.0 이전에는이 ​​메소드를 &lt;code&gt;&lt;a href=&quot;jquery.unique&quot;&gt;jQuery.unique()&lt;/a&gt;&lt;/code&gt; 라고 했습니다 .</target>
        </trans-unit>
        <trans-unit id="3fa495912556317b590f7533e62b99917f547f60" translate="yes" xml:space="preserve">
          <source>Prior to jQuery 3.5.0, unsuccessful HTTP responses with a script &lt;code&gt;Content-Type&lt;/code&gt; were still executed.</source>
          <target state="translated">jQuery 3.5.0 이전에는 스크립트를 사용한 HTTP 응답 실패 &lt;code&gt;Content-Type&lt;/code&gt; 을 이 계속 실행되었습니다.</target>
        </trans-unit>
        <trans-unit id="351a92ceed41b2e610186c68ece5e88842211bfa" translate="yes" xml:space="preserve">
          <source>Promise Object</source>
          <target state="translated">약속 개체</target>
        </trans-unit>
        <trans-unit id="e606f4866747c2f92752089eea46ab0c93882ee6" translate="yes" xml:space="preserve">
          <source>Properties generally affect the dynamic state of a DOM element without changing the serialized HTML attribute. Examples include the &lt;code&gt;value&lt;/code&gt; property of input elements, the &lt;code&gt;disabled&lt;/code&gt; property of inputs and buttons, or the &lt;code&gt;checked&lt;/code&gt; property of a checkbox. The &lt;code&gt;.prop()&lt;/code&gt; method should be used to set disabled and checked instead of the &lt;code&gt;&lt;a href=&quot;attr&quot;&gt;.attr()&lt;/a&gt;&lt;/code&gt; method. The &lt;code&gt;&lt;a href=&quot;val&quot;&gt;.val()&lt;/a&gt;&lt;/code&gt; method should be used for getting and setting value.</source>
          <target state="translated">속성은 일반적으로 직렬화 된 HTML 속성을 변경하지 않고 DOM 요소의 동적 상태에 영향을줍니다. 입력 요소 의 &lt;code&gt;value&lt;/code&gt; 속성, 입력 및 버튼 의 &lt;code&gt;disabled&lt;/code&gt; 속성 또는 확인란 의 &lt;code&gt;checked&lt;/code&gt; 속성을 예로들 수 있습니다 . &lt;code&gt;.prop()&lt;/code&gt; 메소드는 비활성화 설정하는 대신으로 확인해야 &lt;code&gt;&lt;a href=&quot;attr&quot;&gt;.attr()&lt;/a&gt;&lt;/code&gt; 방법. &lt;code&gt;&lt;a href=&quot;val&quot;&gt;.val()&lt;/a&gt;&lt;/code&gt; 메소드는 점점 값을 설정하는 데 사용되어야한다.</target>
        </trans-unit>
        <trans-unit id="5c0c8d78301081a9fe22695fffe4f726d4ea87b3" translate="yes" xml:space="preserve">
          <source>Prototype</source>
          <target state="translated">Prototype</target>
        </trans-unit>
        <trans-unit id="4dddbaec9dd46c9aeafdb1a4344538e3a3f99344" translate="yes" xml:space="preserve">
          <source>Provides a way to execute callback functions based on zero or more Thenable objects, usually Deferred objects that represent asynchronous events.</source>
          <target state="translated">0 개 이상의 Thenable 객체 (일반적으로 비동기 이벤트를 나타내는 지연된 객체)를 기반으로 콜백 함수를 실행하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ec60235a3878a6dcf393d4a6bf9220cf073f8d11" translate="yes" xml:space="preserve">
          <source>Providing a negative number indicates a position starting from the end of the set, rather than the beginning. For example:</source>
          <target state="translated">음수를 제공한다는 것은 시작이 아니라 세트의 끝에서 시작하는 위치를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86f54466e0004ea3152a3be478a81bd98fb0f962" translate="yes" xml:space="preserve">
          <source>Proxy Pattern</source>
          <target state="translated">프록시 패턴</target>
        </trans-unit>
        <trans-unit id="7e558b6e85beca559a259cad628894195c6fe7e4" translate="yes" xml:space="preserve">
          <source>QUnit API docs</source>
          <target state="translated">QUnit API 문서</target>
        </trans-unit>
        <trans-unit id="d0997ef78b0a4c39908ad9bff14d30fbb5aee18f" translate="yes" xml:space="preserve">
          <source>Queue a custom function.</source>
          <target state="translated">사용자 정의 기능을 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="80e638f5c4369734d6653dc96c04c7acd78b38e7" translate="yes" xml:space="preserve">
          <source>Qunit's Assert Object</source>
          <target state="translated">Qunit의 Assert Object</target>
        </trans-unit>
        <trans-unit id="60fefb29eda0237f92306cb85899330ca8b230ee" translate="yes" xml:space="preserve">
          <source>Quoting</source>
          <target state="translated">Quoting</target>
        </trans-unit>
        <trans-unit id="73eacf64e5e81f1fcb39bf6fc6d87cea5690a84c" translate="yes" xml:space="preserve">
          <source>Reading and writing elements to an array uses the array-notation:</source>
          <target state="translated">배열에 요소를 읽고 쓰는 것은 배열 표기법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3bd455d4841aed3c37f7ec4c5a4fc4a2af81c69d" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to a subset specified by a range of indices.</source>
          <target state="translated">일치하는 요소 집합을 다양한 인덱스로 지정된 하위 집합으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="1e8dd6900b011196e2f4a56c0cf89faca36f3e7e" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to the even ones in the set, numbered from zero.</source>
          <target state="translated">일치하는 요소 집합을 0부터 번호가 매겨진 집합의 짝수로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="8739271f849c700a6c0f32e066d7a1a077a8c2dd" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to the final one in the set.</source>
          <target state="translated">일치하는 요소 세트를 세트의 마지막 요소로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="f5f117806b16689d587a077b5e8a3008e7f14b4f" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to the first in the set.</source>
          <target state="translated">일치하는 요소 세트를 세트의 첫 번째 세트로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="dcb9f3bba427cedab9a22608ff1f552fd5105153" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to the odd ones in the set, numbered from zero.</source>
          <target state="translated">0부터 번호가 매겨진 세트의 홀수 요소로 일치하는 요소 집합을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0ef2b5baaab943ca133dd166d2b25a9c8d6847db" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to the one at the specified index.</source>
          <target state="translated">일치하는 요소 세트를 지정된 색인의 요소 세트로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="cbef618e1d6febf6e667f916fb1a247bbf604c36" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to those that have a descendant that matches the selector or DOM element.</source>
          <target state="translated">일치 요소 세트를 선택기 또는 DOM 요소와 일치하는 하위 항목이있는 요소로 줄이십시오.</target>
        </trans-unit>
        <trans-unit id="e092144853f325cc23c57056fac3b9e47adaecea" translate="yes" xml:space="preserve">
          <source>Reduce the set of matched elements to those that match the selector or pass the function&amp;rsquo;s test.</source>
          <target state="translated">일치하는 요소 세트를 선택기와 일치하는 요소로 줄이거 나 함수의 테스트를 통과하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea00b1a0bd8455bb9506bc4716b955661b6d7fc" translate="yes" xml:space="preserve">
          <source>Register a handler to be called when Ajax requests complete with an error. This is an Ajax Event.</source>
          <target state="translated">Ajax 요청이 오류와 함께 완료 될 때 호출 될 핸들러를 등록하십시오. 이것은 Ajax 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="cb1cd3334c0c68c88c6c354897b9a3c37ffc4f28" translate="yes" xml:space="preserve">
          <source>Register a handler to be called when Ajax requests complete. This is an AjaxEvent.</source>
          <target state="translated">Ajax 요청이 완료 될 때 호출 할 핸들러를 등록하십시오. 이것은 AjaxEvent입니다.</target>
        </trans-unit>
        <trans-unit id="046a7a8cf91a262375dabe45d5530f029d0902a1" translate="yes" xml:space="preserve">
          <source>Register a handler to be called when all Ajax requests have completed. This is an Ajax Event.</source>
          <target state="translated">모든 Ajax 요청이 완료되면 호출 할 핸들러를 등록하십시오. 이것은 Ajax 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="f8b1ee0cf3bb013a4901ba48c82a092f864c1981" translate="yes" xml:space="preserve">
          <source>Register a handler to be called when the first Ajax request begins. This is an Ajax Event.</source>
          <target state="translated">첫 번째 Ajax 요청이 시작될 때 호출 될 핸들러를 등록하십시오. 이것은 Ajax 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="50e2f5291c06e2ab1e5d166ed5784a7b771585c2" translate="yes" xml:space="preserve">
          <source>Reject a Deferred object and call any failCallbacks with the given args.</source>
          <target state="translated">지연된 객체를 거부하고 주어진 인수로 failCallbacks를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="5a4cbb7cd001bf81755640657aa8c8f3788845ef" translate="yes" xml:space="preserve">
          <source>Reject a Deferred object and call any failCallbacks with the given context and args.</source>
          <target state="translated">지연된 객체를 거부하고 지정된 컨텍스트 및 인수로 failCallbacks를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="296c0790c40cf3ee5ef277bdc24194e6a59621ee" translate="yes" xml:space="preserve">
          <source>Relinquish jQuery&amp;rsquo;s control of the $ variable.</source>
          <target state="translated">$ 변수에 대한 jQuery의 제어권을 포기합니다.</target>
        </trans-unit>
        <trans-unit id="d254480091a9afb5893e4d137b177e3c48f3d58d" translate="yes" xml:space="preserve">
          <source>Remove a callback or a collection of callbacks from a callback list.</source>
          <target state="translated">콜백 목록에서 콜백 또는 콜백 모음을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="152bebda6c7fab2eb30b4e2f0905212360afd527" translate="yes" xml:space="preserve">
          <source>Remove a handler from the event for all elements which match the current selector, based upon a specific set of root elements.</source>
          <target state="translated">특정 루트 요소 집합을 기반으로 현재 선택기와 일치하는 모든 요소에 대해 이벤트에서 처리기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="51844c3db03fe078e728ade46a3b9a19c4248f5a" translate="yes" xml:space="preserve">
          <source>Remove a previously-attached event handler from the elements.</source>
          <target state="translated">요소에서 이전에 연결된 이벤트 핸들러를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="442c1f1945b0f5e3699145b6117ca4bc982901b0" translate="yes" xml:space="preserve">
          <source>Remove a previously-stored piece of data.</source>
          <target state="translated">이전에 저장된 데이터를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fbeece5249b803d87fb8175d2bb5f652e7808a88" translate="yes" xml:space="preserve">
          <source>Remove a property for the set of matched elements.</source>
          <target state="translated">일치하는 요소 세트의 특성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6b64a5a444f5c29728046911f570f989d1af99d1" translate="yes" xml:space="preserve">
          <source>Remove a single class, multiple classes, or all classes from each element in the set of matched elements.</source>
          <target state="translated">일치하는 요소 세트의 각 요소에서 단일 클래스, 다중 클래스 또는 모든 클래스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="9c0453209c295e68a0c3d52f5c7e937797bbd791" translate="yes" xml:space="preserve">
          <source>Remove all child nodes of the set of matched elements from the DOM.</source>
          <target state="translated">일치하는 요소 세트의 모든 하위 노드를 DOM에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0783a64069f3907b9e9bb07e5cad6b02d24bbf52" translate="yes" xml:space="preserve">
          <source>Remove all delegated click handlers from all paragraphs:</source>
          <target state="translated">모든 단락에서 위임 된 클릭 핸들러를 모두 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="603e780ec0aea140b4761abbaa99d5c6c0951ed5" translate="yes" xml:space="preserve">
          <source>Remove all event handlers from all paragraphs:</source>
          <target state="translated">모든 단락에서 모든 이벤트 핸들러를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fede081dd4918b39d6dff14b203036f0e5a1deab" translate="yes" xml:space="preserve">
          <source>Remove all of the callbacks from a list.</source>
          <target state="translated">목록에서 모든 콜백을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="89eb35e8f65afbe7124f07bef85708a3ab9dc117" translate="yes" xml:space="preserve">
          <source>Remove all the classes from the matched elements.</source>
          <target state="translated">일치하는 요소에서 모든 클래스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fe4f07de07a09dea08897e85ea59b3c2f916b939" translate="yes" xml:space="preserve">
          <source>Remove an attribute from each element in the set of matched elements.</source>
          <target state="translated">일치하는 요소 세트의 각 요소에서 속성을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="944034e77286ef1b27bf82a282cddc5d330b328a" translate="yes" xml:space="preserve">
          <source>Remove an event handler.</source>
          <target state="translated">이벤트 핸들러를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d31f228affab5884a76a09d1b7f8a2dd08681afa" translate="yes" xml:space="preserve">
          <source>Remove elements from the set of matched elements.</source>
          <target state="translated">일치하는 요소 세트에서 요소를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="8cf593ca14051b1ad9096d31bd8f05ed1500f02a" translate="yes" xml:space="preserve">
          <source>Remove event handlers previously attached using .live() from the elements.</source>
          <target state="translated">요소에서 이전에 .live ()를 사용하여 연결된 이벤트 핸들러를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="0fa050548901dd546b504c572fe6013210602a03" translate="yes" xml:space="preserve">
          <source>Remove from the queue all items that have not yet been run.</source>
          <target state="translated">아직 실행되지 않은 모든 항목을 큐에서 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="c7c079e57c1ef7a6b712d33758c39e1793c8fbd0" translate="yes" xml:space="preserve">
          <source>Remove just one previously bound handler by passing it as the third argument:</source>
          <target state="translated">이전에 바인딩 된 핸들러를 세 번째 인수로 전달하여 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="e52e36c56060191804131d5a2b083997fcc59144" translate="yes" xml:space="preserve">
          <source>Remove the class 'blue' and 'under' from the matched elements (3.3+ syntax).</source>
          <target state="translated">일치하는 요소 (3.3+ 구문)에서 'blue'및 'under'클래스를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4219b3dbe4ae825caa17c061864413768325651d" translate="yes" xml:space="preserve">
          <source>Remove the class 'blue' and 'under' from the matched elements.</source>
          <target state="translated">일치하는 요소에서 'blue'및 'under'클래스를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="87b0641be0ccaa7415884b279c3e7b7040b29896" translate="yes" xml:space="preserve">
          <source>Remove the class 'blue' from the matched elements.</source>
          <target state="translated">일치하는 요소에서 클래스 'blue'를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="6a0a7ad121887d5025890028bd2da9cd450a9576" translate="yes" xml:space="preserve">
          <source>Remove the parents of the set of matched elements from the DOM, leaving the matched elements in their place.</source>
          <target state="translated">DOM에서 일치하는 요소 집합의 부모를 제거하고 일치하는 요소는 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="d953b02f2e1c98e517a3ac7edba80df822b4640d" translate="yes" xml:space="preserve">
          <source>Remove the set of matched elements from the DOM.</source>
          <target state="translated">DOM에서 일치하는 요소 세트를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="90873df9b35abbbc19ef0b528f7a8ab9dd986502" translate="yes" xml:space="preserve">
          <source>Remove the white spaces at the start and at the end of the string.</source>
          <target state="translated">문자열의 시작과 끝에서 공백을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d9ed199cbdfe853b660c8cc18fd4e7751a3b78a3" translate="yes" xml:space="preserve">
          <source>Remove the whitespace from the beginning and end of a string.</source>
          <target state="translated">문자열의 시작과 끝에서 공백을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="7f5026e26420d9b7f5049b09584701738205a71d" translate="yes" xml:space="preserve">
          <source>Removes all child nodes (including text nodes) from all paragraphs</source>
          <target state="translated">모든 단락에서 모든 자식 노드 (텍스트 노드 포함)를 제거합니다</target>
        </trans-unit>
        <trans-unit id="c7f59cdf9d384b47749940783c2d6b4773f8723c" translate="yes" xml:space="preserve">
          <source>Removes all elements that match &quot;div p.selected&quot; from the total set of all paragraphs.</source>
          <target state="translated">모든 단락의 총 집합에서 &quot;div p.selected&quot;와 일치하는 모든 요소를 ​​제거합니다.</target>
        </trans-unit>
        <trans-unit id="37dd8d8d2fcc8a4db7dbb9f9bf01ad407803263e" translate="yes" xml:space="preserve">
          <source>Removes all paragraphs from the DOM</source>
          <target state="translated">DOM에서 모든 단락을 제거합니다</target>
        </trans-unit>
        <trans-unit id="ae96008bae2dd4ce2502a89bb1b9295630c1fd4b" translate="yes" xml:space="preserve">
          <source>Removes all paragraphs that contain &quot;Hello&quot; from the DOM. Analogous to doing &lt;code&gt;$(&quot;p&quot;).filter(&quot;:contains('Hello')&quot;).remove()&lt;/code&gt;.</source>
          <target state="translated">DOM에서 &quot;Hello&quot;가 포함 된 모든 단락을 제거합니다. &lt;code&gt;$(&quot;p&quot;).filter(&quot;:contains('Hello')&quot;).remove()&lt;/code&gt; 하는 것과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="1b85b3186be49bd7f79de4ea6d43e176de0433c5" translate="yes" xml:space="preserve">
          <source>Removes any duplicate elements from the array of divs.</source>
          <target state="translated">div 배열에서 중복 요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="4654814c9db6ea1bc61d08a6712f03a793c22363" translate="yes" xml:space="preserve">
          <source>Removes the element with the ID &quot;selected&quot; from the set of all paragraphs.</source>
          <target state="translated">모든 단락 세트에서 ID가 &quot;선택된&quot;요소를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="81901ac43b3bb08696d37b0859394ec85057f9ca" translate="yes" xml:space="preserve">
          <source>Removing Specific Elements</source>
          <target state="translated">특정 요소 제거</target>
        </trans-unit>
        <trans-unit id="15c986757de465b6a45aa264a5bc85edcb733e56" translate="yes" xml:space="preserve">
          <source>Replace all paragraphs with bold words.</source>
          <target state="translated">모든 단락을 굵은 단어로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="78f70c0345c0da10bce4af147178b880384fb813" translate="yes" xml:space="preserve">
          <source>Replace all the paragraphs with bold words.</source>
          <target state="translated">모든 단락을 굵은 단어로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="c5ddda6c87c667d6334fcaaa7ba826763d2dc9d4" translate="yes" xml:space="preserve">
          <source>Replace each element in the set of matched elements with the provided new content and return the set of elements that was removed.</source>
          <target state="translated">일치하는 요소 세트의 각 요소를 제공된 새 컨텐츠로 바꾸고 제거 된 요소 세트를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="f7e1cf90a2e1c81d39b57137303df978f22de979" translate="yes" xml:space="preserve">
          <source>Replace each target element with the set of matched elements.</source>
          <target state="translated">각 대상 요소를 일치하는 요소 세트로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="53087331adad76acaddcc600bbcf93a9c82fcd8b" translate="yes" xml:space="preserve">
          <source>Report the index of some elements in the array.</source>
          <target state="translated">배열에서 일부 요소의 색인을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="5e9a3bf6a560aa64c830e9db0985d0dfcd0ba1e0" translate="yes" xml:space="preserve">
          <source>Request Method</source>
          <target state="translated">요청 방법</target>
        </trans-unit>
        <trans-unit id="4c76b1be4e3aa28fa4d06646fbe476d10b22e4e6" translate="yes" xml:space="preserve">
          <source>Request the test.php page and send some additional data along (while still ignoring the return results).</source>
          <target state="translated">test.php 페이지를 요청하고 추가 데이터를 함께 보내십시오 (반환 결과는 무시하십시오).</target>
        </trans-unit>
        <trans-unit id="24fc417d76f2849e2c64fcd03769a749fc4c02d4" translate="yes" xml:space="preserve">
          <source>Request the test.php page, but ignore the return results.</source>
          <target state="translated">test.php 페이지를 요청하지만 반환 결과는 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="74a6c861840d7edd4e3d07a6e162d87643f6ac6d" translate="yes" xml:space="preserve">
          <source>Resolve a Deferred object and call any doneCallbacks with the given args.</source>
          <target state="translated">Deferred 객체를 해결하고 주어진 인수로 doneCallback을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f310072e690bb2169c5202db5e456cb7ce4b4c1d" translate="yes" xml:space="preserve">
          <source>Resolve a Deferred object and call any doneCallbacks with the given context and args.</source>
          <target state="translated">Deferred 객체를 해결하고 주어진 컨텍스트 및 인수로 doneCallbacks를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="73056f4840fff864dd823e5950a43e004a50bc9a" translate="yes" xml:space="preserve">
          <source>Resolve a Deferred object when the user clicks a button, triggering a number of callback functions:</source>
          <target state="translated">사용자가 버튼을 클릭 할 때 지연된 객체를 해결하여 많은 콜백 함수를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="e738f391ed69af4fa52480f2a02b00f184f1e4e1" translate="yes" xml:space="preserve">
          <source>Resolve context and sole argument is the collection onto which &lt;code&gt;.promise()&lt;/code&gt; has been called.</source>
          <target state="translated">컨텍스트 및 단독 인수 해결은 &lt;code&gt;.promise()&lt;/code&gt; 가 호출 된 콜렉션 입니다.</target>
        </trans-unit>
        <trans-unit id="f5f000a270f03c338bfc34fcaa0468e090d85559" translate="yes" xml:space="preserve">
          <source>Resolve the returned Promise using a &lt;code&gt;$.when()&lt;/code&gt; statement (the &lt;code&gt;.promise()&lt;/code&gt; method makes it possible to do this with jQuery collections):</source>
          <target state="translated">&lt;code&gt;$.when()&lt;/code&gt; 문을 사용하여 리턴 된 Promise를 해결하십시오 ( &lt;code&gt;.promise()&lt;/code&gt; 메소드를 사용하면 jQuery 콜렉션으로이를 수행 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="d289e011b469f4a41e089433b54f9d3dc9dbfe03" translate="yes" xml:space="preserve">
          <source>Resolve the returned Promise when all animations have ended (including those initiated in the animation callback or added later on):</source>
          <target state="translated">모든 애니메이션이 종료되면 반환 된 약속을 해결합니다 (애니메이션 콜백에서 시작되거나 나중에 추가 된 애니메이션 포함).</target>
        </trans-unit>
        <trans-unit id="bd4afc0073cac79bf136f8e1d922b83f76e969ad" translate="yes" xml:space="preserve">
          <source>Result:</source>
          <target state="translated">Result:</target>
        </trans-unit>
        <trans-unit id="280702414af6806995b7134cb0d265cfea74a71c" translate="yes" xml:space="preserve">
          <source>Retrieval of shorthand CSS properties (e.g., &lt;code&gt;margin&lt;/code&gt;, &lt;code&gt;background&lt;/code&gt;, &lt;code&gt;border&lt;/code&gt;), although functional with some browsers, is not guaranteed. For example, if you want to retrieve the rendered &lt;code&gt;border-width&lt;/code&gt;, use: &lt;code&gt;$( elem ).css( &quot;borderTopWidth&quot; )&lt;/code&gt;, &lt;code&gt;$( elem ).css( &quot;borderBottomWidth&quot; )&lt;/code&gt;, and so on.</source>
          <target state="translated">일부 브라우저에서는 작동하지만 짧은 CSS 속성 (예 : &lt;code&gt;margin&lt;/code&gt; , &lt;code&gt;background&lt;/code&gt; , &lt;code&gt;border&lt;/code&gt; ) 검색은 보장되지 않습니다. 예를 들어, 렌더링 검색 할 경우 &lt;code&gt;border-width&lt;/code&gt; , 사용 : &lt;code&gt;$( elem ).css( &quot;borderTopWidth&quot; )&lt;/code&gt; , &lt;code&gt;$( elem ).css( &quot;borderBottomWidth&quot; )&lt;/code&gt; 등.</target>
        </trans-unit>
        <trans-unit id="1ae0f93946ed2805d7338f39fdd2b9f13fc9388d" translate="yes" xml:space="preserve">
          <source>Retrieve all the elements contained in the jQuery set, as an array.</source>
          <target state="translated">jQuery 세트에 포함 된 모든 요소를 ​​배열로 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="c47ebe06b994778f04553202da80384f93ec7ae5" translate="yes" xml:space="preserve">
          <source>Retrieve the DOM elements matched by the jQuery object.</source>
          <target state="translated">jQuery 객체와 일치하는 DOM 요소를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="9e479bed7e5542e5175525608c0a44b2c1fcf5d7" translate="yes" xml:space="preserve">
          <source>Retrieve the latest version of an HTML page.</source>
          <target state="translated">최신 버전의 HTML 페이지를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="4c85d59c181a8bdfec393789d72d1942cf54846f" translate="yes" xml:space="preserve">
          <source>Return Values</source>
          <target state="translated">반환 값</target>
        </trans-unit>
        <trans-unit id="0155f7262e902273c19d5e538a1316f003b2cec2" translate="yes" xml:space="preserve">
          <source>Return a Deferred&amp;rsquo;s Promise object.</source>
          <target state="translated">Deferred의 Promise 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3a487186e39ba43192e25c2d07c2ba9113b48b3a" translate="yes" xml:space="preserve">
          <source>Return a Promise object to observe when all actions of a certain type bound to the collection, queued or not, have finished.</source>
          <target state="translated">컬렉션에 바인딩 된 특정 유형의 모든 작업 (대기 중이 든 아니든)을 관찰하기 위해 Promise 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7824bc1b97268a438f40660068804ec96b80b110" translate="yes" xml:space="preserve">
          <source>Return a collection of matched elements either found in the DOM based on passed argument(s) or created by passing an HTML string.</source>
          <target state="translated">전달 된 인수를 기반으로 DOM에서 찾거나 HTML 문자열을 전달하여 생성 된 일치하는 요소의 컬렉션을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d9398e7ff5752487f63c609b69a5765a1fe72a74" translate="yes" xml:space="preserve">
          <source>Return a number representing the current time.</source>
          <target state="translated">현재 시간을 나타내는 숫자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3464e4fd44ebfd6076f392976403b0abe1c38fff" translate="yes" xml:space="preserve">
          <source>Return the number of elements in the jQuery object.</source>
          <target state="translated">jQuery 객체의 요소 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="48f6da53395f5dc902c90077711039058fa4bf40" translate="yes" xml:space="preserve">
          <source>Return the version number of the rendering engine used by the user's current browser. For example, FireFox 4 returns 2.0 (the version of the Gecko rendering engine it utilizes). &lt;strong&gt;Will not work in jQuery 1.9 or later&lt;/strong&gt; unless the &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate&lt;/a&gt; plugin is included.</source>
          <target state="translated">사용자의 현재 브라우저에서 사용하는 렌더링 엔진의 버전 번호를 반환합니다. 예를 들어 FireFox 4는 2.0 (Gecko 렌더링 엔진의 버전)을 반환합니다. &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate&lt;/a&gt; 플러그인이 포함되어 있지 않으면 &lt;strong&gt;jQuery 1.9 이상에서 작동&lt;/strong&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3356d67954770e949ba2366aec0fa96e10d6e04" translate="yes" xml:space="preserve">
          <source>Return true if the current useragent is some version of Microsoft's Internet Explorer. &lt;strong&gt;Will not work in jQuery 1.9 or later&lt;/strong&gt; unless the &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate&lt;/a&gt; plugin is included.</source>
          <target state="translated">현재 useragent가 Microsoft Internet Explorer의 일부 버전이면 true를 리턴하십시오. &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate&lt;/a&gt; 플러그인이 포함되어 있지 않으면 &lt;strong&gt;jQuery 1.9 이상에서 작동&lt;/strong&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f50100a0f1fca09b3a792dbaaaa792f960f542e" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;false&lt;/code&gt; from a handler is equivalent to calling both &lt;code&gt;.preventDefault()&lt;/code&gt; and &lt;code&gt;.stopPropagation()&lt;/code&gt; on the event object.</source>
          <target state="translated">핸들러에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하는 것은 이벤트 객체에서 &lt;code&gt;.preventDefault()&lt;/code&gt; 및 &lt;code&gt;.stopPropagation()&lt;/code&gt; 을 모두 호출하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="cacb5cbc3c9a29defe5998a16b32ad3376994a2c" translate="yes" xml:space="preserve">
          <source>Returning &lt;code&gt;false&lt;/code&gt; from an event handler will automatically call &lt;code&gt;event.stopPropagation()&lt;/code&gt; and &lt;code&gt;event.preventDefault()&lt;/code&gt;. A &lt;code&gt;false&lt;/code&gt; value can also be passed for the &lt;code&gt;handler&lt;/code&gt; as a shorthand for &lt;code&gt;function(){ return false; }&lt;/code&gt;. So, &lt;code&gt;$( &quot;a.disabled&quot; ).on( &quot;click&quot;, false );&lt;/code&gt; attaches an event handler to all links with class &quot;disabled&quot; that prevents them from being followed when they are clicked and also stops the event from bubbling.</source>
          <target state="translated">이벤트 핸들러에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 자동으로 &lt;code&gt;event.stopPropagation()&lt;/code&gt; 및 &lt;code&gt;event.preventDefault()&lt;/code&gt; 호출됩니다 . &lt;code&gt;false&lt;/code&gt; 값도 대해 전달 될 수있는 &lt;code&gt;handler&lt;/code&gt; 에 대한 속기로서 &lt;code&gt;function(){ return false; }&lt;/code&gt; . 따라서 &lt;code&gt;$( &quot;a.disabled&quot; ).on( &quot;click&quot;, false );&lt;/code&gt; &quot;disabled&quot;클래스가있는 모든 링크에 이벤트 핸들러를 연결하여 클릭시 링크를 따르지 못하게하고 이벤트 버블 링을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="5459c5e9a6bfcaa998770b0962a3243e0f3e2492" translate="yes" xml:space="preserve">
          <source>Returning an Empty Set</source>
          <target state="translated">빈 세트 반환</target>
        </trans-unit>
        <trans-unit id="359ee285db1ab3497383b24058b385819a29afb7" translate="yes" xml:space="preserve">
          <source>Returns -1, as there is no element with ID foobar.</source>
          <target state="translated">ID가 foobar 인 요소가 없으므로 -1을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="24601238c8e49ca9e38cd6023c2beef68041e041" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the Deferred object is in the rejected state, meaning that either &lt;a href=&quot;https://api.jquery.com/h/deferred.reject/&quot;&gt;&lt;code&gt;deferred.reject()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deferred.rejectwith&quot;&gt;&lt;code&gt;deferred.rejectWith()&lt;/code&gt;&lt;/a&gt; has been called for the object and the failCallbacks have been called (or are in the process of being called).</source>
          <target state="translated">Deferred 객체가 거부 된 상태에있는 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 즉, 객체에 대해 &lt;a href=&quot;https://api.jquery.com/h/deferred.reject/&quot;&gt; &lt;code&gt;deferred.reject()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deferred.rejectwith&quot;&gt; &lt;code&gt;deferred.rejectWith()&lt;/code&gt; &lt;/a&gt; 가 호출되었고 failCallbacks가 호출되었거나 호출 중임을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="9dedf983f3b1620c2ac4eee00b8ab8ef38a14955" translate="yes" xml:space="preserve">
          <source>Returns &lt;code&gt;true&lt;/code&gt; if the Deferred object is in the resolved state, meaning that either &lt;a href=&quot;deferred.resolve&quot;&gt;&lt;code&gt;deferred.resolve()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deferred.resolvewith&quot;&gt;&lt;code&gt;deferred.resolveWith()&lt;/code&gt;&lt;/a&gt; has been called for the object and the doneCallbacks have been called (or are in the process of being called).</source>
          <target state="translated">Deferred 객체가 해결 된 상태에있는 경우 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다. 즉, 객체에 대해 &lt;a href=&quot;deferred.resolve&quot;&gt; &lt;code&gt;deferred.resolve()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deferred.resolvewith&quot;&gt; &lt;code&gt;deferred.resolveWith()&lt;/code&gt; &lt;/a&gt; 가 호출되었고 doneCallbacks가 호출되었거나 호출되고 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e66d7a2f48c78a417819b8c659a7fcf4b7bec23" translate="yes" xml:space="preserve">
          <source>Returns a boolean value (&lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;) that indicates whether or not the</source>
          <target state="translated">부울 값 ( &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; )을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d1ad30f7b515023713d6bc9f31009a6f3048d871" translate="yes" xml:space="preserve">
          <source>Returns an object containing the properties &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;top&lt;/code&gt; 및 &lt;code&gt;left&lt;/code&gt; 속성이 포함 된 객체를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a21a8e38cb37e60f58b7163fc87dcac1a82a39dd" translate="yes" xml:space="preserve">
          <source>Returns false, because the parent of the input is a p element.</source>
          <target state="translated">입력의 부모가 ap 요소이므로 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d2be479c7c43a070dda61fc193794309f667f58" translate="yes" xml:space="preserve">
          <source>Returns the height of the element, including top and bottom padding, border, and optionally margin, in pixels. If called on an empty set of elements, returns &lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;null&lt;/code&gt; before jQuery 3.0).</source>
          <target state="translated">상단 및 하단 패딩, 테두리 및 선택적으로 여백을 포함하여 요소의 높이를 픽셀 단위로 반환합니다. 빈 요소 집합에서 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 ( jQuery 3.0 이전의 &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bcb06190361244e70900f5938f0e2cd4070df363" translate="yes" xml:space="preserve">
          <source>Returns the index for the element with ID bar in relation to all &amp;lt;li&amp;gt; elements.</source>
          <target state="translated">모든 &amp;lt;li&amp;gt; 요소와 관련하여 ID 막대가있는 요소의 색인을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b29dc2ed2dd9462cb6949e7b4789acfe0862cff6" translate="yes" xml:space="preserve">
          <source>Returns the index for the element with ID bar in relation to its siblings.</source>
          <target state="translated">형제와 관련하여 ID 막대가있는 요소의 색인을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="14ebfc0e4de6cfe7d96bc5e85c508d46356efb50" translate="yes" xml:space="preserve">
          <source>Returns the index for the element with ID bar.</source>
          <target state="translated">ID 막대가있는 요소의 색인을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bb8639b984c5a451bd2d2390409acfd9250e304" translate="yes" xml:space="preserve">
          <source>Returns the index for the first item in the jQuery collection.</source>
          <target state="translated">jQuery 컬렉션의 첫 번째 항목에 대한 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b393ec4b75484f575ba14d5e0739f81c6524f060" translate="yes" xml:space="preserve">
          <source>Returns the width of the element, including left and right padding, border, and optionally margin, in pixels. If called on an empty set of elements, returns &lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;null&lt;/code&gt; before jQuery 3.0).</source>
          <target state="translated">왼쪽 및 오른쪽 여백, 테두리 및 선택적으로 여백을 포함하여 요소의 너비를 픽셀 단위로 반환합니다. 빈 요소 집합에서 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 ( jQuery 3.0 이전의 &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a7ad448c0457fa47085de3d60015cdbdafb46dd4" translate="yes" xml:space="preserve">
          <source>Returns true, because the parent of the input is a form element.</source>
          <target state="translated">입력의 상위가 양식 요소이므로 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4c048a48626665bb693a24abc82365df59c00522" translate="yes" xml:space="preserve">
          <source>Returns whether event.preventDefault() was ever called on this event object.</source>
          <target state="translated">이 이벤트 객체에서 event.preventDefault ()가 호출되었는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0095bf521db1230ef8902af7b50cd23331098004" translate="yes" xml:space="preserve">
          <source>Returns whether event.stopImmediatePropagation() was ever called on this event object.</source>
          <target state="translated">이 이벤트 객체에서 event.stopImmediatePropagation ()이 호출되었는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="46408a9586a191033969c174efbd68f66d5fd561" translate="yes" xml:space="preserve">
          <source>Returns whether event.stopPropagation() was ever called on this event object.</source>
          <target state="translated">이 이벤트 객체에서 event.stopPropagation ()이 호출되었는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0074c61ba5de3729c365c438f4ab6d87823e2ac4" translate="yes" xml:space="preserve">
          <source>Revert the $ alias and then create and execute a function to provide the $ as a jQuery alias inside the function's scope. Inside the function the original $ object is not available. This works well for most plugins that don't rely on any other library.</source>
          <target state="translated">$ 별명을 되 돌린 후 함수 범위 내에서 $를 jQuery 별명으로 제공하는 함수를 작성하고 실행하십시오. 함수 내에서 원래 $ 객체를 사용할 수 없습니다. 이것은 다른 라이브러리에 의존하지 않는 대부분의 플러그인에 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="1559488e7282166b90ea314062f1988b483f6a31" translate="yes" xml:space="preserve">
          <source>Rewriting the &lt;code&gt;.live()&lt;/code&gt; method in terms of its successors is straightforward; these are templates for equivalent calls for all three event attachment methods:</source>
          <target state="translated">후속 작업의 관점에서 &lt;code&gt;.live()&lt;/code&gt; 메서드를 다시 작성하는 것은 간단합니다. 다음은 세 가지 이벤트 첨부 메소드 모두에 대한 동등한 호출 템플리트입니다.</target>
        </trans-unit>
        <trans-unit id="6aa2379f312caadc948aa7a9d8a823935a9b92fe" translate="yes" xml:space="preserve">
          <source>Right click to toggle background color.</source>
          <target state="translated">마우스 오른쪽 버튼을 클릭하여 배경색을 전환합니다.</target>
        </trans-unit>
        <trans-unit id="cf8d2fa5b636bb50d3b782f2addcd9107ff85896" translate="yes" xml:space="preserve">
          <source>Run a function when the page is fully loaded including graphics.</source>
          <target state="translated">그래픽을 포함하여 페이지가 완전히로드되면 기능을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="660eab7cf7994345058c6792c429efba21c440ff" translate="yes" xml:space="preserve">
          <source>Safari/Webkit: 312.8, 418.9</source>
          <target state="translated">사파리 / 웹킷 : 312.8, 418.9</target>
        </trans-unit>
        <trans-unit id="b481f8b8e77e092a5a1b352b75b3cfd0447e1ee8" translate="yes" xml:space="preserve">
          <source>Same as above, but will POST the additional parameters to the server and a callback that is executed when the server is finished responding.</source>
          <target state="translated">위와 동일하지만 추가 매개 변수를 서버에 POST하고 서버 응답이 완료되면 실행되는 콜백을 POST합니다.</target>
        </trans-unit>
        <trans-unit id="a3b49cbd8336bc28d30035edac48de5804dc67f0" translate="yes" xml:space="preserve">
          <source>Sample return values of $.isNumeric with various inputs.</source>
          <target state="translated">다양한 입력을 가진 $ .isNumeric의 샘플 반환 값.</target>
        </trans-unit>
        <trans-unit id="0abcd8e11817cf7c75bccd6c0aefcb91a6a3cf65" translate="yes" xml:space="preserve">
          <source>Save some data to the server and notify the user once it's complete.</source>
          <target state="translated">일부 데이터를 서버에 저장하고 완료되면 사용자에게 알리십시오.</target>
        </trans-unit>
        <trans-unit id="4651a34e4df9619783ad372f905d6d3b84e9d76d" translate="yes" xml:space="preserve">
          <source>Scope</source>
          <target state="translated">Scope</target>
        </trans-unit>
        <trans-unit id="00b39d4a46acdaf195c97b325431ddaef25894ae" translate="yes" xml:space="preserve">
          <source>Script Execution</source>
          <target state="translated">스크립트 실행</target>
        </trans-unit>
        <trans-unit id="202dac1e22c03c214a8f5fffd9f44b1b2cb618ae" translate="yes" xml:space="preserve">
          <source>Script and JSONP requests are not subject to the same origin policy restrictions.</source>
          <target state="translated">스크립트 및 JSONP 요청에는 동일한 원본 정책 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cf964fefbb3826fdff4af7269ed955c203ad06cc" translate="yes" xml:space="preserve">
          <source>Scripts are included and run by referencing the file name:</source>
          <target state="translated">파일 이름을 참조하여 스크립트가 포함 및 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="e04c0f959a533f174ee286d4e56b7848c0439cfb" translate="yes" xml:space="preserve">
          <source>Search for a given element from among the matched elements.</source>
          <target state="translated">일치하는 요소 중에서 지정된 요소를 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="1a8f35ce561245fefe97e75ccbff02e4aa1d777d" translate="yes" xml:space="preserve">
          <source>Search for a specified value within an array and return its index (or -1 if not found).</source>
          <target state="translated">배열 내에서 지정된 값을 검색하고 해당 색인 (또는 찾지 못한 경우 -1)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3874eae2f04a120390034d50dccc5a447635329f" translate="yes" xml:space="preserve">
          <source>Second handler for .toggle() called.</source>
          <target state="translated">.toggle ()의 두 번째 핸들러가 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="402cc3b6686cd294cb10dd3f5bccbebd0edd8a9b" translate="yes" xml:space="preserve">
          <source>Security Considerations</source>
          <target state="translated">보안 고려 사항</target>
        </trans-unit>
        <trans-unit id="ba92a10db1bf37a49ca690a32bfa35980a52d5b7" translate="yes" xml:space="preserve">
          <source>See also &lt;code&gt;&lt;a href=&quot;ready&quot;&gt;ready()&lt;/a&gt;&lt;/code&gt;, which makes use of this.</source>
          <target state="translated">이것을 사용하는 &lt;code&gt;&lt;a href=&quot;ready&quot;&gt;ready()&lt;/a&gt;&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee12851f210aec736c2971ffe71428d322573012" translate="yes" xml:space="preserve">
          <source>See the &lt;code&gt;.trigger()&lt;/code&gt; method reference for a way to pass data to a handler at the time the event happens rather than when the handler is bound.</source>
          <target state="translated">핸들러가 바인드되지 않고 이벤트가 발생할 때 핸들러에 데이터를 전달하는 방법에 대해서는 &lt;code&gt;.trigger()&lt;/code&gt; 메소드 참조를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="515509590fc48d1dfc5e4f8b29143dbb8193f498" translate="yes" xml:space="preserve">
          <source>See the discussions for &lt;code&gt;&lt;a href=&quot;mouseenter&quot;&gt;.mouseenter()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mouseleave&quot;&gt;.mouseleave()&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;mouseenter&quot;&gt;.mouseenter()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;mouseleave&quot;&gt;.mouseleave()&lt;/a&gt;&lt;/code&gt; 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="782b628d4d91647edbbce286bebc3f11f6b99ff5" translate="yes" xml:space="preserve">
          <source>Select all divs and filter the selection with a DOM element, keeping only the one with an id of &quot;unique&quot;.</source>
          <target state="translated">모든 div를 선택하고 DOM 요소로 선택을 필터링하여 id가 &quot;unique&quot;인 하나만 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="9e24ae5dde661b4bad6278b284056442f482322b" translate="yes" xml:space="preserve">
          <source>Select all divs and filter the selection with a jQuery object, keeping only the one with an id of &quot;unique&quot;.</source>
          <target state="translated">모든 div를 선택하고 jQuery 객체로 선택을 필터링하여 ID가 ​​&quot;unique&quot;인 것을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="cbe0d297ed30bdc4c075085c5b9677952e2bd8b1" translate="yes" xml:space="preserve">
          <source>Select all divs in the document and return the DOM Elements as an Array; then use the built-in reverse() method to reverse that array.</source>
          <target state="translated">문서에서 모든 div를 선택하고 DOM 요소를 배열로 반환하십시오. 그런 다음 내장 reverse () 메소드를 사용하여 해당 배열을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="7855e410bbda7d87687eb82cfb4112e06544d1a0" translate="yes" xml:space="preserve">
          <source>Select all elements at an index greater than index within the matched set.</source>
          <target state="translated">일치하는 세트 내의 색인보다 큰 색인의 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="cebb6b46e90078f144ce6f483dfb711b165e3784" translate="yes" xml:space="preserve">
          <source>Select all elements at an index less than index within the matched set.</source>
          <target state="translated">일치하는 세트 내의 색인보다 작은 색인의 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="6a16c88e4d2edf25e57b22ad8845aa0937c94c4e" translate="yes" xml:space="preserve">
          <source>Select all elements that are in the progress of an animation at the time the selector is run.</source>
          <target state="translated">선택기가 실행될 때 애니메이션 진행중인 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="2a0cff81da7ea1b148eaa387d47ad1b088d95c5d" translate="yes" xml:space="preserve">
          <source>Select all elements that contain the specified text.</source>
          <target state="translated">지정된 텍스트가 포함 된 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="4e332684bab3aa1a45286a9f9d226898372975c7" translate="yes" xml:space="preserve">
          <source>Select all elements that have at least one child node (either an element or text).</source>
          <target state="translated">하나 이상의 자식 노드 (요소 또는 텍스트)가있는 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="078d5d9e1ff6edf0eba91a609de0c95367226ef3" translate="yes" xml:space="preserve">
          <source>Select all elements that have no children (including text nodes).</source>
          <target state="translated">자식이없는 모든 요소 (텍스트 노드 포함)를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="ed11e68f046d8dabef9e45adfed2a810b3f9160b" translate="yes" xml:space="preserve">
          <source>Select all the elements having a class name of &lt;code&gt;.box&lt;/code&gt; inside a &lt;code&gt;div&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;div&lt;/code&gt; 안에 클래스 이름이 &lt;code&gt;.box&lt;/code&gt; 인 모든 요소를 ​​선택하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ed3b7be96f2dbb88cd55ce061c434ce96bdeed1" translate="yes" xml:space="preserve">
          <source>Select elements that either don&amp;rsquo;t have the specified attribute, or do have the specified attribute but not with a certain value.</source>
          <target state="translated">지정된 속성이 없거나 지정된 속성이 있지만 특정 값이없는 요소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="5f6f1aa373c70e29d01f0f02d129effcd00f3046" translate="yes" xml:space="preserve">
          <source>Select the element at index n within the matched set.</source>
          <target state="translated">일치하는 세트 내에서 인덱스 n의 요소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="a0aec192d97708ea18466b753f9630549839da5e" translate="yes" xml:space="preserve">
          <source>Select the element with the id &quot;myDiv&quot; and give it a red border.</source>
          <target state="translated">ID가 &quot;myDiv&quot;인 요소를 선택하고 빨간색 테두리를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="184e3b053c117cadb8f38a32ba7ea866723de909" translate="yes" xml:space="preserve">
          <source>Select the element with the id &quot;myID.entry[1]&quot; and give it a red border. Note how certain characters must be escaped with backslashes.</source>
          <target state="translated">ID가 &quot;myID.entry [1]&quot;인 요소를 선택하고 빨간색 테두리를 지정하십시오. 백 슬래시를 사용하여 특정 문자를 이스케이프 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbc01c4deea127c5fcc07581ab0c87fd938aefa0" translate="yes" xml:space="preserve">
          <source>Selected elements are in the order of their appearance in the document.</source>
          <target state="translated">선택한 요소는 문서에서 나타나는 순서대로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b240d04328a96aac53d166b5299cca81675589d4" translate="yes" xml:space="preserve">
          <source>Selector</source>
          <target state="translated">Selector</target>
        </trans-unit>
        <trans-unit id="a011a21a85c92351b0a96fb4148afac97921c94e" translate="yes" xml:space="preserve">
          <source>Selector Context</source>
          <target state="translated">선택기 컨텍스트</target>
        </trans-unit>
        <trans-unit id="4df28d2cb8a74e0553a8b501f660f7fd482671ed" translate="yes" xml:space="preserve">
          <source>Selectors</source>
          <target state="translated">Selectors</target>
        </trans-unit>
        <trans-unit id="63116277109d7d97ce78872faa8c5b4a7e78c9ad" translate="yes" xml:space="preserve">
          <source>Selects a single element with the given id attribute.</source>
          <target state="translated">주어진 id 속성을 가진 단일 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="482db93da8e164b9b15b7851fb58f4b7485ddf00" translate="yes" xml:space="preserve">
          <source>Selects all button elements and elements of type button.</source>
          <target state="translated">모든 버튼 요소와 버튼 유형의 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="3b9f66e97b3951a19308af594b4428e8f3fd8c91" translate="yes" xml:space="preserve">
          <source>Selects all direct child elements specified by &amp;ldquo;child&amp;rdquo; of elements specified by &amp;ldquo;parent&amp;rdquo;.</source>
          <target state="translated">&amp;ldquo;parent&amp;rdquo;로 지정된 요소 중&amp;ldquo;child&amp;rdquo;로 지정된 모든 직접 하위 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ef672f0c3a28f7f033a7dcbc0a7617c7eb5fd4d2" translate="yes" xml:space="preserve">
          <source>Selects all elements of the specified language.</source>
          <target state="translated">지정된 언어의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="685a95b7c8b8e8075d10bae8c93c1e49b86d0916" translate="yes" xml:space="preserve">
          <source>Selects all elements of type checkbox.</source>
          <target state="translated">유형의 모든 요소 확인란을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="729ba3926411637f6f92f2c5a8b1914bc62c7ed5" translate="yes" xml:space="preserve">
          <source>Selects all elements of type file.</source>
          <target state="translated">파일 형식의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="55f79e80dac38c8c301c8991025d4d361d7a906e" translate="yes" xml:space="preserve">
          <source>Selects all elements of type image.</source>
          <target state="translated">이미지 유형의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="d34fd4cfbc0399e6b2df0f37aace806c64a4aff7" translate="yes" xml:space="preserve">
          <source>Selects all elements of type password.</source>
          <target state="translated">비밀번호 유형의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="192e0aacd3796ba9c13cfe7c6bcd3f583a2319e5" translate="yes" xml:space="preserve">
          <source>Selects all elements of type radio.</source>
          <target state="translated">라디오 유형의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="dea966d1699da730e5da44991d47a4dad2469c8a" translate="yes" xml:space="preserve">
          <source>Selects all elements of type reset.</source>
          <target state="translated">재설정 유형의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="987673eb93dba4606dfa7dcb9aa307074d61d7f7" translate="yes" xml:space="preserve">
          <source>Selects all elements of type submit.</source>
          <target state="translated">제출 유형의 모든 요소를 ​​선택하십시오.</target>
        </trans-unit>
        <trans-unit id="b46fc94979eabceeefefadcb7eb1c9fefdf76622" translate="yes" xml:space="preserve">
          <source>Selects all elements that are descendants of a given ancestor.</source>
          <target state="translated">주어진 조상의 후손 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="1a2f603851e201c12f75a1069d11f1cb3d8cfc13" translate="yes" xml:space="preserve">
          <source>Selects all elements that are disabled.</source>
          <target state="translated">비활성화 된 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="081277be0ebc8652f793ffddd406046bc39328e7" translate="yes" xml:space="preserve">
          <source>Selects all elements that are enabled.</source>
          <target state="translated">활성화 된 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="38e5ee2ab29fb97bf2d880192e4ba13d80f49fe2" translate="yes" xml:space="preserve">
          <source>Selects all elements that are headers, like h1, h2, h3 and so on.</source>
          <target state="translated">h1, h2, h3 등과 같이 헤더 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="26e6c5d52d7420f51b1c55caf7b42dc914aed0ba" translate="yes" xml:space="preserve">
          <source>Selects all elements that are hidden.</source>
          <target state="translated">숨겨진 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="c40bee64ad5f728527b96e701535aebabf850663" translate="yes" xml:space="preserve">
          <source>Selects all elements that are selected.</source>
          <target state="translated">선택된 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="1b12630f2059e80cfc555f557f369d2665cf95e8" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the first among siblings of the same element name.</source>
          <target state="translated">동일한 요소 이름의 형제 중 첫 번째 요소를 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="fb8f6ff10437a0d5ca2c23bc1b677e18d4ca7759" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the first child of their parent.</source>
          <target state="translated">부모의 첫 번째 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="a4ba5db42bd0a7552cba89a906e47a3099d8e085" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the last among siblings of the same element name.</source>
          <target state="translated">동일한 요소 이름의 형제 중 마지막 요소를 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="45549a1c55d46c0024d955d6df5a947b2244e626" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the last child of their parent.</source>
          <target state="translated">부모의 마지막 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="5613b91eb8e4a91b0b62860da066a6409a5da41f" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the nth child of their parent in relation to siblings with the same element name.</source>
          <target state="translated">동일한 요소 이름을 가진 형제와 관련하여 부모의 n 번째 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="b8d0cf76044daf07017ffbe5139c0b5be66be6e3" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the nth-child of their parent, counting from the last element to the first.</source>
          <target state="translated">마지막 요소부터 첫 번째 요소까지 세어 부모의 n 번째 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="f6a62951da436f74e1779c00a0d2636092fcd06f" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the nth-child of their parent.</source>
          <target state="translated">부모의 n 번째 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="0b756624b2efc7b2d985cec25dbd9d959cbf5542" translate="yes" xml:space="preserve">
          <source>Selects all elements that are the only child of their parent.</source>
          <target state="translated">부모의 유일한 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="c33f0d3cfa91120c35c1a70d896db8fa10fa5cfa" translate="yes" xml:space="preserve">
          <source>Selects all elements that are visible.</source>
          <target state="translated">보이는 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="42d4c24b60721feb1dd9d648286569d67c6decf2" translate="yes" xml:space="preserve">
          <source>Selects all elements that do not match the given selector.</source>
          <target state="translated">주어진 선택기와 일치하지 않는 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="6cffcf142b731498a68da13d990cb3881c08f3a7" translate="yes" xml:space="preserve">
          <source>Selects all elements that have no siblings with the same element name.</source>
          <target state="translated">요소 이름이 같은 형제가없는 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="db68910a7f845b35cad42db773fd76e022bbe51e" translate="yes" xml:space="preserve">
          <source>Selects all elements with the given class.</source>
          <target state="translated">주어진 클래스의 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="735daee6abc2bc6517bec931773efa945ec5f209" translate="yes" xml:space="preserve">
          <source>Selects all elements with the given tag name.</source>
          <target state="translated">주어진 태그 이름을 가진 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="2f12468efd2facd408d097c678258691580c27ac" translate="yes" xml:space="preserve">
          <source>Selects all elements.</source>
          <target state="translated">모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="c1dd09ad2abd8bb82a9497a60d0c74bead91f016" translate="yes" xml:space="preserve">
          <source>Selects all input elements of type text.</source>
          <target state="translated">텍스트 유형의 모든 입력 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="67a140314a46ae08098b1cf57a72cd5e5b79dbf8" translate="yes" xml:space="preserve">
          <source>Selects all input, textarea, select and button elements.</source>
          <target state="translated">모든 입력, 텍스트 영역, 선택 및 버튼 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e98be8e688a58a0d9de44bd93af5f4d660a54186" translate="yes" xml:space="preserve">
          <source>Selects all next elements matching &amp;ldquo;next&amp;rdquo; that are immediately preceded by a sibling &amp;ldquo;prev&amp;rdquo;.</source>
          <target state="translated">형제 &quot;prev&quot;바로 앞에 오는 &quot;next&quot;와 일치하는 모든 다음 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="babcc76f8a2eaf292d41e9909b833b8237f646ae" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs and wraps a bold tag around each of its contents.</source>
          <target state="translated">모든 단락을 선택하고 각 내용을 굵게 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a36835c1acf647c040ba63700c2b735fd5c7fc17" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs and wraps a jQuery object around each of its contents.</source>
          <target state="translated">모든 단락을 선택하고 각 내용을 중심으로 jQuery 객체를 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="5a4bed91efb6f9a5909cee1551b5f05d2ea34bcc" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, finds span elements inside these, and reverts the selection back to the paragraphs.</source>
          <target state="translated">모든 단락을 선택하고 해당 범위 내의 범위 요소를 찾은 다음 선택 항목을 다시 단락으로 되돌립니다.</target>
        </trans-unit>
        <trans-unit id="3e93b210ae8a95c62b43b6793d537e7f57acf9b4" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, then slices the selection to include only the first and second element.</source>
          <target state="translated">모든 단락을 선택한 다음 첫 번째와 두 번째 요소 만 포함하도록 선택 영역을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="40adcf5a3954c3a02b0e9920716d96f0495862a7" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, then slices the selection to include only the first element.</source>
          <target state="translated">모든 단락을 선택한 다음 첫 번째 요소 만 포함하도록 선택 영역을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="ec45fca921a8472039aed007f1489458e13f5e14" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, then slices the selection to include only the second and third element.</source>
          <target state="translated">모든 단락을 선택한 다음 두 번째 및 세 번째 요소 만 포함하도록 선택 영역을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="f73e8e58454342c473503c63ec8b67e25eff53a9" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, then slices the selection to include only the second element.</source>
          <target state="translated">모든 단락을 선택한 다음 두 번째 요소 만 포함하도록 선택 영역을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="4a7f2a84a50d64036622e9ea7f84c18196201fcb" translate="yes" xml:space="preserve">
          <source>Selects all paragraphs, then slices the selection to include only the third element.</source>
          <target state="translated">모든 단락을 선택한 다음 세 번째 요소 만 포함하도록 선택 영역을 분할합니다.</target>
        </trans-unit>
        <trans-unit id="6dfd21f77934c962c426762b941607d856ccd3d9" translate="yes" xml:space="preserve">
          <source>Selects all sibling elements that follow after the &amp;ldquo;prev&amp;rdquo; element, have the same parent, and match the filtering &amp;ldquo;siblings&amp;rdquo; selector.</source>
          <target state="translated">&quot;prev&quot;요소 다음에 오는 모든 형제 요소를 선택하고 동일한 부모를 가지며 필터링 &quot;siblings&quot;선택기와 일치시킵니다.</target>
        </trans-unit>
        <trans-unit id="a1df6d8eebdb436cfb94e26403dd9dd4e367a2a1" translate="yes" xml:space="preserve">
          <source>Selects all the elements that are the nth-child of their parent in relation to siblings with the same element name, counting from the last element to the first.</source>
          <target state="translated">마지막 요소부터 첫 번째 요소까지 세는 동일한 요소 이름을 가진 형제와 관련하여 부모의 n 번째 자식 인 모든 요소를 ​​선택합니다.</target>
        </trans-unit>
        <trans-unit id="312ea0332b53f2d1c1ca581f055d2ebc1e2ffad0" translate="yes" xml:space="preserve">
          <source>Selects element if it is currently focused.</source>
          <target state="translated">현재 초점이 맞춰진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1e7db4b62b14c64c2e4cda50f4bf4783bb8620fd" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value beginning exactly with a given string.</source>
          <target state="translated">주어진 문자열로 정확하게 시작하는 값을 가진 지정된 속성을 가진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="d63e53805e9ae87e087a6c4a2e272a6ba8b049f4" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value containing a given substring.</source>
          <target state="translated">주어진 부분 문자열을 포함하는 값으로 지정된 속성을 가진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0fec2cdb00e09613c374738870cc066ab8656d06" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value containing a given word, delimited by spaces.</source>
          <target state="translated">주어진 단어를 포함하는 값으로 지정된 속성을 가진 요소를 공백으로 구분하여 선택합니다.</target>
        </trans-unit>
        <trans-unit id="79509ca2d65ee7fcb7c2f017f07b922c6fba591c" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value either equal to a given string or starting with that string followed by a hyphen (-).</source>
          <target state="translated">지정된 문자열과 같거나 해당 문자열로 시작하여 하이픈 (-)으로 지정된 속성을 가진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="7d140cea9061a89351adf37936c907030724897b" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value ending exactly with a given string. The comparison is case sensitive.</source>
          <target state="translated">주어진 문자열로 정확하게 끝나는 값을 가진 지정된 속성을 가진 요소를 선택합니다. 비교는 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="6bf83f200cc3513db41d467baef2dc38b33ece19" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute with a value exactly equal to a certain value.</source>
          <target state="translated">특정 값과 정확히 동일한 값을 가진 지정된 속성을 가진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e85f9af968eff1005189e62ff883be9f5f43b779" translate="yes" xml:space="preserve">
          <source>Selects elements that have the specified attribute, with any value.</source>
          <target state="translated">값이 지정된 지정된 속성을 가진 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="0bd58b1254b6b26c9b64245aa8dc2848547a1b12" translate="yes" xml:space="preserve">
          <source>Selects elements which contain at least one element that matches the specified selector.</source>
          <target state="translated">지정된 선택기와 일치하는 요소가 하나 이상 포함 된 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="bb8098251a2d5dddf2c727e3d9305899015fbdc5" translate="yes" xml:space="preserve">
          <source>Selects even elements, zero-indexed. See also :odd.</source>
          <target state="translated">인덱스가 0 인 짝수 요소를 선택합니다. : odd도 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7e1685294709e1c314ca9794952e46def1ccffc8" translate="yes" xml:space="preserve">
          <source>Selects even elements, zero-indexed. See also odd.</source>
          <target state="translated">인덱스가없는 짝수 요소를 선택합니다. 홀수 참조.</target>
        </trans-unit>
        <trans-unit id="ddf9894cd11d15fcd2657689963b9ac71094adbe" translate="yes" xml:space="preserve">
          <source>Selects odd elements, zero-indexed. See also :even.</source>
          <target state="translated">인덱스가 0 인 홀수 요소를 선택합니다. 참조 : even.</target>
        </trans-unit>
        <trans-unit id="46aa50381d2d25466bef54d53815431b627d34bc" translate="yes" xml:space="preserve">
          <source>Selects odd elements, zero-indexed. See also even.</source>
          <target state="translated">인덱스가없는 홀수 요소를 선택합니다. 짝수 참조.</target>
        </trans-unit>
        <trans-unit id="5622e64ee47169c9d0b5c6a2d78bb2292d00e373" translate="yes" xml:space="preserve">
          <source>Selects the combined results of all the specified selectors.</source>
          <target state="translated">지정된 모든 선택기의 결합 된 결과를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="4230b70ef603ecf99fe4ec7887bd23aebeedc064" translate="yes" xml:space="preserve">
          <source>Selects the element that is the root of the document.</source>
          <target state="translated">문서의 루트 인 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="49fed8752aaf1e141ae7f7d82020c77946dd72e7" translate="yes" xml:space="preserve">
          <source>Selects the first matched DOM element.</source>
          <target state="translated">일치하는 첫 번째 DOM 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2c838dc34a573624d02bead0b7f78130d08b37fb" translate="yes" xml:space="preserve">
          <source>Selects the last matched element.</source>
          <target state="translated">마지막으로 일치하는 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="1a2d74b9291de2f58c0821fcefd52a614afff7c7" translate="yes" xml:space="preserve">
          <source>Selects the target element indicated by the fragment identifier of the document&amp;rsquo;s URI.</source>
          <target state="translated">문서 URI의 조각 식별자로 표시되는 대상 요소를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2122d88e2a64d624031df153ff3972e8b9ccc281" translate="yes" xml:space="preserve">
          <source>Send an id as data to the server, save some data to the server, and notify the user once it's complete. If the request fails, alert the user.</source>
          <target state="translated">ID를 서버에 데이터로 보내고 일부 데이터를 서버에 저장하고 완료되면 사용자에게 알립니다. 요청이 실패하면 사용자에게 알리십시오.</target>
        </trans-unit>
        <trans-unit id="8658ae1466bf527e3dd6d98e514ecee8b2407051" translate="yes" xml:space="preserve">
          <source>Send an xml document as data to the server. By setting the processData option to &lt;code&gt;false&lt;/code&gt;, the automatic conversion of data to strings is prevented.</source>
          <target state="translated">XML 문서를 서버로 데이터로 보냅니다. processData 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 데이터를 문자열로 자동 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cfeaf157e7c56723921c0be996a0d8049614529b" translate="yes" xml:space="preserve">
          <source>Send data to the server using a HTTP POST request.</source>
          <target state="translated">HTTP POST 요청을 사용하여 서버에 데이터를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f0fef2b9897872624f0e3c46dd2f2183fdfe4a41" translate="yes" xml:space="preserve">
          <source>Send form data using Ajax requests</source>
          <target state="translated">Ajax 요청을 사용하여 양식 데이터 전송</target>
        </trans-unit>
        <trans-unit id="be8b3341b920b4556b27849ea3923b035e535304" translate="yes" xml:space="preserve">
          <source>Sending Data to the Server</source>
          <target state="translated">서버로 데이터 전송</target>
        </trans-unit>
        <trans-unit id="a144807841a866abac7a53c6a9b994f2e222cbcd" translate="yes" xml:space="preserve">
          <source>Serialize a few complex objects</source>
          <target state="translated">몇 가지 복잡한 개체를 직렬화</target>
        </trans-unit>
        <trans-unit id="63ed5c2f8e78737fd1b3ff7eb6e1b49ee3fd6932" translate="yes" xml:space="preserve">
          <source>Serialize a form to a query string that could be sent to a server in an Ajax request.</source>
          <target state="translated">Ajax 요청에서 서버로 전송 될 수있는 쿼리 문자열로 양식을 직렬화하십시오.</target>
        </trans-unit>
        <trans-unit id="4043fe2f1e4cc1ee5d8c65c313d48f13fbe5266c" translate="yes" xml:space="preserve">
          <source>Serialize a key/value object.</source>
          <target state="translated">키 / 값 객체를 직렬화합니다.</target>
        </trans-unit>
        <trans-unit id="2850b89694c0db105340f97fab4f4f0df4f4daae" translate="yes" xml:space="preserve">
          <source>Set a data store for 2 names then remove one of them.</source>
          <target state="translated">2 개의 이름으로 데이터 저장소를 설정 한 후 그 중 하나를 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="d3d5f0b576f04613a8af8da1221bad86abac9bb8" translate="yes" xml:space="preserve">
          <source>Set a numeric property on a paragraph and then remove it.</source>
          <target state="translated">단락에 숫자 속성을 설정 한 다음 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="415e9fa442913c0ff5bb0b2da457a3e5aa4630ea" translate="yes" xml:space="preserve">
          <source>Set a queue array to delete the queue.</source>
          <target state="translated">대기열을 삭제하도록 대기열 배열을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="01fda2b6f88cc560db78cdb5721b1d4bf9e5ab95" translate="yes" xml:space="preserve">
          <source>Set a single select, a multiple select, checkboxes and a radio button .</source>
          <target state="translated">단일 선택, 다중 선택, 확인란 및 단일 선택 단추를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="dcd7e7e02ddf83e40cbae07a5022ad13b4ff3295" translate="yes" xml:space="preserve">
          <source>Set a timeout (in milliseconds) for the request. A value of 0 means there will be no timeout. This will override any global timeout set with &lt;a href=&quot;jquery.ajaxsetup&quot;&gt;$.ajaxSetup()&lt;/a&gt;. The timeout period starts at the point the &lt;code&gt;$.ajax&lt;/code&gt; call is made; if several other requests are in progress and the browser has no connections available, it is possible for a request to time out before it can be sent. &lt;strong&gt;In jQuery 1.4.x and below,&lt;/strong&gt; the XMLHttpRequest object will be in an invalid state if the request times out; accessing any object members may throw an exception. &lt;strong&gt;In Firefox 3.0+ only,&lt;/strong&gt; script and JSONP requests cannot be cancelled by a timeout; the script will run even if it arrives after the timeout period.</source>
          <target state="translated">요청에 대한 시간 초과 (밀리 초)를 설정하십시오. 값이 0이면 시간 종료가 없음을 의미합니다. &lt;a href=&quot;jquery.ajaxsetup&quot;&gt;$ .ajaxSetup ()로&lt;/a&gt; 설정된 모든 글로벌 시간 초과를 무시합니다 . 시간 초과 기간은 &lt;code&gt;$.ajax&lt;/code&gt; 호출이 시작되는 시점에서 시작됩니다 . 다른 요청이 여러 개 진행 중이고 브라우저에 사용 가능한 연결이없는 경우 요청을 보내기 전에 시간이 초과 될 수 있습니다. &lt;strong&gt;jQuery 1.4.x 이하에서는&lt;/strong&gt; 요청 시간이 초과되면 XMLHttpRequest 객체가 잘못된 상태가됩니다. 객체 멤버에 액세스하면 예외가 발생할 수 있습니다. &lt;strong&gt;Firefox 3.0 이상에서만&lt;/strong&gt; 시간 초과로 스크립트 및 JSONP 요청을 취소 할 수 없습니다. 시간 종료 기간이 지난 후에도 스크립트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a75045c3e7e4e41869961e4536a201841a37d8d4" translate="yes" xml:space="preserve">
          <source>Set a timer to delay execution of subsequent items in the queue.</source>
          <target state="translated">큐에서 후속 항목의 실행을 지연 시키려면 타이머를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="29bc597e05b5611f7a75e1d0062b8b589d81d71d" translate="yes" xml:space="preserve">
          <source>Set data on an element and see the results of hasData.</source>
          <target state="translated">요소에 데이터를 설정하고 hasData의 결과를보십시오.</target>
        </trans-unit>
        <trans-unit id="4df763c8781cee89c94fb1655e6b6f2638cf5b8b" translate="yes" xml:space="preserve">
          <source>Set default values for future Ajax requests. Its use is not recommended.</source>
          <target state="translated">향후 Ajax 요청에 대한 기본값을 설정하십시오. 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b8efd5c0d5323f84aaea2833f9663ce507ef5110" translate="yes" xml:space="preserve">
          <source>Set some attributes for all &amp;lt;img&amp;gt;s in the page.</source>
          <target state="translated">페이지에서 모든 &amp;lt;img&amp;gt;에 대한 일부 속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="097a25d652bf055f7a137ff2a570d4f0be2804f8" translate="yes" xml:space="preserve">
          <source>Set the background color of the page to black.</source>
          <target state="translated">페이지의 배경색을 검은 색으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ee26402c1121939de683a5e3c569d8b6b4059083" translate="yes" xml:space="preserve">
          <source>Set the id for divs based on the position in the page.</source>
          <target state="translated">페이지의 위치를 ​​기준으로 div의 id를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="1b434d70d1b6398f4a48de9838e66013be0964e4" translate="yes" xml:space="preserve">
          <source>Set the offset of the second paragraph:</source>
          <target state="translated">두 번째 단락의 오프셋을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4fab112a16558193a664503706e6bdc9b834ddb3" translate="yes" xml:space="preserve">
          <source>Set the scrollLeft of a div.</source>
          <target state="translated">div의 scrollLeft를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="80de7325e36ebaf59890fde0787ee0978812d6fd" translate="yes" xml:space="preserve">
          <source>Set the scrollTop of a div.</source>
          <target state="translated">div의 scrollTop을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="501160f93f7aac197ef0a4afa5136de4c99128c1" translate="yes" xml:space="preserve">
          <source>Set the src attribute from title attribute on the image.</source>
          <target state="translated">이미지의 title 속성에서 src 속성을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0eb0fd641752abcc5ef3043a7964e10a309c836b" translate="yes" xml:space="preserve">
          <source>Set the value of an input box.</source>
          <target state="translated">입력 상자의 값을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="4c430c240166834ea88c0ed7281d7fd5e5999f98" translate="yes" xml:space="preserve">
          <source>Set this to &lt;code&gt;true&lt;/code&gt; if you wish to use the traditional style of &lt;a href=&quot;jquery.param&quot;&gt;param serialization&lt;/a&gt;.</source>
          <target state="translated">전통적인 스타일의 &lt;a href=&quot;jquery.param&quot;&gt;매개 변수 직렬화&lt;/a&gt; 를 사용하려면 이것을 &lt;code&gt;true&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fc8d2b9d04536e217f8d6ee7a88a0bafbd2135d" translate="yes" xml:space="preserve">
          <source>Sets the defaults for Ajax requests to the url &quot;/xmlhttp/&quot;, disables global handlers and uses POST instead of GET. The following Ajax requests then sends some data without having to set anything else.</source>
          <target state="translated">Ajax 요청의 기본값을 URL &quot;/ xmlhttp /&quot;로 설정하고 전역 핸들러를 비활성화하고 GET 대신 POST를 사용합니다. 다음 Ajax 요청은 다른 설정없이 데이터를 전송합니다.</target>
        </trans-unit>
        <trans-unit id="1bc9506ed518c2ffaaeed5c77bcc37e4fff485f4" translate="yes" xml:space="preserve">
          <source>Setting a simple attribute</source>
          <target state="translated">간단한 속성 설정</target>
        </trans-unit>
        <trans-unit id="48d2152c54739da04de91aee4b49440f02938b01" translate="yes" xml:space="preserve">
          <source>Setting several attributes at once</source>
          <target state="translated">한 번에 여러 속성 설정</target>
        </trans-unit>
        <trans-unit id="47415531e62ab24a4bb2deca300877b6fef2b92e" translate="yes" xml:space="preserve">
          <source>Setting the third argument to false will attach a function that prevents the default action from occurring and stops the event from bubbling. The default is true.</source>
          <target state="translated">세 번째 인수를 false로 설정하면 기본 동작이 발생하지 않고 이벤트 버블 링이 중지되는 기능이 추가됩니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="91f123ee7203e5bbd228a25c42679e0e53bd4cc4" translate="yes" xml:space="preserve">
          <source>Setting values using this method (or using the native &lt;code&gt;value&lt;/code&gt; property) does not cause the dispatch of the &lt;code&gt;change&lt;/code&gt; event. For this reason, the relevant event handlers will not be executed. If you want to execute them, you should call &lt;code&gt;.trigger( &quot;change&quot; )&lt;/code&gt; after setting the value.</source>
          <target state="translated">이 메소드를 사용하거나 기본 &lt;code&gt;value&lt;/code&gt; 특성을 사용하여 값을 설정해도 &lt;code&gt;change&lt;/code&gt; 이벤트 가 전달되지 않습니다 . 이러한 이유로 관련 이벤트 핸들러가 실행되지 않습니다. 이를 실행 하려면 값을 설정 한 후 &lt;code&gt;.trigger( &quot;change&quot; )&lt;/code&gt; 호출해야 합니다.</target>
        </trans-unit>
        <trans-unit id="469d5b183fdc0d59e41a51e61529cdd95274ba7c" translate="yes" xml:space="preserve">
          <source>Shift</source>
          <target state="translated">Shift</target>
        </trans-unit>
        <trans-unit id="db6af5aa39d7397cfe1ad95f101c0b53b8393168" translate="yes" xml:space="preserve">
          <source>Shorthand CSS properties (e.g. font, background, border) are not fully supported. For example, if you want to animate the rendered border width, at least a border style and border width other than &quot;auto&quot; must be set in advance. Or, if you want to animate font size, you would use &lt;code&gt;fontSize&lt;/code&gt; or the CSS equivalent &lt;code&gt;'font-size'&lt;/code&gt; rather than simply &lt;code&gt;'font'&lt;/code&gt;.</source>
          <target state="translated">속기 CSS 속성 (예 : 글꼴, 배경, 테두리)은 완전히 지원되지 않습니다. 예를 들어 렌더링 된 테두리 너비에 애니메이션을 적용하려면 최소한 &quot;auto&quot;이외의 테두리 스타일과 테두리 너비를 미리 설정해야합니다. 또는 글꼴 크기에 애니메이션을 적용하려면 단순히 &lt;code&gt;'font'&lt;/code&gt; 대신 &lt;code&gt;fontSize&lt;/code&gt; 또는 CSS와 동등한 &lt;code&gt;'font-size'&lt;/code&gt; '를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="13ce66dde31804d78c943c988b0dbf4d57737048" translate="yes" xml:space="preserve">
          <source>Should &lt;code&gt;.trigger( &quot;eventName&quot; )&lt;/code&gt; be used, it will search for an &quot;eventName&quot; property on the object and attempt to execute it after any attached jQuery handlers are executed. It does not check whether the property is a function or not. To avoid this behavior, &lt;code&gt;.triggerHandler( &quot;eventName&quot; )&lt;/code&gt; should be used instead.</source>
          <target state="translated">해야 &lt;code&gt;.trigger( &quot;eventName&quot; )&lt;/code&gt; 에 개체에 &quot;EVENTNAME&quot;속성을 검색하고 연결된 jQuery를 핸들러가 실행 된 후이를 실행하려고 시도합니다, 사용할 수. 속성이 함수인지 여부를 확인하지 않습니다. 이 동작을 피하려면 대신 &lt;code&gt;.triggerHandler( &quot;eventName&quot; )&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e22b139c05e4b38773ef90bc8904de0d27d90c20" translate="yes" xml:space="preserve">
          <source>Show a loading message whenever an Ajax request starts (and none is already active).</source>
          <target state="translated">Ajax 요청이 시작될 때마다 (그리고 아직 활성화되지 않은) 로딩 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="9f252669f882d844dde09972cc0a4a1f2df2cda9" translate="yes" xml:space="preserve">
          <source>Show a message before an Ajax request is sent.</source>
          <target state="translated">Ajax 요청이 전송되기 전에 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="b476ab773e940c40b6948b21c71c228f1f11a21b" translate="yes" xml:space="preserve">
          <source>Show a message when an Ajax request completes successfully.</source>
          <target state="translated">Ajax 요청이 완료되면 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="7b41f7448fb41b38cd17cdcae79d3950abdd5520" translate="yes" xml:space="preserve">
          <source>Show a message when an Ajax request completes.</source>
          <target state="translated">Ajax 요청이 완료되면 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="05933287608489a9d52cfaf3e1830e781ba4aa9b" translate="yes" xml:space="preserve">
          <source>Show a message when an Ajax request fails.</source>
          <target state="translated">Ajax 요청이 실패하면 메시지를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="519514a8001648e93ee443893ab4b92b963bc312" translate="yes" xml:space="preserve">
          <source>Show all span and input elements with an animation. Change the text once the animation is done.</source>
          <target state="translated">애니메이션과 함께 모든 범위 및 입력 요소를 표시합니다. 애니메이션이 완료되면 텍스트를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="984335580fdfb879f6e3f885677f9f166cd1427f" translate="yes" xml:space="preserve">
          <source>Show how event delegation can be done with closest. The closest list element toggles a yellow background when it or its descendent is clicked.</source>
          <target state="translated">가장 가까운 이벤트 위임을 수행하는 방법을 보여줍니다. 가장 가까운 목록 요소는 배경 또는 그 하위 항목을 클릭 할 때 노란색 배경을 토글합니다.</target>
        </trans-unit>
        <trans-unit id="0ae17c6ac132af952cc810c0dcc914e28fa26861" translate="yes" xml:space="preserve">
          <source>Show number of times mouseout and mouseleave events are triggered. &lt;code&gt;mouseout&lt;/code&gt; fires when the pointer moves out of child element as well, while &lt;code&gt;mouseleave&lt;/code&gt; fires only when the pointer moves out of the bound element.</source>
          <target state="translated">mouseout 및 mouseleave 이벤트가 트리거 된 횟수를 표시합니다. &lt;code&gt;mouseout&lt;/code&gt; 은 포인터가 자식 요소를 &lt;code&gt;mouseleave&lt;/code&gt; 때 발생 하는 반면 mouseleave 는 포인터가 바인딩 된 요소를 벗어날 때만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3625594e77ad218412dfedbe46982302913ad5ac" translate="yes" xml:space="preserve">
          <source>Show or manipulate the queue of functions to be executed on the matched element.</source>
          <target state="translated">일치하는 요소에서 실행될 함수 큐를 표시하거나 조작합니다.</target>
        </trans-unit>
        <trans-unit id="39761be7b983dab5e329662e5feed6f9934622b4" translate="yes" xml:space="preserve">
          <source>Show or manipulate the queue of functions to be executed on the matched elements.</source>
          <target state="translated">일치하는 요소에서 실행될 함수 큐를 표시하거나 조작하십시오.</target>
        </trans-unit>
        <trans-unit id="16df6b0062351304bd84b3a27580952641a99624" translate="yes" xml:space="preserve">
          <source>Show texts when mouseenter and mouseout event triggering. &lt;code&gt;mouseover&lt;/code&gt; fires when the pointer moves into the child element as well, while &lt;code&gt;mouseenter&lt;/code&gt; fires only when the pointer moves into the bound element.</source>
          <target state="translated">mouseenter 및 mouseout 이벤트 트리거시 텍스트를 표시합니다. &lt;code&gt;mouseover&lt;/code&gt; 는 포인터가 자식 요소로 이동할 때도 발생하고 마우스 &lt;code&gt;mouseenter&lt;/code&gt; 는 포인터가 바인딩 된 요소로 이동할 때만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f22e04704b0222408ca3a60fd105ab1256854512" translate="yes" xml:space="preserve">
          <source>Show texts when mouseup and mousedown event triggering.</source>
          <target state="translated">mouseup 및 mousedown 이벤트 트리거시 텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9b08505c4f67fcfe1818b9165cd3486bbdbc8c6c" translate="yes" xml:space="preserve">
          <source>Show the browser info.</source>
          <target state="translated">브라우저 정보를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="ad19f5bdd2ca5c41c2e37f9cba8cb903d27e3050" translate="yes" xml:space="preserve">
          <source>Show the event object for the keydown handler when a key is pressed in the input.</source>
          <target state="translated">입력에서 키를 누를 때 키 다운 핸들러의 이벤트 오브젝트를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d93161b14d70830e3bea85c83d58f3562adbd85e" translate="yes" xml:space="preserve">
          <source>Show the event object for the keyup handler (using a simple $.print plugin) when a key is released in the input.</source>
          <target state="translated">입력에서 키를 놓을 때 간단한 $ .print 플러그인을 사용하여 키업 핸들러의 이벤트 객체를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="fa869efebfddd7c6615aaf04bfabcb5e6772b61b" translate="yes" xml:space="preserve">
          <source>Show the event object when a key is pressed in the input. Note: This demo relies on a simple $.print() plugin (https://api.jquery.com/resources/events.js) for the event object's output.</source>
          <target state="translated">입력에서 키를 누를 때 이벤트 객체를 표시합니다. 참고 :이 데모는 이벤트 객체의 출력을 위해 간단한 $ .print () 플러그인 (https://api.jquery.com/resources/events.js)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a9896f8a3339a0df5ff5e1ecb5209d4930eb8f02" translate="yes" xml:space="preserve">
          <source>Show the first div, followed by each next adjacent sibling div in order, with a 200ms animation. Each animation starts when the previous sibling div's animation ends.</source>
          <target state="translated">200ms 애니메이션과 함께 첫 번째 div 다음에 인접한 각 형제 div를 순서대로 표시하십시오. 이전 형제 div의 애니메이션이 끝나면 각 애니메이션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6557600916e731608ebca494d2d50dcc744408" translate="yes" xml:space="preserve">
          <source>Show the length of the queue.</source>
          <target state="translated">대기열 길이를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="b544befbd2f388b14fd260171b1cca0a42ebef79" translate="yes" xml:space="preserve">
          <source>Show the mouse coordinates when the mouse is moved over the yellow div. Coordinates are relative to the window, which in this case is the iframe.</source>
          <target state="translated">마우스가 노란색 div 위로 움직일 때 마우스 좌표를 표시하십시오. 좌표는 창을 기준으로하며이 경우 iframe입니다.</target>
        </trans-unit>
        <trans-unit id="69f44bacb640a60b4ce5f71dd59e0939296ec35a" translate="yes" xml:space="preserve">
          <source>Show the mouse position relative to the left and top edges of the document (within this iframe).</source>
          <target state="translated">문서의 왼쪽 및 상단 가장자리를 기준으로 마우스 위치를 표시합니다 (이 iframe 내에서).</target>
        </trans-unit>
        <trans-unit id="47f8b628a56746aed654aec7b07b6ed34563e493" translate="yes" xml:space="preserve">
          <source>Show the number of times mouseout and mouseleave events are triggered. &lt;code&gt;mouseout&lt;/code&gt; fires when the pointer moves out of the child element as well, while &lt;code&gt;mouseleave&lt;/code&gt; fires only when the pointer moves out of the bound element.</source>
          <target state="translated">mouseout 및 mouseleave 이벤트가 트리거 된 횟수를 표시하십시오. &lt;code&gt;mouseout&lt;/code&gt; 은 포인터가 자식 요소 밖으로 이동하면 발생 하지만 &lt;code&gt;mouseleave&lt;/code&gt; 는 포인터가 바인딩 된 요소 밖으로 이동하면 발생합니다.</target>
        </trans-unit>
        <trans-unit id="404a7c06b436d2f84162fadbf19e223dca32ae52" translate="yes" xml:space="preserve">
          <source>Show the number of times mouseover and mouseenter events are triggered. &lt;code&gt;mouseover&lt;/code&gt; fires when the pointer moves into the child element as well, while &lt;code&gt;mouseenter&lt;/code&gt; fires only when the pointer moves into the bound element.</source>
          <target state="translated">mouseover 및 mouseenter 이벤트가 트리거 된 횟수를 표시하십시오. &lt;code&gt;mouseover&lt;/code&gt; 는 포인터가 자식 요소로 이동할 때도 발생하고 마우스 &lt;code&gt;mouseenter&lt;/code&gt; 는 포인터가 바인딩 된 요소로 이동할 때만 발생합니다.</target>
        </trans-unit>
        <trans-unit id="090aa960971137d74c0e2c71583ff9a73df44c91" translate="yes" xml:space="preserve">
          <source>Show the order in the jQuery object.</source>
          <target state="translated">jQuery 객체에 순서를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="71a35cb28a1beadceaa3c6e2209e0fec267e3777" translate="yes" xml:space="preserve">
          <source>Show various heights. Note the values are from the iframe so might be smaller than you expected. The yellow highlight shows the iframe body.</source>
          <target state="translated">다양한 높이를 보여줍니다. iframe의 값이므로 예상보다 작을 수 있습니다. 노란색 하이라이트는 iframe 바디를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9473936f01cbca6d69f1dece6d43856b6724edb6" translate="yes" xml:space="preserve">
          <source>Show various widths. Note the values are from the iframe so might be smaller than you expected. The yellow highlight shows the iframe body.</source>
          <target state="translated">다양한 너비를 보여줍니다. iframe의 값이므로 예상보다 작을 수 있습니다. 노란색 하이라이트는 iframe 바디를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c33e45b32872d9e6db475a6df01ad1c0aa074865" translate="yes" xml:space="preserve">
          <source>Shows a few ways is() can be used inside an event handler.</source>
          <target state="translated">이벤트 핸들러 내에서 is ()를 사용할 수있는 몇 가지 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9f80a91d7a7e65cd7176b7698d0ff5aa4efc6c25" translate="yes" xml:space="preserve">
          <source>Shows all hidden divs and counts hidden inputs.</source>
          <target state="translated">숨겨진 모든 div를 표시하고 숨겨진 입력을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="23f883856a4edafeed47bb6a4844925a9fdd3ac1" translate="yes" xml:space="preserve">
          <source>Shows all paragraphs, then hides them all, back and forth.</source>
          <target state="translated">모든 단락을 표시 한 다음 앞뒤로 모두 숨 깁니다.</target>
        </trans-unit>
        <trans-unit id="3a32e745a60f4a870e675d1abfd69e6874c3fdb2" translate="yes" xml:space="preserve">
          <source>Shows the parent of each element as (parent &amp;gt; child). Check the View Source to see the raw html.</source>
          <target state="translated">각 요소의 부모를 (부모&amp;gt; 자식)으로 표시합니다. 원시 HTML을 보려면 소스보기를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="bc96ba5e16ff60d54045222bd716907b909f13a1" translate="yes" xml:space="preserve">
          <source>Similar to &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;.empty()&lt;/a&gt;&lt;/code&gt;, the &lt;code&gt;.remove()&lt;/code&gt; method takes elements out of the DOM. Use &lt;code&gt;.remove()&lt;/code&gt; when you want to remove the element itself, as well as everything inside it. In addition to the elements themselves, all bound events and jQuery data associated with the elements are removed. To remove the elements without removing data and events, use &lt;code&gt;&lt;a href=&quot;detach&quot;&gt;.detach()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">유사 &lt;code&gt;&lt;a href=&quot;empty&quot;&gt;.empty()&lt;/a&gt;&lt;/code&gt; 은 &lt;code&gt;.remove()&lt;/code&gt; 메소드는 DOM 요소를 꺼낸다. 요소 자체와 내부의 모든 요소를 ​​제거 하려면 &lt;code&gt;.remove()&lt;/code&gt; 사용하십시오 . 요소 자체 외에도 요소와 관련된 모든 바인딩 된 이벤트 및 jQuery 데이터가 제거됩니다. 데이터와 이벤트를 제거하지 않고 요소를 제거하려면 &lt;code&gt;&lt;a href=&quot;detach&quot;&gt;.detach()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc3d4b313a79ee01993258bfb62f9d7410a27b2f" translate="yes" xml:space="preserve">
          <source>Similar to other content-adding methods such as &lt;code&gt;&lt;a href=&quot;append&quot;&gt;.append()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.prepend()&lt;/code&gt; also supports passing in multiple arguments as input. Supported input includes DOM elements, jQuery objects, HTML strings, and arrays of DOM elements.</source>
          <target state="translated">같은 다른 콘텐츠 추가 방법과 유사 &lt;code&gt;&lt;a href=&quot;append&quot;&gt;.append()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.prepend()&lt;/code&gt; 과 같은 여러 인자를 입력으로 전달 지원한다. 지원되는 입력에는 DOM 요소, jQuery 객체, HTML 문자열 및 DOM 요소 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a1b7b3cb192f9f19b267d26bdb4a4b8da9505760" translate="yes" xml:space="preserve">
          <source>Similar to other content-adding methods such as &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.before()&lt;/code&gt; also supports passing in multiple arguments as input. Supported input includes DOM elements, jQuery objects, HTML strings, and arrays of DOM elements.</source>
          <target state="translated">같은 다른 콘텐츠 추가 방법과 유사 &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.before()&lt;/code&gt; 과 같은 여러 인자를 입력으로 전달 지원한다. 지원되는 입력에는 DOM 요소, jQuery 객체, HTML 문자열 및 DOM 요소 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="006392ad7e2187f99a07cd2030ba9a75d427ec4d" translate="yes" xml:space="preserve">
          <source>Similar to other content-adding methods such as &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.after()&lt;/code&gt; also supports passing in multiple arguments as input. Supported input includes DOM elements, jQuery objects, HTML strings, and arrays of DOM elements.</source>
          <target state="translated">같은 다른 콘텐츠 추가 방법과 유사 &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.after()&lt;/code&gt; 과 같은 여러 인자를 입력으로 전달 지원한다. 지원되는 입력에는 DOM 요소, jQuery 객체, HTML 문자열 및 DOM 요소 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="df29cb0d48d7733d0bca93bbd664bfcac55e3e87" translate="yes" xml:space="preserve">
          <source>Similar to other content-adding methods such as &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;.append()&lt;/code&gt; also supports passing in multiple arguments as input. Supported input includes DOM elements, jQuery objects, HTML strings, and arrays of DOM elements.</source>
          <target state="translated">같은 다른 콘텐츠 추가 방법과 유사 &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;.append()&lt;/code&gt; 과 같은 여러 인자를 입력으로 전달 지원한다. 지원되는 입력에는 DOM 요소, jQuery 객체, HTML 문자열 및 DOM 요소 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="43e7ddc0a9479bf30d1a0ff5889e2b9da87c3b03" translate="yes" xml:space="preserve">
          <source>Similarly, a handler can call &lt;code&gt;event.preventDefault()&lt;/code&gt; to cancel any default action that the browser may have for this event; for example, the default action on a &lt;code&gt;click&lt;/code&gt; event is to follow the link. Not all browser events have default actions, and not all default actions can be canceled. See the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/#event-types-list&quot;&gt;W3C Events Specification&lt;/a&gt; for details.</source>
          <target state="translated">마찬가지로 핸들러는 &lt;code&gt;event.preventDefault()&lt;/code&gt; 를 호출 하여 브라우저가이 이벤트에 대해 가질 수있는 기본 조치를 취소 할 수 있습니다. 예를 들어 &lt;code&gt;click&lt;/code&gt; 이벤트 의 기본 동작 은 링크를 따르는 것입니다. 모든 브라우저 이벤트에 기본 작업이있는 것은 아니며 모든 기본 작업을 취소 할 수있는 것은 아닙니다. 자세한 내용은 &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-3-Events/#event-types-list&quot;&gt;W3C 이벤트 사양&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ccc5cf9bc9bce46f452c1b0c6151b92830a99ee3" translate="yes" xml:space="preserve">
          <source>Similarly, an element may also be passed to find:</source>
          <target state="translated">마찬가지로, 요소는 다음을 찾기 위해 전달 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9284b14e12238f3e08110b72509fd3a3bf2c689" translate="yes" xml:space="preserve">
          <source>Similarly, if we retrieve a jQuery object consisting of one of the three list items, &lt;code&gt;.index()&lt;/code&gt; will search for that list item:</source>
          <target state="translated">마찬가지로 세 개의 목록 항목 중 하나로 구성된 jQuery 객체를 검색하면 &lt;code&gt;.index()&lt;/code&gt; 는 해당 목록 항목을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="af3ab504fe94703d8bc8d32f7b6369c311849311" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;.after()&lt;/code&gt; can accept any number of additional arguments, the same result can be achieved by passing in the three &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s as three separate arguments, like so: &lt;code&gt;$( &quot;p&quot; ).first().after( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt;. The type and number of arguments will largely depend on the elements that are collected in the code.</source>
          <target state="translated">이후 &lt;code&gt;.after()&lt;/code&gt; 추가 인수의 수를 받아 들일 수 있으며, 동일한 결과가 세 전달함으로써 달성 될 수있다 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; : S 같은 세 개의 인자, 등 &lt;code&gt;$( &quot;p&quot; ).first().after( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt; . 인수의 유형과 개수는 코드에서 수집 된 요소에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="2e9baad5e5717759e600d8fa39a59f53a3545d1b" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;.append()&lt;/code&gt; can accept any number of additional arguments, the same result can be achieved by passing in the three &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s as three separate arguments, like so: &lt;code&gt;$('body').append( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt;. The type and number of arguments will largely depend on how you collect the elements in your code.</source>
          <target state="translated">이후 &lt;code&gt;.append()&lt;/code&gt; 추가 인수의 수를 받아 들일 수 있고, 동일한 결과가 세 전달함으로써 달성 될 수있다 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 과 같이, S 세 개의 별개의 인자들 : &lt;code&gt;$('body').append( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt; . 인수의 유형과 개수는 코드에서 요소를 수집하는 방법에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="3866949d83d1435a9a87376fd01b8109f97bbae5" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;.before()&lt;/code&gt; can accept any number of additional arguments, the same result can be achieved by passing in the three &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s as three separate arguments, like so: &lt;code&gt;$( &quot;p&quot; ).first().before( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt;. The type and number of arguments will largely depend on how you collect the elements in your code.</source>
          <target state="translated">이후 &lt;code&gt;.before()&lt;/code&gt; 추가 인수의 수를 받아 들일 수 같은 결과는 세 가지 전달에 의해 달성 될 수있다 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 과 같이,의 세 가지 별도의 인수 : &lt;code&gt;$( &quot;p&quot; ).first().before( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt; . 인수의 유형과 개수는 코드에서 요소를 수집하는 방법에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="9ff88230d8cf6f6e9a4f26e921ba3235226053a6" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;.prepend()&lt;/code&gt; can accept any number of additional arguments, the same result can be achieved by passing in the three &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s as three separate arguments, like so: &lt;code&gt;$( &quot;body&quot; ).prepend( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt;. The type and number of arguments will largely depend on how you collect the elements in your code.</source>
          <target state="translated">이후 &lt;code&gt;.prepend()&lt;/code&gt; 추가 인수의 수를 받아 들일 수 있고, 동일한 결과를 전달함으로써 달성 될 수있는 세 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 의 세 개의 인자로서 같은 : &lt;code&gt;$( &quot;body&quot; ).prepend( $newdiv1, newdiv2, existingdiv1 )&lt;/code&gt; . 인수의 유형과 개수는 코드에서 요소를 수집하는 방법에 따라 크게 달라집니다.</target>
        </trans-unit>
        <trans-unit id="22770ea7aaf9fb3b5d0d4217e44d0619775c6eeb" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;jQuery 3&lt;/strong&gt;, every two-character sequence of &quot;-&quot; (U+002D) followed by a lowercase ASCII letter in a key is replaced by the uppercase version of the letter, in alignment with the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#dom-dataset&quot;&gt;HTML dataset API&lt;/a&gt;. A statement like &lt;code&gt;$( &quot;body&quot; ).data( { &quot;my-name&quot;: &quot;aValue&quot; } ).data();&lt;/code&gt; will return &lt;code&gt;{ myName: &quot;aValue&quot; }&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;jQuery 3&lt;/strong&gt; 이후 로 키에서 소문자 ASCII 문자가 뒤 따르는 &quot;-&quot;(U + 002D)의 모든 두 문자 시퀀스는 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#dom-dataset&quot;&gt;HTML 데이터 세트 API&lt;/a&gt; 에 맞춰 대문자 버전의 문자로 대체됩니다 . 같은 문 &lt;code&gt;$( &quot;body&quot; ).data( { &quot;my-name&quot;: &quot;aValue&quot; } ).data();&lt;/code&gt; &lt;code&gt;{ myName: &quot;aValue&quot; }&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="88b1ff6e137cf5a7674c0a4b1dd9506e55d3f239" translate="yes" xml:space="preserve">
          <source>Since all &lt;code&gt;.live()&lt;/code&gt; events are attached at the &lt;code&gt;document&lt;/code&gt; element, events take the longest and slowest possible path before they are handled.</source>
          <target state="translated">모든 &lt;code&gt;.live()&lt;/code&gt; 이벤트는 &lt;code&gt;document&lt;/code&gt; 요소에 첨부되므로 이벤트는 처리되기 전에 가능한 가장 길고 느린 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="235d61f94fedb8dacf1f14cb572f293f702d3042" translate="yes" xml:space="preserve">
          <source>Since each request requires its own transport object instance, transports cannot be registered directly. Therefore, you should provide a function that returns a transport instead.</source>
          <target state="translated">각 요청에는 고유 한 전송 개체 인스턴스가 필요하므로 전송을 직접 등록 할 수 없습니다. 따라서 대신 전송을 리턴하는 함수를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="ce2a7c642237538647f2d47dcc1dde9059a17c23" translate="yes" xml:space="preserve">
          <source>Since jQuery 1.4.3, &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes&quot;&gt;&lt;code&gt;data-*&lt;/code&gt; attributes&lt;/a&gt; are used to initialize jQuery data. An element's &lt;code&gt;data-*&lt;/code&gt; attributes are retrieved the first time the &lt;code&gt;data()&lt;/code&gt; method is invoked upon it, and then are no longer accessed or mutated (all values are stored internally by jQuery).</source>
          <target state="translated">jQuery 1.4.3부터 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes&quot;&gt; &lt;code&gt;data-*&lt;/code&gt; 속성&lt;/a&gt; 은 jQuery 데이터를 초기화하는 데 사용됩니다. 요소의 &lt;code&gt;data-*&lt;/code&gt; 속성은 &lt;code&gt;data()&lt;/code&gt; 메서드가 처음 호출 될 때 검색된 다음 더 이상 액세스되거나 변경되지 않습니다 (모든 값은 jQuery에 의해 내부적으로 저장 됨).</target>
        </trans-unit>
        <trans-unit id="5969353c95e8154458c9a2e8efa05a46c0fd3e01" translate="yes" xml:space="preserve">
          <source>Since jQuery 1.6, dashes in &lt;code&gt;data-*&lt;/code&gt; attribute names have been processed in alignment with the &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#dom-dataset&quot;&gt;HTML dataset API&lt;/a&gt;.</source>
          <target state="translated">jQuery 1.6 이후로 &lt;code&gt;data-*&lt;/code&gt; 속성 이름의 대시 는 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/dom.html#dom-dataset&quot;&gt;HTML 데이터 세트 API에&lt;/a&gt; 맞춰 처리되었습니다 .</target>
        </trans-unit>
        <trans-unit id="b94a3fdcc7bc381130af142791076c03992641c6" translate="yes" xml:space="preserve">
          <source>Since jQuery uses one global interval, no animation should be running or all animations should stop for the change of this property to take effect.</source>
          <target state="translated">jQuery는 하나의 전역 간격을 사용하므로이 속성의 변경 사항을 적용하려면 애니메이션이 실행되고 있지 않거나 모든 애니메이션이 중지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb1ebd8b88fa1cbf6d066706d6ca6582244e64cf" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get()&lt;/code&gt;&lt;/a&gt; method returns a &lt;code&gt;jqXHR&lt;/code&gt; object, which is derived from a Deferred object, we can attach a callback for both success and error using the &lt;code&gt;deferred.always()&lt;/code&gt; method.</source>
          <target state="translated">이후 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get()&lt;/code&gt; &lt;/a&gt; 메소드가 리턴 &lt;code&gt;jqXHR&lt;/code&gt; 의 지연된 객체에서 파생 된 개체를, 우리는 사용의 성공 및 오류 모두를위한 콜백 첨부 할 수 있습니다 &lt;code&gt;deferred.always()&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="dcb73e61c93c837cbc057fc46e56718b7e1f1393" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get&lt;/code&gt;&lt;/a&gt; method returns a jqXHR object, which is derived from a Deferred object, we can add rejection handlers using the &lt;code&gt;.catch&lt;/code&gt; method.</source>
          <target state="translated">때문에 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get&lt;/code&gt; 에&lt;/a&gt; 있어서 되돌아 지연된 개체로부터 유래 된 jqXHR 객체, 우리는 제거하여 핸들러를 추가 &lt;code&gt;.catch&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="6342a4abce39c6640aa7cef5fb2c053d726fdd04" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get&lt;/code&gt;&lt;/a&gt; method returns a jqXHR object, which is derived from a Deferred object, we can attach a success callback using the &lt;code&gt;.done()&lt;/code&gt; method.</source>
          <target state="translated">이후 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get&lt;/code&gt; 의&lt;/a&gt; 방법은 이연 객체에서 파생 된 jqXHR 객체를 반환, 우리는 사용 성공 콜백을 첨부 할 수 있습니다 &lt;code&gt;.done()&lt;/code&gt; 메소드를.</target>
        </trans-unit>
        <trans-unit id="5872a8250fa5893d3546adab12605b8ec365deb7" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get&lt;/code&gt;&lt;/a&gt; method returns a jqXHR object, which is derived from a Deferred object, we can attach handlers using the &lt;code&gt;.then&lt;/code&gt; method.</source>
          <target state="translated">이후 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get&lt;/code&gt; 의&lt;/a&gt; 방법은 이연 객체에서 파생 된 jqXHR 객체를 반환, 우리가 사용하는 핸들러를 첨부 할 수 있습니다 &lt;code&gt;.then&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="6f3c5742ce47f98262f8e52369b1aa15badf1bea" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get&lt;/code&gt;&lt;/a&gt; method returns a jqXHR object, which is derived from a Deferred object, we can rejection handlers using the &lt;code&gt;.catch&lt;/code&gt; method.</source>
          <target state="translated">때문에 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get&lt;/code&gt; 에&lt;/a&gt; 있어서 되돌아 지연된 개체로부터 유래 된 jqXHR 객체, 우리는 거부 처리기는 사용 가능 &lt;code&gt;.catch&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="bfa98b5bcb4e82764aa5222d51deca0844c19898" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;jquery.get&quot;&gt;&lt;code&gt;jQuery.get&lt;/code&gt;&lt;/a&gt; method returns a jqXHR object, which is derived from a Deferred, you can attach a success and failure callback using the &lt;code&gt;deferred.done()&lt;/code&gt; and &lt;code&gt;deferred.fail()&lt;/code&gt; methods.</source>
          <target state="translated">이후 &lt;a href=&quot;jquery.get&quot;&gt; &lt;code&gt;jQuery.get&lt;/code&gt; 의&lt;/a&gt; 방법은 이연에서 파생 된 jqXHR 객체를 반환, 당신은 사용하여 성공과 실패 콜백을 첨부 할 수 있습니다 &lt;code&gt;deferred.done()&lt;/code&gt; 및 &lt;code&gt;deferred.fail()&lt;/code&gt; 메소드.</target>
        </trans-unit>
        <trans-unit id="f92de5e75bfc3177db7ca895588568fbf9cbffb1" translate="yes" xml:space="preserve">
          <source>Since the &lt;a href=&quot;live&quot;&gt;&lt;code&gt;.live()&lt;/code&gt;&lt;/a&gt; method handles events once they have propagated to the top of the document, it is not possible to stop propagation of live events. Similarly, events handled by &lt;code&gt;&lt;a href=&quot;delegate&quot;&gt;.delegate()&lt;/a&gt;&lt;/code&gt; will propagate to the elements to which they are delegated; event handlers bound on any elements below it in the DOM tree will already have been executed by the time the delegated event handler is called. These handlers, therefore, may prevent the delegated handler from triggering by calling &lt;code&gt;&lt;a href=&quot;event.stoppropagation&quot;&gt;event.stopPropagation()&lt;/a&gt;&lt;/code&gt; or returning &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이후 &lt;a href=&quot;live&quot;&gt; &lt;code&gt;.live()&lt;/code&gt; &lt;/a&gt; 들은이 문서의 상단에 전파 일단 방법 핸들 이벤트는 라이브 이벤트의 전파를 중지 할 수 없습니다. 마찬가지로 &lt;code&gt;&lt;a href=&quot;delegate&quot;&gt;.delegate()&lt;/a&gt;&lt;/code&gt; 가 처리하는 이벤트 는 위임 된 요소로 전파됩니다. DOM 트리에서 그 아래에있는 모든 요소에 바인딩 된 이벤트 처리기는 위임 된 이벤트 처리기가 호출 될 때 이미 실행되었을 것입니다. 따라서 이러한 핸들러는 &lt;code&gt;&lt;a href=&quot;event.stoppropagation&quot;&gt;event.stopPropagation()&lt;/a&gt;&lt;/code&gt; 을 호출 하거나 &lt;code&gt;false&lt;/code&gt; 를 반환 하여 위임 된 핸들러가 트리거되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1edc5381b6091a7fd6e1829f259f5037f6e15dd" translate="yes" xml:space="preserve">
          <source>Since the index is zero-based, the first list item is returned:</source>
          <target state="translated">인덱스는 0부터 시작하므로 첫 번째 목록 항목이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7a6e24162c86dfba7b0b421fd47f8c5bb8ef4d79" translate="yes" xml:space="preserve">
          <source>Size: 2</source>
          <target state="translated">크기 : 2</target>
        </trans-unit>
        <trans-unit id="982e22c2ba6646fbc5724d9dc05eadc3a19d3774" translate="yes" xml:space="preserve">
          <source>Slide the next sibling LI up or down on hover, and toggle a class.</source>
          <target state="translated">호버에서 다음 형제 LI를 위 또는 아래로 밀고 클래스를 토글하십시오.</target>
        </trans-unit>
        <trans-unit id="fb05309b161291336bae053029c5099275a0941b" translate="yes" xml:space="preserve">
          <source>Some callbacks are required to return something, others make that return value optional. To prevent a form submission, a submit event handler can return false:</source>
          <target state="translated">어떤 콜백은 무언가를 반환하는 데 필요하고 다른 콜백은 그 반환 값을 선택적으로 만듭니다. 양식 제출을 방지하기 위해 제출 이벤트 핸들러는 false를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1f13e9615a3bbabc778ec7b0f33c9cc3e91448" translate="yes" xml:space="preserve">
          <source>Some of jQuery's Ajax functions return the native XMLHttpRequest (XHR) object, or pass it as an argument to success/error/complete handlers, so that you can do additional processing or monitoring on the request. Note that Ajax functions only return or pass an XHR object when an XHR object is actually used in the request. For example, JSONP requests and cross-domain GET requests use a script element rather than an XHR object.</source>
          <target state="translated">jQuery의 Ajax 함수 중 일부는 XHR (원시 XMLHttpRequest) 객체를 반환하거나 성공 / 오류 / 완료 핸들러에 인수로 전달하여 요청에 대한 추가 처리 또는 모니터링을 수행 할 수 있습니다. 요청에 XHR 객체가 실제로 사용될 때 Ajax 함수는 XHR 객체 만 반환하거나 전달합니다. 예를 들어 JSONP 요청 및 도메인 간 GET 요청은 XHR 개체가 아닌 스크립트 요소를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8753ea1e13ebfbe5d422e4686ba9011ca9055869" translate="yes" xml:space="preserve">
          <source>Some properties of DOM elements are quite consistent among browsers. Consider this example of a simple onblur validation:</source>
          <target state="translated">DOM 요소의 일부 속성은 브라우저간에 매우 일관됩니다. 간단한 onblur 유효성 검사의이 예제를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a933f97d99788e859754f51523140619cddcd601" translate="yes" xml:space="preserve">
          <source>Sorts an array of DOM elements, in place, with the duplicates removed. Note that this only works on arrays of DOM elements, not strings or numbers.</source>
          <target state="translated">중복이 제거 된 DOM 요소의 배열을 제자리에 정렬합니다. 이것은 문자열이나 숫자가 아닌 DOM 요소의 배열에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="94d60b8f0ed0d594ef1727e3a6784cb278df97bd" translate="yes" xml:space="preserve">
          <source>Special units</source>
          <target state="translated">특수 유닛</target>
        </trans-unit>
        <trans-unit id="596f7c7958bae7b06d20d1b95c9768562dff1f23" translate="yes" xml:space="preserve">
          <source>Specify a function to execute when the DOM is fully loaded.</source>
          <target state="translated">DOM이 완전히로드 될 때 실행할 함수를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ff20a26a0c1ef838133366e7344c5ab557dc3c37" translate="yes" xml:space="preserve">
          <source>Specify the callback function name for a JSONP request. This value will be used instead of the random name automatically generated by jQuery. It is preferable to let jQuery generate a unique name as it'll make it easier to manage the requests and provide callbacks and error handling. You may want to specify the callback when you want to enable better browser caching of GET requests. &lt;strong&gt;As of jQuery 1.5&lt;/strong&gt;, you can also use a function for this setting, in which case the value of &lt;code&gt;jsonpCallback&lt;/code&gt; is set to the return value of that function.</source>
          <target state="translated">JSONP 요청에 대한 콜백 함수 이름을 지정하십시오. 이 값은 jQuery에 의해 자동 생성 된 임의 이름 대신 사용됩니다. 요청을보다 쉽게 ​​관리하고 콜백 및 오류 처리를 제공 할 수 있으므로 jQuery가 고유 한 이름을 생성하도록하는 것이 좋습니다. 더 나은 GET 요청의 브라우저 캐싱을 사용하려는 경우 콜백을 지정할 수 있습니다. &lt;strong&gt;jQuery 1.5 &lt;/strong&gt; &lt;code&gt;jsonpCallback&lt;/code&gt; 설정에 함수를 사용할 수도 있습니다.이 경우 jsonpCallback의 값이 해당 함수의 리턴 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4b0e61bc82307628e84bf51482e5ca8c38a3aac" translate="yes" xml:space="preserve">
          <source>Spoon!</source>
          <target state="translated">Spoon!</target>
        </trans-unit>
        <trans-unit id="0d8484e4b12cca197bb4c6288ecc229761a2d3c7" translate="yes" xml:space="preserve">
          <source>Starting with jQuery 1.7, selector strings with positional selectors apply the selector against the document, and then determine whether the first element of the current jQuery set matches any of the resulting elements. So for the HTML shown above, an expression such as &lt;code&gt;$( &quot;li:first&quot; ).is( &quot;li:last&quot; )&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Note that since positional selectors are jQuery additions and not W3C standard, we recommend using the W3C selectors whenever feasible.</source>
          <target state="translated">jQuery 1.7부터는 위치 선택기가있는 선택기 문자열이 문서에 선택기를 적용한 다음 현재 jQuery 세트의 첫 번째 요소가 결과 요소와 일치하는지 여부를 판별합니다. 따라서 위에 표시된 HTML의 경우 &lt;code&gt;$( &quot;li:first&quot; ).is( &quot;li:last&quot; )&lt;/code&gt; 와 같은 표현식 은 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 위치 선택기는 W3C 표준이 아닌 jQuery 추가이므로 가능할 때마다 W3C 선택기를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9a166f7dad49a1f78c7503ac2a3ec46b214bd857" translate="yes" xml:space="preserve">
          <source>Starts with all paragraphs and searches for descendant span elements, same as &lt;code&gt;$( &quot;p span&quot; )&lt;/code&gt;</source>
          <target state="translated">모든 단락으로 시작하고 &lt;code&gt;$( &quot;p span&quot; )&lt;/code&gt; 과 같은 하위 범위 요소를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9f2fa9a19aedee83f07905d92ab8023e418f9f17" translate="yes" xml:space="preserve">
          <source>States if the current page, in the user&amp;rsquo;s browser, is being rendered using the W3C CSS Box Model.</source>
          <target state="translated">사용자 브라우저의 현재 페이지가 W3C CSS 상자 모델을 사용하여 렌더링되는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f596ed584d759c21adfacff6072003d6d499e20" translate="yes" xml:space="preserve">
          <source>States if the current page, in the user&amp;rsquo;s browser, is being rendered using the W3C CSS Box Model. This property was removed in jQuery 1.8. Please try to use feature detection instead.</source>
          <target state="translated">사용자 브라우저에서 현재 페이지가 W3C CSS Box Model을 사용하여 렌더링되고 있는지를 나타냅니다. 이 속성은 jQuery 1.8에서 제거되었습니다. 대신 기능 감지를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="49a2be80024194ba9e55c77f622b84ab99f358e4" translate="yes" xml:space="preserve">
          <source>Step Function</source>
          <target state="translated">스텝 기능</target>
        </trans-unit>
        <trans-unit id="ad40990b1f5eb15fcc653c23d700e8b744907126" translate="yes" xml:space="preserve">
          <source>Stop an event from bubbling without preventing the default action by using the .stopPropagation() method.</source>
          <target state="translated">.stopPropagation () 메소드를 사용하여 기본 조치를 방해하지 않고 이벤트 버블 링을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="a76e371f4f22da824fc0475cfa42848c80bb7458" translate="yes" xml:space="preserve">
          <source>Stop submit events from bubbling without preventing form submit, using &lt;code&gt;.stopPropagation()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.stopPropagation()&lt;/code&gt; 사용하여 양식 제출을 막지 않고 제출 이벤트 버블 링을 중지하십시오 .</target>
        </trans-unit>
        <trans-unit id="75c9f5be9829724db34567272dd0a87d7c6ea276" translate="yes" xml:space="preserve">
          <source>Stop the currently-running animation on the matched elements.</source>
          <target state="translated">일치하는 요소에서 현재 실행중인 애니메이션을 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="360d71d11120f40efdbddef5715b200bb25b3684" translate="yes" xml:space="preserve">
          <source>Stop the currently-running animation, remove all queued animations, and complete all animations for the matched elements.</source>
          <target state="translated">현재 실행중인 애니메이션을 중지하고 대기중인 모든 애니메이션을 제거하고 일치하는 요소에 대한 모든 애니메이션을 완료하십시오.</target>
        </trans-unit>
        <trans-unit id="730b19e05abb84da614a729159208dbad5760180" translate="yes" xml:space="preserve">
          <source>Store arbitrary data associated with the matched elements or return the value at the named data store for the first element in the set of matched elements.</source>
          <target state="translated">일치하는 요소와 연관된 임의의 데이터를 저장하거나 일치하는 요소 세트의 첫 번째 요소에 대한 명명 된 데이터 저장소의 값을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="e3dc887795a3e079473d37947acd076182b16d12" translate="yes" xml:space="preserve">
          <source>Store arbitrary data associated with the specified element and/or return the value that was set.</source>
          <target state="translated">지정된 요소와 관련된 임의의 데이터를 저장하거나 설정된 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="664d4a46b20ef3413abe6dbdc69b1b8e5fa252f8" translate="yes" xml:space="preserve">
          <source>Store then retrieve a value from the div element.</source>
          <target state="translated">그런 다음 div 요소에서 값을 저장하고 검색하십시오.</target>
        </trans-unit>
        <trans-unit id="3df63b7acb0522da685dad5fe84b81fdd7b25264" translate="yes" xml:space="preserve">
          <source>String</source>
          <target state="translated">String</target>
        </trans-unit>
        <trans-unit id="817372deb37d508cf48353c2e5bf45228819ce79" translate="yes" xml:space="preserve">
          <source>Success Callback</source>
          <target state="translated">성공 콜백</target>
        </trans-unit>
        <trans-unit id="c0a6e449ed284b809fa46d3ad6117b4a8d99830e" translate="yes" xml:space="preserve">
          <source>Supported Flags</source>
          <target state="translated">지원되는 플래그</target>
        </trans-unit>
        <trans-unit id="10f2d5c8838556785eaa3ee02d811f2678905e69" translate="yes" xml:space="preserve">
          <source>Suppose we have a couple short lists on a page:</source>
          <target state="translated">페이지에 몇 개의 짧은 목록이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e3dda79ad5c100cb272fb6d078c82f63541c7299" translate="yes" xml:space="preserve">
          <source>Suppose we perform a search for &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; elements starting at item A:</source>
          <target state="translated">항목 A에서 시작 하는 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 요소를 검색한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="a94ae9bded1ae99e5c7bcd4f4a8811d18c8089e8" translate="yes" xml:space="preserve">
          <source>Suppose we search for an &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; element instead:</source>
          <target state="translated">대신 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 요소를 검색한다고 가정하십시오 .</target>
        </trans-unit>
        <trans-unit id="b3f888854fd1f1dae92293cac076227ad8552aa0" translate="yes" xml:space="preserve">
          <source>Suppose you have a list, with two of its items containing a child element:</source>
          <target state="translated">하위 요소를 포함하는 두 개의 항목이있는 목록이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="de394c66954399a5ac3332ca39eb0a52c9cc3a47" translate="yes" xml:space="preserve">
          <source>Suppose you have a simple unordered list on the page:</source>
          <target state="translated">페이지에 간단한 순서없는 목록이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="5023b4b6d640dff78ca47b85acb6ff85da25aa61" translate="yes" xml:space="preserve">
          <source>Tags that cannot contain elements may be quick-closed or not:</source>
          <target state="translated">요소를 포함 할 수없는 태그는 빠르게 닫히거나 닫힐 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff582d4a993e914f70aa1f884c48404bf23cf695" translate="yes" xml:space="preserve">
          <source>Takes a function and returns a new one that will always have a particular context.</source>
          <target state="translated">함수를 가져 와서 항상 특정 컨텍스트를 갖는 새로운 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b315f328325b2a0bd0f452ff3b9e918b0b280b19" translate="yes" xml:space="preserve">
          <source>Takes a string and throws an exception containing it.</source>
          <target state="translated">문자열을 가져와 문자열을 포함하는 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="e4e25174b34707da0ca85747ead62e6979587ad7" translate="yes" xml:space="preserve">
          <source>Takes a well-formed JSON string and returns the resulting JavaScript value.</source>
          <target state="translated">올바른 형식의 JSON 문자열을 가져와 결과 JavaScript 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1321935cf4ff7f35cc8aa281970434f1a46233a9" translate="yes" xml:space="preserve">
          <source>Test a few parameter examples.</source>
          <target state="translated">몇 가지 매개 변수 예를 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="c3328c39b0e29f78e9ff45db674248b1d245887d" translate="yes" xml:space="preserve">
          <source>Text</source>
          <target state="translated">Text</target>
        </trans-unit>
        <trans-unit id="2959942028f362a86c6adc899a4d28fb0893b838" translate="yes" xml:space="preserve">
          <source>Text is a node of the Document Object Model (DOM) that represents the textual content of an &lt;a href=&quot;#Element&quot;&gt;element&lt;/a&gt; or an attribute. Consider the following code:</source>
          <target state="translated">텍스트는 &lt;a href=&quot;#Element&quot;&gt;요소&lt;/a&gt; 또는 속성 의 텍스트 내용을 나타내는 DOM (Document Object Model)의 노드입니다 . 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="b88fca4b677e265570d1591da41082afd6bd654a" translate="yes" xml:space="preserve">
          <source>That line of code will replace everything inside &lt;code&gt;&amp;lt;div class=&quot;demo-container&quot;&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">해당 코드 줄은 &lt;code&gt;&amp;lt;div class=&quot;demo-container&quot;&amp;gt;&lt;/code&gt; 내의 모든 것을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="4ecaa7688dde754c54b4ca5ee2f1ea5f31249d7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.Callbacks()&lt;/code&gt; function is internally used to provide the base functionality behind the jQuery &lt;code&gt;$.ajax()&lt;/code&gt; and &lt;code&gt;$.Deferred()&lt;/code&gt; components. It can be used as a similar base to define functionality for new components.</source>
          <target state="translated">&lt;code&gt;$.Callbacks()&lt;/code&gt; 함수는 내부적으로 jQuery를 뒤에 기본 기능 제공하는 데 사용됩니다 &lt;code&gt;$.ajax()&lt;/code&gt; 와 &lt;code&gt;$.Deferred()&lt;/code&gt; 구성 요소를. 새 구성 요소의 기능을 정의하기 위해 유사한 기반으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="baa0d6b0d0bf85d2143bf56d29a81b4ad34efa9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.ajax()&lt;/code&gt; function returns the &lt;code&gt;XMLHttpRequest&lt;/code&gt; object that it creates. Normally jQuery handles the creation of this object internally, but a custom function for manufacturing one can be specified using the &lt;code&gt;xhr&lt;/code&gt; option. The returned object can generally be discarded, but does provide a lower-level interface for observing and manipulating the request. In particular, calling &lt;code&gt;.abort()&lt;/code&gt; on the object will halt the request before it completes.</source>
          <target state="translated">&lt;code&gt;$.ajax()&lt;/code&gt; 함수는 반환 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를 가 생성하는 객체. 일반적으로 jQuery는이 객체의 생성을 내부적으로 처리하지만 &lt;code&gt;xhr&lt;/code&gt; 옵션을 사용하여 객체를 제조하기위한 사용자 정의 함수를 지정할 수 있습니다 . 리턴 된 오브젝트는 일반적으로 버릴 수 있지만 요청을 관찰하고 조작하기위한 하위 레벨 인터페이스를 제공합니다. 특히 객체에서 &lt;code&gt;.abort()&lt;/code&gt; 를 호출 하면 요청이 완료되기 전에 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="85e806a32c04f5dde13a7018da32db82f1e28ca1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.ajax()&lt;/code&gt; function underlies all Ajax requests sent by jQuery. It is often unnecessary to directly call this function, as several higher-level alternatives like &lt;code&gt;&lt;a href=&quot;jquery.get&quot;&gt;$.get()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;load&quot;&gt;.load()&lt;/a&gt;&lt;/code&gt; are available and are easier to use. If less common options are required, though, &lt;code&gt;$.ajax()&lt;/code&gt; can be used more flexibly.</source>
          <target state="translated">&lt;code&gt;$.ajax()&lt;/code&gt; 함수는 jQuery를 보낸 모든 Ajax 요청의 기초가. &lt;code&gt;&lt;a href=&quot;jquery.get&quot;&gt;$.get()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;load&quot;&gt;.load()&lt;/a&gt;&lt;/code&gt; 와 같은 여러 가지 고급 대안 을 사용할 수 있고 사용하기 쉽기 때문에이 함수를 직접 호출 할 필요가없는 경우가 많습니다 . 덜 일반적인 옵션이 필요한 경우 &lt;code&gt;$.ajax()&lt;/code&gt; 를보다 유연하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78f47b93498ccbc5b58c88ddb2f471b1580524b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.ajaxPrefilter()&lt;/code&gt; method can also redirect a request to another dataType by returning that dataType. For example, the following sets a request as &quot;script&quot; if the URL has some specific properties defined in a custom &lt;code&gt;isActuallyScript()&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;$.ajaxPrefilter()&lt;/code&gt; 메소드는 것을 dataType와 리턴하여 또 다른 데이터 유형 요청을 리다이렉트 할 수있다. 예를 들어 다음은 URL에 사용자 정의 &lt;code&gt;isActuallyScript()&lt;/code&gt; 함수에 정의 된 특정 속성이있는 경우 요청을 &quot;스크립트&quot;로 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="280a781cf37dc5a0c87a93c392263fe532ae9059" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.browser&lt;/code&gt; property provides information about the web browser that is accessing the page, as reported by the browser itself. It contains flags for each of the four most prevalent browser classes (Internet Explorer, Mozilla, Webkit, and Opera) as well as version information.</source>
          <target state="translated">&lt;code&gt;$.browser&lt;/code&gt; 속성은 브라우저 자체에 의해보고 된 페이지에 액세스하는 웹 브라우저에 대한 정보를 제공합니다. 여기에는 가장 널리 사용되는 네 가지 브라우저 클래스 (Internet Explorer, Mozilla, Webkit 및 Opera) 및 버전 정보 각각에 대한 플래그가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="76431104c95bae4a44864ebbfd713ef401ebe1b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.contains()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the DOM element provided by the second argument is a descendant of the DOM element provided by the first argument, whether it is a direct child or nested more deeply. Otherwise, it returns &lt;code&gt;false&lt;/code&gt;. Only &lt;em&gt;element&lt;/em&gt; nodes are supported; if the second argument is a text or comment node, &lt;code&gt;$.contains()&lt;/code&gt; will return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$.contains()&lt;/code&gt; 메소드는 반환 &lt;code&gt;true&lt;/code&gt; 번째 인수에 의해 제공된 DOM 요소가 직접적인 자식 이상의 중첩 여부 첫번째 인수에 의해 제공된 DOM 요소의 자손 인 경우. 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 만 &lt;em&gt;요소&lt;/em&gt; 노드를 지원합니다; 두 번째 인수가 텍스트 또는 주석 노드 인 경우 &lt;code&gt;$.contains()&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="09588521748ac438e7c26cbe3f00a85e140fd816" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.cssHooks&lt;/code&gt; object provides a way to define functions for getting and setting particular CSS values. It can also be used to create new cssHooks for normalizing CSS3 features such as box shadows and gradients.</source>
          <target state="translated">&lt;code&gt;$.cssHooks&lt;/code&gt; 객체는 점점 특히 CSS 값을 설정하는 함수를 정의하는 방법을 제공합니다. 또한 상자 그림자 및 그라디언트와 같은 CSS3 기능을 정규화하기 위해 새로운 cssHook을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e4337150a1d2bb6fc88e8b469d5a24912766d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.each()&lt;/code&gt; function is not the same as &lt;a href=&quot;each&quot;&gt;$(selector).each()&lt;/a&gt;, which is used to iterate, exclusively, over a jQuery object. The &lt;code&gt;$.each()&lt;/code&gt; function can be used to iterate over any collection, whether it is an object or an array. In the case of an array, the callback is passed an array index and a corresponding array value each time. (The value can also be accessed through the &lt;code&gt;this&lt;/code&gt; keyword, but Javascript will always wrap the &lt;code&gt;this&lt;/code&gt; value as an &lt;code&gt;Object&lt;/code&gt; even if it is a simple string or number value.) The method returns its first argument, the object that was iterated.</source>
          <target state="translated">&lt;code&gt;$.each()&lt;/code&gt; 함수와 동일하지 &lt;a href=&quot;each&quot;&gt;$ (선택기) .each ()&lt;/a&gt; JQuery와 객체에 걸쳐 독점적으로 반복 사용된다. &lt;code&gt;$.each()&lt;/code&gt; 함수는 객체 또는 배열인지 모든 컬렉션을 반복하는데 사용될 수있다. 배열의 경우 콜백은 매번 배열 인덱스와 해당 배열 값을 전달받습니다. ( &lt;code&gt;this&lt;/code&gt; 키워드를 통해 값에 액세스 할 수도 있지만 Javascript는 &lt;code&gt;this&lt;/code&gt; 값을 단순한 문자열 또는 숫자 값인 경우에도 항상 이 값을 &lt;code&gt;Object&lt;/code&gt; 로 래핑합니다 .)이 메소드는 첫 번째 인수 인 반복 된 오브젝트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="976cdb1065014cb534e388a99a8c84685e8767eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.grep()&lt;/code&gt; method removes items from an array as necessary so that all remaining items pass a provided test. The test is a function that is passed an array item and the index of the item within the array. Only if the test returns true will the item be in the result array.</source>
          <target state="translated">&lt;code&gt;$.grep()&lt;/code&gt; 메소드는 나머지 모든 항목이 제공되는 테스트를 통과 할 필요 않도록 배열로부터 항목을 제거한다. 테스트는 배열 항목과 배열 내 항목의 색인에 전달되는 함수입니다. 테스트가 true를 반환하는 경우에만 항목이 결과 배열에있게됩니다.</target>
        </trans-unit>
        <trans-unit id="18acd609107b58ff2cf0d3332965bdfb5cabf43b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.holdReady()&lt;/code&gt; method allows the caller to delay jQuery's ready event. This &lt;em&gt;advanced feature&lt;/em&gt; would typically be used by dynamic script loaders that want to load additional JavaScript such as jQuery plugins before allowing the ready event to occur, even though the DOM may be ready. This method must be called early in the document, such as in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; immediately after the jQuery script tag. Calling this method after the ready event has already fired will have no effect.</source>
          <target state="translated">&lt;code&gt;$.holdReady()&lt;/code&gt; 메소드는 지연 jQuery의 ready 이벤트를 호출 할 수 있습니다. 이 &lt;em&gt;고급 기능&lt;/em&gt; 은 일반적으로 DOM이 준비되어 있어도 ready 이벤트가 발생하기 전에 jQuery 플러그인과 같은 추가 JavaScript를로드하려는 동적 스크립트 로더에서 사용됩니다. 이 메소드는 jQuery 스크립트 태그 바로 다음의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 에서와 같이 문서의 초기에 호출되어야합니다 . ready 이벤트가 이미 발생한 후이 메소드를 호출해도 아무런 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="335a19e8e8e4eb5696bfd5f99305e44eff1fcc42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.inArray()&lt;/code&gt; method is similar to JavaScript's native &lt;code&gt;.indexOf()&lt;/code&gt; method in that it returns -1 when it doesn't find a match. If the first element within the array matches &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;$.inArray()&lt;/code&gt; returns 0.</source>
          <target state="translated">&lt;code&gt;$.inArray()&lt;/code&gt; 메소드는 자바 스크립트의 기본과 유사 &lt;code&gt;.indexOf()&lt;/code&gt; 가 반환 -1 일치하는 항목을 찾을 수없는 경우에 방법. 배열의 첫 번째 요소가 &lt;code&gt;value&lt;/code&gt; 와 일치 하면 &lt;code&gt;$.inArray()&lt;/code&gt; 는 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="47c6ed7fef66d2169b4d3861ee6d20f7f3defb90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.isNumeric()&lt;/code&gt; method checks whether its argument represents a numeric value. If so, it returns &lt;code&gt;true&lt;/code&gt;. Otherwise it returns &lt;code&gt;false&lt;/code&gt;. The argument can be of any type.</source>
          <target state="translated">&lt;code&gt;$.isNumeric()&lt;/code&gt; 는 인수는 수치 값을 나타내는 지 여부를 검사 방법. 그렇다면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 인수는 모든 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d054908ceec703f2328081f3828c696c4e4831cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.map()&lt;/code&gt; method applies a function to each item in an array or object and maps the results into a new array. &lt;strong&gt;Prior to jQuery 1.6&lt;/strong&gt;, &lt;code&gt;$.map()&lt;/code&gt; supports traversing &lt;em&gt;arrays only&lt;/em&gt;. &lt;strong&gt;As of jQuery 1.6&lt;/strong&gt; it also traverses objects.</source>
          <target state="translated">&lt;code&gt;$.map()&lt;/code&gt; 메소드는 어레이 또는 개체의 각 항목에 함수를 적용하여 새로운 배열 결과를 매핑한다. &lt;strong&gt;이전 jQuery를 1.6&lt;/strong&gt; , &lt;code&gt;$.map()&lt;/code&gt; 지원은 통과 &lt;em&gt;에만 배열&lt;/em&gt; . &lt;strong&gt;jQuery 1.6&lt;/strong&gt; 부터는 객체를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="79d04e01527feacc55c26314c81ca0af5fa41181" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.merge()&lt;/code&gt; operation forms an array that contains all elements from the two arrays. The orders of items in the arrays are preserved, with items from the second array appended. The &lt;code&gt;$.merge()&lt;/code&gt; function is destructive. It alters the &lt;code&gt;length&lt;/code&gt; and numeric index properties of the first object to include items from the second.</source>
          <target state="translated">&lt;code&gt;$.merge()&lt;/code&gt; 연산은 두 어레이의 모든 요소를 포함하는 배열을 형성한다. 배열의 항목 순서는 유지되며 두 번째 배열의 항목이 추가됩니다. &lt;code&gt;$.merge()&lt;/code&gt; 함수는 파괴된다. 첫 번째 개체 의 &lt;code&gt;length&lt;/code&gt; 및 숫자 인덱스 속성을 변경 하여 두 번째 항목을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="2c9302d36417008fe5659ed352ae46a989c038b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.now()&lt;/code&gt; method is a shorthand for the number returned by the expression &lt;code&gt;(new Date).getTime()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$.now()&lt;/code&gt; 메서드는 표현에 의해 반환 된 번호에 대한 속기 &lt;code&gt;(new Date).getTime()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb8e0aa345948427cd7df6c456a7940fd1ca6ecb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.now()&lt;/code&gt; method is an alias for &lt;code&gt;Date.now()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;$.now()&lt;/code&gt; 메소드가의 별칭입니다 &lt;code&gt;Date.now()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7808931143ef016b797914190e650d2a76779e1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.speed()&lt;/code&gt; method provides a way to define properties, such as &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;easing&lt;/code&gt;, and &lt;code&gt;queue&lt;/code&gt;, to use in a custom animation. By using it, you don't have to implement the logic that deals with default values and optional parameters.</source>
          <target state="translated">&lt;code&gt;$.speed()&lt;/code&gt; 메소드와 같은 특성을 정의하는 방법을 제공하는 &lt;code&gt;duration&lt;/code&gt; , &lt;code&gt;easing&lt;/code&gt; 및 &lt;code&gt;queue&lt;/code&gt; 정의하는 애니메이션을 사용. 이를 사용하면 기본값 및 선택적 매개 변수를 처리하는 논리를 구현할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="95ec78e912c92bddbb313103bfc5523271e0edff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.trim()&lt;/code&gt; function removes all newlines, spaces (including non-breaking spaces), and tabs from the beginning and end of the supplied string. If these whitespace characters occur in the middle of the string, they are preserved.</source>
          <target state="translated">&lt;code&gt;$.trim()&lt;/code&gt; 함수는 시작 및 제공된 문자열의 끝에서 모두 (비 분리 공간 포함) 바꿈, 공백 및 탭을 제거한다. 이러한 공백 문자가 문자열 중간에 나타나면 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c8d204e0e76dbbb80f76478ab9fdc37eb8914624" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.unique()&lt;/code&gt; function searches through an array of objects, sorting the array, and removing any duplicate nodes. A node is considered a duplicate if it is the &lt;em&gt;exact same&lt;/em&gt; node as one already in the array; two different nodes with identical attributes are not considered to be duplicates. This function only works on plain JavaScript arrays of DOM elements, and is chiefly used internally by jQuery. You probably will never need to use it.</source>
          <target state="translated">&lt;code&gt;$.unique()&lt;/code&gt; 오브젝트의 배열을 통해 검색 기능의 배열을 정렬하고, 중복 된 노드를 제거하는 단계를 포함한다. 노드가 이미 배열에있는 노드와 &lt;em&gt;정확히 동일한&lt;/em&gt; 노드 인 경우 중복으로 간주 됩니다. 동일한 속성을 가진 두 개의 서로 다른 노드는 중복으로 간주되지 않습니다. 이 함수는 DOM 요소의 일반 JavaScript 배열에서만 작동하며 주로 jQuery에서 내부적으로 사용됩니다. 당신은 아마 그것을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fbbf462da578ffa3e663692abb85559bd63a2923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.uniqueSort()&lt;/code&gt; function searches through an array of objects, sorting the array, and removing any duplicate nodes. A node is considered a duplicate if it is the &lt;em&gt;exact same&lt;/em&gt; node as one already in the array; two different nodes with identical attributes are not considered to be duplicates. This function only works on plain JavaScript arrays of DOM elements, and is chiefly used internally by jQuery. You probably will never need to use it.</source>
          <target state="translated">&lt;code&gt;$.uniqueSort()&lt;/code&gt; 오브젝트의 배열을 통해 검색 기능의 배열을 정렬하고, 중복 된 노드를 제거하는 단계를 포함한다. 노드가 이미 배열에있는 노드와 &lt;em&gt;정확히 동일한&lt;/em&gt; 노드 인 경우 중복으로 간주 됩니다. 동일한 속성을 가진 두 개의 서로 다른 노드는 중복으로 간주되지 않습니다. 이 함수는 DOM 요소의 일반 JavaScript 배열에서만 작동하며 주로 jQuery에서 내부적으로 사용됩니다. 당신은 아마 그것을 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3a26b22ac15e6d3725fb5a622feda2d98b93c1b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.addBack()&lt;/code&gt; method causes the previous set of DOM elements in the traversal stack to be added to the current set. In the first example, the top stack contains the set resulting from &lt;code&gt;.find(&quot;p&quot;)&lt;/code&gt;. In the second example, &lt;code&gt;.addBack()&lt;/code&gt; adds the previous set of elements on the stack &amp;mdash; in this case &lt;code&gt;$(&quot;div.after-addback&quot;)&lt;/code&gt; &amp;mdash; to the current set, selecting both the div and its enclosed paragraphs.</source>
          <target state="translated">&lt;code&gt;.addBack()&lt;/code&gt; 메소드는 탐색 스택의 DOM 요소의 이전 세트가 현재 세트에 추가되도록한다. 첫 번째 예에서 상단 스택에는 &lt;code&gt;.find(&quot;p&quot;)&lt;/code&gt; 의 결과 집합이 포함 됩니다. 두 번째 예에서 &lt;code&gt;.addBack()&lt;/code&gt; 은 스택의 이전 요소 세트 &lt;code&gt;$(&quot;div.after-addback&quot;)&lt;/code&gt; 이 경우 $ ( &quot;div.after-addback&quot;)) 를 현재 세트에 추가하고 div와 그에 포함 된 단락을 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="ff5d402fb11b41c1beb7b79978b5307c1e688a67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.after()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;insertafter&quot;&gt;.insertAfter()&lt;/a&gt;&lt;/code&gt; methods perform the same task. The major difference is in the syntax&amp;mdash;specifically, in the placement of the content and target. With &lt;code&gt;.after()&lt;/code&gt;, the content to be inserted comes from the method's argument: &lt;code&gt;$(target).after(contentToBeInserted)&lt;/code&gt;. With &lt;code&gt;.insertAfter()&lt;/code&gt;, on the other hand, the content precedes the method and is inserted after the target, which in turn is passed as the &lt;code&gt;.insertAfter()&lt;/code&gt; method's argument: &lt;code&gt;$(contentToBeInserted).insertAfter(target)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.after()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;insertafter&quot;&gt;.insertAfter()&lt;/a&gt;&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 가장 큰 차이점은 구문, 특히 컨텐츠와 대상의 배치에 있습니다. &lt;code&gt;.after()&lt;/code&gt; 사용하면 삽입 할 내용은 메소드의 인수 &lt;code&gt;$(target).after(contentToBeInserted)&lt;/code&gt; 에서옵니다 . 반면에 &lt;code&gt;.insertAfter()&lt;/code&gt; 사용하면 컨텐츠가 메소드보다 우선하며 대상 다음에 삽입되어 &lt;code&gt;.insertAfter()&lt;/code&gt; 메소드의 인수 로 전달됩니다 . &lt;code&gt;$(contentToBeInserted).insertAfter(target)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6002f37ecb223258bee7d949314a826effed37b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.andSelf()&lt;/code&gt; method causes the previous set of DOM elements in the traversal stack to be added to the current set. In the first example, the top stack contains the set resulting from &lt;code&gt;.find(&quot;p&quot;)&lt;/code&gt;. In the second example, &lt;code&gt;.andSelf()&lt;/code&gt; adds the previous set of elements on the stack &amp;mdash; in this case &lt;code&gt;$( &quot;div.after-andself&quot; )&lt;/code&gt; &amp;mdash; to the current set, selecting both the div and its enclosed paragraphs.</source>
          <target state="translated">&lt;code&gt;.andSelf()&lt;/code&gt; 메소드는 탐색 스택의 DOM 요소의 이전 세트가 현재 세트에 추가되도록한다. 첫 번째 예에서 상단 스택에는 &lt;code&gt;.find(&quot;p&quot;)&lt;/code&gt; 의 결과 집합이 포함 됩니다. 두 번째 예에서 &lt;code&gt;.andSelf()&lt;/code&gt; 는 스택의 이전 요소 세트 &lt;code&gt;$( &quot;div.after-andself&quot; )&lt;/code&gt; 이 경우 $ ( &quot;div.after-andself&quot;)) 를 현재 세트에 추가하고 div와 그에 포함 된 단락을 모두 선택합니다.</target>
        </trans-unit>
        <trans-unit id="919f011c3d3d39bb6a99b068c83bfc2e73be152d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.animate()&lt;/code&gt; method allows us to create animation effects on any numeric CSS property. The only required parameter is a plain object of CSS properties. This object is similar to the one that can be sent to the &lt;code&gt;.css()&lt;/code&gt; method, except that the range of properties is more restrictive.</source>
          <target state="translated">&lt;code&gt;.animate()&lt;/code&gt; 메소드는 우리가 어떤 숫자 CSS 속성에 애니메이션 효과를 만들 수 있습니다. 필요한 유일한 매개 변수는 CSS 속성의 일반 객체입니다. 이 객체는 속성 범위가 더 제한적이라는 점을 제외하고 &lt;code&gt;.css()&lt;/code&gt; 메서드 로 보낼 수있는 객체와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="8a0edc3a5b47cab439d4809dfee1aeae2a37c618" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.append()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;appendto&quot;&gt;.appendTo()&lt;/a&gt;&lt;/code&gt; methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With &lt;code&gt;.append()&lt;/code&gt;, the selector expression preceding the method is the container into which the content is inserted. With &lt;code&gt;.appendTo()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted into the target container.</source>
          <target state="translated">&lt;code&gt;.append()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;appendto&quot;&gt;.appendTo()&lt;/a&gt;&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 내용과 대상의 배치에서 구문에 따라 다릅니다. &lt;code&gt;.append()&lt;/code&gt; 사용하면 메서드 앞에있는 선택기식이 내용이 삽입되는 컨테이너입니다. 반면에 &lt;code&gt;.appendTo()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메소드보다 우선하며 대상 컨테이너에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a2a671ee3f926faffbc1079125031f1101d1a675" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.append()&lt;/code&gt; method inserts the specified content as the last child of each element in the jQuery collection (To insert it as the &lt;em&gt;first&lt;/em&gt; child, use &lt;a href=&quot;prepend&quot;&gt;&lt;code&gt;.prepend()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;.append()&lt;/code&gt; 메소드 인서트 JQuery와 컬렉션의 각 요소의 마지막 자식으로서 지정된 콘텐츠 (는 AS 삽입하려면 &lt;em&gt;먼저&lt;/em&gt; 아이 사용 &lt;a href=&quot;prepend&quot;&gt; &lt;code&gt;.prepend()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e7ad01b2fc895e8f2f372219f519cf23a25f27a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.attr()&lt;/code&gt; method gets the attribute value for only the &lt;em&gt;first&lt;/em&gt; element in the matched set. To get the value for each element individually, use a looping construct such as jQuery's &lt;code&gt;.each()&lt;/code&gt; or &lt;code&gt;.map()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;.attr()&lt;/code&gt; 메소드 만에 대한 속성 값을 얻는 &lt;em&gt;제&lt;/em&gt; 매칭 세트 소자. 각 요소의 값을 개별적으로 얻으려면 jQuery의 &lt;code&gt;.each()&lt;/code&gt; 또는 &lt;code&gt;.map()&lt;/code&gt; 메소드 와 같은 루핑 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e56a8d18e9615760f255a389b1a9ee37f18e2f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.attr()&lt;/code&gt; method is a convenient way to set the value of attributes&amp;mdash;especially when setting multiple attributes or using values returned by a function. Consider the following image:</source>
          <target state="translated">&lt;code&gt;.attr()&lt;/code&gt; 메소드는 특성, 특히 여러 속성 설정 또는 함수에 의해 리턴 된 값을 사용하여 값을 설정하는 편리한 방법이다. 다음 이미지를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bcf579ddc9930a5a97c07867bb06cdff64125acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.before()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;insertbefore&quot;&gt;.insertBefore()&lt;/a&gt;&lt;/code&gt; methods perform the same task. The major difference is in the syntax&amp;mdash;specifically, in the placement of the content and target. With &lt;code&gt;.before()&lt;/code&gt;, the content to be inserted comes from the method's argument: &lt;code&gt;$(target).before(contentToBeInserted)&lt;/code&gt;. With &lt;code&gt;.insertBefore()&lt;/code&gt;, on the other hand, the content precedes the method and is inserted before the target, which in turn is passed as the &lt;code&gt;.insertBefore()&lt;/code&gt; method's argument: &lt;code&gt;$(contentToBeInserted).insertBefore(target)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.before()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;insertbefore&quot;&gt;.insertBefore()&lt;/a&gt;&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 가장 큰 차이점은 구문, 특히 컨텐츠와 대상의 배치에 있습니다. &lt;code&gt;.before()&lt;/code&gt; 사용하면 삽입 할 내용이 메소드의 인수 &lt;code&gt;$(target).before(contentToBeInserted)&lt;/code&gt; 에서옵니다 . 반면에 &lt;code&gt;.insertBefore()&lt;/code&gt; 사용하면 컨텐츠가 메소드보다 우선하며 대상 앞에 삽입되어 &lt;code&gt;.insertBefore()&lt;/code&gt; 메소드의 인수 로 전달됩니다 . &lt;code&gt;$(contentToBeInserted).insertBefore(target)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b8b87f3a7319468a08ed6667b0d2ac2a11055e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.children()&lt;/code&gt; method optionally accepts a selector expression of the same type that we can pass to the &lt;code&gt;$()&lt;/code&gt; function. If the selector is supplied, the elements will be filtered by testing whether they match it.</source>
          <target state="translated">&lt;code&gt;.children()&lt;/code&gt; 메소드는 임의로 우리가 전달할 수있는 동일한 타입의 선택 식 수용 &lt;code&gt;$()&lt;/code&gt; 함수. 선택기가 제공되면 요소가 일치하는지 테스트하여 요소가 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="376670c6b2301c9502291bf8dd969cf1f3352e2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.clone()&lt;/code&gt; method performs a &lt;em&gt;deep&lt;/em&gt; copy of the set of matched elements, meaning that it copies the matched elements as well as all of their descendant elements and text nodes.</source>
          <target state="translated">&lt;code&gt;.clone()&lt;/code&gt; 메소드가 행하는 &lt;em&gt;깊은&lt;/em&gt; 일치하는 요소의 세트의 사본 의미가 복사합니다 일치하는 요소뿐만 아니라 자손 요소와 텍스트 노드의 모든.</target>
        </trans-unit>
        <trans-unit id="8b9a721c048b18a223ef22271dcee5ef1ddb0b4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.contents()&lt;/code&gt; method can also be used to get the content document of an iframe, if the iframe is on the same domain as the main page.</source>
          <target state="translated">&lt;code&gt;.contents()&lt;/code&gt; 는 Iframe 메인 페이지와 동일한 도메인에있는 경우에있어서 또한 iframe이 내용 문서를 얻기 위해 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="4478d31ecdf490a0aad5d0fa3bac7b611658e869" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.context&lt;/code&gt; property was deprecated in jQuery 1.10 and is only maintained to the extent needed for supporting &lt;code&gt;.live()&lt;/code&gt; in the jQuery Migrate plugin. It may be removed without notice in a future version.</source>
          <target state="translated">&lt;code&gt;.context&lt;/code&gt; 속성 JQuery와 1.10에서 중단하고 만 지원하는데 필요한 정도까지 유지된다 &lt;code&gt;.live()&lt;/code&gt; JQuery와 이주에 플러그인. 차후 버전에서는 예고없이 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a781319ab4b7c2a3038a7d5f82a3aaa7431f7df3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.css()&lt;/code&gt; method is a convenient way to get a computed style property from the first matched element, especially in light of the different ways browsers access most of those properties (the &lt;code&gt;getComputedStyle()&lt;/code&gt; method in standards-based browsers versus the &lt;code&gt;currentStyle&lt;/code&gt; and &lt;code&gt;runtimeStyle&lt;/code&gt; properties in Internet Explorer prior to version 9) and the different terms browsers use for certain properties. For example, Internet Explorer's DOM implementation refers to the &lt;code&gt;float&lt;/code&gt; property as &lt;code&gt;styleFloat&lt;/code&gt;, while W3C standards-compliant browsers refer to it as &lt;code&gt;cssFloat&lt;/code&gt;. For consistency, you can simply use &lt;code&gt;&quot;float&quot;&lt;/code&gt;, and jQuery will translate it to the correct value for each browser.</source>
          <target state="translated">&lt;code&gt;.css()&lt;/code&gt; 메소드는 특히 브라우저가 해당 속성 (의 대부분에 접근하는 다양한 방법에 비추어, 첫 번째 일치하는 요소로부터 계산 된 스타일 속성을 얻을 수있는 편리한 방법입니다 &lt;code&gt;getComputedStyle()&lt;/code&gt; 대에서 방법 표준 기반 브라우저 &lt;code&gt;currentStyle&lt;/code&gt; 과 버전 9 이전의 Internet Explorer의 &lt;code&gt;runtimeStyle&lt;/code&gt; 속성) 및 브라우저가 특정 속성에 사용하는 다른 용어. 예를 들어 Internet Explorer의 DOM 구현은 &lt;code&gt;float&lt;/code&gt; 속성을 &lt;code&gt;styleFloat&lt;/code&gt; 로 참조하고 W3C 표준 호환 브라우저는이를 &lt;code&gt;cssFloat&lt;/code&gt; 로 참조합니다 . 일관성을 위해 간단히 &lt;code&gt;&quot;float&quot;&lt;/code&gt; 를 사용할 수 있습니다jQuery가이를 각 브라우저의 올바른 값으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4e63aa8b4e036e090afb474846ea3fe671048a78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.data()&lt;/code&gt; method allows us to attach data of any type to DOM elements in a way that is safe from circular references and therefore from memory leaks.</source>
          <target state="translated">&lt;code&gt;.data()&lt;/code&gt; 메소드는 우리가 메모리로부터 누출 따라서 순환 참조에서 안전하고있는 방법으로 DOM 요소에 임의의 타입의 데이터를 첨부 할 수있다.</target>
        </trans-unit>
        <trans-unit id="520ce59174f569a4f598506fbd2fd9742a88c3a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.data()&lt;/code&gt; method allows us to attach data of any type to DOM elements in a way that is safe from circular references and therefore from memory leaks. We can retrieve several distinct values for a single element one at a time, or as a set:</source>
          <target state="translated">&lt;code&gt;.data()&lt;/code&gt; 메소드는 우리가 메모리로부터 누출 따라서 순환 참조에서 안전하고있는 방법으로 DOM 요소에 임의의 타입의 데이터를 첨부 할 수있다. 한 번에 하나씩 또는 한 세트로 단일 요소에 대해 여러 가지 고유 한 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eb426ccd7969912cbc62e5e7a40c10005fc497c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.data()&lt;/code&gt; method allows us to read data previously associated with DOM elements. We can retrieve several distinct values for a single element one at a time, or as a set:</source>
          <target state="translated">&lt;code&gt;.data()&lt;/code&gt; 메소드는 이전에 DOM 요소와 관련된 데이터를 읽을 수있게 해준다. 단일 요소에 대해 한 번에 하나씩 또는 집합으로 여러 고유 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="158ffc844ccad87b3e96192f16f798b3f3d7c3fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.detach()&lt;/code&gt; method is the same as &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;.remove()&lt;/a&gt;&lt;/code&gt;, except that &lt;code&gt;.detach()&lt;/code&gt; keeps all jQuery data associated with the removed elements. This method is useful when removed elements are to be reinserted into the DOM at a later time.</source>
          <target state="translated">&lt;code&gt;.detach()&lt;/code&gt; 방법과 동일 &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;.remove()&lt;/a&gt;&lt;/code&gt; 것을 제외 &lt;code&gt;.detach()&lt;/code&gt; 계속 제거 된 요소와 관련된 모든 데이터의 jQuery. 이 방법은 제거 된 요소를 나중에 DOM에 다시 삽입 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="67fa97b3a1074cefe09d0e33804e73171753c7ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.each()&lt;/code&gt; method is designed to make DOM looping constructs concise and less error-prone. When called it iterates over the DOM elements that are part of the jQuery object. Each time the callback runs, it is passed the current loop iteration, beginning from 0. More importantly, the callback is fired in the context of the current DOM element, so the keyword &lt;code&gt;this&lt;/code&gt; refers to the element.</source>
          <target state="translated">&lt;code&gt;.each()&lt;/code&gt; 메소드는 DOM 반복 구조를 간결하고 덜 오류가 발생하기 쉬운 수 있도록 설계된다. 호출되면 jQuery 객체의 일부인 DOM 요소를 반복합니다. 콜백이 실행될 때마다 0부터 시작하여 현재 루프 반복이 전달됩니다. 더 중요한 것은 콜백이 현재 DOM 요소의 컨텍스트에서 시작되므로 키워드 &lt;code&gt;this&lt;/code&gt; 는 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="06ecbb426b5bd923098b84c44b225e3011c46509" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.fadeIn()&lt;/code&gt; method animates the opacity of the matched elements. It is similar to the &lt;code&gt;&lt;a href=&quot;fadeto&quot;&gt;.fadeTo()&lt;/a&gt;&lt;/code&gt; method but that method does not unhide the element and can specify the final opacity level.</source>
          <target state="translated">&lt;code&gt;.fadeIn()&lt;/code&gt; 메소드는 유사한 요소의 불투명도를 부여한다. &lt;code&gt;&lt;a href=&quot;fadeto&quot;&gt;.fadeTo()&lt;/a&gt;&lt;/code&gt; 메소드 와 유사 하지만 해당 메소드가 요소를 숨기기 해제하지 않으며 최종 불투명도 레벨을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="062775b18ef73fe8687369620f45e3672d9a3cc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.fadeOut()&lt;/code&gt; method animates the opacity of the matched elements. Once the opacity reaches 0, the &lt;code&gt;display&lt;/code&gt; style property is set to &lt;code&gt;none&lt;/code&gt;, so the element no longer affects the layout of the page.</source>
          <target state="translated">&lt;code&gt;.fadeOut()&lt;/code&gt; 메소드는 유사한 요소의 불투명도를 부여한다. 불투명도가 0에 도달하면 &lt;code&gt;display&lt;/code&gt; 스타일 속성이 &lt;code&gt;none&lt;/code&gt; 으로 설정되어 요소가 더 이상 페이지 레이아웃에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b666255a099fb53345e3339662753b6bc22c363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.fadeTo()&lt;/code&gt; method animates the opacity of the matched elements. It is similar to the &lt;code&gt;&lt;a href=&quot;fadein&quot;&gt;.fadeIn()&lt;/a&gt;&lt;/code&gt; method but that method unhides the element and always fades to 100% opacity.</source>
          <target state="translated">&lt;code&gt;.fadeTo()&lt;/code&gt; 메소드는 유사한 요소의 불투명도를 부여한다. &lt;code&gt;&lt;a href=&quot;fadein&quot;&gt;.fadeIn()&lt;/a&gt;&lt;/code&gt; 메서드 와 비슷 하지만이 메서드는 요소를 숨기지 않고 항상 100 % 불투명도로 희미 해집니다.</target>
        </trans-unit>
        <trans-unit id="87aefadc97e63343a3f198143ffa44473891ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.fadeToggle()&lt;/code&gt; method animates the opacity of the matched elements. When called on a visible element, the element's &lt;code&gt;display&lt;/code&gt; style property is set to &lt;code&gt;none&lt;/code&gt; once the opacity reaches 0, so the element no longer affects the layout of the page.</source>
          <target state="translated">&lt;code&gt;.fadeToggle()&lt;/code&gt; 메소드는 유사한 요소의 불투명도를 부여한다. 보이는 요소에서 호출 되면 불투명도가 0에 도달하면 요소의 &lt;code&gt;display&lt;/code&gt; 스타일 속성이 &lt;code&gt;none&lt;/code&gt; 으로 설정 되므로 요소가 더 이상 페이지 레이아웃에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="49e81e00b99900cc2b7acf2d3e6518a653013144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.finish()&lt;/code&gt; method is similar to &lt;code&gt;.stop(true, true)&lt;/code&gt; in that it clears the queue and the current animation jumps to its end value. It differs, however, in that &lt;code&gt;.finish()&lt;/code&gt; also causes the CSS property of all &lt;em&gt;queued&lt;/em&gt; animations to jump to their end values, as well.</source>
          <target state="translated">&lt;code&gt;.finish()&lt;/code&gt; 방법과 유사한 &lt;code&gt;.stop(true, true)&lt;/code&gt; 는 큐 클리어 현재 애니메이션의 최종 값으로 이동하는 것이있다. 그러나 &lt;code&gt;.finish()&lt;/code&gt; 로 인해 &lt;em&gt;대기중인&lt;/em&gt; 모든 애니메이션 의 CSS 속성도 최종 값 으로 이동한다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7004a34e94299568cb1b51c71e5fac930bc66ef5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.get()&lt;/code&gt; method grants access to the DOM nodes underlying each jQuery object. If the value of &lt;code&gt;index&lt;/code&gt; is out of bounds &amp;mdash; less than the negative number of elements or equal to or greater than the number of elements &amp;mdash; it returns &lt;code&gt;undefined&lt;/code&gt;. Consider a simple unordered list:</source>
          <target state="translated">&lt;code&gt;.get()&lt;/code&gt; 메소드는, 각각의 jQuery 오브젝트의 기초가되는 DOM 노드에 대한 액세스 권한을 부여. &lt;code&gt;index&lt;/code&gt; 값이 -요소 수보다 작거나 요소 수보다 크거나 같은 범위를 벗어나면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 . 간단한 비 순차 목록을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c12b1ce92b56f787255c4845c73032ecb78d6a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hasClass()&lt;/code&gt; method will return &lt;code&gt;true&lt;/code&gt; if the class is assigned to an element, even if other classes also are. For example, given the HTML above, the following will return &lt;code&gt;true&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.hasClass()&lt;/code&gt; 메소드는 반환 &lt;code&gt;true&lt;/code&gt; 클래스가 요소에 할당되어있는 경우 다른 클래스는 경우에도. 예를 들어, 위의 HTML이 주어지면 다음이 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="ad9dc0cc34c77e937afc19320e0d5f30f2869953" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hover()&lt;/code&gt; method binds handlers for both &lt;code&gt;mouseenter&lt;/code&gt; and &lt;code&gt;mouseleave&lt;/code&gt; events. You can use it to simply apply behavior to an element during the time the mouse is within the element.</source>
          <target state="translated">&lt;code&gt;.hover()&lt;/code&gt; 모두 방법 바인딩 핸들러 &lt;code&gt;mouseenter&lt;/code&gt; 와 &lt;code&gt;mouseleave&lt;/code&gt; 이벤트. 이를 사용하여 마우스가 요소 내에있는 동안 요소에 동작을 간단히 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7352679d5961ada2dc857d5b790b2d2e8264e63d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.hover()&lt;/code&gt; method, when passed a single function, will execute that handler for both &lt;code&gt;mouseenter&lt;/code&gt; and &lt;code&gt;mouseleave&lt;/code&gt; events. This allows the user to use jQuery's various toggle methods within the handler or to respond differently within the handler depending on the &lt;code&gt;event.type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.hover()&lt;/code&gt; 단일 함수를 통과 할 때 방법은 모두 그 핸들러를 실행한다 &lt;code&gt;mouseenter&lt;/code&gt; 및 &lt;code&gt;mouseleave&lt;/code&gt; 이벤트. 이를 통해 사용자는 핸들러 내에서 jQuery의 다양한 토글 메소드를 사용하거나 &lt;code&gt;event.type&lt;/code&gt; 에 따라 핸들러 내에서 다르게 응답 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="34735eda31f0d0c8a8865a97a386f992d2171c2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.html()&lt;/code&gt; method is not available in XML documents.</source>
          <target state="translated">&lt;code&gt;.html()&lt;/code&gt; 메서드는 XML 문서에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5c9b7c19cf9c9bec38c117b9596dfa64b3f5ec8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.jquery&lt;/code&gt; property is assigned to the jQuery prototype, commonly referred to by its alias &lt;code&gt;$.fn&lt;/code&gt;. It is a string containing the version number of &lt;code&gt;jQuery&lt;/code&gt;, such as &quot;1.5.0&quot; or &quot;1.4.4&quot;.</source>
          <target state="translated">&lt;code&gt;.jquery&lt;/code&gt; 의 속성은 jQuery를 프로토 타입, 일반적으로 그 별명에 의해 참조에 할당 된 &lt;code&gt;$.fn&lt;/code&gt; . &quot;1.5.0&quot;또는 &quot;1.4.4&quot;와 같은 &lt;code&gt;jQuery&lt;/code&gt; 버전 번호를 포함하는 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="a617625fc09fff48a482b47a3b9afcbd0fd42a1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.live()&lt;/code&gt; method for binding event handlers uses this property to determine the root element to use for its event delegation needs.</source>
          <target state="translated">&lt;code&gt;.live()&lt;/code&gt; 이벤트 핸들러를 바인딩하는 방법은 이벤트 위임의 요구에 사용할 수있는 루트 요소를 확인하려면이 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="96ea412065b77012ef071db4ab1032df2d1e8056" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.live()&lt;/code&gt; method interacts with other event methods in ways that can be surprising, e.g., &lt;code&gt;$( document ).off( &quot;click&quot; )&lt;/code&gt; removes all click handlers attached by any call to &lt;code&gt;.live()&lt;/code&gt;!</source>
          <target state="translated">&lt;code&gt;.live()&lt;/code&gt; , 놀라게 할 수있는 방법 다른 이벤트 방법과 방법의 상호 작용 예를 들어, &lt;code&gt;$( document ).off( &quot;click&quot; )&lt;/code&gt; 모든 호출에 의해 연결된 모든 클릭 처리기 제거 &lt;code&gt;.live()&lt;/code&gt; !</target>
        </trans-unit>
        <trans-unit id="01c7cdb110bb60a90c982c7bb988effecba4e9a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.load()&lt;/code&gt; method, unlike &lt;code&gt;&lt;a href=&quot;jquery.get&quot;&gt;$.get()&lt;/a&gt;&lt;/code&gt;, allows us to specify a portion of the remote document to be inserted. This is achieved with a special syntax for the &lt;code&gt;url&lt;/code&gt; parameter. If one or more space characters are included in the string, the portion of the string following the first space is assumed to be a jQuery selector that determines the content to be loaded.</source>
          <target state="translated">&lt;code&gt;.load()&lt;/code&gt; 메소드는 달리 &lt;code&gt;&lt;a href=&quot;jquery.get&quot;&gt;$.get()&lt;/a&gt;&lt;/code&gt; , 우리는 원격 문서의 일부가 삽입되도록 지정할 수있다. 이것은 &lt;code&gt;url&lt;/code&gt; 매개 변수에 대한 특수 구문으로 수행 됩니다. 하나 이상의 공백 문자가 문자열에 포함 된 경우 첫 번째 공백 다음의 문자열 부분은로드 할 컨텐츠를 결정하는 jQuery 선택기로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="3944fabbd1d606011ac39735a016c7231097a28b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.map()&lt;/code&gt; method is particularly useful for getting or setting the value of a collection of elements. Consider a form with a set of checkboxes in it:</source>
          <target state="translated">&lt;code&gt;.map()&lt;/code&gt; 메소드는 점점 또는 요소의 모음의 값을 설정하는데 특히 유용하다. 확인란이있는 양식을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bcc25be925e63e21a2f6b44a5ddf92f0365ce360" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.off()&lt;/code&gt; method removes event handlers that were attached with &lt;a href=&quot;on&quot;&gt;&lt;code&gt;.on()&lt;/code&gt;&lt;/a&gt;. See the discussion of delegated and directly bound events on that page for more information. Calling &lt;code&gt;.off()&lt;/code&gt; with no arguments removes all handlers attached to the elements. Specific event handlers can be removed on elements by providing combinations of event names, namespaces, selectors, or handler function names. &lt;strong&gt;When multiple filtering arguments are given, all of the arguments provided must match for the event handler to be removed.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;.off()&lt;/code&gt; 메소드가 부착 된 이벤트 핸들러 제거 &lt;a href=&quot;on&quot;&gt; &lt;code&gt;.on()&lt;/code&gt; &lt;/a&gt; . 자세한 내용은 해당 페이지에서 위임 된 이벤트 및 직접 바인딩 된 이벤트에 대한 설명을 참조하십시오. 인수없이 &lt;code&gt;.off()&lt;/code&gt; 를 호출 하면 요소에 연결된 모든 핸들러가 제거됩니다. 이벤트 이름, 네임 스페이스, 선택기 또는 핸들러 함수 이름의 조합을 제공하여 요소에서 특정 이벤트 핸들러를 제거 할 수 있습니다. &lt;strong&gt;여러 필터링 인수가 제공되면 이벤트 핸들러를 제거하려면 제공된 모든 인수가 일치해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db7e0e81a50ab84b4a804b6e7954e6386c082532" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.offset()&lt;/code&gt; method allows us to retrieve the current position of an element (specifically its border box, which excludes margins) &lt;em&gt;relative to the document&lt;/em&gt;. Contrast this with &lt;code&gt;&lt;a href=&quot;position&quot;&gt;.position()&lt;/a&gt;&lt;/code&gt;, which retrieves the current position &lt;em&gt;relative to the offset parent&lt;/em&gt;. When positioning a new element on top of an existing one for global manipulation (in particular, for implementing drag-and-drop), &lt;code&gt;.offset()&lt;/code&gt; is more useful.</source>
          <target state="translated">&lt;code&gt;.offset()&lt;/code&gt; 메소드는 우리가 요소 (구체적으로는 경계 박스 제외 마진)의 현재 위치를 검색 할 수있는 &lt;em&gt;문서에 대하여&lt;/em&gt; . 이것을 &lt;em&gt;오프셋 parent와 관련된&lt;/em&gt; 현재 위치를 검색하는 &lt;code&gt;&lt;a href=&quot;position&quot;&gt;.position()&lt;/a&gt;&lt;/code&gt; 과 대조하십시오 . 전역 조작 (특히, 끌어서 놓기 구현)을 위해 기존 요소 위에 새 요소를 배치 할 때 &lt;code&gt;.offset()&lt;/code&gt; 이 더 유용합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7fa7f613fb65aa1a55422d29979d55d20abbd326" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.offset()&lt;/code&gt; setter method allows us to reposition an element. The element's border-box position is specified &lt;em&gt;relative to the document&lt;/em&gt;. If the element's &lt;code&gt;position&lt;/code&gt; style property is currently &lt;code&gt;static&lt;/code&gt;, it will be set to &lt;code&gt;relative&lt;/code&gt; to allow for this repositioning.</source>
          <target state="translated">&lt;code&gt;.offset()&lt;/code&gt; setter 메소드는 우리가 요소의 위치를 변경 할 수 있습니다. 요소의 경계 상자 위치는 &lt;em&gt;문서를 기준으로&lt;/em&gt; 지정됩니다 . 요소의 &lt;code&gt;position&lt;/code&gt; 스타일 속성이 현재 &lt;code&gt;static&lt;/code&gt; 인 경우이 재배치가 가능하도록 &lt;code&gt;relative&lt;/code&gt; 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="a272de06ce611fd779824d215b629102bca4911d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.on()&lt;/code&gt; method attaches event handlers to the currently selected set of elements in the jQuery object. As of jQuery 1.7, the &lt;code&gt;.on()&lt;/code&gt; method provides all functionality required for attaching event handlers. For help in converting from older jQuery event methods, see &lt;a href=&quot;bind&quot;&gt;&lt;code&gt;.bind()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;delegate&quot;&gt;&lt;code&gt;.delegate()&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;live&quot;&gt;&lt;code&gt;.live()&lt;/code&gt;&lt;/a&gt;. To remove events bound with &lt;code&gt;.on()&lt;/code&gt;, see &lt;a href=&quot;off&quot;&gt;&lt;code&gt;.off()&lt;/code&gt;&lt;/a&gt;. To attach an event that runs only once and then removes itself, see &lt;a href=&quot;one&quot;&gt;&lt;code&gt;.one()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;.on()&lt;/code&gt; 메소드는 jQuery 오브젝트 요소의 현재 선택된 세트의 이벤트 핸들러를 첨부. jQuery 1.7부터 &lt;code&gt;.on()&lt;/code&gt; 메소드는 이벤트 핸들러를 첨부하는 데 필요한 모든 기능을 제공합니다. 이전의 jQuery 이벤트 방식으로 변환에 대한 도움말을 참조하십시오 &lt;a href=&quot;bind&quot;&gt; &lt;code&gt;.bind()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;delegate&quot;&gt; &lt;code&gt;.delegate()&lt;/code&gt; &lt;/a&gt; , 및 &lt;a href=&quot;live&quot;&gt; &lt;code&gt;.live()&lt;/code&gt; &lt;/a&gt; . 와 결합 된 이벤트 제거 &lt;code&gt;.on()&lt;/code&gt; 참조 &lt;a href=&quot;off&quot;&gt; &lt;code&gt;.off()&lt;/code&gt; &lt;/a&gt; . 한 번만 실행 된 다음 자체 이벤트를 제거하려면 &lt;a href=&quot;one&quot;&gt; &lt;code&gt;.one()&lt;/code&gt; &lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="645c8dceaecbd4770000aadcc5a20e7cb42f53d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.one()&lt;/code&gt; method is identical to &lt;code&gt;.on()&lt;/code&gt;, except that the handler for a given element and event type is unbound after its first invocation. For example:</source>
          <target state="translated">&lt;code&gt;.one()&lt;/code&gt; 방법과 동일 &lt;code&gt;.on()&lt;/code&gt; , 주어진 요소 및 이벤트 유형에 대한 핸들러가 처음 호출 후의 비 결합된다는 점을 제외. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="af016528e5751912d56884465cbb7aa740006e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.parents()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;parent&quot;&gt;.parent()&lt;/a&gt;&lt;/code&gt; methods are similar, except that the latter only travels a single level up the DOM tree. Also, &lt;code&gt;$( &quot;html&quot; ).parent()&lt;/code&gt; method returns a set containing &lt;code&gt;document&lt;/code&gt; whereas &lt;code&gt;$( &quot;html&quot; ).parents()&lt;/code&gt; returns an empty set.</source>
          <target state="translated">&lt;code&gt;.parents()&lt;/code&gt; 와 &lt;code&gt;&lt;a href=&quot;parent&quot;&gt;.parent()&lt;/a&gt;&lt;/code&gt; 후자 만 DOM 트리 최대 단일 레벨을 이동하는 것을 제외하고 방법과 유사하다. 또한 &lt;code&gt;$( &quot;html&quot; ).parent()&lt;/code&gt; 메서드는 &lt;code&gt;document&lt;/code&gt; 포함하는 집합을 반환 하지만 &lt;code&gt;$( &quot;html&quot; ).parents()&lt;/code&gt; 는 빈 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7b7c33fd18c0e46b128a7901820184b28d907678" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.position()&lt;/code&gt; method allows us to retrieve the current position of an element (specifically its margin box) &lt;em&gt;relative to the offset parent&lt;/em&gt; (specifically its padding box, which excludes margins and borders). Contrast this with &lt;code&gt;&lt;a href=&quot;offset&quot;&gt;.offset()&lt;/a&gt;&lt;/code&gt;, which retrieves the current position &lt;em&gt;relative to the document&lt;/em&gt;. When positioning a new element near another one and within the same containing DOM element, &lt;code&gt;.position()&lt;/code&gt; is the more useful.</source>
          <target state="translated">&lt;code&gt;.position()&lt;/code&gt; 메소드는 우리가 요소 (구체적 마진 박스)의 현재 위치를 검색 할 수있는 &lt;em&gt;오프셋에 대해 부모&lt;/em&gt; (즉 패딩 박스를 제외하는 여백 및 테두리). 명암이 &lt;code&gt;&lt;a href=&quot;offset&quot;&gt;.offset()&lt;/a&gt;&lt;/code&gt; 의 현재 위치를 검색하고, &lt;em&gt;문서에 대하여&lt;/em&gt; . 새 요소를 다른 요소 근처에 포함하고 동일한 DOM 요소 내에 배치 할 때는 &lt;code&gt;.position()&lt;/code&gt; 이 더 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8581f6ba7ae84ecb35718c5084ae03b7a5fc4b47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.prepend()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;prependto&quot;&gt;.prependTo()&lt;/a&gt;&lt;/code&gt; methods perform the same task. The major difference is in the syntax&amp;mdash;specifically, in the placement of the content and target. With &lt;code&gt;.prepend()&lt;/code&gt;, the selector expression preceding the method is the container into which the content is inserted. With &lt;code&gt;.prependTo()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted into the target container.</source>
          <target state="translated">&lt;code&gt;.prepend()&lt;/code&gt; 및 &lt;code&gt;&lt;a href=&quot;prependto&quot;&gt;.prependTo()&lt;/a&gt;&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 가장 큰 차이점은 구문, 특히 컨텐츠와 대상의 배치에 있습니다. &lt;code&gt;.prepend()&lt;/code&gt; 사용하면 메소드 앞에있는 선택기 표현식이 컨텐츠가 삽입되는 컨테이너입니다. 반면에 &lt;code&gt;.prependTo()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메소드보다 우선하며 대상 컨테이너에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="74db4525f13cab0cc77a631b7d354c0f8fd76bbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.prepend()&lt;/code&gt; method inserts the specified content as the first child of each element in the jQuery collection (To insert it as the &lt;em&gt;last&lt;/em&gt; child, use &lt;a href=&quot;append&quot;&gt;&lt;code&gt;.append()&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;.prepend()&lt;/code&gt; 메소드 인서트 JQuery와 컬렉션의 각 요소의 첫 번째 자식으로서 지정된 콘텐츠 (는 AS를 삽입하기 위해 &lt;em&gt;마지막&lt;/em&gt; 아이 사용 &lt;a href=&quot;append&quot;&gt; &lt;code&gt;.append()&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e70ed94081943cfae731624da44c4d5273576eb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.promise()&lt;/code&gt; method returns a dynamically generated Promise that is resolved once all actions of a certain type bound to the collection, queued or not, have ended.</source>
          <target state="translated">&lt;code&gt;.promise()&lt;/code&gt; 컬렉션에 바인딩 특정 유형의 모든 행동하면 해결 대기되지 않았거나 메소드가 리턴 동적으로 생성 된 약속은 끝났다.</target>
        </trans-unit>
        <trans-unit id="03b29321ce1c92f36cde79cbab565855893c1edd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.prop()&lt;/code&gt; method gets the property value for only the &lt;em&gt;first&lt;/em&gt; element in the matched set. It returns &lt;code&gt;undefined&lt;/code&gt; for the value of a property that has not been set, or if the matched set has no elements. To get the value for each element individually, use a looping construct such as jQuery's &lt;code&gt;.each()&lt;/code&gt; or &lt;code&gt;.map()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;.prop()&lt;/code&gt; 메소드 만의 속성 값을 얻는 &lt;em&gt;제&lt;/em&gt; 매칭 세트 소자. 설정되지 않은 속성 값 또는 일치하는 집합에 요소가없는 경우 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 . 각 요소의 값을 개별적으로 얻으려면 jQuery의 &lt;code&gt;.each()&lt;/code&gt; 또는 &lt;code&gt;.map()&lt;/code&gt; 메소드 와 같은 루핑 구문을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5ce095d5bd4f19cf6db1858763e51b5719d8d05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.prop()&lt;/code&gt; method is a convenient way to set the value of properties&amp;mdash;especially when setting multiple properties, using values returned by a function, or setting values on multiple elements at once. It should be used when setting &lt;code&gt;selectedIndex&lt;/code&gt;, &lt;code&gt;tagName&lt;/code&gt;, &lt;code&gt;nodeName&lt;/code&gt;, &lt;code&gt;nodeType&lt;/code&gt;, &lt;code&gt;ownerDocument&lt;/code&gt;, &lt;code&gt;defaultChecked&lt;/code&gt;, or &lt;code&gt;defaultSelected&lt;/code&gt;. Since jQuery 1.6, these properties can no longer be set with the &lt;code&gt;.attr()&lt;/code&gt; method. They do not have corresponding attributes and are only properties.</source>
          <target state="translated">&lt;code&gt;.prop()&lt;/code&gt; 메소드는 특성, 특히 함수에 의해 리턴 된 값을 사용하여 여러 속성을 설정하거나, 한 번에 여러 개의 요소 값의 설정 값을 설정하기위한 편리한 방법이다. &lt;code&gt;selectedIndex&lt;/code&gt; , &lt;code&gt;tagName&lt;/code&gt; , &lt;code&gt;nodeName&lt;/code&gt; , &lt;code&gt;nodeType&lt;/code&gt; , &lt;code&gt;ownerDocument&lt;/code&gt; , &lt;code&gt;defaultChecked&lt;/code&gt; 또는 &lt;code&gt;defaultSelected&lt;/code&gt; 를 설정할 때 사용해야합니다 . jQuery 1.6부터는 이러한 속성을 더 이상 &lt;code&gt;.attr()&lt;/code&gt; 메서드 로 설정할 수 없습니다 . 해당 속성이없고 속성 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="658e85773a055f5e1058e298fe6314a906006e63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.queue()&lt;/code&gt; method allows us to directly manipulate this queue of functions. Calling &lt;code&gt;.queue()&lt;/code&gt; with a callback is particularly useful; it allows us to place a new function at the end of the queue. The callback function is executed once for each element in the jQuery set.</source>
          <target state="translated">&lt;code&gt;.queue()&lt;/code&gt; 메소드는 우리가 직접 기능이 큐를 조작 할 수있다. 호출 &lt;code&gt;.queue()&lt;/code&gt; 콜백으로 특별히 유용하다; 대기열 끝에 새로운 기능을 배치 할 수 있습니다. 콜백 함수는 jQuery 세트의 각 요소마다 한 번씩 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dab809c02c354d248b0ee32610b33f65bc9c6ae1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.ready()&lt;/code&gt; method is typically used with an anonymous function:</source>
          <target state="translated">&lt;code&gt;.ready()&lt;/code&gt; 메소드는 일반적으로 익명 함수와 함께 사용된다 :</target>
        </trans-unit>
        <trans-unit id="077d4bdc956042f2c88566c31db4cbfcc7363fe4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.ready()&lt;/code&gt; method offers a way to run JavaScript code as soon as the page's Document Object Model (DOM) becomes safe to manipulate. This will often be a good time to perform tasks that are needed before the user views or interacts with the page, for example to add event handlers and initialize plugins. When multiple functions are added via successive calls to this method, they run when the DOM is ready in the order in which they are added. As of jQuery 3.0, jQuery ensures that an exception occuring in one handler does not prevent subsequently added handlers from executing.</source>
          <target state="translated">&lt;code&gt;.ready()&lt;/code&gt; 메소드 이벤트 페이지의 문서 객체 모델 (DOM)를 조작하기에 안전하게 자마자 자바 스크립트 코드를 실행하는 방법. 이벤트 처리기를 추가하고 플러그인을 초기화하는 등 사용자가 페이지를 보거나 페이지와 상호 작용하기 전에 필요한 작업을 수행하기에 좋은시기입니다. 이 메소드에 대한 연속적인 호출을 통해 여러 함수가 추가되면 DOM이 추가 된 순서대로 준비 될 때 실행됩니다. jQuery 3.0부터 jQuery는 하나의 핸들러에서 발생하는 예외로 인해 이후에 추가 된 핸들러가 실행되는 것을 막지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83bc8e03b021237c11339ba2a1efc2f21d15a5a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.removeAttr()&lt;/code&gt; method uses the JavaScript &lt;code&gt;removeAttribute()&lt;/code&gt; function, but it has the advantage of being able to be called directly on a jQuery object and it accounts for different attribute naming across browsers.</source>
          <target state="translated">&lt;code&gt;.removeAttr()&lt;/code&gt; 메소드는 자바 스크립트를 사용 &lt;code&gt;removeAttribute()&lt;/code&gt; 기능을하지만, 그것은 jQuery를 객체에 직접 호출 할 수있는 장점을 가지고 있으며 브라우저에서 명명 다른 속성 차지한다.</target>
        </trans-unit>
        <trans-unit id="3731546a94484849d0ac8ab85a3029dde61c5913" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.removeData()&lt;/code&gt; method allows us to remove values that were previously set using &lt;code&gt;.data()&lt;/code&gt;. When called with the name of a key, &lt;code&gt;.removeData()&lt;/code&gt; deletes that particular value. When called with no arguments, &lt;code&gt;.removeData()&lt;/code&gt; removes all values.</source>
          <target state="translated">&lt;code&gt;.removeData()&lt;/code&gt; 메소드는 우리가 이전에 사용하여 설정 한 값을 제거 할 수 있습니다 &lt;code&gt;.data()&lt;/code&gt; . 키 이름으로 호출하면 &lt;code&gt;.removeData()&lt;/code&gt; 해당 특정 값을 삭제합니다. 인수없이 호출하면 &lt;code&gt;.removeData()&lt;/code&gt; 는 모든 값을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="2034be3fd4582b7028a473df6aabe0dd58c049f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.removeProp()&lt;/code&gt; method removes properties set by the &lt;code&gt;&lt;a href=&quot;prop&quot;&gt;.prop()&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;.removeProp()&lt;/code&gt; 메소드는 설정 속성을 제거 &lt;code&gt;&lt;a href=&quot;prop&quot;&gt;.prop()&lt;/a&gt;&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="c8addddb62dca0b107eb80169f537d932677c13c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.replaceAll()&lt;/code&gt; method is similar to &lt;code&gt;&lt;a href=&quot;replacewith&quot;&gt;.replaceWith()&lt;/a&gt;&lt;/code&gt;, but with the source and target reversed. Consider this DOM structure:</source>
          <target state="translated">&lt;code&gt;.replaceAll()&lt;/code&gt; 방법과 유사한 &lt;code&gt;&lt;a href=&quot;replacewith&quot;&gt;.replaceWith()&lt;/a&gt;&lt;/code&gt; 하지만, 소스 및 대상 역. 이 DOM 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a4f749be45eb195fd4c23e0fd4ed8e7e1d2c9d7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.replaceAll()&lt;/code&gt; method removes all data and event handlers associated with the removed nodes.</source>
          <target state="translated">&lt;code&gt;.replaceAll()&lt;/code&gt; 메소드가 제거 된 노드와 관련된 모든 데이터, 이벤트 핸들러를 제거한다.</target>
        </trans-unit>
        <trans-unit id="5d74a5b31c932d95002c9ef2ae934fdb08a8e01d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.replaceWith()&lt;/code&gt; method removes all data and event handlers associated with the removed nodes.</source>
          <target state="translated">&lt;code&gt;.replaceWith()&lt;/code&gt; 메소드가 제거 된 노드와 관련된 모든 데이터, 이벤트 핸들러를 제거한다.</target>
        </trans-unit>
        <trans-unit id="35d7d4021234873cff115fe91b4361994144140c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.replaceWith()&lt;/code&gt; method removes content from the DOM and inserts new content in its place with a single call. Consider this DOM structure:</source>
          <target state="translated">&lt;code&gt;.replaceWith()&lt;/code&gt; 단일 호출로 그 자리에 DOM 및 삽입 새로운 콘텐츠의 방법 제거합니다 내용. 이 DOM 구조를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="a9e203e0994b587501030c97a751910f0eeeecbe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.replaceWith()&lt;/code&gt; method, like most jQuery methods, returns the jQuery object so that other methods can be chained onto it. However, it must be noted that the &lt;em&gt;original&lt;/em&gt; jQuery object is returned. This object refers to the element that has been removed from the DOM, not the new element that has replaced it.</source>
          <target state="translated">&lt;code&gt;.replaceWith()&lt;/code&gt; 다른 방법들이 그것에 체인화 될 수있어서, 대부분의 jQuery 방법처럼 jQuery 오브젝트를 반환한다. 그러나 &lt;em&gt;원래&lt;/em&gt; jQuery 객체가 반환됩니다. 이 객체는 대체 된 새 요소가 아니라 DOM에서 제거 된 요소를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="10e5651b768633d3d3742f6a64de99c1edc2dd27" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.selector&lt;/code&gt; property was deprecated in jQuery 1.7 and is only maintained to the extent needed for supporting &lt;code&gt;.live()&lt;/code&gt; in the jQuery Migrate plugin. It may be removed without notice in a future version. The property was never a reliable indicator of the selector that could be used to obtain the set of elements currently contained in the jQuery set where it was a property, since subsequent traversal methods may have changed the set. Plugins that need to use a selector string within their plugin can require it as a parameter of the method. For example, a &quot;foo&quot; plugin could be written as &lt;code&gt;$.fn.foo = function( selector, options ) { /* plugin code goes here */ };&lt;/code&gt;, and the person using the plugin would write &lt;code&gt;$( &quot;div.bar&quot; ).foo( &quot;div.bar&quot;, {dog: &quot;bark&quot;} );&lt;/code&gt; with the &lt;code&gt;&quot;div.bar&quot;&lt;/code&gt; selector repeated as the first argument of &lt;code&gt;.foo()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.selector&lt;/code&gt; 의 속성 JQuery와 1.7 중단하고 만 지원하는데 필요한 정도까지 유지된다 &lt;code&gt;.live()&lt;/code&gt; JQuery와 이주에 플러그인. 차후 버전에서는 예고없이 제거 될 수 있습니다. 이후의 순회 메소드가 세트를 변경했을 가능성이 있기 때문에,이 프로퍼티는 속성이었던 jQuery 세트에 현재 포함되어있는 요소 세트를 얻는 데 사용할 수있는 셀렉터의 신뢰할 수있는 표시기는 결코 아닙니다. 플러그인 내에서 선택기 문자열을 사용해야하는 플러그인은 메소드의 매개 변수로 필요합니다. 예를 들어, &quot;foo&quot;플러그인은 &lt;code&gt;$.fn.foo = function( selector, options ) { /* plugin code goes here */ };&lt;/code&gt; 로 작성 될 수 있습니다. {/ * 플러그인 코드는 여기에 있습니다 * /}; 플러그인을 사용하는 사람은 &lt;code&gt;$( &quot;div.bar&quot; ).foo( &quot;div.bar&quot;, {dog: &quot;bark&quot;} );&lt;/code&gt; 와 &lt;code&gt;&quot;div.bar&quot;&lt;/code&gt; 의 첫번째 인자로 반복 선택기 &lt;code&gt;.foo()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5aca0ee1f61701b4ea28fd1ea3827f8989fb0741" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.serialize()&lt;/code&gt; method creates a text string in standard URL-encoded notation. It can act on a jQuery object that has selected individual form controls, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;: &lt;code&gt;$( &quot;input, textarea, select&quot; ).serialize();&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.serialize()&lt;/code&gt; 메소드는 표준 URL 인코딩 된 표기법에 텍스트 문자열을 만듭니다. &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 와 같이 개별 양식 컨트롤을 선택한 jQuery 객체에서 작동 할 수 있습니다 . &lt;code&gt;$( &quot;input, textarea, select&quot; ).serialize();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9c89836855332a6cd11a6570684abc77c3f88f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.serializeArray()&lt;/code&gt; method creates a JavaScript array of objects, ready to be encoded as a JSON string. It operates on a jQuery collection of &lt;code&gt;form&lt;/code&gt;s and/or form controls. The controls can be of several types:</source>
          <target state="translated">&lt;code&gt;.serializeArray()&lt;/code&gt; 메소드는 JSON 문자열로 인코딩 될 준비가 자바 스크립트 객체의 어레이를 생성한다. &lt;code&gt;form&lt;/code&gt; 및 / 또는 양식 컨트롤의 jQuery 컬렉션에서 작동 합니다. 컨트롤은 여러 유형이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6d35856dae819af217e994ad9f9e6d66e144968" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.serializeArray()&lt;/code&gt; method uses the standard W3C rules for &lt;a href=&quot;https://www.w3.org/TR/html401/interact/forms.html#h-17.13.2&quot;&gt;successful controls&lt;/a&gt; to determine which elements it should include; in particular the element cannot be disabled and must contain a &lt;code&gt;name&lt;/code&gt; attribute. No submit button value is serialized since the form was not submitted using a button. Data from file select elements is not serialized. Elements that do not contain a &lt;code&gt;value&lt;/code&gt; attribute are represented with the empty string value.</source>
          <target state="translated">&lt;code&gt;.serializeArray()&lt;/code&gt; 메소드는 W3C의 표준 규칙을 사용하여 &lt;a href=&quot;https://www.w3.org/TR/html401/interact/forms.html#h-17.13.2&quot;&gt;성공적으로 제어&lt;/a&gt; 가 포함되어야하는 요소를 결정하는 단계; 특히 요소를 비활성화 할 수 없으며 &lt;code&gt;name&lt;/code&gt; 특성을 포함해야합니다 . 양식을 단추를 사용하여 제출하지 않았기 때문에 제출 단추 값이 직렬화되지 않았습니다. 파일 선택 요소의 데이터는 직렬화되지 않습니다. &lt;code&gt;value&lt;/code&gt; 속성을 포함하지 않는 요소 는 빈 문자열 값으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ac90bebcd3635f8d3d17695f20532374d17e9175" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.size()&lt;/code&gt; method is deprecated as of jQuery 1.8. Use the &lt;code&gt;&lt;a href=&quot;length&quot;&gt;.length&lt;/a&gt;&lt;/code&gt; property instead.</source>
          <target state="translated">&lt;code&gt;.size()&lt;/code&gt; 메소드는 jQuery를 1.8로 사용되지 않습니다. &lt;code&gt;&lt;a href=&quot;length&quot;&gt;.length&lt;/a&gt;&lt;/code&gt; 속성을 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7d316944601f50f903569a2ae656e583d6d4f184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.size()&lt;/code&gt; method is functionally equivalent to the &lt;code&gt;&lt;a href=&quot;length&quot;&gt;.length&lt;/a&gt;&lt;/code&gt; property; however, &lt;strong&gt;the &lt;code&gt;.length&lt;/code&gt; property is preferred&lt;/strong&gt; because it does not have the overhead of a function call.</source>
          <target state="translated">&lt;code&gt;.size()&lt;/code&gt; 메소드는 동등한 기능 &lt;code&gt;&lt;a href=&quot;length&quot;&gt;.length&lt;/a&gt;&lt;/code&gt; 속성; 그러나 &lt;strong&gt; &lt;code&gt;.length&lt;/code&gt; &lt;/strong&gt;&lt;strong&gt; 속성이 바람직하다&lt;/strong&gt; 은 함수 호출의 오버 헤드를 갖고 있지 않기 때문에.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08740b8268cec8430f152df38cca53f9dd3c62e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.slideDown()&lt;/code&gt; method animates the height of the matched elements. This causes lower parts of the page to slide down, making way for the revealed items.</source>
          <target state="translated">&lt;code&gt;.slideDown()&lt;/code&gt; 메소드는 유사한 요소의 높이를 애니메이션. 이로 인해 페이지의 아래쪽이 아래로 미끄러 져 표시되는 항목이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e0f562dad9679f841eef5960aed9a626d4d79d28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.slideToggle()&lt;/code&gt; method animates the height of the matched elements. This causes lower parts of the page to slide up or down, appearing to reveal or conceal the items. If the element is initially displayed, it will be hidden; if hidden, it will be shown. The &lt;code&gt;display&lt;/code&gt; property is saved and restored as needed. If an element has a &lt;code&gt;display&lt;/code&gt; value of &lt;code&gt;inline&lt;/code&gt;, then is hidden and shown, it will once again be displayed &lt;code&gt;inline&lt;/code&gt;. When the height reaches 0 after a hiding animation, the &lt;code&gt;display&lt;/code&gt; style property is set to &lt;code&gt;none&lt;/code&gt; to ensure that the element no longer affects the layout of the page.</source>
          <target state="translated">&lt;code&gt;.slideToggle()&lt;/code&gt; 메소드는 유사한 요소의 높이를 애니메이션. 이로 인해 페이지의 아래쪽이 위 또는 아래로 미끄러 져 항목을 표시하거나 숨기는 것처럼 보입니다. 요소가 처음에 표시되면 숨겨집니다. 숨겨져 있으면 표시됩니다. &lt;code&gt;display&lt;/code&gt; 속성을 저장하고 필요에 따라 복원됩니다. 요소의 &lt;code&gt;display&lt;/code&gt; 값이 &lt;code&gt;inline&lt;/code&gt; 이면 숨겨져 표시되고 다시 한 번 &lt;code&gt;inline&lt;/code&gt; 표시됩니다 . 애니메이션 숨기기 후 높이가 0에 도달 하면 요소가 더 이상 페이지 레이아웃에 영향을 미치지 않도록 &lt;code&gt;display&lt;/code&gt; 스타일 속성이 &lt;code&gt;none&lt;/code&gt; 으로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dc8f9d9ce642c6b3a7c575f52b12ea99866b757" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.slideUp()&lt;/code&gt; method animates the height of the matched elements. This causes lower parts of the page to slide up, appearing to conceal the items. Once the height reaches 0 (or, if set, to whatever the CSS min-height property is), the &lt;code&gt;display&lt;/code&gt; style property is set to &lt;code&gt;none&lt;/code&gt; to ensure that the element no longer affects the layout of the page.</source>
          <target state="translated">&lt;code&gt;.slideUp()&lt;/code&gt; 메소드는 유사한 요소의 높이를 애니메이션. 이로 인해 페이지의 아래쪽이 위로 미끄러 져 항목을 숨기는 것처럼 보입니다. 높이가 0에 도달하면 (또는 설정된 경우 CSS 최소 높이 속성에 관계없이) &lt;code&gt;display&lt;/code&gt; 스타일 속성은 &lt;code&gt;none&lt;/code&gt; 으로 설정되어 요소가 더 이상 페이지 레이아웃에 영향을 미치지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="e2302549a8460d5f9c3f7051fcf5cb7a1fa33464" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.text()&lt;/code&gt; method cannot be used on form inputs or scripts. To set or get the text value of &lt;code&gt;input&lt;/code&gt; or &lt;code&gt;textarea&lt;/code&gt; elements, use the &lt;a href=&quot;val&quot;&gt;&lt;code&gt;.val()&lt;/code&gt;&lt;/a&gt; method. To get the value of a script element, use the &lt;a href=&quot;html&quot;&gt;&lt;code&gt;.html()&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">&lt;code&gt;.text()&lt;/code&gt; 메소드는 폼 입력 또는 스크립트를 사용할 수 없습니다. &lt;code&gt;input&lt;/code&gt; 또는 &lt;code&gt;textarea&lt;/code&gt; 요소 의 텍스트 값을 설정하거나 가져 오려면 &lt;a href=&quot;val&quot;&gt; &lt;code&gt;.val()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 . 스크립트 요소의 값을 얻으려면 &lt;a href=&quot;html&quot;&gt; &lt;code&gt;.html()&lt;/code&gt; &lt;/a&gt; 메서드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="373c283f538765ec436d67f9a9ff14adda880de8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.text()&lt;/code&gt; method cannot be used on input elements. For input field text, use the &lt;a href=&quot;val&quot;&gt;.val()&lt;/a&gt; method.</source>
          <target state="translated">입력 요소 에는 &lt;code&gt;.text()&lt;/code&gt; 메소드를 사용할 수 없습니다. 입력 필드 텍스트의 경우 &lt;a href=&quot;val&quot;&gt;.val ()&lt;/a&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fccc2c954d25672295c216fd9075878da0e75407" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.toggle()&lt;/code&gt; method binds a handler for the &lt;code&gt;click&lt;/code&gt; event, so the rules outlined for the triggering of &lt;code&gt;click&lt;/code&gt; apply here as well.</source>
          <target state="translated">&lt;code&gt;.toggle()&lt;/code&gt; 메소드에 대한 핸들러 바인딩 &lt;code&gt;click&lt;/code&gt; 의 트리거 설명 된 규칙 있도록 이벤트를 &lt;code&gt;click&lt;/code&gt; 여기에서도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0b52985915a620941211a673b54e69d2ce481d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.toggle()&lt;/code&gt; method is provided for convenience. It is relatively straightforward to implement the same behavior by hand, and this can be necessary if the assumptions built into &lt;code&gt;.toggle()&lt;/code&gt; prove limiting. For example, &lt;code&gt;.toggle()&lt;/code&gt; is not guaranteed to work correctly if applied twice to the same element. Since &lt;code&gt;.toggle()&lt;/code&gt; internally uses a &lt;code&gt;click&lt;/code&gt; handler to do its work, we must unbind &lt;code&gt;click&lt;/code&gt; to remove a behavior attached with &lt;code&gt;.toggle()&lt;/code&gt;, so other &lt;code&gt;click&lt;/code&gt; handlers can be caught in the crossfire. The implementation also calls &lt;code&gt;.preventDefault()&lt;/code&gt; on the event, so links will not be followed and buttons will not be clicked if &lt;code&gt;.toggle()&lt;/code&gt; has been called on the element.</source>
          <target state="translated">&lt;code&gt;.toggle()&lt;/code&gt; 메소드의 편의를 위해 제공된다. 동일한 동작을 손으로 직접 구현하는 것은 비교적 간단하며 &lt;code&gt;.toggle()&lt;/code&gt; 내장 된 가정이 제한을 입증하는 경우에 필요할 수 있습니다 . 예를 들어 &lt;code&gt;.toggle()&lt;/code&gt; 은 동일한 요소에 두 번 적용되면 올바르게 작동하지 않을 수 있습니다. 이후 &lt;code&gt;.toggle()&lt;/code&gt; 내부적으로 사용 &lt;code&gt;click&lt;/code&gt; 작업을 수행하는 핸들러를, 우리가 바인딩 해제해야한다 &lt;code&gt;click&lt;/code&gt; 부착 된 동작을 제거 &lt;code&gt;.toggle()&lt;/code&gt; , 그래서 다른 &lt;code&gt;click&lt;/code&gt; 핸들러는 일제 공격에서 잡은 될 수있다. 구현은 또한 &lt;code&gt;.preventDefault()&lt;/code&gt; 이벤트를 호출 하므로 &lt;code&gt;.toggle()&lt;/code&gt; 경우 링크를 따르지 않고 버튼을 클릭하지 않습니다. 요소에 호출되었습니다.</target>
        </trans-unit>
        <trans-unit id="90ee2012c0d37e1e2b88250be3147655498ac6c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.trigger()&lt;/code&gt; method can be used on jQuery collections that wrap plain JavaScript objects similar to a pub/sub mechanism; any event handlers bound to the object will be called when the event is triggered.</source>
          <target state="translated">&lt;code&gt;.trigger()&lt;/code&gt; 메소드는 일반 감기 JavaScript가 술집 / 서브기구 유사한 개체 것을 jQuery를 수집에 사용될 수있다; 이벤트가 트리거 될 때 객체에 바인딩 된 이벤트 핸들러가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6727df07ba1a485ab1da0e62516370226a50a0bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.triggerHandler( &quot;event&quot; )&lt;/code&gt; method will not call &lt;code&gt;.event()&lt;/code&gt; on the element it is triggered on. This means &lt;code&gt;.triggerHandler( &quot;submit&quot; )&lt;/code&gt; on a form will not call &lt;code&gt;.submit()&lt;/code&gt; on the form.</source>
          <target state="translated">&lt;code&gt;.triggerHandler( &quot;event&quot; )&lt;/code&gt; 메소드는 호출하지 않습니다 &lt;code&gt;.event()&lt;/code&gt; 가에 트리거되는 요소를. 이것은 양식의 &lt;code&gt;.triggerHandler( &quot;submit&quot; )&lt;/code&gt; 가 양식의 &lt;code&gt;.submit()&lt;/code&gt; 을 호출하지 않음 을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="513e4d6bf3e0be052f40008f5f347b3a0c913660" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.undelegate()&lt;/code&gt; method is a way of removing event handlers that have been bound using &lt;a href=&quot;delegate&quot;&gt;&lt;code&gt;.delegate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.undelegate()&lt;/code&gt; 메소드를 사용하여 결합 된 이벤트 핸들러를 제거하는 방법이다 &lt;a href=&quot;delegate&quot;&gt; &lt;code&gt;.delegate()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51fd5f8e1da6cc53759c1a5d55129187c9c1669f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.unwrap()&lt;/code&gt; method removes the element's parent and returns the unwrapped content. This is effectively the inverse of the &lt;code&gt;&lt;a href=&quot;wrap&quot;&gt;.wrap()&lt;/a&gt;&lt;/code&gt; method. The matched elements (and their siblings, if any) replace their parents within the DOM structure.</source>
          <target state="translated">&lt;code&gt;.unwrap()&lt;/code&gt; 메소드는 요소의 부모를 제거하고 풀어 내용을 반환합니다. 이것은 사실상 &lt;code&gt;&lt;a href=&quot;wrap&quot;&gt;.wrap()&lt;/a&gt;&lt;/code&gt; 메소드 의 반대입니다 . 일치하는 요소 (및 해당하는 경우 형제)는 DOM 구조 내에서 부모를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="be7b1e44db9c19e73004f470a5e8f0469e24649d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.val()&lt;/code&gt; method allows setting the value by passing in a function. As of jQuery 1.4, the function is passed two arguments, the current element's index and its current value:</source>
          <target state="translated">&lt;code&gt;.val()&lt;/code&gt; 메소드는 함수에 전달하여 설정 값을 허용한다. jQuery 1.4부터 함수에는 현재 요소의 색인과 현재 값의 두 가지 인수가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="aa3df7ef8e6c5a1177e85f411ef7f33f49a0b611" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.val()&lt;/code&gt; method is primarily used to get the values of form elements such as &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;textarea&lt;/code&gt;. When called on an empty collection, it returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.val()&lt;/code&gt; 방법은 주로 다음과 같은 형태의 요소의 값의 취득에 사용되는 &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; 및 &lt;code&gt;textarea&lt;/code&gt; . 빈 컬렉션에서 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="322722376da12ca684717a51b25a7d113bdaa84e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wrap()&lt;/code&gt; function can take any string or object that could be passed to the &lt;code&gt;$()&lt;/code&gt; factory function to specify a DOM structure. This structure may be nested several levels deep, but should contain only one inmost element. A copy of this structure will be wrapped around each of the elements in the set of matched elements. This method returns the original set of elements for chaining purposes.</source>
          <target state="translated">&lt;code&gt;.wrap()&lt;/code&gt; 함수는 전달 될 수있는 문자열 또는 객체 걸릴 수 &lt;code&gt;$()&lt;/code&gt; 는 DOM 구조를 지정하는 공장 기능을. 이 구조는 여러 수준으로 중첩 될 수 있지만 가장 안쪽에 하나의 요소 만 포함해야합니다. 이 구조의 사본은 일치하는 요소 세트의 각 요소 주위에 랩핑됩니다. 이 메소드는 연결을 위해 원래 요소 세트를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c812721d970da9b645aa759ae959ba0db5b2e0e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wrapAll()&lt;/code&gt; function can take any string or object that could be passed to the &lt;code&gt;$()&lt;/code&gt; function to specify a DOM structure. This structure may be nested several levels deep, but should contain only one inmost element. The structure will be wrapped around all of the elements in the set of matched elements, as a single group.</source>
          <target state="translated">&lt;code&gt;.wrapAll()&lt;/code&gt; 함수는 전달 될 수있는 문자열 또는 객체 걸릴 수 &lt;code&gt;$()&lt;/code&gt; 는 DOM 구조를 지정하는 기능입니다. 이 구조는 여러 수준으로 중첩 될 수 있지만 가장 안쪽에 하나의 요소 만 포함해야합니다. 구조는 일치하는 요소 집합의 모든 요소를 ​​단일 그룹으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="3db4368770ad651d5dbec7c44cd8ba2db7319e60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.wrapInner()&lt;/code&gt; function can take any string or object that could be passed to the &lt;code&gt;$()&lt;/code&gt; factory function to specify a DOM structure. This structure may be nested several levels deep, but should contain only one inmost element. The structure will be wrapped around the content of each of the elements in the set of matched elements.</source>
          <target state="translated">&lt;code&gt;.wrapInner()&lt;/code&gt; 함수는 전달 될 수있는 문자열 또는 객체 걸릴 수 &lt;code&gt;$()&lt;/code&gt; 는 DOM 구조를 지정하는 공장 기능을. 이 구조는 여러 수준으로 중첩 될 수 있지만 가장 안쪽에 하나의 요소 만 포함해야합니다. 구조는 일치하는 요소 집합에서 각 요소의 내용을 둘러 쌉니다.</target>
        </trans-unit>
        <trans-unit id="139d56bcf1b91aaa8dba4392f3eb16d4d9147cb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:checked&lt;/code&gt; selector works for checkboxes, radio buttons, and options of &lt;code&gt;select&lt;/code&gt; elements.</source>
          <target state="translated">&lt;code&gt;:checked&lt;/code&gt; 선택 체크 박스, 라디오 버튼, 그리고 옵션 작동 &lt;code&gt;select&lt;/code&gt; 요소.</target>
        </trans-unit>
        <trans-unit id="01193d1507c1b5d6b5823171619bb4c82354b9a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:disabled&lt;/code&gt; selector should only be used for selecting HTML elements that support the &lt;code&gt;disabled&lt;/code&gt; attribute (&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;menuitem&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:disabled&lt;/code&gt; 선택기 만지지 HTML 요소를 선택하기 위해 사용되어야 &lt;code&gt;disabled&lt;/code&gt; (속성 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;menuitem&amp;gt;&lt;/code&gt; , 및 &lt;code&gt;&amp;lt;fieldset&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2395e6feb0bbee4323652fc74ae8a9cbd24453a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:enabled&lt;/code&gt; selector should only be used for selecting HTML elements that support the &lt;code&gt;disabled&lt;/code&gt; attribute (&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;:enabled&lt;/code&gt; 선택은지지 HTML 요소를 선택하기 위해 사용되어야 &lt;code&gt;disabled&lt;/code&gt; (속성 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;optgroup&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b08c2cbeff939b37697982eb1a485029c814d6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:first-of-type&lt;/code&gt; selector matches elements that have no other element with both the same parent and the same element name coming before it in the document tree.</source>
          <target state="translated">&lt;code&gt;:first-of-type&lt;/code&gt; 선택자는 같은 부모와 문서 트리에 전에 오는 같은 요소 이름 모두 다른 요소가없는 요소를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="49d835832f63623fec68d9fdda05e2be7c6beae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:first&lt;/code&gt; pseudo-class is equivalent to &lt;code&gt;:eq( 0 )&lt;/code&gt;. It could also be written as &lt;code&gt;:lt( 1 )&lt;/code&gt;. While this matches only a single element, &lt;a href=&quot;first-child-selector&quot;&gt;:first-child&lt;/a&gt; can match more than one: One for each parent.</source>
          <target state="translated">&lt;code&gt;:first&lt;/code&gt; 의사 클래스에 해당 &lt;code&gt;:eq( 0 )&lt;/code&gt; . 또한 &lt;code&gt;:lt( 1 )&lt;/code&gt; 로 쓸 수도 있습니다 . 이 요소는 단일 요소와 만 일치하지만 &lt;a href=&quot;first-child-selector&quot;&gt;: first-child&lt;/a&gt; 는 둘 이상의 요소 를 일치시킬 수 있습니다. 각 부모마다 하나씩.</target>
        </trans-unit>
        <trans-unit id="fcd319e0ed30f65f1bf56aa4209ee68a5c743e4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:input&lt;/code&gt; selector basically selects all form controls.</source>
          <target state="translated">&lt;code&gt;:input&lt;/code&gt; 선택기는 기본적으로 모든 형태의 제어를 선택한다.</target>
        </trans-unit>
        <trans-unit id="e719eb72a2f787d59782d8fc9ac950f9c0950994" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:lang()&lt;/code&gt; selector matches elements that have a language value equal to the supplied language code or that start with the supplied language code immediately followed by &quot;-&quot;. For example, the selector &lt;code&gt;$(&quot;div:lang(en)&quot;)&lt;/code&gt;will match &lt;code&gt;&amp;lt;div lang=&quot;en&quot;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;div lang=&quot;en-us&quot;&amp;gt;&lt;/code&gt; (and any of their descendant &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;s), but not &lt;code&gt;&amp;lt;div lang=&quot;fr&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;:lang()&lt;/code&gt; 언어 값이 선택기 엘리먼트 일치 제공된 언어 코드 또는 바로 뒤에 제공된 언어 코드를 사용하여 그 시작 동일한 &quot;-&quot;. 예를 들어 선택기 &lt;code&gt;$(&quot;div:lang(en)&quot;)&lt;/code&gt; 는 &lt;code&gt;&amp;lt;div lang=&quot;en&quot;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;div lang=&quot;en-us&quot;&amp;gt;&lt;/code&gt; (및 그 하위 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; s) 와 일치 하지만 &lt;code&gt;&amp;lt;div lang=&quot;fr&quot;&amp;gt;&lt;/code&gt; 아님</target>
        </trans-unit>
        <trans-unit id="b3ebbf72ab8f006b6be875c86864d5808bf70755" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:last-of-type&lt;/code&gt; selector matches elements that have no other element with the same parent and the same element name coming after it in the document tree.</source>
          <target state="translated">&lt;code&gt;:last-of-type&lt;/code&gt; 선택자는 같은 부모와 문서 트리에 뒤에 오는 같은 요소 이름을 가진 다른 요소가없는 요소를 일치합니다.</target>
        </trans-unit>
        <trans-unit id="f222c15bce05c9c3271710690a4e94281f26e1e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:nth-child(n)&lt;/code&gt; pseudo-class is easily confused with &lt;code&gt;:eq(n)&lt;/code&gt;, even though the two can result in dramatically different matched elements. With &lt;code&gt;:nth-child(n)&lt;/code&gt;, all children are counted, regardless of what they are, and the specified element is selected only if it matches the selector attached to the pseudo-class. With &lt;code&gt;:eq(n)&lt;/code&gt; only the selector attached to the pseudo-class is counted, not limited to children of any other element, and the (n+1)th one (n is 0-based) is selected.</source>
          <target state="translated">&lt;code&gt;:nth-child(n)&lt;/code&gt; 가상 클래스 쉽게 혼동된다 &lt;code&gt;:eq(n)&lt;/code&gt; 개의 극적 다른 유사한 요소를 초래할 수 있더라도. 로 &lt;code&gt;:nth-child(n)&lt;/code&gt; , 모든 아이들은 상관없이 무엇인지, 계산하고, 지정된 요소은 (는) 의사 클래스에 부착 된 선택 일치하는 경우에만 선택됩니다. 로 &lt;code&gt;:eq(n)&lt;/code&gt; 의사 클래스에 부착 만 선택기 카운트, 다른 요소의 자식에 한정하고, (N + 1) 번째의 하나가되지 (n은 0 기)이 선택된다.</target>
        </trans-unit>
        <trans-unit id="689dff1a2d43ff2ac2346a95c07aae9a34eb5509" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:nth-child(n)&lt;/code&gt; pseudo-class is easily confused with the &lt;code&gt;.eq( n )&lt;/code&gt; call, even though the two can result in dramatically different matched elements. With &lt;code&gt;:nth-child(n)&lt;/code&gt;, all children are counted, regardless of what they are, and the specified element is selected only if it matches the selector attached to the pseudo-class. With the &lt;code&gt;.eq( n )&lt;/code&gt; call only the selector attached to the pseudo-class is counted, not limited to children of any other element, and the (n+1)th one (n is 0-based) is selected.</source>
          <target state="translated">&lt;code&gt;:nth-child(n)&lt;/code&gt; 가상 클래스 용이 혼동된다 &lt;code&gt;.eq( n )&lt;/code&gt; 개의 극적 다른 유사한 요소를 초래할 수 있더라도 통화. 로 &lt;code&gt;:nth-child(n)&lt;/code&gt; , 모든 아이들은 상관없이 무엇인지, 계산하고, 지정된 요소은 (는) 의사 클래스에 부착 된 선택 일치하는 경우에만 선택됩니다. 으로 &lt;code&gt;.eq( n )&lt;/code&gt; 의사 클래스에 부착 만 선택기 카운트 호, 다른 요소의 자식에 한정하고, (N + 1) 번째의 하나가되지 (n은 0 기)이 선택된다.</target>
        </trans-unit>
        <trans-unit id="480990aae62b645f5c757db08b5d22e7fc118d3f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:selected&lt;/code&gt; selector works for &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; elements. It does not work for checkboxes or radio inputs; use &lt;code&gt;:checked&lt;/code&gt; for them.</source>
          <target state="translated">&lt;code&gt;:selected&lt;/code&gt; 선택기 작동 &lt;code&gt;&amp;lt;option&amp;gt;&lt;/code&gt; 요소. 확인란 또는 라디오 입력에는 작동하지 않습니다. 사용 &lt;code&gt;:checked&lt;/code&gt; 했습니다.</target>
        </trans-unit>
        <trans-unit id="977650852f199848327084d347571ad1e5aaab2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:submit&lt;/code&gt; selector typically applies to button or input elements. Note that some browsers treat &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; element as &lt;code&gt;type=&quot;submit&quot;&lt;/code&gt; implicitly while others (such as Internet Explorer) do not. To ensure that markup works consistently across all browsers and guarantee that it is possible to consistently select buttons that will submit a form, always specify a &lt;code&gt;type&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;:submit&lt;/code&gt; 선택기는 전형적으로 버튼 또는 입력 요소에 적용된다. 일부 브라우저는 &lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt; 요소를 암시 적 으로 &lt;code&gt;type=&quot;submit&quot;&lt;/code&gt; 로 취급하지만 다른 브라우저 (예 : Internet Explorer)는 암시 적으로 처리하지 않습니다. 마크 업이 모든 브라우저에서 일관되게 작동하고 양식을 제출할 버튼을 일관되게 선택할 수있게하려면 항상 &lt;code&gt;type&lt;/code&gt; 속성을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e75c719b09262c87105625d3981cdd5716ee6d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;.insertAfter()&lt;/code&gt; methods perform the same task. The major difference is in the syntax&amp;mdash;specifically, in the placement of the content and target. With &lt;code&gt;.after()&lt;/code&gt;, the selector expression preceding the method is the container after which the content is inserted. With &lt;code&gt;.insertAfter()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted after the target container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;.insertAfter()&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 구문, 특히 콘텐츠 및 대상의 배치에 있습니다. &lt;code&gt;.after()&lt;/code&gt; 사용하면 메서드 앞의 선택기 표현식이 콘텐츠가 삽입 된 뒤에 컨테이너입니다. 반면에 &lt;code&gt;.insertAfter()&lt;/code&gt; 사용하면 콘텐츠가 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메서드 앞에 있으며 대상 컨테이너 뒤에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="a62ffe6286350b3c8dba0fe6ec0674cc784f5054" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;.insertAfter()&lt;/code&gt; methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With &lt;code&gt;.after()&lt;/code&gt;, the selector expression preceding the method is the container after which the content is inserted. With &lt;code&gt;.insertAfter()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted after the target container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;after&quot;&gt;.after()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;.insertAfter()&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 내용과 대상의 배치에서 구문에 따라 다릅니다. &lt;code&gt;.after()&lt;/code&gt; 사용하면 메소드 앞의 선택자 표현식은 컨텐츠가 삽입 된 후의 컨테이너입니다. 반면에 &lt;code&gt;.insertAfter()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 작성된 마크 업으로 메소드보다 우선하며 대상 컨테이너 뒤에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="cd94168e712338f385a4b6a33602f5a25787172f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;append&quot;&gt;.append()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;.appendTo()&lt;/code&gt; methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With &lt;code&gt;.append()&lt;/code&gt;, the selector expression preceding the method is the container into which the content is inserted. With &lt;code&gt;.appendTo()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted into the target container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;append&quot;&gt;.append()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;.appendTo()&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 내용과 대상의 배치에서 구문에 따라 다릅니다. &lt;code&gt;.append()&lt;/code&gt; 사용하면 메서드 앞에있는 선택기식이 내용이 삽입되는 컨테이너입니다. 반면에 &lt;code&gt;.appendTo()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메소드보다 우선하며 대상 컨테이너에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="fe43ace986ca75204f321e277ad9e4407e4e3b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;.insertBefore()&lt;/code&gt; methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With &lt;code&gt;.before()&lt;/code&gt;, the selector expression preceding the method is the container before which the content is inserted. With &lt;code&gt;.insertBefore()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted before the target container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;before&quot;&gt;.before()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;.insertBefore()&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 내용과 대상의 배치에서 구문에 따라 다릅니다. &lt;code&gt;.before()&lt;/code&gt; 사용하면 메서드 앞에있는 선택기식이 내용이 삽입되기 전의 컨테이너입니다. 반면에 &lt;code&gt;.insertBefore()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메소드보다 우선하며 대상 컨테이너 앞에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="bb0b532a701ca8991b6d6cf5aa6767e6a60d3c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;not&quot;&gt;.not()&lt;/a&gt;&lt;/code&gt; method will end up providing you with more readable selections than pushing complex selectors or variables into a &lt;code&gt;:not()&lt;/code&gt; selector filter. In most cases, it is a better choice.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;not&quot;&gt;.not()&lt;/a&gt;&lt;/code&gt; 메소드는에 복잡한 선택기 또는 변수를 밀어 것보다 더 읽기 선택 당신을 제공 끝날 &lt;code&gt;:not()&lt;/code&gt; 선택 필터. 대부분의 경우 더 나은 선택입니다.</target>
        </trans-unit>
        <trans-unit id="6e8de57099bebd411d7e3efca254b07f646e05d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;.prependTo()&lt;/code&gt; methods perform the same task. The major difference is in the syntax-specifically, in the placement of the content and target. With &lt;code&gt;.prepend()&lt;/code&gt;, the selector expression preceding the method is the container into which the content is inserted. With &lt;code&gt;.prependTo()&lt;/code&gt;, on the other hand, the content precedes the method, either as a selector expression or as markup created on the fly, and it is inserted into the target container.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;prepend&quot;&gt;.prepend()&lt;/a&gt;&lt;/code&gt; 및 &lt;code&gt;.prependTo()&lt;/code&gt; 메소드는 동일한 작업을 수행합니다. 주요 차이점은 내용과 대상의 배치에서 구문에 따라 다릅니다. &lt;code&gt;.prepend()&lt;/code&gt; 사용하면 메소드 앞에있는 선택기 표현식이 컨텐츠가 삽입되는 컨테이너입니다. 반면에 &lt;code&gt;.prependTo()&lt;/code&gt; 사용하면 내용이 선택기 표현식 또는 즉석에서 생성 된 마크 업으로 메소드보다 우선하며 대상 컨테이너에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="5b9d80e6d688dcee931bd76e1d9f5e5cca4795e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;beforeSend&lt;/code&gt;, &lt;code&gt;error&lt;/code&gt;, &lt;code&gt;dataFilter&lt;/code&gt;, &lt;code&gt;success&lt;/code&gt; and &lt;code&gt;complete&lt;/code&gt; options all accept callback functions that are invoked at the appropriate times.</source>
          <target state="translated">&lt;code&gt;beforeSend&lt;/code&gt; , &lt;code&gt;error&lt;/code&gt; , &lt;code&gt;dataFilter&lt;/code&gt; , &lt;code&gt;success&lt;/code&gt; 및 &lt;code&gt;complete&lt;/code&gt; 옵션은 모든 적절한 시간에 호출되는 콜백 함수를 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="dc09994630bedb3f56bf21fb50b2ce7b0ebf957c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blur&lt;/code&gt; event does not bubble in Internet Explorer. Therefore, scripts that rely on event delegation with the &lt;code&gt;blur&lt;/code&gt; event will not work consistently across browsers. As of version 1.4.2, however, jQuery works around this limitation by mapping &lt;code&gt;blur&lt;/code&gt; to the &lt;code&gt;focusout&lt;/code&gt; event in its event delegation methods, &lt;a href=&quot;live&quot;&gt;&lt;code&gt;.live()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;delegate&quot;&gt;&lt;code&gt;.delegate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;blur&lt;/code&gt; 이벤트는 Internet Explorer에서 거품을하지 않습니다. 따라서 &lt;code&gt;blur&lt;/code&gt; 이벤트 와 함께 이벤트 위임에 의존하는 스크립트는 브라우저에서 일관되게 작동하지 않습니다. 그러나 1.4.2 버전부터 jQuery 는 이벤트 위임 메소드 인 &lt;a href=&quot;live&quot;&gt; &lt;code&gt;.live()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;delegate&quot;&gt; &lt;code&gt;.delegate()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;blur&lt;/code&gt; 를 &lt;code&gt;focusout&lt;/code&gt; 이벤트에 매핑하여이 제한을 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="190cbfc6dbdd3abf5df2269ad19e423de3c772bd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;blur&lt;/code&gt; event is sent to an element when it loses focus. Originally, this event was only applicable to form elements, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;. In recent browsers, the domain of the event has been extended to include all element types. An element can lose focus via keyboard commands, such as the Tab key, or by mouse clicks elsewhere on the page.</source>
          <target state="translated">&lt;code&gt;blur&lt;/code&gt; 이벤트는 포커스를 잃고 요소로 전송됩니다. 원래이 이벤트는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 과 같은 요소를 구성하는 데만 적용되었습니다 . 최근 브라우저에서 이벤트 도메인은 모든 요소 유형을 포함하도록 확장되었습니다. 요소는 Tab 키와 같은 키보드 명령이나 페이지의 다른 곳에서 마우스 클릭을 통해 초점을 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96e3d342f9e34d87560a2e848d913dcdb9acca7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;change&lt;/code&gt; event is sent to an element when its value changes. This event is limited to &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; elements, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; boxes and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; elements. For select boxes, checkboxes, and radio buttons, the event is fired immediately when the user makes a selection with the mouse, but for the other element types the event is deferred until the element loses focus.</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 값이 변경 될 때 이벤트 요소로 전송된다. 이 이벤트는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 요소, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 상자 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 요소로 제한됩니다. 선택 상자, 확인란 및 라디오 버튼의 경우 사용자가 마우스로 선택하면 이벤트가 즉시 시작되지만 다른 요소 유형의 경우 요소가 포커스를 잃을 때까지 이벤트가 지연됩니다.</target>
        </trans-unit>
        <trans-unit id="f256e3f7b3303084dd382deff803de56cd554cfc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;click&lt;/code&gt; event is only triggered after this exact series of events:</source>
          <target state="translated">&lt;code&gt;click&lt;/code&gt; 이벤트는 이벤트의 정확한 일련의 후 트리거 :</target>
        </trans-unit>
        <trans-unit id="86f9be7a8b000b85c91775d5ddce88ef554fea7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data&lt;/code&gt; option can contain either a query string of the form &lt;code&gt;key1=value1&amp;amp;key2=value2&lt;/code&gt;, or an object of the form &lt;code&gt;{key1: 'value1', key2: 'value2'}&lt;/code&gt;. If the latter form is used, the data is converted into a query string using &lt;code&gt;&lt;a href=&quot;jquery.param&quot;&gt;jQuery.param()&lt;/a&gt;&lt;/code&gt; before it is sent. This processing can be circumvented by setting &lt;code&gt;processData&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. The processing might be undesirable if you wish to send an XML object to the server; in this case, change the &lt;code&gt;contentType&lt;/code&gt; option from &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; to a more appropriate MIME type.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 옵션 형태의 쿼리 문자열 중 하나를 포함 할 수 있습니다 &lt;code&gt;key1=value1&amp;amp;key2=value2&lt;/code&gt; , 또는 형태의 객체 &lt;code&gt;{key1: 'value1', key2: 'value2'}&lt;/code&gt; . 후자의 형식이 사용되면 데이터 는 전송되기 전에 &lt;code&gt;&lt;a href=&quot;jquery.param&quot;&gt;jQuery.param()&lt;/a&gt;&lt;/code&gt; 사용하여 쿼리 문자열로 변환됩니다 . &lt;code&gt;processData&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하면이 처리를 피할 수 있습니다 . XML 오브젝트를 서버로 보내려면 처리가 바람직하지 않을 수 있습니다. 이 경우, 변경 &lt;code&gt;contentType&lt;/code&gt; 로부터 옵션 &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; 더 적절한 MIME 타입으로한다.</target>
        </trans-unit>
        <trans-unit id="a45ea61e4be6c2fa09624cd140b6a4afcfcdff80" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dblclick&lt;/code&gt; event is only triggered after this exact series of events:</source>
          <target state="translated">&lt;code&gt;dblclick&lt;/code&gt; 의 이벤트는 이벤트의 정확한 일련의 후 트리거 :</target>
        </trans-unit>
        <trans-unit id="11ae013fda7979634bb7b5a9d1a1604d6bed835c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deferred.done()&lt;/code&gt; method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is resolved, the doneCallbacks are called. Callbacks are executed in the order they were added. Since &lt;code&gt;deferred.done()&lt;/code&gt; returns the deferred object, other methods of the deferred object can be chained to this one, including additional &lt;code&gt;.done()&lt;/code&gt; methods. When the Deferred is resolved, doneCallbacks are executed using the arguments provided to the &lt;a href=&quot;deferred.resolve&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deferred.resolvewith&quot;&gt;&lt;code&gt;resolveWith&lt;/code&gt;&lt;/a&gt; method call in the order they were added. For more information, see the documentation for &lt;a href=&quot;category/deferred-object&quot;&gt;Deferred object&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;deferred.done()&lt;/code&gt; 메소드는 단일 기능 또는 기능의 배열이 될 수 모두 하나 개 이상의 인수를 받아 들인다. Deferred가 해결되면 doneCallbacks가 호출됩니다. 콜백은 추가 된 순서대로 실행됩니다. 이후 &lt;code&gt;deferred.done()&lt;/code&gt; 지연된 객체를 반환 지연된 객체의 다른 방법을 추가로 포함하여,이 체인 수 &lt;code&gt;.done()&lt;/code&gt; 메소드. Deferred가 해결되면 doneCallbacks는 &lt;a href=&quot;deferred.resolve&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deferred.resolvewith&quot;&gt; &lt;code&gt;resolveWith&lt;/code&gt; &lt;/a&gt; 메소드 호출에 제공된 인수 를 추가 된 순서대로 실행합니다. 자세한 내용은 &lt;a href=&quot;category/deferred-object&quot;&gt;지연된 객체&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bda5172606f19b9b736efbd893772823314bb31d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deferred.fail()&lt;/code&gt; method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred is rejected, the failCallbacks are called. Callbacks are executed in the order they were added. Since &lt;code&gt;deferred.fail()&lt;/code&gt; returns the deferred object, other methods of the deferred object can be chained to this one, including additional &lt;code&gt;deferred.fail()&lt;/code&gt; methods. The failCallbacks are executed using the arguments provided to the &lt;a href=&quot;deferred.reject&quot;&gt;&lt;code&gt;deferred.reject()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deferred.rejectwith&quot;&gt;&lt;code&gt;deferred.rejectWith()&lt;/code&gt;&lt;/a&gt; method call in the order they were added. For more information, see the documentation for &lt;a href=&quot;category/deferred-object&quot;&gt;Deferred object&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;deferred.fail()&lt;/code&gt; 메소드는 단일 기능 또는 기능의 배열이 될 수 모두 하나 개 이상의 인수를 받아 들인다. 지연이 거부되면 failCallbacks가 호출됩니다. 콜백은 추가 된 순서대로 실행됩니다. 이후 &lt;code&gt;deferred.fail()&lt;/code&gt; 지연된 객체를 반환 지연된 객체의 다른 방법을 추가로 포함하여,이 체인 수 &lt;code&gt;deferred.fail()&lt;/code&gt; 메소드. failCallbacks는 추가 된 순서대로 &lt;a href=&quot;deferred.reject&quot;&gt; &lt;code&gt;deferred.reject()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deferred.rejectwith&quot;&gt; &lt;code&gt;deferred.rejectWith()&lt;/code&gt; &lt;/a&gt; 메소드 호출에 제공된 인수를 사용하여 실행 됩니다. 자세한 내용은 &lt;a href=&quot;category/deferred-object&quot;&gt;지연된 객체&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="00213c3f3db0a9c85f8d3be62e0af641fa058062" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deferred.pipe()&lt;/code&gt; method returns a new promise that filters the status and values of a deferred through a function. The &lt;code&gt;doneFilter&lt;/code&gt; and &lt;code&gt;failFilter&lt;/code&gt; functions filter the original deferred's resolved / rejected status and values. &lt;strong&gt;As of jQuery 1.7&lt;/strong&gt;, the method also accepts a &lt;code&gt;progressFilter&lt;/code&gt; function to filter any calls to the original deferred's &lt;code&gt;notify&lt;/code&gt; or &lt;code&gt;notifyWith&lt;/code&gt; methods. These filter functions can return a new value to be passed along to the piped promise's &lt;code&gt;done()&lt;/code&gt; or &lt;code&gt;fail()&lt;/code&gt; callbacks, or they can return another observable object (Deferred, Promise, etc) which will pass its resolved / rejected status and values to the piped promise's callbacks. If the filter function used is &lt;code&gt;null&lt;/code&gt;, or not specified, the piped promise will be resolved or rejected with the same values as the original.</source>
          <target state="translated">&lt;code&gt;deferred.pipe()&lt;/code&gt; 메소드는 함수를 통해 지연된 상태 및 값을 필터링하는 새로운 가능성을 반환한다. &lt;code&gt;doneFilter&lt;/code&gt; 및 &lt;code&gt;failFilter&lt;/code&gt; 기능은 원래의 연기 해결 / 거부 상태와 값을 필터링 할 수 있습니다. &lt;strong&gt;jQuery 1.7 &lt;/strong&gt; &lt;code&gt;notifyWith&lt;/code&gt; 메소드 는 &lt;code&gt;progressFilter&lt;/code&gt; 함수를 허용 하여 원래 지연된 &lt;code&gt;notify&lt;/code&gt; 또는 notifyWith 메소드에 대한 호출을 필터링합니다 . 이 필터 함수는 파이프 약속의 &lt;code&gt;done()&lt;/code&gt; 또는 &lt;code&gt;fail()&lt;/code&gt; 전달할 새 값을 반환 할 수 있습니다.콜백 또는 확인 가능 / 거부 된 상태 및 값을 파이프 된 약속의 콜백으로 전달하는 다른 관찰 가능한 객체 (지연, 약속 등)를 반환 할 수 있습니다. 사용 된 필터 함수가 &lt;code&gt;null&lt;/code&gt; 이거나 지정되지 않은 경우 파이프 약속은 원래 값과 동일한 값으로 해결되거나 거부됩니다.</target>
        </trans-unit>
        <trans-unit id="5f826199bcf49ca10b7a337c0b395fa9f9f67956" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deferred.progress()&lt;/code&gt; method accepts one or more arguments, all of which can be either a single function or an array of functions. When the Deferred generates progress notifications by calling &lt;code&gt;notify&lt;/code&gt; or &lt;code&gt;notifyWith&lt;/code&gt;, the &lt;code&gt;progressCallbacks&lt;/code&gt; are called. Since &lt;code&gt;deferred.progress()&lt;/code&gt; returns the Deferred object, other methods of the Deferred object can be chained to this one. When the Deferred is resolved or rejected, progress callbacks will no longer be called, with the exception that any &lt;code&gt;progressCallbacks&lt;/code&gt; added after the Deferred enters the resolved or rejected state are executed immediately when they are added, using the arguments that were passed to the &lt;code&gt;.notify()&lt;/code&gt; or &lt;code&gt;notifyWith()&lt;/code&gt; call. For more information, see the documentation for &lt;a href=&quot;jquery.deferred&quot;&gt;jQuery.Deferred()&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;deferred.progress()&lt;/code&gt; 메소드는 단일 기능 또는 기능의 배열이 될 수 모두 하나 개 이상의 인수를 받아 들인다. Deferred가 &lt;code&gt;notify&lt;/code&gt; 또는 &lt;code&gt;notifyWith&lt;/code&gt; 를 호출하여 진행 알림을 생성 하면 &lt;code&gt;progressCallbacks&lt;/code&gt; 가 호출됩니다. 이후 &lt;code&gt;deferred.progress()&lt;/code&gt; 우회 객체를 반환 우회 대상의 다른 방법이 하나의 체인 수있다. Deferred가 해결되거나 거부 되면 &lt;code&gt;.notify()&lt;/code&gt; 전달 된 인수를 사용하여 Deferred가 해결되거나 거부 된 상태가 된 후 추가 된 &lt;code&gt;progressCallbacks&lt;/code&gt; 가 추가되거나 즉시 거부 된 경우를 제외하고 진행 콜백이 더 이상 호출되지 않습니다. ()또는 &lt;code&gt;notifyWith()&lt;/code&gt; 호출. 자세한 내용은 &lt;a href=&quot;jquery.deferred&quot;&gt;jQuery.Deferred ()&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="797e3639f7aa73f48cd934bfb5beac1e7f53211a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deferred.promise()&lt;/code&gt; method allows an asynchronous function to prevent other code from interfering with the progress or status of its internal request. The Promise exposes only the Deferred methods needed to attach additional handlers or determine the state (&lt;code&gt;then&lt;/code&gt;, &lt;code&gt;done&lt;/code&gt;, &lt;code&gt;fail&lt;/code&gt;, &lt;code&gt;always&lt;/code&gt;, &lt;code&gt;pipe&lt;/code&gt;, &lt;code&gt;progress&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; and &lt;code&gt;promise&lt;/code&gt;), but not ones that change the state (&lt;code&gt;resolve&lt;/code&gt;, &lt;code&gt;reject&lt;/code&gt;, &lt;code&gt;notify&lt;/code&gt;, &lt;code&gt;resolveWith&lt;/code&gt;, &lt;code&gt;rejectWith&lt;/code&gt;, and &lt;code&gt;notifyWith&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;deferred.promise()&lt;/code&gt; 메소드는 비동기 함수 내부 요청의 진행 상태 또는 다른 코드 간섭을 방지 할 수있다. 약속에만 이연 추가 핸들러를 첨부하거나 (상태를 확인하는 데 필요한 방법을 공개 &lt;code&gt;then&lt;/code&gt; , &lt;code&gt;done&lt;/code&gt; , &lt;code&gt;fail&lt;/code&gt; , &lt;code&gt;always&lt;/code&gt; , &lt;code&gt;pipe&lt;/code&gt; , &lt;code&gt;progress&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; 및 &lt;code&gt;promise&lt;/code&gt; ),하지만 상태 (변경 것들을 &lt;code&gt;resolve&lt;/code&gt; , &lt;code&gt;reject&lt;/code&gt; , &lt;code&gt;notify&lt;/code&gt; , &lt;code&gt;resolveWith&lt;/code&gt; 을 , &lt;code&gt;rejectWith&lt;/code&gt; 및 &lt;code&gt;notifyWith&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7aada72a5a29999d21c048cef40f1e43a1a9a189" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;end()&lt;/code&gt; method is useful primarily when exploiting jQuery's chaining properties. When not using chaining, we can usually just call up a previous object by variable name, so we don't need to manipulate the stack. With &lt;code&gt;end()&lt;/code&gt;, though, we can string all the method calls together:</source>
          <target state="translated">&lt;code&gt;end()&lt;/code&gt; 메소드는 jQuery의 체인의 특성을 악용 때 주로 유용합니다. 체인을 사용하지 않을 때는 일반적으로 변수 이름으로 이전 객체를 호출 할 수 있으므로 스택을 조작 할 필요가 없습니다. 그러나 &lt;code&gt;end()&lt;/code&gt; 사용하면 모든 메소드 호출을 함께 문자열로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c74954130e96878d0570d2001ccdea54fe745acf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; event is sent to elements, such as images, that are referenced by a document and loaded by the browser. It is called if the element was not loaded correctly.</source>
          <target state="translated">&lt;code&gt;error&lt;/code&gt; 이벤트는 문서에서 참조하고 브라우저에 의해로드 된 이미지와 같은 요소로 전송됩니다. 요소가 올바르게로드되지 않은 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="4de04198e0282785992a572f3b0294e98a6eb007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error&lt;/code&gt; event on the &lt;code&gt;window&lt;/code&gt; object uses nonstandard arguments and return value conventions, so it is not supported by jQuery. Instead, assign a handler function directly to the &lt;code&gt;window.onerror&lt;/code&gt; property.</source>
          <target state="translated">&lt;code&gt;window&lt;/code&gt; 객체 의 &lt;code&gt;error&lt;/code&gt; 이벤트 는 비표준 인수와 반환 값 규칙을 사용하므로 jQuery에서 지원하지 않습니다. 대신 핸들러 함수를 &lt;code&gt;window.onerror&lt;/code&gt; 속성에 직접 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="41a15e6d0c25cd827f5df958e1162a9271cec778" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;event.which&lt;/code&gt; property normalizes &lt;code&gt;event.keyCode&lt;/code&gt; and &lt;code&gt;event.charCode&lt;/code&gt;. It is recommended to watch &lt;code&gt;event.which&lt;/code&gt; for keyboard key input. For more detail, read about &lt;a href=&quot;https://developer.mozilla.org/en/DOM/event.charCode#Notes&quot;&gt;event.charCode on the MDN&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;event.which&lt;/code&gt; 속성은 정규화 &lt;code&gt;event.keyCode&lt;/code&gt; 및 &lt;code&gt;event.charCode&lt;/code&gt; 을 . 키보드 키 입력을위한 &lt;code&gt;event.which&lt;/code&gt; 를 시청하는 것이 좋습니다 . 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/en/DOM/event.charCode#Notes&quot;&gt;은 MDN의 event.charCode에&lt;/a&gt; 대해 읽으십시오 .</target>
        </trans-unit>
        <trans-unit id="f120b8a959a3219847450a8ee53b66f4187d6db0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;events&lt;/code&gt; argument can either be a space-separated list of event type names and optional namespaces, or an object of event name strings and handlers. The &lt;code&gt;data&lt;/code&gt; argument is optional and can be omitted. For example, the following three method calls are functionally equivalent (but see below for more effective and performant ways to attach delegated event handlers):</source>
          <target state="translated">&lt;code&gt;events&lt;/code&gt; 인수는 어느 경우 유형 이름 및 옵션 네임 스페이스, 또는 이벤트 이름 문자열과 핸들러 객체의 공백으로 구분 된 목록이 될 수 있습니다. &lt;code&gt;data&lt;/code&gt; 인수는 선택 사항이며 생략 할 수 있습니다. 예를 들어, 다음 세 가지 메소드 호출은 기능적으로 동일합니다 (그러나 위임 된 이벤트 핸들러를 첨부하는보다 효과적이고 효과적인 방법은 아래 참조).</target>
        </trans-unit>
        <trans-unit id="975ef46efd18ee6d2e52c114a4f50c14f32efd22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is an optional argument to &lt;code&gt;$.Callbacks()&lt;/code&gt;, structured as a list of space-separated strings that change how the callback list behaves (eg. &lt;code&gt;$.Callbacks( &quot;unique stopOnFalse&quot; )&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;flags&lt;/code&gt; 인수에 선택적 인수입니다 &lt;code&gt;$.Callbacks()&lt;/code&gt; 공백으로 구분 된 문자열 목록으로 구성, 변경이 어떻게 콜백리스트 동작합니다 (예. &lt;code&gt;$.Callbacks( &quot;unique stopOnFalse&quot; )&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b181f01d34d240ec62554a3ea8b0f44ba029e93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;focus&lt;/code&gt; and &lt;code&gt;blur&lt;/code&gt; events are specified by the W3C to not bubble, but jQuery defines cross-browser &lt;code&gt;focusin&lt;/code&gt; and &lt;code&gt;focusout&lt;/code&gt; events that do bubble. When &lt;code&gt;focus&lt;/code&gt; and &lt;code&gt;blur&lt;/code&gt; are used to attach delegated event handlers, jQuery maps the names and delivers them as &lt;code&gt;focusin&lt;/code&gt; and &lt;code&gt;focusout&lt;/code&gt; respectively. For consistency and clarity, use the bubbling event type names.</source>
          <target state="translated">&lt;code&gt;focus&lt;/code&gt; 및 &lt;code&gt;blur&lt;/code&gt; 이벤트는하지 거품에 W3C에 의해 지정된하지만, jQuery를 크로스 브라우저를 정의하는 &lt;code&gt;focusin&lt;/code&gt; 및 &lt;code&gt;focusout&lt;/code&gt; 거품을 이벤트. 때 &lt;code&gt;focus&lt;/code&gt; 과 &lt;code&gt;blur&lt;/code&gt; 위임 된 이벤트 핸들러를 연결하는 데 사용됩니다, jQuery를이 이름을 매핑하고 그들을 제공 &lt;code&gt;focusin&lt;/code&gt; 및 &lt;code&gt;focusout&lt;/code&gt; 각각. 일관성과 명확성을 위해 버블 링 이벤트 유형 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d12d3d94af57d7b957f2a43b6a6ef3e7b3826720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;focus&lt;/code&gt; event does not bubble in Internet Explorer. Therefore, scripts that rely on event delegation with the &lt;code&gt;focus&lt;/code&gt; event will not work consistently across browsers. As of version 1.4.2, however, jQuery works around this limitation by mapping &lt;code&gt;focus&lt;/code&gt; to the &lt;code&gt;focusin&lt;/code&gt; event in its event delegation methods, &lt;a href=&quot;live&quot;&gt;&lt;code&gt;.live()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;delegate&quot;&gt;&lt;code&gt;.delegate()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;focus&lt;/code&gt; 이벤트는 Internet Explorer에서 거품을하지 않습니다. 따라서 &lt;code&gt;focus&lt;/code&gt; 이벤트 와 함께 이벤트 위임에 의존하는 스크립트는 브라우저에서 일관되게 작동하지 않습니다. 그러나 버전 1.4.2부터 jQuery 는 이벤트 위임 메소드 인 &lt;a href=&quot;live&quot;&gt; &lt;code&gt;.live()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;delegate&quot;&gt; &lt;code&gt;.delegate()&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;focusin&lt;/code&gt; 이벤트에 &lt;code&gt;focus&lt;/code&gt; 을 맵핑하여이 제한 사항을 해결합니다 .</target>
        </trans-unit>
        <trans-unit id="dc328d40a9d1978cbe1cf3f383e8ff007361446e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;focus&lt;/code&gt; event is sent to an element when it gains focus. This event is implicitly applicable to a limited set of elements, such as form elements (&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;, etc.) and links (&lt;code&gt;&amp;lt;a href&amp;gt;&lt;/code&gt;). In recent browser versions, the event can be extended to include all element types by explicitly setting the element's &lt;code&gt;tabindex&lt;/code&gt; property. An element can gain focus via keyboard commands, such as the Tab key, or by mouse clicks on the element.</source>
          <target state="translated">&lt;code&gt;focus&lt;/code&gt; 이 포커스를 얻어하면 이벤트 요소로 전송됩니다. 이 이벤트는 양식 요소 ( &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 등) 및 링크 ( &lt;code&gt;&amp;lt;a href&amp;gt;&lt;/code&gt; ) 와 같은 제한된 요소 세트에 암시 적으로 적용 가능합니다 . 최신 브라우저 버전에서는 요소의 &lt;code&gt;tabindex&lt;/code&gt; 속성 을 명시 적으로 설정하여 모든 요소 유형을 포함하도록 이벤트를 확장 할 수 있습니다 . 요소는 Tab 키와 같은 키보드 명령을 통해 또는 요소를 마우스로 클릭하여 초점을 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce407117100e5ba30e2542a045398a2d4fbe17b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;focusin&lt;/code&gt; event is sent to an element when it, or any element inside of it, gains focus. This is distinct from the &lt;a href=&quot;focus&quot;&gt;focus&lt;/a&gt; event in that it supports detecting the focus event on parent elements (in other words, it supports event bubbling).</source>
          <target state="translated">&lt;code&gt;focusin&lt;/code&gt; 그것, 또는 그 내부 요소가, 이익이 집중되면 이벤트는 요소로 전송됩니다. 이것은 부모 요소에서 포커스 이벤트 감지를 지원한다는 점에서 &lt;a href=&quot;focus&quot;&gt;포커스&lt;/a&gt; 이벤트와 다릅니다 (즉, 이벤트 버블 링을 지원함).</target>
        </trans-unit>
        <trans-unit id="5ce041c1230d97a8531ab94f0775a4789a0e64f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;focusout&lt;/code&gt; event is sent to an element when it, or any element inside of it, loses focus. This is distinct from the &lt;a href=&quot;blur&quot;&gt;blur&lt;/a&gt; event in that it supports detecting the loss of focus on descendant elements (in other words, it supports event bubbling).</source>
          <target state="translated">&lt;code&gt;focusout&lt;/code&gt; 그것을, 또는 그것의 모든 요소의 내부가, 포커스를 잃으면 이벤트는 요소로 전송됩니다. 이는 하위 요소에 대한 초점 손실 감지를 지원한다는 점에서 &lt;a href=&quot;blur&quot;&gt;블러&lt;/a&gt; 이벤트와 다릅니다 (즉, 이벤트 버블 링을 지원함).</target>
        </trans-unit>
        <trans-unit id="ce50aa35bcab51ace26d4577f16d8f766ee983d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;global&lt;/code&gt; option prevents handlers registered using &lt;code&gt;&lt;a href=&quot;ajaxsend&quot;&gt;.ajaxSend()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ajaxerror&quot;&gt;.ajaxError()&lt;/a&gt;&lt;/code&gt;, and similar methods from firing when this request would trigger them. This can be useful to, for example, suppress a loading indicator that was implemented with &lt;code&gt;&lt;a href=&quot;ajaxsend&quot;&gt;.ajaxSend()&lt;/a&gt;&lt;/code&gt; if the requests are frequent and brief. With cross-domain script and JSONP requests, the global option is automatically set to &lt;code&gt;false&lt;/code&gt;. See the descriptions of these methods below for more details.</source>
          <target state="translated">&lt;code&gt;global&lt;/code&gt; 옵션을 방지 처리기를 사용하여 등록 &lt;code&gt;&lt;a href=&quot;ajaxsend&quot;&gt;.ajaxSend()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ajaxerror&quot;&gt;.ajaxError()&lt;/a&gt;&lt;/code&gt; 이 요청을 트리거하는 경우에도 발사에서와 유사한 방법을. 예를 들어, 요청이 빈번하고 짧은 경우 &lt;code&gt;&lt;a href=&quot;ajaxsend&quot;&gt;.ajaxSend()&lt;/a&gt;&lt;/code&gt; 로 구현 된로드 표시기를 억제하는 데 유용 할 수 있습니다 . 도메인 간 스크립트 및 JSONP 요청의 경우 전역 옵션은 자동으로 &lt;code&gt;false&lt;/code&gt; 로 설정됩니다 . 자세한 내용은 아래 방법에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="abcc994cdebafa6dd62c6557f6c92b4296d2b215" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handler&lt;/code&gt; argument is a function (or the value &lt;code&gt;false&lt;/code&gt;, see below), and is required unless you pass an object for the &lt;code&gt;events&lt;/code&gt; argument. You can provide an anonymous handler function at the point of the &lt;code&gt;.on()&lt;/code&gt; call, as the examples have done above, or declare a named function and pass its name:</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 인수 (또는 값의 함수 &lt;code&gt;false&lt;/code&gt; , 아래 참조), 그리고 당신이에 대한 개체를 전달하지 않는 한 요구되는 &lt;code&gt;events&lt;/code&gt; 인수입니다. 위의 예제와 같이 &lt;code&gt;.on()&lt;/code&gt; 호출 시점에 익명 처리기 함수를 제공 하거나 명명 된 함수를 선언하고 이름을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2e0e1d782c5ee3726542833629d15debaa0990f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handler&lt;/code&gt; callback function can also take parameters. When the function is called, the event object will be passed to the first parameter.</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 콜백 함수는 매개 변수를 취할 수 있습니다. 함수가 호출되면 이벤트 객체가 첫 번째 매개 변수로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="aebaa4915cec07238cc3400080215cbb6913448d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;handler&lt;/code&gt; parameter takes a callback function, as shown above. Within the handler, the keyword &lt;code&gt;this&lt;/code&gt; refers to the DOM element to which the handler is bound. To make use of the element in jQuery, it can be passed to the normal &lt;code&gt;$()&lt;/code&gt; function. For example:</source>
          <target state="translated">&lt;code&gt;handler&lt;/code&gt; 위와 같이 파라미터는 콜백 함수 걸린다. 핸들러 내에서 키워드 &lt;code&gt;this&lt;/code&gt; 는 핸들러가 바인드 된 DOM 요소를 나타냅니다. jQuery에서 요소를 사용하기 위해 일반 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="665f1a800666ebe5c19cf6aa8ac859d59065c260" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.Callbacks()&lt;/code&gt; function, introduced in version 1.7, returns a multi-purpose object that provides a powerful way to manage callback lists. It supports adding, removing, firing, and disabling callbacks.</source>
          <target state="translated">&lt;code&gt;jQuery.Callbacks()&lt;/code&gt; 버전 1.7에 도입 된 기능은, 콜백 목록을 관리 할 수있는 강력한 방법을 제공하는 다목적 객체를 반환합니다. 콜백 추가, 제거, 실행 및 비활성화를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="8185fa0ab452f17f753c1df65484ea8db044e929" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.Deferred()&lt;/code&gt; factory creates a new &lt;code&gt;deferred&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;jQuery.Deferred()&lt;/code&gt; 공장은 새로운 생성 &lt;code&gt;deferred&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="604bbb8f562ce63abc8a4a830e579583ea19fc8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.Deferred&lt;/code&gt; method can be passed an optional function, which is called just before the method returns and is passed the new &lt;code&gt;deferred&lt;/code&gt; object as both the &lt;code&gt;this&lt;/code&gt; object and as the first argument to the function. The called function can attach callbacks using &lt;a href=&quot;deferred.then&quot;&gt;&lt;code&gt;deferred.then()&lt;/code&gt;&lt;/a&gt;, for example.</source>
          <target state="translated">&lt;code&gt;jQuery.Deferred&lt;/code&gt; 의 메소드는 메소드가 리턴하기 전에 호출되고 새로운 전달되는 옵션 기능, 전달 될 수 &lt;code&gt;deferred&lt;/code&gt; 모두 같은 객체를 &lt;code&gt;this&lt;/code&gt; 객체와 함수의 첫 번째 인수로합니다. 호출 된 함수는 예를 들어 &lt;a href=&quot;deferred.then&quot;&gt; &lt;code&gt;deferred.then()&lt;/code&gt; &lt;/a&gt; 사용하여 콜백을 첨부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="24b6745cb85fcef2edb81c76d1dd1ad2e0bd4c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.Event&lt;/code&gt; constructor is exposed and can be used when calling &lt;a href=&quot;../../trigger&quot;&gt;trigger&lt;/a&gt;. The &lt;code&gt;new&lt;/code&gt; operator is optional.</source>
          <target state="translated">&lt;code&gt;jQuery.Event&lt;/code&gt; 의 생성자는 노출하고 호출 할 때 사용할 수있는 &lt;a href=&quot;../../trigger&quot;&gt;트리거를&lt;/a&gt; . &lt;code&gt;new&lt;/code&gt; 연산자는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="13d3ca3d9389710007ac5e28b23209bd2827c184" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.data()&lt;/code&gt; method allows us to attach data of any type to DOM elements in a way that is safe from circular references and therefore free from memory leaks. jQuery ensures that the data is removed when DOM elements are removed via jQuery methods, and when the user leaves the page. We can set several distinct values for a single element and retrieve them later:</source>
          <target state="translated">&lt;code&gt;jQuery.data()&lt;/code&gt; 메소드는 우리가 순환 참조에서 안전한 메모리 누수로부터 따라서없는 방식으로 DOM 요소에 임의의 타입의 데이터를 첨부 할 수있다. jQuery는 jQuery 메소드를 통해 DOM 요소가 제거 될 때와 사용자가 페이지를 떠날 때 데이터가 제거되도록합니다. 단일 요소에 대해 몇 가지 고유 한 값을 설정하고 나중에 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3168126bd9faa615301fd22885baff874f9cdaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.data()&lt;/code&gt; method allows us to attach data of any type to DOM elements in a way that is safe from circular references and therefore from memory leaks. We can retrieve several distinct values for a single element one at a time, or as a set:</source>
          <target state="translated">&lt;code&gt;jQuery.data()&lt;/code&gt; 메소드는 우리가 순환 참조에서 안전하고, 따라서 메모리에서 누출되는 방식으로 DOM 요소에 임의의 타입의 데이터를 첨부 할 수있다. 한 번에 하나씩 또는 세트로 단일 요소에 대해 여러 가지 고유 한 값을 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b58ce5b2421f175cccfc55bc89b8f9326b398cd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.fn.extend()&lt;/code&gt; method extends the jQuery prototype (&lt;code&gt;$.fn&lt;/code&gt;) object to provide new methods that can be chained to the &lt;code&gt;jQuery()&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;jQuery.fn.extend()&lt;/code&gt; 메소드는 jQuery를 원형 (연장 &lt;code&gt;$.fn&lt;/code&gt; 받는 체인 될 수있는 새로운 방법을 제공하는) 객체 &lt;code&gt;jQuery()&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="60e2c149d29e3c58427eec1ddf67ea5a978e0da6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.hasData()&lt;/code&gt; method provides a way to determine if an element currently has any values that were set using &lt;code&gt;&lt;a href=&quot;jquery.data&quot;&gt;jQuery.data()&lt;/a&gt;&lt;/code&gt;. If there is no data object associated with an element, the method returns &lt;code&gt;false&lt;/code&gt;; otherwise it returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jQuery.hasData()&lt;/code&gt; 메소드가 요소가 현재 사용하고있는 설정 값을 보유하고 있는지 확인하는 방법을 제공 &lt;code&gt;&lt;a href=&quot;jquery.data&quot;&gt;jQuery.data()&lt;/a&gt;&lt;/code&gt; . 요소와 관련된 데이터 개체가 없으면 메서드는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="0da77c2aa73568361092bac2691ed27915c57df8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.queue()&lt;/code&gt; method allows us to directly manipulate this queue of functions. Calling &lt;code&gt;jQuery.queue()&lt;/code&gt; with a callback is particularly useful; it allows us to place a new function at the end of the queue.</source>
          <target state="translated">&lt;code&gt;jQuery.queue()&lt;/code&gt; 메소드는 우리가 직접 기능이 큐를 조작 할 수있다. 호출 &lt;code&gt;jQuery.queue()&lt;/code&gt; 콜백으로 특별히 유용하다; 대기열 끝에 새로운 기능을 배치 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="565a34b4e9f84c0d318e6c4a9c06da64b809bbb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jQuery.removeData()&lt;/code&gt; method allows us to remove values that were previously set using &lt;code&gt;&lt;a href=&quot;jquery.data&quot;&gt;jQuery.data()&lt;/a&gt;&lt;/code&gt;. When called with the name of a key, &lt;code&gt;jQuery.removeData()&lt;/code&gt; deletes that particular value; when called with no arguments, all values are removed.</source>
          <target state="translated">&lt;code&gt;jQuery.removeData()&lt;/code&gt; 메소드는 우리가 이전에 사용하여 설정 한 값을 제거 할 수 있습니다 &lt;code&gt;&lt;a href=&quot;jquery.data&quot;&gt;jQuery.data()&lt;/a&gt;&lt;/code&gt; . 키 이름으로 호출하면 &lt;code&gt;jQuery.removeData()&lt;/code&gt; 해당 특정 값을 삭제합니다. 인수없이 호출하면 모든 값이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="1e7bc28f086c399e4c9e321c7a440e482efc3b82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;jqXHR.success()&lt;/code&gt;, &lt;code&gt;jqXHR.error()&lt;/code&gt;, and &lt;code&gt;jqXHR.complete()&lt;/code&gt; callback methods are &lt;strong&gt;removed as of jQuery 3.0&lt;/strong&gt;. You can use &lt;code&gt;jqXHR.done()&lt;/code&gt;, &lt;code&gt;jqXHR.fail()&lt;/code&gt;, and &lt;code&gt;jqXHR.always()&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;jqXHR.success()&lt;/code&gt; , &lt;code&gt;jqXHR.error()&lt;/code&gt; 및 &lt;code&gt;jqXHR.complete()&lt;/code&gt; 콜백하는 방법이 &lt;strong&gt;jQuery를 3.0으로 제거&lt;/strong&gt; . 대신 &lt;code&gt;jqXHR.done()&lt;/code&gt; , &lt;code&gt;jqXHR.fail()&lt;/code&gt; 및 &lt;code&gt;jqXHR.always()&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f92be4fe000ad94fa5b76d5ae4cbd149a16e9eb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keydown&lt;/code&gt; event is sent to an element when the user presses a key on the keyboard. If the key is kept pressed, the event is sent every time the operating system repeats the key. It can be attached to any element, but the event is only sent to the element that has the focus. Focusable elements can vary between browsers, but form elements can always get focus so are reasonable candidates for this event type.</source>
          <target state="translated">&lt;code&gt;keydown&lt;/code&gt; 사용자가 키보드상의 키를 누를 때 이벤트 요소로 전송된다. 키를 계속 누르고 있으면 운영 체제에서 키를 반복 할 때마다 이벤트가 전송됩니다. 모든 요소에 첨부 할 수 있지만 이벤트는 포커스가있는 요소로만 전송됩니다. 포커스 가능한 요소는 브라우저마다 다를 수 있지만 양식 요소는 항상 포커스를 얻을 수 있으므로이 이벤트 유형에 적합한 후보입니다.</target>
        </trans-unit>
        <trans-unit id="32ff7dffe7efbc0b47c01cc769130f1179525ab3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keypress&lt;/code&gt; event is sent to an element when the browser registers keyboard input. This is similar to the &lt;code&gt;keydown&lt;/code&gt; event, except that modifier and non-printing keys such as</source>
          <target state="translated">&lt;code&gt;keypress&lt;/code&gt; 이벤트는 브라우저가 키보드 입력을 등록하는 요소로 전송됩니다. 이것은 유사하다 &lt;code&gt;keydown&lt;/code&gt; 등이 개질제와 비 인쇄 키를 제외하고, 이벤트</target>
        </trans-unit>
        <trans-unit id="ff2403eb27d497bc275c8f7c7d1d0a83914e9d14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keyup&lt;/code&gt; event is sent to an element when the user releases a key on the keyboard. It can be attached to any element, but the event is only sent to the element that has the focus. Focusable elements can vary between browsers, but form elements can always get focus so are reasonable candidates for this event type.</source>
          <target state="translated">&lt;code&gt;keyup&lt;/code&gt; 이벤트는 사용자가 키보드의 키를 놓을 요소로 전송됩니다. 모든 요소에 첨부 할 수 있지만 이벤트는 포커스가있는 요소로만 전송됩니다. 포커스 가능한 요소는 브라우저마다 다를 수 있지만 양식 요소는 항상 포커스를 얻을 수 있으므로이 이벤트 유형에 적합한 후보입니다.</target>
        </trans-unit>
        <trans-unit id="1ce285026d9f78e3b806cc2e447eb91d6f20c3e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;load&lt;/code&gt; event is sent to an element when it and all sub-elements have been completely loaded. This event can be sent to any element associated with a URL: images, scripts, frames, iframes, and the &lt;code&gt;window&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 이를 모든 서브 - 소자가 완전히 장착되었을 때 이벤트 요소로 전송된다. 이 이벤트는 URL, 이미지, 스크립트, 프레임, iframe 및 &lt;code&gt;window&lt;/code&gt; 객체 와 관련된 모든 요소로 전송 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="298347bd7f87fce8c617d4517cfd4c5ce65d731f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mousedown&lt;/code&gt; event is sent to an element when the mouse pointer is over the element, and the mouse button is pressed. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mousedown&lt;/code&gt; 마우스 포인터가 요소 위에있을 때 이벤트가 요소에 보내지고, 마우스 버튼을 누르면. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b9c501cecef8d644812a3b72346bce59b94d9fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mousedown&lt;/code&gt; event is sent when any mouse button is clicked. To act only on specific buttons, we can use the event object's &lt;code&gt;which&lt;/code&gt; property. Not all browsers support this property (Internet Explorer uses button instead), but jQuery normalizes the property so that it is safe to use in any browser. The value of &lt;code&gt;which&lt;/code&gt; will be 1 for the left button, 2 for the middle button, or 3 for the right button.</source>
          <target state="translated">&lt;code&gt;mousedown&lt;/code&gt; 마우스 단추를 클릭하면 이벤트가 전송됩니다. 특정 버튼에만 작용하기 위해 이벤트 객체의 &lt;code&gt;which&lt;/code&gt; 속성을 사용할 수 있습니다 . 모든 브라우저가이 속성을 지원하지는 않지만 (Internet Explorer는 단추를 대신 사용함) jQuery는 속성을 표준화하여 모든 브라우저에서 사용하기에 안전합니다. 값 오른쪽 버튼 가운데 버튼의 좌측 버튼 1, 2, 또는 3이 될 것이다. &lt;code&gt;which&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b37761ced6fd4810808c7ebb873311465526bbbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseenter&lt;/code&gt; JavaScript event is proprietary to Internet Explorer. Because of the event's general utility, jQuery simulates this event so that it can be used regardless of browser. This event is sent to an element when the mouse pointer enters the element. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mouseenter&lt;/code&gt; 자바 스크립트 이벤트는 인터넷 익스플로러 독점이다. 이벤트의 일반 유틸리티로 인해 jQuery는 브라우저와 상관없이 사용할 수 있도록이 이벤트를 시뮬레이션합니다. 이 이벤트는 마우스 포인터가 요소에 들어갈 때 요소로 전송됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1c57d8a811fc1f9c33a1dffeaf841a6e2c80c74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseenter&lt;/code&gt; event differs from &lt;code&gt;mouseover&lt;/code&gt; in the way it handles event bubbling. If &lt;code&gt;mouseover&lt;/code&gt; were used in this example, then when the mouse pointer moved over the</source>
          <target state="translated">&lt;code&gt;mouseenter&lt;/code&gt; 의 에서 이벤트 다릅니다 &lt;code&gt;mouseover&lt;/code&gt; 가 이벤트 버블 링을 처리하는 방식이다. 경우 &lt;code&gt;mouseover&lt;/code&gt; 이 예에서 사용 된 다음, 마우스 포인터가 움직였다 때</target>
        </trans-unit>
        <trans-unit id="0e998fa63a6373ae919ad037b49d4f728dd6bf05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseleave&lt;/code&gt; JavaScript event is proprietary to Internet Explorer. Because of the event's general utility, jQuery simulates this event so that it can be used regardless of browser. This event is sent to an element when the mouse pointer leaves the element. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mouseleave&lt;/code&gt; 자바 스크립트 이벤트는 인터넷 익스플로러 독점이다. 이벤트의 일반 유틸리티로 인해 jQuery는 브라우저와 상관없이 사용할 수 있도록이 이벤트를 시뮬레이션합니다. 이 이벤트는 마우스 포인터가 요소를 떠날 때 요소로 전송됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8164273b96e3740f431d9d5f3df765b4ec5c68f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseleave&lt;/code&gt; event differs from &lt;code&gt;mouseout&lt;/code&gt; in the way it handles event bubbling. If &lt;code&gt;mouseout&lt;/code&gt; were used in this example, then when the mouse pointer moved out of the</source>
          <target state="translated">&lt;code&gt;mouseleave&lt;/code&gt; 에서 이벤트 다릅니다 &lt;code&gt;mouseout&lt;/code&gt; 가 이벤트 버블 링을 처리하는 방식이다. 이 예제에서 &lt;code&gt;mouseout&lt;/code&gt; 을 사용한 경우 마우스 포인터가</target>
        </trans-unit>
        <trans-unit id="c983abec8d4a818cd465daf3f2d4afd6e71c9966" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mousemove&lt;/code&gt; event is sent to an element when the mouse pointer moves inside the element. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mousemove&lt;/code&gt; 이벤트가 요소에 보낼 때 요소 내부에 마우스 포인터를 이동합니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e082ba9c1250e9f802e30f0ec6097895f8b88e93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseout&lt;/code&gt; event is sent to an element when the mouse pointer leaves the element. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mouseout&lt;/code&gt; 마우스 포인터가 요소를 벗어날 때 이벤트는 요소로 전송됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9106e2ddd472a53e0cf775e02b396b8ff0b95fa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseover&lt;/code&gt; event is sent to an element when the mouse pointer enters the element. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mouseover&lt;/code&gt; 마우스 포인터가 요소를 입력하면 이벤트 요소로 전송됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e153372308071c715ee065406cb301d099f4f6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mouseup&lt;/code&gt; event is sent to an element when the mouse pointer is over the element, and the mouse button is released. Any HTML element can receive this event.</source>
          <target state="translated">&lt;code&gt;mouseup&lt;/code&gt; 마우스 포인터가 요소 위에있을 때 이벤트가 요소에 보내지고, 마우스 버튼이 해제됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26532a19220a35f1ea5c85fbd74d757625d7aed7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;null&lt;/code&gt; keyword is a JavaScript literal that is commonly used to express the absence of an intentional value.</source>
          <target state="translated">&lt;code&gt;null&lt;/code&gt; 키워드는 일반적으로 의도적 인 값의 부재를 표현하는 데 사용되는 자바 스크립트 리터럴입니다.</target>
        </trans-unit>
        <trans-unit id="392d2c36d94605ced68188b8ac59e9e5f6c1f8ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;opacity&lt;/code&gt; of the image is already at its target value, so this property is not animated by the second click. Since the target value for &lt;code&gt;left&lt;/code&gt; is a relative value, the image moves even farther to the right during this second animation.</source>
          <target state="translated">이미지 의 &lt;code&gt;opacity&lt;/code&gt; 는 이미 목표 값에 있으므로이 속성은 두 번째 클릭으로 애니메이션되지 않습니다. &lt;code&gt;left&lt;/code&gt; 의 목표 값 은 상대적인 값이므로이 두 번째 애니메이션 동안 이미지가 오른쪽으로 더 멀리 이동합니다.</target>
        </trans-unit>
        <trans-unit id="7bb964c5f56361acfa5ea28adb7c907dbc7f1504" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resize&lt;/code&gt; event is sent to the &lt;code&gt;window&lt;/code&gt; element when the size of the browser window changes:</source>
          <target state="translated">&lt;code&gt;resize&lt;/code&gt; 이벤트가 전송됩니다 &lt;code&gt;window&lt;/code&gt; 브라우저 윈도우의 크기가 변경 될 때 요소 :</target>
        </trans-unit>
        <trans-unit id="bffc347e3cd115a86996e548a12634ae46a7dcc4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scriptCharset&lt;/code&gt; allows the character set to be explicitly specified for requests that use a &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag (that is, a type of &lt;code&gt;script&lt;/code&gt; or &lt;code&gt;jsonp&lt;/code&gt;). This is useful if the script and host page have differing character sets.</source>
          <target state="translated">&lt;code&gt;scriptCharset&lt;/code&gt; 는 문자 집합이 명시 적으로 사용 요청을 지정할 수 있습니다 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그를 (의 유형입니다 &lt;code&gt;script&lt;/code&gt; 또는 &lt;code&gt;jsonp&lt;/code&gt; ). 스크립트와 호스트 페이지에 다른 문자 집합이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d9ccb6b9fab4201ed4391a6f6c072bb61ffc6663" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scroll&lt;/code&gt; event handler can be bound to this element:</source>
          <target state="translated">&lt;code&gt;scroll&lt;/code&gt; 이벤트 핸들러는이 요소에 바인딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="929f11cae458a443ec78fc803403671cdd96dc1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;scroll&lt;/code&gt; event is sent to an element when the user scrolls to a different place in the element. It applies to &lt;code&gt;window&lt;/code&gt; objects, but also to scrollable frames and elements with the &lt;code&gt;overflow &lt;/code&gt;CSS property set to &lt;code&gt;scroll&lt;/code&gt; (or &lt;code&gt;auto&lt;/code&gt; when the element's explicit height or width is less than the height or width of its contents).</source>
          <target state="translated">&lt;code&gt;scroll&lt;/code&gt; 사용자가 요소에서 다른 곳으로 스크롤 할 때 이벤트 요소로 전송된다. &lt;code&gt;window&lt;/code&gt; 객체뿐만 아니라 &lt;code&gt;overflow &lt;/code&gt; CSS 속성이 &lt;code&gt;scroll&lt;/code&gt; 설정된 스크롤 가능한 프레임 및 요소에도 적용됩니다 (또는 요소의 명시 적 높이 또는 너비가 내용의 높이 또는 너비보다 작은 경우 &lt;code&gt;auto&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8d5205a7fdd64edbe6625ef6cf64ce3deb0f9870" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; event is sent to an element when the user makes a text selection inside it. This event is limited to &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; fields and &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; boxes.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 이벤트는 사용자가 내부의 텍스트를 선택하게하는 요소로 전송된다. 이 이벤트는 &lt;code&gt;&amp;lt;input type=&quot;text&quot;&amp;gt;&lt;/code&gt; 필드 및 &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 상자로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="9113961f76be0bff850b1a78ab9fcf515e957ef2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;submit&lt;/code&gt; event is sent to an element when the user is attempting to submit a form. It can only be attached to &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; elements. Forms can be submitted either by clicking an explicit &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;input type=&quot;image&quot;&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;button type=&quot;submit&quot;&amp;gt;&lt;/code&gt;, or by pressing</source>
          <target state="translated">&lt;code&gt;submit&lt;/code&gt; 이벤트는 사용자가 양식을 제출하려고 요소로 전송됩니다. &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소 에만 첨부 할 수 있습니다 . 양식을 명시 적으로 클릭하여 제출할 수 있습니다. &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;input type=&quot;image&quot;&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;button type=&quot;submit&quot;&amp;gt;&lt;/code&gt; 또는 눌러</target>
        </trans-unit>
        <trans-unit id="0dfac108ca3a7f225da06d364c594943ffbf4277" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; callback function is passed the returned data, which will be an XML root element or a text string depending on the MIME type of the response. It is also passed the text status of the response.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; 콜백 함수는 XML 루트 요소 또는 응답의 MIME 유형에 따라 텍스트 문자열입니다 반환 된 데이터를 전달됩니다. 응답의 텍스트 상태도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="e14c3da3cd5f7d01c1aa5b508e80ef7ea3f16bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; callback function is passed the returned data, which will be an XML root element, text string, JavaScript file, or JSON object, depending on the MIME type of the response. It is also passed the text status of the response.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; 콜백 함수는 응답의 MIME 유형에 따라하는 XML 루트 요소, 텍스트 문자열, 자바 스크립트 파일 또는 JSON 객체가 될 것입니다 반환 된 데이터를 전달됩니다. 응답의 텍스트 상태도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="5ccddae9e6ea73cc88cf2256dce7c4e9e74fac18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; callback is passed the returned data, which is typically a JavaScript object or array as defined by the JSON structure and parsed using the &lt;code&gt;&lt;a href=&quot;jquery.parsejson&quot;&gt;$.parseJSON()&lt;/a&gt;&lt;/code&gt; method. It is also passed the text status of the response.</source>
          <target state="translated">&lt;code&gt;success&lt;/code&gt; 콜백은 JSON 구조에 의해 정의되고 사용 파싱 전형적 자바 스크립트 객체 또는 배열 반환 데이터 전달 &lt;code&gt;&lt;a href=&quot;jquery.parsejson&quot;&gt;$.parseJSON()&lt;/a&gt;&lt;/code&gt; 방법. 응답의 텍스트 상태도 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="f83c22f4983d0e50a0571d7102879050f1da052c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; property can be the element that registered for the event or a descendant of it. It is often useful to compare &lt;code&gt;event.target&lt;/code&gt; to &lt;code&gt;this&lt;/code&gt; in order to determine if the event is being handled due to event bubbling. This property is very useful in event delegation, when events bubble.</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 속성은 이벤트 또는 그 자손에 등록하는 요소가 될 수있다. &lt;code&gt;event.target&lt;/code&gt; 과 비교하는 것이 종종 유용 합니다 . &lt;code&gt;this&lt;/code&gt; 이벤트 버블 링으로 인해 이벤트가 처리되고 있는지 판별하기 위해 이것 과 . 이 속성은 이벤트 거품 발생시 이벤트 위임에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1b8d3506026b92f86a8e616813798c3b44dc5159" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;this&lt;/code&gt; reference within all callbacks is the object in the &lt;code&gt;context&lt;/code&gt; option passed to &lt;code&gt;$.ajax&lt;/code&gt; in the settings; if &lt;code&gt;context&lt;/code&gt; is not specified, &lt;code&gt;this&lt;/code&gt; is a reference to the Ajax settings themselves.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 모든 콜백 내에서 참조가있는 개체이다 &lt;code&gt;context&lt;/code&gt; 에 전달 옵션 &lt;code&gt;$.ajax&lt;/code&gt; 설정에서; 경우 &lt;code&gt;context&lt;/code&gt; 지정되지 않은, &lt;code&gt;this&lt;/code&gt; 아약스 설정 자체에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="7bcc51686054e999eac9f0a4254231a3d071aafe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;unload&lt;/code&gt; event is sent to the &lt;code&gt;window&lt;/code&gt; element when the user navigates away from the page. This could mean one of many things. The user could have clicked on a link to leave the page, or typed in a new URL in the address bar. The forward and back buttons will trigger the event. Closing the browser window will cause the event to be triggered. Even a page reload will first create an &lt;code&gt;unload&lt;/code&gt; event.</source>
          <target state="translated">&lt;code&gt;unload&lt;/code&gt; 이벤트가 전송되는 &lt;code&gt;window&lt;/code&gt; 는 사용자가 다른 페이지로 이동할 때 소자. 이것은 많은 것들 중 하나를 의미 할 수 있습니다. 사용자가 링크를 클릭하여 페이지를 떠나거나 주소 표시 줄에 새 URL을 입력했을 수 있습니다. 앞으로 및 뒤로 버튼은 이벤트를 트리거합니다. 브라우저 창을 닫으면 이벤트가 트리거됩니다. 페이지를 다시로드하더라도 먼저 &lt;code&gt;unload&lt;/code&gt; 이벤트가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="d09b0e7e80a1ed1f473f9537c4e4ed4c3ee2fdd4" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;Anything&lt;/strong&gt; virtual type is used in jQuery documentation to indicate that any type can be used or should be expected.</source>
          <target state="translated">&lt;strong&gt;아무것도&lt;/strong&gt; 가상 유형은 어떤 유형을 사용하거나 예상해야 함을 나타 내기 위해 jQuery를 문서에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="17ba7d519f5da361502187fb64363f84401d28a3" translate="yes" xml:space="preserve">
          <source>The Ajax module also has a method named &lt;code&gt;&lt;a href=&quot;load&quot;&gt;.load()&lt;/a&gt;&lt;/code&gt;. Which one is fired depends on the set of arguments passed.</source>
          <target state="translated">Ajax 모듈에는 &lt;code&gt;&lt;a href=&quot;load&quot;&gt;.load()&lt;/a&gt;&lt;/code&gt; 라는 메소드도 있습니다 . 어느 것이 발생했는지는 전달 된 인수 세트에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="b7648d06183b24c5934f6b9dd7232c3b3d4b750f" translate="yes" xml:space="preserve">
          <source>The Array of DOM elements.</source>
          <target state="translated">DOM 요소의 배열</target>
        </trans-unit>
        <trans-unit id="1ed686e6db6ada7c500787b23e3925a96af3fbc7" translate="yes" xml:space="preserve">
          <source>The Array to translate.</source>
          <target state="translated">번역 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2a94de58ebbebbaecd9d5009b890ff094e401547" translate="yes" xml:space="preserve">
          <source>The CSS specification allows elements to be identified by their attributes. While not supported by some older browsers for the purpose of styling documents, jQuery allows you to employ them regardless of the browser being used.</source>
          <target state="translated">CSS 사양을 사용하면 요소를 해당 속성으로 식별 할 수 있습니다. 문서를 스타일링하기 위해 일부 구형 브라우저에서는 지원하지 않지만 jQuery를 사용하면 사용중인 브라우저에 관계없이 브라우저를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344c01e9b699ec2972a3002d539ac1f765367d65" translate="yes" xml:space="preserve">
          <source>The DOM element or first element within the jQuery object to look for.</source>
          <target state="translated">jQuery 객체 내에서 찾을 DOM 요소 또는 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="ed5ebae3f36ac0af15138db92d7110d8347bb9aa" translate="yes" xml:space="preserve">
          <source>The DOM element that initiated the event.</source>
          <target state="translated">이벤트를 시작한 DOM 요소</target>
        </trans-unit>
        <trans-unit id="eab99c0095d7aec3d1b00060ff7c1b6aec862144" translate="yes" xml:space="preserve">
          <source>The DOM element that may be contained by (a descendant of) the other element.</source>
          <target state="translated">다른 요소 (자손)에 포함될 수있는 DOM 요소.</target>
        </trans-unit>
        <trans-unit id="2cec87eb51b7b37174f1c29a76ae13e9889ebe48" translate="yes" xml:space="preserve">
          <source>The DOM element that may contain the other element.</source>
          <target state="translated">다른 요소를 포함 할 수있는 DOM 요소</target>
        </trans-unit>
        <trans-unit id="fe6bef9476a7d79e0d7dff8416213cf39b5ca1e3" translate="yes" xml:space="preserve">
          <source>The DOM element to associate with the data.</source>
          <target state="translated">데이터와 연관시킬 DOM 요소.</target>
        </trans-unit>
        <trans-unit id="dc030c4a2d267f040181927d43fe4935e74d89fc" translate="yes" xml:space="preserve">
          <source>The DOM element to query for the data.</source>
          <target state="translated">데이터를 쿼리 할 DOM 요소입니다.</target>
        </trans-unit>
        <trans-unit id="5d6133b7dddf9fc4e773853a4b4b07d451a10ef9" translate="yes" xml:space="preserve">
          <source>The DOM node context originally passed to jQuery(); if none was passed then context will likely be the document.</source>
          <target state="translated">DOM 노드 컨텍스트는 원래 jQuery ()로 전달되었습니다. 전달되지 않은 경우 컨텍스트가 문서 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32ab8cdf2d8dfb86443e633f5408b3f7803e0bfe" translate="yes" xml:space="preserve">
          <source>The DOM node that will be checked to see if it's in an XML document.</source>
          <target state="translated">XML 문서에 있는지 확인하는 DOM 노드입니다.</target>
        </trans-unit>
        <trans-unit id="d4ceb340e65dd24c78ae93f5cd9af71b1fafda62" translate="yes" xml:space="preserve">
          <source>The Date type is a JavaScript object that represents a single moment in time. Date objects are instantiated using their constructor function, which by default creates an object that represents the current date and time.</source>
          <target state="translated">날짜 유형은 단일 시점을 나타내는 JavaScript 객체입니다. 날짜 개체는 기본적으로 현재 날짜와 시간을 나타내는 개체를 생성하는 생성자 함수를 사용하여 인스턴스화됩니다.</target>
        </trans-unit>
        <trans-unit id="3000f310db76967f2f07fdbcf374ac00504b3972" translate="yes" xml:space="preserve">
          <source>The Deferred object is chainable, similar to the way a jQuery object is chainable, but it has its own methods. After creating a Deferred object, you can use any of the methods below by either chaining directly from the object creation or saving the object in a variable and invoking one or more methods on that variable.</source>
          <target state="translated">Deferred 객체는 jQuery 객체가 연결 가능한 방식과 유사하게 연결 가능하지만 자체 메서드가 있습니다. 지연된 객체를 생성 한 후 객체 생성에서 직접 연결하거나 변수에 객체를 저장하고 해당 변수에 대해 하나 이상의 메소드를 호출하여 아래의 방법 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a1f8379a7498e59eef9c2b47244cc00919a3dbb" translate="yes" xml:space="preserve">
          <source>The Deferred object, introduced in jQuery 1.5, is a chainable utility object created by calling the &lt;a href=&quot;../jquery.deferred&quot;&gt;&lt;code&gt;jQuery.Deferred()&lt;/code&gt;&lt;/a&gt; method. It can register multiple callbacks into callback queues, invoke callback queues, and relay the success or failure state of any synchronous or asynchronous function.</source>
          <target state="translated">jQuery 1.5에 도입 된 Deferred 객체는 &lt;a href=&quot;../jquery.deferred&quot;&gt; &lt;code&gt;jQuery.Deferred()&lt;/code&gt; &lt;/a&gt; 메서드를 호출하여 만든 체인 가능한 유틸리티 객체입니다 . 콜백 큐에 여러 개의 콜백을 등록하고 콜백 큐를 호출하며 동기 또는 비동기 함수의 성공 또는 실패 상태를 릴레이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff66dca29c062490170f940b0d40f27697ff8621" translate="yes" xml:space="preserve">
          <source>The Event object</source>
          <target state="translated">이벤트 객체</target>
        </trans-unit>
        <trans-unit id="092a65cd15982d517c7cf3d19af043054e48e494" translate="yes" xml:space="preserve">
          <source>The HTML string on which to operate.</source>
          <target state="translated">작동 할 HTML 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="f6e4c07493ef60e5d01175f31e8dbda3949ad8bc" translate="yes" xml:space="preserve">
          <source>The HTTP method to use for the request (e.g. &lt;code&gt;&quot;POST&quot;&lt;/code&gt;, &lt;code&gt;&quot;GET&quot;&lt;/code&gt;, &lt;code&gt;&quot;PUT&quot;&lt;/code&gt;). (version added: &lt;a href=&quot;https://api.jquery.com/category/version/1.9.0/&quot;&gt;1.9.0&lt;/a&gt;)</source>
          <target state="translated">요청에 사용할 HTTP 메소드 (예 : &lt;code&gt;&quot;POST&quot;&lt;/code&gt; , &lt;code&gt;&quot;GET&quot;&lt;/code&gt; , &lt;code&gt;&quot;PUT&quot;&lt;/code&gt; ) (버전 추가 : &lt;a href=&quot;https://api.jquery.com/category/version/1.9.0/&quot;&gt;1.9.0&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="f3dc39f05895e187594bdff8c739099cd3ef44f2" translate="yes" xml:space="preserve">
          <source>The JSON standard does not permit &quot;control characters&quot; such as a tab or newline. An example like &lt;code&gt;$.parseJSON( '{ &quot;testing&quot;:&quot;1\t2\n3&quot; }' )&lt;/code&gt; will throw an error in most implementations because the JavaScript parser converts the string's tab and newline escapes into literal tab and newline; doubling the backslashes like &lt;code&gt;&quot;1\\t2\\n3&quot;&lt;/code&gt; yields expected results. This problem is often seen when injecting JSON into a JavaScript file from a server-side language such as PHP.</source>
          <target state="translated">JSON 표준에서는 탭이나 줄 바꿈과 같은 &quot;제어 문자&quot;를 허용하지 않습니다. JavaScript 파서가 문자열의 탭과 개행 이스케이프를 리터럴 탭과 개행 문자로 변환하기 때문에 &lt;code&gt;$.parseJSON( '{ &quot;testing&quot;:&quot;1\t2\n3&quot; }' )&lt;/code&gt; 과 같은 예제 는 대부분의 구현에서 오류를 발생시킵니다. &lt;code&gt;&quot;1\\t2\\n3&quot;&lt;/code&gt; 과 같이 백 슬래시를 두 배로 늘리면 예상 결과가 나타납니다. 이 문제는 종종 PHP와 같은 서버 측 언어에서 JavaScript 파일로 JSON을 주입 할 때 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0309d3fb6068e328dd40b93aceba5a1d021334b9" translate="yes" xml:space="preserve">
          <source>The JSON string to parse.</source>
          <target state="translated">구문 분석 할 JSON 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="efd29258fca513f46146772577c2b30f5e2a0f96" translate="yes" xml:space="preserve">
          <source>The JavaScript &lt;code&gt;submit&lt;/code&gt; event does not bubble in Internet Explorer. However, scripts that rely on event delegation with the &lt;code&gt;submit&lt;/code&gt; event will work consistently across browsers as of jQuery 1.4, which has normalized the event's behavior.</source>
          <target state="translated">Internet Explorer에서 JavaScript &lt;code&gt;submit&lt;/code&gt; 이벤트가 버블 링되지 않습니다. 그러나 &lt;code&gt;submit&lt;/code&gt; 이벤트 와 함께 이벤트 위임에 의존하는 스크립트 는 jQuery 1.4부터 브라우저에서 일관되게 작동하며, 이는 이벤트의 동작을 정상화합니다.</target>
        </trans-unit>
        <trans-unit id="724d8c6764e0316ac4c41ba0c0b56449243a6c38" translate="yes" xml:space="preserve">
          <source>The JavaScript code to execute.</source>
          <target state="translated">실행할 JavaScript 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3b2129b20519ddffea0fe7ceea74d5ff0a115896" translate="yes" xml:space="preserve">
          <source>The Object to translate.</source>
          <target state="translated">번역 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c8d98bc8f048d9c824aebc49e11225ff08a91d77" translate="yes" xml:space="preserve">
          <source>The POST method is used if data is provided as an object; otherwise, GET is assumed.</source>
          <target state="translated">데이터가 객체로 제공되는 경우 POST 방법이 사용됩니다. 그렇지 않으면 GET이 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="2640e06e6701b966e29a283e9bd75f2d73784d4b" translate="yes" xml:space="preserve">
          <source>The PlainObject type is a JavaScript object containing zero or more key-value pairs. The plain object is, in other words, an &lt;code&gt;Object&lt;/code&gt; object. It is designated &quot;plain&quot; in jQuery documentation to distinguish it from other kinds of JavaScript objects: for example, &lt;code&gt;null&lt;/code&gt;, user-defined arrays, and host objects such as &lt;code&gt;document&lt;/code&gt;, all of which have a &lt;code&gt;typeof&lt;/code&gt; value of &quot;object.&quot; The &lt;code&gt;&lt;a href=&quot;jquery.isplainobject&quot;&gt;jQuery.isPlainObject()&lt;/a&gt;&lt;/code&gt; method identifies whether the passed argument is a plain object or not, as demonstrated below:</source>
          <target state="translated">PlainObject 유형은 0 개 이상의 키-값 쌍을 포함하는 JavaScript 객체입니다. 일반 객체는 다시 말해 &lt;code&gt;Object&lt;/code&gt; 객체입니다. 자바 스크립트를 다른 종류의 구별 할 jQuery를 문서에이 지정되어 &quot;일반&quot;는 객체 : 예를 들어, &lt;code&gt;null&lt;/code&gt; , 사용자 정의 배열 및 호스트가 같은 개체를 &lt;code&gt;document&lt;/code&gt; 이 모두, &lt;code&gt;typeof&lt;/code&gt; 의 값 &quot;개체를.&quot; &lt;code&gt;&lt;a href=&quot;jquery.isplainobject&quot;&gt;jQuery.isPlainObject()&lt;/a&gt;&lt;/code&gt; 전달 인자 아래 있듯이 일반 목적 여부,인지 식별 방법 :</target>
        </trans-unit>
        <trans-unit id="587e7d693373dd183bdd6d7b252b02ad4cbc6584" translate="yes" xml:space="preserve">
          <source>The Promise interface also allows jQuery's Ajax methods, including &lt;code&gt;$.get()&lt;/code&gt;, to chain multiple &lt;code&gt;.done()&lt;/code&gt;, &lt;code&gt;.fail()&lt;/code&gt;, and &lt;code&gt;.always()&lt;/code&gt; callbacks on a single request, and even to assign these callbacks after the request may have completed. If the request is already complete, the callback is fired immediately.</source>
          <target state="translated">Promise 인터페이스는 또한 &lt;code&gt;$.get()&lt;/code&gt; 포함한 jQuery의 Ajax 메소드 가 단일 요청에서 여러 &lt;code&gt;.done()&lt;/code&gt; , &lt;code&gt;.fail()&lt;/code&gt; 및 &lt;code&gt;.always()&lt;/code&gt; 콜백을 연결하고 요청 후 이러한 콜백을 할당 할 수 있도록합니다. 완료했습니다. 요청이 이미 완료되면 콜백이 즉시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="43e52de5068bb1e070f3ee42e34c03fc0ec345d8" translate="yes" xml:space="preserve">
          <source>The Promise interface in jQuery 1.5 also allows jQuery's Ajax methods, including &lt;code&gt;$.getJSON()&lt;/code&gt;, to chain multiple &lt;code&gt;.done()&lt;/code&gt;, &lt;code&gt;.always()&lt;/code&gt;, and &lt;code&gt;.fail()&lt;/code&gt; callbacks on a single request, and even to assign these callbacks after the request may have completed. If the request is already complete, the callback is fired immediately.</source>
          <target state="translated">jQuery 1.5의 Promise 인터페이스는 또한 &lt;code&gt;$.getJSON()&lt;/code&gt; 포함한 jQuery의 Ajax 메소드 가 단일 요청에서 여러 개의 &lt;code&gt;.done()&lt;/code&gt; , &lt;code&gt;.always()&lt;/code&gt; 및 &lt;code&gt;.fail()&lt;/code&gt; 콜백을 연결하고 이후에도 이러한 콜백을 할당 할 수 있도록합니다. 요청이 완료되었을 수 있습니다. 요청이 이미 완료되면 콜백이 즉시 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d6eb2e2c386b7b7095dc892d50af68ceac7a6ab8" translate="yes" xml:space="preserve">
          <source>The W3C recommends that the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element have at least one child node, even if that child is merely text (see &lt;a href=&quot;https://www.w3.org/TR/html401/struct/text.html#edef-P&quot;&gt;http://www.w3.org/TR/html401/struct/text.html#edef-P&lt;/a&gt;). Some other elements, on the other hand, are empty (i.e. have no children) by definition:&lt;code&gt; &amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;, for example.</source>
          <target state="translated">W3C는 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소에 해당 하위 요소가 텍스트 인 경우에도 하나 이상의 하위 노드가있는 것이 좋습니다 ( &lt;a href=&quot;https://www.w3.org/TR/html401/struct/text.html#edef-P&quot;&gt;http://www.w3.org/TR/html401/struct/text.html#edef-P 참조&lt;/a&gt; ). 반면에 일부 다른 요소는 &lt;code&gt; &amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; 정의에 따라 비어 있습니다 (즉, 자식이 없음) .</target>
        </trans-unit>
        <trans-unit id="5b6519a6ba7c2d20aff481697ae138b671dc2b3a" translate="yes" xml:space="preserve">
          <source>The W3C recommends that the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element have at least one child node, even if that child is merely text (see &lt;a href=&quot;https://www.w3.org/TR/html401/struct/text.html#edef-P&quot;&gt;https://www.w3.org/TR/html401/struct/text.html#edef-P&lt;/a&gt;). Some other elements, on the other hand, are empty (i.e. have no children) by definition:&lt;code&gt; &amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;, for example.</source>
          <target state="translated">W3C는 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소가 단지 텍스트 일지라도 적어도 하나의 하위 노드를 가질 것을 권장 합니다 ( &lt;a href=&quot;https://www.w3.org/TR/html401/struct/text.html#edef-P&quot;&gt;https://www.w3.org/TR/html401/struct/text.html#edef-P 참조&lt;/a&gt; ). 반면에 일부 다른 요소는 정의에 따라 비어 있습니다 (즉, 자식이 없음) : 예를 들어 &lt;code&gt; &amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e19a093a3b453869f5a9e45b3b4c2922a34b749" translate="yes" xml:space="preserve">
          <source>The W3C recommends that the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; element have at least one child node, even if that child is merely text (see https://www.w3.org/TR/html401/struct/text.html#edef-P). Some other elements, on the other hand, are empty (i.e. have no children) by definition: &amp;lt;input&amp;gt;, &amp;lt;img&amp;gt;, &amp;lt;br&amp;gt;, and &amp;lt;hr&amp;gt;, for example.</source>
          <target state="translated">W3C는 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 요소에 해당 하위 요소가 텍스트 인 경우에도 하나 이상의 하위 노드를 갖도록 권장 합니다 (https://www.w3.org/TR/html401/struct/text.html#edef-P 참조). 반면에 일부 다른 요소는 &amp;lt;input&amp;gt;, &amp;lt;img&amp;gt;, &amp;lt;br&amp;gt; 및 &amp;lt;hr&amp;gt;과 같이 정의상 비어 있습니다 (예 : 자식이 없음).</target>
        </trans-unit>
        <trans-unit id="070d3bba3be689c7dcc9db2cb7e1c2b999bc4b84" translate="yes" xml:space="preserve">
          <source>The above code will generate two different alerts when the button is clicked.</source>
          <target state="translated">위의 코드는 버튼을 클릭 할 때 두 가지 경고를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="9f62fe5d402e31a15da9defb30b12c9f45a3306a" translate="yes" xml:space="preserve">
          <source>The above lines alert the data values that were set on the &lt;code&gt;body&lt;/code&gt; element. If no data at all was set on that element, &lt;code&gt;undefined&lt;/code&gt; is returned.</source>
          <target state="translated">위의 라인은 &lt;code&gt;body&lt;/code&gt; 요소 에 설정된 데이터 값을 경고합니다 . 해당 요소에 데이터가 전혀 설정 &lt;code&gt;undefined&lt;/code&gt; 경우 undefined 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19dbc42eb0079a96f335996e2465e83a8699102f" translate="yes" xml:space="preserve">
          <source>The above lines alert the data values that were set on the &lt;code&gt;body&lt;/code&gt; element. If nothing was set on that element, an empty string is returned.</source>
          <target state="translated">위의 라인은 &lt;code&gt;body&lt;/code&gt; 요소 에 설정된 데이터 값을 경고합니다 . 해당 요소에 아무것도 설정되지 않은 경우 빈 문자열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="eae634c1a9899fb5e22d8b13e7563287e4cef7e7" translate="yes" xml:space="preserve">
          <source>The above now allows passing from &lt;code&gt;text&lt;/code&gt; to &lt;code&gt;mycustomtype&lt;/code&gt; and then &lt;code&gt;mycustomtype&lt;/code&gt; to &lt;code&gt;json&lt;/code&gt;.</source>
          <target state="translated">위의 내용은 이제 &lt;code&gt;text&lt;/code&gt; 에서 &lt;code&gt;mycustomtype&lt;/code&gt; 으로 , &lt;code&gt;mycustomtype&lt;/code&gt; 에서 &lt;code&gt;json&lt;/code&gt; 으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2b32e570dfd596419701353365115bdabacf94c4" translate="yes" xml:space="preserve">
          <source>The above wraps its code in a function to hide the &quot;proxied&quot;-variable. It saves jQuery's setArray-method in a closure and overwrites it. The proxy then logs all calls to the method and delegates the call to the original. Using apply(this, arguments) guarantees that the caller won't be able to notice the difference between the original and the proxied method.</source>
          <target state="translated">위의 코드는 &quot;proxied&quot;변수를 숨기는 함수로 코드를 래핑합니다. jQuery의 setArray-method를 클로저에 저장하고 덮어 씁니다. 그런 다음 프록시는 모든 호출을 메소드에 기록하고 호출을 원본에 위임합니다. apply (this, arguments)를 사용하면 호출자가 원래 메소드와 프록시 메소드의 차이점을 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6610ea50c945318d3ab7693d709bd53977c14242" translate="yes" xml:space="preserve">
          <source>The argument can be either a single function or an array of functions. When the Deferred is resolved or rejected, the &lt;code&gt;alwaysCallbacks&lt;/code&gt; are called. Since &lt;code&gt;deferred.always()&lt;/code&gt; returns the Deferred object, other methods of the Deferred object can be chained to this one, including additional &lt;code&gt;.always()&lt;/code&gt; methods. When the Deferred is resolved or rejected, callbacks are executed in the order they were added, using the arguments provided to the &lt;a href=&quot;deferred.resolve&quot;&gt;&lt;code&gt;resolve&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.reject&quot;&gt;&lt;code&gt;reject&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.resolvewith&quot;&gt;&lt;code&gt;resolveWith&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;deferred.rejectwith&quot;&gt;&lt;code&gt;rejectWith&lt;/code&gt;&lt;/a&gt; method calls. For more information, see the documentation for &lt;a href=&quot;category/deferred-object&quot;&gt;Deferred object&lt;/a&gt;.</source>
          <target state="translated">인수는 단일 함수 또는 함수 배열 일 수 있습니다. 지연이 해결되거나 거부되면 &lt;code&gt;alwaysCallbacks&lt;/code&gt; 이 호출됩니다. 이후 &lt;code&gt;deferred.always()&lt;/code&gt; 지연된 객체를 반환 우회 대상의 다른 방법이 추가로 포함 하나, 체인 수 &lt;code&gt;.always()&lt;/code&gt; 메소드. Deferred가 해결되거나 거부되면 콜백은 &lt;a href=&quot;deferred.resolve&quot;&gt; &lt;code&gt;resolve&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.reject&quot;&gt; &lt;code&gt;reject&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.resolvewith&quot;&gt; &lt;code&gt;resolveWith&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;deferred.rejectwith&quot;&gt; &lt;code&gt;rejectWith&lt;/code&gt; &lt;/a&gt; 메소드 호출에 제공된 인수를 사용하여 추가 된 순서대로 실행됩니다 . 자세한 내용은 &lt;a href=&quot;category/deferred-object&quot;&gt;지연된 객체&lt;/a&gt; 설명서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b4b7d3a4511e33399069ffc13d4bc8def0f503b" translate="yes" xml:space="preserve">
          <source>The argument or list of arguments to pass back to the callback list.</source>
          <target state="translated">콜백 목록으로 다시 전달할 인수 또는 인수 목록입니다.</target>
        </trans-unit>
        <trans-unit id="953b3138188e0f4497437947cd8a29321abeb58c" translate="yes" xml:space="preserve">
          <source>The arguments object also has a callee property, which refers to the function you're inside of. For instance:</source>
          <target state="translated">arguments 객체에는 내부에있는 함수를 나타내는 callee 속성도 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="bc1aa336f96c29c99dc1ba1bdef4fa0b9f4fb846" translate="yes" xml:space="preserve">
          <source>The arguments that were passed in to the jQuery method (for serialization).</source>
          <target state="translated">jQuery 메소드에 전달 된 인수 (직렬화).</target>
        </trans-unit>
        <trans-unit id="01fe9863cb30f7b0bcc0e1d8d4a68a046910e081" translate="yes" xml:space="preserve">
          <source>The array or array-like object to iterate over.</source>
          <target state="translated">반복 할 배열 또는 배열 유사 객체입니다.</target>
        </trans-unit>
        <trans-unit id="bfc6aedd808a2761d036a171b890dbe3969ca47d" translate="yes" xml:space="preserve">
          <source>The array-like object to search through.</source>
          <target state="translated">검색 할 배열과 유사한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a92d8a0b1c47a77890394dcce7884f2dd51b73ca" translate="yes" xml:space="preserve">
          <source>The available data types are &lt;code&gt;text&lt;/code&gt;, &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt;, &lt;code&gt;json&lt;/code&gt;, &lt;code&gt;jsonp&lt;/code&gt;, and &lt;code&gt;script&lt;/code&gt;.</source>
          <target state="translated">사용 가능한 데이터 유형은 &lt;code&gt;text&lt;/code&gt; , &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;xml&lt;/code&gt; , &lt;code&gt;json&lt;/code&gt; , &lt;code&gt;jsonp&lt;/code&gt; 및 &lt;code&gt;script&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f474111176dbe4b72c85bfbcfa1c612929642144" translate="yes" xml:space="preserve">
          <source>The callback hooks provided by &lt;code&gt;$.ajax()&lt;/code&gt; are as follows:</source>
          <target state="translated">&lt;code&gt;$.ajax()&lt;/code&gt; 가 제공하는 콜백 후크 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48456f9d8ed08fb80093cafa81da3b3750f4a2ec" translate="yes" xml:space="preserve">
          <source>The callback is fired once the script has been loaded but not necessarily executed.</source>
          <target state="translated">스크립트가로드되었지만 반드시 실행되는 것은 아니라면 콜백이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="0a150dbeefa27a6fdaddf5d4cbf61e79e3e341a3" translate="yes" xml:space="preserve">
          <source>The callback to search for.</source>
          <target state="translated">검색 할 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="6b9e0b41d52d14d06d6f59d74c2f23e7bb7aacd6" translate="yes" xml:space="preserve">
          <source>The child combinator (E &lt;strong&gt;&amp;gt;&lt;/strong&gt; F) can be thought of as a more specific form of the descendant combinator (E F) in that it selects only first-level descendants.</source>
          <target state="translated">자식 콤비 네이터 (E &lt;strong&gt;&amp;gt;&lt;/strong&gt; F)는 첫 번째 수준의 자손 만 선택한다는 점에서보다 구체적인 형태의 자손 콤비 네이터 (EF)로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0131d897f9ebfd2e8528f7451f2bd70eaf19197" translate="yes" xml:space="preserve">
          <source>The class name to search for.</source>
          <target state="translated">검색 할 클래스 이름입니다.</target>
        </trans-unit>
        <trans-unit id="1c76c95474ded1c83df62e9659deaf1e78a2557e" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;$( &quot;div.demo-container&quot; ).text( &quot;&amp;lt;p&amp;gt;This is a test.&amp;lt;/p&amp;gt;&quot; );&lt;/code&gt; will produce the following DOM output:</source>
          <target state="translated">코드 &lt;code&gt;$( &quot;div.demo-container&quot; ).text( &quot;&amp;lt;p&amp;gt;This is a test.&amp;lt;/p&amp;gt;&quot; );&lt;/code&gt; 다음과 같은 DOM 출력이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ee09ededc986c4fde55112bb27792c5ab11f4d64" translate="yes" xml:space="preserve">
          <source>The code &lt;code&gt;$( &quot;div.demo-container&quot; ).text()&lt;/code&gt; would produce the following result:</source>
          <target state="translated">&lt;code&gt;$( &quot;div.demo-container&quot; ).text()&lt;/code&gt; 코드 는 다음과 같은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0ff3e41c1bb8be78905878d3080804c616d66cc8" translate="yes" xml:space="preserve">
          <source>The comparison between values is strict. The following will return &lt;code&gt;-1&lt;/code&gt; (not found) because a number is being searched in an array of strings:</source>
          <target state="translated">값 사이의 비교는 엄격합니다. 다음은 문자열 배열에서 숫자를 검색하기 때문에 &lt;code&gt;-1&lt;/code&gt; (찾을 수 없음)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="63934f4de86321cfe3280de8cd4a6928e795771b" translate="yes" xml:space="preserve">
          <source>The complementary operation to &lt;code&gt;.get()&lt;/code&gt;, which accepts an index and returns a DOM node, &lt;code&gt;.index()&lt;/code&gt; can take a DOM node and returns an index. Suppose we have a simple unordered list on the page:</source>
          <target state="translated">인덱스를 받아들이고 DOM 노드를 반환하는 &lt;code&gt;.get()&lt;/code&gt; 대한 보완 작업 &lt;code&gt;.index()&lt;/code&gt; 는 DOM 노드를 가져와 인덱스를 반환 할 수 있습니다. 페이지에 간단한 순서없는 목록이 있다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="04f4668e4368f2a79f73dba514f8e60e41c8e365" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;&amp;lt;div class=&quot;demo-container&quot;&amp;gt;&lt;/code&gt; can be set like this:</source>
          <target state="translated">의 내용 &lt;code&gt;&amp;lt;div class=&quot;demo-container&quot;&amp;gt;&lt;/code&gt; 과 같이 설정할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8d9bb9d21c71526c772e1cdf35a9a991a7064a75" translate="yes" xml:space="preserve">
          <source>The content to insert. May be an HTML string, DOM element, array of DOM elements, or jQuery object.</source>
          <target state="translated">삽입 할 내용입니다. HTML 문자열, DOM 요소, DOM 요소 배열 또는 jQuery 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e1584a1b9999c4d1def5c45e27ab44e4599a0d8" translate="yes" xml:space="preserve">
          <source>The current DOM element within the event bubbling phase.</source>
          <target state="translated">이벤트 버블 링 단계 내의 현재 DOM 요소</target>
        </trans-unit>
        <trans-unit id="46824c34fb82db130a2df5609dafd2545fdc3db2" translate="yes" xml:space="preserve">
          <source>The data- attributes are pulled in the first time the data property is accessed and then are no longer accessed or mutated (all data values are then stored internally in jQuery).</source>
          <target state="translated">데이터 속성은 처음으로 데이터 속성에 액세스 한 다음 더 이상 액세스하거나 변경하지 않습니다 (모든 데이터 값은 내부적으로 jQuery에 저장 됨).</target>
        </trans-unit>
        <trans-unit id="8b8b1c908f3b2c347bd0eeb6d735aa8ab48d1652" translate="yes" xml:space="preserve">
          <source>The deferred.state() method returns a string representing the current state of the Deferred object. The Deferred object can be in one of three states:</source>
          <target state="translated">deferred.state () 메소드는 Deferred 객체의 현재 상태를 나타내는 문자열을 반환합니다. 지연된 오브젝트는 다음 세 가지 상태 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77b4a3dc9d992a9171395774e152136eb0aa3384" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;.css( &quot;height&quot; )&lt;/code&gt; and &lt;code&gt;.height()&lt;/code&gt; is that the latter returns a unit-less pixel value (for example, &lt;code&gt;400&lt;/code&gt;) while the former returns a value with units intact (for example, &lt;code&gt;400px&lt;/code&gt;). The &lt;code&gt;.height()&lt;/code&gt; method is recommended when an element's height needs to be used in a mathematical calculation.</source>
          <target state="translated">&lt;code&gt;.css( &quot;height&quot; )&lt;/code&gt; 와 &lt;code&gt;.height()&lt;/code&gt; 의 차이점 은 후자는 단위없는 픽셀 값 (예 : &lt;code&gt;400&lt;/code&gt; )을 반환하고 전자는 그대로있는 단위 (예 : &lt;code&gt;400px&lt;/code&gt; ) 의 값을 반환한다는 것 입니다. &lt;code&gt;.height()&lt;/code&gt; 메소드는 엘리먼트의 높이가 수학적 계산에 사용되어야 할 때 권장된다.</target>
        </trans-unit>
        <trans-unit id="b8391b1a8d5a18b73e9581f59ba3273ec27cce80" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;.css( &quot;width&quot; )&lt;/code&gt; and &lt;code&gt;.width()&lt;/code&gt; is that the latter returns a unit-less pixel value (for example, &lt;code&gt;400&lt;/code&gt;) while the former returns a value with units intact (for example, &lt;code&gt;400px&lt;/code&gt;). The &lt;code&gt;.width()&lt;/code&gt; method is recommended when an element's width needs to be used in a mathematical calculation.</source>
          <target state="translated">&lt;code&gt;.css( &quot;width&quot; )&lt;/code&gt; 와 &lt;code&gt;.width()&lt;/code&gt; 의 차이점 은 후자는 단위없는 픽셀 값 (예 : &lt;code&gt;400&lt;/code&gt; )을 반환하고 전자는 단위가 그대로있는 값 (예 : &lt;code&gt;400px&lt;/code&gt; )을 반환한다는 것 입니다. &lt;code&gt;.width()&lt;/code&gt; 요소의 폭이 필요 수학적 연산에 사용될 때 방법이 권장된다.</target>
        </trans-unit>
        <trans-unit id="d50a600af0ee02848ff5326868c4753647ab9366" translate="yes" xml:space="preserve">
          <source>The difference between &lt;code&gt;.css(width)&lt;/code&gt; and &lt;code&gt;.width()&lt;/code&gt; is that the latter returns a unit-less pixel value (for example, &lt;code&gt;400&lt;/code&gt;) while the former returns a value with units intact (for example, &lt;code&gt;400px&lt;/code&gt;). The &lt;code&gt;.width()&lt;/code&gt; method is recommended when an element's width needs to be used in a mathematical calculation.</source>
          <target state="translated">&lt;code&gt;.css(width)&lt;/code&gt; 와 &lt;code&gt;.width()&lt;/code&gt; 의 차이점 은 후자는 단위없는 픽셀 값 (예 : &lt;code&gt;400&lt;/code&gt; )을 반환하고 전자는 그대로있는 단위 (예 : &lt;code&gt;400px&lt;/code&gt; ) 의 값을 반환한다는 것 입니다. &lt;code&gt;.width()&lt;/code&gt; 요소의 폭이 필요 수학적 연산에 사용될 때 방법이 권장된다.</target>
        </trans-unit>
        <trans-unit id="37202ea5ad20c3706e31a8627329e1cc35a19b29" translate="yes" xml:space="preserve">
          <source>The difference between &lt;em&gt;attributes&lt;/em&gt; and &lt;em&gt;properties&lt;/em&gt; can be important in specific situations. &lt;strong&gt;Before jQuery 1.6&lt;/strong&gt;, the &lt;code&gt;.attr()&lt;/code&gt; method sometimes took property values into account when retrieving some attributes, which could cause inconsistent behavior. &lt;strong&gt;As of jQuery 1.6&lt;/strong&gt;, the &lt;code&gt;.prop()&lt;/code&gt; method provides a way to explicitly retrieve property values, while &lt;code&gt;.attr()&lt;/code&gt; retrieves attributes.</source>
          <target state="translated">&lt;em&gt;특성&lt;/em&gt; 과 &lt;em&gt;속성&lt;/em&gt; 의 차이 는 특정 상황에서 중요 할 수 있습니다. &lt;strong&gt;jQuery 1.6 이전&lt;/strong&gt; 에는 &lt;code&gt;.attr()&lt;/code&gt; 메소드가 일부 속성을 검색 할 때 특성 값을 고려하여 일관성이없는 동작을 유발할 수 있습니다. &lt;strong&gt;jQuery 1.6&lt;/strong&gt; 부터 &lt;code&gt;.prop()&lt;/code&gt; 메소드는 속성 값을 명시 적으로 검색하는 방법을 제공하는 반면 &lt;code&gt;.attr()&lt;/code&gt; 은 속성을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="c8b8341db17aad3ed60ff6d25f09507ac30ab22b" translate="yes" xml:space="preserve">
          <source>The difference between &lt;em&gt;attributes&lt;/em&gt; and &lt;em&gt;properties&lt;/em&gt; can be important in specific situations. &lt;strong&gt;Before jQuery 1.6&lt;/strong&gt;, the &lt;code&gt;&lt;a href=&quot;attr&quot;&gt;.attr()&lt;/a&gt;&lt;/code&gt; method sometimes took property values into account when retrieving some attributes, which could cause inconsistent behavior. &lt;strong&gt;As of jQuery 1.6&lt;/strong&gt;, the &lt;code&gt;.prop()&lt;/code&gt; method provides a way to explicitly retrieve property values, while &lt;code&gt;.attr()&lt;/code&gt; retrieves attributes.</source>
          <target state="translated">&lt;em&gt;특성&lt;/em&gt; 과 &lt;em&gt;속성&lt;/em&gt; 의 차이 는 특정 상황에서 중요 할 수 있습니다. &lt;strong&gt;jQuery 1.6 이전&lt;/strong&gt; 에는 &lt;code&gt;&lt;a href=&quot;attr&quot;&gt;.attr()&lt;/a&gt;&lt;/code&gt; 메소드가 일부 속성을 검색 할 때 특성 값을 고려하여 일관성이없는 동작을 유발할 수 있습니다. &lt;strong&gt;jQuery 1.6&lt;/strong&gt; 부터 &lt;code&gt;.prop()&lt;/code&gt; 메소드는 속성 값을 명시 적으로 검색하는 방법을 제공하는 반면 &lt;code&gt;.attr()&lt;/code&gt; 은 속성을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="d7d00606c5e46f31f2f98e11c01c5572475bedf2" translate="yes" xml:space="preserve">
          <source>The difference in milliseconds between the time the browser created the event and January 1, 1970.</source>
          <target state="translated">브라우저가 이벤트를 작성한 시간과 1970 년 1 월 1 일의 차이 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="2ad811ab657cc27a74651a8411a156528a0df130" translate="yes" xml:space="preserve">
          <source>The drawback is that the callback is called in the context of each value and you therefore lose the context of your own object if applicable. More on this below at Functions.</source>
          <target state="translated">단점은 각 값의 컨텍스트에서 콜백이 호출되므로 해당되는 경우 자체 객체의 컨텍스트가 손실됩니다. 기능에 대한 자세한 내용은 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9037c831467c9eaa41d28fe7bf4126374f23fbbf" translate="yes" xml:space="preserve">
          <source>The effect of this on &lt;code&gt;&amp;lt;div id=&quot;foo&quot;&amp;gt;&lt;/code&gt; (when it does not initially have the &quot;entered&quot; class) is to add the &quot;entered&quot; class when the mouse enters the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; and remove the class when the mouse leaves.</source>
          <target state="translated">&lt;code&gt;&amp;lt;div id=&quot;foo&quot;&amp;gt;&lt;/code&gt; 에 대한 효과 (처음에 &quot;입력&quot;클래스가없는 경우)는 마우스가 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 들어갈 때 &quot;입력&quot;클래스를 추가하고 마우스가 떠날 때 클래스를 제거하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="abaa5fa0e138e2677c0408917eeeb5af975fe5df" translate="yes" xml:space="preserve">
          <source>The element where the currently-called jQuery event handler was attached.</source>
          <target state="translated">현재 호출 된 jQuery 이벤트 핸들러가 첨부 된 요소입니다.</target>
        </trans-unit>
        <trans-unit id="f33d88a15dc715eabf21b992b42c443d395d3276" translate="yes" xml:space="preserve">
          <source>The end parameter allows us to limit the selected range even further. For example:</source>
          <target state="translated">종료 매개 변수를 사용하면 선택한 범위를 더욱 제한 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c816a005a96322be853cb13839915a982aa35e3" translate="yes" xml:space="preserve">
          <source>The event handler &lt;em&gt;must&lt;/em&gt; be attached before the browser fires the &lt;code&gt;error&lt;/code&gt; event, which is why the example sets the &lt;code&gt;src&lt;/code&gt; attribute after attaching the handler. Also, the &lt;code&gt;error&lt;/code&gt; event may not be correctly fired when the page is served locally; &lt;code&gt;error&lt;/code&gt; relies on HTTP status codes and will generally not be triggered if the URL uses the &lt;code&gt;file:&lt;/code&gt; protocol.</source>
          <target state="translated">브라우저가 &lt;code&gt;error&lt;/code&gt; 이벤트를 발생시키기 전에 이벤트 핸들러 &lt;em&gt;를&lt;/em&gt; 첨부 &lt;em&gt;해야&lt;/em&gt; 하므로이 예제 에서는 핸들러를 첨부 한 후 &lt;code&gt;src&lt;/code&gt; 속성을 설정 합니다. 또한 페이지가 로컬로 제공 될 때 &lt;code&gt;error&lt;/code&gt; 이벤트가 올바르게 시작되지 않을 수 있습니다. &lt;code&gt;error&lt;/code&gt; 는 HTTP 상태 코드에 의존하며 URL이 &lt;code&gt;file:&lt;/code&gt; 프로토콜을 사용하는 경우 일반적으로 트리거되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6592b71414facc03b08e92d3c61ae4a7c6e48089" translate="yes" xml:space="preserve">
          <source>The event handler and its environment</source>
          <target state="translated">이벤트 핸들러와 그 환경</target>
        </trans-unit>
        <trans-unit id="c3eaa89182d66deb143ff4b5e21401f0e6abded1" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to any &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이벤트 핸들러는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 바인딩 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="c3c8521075173da7ee615c1ec3531d4b5d09418a" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to any element:</source>
          <target state="translated">이벤트 핸들러는 모든 요소에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c77560ec7292139b9e6f566baee76ddf960569a" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; as follows:</source>
          <target state="translated">이벤트 핸들러는 다음과 같이 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 바인딩 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7b2e5765f810648c6904605842ced0e04a09f0e3" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the first input field:</source>
          <target state="translated">이벤트 핸들러는 첫 번째 입력 필드에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="541d65895736107ef3f16d5231f478c377077d12" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the form:</source>
          <target state="translated">이벤트 핸들러는 다음 형식으로 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1b2f9b415c772375ce1094bf5af80a249e679b0" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the image:</source>
          <target state="translated">이벤트 핸들러는 이미지에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59db2f3ed37d22060fab94786bd9bfe98aa672b8" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the input field:</source>
          <target state="translated">이벤트 핸들러는 입력 필드에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c302c60ef5ad634affc166ae8ba6a179c97813a" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the target:</source>
          <target state="translated">이벤트 핸들러는 대상에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7089e39a05558f599138c92d69408f4e931882a9" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the text input and the select box:</source>
          <target state="translated">이벤트 핸들러는 텍스트 입력 및 선택 상자에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53ceb3bdf027007c75defc080e05b2850e2e15f7" translate="yes" xml:space="preserve">
          <source>The event handler can be bound to the text input:</source>
          <target state="translated">이벤트 핸들러는 텍스트 입력에 바인딩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a968461088fc48b890360da98e8a2917f0c0ec22" translate="yes" xml:space="preserve">
          <source>The event object is always passed as the first parameter to an event handler. An array of arguments can also be passed to the .trigger() call, and these parameters will be passed along to the handler as well following the event object. As of jQuery 1.6.2, single string or numeric argument can be passed without being wrapped in an array.</source>
          <target state="translated">이벤트 객체는 항상 첫 번째 매개 변수로 이벤트 처리기에 전달됩니다. 인수 배열을 .trigger () 호출로 전달할 수도 있으며 이러한 매개 변수는 이벤트 오브젝트 다음에 핸들러로 전달됩니다. jQuery 1.6.2부터는 단일 문자열 또는 숫자 인수를 배열로 래핑하지 않고 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d04cbf7c5545cd035665c33569633ce74b31c81a" translate="yes" xml:space="preserve">
          <source>The event object is often unnecessary and the parameter omitted, as sufficient context is usually available when the handler is bound to know exactly what needs to be done when the handler is triggered. However, at times it becomes necessary to gather more information about the user's environment at the time the event was initiated. &lt;a href=&quot;category/events/event-object&quot;&gt;View the full Event Object&lt;/a&gt;.</source>
          <target state="translated">핸들러가 트리거 될 때 수행해야 할 작업을 정확하게 알기 위해 핸들러가 바인드 될 때 일반적으로 충분한 컨텍스트가 사용 가능하므로 이벤트 오브젝트는 종종 불필요하고 매개 변수가 생략됩니다. 그러나 때때로 이벤트가 시작될 때 사용자 환경에 대한 추가 정보를 수집해야합니다. &lt;a href=&quot;category/events/event-object&quot;&gt;전체 이벤트 오브젝트를보십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7a5610a350c3ccf39411d452e988cd760b00e727" translate="yes" xml:space="preserve">
          <source>The exact handling of the &lt;code&gt;unload&lt;/code&gt; event has varied from version to version of browsers. For example, some versions of Firefox trigger the event when a link is followed, but not when the window is closed. In practical usage, behavior should be tested on all supported browsers and contrasted with the similar &lt;code&gt;beforeunload&lt;/code&gt; event.</source>
          <target state="translated">&lt;code&gt;unload&lt;/code&gt; 이벤트 의 정확한 처리 는 브라우저 버전에 따라 다릅니다. 예를 들어, 일부 Firefox 버전은 링크를 따를 때 이벤트를 트리거하지만 창을 닫을 때는 이벤트를 트리거하지 않습니다. 실제로 사용하는 경우 지원되는 모든 브라우저에서 동작을 테스트하고 비슷한 &lt;code&gt;beforeunload&lt;/code&gt; 이벤트 와 대조해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a47720c0de238c3c29d705238cb0f84e408d6262" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;$( &quot;div:has(p)&quot; )&lt;/code&gt; matches a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; if a &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; exists anywhere among its descendants, not just as a direct child.</source>
          <target state="translated">표현식 &lt;code&gt;$( &quot;div:has(p)&quot; )&lt;/code&gt; 와 일치하는 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 경우 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 그 자손 중 아무 곳이나 존재 만이 아니라 직접 아이로.</target>
        </trans-unit>
        <trans-unit id="fdec95bd57664e6187875684bcae2f43b3499034" translate="yes" xml:space="preserve">
          <source>The filter function will be passed two arguments: the current array item and its index. The filter function must return 'true' to include the item in the result array.</source>
          <target state="translated">필터 함수에는 현재 배열 항목과 해당 인덱스의 두 가지 인수가 전달됩니다. 결과 배열에 항목을 포함 시키려면 필터 함수가 'true'를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a8c78269da9a7a144139698b6264cc95a56365a" translate="yes" xml:space="preserve">
          <source>The first array-like object to merge, the elements of second added.</source>
          <target state="translated">병합 할 첫 번째 배열과 유사한 개체로, 두 번째 요소가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="bca6f939db67fb58379c0c2238b53604a16dbd93" translate="yes" xml:space="preserve">
          <source>The first button shows how an unqueued animation works. It expands the div out to 90% width &lt;strong&gt;while&lt;/strong&gt; the font-size is increasing. Once the font-size change is complete, the border animation will begin. The second button starts a traditional chained animation, where each animation will start once the previous animation on the element has completed.</source>
          <target state="translated">첫 번째 버튼은 큐에 넣지 않은 애니메이션의 작동 방식을 보여줍니다. 글꼴 크기가 증가 &lt;strong&gt;하는 동안&lt;/strong&gt; div를 90 % 너비로 확장합니다 . 글꼴 크기 변경이 완료되면 테두리 애니메이션이 시작됩니다. 두 번째 버튼은 전통적인 체인 애니메이션을 시작하는데, 여기서 각 애니메이션은 요소의 이전 애니메이션이 완료되면 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="cfe3394cf354aa01c5c119c6f9df4de1d6557809" translate="yes" xml:space="preserve">
          <source>The first letter in Ajax stands for &quot;asynchronous,&quot; meaning that the operation occurs in parallel and the order of completion is not guaranteed. The &lt;code&gt;async&lt;/code&gt; option to &lt;code&gt;$.ajax()&lt;/code&gt; defaults to &lt;code&gt;true&lt;/code&gt;, indicating that code execution can continue after the request is made. Setting this option to &lt;code&gt;false&lt;/code&gt; (and thus making the call no longer asynchronous) is strongly discouraged, as it can cause the browser to become unresponsive.</source>
          <target state="translated">Ajax의 첫 글자는 &quot;비동기&quot;를 나타내며, 이는 작업이 병렬로 수행되고 완료 순서가 보장되지 않음을 의미합니다. &lt;code&gt;$.ajax()&lt;/code&gt; 의 &lt;code&gt;async&lt;/code&gt; 옵션의 기본값은 &lt;code&gt;true&lt;/code&gt; 이며, 요청 후에도 코드 실행을 계속할 수 있음을 나타냅니다. 이 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 (따라서 더 이상 비 동기화하지 않음) 브라우저가 응답하지 않을 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dd4ad641c60ce993a319482b87b6fff7be020a1" translate="yes" xml:space="preserve">
          <source>The first signature for the &lt;code&gt;.find()&lt;/code&gt;method accepts a selector expression of the same type that we can pass to the &lt;code&gt;$()&lt;/code&gt; function. The elements will be filtered by testing whether they match this selector. The expressions allowed include selectors like &lt;code&gt;&amp;gt; p&lt;/code&gt; which will find all the paragraphs that are children of the elements in the jQuery object.</source>
          <target state="translated">&lt;code&gt;.find()&lt;/code&gt; 메소드 의 첫 번째 서명 은 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수있는 것과 동일한 유형의 선택기 표현식을 승인 합니다. 요소가이 선택기와 일치하는지 테스트하여 요소를 필터링합니다. 허용되는 표현식에는 &lt;code&gt;&amp;gt; p&lt;/code&gt; 와 같은 선택기가 포함 되며 jQuery 객체의 요소 하위 인 모든 단락을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="dab134d4e8bf507a0b852b877e39959ba46fce14" translate="yes" xml:space="preserve">
          <source>The first signature for the &lt;code&gt;.find()&lt;/code&gt;method accepts a selector expression of the same type that we can pass to the &lt;code&gt;$()&lt;/code&gt; function. The elements will be filtered by testing whether they match this selector; all parts of the selector must lie inside of an element on which .find() is called. The expressions allowed include selectors like &lt;code&gt;&amp;gt; p&lt;/code&gt; which will find all the paragraphs that are children of the elements in the jQuery object.</source>
          <target state="translated">&lt;code&gt;.find()&lt;/code&gt; 메서드 의 첫 번째 서명 은 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수있는 동일한 유형의 선택기 표현식을받습니다 . 요소는이 선택기와 일치하는지 테스트하여 필터링됩니다. 선택기의 모든 부분은 .find ()가 호출되는 요소 내부에 있어야합니다. 허용되는 표현식에는 &lt;code&gt;&amp;gt; p&lt;/code&gt; 와 같은 선택기가 포함 되어 jQuery 객체에서 요소의 하위 인 모든 단락을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="5fd5cdf1aaec5d99e649d109e9218e1768db80d9" translate="yes" xml:space="preserve">
          <source>The first time we apply &lt;code&gt;$( &quot;div.tumble&quot; ).toggleClass( &quot;bounce&quot; )&lt;/code&gt;, we get the following:</source>
          <target state="translated">&lt;code&gt;$( &quot;div.tumble&quot; ).toggleClass( &quot;bounce&quot; )&lt;/code&gt; 처음 적용 하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="021404d539fa30f7bd9a809d18e784457069d717" translate="yes" xml:space="preserve">
          <source>The following are two sample methods named &lt;code&gt;fn1&lt;/code&gt; and &lt;code&gt;fn2&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;fn1&lt;/code&gt; 및 &lt;code&gt;fn2&lt;/code&gt; 라는 두 가지 샘플 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="f64f18608a238a1192c88dfa8a8f137c9d294636" translate="yes" xml:space="preserve">
          <source>The following comparisons are all true:</source>
          <target state="translated">다음 비교는 모두 사실입니다.</target>
        </trans-unit>
        <trans-unit id="bc071c8397609381bbd9504310c1ba41353890a3" translate="yes" xml:space="preserve">
          <source>The following example shows how a minimal image transport could be implemented:</source>
          <target state="translated">다음 예제는 최소 이미지 전송이 구현되는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="abb3689a802e901601920b2b12ca783b0318c8c6" translate="yes" xml:space="preserve">
          <source>The following properties are also copied to the event object, though some of their values may be undefined depending on the event:</source>
          <target state="translated">다음 속성도 이벤트 객체에 복사되지만 일부 값은 이벤트에 따라 정의되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dec858fec45670eb0dcd1906c0e4f2fc17caf072" translate="yes" xml:space="preserve">
          <source>The following selectors are based on the Cascading Style Sheet 1 specification, as outlined by the W3C. For more information about the specifications, visit &lt;a href=&quot;https://www.w3.org/Style/CSS/#specs&quot;&gt;https://www.w3.org/Style/CSS/#specs&lt;/a&gt;.</source>
          <target state="translated">다음 선택기는 W3C에 요약 된 Cascading Style Sheet 1 사양을 기반으로합니다. 사양에 대한 자세한 내용은 &lt;a href=&quot;https://www.w3.org/Style/CSS/#specs&quot;&gt;https://www.w3.org/Style/CSS/#specs를&lt;/a&gt; 방문 하십시오 .</target>
        </trans-unit>
        <trans-unit id="efc8ca2023c763ab424e309905ae785bfc9fcdc1" translate="yes" xml:space="preserve">
          <source>The following will &lt;em&gt;not&lt;/em&gt; save the added elements, because the &lt;code&gt;.add()&lt;/code&gt; method creates a new set and leaves the original set in pdiv unchanged:</source>
          <target state="translated">다음은 추가 된 요소를 저장 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;.add()&lt;/code&gt; 메소드는 새 세트를 작성하고 원래 세트를 pdiv에 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="6f51f371b8da8dc1313314e38b6c779c426e42e6" translate="yes" xml:space="preserve">
          <source>The function can return:</source>
          <target state="translated">이 함수는 다음을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e37153bc1a8e1ad3a9f12be343e9728f9a20217" translate="yes" xml:space="preserve">
          <source>The function that is no longer to be executed.</source>
          <target state="translated">더 이상 실행되지 않는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="c0e0e646f0de4166549307945db05657dc0f40f2" translate="yes" xml:space="preserve">
          <source>The function that is to be no longer executed.</source>
          <target state="translated">더 이상 실행되지 않는 기능입니다.</target>
        </trans-unit>
        <trans-unit id="7180b46bfb05a111cd04bc1cb12e5540f1eb2375" translate="yes" xml:space="preserve">
          <source>The function that will be executed on every value.</source>
          <target state="translated">모든 값에서 실행될 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d3de917bcd36c99d1259f320a3f7d5ffbc730acf" translate="yes" xml:space="preserve">
          <source>The function to be invoked.</source>
          <target state="translated">호출 할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7f804edca989e0ac4a94b9c06aefacd24370d29f" translate="yes" xml:space="preserve">
          <source>The function to execute when the DOM is ready.</source>
          <target state="translated">DOM이 준비되었을 때 실행할 함수입니다.</target>
        </trans-unit>
        <trans-unit id="528266b758f50455c24b724fbb39bccc1e8838e7" translate="yes" xml:space="preserve">
          <source>The function to process each item against. The first argument to the function is the array item, the second argument is the index in array The function can return any value. A returned array will be flattened into the resulting array. Within the function, &lt;code&gt;this&lt;/code&gt; refers to the global (window) object.</source>
          <target state="translated">각 항목을 처리하는 기능입니다. 함수의 첫 번째 인수는 배열 항목이고 두 번째 인수는 배열의 인덱스입니다. 함수는 모든 값을 반환 할 수 있습니다. 반환 된 배열은 결과 배열로 병합됩니다. 함수 내에서 &lt;code&gt;this&lt;/code&gt; 글로벌 (창) 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="2497be69d4d28d0015898947249c2dfe61e4276d" translate="yes" xml:space="preserve">
          <source>The function to process each item against. The first argument to the function is the item, and the second argument is the index. The function should return a Boolean value. &lt;code&gt;this&lt;/code&gt; will be the global window object.</source>
          <target state="translated">각 항목을 처리하는 기능입니다. 함수의 첫 번째 인수는 항목이고 두 번째 인수는 색인입니다. 이 함수는 부울 값을 반환해야합니다. &lt;code&gt;this&lt;/code&gt; 전역 창 개체가됩니다.</target>
        </trans-unit>
        <trans-unit id="ed78ed460dba43418960b9867533924d5b82946f" translate="yes" xml:space="preserve">
          <source>The function to process each item against. The first argument to the function is the value; the second argument is the key of the object property. The function can return any value to add to the array. A returned array will be flattened into the resulting array. Within the function, &lt;code&gt;this&lt;/code&gt; refers to the global (window) object.</source>
          <target state="translated">각 항목을 처리하는 기능입니다. 함수의 첫 번째 인수는 값입니다. 두 번째 인수는 객체 속성의 키입니다. 이 함수는 배열에 추가 할 값을 반환 할 수 있습니다. 반환 된 배열은 결과 배열로 병합됩니다. 함수 내에서 &lt;code&gt;this&lt;/code&gt; 글로벌 (창) 객체를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0c7f01ed75b8f184641d80cb2808bde2c28779d5" translate="yes" xml:space="preserve">
          <source>The function whose context will be changed.</source>
          <target state="translated">컨텍스트가 변경되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="44671f971a36a5853ba3aa8c82cb9c2627ced934" translate="yes" xml:space="preserve">
          <source>The general idea behind pub/sub (Publish/Subscribe, or, the Observer pattern) is the promotion of loose coupling in applications. Rather than single objects calling on the methods of other objects, an object instead subscribes to a specific task or activity of another object and is notified when it occurs. Observers are also called Subscribers, and we refer to the object being observed as the Publisher (or the subject). Publishers notify subscribers when events occur.</source>
          <target state="translated">pub / sub (Publish / Subscribe 또는 Observer 패턴)의 기본 개념은 응용 프로그램에서 느슨한 커플 링을 촉진하는 것입니다. 객체는 다른 객체의 메소드를 호출하는 단일 객체가 아니라 다른 객체의 특정 작업 또는 활동에 가입하고 해당 객체가 발생할 때 알림을받습니다. 관찰자는 구독자라고도하며, 관찰자 ​​(또는 주제)로 관찰되는 개체를 말합니다. 이벤트 발생시 게시자는 가입자에게 알립니다.</target>
        </trans-unit>
        <trans-unit id="96908f5f2e8c272b018f7fc547920ba259a9f935" translate="yes" xml:space="preserve">
          <source>The handler in this case must take a parameter, so that we can capture the event object and use it to unbind the handler after the third click. The event object contains the context necessary for &lt;code&gt;.unbind()&lt;/code&gt; to know which handler to remove. This example is also an illustration of a closure. Since the handler refers to the &lt;code&gt;timesClicked&lt;/code&gt; variable, which is defined outside the function, incrementing the variable has an effect even between invocations of the handler.</source>
          <target state="translated">이 경우 핸들러는 매개 변수를 가져와야 이벤트 오브젝트를 캡처하고이를 사용하여 세 번째 클릭 후 핸들러를 바인드 해제 할 수 있습니다. 이벤트 객체에는 &lt;code&gt;.unbind()&lt;/code&gt; 가 제거 할 핸들러를 파악하는 데 필요한 컨텍스트가 포함되어 있습니다 . 이 예제는 또한 클로저를 보여줍니다. 핸들러는 함수 외부에 정의 된 &lt;code&gt;timesClicked&lt;/code&gt; 변수를 참조 하므로 변수를 증가 시키면 핸들러 호출 사이에도 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="9a017672927edcddb38cf218fbb12b8313df4cc6" translate="yes" xml:space="preserve">
          <source>The handler list for an element is set when the event is first delivered. Adding or removing event handlers on the current element won't take effect until the next time the event is handled. To prevent any further event handlers from executing on an element within an event handler, call &lt;code&gt;event.stopImmediatePropagation()&lt;/code&gt;. This behavior goes against the &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-removeEventListener&quot;&gt;W3C events specification&lt;/a&gt;. To better understand this case, consider the following code:</source>
          <target state="translated">요소의 핸들러 목록은 이벤트가 처음 전달 될 때 설정됩니다. 현재 요소에서 이벤트 처리기를 추가하거나 제거하면 다음에 이벤트가 처리 될 때까지 적용되지 않습니다. 추가 이벤트 핸들러가 이벤트 핸들러 내의 요소에서 실행되지 않도록하려면 &lt;code&gt;event.stopImmediatePropagation()&lt;/code&gt; 호출 하십시오 . 이 동작은 &lt;a href=&quot;https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget-removeEventListener&quot;&gt;W3C 이벤트 사양&lt;/a&gt; 에 위배 됩니다. 이 경우를 더 잘 이해하려면 다음 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="068354fa5d5791c1d48dccb2e852071a0eec58aa" translate="yes" xml:space="preserve">
          <source>The horizontal scroll position is the same as the number of pixels that are hidden from view above the scrollable area. Setting the &lt;code&gt;scrollLeft&lt;/code&gt; positions the horizontal scroll of each matched element.</source>
          <target state="translated">가로 스크롤 위치는 스크롤 가능 영역 위의보기에서 숨겨지는 픽셀 수와 동일합니다. &lt;code&gt;scrollLeft&lt;/code&gt; 를 설정하면 일치하는 각 요소의 가로 스크롤이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="5ef722341357678071415deb8d758a8d628e8e77" translate="yes" xml:space="preserve">
          <source>The horizontal scroll position is the same as the number of pixels that are hidden from view to the left of the scrollable area. If the scroll bar is at the very left, or if the element is not scrollable, this number will be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">가로 스크롤 위치는 스크롤 가능 영역의보기에서 왼쪽으로 숨겨지는 픽셀 수와 같습니다. 스크롤 막대가 맨 왼쪽에 있거나 요소를 스크롤 할 수없는 경우이 숫자는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f18c308cc9003dd517b04c883ca4c11f2901568f" translate="yes" xml:space="preserve">
          <source>The index of the array at which to begin the search. The default is 0, which will search the whole array.</source>
          <target state="translated">검색을 시작할 배열의 인덱스입니다. 기본값은 0이며 전체 배열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="84fbf232995bee433ace36fdc322edb615edc6af" translate="yes" xml:space="preserve">
          <source>The index-related selector expressions (including this &quot;greater than&quot; selector) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (&lt;code&gt;.myclass&lt;/code&gt;) and four elements are returned, these elements are given indices 0 through 3 for the purposes of these selectors.</source>
          <target state="translated">인덱스 관련 선택기 표현식 (이 &quot;보다 큼&quot;선택기 포함)은 앞에 오는 표현식과 일치하는 요소 세트를 필터링합니다. 일치하는 세트 내의 요소 순서에 따라 세트를 좁 힙니다. 예를 들어, 클래스 선택기 ( &lt;code&gt;.myclass&lt;/code&gt; )를 사용하여 요소를 먼저 선택 하고 4 개의 요소가 리턴되면 이러한 선택기의 목적으로 이러한 요소에 0-3의 색인이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce2345a99b016ade0050c9c9e058771ff484eb6" translate="yes" xml:space="preserve">
          <source>The index-related selectors (&lt;code&gt;:eq()&lt;/code&gt;, &lt;code&gt;:lt()&lt;/code&gt;, &lt;code&gt;:gt()&lt;/code&gt;, &lt;code&gt;:even&lt;/code&gt;, &lt;code&gt;:odd&lt;/code&gt;) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (&lt;code&gt;.myclass&lt;/code&gt;) and four elements are returned, these elements are given indices &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;3&lt;/code&gt; for the purposes of these selectors.</source>
          <target state="translated">인덱스 관련 선택기 ( &lt;code&gt;:eq()&lt;/code&gt; , &lt;code&gt;:lt()&lt;/code&gt; , &lt;code&gt;:gt()&lt;/code&gt; , &lt;code&gt;:even&lt;/code&gt; , &lt;code&gt;:odd&lt;/code&gt; )는 앞에 오는 표현식과 일치하는 요소 세트를 필터링합니다. 일치하는 세트 내의 요소 순서에 따라 세트를 좁 힙니다. 요소는 제 (클래스 셀렉터로 선택하는 경우, 예를 들어, &lt;code&gt;.myclass&lt;/code&gt; )과 네 개의 요소가 리턴되며, 이러한 요소 인덱스를 부여 &lt;code&gt;0&lt;/code&gt; 을 통해 &lt;code&gt;3&lt;/code&gt; 이 선택기의 용도.</target>
        </trans-unit>
        <trans-unit id="ba134bef640122a89e8d25ae63500999badb7aed" translate="yes" xml:space="preserve">
          <source>The index-related selectors (including this &quot;less than&quot; selector) filter the set of elements that have matched the expressions that precede them. They narrow the set down based on the order of the elements within this matched set. For example, if elements are first selected with a class selector (&lt;code&gt;.myclass&lt;/code&gt;) and four elements are returned, these elements are given indices 0 through 3 for the purposes of these selectors.</source>
          <target state="translated">색인 관련 선택기 (이 &quot;보다 작음&quot;선택기 포함)는 앞에 오는 표현식과 일치하는 요소 세트를 필터링합니다. 일치하는 세트 내의 요소 순서에 따라 세트를 좁 힙니다. 예를 들어, 클래스 선택기 ( &lt;code&gt;.myclass&lt;/code&gt; )를 사용하여 요소를 먼저 선택 하고 4 개의 요소가 리턴되면 이러한 선택기의 목적으로 이러한 요소에 0-3의 색인이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="4e288c80fa39dc156186e654513b5fc57fb3fddd" translate="yes" xml:space="preserve">
          <source>The jQuery &lt;code&gt;.slice()&lt;/code&gt; method is patterned after the JavaScript .slice() method for arrays. One of the features that it mimics is the ability for negative numbers to be passed as either the &lt;code&gt;start&lt;/code&gt; or &lt;code&gt;end&lt;/code&gt; parameter. If a negative number is provided, this indicates a position starting from the end of the set, rather than the beginning. For example:</source>
          <target state="translated">jQuery &lt;code&gt;.slice()&lt;/code&gt; 메소드는 배열에 대한 JavaScript .slice () 메소드 이후에 패턴 화됩니다. 모방하는 기능 중 하나는 음수를 &lt;code&gt;start&lt;/code&gt; 또는 &lt;code&gt;end&lt;/code&gt; 매개 변수 로 전달하는 기능입니다 . 음수가 제공되면 시작이 아니라 세트의 끝에서 시작하는 위치를 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="514aa5055f00f797e80751f12544ed3ca726fe25" translate="yes" xml:space="preserve">
          <source>The jQuery Ajax implementation comes with a set of standard dataTypes, such as text, json, xml, and html.</source>
          <target state="translated">jQuery Ajax 구현에는 text, json, xml 및 html과 같은 표준 dataType 세트가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6808edbc627612119a19ef098b25e718fe0d28c4" translate="yes" xml:space="preserve">
          <source>The jQuery XMLHttpRequest (jqXHR) object returned by &lt;code&gt;$.ajax()&lt;/code&gt;&lt;strong&gt;as of jQuery 1.5&lt;/strong&gt; is a superset of the browser's native XMLHttpRequest object. For example, it contains &lt;code&gt;responseText&lt;/code&gt; and &lt;code&gt;responseXML&lt;/code&gt; properties, as well as a &lt;code&gt;getResponseHeader()&lt;/code&gt; method. When the transport mechanism is something other than XMLHttpRequest (for example, a script tag for a JSONP request) the &lt;code&gt;jqXHR&lt;/code&gt; object simulates native XHR functionality where possible.</source>
          <target state="translated">&lt;strong&gt;jQuery 1.5부터 &lt;/strong&gt; &lt;code&gt;$.ajax()&lt;/code&gt; 의해 반환 된 jQuery XMLHttpRequest (jqXHR) 객체 는 브라우저의 기본 XMLHttpRequest 객체의 상위 집합입니다. 예를 들어, &lt;code&gt;getResponseHeader()&lt;/code&gt; 메소드 뿐만 아니라 &lt;code&gt;responseText&lt;/code&gt; 및 &lt;code&gt;responseXML&lt;/code&gt; 특성도 포함 합니다. 전송 메커니즘이 XMLHttpRequest 이외의 것 (예 : JSONP 요청의 스크립트 태그) 인 경우 &lt;code&gt;jqXHR&lt;/code&gt; 객체는 가능한 경우 기본 XHR 기능을 시뮬레이션합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6329bb11d7dcdb2e64db5216d41be8f97344e159" translate="yes" xml:space="preserve">
          <source>The jQuery library has a full suite of Ajax capabilities. The functions and methods therein allow us to load data from the server without a browser page refresh.</source>
          <target state="translated">jQuery 라이브러리에는 완전한 Ajax 기능이 있습니다. 그 기능과 방법을 사용하면 브라우저 페이지를 새로 고치지 않고도 서버에서 데이터를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2bf20b00460b915cf997aa1998852c28ee31339" translate="yes" xml:space="preserve">
          <source>The jQuery library provides several techniques for adding animation to a web page. These include simple, standard animations that are frequently used, and the ability to craft sophisticated custom effects.</source>
          <target state="translated">jQuery 라이브러리는 웹 페이지에 애니메이션을 추가하는 몇 가지 기술을 제공합니다. 여기에는 자주 사용되는 간단한 표준 애니메이션과 정교한 사용자 정의 효과를 만들 수있는 기능이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b10ed5864ed562309d6eb5544f97085abf741a3c" translate="yes" xml:space="preserve">
          <source>The jQuery object itself behaves much like an array; it has a &lt;code&gt;length&lt;/code&gt; property and the elements in the object can be accessed by their numeric indices &lt;code&gt;[0]&lt;/code&gt; to &lt;code&gt;[length-1]&lt;/code&gt;. Note that a jQuery object is not actually a Javascript Array object, so it does not have all the methods of a true Array object such as &lt;code&gt;join()&lt;/code&gt;.</source>
          <target state="translated">jQuery 객체 자체는 배열과 매우 유사합니다. 그것은 갖는 &lt;code&gt;length&lt;/code&gt; 속성 및 객체의 요소들은 수치 색인에 의해 액세스 될 수 &lt;code&gt;[0]&lt;/code&gt; 에 대한 &lt;code&gt;[length-1]&lt;/code&gt; . jQuery 객체는 실제로 Javascript Array 객체가 아니므로 &lt;code&gt;join()&lt;/code&gt; 과 같은 실제 Array 객체의 모든 메소드를 갖지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="9adc43edd25fe471ec1647fe8c39dc7a5af1b244" translate="yes" xml:space="preserve">
          <source>The jqXHR Object</source>
          <target state="translated">jqXHR 객체</target>
        </trans-unit>
        <trans-unit id="31de3d3efc0743154a00d75c22c5127d0f3e1c79" translate="yes" xml:space="preserve">
          <source>The jqXHR objects returned by &lt;code&gt;$.ajax()&lt;/code&gt; as of jQuery 1.5 implement the Promise interface, giving them all the properties, methods, and behavior of a Promise (see &lt;a href=&quot;category/deferred-object&quot;&gt;Deferred object&lt;/a&gt; for more information). These methods take one or more function arguments that are called when the &lt;code&gt;$.ajax()&lt;/code&gt; request terminates. This allows you to assign multiple callbacks on a single request, and even to assign callbacks after the request may have completed. (If the request is already complete, the callback is fired immediately.) Available Promise methods of the jqXHR object include:</source>
          <target state="translated">jQuery 1.5부터 &lt;code&gt;$.ajax()&lt;/code&gt; 의해 반환 된 jqXHR 객체 는 Promise 인터페이스를 구현하여 Promise의 모든 속성, 메소드 및 동작을 제공합니다 ( 자세한 내용 은 &lt;a href=&quot;category/deferred-object&quot;&gt;지연된 객체&lt;/a&gt; 참조 ). 이 메소드는 &lt;code&gt;$.ajax()&lt;/code&gt; 요청이 종료 될 때 호출되는 하나 이상의 함수 인수를 사용 합니다. 이를 통해 단일 요청에서 여러 개의 콜백을 할당 할 수 있으며 요청이 완료된 후 콜백을 할당 할 수도 있습니다. 요청이 이미 완료된 경우 콜백이 즉시 시작됩니다. jqXHR 객체의 사용 가능한 Promise 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e9a9d8acdf4a10af6785836e5bd16312f63736d6" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;jQuery.cssNumber&lt;/code&gt; object are camel-cased and the values are all set to &lt;code&gt;true&lt;/code&gt;. If you want to prevent the &lt;a href=&quot;css&quot;&gt;&lt;code&gt;.css()&lt;/code&gt;&lt;/a&gt; method from automatically adding the &lt;code&gt;px&lt;/code&gt; unit for a specific CSS property, you can add an extra property to the &lt;code&gt;jQuery.cssNumber&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;jQuery.cssNumber&lt;/code&gt; 객체 의 키 는 낙타로 표시되며 값은 모두 &lt;code&gt;true&lt;/code&gt; 로 설정됩니다 . &lt;a href=&quot;css&quot;&gt; &lt;code&gt;.css()&lt;/code&gt; &lt;/a&gt; 메소드 가 특정 CSS 특성에 대해 &lt;code&gt;px&lt;/code&gt; 단위를 자동으로 추가 하지 못하게 하려면 &lt;code&gt;jQuery.cssNumber&lt;/code&gt; 오브젝트에 추가 특성을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9c8a74ca684f546365d11151b876bb5ef5d248e1" translate="yes" xml:space="preserve">
          <source>The last &lt;code&gt;end()&lt;/code&gt; is unnecessary, as we are discarding the jQuery object immediately thereafter. However, when the code is written in this form, the &lt;code&gt;end()&lt;/code&gt; provides visual symmetry and a sense of completion &amp;mdash;making the program, at least to the eyes of some developers, more readable, at the cost of a slight hit to performance as it is an additional function call.</source>
          <target state="translated">jQuery 객체를 즉시 버리고 있으므로 마지막 &lt;code&gt;end()&lt;/code&gt; 는 불필요합니다. 그러나 코드가이 형식으로 작성되면 &lt;code&gt;end()&lt;/code&gt; 는 시각적 대칭성과 완성도를 제공합니다. 최소한 일부 개발자의 눈에는 프로그램을 약간만 읽어도 성능이 약간 떨어집니다. 추가 함수 호출입니다.</target>
        </trans-unit>
        <trans-unit id="7efe7e2c92ffe13a861e60a5a71908950a6e6f96" translate="yes" xml:space="preserve">
          <source>The last value returned by an event handler that was triggered by this event, unless the value was undefined.</source>
          <target state="translated">값이 정의되지 않은 경우이 이벤트에 의해 트리거 된 이벤트 핸들러가 리턴 한 마지막 값.</target>
        </trans-unit>
        <trans-unit id="57b0302cdc98e914c921d10ae80c2282a00fe827" translate="yes" xml:space="preserve">
          <source>The length property can also be used to add elements to the end of an array. That is equivalent to using the push-method:</source>
          <target state="translated">length 속성을 사용하여 배열 끝에 요소를 추가 할 수도 있습니다. 이는 푸시 방법을 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="076292172fb49811fbaacb886eb7c1bb1c8ecc8a" translate="yes" xml:space="preserve">
          <source>The majority of browser events &lt;em&gt;bubble&lt;/em&gt;, or &lt;em&gt;propagate&lt;/em&gt;, from the deepest, innermost element (the &lt;strong&gt;event target&lt;/strong&gt;) in the document where they occur all the way up to the body and the &lt;code&gt;document&lt;/code&gt; element. In Internet Explorer 8 and lower, a few events such as &lt;code&gt;change&lt;/code&gt; and &lt;code&gt;submit&lt;/code&gt; do not natively bubble but jQuery patches these to bubble and create consistent cross-browser behavior.</source>
          <target state="translated">대부분의 브라우저 이벤트 는 문서 의 가장 깊은 가장 안쪽 요소 ( &lt;strong&gt;이벤트 대상&lt;/strong&gt; )에서 본문 및 &lt;code&gt;document&lt;/code&gt; 요소 까지 발생하는 &lt;em&gt;버블&lt;/em&gt; 또는 &lt;em&gt;전파&lt;/em&gt; 됩니다. Internet Explorer 8 이하에서는 &lt;code&gt;change&lt;/code&gt; 및 &lt;code&gt;submit&lt;/code&gt; 과 같은 몇 가지 이벤트 가 기본적으로 버블 링되지 않지만 jQuery는 버블 링하여 일관된 크로스 브라우저 동작을 생성하도록 패치합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0824e824d0098d6239873a84448d410eecdf43c6" translate="yes" xml:space="preserve">
          <source>The matched elements will be hidden immediately, with no animation. This is roughly equivalent to calling &lt;code&gt;.css( &quot;display&quot;, &quot;none&quot; )&lt;/code&gt;, except that the value of the &lt;code&gt;display&lt;/code&gt; property is saved in jQuery's data cache so that &lt;code&gt;display&lt;/code&gt; can later be restored to its initial value. If an element has a &lt;code&gt;display&lt;/code&gt; value of &lt;code&gt;inline&lt;/code&gt; and is hidden then shown, it will once again be displayed &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">일치하는 요소는 애니메이션없이 즉시 숨겨집니다. 이는 &lt;code&gt;display&lt;/code&gt; 속성 값이 jQuery의 데이터 캐시에 저장되어 나중에 &lt;code&gt;display&lt;/code&gt; 를 초기 값으로 복원 할 수 있다는 점을 제외하고 &lt;code&gt;.css( &quot;display&quot;, &quot;none&quot; )&lt;/code&gt; 호출과 거의 같습니다 . 요소에 &lt;code&gt;display&lt;/code&gt; 값이 &lt;code&gt;inline&lt;/code&gt; 이고 숨겨져 표시되면 다시 한 번 &lt;code&gt;inline&lt;/code&gt; 으로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="46f4fb72769ec86f58468699c9160d1615df38e7" translate="yes" xml:space="preserve">
          <source>The matched elements will be revealed immediately, with no animation. This is roughly equivalent to calling &lt;code&gt;.css( &quot;display&quot;, &quot;block&quot; )&lt;/code&gt;, except that the &lt;code&gt;display&lt;/code&gt; property is restored to whatever it was initially. If an element has a &lt;code&gt;display&lt;/code&gt; value of &lt;code&gt;inline&lt;/code&gt;, then is hidden and shown, it will once again be displayed &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">일치하는 요소는 애니메이션없이 즉시 표시됩니다. 이는 &lt;code&gt;display&lt;/code&gt; 속성이 처음에 복원 된 것을 제외하고는 &lt;code&gt;.css( &quot;display&quot;, &quot;block&quot; )&lt;/code&gt; 호출과 거의 같습니다 . 요소의 &lt;code&gt;display&lt;/code&gt; 값이 &lt;code&gt;inline&lt;/code&gt; 이면 숨겨져 표시되고 다시 한 번 &lt;code&gt;inline&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="3db2c262258f59451cfcd14f30a965494fdb7a8c" translate="yes" xml:space="preserve">
          <source>The matched elements will be revealed or hidden immediately, with no animation, by changing the CSS &lt;code&gt;display&lt;/code&gt; property. If the element is initially displayed, it will be hidden; if hidden, it will be shown. The &lt;code&gt;display&lt;/code&gt; property is saved and restored as needed. If an element has a &lt;code&gt;display&lt;/code&gt; value of &lt;code&gt;inline&lt;/code&gt;, then is hidden and shown, it will once again be displayed &lt;code&gt;inline&lt;/code&gt;.</source>
          <target state="translated">CSS &lt;code&gt;display&lt;/code&gt; 속성 을 변경하면 일치하는 요소가 애니메이션없이 즉시 표시되거나 숨겨집니다 . 요소가 처음에 표시되면 숨겨집니다. 숨겨져 있으면 표시됩니다. &lt;code&gt;display&lt;/code&gt; 속성을 저장하고 필요에 따라 복원됩니다. 요소의 &lt;code&gt;display&lt;/code&gt; 값이 &lt;code&gt;inline&lt;/code&gt; 이면 숨겨져 표시되고 다시 한 번 &lt;code&gt;inline&lt;/code&gt; 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="9c7ec0c7e986ccedf73b9e0eb11f7ca9d71e877a" translate="yes" xml:space="preserve">
          <source>The matching text can appear directly within the selected element, in any of that element's descendants, or a combination thereof. As with attribute value selectors, text inside the parentheses of &lt;code&gt;:contains()&lt;/code&gt; can be written as a bare word or surrounded by quotation marks. The text must have matching case to be selected.</source>
          <target state="translated">일치하는 텍스트는 선택한 요소, 해당 요소의 자손 또는 그 조합에서 직접 나타날 수 있습니다. 속성 값 선택기와 마찬가지로 &lt;code&gt;:contains()&lt;/code&gt; 괄호 안의 텍스트 는 간단한 단어로 쓰거나 따옴표로 묶을 수 있습니다. 텍스트는 대소 문자를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="da8dada95be7fb335e0f7f1320405d5fbedd5c7c" translate="yes" xml:space="preserve">
          <source>The merge performed by &lt;code&gt;$.extend()&lt;/code&gt; is not recursive by default; if a property of the first object is itself an object or array, it will be completely overwritten by a property with the same key in the second or subsequent object. The values are not merged. This can be seen in the example below by examining the value of banana. However, by passing &lt;code&gt;true&lt;/code&gt; for the first function argument, objects will be recursively merged.</source>
          <target state="translated">&lt;code&gt;$.extend()&lt;/code&gt; 의해 수행 된 병합 은 기본적으로 재귀 적이 지 않습니다. 첫 번째 객체의 속성 자체가 객체 또는 배열 인 경우 두 번째 또는 후속 객체에서 동일한 키를 가진 속성으로 완전히 덮어 씁니다. 값이 병합되지 않습니다. 이것은 바나나의 가치를 조사하여 아래 예에서 볼 수 있습니다. 그러나 첫 번째 함수 인수에 &lt;code&gt;true&lt;/code&gt; 를 전달 하면 객체가 재귀 적으로 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="1c80fedd44d738243eba338965b1bbbb2d7430fc" translate="yes" xml:space="preserve">
          <source>The message to send out.</source>
          <target state="translated">보낼 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="c43a2a342b89cf38eab310c6b2bdcbbe99661c6e" translate="yes" xml:space="preserve">
          <source>The method for retrieving the current selected text differs from one browser to another. A number of jQuery plug-ins offer cross-platform solutions.</source>
          <target state="translated">현재 선택된 텍스트를 검색하는 방법은 브라우저마다 다릅니다. 많은 jQuery 플러그인은 크로스 플랫폼 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="85b34d3ff4f09696376c290b5d4b739841fed2fd" translate="yes" xml:space="preserve">
          <source>The method is essentially a shim for the &lt;a href=&quot;https://drafts.csswg.org/cssom/#the-css.escape()-method&quot;&gt;CSS Working Group's CSS.escape() method&lt;/a&gt;. The main difference is that &lt;code&gt;$.escapeSelector()&lt;/code&gt; can be reliably used in all of jQuery's supported browsers.</source>
          <target state="translated">이 메소드는 본질적으로 &lt;a href=&quot;https://drafts.csswg.org/cssom/#the-css.escape()-method&quot;&gt;CSS Working Group의 CSS.escape () 메소드에&lt;/a&gt; 대한 shim입니다 . 주요 차이점은 &lt;code&gt;$.escapeSelector()&lt;/code&gt; 를 모든 jQuery 지원 브라우저에서 안정적으로 사용할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bb0ac576955e6ed525104494cccefc79c0ffaa02" translate="yes" xml:space="preserve">
          <source>The method optionally accepts a selector expression for its second argument. If this argument is supplied, the elements will be filtered by testing whether they match it.</source>
          <target state="translated">이 메소드는 선택적으로 두 번째 인수에 대한 선택기 표현식을 승인합니다. 이 인수가 제공되면 요소가 일치하는지 테스트하여 요소가 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="db4b38eca31ac6773d02424670d957ba8068df2a" translate="yes" xml:space="preserve">
          <source>The method optionally accepts a selector expression of the same type that can be passed to the &lt;code&gt;$()&lt;/code&gt; function. If the selector is supplied, the preceding element will be filtered by testing whether it match the selector.</source>
          <target state="translated">이 메소드는 선택적으로 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수있는 동일한 유형의 선택기 표현식을 승인 합니다. 선택기가 제공되면 이전 요소가 선택기와 일치하는지 테스트하여 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="6e347b38d077dd75b669a2a45800a2e68ea6ad65" translate="yes" xml:space="preserve">
          <source>The method optionally accepts a selector expression of the same type that we can pass to the &lt;code&gt;$()&lt;/code&gt; function. If the immediately following sibling matches the selector, it remains in the newly constructed jQuery object; otherwise, it is excluded.</source>
          <target state="translated">이 메소드는 선택적으로 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수있는 것과 동일한 유형의 선택자 표현식을 허용 합니다. 바로 다음 형제가 선택자와 일치하면 새로 구성된 jQuery 객체에 남아 있습니다. 그렇지 않으면 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="8c55f0e439cd154cac85e4979f9c4e7e9575eb8a" translate="yes" xml:space="preserve">
          <source>The method optionally accepts a selector expression of the same type that we can pass to the &lt;code&gt;$()&lt;/code&gt; function. If the selector is supplied, the elements will be filtered by testing whether they match it.</source>
          <target state="translated">이 메소드는 선택적으로 &lt;code&gt;$()&lt;/code&gt; 함수에 전달할 수있는 것과 동일한 유형의 선택자 표현식을 허용 합니다. 선택기가 제공되면 요소가 일치하는지 테스트하여 요소가 필터링됩니다.</target>
        </trans-unit>
        <trans-unit id="6305564df7b2b4e272ed467fba354bfdae8565ff" translate="yes" xml:space="preserve">
          <source>The methods of &lt;code&gt;$.Callbacks&lt;/code&gt; can also be detached, should there be a need to define short-hand versions for convenience:</source>
          <target state="translated">편의상 단축 버전을 정의해야하는 경우 &lt;code&gt;$.Callbacks&lt;/code&gt; 의 메소드를 분리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="dafefab1095fabbdb39dfb2063d2b3e5df760f86" translate="yes" xml:space="preserve">
          <source>The mouse button is depressed again while the pointer is inside the element, within a time window that is system-dependent.</source>
          <target state="translated">시스템에 의존하는 시간 창 내에서 포인터가 요소 안에있는 동안 마우스 버튼을 다시 누릅니다.</target>
        </trans-unit>
        <trans-unit id="576cd8b97d955c1f863447a2e77d26323ba6546c" translate="yes" xml:space="preserve">
          <source>The mouse button is depressed while the pointer is inside the element.</source>
          <target state="translated">포인터가 요소 안에있는 동안 마우스 버튼이 눌려 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1db620e4cdeba5d3d324554abd72a643b595ecf" translate="yes" xml:space="preserve">
          <source>The mouse button is released while the pointer is inside the element.</source>
          <target state="translated">포인터가 요소 안에있는 동안 마우스 버튼이 해제됩니다.</target>
        </trans-unit>
        <trans-unit id="2263bd52a19e370eee7fef7d2360445c3d9c5f06" translate="yes" xml:space="preserve">
          <source>The mouse position relative to the left edge of the document.</source>
          <target state="translated">문서의 왼쪽 가장자리를 기준으로 한 마우스 위치입니다.</target>
        </trans-unit>
        <trans-unit id="12339186c582f7ed442e4c1b7e3883792f2709f5" translate="yes" xml:space="preserve">
          <source>The mouse position relative to the top edge of the document.</source>
          <target state="translated">문서의 상단 가장자리를 기준으로 한 마우스 위치입니다.</target>
        </trans-unit>
        <trans-unit id="2033823b3dadb8c11098d4f039ae3c154ce90a6c" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;&quot;class&quot;&lt;/code&gt; must be quoted in the object since it is a JavaScript reserved word, and &lt;code&gt;&quot;className&quot;&lt;/code&gt; cannot be used since it refers to the DOM property, not the attribute.</source>
          <target state="translated">&lt;code&gt;&quot;class&quot;&lt;/code&gt; 라는 이름 은 JavaScript 예약어이므로 오브젝트에서 인용해야하며 &lt;code&gt;&quot;className&quot;&lt;/code&gt; 은 속성이 아닌 DOM 특성을 나타내므로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2be23a63086ebda18e8b5ba2e3920d1ac2b75c2d" translate="yes" xml:space="preserve">
          <source>The name of a jQuery method that generated the array of elements.</source>
          <target state="translated">요소 배열을 생성 한 jQuery 메소드의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="4296958589618bb6ad56c790eff779ad5d423877" translate="yes" xml:space="preserve">
          <source>The name of the attribute to get.</source>
          <target state="translated">가져올 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="fbd0cc3752c40397ded39a708c242e4c4268ad6a" translate="yes" xml:space="preserve">
          <source>The name of the attribute to set.</source>
          <target state="translated">설정할 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="e46c06096b68a311eebedcb4711d03a49036de4a" translate="yes" xml:space="preserve">
          <source>The name of the function whose context will be changed (should be a property of the &lt;code&gt;context&lt;/code&gt; object).</source>
          <target state="translated">컨텍스트가 변경 될 함수의 이름입니다 ( &lt;code&gt;context&lt;/code&gt; 개체 의 속성이어야 함 ).</target>
        </trans-unit>
        <trans-unit id="2e22159b8af57c29d0edb7193b221eb98a0ca996" translate="yes" xml:space="preserve">
          <source>The name of the property to get.</source>
          <target state="translated">얻을 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="22a258d2d705073bc54bce7ce496f383cbeade4f" translate="yes" xml:space="preserve">
          <source>The name of the property to remove.</source>
          <target state="translated">제거 할 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f1c14f88a65230d7c15efb3a3d43e7bba43ad5af" translate="yes" xml:space="preserve">
          <source>The name of the property to set.</source>
          <target state="translated">설정할 속성의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="0cd4253c3db5e6f71db9e3f316f1013ed1b182b2" translate="yes" xml:space="preserve">
          <source>The name of the queue in which to stop animations.</source>
          <target state="translated">애니메이션을 중지 할 대기열의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="ec510aca48291402a1eb466d7b9bbe2a80c30c14" translate="yes" xml:space="preserve">
          <source>The namespace specified when the event was triggered.</source>
          <target state="translated">이벤트가 트리거 될 때 지정된 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="0e042ae48213e41f3c7dccddac1887f13741ea2e" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element is created on the fly and added to the DOM. The result is a new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; wrapped around all matched elements:</source>
          <target state="translated">새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 즉시 생성되어 DOM에 추가됩니다. 결과는 일치하는 모든 요소를 ​​감싸는 새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="2d83db634f8310cdc17fa4dcfc3eccbf02665e0f" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element is created on the fly and added to the DOM. The result is a new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; wrapped around each matched element:</source>
          <target state="translated">새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 즉시 생성되어 DOM에 추가됩니다. 결과는 일치하는 각 요소를 감싸는 새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="7b58a65b4c9866f2d71d3277e6db6f3e6f3a7760" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element is created on the fly and added to the DOM. The result is a new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; wrapped around the content of each matched element:</source>
          <target state="translated">새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 즉시 생성되어 DOM에 추가됩니다. 결과는 일치하는 각 요소의 내용을 감싸는 새로운 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="79c84130d9d5f31038adef11e326eb07e0a7ceaf" translate="yes" xml:space="preserve">
          <source>The new data value; this can be any Javascript type except &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">새로운 데이터 가치; &lt;code&gt;undefined&lt;/code&gt; 를 제외한 모든 Javascript 유형이 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86f9d09d2b9aa882752be29e4d95646605648024" translate="yes" xml:space="preserve">
          <source>The new function to add to the queue, with a function to call that will dequeue the next item.</source>
          <target state="translated">다음 항목을 대기열에서 제외시키는 호출 기능과 함께 대기열에 추가 할 새 기능.</target>
        </trans-unit>
        <trans-unit id="9c162ae394e32228352d0721ceb63d31e08368c1" translate="yes" xml:space="preserve">
          <source>The new function to add to the queue.</source>
          <target state="translated">대기열에 추가 할 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="a5f0b107fe0d49f6c9decfb59cc2f2c72f057786" translate="yes" xml:space="preserve">
          <source>The nonce attribute passed to the executed script.</source>
          <target state="translated">실행 된 스크립트에 전달 된 nonce 속성입니다.</target>
        </trans-unit>
        <trans-unit id="d0eafdfc57124a623a8018c422334d4b9398c2dc" translate="yes" xml:space="preserve">
          <source>The notable difference between (&lt;code&gt;prev + next&lt;/code&gt;) and (&lt;code&gt;prev ~ siblings&lt;/code&gt;) is their respective reach. While the former reaches only to the immediately following sibling element, the latter extends that reach to all following sibling elements.</source>
          <target state="translated">( &lt;code&gt;prev + next&lt;/code&gt; )와 ( &lt;code&gt;prev ~ siblings&lt;/code&gt; ) 의 주목할만한 차이점은 각각의 도달 거리입니다. 전자는 바로 다음의 형제 요소에만 도달하지만 후자는 모든 형제 요소에 도달합니다.</target>
        </trans-unit>
        <trans-unit id="73c92283828b72633f848b9fc54352c975e1c308" translate="yes" xml:space="preserve">
          <source>The number of elements currently matched. The .&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt; method will return the same value.</source>
          <target state="translated">현재 일치하는 요소 수 . &lt;a href=&quot;size&quot;&gt;size ()&lt;/a&gt; 메서드는 같은 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12d7ae7bde39033c3e928ca063c9efe18c0ee88b" translate="yes" xml:space="preserve">
          <source>The number of elements in the jQuery object.</source>
          <target state="translated">jQuery 객체의 요소 수</target>
        </trans-unit>
        <trans-unit id="a6016b690bdcda756024030e31e339dec9953dc6" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.height()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.height()&lt;/code&gt; 포함하여 차원 관련 API가 반환하는 숫자는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5e1719c954b51432abdfa681d9c3f47f176fad6" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.innerHeight()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.innerHeight()&lt;/code&gt; 포함하여 차원 관련 API가 반환하는 숫자는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7aa21e56b5c6a4a1242bcbb02b0eb0a6d7535a8d" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.innerWidth()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.innerWidth()&lt;/code&gt; 포함하여 차원 관련 API가 반환 한 수는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a8d1ed18f88fb30e931c4dd179fa50e5f3d80b0" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.offset()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.offset()&lt;/code&gt; 포함하여 차원 관련 API가 반환하는 숫자는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4cc7307ad7e4bd4a5e469f56fb8abf4483d5d27c" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.outerHeight()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.outerHeight()&lt;/code&gt; 포함하여 차원 관련 API가 반환 한 수는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="53bf3025deac19407f8af0203fdb55e479bb25a2" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.outerWidth()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.outerWidth()&lt;/code&gt; 포함하여 차원 관련 API가 반환 한 수는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5493f0ce296d72e79d89a3d60ed5606b5223e979" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.position()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.position()&lt;/code&gt; 포함하여 차원 관련 API가 반환하는 숫자는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57c15f4d2fb291886be6e0579952d0630802ecbb" translate="yes" xml:space="preserve">
          <source>The number returned by dimensions-related APIs, including &lt;code&gt;.width()&lt;/code&gt;, may be fractional in some cases. Code should not assume it is an integer. Also, dimensions may be incorrect when the page is zoomed by the user; browsers do not expose an API to detect this condition.</source>
          <target state="translated">&lt;code&gt;.width()&lt;/code&gt; 포함하여 차원 관련 API가 반환하는 숫자는 경우에 따라 소수 일 수 있습니다. 코드는 정수라고 가정해서는 안됩니다. 또한 사용자가 페이지를 확대 / 축소하면 크기가 잘못 될 수 있습니다. 브라우저는이 조건을 감지하기 위해 API를 노출시키지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7159b370dec0b4c77b9794448f968d021591451c" translate="yes" xml:space="preserve">
          <source>The object that will be checked to see if it's a plain object.</source>
          <target state="translated">일반 개체인지 확인하기 위해 검사 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ff0ff630dca657003b8459aa56ecf0e2c77c82ea" translate="yes" xml:space="preserve">
          <source>The object that will be checked to see if it's empty.</source>
          <target state="translated">비어 있는지 확인하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="3ec3b49d6eb40059902496e5b347b2f0250d6d64" translate="yes" xml:space="preserve">
          <source>The object to extend. It will receive the new properties.</source>
          <target state="translated">확장 할 객체입니다. 새로운 속성을받습니다.</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">반복 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="bb0f686882a210293bfb4c1039dba53491f90039" translate="yes" xml:space="preserve">
          <source>The object to which the context (&lt;code&gt;this&lt;/code&gt;) of the function should be set.</source>
          <target state="translated">함수 의 컨텍스트 ( &lt;code&gt;this&lt;/code&gt; )를 설정해야하는 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="3f9e825e08e2e24867189da3596374f800696e05" translate="yes" xml:space="preserve">
          <source>The object to which the context of the function should be set.</source>
          <target state="translated">함수의 컨텍스트를 설정해야하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a3a8b16b79d7f4fee1588777ab5b8dddb1929eab" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;eventData&lt;/code&gt; parameter is not commonly used. When provided, this argument allows us to pass additional information to the handler. One handy use of this parameter is to work around issues caused by closures. For example, suppose we have two event handlers that both refer to the same external variable:</source>
          <target state="translated">선택적 &lt;code&gt;eventData&lt;/code&gt; 매개 변수는 일반적으로 사용되지 않습니다. 제공된 경우이 인수를 사용하면 추가 정보를 처리기에 전달할 수 있습니다. 이 매개 변수의 유용한 사용법 중 하나는 클로저로 인한 문제를 해결하는 것입니다. 예를 들어, 동일한 외부 변수를 참조하는 두 개의 이벤트 핸들러가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="7d1dddeb4e713a5f321f1b20a92fef9ccfbfa2bf" translate="yes" xml:space="preserve">
          <source>The original element is not included among the siblings, which is important to remember when we wish to find all elements at a particular level of the DOM tree. However, if the original collection contains more than one element, they might be mutual siblings and will both be found. If you need an exclusive list of siblings, use &lt;code&gt;$collection.siblings().not($collection)&lt;/code&gt;.</source>
          <target state="translated">원래 요소는 형제 사이에 포함되어 있지 않으므로 특정 수준의 DOM 트리에서 모든 요소를 ​​찾으려면 기억해야합니다. 그러나 원본 컬렉션에 둘 이상의 요소가 포함 된 경우 상호 형제 일 수 있으며 둘 다 찾을 수 있습니다. 독점적 인 형제 목록이 필요하면 &lt;code&gt;$collection.siblings().not($collection)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19df398a82ac5760aa053d006893448666db417e" translate="yes" xml:space="preserve">
          <source>The other DOM element involved in the event, if any.</source>
          <target state="translated">이벤트와 관련된 다른 DOM 요소 (있는 경우)</target>
        </trans-unit>
        <trans-unit id="c42d3730919bd78afe5cc24beda85a4371f8e442" translate="yes" xml:space="preserve">
          <source>The particular use cases of this method can be best described through some examples.</source>
          <target state="translated">이 방법의 특정 사용 사례는 일부 예를 통해 가장 잘 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12be8f32109db553edeba7bd125861dccf618584" translate="yes" xml:space="preserve">
          <source>The pattern allows you to create objects with methods that operate on data that isn't visible to the outside&amp;mdash;the very basis of object-oriented programming.</source>
          <target state="translated">이 패턴을 사용하면 객체 지향 프로그래밍의 기본 인 외부에서 볼 수없는 데이터에서 작동하는 메소드를 사용하여 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c46afeb0966601574b297f1353d3cc0f47df196" translate="yes" xml:space="preserve">
          <source>The point in the document at which the selector should begin matching; similar to the context argument of the &lt;code&gt;$(selector, context)&lt;/code&gt; method.</source>
          <target state="translated">문서에서 선택기가 일치하기 시작해야하는 지점입니다. &lt;code&gt;$(selector, context)&lt;/code&gt; 메소드 의 context 인수와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="0a0db3d81595eb495dfe775005f5118fba49529a" translate="yes" xml:space="preserve">
          <source>The primary advantage of &lt;code&gt;jQuery.hasData(element)&lt;/code&gt; is that it does not create and associate a data object with the element if none currently exists. In contrast, &lt;code&gt;jQuery.data(element)&lt;/code&gt; always returns a data object to the caller, creating one if no data object previously existed.</source>
          <target state="translated">&lt;code&gt;jQuery.hasData(element)&lt;/code&gt; 의 주요 장점은 현재 존재하지 않는 데이터 요소를 생성하고 요소와 연관시키지 않는다는 것입니다. 반대로 &lt;code&gt;jQuery.data(element)&lt;/code&gt; 항상 데이터 객체를 호출자에게 반환하여 이전에 데이터 객체가 존재하지 않는 경우 생성합니다.</target>
        </trans-unit>
        <trans-unit id="acdb90577bf3f6aada029f8710eb364c8c78a2a9" translate="yes" xml:space="preserve">
          <source>The rate (in milliseconds) at which animations fire.</source>
          <target state="translated">애니메이션이 실행되는 속도 (밀리 초)입니다.</target>
        </trans-unit>
        <trans-unit id="cb10dad645475696bea64c8a19075d461c6a4dfa" translate="yes" xml:space="preserve">
          <source>The remaining parameter of &lt;code&gt;.animate()&lt;/code&gt; is a string naming an easing function to use. An easing function specifies the speed at which the animation progresses at different points within the animation. The only easing implementations in the jQuery library are the default, called &lt;code&gt;swing&lt;/code&gt;, and one that progresses at a constant pace, called &lt;code&gt;linear&lt;/code&gt;. More easing functions are available with the use of plug-ins, most notably the &lt;a href=&quot;https://jqueryui.com/&quot;&gt;jQuery UI suite&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.animate()&lt;/code&gt; 의 나머지 매개 변수는 사용할 여유 함수를 명명하는 문자열입니다. 여유 함수는 애니메이션이 애니메이션 내 다른 지점에서 진행되는 속도를 지정합니다. jQuery 라이브러리에서 유일하게 구현하는 구현은 &lt;code&gt;swing&lt;/code&gt; 이라고하는 기본값이고 &lt;code&gt;linear&lt;/code&gt; 라는 일정한 속도로 진행되는 것 입니다. 플러그인, 특히 &lt;a href=&quot;https://jqueryui.com/&quot;&gt;jQuery UI 제품군을&lt;/a&gt; 사용하면 더 많은 여유 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="98e06470e3fa05cf5cc0dafb0b2ea20bf565f4ed" translate="yes" xml:space="preserve">
          <source>The result of the following code is a red background behind items 3, 4 and 5:</source>
          <target state="translated">다음 코드의 결과는 항목 3, 4 및 5 뒤에 빨간색 배경이됩니다.</target>
        </trans-unit>
        <trans-unit id="5f17d80c2fe57707960ab0ce62ea8411233be366" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind all four elements. Using an HTML snippet as the &lt;code&gt;.add()&lt;/code&gt; method's argument (as in the third version), we can create additional elements on the fly and add those elements to the matched set of elements. Let's say, for example, that we want to alter the background of the list items along with a newly created paragraph:</source>
          <target state="translated">이 호출의 결과는 네 가지 요소 뒤에 빨간색 배경이됩니다. HTML 스 니펫을 &lt;code&gt;.add()&lt;/code&gt; 메소드의 인수로 사용하면 (3 번째 버전과 같이) 추가 요소를 즉시 작성하고 해당 요소를 일치하는 요소 세트에 추가 할 수 있습니다. 예를 들어 목록 항목의 배경을 새로 만든 단락과 함께 변경하고 싶다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="f5306f5e1616f9fad7b62559297b520b0e13420d" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind item 2. Since no selector expression is supplied, this preceding element is unequivocally included as part of the object. If one had been supplied, the element would be tested for a match before it was included.</source>
          <target state="translated">이 호출의 결과는 항목 2 뒤에 빨간색 배경이됩니다. 선택기 표현식이 제공되지 않기 때문에이 선행 요소는 명백하게 오브젝트의 일부로 포함됩니다. 하나가 제공된 경우 요소가 포함되기 전에 해당 요소가 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b4fe25b8e98dc2a880ab00b6091306129b22d2b1" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind item 4. Since we do not supply a selector expression, this following element is unequivocally included as part of the object. If we had supplied one, the element would be tested for a match before it was included.</source>
          <target state="translated">이 호출의 결과는 항목 4 뒤에 빨간색 배경이됩니다. 선택자 표현식을 제공하지 않기 때문에이 다음 요소는 명백하게 오브젝트의 일부로 포함됩니다. 우리가 하나를 제공했다면, 요소가 포함되기 전에 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="2bdd09e46848eac38bfa76febcbadcd077bcfffd" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind items 1 and 2. Since we do not supply a selector expression, these preceding elements are unequivocally included as part of the object. If we had supplied one, the elements would be tested for a match before they were included.</source>
          <target state="translated">이 호출의 결과는 항목 1과 2 뒤에있는 빨간색 배경입니다. 선택기 표현식을 제공하지 않기 때문에 이러한 선행 요소는 명백하게 오브젝트의 일부로 포함됩니다. 우리가 하나를 제공했다면, 요소는 포함되기 전에 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="803dcb57e7c93f3e463b7c42ff56d2c06449aae1" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind items 1, 2, 4, and 5. Since we do not supply a selector expression, all of the siblings are part of the object. If we had supplied one, only the matching items among these four would be included.</source>
          <target state="translated">이 호출의 결과는 항목 1, 2, 4 및 5 뒤에 빨간색 배경이됩니다. 선택기 표현식을 제공하지 않기 때문에 모든 형제는 객체의 일부입니다. 우리가 하나를 제공했다면,이 네 가지 중에서 일치하는 항목 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b43225fe6ce7a5b0e7693b20ab46719a0f4b3f89" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind items 4 and 5. Since we do not supply a selector expression, these following elements are unequivocally included as part of the object. If we had supplied one, the elements would be tested for a match before they were included.</source>
          <target state="translated">이 호출의 결과는 항목 4 및 5 뒤에 빨간색 배경이됩니다. 우리는 선택기 표현식을 제공하지 않기 때문에 이러한 다음 요소는 명백하게 오브젝트의 일부로 포함됩니다. 우리가 하나를 제공했다면, 요소는 포함되기 전에 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0ed9f4feb04438548de3b013137694e77d57632b" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background behind items A, B, and C. Since we do not supply a selector expression, all of the children are part of the returned jQuery object. If we had supplied one, only the matching items among these three would be included.</source>
          <target state="translated">이 호출의 결과는 항목 A, B 및 C 뒤에있는 빨간색 배경입니다. 선택기 표현식을 제공하지 않기 때문에 모든 자식은 반환 된 jQuery 객체의 일부입니다. 우리가 하나를 제공했다면,이 세 가지 중 일치하는 항목 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5a5d9de3fcbdb18a4bc188bea62cba2e34e884d1" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for item 2, as it is the only &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; that has a &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; among its descendants.</source>
          <target state="translated">이 호출의 결과는 항목 2에 빨간색 배경이됩니다 . 하위 항목 중 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 이있는 유일한 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="c89615ef14d3fbd60d050d9155e47ebd4ba8656f" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for item 3. Note that the supplied index is zero-based, and refers to the position of the element within the jQuery object, not within the DOM tree.</source>
          <target state="translated">이 호출의 결과는 항목 3의 빨간색 배경입니다. 제공된 인덱스는 0부터 시작하며 DOM 트리가 아닌 jQuery 객체 내에서 요소의 위치를 ​​나타냅니다.</target>
        </trans-unit>
        <trans-unit id="14fb455b8bbff10842086b58eac8f01cab3c1afe" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for items 1, 3 and 5, as they do not match the selector.</source>
          <target state="translated">이 호출의 결과는 선택기와 일치하지 않으므로 항목 1, 3 및 5에 대해 빨간색 배경이됩니다.</target>
        </trans-unit>
        <trans-unit id="3a1805e37c0ac93512567135d69322d80bf04492" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for items 1, 3, and 5, as they match the selector (recall that &lt;code&gt;:even&lt;/code&gt; and &lt;code&gt;:odd&lt;/code&gt; use 0-based indexing).</source>
          <target state="translated">이 호출의 결과는 선택기와 일치하는 항목 1, 3 및 5에 대해 빨간색 배경입니다 ( &lt;code&gt;:even&lt;/code&gt; 및 &lt;code&gt;:odd&lt;/code&gt; 는 0 기반 인덱싱 사용).</target>
        </trans-unit>
        <trans-unit id="008bfcb10c48746c779c107b0cd2e4012a84d492" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for items 2 and 4, as they do not match the selector (recall that :even and :odd use 0-based indexing).</source>
          <target state="translated">이 호출의 결과는 선택기와 일치하지 않기 때문에 항목 2와 4에 빨간색 배경이됩니다 (: even 및 : odd는 0 기반 인덱싱을 사용함).</target>
        </trans-unit>
        <trans-unit id="339946000b39d9fa707e17614083ed036b66079a" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for items 2, 4, and 6, as they match the selector.</source>
          <target state="translated">이 호출의 결과는 선택기와 일치하는 항목 2, 4 및 6에 대한 빨간색 배경입니다.</target>
        </trans-unit>
        <trans-unit id="fa883f229b6f69a81b08da92e713eb4a1caff5f9" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for items 3, 4, and 5. Note that the supplied index is zero-based, and refers to the position of elements within the jQuery object, not within the DOM tree.</source>
          <target state="translated">이 호출의 결과는 항목 3, 4 및 5에 대한 빨간색 배경입니다. 제공된 인덱스는 0부터 시작하며 DOM 트리가 아닌 jQuery 객체 내의 요소 위치를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="db1517b2e444023a7127a38d5c51bcdff691e73b" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the final item.</source>
          <target state="translated">이 호출의 결과는 최종 항목의 빨간색 배경입니다.</target>
        </trans-unit>
        <trans-unit id="facf65b81d3f8a612a59fa241dcd3b82f9307f27" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the first item.</source>
          <target state="translated">이 호출의 결과는 첫 번째 항목의 빨간색 배경입니다.</target>
        </trans-unit>
        <trans-unit id="0c500ec67ebb649d2e140b32763333d3bacd2958" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the first, third &amp;amp; 5th items.</source>
          <target state="translated">이 호출의 결과는 첫 번째, 세 번째 및 다섯 번째 항목에 대한 빨간색 배경입니다.</target>
        </trans-unit>
        <trans-unit id="385666a4367c3ceaa277ae989ffa6d62efba1ee5" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the level-2 list, item II, and the level-1 list (and on up the DOM tree all the way to the &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; element). Since we do not supply a selector expression, all of the ancestors are part of the returned jQuery object. If we had supplied one, only the matching items among these would be included.</source>
          <target state="translated">이 호출의 결과는 레벨 2 목록, 항목 II 및 레벨 1 목록에 대한 빨간색 배경입니다 ( &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 요소 까지 모든 DOM 트리에서 ). 선택자 표현식을 제공하지 않기 때문에 모든 조상은 반환 된 jQuery 객체의 일부입니다. 우리가 하나를 제공했다면, 이들 중 일치하는 항목 만 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="22aacd8c82ea9af8e8daf6e3c4d83d62f3a11bb2" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the level-2 list. Since we do not supply a selector expression, the parent element is unequivocally included as part of the object. If we had supplied one, the element would be tested for a match before it was included.</source>
          <target state="translated">이 호출의 결과는 레벨 2 목록의 빨간색 배경입니다. 우리는 선택자 표현식을 제공하지 않기 때문에 부모 요소는 분명히 객체의 일부로 포함됩니다. 우리가 하나를 제공했다면, 요소가 포함되기 전에 일치하는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="fb4d7a14c05d95a1f5a2597e9018afb9d4fc4078" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background for the second &amp;amp; 4th items.</source>
          <target state="translated">이 호출의 결과는 두 번째 및 네 번째 항목에 대한 빨간색 배경입니다.</target>
        </trans-unit>
        <trans-unit id="759e58f5af381c9ae58e15d8327b13ec00b52925" translate="yes" xml:space="preserve">
          <source>The result of this call is a red background on items A, B, 1, 2, 3, and C. Even though item II matches the selector expression, it is not included in the results; only descendants are considered candidates for the match.</source>
          <target state="translated">이 호출의 결과는 항목 A, B, 1, 2, 3 및 C에서 빨간색 배경입니다. 항목 II가 선택기 표현식과 일치하더라도 결과에 포함되지 않습니다. 자손 만이 경기의 후보로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="8542609c7db1f3303873f6a2002911ee15c9ea8e" translate="yes" xml:space="preserve">
          <source>The result of this call is the string, &lt;code&gt;&quot;two,four,six,eight&quot;&lt;/code&gt;.</source>
          <target state="translated">이 호출의 결과는 문자열 &lt;code&gt;&quot;two,four,six,eight&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="485440b7c20f82cfee29dc2091cb4a9c40a2f99a" translate="yes" xml:space="preserve">
          <source>The result of this call would be a red background on item 1.</source>
          <target state="translated">이 호출의 결과는 항목 1의 빨간색 배경이됩니다.</target>
        </trans-unit>
        <trans-unit id="271ba0250ab50aa59f8fc29f25ec5ee041c7dddd" translate="yes" xml:space="preserve">
          <source>The result of this is that it becomes simple to construct complex lists of callbacks where input values can be passed through to as many functions as needed with ease.</source>
          <target state="translated">그 결과 입력 값을 필요한만큼 많은 함수에 쉽게 전달할 수있는 복잡한 콜백 목록을 구성하는 것이 간단 해집니다.</target>
        </trans-unit>
        <trans-unit id="2e630df4612cdefc2e2262290e72aa29c13c7a13" translate="yes" xml:space="preserve">
          <source>The result would look like this:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57cf4e5bb5314a409449a88f58bf0d0b43b88262" translate="yes" xml:space="preserve">
          <source>The resulting DOM structure would be:</source>
          <target state="translated">결과 DOM 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="141af9b6cff1007634750533839c59d6c52a9d14" translate="yes" xml:space="preserve">
          <source>The returned jQuery object contains zero or more elements for each element in the original set, in reverse document order</source>
          <target state="translated">반환 된 jQuery 객체는 원본 집합의 각 요소에 대해 0 개 이상의 요소를 역순으로 포함합니다.</target>
        </trans-unit>
        <trans-unit id="07ad1547f50f7c20a1cd7579032c984beb61889d" translate="yes" xml:space="preserve">
          <source>The returned jQuery object contains zero or one element for each element in the original set, in document order</source>
          <target state="translated">반환 된 jQuery 객체는 문서 세트에서 원본 세트의 각 요소에 대해 0 개 또는 1 개의 요소를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="f6fe1e1f1407019a7bb0e31dc8b4968b82567270" translate="yes" xml:space="preserve">
          <source>The same is true for other dynamic attributes, such as &lt;code&gt;selected&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 와 같은 다른 동적 속성의 경우에도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="59c475723db5a18006828a3888cc67bbf8c09867" translate="yes" xml:space="preserve">
          <source>The script is executed in the global context, so it can refer to other variables and use jQuery functions. Included scripts can have some impact on the current page.</source>
          <target state="translated">스크립트는 글로벌 컨텍스트에서 실행되므로 다른 변수를 참조하고 jQuery 함수를 사용할 수 있습니다. 포함 된 스크립트는 현재 페이지에 영향을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9cfc35df62d2b3a52dae65a48561a4349497359" translate="yes" xml:space="preserve">
          <source>The second and third formulations of this function create a jQuery object using one or more DOM elements that were already selected in some other way. A jQuery object is created from the array elements in the order they appeared in the array; unlike most other multi-element jQuery operations, the elements are not sorted in DOM order. Elements will be copied from the array as-is and won't be unwrapped if they're already jQuery collections.</source>
          <target state="translated">이 함수의 두 번째 및 세 번째 공식은 다른 방법으로 이미 선택된 하나 이상의 DOM 요소를 사용하여 jQuery 객체를 만듭니다. jQuery 객체는 배열에 나타난 순서대로 배열 요소에서 생성됩니다. 대부분의 다른 다중 요소 jQuery 작업과 달리 요소는 DOM 순서로 정렬되지 않습니다. 요소는 그대로 배열에서 복사되며 이미 jQuery 컬렉션 인 경우 래핑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09640a2d2f7e5680918d2964d2624ebb2a3d2a31" translate="yes" xml:space="preserve">
          <source>The second array-like object to merge into the first, unaltered.</source>
          <target state="translated">첫 번째 배열과 병합되지 않은 두 번째 배열과 유사한 개체입니다.</target>
        </trans-unit>
        <trans-unit id="4bc6e7d14914bf71bafefa2bfaf2aaad9add698b" translate="yes" xml:space="preserve">
          <source>The second form of this method allows us to filter elements against a function rather than a selector. For each element, if the function returns &lt;code&gt;true&lt;/code&gt; (or a &quot;truthy&quot; value), the element will be included in the filtered set; otherwise, it will be excluded. Suppose we have a somewhat more involved HTML snippet:</source>
          <target state="translated">이 방법의 두 번째 형태는 선택자가 아닌 함수에 대해 요소를 필터링 할 수있게합니다. 각 요소에 대해 함수가 &lt;code&gt;true&lt;/code&gt; (또는 &quot;거친&quot;값)를 반환 하면 요소가 필터링 된 집합에 포함됩니다. 그렇지 않으면 제외됩니다. 다소 복잡한 HTML 스 니펫이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fcb5168b1f0fd8e8dcac15e31943b6a43f6f6d0d" translate="yes" xml:space="preserve">
          <source>The second form of this method evaluates expressions related to elements based on a function rather than a selector. For each element, if the function returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;.is()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; as well. For example, given a somewhat more involved HTML snippet:</source>
          <target state="translated">이 방법의 두 번째 형태는 선택자가 아닌 함수를 기반으로 요소와 관련된 표현식을 평가합니다. 각 요소에 대해 함수가 &lt;code&gt;true&lt;/code&gt; 를 반환 하면 &lt;code&gt;.is()&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . 예를 들어, 다소 복잡한 HTML 스 니펫이 주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="2a154816850f6de6770577387c99f209db6b6ece" translate="yes" xml:space="preserve">
          <source>The second inner &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; could be replaced with the specified HTML:</source>
          <target state="translated">두 번째 내부 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 는 지정된 HTML로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e3344300bcc1acfb7bb30ab9c54d31a312c9e1" translate="yes" xml:space="preserve">
          <source>The second statement of the code above correctly refers to the &lt;code&gt;data-last-value&lt;/code&gt; attribute of the element. In case no data is stored with the passed key, jQuery searches among the attributes of the element, converting a camel-cased string into a dashed string and then prepending &lt;code&gt;data-&lt;/code&gt; to the result. So, the string &lt;code&gt;lastValue&lt;/code&gt; is converted to &lt;code&gt;data-last-value&lt;/code&gt;.</source>
          <target state="translated">위 코드의 두 번째 문장은 요소 의 &lt;code&gt;data-last-value&lt;/code&gt; 속성을 올바르게 참조합니다 . 전달 된 키와 함께 데이터가 저장되지 않은 경우 jQuery는 요소의 속성을 검색하여 낙타 문자열을 대시 문자열로 변환 한 다음 결과 앞에 &lt;code&gt;data-&lt;/code&gt; 를 추가 합니다. 따라서 문자열 &lt;code&gt;lastValue&lt;/code&gt; 는 &lt;code&gt;data-last-value&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c42dd9df1106a653c3e574c2ee9fc8431d825de" translate="yes" xml:space="preserve">
          <source>The second time we apply &lt;code&gt;$( &quot;div.tumble&quot; ).toggleClass( &quot;bounce&quot; )&lt;/code&gt;, the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; class is returned to the single &lt;code&gt;tumble&lt;/code&gt; value:</source>
          <target state="translated">두 번째로 &lt;code&gt;$( &quot;div.tumble&quot; ).toggleClass( &quot;bounce&quot; )&lt;/code&gt; 를 적용하면 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 클래스가 단일 &lt;code&gt;tumble&lt;/code&gt; 값으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="665befe924907801a3530bb57b4cbf891ba537dd" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;.animate()&lt;/code&gt; provides a &lt;code&gt;step&lt;/code&gt; option &amp;mdash; a callback function that is fired at each step of the animation. This function is useful for enabling custom animation types or altering the animation as it is occurring. It accepts two arguments (&lt;code&gt;now&lt;/code&gt; and &lt;code&gt;fx&lt;/code&gt;), and &lt;code&gt;this&lt;/code&gt; is set to the DOM element being animated.</source>
          <target state="translated">&lt;code&gt;.animate()&lt;/code&gt; 의 두 번째 버전은 &lt;code&gt;step&lt;/code&gt; 옵션 (애니메이션의 각 단계에서 시작되는 콜백 함수 )을 제공합니다 . 이 기능은 사용자 정의 애니메이션 유형을 활성화하거나 발생하는 애니메이션을 변경하는 데 유용합니다. 이 두 인자 (받아 &lt;code&gt;now&lt;/code&gt; 및 &lt;code&gt;fx&lt;/code&gt; )하고 &lt;code&gt;this&lt;/code&gt; DOM 요소는 애니메이션을 설정한다.</target>
        </trans-unit>
        <trans-unit id="9ae52fd7621257d963ead7e4f0853cac0c5348a5" translate="yes" xml:space="preserve">
          <source>The second version of &lt;code&gt;.toggleClass()&lt;/code&gt; uses the second parameter for determining whether the class should be added or removed. If this parameter's value is &lt;code&gt;true&lt;/code&gt;, then the class is added; if &lt;code&gt;false&lt;/code&gt;, the class is removed. In essence, the statement:</source>
          <target state="translated">&lt;code&gt;.toggleClass()&lt;/code&gt; 의 두 번째 버전은 두 번째 매개 변수를 사용하여 클래스 추가 또는 제거 여부를 결정합니다. 이 매개 변수의 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 클래스가 추가됩니다. 경우 &lt;code&gt;false&lt;/code&gt; , 클래스가 제거됩니다. 본질적으로 진술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="efaf7d0124b927367a9b0ae3fed5a220228eea05" translate="yes" xml:space="preserve">
          <source>The second version of the &lt;code&gt;.not()&lt;/code&gt; method allows us to remove elements from the matched set, assuming we have found those elements previously by some other means. For example, suppose our list had an id applied to one of its items:</source>
          <target state="translated">&lt;code&gt;.not()&lt;/code&gt; 메소드 의 두 번째 버전 에서는 이전에 다른 방법으로 해당 요소를 찾았다 고 가정하여 일치하는 세트에서 요소를 제거 할 수 있습니다. 예를 들어 목록에 항목 중 하나에 ID가 적용되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="db488502c779e5855624bcb94b0d9eac6e51fef3" translate="yes" xml:space="preserve">
          <source>The second version of the method accepts a Boolean parameter. If this parameter is &lt;code&gt;true&lt;/code&gt;, then the matched elements are shown; if &lt;code&gt;false&lt;/code&gt;, the elements are hidden. In essence, the statement:</source>
          <target state="translated">메소드의 두 번째 버전은 부울 매개 변수를 승인합니다. 이 매개 변수가 &lt;code&gt;true&lt;/code&gt; 이면 일치하는 요소가 표시됩니다. 경우 &lt;code&gt;false&lt;/code&gt; , 요소가 숨겨져 있습니다. 본질적으로 진술은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14129c4f8fda0ecb933fddabaa46bdf397f7bc5b" translate="yes" xml:space="preserve">
          <source>The second version of this method allows us to instead specify a callback function. This callback function will be called once for every matched element; it should return a DOM element, jQuery object, or HTML snippet in which to wrap the content of the corresponding element. For example:</source>
          <target state="translated">이 메소드의 두 번째 버전에서는 콜백 함수를 대신 지정할 수 있습니다. 이 콜백 함수는 일치하는 모든 요소마다 한 번씩 호출됩니다. 해당 요소의 내용을 래핑 할 DOM 요소, jQuery 객체 또는 HTML 스 니펫을 반환해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50749b1d27f953b40a33c2be2b260d7a6793cd44" translate="yes" xml:space="preserve">
          <source>The second version of this method allows us to instead specify a callback function. This callback function will be called once for every matched element; it should return a DOM element, jQuery object, or HTML snippet in which to wrap the corresponding element. For example:</source>
          <target state="translated">이 메소드의 두 번째 버전에서는 콜백 함수를 대신 지정할 수 있습니다. 이 콜백 함수는 일치하는 모든 요소마다 한 번씩 호출됩니다. 해당 요소를 래핑 할 DOM 요소, jQuery 객체 또는 HTML 스 니펫을 반환해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f395dc88a156a3c3c8af5ffcd5884c85b81cc391" translate="yes" xml:space="preserve">
          <source>The selectors are a composition of CSS and custom additions. All selectors available in jQuery are documented on the &lt;a href=&quot;category/selectors&quot;&gt;Selectors API page&lt;/a&gt;.</source>
          <target state="translated">선택기는 CSS와 사용자 정의 추가로 구성됩니다. jQuery에서 사용 가능한 모든 선택기는 &lt;a href=&quot;category/selectors&quot;&gt;Selectors API 페이지에 설명되어&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="113d83a724dd060af5c92489a395d6836663109a" translate="yes" xml:space="preserve">
          <source>The standard events in the Document Object Model are: &lt;code&gt;blur&lt;/code&gt;, &lt;code&gt;focus&lt;/code&gt;, &lt;code&gt;load&lt;/code&gt;, &lt;code&gt;resize&lt;/code&gt;, &lt;code&gt;scroll&lt;/code&gt;, &lt;code&gt;unload&lt;/code&gt;, &lt;code&gt;beforeunload&lt;/code&gt;, &lt;code&gt;click&lt;/code&gt;, &lt;code&gt;dblclick&lt;/code&gt;, &lt;code&gt;mousedown&lt;/code&gt;, &lt;code&gt;mouseup&lt;/code&gt;, &lt;code&gt;mousemove&lt;/code&gt;, &lt;code&gt;mouseover&lt;/code&gt;, &lt;code&gt;mouseout&lt;/code&gt;, &lt;code&gt;mouseenter&lt;/code&gt;, &lt;code&gt;mouseleave&lt;/code&gt;, &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;submit&lt;/code&gt;, &lt;code&gt;keydown&lt;/code&gt;, &lt;code&gt;keypress,&lt;/code&gt; and &lt;code&gt;keyup&lt;/code&gt;. Since the DOM event names have predefined meanings for some elements, using them for other purposes is not recommended. jQuery's event model can trigger an event by any name on an element, and it is propagated up the DOM tree to which that element belongs, if any.</source>
          <target state="translated">문서 객체 모델의 표준 이벤트는 다음과 같습니다 : &lt;code&gt;blur&lt;/code&gt; , &lt;code&gt;focus&lt;/code&gt; , &lt;code&gt;load&lt;/code&gt; , &lt;code&gt;resize&lt;/code&gt; , &lt;code&gt;scroll&lt;/code&gt; , &lt;code&gt;unload&lt;/code&gt; , &lt;code&gt;beforeunload&lt;/code&gt; , &lt;code&gt;click&lt;/code&gt; , &lt;code&gt;dblclick&lt;/code&gt; , &lt;code&gt;mousedown&lt;/code&gt; , &lt;code&gt;mouseup&lt;/code&gt; , &lt;code&gt;mousemove&lt;/code&gt; , &lt;code&gt;mouseover&lt;/code&gt; , &lt;code&gt;mouseout&lt;/code&gt; , &lt;code&gt;mouseenter&lt;/code&gt; , &lt;code&gt;mouseleave&lt;/code&gt; , &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;submit&lt;/code&gt; , &lt;code&gt;keydown&lt;/code&gt; , &lt;code&gt;keypress,&lt;/code&gt; 와 &lt;code&gt;keyup&lt;/code&gt; . DOM 이벤트 이름은 일부 요소에 대해 사전 정의 된 의미를 가지므로 다른 용도로 사용하지 않는 것이 좋습니다. jQuery의 이벤트 모델은 요소의 이름으로 이벤트를 트리거 할 수 있으며 해당 요소가 속한 DOM 트리 (있는 경우)로 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="d7dc41bbfc0d4e44cab83fd01605e79bb3468eef" translate="yes" xml:space="preserve">
          <source>The string representing an easing function specifies the speed at which the animation progresses at different points within the animation. The only easing implementations in the jQuery library are the default, called &lt;code&gt;swing&lt;/code&gt;, and one that progresses at a constant pace, called &lt;code&gt;linear&lt;/code&gt;. More easing functions are available with the use of plug-ins, most notably the &lt;a href=&quot;https://jqueryui.com&quot;&gt;jQuery UI suite&lt;/a&gt;.</source>
          <target state="translated">여유 함수를 나타내는 문자열은 애니메이션 내 다른 지점에서 애니메이션이 진행되는 속도를 지정합니다. jQuery 라이브러리에서 유일하게 구현하는 구현은 &lt;code&gt;swing&lt;/code&gt; 이라고하는 기본값이고 &lt;code&gt;linear&lt;/code&gt; 라는 일정한 속도로 진행되는 것 입니다. 플러그인, 특히 &lt;a href=&quot;https://jqueryui.com&quot;&gt;jQuery UI 제품군을&lt;/a&gt; 사용하면 더 많은 여유 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9a2664d68de74010dd9b594714895a2e4e5ee52" translate="yes" xml:space="preserve">
          <source>The string to trim.</source>
          <target state="translated">자를 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="b5a92059af11477af58d65e98372ed264b36cef5" translate="yes" xml:space="preserve">
          <source>The style definition is present to make the target element small enough to be scrollable:</source>
          <target state="translated">스타일 요소는 대상 요소를 스크롤 할 수있을 정도로 작게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5deae09e7c61eea99ec8ef3ea6e54e9cb20eaf6c" translate="yes" xml:space="preserve">
          <source>The text to set as the content of each matched element. When Number or Boolean is supplied, it will be converted to a String representation.</source>
          <target state="translated">일치하는 각 요소의 컨텐츠로 설정할 텍스트입니다. 숫자 또는 부울이 제공되면 문자열 표현으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="5f5b15e66531244890cf5d811d8f2c84ea4027f2" translate="yes" xml:space="preserve">
          <source>The third form of the &lt;code&gt;.unbind()&lt;/code&gt; method is used when we wish to unbind a handler from within itself. For example, suppose we wish to trigger an event handler only three times:</source>
          <target state="translated">&lt;code&gt;.unbind()&lt;/code&gt; 메소드 의 세 번째 형식은 핸들러 자체를 바인드 해제하려는 경우에 사용됩니다. 예를 들어 이벤트 핸들러를 세 번만 트리거한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6c28ffbb3cc7d012a98f2607f053d7e64eaa8d79" translate="yes" xml:space="preserve">
          <source>The translation function that is provided to this method is called for each top-level element in the array or object and is passed two arguments: The element's value and its index or key within the array or object.</source>
          <target state="translated">이 메소드에 제공되는 변환 함수는 배열 또는 오브젝트의 각 최상위 레벨 요소에 대해 호출되며 두 개의 인수 (배열 또는 오브젝트 내의 요소 값 및 색인 또는 키)가 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="258e9a1f5851882139fe20ce70223b4486206779" translate="yes" xml:space="preserve">
          <source>The type of a function is &quot;function&quot;.</source>
          <target state="translated">기능의 유형은 &quot;기능&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="250061ae6c3eaba58f68c8b0705fa5283b17f50a" translate="yes" xml:space="preserve">
          <source>The type of a number is &quot;number&quot;.</source>
          <target state="translated">숫자의 유형은 &quot;숫자&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="7d86a1b42215eee2fd5f10b41fcbfe8d78a85728" translate="yes" xml:space="preserve">
          <source>The type of a string is &quot;string&quot;.</source>
          <target state="translated">문자열의 유형은 &quot;string&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="de7be4ab84b82bbdfbeec8971b1864a663638bfd" translate="yes" xml:space="preserve">
          <source>The type of an array is &quot;object&quot;:</source>
          <target state="translated">배열의 유형은 &quot;object&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="a18897493ed6d8b67961ab81a7e1840ec5872f8e" translate="yes" xml:space="preserve">
          <source>The type of an object is &quot;object&quot;:</source>
          <target state="translated">객체의 유형은 &quot;객체&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8bb813a8f15ca076b4aeffe26fb2a446d33302d2" translate="yes" xml:space="preserve">
          <source>The type of data expected from the server. Default: Intelligent Guess (xml, json, script, text, html).</source>
          <target state="translated">서버에서 예상되는 데이터 유형입니다. 기본값 : Intelligent Guess (xml, json, 스크립트, 텍스트, html).</target>
        </trans-unit>
        <trans-unit id="65b1a1be3665cab47e929452b9514cab452f93f3" translate="yes" xml:space="preserve">
          <source>The type of data that you're expecting back from the server. If none is specified, jQuery will try to infer it based on the MIME type of the response (an XML MIME type will yield XML, in 1.4 JSON will yield a JavaScript object, in 1.4 script will execute the script, and anything else will be returned as a string). The available types (and the result passed as the first argument to your success callback) are:</source>
          <target state="translated">서버에서 다시 기대하는 데이터 유형입니다. 아무것도 지정하지 않으면 jQuery는 응답의 MIME 유형을 기반으로 추론하려고 시도합니다 (XML MIME 유형은 XML을 생성하고 1.4에서 JSON은 JavaScript 객체를 생성하고 1.4 스크립트에서 스크립트를 실행하며 그 밖의 모든 것은 문자열로 반환). 사용 가능한 유형 (및 성공 콜백에 대한 첫 번째 인수로 전달 된 결과)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e4f1e6bc7e33b940ea0ca5958d289d963ae06e7" translate="yes" xml:space="preserve">
          <source>The type of queue that needs to be observed.</source>
          <target state="translated">관찰해야하는 큐 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ac03d521d35e958a333e1be1023588d7bb5c2990" translate="yes" xml:space="preserve">
          <source>The unminified jQuery source itself includes a list of default converters, which effectively illustrates how they can be used:</source>
          <target state="translated">축소되지 않은 jQuery 소스 자체에는 기본 변환기 목록이 포함되어 있으며이를 사용하는 방법을 효과적으로 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb4b9ca98fca80215d567f08acc1e010086fbd76" translate="yes" xml:space="preserve">
          <source>The updated set of elements can be used in a following (chained) method, or assigned to a variable for later use. For example:</source>
          <target state="translated">업데이트 된 요소 집합은 다음 (체인) 방법으로 사용하거나 나중에 사용하기 위해 변수에 할당 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7dc333f2557363d5ea2debb3f8b7027ef58060e4" translate="yes" xml:space="preserve">
          <source>The usefulness of the &lt;code&gt;.stop()&lt;/code&gt; method is evident when we need to animate an element on &lt;code&gt;mouseenter&lt;/code&gt; and &lt;code&gt;mouseleave&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.stop()&lt;/code&gt; 메소드 의 유용성은 &lt;code&gt;mouseenter&lt;/code&gt; 와 &lt;code&gt;mouseleave&lt;/code&gt; 에서 요소에 애니메이션을 적용해야 할 때 분명합니다 .</target>
        </trans-unit>
        <trans-unit id="7ddb3ecf6925c2baa005d5f8268928b76546a56a" translate="yes" xml:space="preserve">
          <source>The value of this property is typically equal to &lt;code&gt;document&lt;/code&gt;, as this is the default context for jQuery objects if none is supplied. The context may differ if, for example, the object was created by searching within an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; or XML document.</source>
          <target state="translated">jQuery 객체가 제공되지 않은 경우 기본 컨텍스트이므로이 속성의 값은 일반적으로 &lt;code&gt;document&lt;/code&gt; 와 같습니다. 예를 들어 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 또는 XML 문서 내에서 검색하여 객체를 만든 경우 컨텍스트가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d165304e00442e2fdb141efe014b25a469d208d2" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.height()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.height()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.height()&lt;/code&gt; 의해보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지 않을 수 있습니다. 정확한 값을 얻으려면 &lt;code&gt;.height()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c0af6f379e115697c7e674c117df786f0e63a85" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.innerHeight()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.innerHeight()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.innerHeight()&lt;/code&gt; 의해보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지는 않습니다. 정확한 값을 얻으려면 &lt;code&gt;.innerHeight()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8991a4ea8bbeb4de8eb903eec32a3d76ab3261d6" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.innerWidth()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.innerWidth()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.innerWidth()&lt;/code&gt; 의해보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지 않을 수 있습니다. 정확한 값을 얻으려면 &lt;code&gt;.innerWidth()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d91533a4f81b4096f3edfca19014a9026436ec64" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.outerHeight()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.outerHeight()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.outerHeight()&lt;/code&gt; 의해보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지 않을 수 있습니다. 정확한 값을 얻으려면 &lt;code&gt;.outerHeight()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd3d5a9284c46e459ea9e01e158794d00a13f65" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.outerWidth()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.outerWidth()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.outerWidth()&lt;/code&gt; 의해보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지 않을 수 있습니다. 정확한 값을 얻으려면 &lt;code&gt;.outerWidth()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ae90c5e2d8c736238c1834e07b1b20df9da99b3" translate="yes" xml:space="preserve">
          <source>The value reported by &lt;code&gt;.width()&lt;/code&gt; is not guaranteed to be accurate when the element or its parent is hidden. To get an accurate value, ensure the element is visible before using &lt;code&gt;.width()&lt;/code&gt;. jQuery will attempt to temporarily show and then re-hide an element in order to measure its dimensions, but this is unreliable and (even when accurate) can significantly impact page performance. This show-and-rehide measurement feature may be removed in a future version of jQuery.</source>
          <target state="translated">&lt;code&gt;.width()&lt;/code&gt; 로보고 된 값 은 요소 나 그 부모가 숨겨져있을 때 정확하지 않을 수 있습니다. 정확한 값을 얻으려면 &lt;code&gt;.width()&lt;/code&gt; 를 사용하기 전에 요소가 표시되는지 확인하십시오 . jQuery는 크기를 측정하기 위해 요소를 일시적으로 표시 한 다음 다시 숨기려고 시도하지만 신뢰할 수 없으며 정확한 경우에도 페이지 성능에 큰 영향을 줄 수 있습니다. 이 표시 및 숨기기 측정 기능은 이후 버전의 jQuery에서 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b826fb647f77daf90366e276f5a2041c3eea0d6" translate="yes" xml:space="preserve">
          <source>The value to be tested.</source>
          <target state="translated">테스트 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="5f9706fe37a21ebb4f5356314e9dbb0f193612de" translate="yes" xml:space="preserve">
          <source>The value to search for.</source>
          <target state="translated">검색 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="df08275a2c09a868605d7342becb61e11202ec4a" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;recursiveEncoded&lt;/code&gt; and &lt;code&gt;recursiveDecoded&lt;/code&gt; are alerted as follows:</source>
          <target state="translated">&lt;code&gt;recursiveEncoded&lt;/code&gt; 및 &lt;code&gt;recursiveDecoded&lt;/code&gt; 의 값은 다음과 같이 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="19e0e1cb47a895c4adce508484a0fbdad4d1c662" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;shallowEncoded&lt;/code&gt; and &lt;code&gt;shallowDecoded&lt;/code&gt; are alerted as follows:</source>
          <target state="translated">&lt;code&gt;shallowEncoded&lt;/code&gt; 및 &lt;code&gt;shallowDecoded&lt;/code&gt; 의 값은 다음과 같이 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="56a99608838cb4e83a0ff0bacdd7885d4ca584ef" translate="yes" xml:space="preserve">
          <source>The variation you choose is generally a matter of style or convenience.</source>
          <target state="translated">선택하는 변형은 일반적으로 스타일 또는 편의의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="98b4a5d36b3f75dae7b5b98ef86f8721c4b2115f" translate="yes" xml:space="preserve">
          <source>The vertical scroll position is the same as the number of pixels that are hidden from view above the scrollable area. If the scroll bar is at the very top, or if the element is not scrollable, this number will be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">세로 스크롤 위치는 스크롤 가능 영역 위의보기에서 숨겨지는 픽셀 수와 동일합니다. 스크롤 막대가 맨 위에 오거나 요소를 스크롤 할 수없는 경우이 숫자는 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="502041741bb29d2d0ce2d7cb3f9f058410872bd0" translate="yes" xml:space="preserve">
          <source>The vertical scroll position is the same as the number of pixels that are hidden from view above the scrollable area. Setting the &lt;code&gt;scrollTop&lt;/code&gt; positions the vertical scroll of each matched element.</source>
          <target state="translated">세로 스크롤 위치는 스크롤 가능 영역 위의보기에서 숨겨지는 픽셀 수와 동일합니다. &lt;code&gt;scrollTop&lt;/code&gt; 을 설정하면 일치하는 각 요소의 세로 스크롤이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="68009f554546520daab11a31781a53314e2258bf" translate="yes" xml:space="preserve">
          <source>Their width and height are explicitly set to 0.</source>
          <target state="translated">너비와 높이는 명시 적으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="51a6b9ab62274f73e087c9eaa4c7881cd846e98d" translate="yes" xml:space="preserve">
          <source>Thenable</source>
          <target state="translated">Thenable</target>
        </trans-unit>
        <trans-unit id="bba170ab9f1988f7e0b5177b2872e6c65a73fd8b" translate="yes" xml:space="preserve">
          <source>There are lot of plugins that leverage jQuery's selectors in other ways. The validation plugin accepts a selector to specify a dependency, whether an input is required or not:</source>
          <target state="translated">jQuery의 선택기를 다른 방식으로 활용하는 플러그인이 많이 있습니다. 유효성 검사 플러그인은 입력이 필요한지 여부에 관계없이 선택기를 수락하여 종속성을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2ce0d5f676018adf414ee9fb049b9a0ccdf3b569" translate="yes" xml:space="preserve">
          <source>There are shorthand methods for some events such as &lt;a href=&quot;click&quot;&gt;&lt;code&gt;.click()&lt;/code&gt;&lt;/a&gt; that can be used to attach or trigger event handlers. For a complete list of shorthand methods, see the &lt;a href=&quot;category/events&quot;&gt;events category&lt;/a&gt;.</source>
          <target state="translated">이벤트 핸들러를 첨부하거나 트리거하는 데 사용할 수있는 &lt;a href=&quot;click&quot;&gt; &lt;code&gt;.click()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 이벤트에는 간단한 메소드 가 있습니다. 속기 방법의 전체 목록은 &lt;a href=&quot;category/events&quot;&gt;events 카테고리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0b6fda1d75631a26b3fa9aabdbc4d04428691220" translate="yes" xml:space="preserve">
          <source>There are shorthand methods for some standard browser events such as &lt;a href=&quot;click&quot;&gt;&lt;code&gt;.click()&lt;/code&gt;&lt;/a&gt; that can be used to attach or trigger event handlers. For a complete list of shorthand methods, see the &lt;a href=&quot;category/events&quot;&gt;events category&lt;/a&gt;.</source>
          <target state="translated">이벤트 핸들러를 첨부하거나 트리거하는 데 사용할 수있는 &lt;a href=&quot;click&quot;&gt; &lt;code&gt;.click()&lt;/code&gt; &lt;/a&gt; 과 같은 일부 표준 브라우저 이벤트에는 약식 메소드 가 있습니다. 속기 방법의 전체 목록은 &lt;a href=&quot;category/events&quot;&gt;events 카테고리를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d63711a0adcaf5fcd03bba3c3b147f0181be2820" translate="yes" xml:space="preserve">
          <source>There are two specific use cases for which jQuery.sub() was created. The first was for providing a painless way of overriding jQuery methods without completely destroying the original methods and another was for helping to do encapsulation and basic namespacing for jQuery plugins.</source>
          <target state="translated">jQuery.sub ()가 작성된 두 가지 특정 사용 사례가 있습니다. 첫 번째는 원래 메서드를 완전히 파괴하지 않고 jQuery 메서드를 재정의하는 고통없는 방법을 제공하는 것이고 다른 하나는 jQuery 플러그인에 대한 캡슐화 및 기본 네임 스페이스 작성을 돕는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f92882ffa32ba59639260af20d453135f132e2a1" translate="yes" xml:space="preserve">
          <source>There are two types of events:</source>
          <target state="translated">두 가지 유형의 이벤트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d166c8f570311888ce1e4d2c5d8012b91e58818d" translate="yes" xml:space="preserve">
          <source>There is also &lt;code&gt;$(document).on( &quot;ready&quot;, handler )&lt;/code&gt;, &lt;em&gt;deprecated as of jQuery 1.8 and removed in jQuery 3.0&lt;/em&gt;. Note that if the DOM becomes ready before this event is attached, the handler &lt;em&gt;will not be executed&lt;/em&gt;.</source>
          <target state="translated">또한이 &lt;code&gt;$(document).on( &quot;ready&quot;, handler )&lt;/code&gt; , &lt;em&gt;jQuery를 1.8으로 사용되지 않으며 jQuery를 3.0에서 제거는&lt;/em&gt; . 이 이벤트가 첨부되기 전에 DOM이 준비되면 핸들러 &lt;em&gt;가 실행되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b2adf959188684f5fb25abf351d01408eb8540a8" translate="yes" xml:space="preserve">
          <source>These are callbacks that you can subscribe to within the Ajax request object, like so:</source>
          <target state="translated">다음과 같이 Ajax 요청 객체 내에서 구독 할 수있는 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="3bb9908eefdc7f5d52352839085856ff586bef42" translate="yes" xml:space="preserve">
          <source>These can be added as callbacks to a &lt;code&gt;$.Callbacks&lt;/code&gt; list and invoked as follows:</source>
          <target state="translated">이것들은 &lt;code&gt;$.Callbacks&lt;/code&gt; 리스트에 콜백으로 추가 되고 다음과 같이 호출 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f3045922e3813d89836a97e9e2f7086202e8607c" translate="yes" xml:space="preserve">
          <source>These events are triggered on the &lt;code&gt;document&lt;/code&gt;, calling any handlers which may be listening. You can listen for these events like so:</source>
          <target state="translated">이러한 이벤트는 &lt;code&gt;document&lt;/code&gt; 에서 트리거되어 수신 대기중인 핸들러를 호출합니다. 다음과 같은 이벤트를들을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e88bd0cd93766cee13f54b1e8fa0d73ba477db4" translate="yes" xml:space="preserve">
          <source>These functions assist with common idioms encountered when performing Ajax tasks.</source>
          <target state="translated">이 기능은 Ajax 작업을 수행 할 때 발생하는 일반적인 관용구를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="bbe40564276f220415e365fe124b886a4b1abcfa" translate="yes" xml:space="preserve">
          <source>These methods adjust the opacity of elements.</source>
          <target state="translated">이 방법은 요소의 불투명도를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="a5dceab1cd6454e730b2a57d9f7b0169f076d3c5" translate="yes" xml:space="preserve">
          <source>These methods allow us to associate arbitrary data with specific DOM elements.</source>
          <target state="translated">이러한 메소드를 사용하면 임의의 데이터를 특정 DOM 요소와 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4066f49a0950cecd91b201b26d1de51efbe9229a" translate="yes" xml:space="preserve">
          <source>These methods allow us to delete elements from the DOM.</source>
          <target state="translated">이러한 메소드를 통해 DOM에서 요소를 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83101d88ab9c3dabba90bc0af8ad464da3b6ec6d" translate="yes" xml:space="preserve">
          <source>These methods allow us to insert new content inside an existing element.</source>
          <target state="translated">이러한 방법을 통해 기존 요소 내에 새로운 내용을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f267e40060626a06189c0c1eee775807f476e368" translate="yes" xml:space="preserve">
          <source>These methods allow us to insert new content outside an existing element.</source>
          <target state="translated">이러한 방법을 통해 기존 요소 외부에 새 컨텐츠를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f29086c3aa4bd1a27da2e9e184fe031e4bfd5a02" translate="yes" xml:space="preserve">
          <source>These methods allow us to insert new content surrounding existing content.</source>
          <target state="translated">이러한 방법을 통해 기존 컨텐츠를 둘러싼 새로운 컨텐츠를 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc604750ce03230768923f16f804981342c1e94d" translate="yes" xml:space="preserve">
          <source>These methods allow you to create effects that are not provided &quot;out of the box&quot; by jQuery.</source>
          <target state="translated">이 메소드를 사용하면 jQuery에서 &quot;즉시&quot;제공하지 않는 효과를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0625f6d74b36be39a6d19f27d45b0219d041a46" translate="yes" xml:space="preserve">
          <source>These methods and event handlers handle forms and their various elements.</source>
          <target state="translated">이 메소드와 이벤트 핸들러는 양식과 다양한 요소를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="18b8674db3e233679cba9aa8c56ce17e71105fda" translate="yes" xml:space="preserve">
          <source>These methods are used to get and set the CSS dimensions for the various properties.</source>
          <target state="translated">이 메소드는 다양한 속성의 CSS 크기를 가져오고 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="21d116605cbd8c6c5ab76a3a490e960c52c3b187" translate="yes" xml:space="preserve">
          <source>These methods are used to register behaviors to take effect when the user interacts with the browser, and to further manipulate those registered behaviors.</source>
          <target state="translated">이러한 방법은 사용자가 브라우저와 상호 작용할 때 적용되는 비헤이비어를 등록하고 등록 된 비헤이비어를 추가로 조작하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e156b975a013e00c555b91859d1720dc0cebe05" translate="yes" xml:space="preserve">
          <source>These methods are used to remove content from the DOM and replace it with new content.</source>
          <target state="translated">이 메소드는 DOM에서 컨텐츠를 제거하고 새 컨텐츠로 바꾸는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="76059f80300cb0ffdcfcb66416bfc17f849566e5" translate="yes" xml:space="preserve">
          <source>These methods can be used to make arbitrary Ajax requests.</source>
          <target state="translated">이 메소드는 임의의 Ajax 요청을 작성하는 데 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1001d40d2d517229663551d85a88e9dba991d4" translate="yes" xml:space="preserve">
          <source>These methods get and set CSS-related properties of elements.</source>
          <target state="translated">이 메소드는 요소의 CSS 관련 특성을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="1f1b0bb6f70a2eb3ccb85e1859247cdd66807aa2" translate="yes" xml:space="preserve">
          <source>These methods get and set DOM attributes of elements</source>
          <target state="translated">이 메소드는 요소의 DOM 속성을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="4b24afb95d5db312e3e6e541dcda0c7a8cbc8e06" translate="yes" xml:space="preserve">
          <source>These methods get and set DOM attributes of elements.</source>
          <target state="translated">이 메소드는 요소의 DOM 속성을 가져오고 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8c704e4ccc42f4db139bb3dcca8c837ee5ce4c92" translate="yes" xml:space="preserve">
          <source>These methods inspect and manipulate the CSS classes assigned to elements.</source>
          <target state="translated">이 메소드는 요소에 지정된 CSS 클래스를 검사하고 조작합니다.</target>
        </trans-unit>
        <trans-unit id="1af509504d5f4d97c437b425452c5adcf074987f" translate="yes" xml:space="preserve">
          <source>These methods perform the more common types of Ajax requests in less code.</source>
          <target state="translated">이러한 메소드는보다 일반적인 코드 유형의 Ajax 요청을 적은 코드로 수행합니다.</target>
        </trans-unit>
        <trans-unit id="152784201cd6ea8db24c609aade9c011ad0e3811" translate="yes" xml:space="preserve">
          <source>These methods register handlers to be called when certain events, such as initialization or completion, take place for any Ajax request on the page. The global events are fired on each Ajax request if the &lt;code&gt;global&lt;/code&gt; property in &lt;a href=&quot;../../jquery.ajaxsetup&quot;&gt;&lt;code&gt;jQuery.ajaxSetup()&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, which it is by default. &lt;em&gt;Note: Global events are never fired for cross-domain script or JSONP requests, regardless of the value of &lt;code&gt;global&lt;/code&gt;.&lt;/em&gt;</source>
          <target state="translated">이러한 메소드는 페이지에서 Ajax 요청에 대해 초기화 또는 완료와 같은 특정 이벤트가 발생할 때 호출 될 핸들러를 등록합니다. &lt;a href=&quot;../../jquery.ajaxsetup&quot;&gt; &lt;code&gt;jQuery.ajaxSetup()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;global&lt;/code&gt; 속성 이 &lt;code&gt;true&lt;/code&gt; 인 경우 전역 이벤트는 각 Ajax 요청 에서 시작 됩니다 (기본적으로). &lt;em&gt;참고 : 글로벌 이벤트의 값에 관계없이, 크로스 도메인 스크립트 또는 JSONP 요청을 해고되지 않습니다 &lt;/em&gt;&lt;em&gt; &lt;code&gt;global&lt;/code&gt; &lt;/em&gt;&lt;em&gt; .&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3e286a3fadf3605299e908d967349e6755901ddd" translate="yes" xml:space="preserve">
          <source>These properties are associated with the global jQuery object.</source>
          <target state="translated">이러한 속성은 글로벌 jQuery 객체와 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="646e8206dbfc5befa834843d4e6c16f08a90de6b" translate="yes" xml:space="preserve">
          <source>They are form elements with &lt;code&gt;type=&quot;hidden&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type=&quot;hidden&quot;&lt;/code&gt; 양식 요소입니다. .</target>
        </trans-unit>
        <trans-unit id="6d3a2f20c508cd89d045ae0802bb6d4d4855106f" translate="yes" xml:space="preserve">
          <source>They have a CSS &lt;code&gt;display&lt;/code&gt; value of &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">CSS &lt;code&gt;display&lt;/code&gt; 값이 &lt;code&gt;none&lt;/code&gt; 입니다. 입니다.</target>
        </trans-unit>
        <trans-unit id="76e00a420ece6eeb2a7c52a9b7fe06713897dd16" translate="yes" xml:space="preserve">
          <source>This API is &lt;code&gt;deprecated&lt;/code&gt; as of jQuery 1.7 and &lt;code&gt;removed&lt;/code&gt; as of jQuery 1.8; please use &lt;a href=&quot;deferred.state&quot;&gt;&lt;code&gt;deferred.state()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 API는 jQuery 1.7부터 &lt;code&gt;deprecated&lt;/code&gt; jQuery 1.8에서 &lt;code&gt;removed&lt;/code&gt; 되었습니다. 사용하십시오 &lt;a href=&quot;deferred.state&quot;&gt; &lt;code&gt;deferred.state()&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="98f1d9eeba8b49c650019ed75b666fd267d8086c" translate="yes" xml:space="preserve">
          <source>This alteration to the code will cause the third and sixth list items to be highlighted, as it uses the modulus operator (&lt;code&gt;%&lt;/code&gt;) to select every item with an &lt;code&gt;index&lt;/code&gt; value that, when divided by 3, has a remainder of &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">이 코드를 변경하면 계수 연산자 ( &lt;code&gt;%&lt;/code&gt; )를 사용하여 3으로 나눈 나머지가 &lt;code&gt;2&lt;/code&gt; 인 &lt;code&gt;index&lt;/code&gt; 값을 가진 모든 항목을 선택 하기 때문에 세 번째 및 여섯 번째 목록 항목이 강조 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="d51b3db33fc47e6a544f2294c10f27126554ddf1" translate="yes" xml:space="preserve">
          <source>This behavior is expected. &lt;strong&gt;As of jQuery 1.9.0&lt;/strong&gt; (and unless using the &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate plugin&lt;/a&gt;), &lt;code&gt;jQuery()&lt;/code&gt; requires the HTML string to start with a &lt;code&gt;&amp;lt;&lt;/code&gt; (i.e text nodes cannot appear at the front of the HTML string).</source>
          <target state="translated">이 동작이 예상됩니다. &lt;strong&gt;jQuery 1.9.0부터&lt;/strong&gt; (및 &lt;a href=&quot;https://github.com/jquery/jquery-migrate/#readme&quot;&gt;jQuery Migrate 플러그인을&lt;/a&gt; 사용하지 않는 한 ) &lt;code&gt;jQuery()&lt;/code&gt; 는 HTML 문자열이 &lt;code&gt;&amp;lt;&lt;/code&gt; 로 시작해야합니다 (즉, 텍스트 노드는 HTML 문자열의 앞에 나타날 수 없음).</target>
        </trans-unit>
        <trans-unit id="4724d0febf83f4df758178179a0cf1d84270ce5e" translate="yes" xml:space="preserve">
          <source>This can then be used by parts of your application to publish and subscribe to events of interest quite easily:</source>
          <target state="translated">그런 다음 애플리케이션의 일부에서이를 사용하여 관심있는 이벤트를 매우 쉽게 게시하고 구독 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="759df6494bc16039dfa401cc721d60dc40be0bc2" translate="yes" xml:space="preserve">
          <source>This causes all of them to be replaced:</source>
          <target state="translated">이로 인해 모든 것이 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="1d9b72538af379ba557b38c88c4d6e1965c43267" translate="yes" xml:space="preserve">
          <source>This chain searches for items with the class &lt;code&gt;foo&lt;/code&gt; within the first list only and turns their backgrounds red. Then &lt;code&gt;end()&lt;/code&gt; returns the object to its state before the call to &lt;code&gt;find()&lt;/code&gt;, so the second &lt;code&gt;find()&lt;/code&gt; looks for '.bar' inside &lt;code&gt;&amp;lt;ul class=&quot;first&quot;&amp;gt;&lt;/code&gt;, not just inside that list's &lt;code&gt;&amp;lt;li class=&quot;foo&quot;&amp;gt;&lt;/code&gt;, and turns the matching elements' backgrounds green. The net result is that items 1 and 3 of the first list have a colored background, and none of the items from the second list do.</source>
          <target state="translated">이 체인 은 첫 번째 목록에서만 &lt;code&gt;foo&lt;/code&gt; 클래스를 가진 항목을 검색 하고 배경을 빨간색으로 바꿉니다. 그런 다음 &lt;code&gt;end()&lt;/code&gt; 는 &lt;code&gt;find()&lt;/code&gt; 호출하기 전에 객체를 상태로 반환 하므로 두 번째 &lt;code&gt;find()&lt;/code&gt; 는 목록의 &lt;code&gt;&amp;lt;li class=&quot;foo&quot;&amp;gt;&lt;/code&gt; 내부가 아닌 &lt;code&gt;&amp;lt;ul class=&quot;first&quot;&amp;gt;&lt;/code&gt; 내부에서 '.bar'를 찾습니다. foo &quot;&amp;gt; 이며 일치하는 요소의 배경을 녹색으로 바꿉니다. 결과적으로 첫 번째 목록의 항목 1과 3은 배경색이 있고 두 번째 목록의 항목은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e5434cf43bec6b10cb2d62ec811119dfe5ec76fc" translate="yes" xml:space="preserve">
          <source>This code first retrieves the contents of &lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/code&gt; and then filters it for text nodes, which are wrapped in paragraph tags. This is accomplished by testing the &lt;a href=&quot;https://developer.mozilla.org/docs/en/DOM/Node.nodeType&quot;&gt;&lt;code&gt;.nodeType&lt;/code&gt; property&lt;/a&gt; of the element. This DOM property holds a numeric code indicating the node's type; text nodes use the code 3. The contents are again filtered, this time for &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; elements, and these elements are removed.</source>
          <target state="translated">이 코드는 먼저 &lt;code&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;/code&gt; 의 내용을 검색 한 다음 단락 태그로 묶인 텍스트 노드에 대해 필터링합니다. 이는 요소 의 &lt;a href=&quot;https://developer.mozilla.org/docs/en/DOM/Node.nodeType&quot;&gt; &lt;code&gt;.nodeType&lt;/code&gt; 특성&lt;/a&gt; 을 테스트하여 수행됩니다 . 이 DOM 속성에는 노드 유형을 나타내는 숫자 코드가 있습니다. 텍스트 노드는 코드 3을 사용합니다. 이번에는 &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 요소에 대해 내용이 다시 필터링 되고 해당 요소가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="63d36dce5d277ad627544d533e1ccbe9b3be2c55" translate="yes" xml:space="preserve">
          <source>This code will alter the first list item only, as it contains exactly one &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; tag. Within the filter function, &lt;code&gt;this&lt;/code&gt; refers to each DOM element in turn. The parameter passed to the function tells us the index of that DOM element within the set matched by the jQuery object.</source>
          <target state="translated">이 코드는 정확히 하나의 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; 태그를 포함하므로 첫 번째 목록 항목 만 변경합니다 . 필터 함수 내에서, &lt;code&gt;this&lt;/code&gt; 차례로 각각의 DOM 요소를 지칭한다. 함수에 전달 된 매개 변수는 jQuery 객체와 일치하는 세트 내의 해당 DOM 요소의 색인을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="21f659be994ef4d8b978b3f4fb6ebf487ff90758" translate="yes" xml:space="preserve">
          <source>This code will cause the element with an ID of &lt;code&gt;foo&lt;/code&gt; to respond to the &lt;code&gt;click&lt;/code&gt; event. When a user clicks inside this element thereafter, the alert will be shown.</source>
          <target state="translated">이 코드는 ID가 &lt;code&gt;foo&lt;/code&gt; 인 요소가 &lt;code&gt;click&lt;/code&gt; 이벤트 에 응답하게합니다 . 그 후 사용자가이 요소를 클릭하면 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9779a0bbf174d5713472f1da50aba3ef40e7aa3a" translate="yes" xml:space="preserve">
          <source>This difference in behavior between &lt;code&gt;$( &quot;:text&quot; )&lt;/code&gt; and &lt;code&gt;$( &quot;[type=text]&quot; )&lt;/code&gt;, can be seen below:</source>
          <target state="translated">&lt;code&gt;$( &quot;:text&quot; )&lt;/code&gt; 와 &lt;code&gt;$( &quot;[type=text]&quot; )&lt;/code&gt; 동작 차이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ad2fb9697b7b6107b3b4e5ec78fe97d5dd681be" translate="yes" xml:space="preserve">
          <source>This event behaves the same as the complete event and will be triggered every time an Ajax request finishes.</source>
          <target state="translated">이 이벤트는 complete 이벤트와 동일하게 작동하며 Ajax 요청이 완료 될 때마다 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="86b7a0fb40d5a08c286f9ff0d205c5d4c063ac8a" translate="yes" xml:space="preserve">
          <source>This event is also only called if the request was successful.</source>
          <target state="translated">이 이벤트는 요청이 성공한 경우에만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6e4ad8a56d7bcd30bea7ca58205cb27a97657804" translate="yes" xml:space="preserve">
          <source>This event is available so that scripts can perform cleanup when the user leaves the page. Most browsers will ignore calls to &lt;code&gt;alert()&lt;/code&gt;, &lt;code&gt;confirm()&lt;/code&gt; and &lt;code&gt;prompt()&lt;/code&gt; inside the event handler. The string you return may be used in a confirmation dialog, but not all browsers support this. It is not possible to cancel the &lt;code&gt;unload&lt;/code&gt; event with &lt;code&gt;.preventDefault()&lt;/code&gt;.</source>
          <target state="translated">이 이벤트는 사용자가 페이지를 떠날 때 스크립트가 정리를 수행 할 수 있도록 사용 가능합니다. 대부분의 브라우저는 이벤트 핸들러 내에서 &lt;code&gt;alert()&lt;/code&gt; , &lt;code&gt;confirm()&lt;/code&gt; 및 &lt;code&gt;prompt()&lt;/code&gt; 호출을 무시 합니다. 반환하는 문자열은 확인 대화 상자에서 사용될 수 있지만 모든 브라우저가이를 지원하지는 않습니다. &lt;code&gt;.preventDefault()&lt;/code&gt; &lt;code&gt;unload&lt;/code&gt; 이벤트 를 취소 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d2bef78d980d6837983d17a683822d89d8fd86d9" translate="yes" xml:space="preserve">
          <source>This event is called regardless of if the request was successful, or not. You will always receive a complete callback, even for synchronous requests.</source>
          <target state="translated">이 이벤트는 요청의 성공 여부에 관계없이 호출됩니다. 동기 요청의 경우에도 항상 완전한 콜백을받습니다.</target>
        </trans-unit>
        <trans-unit id="bc5a1a9dcb7987f22cab7aa53e522431522d89c3" translate="yes" xml:space="preserve">
          <source>This event is only called if an error occurred with the request (you can never have both an error and a success callback with a request).</source>
          <target state="translated">이 이벤트는 요청에서 오류가 발생한 경우에만 호출됩니다 (요청으로 오류 및 성공 콜백을 모두 가질 수 없음).</target>
        </trans-unit>
        <trans-unit id="afae7d93c59f37ce631ca4f57c312d014cc82583" translate="yes" xml:space="preserve">
          <source>This event is only called if the request was successful (no errors from the server, no errors with the data).</source>
          <target state="translated">이 이벤트는 요청이 성공한 경우에만 호출됩니다 (서버에서 오류가없고 데이터에 오류가 없음).</target>
        </trans-unit>
        <trans-unit id="48bbba3ab6f8d076f052cc031a6e20283275fed7" translate="yes" xml:space="preserve">
          <source>This event is primarily useful for ensuring that the primary button was used to begin a drag operation; if ignored, strange results can occur when the user attempts to use a context menu. While the middle and right buttons can be detected with these properties, this is not reliable. In Opera and Safari, for example, right mouse button clicks are not detectable by default.</source>
          <target state="translated">이 이벤트는 주로 기본 버튼을 사용하여 드래그 작업을 시작하는 데 유용합니다. 무시하면 사용자가 상황에 맞는 메뉴를 사용하려고 할 때 이상한 결과가 발생할 수 있습니다. 이러한 속성으로 가운데 및 오른쪽 버튼을 감지 할 수 있지만 이는 신뢰할 수 없습니다. 예를 들어 Opera 및 Safari에서는 기본적으로 마우스 오른쪽 버튼 클릭을 감지 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="683d1abf76fd5c3a88d0f22a26284cfa337c9fee" translate="yes" xml:space="preserve">
          <source>This event is triggered if an Ajax request is started and no other Ajax requests are currently running.</source>
          <target state="translated">이 이벤트는 Ajax 요청이 시작되고 현재 실행중인 다른 Ajax 요청이없는 경우 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="ac253698b4acfcb5905a2aa79e449ffacacdffda" translate="yes" xml:space="preserve">
          <source>This event method is described in the &lt;a href=&quot;https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/events.html#Events-Event-isPropagationStopped&quot;&gt;W3C DOM Level 3 specification&lt;/a&gt;.</source>
          <target state="translated">이 이벤트 방법은 &lt;a href=&quot;https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/events.html#Events-Event-isPropagationStopped&quot;&gt;W3C DOM Level 3 사양에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="69465beb0b30a5a3694e6ad878fdce06864dca13" translate="yes" xml:space="preserve">
          <source>This event type can cause many headaches due to event bubbling. For instance, when the mouse pointer moves out of the</source>
          <target state="translated">이 이벤트 유형은 이벤트 버블 링으로 인해 많은 두통을 유발할 수 있습니다. 예를 들어, 마우스 포인터가</target>
        </trans-unit>
        <trans-unit id="db381105282fc06aa6e1dc99496275fd5171657d" translate="yes" xml:space="preserve">
          <source>This event type can cause many headaches due to event bubbling. For instance, when the mouse pointer moves over the</source>
          <target state="translated">이 이벤트 유형은 이벤트 버블 링으로 인해 많은 두통을 유발할 수 있습니다. 예를 들어 마우스 포인터가</target>
        </trans-unit>
        <trans-unit id="dc4d6bfc67551f643882201c85a8addaea0b978f" translate="yes" xml:space="preserve">
          <source>This event will likely be used together with the &lt;a href=&quot;focusin&quot;&gt;focusin&lt;/a&gt; event.</source>
          <target state="translated">이 이벤트는 &lt;a href=&quot;focusin&quot;&gt;focusin&lt;/a&gt; 이벤트 와 함께 사용될 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f361a07dcfc38de754ec576d34637ea20d8dd245" translate="yes" xml:space="preserve">
          <source>This event will likely be used together with the &lt;a href=&quot;focusout&quot;&gt;focusout&lt;/a&gt; event.</source>
          <target state="translated">이 이벤트는 &lt;a href=&quot;focusout&quot;&gt;포커스 아웃&lt;/a&gt; 이벤트 와 함께 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b981a320ef7be0421529dedac14943e840100a6a" translate="yes" xml:space="preserve">
          <source>This event, which is triggered before an Ajax request is started, allows you to modify the XMLHttpRequest object (setting additional headers, if need be.)</source>
          <target state="translated">Ajax 요청이 시작되기 전에 트리거되는이 이벤트를 사용하면 XMLHttpRequest 객체를 수정할 수 있습니다 (필요한 경우 추가 헤더 설정).</target>
        </trans-unit>
        <trans-unit id="649a216d21a666f54f90151e9ba0e11a69914df4" translate="yes" xml:space="preserve">
          <source>This example causes elements to be hidden with a sliding animation when clicked. Because the handler receives the clicked item in the &lt;code&gt;this&lt;/code&gt; keyword as a bare DOM element, the element must be passed to the &lt;code&gt;$()&lt;/code&gt; function before applying jQuery methods to it.</source>
          <target state="translated">이 예제에서는 요소를 클릭하면 슬라이딩 애니메이션으로 숨겨집니다. 핸들러는 &lt;code&gt;this&lt;/code&gt; 키워드 에서 클릭 된 항목을 Bare DOM 요소로 수신하므로 jQuery 메소드를 적용하기 전에 &lt;code&gt;$()&lt;/code&gt; 함수에 요소를 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="a7fd0c4dc67ac419ff430abce7fa9695943e63d3" translate="yes" xml:space="preserve">
          <source>This example demonstrates that the selected element replaces the target by being moved from its old location, not by being cloned.</source>
          <target state="translated">이 예제는 선택한 요소가 복제되지 않고 이전 위치에서 이동하여 대상을 대체 함을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="63bb26e5bf5293094a86ba3a3d38220ddafd7b42" translate="yes" xml:space="preserve">
          <source>This example fetches the requested HTML snippet and inserts it on the page.</source>
          <target state="translated">이 예제는 요청 된 HTML 스 니펫을 가져 와서 페이지에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="e966acc2b9894ee5016653b5a8190f3e9cb6a381" translate="yes" xml:space="preserve">
          <source>This example inserts a &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; after each paragraph, with each new &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; containing the class name(s) of its preceding paragraph.</source>
          <target state="translated">이 예에서는 각 단락 뒤에 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 를 삽입하고 각 새 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 는 이전 단락의 클래스 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1031242a2fd44b0cc801511ac728f2d8b61935d3" translate="yes" xml:space="preserve">
          <source>This example removes leading and trailing whitespace from the values of text inputs with a &quot;tags&quot; class.</source>
          <target state="translated">이 예에서는 &quot;tags&quot;클래스가있는 텍스트 입력 값에서 선행 및 후행 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="5ebd20fb5abf5bd7afa36f2ff3c0dfa8a59e2351" translate="yes" xml:space="preserve">
          <source>This example removes the class name of the penultimate &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; from the last &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 예는 끝에서 두 번째의 클래스 이름 제거 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 마지막에서 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c27e778fa0bccd68397de1040064cb8b4a36924" translate="yes" xml:space="preserve">
          <source>This example sets the widths of the matched elements to incrementally larger values.</source>
          <target state="translated">이 예에서는 일치하는 요소의 너비를 점차적으로 큰 값으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="da29dc6937adf3fba6bebcf394120d5ad06ad979" translate="yes" xml:space="preserve">
          <source>This example will toggle the &lt;code&gt;happy&lt;/code&gt; class for &lt;code&gt;&amp;lt;div class=&quot;foo&quot;&amp;gt;&lt;/code&gt; elements if their parent element has a class of &lt;code&gt;bar&lt;/code&gt;; otherwise, it will toggle the &lt;code&gt;sad&lt;/code&gt; class.</source>
          <target state="translated">이 예제는 부모 요소에 &lt;code&gt;bar&lt;/code&gt; 클래스가있는 경우 &lt;code&gt;&amp;lt;div class=&quot;foo&quot;&amp;gt;&lt;/code&gt; 요소에 대해 &lt;code&gt;happy&lt;/code&gt; 클래스를 토글합니다 . 그렇지 않으면 &lt;code&gt;sad&lt;/code&gt; 클래스를 토글합니다 .</target>
        </trans-unit>
        <trans-unit id="d9c3c9f7cf4f3c5da5a6ac47e18ae304f904858d" translate="yes" xml:space="preserve">
          <source>This example, of course, relies on the structure of the JSON file:</source>
          <target state="translated">물론이 예제는 JSON 파일의 구조에 의존합니다.</target>
        </trans-unit>
        <trans-unit id="a6c772a7fd8f0bccb3ffa2b41a260d712d32edc5" translate="yes" xml:space="preserve">
          <source>This example, using no options, loads the contents of the current page, but does nothing with the result. To use the result, you can implement one of the callback functions.</source>
          <target state="translated">이 예제는 옵션을 사용하지 않고 현재 페이지의 내용을로드하지만 결과와는 아무런 관련이 없습니다. 결과를 사용하기 위해 콜백 함수 중 하나를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fad7424a11380e496109bffc09072049878d17ef" translate="yes" xml:space="preserve">
          <source>This extra object is necessary because the response Content-Types and data types never have a strict one-to-one correspondence (hence the regular expression).</source>
          <target state="translated">응답 Content-Type 및 데이터 유형이 엄격한 일대일 대응을 갖지 않기 때문에이 추가 오브젝트가 필요합니다 (따라서 정규 표현식).</target>
        </trans-unit>
        <trans-unit id="36c0eb7eb7be94f02195c75311b38633e1e5f915" translate="yes" xml:space="preserve">
          <source>This feature is similar to providing a callback function with an animation method, but does not require the callback to be given at the time the animation is performed.</source>
          <target state="translated">이 기능은 애니메이션 방법으로 콜백 기능을 제공하는 것과 유사하지만 애니메이션을 수행 할 때 콜백을 제공 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a7aff5a0e4a3efea14d5040037b7f596cdecddc" translate="yes" xml:space="preserve">
          <source>This function behaves just like &lt;code&gt;$( document ).ready()&lt;/code&gt;, in that it should be used to wrap other &lt;code&gt;$()&lt;/code&gt; operations on your page that depend on the DOM being ready. While this function is, technically, chainable, there really isn't much use for chaining against it.</source>
          <target state="translated">이 함수는 &lt;code&gt;$( document ).ready()&lt;/code&gt; 와 동일하게 작동하며 준비중인 DOM에 따라 페이지에서 다른 &lt;code&gt;$()&lt;/code&gt; 작업 을 래핑하는 데 사용해야합니다 . 이 기능은 기술적으로 체인 가능하지만 실제로는 체인에 많이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab860837486fd3491fc07a9d2477348f5eeffea1" translate="yes" xml:space="preserve">
          <source>This function can also be overwritten in order to bypass certain edge case issues. The default &lt;code&gt;htmlPrefilter&lt;/code&gt; function in jQuery leaves input unmodified since 3.5.0. Older versions would greedily ensure that all tags were XHTML-compliant. This included anything that looked like an HTML tag, but was actually within a string (e.g. &lt;code&gt;&amp;lt;a title=&quot;&amp;lt;div /&amp;gt;&quot;&amp;gt;&amp;lt;&amp;gt;&lt;/code&gt;), leading to potential security issues. For more information, see the &lt;a href=&quot;https://jquery.com/upgrade-guide/3.5/&quot;&gt;jQuery Core 3.5 Upgrade guide&lt;/a&gt;.</source>
          <target state="translated">특정 엣지 케이스 문제를 우회하기 위해이 함수를 덮어 쓸 수도 있습니다. jQuery 의 기본 &lt;code&gt;htmlPrefilter&lt;/code&gt; 함수는 3.5.0 이후 입력을 수정하지 않은 상태로 둡니다. 이전 버전은 모든 태그가 XHTML과 호환되도록 욕심이 많았습니다. 여기에는 HTML 태그처럼 보이지만 실제로는 문자열 (예 : &lt;code&gt;&amp;lt;a title=&quot;&amp;lt;div /&amp;gt;&quot;&amp;gt;&amp;lt;&amp;gt;&lt;/code&gt; ) 내에있는 모든 것이 포함되어 잠재적 인 보안 문제가 발생했습니다. 자세한 내용은 &lt;a href=&quot;https://jquery.com/upgrade-guide/3.5/&quot;&gt;jQuery Core 3.5 업그레이드 가이드를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="b46b4646df466700b53a938d86b6af892cceff75" translate="yes" xml:space="preserve">
          <source>This function can also be overwritten in order to bypass certain edge case issues. The default &lt;code&gt;htmlPrefilter&lt;/code&gt; function in jQuery will greedily ensure that all tags are XHTML-compliant. This includes anything that looks like an HTML tag, but is actually within a string (e.g.</source>
          <target state="translated">특정한 경우를 우회하기 위해이 기능을 덮어 쓸 수도 있습니다. jQuery 의 기본 &lt;code&gt;htmlPrefilter&lt;/code&gt; 함수는 모든 태그가 XHTML과 호환되도록 쾌적 하게 보장합니다. 여기에는 HTML 태그처럼 보이지만 실제로는 문자열 내에있는 모든 것이 포함됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="8c4ef947f6f8032dee19f1cbd99e7e0445c77b07" translate="yes" xml:space="preserve">
          <source>This function is used internally to convert form element values into a serialized string representation (See &lt;a href=&quot;serialize&quot;&gt;.serialize()&lt;/a&gt; for more information).</source>
          <target state="translated">이 함수는 양식 요소 값을 직렬화 된 문자열 표현으로 변환하는 데 내부적으로 사용됩니다 (자세한 내용은 &lt;a href=&quot;serialize&quot;&gt;.serialize ()&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="f453c13c3e0328f2dfba47020639f6aaa2044325" translate="yes" xml:space="preserve">
          <source>This global event behaves the same as the local error event.</source>
          <target state="translated">이 전역 이벤트는 로컬 오류 이벤트와 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="97d93efb8c0c02bc751d2f0c9c622fbf4ecc7ac0" translate="yes" xml:space="preserve">
          <source>This global event is also triggered before the request is run.</source>
          <target state="translated">이 글로벌 이벤트는 요청이 실행되기 전에 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="655d42a2d71779ddaf2a047b8bc2718ffee0c8b2" translate="yes" xml:space="preserve">
          <source>This global event is triggered if there are no more Ajax requests being processed.</source>
          <target state="translated">처리중인 Ajax 요청이 더 이상 없으면이 글로벌 이벤트가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="2f4d3cd0607d268ab25fdd9533e70fde597ea7b3" translate="yes" xml:space="preserve">
          <source>This indicates that the method doesn't only expect an array as the argument, but also specifies the expected type. The notation is borrowed from Java 5's generics notation (or C++ templates).</source>
          <target state="translated">이는 메소드가 배열을 인수로 예상 할뿐만 아니라 예상되는 유형도 지정 함을 나타냅니다. 이 표기법은 Java 5의 제네릭 표기법 (또는 C ++ 템플릿)에서 빌 렸습니다.</target>
        </trans-unit>
        <trans-unit id="690aa83531b52434d818b32c2f03950ce6592a66" translate="yes" xml:space="preserve">
          <source>This is a playground to see how the selector works with different strings.</source>
          <target state="translated">셀렉터가 다른 문자열로 작동하는 방식을 볼 수있는 놀이터입니다.</target>
        </trans-unit>
        <trans-unit id="82bfa1ac349f897daa07f3e0c0d021d6694748b9" translate="yes" xml:space="preserve">
          <source>This is a playground to see how the selector works with different strings. Notice that this is different from the :even and :odd which have no regard for parent and just filter the list of elements to every other one. The :nth-child, however, counts the index of the child to its particular parent. In any case, it's easier to see than explain so...</source>
          <target state="translated">셀렉터가 다른 문자열로 작동하는 방식을 볼 수있는 놀이터입니다. 이것은 부모를 고려하지 않고 다른 모든 요소로 요소 목록을 필터링하는 : even 및 : odd와 다릅니다. 그러나 : nth-child는 자식의 인덱스를 특정 부모로 계산합니다. 어쨌든 설명하는 것보다 보는 것이 더 쉽습니다 ...</target>
        </trans-unit>
        <trans-unit id="43d06d5d256cc91fbf210ed9e483af8fa7cb9e74" translate="yes" xml:space="preserve">
          <source>This is a playground to see how the selector works with different strings. Notice that this is different from the &lt;a href=&quot;even&quot;&gt;&lt;code&gt;even&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;odd&quot;&gt;&lt;code&gt;odd&lt;/code&gt;&lt;/a&gt; which have no regard for parent and just filter the list of elements to every other one. The :nth-child, however, counts the index of the child to its particular parent. In any case, it's easier to see than explain so...</source>
          <target state="translated">선택기가 다른 문자열에서 어떻게 작동하는지 볼 수있는 놀이터입니다. 공지 이것은 상이한 것을 &lt;a href=&quot;even&quot;&gt; &lt;code&gt;even&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;odd&quot;&gt; &lt;code&gt;odd&lt;/code&gt; &lt;/a&gt; 부모에 대한 고려가 없으며 단지 모든 다른 하나 요소의 목록을 필터링. 그러나 : nth-child는 특정 부모에 대한 자식의 인덱스를 계산합니다. 어쨌든 설명하는 것보다보기 쉽기 때문에 ...</target>
        </trans-unit>
        <trans-unit id="be73f0898db1025d1eedc1b55421499324460238" translate="yes" xml:space="preserve">
          <source>This is a shorthand Ajax function, which is equivalent to:</source>
          <target state="translated">이것은 짧은 Ajax 함수이며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e864657858a9303070a1658a53bf25dbea41192a" translate="yes" xml:space="preserve">
          <source>This is the full list of Ajax events, and in the order in which they are triggered. The indented events are triggered for each and every Ajax request (unless a global option has been set). The ajaxStart and ajaxStop events are events that relate to all Ajax requests together.</source>
          <target state="translated">Ajax 이벤트의 전체 목록과 트리거 된 순서입니다. 들여 쓰기 된 이벤트는 모든 Ajax 요청마다 트리거됩니다 (글로벌 옵션이 설정되지 않은 경우). ajaxStart 및 ajaxStop 이벤트는 모든 Ajax 요청과 관련된 이벤트입니다.</target>
        </trans-unit>
        <trans-unit id="75a40fffbd7637ae6cad737c5a222f44e502a6d4" translate="yes" xml:space="preserve">
          <source>This is the inverse of &lt;code&gt;:empty&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;:empty&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="1afd13e46be54f353d75a53266cc19dfc2f2a79e" translate="yes" xml:space="preserve">
          <source>This is the inverse of &lt;code&gt;:parent&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;:parent&lt;/code&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="f6a24b37da84f50293523975f12e3e02b00fdf99" translate="yes" xml:space="preserve">
          <source>This is the most generous of the jQuery attribute selectors that match against a value. It will select an element if the selector's string appears anywhere within the element's attribute value. Compare this selector with the Attribute Contains Word selector (e.g. [attr~=&quot;word&quot;]), which is more appropriate in many cases.</source>
          <target state="translated">이것은 값과 일치하는 가장 jQuery 속성 선택기입니다. 선택기의 문자열이 요소의 속성 값 내에 있으면 요소를 선택합니다. 이 선택기를 단어 포함 속성 선택기 (예 : [attr ~ = &quot;word&quot;])와 비교하십시오. 이는 많은 경우에 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="d9da68639be63e4e887067e82cda70e44e59b905" translate="yes" xml:space="preserve">
          <source>This is used in a number of places in jQuery to determine if we're operating against a browser window (such as the current window or an iframe).</source>
          <target state="translated">이것은 jQuery의 여러 곳에서 사용되어 브라우저 창 (예 : 현재 창 또는 iframe)에 대해 작동하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="f08b6ce82deda11c3f60b7deafa153420ae2161b" translate="yes" xml:space="preserve">
          <source>This is useful for plugin authors who offer optional callbacks; in the case that no callback is given, something like &lt;code&gt;jQuery.noop&lt;/code&gt; could execute.</source>
          <target state="translated">이것은 선택적 콜백을 제공하는 플러그인 작성자에게 유용합니다. 콜백이 제공되지 않은 경우 &lt;code&gt;jQuery.noop&lt;/code&gt; 과 같은 것이 실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d812d14581ba0c1674dc38a60217df13c4f84f" translate="yes" xml:space="preserve">
          <source>This is usually the desired sequence before taking an action. If this is not required, the &lt;code&gt;mousedown&lt;/code&gt; or &lt;code&gt;mouseup&lt;/code&gt; event may be more suitable.</source>
          <target state="translated">이것은 일반적으로 조치를 취하기 전에 원하는 순서입니다. 이것이 필요하지 않은 경우 &lt;code&gt;mousedown&lt;/code&gt; 또는 &lt;code&gt;mouseup&lt;/code&gt; 이벤트가 더 적합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c3d57f2d941e7b5d42230477fec9cf8433d9503" translate="yes" xml:space="preserve">
          <source>This method behaves differently from using a normal JavaScript &lt;code&gt;eval()&lt;/code&gt; in that it's executed within the global context (which is important for loading external scripts dynamically).</source>
          <target state="translated">이 메소드 는 전역 컨텍스트 내에서 실행된다는 점에서 일반적인 JavaScript &lt;code&gt;eval()&lt;/code&gt; 을 사용하는 것과 다르게 작동합니다 ( 외부 스크립트를 동적으로로드하는 데 중요 함).</target>
        </trans-unit>
        <trans-unit id="7055b8d61d1b481dd833dfd2669a99e44ee927e0" translate="yes" xml:space="preserve">
          <source>This method can act on a jQuery object that has selected individual form controls, such as &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;. However, it is typically easier to select the &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; element itself for serialization:</source>
          <target state="translated">이 메소드는 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt; 와 같은 개별 양식 컨트롤을 선택한 jQuery 객체에서 작동 할 수 있습니다 . 그러나 일반적으로 직렬화를 위해 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 요소 자체 를 선택하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="5b38d3c48bdcbca3659c53e58607a9cf7dccaf8c" translate="yes" xml:space="preserve">
          <source>This method does not accept any arguments.</source>
          <target state="translated">이 메소드는 인수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bfb451eae6e159d41053c63c7ab0de01084ab951" translate="yes" xml:space="preserve">
          <source>This method exists primarily for plugin developers who wish to override it and provide a better display (or more information) for the error messages.</source>
          <target state="translated">이 메소드는 주로이를 대체하고 오류 메시지에 대해 더 나은 표시 (또는 더 많은 정보)를 제공하려는 플러그인 개발자를 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="062bd2d7d515033788955331f2b4e1a92f7c2a23" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;blur&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;blur&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;blur&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;blur&quot;, handler )&lt;/code&gt; 의 단축키이며 세 번째 변형에서 .trigger ( &quot;blur&quot;)의 단축키 입니다.</target>
        </trans-unit>
        <trans-unit id="346692c9809684c46a877bfaa5170a427dd16e78" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;change&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;change&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 처음 두 변형의 &lt;code&gt;.trigger( &quot;change&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;change&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;change&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="a0650bd2ed2e304aeb035f14a80cc4104b12697c" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;click&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;click&quot; )&lt;/code&gt; in the third. The &lt;code&gt;click&lt;/code&gt; event is sent to an element when the mouse pointer is over the element, and the mouse button is pressed and released. Any HTML element can receive this event. For example, consider the HTML:</source>
          <target state="translated">이 메소드는 처음 두 변형의 &lt;code&gt;.trigger( &quot;click&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;click&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;click&quot;) 에 대한 바로 가기입니다 . &lt;code&gt;click&lt;/code&gt; 마우스 포인터가 요소 위에있을 때 이벤트는 요소로 전송하고, 마우스 버튼을 누를 해제됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다. 예를 들어 HTML을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0db2428740ed667f182f8512b88eb604bda1c58a" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;contextmenu&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;contextmenu&quot; )&lt;/code&gt; in the third. The &lt;code&gt;contextmenu&lt;/code&gt; event is sent to an element when the right button of the mouse is clicked on it, but before the context menu is displayed. In case the context menu key is pressed, the event is triggered on the &lt;code&gt;html&lt;/code&gt; element or the currently focused element. Any HTML element can receive this event. For example, consider the HTML:</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;contextmenu&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;contextmenu&quot;, handler )&lt;/code&gt; 에 대한 단축키이며 세 번째 변형에서 .trigger ( &quot;contextmenu&quot;) 에 대한 단축키 입니다. &lt;code&gt;contextmenu&lt;/code&gt; 이벤트는 마우스의 오른쪽 버튼이 클릭 된 요소로 전송되지만, 상황에 맞는 메뉴가 표시되기 전에. 상황에 맞는 메뉴 키를 누르면 &lt;code&gt;html&lt;/code&gt; 요소 또는 현재 포커스가있는 요소 에서 이벤트가 트리거됩니다 . 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다. 예를 들어 HTML을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e874b85d8b87e616d9b2b3e78468b8b1469b0d74" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;dblclick&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;dblclick&quot; )&lt;/code&gt; in the third. The &lt;code&gt;dblclick&lt;/code&gt; event is sent to an element when the element is double-clicked. Any HTML element can receive this event. For example, consider the HTML:</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;dblclick&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;dblclick&quot;, handler )&lt;/code&gt; 에 대한 단축키이며 세 번째 변형에서 .trigger ( &quot;dblclick&quot;) 에 대한 단축키 입니다. &lt;code&gt;dblclick&lt;/code&gt; 의 요소가 더블 클릭하면 이벤트가 요소로 전송됩니다. 모든 HTML 요소가이 이벤트를 수신 할 수 있습니다. 예를 들어 HTML을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="d13a26a73fa8a32f0b6c96afe45e01dbb8b531da" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;error&quot;, handler )&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;.on( &quot;error&quot;, handler )&lt;/code&gt; 의 단축키입니다 .</target>
        </trans-unit>
        <trans-unit id="55194cb606a3bf92352bb24a102c067fe1a4f76f" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;focus&quot;, handler )&lt;/code&gt; in the first and second variations, and &lt;code&gt;.trigger( &quot;focus&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 번째 및 두 번째 변형에서 &lt;code&gt;.trigger( &quot;focus&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;focus&quot;, handler )&lt;/code&gt; 및 세 번째 변형에서 .trigger ( &quot;focus&quot;) 의 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="a78fa95a3c99515fe9ba77f8210bf088d3ad80ab" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;focusin&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;focusin&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.on( &quot;focusin&quot;, handler )&lt;/code&gt; 및 세 번째에서는 &lt;code&gt;.trigger( &quot;focusin&quot; )&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2f404e361904d188974da0d867762f2b8f5bbf1a" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;focusout&quot;, handler )&lt;/code&gt; when passed arguments, and &lt;code&gt;.trigger( &quot;focusout&quot; )&lt;/code&gt; when no arguments are passed.</source>
          <target state="translated">이 메소드는 인수를 전달할 때 &lt;code&gt;.on( &quot;focusout&quot;, handler )&lt;/code&gt; 및 전달 된 인수가 없을 때 &lt;code&gt;.trigger( &quot;focusout&quot; )&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="41f8feb54d90484574c64e3baf7695ac56d76f6a" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;keydown&quot;, handler )&lt;/code&gt; in the first and second variations, and &lt;code&gt;.trigger( &quot;keydown&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 번째 및 두 번째 변형의 &lt;code&gt;.trigger( &quot;keydown&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;keydown&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;keydown&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="5ea90d8a612eae07733cb9a953095aece3559d80" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;keypress&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;keypress&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;keypress&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;keypress&quot;, handler )&lt;/code&gt; 에 대한 단축키이며 세 번째 변형에서 .trigger ( &quot;keypress&quot;) 에 대한 단축키 입니다.</target>
        </trans-unit>
        <trans-unit id="4829b0add7a93cf88eb293c411bb411f3ef1e117" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;keyup&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;keyup&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;keyup&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;keyup&quot;, handler )&lt;/code&gt; 에 대한 단축키이며 세 번째 변형에서 .trigger ( &quot;keyup&quot;) 에 대한 단축키 입니다.</target>
        </trans-unit>
        <trans-unit id="4f33dc4654f9529dd8f001a910b09881e9c49b82" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;load&quot;, handler )&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;.on( &quot;load&quot;, handler )&lt;/code&gt; 의 단축키입니다 .</target>
        </trans-unit>
        <trans-unit id="bd6a5b08c80b8fd5752389522a110b3d911a2b5b" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;mousedown&quot;, handler)&lt;/code&gt; in the first variation, and &lt;code&gt;.trigger( &quot;mousedown&quot; )&lt;/code&gt; in the second.</source>
          <target state="translated">이 메소드는 첫 번째 변형에서 &lt;code&gt;.trigger( &quot;mousedown&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;mousedown&quot;, handler)&lt;/code&gt; 및 두 번째 변형에서 .trigger ( &quot;mousedown&quot;)의 단축키 입니다.</target>
        </trans-unit>
        <trans-unit id="69b00c787b7cc1a27054d6f09f61eb7db1b27df3" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;mouseenter&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;mouseenter&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.on( &quot;mouseenter&quot;, handler )&lt;/code&gt; 의 단축키이며 세 번째 변형에서 &lt;code&gt;.trigger( &quot;mouseenter&quot; )&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f69e7b7e84c1d679e65f225b8bbcf922a7b63987" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;mousemove&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;mousemove&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 두 변형에서 &lt;code&gt;.trigger( &quot;mousemove&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;mousemove&quot;, handler )&lt;/code&gt; 의 단축키이며 세 번째 변형에서 .trigger ( &quot;mousemove&quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="06b06641034cabafc7c3a89771b3bfb178535b20" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;mouseout&quot;, handler )&lt;/code&gt; in the first two variation, and &lt;code&gt;.trigger( &quot;mouseout&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 방법은 처음 두 변형의 &lt;code&gt;.trigger( &quot;mouseout&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;mouseout&quot;, handler )&lt;/code&gt; 의 바로 가기이며 세 번째 변형의 .trigger ( &quot;mouseout&quot;) 입니다.</target>
        </trans-unit>
        <trans-unit id="c031239c05a4d2d7c8f7763e0c4dce22389771b5" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;mouseover&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;mouseover&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 처음 두 변형에서 &lt;code&gt;.trigger( &quot;mouseover&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;mouseover&quot;, handler )&lt;/code&gt; 의 단축키이며 세 번째 변형에서 .trigger ( &quot;mouseover&quot;)의 단축키 입니다.</target>
        </trans-unit>
        <trans-unit id="b6154672016dd082ac86d67cedc849e56ba90b30" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;scroll&quot;, handler )&lt;/code&gt; in the first and second variations, and &lt;code&gt;.trigger( &quot;scroll&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 번째 및 두 번째 변형의 &lt;code&gt;.trigger( &quot;scroll&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;scroll&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;scroll&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="5e74519010db55b24d2b383da7d044d1a8289229" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;select&quot;, handler )&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger( &quot;select&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 처음 두 변형의 &lt;code&gt;.trigger( &quot;select&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;select&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;select&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="0d345de59a7eaf1933e66da1db69440e5868a3db" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;submit&quot;, handler )&lt;/code&gt; in the first variation, and &lt;code&gt;.trigger( &quot;submit&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 번째 변형의 &lt;code&gt;.trigger( &quot;submit&quot; )&lt;/code&gt; &lt;code&gt;.on( &quot;submit&quot;, handler )&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;submit&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="1eb9dc7288639e70f49bacd03cacbfa56ac32283" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on( &quot;unload&quot;, handler )&lt;/code&gt;.</source>
          <target state="translated">이 메소드는 &lt;code&gt;.on( &quot;unload&quot;, handler )&lt;/code&gt; 의 단축키입니다 .</target>
        </trans-unit>
        <trans-unit id="52ff3678157c22780a9cfc21b02b92dddc40ff36" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on('mouseleave', handler)&lt;/code&gt; in the first two variations, and &lt;code&gt;.trigger('mouseleave')&lt;/code&gt; in the third.</source>
          <target state="translated">이 방법은 처음 두 변형에서 &lt;code&gt;.on('mouseleave', handler)&lt;/code&gt; 에 대한 바로 가기이며 세 번째 변형에서 &lt;code&gt;.trigger('mouseleave')&lt;/code&gt; 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="c26ac53ee675f9addb362831a5d3f4fa59caa27a" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on('mouseup', handler)&lt;/code&gt; in the first variation, and &lt;code&gt;.trigger('mouseup')&lt;/code&gt; in the second.</source>
          <target state="translated">이 방법은 첫 번째 변형의 &lt;code&gt;.trigger('mouseup')&lt;/code&gt; &lt;code&gt;.on('mouseup', handler)&lt;/code&gt; 및 두 번째 변형의 .trigger ( 'mouseup') 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="c808514b87bd343496959e8c779b341d866fc82f" translate="yes" xml:space="preserve">
          <source>This method is a shortcut for &lt;code&gt;.on('resize', handler)&lt;/code&gt; in the first and second variations, and &lt;code&gt;.trigger( &quot;resize&quot; )&lt;/code&gt; in the third.</source>
          <target state="translated">이 메소드는 첫 번째 및 두 번째 변형의 &lt;code&gt;.trigger( &quot;resize&quot; )&lt;/code&gt; &lt;code&gt;.on('resize', handler)&lt;/code&gt; 및 세 번째 변형의 .trigger ( &quot;resize&quot;) 에 대한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="85bb24f782fa2a4858de19ce93437e137aa3340c" translate="yes" xml:space="preserve">
          <source>This method is also able to find the height of the window and document.</source>
          <target state="translated">이 방법은 창과 문서의 높이를 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2607253a7033781c403606df4eebe156180a466" translate="yes" xml:space="preserve">
          <source>This method is also able to find the width of the window and document.</source>
          <target state="translated">이 방법은 또한 창과 문서의 너비를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec9291828724747376d950545c6d540d08e366c" translate="yes" xml:space="preserve">
          <source>This method is fired when an error is thrown synchronously in a function wrapped in &lt;code&gt;jQuery()&lt;/code&gt; or &lt;code&gt;jQuery( document ).ready()&lt;/code&gt;, or equivalent. By default it re-throws the error in a timeout so that it's logged in the console and passed to &lt;code&gt;window.onerror&lt;/code&gt; instead of being swallowed. Overwrite this method if you want to handle such errors differently.</source>
          <target state="translated">이 메소드는 &lt;code&gt;jQuery()&lt;/code&gt; 또는 &lt;code&gt;jQuery( document ).ready()&lt;/code&gt; 또는 이와 동등한 함수로 래핑 된 함수에서 동 기적으로 오류가 발생하면 시작됩니다 . 기본적으로 시간 초과로 오류를 다시 발생시켜 콘솔에 기록되어 삼키지 않고 &lt;code&gt;window.onerror&lt;/code&gt; 에 전달됩니다 . 이러한 오류를 다르게 처리하려면이 방법을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="0161551cba801aedb18b05604b3021306dc4d081" translate="yes" xml:space="preserve">
          <source>This method is meant for plugin developers who are creating new animation methods. Letting &lt;code&gt;$.speed()&lt;/code&gt; do all the parameter hockey and normalization for you, rather than duplicating the logic yourself, makes your work simpler. An example of use can be found in the animated form of &lt;code&gt;.addClass()&lt;/code&gt; of jQuery UI.</source>
          <target state="translated">이 방법은 새로운 애니메이션 방법을 만드는 플러그인 개발자를위한 것입니다. 분들께 &lt;code&gt;$.speed()&lt;/code&gt; 오히려 자신이, 작업이 간단하게 논리를 복제하는 대신, 모든 매개 변수 하키 정상화을한다. 사용 예는 jQuery UI 의 &lt;code&gt;.addClass()&lt;/code&gt; 애니메이션 형식에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be28d98cd2c7a67e6865551fa4b367a0630987b0" translate="yes" xml:space="preserve">
          <source>This method is most useful for attaching event handlers to an element where the context is pointing back to a different object. Additionally, jQuery makes sure that even if you bind the function returned from &lt;code&gt;jQuery.proxy()&lt;/code&gt; it will still unbind the correct function if passed the original.</source>
          <target state="translated">이 메소드는 컨텍스트가 다른 오브젝트를 다시 가리키는 요소에 이벤트 핸들러를 첨부 할 때 가장 유용합니다. 또한 jQuery는 &lt;code&gt;jQuery.proxy()&lt;/code&gt; 에서 반환 된 함수를 바인딩하더라도 원본을 전달한 경우에도 올바른 함수를 바인딩 해제합니다.</target>
        </trans-unit>
        <trans-unit id="792159b794709664077d97cb3536c3cd14904a0d" translate="yes" xml:space="preserve">
          <source>This method is not applicable to &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt; objects; for these, use &lt;code&gt;&lt;a href=&quot;height&quot;&gt;.height()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 방법은 &lt;code&gt;window&lt;/code&gt; 및 &lt;code&gt;document&lt;/code&gt; 객체 에는 적용 할 수 없습니다 . 이를 위해 &lt;code&gt;&lt;a href=&quot;height&quot;&gt;.height()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef15703808f5f2d053665850bfca24d04d1a2e24" translate="yes" xml:space="preserve">
          <source>This method is not applicable to &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt; objects; for these, use &lt;code&gt;&lt;a href=&quot;height&quot;&gt;.height()&lt;/a&gt;&lt;/code&gt; instead. Although &lt;code&gt;.outerHeight()&lt;/code&gt; can be used on table elements, it may give unexpected results on tables using the &lt;code&gt;border-collapse: collapse&lt;/code&gt; CSS property.</source>
          <target state="translated">이 방법은 &lt;code&gt;window&lt;/code&gt; 및 &lt;code&gt;document&lt;/code&gt; 객체 에는 적용 할 수 없습니다 . 이를 위해 &lt;code&gt;&lt;a href=&quot;height&quot;&gt;.height()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오. &lt;code&gt;.outerHeight()&lt;/code&gt; 를 테이블 요소에 사용할 수 있지만 &lt;code&gt;border-collapse: collapse&lt;/code&gt; CSS 속성을 사용하여 테이블에 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="829556cbe373a45b949053668c7a8cfa83ebe1b2" translate="yes" xml:space="preserve">
          <source>This method is not applicable to &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt; objects; for these, use &lt;code&gt;&lt;a href=&quot;width&quot;&gt;.width()&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">이 방법은 &lt;code&gt;window&lt;/code&gt; 및 &lt;code&gt;document&lt;/code&gt; 객체 에는 적용 할 수 없습니다 . 이를 위해 &lt;code&gt;&lt;a href=&quot;width&quot;&gt;.width()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ba117f4e1229732c120748b2aca40b446fd60fb4" translate="yes" xml:space="preserve">
          <source>This method is not applicable to &lt;code&gt;window&lt;/code&gt; and &lt;code&gt;document&lt;/code&gt; objects; for these, use &lt;code&gt;&lt;a href=&quot;width&quot;&gt;.width()&lt;/a&gt;&lt;/code&gt; instead. Although &lt;code&gt;.outerWidth()&lt;/code&gt; can be used on table elements, it may give unexpected results on tables using the &lt;code&gt;border-collapse: collapse&lt;/code&gt; CSS property.</source>
          <target state="translated">이 방법은 &lt;code&gt;window&lt;/code&gt; 및 &lt;code&gt;document&lt;/code&gt; 객체 에는 적용 할 수 없습니다 . 이를 위해 &lt;code&gt;&lt;a href=&quot;width&quot;&gt;.width()&lt;/a&gt;&lt;/code&gt; 대신 사용하십시오. &lt;code&gt;.outerWidth()&lt;/code&gt; 를 테이블 요소에 사용할 수 있지만 &lt;code&gt;border-collapse: collapse&lt;/code&gt; CSS 속성을 사용하여 테이블에 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b303eebf0f43b27153ed68f23c0854debc8a5aa7" translate="yes" xml:space="preserve">
          <source>This method is not available on XML documents.</source>
          <target state="translated">이 방법은 XML 문서에서 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="02843289c06dc2a11b69cb325ed07cd3b9ece06f" translate="yes" xml:space="preserve">
          <source>This method is often used with &lt;code&gt;.addClass()&lt;/code&gt; to switch elements' classes from one to another, like so:</source>
          <target state="translated">이 메소드는 종종 &lt;code&gt;.addClass()&lt;/code&gt; 와 함께 사용 되어 다음과 같이 요소의 클래스를 다른 클래스로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="a3a5be0658971b62f855cbbcb5c4bc8dcf2d8b61" translate="yes" xml:space="preserve">
          <source>This method is often used with &lt;code&gt;.removeClass()&lt;/code&gt; to switch elements' classes from one to another, like so:</source>
          <target state="translated">이 메소드는 종종 다음과 같이 &lt;code&gt;.removeClass()&lt;/code&gt; 와 함께 사용되어 요소의 클래스를 다른 클래스로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="a33c880bf752394d0bef47af6df6b9420072d808" translate="yes" xml:space="preserve">
          <source>This method is primarily useful for debugging to determine, for example, whether a Deferred has already been resolved even though you are inside code that intended to reject it.</source>
          <target state="translated">이 방법은 지연된 코드를 거부하려는 코드 내부에 있더라도 지연된 것이 이미 해결되었는지 여부를 결정하기 위해 디버깅하는 데 주로 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6158f3be944f5323b063daabea46f186e081a8f5" translate="yes" xml:space="preserve">
          <source>This method is similar to &lt;a href=&quot;parents&quot;&gt;&lt;code&gt;.parents()&lt;/code&gt;&lt;/a&gt;, except &lt;code&gt;.parent()&lt;/code&gt; only travels a single level up the DOM tree. Also, &lt;code&gt;$( &quot;html&quot; ).parent()&lt;/code&gt; method returns a set containing &lt;code&gt;document&lt;/code&gt; whereas &lt;code&gt;$( &quot;html&quot; ).parents()&lt;/code&gt; returns an empty set.</source>
          <target state="translated">이 방법은 비슷합니다 &lt;a href=&quot;parents&quot;&gt; &lt;code&gt;.parents()&lt;/code&gt; &lt;/a&gt; 제외, &lt;code&gt;.parent()&lt;/code&gt; 에만 DOM 트리 최대 단일 레벨을 이동한다. 또한 &lt;code&gt;$( &quot;html&quot; ).parent()&lt;/code&gt; 메서드는 &lt;code&gt;document&lt;/code&gt; 포함하는 집합을 반환 하지만 &lt;code&gt;$( &quot;html&quot; ).parents()&lt;/code&gt; 는 빈 집합을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f212f682efcc36782acb359a7b6a9498a049d716" translate="yes" xml:space="preserve">
          <source>This method is the simplest way to fetch data from the server. It is roughly equivalent to &lt;code&gt;$.get(url, data, success)&lt;/code&gt; except that it is a method rather than global function and it has an implicit callback function. When a successful response is detected (i.e. when &lt;code&gt;textStatus&lt;/code&gt; is &quot;success&quot; or &quot;notmodified&quot;), &lt;code&gt;.load()&lt;/code&gt; sets the HTML contents of the matched element to the returned data. This means that most uses of the method can be quite simple:</source>
          <target state="translated">이 방법은 서버에서 데이터를 가져 오는 가장 간단한 방법입니다. 전역 함수가 아닌 메서드이며 암시 적 콜백 함수가 있다는 점을 제외하면 &lt;code&gt;$.get(url, data, success)&lt;/code&gt; 와 거의 같습니다 . 성공적인 응답이 감지되면 (예 : &lt;code&gt;textStatus&lt;/code&gt; 가 &quot;성공&quot;또는 &quot;수정되지 않음&quot;인 경우) &lt;code&gt;.load()&lt;/code&gt; 는 일치하는 요소의 HTML 내용을 반환 된 데이터로 설정합니다. 이는 대부분의 방법 사용이 매우 간단하다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="97bad19c70b5728f621288ec148f22105f3c99f4" translate="yes" xml:space="preserve">
          <source>This method is the simplest way to fetch data from the server. It is roughly equivalent to &lt;code&gt;$.get(url, data, success)&lt;/code&gt; except that it is a method rather than global function and it has an implicit callback function. When a successful response is detected (i.e. when &lt;code&gt;textStatus&lt;/code&gt; is &quot;success&quot; or &quot;notmodified&quot;), &lt;code&gt;.load()&lt;/code&gt; sets the HTML contents of the matched elements to the returned data. This means that most uses of the method can be quite simple:</source>
          <target state="translated">이 방법은 서버에서 데이터를 가져 오는 가장 간단한 방법입니다. 전역 함수가 아닌 메서드이고 암시 적 콜백 함수가 있다는 점을 제외하면 &lt;code&gt;$.get(url, data, success)&lt;/code&gt; 와 거의 동일 합니다. 성공적인 응답이 감지되면 (즉, &lt;code&gt;textStatus&lt;/code&gt; 가 &quot;success&quot;또는 &quot;notmodified&quot;인 경우) &lt;code&gt;.load()&lt;/code&gt; 는 일치하는 요소의 HTML 내용을 반환 된 데이터로 설정합니다. 이는 대부분의 메서드 사용이 매우 간단 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="33a293e72757673a33b710d1c8020b662670351f" translate="yes" xml:space="preserve">
          <source>This method is typically used to set the values of form fields.</source>
          <target state="translated">이 방법은 일반적으로 양식 필드의 값을 설정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b041aaa9a6860bdfc4ee2d9736df50aacf1367d7" translate="yes" xml:space="preserve">
          <source>This method is useful for situations where a class name or an ID contains characters that have a special meaning in CSS, such as the dot or the semicolon.</source>
          <target state="translated">이 방법은 클래스 이름 또는 ID에 점 또는 세미콜론과 같이 CSS에서 특별한 의미를 가진 문자가 포함 된 상황에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="244806d817f0a7d369a67cd7d7c93c5a39756ca3" translate="yes" xml:space="preserve">
          <source>This method provides a means to attach delegated event handlers to the &lt;code&gt;document&lt;/code&gt; element of a page, which simplifies the use of event handlers when content is dynamically added to a page. See the discussion of direct versus delegated events in the &lt;a href=&quot;on&quot;&gt;&lt;code&gt;.on()&lt;/code&gt;&lt;/a&gt; method for more information.</source>
          <target state="translated">이 메소드는 위임 된 이벤트 핸들러를 페이지 의 &lt;code&gt;document&lt;/code&gt; 요소에 첨부하는 수단을 제공하여 컨텐츠가 페이지에 동적으로 추가 될 때 이벤트 핸들러의 사용을 단순화합니다. 자세한 내용은 &lt;a href=&quot;on&quot;&gt; &lt;code&gt;.on()&lt;/code&gt; &lt;/a&gt; 메서드 에서 직접 이벤트와 위임 된 이벤트에 대한 설명을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7fd2a5591a30ca6ff308b7643859a6536be39441" translate="yes" xml:space="preserve">
          <source>This method rarely needs to be called directly. Instead, use it as an entry point to modify existing &lt;a href=&quot;category/manipulation&quot;&gt;jQuery manipulation methods&lt;/a&gt;. For instance, to remove all &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; tags from incoming HTML strings, do this:</source>
          <target state="translated">이 메소드를 직접 호출 할 필요는 거의 없습니다. 대신, 기존 &lt;a href=&quot;category/manipulation&quot;&gt;jQuery 조작 메소드&lt;/a&gt; 를 수정하기위한 진입 점으로 사용하십시오 . 예를 들어 들어오는 HTML 문자열에서 모든 &lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt; 태그 를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="dd80397630c84b50e8d361e72a33e91191dbf528" translate="yes" xml:space="preserve">
          <source>This method rarely needs to be called directly. Instead, use it as an entry point to modify existing &lt;a href=&quot;category/manipulation&quot;&gt;jQuery manipulation methods&lt;/a&gt;. jQuery calls this method on input HTML before processing it further: it accepts an HTML string &amp;amp; should return a HTML string as well.</source>
          <target state="translated">이 메서드는 직접 호출 할 필요가 거의 없습니다. 대신 기존 &lt;a href=&quot;category/manipulation&quot;&gt;jQuery 조작 방법&lt;/a&gt; 을 수정하기위한 진입 점으로 사용하십시오 . jQuery는 추가 처리하기 전에 입력 HTML에서이 메서드를 호출합니다. HTML 문자열을 받아들이고 HTML 문자열도 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="81bd8de971947848a1bbc3dd30bdfc905828a2cc" translate="yes" xml:space="preserve">
          <source>This method removes not only child (and other descendant) elements, but also any text within the set of matched elements. This is because, according to the DOM specification, any string of text within an element is considered a child node of that element. Consider the following HTML:</source>
          <target state="translated">이 방법은 자식 (및 기타 자손) 요소뿐만 아니라 일치하는 요소 세트 내의 텍스트도 제거합니다. DOM 사양에 따르면 요소 내의 모든 텍스트 문자열은 해당 요소의 자식 노드로 간주되기 때문입니다. 다음 HTML을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="2c6511822632c27fce0c859034fc93723aeb40d5" translate="yes" xml:space="preserve">
          <source>This method returns the Callbacks object onto which it is attached (&lt;code&gt;this&lt;/code&gt;).</source>
          <target state="translated">이 메소드는 첨부 된 콜백 오브젝트 ( &lt;code&gt;this&lt;/code&gt; )를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="db22403d5e9f887b88f057e719d07941784e3daa" translate="yes" xml:space="preserve">
          <source>This method returns the height of the element, including top and bottom padding, in pixels. If called on an empty set of elements, returns &lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;null&lt;/code&gt; before jQuery 3.0).</source>
          <target state="translated">이 메소드는 상단 및 하단 패딩을 포함하여 요소의 높이를 픽셀 단위로 반환합니다. 빈 요소 집합에서 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 ( jQuery 3.0 이전의 &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="46751de65f82b868a8d805a118d0472c10ab2eb4" translate="yes" xml:space="preserve">
          <source>This method returns the width of the element, including left and right padding, in pixels. If called on an empty set of elements, returns &lt;code&gt;undefined&lt;/code&gt; (&lt;code&gt;null&lt;/code&gt; before jQuery 3.0).</source>
          <target state="translated">이 메서드는 왼쪽 및 오른쪽 패딩을 포함하여 요소의 너비를 픽셀 단위로 반환합니다. 빈 요소 집합에서 호출되면 &lt;code&gt;undefined&lt;/code&gt; 를 반환합니다 ( jQuery 3.0 이전의 &lt;code&gt;null&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="346db25be5af8ef6c0901a77a68e78712521680d" translate="yes" xml:space="preserve">
          <source>This method takes one or more class names as its parameter. In the first version, if an element in the matched set of elements already has the class, then it is removed; if an element does not have the class, then it is added. For example, we can apply &lt;code&gt;.toggleClass()&lt;/code&gt; to a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이 메소드는 하나 이상의 클래스 이름을 매개 변수로 사용합니다. 첫 번째 버전에서 일치하는 요소 집합의 요소에 이미 클래스가 있으면 제거됩니다. 요소에 클래스가 없으면 추가됩니다. 예를 들어 &lt;code&gt;.toggleClass()&lt;/code&gt; 를 간단한 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffca30b1eb6fa5e71da9068c59603b1d9459f862" translate="yes" xml:space="preserve">
          <source>This method takes one or more classes as its parameter. In the first version, if an element in the matched set of elements already has the class, then it is removed; if an element does not have the class, then it is added. For example, we can apply &lt;code&gt;.toggleClass()&lt;/code&gt; to a simple &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">이 메소드는 하나 이상의 클래스를 매개 변수로 사용합니다. 첫 번째 버전에서는 일치하는 요소 집합의 요소에 이미 클래스가있는 경우 제거됩니다. 요소에 클래스가 없으면 추가됩니다. 예를 들어 &lt;code&gt;.toggleClass()&lt;/code&gt; 를 간단한 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="715fb2b06c008009d1fe416597cf8a202325a3d1" translate="yes" xml:space="preserve">
          <source>This method uses the browser's &lt;code&gt;innerHTML&lt;/code&gt; property. Some browsers may not generate a DOM that exactly replicates the HTML source provided. For example, Internet Explorer prior to version 8 will convert all &lt;code&gt;href&lt;/code&gt; properties on links to absolute URLs, and Internet Explorer prior to version 9 will not correctly handle HTML5 elements without the addition of a separate &lt;a href=&quot;https://code.google.com/p/html5shiv/&quot;&gt;compatibility layer&lt;/a&gt;.</source>
          <target state="translated">이 메소드는 브라우저의 &lt;code&gt;innerHTML&lt;/code&gt; 속성을 사용합니다 . 일부 브라우저는 제공된 HTML 소스를 정확하게 복제하는 DOM을 생성하지 않을 수 있습니다. 예를 들어, 버전 8 이전의 Internet Explorer 는 링크의 모든 &lt;code&gt;href&lt;/code&gt; 특성을 절대 URL 로 변환 하고 버전 9 이전의 Internet Explorer는 별도의 &lt;a href=&quot;https://code.google.com/p/html5shiv/&quot;&gt;호환성 계층을&lt;/a&gt; 추가하지 않으면 HTML5 요소를 올바르게 처리하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="150d540b15cca9563d10ff4107f8ef56ab70336e" translate="yes" xml:space="preserve">
          <source>This method uses the browser's &lt;code&gt;innerHTML&lt;/code&gt; property. Some browsers may not return HTML that exactly replicates the HTML source in an original document. For example, Internet Explorer sometimes leaves off the quotes around attribute values if they contain only alphanumeric characters.</source>
          <target state="translated">이 메소드는 브라우저의 &lt;code&gt;innerHTML&lt;/code&gt; 속성을 사용합니다 . 일부 브라우저는 원본 문서에서 HTML 소스를 정확하게 복제하는 HTML을 반환하지 않을 수 있습니다. 예를 들어 Internet Explorer는 영숫자 문자 만 포함하는 경우 속성 값 주위에 따옴표를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65e0fd7b6508a3fd582b43249cfe77d08ec202a6" translate="yes" xml:space="preserve">
          <source>This method works for custom events triggered with &lt;a href=&quot;trigger&quot;&gt;trigger()&lt;/a&gt; as well.</source>
          <target state="translated">이 메소드는 &lt;a href=&quot;trigger&quot;&gt;trigger ()&lt;/a&gt; 로 트리거 된 사용자 정의 이벤트에도 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="51d7b57e32048f9435bc9def6a654077e7bbd4e6" translate="yes" xml:space="preserve">
          <source>This object provides a subset of the methods of the &lt;a href=&quot;category/deferred-object&quot;&gt;Deferred&lt;/a&gt; object (&lt;a href=&quot;deferred.then&quot;&gt;&lt;code&gt;then&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.done&quot;&gt;&lt;code&gt;done&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.fail&quot;&gt;&lt;code&gt;fail&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.always&quot;&gt;&lt;code&gt;always&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.pipe&quot;&gt;&lt;code&gt;pipe&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.progress&quot;&gt;&lt;code&gt;progress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;deferred.state&quot;&gt;&lt;code&gt;state&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;deferred.promise&quot;&gt;&lt;code&gt;promise&lt;/code&gt;&lt;/a&gt;) to prevent users from changing the state of the Deferred.</source>
          <target state="translated">이 개체의 방법 중 일부 제공 &lt;a href=&quot;category/deferred-object&quot;&gt;이연&lt;/a&gt; 객체를 ( &lt;a href=&quot;deferred.then&quot;&gt; &lt;code&gt;then&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.done&quot;&gt; &lt;code&gt;done&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.fail&quot;&gt; &lt;code&gt;fail&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.always&quot;&gt; &lt;code&gt;always&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.pipe&quot;&gt; &lt;code&gt;pipe&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.progress&quot;&gt; &lt;code&gt;progress&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;deferred.state&quot;&gt; &lt;code&gt;state&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;deferred.promise&quot;&gt; &lt;code&gt;promise&lt;/code&gt; &lt;/a&gt; )을 이연의 상태를 변경하지 못하도록합니다.</target>
        </trans-unit>
        <trans-unit id="9b34e7f3b9e24382935439639824b6cd3a1daafd" translate="yes" xml:space="preserve">
          <source>This object will be the context of all Ajax-related callbacks. By default, the context is an object that represents the Ajax settings used in the call (&lt;code&gt;$.ajaxSettings&lt;/code&gt; merged with the settings passed to &lt;code&gt;$.ajax&lt;/code&gt;). For example, specifying a DOM element as the context will make that the context for the &lt;code&gt;complete&lt;/code&gt; callback of a request, like so:</source>
          <target state="translated">이 객체는 모든 Ajax 관련 콜백의 컨텍스트입니다. 기본적으로 컨텍스트는 호출에 사용 된 Ajax 설정을 나타내는 오브젝트입니다 ( &lt;code&gt;$.ajaxSettings&lt;/code&gt; 는 &lt;code&gt;$.ajax&lt;/code&gt; 전달 된 설정과 병합 됨 ). 예를 들어, DOM 요소를 컨텍스트로 지정 하면 요청 의 &lt;code&gt;complete&lt;/code&gt; 콜백에 대한 컨텍스트가 다음 과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="94cbfc92f8ea1f8d27355869ff32de50ce680892" translate="yes" xml:space="preserve">
          <source>This page documents data types appearing in jQuery function signatures, whether defined by JavaScript itself or further restricted by jQuery. Unless explicitly stated otherwise, jQuery functions require primitive values where applicable, and do not accept their Object-wrapped forms. If you want to study these concepts in depth, take a look at &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 JavaScript 자체에 의해 정의되거나 jQuery에 의해 더 제한되는 jQuery 함수 시그니처에 나타나는 데이터 유형을 문서화합니다. 명시 적으로 다르게 명시되지 않는 한, jQuery 함수는 해당되는 경우 기본 값을 필요로하며 해당 오브젝트 랩핑 양식을 승인하지 않습니다. 이러한 개념을 심도있게 연구하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript&quot;&gt;MDN을&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="56203e63040b71fce3654bce970b8a4d69bf07fb" translate="yes" xml:space="preserve">
          <source>This produces the following data structure (provided that the browser supports &lt;code&gt;console.log&lt;/code&gt;):</source>
          <target state="translated">브라우저가 &lt;code&gt;console.log&lt;/code&gt; 를 지원하는 경우 다음과 같은 데이터 구조가 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea2441e4626bbaa933d91f94581ef965a8c98747" translate="yes" xml:space="preserve">
          <source>This produces two messages:</source>
          <target state="translated">두 가지 메시지가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3c947e063813842196c7d7043a6f71bdfe405d" translate="yes" xml:space="preserve">
          <source>This property can be useful for getting previous return values of custom events.</source>
          <target state="translated">이 특성은 사용자 정의 이벤트의 이전 리턴 값을 가져 오는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e6af58b84f3fd5422adf8be75663d1cdcaec458" translate="yes" xml:space="preserve">
          <source>This property can be useful for profiling event performance by getting the &lt;code&gt;event.timeStamp&lt;/code&gt; value at two points in the code and noting the difference. To simply determine the current time inside an event handler, use &lt;code&gt;(new Date).getTime()&lt;/code&gt; instead.</source>
          <target state="translated">이 특성은 코드의 두 지점에서 &lt;code&gt;event.timeStamp&lt;/code&gt; 값을 가져 와서 차이를 기록하여 이벤트 성능을 프로파일 링하는 데 유용 할 수 있습니다 . 이벤트 핸들러 내에서 현재 시간을 간단히 판별하려면 &lt;code&gt;(new Date).getTime()&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="32854e587e24ee920ce451c5ed1f67d727e051d7" translate="yes" xml:space="preserve">
          <source>This property is available immediately. It is therefore safe to use it to determine whether or not to call &lt;code&gt;$(document).ready()&lt;/code&gt;. The &lt;code&gt;$.browser&lt;/code&gt; property is deprecated in jQuery 1.3, and its functionality may be moved to a team-supported plugin in a future release of jQuery.</source>
          <target state="translated">이 숙박 시설은 즉시 이용 가능합니다. 따라서 &lt;code&gt;$(document).ready()&lt;/code&gt; 를 호출할지 여부를 결정하는 데 사용하는 것이 안전합니다 . &lt;code&gt;$.browser&lt;/code&gt; 속성은 jQuery를 1.3에서 더 이상 사용되지 않습니다, 그 기능은 jQuery를의 향후 릴리스에서 팀 지원 플러그인으로 이동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb47618e4f09b9437b6d3e0140b679d5c2ebfe6" translate="yes" xml:space="preserve">
          <source>This property is deprecated as of version 3.0, and has no effect in browsers that support the &lt;a href=&quot;https://caniuse.com/#feat=requestanimationframe&quot;&gt;&lt;code&gt;requestAnimationFrame&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">이 속성은 버전 3.0부터 사용되지 않으며 &lt;a href=&quot;https://caniuse.com/#feat=requestanimationframe&quot;&gt; &lt;code&gt;requestAnimationFrame&lt;/code&gt; &lt;/a&gt; 메서드 를 지원하는 브라우저에는 영향을 미치지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="02b9c04a0a37a88e51468f13a1b96e7dc499d1cf" translate="yes" xml:space="preserve">
          <source>This property is most often useful in delegated events attached by &lt;a href=&quot;delegate&quot;&gt;&lt;code&gt;.delegate()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;on&quot;&gt;&lt;code&gt;.on()&lt;/code&gt;&lt;/a&gt;, where the event handler is attached at an ancestor of the element being processed. It can be used, for example, to identify and remove event handlers at the delegation point.</source>
          <target state="translated">이 속성은 이벤트 처리기가 처리되는 요소의 &lt;a href=&quot;delegate&quot;&gt; &lt;code&gt;.delegate()&lt;/code&gt; &lt;/a&gt; 연결되는 .delegate () 또는 &lt;a href=&quot;on&quot;&gt; &lt;code&gt;.on()&lt;/code&gt; &lt;/a&gt; 에 의해 연결된 위임 된 이벤트에서 가장 유용 합니다. 예를 들어, 위임 지점에서 이벤트 핸들러를 식별하고 제거하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5242b856f2e8af25d2fe18fd4c6247bb987e210a" translate="yes" xml:space="preserve">
          <source>This property was introduced in &lt;a href=&quot;https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-Event-isImmediatePropagationStopped&quot;&gt;DOM level 3&lt;/a&gt;.</source>
          <target state="translated">이 프로퍼티는 &lt;a href=&quot;https://www.w3.org/TR/2003/NOTE-DOM-Level-3-Events-20031107/events.html#Events-Event-isImmediatePropagationStopped&quot;&gt;DOM 레벨 3&lt;/a&gt; 에서 도입되었습니다 .</target>
        </trans-unit>
        <trans-unit id="5624080d6e56e0b5af625d523f2fcfcdbbad692f" translate="yes" xml:space="preserve">
          <source>This property will typically be equal to the &lt;code&gt;this&lt;/code&gt; of the function.</source>
          <target state="translated">이 속성은 일반적 &lt;code&gt;this&lt;/code&gt; 기능 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="6de398b115e8ac4d3b07baf9ed497787bdfbc62f" translate="yes" xml:space="preserve">
          <source>This results in the DOM structure:</source>
          <target state="translated">결과적으로 DOM 구조가됩니다.</target>
        </trans-unit>
        <trans-unit id="3f3c511251892c96fdc482ea356fa92b79ae9eba" translate="yes" xml:space="preserve">
          <source>This results in the structure:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31f4d3fdf074258f85fde4229aa90949580dc628" translate="yes" xml:space="preserve">
          <source>This results in two alerts:</source>
          <target state="translated">두 가지 경고가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb2238853884687136f37826653802e89b4ec755" translate="yes" xml:space="preserve">
          <source>This selector can be useful for identifying elements in pages produced by server-side frameworks that produce HTML with systematic element IDs. However it will be slower than using a class selector so leverage classes, if you can, to group like elements.</source>
          <target state="translated">이 선택기는 체계적인 요소 ID로 HTML을 생성하는 서버 측 프레임 워크에서 생성 한 페이지에서 요소를 식별하는 데 유용 할 수 있습니다. 그러나 클래스 선택기를 사용하는 것보다 속도가 느리므로 가능한 경우 클래스를 활용하여 유사한 요소를 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="542c4fe2ce4fad40e426004d25711efcc3fa66b4" translate="yes" xml:space="preserve">
          <source>This selector is equivalent to &lt;code&gt;:not([attr='value'])&lt;/code&gt;.</source>
          <target state="translated">이 선택기는 &lt;code&gt;:not([attr='value'])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db2a826908ba8d7cc8b0f271e54dfa57adba710" translate="yes" xml:space="preserve">
          <source>This selector is the opposite of the &lt;a href=&quot;hidden-selector&quot;&gt;&lt;code&gt;:hidden&lt;/code&gt;&lt;/a&gt; selector. So, every element selected by &lt;code&gt;:visible&lt;/code&gt; isn't selected by &lt;code&gt;:hidden&lt;/code&gt; and vice versa.</source>
          <target state="translated">이 선택기는 &lt;a href=&quot;hidden-selector&quot;&gt; &lt;code&gt;:hidden&lt;/code&gt; &lt;/a&gt; 선택기 와 반대입니다 . 따라서 &lt;code&gt;:visible&lt;/code&gt; 에 의해 선택된 모든 요소 는 &lt;code&gt;:hidden&lt;/code&gt; 에 의해 선택되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="1e74fa4479166ae1158a0c6329853a1894417dc8" translate="yes" xml:space="preserve">
          <source>This selector is the opposite of the &lt;a href=&quot;visible-selector&quot;&gt;&lt;code&gt;:visible&lt;/code&gt;&lt;/a&gt; selector. So, every element selected by &lt;code&gt;:hidden&lt;/code&gt; isn't selected by &lt;code&gt;:visible&lt;/code&gt; and vice versa.</source>
          <target state="translated">이 선택기는 &lt;a href=&quot;visible-selector&quot;&gt; &lt;code&gt;:visible&lt;/code&gt; &lt;/a&gt; 선택기 와 반대입니다 . 따라서 &lt;code&gt;:hidden&lt;/code&gt; 에 의해 선택된 모든 요소 는 &lt;code&gt;:visible&lt;/code&gt; 에 의해 선택되지 않으며 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b3a2d5e9b02d76f676ebf7a40f5475bdf5d72525" translate="yes" xml:space="preserve">
          <source>This selector matches the test string against each word in the attribute value, where a &quot;word&quot; is defined as a string delimited by whitespace. The selector matches if the test string is exactly equal to any of the words.</source>
          <target state="translated">이 선택기는 속성 값의 각 단어에 대해 테스트 문자열을 일치시킵니다. 여기서 &quot;word&quot;는 공백으로 구분 된 문자열로 정의됩니다. 테스트 문자열이 단어와 정확히 일치하면 선택기가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2aacd81dd9108d85703a0183ce334c9f00b22a92" translate="yes" xml:space="preserve">
          <source>This selector was introduced into the CSS specification to handle language attributes.</source>
          <target state="translated">이 선택기는 언어 특성을 처리하기 위해 CSS 사양에 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="157e09ed59bcd27e64a54f0808685dfbd88c2ba5" translate="yes" xml:space="preserve">
          <source>This shortcut creates a new, empty array and merges the contents of oldArray into it, effectively cloning the array.</source>
          <target state="translated">이 바로 가기는 비어있는 새 배열을 만들고 oldArray의 내용을 병합하여 효과적으로 배열을 복제합니다.</target>
        </trans-unit>
        <trans-unit id="fe3f15321a53dc582b1d5e1967292d0bc3fdf9eb" translate="yes" xml:space="preserve">
          <source>This signature does not accept any arguments.</source>
          <target state="translated">이 서명은 인수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="62e54623d8fe421971d23883eb405d33fe0f0049" translate="yes" xml:space="preserve">
          <source>This statement changes the color of items 1, 2, 4, and 5. We could have accomplished the same thing with a simpler jQuery expression, but this technique can be useful when, for example, other libraries provide references to plain DOM nodes.</source>
          <target state="translated">이 문장은 항목 1, 2, 4 및 5의 색상을 변경합니다. 더 간단한 jQuery 표현식으로 동일한 작업을 수행 할 수 있지만이 기법은 예를 들어 다른 라이브러리가 일반 DOM 노드에 대한 참조를 제공 할 때 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="641e0b0e743e0f9db8cc5b5032d87f59f062fa73" translate="yes" xml:space="preserve">
          <source>This technique is especially effective in conjunction with the &lt;code&gt;.ready()&lt;/code&gt; method's ability to alias the jQuery object, as within callback passed to &lt;code&gt;.ready()&lt;/code&gt; you can use &lt;code&gt;$&lt;/code&gt; if you wish without fear of conflicts later:</source>
          <target state="translated">이 기술은 jQuery 객체의 별칭 을 지정하는 &lt;code&gt;.ready()&lt;/code&gt; 메서드의 기능 과 함께 특히 효과적입니다. 콜백에서 &lt;code&gt;.ready()&lt;/code&gt; 전달 되면 나중에 충돌에 대한 두려움없이 원하는 경우 &lt;code&gt;$&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef9920d4ff0249fafafc91db9d9e4e8c4396132d" translate="yes" xml:space="preserve">
          <source>This time list item 4 is turned red, since it is two from the end of the set.</source>
          <target state="translated">이 시간 목록 항목 4는 세트의 끝에서 2이므로 빨간색으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="fb54eb060df63805863b2cc09662a50e679af5ab" translate="yes" xml:space="preserve">
          <source>This time only list item 4 is turned red, since it is the only item in the range between two from the end (&lt;code&gt;-2&lt;/code&gt;) and one from the end (&lt;code&gt;-1&lt;/code&gt;).</source>
          <target state="translated">이번에는 목록 항목 4 만 끝에서 두 개 ( &lt;code&gt;-2&lt;/code&gt; )와 끝에서 하나 ( &lt;code&gt;-1&lt;/code&gt; ) 사이의 유일한 항목이므로 빨간색으로 바뀝니다 .</target>
        </trans-unit>
        <trans-unit id="8e1b0702c2347c741838ffed942588981600a704" translate="yes" xml:space="preserve">
          <source>This time the variable is not referred to directly within the handlers; instead, the variable is passed in &lt;em&gt;by value&lt;/em&gt; through &lt;code&gt;eventData&lt;/code&gt;, which fixes the value at the time the event is bound. The first handler will now display</source>
          <target state="translated">이번에는 변수가 핸들러 내에서 직접 참조되지 않습니다. 대신 변수가 &lt;code&gt;eventData&lt;/code&gt; 를 통해 &lt;em&gt;값으로&lt;/em&gt; 전달되어 이벤트가 바인드 될 때 값을 수정합니다. 이제 첫 번째 핸들러가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="33e92c4d32c144b41a463b2a72bc99e0d9ed77bf" translate="yes" xml:space="preserve">
          <source>This use of a function to compute attribute values can be particularly useful when modifying the attributes of multiple elements at once.</source>
          <target state="translated">이러한 속성 값 계산 기능을 사용하면 여러 요소의 속성을 한 번에 수정할 때 특히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90e99a4c6ae445c81aefa522c507c0b74a3289ec" translate="yes" xml:space="preserve">
          <source>This version removes the handlers regardless of type. To be more precise, we can pass an event type:</source>
          <target state="translated">이 버전은 유형에 관계없이 핸들러를 제거합니다. 더 정확하게 말하면 이벤트 유형을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8f494293589fde5d66a9f0fd3de5d8ce4c6042" translate="yes" xml:space="preserve">
          <source>This will cause each &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; to have a class corresponding to the text it wraps:</source>
          <target state="translated">그러면 각 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 에 줄 바꿈 된 텍스트에 해당하는 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d9118b4fa1f3e8e18281acd7053ecc4ebd98b4f" translate="yes" xml:space="preserve">
          <source>This will change the color of list item A. The &lt;code&gt;.closest()&lt;/code&gt; method begins its search &lt;em&gt;with the element itself&lt;/em&gt; before progressing up the DOM tree, and stops when item A matches the selector.</source>
          <target state="translated">이렇게하면 목록 항목 A의 색상이 변경됩니다. &lt;code&gt;.closest()&lt;/code&gt; 메서드는 DOM 트리를 진행하기 전에 &lt;em&gt;요소 자체에서&lt;/em&gt; 검색 &lt;em&gt;을&lt;/em&gt; 시작하고 항목 A가 선택기와 일치하면 중지됩니다.</target>
        </trans-unit>
        <trans-unit id="14e650ca3a960ce5e1c69a20a7735fd10a84f51f" translate="yes" xml:space="preserve">
          <source>This will change the color of list item II, which is positioned.</source>
          <target state="translated">그러면 목록 항목 II의 색상이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="6445328f9b2e260ef2fd3767cecdd73168ad2247" translate="yes" xml:space="preserve">
          <source>This will change the color of the level-2 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, because it is both the first &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; ancestor of list item A and a descendant of list item II. It will not change the color of the level-1 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, however, because it is not a descendant of list item II.</source>
          <target state="translated">레벨 2 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 의 색상이 변경됩니다. 목록 항목 A 의 첫 번째 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 조상이자 목록 항목 II의 하위 항목 이기 때문입니다 . 그러나 레벨 1 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 의 색상 은 목록 항목 II의 하위 항목이 아니기 때문에 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="30761f176591a578865ba51b9704b1d8e4292dab" translate="yes" xml:space="preserve">
          <source>This will change the color of the level-2 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;, since it is the first encountered when traveling up the DOM tree.</source>
          <target state="translated">레벨 2 &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; 의 색상이 변경 됩니다. DOM 트리를 여행 할 때 처음 만나기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="da12335e31823528963ade8757b1f95116d49939" translate="yes" xml:space="preserve">
          <source>This will likely be used primarily by plugin authors who wish to handle tasks differently depending on the event namespace used.</source>
          <target state="translated">이것은 주로 사용되는 이벤트 네임 스페이스에 따라 작업을 다르게 처리하려는 플러그인 작성자가 주로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23a466e8090dcdd96843ee2332573bed8a724b31" translate="yes" xml:space="preserve">
          <source>This will result in a DOM structure with the &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; element deleted:</source>
          <target state="translated">&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 요소가 삭제 된 DOM 구조가 됩니다.</target>
        </trans-unit>
        <trans-unit id="ac3089e0a92b12a862e14834e3811b822b252ec9" translate="yes" xml:space="preserve">
          <source>This will result in a DOM structure with the &lt;code&gt;Hello&lt;/code&gt; text deleted:</source>
          <target state="translated">&lt;code&gt;Hello&lt;/code&gt; 텍스트가 삭제 된 DOM 구조가 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="8f51918357cfd5fb539009a6a575f4d17e914b38" translate="yes" xml:space="preserve">
          <source>This will return a jQuery collection which contains only the list elements that are descendants of item II.</source>
          <target state="translated">그러면 항목 II의 하위 항목 인 목록 요소 만 포함하는 jQuery 컬렉션이 반환됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
