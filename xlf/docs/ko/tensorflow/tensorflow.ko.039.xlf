<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="083730c076520c06f329b3a1d05a2c9ceace46aa" translate="yes" xml:space="preserve">
          <source>SpaceToBatch for N-D tensors of type T.</source>
          <target state="translated">유형 T의 ND 텐서 용 SpaceToBatch</target>
        </trans-unit>
        <trans-unit id="02dff74c4fb55771bcd9c6f3bae239b5c926752d" translate="yes" xml:space="preserve">
          <source>SpaceToBatchND</source>
          <target state="translated">SpaceToBatchND</target>
        </trans-unit>
        <trans-unit id="27c2f818204c82b7170206e8d239ed96f576808c" translate="yes" xml:space="preserve">
          <source>SpaceToDepth</source>
          <target state="translated">SpaceToDepth</target>
        </trans-unit>
        <trans-unit id="70947ab2fc979f29296aaef123d22483ba02139e" translate="yes" xml:space="preserve">
          <source>SpaceToDepth for tensors of type T.</source>
          <target state="translated">T 유형의 텐서에 대한 SpaceToDepth</target>
        </trans-unit>
        <trans-unit id="b32e033310ebd5e93b4041f5df9964210ade963a" translate="yes" xml:space="preserve">
          <source>Sparse Tensor Representation.</source>
          <target state="translated">스파 스 텐서 표현.</target>
        </trans-unit>
        <trans-unit id="297fd960fda1b45bfadfb929e956fa6dcd5df811" translate="yes" xml:space="preserve">
          <source>Sparse addition of two CSR matrices, C = alpha * A + beta * B.</source>
          <target state="translated">두 CSR 행렬의 희소 덧셈, C = 알파 * A + 베타 * B.</target>
        </trans-unit>
        <trans-unit id="fd6ed54737aabfc431d2acb0e85f89ee895aef63" translate="yes" xml:space="preserve">
          <source>Sparse categorical accuracy values.</source>
          <target state="translated">희소 범주 형 정확도 값.</target>
        </trans-unit>
        <trans-unit id="a4f475eac216a4861e2e8977461d56eea5138d37" translate="yes" xml:space="preserve">
          <source>Sparse categorical crossentropy loss value.</source>
          <target state="translated">희소 범주 형 교차 엔트로피 손실 값입니다.</target>
        </trans-unit>
        <trans-unit id="069a9228c751a538f52a392a1cd0e50f26fac743" translate="yes" xml:space="preserve">
          <source>Sparse gradients are represented by &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="translated">희소 그라디언트는 &lt;code&gt;IndexedSlices&lt;/code&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="746eaddaf50318b240e02275edbdb2830f3ccb5c" translate="yes" xml:space="preserve">
          <source>Sparse top K categorical accuracy value.</source>
          <target state="translated">스파 스 상위 K 범주 정확도 값.</target>
        </trans-unit>
        <trans-unit id="fd4a8b5726a640c6ed69cf0e30bab1e6e2ffb32d" translate="yes" xml:space="preserve">
          <source>Sparse update '*var' as FOBOS algorithm with fixed learning rate.</source>
          <target state="translated">고정 학습률을 사용하는 FOBOS 알고리즘으로 스파 스 업데이트 '* var'.</target>
        </trans-unit>
        <trans-unit id="b1694f3eadba000742e82cef2fa78625d8e9076c" translate="yes" xml:space="preserve">
          <source>Sparse update entries in '&lt;em&gt;var' and '&lt;/em&gt;accum' according to FOBOS algorithm.</source>
          <target state="translated">FOBOS 알고리즘에 따라 ' &lt;em&gt;var'및 '&lt;/em&gt; accum'의 희소 업데이트 항목 .</target>
        </trans-unit>
        <trans-unit id="a6309026e4e714f71ee3ee89779ccfe84cf4e87e" translate="yes" xml:space="preserve">
          <source>Sparse-matrix-multiplies two CSR matrices &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">Sparse-matrix-multiply 두 CSR 행렬 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bfde9fc0aa278505d4dfa97aa1b467e722aa8e8" translate="yes" xml:space="preserve">
          <source>SparseAccumulatorApplyGradient</source>
          <target state="translated">SparseAccumulatorApplyGradient</target>
        </trans-unit>
        <trans-unit id="bdd7ea5381f2da5f60515c1c2776cf94f0431cbd" translate="yes" xml:space="preserve">
          <source>SparseAccumulatorTakeGradient</source>
          <target state="translated">SparseAccumulatorTakeGradient</target>
        </trans-unit>
        <trans-unit id="249f12388f8e22f1c462f0fdfc7611ab0874399a" translate="yes" xml:space="preserve">
          <source>SparseAdd</source>
          <target state="translated">SparseAdd</target>
        </trans-unit>
        <trans-unit id="dcc522bee3927102912fd66127381b4718966e6c" translate="yes" xml:space="preserve">
          <source>SparseAddGrad</source>
          <target state="translated">SparseAddGrad</target>
        </trans-unit>
        <trans-unit id="1cdfbb3c5ab2d562fe3c475ab94c701cb796104c" translate="yes" xml:space="preserve">
          <source>SparseApplyAdadelta</source>
          <target state="translated">SparseApplyAdadelta</target>
        </trans-unit>
        <trans-unit id="3d418cb7a1ad844d45b106ce39b28c8d703bbf1d" translate="yes" xml:space="preserve">
          <source>SparseApplyAdagrad</source>
          <target state="translated">SparseApplyAdagrad</target>
        </trans-unit>
        <trans-unit id="9367876d4671a0952c532dc60536c6bd51dfd3d3" translate="yes" xml:space="preserve">
          <source>SparseApplyAdagradDA</source>
          <target state="translated">SparseApplyAdagradDA</target>
        </trans-unit>
        <trans-unit id="3b6ee3d5c2961a35df0e0bcf97b22a79b8ea2cd1" translate="yes" xml:space="preserve">
          <source>SparseApplyAdagradV2</source>
          <target state="translated">SparseApplyAdagradV2</target>
        </trans-unit>
        <trans-unit id="b77eb40a01e4db883fe1ee8dd8dfe4307a2a1aaa" translate="yes" xml:space="preserve">
          <source>SparseApplyCenteredRMSProp</source>
          <target state="translated">SparseApplyCenteredRMSProp</target>
        </trans-unit>
        <trans-unit id="4877869e59f0ea0b186f27748e4f15df0c034e2d" translate="yes" xml:space="preserve">
          <source>SparseApplyFtrl</source>
          <target state="translated">SparseApplyFtrl</target>
        </trans-unit>
        <trans-unit id="800d3891ccb155f6396234527980fa18782b4933" translate="yes" xml:space="preserve">
          <source>SparseApplyFtrlV2</source>
          <target state="translated">SparseApplyFtrlV2</target>
        </trans-unit>
        <trans-unit id="a22f1b0250fab301e3982b2a1cdf630ee577baa8" translate="yes" xml:space="preserve">
          <source>SparseApplyMomentum</source>
          <target state="translated">SparseApplyMomentum</target>
        </trans-unit>
        <trans-unit id="43918531d5decd8bc5f29c17a5ab14d60c356787" translate="yes" xml:space="preserve">
          <source>SparseApplyProximalAdagrad</source>
          <target state="translated">SparseApplyProximalAdagrad</target>
        </trans-unit>
        <trans-unit id="c31a2accba554579538ec14c88a2c1d8888ed3f2" translate="yes" xml:space="preserve">
          <source>SparseApplyProximalGradientDescent</source>
          <target state="translated">SparseApplyProximalGradientDescent</target>
        </trans-unit>
        <trans-unit id="73ff23530143b457e0b5aa626f580af31cb2805a" translate="yes" xml:space="preserve">
          <source>SparseApplyRMSProp</source>
          <target state="translated">SparseApplyRMSProp</target>
        </trans-unit>
        <trans-unit id="69f1147a0bb3348ad6860c7cf47c3b1be2927cfc" translate="yes" xml:space="preserve">
          <source>SparseBincount</source>
          <target state="translated">SparseBincount</target>
        </trans-unit>
        <trans-unit id="9741604df92212d707cf823523096c0c10605504" translate="yes" xml:space="preserve">
          <source>SparseConcat</source>
          <target state="translated">SparseConcat</target>
        </trans-unit>
        <trans-unit id="e172228800bb4ef266cfae249360c9adb18c222b" translate="yes" xml:space="preserve">
          <source>SparseConditionalAccumulator</source>
          <target state="translated">SparseConditionalAccumulator</target>
        </trans-unit>
        <trans-unit id="343e97bcbfdc55326d10655662c2ff72f0e6c132" translate="yes" xml:space="preserve">
          <source>SparseCountSparseOutput</source>
          <target state="translated">SparseCountSparseOutput</target>
        </trans-unit>
        <trans-unit id="fc393f647312656ab5f2d94fea4751142ed63d03" translate="yes" xml:space="preserve">
          <source>SparseCross</source>
          <target state="translated">SparseCross</target>
        </trans-unit>
        <trans-unit id="b6bca69b1b714f2d3ea37d2437a5d444c90d3630" translate="yes" xml:space="preserve">
          <source>SparseCrossHashed</source>
          <target state="translated">SparseCrossHashed</target>
        </trans-unit>
        <trans-unit id="790117eab2ba1913ce866d879ee430b559bb3b5a" translate="yes" xml:space="preserve">
          <source>SparseCrossV2</source>
          <target state="translated">SparseCrossV2</target>
        </trans-unit>
        <trans-unit id="17b61339890f8722663e2e5f752e314dad0d56df" translate="yes" xml:space="preserve">
          <source>SparseDenseCwiseAdd</source>
          <target state="translated">SparseDenseCwiseAdd</target>
        </trans-unit>
        <trans-unit id="fc5f908a0a14da3d930f57bd0a310cc42f95c577" translate="yes" xml:space="preserve">
          <source>SparseDenseCwiseDiv</source>
          <target state="translated">SparseDenseCwiseDiv</target>
        </trans-unit>
        <trans-unit id="4fe72e75eb5b66d560741c8aa08e1d5c0f66c139" translate="yes" xml:space="preserve">
          <source>SparseDenseCwiseMul</source>
          <target state="translated">SparseDenseCwiseMul</target>
        </trans-unit>
        <trans-unit id="62f8d22d634ba8ed1c8905b6b404fb4b601cc5f7" translate="yes" xml:space="preserve">
          <source>SparseFillEmptyRows</source>
          <target state="translated">SparseFillEmptyRows</target>
        </trans-unit>
        <trans-unit id="ab7cf0e36f1467fdc9b3ae7d80d58d84eb0f1ab7" translate="yes" xml:space="preserve">
          <source>SparseFillEmptyRowsGrad</source>
          <target state="translated">SparseFillEmptyRowsGrad</target>
        </trans-unit>
        <trans-unit id="ce8bfa77ed4ac9f3fa1d2a359f566ebe70c39b48" translate="yes" xml:space="preserve">
          <source>SparseMatMul</source>
          <target state="translated">SparseMatMul</target>
        </trans-unit>
        <trans-unit id="3cf42c0cd63305eae39753b795996ee97fab383f" translate="yes" xml:space="preserve">
          <source>SparseMatrixAdd</source>
          <target state="translated">SparseMatrixAdd</target>
        </trans-unit>
        <trans-unit id="48528ac0c2faf4223200c626bfe3edf8ac895e5e" translate="yes" xml:space="preserve">
          <source>SparseMatrixMatMul</source>
          <target state="translated">SparseMatrixMatMul</target>
        </trans-unit>
        <trans-unit id="4279b19a5f9930f0874059a7e46ed173ba5ebe7f" translate="yes" xml:space="preserve">
          <source>SparseMatrixMul</source>
          <target state="translated">SparseMatrixMul</target>
        </trans-unit>
        <trans-unit id="523132d044bbb3d197acb20f4f4feae322e6bcd8" translate="yes" xml:space="preserve">
          <source>SparseMatrixNNZ</source>
          <target state="translated">SparseMatrixNNZ</target>
        </trans-unit>
        <trans-unit id="6c1c0e15bc3c654ae8df6e1f9f8a7ce64a24dfc9" translate="yes" xml:space="preserve">
          <source>SparseMatrixOrderingAMD</source>
          <target state="translated">SparseMatrixOrderingAMD</target>
        </trans-unit>
        <trans-unit id="73e04112a19a80bfa3d79ee64a1f963128da864e" translate="yes" xml:space="preserve">
          <source>SparseMatrixSoftmax</source>
          <target state="translated">SparseMatrixSoftmax</target>
        </trans-unit>
        <trans-unit id="7c621a154eb82c0067ca01796aba9cc0ee388e77" translate="yes" xml:space="preserve">
          <source>SparseMatrixSoftmaxGrad</source>
          <target state="translated">SparseMatrixSoftmaxGrad</target>
        </trans-unit>
        <trans-unit id="66a5c848777562b7ca7fb4cad812e026290aa1df" translate="yes" xml:space="preserve">
          <source>SparseMatrixSparseCholesky</source>
          <target state="translated">SparseMatrixSparseCholesky</target>
        </trans-unit>
        <trans-unit id="c3c5c7b84d2af8b9ef18ab0003ea1ce40ab4e4fc" translate="yes" xml:space="preserve">
          <source>SparseMatrixSparseMatMul</source>
          <target state="translated">SparseMatrixSparseMatMul</target>
        </trans-unit>
        <trans-unit id="54781178ca318ed50d0ca703e108a30afbeb1d7f" translate="yes" xml:space="preserve">
          <source>SparseMatrixTranspose</source>
          <target state="translated">SparseMatrixTranspose</target>
        </trans-unit>
        <trans-unit id="1906bd0dff1f0689566550297562246b450522c5" translate="yes" xml:space="preserve">
          <source>SparseMatrixZeros</source>
          <target state="translated">SparseMatrixZeros</target>
        </trans-unit>
        <trans-unit id="cf14b376c29c3c02d073e282519a42fad3b16c08" translate="yes" xml:space="preserve">
          <source>SparseReduceMax</source>
          <target state="translated">SparseReduceMax</target>
        </trans-unit>
        <trans-unit id="abe4ee718716b4f2e1444db7308390e1ee3ed7ac" translate="yes" xml:space="preserve">
          <source>SparseReduceMaxSparse</source>
          <target state="translated">SparseReduceMaxSparse</target>
        </trans-unit>
        <trans-unit id="0fd09e8caf8a4d6991cfd23e07910f3f9c598d41" translate="yes" xml:space="preserve">
          <source>SparseReduceSum</source>
          <target state="translated">SparseReduceSum</target>
        </trans-unit>
        <trans-unit id="30eac2752ce1ceab0de7a5545abdb8ca33742ae0" translate="yes" xml:space="preserve">
          <source>SparseReduceSumSparse</source>
          <target state="translated">SparseReduceSumSparse</target>
        </trans-unit>
        <trans-unit id="6339f44ab9a27d89470df90d3d6c053bd1d15396" translate="yes" xml:space="preserve">
          <source>SparseReorder</source>
          <target state="translated">SparseReorder</target>
        </trans-unit>
        <trans-unit id="db860331321faa0d2837c12e83a4dc71a4d1ea38" translate="yes" xml:space="preserve">
          <source>SparseReshape</source>
          <target state="translated">SparseReshape</target>
        </trans-unit>
        <trans-unit id="a02cc82cd67e5d1fd156cbcd34d472d5fc5ef081" translate="yes" xml:space="preserve">
          <source>SparseSegmentMean</source>
          <target state="translated">SparseSegmentMean</target>
        </trans-unit>
        <trans-unit id="26f1162ce1d82f470fd702e14f79d5e7c9e39609" translate="yes" xml:space="preserve">
          <source>SparseSegmentMeanGrad</source>
          <target state="translated">SparseSegmentMeanGrad</target>
        </trans-unit>
        <trans-unit id="5146d89f1fd003f0d5bc8a63fe20aa9844ce7202" translate="yes" xml:space="preserve">
          <source>SparseSegmentMeanWithNumSegments</source>
          <target state="translated">SparseSegmentMeanWithNumSegments</target>
        </trans-unit>
        <trans-unit id="3e4e8a4d496f5ca492077964d5dc9586fef486e1" translate="yes" xml:space="preserve">
          <source>SparseSegmentSqrtN</source>
          <target state="translated">SparseSegmentSqrtN</target>
        </trans-unit>
        <trans-unit id="ccba9de2aad7b2af6dbc3cdd0e9d48e92197309f" translate="yes" xml:space="preserve">
          <source>SparseSegmentSqrtNGrad</source>
          <target state="translated">SparseSegmentSqrtNGrad</target>
        </trans-unit>
        <trans-unit id="0c8b21214653614b8e14c4a9191ad289716fc3ed" translate="yes" xml:space="preserve">
          <source>SparseSegmentSqrtNWithNumSegments</source>
          <target state="translated">SparseSegmentSqrtNWithNumSegments</target>
        </trans-unit>
        <trans-unit id="f3f0a05296f1ec028f1ecacda18d19691113dd3f" translate="yes" xml:space="preserve">
          <source>SparseSegmentSum</source>
          <target state="translated">SparseSegmentSum</target>
        </trans-unit>
        <trans-unit id="4c106d8d638767bc6148f2ac91b51f75b015d9f8" translate="yes" xml:space="preserve">
          <source>SparseSegmentSumWithNumSegments</source>
          <target state="translated">SparseSegmentSumWithNumSegments</target>
        </trans-unit>
        <trans-unit id="bde3aa2f1ff79895c18f788c8aaa0a84703fc850" translate="yes" xml:space="preserve">
          <source>SparseSlice</source>
          <target state="translated">SparseSlice</target>
        </trans-unit>
        <trans-unit id="07ee0f62ef583185aec4e065c61c02f50b42d3e8" translate="yes" xml:space="preserve">
          <source>SparseSliceGrad</source>
          <target state="translated">SparseSliceGrad</target>
        </trans-unit>
        <trans-unit id="1e170979bb98e066666e1d7c02b1980ab0de0f1e" translate="yes" xml:space="preserve">
          <source>SparseSoftmax</source>
          <target state="translated">SparseSoftmax</target>
        </trans-unit>
        <trans-unit id="f1a6fa9f8ea7ca8850a5f1ec7eb72dfce8fcb36b" translate="yes" xml:space="preserve">
          <source>SparseSoftmaxCrossEntropyWithLogits</source>
          <target state="translated">SparseSoftmaxCrossEntropyWithLogits</target>
        </trans-unit>
        <trans-unit id="c1aadec295283e1c2e27af2edb9e7a99885ecfa2" translate="yes" xml:space="preserve">
          <source>SparseSparseMaximum</source>
          <target state="translated">SparseSparseMaximum</target>
        </trans-unit>
        <trans-unit id="0db7745b65e7336d0412c2ecedfd8e19202d9a9b" translate="yes" xml:space="preserve">
          <source>SparseSparseMinimum</source>
          <target state="translated">SparseSparseMinimum</target>
        </trans-unit>
        <trans-unit id="17f6a95e588289e6f27054ecb850364d5a4110d1" translate="yes" xml:space="preserve">
          <source>SparseSplit</source>
          <target state="translated">SparseSplit</target>
        </trans-unit>
        <trans-unit id="9cea8a4cddb4b8d1cc0732cca1c0b02187d2f314" translate="yes" xml:space="preserve">
          <source>SparseTensor (or dense Matrix) A, of rank 2.</source>
          <target state="translated">SparseTensor (또는 조밀 행렬) A, 순위 2입니다.</target>
        </trans-unit>
        <trans-unit id="7b4c1d1909f9bc68a995624a409254a398966f07" translate="yes" xml:space="preserve">
          <source>SparseTensor is not supported. The return value of the decorated function must be a Tensor or a list/tuple of Tensors.</source>
          <target state="translated">SparseTensor는 지원되지 않습니다. 데코 레이팅 된 함수의 반환 값은 Tensor 또는 Tensor 목록 / 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="a1ffd7ce11921ece1834d4731c951cc910508d1f" translate="yes" xml:space="preserve">
          <source>SparseTensor referred by first key:</source>
          <target state="translated">첫 번째 키로 참조되는 SparseTensor :</target>
        </trans-unit>
        <trans-unit id="1c32b414e828af630366a2f4a79388908c22a788" translate="yes" xml:space="preserve">
          <source>SparseTensor referred by second key:</source>
          <target state="translated">두 번째 키로 참조되는 SparseTensor :</target>
        </trans-unit>
        <trans-unit id="4b02c490105a73e4677e7af826183a355e348428" translate="yes" xml:space="preserve">
          <source>SparseTensorDenseAdd</source>
          <target state="translated">SparseTensorDenseAdd</target>
        </trans-unit>
        <trans-unit id="9b0e03d3f005e119dab66c03dae6ae4555a46d37" translate="yes" xml:space="preserve">
          <source>SparseTensorDenseMatMul</source>
          <target state="translated">SparseTensorDenseMatMul</target>
        </trans-unit>
        <trans-unit id="fd609f1385af3c0983488849c5d3db3d54dcdc0d" translate="yes" xml:space="preserve">
          <source>SparseTensorSliceDataset</source>
          <target state="translated">SparseTensorSliceDataset</target>
        </trans-unit>
        <trans-unit id="b5b086dcba335f8373b291889b402724c457e59d" translate="yes" xml:space="preserve">
          <source>SparseTensorToCSRSparseMatrix</source>
          <target state="translated">SparseTensorToCSRSparseMatrix</target>
        </trans-unit>
        <trans-unit id="fa5e3369b1a543faf6701e41ac2ec3d01253f981" translate="yes" xml:space="preserve">
          <source>SparseTensorValue(indices, values, dense_shape)</source>
          <target state="translated">SparseTensorValue (표시, 값, 밀도 _ 모양)</target>
        </trans-unit>
        <trans-unit id="7abf55a16fe5d57246cc5925f0abff9c75820d59" translate="yes" xml:space="preserve">
          <source>SparseTensors</source>
          <target state="translated">SparseTensors</target>
        </trans-unit>
        <trans-unit id="a1633924cf157b2cfe630e97431895832f91082c" translate="yes" xml:space="preserve">
          <source>SparseToDense</source>
          <target state="translated">SparseToDense</target>
        </trans-unit>
        <trans-unit id="7c3a69501a810936e4544b3f411c791266754835" translate="yes" xml:space="preserve">
          <source>SparseToSparseSetOperation</source>
          <target state="translated">SparseToSparseSetOperation</target>
        </trans-unit>
        <trans-unit id="6ee93c8da33edf23834992d6432a8f0e409815de" translate="yes" xml:space="preserve">
          <source>Spatial 1D version of Dropout.</source>
          <target state="translated">Dropout의 공간 1D 버전.</target>
        </trans-unit>
        <trans-unit id="44ada72cd6d79ae9c07a9cb3d7a9ed46bb7aa114" translate="yes" xml:space="preserve">
          <source>Spatial 2D version of Dropout.</source>
          <target state="translated">Dropout의 공간 2D 버전.</target>
        </trans-unit>
        <trans-unit id="1b491fa379bdaddd72ebc9a3730d0e2efd96f9bc" translate="yes" xml:space="preserve">
          <source>Spatial 3D version of Dropout.</source>
          <target state="translated">Dropout의 공간적 3D 버전.</target>
        </trans-unit>
        <trans-unit id="c3f29e68c2f47d80899bc4477479be5589b1d283" translate="yes" xml:space="preserve">
          <source>Special math functions (like: &lt;a href=&quot;../../math/igamma&quot;&gt;&lt;code&gt;tf.math.igamma&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../math/zeta&quot;&gt;&lt;code&gt;tf.math.zeta&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">특수 수학 함수 (예 : &lt;a href=&quot;../../math/igamma&quot;&gt; &lt;code&gt;tf.math.igamma&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../math/zeta&quot;&gt; &lt;code&gt;tf.math.zeta&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="42e77439e21bd348d1d9ca7ffa4988277cfd7529" translate="yes" xml:space="preserve">
          <source>Special math functions (like: &lt;a href=&quot;math/igamma&quot;&gt;&lt;code&gt;tf.math.igamma&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;math/zeta&quot;&gt;&lt;code&gt;tf.math.zeta&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">특수 수학 함수 (예 : &lt;a href=&quot;math/igamma&quot;&gt; &lt;code&gt;tf.math.igamma&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;math/zeta&quot;&gt; &lt;code&gt;tf.math.zeta&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="87fda649d275e8caddcb2a2ca9883319168cb531" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;grad = -dy * y*y&lt;/code&gt;, where &lt;code&gt;y = 1/x&lt;/code&gt;, and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</source>
          <target state="translated">특히 &lt;code&gt;grad = -dy * y*y&lt;/code&gt; , 여기서 &lt;code&gt;y = 1/x&lt;/code&gt; 이고 &lt;code&gt;dy&lt;/code&gt; 는 해당 입력 기울기입니다.</target>
        </trans-unit>
        <trans-unit id="9490a5aa68b217b343aa6c32a431a4354acf352d" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;grad = dy * (1 - y*y)&lt;/code&gt;, where &lt;code&gt;y = tanh(x)&lt;/code&gt;, and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</source>
          <target state="translated">특히 &lt;code&gt;grad = dy * (1 - y*y)&lt;/code&gt; , 여기서 &lt;code&gt;y = tanh(x)&lt;/code&gt; 이고 &lt;code&gt;dy&lt;/code&gt; 는 해당 입력 기울기입니다.</target>
        </trans-unit>
        <trans-unit id="b0eb3503a4569dc92b3286b553d1515046a20738" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;grad = dy * -0.5 * y^3&lt;/code&gt;, where &lt;code&gt;y = rsqrt(x)&lt;/code&gt;, and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</source>
          <target state="translated">특히 &lt;code&gt;grad = dy * -0.5 * y^3&lt;/code&gt; , 여기서 &lt;code&gt;y = rsqrt(x)&lt;/code&gt; 이고 &lt;code&gt;dy&lt;/code&gt; 는 해당 입력 기울기입니다.</target>
        </trans-unit>
        <trans-unit id="4b78cbd77beea0a2b3caee50e523d8e75b7b46c7" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;grad = dy * 0.5 / y&lt;/code&gt;, where &lt;code&gt;y = sqrt(x)&lt;/code&gt;, and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</source>
          <target state="translated">Specifically, &lt;code&gt;grad = dy * 0.5 / y&lt;/code&gt; , where &lt;code&gt;y = sqrt(x)&lt;/code&gt; , and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</target>
        </trans-unit>
        <trans-unit id="2ec8caad6d138b060540254f511fece75b9d2aa8" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;grad = dy * y * (1 - y)&lt;/code&gt;, where &lt;code&gt;y = sigmoid(x)&lt;/code&gt;, and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</source>
          <target state="translated">Specifically, &lt;code&gt;grad = dy * y * (1 - y)&lt;/code&gt; , where &lt;code&gt;y = sigmoid(x)&lt;/code&gt; , and &lt;code&gt;dy&lt;/code&gt; is the corresponding input gradient.</target>
        </trans-unit>
        <trans-unit id="c7001c1ac0b17fbd7ca3a02ab7f20b52959b8e41" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;y = 1 / (1 + exp(-x))&lt;/code&gt;.</source>
          <target state="translated">구체적으로, &lt;code&gt;y = 1 / (1 + exp(-x))&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="954c9de28a55b63501fe0fe04e4bf1cb501e7df5" translate="yes" xml:space="preserve">
          <source>Specifically, &lt;code&gt;y = log(1 / (1 + exp(-x)))&lt;/code&gt;. For numerical stability, we use &lt;code&gt;y = -tf.nn.softplus(-x)&lt;/code&gt;.</source>
          <target state="translated">구체적으로, &lt;code&gt;y = log(1 / (1 + exp(-x)))&lt;/code&gt; 입니다. 수치 안정성을 위해 &lt;code&gt;y = -tf.nn.softplus(-x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="6597172c93c2b702bcd7586ce5fa7c1bf3b6fa02" translate="yes" xml:space="preserve">
          <source>Specifically, in the case that &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, given a rank (N+2) &lt;code&gt;input&lt;/code&gt; Tensor of shape</source>
          <target state="translated">구체적으로 &lt;code&gt;data_format&lt;/code&gt; 이 &quot;NC&quot;로 시작하지 않는 경우 , 순위 (N + 2)의 &lt;code&gt;input&lt;/code&gt; 텐서가 주어지면</target>
        </trans-unit>
        <trans-unit id="4685e2fad46095eee9ba25a53c669f27eb8ab429" translate="yes" xml:space="preserve">
          <source>Specifically, returns &lt;code&gt;True&lt;/code&gt; if the dtype of &lt;code&gt;tensor&lt;/code&gt; is one of the following:</source>
          <target state="translated">특히 &lt;code&gt;tensor&lt;/code&gt; 의 dtype 이 다음 중 하나 인 경우 &lt;code&gt;True&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="0556709f41308a40346ba1c586e66a03dc18eabe" translate="yes" xml:space="preserve">
          <source>Specifically, the op extracts patches of shape &lt;code&gt;sizes&lt;/code&gt; which are &lt;code&gt;strides&lt;/code&gt; apart in the input image. The output is subsampled using the &lt;code&gt;rates&lt;/code&gt; argument, in the same manner as &quot;atrous&quot; or &quot;dilated&quot; convolutions.</source>
          <target state="translated">특히, 영업 모양의 패치를 추출하는 &lt;code&gt;sizes&lt;/code&gt; 이다 &lt;code&gt;strides&lt;/code&gt; 이격 입력 화상하여. 출력은 &quot;atrous&quot;또는 &quot;dilated&quot;컨볼 루션과 같은 방식으로 &lt;code&gt;rates&lt;/code&gt; 인수를 사용하여 서브 샘플링됩니다 .</target>
        </trans-unit>
        <trans-unit id="fae6543b085f90e9db03167ac9f6f9969607441e" translate="yes" xml:space="preserve">
          <source>Specifically, this function implements single-machine multi-GPU data parallelism. It works in the following way:</source>
          <target state="translated">특히이 기능은 단일 시스템 다중 GPU 데이터 병렬 처리를 구현합니다. 다음과 같은 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4e9e8fdae6be8ea97754587f39987e492cd88c1c" translate="yes" xml:space="preserve">
          <source>Specification for the output of the layer. Defaults to &quot;binary&quot;. Values can be &quot;binary&quot;, &quot;count&quot; or &quot;tf-idf&quot;, configuring the layer as follows: &quot;binary&quot;: Outputs a single int array per batch, of either vocab_size or max_tokens size, containing 1s in all elements where the token mapped to that index exists at least once in the batch item. &quot;count&quot;: As &quot;binary&quot;, but the int array contains a count of the number of times the token at that index appeared in the batch item. &quot;tf-idf&quot;: As &quot;binary&quot;, but the TF-IDF algorithm is applied to find the value in each token slot.</source>
          <target state="translated">Specification for the output of the layer. Defaults to &quot;binary&quot;. Values can be &quot;binary&quot;, &quot;count&quot; or &quot;tf-idf&quot;, configuring the layer as follows: &quot;binary&quot;: Outputs a single int array per batch, of either vocab_size or max_tokens size, containing 1s in all elements where the token mapped to that index exists at least once in the batch item. &quot;count&quot;: As &quot;binary&quot;, but the int array contains a count of the number of times the token at that index appeared in the batch item. &quot;tf-idf&quot;: As &quot;binary&quot;, but the TF-IDF algorithm is applied to find the value in each token slot.</target>
        </trans-unit>
        <trans-unit id="0c8f3483a76d71d8bb0d00a6d0eabe91ca24c35a" translate="yes" xml:space="preserve">
          <source>Specification of target device.</source>
          <target state="translated">대상 장치의 사양</target>
        </trans-unit>
        <trans-unit id="fb83322fdf8c262876d78cb727d403b2970f108f" translate="yes" xml:space="preserve">
          <source>Specified by &lt;code&gt;output_shape&lt;/code&gt; argument</source>
          <target state="translated">Specified by &lt;code&gt;output_shape&lt;/code&gt; argument</target>
        </trans-unit>
        <trans-unit id="ea883e74b6a3843ac1a29b4ff2add9d3a018b23d" translate="yes" xml:space="preserve">
          <source>Specifies a TensorFlow value type.</source>
          <target state="translated">TensorFlow 값 유형을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="b14fa4e629580a37533f3fdd00fb901d2f01863b" translate="yes" xml:space="preserve">
          <source>Specifies additional arguments to be passed to the enclosing while_loop.</source>
          <target state="translated">Specifies additional arguments to be passed to the enclosing while_loop.</target>
        </trans-unit>
        <trans-unit id="4f8e54eb07c8ef1f0bb9beb5c80869956ccc814c" translate="yes" xml:space="preserve">
          <source>Specifies how the initial cluster centers are chosen. One of the following: * a tensor or numpy array with the initial cluster centers. * a callable &lt;code&gt;f(inputs, k)&lt;/code&gt; that selects and returns up to &lt;code&gt;k&lt;/code&gt; centers from an input batch. &lt;code&gt;f&lt;/code&gt; is free to return any number of centers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;k&lt;/code&gt;. It will be invoked on successive input batches as necessary until all &lt;code&gt;num_clusters&lt;/code&gt; centers are chosen.</source>
          <target state="translated">Specifies how the initial cluster centers are chosen. One of the following: * a tensor or numpy array with the initial cluster centers. * a callable &lt;code&gt;f(inputs, k)&lt;/code&gt; that selects and returns up to &lt;code&gt;k&lt;/code&gt; centers from an input batch. &lt;code&gt;f&lt;/code&gt; is free to return any number of centers from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;k&lt;/code&gt; . It will be invoked on successive input batches as necessary until all &lt;code&gt;num_clusters&lt;/code&gt; centers are chosen.</target>
        </trans-unit>
        <trans-unit id="9a48f07e1a4fe0d4805753bda46239c41d040c75" translate="yes" xml:space="preserve">
          <source>Specifies pooling operation, must be &quot;AVG&quot; or &quot;MAX&quot;.</source>
          <target state="translated">Specifies pooling operation, must be &quot;AVG&quot; or &quot;MAX&quot;.</target>
        </trans-unit>
        <trans-unit id="50ddb4ee8c52d872568fecc64ff41f8830ff5dee" translate="yes" xml:space="preserve">
          <source>Specifies that a flag is a key flag for a module.</source>
          <target state="translated">플래그가 모듈의 키 플래그임을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="60e17bd62fb185088c8acaab226bfbeedef8f34c" translate="yes" xml:space="preserve">
          <source>Specifies that ops of type &lt;code&gt;op_type&lt;/code&gt; is not differentiable.</source>
          <target state="translated">&lt;code&gt;op_type&lt;/code&gt; 유형의 op를 구별 할 수 없도록 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="12365a41b5aa31f5b19fd0fc0145e72191eee359" translate="yes" xml:space="preserve">
          <source>Specifies the Riemann summation method used (&lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_sum&quot;&gt;https://en.wikipedia.org/wiki/Riemann_sum&lt;/a&gt;): 'trapezoidal' [default] that applies the trapezoidal rule; 'careful_interpolation', a variant of it differing only by a more correct interpolation scheme for PR-AUC - interpolating (true/false) positives but not the ratio that is precision; 'minoring' that applies left summation for increasing intervals and right summation for decreasing intervals; 'majoring' that does the opposite. Note that 'careful_interpolation' is strictly preferred to 'trapezoidal' (to be deprecated soon) as it applies the same method for ROC, and a better one (see Davis &amp;amp; Goadrich 2006 for details) for the PR curve.</source>
          <target state="translated">Specifies the Riemann summation method used (&lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_sum&quot;&gt;https://en.wikipedia.org/wiki/Riemann_sum&lt;/a&gt;): 'trapezoidal' [default] that applies the trapezoidal rule; 'careful_interpolation', a variant of it differing only by a more correct interpolation scheme for PR-AUC - interpolating (true/false) positives but not the ratio that is precision; 'minoring' that applies left summation for increasing intervals and right summation for decreasing intervals; 'majoring' that does the opposite. Note that 'careful_interpolation' is strictly preferred to 'trapezoidal' (to be deprecated soon) as it applies the same method for ROC, and a better one (see Davis &amp;amp; Goadrich 2006 for details) for the PR curve.</target>
        </trans-unit>
        <trans-unit id="a60e012592deb2a21071b5ebbba778d9c0dd8447" translate="yes" xml:space="preserve">
          <source>Specifies the address of the dispatcher.</source>
          <target state="translated">Specifies the address of the dispatcher.</target>
        </trans-unit>
        <trans-unit id="847ad11bfeecb8d48ed0c0033c02e5d0d9d05fd9" translate="yes" xml:space="preserve">
          <source>Specifies the device for ops created/executed in this context.</source>
          <target state="translated">이 컨텍스트에서 작성 / 실행 된 조작에 대한 디바이스를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8ab4832f2706bba7781b4a6050175a12aa0c94b9" translate="yes" xml:space="preserve">
          <source>Specifies the dimension to reduce along within each replica's tensor. Should typically be set to the batch dimension, or &lt;code&gt;None&lt;/code&gt; to only reduce across replicas (e.g. if the tensor has no batch dimension).</source>
          <target state="translated">Specifies the dimension to reduce along within each replica's tensor. Should typically be set to the batch dimension, or &lt;code&gt;None&lt;/code&gt; to only reduce across replicas (e.g. if the tensor has no batch dimension).</target>
        </trans-unit>
        <trans-unit id="77e8903838f80452c5cfc729dea4247083f92031" translate="yes" xml:space="preserve">
          <source>Specifies the length of each sequence in inputs. An int32 or int64 vector (tensor) size &lt;code&gt;[batch_size]&lt;/code&gt;, values in &lt;code&gt;[0, T)&lt;/code&gt;.</source>
          <target state="translated">Specifies the length of each sequence in inputs. An int32 or int64 vector (tensor) size &lt;code&gt;[batch_size]&lt;/code&gt; , values in &lt;code&gt;[0, T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffd3a5beb6180a98107520a1a7fc723aca4ad2f" translate="yes" xml:space="preserve">
          <source>Specifies the method used to combine gradient terms. Accepted values are constants defined in the class &lt;code&gt;AggregationMethod&lt;/code&gt;.</source>
          <target state="translated">Specifies the method used to combine gradient terms. Accepted values are constants defined in the class &lt;code&gt;AggregationMethod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c34ad5a470970817e09aaa324247d70e8e5125e" translate="yes" xml:space="preserve">
          <source>Specifies the method used to combine gradient terms. Valid values are defined in the class &lt;code&gt;AggregationMethod&lt;/code&gt;.</source>
          <target state="translated">Specifies the method used to combine gradient terms. Valid values are defined in the class &lt;code&gt;AggregationMethod&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88a50346386cac79e931b4315cf416e5d9625d6" translate="yes" xml:space="preserve">
          <source>Specifies the name of the curve to be computed, 'ROC' [default] or 'PR' for the Precision-Recall-curve.</source>
          <target state="translated">Specifies the name of the curve to be computed, 'ROC' [default] or 'PR' for the Precision-Recall-curve.</target>
        </trans-unit>
        <trans-unit id="a23f6051fc3fbb5815e141c943efca771d21b5b9" translate="yes" xml:space="preserve">
          <source>Specifies the ndim, dtype and shape of every input to a layer.</source>
          <target state="translated">레이어에 대한 모든 입력의 ndim, dtype 및 모양을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="8cc45caf8664c056edb3d054f7a7d6ace966e2c1" translate="yes" xml:space="preserve">
          <source>Specifies the port to bind to.</source>
          <target state="translated">Specifies the port to bind to.</target>
        </trans-unit>
        <trans-unit id="957b15c5bf93ae8e6b374647a345a022bff4b9b6" translate="yes" xml:space="preserve">
          <source>Specifies the port to bind to. A value of 0 indicates that the worker can bind to any available port.</source>
          <target state="translated">Specifies the port to bind to. A value of 0 indicates that the worker can bind to any available port.</target>
        </trans-unit>
        <trans-unit id="025e8c546c0a504a0fad6b1b253252ae904bbad5" translate="yes" xml:space="preserve">
          <source>Specifies the rank, dtype and shape of every input to a layer.</source>
          <target state="translated">Specifies the rank, dtype and shape of every input to a layer.</target>
        </trans-unit>
        <trans-unit id="479441c20bd6b05a03d87908a48b7f5bb9a7fc51" translate="yes" xml:space="preserve">
          <source>Specifies the response when an input string can't be converted using the indicated encoding. One of:</source>
          <target state="translated">Specifies the response when an input string can't be converted using the indicated encoding. One of:</target>
        </trans-unit>
        <trans-unit id="bf4af342c787b5318e7212cadbb826bc238bd9d4" translate="yes" xml:space="preserve">
          <source>Specifies the response when an invalid codepoint is encountered (optional). One of:</source>
          <target state="translated">Specifies the response when an invalid codepoint is encountered (optional). One of:</target>
        </trans-unit>
        <trans-unit id="17dc1bc89affaacc3206c6d8f591c91199d8edfc" translate="yes" xml:space="preserve">
          <source>Specifies whether operations are executed synchronously or asynchronously.</source>
          <target state="translated">작업이 동 기적으로 또는 비동기 적으로 실행 될지 여부를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="86a70a978ffb3c314d3fa9e073f9f1ebb89c519c" translate="yes" xml:space="preserve">
          <source>Specifies which &lt;code&gt;PhysicalDevice&lt;/code&gt; objects are visible to the runtime. TensorFlow will only allocate memory and place operations on visible physical devices, as otherwise no &lt;code&gt;LogicalDevice&lt;/code&gt; will be created on them. By default all discovered devices are marked as visible.</source>
          <target state="translated">런타임에 표시 할 &lt;code&gt;PhysicalDevice&lt;/code&gt; 개체를 지정 합니다. TensorFlow 만 그렇지 않으면로, 눈에 보이는 물리적 장치에 메모리와 장소에 작업을 할당합니다 &lt;code&gt;LogicalDevice&lt;/code&gt; 에 합니다. 가 생성 . 기본적으로 검색된 모든 장치는 표시되는 것으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1dc8e11dd50b0215e624b3b32a9d0f31a9f6f8b" translate="yes" xml:space="preserve">
          <source>Specify tensors to watch and their Jacobian-vector products.</source>
          <target state="translated">시청할 텐서와 Jacobian-vector 제품을 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="1f87b90a8d7793941c1404a83aa800fc278fa4cb" translate="yes" xml:space="preserve">
          <source>Specify the hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function to combine the crosses fingerprints on SparseCrossOp (optional).</source>
          <target state="translated">Specify the hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function to combine the crosses fingerprints on SparseCrossOp (optional).</target>
        </trans-unit>
        <trans-unit id="7cf0f0544b64dfcba20fcf156a1f0aae78a1fd62" translate="yes" xml:space="preserve">
          <source>Specify values using num_replicas_in_sync:</source>
          <target state="translated">Specify values using num_replicas_in_sync:</target>
        </trans-unit>
        <trans-unit id="b24d687c3187080c59435b4fefd44a5993c81aed" translate="yes" xml:space="preserve">
          <source>Specify what input/output index should this be in the final stub. i.e. add(arg0, index=1); add(arg1, index=0) will make the final stub be as stub_func(inputs[arg1, arg0], outputs=[]) rather than the default call order based ordering.</source>
          <target state="translated">Specify what input/output index should this be in the final stub. i.e. add(arg0, index=1); add(arg1, index=0) will make the final stub be as stub_func(inputs[arg1, arg0], outputs=[]) rather than the default call order based ordering.</target>
        </trans-unit>
        <trans-unit id="b5641c8d22b21d1e9602ce014b4719ee01c9c37b" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;''&lt;/code&gt; requests an in-process session that does not use RPC.</source>
          <target state="translated">&lt;code&gt;''&lt;/code&gt; 을 지정 하면 RPC를 사용하지 않는 프로세스 내 세션이 요청됩니다.</target>
        </trans-unit>
        <trans-unit id="405b7de568617cf3ae840e38096fa116bfa8c971" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;'grpc://hostname:port'&lt;/code&gt; requests a session that uses the RPC interface to a specific host, and also allows the in-process master to access remote tensorflow workers. Often, it is appropriate to pass &lt;code&gt;server.target&lt;/code&gt; (for some &lt;a href=&quot;../../../distribute/server&quot;&gt;&lt;code&gt;tf.distribute.Server&lt;/code&gt;&lt;/a&gt; named `server).</source>
          <target state="translated">&lt;code&gt;'grpc://hostname:port'&lt;/code&gt; 를 지정 하면 RPC 인터페이스를 사용하여 특정 호스트에 대한 세션을 요청하고 프로세스 내 마스터가 원격 tensorflow 작업자에 액세스 할 수 있습니다. 종종 &lt;code&gt;server.target&lt;/code&gt; ( `server라는 이름의 &lt;a href=&quot;../../../distribute/server&quot;&gt; &lt;code&gt;tf.distribute.Server&lt;/code&gt; )&lt;/a&gt; 을 전달하는 것이 적절합니다 .</target>
        </trans-unit>
        <trans-unit id="26bd73b0bd8bb18d70c2dc4595792f67ad9856b4" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;'local'&lt;/code&gt; requests a session that uses the RPC-based &quot;Master interface&quot; to run TensorFlow programs. See &lt;code&gt;tf.train.Server.create_local_server&lt;/code&gt; for details.</source>
          <target state="translated">&lt;code&gt;'local'&lt;/code&gt; 을 지정 하면 RPC 기반 &quot;마스터 인터페이스&quot;를 사용하여 TensorFlow 프로그램을 실행하는 세션이 요청됩니다. &lt;code&gt;tf.train.Server.create_local_server&lt;/code&gt; 를 참조하십시오 . 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="72b9c3a0e97721293f2206fc621aa349b807f2d6" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;fn&lt;/code&gt;'s output signature</source>
          <target state="translated">Specifying &lt;code&gt;fn&lt;/code&gt; 's output signature</target>
        </trans-unit>
        <trans-unit id="b8f602869139be49c749576d1dc9c96beb1909a8" translate="yes" xml:space="preserve">
          <source>Spectrograms are a standard way of representing audio information as a series of slices of frequency information, one slice for each window of time. By joining these together into a sequence, they form a distinctive fingerprint of the sound over time.</source>
          <target state="translated">Spectrograms are a standard way of representing audio information as a series of slices of frequency information, one slice for each window of time. By joining these together into a sequence, they form a distinctive fingerprint of the sound over time.</target>
        </trans-unit>
        <trans-unit id="9f40272d442956261d256d21bfad29eabcf1fd09" translate="yes" xml:space="preserve">
          <source>Spence</source>
          <target state="translated">Spence</target>
        </trans-unit>
        <trans-unit id="5a083194f353eafeb3b58817d4b4ec44ca83f437" translate="yes" xml:space="preserve">
          <source>Spence's integral is defined as the integral of &lt;code&gt;log(t) / (1 - t)&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, with the domain of definition all non-negative real numbers.</source>
          <target state="translated">Spence's integral is defined as the integral of &lt;code&gt;log(t) / (1 - t)&lt;/code&gt; from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; , with the domain of definition all non-negative real numbers.</target>
        </trans-unit>
        <trans-unit id="fc8230b4119ad4b994db2324d71f4e0ae7ad932c" translate="yes" xml:space="preserve">
          <source>Split</source>
          <target state="translated">Split</target>
        </trans-unit>
        <trans-unit id="e8d93b14898782206a27c2f623c3e13068558d40" translate="yes" xml:space="preserve">
          <source>Split a &lt;code&gt;SparseTensor&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; tensors along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 따라 &lt;code&gt;SparseTensor&lt;/code&gt; 를 &lt;code&gt;num_split&lt;/code&gt; 텐서 로 분할하십시오 .</target>
        </trans-unit>
        <trans-unit id="48c476197d75a69934319a7ec0da01331434b536" translate="yes" xml:space="preserve">
          <source>Split a &lt;code&gt;SparseTensor&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; tensors along &lt;code&gt;axis&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 따라 &lt;code&gt;SparseTensor&lt;/code&gt; 를 &lt;code&gt;num_split&lt;/code&gt; 텐서 로 분할하십시오 . (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="bcd7a6074afeef60305a9e51917dbd2dc92f5a1d" translate="yes" xml:space="preserve">
          <source>Split a &lt;code&gt;SparseTensor&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; tensors along one dimension.</source>
          <target state="translated">Split a &lt;code&gt;SparseTensor&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; tensors along one dimension.</target>
        </trans-unit>
        <trans-unit id="13b61710ceda0a0a714c192ec19ac0321dd2bcae" translate="yes" xml:space="preserve">
          <source>Split elements of &lt;code&gt;input&lt;/code&gt; based on &lt;code&gt;delimiter&lt;/code&gt; into a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">Split elements of &lt;code&gt;input&lt;/code&gt; based on &lt;code&gt;delimiter&lt;/code&gt; into a &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da7b9513b11ddbf83b6b96223d58f5a656aa657d" translate="yes" xml:space="preserve">
          <source>Split elements of &lt;code&gt;input&lt;/code&gt; based on &lt;code&gt;sep&lt;/code&gt; into a &lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 를 기준으로 &lt;code&gt;input&lt;/code&gt; 요소를 &lt;code&gt;RaggedTensor&lt;/code&gt; 로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="58404bb00065199a0e549c463f07be748d39a794" translate="yes" xml:space="preserve">
          <source>Split elements of &lt;code&gt;input&lt;/code&gt; based on &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 에 따라 &lt;code&gt;input&lt;/code&gt; 요소를 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="48ef48c846fb000283c6182d2a2c88def70c9079" translate="yes" xml:space="preserve">
          <source>Split elements of &lt;code&gt;source&lt;/code&gt; based on &lt;code&gt;delimiter&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">&lt;code&gt;delimiter&lt;/code&gt; 기준으로 &lt;code&gt;source&lt;/code&gt; 요소 분리 . (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="2879700e56cee4a5b7ddb5f51a7d51aed2bf2ce6" translate="yes" xml:space="preserve">
          <source>Split elements of &lt;code&gt;source&lt;/code&gt; based on &lt;code&gt;sep&lt;/code&gt; into a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">Split elements of &lt;code&gt;source&lt;/code&gt; based on &lt;code&gt;sep&lt;/code&gt; into a &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="feeb0afbc717961d923c1bb6d0a2cbd2235c11fc" translate="yes" xml:space="preserve">
          <source>Split string elements of &lt;code&gt;input&lt;/code&gt; into bytes.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 문자열 요소 를 바이트로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="aa097d95cb8c468c0c8027f0bcc4ad10ac5a28da" translate="yes" xml:space="preserve">
          <source>Split the data from the input value into TensorArray elements.</source>
          <target state="translated">Split the data from the input value into TensorArray elements.</target>
        </trans-unit>
        <trans-unit id="2ec109a46f53e7a89dab4ee2f80314ae2e476dd5" translate="yes" xml:space="preserve">
          <source>Split the values of a &lt;code&gt;Tensor&lt;/code&gt; into the TensorArray.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; 의 값을 TensorArray로 분할하십시오 .</target>
        </trans-unit>
        <trans-unit id="42b3e6748ecf4c86019b4b13e8182aba35dd9f29" translate="yes" xml:space="preserve">
          <source>SplitV</source>
          <target state="translated">SplitV</target>
        </trans-unit>
        <trans-unit id="25a449ed54bd4c309837dbd3e75f82a964157ff4" translate="yes" xml:space="preserve">
          <source>Splits a tensor &lt;code&gt;value&lt;/code&gt; into a list of sub tensors.</source>
          <target state="translated">Splits a tensor &lt;code&gt;value&lt;/code&gt; into a list of sub tensors.</target>
        </trans-unit>
        <trans-unit id="b7c1a0f03767e59e59975d449f7708b9b5087c95" translate="yes" xml:space="preserve">
          <source>Splits a tensor into &lt;code&gt;num_split&lt;/code&gt; tensors along one dimension.</source>
          <target state="translated">Splits a tensor into &lt;code&gt;num_split&lt;/code&gt; tensors along one dimension.</target>
        </trans-unit>
        <trans-unit id="0d4979a7a7d36e70cdbdf010a56fd476f1189fb6" translate="yes" xml:space="preserve">
          <source>Splits a tensor into a list.</source>
          <target state="translated">Splits a tensor into a list.</target>
        </trans-unit>
        <trans-unit id="2525a2c7ac0234994f7780711bb8b426b3f60464" translate="yes" xml:space="preserve">
          <source>Splits a tensor into sub tensors.</source>
          <target state="translated">텐서를 하위 텐서로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="270fb145355f34928eb378f975df5b66f170373b" translate="yes" xml:space="preserve">
          <source>Splits an RNG seed into &lt;code&gt;num&lt;/code&gt; new seeds by adding a leading axis.</source>
          <target state="translated">Splits an RNG seed into &lt;code&gt;num&lt;/code&gt; new seeds by adding a leading axis.</target>
        </trans-unit>
        <trans-unit id="4d43c36bbfca1a538b2005f5a195827db6f584b5" translate="yes" xml:space="preserve">
          <source>Splits each rank-N &lt;a href=&quot;../../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt; in this dataset row-wise. (deprecated)</source>
          <target state="translated">이 데이터 세트에서 각 순위 N &lt;a href=&quot;../../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; 를 행 단위로 분할합니다 . (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="9dd58b51a29333666bb6c49f7f55516391e02899" translate="yes" xml:space="preserve">
          <source>Splits each rank-N &lt;a href=&quot;../../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; in this dataset row-wise. (deprecated)</source>
          <target state="translated">Splits each rank-N &lt;a href=&quot;../../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; in this dataset row-wise. (deprecated)</target>
        </trans-unit>
        <trans-unit id="d2558021e23f8309108fd307b098699b10771f98" translate="yes" xml:space="preserve">
          <source>Splits each rank-N &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt; in this dataset row-wise. (deprecated)</source>
          <target state="translated">이 데이터 세트에서 각 순위 N &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; 를 행 단위로 분할합니다 . (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="3a1226452887d9eff5446eb8c3b72d94a498f8cd" translate="yes" xml:space="preserve">
          <source>Splits each rank-N &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; in this dataset row-wise. (deprecated)</source>
          <target state="translated">Splits each rank-N &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; in this dataset row-wise. (deprecated)</target>
        </trans-unit>
        <trans-unit id="f4d1aaee79561119dd0a5d338e2a7ca4f1422ce7" translate="yes" xml:space="preserve">
          <source>Splits each string in &lt;code&gt;input&lt;/code&gt; into a sequence of Unicode code points.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 각 문자열을 일련의 유니 코드 코드 포인트로 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="94584a38ee61d0af4ef0ac0752e5ef4eaa3d1dc9" translate="yes" xml:space="preserve">
          <source>Splits each string into a sequence of code points with start offsets.</source>
          <target state="translated">각 문자열을 시작 오프셋이있는 일련의 코드 포인트로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="c47b3f827bb53db64e834684eba00cbf35296512" translate="yes" xml:space="preserve">
          <source>Splits elements of a dataset into multiple elements on the batch dimension. (deprecated)</source>
          <target state="translated">배치 차원에서 데이터 집합의 요소를 여러 요소로 분할합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="b8bd28acaf2b895effd8654557c3dacbebf4a2c4" translate="yes" xml:space="preserve">
          <source>Splits elements of a dataset into multiple elements.</source>
          <target state="translated">데이터 세트의 요소를 여러 요소로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="97aa05f8add5a99aac5af8515bc87ecc98cf108e" translate="yes" xml:space="preserve">
          <source>SqlDataset</source>
          <target state="translated">SqlDataset</target>
        </trans-unit>
        <trans-unit id="6bbb118b36018412cea4de47bc914f00685c9ac5" translate="yes" xml:space="preserve">
          <source>Sqrt</source>
          <target state="translated">Sqrt</target>
        </trans-unit>
        <trans-unit id="f51c4940eeb1c607be0038995aa17ad0642b145b" translate="yes" xml:space="preserve">
          <source>SqrtGrad</source>
          <target state="translated">SqrtGrad</target>
        </trans-unit>
        <trans-unit id="82810cb97184cf542141f811b63d90bc5de31d1b" translate="yes" xml:space="preserve">
          <source>Square</source>
          <target state="translated">Square</target>
        </trans-unit>
        <trans-unit id="1ae6dd836b1e60558f43e8ef31eda2b8306442d8" translate="yes" xml:space="preserve">
          <source>Squared hinge loss values. shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt;.</source>
          <target state="translated">Squared hinge loss values. shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f12d31a6bd87230a11338cd4f02ec5d2853d03df" translate="yes" xml:space="preserve">
          <source>SquaredDifference</source>
          <target state="translated">SquaredDifference</target>
        </trans-unit>
        <trans-unit id="92c9ea71c15cbb09e5ae60de5a8ab0f25d70a156" translate="yes" xml:space="preserve">
          <source>Squeeze</source>
          <target state="translated">Squeeze</target>
        </trans-unit>
        <trans-unit id="83e5a0d3d2ef19df258412a4d3ef3f9533b0c0c1" translate="yes" xml:space="preserve">
          <source>Stack</source>
          <target state="translated">Stack</target>
        </trans-unit>
        <trans-unit id="47dd9a3d44ce99e3bbd366c9c91a60fc96281e66" translate="yes" xml:space="preserve">
          <source>Stack Overflow</source>
          <target state="translated">Stack Overflow</target>
        </trans-unit>
        <trans-unit id="bb2418f859198c7d1e798390c6339d300b7da63d" translate="yes" xml:space="preserve">
          <source>StackClose</source>
          <target state="translated">StackClose</target>
        </trans-unit>
        <trans-unit id="9f86bb372bf423c19d02b2f210bb8dd7938057cf" translate="yes" xml:space="preserve">
          <source>StackCloseV2</source>
          <target state="translated">StackCloseV2</target>
        </trans-unit>
        <trans-unit id="13caa61340d124de01583d0562b008d7dcf4eab1" translate="yes" xml:space="preserve">
          <source>StackPop</source>
          <target state="translated">StackPop</target>
        </trans-unit>
        <trans-unit id="9e82f03cbcf0bfde09bf1731036c4614799f312b" translate="yes" xml:space="preserve">
          <source>StackPopV2</source>
          <target state="translated">StackPopV2</target>
        </trans-unit>
        <trans-unit id="70c96797060f727c342a012ca5826333a270498a" translate="yes" xml:space="preserve">
          <source>StackPush</source>
          <target state="translated">StackPush</target>
        </trans-unit>
        <trans-unit id="9bc99bdb31798279909235b7267767b01b53463b" translate="yes" xml:space="preserve">
          <source>StackPushV2</source>
          <target state="translated">StackPushV2</target>
        </trans-unit>
        <trans-unit id="9801c21c3345eeaac64b9cbdf7297998a6db5c76" translate="yes" xml:space="preserve">
          <source>StackV2</source>
          <target state="translated">StackV2</target>
        </trans-unit>
        <trans-unit id="c3dcf86335eb4dcd9df560b318acb47a8f5d257d" translate="yes" xml:space="preserve">
          <source>Stacks a list of rank &lt;code&gt;R&lt;/code&gt; tensors into a rank &lt;code&gt;R+1&lt;/code&gt; tensor.</source>
          <target state="translated">순위 &lt;code&gt;R&lt;/code&gt; 텐서 목록을 순위 &lt;code&gt;R+1&lt;/code&gt; 텐서에 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="a8f192bcec355d760ffbcfb5d4356d125221a71c" translate="yes" xml:space="preserve">
          <source>Stacks a list of rank-&lt;code&gt;R&lt;/code&gt; tensors into one rank-&lt;code&gt;(R+1)&lt;/code&gt; tensor in parallel.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 등급 텐서 목록 을 하나의 등급으로 쌓습니다 &lt;code&gt;(R+1)&lt;/code&gt; . 병렬 텐서에 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="411d8e2a06e5fa2c606474dc5fbe557c7d2ba8bb" translate="yes" xml:space="preserve">
          <source>Stacks a list of rank-&lt;code&gt;R&lt;/code&gt; tensors into one rank-&lt;code&gt;(R+1)&lt;/code&gt; tensor.</source>
          <target state="translated">순위 &lt;code&gt;R&lt;/code&gt; 텐서 목록 을 하나 의 순위 &lt;code&gt;(R+1)&lt;/code&gt; 텐서에 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="07a81968a5e580e3ddc7f3c1dfe616f113f25eb2" translate="yes" xml:space="preserve">
          <source>Stacks a list of rank-&lt;code&gt;R&lt;/code&gt; tensors into one rank-&lt;code&gt;(R+1)&lt;/code&gt;&lt;code&gt;RaggedTensor&lt;/code&gt;.</source>
          <target state="translated">순위 &lt;code&gt;R&lt;/code&gt; 텐서 목록 을 하나의 &lt;code&gt;RaggedTensor&lt;/code&gt; &lt;code&gt;(R+1)&lt;/code&gt; RaggedTensor로 쌓습니다 .</target>
        </trans-unit>
        <trans-unit id="3788bdbf6e9fb45cf211dfdc64d81ab60ac56b11" translate="yes" xml:space="preserve">
          <source>Stacks all tensors in the list.</source>
          <target state="translated">Stacks all tensors in the list.</target>
        </trans-unit>
        <trans-unit id="244b873bd8fa37f33bd8c2425d0c77e7748a72b7" translate="yes" xml:space="preserve">
          <source>Stacks dynamic partitions of a Tensor or RaggedTensor.</source>
          <target state="translated">Tensor 또는 RaggedTensor의 동적 파티션을 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="ca6d0e3aaa7d6cc0e9d9fe14eed28587f7ee1133" translate="yes" xml:space="preserve">
          <source>Stage</source>
          <target state="translated">Stage</target>
        </trans-unit>
        <trans-unit id="512ad68fcdcea5488ca457ac51e4251350f5a993" translate="yes" xml:space="preserve">
          <source>Stage (key, values) in the underlying container which behaves like a hashtable.</source>
          <target state="translated">Stage (key, values) in the underlying container which behaves like a hashtable.</target>
        </trans-unit>
        <trans-unit id="2e08c3cb63f032c8c16999eaeee9ece818cc3259" translate="yes" xml:space="preserve">
          <source>Stage (key, values) in the underlying container which behaves like a ordered</source>
          <target state="translated">Stage (key, values) in the underlying container which behaves like a ordered</target>
        </trans-unit>
        <trans-unit id="150ca4d5bb87e9f662a9254d47d485e02e90e6f4" translate="yes" xml:space="preserve">
          <source>Stage values similar to a lightweight Enqueue.</source>
          <target state="translated">Stage values similar to a lightweight Enqueue.</target>
        </trans-unit>
        <trans-unit id="e9db0ce530e0e3406692c3626215571ff7c1e17e" translate="yes" xml:space="preserve">
          <source>StageClear</source>
          <target state="translated">StageClear</target>
        </trans-unit>
        <trans-unit id="ca4cd8248268a1a015d8be8ae12c3f40b95b4e29" translate="yes" xml:space="preserve">
          <source>StagePeek</source>
          <target state="translated">StagePeek</target>
        </trans-unit>
        <trans-unit id="cfaff0bfbcd716db675c7ddfbebd0f108a568bca" translate="yes" xml:space="preserve">
          <source>StageSize</source>
          <target state="translated">StageSize</target>
        </trans-unit>
        <trans-unit id="65d8dacb9db9be4d466b11045f434d133a9ed75c" translate="yes" xml:space="preserve">
          <source>Standalone usage:</source>
          <target state="translated">Standalone usage:</target>
        </trans-unit>
        <trans-unit id="c79e6e247019a81999cc68e49d7a710622176286" translate="yes" xml:space="preserve">
          <source>Standard deviation is defined as,</source>
          <target state="translated">표준 편차는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="055d92b4a3c41965fe47264346978d7a3185cce9" translate="yes" xml:space="preserve">
          <source>Standard deviation of a tensor, alongside the specified axis.</source>
          <target state="translated">지정된 축과 함께 텐서의 표준 편차.</target>
        </trans-unit>
        <trans-unit id="f587ab06e00878820f1cd40292d41463c1c70da5" translate="yes" xml:space="preserve">
          <source>Standard deviation of the values.</source>
          <target state="translated">Standard deviation of the values.</target>
        </trans-unit>
        <trans-unit id="df9f5f66c6d3882cf2305d67d9a9474489134d03" translate="yes" xml:space="preserve">
          <source>Standard deviation.</source>
          <target state="translated">표준 편차.</target>
        </trans-unit>
        <trans-unit id="b2ed39a6edbebcf3314654280c568f2b853932b1" translate="yes" xml:space="preserve">
          <source>Standard layer keyword arguments.</source>
          <target state="translated">Standard layer keyword arguments.</target>
        </trans-unit>
        <trans-unit id="f057b861993d91873adb8d03059b68337b2c76e0" translate="yes" xml:space="preserve">
          <source>Standard names for Estimator model modes.</source>
          <target state="translated">Estimator 모델 모드의 표준 이름.</target>
        </trans-unit>
        <trans-unit id="4f99c39141bb3ddf1a7d22eeab71658b76e3cad1" translate="yes" xml:space="preserve">
          <source>Standard names to use for graph collections.</source>
          <target state="translated">그래프 수집에 사용할 표준 이름입니다.</target>
        </trans-unit>
        <trans-unit id="594ca634eb315bc3997ded1357b2f6c715d7772e" translate="yes" xml:space="preserve">
          <source>Start a LooperThread that calls a function periodically.</source>
          <target state="translated">주기적으로 함수를 호출하는 LooperThread를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc1738890613981c8b7dcd677549d1557fc8771" translate="yes" xml:space="preserve">
          <source>Start a profiler grpc server that listens to given port.</source>
          <target state="translated">Start a profiler grpc server that listens to given port.</target>
        </trans-unit>
        <trans-unit id="ae481343527e6347255947874b0d3ca086c0b48f" translate="yes" xml:space="preserve">
          <source>Start a profiler server before your model runs.</source>
          <target state="translated">Start a profiler server before your model runs.</target>
        </trans-unit>
        <trans-unit id="15aa8e658d8f3e8d9e2bcd223fef378355b8f614" translate="yes" xml:space="preserve">
          <source>Start a step: fetch variables and compute gradients.</source>
          <target state="translated">변수를 가져오고 그라디언트를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="08ad0056ecc29209217961803b2e9f7137506856" translate="yes" xml:space="preserve">
          <source>Start by either creating a &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; normally or using &lt;code&gt;tf.distribute.experimental_make_numpy_dataset&lt;/code&gt; to make a dataset out of a &lt;code&gt;numpy&lt;/code&gt; array.</source>
          <target state="translated">&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 을&lt;/a&gt; 정상적으로 작성 하거나 &lt;code&gt;tf.distribute.experimental_make_numpy_dataset&lt;/code&gt; 을 사용하여 &lt;code&gt;numpy&lt;/code&gt; 배열 에서 데이터 세트를 작성하여 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="d86e406e531f06a60d2dee1e4984ec027b2308d0" translate="yes" xml:space="preserve">
          <source>Start the next batch.</source>
          <target state="translated">다음 배치를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="faf298f1e87c04adba60787926533cc120075122" translate="yes" xml:space="preserve">
          <source>Start the scope block.</source>
          <target state="translated">범위 블록을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="8cbf1285faa03571413d56c285dbab6cefc1bca8" translate="yes" xml:space="preserve">
          <source>Start the standard services for 'sess'.</source>
          <target state="translated">'sess'에 대한 표준 서비스를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="6981642129cbd20083e772ec5f952609a47be106" translate="yes" xml:space="preserve">
          <source>Start the thread's activity.</source>
          <target state="translated">스레드 활동을 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="83b5898849275d244f9dc1b3986f7cb88a3fa122" translate="yes" xml:space="preserve">
          <source>Start threads for &lt;code&gt;QueueRunners&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;QueueRunners&lt;/code&gt; 의 스레드를 시작하십시오 .</target>
        </trans-unit>
        <trans-unit id="7757abbbe7e321194f81d9a698c1ecb45b2b9c1f" translate="yes" xml:space="preserve">
          <source>Start value.</source>
          <target state="translated">Start value.</target>
        </trans-unit>
        <trans-unit id="edf1fcfb7060b839d58846461c7fe9ea1192ffb9" translate="yes" xml:space="preserve">
          <source>Starts a trace to record computation graphs and profiling information.</source>
          <target state="translated">계산 그래프 및 프로파일 링 정보를 기록하기위한 추적을 시작합니다.</target>
        </trans-unit>
        <trans-unit id="817af290c476c6f8d3234f21fb9c38bd1fc07a8f" translate="yes" xml:space="preserve">
          <source>Starts all queue runners collected in the graph. (deprecated)</source>
          <target state="translated">그래프에서 수집 된 모든 큐 러너를 시작합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="9a073842c749604aad721fad057a4487748943cb" translate="yes" xml:space="preserve">
          <source>Starts profiling.</source>
          <target state="translated">Starts profiling.</target>
        </trans-unit>
        <trans-unit id="8263038cce7fa6e464120a6a80cc9bb67343087c" translate="yes" xml:space="preserve">
          <source>Starts reading from current position in file.</source>
          <target state="translated">파일의 현재 위치에서 읽기를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="e91bf74af9bf0945d6f92cab271e149069e0083c" translate="yes" xml:space="preserve">
          <source>Starts the handler's workers.</source>
          <target state="translated">처리기의 작업자를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="d4baf635ff2545da5d38edb917b754f17529ea58" translate="yes" xml:space="preserve">
          <source>Starts this server.</source>
          <target state="translated">이 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="591c41300836381ed72d66bf8143018f27457ad0" translate="yes" xml:space="preserve">
          <source>Stateful kernels may mostly not be supported since these often imply a data dependency. We do support a limited set of such stateful kernels though (like RandomFoo, Variable operations like reads, etc).</source>
          <target state="translated">Stateful kernels may mostly not be supported since these often imply a data dependency. We do support a limited set of such stateful kernels though (like RandomFoo, Variable operations like reads, etc).</target>
        </trans-unit>
        <trans-unit id="4342bc56c343c89819e7b2431ab23a0028e31c50" translate="yes" xml:space="preserve">
          <source>Stateful operations, such as variables and queues, can maintain their states on devices so that they can be shared by multiple processes. A resource container is a string name under which these stateful operations are tracked. These resources can be released or cleared with &lt;code&gt;tf.Session.reset()&lt;/code&gt;.</source>
          <target state="translated">변수 및 대기열과 같은 상태 저장 작업은 여러 프로세스에서 공유 할 수 있도록 장치에서 상태를 유지할 수 있습니다. 리소스 컨테이너는 이러한 상태 저장 작업이 추적되는 문자열 이름입니다. 이러한 리소스는 &lt;code&gt;tf.Session.reset()&lt;/code&gt; 으로 해제하거나 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="470ef7e99a337614d3db5e7652076ca064b44c15" translate="yes" xml:space="preserve">
          <source>StatefulPartitionedCall</source>
          <target state="translated">StatefulPartitionedCall</target>
        </trans-unit>
        <trans-unit id="3e37de8f63bc4ee60f3be4e85ed692c36857e712" translate="yes" xml:space="preserve">
          <source>StatefulRandomBinomial</source>
          <target state="translated">StatefulRandomBinomial</target>
        </trans-unit>
        <trans-unit id="c9b7d2eb544dfaea36a6f11fa92e198521d02005" translate="yes" xml:space="preserve">
          <source>StatefulStandardNormal</source>
          <target state="translated">StatefulStandardNormal</target>
        </trans-unit>
        <trans-unit id="81fde8de69ec89de50351aebb7a476ed6408ed1b" translate="yes" xml:space="preserve">
          <source>StatefulStandardNormalV2</source>
          <target state="translated">StatefulStandardNormalV2</target>
        </trans-unit>
        <trans-unit id="2f2e659f9901f6777985b151ad4525534d4ff174" translate="yes" xml:space="preserve">
          <source>StatefulTruncatedNormal</source>
          <target state="translated">StatefulTruncatedNormal</target>
        </trans-unit>
        <trans-unit id="5b821af7889af4e9f3257ea8cf754e075cffdc6e" translate="yes" xml:space="preserve">
          <source>StatefulUniform</source>
          <target state="translated">StatefulUniform</target>
        </trans-unit>
        <trans-unit id="82c149f3853fe2a317afd45b3a57b818140613cc" translate="yes" xml:space="preserve">
          <source>StatefulUniformFullInt</source>
          <target state="translated">StatefulUniformFullInt</target>
        </trans-unit>
        <trans-unit id="fc34236d34ea55b6b1e4e05151c5cbe7b61c1cec" translate="yes" xml:space="preserve">
          <source>StatefulUniformInt</source>
          <target state="translated">StatefulUniformInt</target>
        </trans-unit>
        <trans-unit id="9a5be03c78b5380456d3eb66c29b71560f1427ad" translate="yes" xml:space="preserve">
          <source>StatelessIf</source>
          <target state="translated">StatelessIf</target>
        </trans-unit>
        <trans-unit id="45132510ddf051811a2e24394d60f2e5cbea7eab" translate="yes" xml:space="preserve">
          <source>StatelessMultinomial</source>
          <target state="translated">StatelessMultinomial</target>
        </trans-unit>
        <trans-unit id="c4adeb6736a66e16e5b199d05b6621f01008cc01" translate="yes" xml:space="preserve">
          <source>StatelessParameterizedTruncatedNormal</source>
          <target state="translated">StatelessParameterizedTruncatedNormal</target>
        </trans-unit>
        <trans-unit id="75fcc4c39071e609cd8ee650d8b3400b45804982" translate="yes" xml:space="preserve">
          <source>StatelessRandomBinomial</source>
          <target state="translated">StatelessRandomBinomial</target>
        </trans-unit>
        <trans-unit id="2be875fe6eed06ce71c03f028353b5a43a7364da" translate="yes" xml:space="preserve">
          <source>StatelessRandomGammaV2</source>
          <target state="translated">StatelessRandomGammaV2</target>
        </trans-unit>
        <trans-unit id="9e89654ec3c6d5e575033fd786de3be638da65db" translate="yes" xml:space="preserve">
          <source>StatelessRandomNormal</source>
          <target state="translated">StatelessRandomNormal</target>
        </trans-unit>
        <trans-unit id="d81eafeb6cdf9395df654cfb583b88913f018ed0" translate="yes" xml:space="preserve">
          <source>StatelessRandomPoisson</source>
          <target state="translated">StatelessRandomPoisson</target>
        </trans-unit>
        <trans-unit id="851d3d772bf0ae03814d50f90821f5dfa67e9db3" translate="yes" xml:space="preserve">
          <source>StatelessRandomUniform</source>
          <target state="translated">StatelessRandomUniform</target>
        </trans-unit>
        <trans-unit id="f7c6203d54e3016f06d47a455931f43bd254c843" translate="yes" xml:space="preserve">
          <source>StatelessRandomUniformFullInt</source>
          <target state="translated">StatelessRandomUniformFullInt</target>
        </trans-unit>
        <trans-unit id="e52b17ca770e07ad440d4dfa41953cc45d340af1" translate="yes" xml:space="preserve">
          <source>StatelessRandomUniformInt</source>
          <target state="translated">StatelessRandomUniformInt</target>
        </trans-unit>
        <trans-unit id="7408ba89f68041305f5b199abd1d5483ceea075a" translate="yes" xml:space="preserve">
          <source>StatelessTruncatedNormal</source>
          <target state="translated">StatelessTruncatedNormal</target>
        </trans-unit>
        <trans-unit id="dc5919faf6612eb2b6e2b7d02b1712501f0e4398" translate="yes" xml:space="preserve">
          <source>StatelessWhile</source>
          <target state="translated">StatelessWhile</target>
        </trans-unit>
        <trans-unit id="2656236f800a76ebc0f7b49c14ff22e2c68fde8c" translate="yes" xml:space="preserve">
          <source>Static assert that values is a &quot;proper&quot; iterable.</source>
          <target state="translated">정적은 값이 &quot;적절한&quot;반복 가능하다고 주장합니다.</target>
        </trans-unit>
        <trans-unit id="6404383a96f28b8d17ebe74b018f2fd9a3dfb2c4" translate="yes" xml:space="preserve">
          <source>StaticRegexFullMatch</source>
          <target state="translated">StaticRegexFullMatch</target>
        </trans-unit>
        <trans-unit id="a2f5bda1343921dac2592657a3c1bb673f354eb4" translate="yes" xml:space="preserve">
          <source>StaticRegexReplace</source>
          <target state="translated">StaticRegexReplace</target>
        </trans-unit>
        <trans-unit id="ffa05fac8dc7f5a7d7afa20754fed148f2437c90" translate="yes" xml:space="preserve">
          <source>Statically asserts that the given &lt;code&gt;Tensor&lt;/code&gt; is of the specified type.</source>
          <target state="translated">주어진 &lt;code&gt;Tensor&lt;/code&gt; 가 지정된 유형 임을 정적으로 주장합니다 .</target>
        </trans-unit>
        <trans-unit id="60df8ae87178e3ec5ce8d8d0fa30901d76174405" translate="yes" xml:space="preserve">
          <source>Stats return +/- infinity when it makes sense. E.g., the variance of a Cauchy distribution is infinity. However, sometimes the statistic is undefined, e.g., if a distribution's pdf does not achieve a maximum within the support of the distribution, the mode is undefined. If the mean is undefined, then by definition the variance is undefined. E.g. the mean for Student's T for df = 1 is undefined (no clear way to say it is either + or - infinity), so the variance = E[(X - mean)**2] is also undefined.</source>
          <target state="translated">의미가있는 경우 통계는 +/- 무한대를 반환합니다. 예를 들어, 코시 분포의 분산은 무한대입니다. 그러나 때로는 통계가 정의되지 않은 경우도 있습니다. 예를 들어, 배포의 pdf가 배포 지원 범위 내에서 최대 값을 달성하지 못하면 모드가 정의되지 않습니다. 평균이 정의되지 않은 경우 정의에 따라 분산이 정의되지 않습니다. 예를 들어 df = 1에 대한 Student 's T의 평균은 정의되지 않았으므로 (+ 또는-무한대라고 말할 수있는 명확한 방법은 없음) 분산 = E [(X-mean) ** 2]도 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6962066f13db78a5ec454a5212c06058d2fdec79" translate="yes" xml:space="preserve">
          <source>StatsAggregatorHandle</source>
          <target state="translated">StatsAggregatorHandle</target>
        </trans-unit>
        <trans-unit id="bb4c77d29cd93db23e1093847eb5102b70ff53c6" translate="yes" xml:space="preserve">
          <source>StatsAggregatorHandleV2</source>
          <target state="translated">StatsAggregatorHandleV2</target>
        </trans-unit>
        <trans-unit id="85f41c0c302400d570031378359d9fb2792db5b3" translate="yes" xml:space="preserve">
          <source>StatsAggregatorSetSummaryWriter</source>
          <target state="translated">StatsAggregatorSetSummaryWriter</target>
        </trans-unit>
        <trans-unit id="251ca3e57b703ac164fa43b12aef4db8dcee18d5" translate="yes" xml:space="preserve">
          <source>StatsAggregatorSummary</source>
          <target state="translated">StatsAggregatorSummary</target>
        </trans-unit>
        <trans-unit id="925338de78ef990dae5c63810e8a9d9dde59c9df" translate="yes" xml:space="preserve">
          <source>Stay connected</source>
          <target state="translated">Stay connected</target>
        </trans-unit>
        <trans-unit id="b2774225dd59a876c27c7596f3a484fcf70ccb49" translate="yes" xml:space="preserve">
          <source>Step after which to stop.</source>
          <target state="translated">Step after which to stop.</target>
        </trans-unit>
        <trans-unit id="1322357c8c718a7318abf7389375bbcd8dbb4afc" translate="yes" xml:space="preserve">
          <source>Steps 2 through 4 are done automatically by class &lt;a href=&quot;../../../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; if you call its &lt;a href=&quot;../../../keras/optimizers/optimizer#apply_gradients&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt;&lt;/a&gt; method in a replica context.</source>
          <target state="translated">Steps 2 through 4 are done automatically by class &lt;a href=&quot;../../../keras/optimizers/optimizer&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt; &lt;/a&gt; if you call its &lt;a href=&quot;../../../keras/optimizers/optimizer#apply_gradients&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt; &lt;/a&gt; method in a replica context.</target>
        </trans-unit>
        <trans-unit id="22071530d6c4d9de4a3df64a6b62d022124955f6" translate="yes" xml:space="preserve">
          <source>Steps 2 through 4 are done automatically by class &lt;a href=&quot;../../../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; if you call its &lt;a href=&quot;../../../keras/optimizers/optimizer#apply_gradients&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt;&lt;/a&gt; method in a replica context. They are also done automatically if you call an &lt;code&gt;assign*&lt;/code&gt; method on a (non sync-on-read) variable that was constructed with an aggregation method (which is used to determine the reduction used in step 3).</source>
          <target state="translated">복제 컨텍스트에서 &lt;a href=&quot;../../../keras/optimizers/optimizer#apply_gradients&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하면 2-4 단계는 클래스 &lt;a href=&quot;../../../keras/optimizers/optimizer&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 수행됩니다 . 또한 집계 방법 (3 단계에서 사용 된 감소를 결정하는 데 사용됨)으로 구성된 (읽지 않은 비 동기화) 변수 에서 &lt;code&gt;assign*&lt;/code&gt; 메서드 를 호출하면 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2aba5eee442d591a15fb0bb2a0c84b437adb7da8" translate="yes" xml:space="preserve">
          <source>Steps 2 through 4 are done automatically by class &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; if you call its &lt;a href=&quot;../keras/optimizers/optimizer#apply_gradients&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt;&lt;/a&gt; method in a replica context.</source>
          <target state="translated">Steps 2 through 4 are done automatically by class &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt; &lt;/a&gt; if you call its &lt;a href=&quot;../keras/optimizers/optimizer#apply_gradients&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt; &lt;/a&gt; method in a replica context.</target>
        </trans-unit>
        <trans-unit id="f210a94770e322853957792583d184bd18568f9b" translate="yes" xml:space="preserve">
          <source>Steps 2 through 4 are done automatically by class &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt; if you call its &lt;a href=&quot;../keras/optimizers/optimizer#apply_gradients&quot;&gt;&lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt;&lt;/a&gt; method in a replica context. They are also done automatically if you call an &lt;code&gt;assign*&lt;/code&gt; method on a (non sync-on-read) variable that was constructed with an aggregation method (which is used to determine the reduction used in step 3).</source>
          <target state="translated">복제 컨텍스트에서 &lt;a href=&quot;../keras/optimizers/optimizer#apply_gradients&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer.apply_gradients&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하면 2-4 단계는 클래스 &lt;a href=&quot;../keras/optimizers/optimizer&quot;&gt; &lt;code&gt;tf.keras.optimizers.Optimizer&lt;/code&gt; 에&lt;/a&gt; 의해 자동으로 수행됩니다 . 또한 집계 방법 (3 단계에서 사용 된 감소를 결정하는 데 사용됨)으로 구성된 (읽지 않은 비 동기화) 변수 에서 &lt;code&gt;assign*&lt;/code&gt; 메서드 를 호출하면 자동으로 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="85a411ea2f2761d1ddcb88eb51ad0e8e10187389" translate="yes" xml:space="preserve">
          <source>Stochastic Dual Coordinate Ascent helper for linear estimators.</source>
          <target state="translated">선형 추정기의 확률 적 이중 좌표 상승 도우미.</target>
        </trans-unit>
        <trans-unit id="2e20f05c0478db17b96bfc4f1f237857a37fd196" translate="yes" xml:space="preserve">
          <source>Stochastic Gradient Descent with Warm Restarts: &lt;a href=&quot;https://openreview.net/forum?id=Skq89Scxx&amp;amp;noteId=Skq89Scxx&quot;&gt;Loshchilov et al., 2017&lt;/a&gt; (&lt;a href=&quot;https://openreview.net/pdf?id=Skq89Scxx&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="translated">Stochastic Gradient Descent with Warm Restarts: &lt;a href=&quot;https://openreview.net/forum?id=Skq89Scxx&amp;amp;noteId=Skq89Scxx&quot;&gt;Loshchilov et al., 2017&lt;/a&gt; (&lt;a href=&quot;https://openreview.net/pdf?id=Skq89Scxx&quot;&gt;pdf&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="5db97c77f8ae58c61c9d9965b48bf1937ae6418f" translate="yes" xml:space="preserve">
          <source>Stochastic gradient descent and momentum optimizer.</source>
          <target state="translated">확률 적 경사 하강 및 운동량 최적화.</target>
        </trans-unit>
        <trans-unit id="133b83393780c8ea9a29cf07bcedf37ff11c6738" translate="yes" xml:space="preserve">
          <source>Stop condition: In order to support both distributed and non-distributed configuration reliably, the only supported stop condition for model training is &lt;code&gt;train_spec.max_steps&lt;/code&gt;. If &lt;code&gt;train_spec.max_steps&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the model is trained forever. &lt;em&gt;Use with care&lt;/em&gt; if model stop condition is different. For example, assume that the model is expected to be trained with one epoch of training data, and the training &lt;code&gt;input_fn&lt;/code&gt; is configured to throw &lt;code&gt;OutOfRangeError&lt;/code&gt; after going through one epoch, which stops the &lt;a href=&quot;../compat/v1/estimator/estimator#train&quot;&gt;&lt;code&gt;Estimator.train&lt;/code&gt;&lt;/a&gt;. For a three-training-worker distributed configuration, each training worker is likely to go through the whole epoch independently. So, the model will be trained with three epochs of training data instead of one epoch.</source>
          <target state="translated">정지 조건 : 분산 및 비 분산 구성을 확실하게 지원하기 위해 모델 교육에 지원되는 유일한 정지 조건은 &lt;code&gt;train_spec.max_steps&lt;/code&gt; 입니다. &lt;code&gt;train_spec.max_steps&lt;/code&gt; 인 경우 없습니다 &lt;code&gt;None&lt;/code&gt; 모델은 영원히 훈련. 모델 정지 조건이 다른 경우 &lt;em&gt;주의해서 사용하십시오&lt;/em&gt; . 예를 들어, 모델이 하나의 에포크 교육 데이터로 훈련 될 것으로 예상되고, 훈련 &lt;code&gt;input_fn&lt;/code&gt; 이 하나의 에포크를 &lt;code&gt;OutOfRangeError&lt;/code&gt; 후 OutOfRangeError를 발생 시키도록 구성되어 &lt;a href=&quot;../compat/v1/estimator/estimator#train&quot;&gt; &lt;code&gt;Estimator.train&lt;/code&gt; &lt;/a&gt; 을 중지 한다고 가정 하십시오.. 3 명의 교육 담당자 분산 구성의 경우 각 교육 담당자는 전체 시대를 독립적으로 거치게됩니다. 따라서 모델은 하나의 에포크 대신 세 개의 에포크 교육 데이터로 학습됩니다.</target>
        </trans-unit>
        <trans-unit id="0b73c19e56bb305894a3de5407fb01e4f9a8fe89" translate="yes" xml:space="preserve">
          <source>Stop the services and the coordinator.</source>
          <target state="translated">서비스와 코디네이터를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="178bf5a0d6795a75dd8c77a8ab5f64c90f1e95c4" translate="yes" xml:space="preserve">
          <source>Stop training when a monitored metric has stopped improving.</source>
          <target state="translated">Stop training when a monitored metric has stopped improving.</target>
        </trans-unit>
        <trans-unit id="acaf908480f4f7513719d5d37193f12e822e8df4" translate="yes" xml:space="preserve">
          <source>Stop training when a monitored quantity has stopped improving.</source>
          <target state="translated">모니터링 된 수량의 개선이 중단되면 훈련을 중단하십시오.</target>
        </trans-unit>
        <trans-unit id="6bd0877ac923e27bfb355d76a07759435944808f" translate="yes" xml:space="preserve">
          <source>Stop value.</source>
          <target state="translated">Stop value.</target>
        </trans-unit>
        <trans-unit id="04a2f3a1b1a88e057de7815aa5765999e45ceae0" translate="yes" xml:space="preserve">
          <source>StopGradient</source>
          <target state="translated">StopGradient</target>
        </trans-unit>
        <trans-unit id="5492e7af5bc227efd8741534cde9d83c515b2fee" translate="yes" xml:space="preserve">
          <source>StopIteration</source>
          <target state="translated">StopIteration</target>
        </trans-unit>
        <trans-unit id="7ca958edd4ae9334803b83d98f9fa435aceacaef" translate="yes" xml:space="preserve">
          <source>Stops and exports the active trace as a Summary and/or profile file.</source>
          <target state="translated">활성 추적을 요약 및 / 또는 프로필 파일로 중지하고 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="55a9229e4f89292e865188cb6a0d2d8542aff987" translate="yes" xml:space="preserve">
          <source>Stops gradient computation.</source>
          <target state="translated">그래디언트 계산을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="e4e14f4106f6a3870d0e38ef853369d42ee937fd" translate="yes" xml:space="preserve">
          <source>Stops running threads and wait for them to exit, if necessary.</source>
          <target state="translated">스레드 실행을 중지하고 필요한 경우 종료 될 때까지 기다리십시오.</target>
        </trans-unit>
        <trans-unit id="fcd54636ab3abf45ce6ada0f0d4fc3e14d23ab86" translate="yes" xml:space="preserve">
          <source>Stops the current profiling session.</source>
          <target state="translated">Stops the current profiling session.</target>
        </trans-unit>
        <trans-unit id="9b208b5f31ff1c56cafbcbee9b5e3c8091431b21" translate="yes" xml:space="preserve">
          <source>Stops the current trace and discards any collected information.</source>
          <target state="translated">현재 추적을 중지하고 수집 된 정보를 버립니다.</target>
        </trans-unit>
        <trans-unit id="2d87fc3a0f3a70413df9f203b126effeeeda2c89" translate="yes" xml:space="preserve">
          <source>Stops the trace and exports all metadata collected during the trace to the default SummaryWriter, if one has been set.</source>
          <target state="translated">추적을 중지하고 추적 중에 수집 된 모든 메타 데이터를 설정된 경우 기본 SummaryWriter로 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="b06e8e16410bacae116aaf4c85d647ff5691dee0" translate="yes" xml:space="preserve">
          <source>Store the input tensor in the state of the current session.</source>
          <target state="translated">Store the input tensor in the state of the current session.</target>
        </trans-unit>
        <trans-unit id="498891dd84278fabc1afd5025cb9d7776029cb2e" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;value&lt;/code&gt; in the collection with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">주어진 &lt;code&gt;name&lt;/code&gt; 컬렉션에 &lt;code&gt;value&lt;/code&gt; 을 저장 합니다 .</target>
        </trans-unit>
        <trans-unit id="7487de8aca0f8eb26902fa7d5921abad1adb56f6" translate="yes" xml:space="preserve">
          <source>Stores &lt;code&gt;value&lt;/code&gt; in the collections given by &lt;code&gt;names&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 지정된 컬렉션에 &lt;code&gt;value&lt;/code&gt; 을 저장 합니다 .</target>
        </trans-unit>
        <trans-unit id="a8ad5005cffff07e7ce60dc5e8a6e835ce897462" translate="yes" xml:space="preserve">
          <source>Stores two elements: &lt;code&gt;(c, h)&lt;/code&gt;, in that order. Where &lt;code&gt;c&lt;/code&gt; is the hidden state and &lt;code&gt;h&lt;/code&gt; is the output.</source>
          <target state="translated">&lt;code&gt;(c, h)&lt;/code&gt; 두 요소 를 순서대로 저장합니다. 여기서 &lt;code&gt;c&lt;/code&gt; 는 숨겨진 상태이고 &lt;code&gt;h&lt;/code&gt; 는 출력입니다.</target>
        </trans-unit>
        <trans-unit id="d91fe2f0e655f4368f035ab16882f26aec617b28" translate="yes" xml:space="preserve">
          <source>Storing 2 bands of a 3x3 matrix. Note that first element in the second row is ignored due to the 'LEFT_RIGHT' padding.</source>
          <target state="translated">Storing 2 bands of a 3x3 matrix. Note that first element in the second row is ignored due to the 'LEFT_RIGHT' padding.</target>
        </trans-unit>
        <trans-unit id="7e2dcead89ab3619bfd615aad51c544f9429db86" translate="yes" xml:space="preserve">
          <source>Storing 2 superdiagonals of a 4x4 matrix. Because of the 'LEFT_RIGHT' padding the last element of the first row is ignored.</source>
          <target state="translated">Storing 2 superdiagonals of a 4x4 matrix. Because of the 'LEFT_RIGHT' padding the last element of the first row is ignored.</target>
        </trans-unit>
        <trans-unit id="a82e4ae2851cfeda98353075ffa62140368519f1" translate="yes" xml:space="preserve">
          <source>Str (default: &lt;code&gt;''&lt;/code&gt;). Prefix to use for filenames of saved pictures (only relevant if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="translated">Str (default: &lt;code&gt;''&lt;/code&gt; ). Prefix to use for filenames of saved pictures (only relevant if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</target>
        </trans-unit>
        <trans-unit id="8ca55f830ec6dd6221a3560bb62ed0fa07fc6882" translate="yes" xml:space="preserve">
          <source>Str. Prefix to use for filenames of saved pictures (only relevant if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="translated">Str. Prefix to use for filenames of saved pictures (only relevant if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</target>
        </trans-unit>
        <trans-unit id="7c64f2665a01e26d35ae8ab108683aa71c9125b5" translate="yes" xml:space="preserve">
          <source>Strategies that intend to have an associated &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</source>
          <target state="translated">Strategies that intend to have an associated &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</target>
        </trans-unit>
        <trans-unit id="1c150005852c9b99b991127e9b0603b5216724ee" translate="yes" xml:space="preserve">
          <source>Strategies that intend to have an associated &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</source>
          <target state="translated">Strategies that intend to have an associated &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</target>
        </trans-unit>
        <trans-unit id="b65f23738d3d600c90b48a211073e4574e79d771" translate="yes" xml:space="preserve">
          <source>Strategies that intend to have an associated &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</source>
          <target state="translated">Strategies that intend to have an associated &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</target>
        </trans-unit>
        <trans-unit id="dce87deedac433f86019ae09a049c926cf20a63e" translate="yes" xml:space="preserve">
          <source>Strategies that intend to have an associated &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</source>
          <target state="translated">Strategies that intend to have an associated &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; must set the relevant attribute, or override this property; otherwise, &lt;code&gt;None&lt;/code&gt; is returned by default. Those strategies should also provide information regarding what is returned by this property.</target>
        </trans-unit>
        <trans-unit id="e1630086b72a99aef376059ae635df741b6845b2" translate="yes" xml:space="preserve">
          <source>Strategy to aggregate. Acceptable values are OpHint.AGGREGATE_FIRST, OpHint.AGGREGATE_LAST, and OpHint.AGGREGATE_STACK. Note, aggregate is only valid if tag is specified.</source>
          <target state="translated">Strategy to aggregate. Acceptable values are OpHint.AGGREGATE_FIRST, OpHint.AGGREGATE_LAST, and OpHint.AGGREGATE_STACK. Note, aggregate is only valid if tag is specified.</target>
        </trans-unit>
        <trans-unit id="2dae3f8a26c540bddc508bd4fc20a264913a3400" translate="yes" xml:space="preserve">
          <source>Strict nesting also applies to combinations of &lt;code&gt;ForwardAccumulator&lt;/code&gt; and &lt;a href=&quot;../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. More deeply nested &lt;code&gt;GradientTape&lt;/code&gt; objects will ignore the products of outer &lt;code&gt;ForwardAccumulator&lt;/code&gt; objects. This allows (for example) memory-efficient forward-over-backward computation of Hessian-vector products, where the inner &lt;code&gt;GradientTape&lt;/code&gt; would otherwise hold on to all intermediate JVPs:</source>
          <target state="translated">엄격한 중첩은 &lt;code&gt;ForwardAccumulator&lt;/code&gt; 와 &lt;a href=&quot;../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; 의&lt;/a&gt; 조합에도 적용됩니다 . 더 깊이 중첩 된 &lt;code&gt;GradientTape&lt;/code&gt; 객체는 외부 &lt;code&gt;ForwardAccumulator&lt;/code&gt; 객체 의 제품을 무시 합니다. 이를 통해 (예를 들어) 내부 &lt;code&gt;GradientTape&lt;/code&gt; 가 모든 중간 JVP를 유지할 수있는 Hessian- 벡터 제품의 메모리 효율적인 순방향 역전 계산이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="12a38590f790b0ac06d9406836155d6d1e3b3a6e" translate="yes" xml:space="preserve">
          <source>StridedSlice</source>
          <target state="translated">StridedSlice</target>
        </trans-unit>
        <trans-unit id="0df34b2d8e54fbf036d1b86fda2a402c4c2ebaca" translate="yes" xml:space="preserve">
          <source>StridedSliceAssign</source>
          <target state="translated">StridedSliceAssign</target>
        </trans-unit>
        <trans-unit id="47875586b3a2d66840adff7de5136b4e124e9604" translate="yes" xml:space="preserve">
          <source>StridedSliceGrad</source>
          <target state="translated">StridedSliceGrad</target>
        </trans-unit>
        <trans-unit id="dfd77fa0557e26459c08006318518445bec349dd" translate="yes" xml:space="preserve">
          <source>String (name of objective function), objective function or &lt;a href=&quot;../losses/loss&quot;&gt;&lt;code&gt;tf.keras.losses.Loss&lt;/code&gt;&lt;/a&gt; instance. See &lt;a href=&quot;../losses&quot;&gt;&lt;code&gt;tf.keras.losses&lt;/code&gt;&lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;loss = fn(y_true, y_pred)&lt;/code&gt;, where y_true = ground truth values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;, except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt;. y_pred = predicted values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;. It returns a weighted loss float tensor. If a custom &lt;code&gt;Loss&lt;/code&gt; instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</source>
          <target state="translated">String (name of objective function), objective function or &lt;a href=&quot;../losses/loss&quot;&gt; &lt;code&gt;tf.keras.losses.Loss&lt;/code&gt; &lt;/a&gt; instance. See &lt;a href=&quot;../losses&quot;&gt; &lt;code&gt;tf.keras.losses&lt;/code&gt; &lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;loss = fn(y_true, y_pred)&lt;/code&gt; , where y_true = ground truth values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; , except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt; . y_pred = predicted values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; . It returns a weighted loss float tensor. If a custom &lt;code&gt;Loss&lt;/code&gt; instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</target>
        </trans-unit>
        <trans-unit id="b60702a80c7edd9c6acd79c2add206069a42b97a" translate="yes" xml:space="preserve">
          <source>String (name of objective function), objective function or &lt;a href=&quot;losses/loss&quot;&gt;&lt;code&gt;tf.keras.losses.Loss&lt;/code&gt;&lt;/a&gt; instance. See &lt;a href=&quot;losses&quot;&gt;&lt;code&gt;tf.keras.losses&lt;/code&gt;&lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;loss = fn(y_true, y_pred)&lt;/code&gt;, where y_true = ground truth values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;, except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt;. y_pred = predicted values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt;. It returns a weighted loss float tensor. If a custom &lt;code&gt;Loss&lt;/code&gt; instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</source>
          <target state="translated">String (name of objective function), objective function or &lt;a href=&quot;losses/loss&quot;&gt; &lt;code&gt;tf.keras.losses.Loss&lt;/code&gt; &lt;/a&gt; instance. See &lt;a href=&quot;losses&quot;&gt; &lt;code&gt;tf.keras.losses&lt;/code&gt; &lt;/a&gt;. An objective function is any callable with the signature &lt;code&gt;loss = fn(y_true, y_pred)&lt;/code&gt; , where y_true = ground truth values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; , except sparse loss functions such as sparse categorical crossentropy where shape = &lt;code&gt;[batch_size, d0, .. dN-1]&lt;/code&gt; . y_pred = predicted values with shape = &lt;code&gt;[batch_size, d0, .. dN]&lt;/code&gt; . It returns a weighted loss float tensor. If a custom &lt;code&gt;Loss&lt;/code&gt; instance is used and reduction is set to NONE, return value has the shape [batch_size, d0, .. dN-1] ie. per-sample or per-timestep loss values; otherwise, it is a scalar. If the model has multiple outputs, you can use a different loss on each output by passing a dictionary or a list of losses. The loss value that will be minimized by the model will then be the sum of all individual losses.</target>
        </trans-unit>
        <trans-unit id="5f2dfe8ca8db07eb08debc2c7f9b696dd73b0fe5" translate="yes" xml:space="preserve">
          <source>String (name of optimizer) or optimizer instance. See &lt;a href=&quot;../optimizers&quot;&gt;&lt;code&gt;tf.keras.optimizers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">String (name of optimizer) or optimizer instance. See &lt;a href=&quot;../optimizers&quot;&gt; &lt;code&gt;tf.keras.optimizers&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="922a30c15b8d3138b68b7d2b77a5cdd44f324ab2" translate="yes" xml:space="preserve">
          <source>String (name of optimizer) or optimizer instance. See &lt;a href=&quot;optimizers&quot;&gt;&lt;code&gt;tf.keras.optimizers&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">String (name of optimizer) or optimizer instance. See &lt;a href=&quot;optimizers&quot;&gt; &lt;code&gt;tf.keras.optimizers&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1491a3bd88f9e10c7ce3a5a0f1112506bd8f631c" translate="yes" xml:space="preserve">
          <source>String denoting the name attribute of the input function</source>
          <target state="translated">입력 함수의 이름 속성을 나타내는 문자열</target>
        </trans-unit>
        <trans-unit id="09a179a2e299df379d41ba596e3a17c3174c4727" translate="yes" xml:space="preserve">
          <source>String identifier.</source>
          <target state="translated">String identifier.</target>
        </trans-unit>
        <trans-unit id="9da9794e72722db1fc3be9ac6d15d7e99070a68b" translate="yes" xml:space="preserve">
          <source>String indicating which flip mode to use. Can be &quot;horizontal&quot;, &quot;vertical&quot;, or &quot;horizontal_and_vertical&quot;. Defaults to &quot;horizontal_and_vertical&quot;. &quot;horizontal&quot; is a left-right flip and &quot;vertical&quot; is a top-bottom flip.</source>
          <target state="translated">String indicating which flip mode to use. Can be &quot;horizontal&quot;, &quot;vertical&quot;, or &quot;horizontal_and_vertical&quot;. Defaults to &quot;horizontal_and_vertical&quot;. &quot;horizontal&quot; is a left-right flip and &quot;vertical&quot; is a top-bottom flip.</target>
        </trans-unit>
        <trans-unit id="8219ddd9df81240d263b9ff43e77bbf9da8cf489" translate="yes" xml:space="preserve">
          <source>String key for weight values.</source>
          <target state="translated">String key for weight values.</target>
        </trans-unit>
        <trans-unit id="7b4c8e7832ea4bb28fb1ecea1eb04c21acf3235a" translate="yes" xml:space="preserve">
          <source>String lengths of &lt;code&gt;input&lt;/code&gt;.</source>
          <target state="translated">의 문자열 길이를 &lt;code&gt;input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a599dc6c9efa11184c777c15cffb542116b038e2" translate="yes" xml:space="preserve">
          <source>String message expected in the raised exception. For a raise exception e, expected_exception_message must equal str(e).</source>
          <target state="translated">String message expected in the raised exception. For a raise exception e, expected_exception_message must equal str(e).</target>
        </trans-unit>
        <trans-unit id="bd7f3eb7d3d50c6e8c0a26f1d331b02f0bc5dc9a" translate="yes" xml:space="preserve">
          <source>String metric name.</source>
          <target state="translated">String metric name.</target>
        </trans-unit>
        <trans-unit id="a30c1d22bb3f6422419875a2a58ff7fc57c21425" translate="yes" xml:space="preserve">
          <source>String name for the unicode encoding that should be used to decode each string.</source>
          <target state="translated">String name for the unicode encoding that should be used to decode each string.</target>
        </trans-unit>
        <trans-unit id="e29bfd02b922dbdbb018d7d60f863db98a6f0924" translate="yes" xml:space="preserve">
          <source>String name of the layer.</source>
          <target state="translated">String name of the layer.</target>
        </trans-unit>
        <trans-unit id="41c15ce36cf1b202bd7c9ed708074977a828206a" translate="yes" xml:space="preserve">
          <source>String or &lt;code&gt;pathlib.Path&lt;/code&gt; object, path to the saved model</source>
          <target state="translated">String or &lt;code&gt;pathlib.Path&lt;/code&gt; object, path to the saved model</target>
        </trans-unit>
        <trans-unit id="07997921f90be84e2eaf9af95300df1fbba2d9c7" translate="yes" xml:space="preserve">
          <source>String or &lt;code&gt;pathlib.Path&lt;/code&gt; object, path where to save the model</source>
          <target state="translated">String or &lt;code&gt;pathlib.Path&lt;/code&gt; object, path where to save the model</target>
        </trans-unit>
        <trans-unit id="dddf6e9408c091c8bde9c2f308bb3f33f6bb0e59" translate="yes" xml:space="preserve">
          <source>String or PathLike, path to the file to save the weights to. When saving in TensorFlow format, this is the prefix used for checkpoint files (multiple files are generated). Note that the '.h5' suffix causes weights to be saved in HDF5 format.</source>
          <target state="translated">String or PathLike, path to the file to save the weights to. When saving in TensorFlow format, this is the prefix used for checkpoint files (multiple files are generated). Note that the '.h5' suffix causes weights to be saved in HDF5 format.</target>
        </trans-unit>
        <trans-unit id="9c2aad5c6a931d4c7513d72ecffc8d9eb68b3cc5" translate="yes" xml:space="preserve">
          <source>String paths to latest checkpoint files as they arrive.</source>
          <target state="translated">최신 검사 점 파일이 도착할 때의 문자열 경로.</target>
        </trans-unit>
        <trans-unit id="07ddd1ca7db4978b8769d8dcb6b1beb11b88795b" translate="yes" xml:space="preserve">
          <source>String prefix to index.</source>
          <target state="translated">String prefix to index.</target>
        </trans-unit>
        <trans-unit id="0bb258314d29446040973d8100f997aa2449fcf2" translate="yes" xml:space="preserve">
          <source>String prefix to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</source>
          <target state="translated">String prefix to use for saving sample images (if &lt;code&gt;save_to_dir&lt;/code&gt; is set).</target>
        </trans-unit>
        <trans-unit id="beb3dec21fc639d9c053646d7320a1d84ea43009" translate="yes" xml:space="preserve">
          <source>String representing checkpoint name/pattern from which to restore column weights. Required if &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">String representing checkpoint name/pattern from which to restore column weights. Required if &lt;code&gt;tensor_name_in_ckpt&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c86c0e80130b067fc9f045422638dd0c5401ef7" translate="yes" xml:space="preserve">
          <source>String tag to identify arguments that should be packed.</source>
          <target state="translated">String tag to identify arguments that should be packed.</target>
        </trans-unit>
        <trans-unit id="aeb494b5d1b54f48ea849048d1edcfe06dd51044" translate="yes" xml:space="preserve">
          <source>String to Id table wrapper that assigns out-of-vocabulary keys to buckets.</source>
          <target state="translated">어휘 외의 키를 버킷에 할당하는 문자열 대 ID 테이블 래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="179de94c59fa9ac14c23a48547e8133600523550" translate="yes" xml:space="preserve">
          <source>String used to separate elements in the CSV file.</source>
          <target state="translated">String used to separate elements in the CSV file.</target>
        </trans-unit>
        <trans-unit id="a36b819797c20ea79fdf62ca6a301d30ac9580a7" translate="yes" xml:space="preserve">
          <source>String, 'pre' or 'post' (optional, defaults to 'pre'): pad either before or after each sequence.</source>
          <target state="translated">String, 'pre' or 'post' (optional, defaults to 'pre'): pad either before or after each sequence.</target>
        </trans-unit>
        <trans-unit id="4eadb934587d5f2664960028affe43281d5dbf8c" translate="yes" xml:space="preserve">
          <source>String, 'pre' or 'post' (optional, defaults to 'pre'): remove values from sequences larger than &lt;code&gt;maxlen&lt;/code&gt;, either at the beginning or at the end of the sequences.</source>
          <target state="translated">String, 'pre' or 'post' (optional, defaults to 'pre'): remove values from sequences larger than &lt;code&gt;maxlen&lt;/code&gt; , either at the beginning or at the end of the sequences.</target>
        </trans-unit>
        <trans-unit id="48f4f911fb0543798c85eef202f511b5782f781f" translate="yes" xml:space="preserve">
          <source>String, &lt;code&gt;tf.keras.optimizers.*&lt;/code&gt; object, or callable that creates the optimizer to use for training. If not specified, will use &lt;code&gt;Ftrl&lt;/code&gt; as the default optimizer.</source>
          <target state="translated">String, &lt;code&gt;tf.keras.optimizers.*&lt;/code&gt; object, or callable that creates the optimizer to use for training. If not specified, will use &lt;code&gt;Ftrl&lt;/code&gt; as the default optimizer.</target>
        </trans-unit>
        <trans-unit id="67d39d70acdc880413877671e7f168fccf79fc21" translate="yes" xml:space="preserve">
          <source>String, PathLike, path to SavedModel or H5 file to save the model.</source>
          <target state="translated">String, PathLike, path to SavedModel or H5 file to save the model.</target>
        </trans-unit>
        <trans-unit id="1ed59984dcb6b51bcf59ca42f056109f19a00deb" translate="yes" xml:space="preserve">
          <source>String, data type of returned Keras variable.</source>
          <target state="translated">String, data type of returned Keras variable.</target>
        </trans-unit>
        <trans-unit id="aaa81af7916f61c4c8df3b14acde35215be76a44" translate="yes" xml:space="preserve">
          <source>String, dtype of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">문자열의 DTYPE &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5789ff3dbd761a130ee438cdcb1928b66fdf0b3" translate="yes" xml:space="preserve">
          <source>String, dtype of returned Keras variable.</source>
          <target state="translated">String, dtype of returned Keras variable.</target>
        </trans-unit>
        <trans-unit id="3e0ea604a5f3c39c4b642db98b9396055178bded" translate="yes" xml:space="preserve">
          <source>String, dtype of returned Keras variable. None uses the dtype of x.</source>
          <target state="translated">String, dtype of returned Keras variable. None uses the dtype of x.</target>
        </trans-unit>
        <trans-unit id="b66ae7000a46e9202544c5e1993d349d00e7ef78" translate="yes" xml:space="preserve">
          <source>String, dtype of returned tensor.</source>
          <target state="translated">String, dtype of returned tensor.</target>
        </trans-unit>
        <trans-unit id="b9c15ef536aef04dc820663f0662b5f156b76689" translate="yes" xml:space="preserve">
          <source>String, either (&lt;code&gt;'float16'&lt;/code&gt;, &lt;code&gt;'float32'&lt;/code&gt;, or &lt;code&gt;'float64'&lt;/code&gt;).</source>
          <target state="translated">String, either ( &lt;code&gt;'float16'&lt;/code&gt; , &lt;code&gt;'float32'&lt;/code&gt; , or &lt;code&gt;'float64'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1482a5171d848e7aceca5637e4e4c0ea940ef1ef" translate="yes" xml:space="preserve">
          <source>String, name for the variable to create.</source>
          <target state="translated">String, name for the variable to create.</target>
        </trans-unit>
        <trans-unit id="b7a64beca13685d79562b0ff4d118c3028987a83" translate="yes" xml:space="preserve">
          <source>String, name of function.</source>
          <target state="translated">String, name of function.</target>
        </trans-unit>
        <trans-unit id="49869a86329cca78f60b6659ab4e804038b77670" translate="yes" xml:space="preserve">
          <source>String, name of layer.</source>
          <target state="translated">String, name of layer.</target>
        </trans-unit>
        <trans-unit id="382c3344acb6ff576ac953c3b3db965623add21b" translate="yes" xml:space="preserve">
          <source>String, name of returned Keras variable.</source>
          <target state="translated">String, name of returned Keras variable.</target>
        </trans-unit>
        <trans-unit id="aea48fb0ecc193f0989453b8eeb2b40be5fd519b" translate="yes" xml:space="preserve">
          <source>String, name to use for this layer.</source>
          <target state="translated">String, name to use for this layer.</target>
        </trans-unit>
        <trans-unit id="ab74a953dea30e88d9ccf5105994b58a4ab4d210" translate="yes" xml:space="preserve">
          <source>String, one of &lt;code&gt;None&lt;/code&gt; (random initialization), 'imagenet' (pre-training on ImageNet), or the path to the weights file to be loaded.</source>
          <target state="translated">String, one of &lt;code&gt;None&lt;/code&gt; (random initialization), 'imagenet' (pre-training on ImageNet), or the path to the weights file to be loaded.</target>
        </trans-unit>
        <trans-unit id="4826fea045af2fba0ea512cfe48134e3e456d2b6" translate="yes" xml:space="preserve">
          <source>String, one of &lt;code&gt;channels_first&lt;/code&gt;, &lt;code&gt;channels_last&lt;/code&gt;.</source>
          <target state="translated">String, one of &lt;code&gt;channels_first&lt;/code&gt; , &lt;code&gt;channels_last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be43801f0bf9e3057814c43ae42f8fe0e04f00a3" translate="yes" xml:space="preserve">
          <source>String, optional pooling mode for feature extraction when &lt;code&gt;include_top&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">String, optional pooling mode for feature extraction when &lt;code&gt;include_top&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d0a89a07af47d312c838385adbba36734e9d422" translate="yes" xml:space="preserve">
          <source>String, path to save the model file. This is the directory in which the system stores temporary files to recover the model from jobs terminated unexpectedly. The directory cannot be reused elsewhere to store other checkpoints, e.g. by BackupAndRestore callback of another training, or by another callback (ModelCheckpoint) of the same training.</source>
          <target state="translated">String, path to save the model file. This is the directory in which the system stores temporary files to recover the model from jobs terminated unexpectedly. The directory cannot be reused elsewhere to store other checkpoints, e.g. by BackupAndRestore callback of another training, or by another callback (ModelCheckpoint) of the same training.</target>
        </trans-unit>
        <trans-unit id="ea9f5b6cc332ffad44ba87818cd1c1307282d6c3" translate="yes" xml:space="preserve">
          <source>String, path to the saved model</source>
          <target state="translated">문자열, 저장된 모델의 경로</target>
        </trans-unit>
        <trans-unit id="8ff3eca339aa26478965031d60242092bc17292c" translate="yes" xml:space="preserve">
          <source>String, path to the weights file to load. For weight files in TensorFlow format, this is the file prefix (the same as was passed to &lt;code&gt;save_weights&lt;/code&gt;).</source>
          <target state="translated">String, path to the weights file to load. For weight files in TensorFlow format, this is the file prefix (the same as was passed to &lt;code&gt;save_weights&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a0a3d9cd808b86047665f49535c974af481846b3" translate="yes" xml:space="preserve">
          <source>String, path where to save the model</source>
          <target state="translated">문자열, 모델을 저장할 경로</target>
        </trans-unit>
        <trans-unit id="54bc218b3ac398424451a14065ba255b110489cd" translate="yes" xml:space="preserve">
          <source>String, the current default float type.</source>
          <target state="translated">현재 기본 부동 유형 인 문자열</target>
        </trans-unit>
        <trans-unit id="700c4a2ce847530565679aa57b1cd230cd218708" translate="yes" xml:space="preserve">
          <source>String, the interpolation method used when resizing images. Defaults to &lt;code&gt;bilinear&lt;/code&gt;. Supports &lt;code&gt;bilinear&lt;/code&gt;, &lt;code&gt;nearest&lt;/code&gt;, &lt;code&gt;bicubic&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt;, &lt;code&gt;lanczos3&lt;/code&gt;, &lt;code&gt;lanczos5&lt;/code&gt;, &lt;code&gt;gaussian&lt;/code&gt;, &lt;code&gt;mitchellcubic&lt;/code&gt;.</source>
          <target state="translated">String, the interpolation method used when resizing images. Defaults to &lt;code&gt;bilinear&lt;/code&gt; . Supports &lt;code&gt;bilinear&lt;/code&gt; , &lt;code&gt;nearest&lt;/code&gt; , &lt;code&gt;bicubic&lt;/code&gt; , &lt;code&gt;area&lt;/code&gt; , &lt;code&gt;lanczos3&lt;/code&gt; , &lt;code&gt;lanczos5&lt;/code&gt; , &lt;code&gt;gaussian&lt;/code&gt; , &lt;code&gt;mitchellcubic&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f9c5ee92c6d361af784e7600c5dac9c3eb02033" translate="yes" xml:space="preserve">
          <source>String, the interpolation method. Defaults to &lt;code&gt;bilinear&lt;/code&gt;. Supports &lt;code&gt;bilinear&lt;/code&gt;, &lt;code&gt;nearest&lt;/code&gt;, &lt;code&gt;bicubic&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt;, &lt;code&gt;lanczos3&lt;/code&gt;, &lt;code&gt;lanczos5&lt;/code&gt;, &lt;code&gt;gaussian&lt;/code&gt;, &lt;code&gt;mitchellcubic&lt;/code&gt;</source>
          <target state="translated">String, the interpolation method. Defaults to &lt;code&gt;bilinear&lt;/code&gt; . Supports &lt;code&gt;bilinear&lt;/code&gt; , &lt;code&gt;nearest&lt;/code&gt; , &lt;code&gt;bicubic&lt;/code&gt; , &lt;code&gt;area&lt;/code&gt; , &lt;code&gt;lanczos3&lt;/code&gt; , &lt;code&gt;lanczos5&lt;/code&gt; , &lt;code&gt;gaussian&lt;/code&gt; , &lt;code&gt;mitchellcubic&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8880beadf72da21a00dcda22ee241cb40151e95" translate="yes" xml:space="preserve">
          <source>String, the name of the layer.</source>
          <target state="translated">String, the name of the layer.</target>
        </trans-unit>
        <trans-unit id="306a7252965aceb9c80bc2d9d564d0950eadf9e3" translate="yes" xml:space="preserve">
          <source>String, the name of the layer. Layers with the same name will share weights, but to avoid mistakes we require reuse=True in such cases.</source>
          <target state="translated">String, the name of the layer. Layers with the same name will share weights, but to avoid mistakes we require reuse=True in such cases.</target>
        </trans-unit>
        <trans-unit id="dc45af0eb0a8519c084c858a7d6df00877d8c002" translate="yes" xml:space="preserve">
          <source>String, the name of the model.</source>
          <target state="translated">String, the name of the model.</target>
        </trans-unit>
        <trans-unit id="131db5fdecbb06270579c19677a0deb4267c0711" translate="yes" xml:space="preserve">
          <source>String. All statistics recorded by the returned transformation will be associated with the given &lt;code&gt;tag&lt;/code&gt;.</source>
          <target state="translated">String. All statistics recorded by the returned transformation will be associated with the given &lt;code&gt;tag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e2c163e98ebde1c4b775234eb7f91017f7f98ff" translate="yes" xml:space="preserve">
          <source>String. Device of the &lt;code&gt;ps&lt;/code&gt; job. If empty no &lt;code&gt;ps&lt;/code&gt; job is used. Defaults to &lt;code&gt;ps&lt;/code&gt;.</source>
          <target state="translated">String. Device of the &lt;code&gt;ps&lt;/code&gt; job. If empty no &lt;code&gt;ps&lt;/code&gt; job is used. Defaults to &lt;code&gt;ps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="635e2818e0535519379e2e8106b2dcc7adc92598" translate="yes" xml:space="preserve">
          <source>String. Device of the &lt;code&gt;worker&lt;/code&gt; job. If empty no &lt;code&gt;worker&lt;/code&gt; job is used.</source>
          <target state="translated">String. Device of the &lt;code&gt;worker&lt;/code&gt; job. If empty no &lt;code&gt;worker&lt;/code&gt; job is used.</target>
        </trans-unit>
        <trans-unit id="8fa03651cb80d37144397c6eefec120d8d602db1" translate="yes" xml:space="preserve">
          <source>String. Name of the evaluation if user needs to run multiple evaluations on different data sets. Metrics for different evaluations are saved in separate folders, and appear separately in tensorboard.</source>
          <target state="translated">String. Name of the evaluation if user needs to run multiple evaluations on different data sets. Metrics for different evaluations are saved in separate folders, and appear separately in tensorboard.</target>
        </trans-unit>
        <trans-unit id="4d8ec7cb126f294a0791f76e3890d9dbe6d20127" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'CosineDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'CosineDecay'.</target>
        </trans-unit>
        <trans-unit id="41969b7d40b0a431e3776651c8f731373b3c1699" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'ExponentialDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'ExponentialDecay'.</target>
        </trans-unit>
        <trans-unit id="bd3aef72e0071162206cbb9794849ce33602d497" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'ExponentialTimeDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'ExponentialTimeDecay'.</target>
        </trans-unit>
        <trans-unit id="fa753c835c3d25b0cae4b5cc0333640920cea738" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'InverseTimeDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'InverseTimeDecay'.</target>
        </trans-unit>
        <trans-unit id="7465226034591c401cb622ccc4f9e085415e76e9" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'LinearCosineDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'LinearCosineDecay'.</target>
        </trans-unit>
        <trans-unit id="2d4173f116f1b7b724fa8b00d832a269481667d4" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'NoisyLinearCosineDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'NoisyLinearCosineDecay'.</target>
        </trans-unit>
        <trans-unit id="82ac7fdff59fa998124494ff3d945f4a716d9118" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'PolynomialDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'PolynomialDecay'.</target>
        </trans-unit>
        <trans-unit id="b0e6a5900cf7b56971451b84180201678131d209" translate="yes" xml:space="preserve">
          <source>String. Optional name of the operation. Defaults to 'SGDRDecay'.</source>
          <target state="translated">String. Optional name of the operation. Defaults to 'SGDRDecay'.</target>
        </trans-unit>
        <trans-unit id="fcffada860c3a7681e6bbad8da4b271f0e103559" translate="yes" xml:space="preserve">
          <source>String. Optional name to use as a prefix when adding operations.</source>
          <target state="translated">String. Optional name to use as a prefix when adding operations.</target>
        </trans-unit>
        <trans-unit id="b5252b6081181d093fce188a54fcddad441142da" translate="yes" xml:space="preserve">
          <source>String. Optional prefix name to use for the name of ops added in &lt;code&gt;apply()&lt;/code&gt;.</source>
          <target state="translated">String. Optional prefix name to use for the name of ops added in &lt;code&gt;apply()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9505c77d12b5fb7c5835f90cb0f4a212e4267bee" translate="yes" xml:space="preserve">
          <source>String. Prefix of filenames created for the checkpoint.</source>
          <target state="translated">String. Prefix of filenames created for the checkpoint.</target>
        </trans-unit>
        <trans-unit id="8b50ed2af7b098b529bbc7279bbf5db9de65578d" translate="yes" xml:space="preserve">
          <source>String/value dictionary of initialization arguments to override with new values.</source>
          <target state="translated">String/value dictionary of initialization arguments to override with new values.</target>
        </trans-unit>
        <trans-unit id="57e5867b01bfc07f9eb74efe89e78ace68c7ff5a" translate="yes" xml:space="preserve">
          <source>String: name of an optimizer</source>
          <target state="translated">문자열 : 옵티 마이저 이름</target>
        </trans-unit>
        <trans-unit id="7db1b1d60bd8122756e09e6b21ea6f728c05bcf4" translate="yes" xml:space="preserve">
          <source>String; &lt;code&gt;'float16'&lt;/code&gt;, &lt;code&gt;'float32'&lt;/code&gt;, or &lt;code&gt;'float64'&lt;/code&gt;.</source>
          <target state="translated">String; &lt;code&gt;'float16'&lt;/code&gt; , &lt;code&gt;'float32'&lt;/code&gt; , or &lt;code&gt;'float64'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69f7c6cdff842a2f8f4173078fe399f60f46bb4f" translate="yes" xml:space="preserve">
          <source>String; JSON field under which the data will be stored. The field is used only if the payload is sent within a form (i.e. send_as_json is set to False).</source>
          <target state="translated">String; JSON field under which the data will be stored. The field is used only if the payload is sent within a form (i.e. send_as_json is set to False).</target>
        </trans-unit>
        <trans-unit id="25991458a54b6b5c2c3bcfec9fbd218e33a7aa72" translate="yes" xml:space="preserve">
          <source>String; path relative to &lt;code&gt;root&lt;/code&gt; to which the events will be sent.</source>
          <target state="translated">String; path relative to &lt;code&gt;root&lt;/code&gt; to which the events will be sent.</target>
        </trans-unit>
        <trans-unit id="adb953e66a4b5ffefe52caaa7d0d498ef07d9647" translate="yes" xml:space="preserve">
          <source>String; root url of the target server.</source>
          <target state="translated">String; root url of the target server.</target>
        </trans-unit>
        <trans-unit id="56b757ccca43c3d5c7122b7bf0be5d39f94aadf7" translate="yes" xml:space="preserve">
          <source>StringFormat</source>
          <target state="translated">StringFormat</target>
        </trans-unit>
        <trans-unit id="febc3a9504942ba66d2686cf86922d3cf5631c76" translate="yes" xml:space="preserve">
          <source>StringJoin</source>
          <target state="translated">StringJoin</target>
        </trans-unit>
        <trans-unit id="747a6d9f79ce26bfcb75595cb97a96bf75d5f237" translate="yes" xml:space="preserve">
          <source>StringLength</source>
          <target state="translated">StringLength</target>
        </trans-unit>
        <trans-unit id="ecf4b9136eb2c585e0aa43773e5e6a271f4470d9" translate="yes" xml:space="preserve">
          <source>StringLower</source>
          <target state="translated">StringLower</target>
        </trans-unit>
        <trans-unit id="e701cf755f940d71be4654653b031b62a6f90a39" translate="yes" xml:space="preserve">
          <source>StringNGrams</source>
          <target state="translated">StringNGrams</target>
        </trans-unit>
        <trans-unit id="b6b8c2f2fe292b14e30b9dc4b3d2d0d73d2b3c78" translate="yes" xml:space="preserve">
          <source>StringSplit</source>
          <target state="translated">StringSplit</target>
        </trans-unit>
        <trans-unit id="83d070fc52da8b7c49d1eec25e4840e7ac623a94" translate="yes" xml:space="preserve">
          <source>StringSplitV2</source>
          <target state="translated">StringSplitV2</target>
        </trans-unit>
        <trans-unit id="3447a6da016b573f4a9b57aa81505e26c81f4c33" translate="yes" xml:space="preserve">
          <source>StringStrip</source>
          <target state="translated">StringStrip</target>
        </trans-unit>
        <trans-unit id="2456fea4c53341cb4fa48e9be5e86cf767c91827" translate="yes" xml:space="preserve">
          <source>StringToHashBucket</source>
          <target state="translated">StringToHashBucket</target>
        </trans-unit>
        <trans-unit id="a315e5a8362dbfb1db15edd08ef7acd2d1adc141" translate="yes" xml:space="preserve">
          <source>StringToHashBucketFast</source>
          <target state="translated">StringToHashBucketFast</target>
        </trans-unit>
        <trans-unit id="a1ebd64aa8e6e6b490c1de5f8d0e189cfe523c84" translate="yes" xml:space="preserve">
          <source>StringToHashBucketStrong</source>
          <target state="translated">StringToHashBucketStrong</target>
        </trans-unit>
        <trans-unit id="17895bd3a37cd75adfc52553eed6e06dfb429e14" translate="yes" xml:space="preserve">
          <source>StringToNumber</source>
          <target state="translated">StringToNumber</target>
        </trans-unit>
        <trans-unit id="4bed54a5cbfb94f15143c106342c651aa6141d46" translate="yes" xml:space="preserve">
          <source>StringUpper</source>
          <target state="translated">StringUpper</target>
        </trans-unit>
        <trans-unit id="4783a53435e04475242288debdaae1f5d02699bf" translate="yes" xml:space="preserve">
          <source>Strings.</source>
          <target state="translated">Strings.</target>
        </trans-unit>
        <trans-unit id="66bf723a15be4c8e82544fa8db7d3459828330ba" translate="yes" xml:space="preserve">
          <source>Strip leading and trailing whitespaces from the Tensor.</source>
          <target state="translated">텐서에서 앞뒤 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="f350b1261d4080472d67731c5c9e2f0603eeb906" translate="yes" xml:space="preserve">
          <source>Structure to create or gather pieces commonly needed to train a model.</source>
          <target state="translated">모델 훈련에 일반적으로 필요한 조각을 생성하거나 수집하는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="7c98ab4418a813d6b943f2b02fac0d62645ae018" translate="yes" xml:space="preserve">
          <source>Student's t-distribution.</source>
          <target state="translated">학생의 t- 분포.</target>
        </trans-unit>
        <trans-unit id="1f3c17ad45052c3c8faf844ec9d98e802f713c26" translate="yes" xml:space="preserve">
          <source>Sub</source>
          <target state="translated">Sub</target>
        </trans-unit>
        <trans-unit id="7ffaefd8b7f218faf62448be773733b362a94c3c" translate="yes" xml:space="preserve">
          <source>Subclasses are expected to implement a leading-underscore version of the same-named function. The argument signature should be identical except for the omission of &lt;code&gt;name=&quot;...&quot;&lt;/code&gt;. For example, to enable &lt;code&gt;log_prob(value, name=&quot;log_prob&quot;)&lt;/code&gt; a subclass should implement &lt;code&gt;_log_prob(value)&lt;/code&gt;.</source>
          <target state="translated">서브 클래스는 동일한 이름을 가진 함수의 밑줄이 그어진 버전을 구현할 것으로 예상됩니다. &lt;code&gt;name=&quot;...&quot;&lt;/code&gt; 생략을 제외하고 인수 서명은 동일해야합니다 . 예를 들어, &lt;code&gt;log_prob(value, name=&quot;log_prob&quot;)&lt;/code&gt; 를 활성화 하려면 서브 클래스가 &lt;code&gt;_log_prob(value)&lt;/code&gt; 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2a6721e7c506f9fb97672ded9cc77a3beb182cd0" translate="yes" xml:space="preserve">
          <source>Subclasses can append to public-level docstrings by providing docstrings for their method specializations. For example:</source>
          <target state="translated">서브 클래스는 메소드 전문화를 위해 docstring을 제공하여 공개 레벨 docstring에 추가 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7aec789137a8d9a01ede9775ea920d915b4cb613" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;a href=&quot;module&quot;&gt;&lt;code&gt;tf.Module&lt;/code&gt;&lt;/a&gt; can also take advantage of the &lt;code&gt;_flatten&lt;/code&gt; method which can be used to implement tracking of any other types.</source>
          <target state="translated">의 서브 클래스 &lt;a href=&quot;module&quot;&gt; &lt;code&gt;tf.Module&lt;/code&gt; 는&lt;/a&gt; 도 활용할 수 있습니다 &lt;code&gt;_flatten&lt;/code&gt; 다른 유형의 추적을 구현하는 데 사용할 수있는 메소드를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6710338017625456fa4561184c0ed0ef98bc5b38" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;LinearOperator&lt;/code&gt; provide access to common methods on a (batch) matrix, without the need to materialize the matrix. This allows:</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; 의 서브 클래스는 매트릭스를 구체화 할 필요없이 (배치) 매트릭스에서 공통 메소드에 액세스 할 수 있도록합니다. 이를 통해 다음이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="42876d8a9661050716824a58ac5a82c08c248d20" translate="yes" xml:space="preserve">
          <source>Subclasses should also define a syntactic_help string which may be presented to the user to describe the form of the legal values.</source>
          <target state="translated">서브 클래스는 또한 유효한 값의 형식을 설명하기 위해 사용자에게 제공 될 수있는 syntactic_help 문자열을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="aea78081ca45ef2980de5a15e286ad2bbda54156" translate="yes" xml:space="preserve">
          <source>Subclasses should only implement the assert methods (e.g. &lt;code&gt;assert_non_singular&lt;/code&gt;) if they can be done in less than &lt;code&gt;O(N^3)&lt;/code&gt; time.</source>
          <target state="translated">서브 클래스는 &lt;code&gt;O(N^3)&lt;/code&gt; 시간 이내에 완료 될 수있는 경우 에만 assert 메소드 (예 : &lt;code&gt;assert_non_singular&lt;/code&gt; )를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="cf637286e0e32e92c7c31e4552b50b7fae1598ef" translate="yes" xml:space="preserve">
          <source>Subclasses should override class method &lt;code&gt;_param_shapes&lt;/code&gt; to return constant-valued tensors when constant values are fed.</source>
          <target state="translated">상수 값이 제공 될 때 상수 값 텐서를 반환하도록 서브 클래스는 클래스 메소드 &lt;code&gt;_param_shapes&lt;/code&gt; 를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="37df94753f92ace08cbf9f39640c831c989de432" translate="yes" xml:space="preserve">
          <source>Subclasses should override class method &lt;code&gt;_param_shapes&lt;/code&gt;.</source>
          <target state="translated">서브 클래스는 클래스 메소드 &lt;code&gt;_param_shapes&lt;/code&gt; 를 대체해야합니다. .</target>
        </trans-unit>
        <trans-unit id="8ce7d0131be24554322a374d91443a37c9bff932" translate="yes" xml:space="preserve">
          <source>Subclasses should override for any actions to run.</source>
          <target state="translated">조치를 실행하려면 서브 클래스를 대체해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7a01ff259fb1b5c2717e8c75756ea59f3bfc673" translate="yes" xml:space="preserve">
          <source>Subclasses should override for any actions to run. This function should only be called during TRAIN mode.</source>
          <target state="translated">조치를 실행하려면 서브 클래스를 대체해야합니다. 이 기능은 TRAIN 모드에서만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="82494d5df2327066831b19fcbdbc11f57f406da0" translate="yes" xml:space="preserve">
          <source>Subclassing</source>
          <target state="translated">Subclassing</target>
        </trans-unit>
        <trans-unit id="1bd00ac5a13e28040a2dcff4532ed95198cd4120" translate="yes" xml:space="preserve">
          <source>Subdirectory under the Keras cache dir where the file is saved. If an absolute path &lt;code&gt;/path/to/folder&lt;/code&gt; is specified the file will be saved at that location.</source>
          <target state="translated">Subdirectory under the Keras cache dir where the file is saved. If an absolute path &lt;code&gt;/path/to/folder&lt;/code&gt; is specified the file will be saved at that location.</target>
        </trans-unit>
        <trans-unit id="4ee2b1df95332be247a338e3703c536ed3849d29" translate="yes" xml:space="preserve">
          <source>Submodules are modules which are properties of this module, or found as properties of modules which are properties of this module (and so on).</source>
          <target state="translated">서브 모듈은이 모듈의 속성이거나이 모듈의 속성 인 모듈의 속성 등으로 알려진 모듈입니다.</target>
        </trans-unit>
        <trans-unit id="51e80dcaa34f1399e616159858d058d947cd464a" translate="yes" xml:space="preserve">
          <source>Subset of data (&lt;code&gt;&quot;training&quot;&lt;/code&gt; or &lt;code&gt;&quot;validation&quot;&lt;/code&gt;) if &lt;code&gt;validation_split&lt;/code&gt; is set in &lt;code&gt;ImageDataGenerator&lt;/code&gt;.</source>
          <target state="translated">Subset of data ( &lt;code&gt;&quot;training&quot;&lt;/code&gt; or &lt;code&gt;&quot;validation&quot;&lt;/code&gt; ) if &lt;code&gt;validation_split&lt;/code&gt; is set in &lt;code&gt;ImageDataGenerator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5cde39c455412b7e41e71c23e1437f4bfaa5876" translate="yes" xml:space="preserve">
          <source>Subset of data (&lt;code&gt;&quot;training&quot;&lt;/code&gt; or &lt;code&gt;&quot;validation&quot;&lt;/code&gt;) if validation_split is set in ImageDataGenerator.</source>
          <target state="translated">Subset of data ( &lt;code&gt;&quot;training&quot;&lt;/code&gt; or &lt;code&gt;&quot;validation&quot;&lt;/code&gt; ) if validation_split is set in ImageDataGenerator.</target>
        </trans-unit>
        <trans-unit id="aeeea8448907cebd24c27fdb058a5a2b0063306c" translate="yes" xml:space="preserve">
          <source>Substr</source>
          <target state="translated">Substr</target>
        </trans-unit>
        <trans-unit id="165eb6fe055989673d9f7ff7fc05154aebafbb3c" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;a href=&quot;../../indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; from this variable.</source>
          <target state="translated">이 변수에서 &lt;a href=&quot;../../indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; 를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="f35f0686291951a05d8c56e0435069d27921f5e4" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;a href=&quot;indexedslices&quot;&gt;&lt;code&gt;tf.IndexedSlices&lt;/code&gt;&lt;/a&gt; from this variable.</source>
          <target state="translated">이 변수에서 &lt;a href=&quot;indexedslices&quot;&gt; &lt;code&gt;tf.IndexedSlices&lt;/code&gt; &lt;/a&gt; 를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="d0df54d59a0a8e3d7213b02b8f3dd1802f26c838" translate="yes" xml:space="preserve">
          <source>Subtracts &lt;code&gt;v&lt;/code&gt; into specified rows of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Subtracts &lt;code&gt;v&lt;/code&gt; into specified rows of &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4f3ceff40b4c6fedef3257e6fc955248332ea8b" translate="yes" xml:space="preserve">
          <source>Subtracts a value from the current value of a variable.</source>
          <target state="translated">Subtracts a value from the current value of a variable.</target>
        </trans-unit>
        <trans-unit id="862f9417a21c1ab694eec964a2530921649cc05a" translate="yes" xml:space="preserve">
          <source>Subtracts a value from this variable.</source>
          <target state="translated">이 변수에서 값을 뺍니다.</target>
        </trans-unit>
        <trans-unit id="533efd56cc6494d580885f7e5b88d2e19d328bec" translate="yes" xml:space="preserve">
          <source>Subtracts sparse &lt;code&gt;updates&lt;/code&gt; from an existing tensor according to &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 에 따라 기존 텐서에서 희소 &lt;code&gt;updates&lt;/code&gt; 를 뺍니다 .</target>
        </trans-unit>
        <trans-unit id="07ea115f667714fdf889a4dd7b8b19a88c2c6a4c" translate="yes" xml:space="preserve">
          <source>Subtracts sparse updates from the variable referenced by &lt;code&gt;resource&lt;/code&gt;.</source>
          <target state="translated">Subtracts sparse updates from the variable referenced by &lt;code&gt;resource&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f817b1800d31c4059e5eec01c90ea508fa2de1" translate="yes" xml:space="preserve">
          <source>Subtracts sparse updates to a variable reference.</source>
          <target state="translated">변수 참조에 대한 희소 업데이트를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="ffab6af063b75339c2da62f252c5b9fd21c5a8b2" translate="yes" xml:space="preserve">
          <source>Such a boolean flag does not take an argument. If a user wants to specify a false value explicitly, the long option beginning with 'no' must be used: i.e. --noflag</source>
          <target state="translated">이러한 부울 플래그는 인수를 사용하지 않습니다. 사용자가 명시 적으로 false 값을 지정하려면 'no'로 시작하는 긴 옵션을 사용해야합니다. 즉 --noflag</target>
        </trans-unit>
        <trans-unit id="148ca103270cd289f01e05a2353802e186d98b69" translate="yes" xml:space="preserve">
          <source>Suffix for &lt;code&gt;MetaGraphDef&lt;/code&gt; file. Defaults to 'meta'.</source>
          <target state="translated">Suffix for &lt;code&gt;MetaGraphDef&lt;/code&gt; file. Defaults to 'meta'.</target>
        </trans-unit>
        <trans-unit id="7134069c282a2f783eef48ab8ddea200ea10abe8" translate="yes" xml:space="preserve">
          <source>Suggest &lt;a href=&quot;tensorshape#as_list&quot;&gt;&lt;code&gt;TensorShape.as_list&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Suggest &lt;a href=&quot;tensorshape#as_list&quot;&gt; &lt;code&gt;TensorShape.as_list&lt;/code&gt; &lt;/a&gt; instead.</target>
        </trans-unit>
        <trans-unit id="6a79dcd29d4b3b6000264a88496dc0b21c3bb9bd" translate="yes" xml:space="preserve">
          <source>Suitable for passing to &lt;a href=&quot;checkpoint#restore&quot;&gt;&lt;code&gt;tf.train.Checkpoint.restore&lt;/code&gt;&lt;/a&gt; to resume training.</source>
          <target state="translated">&lt;a href=&quot;checkpoint#restore&quot;&gt; &lt;code&gt;tf.train.Checkpoint.restore&lt;/code&gt; &lt;/a&gt; 로 전달하기에 적합훈련을 재개 로 .</target>
        </trans-unit>
        <trans-unit id="fc9ce14b28c6f2c3b72caf056ca604b2b96f7d2b" translate="yes" xml:space="preserve">
          <source>Sum</source>
          <target state="translated">Sum</target>
        </trans-unit>
        <trans-unit id="0767ec9c89c14ac885f6aac10f61d8b491a9b0fe" translate="yes" xml:space="preserve">
          <source>Sum of concentration parameters.</source>
          <target state="translated">농도 매개 변수의 합.</target>
        </trans-unit>
        <trans-unit id="8e620e3b949e70befef0ae092fde25014ac70320" translate="yes" xml:space="preserve">
          <source>Sum of last dim of concentration parameter.</source>
          <target state="translated">마지막 농도의 희미한 파라미터의 합입니다.</target>
        </trans-unit>
        <trans-unit id="828ac024d0a463272c3865c79e2c0bf52a749629" translate="yes" xml:space="preserve">
          <source>Sum of the values in a tensor, alongside the specified axis.</source>
          <target state="translated">지정된 축과 함께 텐서의 값의 합입니다.</target>
        </trans-unit>
        <trans-unit id="099c5812d8fa488a0e61fa106c074634bb1f9d7f" translate="yes" xml:space="preserve">
          <source>Sum the input tensor across replicas according to group_assignment.</source>
          <target state="translated">group_assignment에 따라 복제본에서 입력 텐서를 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="10af7e4de27c05194aa88c5baa285ca841cf04ab" translate="yes" xml:space="preserve">
          <source>Sum the weights of false positives.</source>
          <target state="translated">오 탐지의 가중치를 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="2a3284e36f760f4254131fea54732c3ba499239f" translate="yes" xml:space="preserve">
          <source>Sum the weights of true_negatives.</source>
          <target state="translated">true_negatives의 가중치를 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="42dd5be548c1e47f53fdb48f3d5c971ee04367e9" translate="yes" xml:space="preserve">
          <source>Sum the weights of true_positives.</source>
          <target state="translated">true_positives의 가중치를 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="8333177a21c8e3581d5ed83f3b343cfae98cec5f" translate="yes" xml:space="preserve">
          <source>Summarizes textual data.</source>
          <target state="translated">텍스트 데이터를 요약합니다.</target>
        </trans-unit>
        <trans-unit id="123b3029e4d453e7c92a3cd95aae0d58e4d73529" translate="yes" xml:space="preserve">
          <source>SummaryWriter</source>
          <target state="translated">SummaryWriter</target>
        </trans-unit>
        <trans-unit id="f32d5a3b17e614297417cc279a7ec1cd02274d65" translate="yes" xml:space="preserve">
          <source>Support</source>
          <target state="translated">Support</target>
        </trans-unit>
        <trans-unit id="b079c2d8619aadef5a47beee8545f1de33276597" translate="yes" xml:space="preserve">
          <source>Support class for stubbing methods out for unit testing.</source>
          <target state="translated">단위 테스트를 위해 스텁 메소드를 지원하기위한 지원 클래스.</target>
        </trans-unit>
        <trans-unit id="7c570510ec02530b48ce8c6a2822119f29cc294e" translate="yes" xml:space="preserve">
          <source>Support for training models.</source>
          <target state="translated">훈련 모델을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9f45023b45c5bcb0e2e566e86c212c8ad3099045" translate="yes" xml:space="preserve">
          <source>Support wide range of machine learning models. Since most heads can work with logits, they can support DNN, RNN, Wide, Wide&amp;amp;Deep, Global objectives, Gradient boosted trees and many other types of machine learning models.</source>
          <target state="translated">광범위한 머신 러닝 모델을 지원합니다. 대부분의 헤드는 로짓으로 작업 할 수 있으므로 DNN, RNN, Wide, Wide &amp;amp; Deep, Global objectives, Gradient boosted tree 및 기타 여러 유형의 머신 러닝 모델을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e4c3ba1c4c9a5628bf53097a54a121b78c3ef2e" translate="yes" xml:space="preserve">
          <source>Supported Python entities include:</source>
          <target state="translated">Supported Python entities include:</target>
        </trans-unit>
        <trans-unit id="7ca7b2b776a1a659ec26ed62726c8ba0fc984e92" translate="yes" xml:space="preserve">
          <source>Supported Python entities include: * functions * classes * object methods</source>
          <target state="translated">지원되는 Python 엔티티는 다음과 같습니다. * 함수 * 클래스 * 객체 메소드</target>
        </trans-unit>
        <trans-unit id="6a7904d43a7d7b78c5432b67ecbbf60280c81cd9" translate="yes" xml:space="preserve">
          <source>Supported attribute includes micros, bytes, occurrence, params, etc. &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&quot;&gt;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&lt;/a&gt;</source>
          <target state="translated">Supported attribute includes micros, bytes, occurrence, params, etc. &lt;a href=&quot;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&quot;&gt;https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8ce9158bd839abeef632632d7ada1c1f6e0c0ccf" translate="yes" xml:space="preserve">
          <source>Supported attribute includes micros, bytes, occurrence, params, etc. https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md</source>
          <target state="translated">지원되는 속성에는 마이크로, 바이트, 발생, 매개 변수 등이 포함됩니다. https://github.com/tensorflow/tensorflow/tree/master/tensorflow/core/profiler/g3doc/options.md</target>
        </trans-unit>
        <trans-unit id="385210a6e3ca5b33d8993c5d65a5be60d214884c" translate="yes" xml:space="preserve">
          <source>Supported image formats: jpeg, png, bmp, gif. Animated gifs are truncated to the first frame.</source>
          <target state="translated">Supported image formats: jpeg, png, bmp, gif. Animated gifs are truncated to the first frame.</target>
        </trans-unit>
        <trans-unit id="9794d24ec85271049a86498f820c37d015564882" translate="yes" xml:space="preserve">
          <source>Supported types</source>
          <target state="translated">지원되는 유형</target>
        </trans-unit>
        <trans-unit id="be8759e614c84bf4aa1ab490c6a68e3e469c7bdd" translate="yes" xml:space="preserve">
          <source>Supported types:</source>
          <target state="translated">지원되는 유형 :</target>
        </trans-unit>
        <trans-unit id="ebc61f82b2a83286b06fcc3b771ac98f59a64fd3" translate="yes" xml:space="preserve">
          <source>Supported values: 2 (CURT_HEALTH): Output a float32/64 tensor of shape [2]. The 1st element is the tensor_id, if provided, and -1 otherwise. The 2nd element is a bit which is set to 1 if the input tensor has an infinity or nan value, or zero otherwise.</source>
          <target state="translated">Supported values: 2 (CURT_HEALTH): Output a float32/64 tensor of shape [2]. The 1st element is the tensor_id, if provided, and -1 otherwise. The 2nd element is a bit which is set to 1 if the input tensor has an infinity or nan value, or zero otherwise.</target>
        </trans-unit>
        <trans-unit id="f61dfa31d4cb3ff17788ec5b8346532ec118b4e9" translate="yes" xml:space="preserve">
          <source>Supports all values that can be represented as a string, including 1D iterables such as &lt;code&gt;np.ndarray&lt;/code&gt;.</source>
          <target state="translated">Supports all values that can be represented as a string, including 1D iterables such as &lt;code&gt;np.ndarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abd5978641e98b805d5cc09691807cae3f3387cc" translate="yes" xml:space="preserve">
          <source>Supports all values that can be represented as a string, including 1D iterables such as np.ndarray.</source>
          <target state="translated">np.ndarray와 같은 1D 이터 러블을 포함하여 문자열로 표현할 수있는 모든 값을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="104d684cf03eff52e2dbd8ee731bf94a0c3b8a59" translate="yes" xml:space="preserve">
          <source>Supports custom &lt;code&gt;loss_fn&lt;/code&gt;. &lt;code&gt;loss_fn&lt;/code&gt; takes &lt;code&gt;(labels, logits)&lt;/code&gt; or &lt;code&gt;(labels, logits, features, loss_reduction)&lt;/code&gt; as arguments and returns unreduced loss with shape &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt;.</source>
          <target state="translated">사용자 정의 &lt;code&gt;loss_fn&lt;/code&gt; 을 지원합니다 . &lt;code&gt;loss_fn&lt;/code&gt; 은 &lt;code&gt;(labels, logits)&lt;/code&gt; 또는 &lt;code&gt;(labels, logits, features, loss_reduction)&lt;/code&gt; 을 인수로 취하고 모양이 &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt; 감소되지 않은 손실을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a316cf92878313bf869404b90ceec201fde29a87" translate="yes" xml:space="preserve">
          <source>Supports loading into partitioned variables, which are represented as &lt;code&gt;'&amp;lt;variable&amp;gt;/part_&amp;lt;part #&amp;gt;'&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;'&amp;lt;variable&amp;gt;/part_&amp;lt;part #&amp;gt;'&lt;/code&gt; 로 표시되는 파티션 된 변수로의로드를 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e964d3014915281d079adadf918032ad21ee9376" translate="yes" xml:space="preserve">
          <source>Supports many numeric types and boolean.</source>
          <target state="translated">많은 숫자 유형과 부울을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="f7d38c23447a54dd0a8a5a8f23ba246013d5bca2" translate="yes" xml:space="preserve">
          <source>Supports multidimensional indexing and slicing, with one restriction: indexing into a ragged inner dimension is not allowed. This case is problematic because the indicated value may exist in some rows but not others. In such cases, it's not obvious whether we should (1) report an IndexError; (2) use a default value; or (3) skip that value and return a tensor with fewer rows than we started with. Following the guiding principles of Python (&quot;In the face of ambiguity, refuse the temptation to guess&quot;), we simply disallow this operation.</source>
          <target state="translated">한 차원의 제한으로 다차원 인덱싱 및 슬라이싱을 지원합니다. 비정형 내부 차원으로 인덱싱 할 수 없습니다. 이 값은 표시된 값이 일부 행에 존재할 수 있지만 다른 행에는 존재하지 않기 때문에 문제가됩니다. 그러한 경우, 우리가 (1) IndexError를보고해야하는지의 여부는 확실하지 않다. (2) 기본값을 사용하십시오. 또는 (3) 그 값을 건너 뛰고 시작했던 것보다 적은 행을 가진 텐서를 반환합니다. 파이썬의지도 원칙 ( &quot;모호함에 직면하여 추측하려는 유혹을 거부한다&quot;)에 따라, 우리는 단순히이 동작을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="465d7f75658c4dd0bcc894320c0de2a6164e5f1f" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;H.shape = [B1,...,Bb, N0, N1, N2]&lt;/code&gt;, we say that &lt;code&gt;H&lt;/code&gt; is a Hermitian spectrum if, with &lt;code&gt;%&lt;/code&gt; meaning modulus division,</source>
          <target state="translated">가정 &lt;code&gt;H.shape = [B1,...,Bb, N0, N1, N2]&lt;/code&gt; , 우리는 말할 &lt;code&gt;H&lt;/code&gt; 는 허미 시안 스펙트럼으로, 만약 &lt;code&gt;%&lt;/code&gt; 로 계수 분할을 의미</target>
        </trans-unit>
        <trans-unit id="f72a981b2d0bc9ee25053f2c6bb8efd804f77034" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;H.shape = [B1,...,Bb, N0, N1]&lt;/code&gt;, we say that &lt;code&gt;H&lt;/code&gt; is a Hermitian spectrum if, with &lt;code&gt;%&lt;/code&gt; indicating modulus division,</source>
          <target state="translated">가정 &lt;code&gt;H.shape = [B1,...,Bb, N0, N1]&lt;/code&gt; , 우리는 말할 &lt;code&gt;H&lt;/code&gt; 는 허미 시안 스펙트럼 경우 함께이다 &lt;code&gt;%&lt;/code&gt; , 모듈러스 나눗셈을 나타내는</target>
        </trans-unit>
        <trans-unit id="69e9539be0d74edf27965ae7808985529de3daca" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;H.shape = [B1,...,Bb, N]&lt;/code&gt;. We say that &lt;code&gt;H&lt;/code&gt; is a Hermitian spectrum if, with &lt;code&gt;%&lt;/code&gt; meaning modulus division,</source>
          <target state="translated">&lt;code&gt;H.shape = [B1,...,Bb, N]&lt;/code&gt; 이라고 가정하십시오 . 우리는 말할 &lt;code&gt;H&lt;/code&gt; 는 에르 미트 스펙트럼 경우가와입니다 &lt;code&gt;%&lt;/code&gt; 모듈로 나눗셈을 의미 .</target>
        </trans-unit>
        <trans-unit id="3f9b5e76df5dccbcc6983619f69ec6626d9745ba" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; consisting of &lt;code&gt;D&lt;/code&gt; row-partitions and &lt;code&gt;D&lt;/code&gt; column-partitions, such that the total number of operators is &lt;code&gt;N = D * (D + 1) // 2&lt;/code&gt;.</source>
          <target state="translated">Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorBlockLowerTriangular&lt;/code&gt; consisting of &lt;code&gt;D&lt;/code&gt; row-partitions and &lt;code&gt;D&lt;/code&gt; column-partitions, such that the total number of operators is &lt;code&gt;N = D * (D + 1) // 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c13ea8e213e123c5d46aca6ff82c0ff6d54078b" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorCirculant&lt;/code&gt; of shape &lt;code&gt;[N, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">가정하자 &lt;code&gt;operator&lt;/code&gt; A는 &lt;code&gt;LinearOperatorCirculant&lt;/code&gt; 형상을 &lt;code&gt;[N, N]&lt;/code&gt; , 및 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; . 그때</target>
        </trans-unit>
        <trans-unit id="c7ae0d4dbc265f3305695b532a6acdf5985ab031" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorDiag&lt;/code&gt; of shape &lt;code&gt;[N, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">&lt;code&gt;operator&lt;/code&gt; 가 모양 &lt;code&gt;[N, N]&lt;/code&gt; 이고 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; &lt;code&gt;LinearOperatorDiag&lt;/code&gt; 라고 가정합니다 . 그때</target>
        </trans-unit>
        <trans-unit id="0ba1a907b3f27c40ff85272978f14bd8fe9cc06b" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; of shape &lt;code&gt;[M, N]&lt;/code&gt;, made from a rank &lt;code&gt;K&lt;/code&gt; update of &lt;code&gt;base_operator&lt;/code&gt; which performs &lt;code&gt;.matmul(x)&lt;/code&gt; on &lt;code&gt;x&lt;/code&gt; having &lt;code&gt;x.shape = [N, R]&lt;/code&gt; with &lt;code&gt;O(L_matmul*N*R)&lt;/code&gt; complexity (and similarly for &lt;code&gt;solve&lt;/code&gt;, &lt;code&gt;determinant&lt;/code&gt;. Then, if &lt;code&gt;x.shape = [N, R]&lt;/code&gt;,</source>
          <target state="translated">가정하자 &lt;code&gt;operator&lt;/code&gt; A는 &lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; 형상 &lt;code&gt;[M, N]&lt;/code&gt; 랭크에서 만든 &lt;code&gt;K&lt;/code&gt; 의 업데이트 &lt;code&gt;base_operator&lt;/code&gt; 수행 &lt;code&gt;.matmul(x)&lt;/code&gt; 에 대한 &lt;code&gt;x&lt;/code&gt; 갖는 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; 과 &lt;code&gt;O(L_matmul*N*R)&lt;/code&gt; 복잡성 (와 마찬가지로 &lt;code&gt;solve&lt;/code&gt; , &lt;code&gt;determinant&lt;/code&gt; . 그러면 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="0c77e9c8aaab3edc5678c3e6e549ae40d1713585" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; of shape &lt;code&gt;[N, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">가정하자 &lt;code&gt;operator&lt;/code&gt; A는 &lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; 형상 &lt;code&gt;[N, N]&lt;/code&gt; , 및 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; . 그때</target>
        </trans-unit>
        <trans-unit id="b2084687b2895669a5e72e33943c08a5a3724177" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorTridiag&lt;/code&gt; of shape &lt;code&gt;[N, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">Suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorTridiag&lt;/code&gt; of shape &lt;code&gt;[N, N]&lt;/code&gt; , and &lt;code&gt;x.shape = [N, R]&lt;/code&gt; . Then</target>
        </trans-unit>
        <trans-unit id="23ed1b4df71c9959792073ca5b67ae2e12e27635" translate="yes" xml:space="preserve">
          <source>Suppose head1.logits_dimension = 2 and head2.logits_dimension = 3. After</source>
          <target state="translated">head1.logits_dimension = 2이고 head2.logits_dimension = 3이라고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1ed5b73f01ec764b2e1451778b0c4aa2a7352d61" translate="yes" xml:space="preserve">
          <source>Suppose that</source>
          <target state="translated">Suppose that</target>
        </trans-unit>
        <trans-unit id="5c269bc606f19d8edaa319f84a6c255fb252f362" translate="yes" xml:space="preserve">
          <source>Suppose that &lt;code&gt;elems&lt;/code&gt; is unpacked into &lt;code&gt;values&lt;/code&gt;, a list of tensors. The shape of the result tensor is &lt;code&gt;[len(values)] + fn(initializer, values[0]).shape&lt;/code&gt;. If reverse=True, it's fn(initializer, values[-1]).shape.</source>
          <target state="translated">&lt;code&gt;elems&lt;/code&gt; 가 텐서 목록 인 &lt;code&gt;values&lt;/code&gt; 로 압축 해제 되었다고 가정하십시오 . 결과 텐서의 모양은 &lt;code&gt;[len(values)] + fn(initializer, values[0]).shape&lt;/code&gt; 입니다. reverse = True이면 fn (initializer, values ​​[-1]). shape입니다.</target>
        </trans-unit>
        <trans-unit id="d3c35f6ed89e8be18a5dda61c0fefcaae20da780" translate="yes" xml:space="preserve">
          <source>Suppose that &lt;code&gt;elems&lt;/code&gt; is unpacked into &lt;code&gt;values&lt;/code&gt;, a list of tensors. The shape of the result tensor is &lt;code&gt;[values.shape[0]] + fn(values[0]).shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;elems&lt;/code&gt; 가 텐서 목록 인 &lt;code&gt;values&lt;/code&gt; 로 압축 해제 되었다고 가정하십시오 . 결과 텐서의 모양은 &lt;code&gt;[values.shape[0]] + fn(values[0]).shape&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dffca82b48f3566d75cc894aa925b53a25bf73ca" translate="yes" xml:space="preserve">
          <source>Suppose that &lt;code&gt;elems&lt;/code&gt; is unpacked into &lt;code&gt;values&lt;/code&gt;, a list of tensors. The shape of the result tensor is &lt;code&gt;fn(initializer, values[0]).shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;elems&lt;/code&gt; 가 텐서 목록 인 &lt;code&gt;values&lt;/code&gt; 로 압축 해제 되었다고 가정하십시오 . 결과 텐서의 모양은 &lt;code&gt;fn(initializer, values[0]).shape&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3bdc81326d20683103cdcdb7d7d719aec67b18bc" translate="yes" xml:space="preserve">
          <source>Suppose that &lt;code&gt;elems&lt;/code&gt; is unpacked into &lt;code&gt;values&lt;/code&gt;, a list of tensors. The shape of the result tensor is fn(initializer, values[0]).shape`.</source>
          <target state="translated">&lt;code&gt;elems&lt;/code&gt; 이 &lt;code&gt;values&lt;/code&gt; 으로 압축 해제 되었다고 가정하십시오. 텐서 목록 인 . 결과 텐서의 모양은 fn (initializer, values ​​[0]). shape`입니다.</target>
        </trans-unit>
        <trans-unit id="f480af4470b536307bbf09765cdc8e2696cc548a" translate="yes" xml:space="preserve">
          <source>Survival function.</source>
          <target state="translated">생존 기능.</target>
        </trans-unit>
        <trans-unit id="0de5ff9a96be0872c4a95318ce78eb85ff4766da" translate="yes" xml:space="preserve">
          <source>Svd</source>
          <target state="translated">Svd</target>
        </trans-unit>
        <trans-unit id="da92d85a6fc13c9b04db86132c713c6ff78d5eec" translate="yes" xml:space="preserve">
          <source>Swish activation function which returns &lt;code&gt;x*sigmoid(x)&lt;/code&gt;. It is a smooth, non-monotonic function that consistently matches or outperforms ReLU on deep networks, it is unbounded above and bounded below.</source>
          <target state="translated">Swish activation function which returns &lt;code&gt;x*sigmoid(x)&lt;/code&gt; . It is a smooth, non-monotonic function that consistently matches or outperforms ReLU on deep networks, it is unbounded above and bounded below.</target>
        </trans-unit>
        <trans-unit id="7a4332dc29f19a6318c112c9802095accf9482bc" translate="yes" xml:space="preserve">
          <source>Swish activation function, &lt;code&gt;swish(x) = x * sigmoid(x)&lt;/code&gt;.</source>
          <target state="translated">Swish activation function, &lt;code&gt;swish(x) = x * sigmoid(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e44c920427e845df4958295eb8c3045b55fcfd5" translate="yes" xml:space="preserve">
          <source>Switch</source>
          <target state="translated">Switch</target>
        </trans-unit>
        <trans-unit id="3226a9be6189190c548f628801bd70aeb6bac060" translate="yes" xml:space="preserve">
          <source>Switch to cross-replica mode by calling &lt;code&gt;tf.distribute.get_replica_context().merge_call()&lt;/code&gt; with the updates and variables as arguments.</source>
          <target state="translated">업데이트 및 변수를 인수로 사용하여 &lt;code&gt;tf.distribute.get_replica_context().merge_call()&lt;/code&gt; 을 호출하여 교차 복제 모드로 전환하십시오 .</target>
        </trans-unit>
        <trans-unit id="c82b9c388b0f25a72fdba537900d4ee1afe829a0" translate="yes" xml:space="preserve">
          <source>Switches between two operations depending on a scalar value.</source>
          <target state="translated">스칼라 값에 따라 두 작업 사이를 전환합니다.</target>
        </trans-unit>
        <trans-unit id="4bd6d6747309915056dbba0e2193c97595c133f2" translate="yes" xml:space="preserve">
          <source>Symbolic tensors are allowed to pass through.</source>
          <target state="translated">기호 텐서가 통과 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="030a01f5f589b63fb470abdc96d1262d3ad7cea8" translate="yes" xml:space="preserve">
          <source>SymbolicGradient</source>
          <target state="translated">SymbolicGradient</target>
        </trans-unit>
        <trans-unit id="0fb1fd52c55e655e07722932e23d7213a1f7639b" translate="yes" xml:space="preserve">
          <source>Synchronous training across multiple replicas on one machine.</source>
          <target state="translated">Synchronous training across multiple replicas on one machine.</target>
        </trans-unit>
        <trans-unit id="ed4aff47c3be607749bd2e1d76c1e799b5c23200" translate="yes" xml:space="preserve">
          <source>Synchronous training in TPU donuts or Pods.</source>
          <target state="translated">TPU 도넛 또는 포드의 동기식 훈련.</target>
        </trans-unit>
        <trans-unit id="08c3d58cad53f10c3d5bd02aff3f3ba1a7ff0e69" translate="yes" xml:space="preserve">
          <source>Synchronous training on TPUs and TPU Pods.</source>
          <target state="translated">Synchronous training on TPUs and TPU Pods.</target>
        </trans-unit>
        <trans-unit id="b9cb28847740ddfa22df77ecf9af53c7bcc458c9" translate="yes" xml:space="preserve">
          <source>System configuration library.</source>
          <target state="translated">시스템 구성 라이브러리</target>
        </trans-unit>
        <trans-unit id="96dfaad4f747857beb41d1e85f4c6a845c40559b" translate="yes" xml:space="preserve">
          <source>T-shirt/top</source>
          <target state="translated">T-shirt/top</target>
        </trans-unit>
        <trans-unit id="c3c9fd8a607c0fc8d5f20ab08a585b5a769813a4" translate="yes" xml:space="preserve">
          <source>TFDecorator captures and exposes the wrapped target, and provides details about the current decorator.</source>
          <target state="translated">TFDecorator는 랩핑 된 대상을 캡처하고 노출하며 현재 데코레이터에 대한 세부 사항을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b0ae8b7e5c1a9027f31ac3b8b9a304ad1f03ee67" translate="yes" xml:space="preserve">
          <source>TFLiteConverter class.</source>
          <target state="translated">TFLiteConverter 클래스</target>
        </trans-unit>
        <trans-unit id="40c2a70a8ac9081500125d800973c1f2856d001e" translate="yes" xml:space="preserve">
          <source>TFLiteConverter object.</source>
          <target state="translated">TFLiteConverter 객체.</target>
        </trans-unit>
        <trans-unit id="5a3f9ca39eb5977717f75ea98c14ebd341cb7b0c" translate="yes" xml:space="preserve">
          <source>TFRecord and tf.Example</source>
          <target state="translated">TFRecord 및 tf.Example</target>
        </trans-unit>
        <trans-unit id="c164b336cc47baa6a15ddd49c63091d7da6180d8" translate="yes" xml:space="preserve">
          <source>TFRecordDataset</source>
          <target state="translated">TFRecordDataset</target>
        </trans-unit>
        <trans-unit id="8df4b52fbc8864648ac860405c6438c112669392" translate="yes" xml:space="preserve">
          <source>TFRecordReader</source>
          <target state="translated">TFRecordReader</target>
        </trans-unit>
        <trans-unit id="17f974c4f4299c7c4142cb4b6284dff42f4a579e" translate="yes" xml:space="preserve">
          <source>TFRecordReaderV2</source>
          <target state="translated">TFRecordReaderV2</target>
        </trans-unit>
        <trans-unit id="32d34981bbb9299daf0163a123badc9ab99428e3" translate="yes" xml:space="preserve">
          <source>TFRecords is a binary format which is optimized for high throughput data retrieval, generally in conjunction with &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;TFRecordWriter&lt;/code&gt; is used to write serialized examples to a file for later consumption. The key steps are:</source>
          <target state="translated">TFRecords is a binary format which is optimized for high throughput data retrieval, generally in conjunction with &lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;. &lt;code&gt;TFRecordWriter&lt;/code&gt; is used to write serialized examples to a file for later consumption. The key steps are:</target>
        </trans-unit>
        <trans-unit id="00fd1de249e5cb7297b059142d08b24b2185a8f1" translate="yes" xml:space="preserve">
          <source>TFRecords tutorial</source>
          <target state="translated">TFRecords tutorial</target>
        </trans-unit>
        <trans-unit id="f2a1cfdc5a677069b65778d10bf6ba1ec74141b1" translate="yes" xml:space="preserve">
          <source>THIS CLASS IS DEPRECATED. Training with HDF5Matrix may not be optimized for performance, and might not work with every distribution strategy.</source>
          <target state="translated">이 클래스는 더 이상 사용되지 않습니다. HDF5Matrix를 사용한 교육은 성능에 최적화되지 않았으며 모든 배포 전략에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea3b5253f8acd939a0fcfcfde0d4f81758ceb6ec" translate="yes" xml:space="preserve">
          <source>THIS FUNCTION IS EXPERIMENTAL. Keras layers/models are the recommended APIs for logit and model composition.</source>
          <target state="translated">이 기능은 실험적입니다. Keras 레이어 / 모델은 로짓 및 모델 구성에 권장되는 API입니다.</target>
        </trans-unit>
        <trans-unit id="6e68009384c2a3495a678e12d2ac69897187a9e4" translate="yes" xml:space="preserve">
          <source>TIP: V2 is recommended as it is more flexible (eg: batching, etc).</source>
          <target state="translated">힌트 : V2는보다 유연하므로 (예 : 배치 등) 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="86c515aa235c35a6dd43d1bb6f6bd5b2174b6173" translate="yes" xml:space="preserve">
          <source>TODO(phawkins): consider adding support for broadcasting Tensors passed as inputs.</source>
          <target state="translated">TODO (phawkins) : 입력으로 전달 된 Tensor 브로드 캐스트에 대한 지원 추가를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0670d6d1899b8c7a6ede58b5b723e5aff4b026c8" translate="yes" xml:space="preserve">
          <source>TODO: add doc.</source>
          <target state="translated">TODO : 문서를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6907e140b23b35d38f6441293f654f8fc707a293" translate="yes" xml:space="preserve">
          <source>TPU distribution strategy implementation.</source>
          <target state="translated">TPU 배포 전략 구현.</target>
        </trans-unit>
        <trans-unit id="c2e6d3a312671dc52e2d71bde402cdc7f8d14f6d" translate="yes" xml:space="preserve">
          <source>TPU embeddings do not support arbitrary Tensorflow optimizers and the main optimizer you use for your model will be ignored for the embedding table variables. Instead TPU embeddigns support a fixed set of predefined optimizers that you can select from and set the parameters of. These include adagrad, adam and stochastic gradient descent. Each supported optimizer has a &lt;code&gt;Parameters&lt;/code&gt; class in the &lt;a href=&quot;../../../../../tpu/experimental&quot;&gt;&lt;code&gt;tf.tpu.experimental&lt;/code&gt;&lt;/a&gt; namespace.</source>
          <target state="translated">TPU 임베딩은 임의의 Tensorflow 옵티 마이저를 지원하지 않으며 임베드 테이블 변수에 대해 모델에 사용하는 기본 옵티마이 저는 무시됩니다. 대신 TPU embeddigns는 매개 변수를 선택하고 설정할 수있는 사전 정의 된 고정 최적화 프로그램의 고정 집합을 지원합니다. 여기에는 adagrad, adam 및 stochastic gradient descent가 포함됩니다. 지원되는 각 최적화 프로그램에는 &lt;a href=&quot;../../../../../tpu/experimental&quot;&gt; &lt;code&gt;tf.tpu.experimental&lt;/code&gt; &lt;/a&gt; 네임 스페이스 에 &lt;code&gt;Parameters&lt;/code&gt; 클래스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c46f66d84964d9d9b6cca0e4bf0d96c3c3563722" translate="yes" xml:space="preserve">
          <source>TPU evaluation only works on a single host (one TPU worker) except BROADCAST mode.</source>
          <target state="translated">TPU 평가는 BROADCAST 모드를 제외한 단일 호스트 (한 TPU 작업자)에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="608813e35435b00f9557600b0760339a8be2fba8" translate="yes" xml:space="preserve">
          <source>TPU prediction only works on a single host (one TPU worker).</source>
          <target state="translated">TPU 예측은 단일 호스트 (한 TPU 작업자)에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bea46edc5a09b34d108296e7caa64c56863439a0" translate="yes" xml:space="preserve">
          <source>TPU related configuration required by &lt;code&gt;TPUEstimator&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TPUEstimator&lt;/code&gt; 에 필요한 TPU 관련 구성 .</target>
        </trans-unit>
        <trans-unit id="15462f6b704e5cb2f8f24f59de3042ec97404e38" translate="yes" xml:space="preserve">
          <source>TPU version of &lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../../feature_column/embedding_column&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.embedding_column&lt;/code&gt; 의&lt;/a&gt; TPU 버전 .</target>
        </trans-unit>
        <trans-unit id="9d40306c82f3b12d754e570cc8b1cc658af2d7ec" translate="yes" xml:space="preserve">
          <source>TPU version of &lt;a href=&quot;../../feature_column/shared_embedding_columns&quot;&gt;&lt;code&gt;tf.compat.v1.feature_column.shared_embedding_columns&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../feature_column/shared_embedding_columns&quot;&gt; &lt;code&gt;tf.compat.v1.feature_column.shared_embedding_columns&lt;/code&gt; 의&lt;/a&gt; TPU 버전 .</target>
        </trans-unit>
        <trans-unit id="87bcdd18e5c8f3b283a01e8df873660ee1d3e88c" translate="yes" xml:space="preserve">
          <source>TPUClusterResolver supports the following distinct environments: Google Compute Engine Google Kubernetes Engine Google internal</source>
          <target state="translated">TPUClusterResolver는 다음과 같은 고유 한 환경을 지원합니다. Google Compute Engine Google Kubernetes Engine Google 내부</target>
        </trans-unit>
        <trans-unit id="aa01338f3d5c86c9fcdb705e00f36f804bb0cc34" translate="yes" xml:space="preserve">
          <source>TPUCompilationResult</source>
          <target state="translated">TPUCompilationResult</target>
        </trans-unit>
        <trans-unit id="1bf6991a8244be8f112b91697481461e3dbf1f90" translate="yes" xml:space="preserve">
          <source>TPUEmbeddingActivations</source>
          <target state="translated">TPUEmbeddingActivations</target>
        </trans-unit>
        <trans-unit id="3090232b8a50e355f64d4b6a9078737dd646c783" translate="yes" xml:space="preserve">
          <source>TPUEstimator also supports training on CPU and GPU. You don't need to define a separate &lt;a href=&quot;../../../../estimator/estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TPUEstimator는 CPU 및 GPU에 대한 교육도 지원합니다. 별도의 &lt;a href=&quot;../../../../estimator/estimator&quot;&gt; &lt;code&gt;tf.estimator.Estimator&lt;/code&gt; &lt;/a&gt; 를 정의 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2ddc9467e5f271b2c256312505abf3c2d4c6b0c7" translate="yes" xml:space="preserve">
          <source>TPUEstimator handles many of the details of running on TPU devices, such as replicating inputs and models for each core, and returning to host periodically to run hooks.</source>
          <target state="translated">TPUEstimator는 각 코어에 대한 입력 및 모델 복제, 주기적으로 호스트로 돌아와 후크를 실행하는 등 TPU 장치에서 실행하는 많은 세부 사항을 처리합니다.</target>
        </trans-unit>
        <trans-unit id="b7e3ce08e3020395f3645372f9a127852462deaa" translate="yes" xml:space="preserve">
          <source>TPUEstimator transforms a global batch size in params to a per-shard batch size when calling the &lt;code&gt;input_fn&lt;/code&gt; and &lt;code&gt;model_fn&lt;/code&gt;. Users should specify global batch size in constructor, and then get the batch size for each shard in &lt;code&gt;input_fn&lt;/code&gt; and &lt;code&gt;model_fn&lt;/code&gt; by &lt;code&gt;params['batch_size']&lt;/code&gt;.</source>
          <target state="translated">TPUEstimator는 &lt;code&gt;input_fn&lt;/code&gt; 및 &lt;code&gt;model_fn&lt;/code&gt; 을 호출 할 때 params의 전역 배치 크기를 샤드 별 배치 크기로 변환합니다 . 사용자는 생성자에 전역 배치 크기를 지정한 다음 &lt;code&gt;params['batch_size']&lt;/code&gt; 에 의해 &lt;code&gt;input_fn&lt;/code&gt; 및 &lt;code&gt;model_fn&lt;/code&gt; 의 각 샤드에 대한 배치 크기를 가져와야 합니다 .</target>
        </trans-unit>
        <trans-unit id="b79ea6bd91e106b020941541f8a693784aab7f0d" translate="yes" xml:space="preserve">
          <source>TPUOrdinalSelector</source>
          <target state="translated">TPUOrdinalSelector</target>
        </trans-unit>
        <trans-unit id="db23d6b228f4f269c406951ac6f48bb9618723ba" translate="yes" xml:space="preserve">
          <source>TPUPartitionedCall</source>
          <target state="translated">TPUPartitionedCall</target>
        </trans-unit>
        <trans-unit id="4ce14a2bc1df9e5fd9f3b0ba5666724aeb5292a5" translate="yes" xml:space="preserve">
          <source>TPUReplicateMetadata</source>
          <target state="translated">TPUReplicateMetadata</target>
        </trans-unit>
        <trans-unit id="01f8296c3cd8091ece253f444c565756100968ff" translate="yes" xml:space="preserve">
          <source>TPUReplicatedInput</source>
          <target state="translated">TPUReplicatedInput</target>
        </trans-unit>
        <trans-unit id="732e12e781f76421b82f1f4357afe8f9aa493c90" translate="yes" xml:space="preserve">
          <source>TPUReplicatedOutput</source>
          <target state="translated">TPUReplicatedOutput</target>
        </trans-unit>
        <trans-unit id="d1c1e452ecf33031ed0f22504870118a774db89c" translate="yes" xml:space="preserve">
          <source>TRAIN / EVAL / PREDICT ModeKeys.</source>
          <target state="translated">TRAIN / EVAL / PREDICT ModeKeys.</target>
        </trans-unit>
        <trans-unit id="61da3e3ab775849343a5d8c98a22be9479f3edbc" translate="yes" xml:space="preserve">
          <source>Table initializer that takes two tensors for keys and values respectively.</source>
          <target state="translated">Table initializer that takes two tensors for keys and values respectively.</target>
        </trans-unit>
        <trans-unit id="39242b58e44e50c227c356940f2f4790b1a6c7ad" translate="yes" xml:space="preserve">
          <source>Table initializers from a text file.</source>
          <target state="translated">텍스트 파일의 테이블 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="e9a99855991e9fba416a14570cf1cb6a0187f661" translate="yes" xml:space="preserve">
          <source>Table initializers given &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; tensors.</source>
          <target state="translated">&lt;code&gt;keys&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 주어진 테이블 이니셜 라이저 텐서가 .</target>
        </trans-unit>
        <trans-unit id="0ca4ea5ec4f9fcdb5ef0036d59d590c2c4ae6ff3" translate="yes" xml:space="preserve">
          <source>TakeDataset</source>
          <target state="translated">TakeDataset</target>
        </trans-unit>
        <trans-unit id="2eab7790b3d93d34755a8f59c3c006f04c2bbed3" translate="yes" xml:space="preserve">
          <source>TakeManySparseFromTensorsMap</source>
          <target state="translated">TakeManySparseFromTensorsMap</target>
        </trans-unit>
        <trans-unit id="b6eea7b2143fd69da3f4217bcdfc5542d526b61f" translate="yes" xml:space="preserve">
          <source>TakeWhileDataset</source>
          <target state="translated">TakeWhileDataset</target>
        </trans-unit>
        <trans-unit id="c8cdf739c22a4d4562a4121cb9924e968d8c70c9" translate="yes" xml:space="preserve">
          <source>Takes &lt;code&gt;T&lt;/code&gt; elements of shapes</source>
          <target state="translated">Takes &lt;code&gt;T&lt;/code&gt; elements of shapes</target>
        </trans-unit>
        <trans-unit id="1af97a71a1a73644d18d0f047160d91771a21862" translate="yes" xml:space="preserve">
          <source>Takes a &lt;strong&gt;doc&lt;/strong&gt; string and reformats it as help.</source>
          <target state="translated">걸린다 &lt;strong&gt;문서를&lt;/strong&gt; 문자열과 도움으로 다시 포맷을.</target>
        </trans-unit>
        <trans-unit id="b5507e3c183afb3feb1fdd594429bbf04fe50d0d" translate="yes" xml:space="preserve">
          <source>Takes data &amp;amp; label arrays, generates batches of augmented data.</source>
          <target state="translated">데이터 및 레이블 배열을 가져 와서 확장 된 데이터의 배치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dc5dd136fb3e20832ac83739b0d79852faeb82ca" translate="yes" xml:space="preserve">
          <source>Takes input and builds independent forward and backward RNNs. The input_size of forward and backward cell must match. The initial state for both directions is zero by default (but can be set optionally) and no intermediate states are ever returned -- the network is fully unrolled for the given (passed in) length(s) of the sequence(s) or completely unrolled if length(s) is not given.</source>
          <target state="translated">입력을 받아서 독립적 인 정방향 및 역방향 RNN을 작성합니다. 정방향 및 역방향 셀의 input_size가 일치해야합니다. 양방향의 초기 상태는 기본적으로 0이지만 (선택적으로 설정 가능) 중간 상태는 반환되지 않습니다. 시퀀스의 지정된 길이 (또는 길이) 동안 네트워크가 완전히 언 롤링됩니다. 길이가 주어지지 않으면 풀린다.</target>
        </trans-unit>
        <trans-unit id="14bd6c407f104bb9dbcadb64b98d00494166da7f" translate="yes" xml:space="preserve">
          <source>Takes the dataframe and the path to a directory + generates batches.</source>
          <target state="translated">Takes the dataframe and the path to a directory + generates batches.</target>
        </trans-unit>
        <trans-unit id="53df57e552ce83928403023542fdf87dfd9006ea" translate="yes" xml:space="preserve">
          <source>Takes the dataframe and the path to a directory and generates batches of augmented/normalized data.</source>
          <target state="translated">데이터 프레임과 디렉토리 경로를 가져 와서 확장 / 정규화 된 데이터 배치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="90f2cc362e7961321edf03101ab5c11b209fdfe1" translate="yes" xml:space="preserve">
          <source>Takes the given number of completed elements from a barrier.</source>
          <target state="translated">Takes the given number of completed elements from a barrier.</target>
        </trans-unit>
        <trans-unit id="271a488ff4179dc414b9d598c0dc902bde38633e" translate="yes" xml:space="preserve">
          <source>Takes the path to a directory &amp;amp; generates batches of augmented data.</source>
          <target state="translated">디렉토리로의 경로를 취하고 증강 데이터의 배치를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6a4bc3c503c1251fa317296676237f5dd2f5cbff" translate="yes" xml:space="preserve">
          <source>Takes vectors reverse_index_map, shaped &lt;code&gt;[N]&lt;/code&gt;, and grad_values, shaped &lt;code&gt;[N_full]&lt;/code&gt;, where &lt;code&gt;N_full &amp;gt;= N&lt;/code&gt; and copies data into either &lt;code&gt;d_values&lt;/code&gt; or &lt;code&gt;d_default_value&lt;/code&gt;. Here &lt;code&gt;d_values&lt;/code&gt; is shaped &lt;code&gt;[N]&lt;/code&gt; and &lt;code&gt;d_default_value&lt;/code&gt; is a scalar.</source>
          <target state="translated">Takes vectors reverse_index_map, shaped &lt;code&gt;[N]&lt;/code&gt; , and grad_values, shaped &lt;code&gt;[N_full]&lt;/code&gt; , where &lt;code&gt;N_full &amp;gt;= N&lt;/code&gt; and copies data into either &lt;code&gt;d_values&lt;/code&gt; or &lt;code&gt;d_default_value&lt;/code&gt; . Here &lt;code&gt;d_values&lt;/code&gt; is shaped &lt;code&gt;[N]&lt;/code&gt; and &lt;code&gt;d_default_value&lt;/code&gt; is a scalar.</target>
        </trans-unit>
        <trans-unit id="133552ebfbcce8310f8920695422699d5256bac9" translate="yes" xml:space="preserve">
          <source>Tan</source>
          <target state="translated">Tan</target>
        </trans-unit>
        <trans-unit id="19bff9fbbbadd7b339e0ee0ae1715d62fea9cae0" translate="yes" xml:space="preserve">
          <source>Tanh</source>
          <target state="translated">Tanh</target>
        </trans-unit>
        <trans-unit id="14112156ac08b6a92c0a75374052fff645e2bcc6" translate="yes" xml:space="preserve">
          <source>TanhGrad</source>
          <target state="translated">TanhGrad</target>
        </trans-unit>
        <trans-unit id="28e1f2599eedcaa4777b838dbc9cdf0483db19ef" translate="yes" xml:space="preserve">
          <source>Target data type of real-number arrays in the output file. Must be &lt;code&gt;{tf.float32, tf.uint8}&lt;/code&gt;. If &lt;code&gt;optimzations&lt;/code&gt; are provided, this parameter is ignored. (default tf.float32)</source>
          <target state="translated">Target data type of real-number arrays in the output file. Must be &lt;code&gt;{tf.float32, tf.uint8}&lt;/code&gt; . If &lt;code&gt;optimzations&lt;/code&gt; are provided, this parameter is ignored. (default tf.float32)</target>
        </trans-unit>
        <trans-unit id="7b3ddfa024079f3b2e31a83be781ac4fc1b50fc2" translate="yes" xml:space="preserve">
          <source>Target data type of real-number input arrays. Allows for a different type for input arrays. If an integer type is provided and &lt;code&gt;optimizations&lt;/code&gt; are not used, &lt;code&gt;quantized_inputs_stats&lt;/code&gt; must be provided. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained input model, then &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.float32. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</source>
          <target state="translated">Target data type of real-number input arrays. Allows for a different type for input arrays. If an integer type is provided and &lt;code&gt;optimizations&lt;/code&gt; are not used, &lt;code&gt;quantized_inputs_stats&lt;/code&gt; must be provided. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained input model, then &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_input_type&lt;/code&gt; defaults to tf.float32. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61e25ecfb7a5f990edbebe475f179877ca81f12c" translate="yes" xml:space="preserve">
          <source>Target data type of real-number output arrays. Allows for a different type for output arrays. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained output model, then &lt;code&gt;inference_output_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_output_type&lt;/code&gt; must be tf.float32, an error will be thrown otherwise. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</source>
          <target state="translated">Target data type of real-number output arrays. Allows for a different type for output arrays. If &lt;code&gt;inference_type&lt;/code&gt; is tf.uint8, signaling conversion to a fully quantized model from a quantization-aware trained output model, then &lt;code&gt;inference_output_type&lt;/code&gt; defaults to tf.uint8. In all other cases, &lt;code&gt;inference_output_type&lt;/code&gt; must be tf.float32, an error will be thrown otherwise. Must be &lt;code&gt;{tf.float32, tf.uint8, tf.int8}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c40e6458ec2129b4b29993fc7728baa2c9343c7" translate="yes" xml:space="preserve">
          <source>Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely).</source>
          <target state="translated">Target data. Like the input data &lt;code&gt;x&lt;/code&gt; , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely).</target>
        </trans-unit>
        <trans-unit id="d28edc72ae59652ee027fff110b801175d024129" translate="yes" xml:space="preserve">
          <source>Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</source>
          <target state="translated">Target data. Like the input data &lt;code&gt;x&lt;/code&gt; , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</target>
        </trans-unit>
        <trans-unit id="e0a687e930239141f64fb62935e1b697471281cb" translate="yes" xml:space="preserve">
          <source>Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</source>
          <target state="translated">Target data. Like the input data &lt;code&gt;x&lt;/code&gt; , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator or &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from the iterator/dataset).</target>
        </trans-unit>
        <trans-unit id="76f5e236c2023fb769ce08a2055a875a37783f94" translate="yes" xml:space="preserve">
          <source>Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">Target data. Like the input data &lt;code&gt;x&lt;/code&gt; , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="124a73f76ea9d935dce26078b03f265f6dcafe1e" translate="yes" xml:space="preserve">
          <source>Target data. Like the input data &lt;code&gt;x&lt;/code&gt;, it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt;).</source>
          <target state="translated">Target data. Like the input data &lt;code&gt;x&lt;/code&gt; , it could be either Numpy array(s) or TensorFlow tensor(s). It should be consistent with &lt;code&gt;x&lt;/code&gt; (you cannot have Numpy inputs and tensor targets, or inversely). If &lt;code&gt;x&lt;/code&gt; is a dataset, generator, or &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; instance, &lt;code&gt;y&lt;/code&gt; should not be specified (since targets will be obtained from &lt;code&gt;x&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af628ed5985a62b6169c1b32fe469e858bb5a962" translate="yes" xml:space="preserve">
          <source>Target height.</source>
          <target state="translated">Target height.</target>
        </trans-unit>
        <trans-unit id="adf589a76f0f5d9e2bb86e8b2dde9f5095147f53" translate="yes" xml:space="preserve">
          <source>Target shape tuple.</source>
          <target state="translated">Target shape tuple.</target>
        </trans-unit>
        <trans-unit id="ebc13cd2359f05591f34d4dd0c6c20c3be19247c" translate="yes" xml:space="preserve">
          <source>Target shape. Tuple of integers, does not include the samples dimension (batch size).</source>
          <target state="translated">Target shape. Tuple of integers, does not include the samples dimension (batch size).</target>
        </trans-unit>
        <trans-unit id="7d1fb71a5db68820664bf8bef7b6c55070db1b7d" translate="yes" xml:space="preserve">
          <source>Target width.</source>
          <target state="translated">Target width.</target>
        </trans-unit>
        <trans-unit id="33a027db88feecfd3ab027d6a00fe2cae9c3cf55" translate="yes" xml:space="preserve">
          <source>Targets corresponding to timesteps in &lt;code&gt;data&lt;/code&gt;. It should have same length as &lt;code&gt;data&lt;/code&gt;. &lt;code&gt;targets[i]&lt;/code&gt; should be the target corresponding to the window that starts at index &lt;code&gt;i&lt;/code&gt; (see example 2 below). Pass None if you don't have target data (in this case the dataset will only yield the input data).</source>
          <target state="translated">Targets corresponding to timesteps in &lt;code&gt;data&lt;/code&gt; . It should have same length as &lt;code&gt;data&lt;/code&gt; . &lt;code&gt;targets[i]&lt;/code&gt; should be the target corresponding to the window that starts at index &lt;code&gt;i&lt;/code&gt; (see example 2 below). Pass None if you don't have target data (in this case the dataset will only yield the input data).</target>
        </trans-unit>
        <trans-unit id="1ca63275fee9de8e1de06948cce8c928cfa17e6c" translate="yes" xml:space="preserve">
          <source>Task: The task index.</source>
          <target state="translated">작업 : 작업 인덱스</target>
        </trans-unit>
        <trans-unit id="0d5c8c8a1221df9d08630309c4e00e480ca26a66" translate="yes" xml:space="preserve">
          <source>Temporarily stops recording operations on this tape.</source>
          <target state="translated">이 테이프의 녹화 작업을 일시적으로 중지합니다.</target>
        </trans-unit>
        <trans-unit id="7587797028f9f977f3dcc7f5d6cb4ce9b3c6d940" translate="yes" xml:space="preserve">
          <source>TemporaryVariable</source>
          <target state="translated">TemporaryVariable</target>
        </trans-unit>
        <trans-unit id="d86199f8c5e160f3763b898f782dff935a2b3f9d" translate="yes" xml:space="preserve">
          <source>Tensor by which to scale the input.</source>
          <target state="translated">Tensor by which to scale the input.</target>
        </trans-unit>
        <trans-unit id="86c1923b9f8f2d8f31711cb222572e1b5d8374b8" translate="yes" xml:space="preserve">
          <source>Tensor containing indices as described above.</source>
          <target state="translated">Tensor containing indices as described above.</target>
        </trans-unit>
        <trans-unit id="d9587e11eb6cecf6bcb21eaf3f92dfb4eae1e92e" translate="yes" xml:space="preserve">
          <source>Tensor contraction according to Einstein summation convention.</source>
          <target state="translated">Tensor contraction according to Einstein summation convention.</target>
        </trans-unit>
        <trans-unit id="b284c7bc2378fc04ec8bfcb09803127b9f601fb1" translate="yes" xml:space="preserve">
          <source>Tensor contraction of a and b along specified axes and outer product.</source>
          <target state="translated">지정된 축과 외부 제품을 따라 a와 b의 텐서 수축.</target>
        </trans-unit>
        <trans-unit id="38618f2d27b4f14fefef4170aa6ae920945a40f0" translate="yes" xml:space="preserve">
          <source>Tensor contraction over specified indices and outer product.</source>
          <target state="translated">지정된 지수 및 외부 제품에 대한 텐서 수축.</target>
        </trans-unit>
        <trans-unit id="0eb7922b93e36f198944524d3ccbd887eb62554c" translate="yes" xml:space="preserve">
          <source>Tensor holding edge maps for each channel. Returns a tensor with shape [batch_size, h, w, d, 2] where the last two dimensions hold [[dy[0], dx[0]], [dy[1], dx[1]], ..., [dy[d-1], dx[d-1]]] calculated using the Sobel filter.</source>
          <target state="translated">각 채널에 대한 텐서 홀딩 엣지 맵. 마지막 두 치수가 [[dy [0], dx [0]], [dy [1], dx [1]], ...를 보유하는 [batch_size, h, w, d, 2] 모양의 텐서를 반환합니다. , [dy [d-1], dx [d-1]]]을 Sobel 필터를 사용하여 계산했습니다.</target>
        </trans-unit>
        <trans-unit id="818277be4897b82afcda9bea946567f0db418a0a" translate="yes" xml:space="preserve">
          <source>Tensor index of input to set. This value can be gotten from the 'index' field in get_input_details.</source>
          <target state="translated">Tensor index of input to set. This value can be gotten from the 'index' field in get_input_details.</target>
        </trans-unit>
        <trans-unit id="a57be7e6ceb7fe22d5efa47f9863a75198cb096e" translate="yes" xml:space="preserve">
          <source>Tensor index of tensor to get. This value can be gotten from the 'index' field in get_output_details.</source>
          <target state="translated">Tensor index of tensor to get. This value can be gotten from the 'index' field in get_output_details.</target>
        </trans-unit>
        <trans-unit id="6364407ec916483f74f70506b2ee490b75f44a0b" translate="yes" xml:space="preserve">
          <source>Tensor index of tensor to set. This value can be gotten from the 'index' field in get_input_details.</source>
          <target state="translated">Tensor index of tensor to set. This value can be gotten from the 'index' field in get_input_details.</target>
        </trans-unit>
        <trans-unit id="492485b81d5a760e9c8620ce8eb6ed8ee8dddf55" translate="yes" xml:space="preserve">
          <source>Tensor input.</source>
          <target state="translated">Tensor input.</target>
        </trans-unit>
        <trans-unit id="998135bad24dda7870bc2f0601f12e030cb5ca03" translate="yes" xml:space="preserve">
          <source>Tensor instance (with Keras metadata included).</source>
          <target state="translated">텐서 인스턴스 (Keras 메타 데이터 포함).</target>
        </trans-unit>
        <trans-unit id="2c4735941ed18003c573a2a235a9bd64c4812ee5" translate="yes" xml:space="preserve">
          <source>Tensor of one-hot true targets.</source>
          <target state="translated">Tensor of one-hot true targets.</target>
        </trans-unit>
        <trans-unit id="cf7f8d5bfd1434b76a643f6e9b82cc447c32d744" translate="yes" xml:space="preserve">
          <source>Tensor of predicted targets.</source>
          <target state="translated">Tensor of predicted targets.</target>
        </trans-unit>
        <trans-unit id="f0de66290e43e92c8ce19f341ae3cc5eeaf8fc7f" translate="yes" xml:space="preserve">
          <source>Tensor of rank &amp;gt; max(spatial_dims).</source>
          <target state="translated">Tensor of rank &amp;gt; max(spatial_dims).</target>
        </trans-unit>
        <trans-unit id="a8c99199dc012dfb8db3fd6e6e71228915c2c735" translate="yes" xml:space="preserve">
          <source>Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</source>
          <target state="translated">Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</target>
        </trans-unit>
        <trans-unit id="0847d9d94779e4f5295b4ffd5a07abb92c173543" translate="yes" xml:space="preserve">
          <source>Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if data_format does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</source>
          <target state="translated">Tensor of rank N+2, of shape &lt;code&gt;[batch_size] + input_spatial_shape + [num_channels]&lt;/code&gt; if data_format does not start with &quot;NC&quot; (default), or &lt;code&gt;[batch_size, num_channels] + input_spatial_shape&lt;/code&gt; if data_format starts with &quot;NC&quot;. Pooling happens over the spatial dimensions only.</target>
        </trans-unit>
        <trans-unit id="cd4eaaecc52921b6ace4791b28568b11625a63a9" translate="yes" xml:space="preserve">
          <source>Tensor of rank N+2, of shape [batch_size] + output_spatial_shape + [num_channels]</source>
          <target state="translated">모양 [batch_size] + output_spatial_shape + [num_channels]의 순위 N + 2의 텐서</target>
        </trans-unit>
        <trans-unit id="cb76e00fc954d9b6160cc47c8ab840677d6dc502" translate="yes" xml:space="preserve">
          <source>Tensor of same shape and dtype of input &lt;code&gt;x&lt;/code&gt;, with tanh activation: &lt;code&gt;tanh(x) = sinh(x)/cosh(x) = ((exp(x) - exp(-x))/(exp(x) + exp(-x)))&lt;/code&gt;.</source>
          <target state="translated">tanh 활성화시 동일한 모양과 입력 &lt;code&gt;x&lt;/code&gt; 의 dtype 텐서 : &lt;code&gt;tanh(x) = sinh(x)/cosh(x) = ((exp(x) - exp(-x))/(exp(x) + exp(-x)))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991a78eea129e011b2fea5bcfc4bbdfae5ae6d89" translate="yes" xml:space="preserve">
          <source>Tensor of shape [batch, max value in seq_length]</source>
          <target state="translated">Tensor of shape [batch, max value in seq_length]</target>
        </trans-unit>
        <trans-unit id="0ab2c569a3910220cc74fa58f8e584ae7ad42554" translate="yes" xml:space="preserve">
          <source>Tensor of shape [batch, max_seq_length] with repeated labels collapsed and padded to max_seq_length, eg: &lt;code&gt;[[A, A, B, B, A], [A, B, C, D, E]] =&amp;gt; [[A, B, A, 0, 0], [A, B, C, D, E]]&lt;/code&gt;</source>
          <target state="translated">Tensor of shape [batch, max_seq_length] with repeated labels collapsed and padded to max_seq_length, eg: &lt;code&gt;[[A, A, B, B, A], [A, B, C, D, E]] =&amp;gt; [[A, B, A, 0, 0], [A, B, C, D, E]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09b6de4a94ad48d9d7a5400cd4c0b4565ee41127" translate="yes" xml:space="preserve">
          <source>Tensor of shape [batch], sequence length of each batch element.</source>
          <target state="translated">Tensor of shape [batch], sequence length of each batch element.</target>
        </trans-unit>
        <trans-unit id="4711a72d6803380500da6cc386c6dc5e9e15af3f" translate="yes" xml:space="preserve">
          <source>Tensor of temporal data of shape &lt;code&gt;(samples, time, ...)&lt;/code&gt; (at least 3D), or nested tensors, and each of which has shape &lt;code&gt;(samples, time, ...)&lt;/code&gt;.</source>
          <target state="translated">Tensor of temporal data of shape &lt;code&gt;(samples, time, ...)&lt;/code&gt; (at least 3D), or nested tensors, and each of which has shape &lt;code&gt;(samples, time, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="983824590fcdbd70ba29193fec6dfcd4f06040b1" translate="yes" xml:space="preserve">
          <source>Tensor of true targets.</source>
          <target state="translated">Tensor of true targets.</target>
        </trans-unit>
        <trans-unit id="4ece434f42d02c35bcd9f0f22d16c9ace70e63c1" translate="yes" xml:space="preserve">
          <source>Tensor of updates to apply to &lt;code&gt;ref&lt;/code&gt;.</source>
          <target state="translated">Tensor of updates to apply to &lt;code&gt;ref&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="609226623d6804277472c985802ca7f821557acf" translate="yes" xml:space="preserve">
          <source>Tensor or SparseTensor whose name, dtype and shape are used to build the TensorInfo. For SparseTensors, the names of the three constituent Tensors are used.</source>
          <target state="translated">Tensor or SparseTensor whose name, dtype and shape are used to build the TensorInfo. For SparseTensors, the names of the three constituent Tensors are used.</target>
        </trans-unit>
        <trans-unit id="8bdb1abfaca3ce302ff13a33877ebf1f3b320f8a" translate="yes" xml:space="preserve">
          <source>Tensor or list of tensors to consider constant with respect to any other variable.</source>
          <target state="translated">Tensor or list of tensors to consider constant with respect to any other variable.</target>
        </trans-unit>
        <trans-unit id="98d8b25344eaca65f119ba9ee81b8fffc77d72cc" translate="yes" xml:space="preserve">
          <source>Tensor or list of tensors.</source>
          <target state="translated">Tensor or list of tensors.</target>
        </trans-unit>
        <trans-unit id="0e2d5b0d328618d8eea7c94cdd41745f06de90ef" translate="yes" xml:space="preserve">
          <source>Tensor or variable to resize.</source>
          <target state="translated">Tensor or variable to resize.</target>
        </trans-unit>
        <trans-unit id="d552fc19b0fcf59ac1126f970eb95210e83e9df8" translate="yes" xml:space="preserve">
          <source>Tensor or variable.</source>
          <target state="translated">Tensor or variable.</target>
        </trans-unit>
        <trans-unit id="67448d108f3268b1d5cbe74737caa0c2837d5856" translate="yes" xml:space="preserve">
          <source>Tensor to be differentiated.</source>
          <target state="translated">Tensor to be differentiated.</target>
        </trans-unit>
        <trans-unit id="021c1126aa37ca96534d60a019fc5c258c8b005f" translate="yes" xml:space="preserve">
          <source>Tensor to check.</source>
          <target state="translated">Tensor to check.</target>
        </trans-unit>
        <trans-unit id="b6d15ec006a5175d233a822b263e83647bcf3a5b" translate="yes" xml:space="preserve">
          <source>Tensor to print.</source>
          <target state="translated">Tensor to print.</target>
        </trans-unit>
        <trans-unit id="5316e6de8e219f39a9950fe8aa6af256d69ae69b" translate="yes" xml:space="preserve">
          <source>Tensor to reverse.</source>
          <target state="translated">Tensor to reverse.</target>
        </trans-unit>
        <trans-unit id="09f3440d4c47db7469d3f1a64881a5b0f52622c8" translate="yes" xml:space="preserve">
          <source>Tensor type.</source>
          <target state="translated">Tensor type.</target>
        </trans-unit>
        <trans-unit id="f229fd06f270a1472ee5fc7d946ec114e17083e8" translate="yes" xml:space="preserve">
          <source>Tensor with dtype &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">dtype &lt;code&gt;dtype&lt;/code&gt; 을 가진 텐서 .</target>
        </trans-unit>
        <trans-unit id="3a5173388b5a1f32c8e6079ea1f65f9ee01338a1" translate="yes" xml:space="preserve">
          <source>Tensor with exponential activation: &lt;code&gt;exp(x)&lt;/code&gt;.</source>
          <target state="translated">Tensor with exponential activation: &lt;code&gt;exp(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b127d103d72c024e0c3a7e4c213e3125d5bed59" translate="yes" xml:space="preserve">
          <source>Tensor with exponential activation: &lt;code&gt;exp(x)&lt;/code&gt;. Tensor will be of same shape and dtype of input &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">지수 활성화 된 텐서 : &lt;code&gt;exp(x)&lt;/code&gt; . 텐서는 입력 &lt;code&gt;x&lt;/code&gt; 의 모양과 dtype이 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c04a1202ada48999add7a1b4944833aee2cdad3e" translate="yes" xml:space="preserve">
          <source>Tensor with one scalar loss entry per sample.</source>
          <target state="translated">샘플 당 하나의 스칼라 손실 항목이있는 텐서.</target>
        </trans-unit>
        <trans-unit id="a1bcf3e6714689670e8871ddc1423b42db7d58cf" translate="yes" xml:space="preserve">
          <source>Tensor with same type and shape as &lt;code&gt;initializer&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer&lt;/code&gt; 와 동일한 유형 및 모양의 텐서 .</target>
        </trans-unit>
        <trans-unit id="7eb3ed83767298c300168c3e7bea9ba8df3bf9a3" translate="yes" xml:space="preserve">
          <source>Tensor with shape (samples,1) containing the CTC loss of each element.</source>
          <target state="translated">각 요소의 CTC 손실을 포함하는 모양 (샘플, 1)의 텐서.</target>
        </trans-unit>
        <trans-unit id="d92f799e565170398cbb66590e4f41df4601a016" translate="yes" xml:space="preserve">
          <source>Tensor with shape &lt;code&gt;(samples, state_size)&lt;/code&gt; (no time dimension), containing the initial values for the states used in the step function. In the case that state_size is in a nested shape, the shape of initial_states will also follow the nested structure.</source>
          <target state="translated">Tensor with shape &lt;code&gt;(samples, state_size)&lt;/code&gt; (no time dimension), containing the initial values for the states used in the step function. In the case that state_size is in a nested shape, the shape of initial_states will also follow the nested structure.</target>
        </trans-unit>
        <trans-unit id="f08cd9217a6e1bd951c428dea94df7840878f58b" translate="yes" xml:space="preserve">
          <source>Tensor with shape [batch_size, h, w, d].</source>
          <target state="translated">Tensor with shape [batch_size, h, w, d].</target>
        </trans-unit>
        <trans-unit id="c6e0a539edac6a669824128887ac83f25a022bed" translate="yes" xml:space="preserve">
          <source>Tensor with the sigmoid activation: &lt;code&gt;(1.0 / (1.0 + exp(-x)))&lt;/code&gt;. Tensor will be of same shape and dtype of input &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">S 자형 활성화 텐서 : &lt;code&gt;(1.0 / (1.0 + exp(-x)))&lt;/code&gt; . 텐서는 입력 &lt;code&gt;x&lt;/code&gt; 의 모양과 dtype이 같습니다 .</target>
        </trans-unit>
        <trans-unit id="f77273548e1cf39fd9f7bfafc8ed98142db862b5" translate="yes" xml:space="preserve">
          <source>Tensor with the sigmoid activation: &lt;code&gt;1 / (1 + exp(-x))&lt;/code&gt;.</source>
          <target state="translated">Tensor with the sigmoid activation: &lt;code&gt;1 / (1 + exp(-x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc8bb92a9662cf2dd1d1e4ba1be3c7c09fd20d4e" translate="yes" xml:space="preserve">
          <source>Tensor with which to center the input.</source>
          <target state="translated">Tensor with which to center the input.</target>
        </trans-unit>
        <trans-unit id="86989d8c3ba1ef406d202928da376f95029f14db" translate="yes" xml:space="preserve">
          <source>Tensor, output of softmax transformation (all values are non-negative and sum to 1).</source>
          <target state="translated">텐서, softmax 변환의 출력 (모든 값은 음수가 아니고 1로 합산 됨).</target>
        </trans-unit>
        <trans-unit id="e89226b175152427d7c493c32cfe624d665fd212" translate="yes" xml:space="preserve">
          <source>Tensor. The concentration parameter of the gamma distribution. Must be broadcastable with &lt;code&gt;beta&lt;/code&gt;, and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Tensor. The concentration parameter of the gamma distribution. Must be broadcastable with &lt;code&gt;beta&lt;/code&gt; , and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf3a3996cfe39ab309b04a925c58f1a0c1fd2078" translate="yes" xml:space="preserve">
          <source>Tensor. The counts of the binomial distribution. Must be broadcastable with &lt;code&gt;probs&lt;/code&gt;, and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Tensor. The counts of the binomial distribution. Must be broadcastable with &lt;code&gt;probs&lt;/code&gt; , and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d9890b70264751a0b9b7af3b211cc518a429f2e" translate="yes" xml:space="preserve">
          <source>Tensor. The inverse scale parameter of the gamma distribution. Must be broadcastable with &lt;code&gt;alpha&lt;/code&gt; and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Tensor. The inverse scale parameter of the gamma distribution. Must be broadcastable with &lt;code&gt;alpha&lt;/code&gt; and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49f8b43c304674d66e5a1e831386d270bfa0b3f1" translate="yes" xml:space="preserve">
          <source>Tensor. The probability of success for the binomial distribution. Must be broadcastable with &lt;code&gt;counts&lt;/code&gt; and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Tensor. The probability of success for the binomial distribution. Must be broadcastable with &lt;code&gt;counts&lt;/code&gt; and broadcastable with the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25ae453d24d0a062206d224fce0e81c1a28a35c6" translate="yes" xml:space="preserve">
          <source>Tensor. The rate parameter &quot;lambda&quot; of the Poisson distribution. Shape must match the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">Tensor. The rate parameter &quot;lambda&quot; of the Poisson distribution. Shape must match the rightmost dimensions of &lt;code&gt;shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8cfa50554daa966a4bf3a8b045b195bf8bcb8b8" translate="yes" xml:space="preserve">
          <source>TensorArray</source>
          <target state="translated">TensorArray</target>
        </trans-unit>
        <trans-unit id="9cd06a33d5cee5fdef49b04732933adce7406e6f" translate="yes" xml:space="preserve">
          <source>TensorArray gradient calls use an accumulator TensorArray object. If multiple gradients are calculated and run in the same session, the multiple gradient nodes may accidentally flow through the same accumulator TensorArray. This double counts and generally breaks the TensorArray gradient flow.</source>
          <target state="translated">TensorArray gradient calls use an accumulator TensorArray object. If multiple gradients are calculated and run in the same session, the multiple gradient nodes may accidentally flow through the same accumulator TensorArray. This double counts and generally breaks the TensorArray gradient flow.</target>
        </trans-unit>
        <trans-unit id="e48afa0d245404da5744de2c8636a3f5d39cfbe8" translate="yes" xml:space="preserve">
          <source>TensorArrayClose</source>
          <target state="translated">TensorArrayClose</target>
        </trans-unit>
        <trans-unit id="5b15d2b760f150def025acec46e2c27cfee1a194" translate="yes" xml:space="preserve">
          <source>TensorArrayCloseV2</source>
          <target state="translated">TensorArrayCloseV2</target>
        </trans-unit>
        <trans-unit id="387b419ce30390584889b7475ce8b3ec47529f97" translate="yes" xml:space="preserve">
          <source>TensorArrayCloseV3</source>
          <target state="translated">TensorArrayCloseV3</target>
        </trans-unit>
        <trans-unit id="5cce057beabc2f9e2d52bcda9a2dd1007f597b54" translate="yes" xml:space="preserve">
          <source>TensorArrayConcat</source>
          <target state="translated">TensorArrayConcat</target>
        </trans-unit>
        <trans-unit id="893a2396c6886b0e2e7fadb065fc85958c5d2fe4" translate="yes" xml:space="preserve">
          <source>TensorArrayConcatV2</source>
          <target state="translated">TensorArrayConcatV2</target>
        </trans-unit>
        <trans-unit id="5f0e37d984cb996c87c1353e9d3cac4f56059b81" translate="yes" xml:space="preserve">
          <source>TensorArrayConcatV3</source>
          <target state="translated">TensorArrayConcatV3</target>
        </trans-unit>
        <trans-unit id="cde7b38270db7c0b9c0de6e1377158f2b6c50c32" translate="yes" xml:space="preserve">
          <source>TensorArrayGather</source>
          <target state="translated">TensorArrayGather</target>
        </trans-unit>
        <trans-unit id="409fc6439c35830bdd7ea17d0dfd1caae4f1c2c4" translate="yes" xml:space="preserve">
          <source>TensorArrayGatherV2</source>
          <target state="translated">TensorArrayGatherV2</target>
        </trans-unit>
        <trans-unit id="241f549311eb30a2a857f1aea1975640214d8a4c" translate="yes" xml:space="preserve">
          <source>TensorArrayGatherV3</source>
          <target state="translated">TensorArrayGatherV3</target>
        </trans-unit>
        <trans-unit id="761aefb90e9078ba089d2df6236ad882da9a2007" translate="yes" xml:space="preserve">
          <source>TensorArrayGrad</source>
          <target state="translated">TensorArrayGrad</target>
        </trans-unit>
        <trans-unit id="5ebf400b5e1373140bb24f6c6a99ef1ef9a1a8da" translate="yes" xml:space="preserve">
          <source>TensorArrayGradV2</source>
          <target state="translated">TensorArrayGradV2</target>
        </trans-unit>
        <trans-unit id="9be136465c053c3355da5dbd580d5f0883b5b2fd" translate="yes" xml:space="preserve">
          <source>TensorArrayGradV3</source>
          <target state="translated">TensorArrayGradV3</target>
        </trans-unit>
        <trans-unit id="9535f959112da37dbc6ef9e2abbdbb12a36ed126" translate="yes" xml:space="preserve">
          <source>TensorArrayGradWithShape</source>
          <target state="translated">TensorArrayGradWithShape</target>
        </trans-unit>
        <trans-unit id="6276b88ec6e0ea2cd2cfae403278a4c8fdf2b484" translate="yes" xml:space="preserve">
          <source>TensorArrayPack</source>
          <target state="translated">TensorArrayPack</target>
        </trans-unit>
        <trans-unit id="7f889e1897d306a796c336146bd972099f47ac16" translate="yes" xml:space="preserve">
          <source>TensorArrayRead</source>
          <target state="translated">TensorArrayRead</target>
        </trans-unit>
        <trans-unit id="62a8c9a8b4ca92a765a78074917c520e04e45da3" translate="yes" xml:space="preserve">
          <source>TensorArrayReadV2</source>
          <target state="translated">TensorArrayReadV2</target>
        </trans-unit>
        <trans-unit id="58de94649511599b80f46597798043eb3def567b" translate="yes" xml:space="preserve">
          <source>TensorArrayReadV3</source>
          <target state="translated">TensorArrayReadV3</target>
        </trans-unit>
        <trans-unit id="a853dee84c85c35795c3288b8fb9db2742f9d103" translate="yes" xml:space="preserve">
          <source>TensorArrayScatter</source>
          <target state="translated">TensorArrayScatter</target>
        </trans-unit>
        <trans-unit id="d37714a7f87ed455f276af6ee5c15df7773dcd38" translate="yes" xml:space="preserve">
          <source>TensorArrayScatterV2</source>
          <target state="translated">TensorArrayScatterV2</target>
        </trans-unit>
        <trans-unit id="b8401ae9a5bbe12db1bf0c06678280217e910372" translate="yes" xml:space="preserve">
          <source>TensorArrayScatterV3</source>
          <target state="translated">TensorArrayScatterV3</target>
        </trans-unit>
        <trans-unit id="25d813ebee7cd1073b3ae4cce1ff827658177cf1" translate="yes" xml:space="preserve">
          <source>TensorArraySize</source>
          <target state="translated">TensorArraySize</target>
        </trans-unit>
        <trans-unit id="21ab1149c6f7999ab8d64cc70350e337345fb786" translate="yes" xml:space="preserve">
          <source>TensorArraySizeV2</source>
          <target state="translated">TensorArraySizeV2</target>
        </trans-unit>
        <trans-unit id="24bcb6045cff760350060e92715cbd68488630cd" translate="yes" xml:space="preserve">
          <source>TensorArraySizeV3</source>
          <target state="translated">TensorArraySizeV3</target>
        </trans-unit>
        <trans-unit id="fbb5cce9e596e13305fdac67b26638bce1c4584a" translate="yes" xml:space="preserve">
          <source>TensorArraySplit</source>
          <target state="translated">TensorArraySplit</target>
        </trans-unit>
        <trans-unit id="dedb8370dfccba2844f92b3309582a012bb44347" translate="yes" xml:space="preserve">
          <source>TensorArraySplitV2</source>
          <target state="translated">TensorArraySplitV2</target>
        </trans-unit>
        <trans-unit id="5566e35be3ac1bad44a407c93409aff4050d635e" translate="yes" xml:space="preserve">
          <source>TensorArraySplitV3</source>
          <target state="translated">TensorArraySplitV3</target>
        </trans-unit>
        <trans-unit id="91f8fb74b6b10a5e4435fc1923081d04f76c7588" translate="yes" xml:space="preserve">
          <source>TensorArrayUnpack</source>
          <target state="translated">TensorArrayUnpack</target>
        </trans-unit>
        <trans-unit id="e0d8218dabbafbfa773400efade8fbff5f87b19e" translate="yes" xml:space="preserve">
          <source>TensorArrayV2</source>
          <target state="translated">TensorArrayV2</target>
        </trans-unit>
        <trans-unit id="a848f6657a20bf233e1497813eeb214d189175ef" translate="yes" xml:space="preserve">
          <source>TensorArrayV3</source>
          <target state="translated">TensorArrayV3</target>
        </trans-unit>
        <trans-unit id="059449a07f82b191b2b757ec228ea9591e698946" translate="yes" xml:space="preserve">
          <source>TensorArrayWrite</source>
          <target state="translated">TensorArrayWrite</target>
        </trans-unit>
        <trans-unit id="1616be38e66741c7ca653bf71c3c9d2753419306" translate="yes" xml:space="preserve">
          <source>TensorArrayWriteV2</source>
          <target state="translated">TensorArrayWriteV2</target>
        </trans-unit>
        <trans-unit id="6832628b3c921361a1ed6f81adf432bb9f0a06ad" translate="yes" xml:space="preserve">
          <source>TensorArrayWriteV3</source>
          <target state="translated">TensorArrayWriteV3</target>
        </trans-unit>
        <trans-unit id="0c870eac18cde0821e85a6e2e0cd690795d9b0f8" translate="yes" xml:space="preserve">
          <source>TensorBoard is a visualization tool provided with TensorFlow.</source>
          <target state="translated">TensorBoard는 TensorFlow와 함께 제공되는 시각화 도구입니다.</target>
        </trans-unit>
        <trans-unit id="d6c5b7495606642427d84d9560c2c6fa48e983ac" translate="yes" xml:space="preserve">
          <source>TensorBoard will pick the graph from the file and display it graphically so you can interactively explore the graph you built. You will usually pass the graph from the session in which you launched it:</source>
          <target state="translated">TensorBoard는 파일에서 그래프를 선택하여 그래픽으로 표시하므로 사용자가 작성한 그래프를 대화식으로 탐색 할 수 있습니다. 일반적으로 그래프를 시작한 세션에서 그래프를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f8342214fe44b1c0c83175be83a91f5e2a145745" translate="yes" xml:space="preserve">
          <source>TensorDataset</source>
          <target state="translated">TensorDataset</target>
        </trans-unit>
        <trans-unit id="91920dffa2de075aa71252ce246c4919ca2918b7" translate="yes" xml:space="preserve">
          <source>TensorFlow</source>
          <target state="translated">TensorFlow</target>
        </trans-unit>
        <trans-unit id="0aa8b8730f9d4ee0f6fd230f9d2510cbf8c53747" translate="yes" xml:space="preserve">
          <source>TensorFlow 1 version</source>
          <target state="translated">텐서 플로우 1 버전</target>
        </trans-unit>
        <trans-unit id="4e54099f7adc352258d80aa2a07931abd0dfaf7a" translate="yes" xml:space="preserve">
          <source>TensorFlow 1.x and 2.x</source>
          <target state="translated">텐서 플로우 1.x 및 2.x</target>
        </trans-unit>
        <trans-unit id="895342c8e5449651b084f46f85af49138e2e8798" translate="yes" xml:space="preserve">
          <source>TensorFlow 2 quickstart for experts</source>
          <target state="translated">전문가를위한 TensorFlow 2 빠른 시작</target>
        </trans-unit>
        <trans-unit id="4d7a6f2a780bcce78ffe938ccead5b3061683157" translate="yes" xml:space="preserve">
          <source>TensorFlow Compiler Bridge (TF Bridge) is responsible for translating parts of TensorFlow graph into a form that can be accepted as an input by a backend compiler such as XLA.</source>
          <target state="translated">TensorFlow Compiler Bridge (TF Bridge)는 TensorFlow 그래프의 일부를 XLA와 같은 백엔드 컴파일러가 입력으로 받아 들일 수있는 형식으로 변환하는 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="df64a2e128865b8108ebd54f1004aef489171bf7" translate="yes" xml:space="preserve">
          <source>TensorFlow Compiler Optimizations are responsible general graph level optimizations that in the current stack mostly done by Grappler graph optimizers.</source>
          <target state="translated">TensorFlow Compiler Optimizations are responsible general graph level optimizations that in the current stack mostly done by Grappler graph optimizers.</target>
        </trans-unit>
        <trans-unit id="7c9fbc6a836283d6b77fb69cb71170fb5aa3025a" translate="yes" xml:space="preserve">
          <source>TensorFlow Function construction (e.g., compilation of Python functions decorated with @tf.function), the op types, names (if available), context, the input and output tensors, and the associated stack traces.</source>
          <target state="translated">TensorFlow Function construction (e.g., compilation of Python functions decorated with @tf.function), the op types, names (if available), context, the input and output tensors, and the associated stack traces.</target>
        </trans-unit>
        <trans-unit id="40fd32522d9e2bac50b01c2a54d090f0edc43fdf" translate="yes" xml:space="preserve">
          <source>TensorFlow Session.</source>
          <target state="translated">TensorFlow Session.</target>
        </trans-unit>
        <trans-unit id="817a54d8521aedb8183452480ae1c26498fbd2da" translate="yes" xml:space="preserve">
          <source>TensorFlow can convert between images in RGB or HSV or YIQ.</source>
          <target state="translated">TensorFlow can convert between images in RGB or HSV or YIQ.</target>
        </trans-unit>
        <trans-unit id="5218d7001def4141ae436cbd9f4e4ab5c90eec24" translate="yes" xml:space="preserve">
          <source>TensorFlow can execute operations synchronously or asynchronously. If asynchronous execution is enabled, operations may return &quot;non-ready&quot; handles.</source>
          <target state="translated">TensorFlow는 작업을 동기식 또는 비동기식으로 실행할 수 있습니다. 비동기 실행이 활성화되면 작업이 &quot;준비되지 않은&quot;핸들을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b177522823bac7fab49a3e953658eb26bd8be99" translate="yes" xml:space="preserve">
          <source>TensorFlow can utilize various devices such as the CPU or multiple GPUs for computation. Before initializing a local device for use, the user can customize certain properties of the device such as it's visibility or memory configuration.</source>
          <target state="translated">TensorFlow는 CPU 또는 여러 GPU와 같은 다양한 장치를 사용하여 계산할 수 있습니다. 사용하기 위해 로컬 장치를 초기화하기 전에 사용자는 가시성 또는 메모리 구성과 같은 장치의 특정 속성을 사용자 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed9b6265dc382d52218eef149b9d9551ba4b9fc9" translate="yes" xml:space="preserve">
          <source>TensorFlow defaults to eager execution. In the example below, the matrix multiplication results are calculated immediately.</source>
          <target state="translated">TensorFlow defaults to eager execution. In the example below, the matrix multiplication results are calculated immediately.</target>
        </trans-unit>
        <trans-unit id="aeb6cbc7489405eda828caa72395bff0364182ee" translate="yes" xml:space="preserve">
          <source>TensorFlow does not support strides, &lt;a href=&quot;matrix_transpose&quot;&gt;&lt;code&gt;linalg.matrix_transpose&lt;/code&gt;&lt;/a&gt; returns a new tensor with the items permuted.</source>
          <target state="translated">TensorFlow는 보폭을 지원하지 않습니다. &lt;a href=&quot;matrix_transpose&quot;&gt; &lt;code&gt;linalg.matrix_transpose&lt;/code&gt; &lt;/a&gt; 는 항목이 치환 된 새 텐서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ab173e45e5b70ecdfa453b1565a9d48b4aea76c" translate="yes" xml:space="preserve">
          <source>TensorFlow does not support strides, so &lt;code&gt;transpose&lt;/code&gt; returns a new tensor with the items permuted.</source>
          <target state="translated">TensorFlow는 보폭을 지원하지 않으므로 &lt;code&gt;transpose&lt;/code&gt; 은 항목이 치환 된 새 텐서를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7258b473d648b978f0063efc0c3f0fba649a7ae7" translate="yes" xml:space="preserve">
          <source>TensorFlow example</source>
          <target state="translated">텐서 플로우 예제</target>
        </trans-unit>
        <trans-unit id="80a5a18b376b7e19393c2007205799ec5fa64c3e" translate="yes" xml:space="preserve">
          <source>TensorFlow graph optimization with Grappler</source>
          <target state="translated">Grappler를 사용한 TensorFlow 그래프 최적화</target>
        </trans-unit>
        <trans-unit id="faa0af6a22961093bbe0a8dd50a78c706f27b26f" translate="yes" xml:space="preserve">
          <source>TensorFlow has been supporting a 3 week forward-compatibility window for programs compiled from source at HEAD.</source>
          <target state="translated">TensorFlow는 HEAD의 소스에서 컴파일 된 프로그램에 대해 3 주 순방향 호환성 창을 지원하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d777d2e0001d30ab9c8068008f110317d36562d1" translate="yes" xml:space="preserve">
          <source>TensorFlow image datasets typically yield images that have each a different size. However, these images need to be batched before they can be processed by Keras layers. To be batched, images need to share the same height and width.</source>
          <target state="translated">TensorFlow image datasets typically yield images that have each a different size. However, these images need to be batched before they can be processed by Keras layers. To be batched, images need to share the same height and width.</target>
        </trans-unit>
        <trans-unit id="72769cecd87d42b437dab4e9d4a607af2d9ab1dc" translate="yes" xml:space="preserve">
          <source>TensorFlow lacks support for unsigned integers. The ops represent uint64 types as a &lt;code&gt;DT_INT64&lt;/code&gt; with the same twos-complement bit pattern (the obvious way). Unsigned int32 values can be represented exactly by specifying type &lt;code&gt;DT_INT64&lt;/code&gt;, or using twos-complement if the caller specifies &lt;code&gt;DT_INT32&lt;/code&gt; in the &lt;code&gt;output_types&lt;/code&gt; attribute.</source>
          <target state="translated">TensorFlow에는 부호없는 정수에 대한 지원이 없습니다. ops는 uint64 유형을 동일한 2 보완 비트 패턴 (명확한 방법) 으로 &lt;code&gt;DT_INT64&lt;/code&gt; 로 나타냅니다 . 부호없는 int32 값은 &lt;code&gt;DT_INT64&lt;/code&gt; 유형을 지정 하거나 호출자 가 &lt;code&gt;output_types&lt;/code&gt; 속성에 &lt;code&gt;DT_INT32&lt;/code&gt; 를 지정하는 경우 two -complement를 사용하여 정확하게 표현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="173be625ee6b740f87a6f6b6b09514fbf3c93296" translate="yes" xml:space="preserve">
          <source>TensorFlow multi-step profiler.</source>
          <target state="translated">TensorFlow 다단계 프로파일 러.</target>
        </trans-unit>
        <trans-unit id="810fc361befc14d32fdf0508d15d40661b9df85e" translate="yes" xml:space="preserve">
          <source>TensorFlow provides Ops to decode and encode JPEG and PNG formats. Encoded images are represented by scalar string Tensors, decoded images by 3-D uint8 tensors of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;. (PNG also supports uint16.)</source>
          <target state="translated">TensorFlow provides Ops to decode and encode JPEG and PNG formats. Encoded images are represented by scalar string Tensors, decoded images by 3-D uint8 tensors of shape &lt;code&gt;[height, width, channels]&lt;/code&gt; . (PNG also supports uint16.)</target>
        </trans-unit>
        <trans-unit id="8d014f833e885f8b8ed6b7a6c3ea673ead6d65d8" translate="yes" xml:space="preserve">
          <source>TensorFlow provides a variety of math functions including:</source>
          <target state="translated">TensorFlow는 다음을 포함한 다양한 수학 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="05d759537de08462c7cc6537b87ea9fe004eb7fb" translate="yes" xml:space="preserve">
          <source>TensorFlow provides functions to adjust images in various ways: brightness, contrast, hue, and saturation. Each adjustment can be done with predefined parameters or with random parameters picked from predefined intervals. Random adjustments are often useful to expand a training set and reduce overfitting.</source>
          <target state="translated">TensorFlow provides functions to adjust images in various ways: brightness, contrast, hue, and saturation. Each adjustment can be done with predefined parameters or with random parameters picked from predefined intervals. Random adjustments are often useful to expand a training set and reduce overfitting.</target>
        </trans-unit>
        <trans-unit id="305519ec0cbf6a7bdfd33f052e7a4a788bce222c" translate="yes" xml:space="preserve">
          <source>TensorFlow provides several operations that you can use to perform common math computations on tensor segments. Here a segmentation is a partitioning of a tensor along the first dimension, i.e. it defines a mapping from the first dimension onto &lt;code&gt;segment_ids&lt;/code&gt;. The &lt;code&gt;segment_ids&lt;/code&gt; tensor should be the size of the first dimension, &lt;code&gt;d0&lt;/code&gt;, with consecutive IDs in the range &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;k&lt;/code&gt;, where &lt;code&gt;k&amp;lt;d0&lt;/code&gt;. In particular, a segmentation of a matrix tensor is a mapping of rows to segments.</source>
          <target state="translated">TensorFlow는 텐서 세그먼트에서 일반적인 수학 계산을 수행하는 데 사용할 수있는 몇 가지 작업을 제공합니다. 여기서 세분화는 첫 번째 차원을 따라 텐서의 분할입니다. 즉, 첫 번째 차원에서 &lt;code&gt;segment_ids&lt;/code&gt; 로의 맵핑을 정의합니다 . &lt;code&gt;segment_ids&lt;/code&gt; 제 치수의 크기이어야 텐서 &lt;code&gt;d0&lt;/code&gt; 범위의 연속 ID가, &lt;code&gt;0&lt;/code&gt; 하는 &lt;code&gt;k&lt;/code&gt; 여기서, &lt;code&gt;k&amp;lt;d0&lt;/code&gt; . 특히, 매트릭스 텐서의 세그먼트는 행을 세그먼트에 매핑하는 것이다.</target>
        </trans-unit>
        <trans-unit id="476649b1950b2c7e7e27717793935f815d493aa9" translate="yes" xml:space="preserve">
          <source>TensorFlow represents a sparse tensor as three separate dense tensors: &lt;code&gt;indices&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;dense_shape&lt;/code&gt;. In Python, the three tensors are collected into a &lt;code&gt;SparseTensor&lt;/code&gt; class for ease of use. If you have separate &lt;code&gt;indices&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;dense_shape&lt;/code&gt; tensors, wrap them in a &lt;code&gt;SparseTensor&lt;/code&gt; object before passing to the ops below.</source>
          <target state="translated">TensorFlow는 희소 텐서를 3 개의 개별 밀도 텐서 ( &lt;code&gt;indices&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 및 &lt;code&gt;dense_shape&lt;/code&gt; )로 나타냅니다 . 파이썬에서는 세 개의 텐서가 &lt;code&gt;SparseTensor&lt;/code&gt; 클래스에 수집되어 사용하기가 쉽습니다. 별도의 &lt;code&gt;indices&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 및 &lt;code&gt;dense_shape&lt;/code&gt; 텐서 가있는 경우 아래 ops에 전달하기 전에 &lt;code&gt;SparseTensor&lt;/code&gt; 오브젝트로 랩핑 하십시오.</target>
        </trans-unit>
        <trans-unit id="93ac22f1d8d8c79ba60c08da8c0008ff464ff4c0" translate="yes" xml:space="preserve">
          <source>TensorFlow supports eager execution and graph execution. In eager execution, operations are evaluated immediately. In graph execution, a computational graph is constructed for later evaluation.</source>
          <target state="translated">TensorFlow supports eager execution and graph execution. In eager execution, operations are evaluated immediately. In graph execution, a computational graph is constructed for later evaluation.</target>
        </trans-unit>
        <trans-unit id="4593f4895cde5cdd282a36ff87b191ba4a5be07b" translate="yes" xml:space="preserve">
          <source>TensorFlow task number.</source>
          <target state="translated">TensorFlow task number.</target>
        </trans-unit>
        <trans-unit id="cfe97f05011118b2f246778fd7ffc0ecc02ee0e1" translate="yes" xml:space="preserve">
          <source>TensorFlow v1.x</source>
          <target state="translated">TensorFlow v1.x</target>
        </trans-unit>
        <trans-unit id="4b29d24e09666b1f0ef1ab103840afdc0c926e9e" translate="yes" xml:space="preserve">
          <source>TensorFlow v2.x</source>
          <target state="translated">TensorFlow v2.x</target>
        </trans-unit>
        <trans-unit id="a37abf1551d5441ca76c6027db3d86fa63aa8e14" translate="yes" xml:space="preserve">
          <source>TensorListConcat</source>
          <target state="translated">TensorListConcat</target>
        </trans-unit>
        <trans-unit id="9d41439e87d18ad7171c9e3b746f68d812e8b749" translate="yes" xml:space="preserve">
          <source>TensorListConcatLists</source>
          <target state="translated">TensorListConcatLists</target>
        </trans-unit>
        <trans-unit id="90952ebbd845c00e33141b5dcaccba672fd8b16a" translate="yes" xml:space="preserve">
          <source>TensorListConcatV2</source>
          <target state="translated">TensorListConcatV2</target>
        </trans-unit>
        <trans-unit id="0150384f1b5e4edf5af3ad08c5cab8dd526ee269" translate="yes" xml:space="preserve">
          <source>TensorListElementShape</source>
          <target state="translated">TensorListElementShape</target>
        </trans-unit>
        <trans-unit id="cdd9f9a8bc65ad4ad29c78f8b1ac8b66375955c6" translate="yes" xml:space="preserve">
          <source>TensorListFromTensor</source>
          <target state="translated">TensorListFromTensor</target>
        </trans-unit>
        <trans-unit id="dccda28c8a3040666a26d581e6bff9f168ece9ed" translate="yes" xml:space="preserve">
          <source>TensorListGather</source>
          <target state="translated">TensorListGather</target>
        </trans-unit>
        <trans-unit id="14f3dc52acfcfff3731892c7d01ee64a418c4169" translate="yes" xml:space="preserve">
          <source>TensorListGetItem</source>
          <target state="translated">TensorListGetItem</target>
        </trans-unit>
        <trans-unit id="c633de63f737370e705311a9f3a8938e139b24c1" translate="yes" xml:space="preserve">
          <source>TensorListLength</source>
          <target state="translated">TensorListLength</target>
        </trans-unit>
        <trans-unit id="a2250cb1b710a1f3cf34e62c8442f009ae44283c" translate="yes" xml:space="preserve">
          <source>TensorListPopBack</source>
          <target state="translated">TensorListPopBack</target>
        </trans-unit>
        <trans-unit id="21dc1f858f8f8546ff6c946d65457ad1e70ac1af" translate="yes" xml:space="preserve">
          <source>TensorListPushBack</source>
          <target state="translated">TensorListPushBack</target>
        </trans-unit>
        <trans-unit id="c57aa7340950223e030e0b97560d8e844fcfa560" translate="yes" xml:space="preserve">
          <source>TensorListPushBackBatch</source>
          <target state="translated">TensorListPushBackBatch</target>
        </trans-unit>
        <trans-unit id="8d7a7c2a17556888a90e53b5d47d964c38f77da3" translate="yes" xml:space="preserve">
          <source>TensorListReserve</source>
          <target state="translated">TensorListReserve</target>
        </trans-unit>
        <trans-unit id="a0809d58d382f9660ac66090df2e7dc4c1af058e" translate="yes" xml:space="preserve">
          <source>TensorListResize</source>
          <target state="translated">TensorListResize</target>
        </trans-unit>
        <trans-unit id="9f7d48a1a8360230f6ee08bc4743f237e2a90127" translate="yes" xml:space="preserve">
          <source>TensorListScatter</source>
          <target state="translated">TensorListScatter</target>
        </trans-unit>
        <trans-unit id="5ef4e2392d5ace62fce6b70b140e7df79b18e2a5" translate="yes" xml:space="preserve">
          <source>TensorListScatterIntoExistingList</source>
          <target state="translated">TensorListScatterIntoExistingList</target>
        </trans-unit>
        <trans-unit id="ab1d1ae5b9041f12b6e7a508fcdf4083605dfcaa" translate="yes" xml:space="preserve">
          <source>TensorListScatterV2</source>
          <target state="translated">TensorListScatterV2</target>
        </trans-unit>
        <trans-unit id="e993c73c18f7b6952b82875362c2611a4be232ed" translate="yes" xml:space="preserve">
          <source>TensorListSetItem</source>
          <target state="translated">TensorListSetItem</target>
        </trans-unit>
        <trans-unit id="9c9c126fb3acac8b777f1e794c016d908aa9bf5d" translate="yes" xml:space="preserve">
          <source>TensorListSplit</source>
          <target state="translated">TensorListSplit</target>
        </trans-unit>
        <trans-unit id="0b9ee82f2975305d6b770c3c1857adf3aceb000d" translate="yes" xml:space="preserve">
          <source>TensorListStack</source>
          <target state="translated">TensorListStack</target>
        </trans-unit>
        <trans-unit id="fed44bee83c9b1a76c423eb2e2a741853427be80" translate="yes" xml:space="preserve">
          <source>TensorScatterAdd</source>
          <target state="translated">TensorScatterAdd</target>
        </trans-unit>
        <trans-unit id="2dfa8a2396bbd4ebc6bc447db7053f28e1905f3c" translate="yes" xml:space="preserve">
          <source>TensorScatterMax</source>
          <target state="translated">TensorScatterMax</target>
        </trans-unit>
        <trans-unit id="14be854fb30ff59fae71fbe9893d82ab1705bd06" translate="yes" xml:space="preserve">
          <source>TensorScatterMin</source>
          <target state="translated">TensorScatterMin</target>
        </trans-unit>
        <trans-unit id="4c72eeca84d96511d52c490157b087a2d312fb7d" translate="yes" xml:space="preserve">
          <source>TensorScatterSub</source>
          <target state="translated">TensorScatterSub</target>
        </trans-unit>
        <trans-unit id="9e8144c6742af4ddb9ddd9cc6b36fe8c13273100" translate="yes" xml:space="preserve">
          <source>TensorScatterUpdate</source>
          <target state="translated">TensorScatterUpdate</target>
        </trans-unit>
        <trans-unit id="a47222eb58bbdfce0fc55dcabde531b7c9adb406" translate="yes" xml:space="preserve">
          <source>TensorShape(None) is compatible with all shapes.</source>
          <target state="translated">TensorShape (None)은 모든 모양과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="bac8d5b9c3640fab327ab07d92ee55320fd3913d" translate="yes" xml:space="preserve">
          <source>TensorShape([1, 2, 3]) is the most specific TensorShape compatible with both TensorShape([1, 2, 3]) and TensorShape([1, 2, 3]). There are more less specific TensorShapes compatible with above mentioned TensorShapes, e.g. TensorShape([1, 2, None]), TensorShape(None).</source>
          <target state="translated">TensorShape ([1, 2, 3])은 TensorShape ([1, 2, 3]) 및 TensorShape ([1, 2, 3])와 호환되는 가장 구체적인 TensorShape입니다. 위에서 언급 한 TensorShapes와 호환되는보다 덜 구체적인 TensorShapes가 있습니다 (예 : TensorShape ([1, 2, None]), TensorShape (None)).</target>
        </trans-unit>
        <trans-unit id="0224569211f435d2df63b768abb6efc726a69d01" translate="yes" xml:space="preserve">
          <source>TensorShape([32, 784]) is compatible with itself, and also TensorShape([32, None]), TensorShape([None, 784]), TensorShape([None, None]) and TensorShape(None). It is not compatible with, for example, TensorShape([32, 1, 784]) or TensorShape([None]).</source>
          <target state="translated">TensorShape ([32, 784])는 자체와 호환되며 TensorShape ([32, None]), TensorShape ([None, 784]), TensorShape ([None, None]) 및 TensorShape (None) 과도 호환됩니다. 예를 들어 TensorShape ([32, 1, 784]) 또는 TensorShape ([None])과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d64401ff7bd3446564470a92463f73e24f52237" translate="yes" xml:space="preserve">
          <source>TensorShape([32, None]) is compatible with all two-dimensional shapes with size 32 in the 0th dimension, and also TensorShape([None, None]) and TensorShape(None). It is not compatible with, for example, TensorShape([32]), TensorShape([32, None, 1]) or TensorShape([64, None]).</source>
          <target state="translated">TensorShape ([32, None])은 0 차원에서 크기가 32 인 모든 2 차원 모양과 TensorShape ([None, None]) 및 TensorShape (None)과 호환됩니다. 예를 들어 TensorShape ([32]), TensorShape ([32, None, 1]) 또는 TensorShape ([64, None])과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="59fc38face567505b51ef9cc1d627c3ec48e0458" translate="yes" xml:space="preserve">
          <source>TensorShape([None, 1]) is the most specific TensorShape compatible with both TensorShape([2, 1]) and TensorShape([5, 1]). Note that TensorShape(None) is also compatible with above mentioned TensorShapes.</source>
          <target state="translated">TensorShape ([없음, 1])은 TensorShape ([2, 1]) 및 TensorShape ([5, 1]) 모두와 호환되는 가장 구체적인 TensorShape입니다. TensorShape (None)은 위에서 언급 한 TensorShapes 와도 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="0f0011d7d16cb288f3076f4ccc9f15a9b93ab18d" translate="yes" xml:space="preserve">
          <source>TensorShape([None, None]) is compatible with all two-dimensional shapes, such as TensorShape([32, 784]), and also TensorShape(None). It is not compatible with, for example, TensorShape([None]) or TensorShape([None, None, None]).</source>
          <target state="translated">TensorShape ([None, None])은 TensorShape ([32, 784]) 및 TensorShape (None)과 같은 모든 2 차원 모양과 호환됩니다. 예를 들어 TensorShape ([None]) 또는 TensorShape ([None, None, None])과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="37305f95359127b9612e69d7d869649d989247fe" translate="yes" xml:space="preserve">
          <source>TensorSliceDataset</source>
          <target state="translated">TensorSliceDataset</target>
        </trans-unit>
        <trans-unit id="f8c7b9a4c989b1d10f82cf3a5da138bae1cecfa2" translate="yes" xml:space="preserve">
          <source>TensorStridedSliceUpdate</source>
          <target state="translated">TensorStridedSliceUpdate</target>
        </trans-unit>
        <trans-unit id="cb9605b0e23dcfcc6641ff9040f90cf6eae32f09" translate="yes" xml:space="preserve">
          <source>TensorSummary</source>
          <target state="translated">TensorSummary</target>
        </trans-unit>
        <trans-unit id="f1b1e925cc812364ca2646b501ac9b1813d7be72" translate="yes" xml:space="preserve">
          <source>TensorSummaryV2</source>
          <target state="translated">TensorSummaryV2</target>
        </trans-unit>
        <trans-unit id="eb7208ca53baf0c906efb86ab8419484372d57aa" translate="yes" xml:space="preserve">
          <source>Tensordot (also known as tensor contraction) sums the product of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; over the indices specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The lists &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt; specify those pairs of axes along which to contract the tensors. The axis &lt;code&gt;a_axes[i]&lt;/code&gt; of &lt;code&gt;a&lt;/code&gt; must have the same dimension as axis &lt;code&gt;b_axes[i]&lt;/code&gt; of &lt;code&gt;b&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;range(0, len(a_axes))&lt;/code&gt;. The lists &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt; must have identical length and consist of unique integers that specify valid axes for each of the tensors. Additionally outer product is supported by passing &lt;code&gt;axes=0&lt;/code&gt;.</source>
          <target state="translated">텐서 도트 (텐서 수축이라고도 함)는 &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; 로 지정된 인덱스에 대해 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소 곱을 합산합니다 . 리스트 &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; 는 텐서를 수축시키는 축 쌍을 지정합니다. 축 &lt;code&gt;a_axes[i]&lt;/code&gt; 의 &lt;code&gt;a&lt;/code&gt; 축과 동일한 치수 있어야 &lt;code&gt;b_axes[i]&lt;/code&gt; 의 &lt;code&gt;b&lt;/code&gt; 모두 &lt;code&gt;i&lt;/code&gt; 의 &lt;code&gt;range(0, len(a_axes))&lt;/code&gt; . &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; 목록길이는 동일해야하며 각 텐서에 유효한 축을 지정하는 고유 한 정수로 구성되어야합니다. 또한 &lt;code&gt;axes=0&lt;/code&gt; 을 전달하여 외부 제품을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="3da1e8a48fb9ee2ea5423ca2bee26f977fbfb800" translate="yes" xml:space="preserve">
          <source>Tensorflow 1.x and 2.x APIs</source>
          <target state="translated">텐서 플로우 1.x 및 2.x API</target>
        </trans-unit>
        <trans-unit id="a7bfa5dc3be3af3be0f8badf7fd5b14992033252" translate="yes" xml:space="preserve">
          <source>Tensorflow eager tensor, to be converted to dlpack capsule.</source>
          <target state="translated">Tensorflow eager tensor, to be converted to dlpack capsule.</target>
        </trans-unit>
        <trans-unit id="df64ef28dfdc0fed49d20c14d6e6f4dee9cf4df9" translate="yes" xml:space="preserve">
          <source>Tensorflow set operations.</source>
          <target state="translated">텐서 플로우 세트 조작.</target>
        </trans-unit>
        <trans-unit id="c78b40e19c215435bc3ed71dd1958e2bcae7efd3" translate="yes" xml:space="preserve">
          <source>Tensorlow Activation function denoted by input string.</source>
          <target state="translated">입력 문자열로 표시되는 텐서 로우 활성화 기능.</target>
        </trans-unit>
        <trans-unit id="08f39ae099e26b016733e9e9c40c5aeddf309f4f" translate="yes" xml:space="preserve">
          <source>Tensors are broadcast to all shards if they are lexically captured by &lt;code&gt;computation&lt;/code&gt;. e.g.,</source>
          <target state="translated">텐서는 &lt;code&gt;computation&lt;/code&gt; 의해 어휘 적으로 캡처 된 경우 모든 샤드에 브로드 캐스트됩니다 . 예를 들어</target>
        </trans-unit>
        <trans-unit id="1a8d4468d2d83e08e6b380dfdd980b18e8bfdfab" translate="yes" xml:space="preserve">
          <source>Tensors of input values. Can include &lt;code&gt;None&lt;/code&gt; elements, which will be ignored.</source>
          <target state="translated">Tensors of input values. Can include &lt;code&gt;None&lt;/code&gt; elements, which will be ignored.</target>
        </trans-unit>
        <trans-unit id="bf0313234b1dcd5626309aecb9ec7ec9391ddedf" translate="yes" xml:space="preserve">
          <source>Tensors returned by the call to either &lt;code&gt;true_fn&lt;/code&gt; or &lt;code&gt;false_fn&lt;/code&gt;. If the callables return a singleton list, the element is extracted from the list.</source>
          <target state="translated">텐서 중 하나에 대한 호출에 의해 반환 &lt;code&gt;true_fn&lt;/code&gt; 또는 &lt;code&gt;false_fn&lt;/code&gt; . 콜 러블이 싱글 톤 목록을 반환하면 요소가 목록에서 추출됩니다.</target>
        </trans-unit>
        <trans-unit id="a48b71c8b807b599bf508a6dbc5c09d5b67d8a03" translate="yes" xml:space="preserve">
          <source>Tensors where required information about the tensor is not found are not added to the list. This includes temporary tensors without a name.</source>
          <target state="translated">텐서에 대한 필수 정보가없는 텐서는 목록에 추가되지 않습니다. 여기에는 이름이없는 임시 텐서가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f7b5ca3ec5313c82b6abfc2564bf0e69a6804f5b" translate="yes" xml:space="preserve">
          <source>Tensors with the same shapes and dtypes as &lt;code&gt;primals&lt;/code&gt;, or None if no JVP is available.</source>
          <target state="translated">primals와 모양 및 dtype이 동일한 &lt;code&gt;primals&lt;/code&gt; 또는 사용 가능한 JVP가없는 경우 None</target>
        </trans-unit>
        <trans-unit id="a55a275aa676930d9258569485d5b38eb1196630" translate="yes" xml:space="preserve">
          <source>Terms</source>
          <target state="translated">Terms</target>
        </trans-unit>
        <trans-unit id="f63302361128babd351769e59c1a4b3a6ec16f94" translate="yes" xml:space="preserve">
          <source>Test the model on a single batch of samples.</source>
          <target state="translated">단일 샘플 배치에서 모델을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="bdf696f0dd4d97504f4a88d9e975e9f3294e8162" translate="yes" xml:space="preserve">
          <source>Testing.</source>
          <target state="translated">Testing.</target>
        </trans-unit>
        <trans-unit id="922aa0452fde3720fa66aa3c8e60b54fc1c9bf57" translate="yes" xml:space="preserve">
          <source>Tests if a variable has been initialized.</source>
          <target state="translated">변수가 초기화되었는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f458c872a2ebaf65e5d7df76b800c1d13ed30e7f" translate="yes" xml:space="preserve">
          <source>Tests whether &lt;code&gt;v&lt;/code&gt; was created while this strategy scope was active.</source>
          <target state="translated">이 전략 범위가 활성화 된 동안 &lt;code&gt;v&lt;/code&gt; 가 작성 되었는지 테스트합니다 .</target>
        </trans-unit>
        <trans-unit id="e0beba45f94aef1d128461a461734027a1cbdc6a" translate="yes" xml:space="preserve">
          <source>Text classification with TensorFlow Hub: Movie reviews</source>
          <target state="translated">TensorFlow Hub를 사용한 텍스트 분류 : 영화 리뷰</target>
        </trans-unit>
        <trans-unit id="af2326670284928f1fa19c7cb38f5c886d723da5" translate="yes" xml:space="preserve">
          <source>Text classification with an RNN</source>
          <target state="translated">RNN을 사용한 텍스트 분류</target>
        </trans-unit>
        <trans-unit id="666b2045ab57fe75e30e76d0ab8d952507d4bb84" translate="yes" xml:space="preserve">
          <source>Text classification with preprocessed text: Movie reviews</source>
          <target state="translated">전처리 된 텍스트를 사용한 텍스트 분류 : 영화 리뷰</target>
        </trans-unit>
        <trans-unit id="238cbda9697b2819cc76abe6b2dfc721f459f878" translate="yes" xml:space="preserve">
          <source>Text data summarized via this plugin will be visible in the Text Dashboard in TensorBoard. The standard TensorBoard Text Dashboard will render markdown in the strings, and will automatically organize 1d and 2d tensors into tables. If a tensor with more than 2 dimensions is provided, a 2d subarray will be displayed along with a warning message. (Note that this behavior is not intrinsic to the text summary api, but rather to the default TensorBoard text plugin.)</source>
          <target state="translated">이 플러그인을 통해 요약 된 텍스트 데이터는 TensorBoard의 텍스트 대시 보드에 표시됩니다. 표준 TensorBoard Text Dashboard는 문자열에서 마크 다운을 렌더링하고 1d 및 2d 텐서를 테이블로 자동 구성합니다. 2 차원보다 큰 텐서가 제공되면 경고 메시지와 함께 2d 하위 배열이 표시됩니다. (이 동작은 텍스트 요약 API에 고유 한 것이 아니라 기본 TensorBoard 텍스트 플러그인에 고유합니다.)</target>
        </trans-unit>
        <trans-unit id="215d4fed2fcabcf3c40621205317566597794ae1" translate="yes" xml:space="preserve">
          <source>Text generation with an RNN</source>
          <target state="translated">RNN을 사용한 텍스트 생성</target>
        </trans-unit>
        <trans-unit id="61400e23cf34d05c482b01eaced08ef2d8868035" translate="yes" xml:space="preserve">
          <source>Text tokenization utility class.</source>
          <target state="translated">텍스트 토큰 화 유틸리티 클래스.</target>
        </trans-unit>
        <trans-unit id="fdb6f1dda58b475840646d14c94922eb6f72f336" translate="yes" xml:space="preserve">
          <source>Text vectorization layer.</source>
          <target state="translated">텍스트 벡터화 레이어.</target>
        </trans-unit>
        <trans-unit id="f1625deb08cd91b1818022a22d98396b875c5eb8" translate="yes" xml:space="preserve">
          <source>TextFileIndex.LINE_NUMBER means use the line number starting from zero, expects data type int64.</source>
          <target state="translated">TextFileIndex.LINE_NUMBER는 0부터 시작하는 행 번호를 사용한다는 의미이며 데이터 유형은 int64입니다.</target>
        </trans-unit>
        <trans-unit id="52639d0bc1ea1e6f18d19dfc84aced6fc473d4b7" translate="yes" xml:space="preserve">
          <source>TextFileIndex.WHOLE_LINE means use the whole line content, expects data type string.</source>
          <target state="translated">TextFileIndex.WHOLE_LINE은 전체 행 내용을 사용하고 데이터 유형 문자열을 예상 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="aae1af3abaa894b413f4b067008faeab65eabf5c" translate="yes" xml:space="preserve">
          <source>TextLineDataset</source>
          <target state="translated">TextLineDataset</target>
        </trans-unit>
        <trans-unit id="00504b1255a96c459911faa4e9c084086511e171" translate="yes" xml:space="preserve">
          <source>TextLineReader</source>
          <target state="translated">TextLineReader</target>
        </trans-unit>
        <trans-unit id="4b2c757da49259aded733326539b78214b6386f7" translate="yes" xml:space="preserve">
          <source>TextLineReaderV2</source>
          <target state="translated">TextLineReaderV2</target>
        </trans-unit>
        <trans-unit id="32a32db1543cdc3c626d9e433e0bcb624a120cf4" translate="yes" xml:space="preserve">
          <source>Tf1 Compatibility</source>
          <target state="translated">Tf1 Compatibility</target>
        </trans-unit>
        <trans-unit id="3bd93c93ad7351313ce7fcdddf6eae9396528ebd" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var and accum as follows:</source>
          <target state="translated">That is for rows we have grad for, we update var and accum as follows:</target>
        </trans-unit>
        <trans-unit id="929ca813ba0d0e0e8019d57d723a975ded7a98c1" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var and accum as follows: accum += grad * grad prox_v = var prox_v -= lr * grad * (1 / sqrt(accum)) var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}</source>
          <target state="translated">That is for rows we have grad for, we update var and accum as follows: accum += grad * grad prox_v = var prox_v -= lr * grad * (1 / sqrt(accum)) var = sign(prox_v)/(1+lr*l2) * max{|prox_v|-lr*l1,0}</target>
        </trans-unit>
        <trans-unit id="9ef1d3736ee1570a99e3839352b8be40fa69fa3b" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var and accum as follows: accum += grad * grad var -= lr * grad * (1 / sqrt(accum))</source>
          <target state="translated">That is for rows we have grad for, we update var and accum as follows: accum += grad * grad var -= lr * grad * (1 / sqrt(accum))</target>
        </trans-unit>
        <trans-unit id="e3002670e140323f193822e7322051db5b0796ae" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var as follows:</source>
          <target state="translated">That is for rows we have grad for, we update var as follows:</target>
        </trans-unit>
        <trans-unit id="87f1c5e604fe8b91203c415d93576c5c698bbe19" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var as follows: prox_v = var - alpha * grad var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}</source>
          <target state="translated">That is for rows we have grad for, we update var as follows: prox_v = var - alpha * grad var = sign(prox_v)/(1+alpha*l2) * max{|prox_v|-alpha*l1,0}</target>
        </trans-unit>
        <trans-unit id="faa2fc81a8cc984f4e78327801816384e2824a57" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var, accum and linear as follows:</source>
          <target state="translated">That is for rows we have grad for, we update var, accum and linear as follows:</target>
        </trans-unit>
        <trans-unit id="edbeb8da53ac3780cd97043899b23bcb49bd08f0" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var, accum and linear as follows: accum_new = accum + grad * grad linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</source>
          <target state="translated">That is for rows we have grad for, we update var, accum and linear as follows: accum_new = accum + grad * grad linear += grad - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</target>
        </trans-unit>
        <trans-unit id="ae53fa0352a639df9f5ce6648263083ffb0e5c21" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var, accum and linear as follows: grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad * grad linear += grad_with_shrinkage - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</source>
          <target state="translated">That is for rows we have grad for, we update var, accum and linear as follows: grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad * grad linear += grad_with_shrinkage - (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</target>
        </trans-unit>
        <trans-unit id="1fa4e061d9d26a6b3da848e09b858d3702ecff6b" translate="yes" xml:space="preserve">
          <source>That is for rows we have grad for, we update var, accum and linear as follows: grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad_with_shrinkage * grad_with_shrinkage linear += grad_with_shrinkage + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</source>
          <target state="translated">That is for rows we have grad for, we update var, accum and linear as follows: grad_with_shrinkage = grad + 2 * l2_shrinkage * var accum_new = accum + grad_with_shrinkage * grad_with_shrinkage linear += grad_with_shrinkage + (accum_new^(-lr_power) - accum^(-lr_power)) / lr * var quadratic = 1.0 / (accum_new^(lr_power) * lr) + 2 * l2 var = (sign(linear) * l1 - linear) / quadratic if |linear| &amp;gt; l1 else 0.0 accum = accum_new</target>
        </trans-unit>
        <trans-unit id="fad4058d06803c465e05d1c5344e342b15bc7c35" translate="yes" xml:space="preserve">
          <source>That is, the data from the input tensors is joined along the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">즉, 입력 텐서의 데이터가 &lt;code&gt;axis&lt;/code&gt; 치수를 따라 결합됩니다 .</target>
        </trans-unit>
        <trans-unit id="99e979e2c9f35b245f91a4fcf123a371dda84688" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; behavior to is to output all intermediates when using v2 control flow inside Keras models in graph mode (possibly inside Estimators). This is needed to support taking gradients of v2 control flow. In graph mode, Keras can sometimes freeze the forward graph before the gradient computation which does not work for v2 control flow since it requires updating the forward ops to output the needed intermediates. We work around this by proactively outputting the needed intermediates when building the forward pass itself. Ideally any such extra tensors should be pruned out at runtime. However, if for any reason this doesn't work for you or if you have an inference-only model you can turn this behavior off using &lt;a href=&quot;output_all_intermediates&quot;&gt;&lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(False)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &quot;default&quot; behavior to is to output all intermediates when using v2 control flow inside Keras models in graph mode (possibly inside Estimators). This is needed to support taking gradients of v2 control flow. In graph mode, Keras can sometimes freeze the forward graph before the gradient computation which does not work for v2 control flow since it requires updating the forward ops to output the needed intermediates. We work around this by proactively outputting the needed intermediates when building the forward pass itself. Ideally any such extra tensors should be pruned out at runtime. However, if for any reason this doesn't work for you or if you have an inference-only model you can turn this behavior off using &lt;a href=&quot;output_all_intermediates&quot;&gt; &lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(False)&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="819444ab5f8a03046c9bdaef264812c5a336db87" translate="yes" xml:space="preserve">
          <source>The &quot;default&quot; behavior to is to output all intermediates when using v2 control flow inside Keras models in graph mode (possibly inside Estimators). This is needed to support taking gradients of v2 control flow. In graph mode, Keras can sometimes freeze the forward graph before the gradient computation which does not work for v2 control flow since it requires updating the forward ops to output the needed intermediates. We work around this by proactively outputting the needed intermediates when building the forward pass itself. Ideally any such extra tensors should be pruned out at runtime. However, if for any reason this doesn't work for you or if you have an infernce-only model you can turn this behavior off using &lt;a href=&quot;output_all_intermediates&quot;&gt;&lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(False)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&quot;기본&quot;동작은 그래프 모드에서 Keras 모델 내부 (예상자 내부)에서 v2 제어 흐름을 사용할 때 모든 중간체를 출력하는 것입니다. 이것은 v2 제어 흐름의 그라디언트를 지원하는 데 필요합니다. 그래프 모드에서 Keras는 필요한 중간체를 출력하기 위해 순방향 op를 업데이트해야하므로 v2 제어 흐름에서는 작동하지 않는 기울기 계산 전에 순방향 그래프를 고정 할 수 있습니다. 정방향 패스를 만들 때 필요한 중간체를 미리 출력하여이 문제를 해결합니다. 이상적으로 이러한 여분의 텐서는 런타임에 정리해야합니다. 그러나 어떤 이유로 든 이것이 작동하지 않거나 추론 전용 모델 인 경우 &lt;a href=&quot;output_all_intermediates&quot;&gt; &lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(False)&lt;/code&gt; &lt;/a&gt; 사용 하여이 동작을 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b9fa0a04a1154461443bf2e15e0c100a29ae547" translate="yes" xml:space="preserve">
          <source>The 'key' part of the state of a counter-based RNG.</source>
          <target state="translated">카운터 기반 RNG 상태의 '핵심'부분.</target>
        </trans-unit>
        <trans-unit id="3318a80b2f7ae85ea4618b44f96f90cdc30913bf" translate="yes" xml:space="preserve">
          <source>The 'step' here refers to the step defined by &lt;code&gt;Profiler.add_step()&lt;/code&gt; API.</source>
          <target state="translated">여기서 '단계'는 &lt;code&gt;Profiler.add_step()&lt;/code&gt; API에 의해 정의 된 단계를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="32756cff4dc3fe86f44d1b62b470239afbc36f52" translate="yes" xml:space="preserve">
          <source>The -32768 to 32767 signed 16-bit values will be scaled to -1.0 to 1.0 in float.</source>
          <target state="translated">-32768 ~ 32767 부호있는 16 비트 값은 부동 소수점으로 -1.0 ~ 1.0으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a500fcca2783caaf16ae016a052e05e8f3aac0f1" translate="yes" xml:space="preserve">
          <source>The .value attribute of the registered 'Flag' objects can be accessed as attributes of this 'FlagValues' object, through &lt;strong&gt;getattr&lt;/strong&gt;. Both the long and short name of the original 'Flag' objects can be used to access its value: FLAGS.longname # parsed flag value FLAGS.x # parsed flag value (short name)</source>
          <target state="translated">등록 된 'Flag'객체의 .value 속성은 &lt;strong&gt;getattr&lt;/strong&gt; 을 통해이 'FlagValues'객체의 속성으로 액세스 할 수 있습니다 . 원래 'Flag'객체의 긴 이름과 짧은 이름을 사용하여 해당 값에 액세스 할 수 있습니다. FLAGS.longname # 구문 분석 된 플래그 값 FLAGS.x # 구문 분석 된 플래그 값 (짧은 이름)</target>
        </trans-unit>
        <trans-unit id="310600070b5ce2b07429f189bd9cdba9eeaed7e3" translate="yes" xml:space="preserve">
          <source>The 4-D &lt;code&gt;input&lt;/code&gt; tensor is treated as a 3-D array of 1-D vectors (along the last dimension), and each vector is normalized independently. Within a given vector, each component is divided by the weighted, squared sum of inputs within &lt;code&gt;depth_radius&lt;/code&gt;. In detail,</source>
          <target state="translated">4 차원 &lt;code&gt;input&lt;/code&gt; 텐서는 1 차원 벡터 (마지막 차원)의 3 차원 배열로 취급되며 각 벡터는 독립적으로 정규화됩니다. 주어진 벡터 내에서 각 구성 요소는 &lt;code&gt;depth_radius&lt;/code&gt; 내의 가중 제곱 입력 합으로 나뉩니다 . 상세히,</target>
        </trans-unit>
        <trans-unit id="0f0e683a1673564b6d46b0b9fa5e4680c1843f5c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;input_fn&lt;/code&gt; should have a per-replica batch size, which may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 는&lt;/a&gt; 에 의해 반환 &lt;code&gt;input_fn&lt;/code&gt; 사용하여 계산 될 수있는 당 복제 배치 크기, 있어야 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="61826dd5bb7c2966f5aa2b8a6e3a8cdffb1d52d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</source>
          <target state="translated">The &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</target>
        </trans-unit>
        <trans-unit id="457c92aa7bdffea8661a2def17f70e375b2b0d14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;input_fn&lt;/code&gt; should have a per-replica batch size, which may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 는&lt;/a&gt; 에 의해 반환 &lt;code&gt;input_fn&lt;/code&gt; 사용하여 계산 될 수있는 당 복제 배치 크기, 있어야 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="16de01ef66472389e867ed7172f8cf19b9d12f37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</source>
          <target state="translated">The &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</target>
        </trans-unit>
        <trans-unit id="c669108152980f350f27d9f945606a7f5042af07" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../compat&quot;&gt;&lt;code&gt;tf.compat&lt;/code&gt;&lt;/a&gt; module contains two sets of compatibility functions.</source>
          <target state="translated">&lt;a href=&quot;../../compat&quot;&gt; &lt;code&gt;tf.compat&lt;/code&gt; 의&lt;/a&gt; 모듈은 호환 함수의 두 세트를 포함한다.</target>
        </trans-unit>
        <trans-unit id="7930784ff8dbb651a991e042e417bd9dc3a14eeb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; this model was created under.</source>
          <target state="translated">The &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; this model was created under.</target>
        </trans-unit>
        <trans-unit id="3fbdd965cada2455c5a4b44ca098e598d5cdf301" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../../image&quot;&gt;&lt;code&gt;tf.image&lt;/code&gt;&lt;/a&gt; module contains various functions for image processing and decoding-encoding Ops.</source>
          <target state="translated">The &lt;a href=&quot;../../image&quot;&gt; &lt;code&gt;tf.image&lt;/code&gt; &lt;/a&gt; module contains various functions for image processing and decoding-encoding Ops.</target>
        </trans-unit>
        <trans-unit id="22402ac75618003d1c02e2a951e502bb27f99e5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</source>
          <target state="translated">The &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</target>
        </trans-unit>
        <trans-unit id="381a5f266061634b6218e86a5278cc8e73b11bce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; Python API creates instances of this op from &lt;a href=&quot;../data/dataset#interleave&quot;&gt;&lt;code&gt;Dataset.interleave()&lt;/code&gt;&lt;/a&gt; when the &lt;code&gt;num_parallel_calls&lt;/code&gt; parameter of that method is set to any value other than &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; Python API creates instances of this op from &lt;a href=&quot;../data/dataset#interleave&quot;&gt; &lt;code&gt;Dataset.interleave()&lt;/code&gt; &lt;/a&gt; when the &lt;code&gt;num_parallel_calls&lt;/code&gt; parameter of that method is set to any value other than &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1692f604914f2012ce5644f6e1f92719dcce4ac" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; this model was created under.</source>
          <target state="translated">The &lt;a href=&quot;../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; this model was created under.</target>
        </trans-unit>
        <trans-unit id="d984abb5fd047cadea5d56f7490219cb30629a70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../math/asin&quot;&gt;&lt;code&gt;tf.math.asin&lt;/code&gt;&lt;/a&gt; operation returns the inverse of &lt;a href=&quot;../math/sin&quot;&gt;&lt;code&gt;tf.math.sin&lt;/code&gt;&lt;/a&gt;, such that if &lt;code&gt;y = tf.math.sin(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.asin(y)&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;../math/asin&quot;&gt; &lt;code&gt;tf.math.asin&lt;/code&gt; &lt;/a&gt; operation returns the inverse of &lt;a href=&quot;../math/sin&quot;&gt; &lt;code&gt;tf.math.sin&lt;/code&gt; &lt;/a&gt;, such that if &lt;code&gt;y = tf.math.sin(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.asin(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb62e61562cfc798d007ffb505d7c927be8a3767" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../math/atan&quot;&gt;&lt;code&gt;tf.math.atan&lt;/code&gt;&lt;/a&gt; operation returns the inverse of &lt;a href=&quot;../math/tan&quot;&gt;&lt;code&gt;tf.math.tan&lt;/code&gt;&lt;/a&gt;, such that if &lt;code&gt;y = tf.math.tan(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.atan(y)&lt;/code&gt;.</source>
          <target state="translated">The &lt;a href=&quot;../math/atan&quot;&gt; &lt;code&gt;tf.math.atan&lt;/code&gt; &lt;/a&gt; operation returns the inverse of &lt;a href=&quot;../math/tan&quot;&gt; &lt;code&gt;tf.math.tan&lt;/code&gt; &lt;/a&gt;, such that if &lt;code&gt;y = tf.math.tan(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.atan(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d2d82dc787cbf3a2ae3987bb1b5d16410bae2e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../v1&quot;&gt;&lt;code&gt;compat.v1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../v2&quot;&gt;&lt;code&gt;compat.v2&lt;/code&gt;&lt;/a&gt; submodules provide a complete copy of both the &lt;a href=&quot;../v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../v2&quot;&gt;&lt;code&gt;v2&lt;/code&gt;&lt;/a&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;../v1&quot;&gt; &lt;code&gt;compat.v1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../v2&quot;&gt; &lt;code&gt;compat.v2&lt;/code&gt; &lt;/a&gt; 서브 모듈은 완료 모두의 사본을 제공 &lt;a href=&quot;../v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../v2&quot;&gt; &lt;code&gt;v2&lt;/code&gt; &lt;/a&gt; TensorFlow 버전 1.x 및 2.x 또는 3.0을 통해 앞으로 뒤로위한 API와 호환성을 자세한 내용은 &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;마이그레이션 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="988e4c84f8c74714ed58270532749c9a06a1161b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../v1&quot;&gt;&lt;code&gt;compat.v1&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;compat.v2&lt;/code&gt; submodules provide a complete copy of both the &lt;a href=&quot;../v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;v2&lt;/code&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</source>
          <target state="translated">The &lt;a href=&quot;../v1&quot;&gt; &lt;code&gt;compat.v1&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;compat.v2&lt;/code&gt; submodules provide a complete copy of both the &lt;a href=&quot;../v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;v2&lt;/code&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="fbe9cc0c9957673c491ce6d30fbea4a26885b807" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;as_dtype&quot;&gt;&lt;code&gt;tf.as_dtype()&lt;/code&gt;&lt;/a&gt; function converts numpy types and string type names to a &lt;code&gt;DType&lt;/code&gt; object.</source>
          <target state="translated">&lt;a href=&quot;as_dtype&quot;&gt; &lt;code&gt;tf.as_dtype()&lt;/code&gt; &lt;/a&gt; 함수로 변환은 유형 및 스트링 유형 이름 NumPy와 &lt;code&gt;DType&lt;/code&gt; 오브젝트.</target>
        </trans-unit>
        <trans-unit id="32f6a4f580c3c6e3fc936c05d3cb6e72f0b9bb8c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;asin&quot;&gt;&lt;code&gt;tf.math.asin&lt;/code&gt;&lt;/a&gt; operation returns the inverse of &lt;a href=&quot;sin&quot;&gt;&lt;code&gt;tf.math.sin&lt;/code&gt;&lt;/a&gt;, such that if &lt;code&gt;y = tf.math.sin(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.asin(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;asin&quot;&gt; &lt;code&gt;tf.math.asin&lt;/code&gt; 의&lt;/a&gt; 동작의 역 복귀 &lt;a href=&quot;sin&quot;&gt; &lt;code&gt;tf.math.sin&lt;/code&gt; &lt;/a&gt; 같은 그 경우 &lt;code&gt;y = tf.math.sin(x)&lt;/code&gt; 그리고, &lt;code&gt;x = tf.math.asin(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fe608389d1e1d156ec65aaf39eda66bf4b6d78b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;atan&quot;&gt;&lt;code&gt;tf.math.atan&lt;/code&gt;&lt;/a&gt; operation returns the inverse of &lt;a href=&quot;tan&quot;&gt;&lt;code&gt;tf.math.tan&lt;/code&gt;&lt;/a&gt;, such that if &lt;code&gt;y = tf.math.tan(x)&lt;/code&gt; then, &lt;code&gt;x = tf.math.atan(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;atan&quot;&gt; &lt;code&gt;tf.math.atan&lt;/code&gt; &lt;/a&gt; 동작의 역 복귀 &lt;a href=&quot;tan&quot;&gt; &lt;code&gt;tf.math.tan&lt;/code&gt; &lt;/a&gt; 같은 그 경우 &lt;code&gt;y = tf.math.tan(x)&lt;/code&gt; 그리고, &lt;code&gt;x = tf.math.atan(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7383c15524c25652a8be0c20b2757d2d4dcf2ab3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; instance to save and manage checkpoints for.</source>
          <target state="translated">The &lt;a href=&quot;checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; instance to save and manage checkpoints for.</target>
        </trans-unit>
        <trans-unit id="7434949d112760b2d99fef94744aa31346652af1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</source>
          <target state="translated">The &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; may be useful when the user needs to access information such as the cluster spec, task type or task id. For example,</target>
        </trans-unit>
        <trans-unit id="377c0dfe96375de255d1078e440f823480e3a6ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compat&quot;&gt;&lt;code&gt;tf.compat&lt;/code&gt;&lt;/a&gt; module contains two sets of compatibility functions.</source>
          <target state="translated">&lt;a href=&quot;compat&quot;&gt; &lt;code&gt;tf.compat&lt;/code&gt; 의&lt;/a&gt; 모듈은 호환 함수의 두 세트를 포함한다.</target>
        </trans-unit>
        <trans-unit id="b3d73ba603d6fb92f75b91298f4942e6c40c7715" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;compat.v1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;compat/v2&quot;&gt;&lt;code&gt;compat.v2&lt;/code&gt;&lt;/a&gt; submodules provide a complete copy of both the &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;compat/v2&quot;&gt;&lt;code&gt;v2&lt;/code&gt;&lt;/a&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;compat.v1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;compat/v2&quot;&gt; &lt;code&gt;compat.v2&lt;/code&gt; &lt;/a&gt; 서브 모듈은 완료 모두의 사본을 제공 &lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;compat/v2&quot;&gt; &lt;code&gt;v2&lt;/code&gt; &lt;/a&gt; TensorFlow 버전 1.x 및 2.x 또는 3.0을 통해 앞으로 뒤로위한 API와 호환성을 자세한 내용은 &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;마이그레이션 안내서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ca8181df14f66605275982b870e43d04f0771679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;compat.v1&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;compat.v2&lt;/code&gt; submodules provide a complete copy of both the &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;v1&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;v2&lt;/code&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</source>
          <target state="translated">The &lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;compat.v1&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;compat.v2&lt;/code&gt; submodules provide a complete copy of both the &lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;v1&lt;/code&gt; &lt;/a&gt; and &lt;code&gt;v2&lt;/code&gt; APIs for backwards and forwards compatibility across TensorFlow versions 1.x and 2.x. See the &lt;a href=&quot;https://www.tensorflow.org/guide/migrate&quot;&gt;migration guide&lt;/a&gt; for details.</target>
        </trans-unit>
        <trans-unit id="296ec246e39e89b77945b24475c46eb438f28485" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; API supports writing descriptive and efficient input pipelines. &lt;code&gt;Dataset&lt;/code&gt; usage follows a common pattern:</source>
          <target state="translated">&lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 을&lt;/a&gt; 설명하고 효율적인 입력 파이프 라인을 작성하는 API를 지원합니다. &lt;code&gt;Dataset&lt;/code&gt; 사용법은 일반적인 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="8c3d4e4e633551f12e713ed696a5627504df6738" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dtypes/dtype&quot;&gt;&lt;code&gt;tf.dtypes.DType&lt;/code&gt;&lt;/a&gt; specified by this type for the SparseTensor.</source>
          <target state="translated">&lt;a href=&quot;dtypes/dtype&quot;&gt; &lt;code&gt;tf.dtypes.DType&lt;/code&gt; 는&lt;/a&gt; SparseTensor이 유형에 의해 지정.</target>
        </trans-unit>
        <trans-unit id="70d5ec6de5836f215309b5a86984ea31fb17eefc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto&quot;&gt;&lt;code&gt;ConfigProto&lt;/code&gt;&lt;/a&gt; protocol buffer exposes various configuration options for a session. For example, to create a session that uses soft constraints for device placement, and log the resulting placement decisions, create a session as follows:</source>
          <target state="translated">&lt;a href=&quot;https://www.tensorflow.org/code/tensorflow/core/protobuf/config.proto&quot;&gt; &lt;code&gt;ConfigProto&lt;/code&gt; 의&lt;/a&gt; 프로토콜 버퍼는 세션에 대한 다양한 구성 옵션을 제공합니다. 예를 들어, 장치 배치에 소프트 제한 조건을 사용하는 세션을 작성하고 결과 배치 결정을 로그하려면 다음과 같이 세션을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c5070704459494efabd9de46ea247ae08b2267c2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;image&quot;&gt;&lt;code&gt;tf.image&lt;/code&gt;&lt;/a&gt; module contains various functions for image processing and decoding-encoding Ops.</source>
          <target state="translated">The &lt;a href=&quot;image&quot;&gt; &lt;code&gt;tf.image&lt;/code&gt; &lt;/a&gt; module contains various functions for image processing and decoding-encoding Ops.</target>
        </trans-unit>
        <trans-unit id="828225ce38f2c2861420ded59d51ee7ae52b80d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;policy&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.Policy&lt;/code&gt;&lt;/a&gt; of the layer.</source>
          <target state="translated">The &lt;a href=&quot;policy&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.Policy&lt;/code&gt; &lt;/a&gt; of the layer.</target>
        </trans-unit>
        <trans-unit id="ee6db31a7766468eec0b350c9fc9a1f275e8fb70" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;reshape&quot;&gt;&lt;code&gt;tf.reshape&lt;/code&gt;&lt;/a&gt; does not change the order of or the total number of elements in the tensor, and so it can reuse the underlying data buffer. This makes it a fast operation independent of how big of a tensor it is operating on.</source>
          <target state="translated">&lt;a href=&quot;reshape&quot;&gt; &lt;code&gt;tf.reshape&lt;/code&gt; 은&lt;/a&gt; 순서 또는 텐서 요소의 총 개수를 변경하지 않고, 그 재사용 할 수 있도록 기본 데이터 버퍼. 이것은 얼마나 큰 텐서가 작동하는지에 관계없이 빠른 작동을합니다.</target>
        </trans-unit>
        <trans-unit id="7963552cb54b1ec49bf3619d53b5f98fe3bf0679" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;summary&quot;&gt;&lt;code&gt;tf.summary&lt;/code&gt;&lt;/a&gt; module provides APIs for writing summary data. This data can be visualized in TensorBoard, the visualization toolkit that comes with TensorFlow. See the &lt;a href=&quot;https://www.tensorflow.org/tensorboard&quot;&gt;TensorBoard website&lt;/a&gt; for more detailed tutorials about how to use these APIs, or some quick examples below.</source>
          <target state="translated">&lt;a href=&quot;summary&quot;&gt; &lt;code&gt;tf.summary&lt;/code&gt; &lt;/a&gt; 모듈은 요약 데이터를 작성하기위한 API를 제공합니다. 이 데이터는 TensorFlow와 함께 제공되는 시각화 툴킷 인 TensorBoard에서 시각화 할 수 있습니다. 이러한 API 사용 방법에 대한 자세한 자습서 또는 아래의 몇 가지 간단한 예 는 &lt;a href=&quot;https://www.tensorflow.org/tensorboard&quot;&gt;TensorBoard 웹 사이트&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3a28a188c3e8accbc6798bb8b1a1cc55ac7affc9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;summarywriter&quot;&gt;&lt;code&gt;tf.summary.SummaryWriter&lt;/code&gt;&lt;/a&gt; resource to flush. The thread default will be used if this parameter is None. Otherwise a &lt;a href=&quot;../no_op&quot;&gt;&lt;code&gt;tf.no_op&lt;/code&gt;&lt;/a&gt; is returned.</source>
          <target state="translated">The &lt;a href=&quot;summarywriter&quot;&gt; &lt;code&gt;tf.summary.SummaryWriter&lt;/code&gt; &lt;/a&gt; resource to flush. The thread default will be used if this parameter is None. Otherwise a &lt;a href=&quot;../no_op&quot;&gt; &lt;code&gt;tf.no_op&lt;/code&gt; &lt;/a&gt; is returned.</target>
        </trans-unit>
        <trans-unit id="24f9ea8adfa7610b42fddb644a5a51e051b8eaa7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; of elements in this TensorArray.</source>
          <target state="translated">이 &lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt; 에있는 요소 의 tf.TensorShape 입니다.</target>
        </trans-unit>
        <trans-unit id="04e6781a375d8a3c0003a07e94ac44bcb3e616e5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; specified by this type for the SparseTensor.</source>
          <target state="translated">&lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; 는&lt;/a&gt; SparseTensor이 유형에 의해 지정.</target>
        </trans-unit>
        <trans-unit id="66692c6576fc19dc600e497055779a41aa378ba7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;AUTOGRAPH_VERBOSITY&lt;/code&gt; environment variable</source>
          <target state="translated">&lt;code&gt;AUTOGRAPH_VERBOSITY&lt;/code&gt; 의 환경 변수</target>
        </trans-unit>
        <trans-unit id="5dca74f64b67802ef6255942a005b4b0e987ede6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;D&lt;/code&gt; dimensional DFT of this kernel is the frequency domain spectrum of this operator.</source>
          <target state="translated">이 커널 의 &lt;code&gt;D&lt;/code&gt; 차원 DFT는이 연산자의 주파수 영역 스펙트럼입니다.</target>
        </trans-unit>
        <trans-unit id="66b37f1319974cb5f0fa3b6a811c37b0c0727341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt;s handled by this &lt;code&gt;Distribution&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DType&lt;/code&gt; 의 &lt;code&gt;Tensor&lt;/code&gt; 이 처리 s의 &lt;code&gt;Distribution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bb640578d6cd791bb5862104fe6d0205745975e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt;s handled by this &lt;code&gt;LinearOperator&lt;/code&gt;.</source>
          <target state="translated">이 &lt;code&gt;DType&lt;/code&gt; 가 처리하는 &lt;code&gt;Tensor&lt;/code&gt; 의 &lt;code&gt;LinearOperator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d9d4756bd9db645b28103af34e5194ce4953cfef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of elements in this tensor.</source>
          <target state="translated">이 텐서 요소 의 &lt;code&gt;DType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="75ee899d1ba59ad3ee99fc46d3b07ccd0b0595f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of the result matrix. Must be a floating point type.</source>
          <target state="translated">The &lt;code&gt;DType&lt;/code&gt; of the result matrix. Must be a floating point type.</target>
        </trans-unit>
        <trans-unit id="b5ab67eadac883aa6725083774a80ae7132a5bd6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of this variable.</source>
          <target state="translated">이 변수 의 &lt;code&gt;DType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="53e90665615d6d49947adc54462569d15bfa77ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DType&lt;/code&gt; of values in this tensor.</source>
          <target state="translated">이 텐서의 값 의 &lt;code&gt;DType&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="002dd8c89bb7df3616a476af70ae5059fd25b6ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dataset&lt;/code&gt; containing the elements of this dataset for which &lt;code&gt;predicate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;Dataset&lt;/code&gt; containing the elements of this dataset for which &lt;code&gt;predicate&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee4829a0c603daeed835711034774800b5049669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dataset&lt;/code&gt; returned by applying &lt;code&gt;transformation_func&lt;/code&gt; to this dataset.</source>
          <target state="translated">The &lt;code&gt;Dataset&lt;/code&gt; returned by applying &lt;code&gt;transformation_func&lt;/code&gt; to this dataset.</target>
        </trans-unit>
        <trans-unit id="b7a67bba30f7a7c9709251275c277fca1bfce8ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DeviceSpec&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DeviceSpec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0310f14b96c9ed2b643415080c07ecfa0544c1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Estimator&lt;/code&gt; object wraps a model which is specified by a &lt;code&gt;model_fn&lt;/code&gt;, which, given inputs and a number of other parameters, returns the ops necessary to perform training, evaluation, or predictions.</source>
          <target state="translated">&lt;code&gt;Estimator&lt;/code&gt; 목적은에 의해 특정되는 모델 랩 &lt;code&gt;model_fn&lt;/code&gt; 다른 파라미터의 수가, 트레이닝, 평가, 또는 예측을 수행하는 데 필요한 OPS를 반환 주어진 입력과.</target>
        </trans-unit>
        <trans-unit id="196e0cebbe1e15bfa0065abbfc42918c9e99edb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FileWriter&lt;/code&gt; class provides a mechanism to create an event file in a given directory and add summaries and events to it. The class updates the file contents asynchronously. This allows a training program to call methods to add data to the file directly from the training loop, without slowing down training.</source>
          <target state="translated">&lt;code&gt;FileWriter&lt;/code&gt; 의 클래스는 지정된 디렉토리에서 이벤트 파일을 작성하고 요약 및 이벤트를 추가 할 수있는 메커니즘을 제공합니다. 클래스는 파일 내용을 비동기 적으로 업데이트합니다. 이를 통해 훈련 프로그램은 훈련 속도를 늦추지 않고 훈련 루프에서 직접 파일에 데이터를 추가하는 메소드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="196ae7d5b42d47f46f7482c41ead4515ecb54223" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; of this variable.</source>
          <target state="translated">이 변수 의 &lt;code&gt;Graph&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="584ca58bfd11413a8b78de2539e6a0dc60006c1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; that contains the index, value, and dense_shape tensors.</source>
          <target state="translated">&lt;code&gt;Graph&lt;/code&gt; 인덱스 값 및 dense_shape 텐서가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ca109a80501f1caf39360f020e2482be69cd6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; that contains the values, indices, and shape tensors.</source>
          <target state="translated">&lt;code&gt;Graph&lt;/code&gt; 값, 인덱스 및 형상 텐서를 포함한다.</target>
        </trans-unit>
        <trans-unit id="a3f124e19ecf06b5bede3c16429a910c11d7deff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; that contains this operation.</source>
          <target state="translated">이 작업이 포함 된 &lt;code&gt;Graph&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca5e3e755e232a9bd4baefb017c11720d3cb6b8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; that contains this tensor.</source>
          <target state="translated">이 텐서가 포함 된 &lt;code&gt;Graph&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="759d796b4b952d2596b86361f4e9520455ee1328" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; that the model will use.</source>
          <target state="translated">The &lt;code&gt;Graph&lt;/code&gt; that the model will use.</target>
        </trans-unit>
        <trans-unit id="12834f0b5daa034b0698702e55e41fb711279722" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Graph&lt;/code&gt; to export. If &lt;code&gt;None&lt;/code&gt;, use the default graph.</source>
          <target state="translated">The &lt;code&gt;Graph&lt;/code&gt; to export. If &lt;code&gt;None&lt;/code&gt; , use the default graph.</target>
        </trans-unit>
        <trans-unit id="3a0f37ad85dc252ac5925abfae634853c02e8afc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GraphDef&lt;/code&gt; we expected.</source>
          <target state="translated">The &lt;code&gt;GraphDef&lt;/code&gt; we expected.</target>
        </trans-unit>
        <trans-unit id="b6d5d9570275d3383af7721887493926bb28e6bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;GraphDef&lt;/code&gt; we have.</source>
          <target state="translated">The &lt;code&gt;GraphDef&lt;/code&gt; we have.</target>
        </trans-unit>
        <trans-unit id="ad04e8ed6553bb23d3fbb8f177dc964899bc3ca0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IndexedSlices&lt;/code&gt; class is used principally in the definition of gradients for operations that have sparse gradients (e.g. &lt;a href=&quot;gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;code&gt;IndexedSlices&lt;/code&gt; 의 클래스는 스파 스 구배를 (예를 들어,이 작업을 위해 그라디언트의 정의에 주로 사용된다 &lt;a href=&quot;gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c19abf24b90c56611a87677ee0e44c98b82b9a43" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lambda&lt;/code&gt; layer exists so that arbitrary TensorFlow functions can be used when constructing &lt;code&gt;Sequential&lt;/code&gt; and Functional API models. &lt;code&gt;Lambda&lt;/code&gt; layers are best suited for simple operations or quick experimentation. For more advanced use cases, follow &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;this guide&lt;/a&gt; for subclassing &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">The &lt;code&gt;Lambda&lt;/code&gt; layer exists so that arbitrary TensorFlow functions can be used when constructing &lt;code&gt;Sequential&lt;/code&gt; and Functional API models. &lt;code&gt;Lambda&lt;/code&gt; layers are best suited for simple operations or quick experimentation. For more advanced use cases, follow &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;this guide&lt;/a&gt; for subclassing &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;tf.keras.layers.Layer&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b67dd6295f95267a6fd766fa43e3a4f8445ff608" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Lambda&lt;/code&gt; layer exists so that arbitrary TensorFlow functions can be used when constructing &lt;code&gt;Sequential&lt;/code&gt; and Functional API models. &lt;code&gt;Lambda&lt;/code&gt; layers are best suited for simple operations or quick experimentation. For more advanced usecases, follow &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;this guide&lt;/a&gt; for subclassing &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Lambda&lt;/code&gt; 층 구성 할 때 임의의 TensorFlow 기능을 사용할 수 있도록 존재 &lt;code&gt;Sequential&lt;/code&gt; 및 기능 API 모델. &lt;code&gt;Lambda&lt;/code&gt; 레이어는 간단한 작업이나 빠른 실험에 가장 적합합니다. 고급 쓰임새를 들어, 다음과 &lt;a href=&quot;https://www.tensorflow.org/guide/keras/custom_layers_and_models&quot;&gt;이 가이드&lt;/a&gt; 서브 클래스에 대한 &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;tf.keras.layers.Layer&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="12b734c9cea4d788668e7d42b41afdea642fee23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinearOperatorIdentity&lt;/code&gt; is initialized with arguments defining &lt;code&gt;dtype&lt;/code&gt; and shape.</source>
          <target state="translated">&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; 는 인수가 정의로 초기화됩니다 &lt;code&gt;dtype&lt;/code&gt; 와 모양.</target>
        </trans-unit>
        <trans-unit id="d73311c5178545cf753217309588019e38f9d709" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt; is initialized with &lt;code&gt;num_rows&lt;/code&gt;, which determines the size of each identity matrix, and a &lt;code&gt;multiplier&lt;/code&gt;, which defines &lt;code&gt;dtype&lt;/code&gt;, batch shape, and scale of each matrix.</source>
          <target state="translated">&lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt; 가 초기화되는 &lt;code&gt;num_rows&lt;/code&gt; 각 행렬의 크기를 결정하고, &lt;code&gt;multiplier&lt;/code&gt; 정의하는 &lt;code&gt;dtype&lt;/code&gt; 각 행렬의 배치 형태 및 크기.</target>
        </trans-unit>
        <trans-unit id="b6a140a1c911bc07b4bf6bf40190ce8128dc1514" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LinearOperatorZeros&lt;/code&gt; is initialized with arguments defining &lt;code&gt;dtype&lt;/code&gt; and shape.</source>
          <target state="translated">&lt;code&gt;LinearOperatorZeros&lt;/code&gt; 는 인수가 정의로 초기화됩니다 &lt;code&gt;dtype&lt;/code&gt; 와 모양.</target>
        </trans-unit>
        <trans-unit id="b1f24df7eab694b0f1703da39cd73b8c86b688da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LocallyConnected1D&lt;/code&gt; layer works similarly to the &lt;code&gt;Conv1D&lt;/code&gt; layer, except that weights are unshared, that is, a different set of filters is applied at each different patch of the input.</source>
          <target state="translated">&lt;code&gt;LocallyConnected1D&lt;/code&gt; 의 계층은 비슷하게 작동 &lt;code&gt;Conv1D&lt;/code&gt; 필터의 다른 세트는 각각 다른 입력의 패치에 적용되는 가중치는 그 비공유이다 제외 층.</target>
        </trans-unit>
        <trans-unit id="70697b9bab37838191095266898ffadfd97d828c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LocallyConnected2D&lt;/code&gt; layer works similarly to the &lt;code&gt;Conv2D&lt;/code&gt; layer, except that weights are unshared, that is, a different set of filters is applied at each different patch of the input.</source>
          <target state="translated">&lt;code&gt;LocallyConnected2D&lt;/code&gt; 의 계층은 비슷하게 작동 &lt;code&gt;Conv2D&lt;/code&gt; 필터의 다른 세트는 각각 다른 입력의 패치에 적용되는 가중치는 그 비공유이다 제외 층.</target>
        </trans-unit>
        <trans-unit id="b8fa1143a320d647d8e801e00a58c7e05a50565b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LossScale&lt;/code&gt; instance associated with this optimizer.</source>
          <target state="translated">&lt;code&gt;LossScale&lt;/code&gt; 의 이 최적화와 관련된 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="98a41775ad95ce382b63a77e41954693dabb7a8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MetaGraphDef&lt;/code&gt; allows running the given graph via &lt;code&gt;saver.import_meta_graph()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;MetaGraphDef&lt;/code&gt; 을 통해 주어진 그래프를 실행 허용 &lt;code&gt;saver.import_meta_graph()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d513aeb35380001cdceb5f916046f228692a7e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MetaGraphDef&lt;/code&gt; protocol buffer loaded in the provided session. This can be used to further extract signature-defs, collection-defs, etc.</source>
          <target state="translated">&lt;code&gt;MetaGraphDef&lt;/code&gt; 에 제공된 세션에 로딩 프로토콜 버퍼. 시그니처 데프, 콜렉션 데프 등을 추가로 추출하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a898b11561ca53e71dbc4e0e1c53c10f9194a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MethodNameUpdater&lt;/code&gt; class provides the functionality to update the method name field in the signature_defs of the given SavedModel. For example, it can be used to replace the &lt;code&gt;predict&lt;/code&gt;&lt;code&gt;method_name&lt;/code&gt; to &lt;code&gt;regress&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;MethodNameUpdater&lt;/code&gt; class provides the functionality to update the method name field in the signature_defs of the given SavedModel. For example, it can be used to replace the &lt;code&gt;predict&lt;/code&gt; &lt;code&gt;method_name&lt;/code&gt; to &lt;code&gt;regress&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7d321601f5768b6abd214deca3a0d8d37c530ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Model&lt;/code&gt; these callbacks are used with.</source>
          <target state="translated">The &lt;code&gt;Model&lt;/code&gt; these callbacks are used with.</target>
        </trans-unit>
        <trans-unit id="cb465f350147752217292b36e4f6e8af3b681307" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NodeDef&lt;/code&gt; proto representing the op that failed.</source>
          <target state="translated">&lt;code&gt;NodeDef&lt;/code&gt; 의 실패 연산을 나타내는 프로토.</target>
        </trans-unit>
        <trans-unit id="ff313cdcfce21b44585ea5f9a91a7a3dc6de0178" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; objects on which this op has a control dependency.</source>
          <target state="translated">이 op에 제어 종속성이 있는 &lt;code&gt;Operation&lt;/code&gt; 개체</target>
        </trans-unit>
        <trans-unit id="87fc441eb7b6054082173c9f1ab6bf4c42c56cd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; of this variable.</source>
          <target state="translated">이 변수 의 &lt;code&gt;Operation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a9cda719e59cf9091cbf0d01fc46d4aaf72fff1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; that failed, or None.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 실패하지 않거나 아무도 그.</target>
        </trans-unit>
        <trans-unit id="438a9dc8c58e4a098826c43ea413784f9b3995d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; that produces &lt;code&gt;values&lt;/code&gt; as an output.</source>
          <target state="translated">출력으로 &lt;code&gt;values&lt;/code&gt; 을 생성 하는 &lt;code&gt;Operation&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="b9d068224c3abe35b7ed380528fe996c78ebd4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; that produces this tensor as an output.</source>
          <target state="translated">이 텐서를 출력으로 생성 하는 &lt;code&gt;Operation&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6f8ca71f67bffa4b0033f109d8e6e570e0590a7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; type to create. This corresponds to the &lt;code&gt;OpDef.name&lt;/code&gt; field for the proto that defines the operation.</source>
          <target state="translated">The &lt;code&gt;Operation&lt;/code&gt; type to create. This corresponds to the &lt;code&gt;OpDef.name&lt;/code&gt; field for the proto that defines the operation.</target>
        </trans-unit>
        <trans-unit id="05c1129e9d0be24dc0a8495f7e24b9eaf32d0723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Operation&lt;/code&gt; with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 주어진와 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae052b5d764dae51c83f77445f8c559127d647cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PhysicalDevice&lt;/code&gt; to configure.</source>
          <target state="translated">The &lt;code&gt;PhysicalDevice&lt;/code&gt; to configure.</target>
        </trans-unit>
        <trans-unit id="207e00a2d0ea7a2feedfe3c413469ac89cde7bb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;QueueRunner&lt;/code&gt;, combined with the &lt;code&gt;Coordinator&lt;/code&gt;, helps handle these issues.</source>
          <target state="translated">&lt;code&gt;QueueRunner&lt;/code&gt; 는 의와 결합 &lt;code&gt;Coordinator&lt;/code&gt; , 이러한 문제를 처리하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c6875e1876426bfecf07e4b4acdb8ea569eea6f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SavedModel&lt;/code&gt; contains:</source>
          <target state="translated">&lt;code&gt;SavedModel&lt;/code&gt; 에는 다음 이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6f4f2790a6a7f05dc0c928fcd21f48c92ded1ee8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SavedModel&lt;/code&gt; saved by the &lt;code&gt;export_saved_model&lt;/code&gt; method does not include the cluster centers. However, the cluster centers may be retrieved by the latest checkpoint saved during training. Specifically,</source>
          <target state="translated">&lt;code&gt;SavedModel&lt;/code&gt; 는 에 의해 저장 &lt;code&gt;export_saved_model&lt;/code&gt; 의 클러스터 센터를 포함하지 않는 방법. 그러나 훈련 중에 저장된 최신 체크 포인트로 클러스터 센터를 검색 할 수 있습니다. 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="e6039bfa2164055554cd488d18e16d9f34bf9b47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SavedModelBuilder&lt;/code&gt; class provides functionality to build a &lt;code&gt;SavedModel&lt;/code&gt; protocol buffer. Specifically, this allows multiple meta graphs to be saved as part of a single language-neutral &lt;code&gt;SavedModel&lt;/code&gt;, while sharing variables and assets.</source>
          <target state="translated">&lt;code&gt;SavedModelBuilder&lt;/code&gt; 의 클래스는 구축하는 기능 제공 &lt;code&gt;SavedModel&lt;/code&gt; 의 프로토콜 버퍼를. 특히 변수와 자산을 공유하면서 여러 메타 그래프를 단일 언어 중립 &lt;code&gt;SavedModel&lt;/code&gt; 의 일부로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd194d774bf843726a9b31fd8c5760738d54965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Saver&lt;/code&gt; class adds ops to save and restore variables to and from &lt;em&gt;checkpoints&lt;/em&gt;. It also provides convenience methods to run these ops.</source>
          <target state="translated">&lt;code&gt;Saver&lt;/code&gt; 클래스는 저장과에서 변수를 복원하기 위해 작전을 추가 &lt;em&gt;체크 포인트&lt;/em&gt; . 또한 이러한 작업을 실행하는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="20d59bb6bfa83ff7c6db0ed3d04afcb2605b70d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; can then be read out as part of a minibatch by passing the key as a vector element to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;. To ensure the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op. If no &lt;code&gt;shared_name&lt;/code&gt; is provided here, instead use the &lt;em&gt;name&lt;/em&gt; of the Operation created by calling &lt;code&gt;AddSparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;. Ensure the Operations are colocated.</source>
          <target state="translated">The &lt;code&gt;SparseTensor&lt;/code&gt; can then be read out as part of a minibatch by passing the key as a vector element to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt; . To ensure the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op. If no &lt;code&gt;shared_name&lt;/code&gt; is provided here, instead use the &lt;em&gt;name&lt;/em&gt; of the Operation created by calling &lt;code&gt;AddSparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt; . Ensure the Operations are colocated.</target>
        </trans-unit>
        <trans-unit id="e408353ec897db2100239f8ae8da9071b4cc1520" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; must have rank &lt;code&gt;R&lt;/code&gt; greater than 1, and the first dimension is treated as the minibatch dimension. Elements of the &lt;code&gt;SparseTensor&lt;/code&gt; must be sorted in increasing order of this first dimension. The serialized &lt;code&gt;SparseTensor&lt;/code&gt; objects going into each row of &lt;code&gt;serialized_sparse&lt;/code&gt; will have rank &lt;code&gt;R-1&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;SparseTensor&lt;/code&gt; must have rank &lt;code&gt;R&lt;/code&gt; greater than 1, and the first dimension is treated as the minibatch dimension. Elements of the &lt;code&gt;SparseTensor&lt;/code&gt; must be sorted in increasing order of this first dimension. The serialized &lt;code&gt;SparseTensor&lt;/code&gt; objects going into each row of &lt;code&gt;serialized_sparse&lt;/code&gt; will have rank &lt;code&gt;R-1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4996fa4000c885aea5b079a558bc6345b7b96a57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; must have rank &lt;code&gt;R&lt;/code&gt; greater than 1, and the first dimension is treated as the minibatch dimension. Elements of the &lt;code&gt;SparseTensor&lt;/code&gt; must be sorted in increasing order of this first dimension. The serialized &lt;code&gt;SparseTensor&lt;/code&gt; objects going into each row of the output &lt;code&gt;Tensor&lt;/code&gt; will have rank &lt;code&gt;R-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; 는 랭크 있어야 &lt;code&gt;R&lt;/code&gt; 에 1보다 큰를, 제 1 차원은 minibatch 차원으로 처리한다. &lt;code&gt;SparseTensor&lt;/code&gt; 의 요소는 이 첫 번째 차원의 순서대로 정렬되어야합니다. 출력 &lt;code&gt;Tensor&lt;/code&gt; 의 각 행으로 들어가는 직렬화 된 &lt;code&gt;SparseTensor&lt;/code&gt; 오브젝트 는 &lt;code&gt;R-1&lt;/code&gt; 등급을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="b42219c4a7badee8ff4052cb167c2aad9136d9f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; returned by this function has the following properties:</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; 이 함수에 의해 반환에는 다음과 같은 속성이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="49917282a350971323ae841c4b9d435ada931dad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; to split.</source>
          <target state="translated">The &lt;code&gt;SparseTensor&lt;/code&gt; to split.</target>
        </trans-unit>
        <trans-unit id="947dab0c26a3057863d288f8b9978fb1f8fac21a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt; values can then be read out as part of a minibatch by passing the given keys as vector elements to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;. To ensure the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op. If no &lt;code&gt;shared_name&lt;/code&gt; is provided here, instead use the &lt;em&gt;name&lt;/em&gt; of the Operation created by calling &lt;code&gt;AddManySparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt;. Ensure the Operations are colocated.</source>
          <target state="translated">The &lt;code&gt;SparseTensor&lt;/code&gt; values can then be read out as part of a minibatch by passing the given keys as vector elements to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt; . To ensure the correct &lt;code&gt;SparseTensorsMap&lt;/code&gt; is accessed, ensure that the same &lt;code&gt;container&lt;/code&gt; and &lt;code&gt;shared_name&lt;/code&gt; are passed to that Op. If no &lt;code&gt;shared_name&lt;/code&gt; is provided here, instead use the &lt;em&gt;name&lt;/em&gt; of the Operation created by calling &lt;code&gt;AddManySparseToTensorsMap&lt;/code&gt; as the &lt;code&gt;shared_name&lt;/code&gt; passed to &lt;code&gt;TakeManySparseFromTensorsMap&lt;/code&gt; . Ensure the Operations are colocated.</target>
        </trans-unit>
        <trans-unit id="ef8d47ae2cffd6a60717723743196db2da48e873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb84d767bf36de5116c226d433a45472c3fcd908" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tensor&lt;/code&gt; from which to gather values. Must be at least rank &lt;code&gt;axis + 1&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;Tensor&lt;/code&gt; from which to gather values. Must be at least rank &lt;code&gt;axis + 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61a9703a7b332edaa3d2a56d6128abb09ee039b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;Operation&lt;/code&gt; in the Graph corresponding to &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 해당하는 그래프 의 &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;Operation&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="f6be4cc7d313052cfc6d80dad203087d37153e51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tensor&lt;/code&gt; to convert. Must have rank &lt;code&gt;ragged_rank + 1&lt;/code&gt; or higher.</source>
          <target state="translated">The &lt;code&gt;Tensor&lt;/code&gt; to convert. Must have rank &lt;code&gt;ragged_rank + 1&lt;/code&gt; or higher.</target>
        </trans-unit>
        <trans-unit id="4d80dc3d5783767a6f128de252a3040fe80eada2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tensor&lt;/code&gt; to split.</source>
          <target state="translated">The &lt;code&gt;Tensor&lt;/code&gt; to split.</target>
        </trans-unit>
        <trans-unit id="21aeac68c332c23a4035410d874f4d643b5e9753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Tensor&lt;/code&gt; with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; 주어진와 &lt;code&gt;name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="062bc5ef63073ebe0bba42c69dd60fbbac0ba11a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TensorShape&lt;/code&gt; of this variable.</source>
          <target state="translated">이 변수 의 &lt;code&gt;TensorShape&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d5f495d7cfc5ed68324d2dab206b4e7d15c1c2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Variable()&lt;/code&gt; constructor requires an initial value for the variable, which can be a &lt;code&gt;Tensor&lt;/code&gt; of any type and shape. The initial value defines the type and shape of the variable. After construction, the type and shape of the variable are fixed. The value can be changed using one of the assign methods.</source>
          <target state="translated">&lt;code&gt;Variable()&lt;/code&gt; 생성자는 될 수있는 변수의 초기 값이 있어야 &lt;code&gt;Tensor&lt;/code&gt; 모든 유형 및 형상을. 초기 값은 변수의 유형과 모양을 정의합니다. 시공 후 변수의 유형과 모양이 고정됩니다. assign 메소드 중 하나를 사용하여 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1083cab47ab61c7cdda4d83367b338d6c7e04350" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Variable()&lt;/code&gt; constructor requires an initial value for the variable, which can be a &lt;code&gt;Tensor&lt;/code&gt; of any type and shape. This initial value defines the type and shape of the variable. After construction, the type and shape of the variable are fixed. The value can be changed using one of the assign methods.</source>
          <target state="translated">&lt;code&gt;Variable()&lt;/code&gt; 생성자는 될 수있는 변수의 초기 값이 있어야 &lt;code&gt;Tensor&lt;/code&gt; 모든 유형 및 형상을. 이 초기 값은 변수의 유형과 모양을 정의합니다. 시공 후 변수의 유형과 모양이 고정됩니다. assign 메소드 중 하나를 사용하여 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="127a5eff8bb10c7a9751d8d922f006229b0755c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Variable&lt;/code&gt; for the slot if it was created, &lt;code&gt;None&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;Variable&lt;/code&gt; 슬롯에 대한이 생성 된 경우, &lt;code&gt;None&lt;/code&gt; , 그렇지.</target>
        </trans-unit>
        <trans-unit id="368fe6644a57bbac64f15832c728e327af009d67" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Vocabulary&lt;/code&gt; object will performs the following mapping:</source>
          <target state="translated">&lt;code&gt;Vocabulary&lt;/code&gt; 객체는 다음 매핑을 수행합니다 :</target>
        </trans-unit>
        <trans-unit id="15c19d26fcfad74fc018f065f20a7fa6b9d26cfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;A @ X = RHS&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;X&lt;/code&gt; in &lt;code&gt;A @ X = RHS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="519c59ffc79a16af729e3142dd3abe9ca662d6c6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;accuracy&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the frequency with which &lt;code&gt;predictions&lt;/code&gt; matches &lt;code&gt;labels&lt;/code&gt;. This frequency is ultimately returned as &lt;code&gt;accuracy&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;accuracy&lt;/code&gt; 함수는 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 되는 빈도를 계산하는 데 사용되는 &lt;code&gt;predictions&lt;/code&gt; 일치하는 &lt;code&gt;labels&lt;/code&gt; . 이 주파수는 궁극적으로 반환된다 &lt;code&gt;accuracy&lt;/code&gt; : 단순히 분할가 멱등 동작 &lt;code&gt;total&lt;/code&gt; 로 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb05150efdb907d6c2345164aacf0bfaba0751c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply()&lt;/code&gt; method adds shadow copies of trained variables and add ops that maintain a moving average of the trained variables in their shadow copies. It is used when building the training model. The ops that maintain moving averages are typically run after each training step. The &lt;code&gt;average()&lt;/code&gt; and &lt;code&gt;average_name()&lt;/code&gt; methods give access to the shadow variables and their names. They are useful when building an evaluation model, or when restoring a model from a checkpoint file. They help use the moving averages in place of the last trained values for evaluations.</source>
          <target state="translated">&lt;code&gt;apply()&lt;/code&gt; 메소드는 훈련 변수의 섀도 복사본을 추가하고 자신의 섀도 복사본에 훈련 된 변수의 이동 평균을 유지 작전을 추가합니다. 훈련 모델을 만들 때 사용됩니다. 이동 평균을 유지하는 작전은 일반적으로 각 훈련 단계 후에 실행됩니다. &lt;code&gt;average()&lt;/code&gt; 및 &lt;code&gt;average_name()&lt;/code&gt; 메소드는 그림자 변수와 이름에 대한 액세스를 제공합니다. 평가 모델을 작성하거나 검사 점 파일에서 모델을 복원 할 때 유용합니다. 평가를 위해 마지막 훈련 된 값 대신 이동 평균을 사용하도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="606eed9ef4b94263c255e5099fa91bbc0424bdd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;apply()&lt;/code&gt; method has to be called to create shadow variables and add ops to maintain moving averages.</source>
          <target state="translated">&lt;code&gt;apply()&lt;/code&gt; 메소드는 이동 평균 유지 OPS 그림자 변수를 생성하고 추가 호출되어야한다.</target>
        </trans-unit>
        <trans-unit id="fc2517e9824df1742df7d5a7c8c3c56a268719aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;auc&lt;/code&gt; function creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the AUC. To discretize the AUC curve, a linearly spaced set of thresholds is used to compute pairs of recall and precision values. The area under the ROC-curve is therefore computed using the height of the recall values by the false positive rate, while the area under the PR-curve is the computed using the height of the precision values by the recall.</source>
          <target state="translated">&lt;code&gt;auc&lt;/code&gt; 기능은 네 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; AUC를 계산하기 위해 사용된다. AUC 곡선을 이산화시키기 위해 선형 간격의 임계 값 세트를 사용하여 리콜 및 정밀 값 쌍을 계산합니다. 따라서 ROC- 커브 아래 영역은 리콜 값의 높이를 가양 성 비율로 사용하여 계산되는 반면 PR- 커브 아래 영역은 리콜에 의해 정밀도 값의 높이를 사용하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="3fa0a25f6b40ef6dcf6f6a5e64ed998f56659d5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bad_color&lt;/code&gt; argument is the color to use in the generated images for non-finite input values. It is a &lt;code&gt;uint8&lt;/code&gt; 1-D tensor of length &lt;code&gt;channels&lt;/code&gt;. Each element must be in the range &lt;code&gt;[0, 255]&lt;/code&gt; (It represents the value of a pixel in the output image). Non-finite values in the input tensor are replaced by this tensor in the output image. The default value is the color red.</source>
          <target state="translated">The &lt;code&gt;bad_color&lt;/code&gt; argument is the color to use in the generated images for non-finite input values. It is a &lt;code&gt;uint8&lt;/code&gt; 1-D tensor of length &lt;code&gt;channels&lt;/code&gt; . Each element must be in the range &lt;code&gt;[0, 255]&lt;/code&gt; (It represents the value of a pixel in the output image). Non-finite values in the input tensor are replaced by this tensor in the output image. The default value is the color red.</target>
        </trans-unit>
        <trans-unit id="8af58715c30e66d456c8d6905c0d5153fbdbbc7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;band&lt;/code&gt; part is computed as follows: Assume &lt;code&gt;input&lt;/code&gt; has &lt;code&gt;k&lt;/code&gt; dimensions &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt;, then the output is a tensor with the same shape where</source>
          <target state="translated">&lt;code&gt;band&lt;/code&gt; 다음 부분이 계산된다 가정 &lt;code&gt;input&lt;/code&gt; 갖는 &lt;code&gt;k&lt;/code&gt; 개의 치수 &lt;code&gt;[I, J, K, ..., M, N]&lt;/code&gt; , 그 출력이 동일한 형상을 가진 곳 텐서</target>
        </trans-unit>
        <trans-unit id="c1eb08b43ce7219e68f0c3bd3c76b2d17d8da595" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;branch_fns&lt;/code&gt; parameter is either a dict from &lt;code&gt;int&lt;/code&gt; to callables, or list of (&lt;code&gt;int&lt;/code&gt;, callable) pairs, or simply a list of callables (in which case the index is implicitly the key). The &lt;code&gt;branch_index&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; is used to select an element in &lt;code&gt;branch_fns&lt;/code&gt; with matching &lt;code&gt;int&lt;/code&gt; key, falling back to &lt;code&gt;default&lt;/code&gt; if none match, or &lt;code&gt;max(keys)&lt;/code&gt; if no &lt;code&gt;default&lt;/code&gt; is provided. The keys must form a contiguous set from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;len(branch_fns) - 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;branch_fns&lt;/code&gt; 의 파라미터는 하나의 딕셔너리이다 &lt;code&gt;int&lt;/code&gt; callables, 또는 (목록 &lt;code&gt;int&lt;/code&gt; , 호출) 쌍, 또는 단순히 (인덱스 키 암시되는 경우) callables 목록. &lt;code&gt;branch_index&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; 의 요소를 선택하는 데 사용됩니다 &lt;code&gt;branch_fns&lt;/code&gt; 일치와 &lt;code&gt;int&lt;/code&gt; 다시 떨어지는 키를 &lt;code&gt;default&lt;/code&gt; 경우 없음 일치, 또는 &lt;code&gt;max(keys)&lt;/code&gt; 어떤 경우 &lt;code&gt;default&lt;/code&gt; 제공되지 않습니다. 키는 &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;len(branch_fns) - 1&lt;/code&gt; 사이의 연속 세트를 형성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="191ea315ef50769cbc5f21b205a7c35e5f727b01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;capacity&lt;/code&gt; argument controls the how long the prefetching is allowed to grow the queues.</source>
          <target state="translated">&lt;code&gt;capacity&lt;/code&gt; 인수는 프리 페치가 큐 성장을 허용 얼마나 오래 제어합니다.</target>
        </trans-unit>
        <trans-unit id="90470bf7983fc786e9b2f478b52410df3cb933b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;compact&lt;/code&gt; format is recommended as the one with best performance. In case you need to cast a tensor into a compact format manually, use &lt;a href=&quot;../gather_nd&quot;&gt;&lt;code&gt;tf.gather_nd&lt;/code&gt;&lt;/a&gt;. An example for a tensor of shape [m, m]:</source>
          <target state="translated">&lt;code&gt;compact&lt;/code&gt; 형식은 최고의 성능과 하나로 좋습니다. 텐서를 컴팩트 형식으로 수동으로 캐스팅 해야하는 경우 &lt;a href=&quot;../gather_nd&quot;&gt; &lt;code&gt;tf.gather_nd&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 . 모양의 텐서 [m, m]의 예 :</target>
        </trans-unit>
        <trans-unit id="97f57a9366600ee779830b27b2d179f2f5db2b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;concentration&lt;/code&gt; represents mean total counts of class occurrence, i.e.,</source>
          <target state="translated">&lt;code&gt;concentration&lt;/code&gt; , 즉 클래스 발생의 평균 총 수를 나타냅니다</target>
        </trans-unit>
        <trans-unit id="9c6e5ba01c6a262d3caec134364aed5a4ee8d794" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; tensor acts as a mask that chooses whether the corresponding element / row in the output should be taken from &lt;code&gt;x&lt;/code&gt; (if the element in &lt;code&gt;condition is True) or&lt;/code&gt;y` (if it is false).</source>
          <target state="translated">The &lt;code&gt;condition&lt;/code&gt; tensor acts as a mask that chooses whether the corresponding element / row in the output should be taken from &lt;code&gt;x&lt;/code&gt; (if the element in &lt;code&gt;condition is True) or&lt;/code&gt; y` (if it is false).</target>
        </trans-unit>
        <trans-unit id="01ab58045b90ae07778088607a3eab393fc1bb6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; tensor acts as a mask that chooses, based on the value at each element, whether the corresponding element / row in the output should be taken from &lt;code&gt;x&lt;/code&gt; (if true) or &lt;code&gt;y&lt;/code&gt; (if false).</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 텐서는 각 요소의 값에 기초하여 선택한다면가 출력 내의 대응하는 요소 / 행에서 수행되어야하는지 여부 것을 마스크로서 역할을 &lt;code&gt;x&lt;/code&gt; (true 인 경우), 또는 &lt;code&gt;y&lt;/code&gt; (FALSE 경우).</target>
        </trans-unit>
        <trans-unit id="facc94a32b1104f4cf40a2df2cff62adde7bf05f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalars. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are vectors or higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a scalar, a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt;, or must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalars. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are vectors or higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a scalar, a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt; , or must have the same shape as &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9bfb9121150515c59120455c6322fe9bdac07ae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; argument can be passed &lt;a href=&quot;../../../estimator/runconfig&quot;&gt;&lt;code&gt;tf.estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object containing information about the execution environment. It is passed on to the &lt;code&gt;model_fn&lt;/code&gt;, if the &lt;code&gt;model_fn&lt;/code&gt; has a parameter named &quot;config&quot; (and input functions in the same manner). If the &lt;code&gt;config&lt;/code&gt; parameter is not passed, it is instantiated by the &lt;code&gt;Estimator&lt;/code&gt;. Not passing config means that defaults useful for local execution are used. &lt;code&gt;Estimator&lt;/code&gt; makes config available to the model (for instance, to allow specialization based on the number of workers available), and also uses some of its fields to control internals, especially regarding checkpointing.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 인수는 전달 될 수 &lt;a href=&quot;../../../estimator/runconfig&quot;&gt; &lt;code&gt;tf.estimator.RunConfig&lt;/code&gt; 의&lt;/a&gt; 실행 환경에 대한 정보가 포함 된 개체를. 그것은에 전달 &lt;code&gt;model_fn&lt;/code&gt; 경우 &lt;code&gt;model_fn&lt;/code&gt; 는 &quot;구성&quot;(동일하게 입력 기능)라는 매개 변수를 갖는다. 는 IF &lt;code&gt;config&lt;/code&gt; 매개 변수가 전달되지 않으며, 그것은에 의해 인스턴스화 &lt;code&gt;Estimator&lt;/code&gt; . 구성을 전달하지 않으면 로컬 실행에 유용한 기본값이 사용됩니다. &lt;code&gt;Estimator&lt;/code&gt; 는 모델에 구성을 사용할 수있게하며 (예 : 사용 가능한 작업자 수에 따른 특수화 허용) 일부 필드를 사용하여 내부, 특히 검사 점 지정을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0bec4775822937a50bbd9f3cbf347be8160f7726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config&lt;/code&gt; argument can be passed &lt;a href=&quot;runconfig&quot;&gt;&lt;code&gt;tf.estimator.RunConfig&lt;/code&gt;&lt;/a&gt; object containing information about the execution environment. It is passed on to the &lt;code&gt;model_fn&lt;/code&gt;, if the &lt;code&gt;model_fn&lt;/code&gt; has a parameter named &quot;config&quot; (and input functions in the same manner). If the &lt;code&gt;config&lt;/code&gt; parameter is not passed, it is instantiated by the &lt;code&gt;Estimator&lt;/code&gt;. Not passing config means that defaults useful for local execution are used. &lt;code&gt;Estimator&lt;/code&gt; makes config available to the model (for instance, to allow specialization based on the number of workers available), and also uses some of its fields to control internals, especially regarding checkpointing.</source>
          <target state="translated">&lt;code&gt;config&lt;/code&gt; 인수는 전달 될 수 &lt;a href=&quot;runconfig&quot;&gt; &lt;code&gt;tf.estimator.RunConfig&lt;/code&gt; 의&lt;/a&gt; 실행 환경에 대한 정보가 포함 된 개체를. 그것은에 전달 &lt;code&gt;model_fn&lt;/code&gt; 경우 &lt;code&gt;model_fn&lt;/code&gt; 는 &quot;구성&quot;(동일하게 입력 기능)라는 매개 변수를 갖는다. 는 IF &lt;code&gt;config&lt;/code&gt; 매개 변수가 전달되지 않으며, 그것은에 의해 인스턴스화 &lt;code&gt;Estimator&lt;/code&gt; . 구성을 전달하지 않으면 로컬 실행에 유용한 기본값이 사용됩니다. &lt;code&gt;Estimator&lt;/code&gt; 는 모델에 구성을 사용할 수있게하며 (예 : 사용 가능한 작업자 수에 따른 특수화 허용) 일부 필드를 사용하여 내부, 특히 검사 점 지정을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0aeca4b97eca00ef17635cebe947fcd9da586a15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context_features&lt;/code&gt; keys are associated with a &lt;code&gt;SequenceExample&lt;/code&gt; as a whole, independent of time / frame. In contrast, the &lt;code&gt;sequence_features&lt;/code&gt; keys provide a way to access variable-length data within the &lt;code&gt;FeatureList&lt;/code&gt; section of the &lt;code&gt;SequenceExample&lt;/code&gt; proto. While the shapes of &lt;code&gt;context_features&lt;/code&gt; values are fixed with respect to frame, the frame dimension (the first dimension) of &lt;code&gt;sequence_features&lt;/code&gt; values may vary between &lt;code&gt;SequenceExample&lt;/code&gt; protos, and even between &lt;code&gt;feature_list&lt;/code&gt; keys within the same &lt;code&gt;SequenceExample&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;context_features&lt;/code&gt; 의 키는와 연관된 &lt;code&gt;SequenceExample&lt;/code&gt; 시간 / 프레임의 전체 독립적있다. 반대로 &lt;code&gt;sequence_features&lt;/code&gt; 키 는 &lt;code&gt;SequenceExample&lt;/code&gt; 프로토 타입 의 &lt;code&gt;FeatureList&lt;/code&gt; 섹션 내에서 가변 길이 데이터에 액세스하는 방법을 제공합니다 . &lt;code&gt;context_features&lt;/code&gt; 값 의 모양은 프레임에 대해 고정되어 있지만 &lt;code&gt;sequence_features&lt;/code&gt; 값 의 프레임 차원 (첫 번째 차원)은 &lt;code&gt;SequenceExample&lt;/code&gt; 프로토 타입 간에 , 심지어 동일한 &lt;code&gt;SequenceExample&lt;/code&gt; 내의 &lt;code&gt;feature_list&lt;/code&gt; 키 간에도 달라질 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1682e2f681183d97e2a0110f16b4f60410e0df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;coord&lt;/code&gt; argument is an optional coordinator that the threads will use to terminate together and report exceptions. If a coordinator is given, this method starts an additional thread to close the queue when the coordinator requests a stop.</source>
          <target state="translated">&lt;code&gt;coord&lt;/code&gt; 인수는 스레드가 함께 종료하고 예외를보고하는 데 사용할 옵션 코디네이터입니다. 코디네이터가 제공되면이 메소드는 코디네이터가 중지를 요청할 때 큐를 닫기 위해 추가 스레드를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="79d54183b850ac8c8ff0b7cfd536e56b95627d32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cycle_length&lt;/code&gt; and &lt;code&gt;block_length&lt;/code&gt; arguments control the order in which elements are produced. &lt;code&gt;cycle_length&lt;/code&gt; controls the number of input elements that are processed concurrently. If you set &lt;code&gt;cycle_length&lt;/code&gt; to 1, this transformation will handle one input element at a time, and will produce identical results to &lt;a href=&quot;../../../../data/dataset#flat_map&quot;&gt;&lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt;&lt;/a&gt;. In general, this transformation will apply &lt;code&gt;map_func&lt;/code&gt; to &lt;code&gt;cycle_length&lt;/code&gt; input elements, open iterators on the returned &lt;code&gt;Dataset&lt;/code&gt; objects, and cycle through them producing &lt;code&gt;block_length&lt;/code&gt; consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</source>
          <target state="translated">&lt;code&gt;cycle_length&lt;/code&gt; 및 &lt;code&gt;block_length&lt;/code&gt; 의 인수 소자를 제작하는 순서를 제어한다. &lt;code&gt;cycle_length&lt;/code&gt; 는 동시에 처리되는 입력 요소 수를 제어합니다. &lt;code&gt;cycle_length&lt;/code&gt; 를 1로 설정하면 이 변환은 한 번에 하나의 입력 요소를 처리하고 &lt;a href=&quot;../../../../data/dataset#flat_map&quot;&gt; &lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt; &lt;/a&gt; 과 동일한 결과를 생성합니다 . 일반적으로이 변환은 &lt;code&gt;map_func&lt;/code&gt; 를 &lt;code&gt;cycle_length&lt;/code&gt; 입력 요소에 적용 하고 반환 된 &lt;code&gt;Dataset&lt;/code&gt; 객체에서 반복자를 연 &lt;code&gt;block_length&lt;/code&gt; 를다음 각 반복자에서 연속 요소를 생성 하고 반복자의 끝에 도달 할 때마다 다음 입력 요소를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="ee978764731ae2547628b468794cefc836bc4795" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cycle_length&lt;/code&gt; and &lt;code&gt;block_length&lt;/code&gt; arguments control the order in which elements are produced. &lt;code&gt;cycle_length&lt;/code&gt; controls the number of input elements that are processed concurrently. If you set &lt;code&gt;cycle_length&lt;/code&gt; to 1, this transformation will handle one input element at a time, and will produce identical results to &lt;a href=&quot;../../../data/dataset#flat_map&quot;&gt;&lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt;&lt;/a&gt;. In general, this transformation will apply &lt;code&gt;map_func&lt;/code&gt; to &lt;code&gt;cycle_length&lt;/code&gt; input elements, open iterators on the returned &lt;code&gt;Dataset&lt;/code&gt; objects, and cycle through them producing &lt;code&gt;block_length&lt;/code&gt; consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</source>
          <target state="translated">&lt;code&gt;cycle_length&lt;/code&gt; 및 &lt;code&gt;block_length&lt;/code&gt; 의 인수 소자를 제작하는 순서를 제어한다. &lt;code&gt;cycle_length&lt;/code&gt; 는 동시에 처리되는 입력 요소 수를 제어합니다. &lt;code&gt;cycle_length&lt;/code&gt; 를 1로 설정하면 이 변환은 한 번에 하나의 입력 요소를 처리하고 &lt;a href=&quot;../../../data/dataset#flat_map&quot;&gt; &lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt; &lt;/a&gt; 과 동일한 결과를 생성합니다 . 일반적으로이 변환은 &lt;code&gt;map_func&lt;/code&gt; 를 &lt;code&gt;cycle_length&lt;/code&gt; 입력 요소에 적용 하고 반환 된 &lt;code&gt;Dataset&lt;/code&gt; 객체에서 반복자를 연 다음이를 순환하여 &lt;code&gt;block_length&lt;/code&gt; 를 생성합니다. 각 반복자에서 연속 요소를 반복하고 반복자 끝에 도달 할 때마다 다음 입력 요소를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="04f48577e80fcfb603fa15b3b9e05181dd539f9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cycle_length&lt;/code&gt; and &lt;code&gt;block_length&lt;/code&gt; arguments control the order in which elements are produced. &lt;code&gt;cycle_length&lt;/code&gt; controls the number of input elements that are processed concurrently. If you set &lt;code&gt;cycle_length&lt;/code&gt; to 1, this transformation will handle one input element at a time, and will produce identical results to &lt;a href=&quot;../dataset#flat_map&quot;&gt;&lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt;&lt;/a&gt;. In general, this transformation will apply &lt;code&gt;map_func&lt;/code&gt; to &lt;code&gt;cycle_length&lt;/code&gt; input elements, open iterators on the returned &lt;code&gt;Dataset&lt;/code&gt; objects, and cycle through them producing &lt;code&gt;block_length&lt;/code&gt; consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</source>
          <target state="translated">&lt;code&gt;cycle_length&lt;/code&gt; 및 &lt;code&gt;block_length&lt;/code&gt; 의 인수 소자를 제작하는 순서를 제어한다. &lt;code&gt;cycle_length&lt;/code&gt; 는 동시에 처리되는 입력 요소 수를 제어합니다. &lt;code&gt;cycle_length&lt;/code&gt; 를 1로 설정하면 이 변환은 한 번에 하나의 입력 요소를 처리하고 &lt;a href=&quot;../dataset#flat_map&quot;&gt; &lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt; &lt;/a&gt; 과 동일한 결과를 생성합니다 . 일반적으로이 변환은 &lt;code&gt;map_func&lt;/code&gt; 를 &lt;code&gt;cycle_length&lt;/code&gt; 입력 요소에 적용 하고 반환 된 &lt;code&gt;Dataset&lt;/code&gt; 객체에서 반복자를 연 다음이를 순환하여 &lt;code&gt;block_length&lt;/code&gt; 를 생성합니다. 각 반복자에서 연속 요소를 반복하고 반복자 끝에 도달 할 때마다 다음 입력 요소를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="eccbe3ff90cfb1e82cccca44957962bdd5ce30cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cycle_length&lt;/code&gt; and &lt;code&gt;block_length&lt;/code&gt; arguments control the order in which elements are produced. &lt;code&gt;cycle_length&lt;/code&gt; controls the number of input elements that are processed concurrently. If you set &lt;code&gt;cycle_length&lt;/code&gt; to 1, this transformation will handle one input element at a time, and will produce identical results to &lt;a href=&quot;dataset#flat_map&quot;&gt;&lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt;&lt;/a&gt;. In general, this transformation will apply &lt;code&gt;map_func&lt;/code&gt; to &lt;code&gt;cycle_length&lt;/code&gt; input elements, open iterators on the returned &lt;code&gt;Dataset&lt;/code&gt; objects, and cycle through them producing &lt;code&gt;block_length&lt;/code&gt; consecutive elements from each iterator, and consuming the next input element each time it reaches the end of an iterator.</source>
          <target state="translated">&lt;code&gt;cycle_length&lt;/code&gt; 및 &lt;code&gt;block_length&lt;/code&gt; 의 인수 소자를 제작하는 순서를 제어한다. &lt;code&gt;cycle_length&lt;/code&gt; 는 동시에 처리되는 입력 요소 수를 제어합니다. &lt;code&gt;cycle_length&lt;/code&gt; 를 1로 설정하면 이 변환은 한 번에 하나의 입력 요소를 처리하고 &lt;a href=&quot;dataset#flat_map&quot;&gt; &lt;code&gt;tf.data.Dataset.flat_map&lt;/code&gt; &lt;/a&gt; 과 동일한 결과를 생성합니다 . 일반적으로이 변환은 &lt;code&gt;map_func&lt;/code&gt; 를 &lt;code&gt;cycle_length&lt;/code&gt; 입력 요소에 적용 하고 반환 된 &lt;code&gt;Dataset&lt;/code&gt; 객체에서 반복자를 연 다음이를 순환하여 &lt;code&gt;block_length&lt;/code&gt; 를 생성합니다. 각 반복자에서 연속 요소를 반복하고 반복자 끝에 도달 할 때마다 다음 입력 요소를 소비합니다.</target>
        </trans-unit>
        <trans-unit id="cdd71fb6bd2b9b57b19cddd99579978c6dafa2a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;data_format&lt;/code&gt; attr specifies the layout of the input and output tensors with the following options: &quot;NHWC&quot;: &lt;code&gt;[ batch, height, width, channels ]&lt;/code&gt; &quot;NCHW&quot;: &lt;code&gt;[ batch, channels, height, width ]&lt;/code&gt; &quot;NCHW_VECT_C&quot;: &lt;code&gt;qint8 [ batch, channels / 4, height, width, 4 ]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; 의 ATTR의 지정은 다음 옵션 입출력 텐서의 레이아웃 &quot;NHWC&quot; &lt;code&gt;[ batch, height, width, channels ]&lt;/code&gt; &quot;NCHW&quot; &lt;code&gt;[ batch, channels, height, width ]&lt;/code&gt; &quot;NCHW_VECT_C&quot; &lt;code&gt;qint8 [ batch, channels / 4, height, width, 4 ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf61f37ebe9cd16d3f414cb7f7236218bfbaff74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed.</source>
          <target state="translated">The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; &lt;/a&gt; instance where information about batching and input replication can be accessed.</target>
        </trans-unit>
        <trans-unit id="5cd12fa44d77e3c12fe697b0db4b93e48339e374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed:</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; 는 해야 &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 복제에 대한 정보를 액세스 할 수있는 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="9df9bee262df9fe514f64dc1a1738a7cc92c1df5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed.</source>
          <target state="translated">The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; &lt;/a&gt; instance where information about batching and input replication can be accessed.</target>
        </trans-unit>
        <trans-unit id="0e86d0834b58ce3b47a884a1d468afe9d9201946" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed:</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; 는 해야 &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 복제에 대한 정보를 액세스 할 수있는 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="dab43a435b361f56a83a42c04da29fda060c86e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed.</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; 는 해야 &lt;a href=&quot;../inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 복제에 대한 정보에 액세스 할 수 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="f7ca657c4395755383bc81fcb9f2b453ce90db09" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;../inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed:</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; 는 해야 &lt;a href=&quot;../inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 복제에 대한 정보를 액세스 할 수있는 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="75909f06c6cc8457169ade05db9b253d9c1c919e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed.</source>
          <target state="translated">The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; &lt;/a&gt; instance where information about batching and input replication can be accessed.</target>
        </trans-unit>
        <trans-unit id="6fde1903f8238ad03f3998edc676b8256c4d75c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dataset_fn&lt;/code&gt; should take an &lt;a href=&quot;inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; instance where information about batching and input replication can be accessed:</source>
          <target state="translated">&lt;code&gt;dataset_fn&lt;/code&gt; 는 해야 &lt;a href=&quot;inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 복제에 대한 정보를 액세스 할 수있는 인스턴스를 :</target>
        </trans-unit>
        <trans-unit id="f20e1c4521e0296106d88f47b84176329b10342a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decode_proto&lt;/code&gt; op extracts fields from a serialized protocol buffers message into tensors. The fields in &lt;code&gt;field_names&lt;/code&gt; are decoded and converted to the corresponding &lt;code&gt;output_types&lt;/code&gt; if possible.</source>
          <target state="translated">&lt;code&gt;decode_proto&lt;/code&gt; 의 영업 이익은 텐서에 직렬화 된 프로토콜 버퍼 메시지에서 필드를 추출합니다. &lt;code&gt;field_names&lt;/code&gt; 의 필드는 가능한 경우 디코딩되어 해당 &lt;code&gt;output_types&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="61bfd7600a5bc08577b34e4662502a0cb1a1a96f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;decorator_func&lt;/code&gt; argument with new metadata attached.</source>
          <target state="translated">&lt;code&gt;decorator_func&lt;/code&gt; 의 새로운 메타 데이터 인수 부착.</target>
        </trans-unit>
        <trans-unit id="a514f3a1501df389c97cb427fbd5d632c8c0d4a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;default_value&lt;/code&gt; is used for keys not present in the table.</source>
          <target state="translated">&lt;code&gt;default_value&lt;/code&gt; 테이블에 존재하지 않는 키에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f256cc69c0f762014c0c50a38e920065363cfb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;descriptor_source&lt;/code&gt; attribute selects the source of protocol descriptors to consult when looking up &lt;code&gt;message_type&lt;/code&gt;. This may be:</source>
          <target state="translated">&lt;code&gt;descriptor_source&lt;/code&gt; 를 찾는 경우 속성 선택 프로토콜 기술자의 소스는 상담 &lt;code&gt;message_type&lt;/code&gt; 을 . 이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a92bd94cb0af3355b6f29220671131a1d4a6adc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;device_name_or_function&lt;/code&gt; argument may either be a device name string, a device function, or None:</source>
          <target state="translated">&lt;code&gt;device_name_or_function&lt;/code&gt; 의 인수는 하나의 장치 이름 문자열, 디바이스 기능, 또는 유료 일 수있다 :</target>
        </trans-unit>
        <trans-unit id="537653ccd6821ffd71800f167aa318e3dcab8cd9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; of arguments to this operator. Default: &lt;code&gt;float32&lt;/code&gt;. Allowed dtypes: &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;dtype&lt;/code&gt; of arguments to this operator. Default: &lt;code&gt;float32&lt;/code&gt; . Allowed dtypes: &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e71cc421951f39f5835ed5689f2aee145d82f7db" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; of the serialized &lt;code&gt;SparseTensor&lt;/code&gt; objects.</source>
          <target state="translated">The &lt;code&gt;dtype&lt;/code&gt; of the serialized &lt;code&gt;SparseTensor&lt;/code&gt; objects.</target>
        </trans-unit>
        <trans-unit id="47ba9064da69708316fb10e82e7071f7b240dc2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; to use for serialization.</source>
          <target state="translated">The &lt;code&gt;dtype&lt;/code&gt; to use for serialization.</target>
        </trans-unit>
        <trans-unit id="19b121f477789a4199014186a6e228b0aa000947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enqueuer.get()&lt;/code&gt; should be an infinite stream of datas.</source>
          <target state="translated">&lt;code&gt;enqueuer.get()&lt;/code&gt; datas 무한 스트림이어야한다.</target>
        </trans-unit>
        <trans-unit id="ba25e9ca24f7a14bb1417a2fb32d4c4e26d77827" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;error_codes_pb2.Code&lt;/code&gt; describing the error.</source>
          <target state="translated">The &lt;code&gt;error_codes_pb2.Code&lt;/code&gt; describing the error.</target>
        </trans-unit>
        <trans-unit id="ae1bab6951216e7b0f3d9533c0fe4cef0e27a5dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetches&lt;/code&gt; argument may be a single graph element, or an arbitrarily nested list, tuple, namedtuple, dict, or OrderedDict containing graph elements at its leaves. A graph element can be one of the following types:</source>
          <target state="translated">&lt;code&gt;fetches&lt;/code&gt; 인수 그래프는 단일 요소 또는 임의로 중첩리스트 튜플 일 수 namedtuple 그 잎의 그래프 요소를 포함하는 딕셔너리 또는 OrderedDict. 그래프 요소는 다음 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785d7e8c57af0973369bcb00a38fc045b0c9ae7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;../../../../data/dataset#from_tensor_slices&quot;&gt;&lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt;&lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</source>
          <target state="translated">&lt;code&gt;file_pattern&lt;/code&gt; 인수는 글로브 패턴의 소수이어야한다. 파일 이름이 이미 파악 된 경우, 모든 파일 이름을 &lt;code&gt;list_files&lt;/code&gt; 로 다시 지정 하면 원격 스토리지 시스템의 성능이 저하 될 수 있으므로 &lt;a href=&quot;../../../../data/dataset#from_tensor_slices&quot;&gt; &lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae29332866e5bc8b9ee07b134fda5a738b8021d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;../../../data/dataset#from_tensor_slices&quot;&gt;&lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt;&lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</source>
          <target state="translated">&lt;code&gt;file_pattern&lt;/code&gt; 인수는 글로브 패턴의 소수이어야한다. 파일 이름이 이미 파악 된 경우, 모든 파일 이름을 &lt;code&gt;list_files&lt;/code&gt; 로 다시 지정 하면 원격 스토리지 시스템의 성능이 저하 될 수 있으므로 &lt;a href=&quot;../../../data/dataset#from_tensor_slices&quot;&gt; &lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3f18a1c227e50f0bcfa83536b4f1a61f14aca11e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;../dataset#from_tensor_slices&quot;&gt;&lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt;&lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</source>
          <target state="translated">&lt;code&gt;file_pattern&lt;/code&gt; 인수는 글로브 패턴의 소수이어야한다. 파일 이름이 이미 파악 된 경우, 모든 파일 이름을 &lt;code&gt;list_files&lt;/code&gt; 로 다시 지정 하면 원격 스토리지 시스템의 성능이 저하 될 수 있으므로 &lt;a href=&quot;../dataset#from_tensor_slices&quot;&gt; &lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a5d371bf05fee9ac34c79b3ecb1708c225ca7a5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;dataset#from_tensor_slices&quot;&gt;&lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt;&lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</source>
          <target state="translated">&lt;code&gt;file_pattern&lt;/code&gt; 인수는 글로브 패턴의 소수이어야한다. 파일 이름이 이미 파악 된 경우, 모든 파일 이름을 &lt;code&gt;list_files&lt;/code&gt; 로 다시 지정 하면 원격 스토리지 시스템의 성능이 저하 될 수 있으므로 &lt;a href=&quot;dataset#from_tensor_slices&quot;&gt; &lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt; &lt;/a&gt; 대신 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f25ee43478700a03ff3a05bac5462d710345efcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_tensor_slices&quot;&gt;&lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt;&lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</source>
          <target state="translated">The &lt;code&gt;file_pattern&lt;/code&gt; argument should be a small number of glob patterns. If your filenames have already been globbed, use &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_tensor_slices&quot;&gt; &lt;code&gt;Dataset.from_tensor_slices(filenames)&lt;/code&gt; &lt;/a&gt; instead, as re-globbing every filename with &lt;code&gt;list_files&lt;/code&gt; may result in poor performance with remote storage systems.</target>
        </trans-unit>
        <trans-unit id="ae4fe9c389bd86de17fd613b2cb617cf5b34971a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;generator&lt;/code&gt; argument must be a callable object that returns an object that supports the &lt;code&gt;iter()&lt;/code&gt; protocol (e.g. a generator function). The elements generated by &lt;code&gt;generator&lt;/code&gt; must be compatible with the given &lt;code&gt;output_types&lt;/code&gt; and (optional) &lt;code&gt;output_shapes&lt;/code&gt; arguments.</source>
          <target state="translated">&lt;code&gt;generator&lt;/code&gt; 인수는 호출 객체 여야가 반환 객체가 지원하는 &lt;code&gt;iter()&lt;/code&gt; 프로토콜 (예 : 발전기 기능). &lt;code&gt;generator&lt;/code&gt; 가 생성 한 요소 는 주어진 &lt;code&gt;output_types&lt;/code&gt; 및 (선택적) &lt;code&gt;output_shapes&lt;/code&gt; 인수 와 호환 가능해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d34ef9051018aee7b571f4ddcf30ab7cfc4276af" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_losses_for&lt;/code&gt; method allows to retrieve the losses relevant to a specific set of inputs.</source>
          <target state="translated">&lt;code&gt;get_losses_for&lt;/code&gt; 방법은 입력들의 특정 세트에 관련된 손실을 가져올 수있다.</target>
        </trans-unit>
        <trans-unit id="c06d13d8339819e2aa27ef381a46e85c67ddba64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_updates_for&lt;/code&gt; method allows to retrieve the updates relevant to a specific set of inputs.</source>
          <target state="translated">&lt;code&gt;get_updates_for&lt;/code&gt; 방법은 입력의 특정 세트에 관련 업데이트를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b891813820eae94e521e3bee74123211ca55a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identifier&lt;/code&gt; may be the string name of a loss function or &lt;code&gt;Loss&lt;/code&gt; class.</source>
          <target state="translated">The &lt;code&gt;identifier&lt;/code&gt; may be the string name of a loss function or &lt;code&gt;Loss&lt;/code&gt; class.</target>
        </trans-unit>
        <trans-unit id="180e3dd70a4fcebb6b3fd2497d1a388123d7f672" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;identifier&lt;/code&gt; may be the string name of a metric function or class.</source>
          <target state="translated">The &lt;code&gt;identifier&lt;/code&gt; may be the string name of a metric function or class.</target>
        </trans-unit>
        <trans-unit id="ec9647e5e43640fc561f86326ed66d7b1839d523" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ignore_longer_outputs_than_inputs&lt;/code&gt; option allows to specify the behavior of the CTCLoss when dealing with sequences that have longer outputs than inputs. If true, the CTCLoss will simply return zero gradient for those items, otherwise an InvalidArgument error is returned, stopping training.</source>
          <target state="translated">&lt;code&gt;ignore_longer_outputs_than_inputs&lt;/code&gt; 옵션은 입력 이상 출력이 시퀀스를 처리 할 때 CTCLoss의 동작을 지정할 수 있습니다. true 인 경우 CTCLoss는 해당 항목에 대해 단순히 0 그라데이션을 반환합니다. 그렇지 않으면 InvalidArgument 오류가 반환되어 교육이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="3e77ea3b32e4a62532979c99f1006fa100924b5f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indices&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, and &lt;code&gt;shapes&lt;/code&gt; lists must have the same length.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; , &lt;code&gt;values&lt;/code&gt; 및 &lt;code&gt;shapes&lt;/code&gt; 목록은 같은 길이가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="8cca3019d062a9892e2676ec309dbc9e2a90d317" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input&lt;/code&gt; tensor has shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; and the &lt;code&gt;filter&lt;/code&gt; tensor has shape &lt;code&gt;[filter_height, filter_width, depth]&lt;/code&gt;, i.e., each input channel is processed independently of the others with its own structuring function. The &lt;code&gt;output&lt;/code&gt; tensor has shape &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt;. The spatial dimensions of the output tensor depend on the &lt;code&gt;padding&lt;/code&gt; algorithm. We currently only support the default &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; 상기 &lt;code&gt;filter&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[filter_height, filter_width, depth]&lt;/code&gt; 즉, 각각의 입력 채널이 독립적으로 자신의 구조 기능 다른 것의 처리된다. &lt;code&gt;output&lt;/code&gt; 텐서는 형상을 갖고 &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt; . 출력 텐서의 공간 치수는 &lt;code&gt;padding&lt;/code&gt; 알고리즘 에 따라 다릅니다 . 현재 기본 &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e66cb3e17296e0dbd7031b533b7074c9bfdfef6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input&lt;/code&gt; tensor has shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; and the &lt;code&gt;filters&lt;/code&gt; tensor has shape &lt;code&gt;[filter_height, filter_width, depth]&lt;/code&gt;, i.e., each input channel is processed independently of the others with its own structuring function. The &lt;code&gt;output&lt;/code&gt; tensor has shape &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt;. The spatial dimensions of the output tensor depend on the &lt;code&gt;padding&lt;/code&gt; algorithm. We currently only support the default &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; 및 &lt;code&gt;filters&lt;/code&gt; 형상을 갖는다 텐서 &lt;code&gt;[filter_height, filter_width, depth]&lt;/code&gt; 즉, 각각의 입력 채널이 독립적으로 자신의 구조 기능 다른 것의 처리된다. &lt;code&gt;output&lt;/code&gt; 텐서는 형상을 갖는 &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt; . 출력 텐서의 공간 치수는 &lt;code&gt;padding&lt;/code&gt; 알고리즘 에 따라 다릅니다 . 현재 기본 &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="e9d4ca3ee4fe9c49bd0cf7e45805bfee3864ac7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input&lt;/code&gt; tensor may have rank &lt;code&gt;4&lt;/code&gt; or higher, where shape dimensions &lt;code&gt;[:-3]&lt;/code&gt; are considered batch dimensions (&lt;code&gt;batch_shape&lt;/code&gt;).</source>
          <target state="translated">The &lt;code&gt;input&lt;/code&gt; tensor may have rank &lt;code&gt;4&lt;/code&gt; or higher, where shape dimensions &lt;code&gt;[:-3]&lt;/code&gt; are considered batch dimensions ( &lt;code&gt;batch_shape&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="17d78b23014241429cebda7a7ed18dd11ac18169" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; object where information about batching and input sharding can be accessed:</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; 해야 &lt;a href=&quot;../../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 샤딩에 대한 정보에 액세스 할 수있는 개체를 :</target>
        </trans-unit>
        <trans-unit id="5a7667b672c0fb6a912c80d541aa0d63d101f97d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;input_fn&lt;/code&gt; should take an &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt;&lt;code&gt;tf.distribute.InputContext&lt;/code&gt;&lt;/a&gt; object where information about batching and input sharding can be accessed:</source>
          <target state="translated">&lt;code&gt;input_fn&lt;/code&gt; 해야 &lt;a href=&quot;../../../distribute/inputcontext&quot;&gt; &lt;code&gt;tf.distribute.InputContext&lt;/code&gt; 의&lt;/a&gt; 배치 및 입력 샤딩에 대한 정보에 액세스 할 수있는 개체를 :</target>
        </trans-unit>
        <trans-unit id="659e1fc33dd53c3ed2709a794415182888957e1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inputs&lt;/code&gt; Tensor's innermost dimension size, &lt;code&gt;num_classes&lt;/code&gt;, represents &lt;code&gt;num_labels + 1&lt;/code&gt; classes, where num_labels is the number of true labels, and the largest value &lt;code&gt;(num_classes - 1)&lt;/code&gt; is reserved for the blank label.</source>
          <target state="translated">&lt;code&gt;inputs&lt;/code&gt; 텐서의 안쪽 치수 크기, &lt;code&gt;num_classes&lt;/code&gt; 을 나타냅니다 &lt;code&gt;num_labels + 1&lt;/code&gt; num_labels 사실 라벨의 수 및 최대 값이고, 클래스 &lt;code&gt;(num_classes - 1)&lt;/code&gt; 빈 레이블이 예약되어가.</target>
        </trans-unit>
        <trans-unit id="52852cb960e86780103624fe955f152ef384049d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;job_name&lt;/code&gt; argument allows jobs to be shared across multiple datasets. Instead of each dataset creating its own job, all datasets with the same &lt;code&gt;job_name&lt;/code&gt; will consume from the same job. A new job will be created for each iteration of the dataset (with each repetition of &lt;a href=&quot;../../dataset#repeat&quot;&gt;&lt;code&gt;Dataset.repeat&lt;/code&gt;&lt;/a&gt; counting as a new iteration). Suppose two training workers (in either a single client or multi-client setup) iterate over the below dataset, and there is a single tf.data worker:</source>
          <target state="translated">The &lt;code&gt;job_name&lt;/code&gt; argument allows jobs to be shared across multiple datasets. Instead of each dataset creating its own job, all datasets with the same &lt;code&gt;job_name&lt;/code&gt; will consume from the same job. A new job will be created for each iteration of the dataset (with each repetition of &lt;a href=&quot;../../dataset#repeat&quot;&gt; &lt;code&gt;Dataset.repeat&lt;/code&gt; &lt;/a&gt; counting as a new iteration). Suppose two training workers (in either a single client or multi-client setup) iterate over the below dataset, and there is a single tf.data worker:</target>
        </trans-unit>
        <trans-unit id="54adbaacaf1b1235d65bae24606d9417fde02168" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;job_name&lt;/code&gt;, &lt;code&gt;task_index&lt;/code&gt;, and &lt;code&gt;protocol&lt;/code&gt; arguments are optional, and override any information provided in &lt;code&gt;server_or_cluster_def&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;job_name&lt;/code&gt; , &lt;code&gt;task_index&lt;/code&gt; 하고, &lt;code&gt;protocol&lt;/code&gt; 인수는 선택 사항이며, 제공 정보 오버라이드 (override) &lt;code&gt;server_or_cluster_def&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="e82bdbf23648ae7e356f1b9921da5131f1b83a9b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; largest elements along each last dimensional slice.</source>
          <target state="translated">The &lt;code&gt;k&lt;/code&gt; largest elements along each last dimensional slice.</target>
        </trans-unit>
        <trans-unit id="c3533500524684a2c4cc98267eb7938138431a62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; data type.</source>
          <target state="translated">The &lt;code&gt;key&lt;/code&gt; data type.</target>
        </trans-unit>
        <trans-unit id="19f499068ceec21634d06f2a52769f688704a6e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keys&lt;/code&gt; data type. Used when &lt;code&gt;keys&lt;/code&gt; is a python array.</source>
          <target state="translated">The &lt;code&gt;keys&lt;/code&gt; data type. Used when &lt;code&gt;keys&lt;/code&gt; is a python array.</target>
        </trans-unit>
        <trans-unit id="a121b1c952b1d66b82abf663f7114cd18e26ce58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;labels&lt;/code&gt; shape must match &lt;code&gt;logits&lt;/code&gt;, namely &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt;. If &lt;code&gt;label_dimension=1&lt;/code&gt;, shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; is also supported.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; 모양이 일치해야 &lt;code&gt;logits&lt;/code&gt; , 즉 &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt; . 만약 &lt;code&gt;label_dimension=1&lt;/code&gt; , 형상 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 또한 지원된다.</target>
        </trans-unit>
        <trans-unit id="1a7473ff7ad3c16ed4893e43c01e352fd1f3c9c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;labels&lt;/code&gt; shape must match &lt;code&gt;logits&lt;/code&gt;, namely &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; 모양이 일치해야합니다 &lt;code&gt;logits&lt;/code&gt; 을 즉, &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 또는 &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="337997246db8337cb34ef7810fd235c2b2595916" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;load&lt;/code&gt; operation requires the session in which to restore the graph definition and variables, the tags used to identify the meta graph def to load and the location of the SavedModel.</source>
          <target state="translated">그만큼 &lt;code&gt;load&lt;/code&gt; 운전 그래프 정의와 변수 하중과 SavedModel의 위치 DEF 메타 그래프를 식별하는 데 사용되는 태그를 복원 할 수있는 세션을 요구한다.</target>
        </trans-unit>
        <trans-unit id="7d30c15fc4a153c98926b67d30f2faeb014c1e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;local_init_op&lt;/code&gt; is an &lt;code&gt;Operation&lt;/code&gt; that is run always after a new session was created. If &lt;code&gt;None&lt;/code&gt;, this step is skipped.</source>
          <target state="translated">&lt;code&gt;local_init_op&lt;/code&gt; 는 인 &lt;code&gt;Operation&lt;/code&gt; 새로운 세션이 생성 된 후 항상 실행됩니다. 경우 &lt;code&gt;None&lt;/code&gt; ,이 단계를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="d1f6127575bb783a396c88c5a17bc09e9f309fd2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logs&lt;/code&gt; dictionary that callback methods take as argument will contain keys for quantities relevant to the current batch or epoch (see method-specific docstrings).</source>
          <target state="translated">The &lt;code&gt;logs&lt;/code&gt; dictionary that callback methods take as argument will contain keys for quantities relevant to the current batch or epoch (see method-specific docstrings).</target>
        </trans-unit>
        <trans-unit id="2701808169cb5f6edee74183d83e4eef575157e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;logs&lt;/code&gt; dictionary that callback methods take as argument will contain keys for quantities relevant to the current batch or epoch.</source>
          <target state="translated">그만큼 &lt;code&gt;logs&lt;/code&gt; 콜백 메소드는 현재 배치 또는 시대에 관련 수량에 대한 키를 포함 인수로 취할 것을 사전.</target>
        </trans-unit>
        <trans-unit id="fc148a0836cef52be69ad741735a0b91ff403bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;loss_collection&lt;/code&gt; argument is ignored when executing eagerly. Consider holding on to the return value or collecting losses via a &lt;a href=&quot;../../../keras/model&quot;&gt;&lt;code&gt;tf.keras.Model&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;loss_collection&lt;/code&gt; 의 열망 실행시 인수는 무시됩니다. 를 통해 수익을 유지하거나 손실을 수집하십시오.&lt;a href=&quot;../../../keras/model&quot;&gt; &lt;code&gt;tf.keras.Model&lt;/code&gt; 을 하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0afc68c6d1107a5abc809b22cf778d4900b10f1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;max_intra_op_parallelism&lt;/code&gt; attr, which defaults to 1, can be used to limit the intra op parallelism. To limit inter-op parallelism, a user can set a private threadpool on the dataset using &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;'s &lt;code&gt;ThreadingOptions&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;max_intra_op_parallelism&lt;/code&gt; attr, which defaults to 1, can be used to limit the intra op parallelism. To limit inter-op parallelism, a user can set a private threadpool on the dataset using &lt;a href=&quot;../data/options&quot;&gt; &lt;code&gt;tf.data.Options&lt;/code&gt; &lt;/a&gt;'s &lt;code&gt;ThreadingOptions&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e3ee2c38e78144a1138ef9d3009b14144429a19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the average of &lt;code&gt;values&lt;/code&gt;. This average is ultimately returned as &lt;code&gt;mean&lt;/code&gt; which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; 함수는 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 평균 계산하는 데 사용되는 &lt;code&gt;values&lt;/code&gt; . 이 평균은 궁극적으로 반환 &lt;code&gt;mean&lt;/code&gt; 단순히 분할가 멱등 동작되는 &lt;code&gt;total&lt;/code&gt; 의해 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d502617cdf652bd304ad5b305d7afe67fbd9b64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean_absolute_error&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean absolute error. This average is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_absolute_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean_absolute_error&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 평균 절대 오차를 계산하는 데 사용된다. 이 평균에 의해 가중되는 &lt;code&gt;weights&lt;/code&gt; 하고, 궁극적으로 반환된다 &lt;code&gt;mean_absolute_error&lt;/code&gt; : 멱등 동작은 단순히 나누는 것을 &lt;code&gt;total&lt;/code&gt; 로 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5274af314d757e1ddc8b38db5fa05ae667819167" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean_cosine_distance&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the average cosine distance between &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt;. This average is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_distance&lt;/code&gt;, which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean_cosine_distance&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 와 &lt;code&gt;count&lt;/code&gt; 사이의 평균 코사인 거리를 계산하기 위해 사용되는 &lt;code&gt;predictions&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; . 이 평균의 가중치는 가중치로 &lt;code&gt;weights&lt;/code&gt; 가 부여되며 궁극적으로 &lt;code&gt;mean_distance&lt;/code&gt; 로 반환됩니다. 이 평균은 단순히 &lt;code&gt;total&lt;/code&gt; 를 &lt;code&gt;count&lt;/code&gt; 나누는 dem 등식 입니다.</target>
        </trans-unit>
        <trans-unit id="336c620aa42f01c6ce6a5a126282c5957ed048ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean_relative_error&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean relative absolute error. This average is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_relative_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean_relative_error&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 평균 절대 상대 오차를 계산하는 데 사용된다. 이 평균에 의해 가중되는 &lt;code&gt;weights&lt;/code&gt; 하고, 궁극적으로 반환된다 &lt;code&gt;mean_relative_error&lt;/code&gt; : 단순히 분할가 멱등 동작 &lt;code&gt;total&lt;/code&gt; 로 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c2bbcc205906b964a9ff8ac3199c6be162fe51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean_squared_error&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the mean squared error. This average is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;mean_squared_error&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean_squared_error&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 평균 제곱 오차를 계산하는 데 사용된다. 이 평균에 의해 가중되는 &lt;code&gt;weights&lt;/code&gt; 하고, 궁극적으로 반환된다 &lt;code&gt;mean_squared_error&lt;/code&gt; : 단순히 분할가 멱등 동작 &lt;code&gt;total&lt;/code&gt; 로 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b117bfd9e6e5a2c416636178e1f60670fea3d28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mean_tensor&lt;/code&gt; function creates two local variables, &lt;code&gt;total_tensor&lt;/code&gt; and &lt;code&gt;count_tensor&lt;/code&gt; that are used to compute the average of &lt;code&gt;values&lt;/code&gt;. This average is ultimately returned as &lt;code&gt;mean&lt;/code&gt; which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;mean_tensor&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total_tensor&lt;/code&gt; 및 &lt;code&gt;count_tensor&lt;/code&gt; 평균 계산하는 데 사용되는 &lt;code&gt;values&lt;/code&gt; . 이 평균은 궁극적으로 반환 &lt;code&gt;mean&lt;/code&gt; 단순히 분할가 멱등 동작되는 &lt;code&gt;total&lt;/code&gt; 의해 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c200f71e36ea6a98c41ca94cc97dfe77978a644" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;method&lt;/code&gt; argument expects an item from the &lt;a href=&quot;resizemethod&quot;&gt;&lt;code&gt;image.ResizeMethod&lt;/code&gt;&lt;/a&gt; enum, or the string equivalent. The options are:</source>
          <target state="translated">The &lt;code&gt;method&lt;/code&gt; argument expects an item from the &lt;a href=&quot;resizemethod&quot;&gt; &lt;code&gt;image.ResizeMethod&lt;/code&gt; &lt;/a&gt; enum, or the string equivalent. The options are:</target>
        </trans-unit>
        <trans-unit id="359effe1a8bd137a123edc648170974d6a070045" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;method&lt;/code&gt; can be one of:</source>
          <target state="translated">The &lt;code&gt;method&lt;/code&gt; can be one of:</target>
        </trans-unit>
        <trans-unit id="61901168dd1572e51930a90d2c41288724617770" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;min_after_dequeue&lt;/code&gt; argument allows the caller to specify a minimum number of elements that will remain in the queue after a &lt;code&gt;dequeue&lt;/code&gt; or &lt;code&gt;dequeue_many&lt;/code&gt; operation completes, to ensure a minimum level of mixing of elements. This invariant is maintained by blocking those operations until sufficient elements have been enqueued. The &lt;code&gt;min_after_dequeue&lt;/code&gt; argument is ignored after the queue has been closed.</source>
          <target state="translated">&lt;code&gt;min_after_dequeue&lt;/code&gt; 인수는, 발신자가 후에 큐에 남아 요소들의 최소 수를 지정 할 수 &lt;code&gt;dequeue&lt;/code&gt; 또는 &lt;code&gt;dequeue_many&lt;/code&gt; 동작이 완료된 요소의 혼합의 최소 수준을 보장한다. 이 불변은 충분한 요소가 큐에 들어갈 때까지 해당 작업을 차단하여 유지됩니다. 그만큼 &lt;code&gt;min_after_dequeue&lt;/code&gt; 큐가 닫힌 후 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="87f93cdb7fe70e84bf2c6a1f629508cf097e91cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;model_fn&lt;/code&gt; with following signature: &lt;code&gt;def model_fn(features, labels, mode, config)&lt;/code&gt;</source>
          <target state="translated">다음 서명 이있는 &lt;code&gt;model_fn&lt;/code&gt; : &lt;code&gt;def model_fn(features, labels, mode, config)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b0f2d1521a662066e2e88bb2088b1a4f0eee648" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; argument determines the compute and variable dtype, the default loss scale, and has no additional effect on the Policy. The compute and variable dtypes can only be specified through &lt;code&gt;name&lt;/code&gt;, and cannot be specified directly.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 인수는 컴퓨팅 및 변수 DTYPE, 기본 손실 규모를 결정하고, 정책에 추가적인 영향을주지 않습니다. 계산 및 변수 dtype은 다음을 통해서만 지정할 수 있습니다 &lt;code&gt;name&lt;/code&gt; 을 수 있으며 직접 지정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="caae61aec33371ff4b676bc337e8ca5b2b3735d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; argument will be interpreted as follows:</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 은 다음과 같이 인수는 해석됩니다 :</target>
        </trans-unit>
        <trans-unit id="3f5d6d961f52c53a04a1f2df011d2c611359581d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt; proto representing the op that failed, if known; otherwise None.</source>
          <target state="translated">The &lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt; proto representing the op that failed, if known; otherwise None.</target>
        </trans-unit>
        <trans-unit id="ff799851115a4d2209de0937f04e1ab56cdaa6e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ops.Operation&lt;/code&gt; that failed, if known; otherwise None.</source>
          <target state="translated">The &lt;code&gt;ops.Operation&lt;/code&gt; that failed, if known; otherwise None.</target>
        </trans-unit>
        <trans-unit id="0bb4358003786fb876ae7af1510a743596ce0c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;output&lt;/code&gt; is a string &lt;code&gt;Tensor&lt;/code&gt; of the same shape as &lt;code&gt;bytes&lt;/code&gt;, each element containing the decompressed data from the corresponding element in &lt;code&gt;bytes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 문자열이다 &lt;code&gt;Tensor&lt;/code&gt; 동일한 형상의 &lt;code&gt;bytes&lt;/code&gt; 에 대응하는 요소로부터 압축 해제 된 데이터를 포함하는 각 요소 &lt;code&gt;bytes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b4d4c43eca0087042a4ac89a69f9618fa9ccf44" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;padding&lt;/code&gt; argument has no effect on the size of each patch, it determines how many patches are extracted. If &lt;code&gt;VALID&lt;/code&gt;, only patches which are fully contained in the input image are included. If &lt;code&gt;SAME&lt;/code&gt;, all patches whose starting point is inside the input are included, and areas outside the input default to zero.</source>
          <target state="translated">&lt;code&gt;padding&lt;/code&gt; 인수는 각 패치의 크기에 영향을주지 않습니다, 많은 패치가 추출되는 방식을 결정합니다. &lt;code&gt;VALID&lt;/code&gt; 인 경우 입력 이미지에 완전히 포함 된 패치 만 포함됩니다. 만약 &lt;code&gt;SAME&lt;/code&gt; 인 시작점이 입력 내부에있는 모든 패치가 포함되며 입력 외부 영역은 기본적으로 0입니다.</target>
        </trans-unit>
        <trans-unit id="5d6511601b9be092f62183d45376bcdd0b07ca55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; argument contains hyperparameters. It is passed to the &lt;code&gt;model_fn&lt;/code&gt;, if the &lt;code&gt;model_fn&lt;/code&gt; has a parameter named &quot;params&quot;, and to the input functions in the same manner. &lt;code&gt;Estimator&lt;/code&gt; only passes params along, it does not inspect it. The structure of &lt;code&gt;params&lt;/code&gt; is therefore entirely up to the developer.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 인수는 하이퍼 파라미터가 포함되어 있습니다. 그것은에 전달 &lt;code&gt;model_fn&lt;/code&gt; 경우 &lt;code&gt;model_fn&lt;/code&gt; 는 &quot;PARAMS&quot;이라는 파라미터를 갖고, 동일한 방식으로 입력 기능한다. &lt;code&gt;Estimator&lt;/code&gt; 는 매개 변수 만 전달하며 검사하지는 않습니다. 따라서 &lt;code&gt;params&lt;/code&gt; 의 구조는 전적으로 개발자에게 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d95e516d4f18ca77f6adc9dd062547aed852bf4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;partition_strategy&lt;/code&gt; is always &lt;code&gt;&quot;div&quot;&lt;/code&gt; currently. This means that we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;partition_strategy&lt;/code&gt; 는 항상 &lt;code&gt;&quot;div&quot;&lt;/code&gt; 현재. 이것은 우리가 연속적으로 파티션에 ID를 할당한다는 것을 의미합니다. 예를 들어 13 개의 ID는 다음과 같이 5 개의 파티션으로 분할됩니다. &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52630b2e3206fda8f0264a5aa2143342644368d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;percentage_below&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the percentage of &lt;code&gt;values&lt;/code&gt; that fall below &lt;code&gt;threshold&lt;/code&gt;. This rate is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;percentage&lt;/code&gt; which is an idempotent operation that simply divides &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;percentage_below&lt;/code&gt; 함수는 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 및 &lt;code&gt;count&lt;/code&gt; 의 비율의 계산에 사용되는 &lt;code&gt;values&lt;/code&gt; 을 하회 &lt;code&gt;threshold&lt;/code&gt; . 이 레이트에 의해 가중되는 &lt;code&gt;weights&lt;/code&gt; 하고, 궁극적으로 반환된다 &lt;code&gt;percentage&lt;/code&gt; 단순히 분할가 멱등 동작이다 &lt;code&gt;total&lt;/code&gt; 의해 &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ff7ad77d0b4964b4f1ddd1a1b58d2783393a3a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;precision&lt;/code&gt; function creates two local variables, &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_positives&lt;/code&gt;, that are used to compute the precision. This value is ultimately returned as &lt;code&gt;precision&lt;/code&gt;, an idempotent operation that simply divides &lt;code&gt;true_positives&lt;/code&gt; by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_positives&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;precision&lt;/code&gt; 함수는 두 개의 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; 및 &lt;code&gt;false_positives&lt;/code&gt; 정확도를 계산하기 위해 사용된다. 이 값은 궁극적 으로 &lt;code&gt;true_positives&lt;/code&gt; 를 &lt;code&gt;true_positives&lt;/code&gt; 와 &lt;code&gt;false_positives&lt;/code&gt; 의 합으로 나누는 pot 등식 연산 인 &lt;code&gt;precision&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="5dd1225edff0d711a1d881f6569af599477db82d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;precision_at_thresholds&lt;/code&gt; function creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; for various values of thresholds. &lt;code&gt;precision[i]&lt;/code&gt; is defined as the total weight of values in &lt;code&gt;predictions&lt;/code&gt; above &lt;code&gt;thresholds[i]&lt;/code&gt; whose corresponding entry in &lt;code&gt;labels&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, divided by the total weight of values in &lt;code&gt;predictions&lt;/code&gt; above &lt;code&gt;thresholds[i]&lt;/code&gt; (&lt;code&gt;true_positives[i] / (true_positives[i] + false_positives[i])&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;precision_at_thresholds&lt;/code&gt; 의 함수 네 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; 임계 값을 다양. &lt;code&gt;precision[i]&lt;/code&gt; 의 값의 합계 중량으로 정의되고 &lt;code&gt;predictions&lt;/code&gt; 상기 &lt;code&gt;thresholds[i]&lt;/code&gt; 그 안에 진입 대응 &lt;code&gt;labels&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 의 값의 합계 중량으로 나눈 값, &lt;code&gt;predictions&lt;/code&gt; 상기 &lt;code&gt;thresholds[i]&lt;/code&gt; ( &lt;code&gt;true_positives[i] / (true_positives[i] + false_positives[i])&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6eefdf49a7cc35e9901e07fb1fbbe5c8a0436241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred_fn_pairs&lt;/code&gt; parameter is a dict or list of pairs of size N. Each pair contains a boolean scalar tensor and a python callable that creates the tensors to be returned if the boolean evaluates to True. &lt;code&gt;default&lt;/code&gt; is a callable generating a list of tensors. All the callables in &lt;code&gt;pred_fn_pairs&lt;/code&gt; as well as &lt;code&gt;default&lt;/code&gt; (if provided) should return the same number and types of tensors.</source>
          <target state="translated">&lt;code&gt;pred_fn_pairs&lt;/code&gt; 각 쌍의 부울 스칼라 텐서 및 텐서를 생성 파이썬 호출을 포함하는 딕셔너리 또는 크기 N. 쌍의리스트이다 파라미터 부울 참으로 평가되면 반환한다. &lt;code&gt;default&lt;/code&gt; 은 텐서 목록을 생성하는 호출 가능입니다. &lt;code&gt;pred_fn_pairs&lt;/code&gt; 의 모든 콜 러블 과 &lt;code&gt;default&lt;/code&gt; (제공된 경우)은 동일한 개수와 유형의 텐서를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="34976fcb5528295e8ddc3902a61df136b0d0ffdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pred_fn_pairs&lt;/code&gt; parameter is a list of pairs of size N. Each pair contains a boolean scalar tensor and a python callable that creates the tensors to be returned if the boolean evaluates to True. &lt;code&gt;default&lt;/code&gt; is a callable generating a list of tensors. All the callables in &lt;code&gt;pred_fn_pairs&lt;/code&gt; as well as &lt;code&gt;default&lt;/code&gt; (if provided) should return the same number and types of tensors.</source>
          <target state="translated">&lt;code&gt;pred_fn_pairs&lt;/code&gt; 각 쌍의 부울 스칼라 텐서 및 텐서는 불리언 평가되면 참으로 리턴 될 작성 파이썬 호출 포함 크기 N. 쌍의리스트는 파라미터. &lt;code&gt;default&lt;/code&gt; 은 텐서 목록을 생성하는 호출 가능입니다. &lt;code&gt;pred_fn_pairs&lt;/code&gt; 의 모든 콜 러블 과 &lt;code&gt;default&lt;/code&gt; (제공된 경우)은 동일한 개수와 유형의 텐서를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="93cb2f4ffc1343d3e578716fa0f2259765515b7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;predicate&lt;/code&gt; function must return a scalar boolean and accept the following arguments:</source>
          <target state="translated">The &lt;code&gt;predicate&lt;/code&gt; function must return a scalar boolean and accept the following arguments:</target>
        </trans-unit>
        <trans-unit id="9f193e11e3c3d02548a087c0b651e12da6960ea6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;processing_mode&lt;/code&gt; argument controls what data is produced by a tf.data service job. Currently, the only supported mode is &quot;parallel_epochs&quot;.</source>
          <target state="translated">The &lt;code&gt;processing_mode&lt;/code&gt; argument controls what data is produced by a tf.data service job. Currently, the only supported mode is &quot;parallel_epochs&quot;.</target>
        </trans-unit>
        <trans-unit id="1b86bcbbc0d3b8196c89c0939e24a5f7427c39be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ragged_to_dense&lt;/code&gt; op creates a dense tensor from a list of row partition tensors, a value vector, and default values. If the shape is unspecified, the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.</source>
          <target state="translated">The &lt;code&gt;ragged_to_dense&lt;/code&gt; op creates a dense tensor from a list of row partition tensors, a value vector, and default values. If the shape is unspecified, the minimal shape required to contain all the elements in the ragged tensor (the natural shape) will be used. If some dimensions are left unspecified, then the size of the natural shape is used in that dimension.</target>
        </trans-unit>
        <trans-unit id="5afdb3b995f3b29ea4cf73eec10f30fcac05b0a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reader_func&lt;/code&gt; argument can be used to specify a custom order in which elements should be loaded from the individual shards. The &lt;code&gt;reader_func&lt;/code&gt; is expected to take a single argument -- a dataset of datasets, each containing elements of one of the shards -- and return a dataset of elements. For example, the order of shards can be shuffled when loading them as follows:</source>
          <target state="translated">The &lt;code&gt;reader_func&lt;/code&gt; argument can be used to specify a custom order in which elements should be loaded from the individual shards. The &lt;code&gt;reader_func&lt;/code&gt; is expected to take a single argument -- a dataset of datasets, each containing elements of one of the shards -- and return a dataset of elements. For example, the order of shards can be shuffled when loading them as follows:</target>
        </trans-unit>
        <trans-unit id="968a8378fc8eb3fdd1fb2170f34eb48e9c1bec93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_for_local_init_op&lt;/code&gt; is an &lt;code&gt;Operation&lt;/code&gt; used to check if the model is ready to run local_init_op. The model is considered ready if that operation returns an empty 1D string tensor. If the operation returns a non empty 1D string tensor, the elements are concatenated and used to indicate to the user why the model is not ready.</source>
          <target state="translated">&lt;code&gt;ready_for_local_init_op&lt;/code&gt; 는 입니다 &lt;code&gt;Operation&lt;/code&gt; 모델이 local_init_op 실행할 준비가되어 있는지 확인하는 데 사용됩니다. 해당 작업이 빈 1D 문자열 텐서를 반환하면 모델이 준비된 것으로 간주됩니다. 조작이 비어 있지 않은 1D 문자열 텐서를 리턴하면 요소가 연결되어 모델이 준비되지 않은 이유를 사용자에게 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8200e403875e28ce9b4147cac96db59b27a581ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ready_op&lt;/code&gt; is an &lt;code&gt;Operation&lt;/code&gt; used to check if the model is ready. The model is considered ready if that operation returns an empty 1D string tensor. If the operation returns a non empty 1D string tensor, the elements are concatenated and used to indicate to the user why the model is not ready.</source>
          <target state="translated">&lt;code&gt;ready_op&lt;/code&gt; 는 입니다 &lt;code&gt;Operation&lt;/code&gt; 모델이 준비가되었는지 확인하는 데 사용됩니다. 해당 작업이 빈 1D 문자열 텐서를 반환하면 모델이 준비된 것으로 간주됩니다. 조작이 비어 있지 않은 1D 문자열 텐서를 리턴하면 요소가 연결되어 모델이 준비되지 않은 이유를 사용자에게 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e2627a0b13cf79619cf55143c1bafbedffc6df2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recall&lt;/code&gt; function creates two local variables, &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;, that are used to compute the recall. This value is ultimately returned as &lt;code&gt;recall&lt;/code&gt;, an idempotent operation that simply divides &lt;code&gt;true_positives&lt;/code&gt; by the sum of &lt;code&gt;true_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recall&lt;/code&gt; 함수는 두 개의 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; 회수를 계산하기 위해 사용된다. 이 값은 궁극적 으로 &lt;code&gt;true_positives&lt;/code&gt; 를 &lt;code&gt;true_positives&lt;/code&gt; 와 &lt;code&gt;false_negatives&lt;/code&gt; 의 합으로 나누는 dem 등원 연산 인 &lt;code&gt;recall&lt;/code&gt; 으로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb44adc5fb4d7d2974a8444bc13883fdc576fe0e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recall_at_thresholds&lt;/code&gt; function creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; for various values of thresholds. &lt;code&gt;recall[i]&lt;/code&gt; is defined as the total weight of values in &lt;code&gt;predictions&lt;/code&gt; above &lt;code&gt;thresholds[i]&lt;/code&gt; whose corresponding entry in &lt;code&gt;labels&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, divided by the total weight of &lt;code&gt;True&lt;/code&gt; values in &lt;code&gt;labels&lt;/code&gt; (&lt;code&gt;true_positives[i] / (true_positives[i] + false_negatives[i])&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;recall_at_thresholds&lt;/code&gt; 의 함수 네 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; 임계 값을 다양. &lt;code&gt;recall[i]&lt;/code&gt; 의 값의 합계 중량으로 정의되고 &lt;code&gt;predictions&lt;/code&gt; 상기 &lt;code&gt;thresholds[i]&lt;/code&gt; 누구의 엔트리에 대응하는 &lt;code&gt;labels&lt;/code&gt; 이다 &lt;code&gt;True&lt;/code&gt; 의 총 중량으로 나눈 &lt;code&gt;True&lt;/code&gt; 의 값 &lt;code&gt;labels&lt;/code&gt; ( &lt;code&gt;true_positives[i] / (true_positives[i] + false_negatives[i])&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1de524f73c4314e7c1d91fd220ad1d6d3224de54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reverse&lt;/code&gt; and &lt;code&gt;exclusive&lt;/code&gt; kwargs can also be combined:</source>
          <target state="translated">&lt;code&gt;reverse&lt;/code&gt; 및 &lt;code&gt;exclusive&lt;/code&gt; kwargs로도 결합 될 수있다 :</target>
        </trans-unit>
        <trans-unit id="7095d9dae674a6139b14cf56a48942249fb95a3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root_mean_squared_error&lt;/code&gt; function creates two local variables, &lt;code&gt;total&lt;/code&gt; and &lt;code&gt;count&lt;/code&gt; that are used to compute the root mean squared error. This average is weighted by &lt;code&gt;weights&lt;/code&gt;, and it is ultimately returned as &lt;code&gt;root_mean_squared_error&lt;/code&gt;: an idempotent operation that takes the square root of the division of &lt;code&gt;total&lt;/code&gt; by &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;root_mean_squared_error&lt;/code&gt; 의 기능은 두 개의 로컬 변수 생성 &lt;code&gt;total&lt;/code&gt; 과 &lt;code&gt;count&lt;/code&gt; 루트 평균 제곱 오차를 계산하는 데 사용된다. 이 평균의 가중치는 가중치로 &lt;code&gt;weights&lt;/code&gt; 가 부여되며 , 결국 &lt;code&gt;root_mean_squared_error&lt;/code&gt; 로 반환됩니다 . 즉, &lt;code&gt;total&lt;/code&gt; 를 &lt;code&gt;count&lt;/code&gt; 나눈 제곱근을 취하는 dem 등식 연산입니다 .</target>
        </trans-unit>
        <trans-unit id="7881e064a0f67020a02c8653b63784b07ff64c62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;row_splits&lt;/code&gt; tensor indicates where the codepoints and start offsets for each input string begin and end within the &lt;code&gt;char_values&lt;/code&gt; and &lt;code&gt;char_to_byte_starts&lt;/code&gt; tensors. In particular, the values for the &lt;code&gt;i&lt;/code&gt;th string (in row-major order) are stored in the slice &lt;code&gt;[row_splits[i]:row_splits[i+1]]&lt;/code&gt;. Thus:</source>
          <target state="translated">The &lt;code&gt;row_splits&lt;/code&gt; tensor indicates where the codepoints and start offsets for each input string begin and end within the &lt;code&gt;char_values&lt;/code&gt; and &lt;code&gt;char_to_byte_starts&lt;/code&gt; tensors. In particular, the values for the &lt;code&gt;i&lt;/code&gt; th string (in row-major order) are stored in the slice &lt;code&gt;[row_splits[i]:row_splits[i+1]]&lt;/code&gt; . Thus:</target>
        </trans-unit>
        <trans-unit id="01e6fbf0499b79f1cde87a483276287ea014214c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;row_splits&lt;/code&gt; tensor indicates where the codepoints for each input string begin and end within the &lt;code&gt;char_values&lt;/code&gt; tensor. In particular, the values for the &lt;code&gt;i&lt;/code&gt;th string (in row-major order) are stored in the slice &lt;code&gt;[row_splits[i]:row_splits[i+1]]&lt;/code&gt;. Thus:</source>
          <target state="translated">The &lt;code&gt;row_splits&lt;/code&gt; tensor indicates where the codepoints for each input string begin and end within the &lt;code&gt;char_values&lt;/code&gt; tensor. In particular, the values for the &lt;code&gt;i&lt;/code&gt; th string (in row-major order) are stored in the slice &lt;code&gt;[row_splits[i]:row_splits[i+1]]&lt;/code&gt; . Thus:</target>
        </trans-unit>
        <trans-unit id="458e5a2574272cd3d33b7c903a0b4f0ec7f14636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_context&lt;/code&gt; argument is a &lt;code&gt;SessionRunContext&lt;/code&gt; that provides information about the upcoming &lt;code&gt;run()&lt;/code&gt; call: the originally requested op/tensors, the TensorFlow Session.</source>
          <target state="translated">&lt;code&gt;run_context&lt;/code&gt; 의 인수는이다 &lt;code&gt;SessionRunContext&lt;/code&gt; 다가오는에 대한 정보 제공 &lt;code&gt;run()&lt;/code&gt; 원래 요청한 연산 / 텐서의 TensorFlow 세션 : 전화를.</target>
        </trans-unit>
        <trans-unit id="cf828e3dc7b5c6afebb2a4e95b3f86639dbbc64b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_context&lt;/code&gt; argument is the same one send to &lt;code&gt;before_run&lt;/code&gt; call. &lt;code&gt;run_context.request_stop()&lt;/code&gt; can be called to stop the iteration.</source>
          <target state="translated">&lt;code&gt;run_context&lt;/code&gt; 의 인수는 동일한 하나의 전송이다 &lt;code&gt;before_run&lt;/code&gt; 전화. &lt;code&gt;run_context.request_stop()&lt;/code&gt; 을 호출하여 반복을 중지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94f5d1df32e6ce942188c9ddfd764b608ff17856" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_values&lt;/code&gt; argument contains results of requested ops/tensors by &lt;code&gt;before_run()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;run_values&lt;/code&gt; 의 인수에 의해 요청 작전 / 텐서의 결과를 포함 &lt;code&gt;before_run()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be802e4b5940c54925a16198fd046cde07510ef1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;save_path&lt;/code&gt; argument is typically a value previously returned from a &lt;code&gt;save()&lt;/code&gt; call, or a call to &lt;code&gt;latest_checkpoint()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;save_path&lt;/code&gt; 의 인수는 일반적으로 이전에서 반환 된 값 &lt;code&gt;save()&lt;/code&gt; 호출, 또는를 호출 &lt;code&gt;latest_checkpoint()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f865f0bbd1d6f2fff1a5c15f6500c2a842d180ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;seed&lt;/code&gt; argument produces a deterministic sequence of tensors across multiple calls. To repeat that sequence, use &lt;a href=&quot;set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;seed&lt;/code&gt; 인수는 여러 통화에서 텐서의 결정 순서를 생산하고 있습니다. 이 순서를 반복하려면 &lt;a href=&quot;set_seed&quot;&gt; &lt;code&gt;tf.random.set_seed&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="cd56b7af0c6b81f60b1e8953cb5fa5a8ea87a447" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sensitivity_at_specificity&lt;/code&gt; function creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the sensitivity at the given specificity value. The threshold for the given specificity value is computed and used to evaluate the corresponding sensitivity.</source>
          <target state="translated">&lt;code&gt;sensitivity_at_specificity&lt;/code&gt; 의 함수 네 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; 을 주어진 특이 값의 감도를 계산하는데 사용된다. 주어진 특이성 값에 대한 임계 값이 계산되어 해당 감도를 평가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e87df8700aa595c22c3204338d3a54c757320ca4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sequence&lt;/code&gt; format is recommended as the one with the best performance.</source>
          <target state="translated">&lt;code&gt;sequence&lt;/code&gt; 형식은 최고의 성능과 하나로 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4c2d41a4697cb394d4d9e0620c83a904374239b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session&lt;/code&gt; argument can be used in case the hook wants to run final ops, such as saving a last checkpoint.</source>
          <target state="translated">&lt;code&gt;session&lt;/code&gt; 후크는 마지막 체크 포인트를 저장하는 등의 최종 작전을 실행하고자하는 경우에는 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5409b22ac50361a38c4e5620fb792814a952ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;session&lt;/code&gt; argument to the constructor makes the returned &lt;code&gt;FileWriter&lt;/code&gt; a compatibility layer over new graph-based summaries (&lt;code&gt;tf.contrib.summary&lt;/code&gt;). Crucially, this means the underlying writer resource and events file will be shared with any other &lt;code&gt;FileWriter&lt;/code&gt; using the same &lt;code&gt;session&lt;/code&gt; and &lt;code&gt;logdir&lt;/code&gt;, and with any &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt; in this session using the the same shared resource name (which by default scoped to the logdir). If no such resource exists, one will be created using the remaining arguments to this constructor, but if one already exists those arguments are ignored. In either case, ops will be added to &lt;code&gt;session.graph&lt;/code&gt; to control the underlying file writer resource. See &lt;code&gt;tf.contrib.summary&lt;/code&gt; for more details.</source>
          <target state="translated">생성자에 대한 &lt;code&gt;session&lt;/code&gt; 인수는 반환 된 &lt;code&gt;FileWriter&lt;/code&gt; 를 새로운 그래프 기반 요약 ( &lt;code&gt;tf.contrib.summary&lt;/code&gt; )에 대한 호환성 계층으로 만듭니다 . 결정적으로,이 방법은 기본 작가 자원 및 이벤트 파일은 다른 공유됩니다 &lt;code&gt;FileWriter&lt;/code&gt; 같은 사용하여 &lt;code&gt;session&lt;/code&gt; 및 &lt;code&gt;logdir&lt;/code&gt; , 어떤으로 &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt; 이 세션에서 기본적으로 범위하여 동일한 공유 리소스 이름을 (사용 logdir에). 그러한 리소스가 존재하지 않으면이 생성자에 나머지 인수를 사용하여 생성되지만 이미 존재하는 경우 해당 인수는 무시됩니다. 두 경우 모두 op가 &lt;code&gt;session.graph&lt;/code&gt; 추가됩니다.기본 파일 작성기 리소스를 제어합니다. 자세한 내용은 &lt;code&gt;tf.contrib.summary&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="97ff29fadf0e70b89b34fdebe66a53feae7519dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_verbosity&lt;/code&gt; function</source>
          <target state="translated">&lt;code&gt;set_verbosity&lt;/code&gt; 의 기능</target>
        </trans-unit>
        <trans-unit id="303d3a64650f2563c6f2537d372e68f6d33680c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shape&lt;/code&gt; argument to &lt;code&gt;Variable&lt;/code&gt;'s constructor allows you to construct a variable with a less defined shape than its &lt;code&gt;initial_value&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Variable&lt;/code&gt; 의 생성자에 대한 &lt;code&gt;shape&lt;/code&gt; 인수를 사용하면 &lt;code&gt;initial_value&lt;/code&gt; 보다 덜 정의 된 모양으로 변수를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="995bb7427d25ed39381d1e3024a81d1388decd49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shape&lt;/code&gt; must be 1-D and the operation returns a tensor with shape &lt;code&gt;shape&lt;/code&gt; filled with the values of &lt;code&gt;tensor&lt;/code&gt;. In this case, the number of elements implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of elements in &lt;code&gt;tensor&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;shape&lt;/code&gt; must be 1-D and the operation returns a tensor with shape &lt;code&gt;shape&lt;/code&gt; filled with the values of &lt;code&gt;tensor&lt;/code&gt; . In this case, the number of elements implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of elements in &lt;code&gt;tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5096c5e057bb7371bd8b3aaa5fa49bb7491933b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shape_and_slice&lt;/code&gt; input has the same format as the elements of the &lt;code&gt;shapes_and_slices&lt;/code&gt; input of the &lt;code&gt;SaveSlices&lt;/code&gt; op.</source>
          <target state="translated">The &lt;code&gt;shape_and_slice&lt;/code&gt; input has the same format as the elements of the &lt;code&gt;shapes_and_slices&lt;/code&gt; input of the &lt;code&gt;SaveSlices&lt;/code&gt; op.</target>
        </trans-unit>
        <trans-unit id="c69ff0d563e037b396ab2e9976bb7ebc62fb1134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shapes&lt;/code&gt; argument must be specified; each component of a queue element must have the respective shape. Shapes of fixed rank but variable size are allowed by setting any shape dimension to None. In this case, the inputs' shape may vary along the given dimension, and &lt;code&gt;dequeue_many&lt;/code&gt; will pad the given dimension with zeros up to the maximum shape of all elements in the given batch.</source>
          <target state="translated">&lt;code&gt;shapes&lt;/code&gt; 인수를 지정해야합니다; 큐 요소의 각 구성 요소는 각각의 모양을 가져야합니다. 임의의 모양 치수를 없음으로 설정하면 고정 순위이지만 가변 크기의 모양이 허용됩니다. 이 경우 입력의 모양은 주어진 차원에 따라 다를 수 있으며 &lt;code&gt;dequeue_many&lt;/code&gt; 는 주어진 배치에서 모든 요소의 최대 모양까지 주어진 차원을 0으로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="ab0ab5c8b4fa1e59681b582306920e3555e0b84e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shift&lt;/code&gt; argument determines the number of input elements by which the window moves on each iteration. If windows and elements are both numbered starting at 0, the first element in window &lt;code&gt;k&lt;/code&gt; will be element &lt;code&gt;k * shift&lt;/code&gt; of the input dataset. In particular, the first element of the first window will always be the first element of the input dataset.</source>
          <target state="translated">The &lt;code&gt;shift&lt;/code&gt; argument determines the number of input elements by which the window moves on each iteration. If windows and elements are both numbered starting at 0, the first element in window &lt;code&gt;k&lt;/code&gt; will be element &lt;code&gt;k * shift&lt;/code&gt; of the input dataset. In particular, the first element of the first window will always be the first element of the input dataset.</target>
        </trans-unit>
        <trans-unit id="c8ead13fa637337db4285f46038ea1a1a7e03519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shift&lt;/code&gt; argument determines the number of input elements by which the window moves on each iteration. The first element in the &lt;code&gt;k&lt;/code&gt;th window will be element</source>
          <target state="translated">The &lt;code&gt;shift&lt;/code&gt; argument determines the number of input elements by which the window moves on each iteration. The first element in the &lt;code&gt;k&lt;/code&gt; th window will be element</target>
        </trans-unit>
        <trans-unit id="6d1e6359fd2b9322b254250e0bc1bdb6607c603e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sizes&lt;/code&gt; tensor specifies repeat counts for each field. The repeat count (last dimension) of a each tensor in &lt;code&gt;values&lt;/code&gt; must be greater than or equal to corresponding repeat count in &lt;code&gt;sizes&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sizes&lt;/code&gt; 를 지정 텐서는 각 필드에 대해 계산을 반복합니다. &lt;code&gt;values&lt;/code&gt; 에서 각 텐서의 반복 횟수 (마지막 치수)는 &lt;code&gt;sizes&lt;/code&gt; 해당 반복 횟수보다 크거나 같아야 합니다 .</target>
        </trans-unit>
        <trans-unit id="6881b3cf0171ded834c55d240775c14753ca1a7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sparse_combiner&lt;/code&gt; argument works as follows For example, for two features represented as the categorical columns:</source>
          <target state="translated">&lt;code&gt;sparse_combiner&lt;/code&gt; 의 인수는 같은 범주 열로 표현 두 가지 기능, 예를 들어 다음과 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="a8e8fe9df97a94b949937ed1f21ec89b558385be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;specificity_at_sensitivity&lt;/code&gt; function creates four local variables, &lt;code&gt;true_positives&lt;/code&gt;, &lt;code&gt;true_negatives&lt;/code&gt;, &lt;code&gt;false_positives&lt;/code&gt; and &lt;code&gt;false_negatives&lt;/code&gt; that are used to compute the specificity at the given sensitivity value. The threshold for the given sensitivity value is computed and used to evaluate the corresponding specificity.</source>
          <target state="translated">&lt;code&gt;specificity_at_sensitivity&lt;/code&gt; 의 함수 네 로컬 변수 생성 &lt;code&gt;true_positives&lt;/code&gt; , &lt;code&gt;true_negatives&lt;/code&gt; , &lt;code&gt;false_positives&lt;/code&gt; 및 &lt;code&gt;false_negatives&lt;/code&gt; 주어진 감도 값의 특이성을 계산하는데 사용된다. 주어진 감도 값에 대한 임계 값이 계산되어 해당 특이성을 평가하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb73b0594146c19de95fb48de33a2ddca84ec873" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stride&lt;/code&gt; argument determines the stride of the input elements, and the &lt;code&gt;shift&lt;/code&gt; argument determines the shift of the window.</source>
          <target state="translated">&lt;code&gt;stride&lt;/code&gt; 인수는 입력 요소의 보폭을 결정하고, &lt;code&gt;shift&lt;/code&gt; 인수는 윈도우의 시프트를 판정한다.</target>
        </trans-unit>
        <trans-unit id="a74f9dc305f1b43559e657d172a2c2d77ebf9598" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag&lt;/code&gt; argument is a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt;. It is used to build the &lt;code&gt;tag&lt;/code&gt; of the summary values:</source>
          <target state="translated">The &lt;code&gt;tag&lt;/code&gt; argument is a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; . It is used to build the &lt;code&gt;tag&lt;/code&gt; of the summary values:</target>
        </trans-unit>
        <trans-unit id="2cdbc2357c63bcb39a39386eb4f06b9794007481" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tag&lt;/code&gt; in the outputted Summary.Value protobufs is generated based on the name, with a suffix depending on the max_outputs setting:</source>
          <target state="translated">The &lt;code&gt;tag&lt;/code&gt; in the outputted Summary.Value protobufs is generated based on the name, with a suffix depending on the max_outputs setting:</target>
        </trans-unit>
        <trans-unit id="7cb863ed936a846c83669117e5a427aa5ac1c932" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tensors_list&lt;/code&gt; argument is a list of tuples of tensors, or a list of dictionaries of tensors. Each element in the list is treated similarly to the &lt;code&gt;tensors&lt;/code&gt; argument of &lt;a href=&quot;batch&quot;&gt;&lt;code&gt;tf.compat.v1.train.batch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tensors_list&lt;/code&gt; 의 인수는 텐서의 튜플의 목록 또는 텐서의 사전의 목록입니다. 목록의 각 요소 는 &lt;a href=&quot;batch&quot;&gt; &lt;code&gt;tf.compat.v1.train.batch()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;tensors&lt;/code&gt; 인수 와 유사하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="410a750f639c5f1de66d97c0804239f72c4604d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tensors_list&lt;/code&gt; argument is a list of tuples of tensors, or a list of dictionaries of tensors. Each element in the list is treated similarly to the &lt;code&gt;tensors&lt;/code&gt; argument of &lt;a href=&quot;shuffle_batch&quot;&gt;&lt;code&gt;tf.compat.v1.train.shuffle_batch()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tensors_list&lt;/code&gt; 의 인수는 텐서의 튜플의 목록 또는 텐서의 사전의 목록입니다. 목록의 각 요소 는 &lt;a href=&quot;shuffle_batch&quot;&gt; &lt;code&gt;tf.compat.v1.train.shuffle_batch()&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;tensors&lt;/code&gt; 인수 와 유사하게 취급 됩니다.</target>
        </trans-unit>
        <trans-unit id="e8643ae6bb3114dbfb70eef96843715bb87d8ebd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timeout&lt;/code&gt; argument is the maximum number of seconds to block waiting for a new checkpoint. It is used in combination with the &lt;code&gt;timeout_fn&lt;/code&gt; as follows:</source>
          <target state="translated">&lt;code&gt;timeout&lt;/code&gt; 인수는 새로운 체크 포인트를 기다리고 차단하는 최대 시간 (초)입니다. 다음과 같이 &lt;code&gt;timeout_fn&lt;/code&gt; 과 함께 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="807f1f04969e4f2ae0883a825c647b1f0d8a39fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter denotes the type of the matrix elements. Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must have the same type. The supported types are: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt; and &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter denotes the type of the matrix elements. Both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; must have the same type. The supported types are: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; and &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e399b2f0589b0205025fb98a811a310105aeb18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter denotes the type of the matrix elements. The supported types are: &lt;code&gt;float32&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex64&lt;/code&gt; and &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">The &lt;code&gt;type&lt;/code&gt; parameter denotes the type of the matrix elements. The supported types are: &lt;code&gt;float32&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex64&lt;/code&gt; and &lt;code&gt;complex128&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6a77ac96bac9f8fce1798d1188124dbf4505e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; data type.</source>
          <target state="translated">The &lt;code&gt;value&lt;/code&gt; data type.</target>
        </trans-unit>
        <trans-unit id="972185be83406631ec3872d41f4d67b45194a05d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; tensor has shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; and the &lt;code&gt;filters&lt;/code&gt; tensor has shape &lt;code&gt;[filters_height, filters_width, depth]&lt;/code&gt;, i.e., each input channel is processed independently of the others with its own structuring function. The &lt;code&gt;output&lt;/code&gt; tensor has shape &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt;. The spatial dimensions of the output tensor depend on the &lt;code&gt;padding&lt;/code&gt; algorithm. We currently only support the default &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; 및 &lt;code&gt;filters&lt;/code&gt; 형상을 갖는다 텐서 &lt;code&gt;[filters_height, filters_width, depth]&lt;/code&gt; 즉, 각각의 입력 채널이 독립적으로 자신의 구조 기능 다른 것의 처리된다. &lt;code&gt;output&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt; . 출력 텐서의 공간 치수는 &lt;code&gt;padding&lt;/code&gt; 알고리즘 에 따라 다릅니다 . 현재 기본 &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="9754d069f440bf7569706c44c08fdac07bea1efd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;value&lt;/code&gt; tensor has shape &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; and the &lt;code&gt;kernel&lt;/code&gt; tensor has shape &lt;code&gt;[kernel_height, kernel_width, depth]&lt;/code&gt;, i.e., each input channel is processed independently of the others with its own structuring function. The &lt;code&gt;output&lt;/code&gt; tensor has shape &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt;. The spatial dimensions of the output tensor depend on the &lt;code&gt;padding&lt;/code&gt; algorithm. We currently only support the default &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, in_height, in_width, depth]&lt;/code&gt; 및 &lt;code&gt;kernel&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[kernel_height, kernel_width, depth]&lt;/code&gt; 즉, 각각의 입력 채널은 자체 구조 기능과 다른 독립적으로 처리된다. &lt;code&gt;output&lt;/code&gt; 텐서 형상 갖는다 &lt;code&gt;[batch, out_height, out_width, depth]&lt;/code&gt; . 출력 텐서의 공간 치수는 &lt;code&gt;padding&lt;/code&gt; 알고리즘 에 따라 다릅니다 . 현재 기본 &quot;NHWC&quot; &lt;code&gt;data_format&lt;/code&gt; 만 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="8e0daa2997898655580fac130d0dbe55448f0e54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;values&lt;/code&gt; data type. Used when &lt;code&gt;values&lt;/code&gt; is a python array.</source>
          <target state="translated">The &lt;code&gt;values&lt;/code&gt; data type. Used when &lt;code&gt;values&lt;/code&gt; is a python array.</target>
        </trans-unit>
        <trans-unit id="7671379c01d658910f965c7fbeadd766859617c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt; tensors must all have the same shape, and the output will also have that shape.</source>
          <target state="translated">The &lt;code&gt;x&lt;/code&gt; , and &lt;code&gt;y&lt;/code&gt; tensors must all have the same shape, and the output will also have that shape.</target>
        </trans-unit>
        <trans-unit id="0e0b84cabe53e9e5c6c0da1ca87fa0c58be00cc6" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;EM&lt;/em&gt; algorithm where the &lt;em&gt;M-step&lt;/em&gt; should not involve backpropagation through the output of the &lt;em&gt;E-step&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;EM의&lt;/em&gt; 알고리즘 &lt;em&gt;M-단계&lt;/em&gt; 의 출력을 역 전파를 포함 안 &lt;em&gt;E 단계&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b18ff4b0c03781a21c34b4aa7c91c48fe6607e87" translate="yes" xml:space="preserve">
          <source>The API also assigns ops in tf.compat.v1.trainable_variables() an op type called '_trainable_variables'. The API also logs 'flops' statistics for ops with op.RegisterStatistics() defined. flops calculation depends on Tensor shapes defined in 'graph', which might not be complete. 'run_meta', if provided, completes the shape information with best effort.</source>
          <target state="translated">또한 API는 tf.compat.v1.trainable_variables ()의 op에 '_trainable_variables'라는 op 유형을 할당합니다. 또한 API는 op.RegisterStatistics ()가 정의 된 op에 대한 '플롭'통계를 기록합니다. 플롭 계산은 '그래프'에 정의 된 텐서 모양에 따라 달라지며 완료되지 않을 수 있습니다. 'run_meta'는 제공된 경우 최선의 노력으로 형태 정보를 완성합니다.</target>
        </trans-unit>
        <trans-unit id="35cdea1353819951b9d17d1a0b3f4b3c895f479c" translate="yes" xml:space="preserve">
          <source>The API symbol is not intended to be called by users directly and does appear in TensorFlow's generated documentation.</source>
          <target state="translated">The API symbol is not intended to be called by users directly and does appear in TensorFlow's generated documentation.</target>
        </trans-unit>
        <trans-unit id="6d0fc1f05596c2c92bd92cba556fe327b716c416" translate="yes" xml:space="preserve">
          <source>The Bernoulli distribution with &lt;code&gt;probs&lt;/code&gt; parameter, i.e., the probability of a &lt;code&gt;1&lt;/code&gt; outcome (vs a &lt;code&gt;0&lt;/code&gt; outcome).</source>
          <target state="translated">&lt;code&gt;probs&lt;/code&gt; 모수를 갖는 Bernoulli 분포 , 즉 &lt;code&gt;1&lt;/code&gt; 결과 의 확률 ( &lt;code&gt;0&lt;/code&gt; 결과 대 ).</target>
        </trans-unit>
        <trans-unit id="9353ab8095bc0b0b24b3be126e8e9c7fb1f1ad3d" translate="yes" xml:space="preserve">
          <source>The Beta distribution is defined over the &lt;code&gt;(0, 1)&lt;/code&gt; interval using parameters &lt;code&gt;concentration1&lt;/code&gt; (aka &quot;alpha&quot;) and &lt;code&gt;concentration0&lt;/code&gt; (aka &quot;beta&quot;).</source>
          <target state="translated">베타 분포는 위에 정의된다 &lt;code&gt;(0, 1)&lt;/code&gt; 파라미터를 사용 구간 &lt;code&gt;concentration1&lt;/code&gt; (일명 &quot;알파&quot;)와 &lt;code&gt;concentration0&lt;/code&gt; (일명 &quot;베타&quot;).</target>
        </trans-unit>
        <trans-unit id="eeb17415817c833db2a71ea4466b394324558027" translate="yes" xml:space="preserve">
          <source>The C++ FileSystem API supports multiple file system implementations, including local files, Google Cloud Storage (using a &lt;code&gt;gs://&lt;/code&gt; prefix, and HDFS (using an &lt;code&gt;hdfs://&lt;/code&gt; prefix). TensorFlow exports these as &lt;code&gt;tf.io.gfile&lt;/code&gt;, so that you can use these implementations for saving and loading checkpoints, writing to TensorBoard logs, and accessing training data (among other uses). However, if all your files are local, you can use the regular Python file API without any problem.</source>
          <target state="translated">The C++ FileSystem API supports multiple file system implementations, including local files, Google Cloud Storage (using a &lt;code&gt;gs://&lt;/code&gt; prefix, and HDFS (using an &lt;code&gt;hdfs://&lt;/code&gt; prefix). TensorFlow exports these as &lt;code&gt;tf.io.gfile&lt;/code&gt; , so that you can use these implementations for saving and loading checkpoints, writing to TensorBoard logs, and accessing training data (among other uses). However, if all your files are local, you can use the regular Python file API without any problem.</target>
        </trans-unit>
        <trans-unit id="abea42cad220fd20eda787ac80e243e2cf47e13d" translate="yes" xml:space="preserve">
          <source>The Categorical distribution is closely related to the &lt;code&gt;OneHotCategorical&lt;/code&gt; and &lt;code&gt;Multinomial&lt;/code&gt; distributions. The Categorical distribution can be intuited as generating samples according to &lt;code&gt;argmax{ OneHotCategorical(probs) }&lt;/code&gt; itself being identical to &lt;code&gt;argmax{ Multinomial(probs, total_count=1) }&lt;/code&gt;.</source>
          <target state="translated">범주 형 분포와 밀접한 관련이 &lt;code&gt;OneHotCategorical&lt;/code&gt; 및 &lt;code&gt;Multinomial&lt;/code&gt; 분포. 범주 형 분포는 &lt;code&gt;argmax{ OneHotCategorical(probs) }&lt;/code&gt; 자체가 &lt;code&gt;argmax{ Multinomial(probs, total_count=1) }&lt;/code&gt; 과 동일하므로 표본을 생성하는 것으로 직관 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6c2637ba9bb0ae73ad068069b2445eb1bf971490" translate="yes" xml:space="preserve">
          <source>The Categorical distribution is parameterized by either probabilities or log-probabilities of a set of &lt;code&gt;K&lt;/code&gt; classes. It is defined over the integers &lt;code&gt;{0, 1, ..., K}&lt;/code&gt;.</source>
          <target state="translated">범주 형 분포는 &lt;code&gt;K&lt;/code&gt; 클래스 집합의 확률 또는 로그 확률로 매개 변수화됩니다 . 정수 &lt;code&gt;{0, 1, ..., K}&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="90df9f68f1bf90b37500c909eccb4526c5231678" translate="yes" xml:space="preserve">
          <source>The Class &lt;a href=&quot;../../image/resizemethod&quot;&gt;&lt;code&gt;tf.image.ResizeMethod&lt;/code&gt;&lt;/a&gt; provides various resize methods like &lt;code&gt;bilinear&lt;/code&gt;, &lt;code&gt;nearest_neighbor&lt;/code&gt;.</source>
          <target state="translated">The Class &lt;a href=&quot;../../image/resizemethod&quot;&gt; &lt;code&gt;tf.image.ResizeMethod&lt;/code&gt; &lt;/a&gt; provides various resize methods like &lt;code&gt;bilinear&lt;/code&gt; , &lt;code&gt;nearest_neighbor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba0e0e764a04f5d3663fdeffe26bef760c621f01" translate="yes" xml:space="preserve">
          <source>The Class &lt;a href=&quot;image/resizemethod&quot;&gt;&lt;code&gt;tf.image.ResizeMethod&lt;/code&gt;&lt;/a&gt; provides various resize methods like &lt;code&gt;bilinear&lt;/code&gt;, &lt;code&gt;nearest_neighbor&lt;/code&gt;.</source>
          <target state="translated">The Class &lt;a href=&quot;image/resizemethod&quot;&gt; &lt;code&gt;tf.image.ResizeMethod&lt;/code&gt; &lt;/a&gt; provides various resize methods like &lt;code&gt;bilinear&lt;/code&gt; , &lt;code&gt;nearest_neighbor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66f064277a2e3928ce326dffecdba70543ff622" translate="yes" xml:space="preserve">
          <source>The ClusterResolver will then use the parameters to query the Cloud TPU APIs for the IP addresses and ports of each Cloud TPU listed.</source>
          <target state="translated">그런 다음 ClusterResolver는 매개 변수를 사용하여 나열된 각 Cloud TPU의 IP 주소 및 포트에 대한 Cloud TPU API를 쿼리합니다.</target>
        </trans-unit>
        <trans-unit id="345e361eb29b1a63bf06b68ef8175eed879cd43c" translate="yes" xml:space="preserve">
          <source>The Coordinator can be useful if you want to run multiple threads during your training.</source>
          <target state="translated">코디네이터는 훈련 중에 여러 스레드를 실행하려는 경우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="625b1613ee5ff0ad2573b9f62d520cc8545d17ac" translate="yes" xml:space="preserve">
          <source>The DCT type to perform. Must be 1, 2, 3 or 4.</source>
          <target state="translated">The DCT type to perform. Must be 1, 2, 3 or 4.</target>
        </trans-unit>
        <trans-unit id="751bb659f3927cb28c8460bf1418a1772ceee9d2" translate="yes" xml:space="preserve">
          <source>The DType of an element in the resulting &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">The DType of an element in the resulting &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="762ae5bf9871f156d31ebbf73968a3d2925b8520" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is defined over the &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex&quot;&gt;&lt;code&gt;(k-1)&lt;/code&gt;-simplex&lt;/a&gt; using a positive, length-&lt;code&gt;k&lt;/code&gt; vector &lt;code&gt;concentration&lt;/code&gt; (&lt;code&gt;k &amp;gt; 1&lt;/code&gt;). The Dirichlet is identically the Beta distribution when &lt;code&gt;k = 2&lt;/code&gt;.</source>
          <target state="translated">Dirichlet 분포는 양의 길이 &lt;code&gt;k&lt;/code&gt; 벡터 &lt;code&gt;concentration&lt;/code&gt; 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Simplex&quot;&gt; &lt;code&gt;(k-1)&lt;/code&gt; -simplex에&lt;/a&gt; 대해 정의됩니다 ( &lt;code&gt;k &amp;gt; 1&lt;/code&gt; ). Dirichlet은 &lt;code&gt;k = 2&lt;/code&gt; 때 베타 분포와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="e30884de69ccdd0148c69a6e73300256037fabed" translate="yes" xml:space="preserve">
          <source>The Dirichlet is a distribution over the open &lt;code&gt;(k-1)&lt;/code&gt;-simplex, i.e.,</source>
          <target state="translated">Dirichlet은 개방형 &lt;code&gt;(k-1)&lt;/code&gt; -simplex에 대한 분포입니다 .</target>
        </trans-unit>
        <trans-unit id="2e41a41e81118c558d85cbc4587e8d93ce2121bf" translate="yes" xml:space="preserve">
          <source>The Dirichlet-Multinomial distribution is parameterized by a (batch of) length-&lt;code&gt;K&lt;/code&gt;&lt;code&gt;concentration&lt;/code&gt; vectors (&lt;code&gt;K &amp;gt; 1&lt;/code&gt;) and a &lt;code&gt;total_count&lt;/code&gt; number of trials, i.e., the number of trials per draw from the DirichletMultinomial. It is defined over a (batch of) length-&lt;code&gt;K&lt;/code&gt; vector &lt;code&gt;counts&lt;/code&gt; such that &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt;. The Dirichlet-Multinomial is identically the Beta-Binomial distribution when &lt;code&gt;K = 2&lt;/code&gt;.</source>
          <target state="translated">DirichletMultinomial 분포 길이 - A (일괄)에 의해 매개 변수화 &lt;code&gt;K&lt;/code&gt; 의 &lt;code&gt;concentration&lt;/code&gt; 벡터 ( &lt;code&gt;K &amp;gt; 1&lt;/code&gt; ) 및 &lt;code&gt;total_count&lt;/code&gt; 즉 시행 횟수, 상기 DirichletMultinomial에서 연신 당 시도 횟수. &lt;code&gt;tf.reduce_sum(counts, -1) = total_count&lt;/code&gt; 가 되도록 ( 일괄) 길이 &lt;code&gt;K&lt;/code&gt; 벡터 &lt;code&gt;counts&lt;/code&gt; 대해 정의 됩니다. Dirichlet-Multinomial은 &lt;code&gt;K = 2&lt;/code&gt; 때 Beta-Binomial 분포와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0e283a7e839668d96942d9fe27b03aceff70e822" translate="yes" xml:space="preserve">
          <source>The Dirichlet-Multinomial is a distribution over &lt;code&gt;K&lt;/code&gt;-class counts, i.e., a length-&lt;code&gt;K&lt;/code&gt; vector of non-negative integer &lt;code&gt;counts = n = [n_0, ..., n_{K-1}]&lt;/code&gt;.</source>
          <target state="translated">Dirichlet-Multinomial은 &lt;code&gt;K&lt;/code&gt; 클래스 수, 즉 음이 아닌 정수 &lt;code&gt;counts = n = [n_0, ..., n_{K-1}]&lt;/code&gt; 의 길이 &lt;code&gt;K&lt;/code&gt; 벡터에 대한 분포 입니다.</target>
        </trans-unit>
        <trans-unit id="d6acb7167c1696c912c8e5dfb6364d325b6dc9c6" translate="yes" xml:space="preserve">
          <source>The Dropout layer randomly sets input units to 0 with a frequency of &lt;code&gt;rate&lt;/code&gt; at each step during training time, which helps prevent overfitting. Inputs not set to 0 are scaled up by 1/(1 - rate) such that the sum over all inputs is unchanged.</source>
          <target state="translated">The Dropout layer randomly sets input units to 0 with a frequency of &lt;code&gt;rate&lt;/code&gt; at each step during training time, which helps prevent overfitting. Inputs not set to 0 are scaled up by 1/(1 - rate) such that the sum over all inputs is unchanged.</target>
        </trans-unit>
        <trans-unit id="f02fcb57d9bed9fe1cb9e26959ca7e29bea23df5" translate="yes" xml:space="preserve">
          <source>The Exponential distribution is a special case of the Gamma distribution, i.e.,</source>
          <target state="translated">지수 분포는 감마 분포의 특별한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="e6f3e5f56915f923971b04b2d769299865559dab" translate="yes" xml:space="preserve">
          <source>The Exponential distribution is parameterized by an event &lt;code&gt;rate&lt;/code&gt; parameter.</source>
          <target state="translated">지수 분포는 이벤트 &lt;code&gt;rate&lt;/code&gt; 매개 변수 로 매개 변수화됩니다.</target>
        </trans-unit>
        <trans-unit id="e2d0890a7adeefe2d23082f4a11de8d57d4d1ed8" translate="yes" xml:space="preserve">
          <source>The Exponential distribution uses a &lt;code&gt;rate&lt;/code&gt; parameter, or &quot;inverse scale&quot;, which can be intuited as,</source>
          <target state="translated">지수 분포는 다음 과 같이 직감 될 수 있는 &lt;code&gt;rate&lt;/code&gt; 매개 변수 또는 &quot;역 척도&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c27a80541a728b960073681030d112b982bbe70e" translate="yes" xml:space="preserve">
          <source>The Exponential integral is defined as the integral of &lt;code&gt;exp(t) / t&lt;/code&gt; from &lt;code&gt;-inf&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, with the domain of definition all positive real numbers.</source>
          <target state="translated">The Exponential integral is defined as the integral of &lt;code&gt;exp(t) / t&lt;/code&gt; from &lt;code&gt;-inf&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; , with the domain of definition all positive real numbers.</target>
        </trans-unit>
        <trans-unit id="e6af11365287945f3c89476436217914d9696a41" translate="yes" xml:space="preserve">
          <source>The Fresnel cosine integral is defined as the integral of &lt;code&gt;cos(t^2)&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, with the domain of definition all real numbers.</source>
          <target state="translated">The Fresnel cosine integral is defined as the integral of &lt;code&gt;cos(t^2)&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; , with the domain of definition all real numbers.</target>
        </trans-unit>
        <trans-unit id="024c3990be40c756db4eb49b431ef0ccfe9b4c3d" translate="yes" xml:space="preserve">
          <source>The Fresnel cosine integral is odd.</source>
          <target state="translated">The Fresnel cosine integral is odd.</target>
        </trans-unit>
        <trans-unit id="fc2218a2e44fae16a68dd6449b12be71bd410e0a" translate="yes" xml:space="preserve">
          <source>The Fresnel sine integral is defined as the integral of &lt;code&gt;sin(t^2)&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;, with the domain of definition all real numbers.</source>
          <target state="translated">The Fresnel sine integral is defined as the integral of &lt;code&gt;sin(t^2)&lt;/code&gt; from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt; , with the domain of definition all real numbers.</target>
        </trans-unit>
        <trans-unit id="b076c591ecece6b841a18c0467c2055d9c7a690a" translate="yes" xml:space="preserve">
          <source>The GCE API object returned by the googleapiclient.discovery function. (Default: discovery.build('compute', 'v1')). If you specify a custom service object, then the credentials parameter will be ignored.</source>
          <target state="translated">The GCE API object returned by the googleapiclient.discovery function. (Default: discovery.build('compute', 'v1')). If you specify a custom service object, then the credentials parameter will be ignored.</target>
        </trans-unit>
        <trans-unit id="1518eee2906925a93ae1d93256f98d5eb688bbaf" translate="yes" xml:space="preserve">
          <source>The GCE API object returned by the googleapiclient.discovery function. If you specify a custom service object, then the credentials parameter will be ignored.</source>
          <target state="translated">The GCE API object returned by the googleapiclient.discovery function. If you specify a custom service object, then the credentials parameter will be ignored.</target>
        </trans-unit>
        <trans-unit id="609d4d600899851c7fc93aa7a4ce757600207e0c" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is defined over positive real numbers using parameters &lt;code&gt;concentration&lt;/code&gt; (aka &quot;alpha&quot;) and &lt;code&gt;rate&lt;/code&gt; (aka &quot;beta&quot;).</source>
          <target state="translated">감마 분포는 매개 변수 &lt;code&gt;concentration&lt;/code&gt; (일명 &quot;알파&quot;) 및 &lt;code&gt;rate&lt;/code&gt; (일명 &quot;베타&quot;)을 사용하여 양의 실수에 대해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="79a61f2d86901aebd84ad8b2d9002905d13b2a9f" translate="yes" xml:space="preserve">
          <source>The Glorot normal initializer, also called Xavier normal initializer.</source>
          <target state="translated">Xavier 일반 이니셜 라이저라고도하는 Glorot 일반 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="9d823ca2ee407bbabe7dc4bda0e7dfaa683e7ffd" translate="yes" xml:space="preserve">
          <source>The Glorot uniform initializer, also called Xavier uniform initializer.</source>
          <target state="translated">Xavier 균일 이니셜 라이저라고도하는 Glorot 균일 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="10c27f35329e2804c14ef129a0fd65ea4a51e512" translate="yes" xml:space="preserve">
          <source>The GraphDef of the sub-graph.</source>
          <target state="translated">하위 그래프의 GraphDef</target>
        </trans-unit>
        <trans-unit id="216c6a790806834283ef828e6ca13d0147897e6b" translate="yes" xml:space="preserve">
          <source>The GraphDef version information of this graph.</source>
          <target state="translated">이 그래프의 GraphDef 버전 정보입니다.</target>
        </trans-unit>
        <trans-unit id="89e14da68e001e83bf42d756cbdf87502820c4f8" translate="yes" xml:space="preserve">
          <source>The Grayscale tensor to convert. The last dimension must be size 1.</source>
          <target state="translated">The Grayscale tensor to convert. The last dimension must be size 1.</target>
        </trans-unit>
        <trans-unit id="482d4cd0e1abf7bb59d9b3a8592f133a7b8d6585" translate="yes" xml:space="preserve">
          <source>The Hessian is a matrix of second-order partial derivatives of a scalar tensor (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;https://en.wikipedia.org/wiki/Hessian_matrix&lt;/a&gt; for more details).</source>
          <target state="translated">The Hessian is a matrix of second-order partial derivatives of a scalar tensor (see &lt;a href=&quot;https://en.wikipedia.org/wiki/Hessian_matrix&quot;&gt;https://en.wikipedia.org/wiki/Hessian_matrix&lt;/a&gt; for more details).</target>
        </trans-unit>
        <trans-unit id="655c4658cd7a0d63da53a13b211c6ef8e7cc1af3" translate="yes" xml:space="preserve">
          <source>The Hessian is a matrix of second-order partial derivatives of a scalar tensor (see https://en.wikipedia.org/wiki/Hessian_matrix for more details).</source>
          <target state="translated">Hessian은 스칼라 텐서의 2 차 부분 파생물 행렬입니다 (자세한 내용은 https://en.wikipedia.org/wiki/Hessian_matrix 참조).</target>
        </trans-unit>
        <trans-unit id="d81e5e619b3ab76ee0da2d228e26df5c365438e4" translate="yes" xml:space="preserve">
          <source>The Hurwitz zeta function is defined as:</source>
          <target state="translated">Hurwitz zeta 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
