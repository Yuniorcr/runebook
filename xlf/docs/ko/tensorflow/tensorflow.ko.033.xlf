<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="d8ab4fc41b0560bb6a934607949bd5b386ee29f8" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns a &lt;code&gt;Tensor&lt;/code&gt; holding &lt;code&gt;[B1,...,Bb]&lt;/code&gt;.</source>
          <target state="translated">이 오퍼레이터가 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 리턴 &lt;code&gt;Tensor&lt;/code&gt; 유지 &lt;code&gt;[B1,...,Bb]&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="921347482b8fd91ee313851ca1cccdafc480cddb" translate="yes" xml:space="preserve">
          <source>If this operator has shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt;, this returns a &lt;code&gt;Tensor&lt;/code&gt;&lt;code&gt;diagonal&lt;/code&gt;, of shape &lt;code&gt;[B1,...,Bb, min(M, N)]&lt;/code&gt;, where &lt;code&gt;diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]&lt;/code&gt;.</source>
          <target state="translated">이 연산자의 모양이 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 경우 &lt;code&gt;[B1,...,Bb, min(M, N)]&lt;/code&gt; 모양 의 &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;diagonal&lt;/code&gt; 반환합니다 &lt;code&gt;diagonal[b1,...,bb, i] = self.to_dense()[b1,...,bb, i, i]&lt;/code&gt; 여기서 대각선 [b1 ,. .., bb, i] = self.to_dense () [b1, ..., bb, i, i] .</target>
        </trans-unit>
        <trans-unit id="8f17df02cdfdf16ae55ddc38c4d96a43d8d0194c" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this hints &lt;code&gt;D &amp;gt; 0&lt;/code&gt; elementwise.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 인 경우 &lt;code&gt;D &amp;gt; 0&lt;/code&gt; 요소 단위로 암시 합니다.</target>
        </trans-unit>
        <trans-unit id="3d7432da8d98b1f600f518b45f152630261f8725" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 이면 &lt;code&gt;D&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac0c26f8d498bda35983c79790cb84038dcc48a1" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 이면 &lt;code&gt;L&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed4f7079684ac253ddfaf867eaf34bf8cf0aed43" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 이면 &lt;code&gt;U&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b75fcf71c0a569ab0e4f88a68f9b2ba47762aa34" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 이면 &lt;code&gt;V&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11a0d778ea7b358f23842e885c1d5a8c5ecc2928" translate="yes" xml:space="preserve">
          <source>If this operator is &lt;code&gt;A = L + U D V^H&lt;/code&gt;, this is the diagonal of &lt;code&gt;D&lt;/code&gt;.</source>
          <target state="translated">이 연산자가 &lt;code&gt;A = L + U D V^H&lt;/code&gt; 이면 &lt;code&gt;D&lt;/code&gt; 의 대각선입니다 .</target>
        </trans-unit>
        <trans-unit id="ac015fe43443b780f0f83ee7a02dba87f69812e3" translate="yes" xml:space="preserve">
          <source>If this optional does not have a value (i.e. &lt;code&gt;self.has_value()&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt;), this operation will raise &lt;a href=&quot;../../errors/invalidargumenterror&quot;&gt;&lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt;&lt;/a&gt; at runtime.</source>
          <target state="translated">이 옵션에 값이없는 경우 (예 : &lt;code&gt;self.has_value()&lt;/code&gt; 는 &lt;code&gt;False&lt;/code&gt; 로 평가 ) 런타임시 &lt;a href=&quot;../../errors/invalidargumenterror&quot;&gt; &lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e721351d62e8560faa79940bb195f1f52214823e" translate="yes" xml:space="preserve">
          <source>If this optional does not have a value (i.e. &lt;code&gt;self.has_value()&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt;), this operation will raise &lt;a href=&quot;../errors/invalidargumenterror&quot;&gt;&lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt;&lt;/a&gt; at runtime.</source>
          <target state="translated">이 옵션에 값이없는 경우 (예 : &lt;code&gt;self.has_value()&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 평가됨 )이 작업은 런타임에 &lt;a href=&quot;../errors/invalidargumenterror&quot;&gt; &lt;code&gt;tf.errors.InvalidArgumentError&lt;/code&gt; &lt;/a&gt; 를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="8b41f377cbcb0fda59b6793b37f389278a7f495c" translate="yes" xml:space="preserve">
          <source>If this value is more than 1, OOV inputs are hashed to determine their OOV value; if this value is 0, passing an OOV input will result in a '-1' being returned for that value in the output tensor. (Note that, because the value is -1 and not 0, this will allow you to effectively drop OOV values from categorical encodings.)</source>
          <target state="translated">이 값이 1보다 크면 OOV 입력이 해시되어 OOV 값을 결정합니다. 이 값이 0이면 OOV 입력을 전달하면 출력 텐서의 해당 값에 대해 '-1'이 반환됩니다. (값이 0이 아니라 -1이기 때문에 범주 형 인코딩에서 OOV 값을 효과적으로 삭제할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="f1514ab93b97285018f1c274f51c16deb4d70ee5" translate="yes" xml:space="preserve">
          <source>If this value is more than 1, OOV inputs are modulated to determine their OOV value; if this value is 0, passing an OOV input will result in a '-1' being returned for that value in the output tensor. (Note that, because the value is -1 and not 0, this will allow you to effectively drop OOV values from categorical encodings.)</source>
          <target state="translated">이 값이 1보다 크면 OOV 입력이 변조되어 OOV 값을 결정합니다. 이 값이 0이면 OOV 입력을 전달하면 출력 텐서의 해당 값에 대해 '-1'이 반환됩니다. (값이 0이 아니라 -1이기 때문에 범주 형 인코딩에서 OOV 값을 효과적으로 삭제할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="77cdf432873b1c4a434c37672f4c11b50efb424e" translate="yes" xml:space="preserve">
          <source>If time_major == False (default), this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[batch_size, max_time, cell.output_size]&lt;/code&gt;.</source>
          <target state="translated">time_major == False (기본값) 인 경우 &lt;code&gt;Tensor&lt;/code&gt; 모양입니다 : &lt;code&gt;[batch_size, max_time, cell.output_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ef8f486f9257f3c609cd71034848e31051aeee" translate="yes" xml:space="preserve">
          <source>If time_major == True, this will be a &lt;code&gt;Tensor&lt;/code&gt; shaped: &lt;code&gt;[max_time, batch_size, cell.output_size]&lt;/code&gt;.</source>
          <target state="translated">time_major == True 인 경우 이것은 &lt;code&gt;Tensor&lt;/code&gt; 모양입니다 : &lt;code&gt;[max_time, batch_size, cell.output_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e814ed4eb2aa229b46d9532ee0af8eee2088116" translate="yes" xml:space="preserve">
          <source>If transpose_a and adjoint_a are both set to True.</source>
          <target state="translated">transpose_a 및 adjoint_a가 모두 True로 설정된 경우.</target>
        </trans-unit>
        <trans-unit id="8d9771c610e0ca580ebfd1ee02c48a63efc43f4a" translate="yes" xml:space="preserve">
          <source>If transpose_output is &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="translated">transpose_output이 &lt;code&gt;true&lt;/code&gt; 이면 다음 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4be7f5250b50d753b36e91700f51df547557d415" translate="yes" xml:space="preserve">
          <source>If transpose_output is false, returns:</source>
          <target state="translated">transpose_output이 false이면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="987f748364c0cbac5dff0794850510411dc2ab70" translate="yes" xml:space="preserve">
          <source>If true put each gradient subgraph into a separate compilation scope. This gives fine-grained control over which portions of the graph will be compiled as a single unit. Compiling gradients separately may yield better performance for some graphs. The scope is named based on the scope of the forward computation as well as the name of the gradients. As a result, the gradients will be compiled in a scope that is separate from both the forward computation, and from other gradients.</source>
          <target state="translated">참이면 각 그라디언트 하위 그래프를 별도의 컴파일 범위에 넣습니다. 이렇게하면 그래프의 어느 부분이 단일 단위로 컴파일 될지 세밀하게 제어 할 수 있습니다. 그래디언트를 개별적으로 컴파일하면 일부 그래프의 성능이 향상 될 수 있습니다. 범위는 순방향 계산의 범위와 그라디언트의 이름에 따라 이름이 지정됩니다. 결과적으로 그라디언트는 순방향 계산 및 다른 그라디언트와 분리 된 범위에서 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="d4bf4531db5255ca9a9edafe8fc64d442d3621ea" translate="yes" xml:space="preserve">
          <source>If true the resulting &lt;code&gt;k&lt;/code&gt; elements will be sorted by the values in descending order.</source>
          <target state="translated">If true the resulting &lt;code&gt;k&lt;/code&gt; elements will be sorted by the values in descending order.</target>
        </trans-unit>
        <trans-unit id="58e6ce40eef5a70bfa5ac1274964be590a2c1a68" translate="yes" xml:space="preserve">
          <source>If true use &lt;code&gt;input_min&lt;/code&gt; and &lt;code&gt;input_max&lt;/code&gt; for the range of the input, otherwise determine min and max from the input &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">true이면 입력 범위에 &lt;code&gt;input_min&lt;/code&gt; 및 &lt;code&gt;input_max&lt;/code&gt; 를 사용 하고 , 그렇지 않으면 입력 &lt;code&gt;Tensor&lt;/code&gt; 에서 min과 max를 결정 합니다.</target>
        </trans-unit>
        <trans-unit id="55d835c5abdde926d74d741995b5b63e74e4a04d" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;MonitoredSession&lt;/code&gt; stops iterations. Returns: A &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">true이면 &lt;code&gt;MonitoredSession&lt;/code&gt; 이 반복을 중지합니다. 반환 : &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="642245f4a87a8ae51f595e743952d5f1a8383e6b" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;obj&lt;/code&gt; may refer to a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">true이면 &lt;code&gt;obj&lt;/code&gt; 는 &lt;code&gt;Tensor&lt;/code&gt; 를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bb038c7a2651630e273adec4e4668df52c87e0e" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;obj&lt;/code&gt; may refer to an &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="translated">true이면 &lt;code&gt;obj&lt;/code&gt; 는 &lt;code&gt;Operation&lt;/code&gt; 을 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0427ac6b0b0fdb1672cf3af3d4818c9a571f5214" translate="yes" xml:space="preserve">
          <source>If true, adds an &quot;_output_shapes&quot; list attr to each node with the inferred shapes of each of its outputs.</source>
          <target state="translated">true 인 경우 각 출력의 추론 된 모양과 함께 각 노드에 &quot;_output_shapes&quot;목록 속성을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2410d14ffcca817b83e0409520b16ad690792a61" translate="yes" xml:space="preserve">
          <source>If true, compute full-sized &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;. If false (the default), compute only the leading &lt;code&gt;P&lt;/code&gt; singular vectors. Ignored if &lt;code&gt;compute_uv&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">참이면 전체 크기 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 를 계산 합니다. false (기본값)이면 선행 &lt;code&gt;P&lt;/code&gt; 특이 벡터 만 계산합니다 . &lt;code&gt;compute_uv&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="f633a10a54cff5eadc8d762cd005175ec8c3e6f1" translate="yes" xml:space="preserve">
          <source>If true, on failing to vectorize an operation, the unsupported op is wrapped in a tf.while_loop to execute the map iterations. Note that this fallback only happens for unsupported ops and other parts of &lt;code&gt;fn&lt;/code&gt; are still vectorized. If false, on encountering an unsupported op, a ValueError is thrown. Note that the fallbacks can result in slowdowns since vectorization often yields speedup of one to two orders of magnitude.</source>
          <target state="translated">true 인 경우 작업 벡터화에 실패하면 지원되지 않는 작업이 tf.while_loop에 래핑되어 맵 반복을 실행합니다. 이 폴백은 지원되지 않는 작업에 대해서만 발생하며 &lt;code&gt;fn&lt;/code&gt; 의 다른 부분 은 여전히 ​​벡터화됩니다. false 인 경우 지원되지 않는 작업이 발생하면 ValueError가 발생합니다. 벡터화는 종종 1 ~ 2 배의 속도 향상을 가져 오기 때문에 대체로 인해 속도가 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="048f1f24a5bcac1d8894f5b93c0a90fdbe61f251" translate="yes" xml:space="preserve">
          <source>If true, only account statistics of nodes eventually displayed by the outputs. Otherwise, a node's statistics are accounted by its parents as long as it's types match 'account_type_regexes', even if it is hidden from the output, say, by hide_name_regexes.</source>
          <target state="translated">참이면 노드의 계정 통계 만 결국 출력에 표시됩니다. 그렇지 않으면 노드의 통계는 출력에서 ​​숨겨 지더라도 (예 : hide_name_regexes) 유형이 'account_type_regexes'와 일치하는 한 상위에 의해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="c0d83a8ec3b4b432ce5abe190cc7b46d4bf56426" translate="yes" xml:space="preserve">
          <source>If true, only applies colocation of this op within the context, rather than applying all colocation properties on the stack. If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, this value must be &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">true 인 경우 스택의 모든 코 로케이션 속성을 적용하는 대신 컨텍스트 내에서이 작업의 코 로케이션 만 적용합니다. 경우 &lt;code&gt;op&lt;/code&gt; 없다 &lt;code&gt;None&lt;/code&gt; 이 값은해야 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d5991704ef5e5ed338b15a5a568def2fee052f4" translate="yes" xml:space="preserve">
          <source>If true, retain reduced dimensions with length 1.</source>
          <target state="translated">If true, retain reduced dimensions with length 1.</target>
        </trans-unit>
        <trans-unit id="55e2c570f4b644f41dc5e0706770850ecf206aa3" translate="yes" xml:space="preserve">
          <source>If true, retains reduced dimensions with length 1.</source>
          <target state="translated">true 인 경우 길이가 1 인 축소 된 치수를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="78bd78dc8c3d9722bd2751248ac3d2d2f79be2ad" translate="yes" xml:space="preserve">
          <source>If true, returns a &lt;code&gt;SparseTensor&lt;/code&gt; instead of a dense &lt;code&gt;Tensor&lt;/code&gt; (the default).</source>
          <target state="translated">true이면 조밀 한 &lt;code&gt;Tensor&lt;/code&gt; (기본값) 대신 &lt;code&gt;SparseTensor&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="7fecd242704de37b3dd904a022f989afe06213fd" translate="yes" xml:space="preserve">
          <source>If true, the coordinates of output nmsed boxes will be clipped to [0, 1]. If false, output the box coordinates as it is. Defaults to true.</source>
          <target state="translated">참이면 출력 nmsed 상자의 좌표가 [0, 1]로 잘립니다. 거짓이면 상자 좌표를 그대로 출력합니다. 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="502ce0cdb04da01c657079618fa04e2987ef5a38" translate="yes" xml:space="preserve">
          <source>If true, then composite tensors such as &lt;a href=&quot;../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; are expanded into their component tensors.</source>
          <target state="translated">true이면 &lt;a href=&quot;../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 와 같은 복합 텐서 가 해당 구성 요소 텐서로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="a1f3e3debcd743db974fadd47bb3a3fd32699bd6" translate="yes" xml:space="preserve">
          <source>If true, then ensure that at least one ngram is generated for each input sequence. In particular, if an input sequence is shorter than &lt;code&gt;min(ngram_width) + 2*pad_width&lt;/code&gt;, then generate a single ngram containing the entire sequence. If false, then no ngrams are generated for these short input sequences.</source>
          <target state="translated">참이면 각 입력 시퀀스에 대해 하나 이상의 ngram이 생성되었는지 확인합니다. 특히, 입력 시퀀스가 &lt;code&gt;min(ngram_width) + 2*pad_width&lt;/code&gt; 보다 짧은 경우 전체 시퀀스를 포함하는 단일 ngram을 생성합니다. false이면 이러한 짧은 입력 시퀀스에 대해 ngram이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b8897b80b8903485de9da49cf445089ca28e01ee" translate="yes" xml:space="preserve">
          <source>If true, then the absolute value of the quantized minimum value is the same as the quantized maximum value, instead of 1 greater. i.e. for 8 bit quantization, the minimum value is -127 instead of -128.</source>
          <target state="translated">참이면 양자화 된 최소값의 절대 값은 1 더 큰 것이 아니라 양자화 된 최대 값과 같습니다. 즉, 8 비트 양자화의 경우 최소값은 -128 대신 -127입니다.</target>
        </trans-unit>
        <trans-unit id="605f28ad697888d560565e20edb2658524ca80dd" translate="yes" xml:space="preserve">
          <source>If true, then use assertions to check that the arguments form a valid &lt;code&gt;RaggedTensor&lt;/code&gt;. Note: these assertions incur a runtime cost, since they must be checked for each tensor value.</source>
          <target state="translated">참이면 주장을 사용하여 인수가 유효한 &lt;code&gt;RaggedTensor&lt;/code&gt; 를 형성하는지 확인합니다 . 참고 : 이러한 어설 션은 각 텐서 값에 대해 확인해야하므로 런타임 비용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50e1750211ccf0ffd4d7bf04033e96ab6703e8b1" translate="yes" xml:space="preserve">
          <source>If true, this layer will map indices to vocabulary items instead of mapping vocabulary items to indices.</source>
          <target state="translated">true 인 경우이 레이어는 어휘 항목을 인덱스에 매핑하는 대신 인덱스를 어휘 항목에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="1a5fe58711f7508a2f179f8f78c412b0f3855389" translate="yes" xml:space="preserve">
          <source>If true, uses pfor for computing the Jacobian. Else uses a tf.while_loop.</source>
          <target state="translated">true이면 야 코비 행렬 계산에 pfor를 사용합니다. Else는 tf.while_loop를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="0088562ae1b7677b52faeef211542485c79f6d3c" translate="yes" xml:space="preserve">
          <source>If true, uses safe_embedding_lookup_sparse instead of embedding_lookup_sparse. safe_embedding_lookup_sparse ensures there are no empty rows and all weights and ids are positive at the expense of extra compute cost. This only applies to rank 2 (NxM) shaped input tensors. Defaults to true, consider turning off if the above checks are not needed. Note that having empty rows will not trigger any error though the output result might be 0 or omitted.</source>
          <target state="translated">true 인 경우 embedding_lookup_sparse 대신 safe_embedding_lookup_sparse를 사용합니다. safe_embedding_lookup_sparse는 빈 행이없고 모든 가중치와 ID가 추가 컴퓨팅 비용을 희생하면서 양수인지 확인합니다. 이는 랭크 2 (NxM) 모양의 입력 텐서에만 적용됩니다. 기본값은 true입니다. 위의 검사가 필요하지 않으면 끄는 것이 좋습니다. 빈 행이 있으면 출력 결과가 0이거나 생략 될 수 있지만 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dbeb35334fcf898781955202c2c41a0263216176" translate="yes" xml:space="preserve">
          <source>If true, vectorizes the jacobian computation. Else falls back to a sequential while_loop. Vectorization can sometimes fail or lead to excessive memory usage. This option can be used to disable vectorization in such cases.</source>
          <target state="translated">참이면 야 코비 계산을 벡터화합니다. Else는 순차적 while_loop로 돌아갑니다. 벡터화는 때때로 실패하거나 과도한 메모리 사용으로 이어질 수 있습니다. 이러한 경우이 옵션을 사용하여 벡터화를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78bb27a9d56dc099a7acc0da9b42015044430fff" translate="yes" xml:space="preserve">
          <source>If true, we do not use the minimum quantized value. i.e. for int8 the quantized output, it would be restricted to the range -127..127 instead of the full -128..127 range. This is provided for compatibility with certain inference backends. (Only applies to SCALED mode)</source>
          <target state="translated">참이면 최소 양자화 된 값을 사용하지 않습니다. 즉, int8 양자화 된 출력의 경우 전체 -128..127 범위 대신 -127..127 범위로 제한됩니다. 특정 추론 백엔드와의 호환성을 위해 제공됩니다. (SCALED 모드에만 적용)</target>
        </trans-unit>
        <trans-unit id="83490805bb1f49a5f8bb8f11bf034585aac8c23b" translate="yes" xml:space="preserve">
          <source>If tuple of 2 ints: interpreted as two different symmetric cropping values for height and width: &lt;code&gt;(symmetric_height_crop, symmetric_width_crop)&lt;/code&gt;.</source>
          <target state="translated">2 int의 튜플 인 경우 : 높이와 너비에 대해 서로 다른 두 개의 대칭 자르기 값으로 해석됩니다 : &lt;code&gt;(symmetric_height_crop, symmetric_width_crop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29288c4cdf42a8a30d0d3b67f8aed321e16ae670" translate="yes" xml:space="preserve">
          <source>If tuple of 2 ints: interpreted as two different symmetric padding values for height and width: &lt;code&gt;(symmetric_height_pad, symmetric_width_pad)&lt;/code&gt;.</source>
          <target state="translated">2 int의 튜플 인 경우 : 높이와 너비에 대해 서로 다른 두 개의 대칭 패딩 값으로 해석됩니다 : &lt;code&gt;(symmetric_height_pad, symmetric_width_pad)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b67c19bd4a86767a2e3f540ca915d81b144b003" translate="yes" xml:space="preserve">
          <source>If tuple of 2 tuples of 2 ints: interpreted as &lt;code&gt;((top_crop, bottom_crop), (left_crop, right_crop))&lt;/code&gt;</source>
          <target state="translated">2 개의 정수로 된 2 개의 튜플의 튜플 : &lt;code&gt;((top_crop, bottom_crop), (left_crop, right_crop))&lt;/code&gt; 로 해석</target>
        </trans-unit>
        <trans-unit id="487146df721c523689eaeddaf64885a4a783f231" translate="yes" xml:space="preserve">
          <source>If tuple of 2 tuples of 2 ints: interpreted as &lt;code&gt;((top_pad, bottom_pad), (left_pad, right_pad))&lt;/code&gt;</source>
          <target state="translated">2 개의 튜플 중 2 개의 튜플 인 경우 : &lt;code&gt;((top_pad, bottom_pad), (left_pad, right_pad))&lt;/code&gt; 로 해석</target>
        </trans-unit>
        <trans-unit id="812fc65b353a07607726b2966667ffdf62fd3b3c" translate="yes" xml:space="preserve">
          <source>If tuple of 3 ints: interpreted as two different symmetric cropping values for depth, height, and width: &lt;code&gt;(symmetric_dim1_crop, symmetric_dim2_crop, symmetric_dim3_crop)&lt;/code&gt;.</source>
          <target state="translated">3 int의 튜플 인 경우 : 깊이, 높이 및 너비에 대해 서로 다른 두 개의 대칭 자르기 값으로 해석됩니다 : &lt;code&gt;(symmetric_dim1_crop, symmetric_dim2_crop, symmetric_dim3_crop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43b0e46a9dc3a1e8c76f88c379c30be852303e72" translate="yes" xml:space="preserve">
          <source>If tuple of 3 ints: interpreted as two different symmetric padding values for height and width: &lt;code&gt;(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)&lt;/code&gt;.</source>
          <target state="translated">3 int의 튜플 인 경우 : 높이와 너비에 대해 서로 다른 두 개의 대칭 패딩 값으로 해석됩니다 : &lt;code&gt;(symmetric_dim1_pad, symmetric_dim2_pad, symmetric_dim3_pad)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c88b2c00149b3f5340f436ed5d7d8a348e7c720" translate="yes" xml:space="preserve">
          <source>If tuple of 3 tuples of 2 ints: interpreted as &lt;code&gt;((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))&lt;/code&gt;</source>
          <target state="translated">2 개의 정수로 &lt;code&gt;((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))&lt;/code&gt; 3 개의 튜플의 튜플 : ((left_dim1_crop, right_dim1_crop), (left_dim2_crop, right_dim2_crop), (left_dim3_crop, right_dim3_crop))</target>
        </trans-unit>
        <trans-unit id="f527489de1e80e2130364ad7b3746cd24f497905" translate="yes" xml:space="preserve">
          <source>If tuple of 3 tuples of 2 ints: interpreted as &lt;code&gt;((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))&lt;/code&gt;</source>
          <target state="translated">2 개의 정수 중 3 개의 튜플의 튜플 인 경우 : &lt;code&gt;((left_dim1_pad, right_dim1_pad), (left_dim2_pad, right_dim2_pad), (left_dim3_pad, right_dim3_pad))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3faf4c1ccd2136f577d7a0c4205048d0ffd1bdee" translate="yes" xml:space="preserve">
          <source>If tuple of int (length 2): How many zeros to add at the beginning and at the end of the padding dimension (&lt;code&gt;(left_pad, right_pad)&lt;/code&gt;).</source>
          <target state="translated">튜플 int (길이 2) : 패딩 차원의 시작과 끝에 추가 할 0의 수 ( &lt;code&gt;(left_pad, right_pad)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="04717633bfa1f5d00ee7921c11bc933528638c7c" translate="yes" xml:space="preserve">
          <source>If tuple of int (length 2): How many zeros to add at the beginning and the end of the padding dimension (&lt;code&gt;(left_pad, right_pad)&lt;/code&gt;).</source>
          <target state="translated">int의 튜플 (길이 2) : 패딩 차원의 시작과 끝에 추가 할 0의 수 ( &lt;code&gt;(left_pad, right_pad)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fd5216b9fe5dfaa382d9801ed52c23fb17ea2eda" translate="yes" xml:space="preserve">
          <source>If two elements are equal, the lower-index element appears first.</source>
          <target state="translated">두 요소가 같으면 하위 인덱스 요소가 먼저 나타납니다.</target>
        </trans-unit>
        <trans-unit id="db885c2d7731f7899921d98b5677edf2220668cb" translate="yes" xml:space="preserve">
          <source>If units is not an int.</source>
          <target state="translated">단위가 정수가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="4bce7b71d5fde27e87108fc2b8f29d9e9dd019f3" translate="yes" xml:space="preserve">
          <source>If user called &lt;code&gt;MonitoredSession.run(fetches=a, feed_dict=b)&lt;/code&gt;, then this field is equal to SessionRunArgs(a, b).</source>
          <target state="translated">사용자가 &lt;code&gt;MonitoredSession.run(fetches=a, feed_dict=b)&lt;/code&gt; 호출 한 경우이 필드는 SessionRunArgs (a, b)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7b2692658ec0f3b0fedbacc5e4dc8afebe62f2f" translate="yes" xml:space="preserve">
          <source>If users keep data in tf.Example format, they need to call tf.parse_example with a proper feature spec. There are two main things that this utility helps:</source>
          <target state="translated">사용자가 tf.Example 형식으로 데이터를 유지하는 경우 적절한 기능 사양으로 tf.parse_example을 호출해야합니다. 이 유틸리티가 도움이되는 두 가지 주요 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="50cf7138d7b09704383c9338ec705e7ebf6961a1" translate="yes" xml:space="preserve">
          <source>If using exclusive &lt;code&gt;labels&lt;/code&gt; (wherein one and only one class is true at a time), see &lt;code&gt;sparse_softmax_cross_entropy_with_logits&lt;/code&gt;.</source>
          <target state="translated">독점 &lt;code&gt;labels&lt;/code&gt; 사용하는 경우 (한 번에 하나의 클래스 만 true 인 경우) &lt;code&gt;sparse_softmax_cross_entropy_with_logits&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="19d3637a3d6d25647e984cf647cb8291a36aa8b9" translate="yes" xml:space="preserve">
          <source>If valid compression_type can't be determined from &lt;code&gt;options&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 에서 유효한 compression_type을 결정할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="87079ede7f1a53d1f2cf6b63c82bcae55f52855b" translate="yes" xml:space="preserve">
          <source>If validation fails.</source>
          <target state="translated">유효성 검사가 실패한 경우.</target>
        </trans-unit>
        <trans-unit id="c6f309484c1aebad69e2272b3c3b34b511f44f66" translate="yes" xml:space="preserve">
          <source>If value is False, then only the name prepended with 'no' is emitted.</source>
          <target state="translated">value가 False이면 앞에 'no'가 붙은 이름 만 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="0d582533f76f9fbe72b42e141cd8db21e3ebbecb" translate="yes" xml:space="preserve">
          <source>If value is None, then only the name is emitted.</source>
          <target state="translated">value가 None이면 이름 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1b932d0c6b9763d6c98a7c7a4f7d4c559674b7" translate="yes" xml:space="preserve">
          <source>If value is True, then only the name is emitted.</source>
          <target state="translated">value가 True이면 이름 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ba9125247d16d07818ddb28c97b11a7ccc26f154" translate="yes" xml:space="preserve">
          <source>If value is a collection, this will emit --name=value1,value2,value3, unless the flag name is in multi_flags, in which case this will emit --name=value1 --name=value2 --name=value3.</source>
          <target state="translated">값이 컬렉션 인 경우 플래그 이름이 multi_flags에없는 경우 --name = value1, value2, value3을 내 보냅니다.이 경우 --name = value1 --name = value2 --name = value3을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5d4ad20b53a04eec43483216203f6cf47ad97680" translate="yes" xml:space="preserve">
          <source>If value is a collection, this will emit --name=value1,value2,value3.</source>
          <target state="translated">값이 모음 인 경우 --name = value1, value2, value3을 방출합니다.</target>
        </trans-unit>
        <trans-unit id="e94289cc0ab276f55f2d57923859f1b90e55cdac" translate="yes" xml:space="preserve">
          <source>If value is a string then --name=value is emitted.</source>
          <target state="translated">value가 문자열이면 --name = value가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="20d186d757c8e634482f4b0ae70d6c1979fa6163" translate="yes" xml:space="preserve">
          <source>If value_range does not satisfy value_range[0] &amp;lt; value_range[1].</source>
          <target state="translated">value_range가 value_range [0] &amp;lt;value_range [1]를 충족하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="269bcbd39e8d044a050279a6fd20ff4311dabf60" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;ref&lt;/code&gt; is to be updated more than once, because there are duplicate entries in &lt;code&gt;indices&lt;/code&gt;, the order at which the updates happen for each value is undefined.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 중복 된 항목이 있으므로 &lt;code&gt;ref&lt;/code&gt; 의 값을 두 번 이상 업데이트해야하는 경우 각 값에 대해 업데이트가 수행되는 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4d6a559f5a98c45e6ddecc38bc713096d867c80" translate="yes" xml:space="preserve">
          <source>If values is not a &lt;code&gt;RaggedTensor&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt;, or row_partition is not a &lt;code&gt;RowPartition&lt;/code&gt;.</source>
          <target state="translated">값이없는 경우 &lt;code&gt;RaggedTensor&lt;/code&gt; 또는 &lt;code&gt;Tensor&lt;/code&gt; , 또는 row_partition는 아니다 &lt;code&gt;RowPartition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac6316280f4f6f5ca675262d96420bb0b27b62bd" translate="yes" xml:space="preserve">
          <source>If vectorization fails and fallback_to_while_loop is False.</source>
          <target state="translated">벡터화가 실패하고 fallback_to_while_loop가 False 인 경우.</target>
        </trans-unit>
        <trans-unit id="6ab9ab3db6068354900613f2c4625d2d8e843adc" translate="yes" xml:space="preserve">
          <source>If vectorization of jacobian computation fails or if first dimension of &lt;code&gt;target&lt;/code&gt; and &lt;code&gt;source&lt;/code&gt; do not match.</source>
          <target state="translated">jacobian 계산의 벡터화가 실패하거나 &lt;code&gt;target&lt;/code&gt; 과 &lt;code&gt;source&lt;/code&gt; 의 첫 번째 차원이 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="6afc73dd15833cabdb9c1824eeedbffd6886893b" translate="yes" xml:space="preserve">
          <source>If vectorization of jacobian computation fails.</source>
          <target state="translated">Jacobian 계산의 벡터화가 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="2c17ad3469647662115f724bb24589b2f2fe2137" translate="yes" xml:space="preserve">
          <source>If we cannot talk to a TPU worker after retrying or if the number of TPU devices per host is different.</source>
          <target state="translated">재시도 후 TPU 작업자와 대화 할 수 없거나 호스트 당 TPU 기기 수가 다른 경우</target>
        </trans-unit>
        <trans-unit id="bb2d3ade5eb0388154905624037e8e2403cf867e" translate="yes" xml:space="preserve">
          <source>If we had the following files on our filesystem:</source>
          <target state="translated">파일 시스템에 다음 파일이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="bdb844cd4d2f332924e15531b086460f3069fb1e" translate="yes" xml:space="preserve">
          <source>If we had the following files on our filesystem: - /path/to/dir/a.txt - /path/to/dir/b.py - /path/to/dir/c.py If we pass &quot;/path/to/dir/*.py&quot; as the directory, the dataset would produce: - /path/to/dir/b.py - /path/to/dir/c.py</source>
          <target state="translated">파일 시스템에 다음 파일이있는 경우 :-/path/to/dir/a.txt-/path/to/dir/b.py-/path/to/dir/c.py &quot;/ path / to / dir / *. py &quot;를 디렉토리로 지정하면 데이터 세트는 다음을 생성합니다.-/path/to/dir/b.py-/path/to/dir/c.py</target>
        </trans-unit>
        <trans-unit id="c56249ff57de445c0d669230b1aed90585bd8f33" translate="yes" xml:space="preserve">
          <source>If we mark the pixels in the input image which are taken for the output with &lt;code&gt;*&lt;/code&gt;, we see the pattern:</source>
          <target state="translated">출력을 위해 가져온 입력 이미지의 픽셀을 &lt;code&gt;*&lt;/code&gt; 로 표시하면 패턴이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="1ae663933de0e8928039055bec37a56ddb299b82" translate="yes" xml:space="preserve">
          <source>If we pass &quot;/path/to/dir/*.py&quot; as the directory, the dataset would produce:</source>
          <target state="translated">디렉토리로 &quot;/path/to/dir/*.py&quot;를 전달하면 데이터 세트는 다음을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3e165b6980fcb6841fc0e5a5137adce0275712d9" translate="yes" xml:space="preserve">
          <source>If weight_column is used in &lt;code&gt;feature_columns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;feature_columns&lt;/code&gt; 에서 weight_column이 사용되는 경우 .</target>
        </trans-unit>
        <trans-unit id="cf89ab89e64bfcf039295e9f006b5cf17e441357" translate="yes" xml:space="preserve">
          <source>If with the default behavior you are still seeing errors of the form &quot;Connecting to invalid output X of source node Y which has Z outputs&quot; try setting &lt;a href=&quot;output_all_intermediates&quot;&gt;&lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(True)&lt;/code&gt;&lt;/a&gt; and please file an issue at https://github.com/tensorflow/tensorflow/issues.</source>
          <target state="translated">기본 동작으로 &quot;Z 출력이있는 소스 노드 Y의 유효하지 않은 출력 X에 연결&quot;형식의 오류가 계속 표시되면 &lt;a href=&quot;output_all_intermediates&quot;&gt; &lt;code&gt;tf.compat.v1.experimental.output_all_intermediates(True)&lt;/code&gt; &lt;/a&gt; 설정 하고 https에 문제를 제기하십시오. //github.com/tensorflow/tensorflow/issues.</target>
        </trans-unit>
        <trans-unit id="179651235595979238d6d1b42291336cc1b0116d" translate="yes" xml:space="preserve">
          <source>If writing your own layer, it is recommended to accept tensors only in the first argument. This way, all tensors are casted to the layer's compute dtype. &lt;code&gt;MyLayer&lt;/code&gt; should therefore be written as:</source>
          <target state="translated">자신의 레이어를 작성하는 경우 첫 번째 인수에서만 텐서를 허용하는 것이 좋습니다. 이런 식으로 모든 텐서는 레이어의 컴퓨팅 dtype으로 캐스팅됩니다. 따라서 &lt;code&gt;MyLayer&lt;/code&gt; 는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="8bb0682ea4f5a735a707df158e50587d8f0af257" translate="yes" xml:space="preserve">
          <source>If wrong keyword arguments are provided.</source>
          <target state="translated">잘못된 키워드 인수가 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="34be2be24c5f0073337a7cac4785baf1c58af41e" translate="yes" xml:space="preserve">
          <source>If x is a SparseTensor, returns SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape).</source>
          <target state="translated">x가 SparseTensor이면 SparseTensor (x.indices, tf.math.sign (x.values, ...), x.dense_shape)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66c552947837446cda68c94afb3c12def67506f5" translate="yes" xml:space="preserve">
          <source>If x is not list, but any other type.</source>
          <target state="translated">x가 목록이 아니라 다른 유형 인 경우.</target>
        </trans-unit>
        <trans-unit id="6da86ecefe3f269e32bca33996606c1bbf1c5d57" translate="yes" xml:space="preserve">
          <source>If you are creating many models in a loop, this global state will consume an increasing amount of memory over time, and you may want to clear it. Calling &lt;code&gt;clear_session()&lt;/code&gt; releases the global state: this helps avoid clutter from old models and layers, especially when memory is limited.</source>
          <target state="translated">루프에서 많은 모델을 생성하는 경우이 전역 상태는 시간이 지남에 따라 증가하는 메모리를 소비하므로이를 지울 수 있습니다. &lt;code&gt;clear_session()&lt;/code&gt; 호출 하면 전역 상태가 해제됩니다. 이는 특히 메모리가 제한된 경우 이전 모델 및 레이어의 혼란을 방지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3520c54d6dc04ce1b07ddaf989e991f6131aee9c" translate="yes" xml:space="preserve">
          <source>If you are implementing a ClusterResolver that works in both the Google environment and the open-source world (for instance, a TPU ClusterResolver or similar), you will have to return the appropriate string depending on the environment, which you will have to detect.</source>
          <target state="translated">Google 환경과 오픈 소스 환경 모두에서 작동하는 ClusterResolver를 구현하는 경우 (예 : TPU ClusterResolver 또는 이와 유사한) 환경에 따라 감지해야 할 적절한 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="811aed6a83297431f65eb3e17b9462a562e7f734" translate="yes" xml:space="preserve">
          <source>If you are not using these and you want to average gradients, you should use &lt;a href=&quot;../../math/reduce_sum&quot;&gt;&lt;code&gt;tf.math.reduce_sum&lt;/code&gt;&lt;/a&gt; to add up your per-example losses and then divide by the global batch size. Note that when using &lt;a href=&quot;../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, the first component of a tensor's shape is the &lt;em&gt;replica-local&lt;/em&gt; batch size, which is off by a factor equal to the number of replicas being used to compute a single step. As a result, using &lt;a href=&quot;../../math/reduce_mean&quot;&gt;&lt;code&gt;tf.math.reduce_mean&lt;/code&gt;&lt;/a&gt; will give the wrong answer, resulting in gradients that can be many times too big.</source>
          <target state="translated">이것을 사용하지 않고 그라디언트를 평균화하려면 &lt;a href=&quot;../../math/reduce_sum&quot;&gt; &lt;code&gt;tf.math.reduce_sum&lt;/code&gt; &lt;/a&gt; 을 사용 하여 예제 별 손실을 합한 다음 전역 배치 크기로 나눕니다. &lt;a href=&quot;../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 를 사용할 때 텐서 모양의 첫 번째 구성 요소는 &lt;em&gt;복제본 로컬&lt;/em&gt; 배치 크기이며, 이는 단일 단계를 계산하는 데 사용되는 복제본 수와 같은 요인에 의해 해제됩니다. 결과적으로, &lt;a href=&quot;../../math/reduce_mean&quot;&gt; &lt;code&gt;tf.math.reduce_mean&lt;/code&gt; &lt;/a&gt; 을 사용하면 잘못된 답변이 제공되어 그라디언트가 너무 커질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59f63bd02d496354bd6dba5b7411d9b6c135d1dc" translate="yes" xml:space="preserve">
          <source>If you are using a tf.estimator.Estimator, this will automatically be called during training.</source>
          <target state="translated">tf.estimator.Estimator를 사용하는 경우 훈련 중에 자동으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2c2917c6169e51767f3a1cf473ef3869b6db63a6" translate="yes" xml:space="preserve">
          <source>If you are writing a custom training loop, you will need to call a few more methods, &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_custom_training_loops&quot;&gt;see the guide&lt;/a&gt;:</source>
          <target state="translated">사용자 정의 교육 루프를 작성하는 경우 몇 가지 방법을 더 호출해야 &lt;a href=&quot;https://www.tensorflow.org/guide/distributed_training#using_tfdistributestrategy_with_custom_training_loops&quot;&gt;합니다. 안내서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a7892158ce0223192ea1db18bc5c647fa4e1ee34" translate="yes" xml:space="preserve">
          <source>If you call the scaffold constructor without any arguments, it will pick pieces from the collections, creating default ones if needed when &lt;code&gt;scaffold.finalize()&lt;/code&gt; is called. You can pass arguments to the constructor to provide your own pieces. Pieces that you pass to the constructor are not added to the graph collections.</source>
          <target state="translated">인수없이 스캐 폴드 생성자를 호출하면 &lt;code&gt;scaffold.finalize()&lt;/code&gt; 가 호출 될 때 컬렉션에서 조각을 선택하여 필요한 경우 기본 조각을 만듭니다 . 자신의 조각을 제공하기 위해 생성자에 인수를 전달할 수 있습니다. 생성자에 전달한 조각은 그래프 컬렉션에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc4b64fc1392f71d3b32889d1028fdf4c14a5708" translate="yes" xml:space="preserve">
          <source>If you call this method multiple times during in a test, it will return the same folder. However, across different runs the directories will be different. This will ensure that across different runs tests will not be able to pollute each others environment. If you need multiple unique directories within a single test, you should use tempfile.mkdtemp as follows: tempfile.mkdtemp(dir=self.get_temp_dir()):</source>
          <target state="translated">테스트 중에이 메소드를 여러 번 호출하면 동일한 폴더가 리턴됩니다. 그러나 다른 실행에서 디렉토리는 다릅니다. 이렇게하면 여러 실행에서 테스트가 서로의 환경을 오염시킬 수 없습니다. 단일 테스트 내에 여러 개의 고유 디렉토리가 필요한 경우 tempfile.mkdtemp를 다음과 같이 사용해야합니다. tempfile.mkdtemp (dir = self.get_temp_dir ()) :</target>
        </trans-unit>
        <trans-unit id="a3580f3a4d3112463848bcded904b9614c30e36b" translate="yes" xml:space="preserve">
          <source>If you create several savers, you can specify a different filename for the protocol buffer file in the call to &lt;code&gt;save()&lt;/code&gt;.</source>
          <target state="translated">여러 개의 보호기를 작성하는 경우 &lt;code&gt;save()&lt;/code&gt; 호출에서 프로토콜 버퍼 파일의 다른 파일 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28103958dfc2a16c0c732f42cc7e814e32d142b8" translate="yes" xml:space="preserve">
          <source>If you did not pass &lt;code&gt;dtype=inputs.dtype&lt;/code&gt; to &lt;a href=&quot;../../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;, a &lt;code&gt;TypeError&lt;/code&gt; would have occurred. This is because the dtype defaults to &lt;code&gt;&quot;float32&quot;&lt;/code&gt;, so the layer would only work if the inputs were float32.</source>
          <target state="translated">당신이 통과하지 않은 경우 &lt;code&gt;dtype=inputs.dtype&lt;/code&gt; 에 &lt;a href=&quot;../../../random/normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; &lt;/a&gt; 하는 &lt;code&gt;TypeError&lt;/code&gt; 발생한 것입니다. 이는 dtype의 기본값이 &lt;code&gt;&quot;float32&quot;&lt;/code&gt; 이므로 입력이 float32 인 경우에만 레이어가 작동하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="4b3c655b2c0cd15900dc6ea65570d055839af0e8" translate="yes" xml:space="preserve">
          <source>If you have a single image of shape &lt;code&gt;[height, width, channels]&lt;/code&gt;:</source>
          <target state="translated">모양 &lt;code&gt;[height, width, channels]&lt;/code&gt; 의 단일 이미지가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="64d1cb8a274c0bbb6c61df5f30bfb914148bc1ce" translate="yes" xml:space="preserve">
          <source>If you have a sparse tensor with shape &lt;code&gt;[height, width, depth]&lt;/code&gt;:</source>
          <target state="translated">모양이 &lt;code&gt;[height, width, depth]&lt;/code&gt; 희소 텐서가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="643bb410030ee559023f612081129a136d785967" translate="yes" xml:space="preserve">
          <source>If you have a trained graph containing Variable ops, it can be convenient to convert them all to Const ops holding the same values. This makes it possible to describe the network fully with a single GraphDef file, and allows the removal of a lot of ops related to loading and saving the variables.</source>
          <target state="translated">Variable ops가 포함 된 훈련 된 그래프가있는 경우 모두 동일한 값을 유지하는 Const ops로 변환하는 것이 편리 할 수 ​​있습니다. 이를 통해 단일 GraphDef 파일로 네트워크를 완전히 설명 할 수 있으며 변수로드 및 저장과 관련된 많은 작업을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbbe35a21e92354b6099726c1f1b63c090066bd0" translate="yes" xml:space="preserve">
          <source>If you have installed TensorFlow with pip, you should be able to launch TensorBoard from the command line:</source>
          <target state="translated">pip와 함께 TensorFlow를 설치 한 경우 명령 행에서 TensorBoard를 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="016085ae26a60bbb61348962a0dfeec05c644fd2" translate="yes" xml:space="preserve">
          <source>If you intend to create your own optimization algorithm, simply inherit from this class and override the following methods:</source>
          <target state="translated">자체 최적화 알고리즘을 만들려는 경우이 클래스에서 상속하고 다음 방법을 재정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="7a4975dd1a9a628301d8fcc46c4c1c4006240c2f" translate="yes" xml:space="preserve">
          <source>If you need to create a variable with an initial value dependent on another variable, use the other variable's &lt;code&gt;initialized_value()&lt;/code&gt;. This ensures that variables are initialized in the right order.</source>
          <target state="translated">다른 변수에 따라 초기 값으로 변수를 작성해야하는 경우 다른 변수의 &lt;code&gt;initialized_value()&lt;/code&gt; . 이를 통해 변수가 올바른 순서로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="0dc17bf51002e45117b6f345986483c155902a03" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;Graph&lt;/code&gt; to the constructor it is added to the event file. (This is equivalent to calling &lt;code&gt;add_graph()&lt;/code&gt; later).</source>
          <target state="translated">생성자에 &lt;code&gt;Graph&lt;/code&gt; 를 전달 하면 이벤트 파일에 추가됩니다. (이것은 나중에 &lt;code&gt;add_graph()&lt;/code&gt; 를 호출하는 것과 같습니다 ).</target>
        </trans-unit>
        <trans-unit id="3b597fd2dcc48bc48d2628a974c7978b906354cd" translate="yes" xml:space="preserve">
          <source>If you should use &lt;code&gt;_distributed_apply()&lt;/code&gt; instead.</source>
          <target state="translated">대신 &lt;code&gt;_distributed_apply()&lt;/code&gt; 를 사용해야하는 경우 .</target>
        </trans-unit>
        <trans-unit id="2781f7468959178d029e9786cd7a67e84aa2b60a" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;code&gt;Model&lt;/code&gt;, you can optionally have a &lt;code&gt;training&lt;/code&gt; argument (boolean) in &lt;code&gt;call&lt;/code&gt;, which you can use to specify a different behavior in training and inference:</source>
          <target state="translated">&lt;code&gt;Model&lt;/code&gt; 을 서브 클래 싱하는 경우 선택적 으로 &lt;code&gt;call&lt;/code&gt; 에서 &lt;code&gt;training&lt;/code&gt; 인수 (부울) 를 가질 수 있습니다. 훈련 및 추론에서 다른 동작을 지정하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5da8bcdbe00cdaa6f02c6698e68c0a2734bda5f" translate="yes" xml:space="preserve">
          <source>If you use infrastructure or other tooling that relies on Estimators, you can still build a Keras model and use model_to_estimator to convert the Keras model to an Estimator for use with downstream systems.</source>
          <target state="translated">Estimator를 사용하는 인프라 또는 기타 도구를 사용하는 경우에도 Keras 모델을 빌드하고 model_to_estimator를 사용하여 다운 스트림 시스템에서 사용하기 위해 Keras 모델을 Estimator로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14b4c4dfa2247d3068e5eb1177e034e3d1c73d48" translate="yes" xml:space="preserve">
          <source>If you want to avoid copying, you can use the &lt;code&gt;tensor()&lt;/code&gt; function to get a numpy buffer pointing to the input buffer in the tflite interpreter.</source>
          <target state="translated">복사를 피하려면 &lt;code&gt;tensor()&lt;/code&gt; 함수를 사용 하여 tflite 인터프리터의 입력 버퍼를 가리키는 numpy 버퍼를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30064acebab6ecca146a1290566e335cd8e88f84" translate="yes" xml:space="preserve">
          <source>If you want to change the shape of a variable later you have to use an &lt;code&gt;assign&lt;/code&gt; Op with &lt;code&gt;validate_shape=False&lt;/code&gt;.</source>
          <target state="translated">나중에 변수의 모양을 변경하려면 &lt;code&gt;validate_shape=False&lt;/code&gt; 와 함께 &lt;code&gt;assign&lt;/code&gt; Op 를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1e9d13dc74d0a69d3dde9828649eff4bfd882d5c" translate="yes" xml:space="preserve">
          <source>If you want to obfuscate the hashed output, you can also pass a random &lt;code&gt;salt&lt;/code&gt; argument in the constructor. In that case, the layer will use the &lt;a href=&quot;https://github.com/google/highwayhash&quot;&gt;SipHash64&lt;/a&gt; hash function, with the &lt;code&gt;salt&lt;/code&gt; value serving as additional input to the hash function.</source>
          <target state="translated">해시 된 출력을 난독 화하려는 경우 생성자에 임의의 &lt;code&gt;salt&lt;/code&gt; 인수를 전달할 수도 있습니다 . 이 경우 계층은 &lt;a href=&quot;https://github.com/google/highwayhash&quot;&gt;SipHash64&lt;/a&gt; 해시 함수를 사용하며 &lt;code&gt;salt&lt;/code&gt; 값은 해시 함수에 대한 추가 입력으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="62aa5f24c44d925f32d0da5e3403123315297df8" translate="yes" xml:space="preserve">
          <source>If you want to retrieve the Dimension instance corresponding to a certain index in a TensorShape instance, use this utility, like this:</source>
          <target state="translated">TensorShape 인스턴스의 특정 인덱스에 해당하는 Dimension 인스턴스를 검색하려면 다음과 같이이 유틸리티를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b8ffbf1a170d32110a5930f1952bac45b4d249c7" translate="yes" xml:space="preserve">
          <source>If you want to retry the training loop in case of preemption you can do it as follows:</source>
          <target state="translated">선점시 훈련 루프를 재 시도하려면 다음과 같이 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="adc45763eb8027d619cccae315120edbed7cddbd" translate="yes" xml:space="preserve">
          <source>If you wish to avoid the copy, use &lt;code&gt;tensor()&lt;/code&gt;. This function cannot be used to read intermediate results.</source>
          <target state="translated">복사를 피하려면 &lt;code&gt;tensor()&lt;/code&gt; . 이 기능은 중간 결과를 읽는 데 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cb43b900ca1b66e6594e59c48bc30ab315af1d0f" translate="yes" xml:space="preserve">
          <source>If your code needs tf.disable_control_flow_v2() to be called to work properly please file a bug.</source>
          <target state="translated">코드가 제대로 작동하기 위해 tf.disable_control_flow_v2 ()를 호출해야하는 경우 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="bb220fa51853484751849912116a41cad5054655" translate="yes" xml:space="preserve">
          <source>If your code needs tf.disable_resource_variables() to be called to work properly please file a bug.</source>
          <target state="translated">코드가 제대로 작동하기 위해 tf.disable_resource_variables ()를 호출해야하는 경우 버그를 신고하십시오.</target>
        </trans-unit>
        <trans-unit id="bd9af0a911d43ef76ca8009ab8b340966b03cf39" translate="yes" xml:space="preserve">
          <source>If your directory structure is:</source>
          <target state="translated">디렉토리 구조가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="5848859753847331f8db1042c28d2504dd35ba7f" translate="yes" xml:space="preserve">
          <source>If, however, the function is not expressible as a TensorFlow op, then use</source>
          <target state="translated">그러나이 함수를 TensorFlow op로 표현할 수없는 경우에는</target>
        </trans-unit>
        <trans-unit id="9f96f3d16af9765cccba84d66825f4c203ba2397" translate="yes" xml:space="preserve">
          <source>Igamma</source>
          <target state="translated">Igamma</target>
        </trans-unit>
        <trans-unit id="f50fb74a9b438de96e68b1a585aafd4cb6f6d09e" translate="yes" xml:space="preserve">
          <source>IgammaGradA</source>
          <target state="translated">IgammaGradA</target>
        </trans-unit>
        <trans-unit id="7f4710aed5a69f33a81d3a0ee849c534177e5893" translate="yes" xml:space="preserve">
          <source>Igammac</source>
          <target state="translated">Igammac</target>
        </trans-unit>
        <trans-unit id="ea3708d0408dabca1e98f4d1dfe44e1dff457200" translate="yes" xml:space="preserve">
          <source>IgnoreErrorsDataset</source>
          <target state="translated">IgnoreErrorsDataset</target>
        </trans-unit>
        <trans-unit id="04737b2fc646203f8956213c304c3ff669721355" translate="yes" xml:space="preserve">
          <source>Imag</source>
          <target state="translated">Imag</target>
        </trans-unit>
        <trans-unit id="ad9de5a5ad019656d0e1d16433eb9b2e33cb4c7b" translate="yes" xml:space="preserve">
          <source>Image Adjustments</source>
          <target state="translated">이미지 조정</target>
        </trans-unit>
        <trans-unit id="c42b5ea19e3b21d08dd7b7c8a4d6dfa69396f0bf" translate="yes" xml:space="preserve">
          <source>Image captioning with visual attention</source>
          <target state="translated">눈에 띄는 이미지 캡션</target>
        </trans-unit>
        <trans-unit id="c57a791cfe94292451c577369e78dd317dacf038" translate="yes" xml:space="preserve">
          <source>Image classification</source>
          <target state="translated">이미지 분류</target>
        </trans-unit>
        <trans-unit id="b9dc38b92b74ab56c396229633605467280d3ad3" translate="yes" xml:space="preserve">
          <source>Image data format, can be either &quot;channels_first&quot; or &quot;channels_last&quot;. Defaults to &lt;code&gt;None&lt;/code&gt;, in which case the global setting &lt;a href=&quot;../../backend/image_data_format&quot;&gt;&lt;code&gt;tf.keras.backend.image_data_format()&lt;/code&gt;&lt;/a&gt; is used (unless you changed it, it defaults to &quot;channels_last&quot;).</source>
          <target state="translated">이미지 데이터 형식은 &quot;channels_first&quot;또는 &quot;channels_last&quot;일 수 있습니다. 기본값은 &lt;code&gt;None&lt;/code&gt; &lt;a href=&quot;../../backend/image_data_format&quot;&gt; &lt;code&gt;tf.keras.backend.image_data_format()&lt;/code&gt; &lt;/a&gt; 경우 전역 설정 tf.keras.backend.image_data_format () 이 사용됩니다 (변경하지 않는 한 기본값은 &quot;channels_last&quot;).</target>
        </trans-unit>
        <trans-unit id="03bc4f1f3dc0b8877ffe7138fa5c01d4b1ed5f6f" translate="yes" xml:space="preserve">
          <source>Image data format, either &quot;channels_first&quot; or &quot;channels_last&quot;.</source>
          <target state="translated">이미지 데이터 형식은 &quot;channels_first&quot;또는 &quot;channels_last&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e99ccc1e8a027a31ba180fcc93dd7b3a5384bb01" translate="yes" xml:space="preserve">
          <source>Image data format, either &quot;channels_first&quot; or &quot;channels_last&quot;. &quot;channels_last&quot; mode means that the images should have shape &lt;code&gt;(samples, height, width, channels)&lt;/code&gt;, &quot;channels_first&quot; mode means that the images should have shape &lt;code&gt;(samples, channels, height, width)&lt;/code&gt;. It defaults to the &lt;code&gt;image_data_format&lt;/code&gt; value found in your Keras config file at &lt;code&gt;~/.keras/keras.json&lt;/code&gt;. If you never set it, then it will be &quot;channels_last&quot;.</source>
          <target state="translated">이미지 데이터 형식은 &quot;channels_first&quot;또는 &quot;channels_last&quot;입니다. &quot;channels_last&quot;모드는 이미지가 모양 &lt;code&gt;(samples, height, width, channels)&lt;/code&gt; 가져야 함을 의미하고, &quot;channels_first&quot;모드는 이미지가 모양 &lt;code&gt;(samples, channels, height, width)&lt;/code&gt; 가져야 함을 의미합니다 . 기본값 은 &lt;code&gt;~/.keras/keras.json&lt;/code&gt; 의 Keras 구성 파일에 있는 &lt;code&gt;image_data_format&lt;/code&gt; 값 입니다. 설정하지 않으면 &quot;channels_last&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="2fd7056b6a4b9fce0b732dbb7496a4870360b85c" translate="yes" xml:space="preserve">
          <source>Image decoding and encoding</source>
          <target state="translated">이미지 디코딩 및 인코딩</target>
        </trans-unit>
        <trans-unit id="09a69cfa619159e9e923882fbbb472ea75a854f3" translate="yes" xml:space="preserve">
          <source>Image ops work either on individual images or on batches of images, depending on the shape of their input Tensor.</source>
          <target state="translated">이미지 작업은 입력 Tensor의 모양에 따라 개별 이미지 또는 이미지 배치에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="92b2aca7ed267b133c1905bcbc3ee8c0ced0047e" translate="yes" xml:space="preserve">
          <source>Image ops.</source>
          <target state="translated">이미지 작업.</target>
        </trans-unit>
        <trans-unit id="5bb3ad26e2fda3cd343bd1dc49196d9e2b80c785" translate="yes" xml:space="preserve">
          <source>Image processing</source>
          <target state="translated">이미지 처리</target>
        </trans-unit>
        <trans-unit id="de38a279dcdcd93610ed628ea92871220d9f71d2" translate="yes" xml:space="preserve">
          <source>Image processing and decoding ops.</source>
          <target state="translated">이미지 처리 및 디코딩 작업.</target>
        </trans-unit>
        <trans-unit id="1f104cd249212e0c24d68445f341b223f49368be" translate="yes" xml:space="preserve">
          <source>Image resizing layer.</source>
          <target state="translated">이미지 크기 조정 레이어.</target>
        </trans-unit>
        <trans-unit id="ba7c6b63a88cb374ff63fc7f30662360ee0eafa4" translate="yes" xml:space="preserve">
          <source>Image segmentation</source>
          <target state="translated">이미지 세분화</target>
        </trans-unit>
        <trans-unit id="549ffedf349ced70c3596d6a5af3e5e9f2f85606" translate="yes" xml:space="preserve">
          <source>Image tensor with shape [batch_size, h, w, d] and type float32 or float64. The image(s) must be 2x2 or larger.</source>
          <target state="translated">모양이 [batch_size, h, w, d]이고 유형이 float32 또는 float64 인 이미지 텐서입니다. 이미지는 2x2 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1679853a715a13372b9dbba5c8e3dee507c85e51" translate="yes" xml:space="preserve">
          <source>ImageProjectiveTransformV2</source>
          <target state="translated">ImageProjectiveTransformV2</target>
        </trans-unit>
        <trans-unit id="05d0d38956d6d758e651d5df3fe161d5df79ca6f" translate="yes" xml:space="preserve">
          <source>ImageSummary</source>
          <target state="translated">ImageSummary</target>
        </trans-unit>
        <trans-unit id="6b5de061768f5b63882ed2d718f0716548970fc8" translate="yes" xml:space="preserve">
          <source>Images that are represented using floating point values are expected to have values in the range [0,1). Image data stored in integer data types are expected to have values in the range &lt;code&gt;[0,MAX]&lt;/code&gt;, where &lt;code&gt;MAX&lt;/code&gt; is the largest positive representable number for the data type.</source>
          <target state="translated">부동 소수점 값을 사용하여 표현 된 이미지는 [0,1) 범위의 값을 가질 것으로 예상됩니다. 정수 데이터 유형에 저장된 이미지 데이터는 &lt;code&gt;[0,MAX]&lt;/code&gt; 범위의 값을 가질 것으로 예상되며 , 여기서 &lt;code&gt;MAX&lt;/code&gt; 는 데이터 유형에 대해 가장 큰 양의 표현 가능한 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="ccc97dec6d4395a74fe2285c4a5cffe536e82bbb" translate="yes" xml:space="preserve">
          <source>Images to adjust. At least 3-D.</source>
          <target state="translated">조정할 이미지. 최소한 3 차원.</target>
        </trans-unit>
        <trans-unit id="1cfb47d7a3d4989535a89f1c2c00a918608b2b94" translate="yes" xml:space="preserve">
          <source>ImmutableConst</source>
          <target state="translated">ImmutableConst</target>
        </trans-unit>
        <trans-unit id="012973862f6d580b577f1ca55fe2d5d026bfe3a4" translate="yes" xml:space="preserve">
          <source>Implement serialization via &lt;code&gt;get_config()&lt;/code&gt; and &lt;code&gt;from_config()&lt;/code&gt;. Note that the recommended way to create new RNN layers is to write a custom RNN cell and use it with &lt;a href=&quot;rnn&quot;&gt;&lt;code&gt;keras.layers.RNN&lt;/code&gt;&lt;/a&gt;, instead of subclassing &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;keras.layers.Layer&lt;/code&gt;&lt;/a&gt; directly.</source>
          <target state="translated">&lt;code&gt;get_config()&lt;/code&gt; 및 &lt;code&gt;from_config()&lt;/code&gt; 를 통해 직렬화를 구현 합니다. 새로운 RNN 레이어를 생성하는 권장 방법은 &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;keras.layers.Layer&lt;/code&gt; 를&lt;/a&gt; 직접 서브 클래 싱하는 대신 커스텀 RNN 셀을 작성하고 &lt;a href=&quot;rnn&quot;&gt; &lt;code&gt;keras.layers.RNN&lt;/code&gt; &lt;/a&gt; 과 함께 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="8bcae14734b26e859d782e85cd6d711a5ef2255b" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 (default) will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="translated">구현 모드, 1 또는 2입니다. 모드 1은 더 많은 수의 작은 내적 및 추가로 작업을 구성하는 반면 모드 2 (기본값)는 더 적은 수의 더 큰 작업으로 일괄 처리합니다. 이러한 모드는 하드웨어 및 응용 프로그램에 따라 다른 성능 프로필을 갖습니다. 기본값 : 2.</target>
        </trans-unit>
        <trans-unit id="7b9a2fe91a457a38eea4454f2e5c0a2dfb6358ae" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications.</source>
          <target state="translated">구현 모드, 1 또는 2입니다. 모드 1은 더 많은 수의 작은 내적 및 추가로 작업을 구성하는 반면 모드 2는 더 적은 수의 더 큰 작업으로 일괄 처리합니다. 이러한 모드는 하드웨어 및 응용 프로그램에 따라 다른 성능 프로필을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d338df7aebbbd96f6ef415f339b2419e491891fb" translate="yes" xml:space="preserve">
          <source>Implementation mode, either 1 or 2. Mode 1 will structure its operations as a larger number of smaller dot products and additions, whereas mode 2 will batch them into fewer, larger operations. These modes will have different performance profiles on different hardware and for different applications. Default: 2.</source>
          <target state="translated">구현 모드, 1 또는 2입니다. 모드 1은 더 많은 수의 작은 내적 및 추가로 작업을 구성하는 반면 모드 2는 더 적은 수의 더 큰 작업으로 일괄 처리합니다. 이러한 모드는 하드웨어 및 응용 프로그램에 따라 다른 성능 프로필을 갖습니다. 기본값 : 2.</target>
        </trans-unit>
        <trans-unit id="81ae76c5a033525b9bebb71fc5faddfefe6500ee" translate="yes" xml:space="preserve">
          <source>Implementation of a ClusterResolver which reads the TF_CONFIG EnvVar.</source>
          <target state="translated">TF_CONFIG EnvVar를 읽는 ClusterResolver의 구현.</target>
        </trans-unit>
        <trans-unit id="d540ae9790266c43ea448cc58760dee1f4459524" translate="yes" xml:space="preserve">
          <source>Implementation of broadcast the &lt;code&gt;tensor&lt;/code&gt; to destinations.</source>
          <target state="translated">&lt;code&gt;tensor&lt;/code&gt; 를 대상 으로 브로드 캐스트 구현 .</target>
        </trans-unit>
        <trans-unit id="ed2e87a0db4ddf68319e3f3abca999b37869d878" translate="yes" xml:space="preserve">
          <source>Implementation of reduce PerReplica objects in a batch.</source>
          <target state="translated">배치에서 PerReplica 객체 줄이기 구현.</target>
        </trans-unit>
        <trans-unit id="e8639a6ef1f4702b490c2cdeb6e50d5693132a19" translate="yes" xml:space="preserve">
          <source>Implementation of the Keras API meant to be a high-level API for TensorFlow.</source>
          <target state="translated">Keras API의 구현은 TensorFlow를위한 고급 API였습니다.</target>
        </trans-unit>
        <trans-unit id="89723e13fc88450d8f0a38ed3d90958d12a4e396" translate="yes" xml:space="preserve">
          <source>Implementation of the scikit-learn classifier API for Keras.</source>
          <target state="translated">Keras를위한 scikit-learn 분류기 API 구현.</target>
        </trans-unit>
        <trans-unit id="7de56b2d26746dd73b9fcddfd1c104e0c913f8f8" translate="yes" xml:space="preserve">
          <source>Implementation of the scikit-learn regressor API for Keras.</source>
          <target state="translated">Keras를위한 scikit-learn 회귀 API의 구현.</target>
        </trans-unit>
        <trans-unit id="08c5c38cccf1eb318b9ecd19fdc9f41a46cfbb1e" translate="yes" xml:space="preserve">
          <source>Implemented using a Queue -- a &lt;code&gt;QueueRunner&lt;/code&gt; for the Queue is added to the current &lt;code&gt;Graph&lt;/code&gt;'s &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; collection.</source>
          <target state="translated">큐를 사용하여 구현 됨-큐의 &lt;code&gt;QueueRunner&lt;/code&gt; 가 현재 &lt;code&gt;Graph&lt;/code&gt; 의 &lt;code&gt;QUEUE_RUNNER&lt;/code&gt; 컬렉션에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="99ad440c7b2df497d09111d62c37946bec231ffe" translate="yes" xml:space="preserve">
          <source>Implemented with GPU-compatible ops and supports gradients.</source>
          <target state="translated">GPU 호환 ops로 구현되고 그라디언트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="131bd86e21be57724f2b5e9ee7e658b5ecb52043" translate="yes" xml:space="preserve">
          <source>Implemented with TPU/GPU-compatible ops and supports gradients.</source>
          <target state="translated">TPU / GPU 호환 op로 구현되고 그라디언트를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="597f3136a6ebd70744437c04d68554ff073fbb6c" translate="yes" xml:space="preserve">
          <source>Implementors of this function must take care in ensuring that the ClusterSpec returned is up-to-date at the time of calling this function. This usually means retrieving the information from the underlying cluster management system every time this function is invoked and reconstructing a cluster_spec, rather than attempting to cache anything.</source>
          <target state="translated">이 함수의 구현자는이 함수를 호출 할 때 리턴 된 ClusterSpec이 최신인지 확인해야합니다. 이는 일반적으로이 함수가 호출 될 때마다 기본 클러스터 관리 시스템에서 정보를 검색하고 캐시를 시도하지 않고 cluster_spec을 재구성하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="6d2f9e9adc660c2a8db8b19c19593d1554adf0a2" translate="yes" xml:space="preserve">
          <source>Implementors of this function must take care in ensuring that the master returned is up-to-date at the time to calling this function. This usually means retrieving the master every time this function is invoked.</source>
          <target state="translated">이 함수의 구현자는이 함수를 호출 할 때 리턴 된 마스터가 최신 상태인지 확인해야합니다. 이는 일반적으로이 함수가 호출 될 때마다 마스터를 검색하는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f959bfc7a5d94e9325629ea88125d58bf26d97e5" translate="yes" xml:space="preserve">
          <source>Implements categorical feature hashing, also known as &quot;hashing trick&quot;.</source>
          <target state="translated">&quot;해싱 트릭&quot;이라고도하는 범주 형 기능 해싱을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="dc7a1efdef9331be59eaffeca4ae1e2cd8a5e8f2" translate="yes" xml:space="preserve">
          <source>Implements generalized Tensor contraction and reduction. Each input Tensor must have a corresponding input subscript appearing in the comma-separated left-hand side of the equation. The right-hand side of the equation consists of the output subscript. The input subscripts and the output subscript should consist of zero or more named axis labels and at most one ellipsis (&lt;code&gt;...&lt;/code&gt;).</source>
          <target state="translated">일반화 된 Tensor 축소 및 축소를 구현합니다. 각 입력 Tensor에는 방정식의 쉼표로 구분 된 왼쪽에 나타나는 해당 입력 첨자가 있어야합니다. 방정식의 오른쪽은 출력 첨자로 구성됩니다. 입력 첨자와 출력 첨자는 0 개 이상의 명명 된 축 레이블과 최대 하나의 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 로 구성되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a52c4746cca5aa22e651ddd176b154ea55d83a22" translate="yes" xml:space="preserve">
          <source>Implicit Reparameterization Gradients: &lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients&quot;&gt;Figurnov et al., 2018&lt;/a&gt; (&lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients.pdf&quot;&gt;pdf&lt;/a&gt;)</source>
          <target state="translated">암시 적 &lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients&quot;&gt;재 매개 변수화&lt;/a&gt; 기울기 : Figurnov et al., 2018 ( &lt;a href=&quot;http://papers.nips.cc/paper/7326-implicit-reparameterization-gradients.pdf&quot;&gt;pdf&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b34153a7b6c2ed124d924be11081a13d32dadcc7" translate="yes" xml:space="preserve">
          <source>Implicit in the &lt;code&gt;tape.gradient&lt;/code&gt; call is a length-one vector which left-multiplies the Jacobian, a vector-Jacobian product.</source>
          <target state="translated">&lt;code&gt;tape.gradient&lt;/code&gt; 호출에 내재 된 길이-벡터는 벡터-자 코비안 곱인 Jacobian을 왼쪽으로 곱한 것입니다.</target>
        </trans-unit>
        <trans-unit id="6d5ca9be0a1bd2497683f94ed45157a705abee73" translate="yes" xml:space="preserve">
          <source>Import a GraphDef and convert it to a textual MLIR module.</source>
          <target state="translated">GraphDef를 가져 와서 텍스트 MLIR 모듈로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="545c1126ae772bf7a2e6008df556dad256e5b169" translate="yes" xml:space="preserve">
          <source>Import router for absl.flags. See &lt;a href=&quot;https://github.com/abseil/abseil-py&quot;&gt;https://github.com/abseil/abseil-py&lt;/a&gt;</source>
          <target state="translated">absl.flags에 대한 가져 오기 라우터. 참조 &lt;a href=&quot;https://github.com/abseil/abseil-py&quot;&gt;https://github.com/abseil/abseil-py를&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3750f606daadb180526d7ccaf9a3482ec4910c6" translate="yes" xml:space="preserve">
          <source>Import router for absl.flags. See https://github.com/abseil/abseil-py.</source>
          <target state="translated">absl.flags 용 가져 오기 라우터. https://github.com/abseil/abseil-py를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d3375d44e4b643dfc4f13312d4430da6429af78a" translate="yes" xml:space="preserve">
          <source>Import router for file_io.</source>
          <target state="translated">file_io의 라우터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="c14a7d57f569579c21ce1fdc7d99c47f7db6b828" translate="yes" xml:space="preserve">
          <source>ImportError if HDF5 &amp;amp; h5py are not installed</source>
          <target state="translated">HDF5 및 h5py가 설치되지 않은 경우 ImportError</target>
        </trans-unit>
        <trans-unit id="241bfbb99446e43904d0271d5420c06643897761" translate="yes" xml:space="preserve">
          <source>ImportEvent</source>
          <target state="translated">ImportEvent</target>
        </trans-unit>
        <trans-unit id="06cbfad937d0c9edcdf28651087ed18c71fcfcc4" translate="yes" xml:space="preserve">
          <source>Important caveats:</source>
          <target state="translated">중요한 경고 사항 :</target>
        </trans-unit>
        <trans-unit id="d7515a79183f4fea6cdf71780ae3ef25fdf0ea35" translate="yes" xml:space="preserve">
          <source>Important note: This class &lt;em&gt;is not&lt;/em&gt; thread-safe for graph construction. All operations should be created from a single thread, or external synchronization must be provided. Unless otherwise specified, all methods are not thread-safe.</source>
          <target state="translated">중요 사항 :이 클래스 &lt;em&gt;는&lt;/em&gt; 그래프 생성에 스레드로부터 안전 &lt;em&gt;하지 않습니다&lt;/em&gt; . 모든 작업은 단일 스레드에서 작성하거나 외부 동기화를 제공해야합니다. 달리 지정하지 않는 한 모든 메소드는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dee6dd71bc893fc99d70b2da2a20f8ba1b604f3f" translate="yes" xml:space="preserve">
          <source>Important note: This validator checks if flag values are None, and it does not distinguish between default and explicit values. Therefore, this validator does not make sense when applied to flags with default values other than None, including other false values (e.g. False, 0, '', []). That includes multi flags with a default value of [] instead of None.</source>
          <target state="translated">중요 사항 :이 유효성 검증기는 플래그 값이 없음인지 확인하고 기본값과 명시 적 값을 구분하지 않습니다. 따라서이 유효성 검사기는 다른 잘못된 값 (예 : False, 0, '', [])을 포함하여 None 이외의 기본값을 가진 플래그에 적용 할 때는 의미가 없습니다. 여기에는 None 대신 기본값이 [] 인 다중 플래그가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d8c7b39b8707e89a6e9ce5503ad33254f378a175" translate="yes" xml:space="preserve">
          <source>Imports the graph from &lt;code&gt;graph_def&lt;/code&gt; into the current default &lt;code&gt;Graph&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">&lt;code&gt;graph_def&lt;/code&gt; 에서 현재 기본 &lt;code&gt;Graph&lt;/code&gt; 로 그래프를 가져옵니다 . (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="fe4ad23456cf41a5fe35769340815f2088fbbdc4" translate="yes" xml:space="preserve">
          <source>In &quot;CONSTANT&quot; mode, the scalar pad value to use. Must be same type as &lt;code&gt;tensor&lt;/code&gt;.</source>
          <target state="translated">&quot;CONSTANT&quot;모드에서 사용할 스칼라 패드 값입니다. &lt;code&gt;tensor&lt;/code&gt; 와 동일한 유형이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="73407b35ca652d79b02dd24b5db9d02e3e0e5f03" translate="yes" xml:space="preserve">
          <source>In 'MIN_COMBINED' mode, each value of the tensor will undergo the following:</source>
          <target state="translated">'MIN_COMBINED'모드에서 텐서의 각 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5dc7fe91c429ae9bf237811621354fd582a8d06b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CentralStorageStrategy&lt;/code&gt; there is a single worker so the value returned will be all the values on that worker.</source>
          <target state="translated">에서 &lt;code&gt;CentralStorageStrategy&lt;/code&gt; 값이 그 근로자에 대한 모든 값이 될 것입니다 반환, 그래서 하나의 노동자가있다.</target>
        </trans-unit>
        <trans-unit id="f911260e196d9d52bc11c1d245f364fa94ee6a5e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;CentralStorageStrategy&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is called on each of the compute replicas, with the provided &quot;per replica&quot; arguments specific to that device.</source>
          <target state="translated">에서 &lt;code&gt;CentralStorageStrategy&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; (가) 해당 장치에 인수 특정 &quot;복제 당&quot;제공과 함께, 컴퓨팅 복제본의 각 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="83a783316a9edd78ba1fd02d394a253388645aea" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;MultiWorkerMirroredStrategy&lt;/code&gt;, all variables created inside `strategy.scope() will be mirrored on all replicas of each worker. Moreover, it also sets a default device scope so that ops without specified devices will end up on the correct worker.</source>
          <target state="translated">&lt;code&gt;MultiWorkerMirroredStrategy&lt;/code&gt; 에서는 `strategy.scope () 내부에 생성 된 모든 변수가 각 작업자의 모든 복제본에 미러링됩니다. 또한 지정된 장치가없는 op가 올바른 작업자로 끝나도록 기본 장치 범위를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="fc27e94172bcfc6d46e82386176739ca5f0a870a" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, &lt;code&gt;fn&lt;/code&gt; is simply called within a device scope for the given device, with the provided arguments.</source>
          <target state="translated">에서 &lt;code&gt;OneDeviceStrategy&lt;/code&gt; , &lt;code&gt;fn&lt;/code&gt; 단순히 제공된 인수, 주어진 장치에 대한 장치 범위 내에서라고합니다.</target>
        </trans-unit>
        <trans-unit id="a37b98485da84e0982814ff7b9a05e1c529e56f1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, all variables created inside &lt;code&gt;strategy.scope()&lt;/code&gt; will be on &lt;code&gt;device&lt;/code&gt; specified at strategy construction time. See example in the docs for this class.</source>
          <target state="translated">에서는 &lt;code&gt;OneDeviceStrategy&lt;/code&gt; , 내부에서 생성 된 모든 변수 &lt;code&gt;strategy.scope()&lt;/code&gt; 에있을 것이다 &lt;code&gt;device&lt;/code&gt; 전략 시공시에 지정. 이 클래스의 문서에서 예제를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="89dca9293fe8e75256246ee570af4561031fe2c4" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, the &lt;code&gt;value&lt;/code&gt; is always expected to be a single value, so the result is just the value in a tuple.</source>
          <target state="translated">에서 &lt;code&gt;OneDeviceStrategy&lt;/code&gt; 의 &lt;code&gt;value&lt;/code&gt; 결과가 튜플 단지 값이 있으므로 항상 하나의 값이 될 것으로 예상된다.</target>
        </trans-unit>
        <trans-unit id="5d17dc9c8bbe0f8426ef33525f3803ac13280d23" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OneDeviceStrategy&lt;/code&gt;, there is only one replica, so if axis=None, value is simply returned. If axis is specified as something other than None, such as axis=0, value is reduced along that axis and returned.</source>
          <target state="translated">에서는 &lt;code&gt;OneDeviceStrategy&lt;/code&gt; 축 = 없음, 값이 단순히 반환 그렇다면, 하나의 복제본이있다. axis = 0과 같이 None 이외의 값으로 axis를 지정하면 해당 축을 따라 값이 줄어들고 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64ad04a752452a82392f727330adb50f1b0ef1ed" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;PREDICT&lt;/code&gt; mode, only returns logits and predictions (&lt;code&gt;=tf.sigmoid(logits)&lt;/code&gt;), whereas &lt;code&gt;BinaryClassHead&lt;/code&gt; also returns probabilities, classes, and class_ids.</source>
          <target state="translated">&lt;code&gt;PREDICT&lt;/code&gt; 모드 에서는 로짓과 예측 ( &lt;code&gt;=tf.sigmoid(logits)&lt;/code&gt; ) 만 반환 하지만 &lt;code&gt;BinaryClassHead&lt;/code&gt; 는 확률, 클래스 및 class_id도 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f12d35a27cca8e8a6a072f66b7e466bedf447861" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;compact&lt;/code&gt; format the three diagonals are brought together into one tensor of shape &lt;code&gt;[..., 3, M]&lt;/code&gt;, with last two dimensions containing superdiagonals, diagonals, and subdiagonals, in order. Similarly to &lt;code&gt;sequence&lt;/code&gt; format, elements &lt;code&gt;diagonals[..., 0, M-1]&lt;/code&gt; and &lt;code&gt;diagonals[..., 2, 0]&lt;/code&gt; are ignored.</source>
          <target state="translated">에서는 &lt;code&gt;compact&lt;/code&gt; 포맷 세 대각선 형상 중 하나 텐서에 소집되어 &lt;code&gt;[..., 3, M]&lt;/code&gt; 마지막 두 치수 위해 superdiagonals 대각선 및 subdiagonals을 함유. &lt;code&gt;sequence&lt;/code&gt; 형식과 유사하게 &lt;code&gt;diagonals[..., 0, M-1]&lt;/code&gt; 및 &lt;code&gt;diagonals[..., 2, 0]&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="66cbdb97f05830f246eaf05dcd7ae0826bf8f242" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;matrix&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; must be a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt;, with two inner-most dimensions representing the square tridiagonal matrices. Elements outside of the three diagonals will be ignored.</source>
          <target state="translated">에서는 &lt;code&gt;matrix&lt;/code&gt; 형식 &lt;code&gt;diagonals&lt;/code&gt; 형상의 텐서 있어야 &lt;code&gt;[..., M, M]&lt;/code&gt; 사각형 삼중 대각 행렬들을 나타내는 두 개의 가장 안쪽 치수. 세 대각선 이외의 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8148d8cfce5b0dec87e1cdaa0ca93570d75b1c32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;numpy&lt;/code&gt; transposes are memory-efficient constant time operations as they simply return a new view of the same data with adjusted &lt;code&gt;strides&lt;/code&gt;.</source>
          <target state="translated">에서는 &lt;code&gt;numpy&lt;/code&gt; 전치 단순히 조정과 같은 새로운 데이터보기로 복귀 메모리 효율적인 일정 시간 조작되어 &lt;code&gt;strides&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02241eae37adc7c28b9d589b3d5cb723cc8b981e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sequence&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; are supplied as a tuple or list of three tensors of shapes &lt;code&gt;[..., N]&lt;/code&gt;, &lt;code&gt;[..., M]&lt;/code&gt;, &lt;code&gt;[..., N]&lt;/code&gt; representing superdiagonals, diagonals, and subdiagonals, respectively. &lt;code&gt;N&lt;/code&gt; can be either &lt;code&gt;M-1&lt;/code&gt; or &lt;code&gt;M&lt;/code&gt;; in the latter case, the last element of superdiagonal and the first element of subdiagonal will be ignored.</source>
          <target state="translated">에서는 &lt;code&gt;sequence&lt;/code&gt; 형식 &lt;code&gt;diagonals&lt;/code&gt; 튜플 또는 도형의 세 텐서 목록으로 공급된다 &lt;code&gt;[..., N]&lt;/code&gt; , &lt;code&gt;[..., M]&lt;/code&gt; , &lt;code&gt;[..., N]&lt;/code&gt; 은 각각 superdiagonals 대각선 및 subdiagonals 나타내는. &lt;code&gt;N&lt;/code&gt; 은 &lt;code&gt;M-1&lt;/code&gt; 또는 &lt;code&gt;M&lt;/code&gt; 일 수 있고 ; 후자의 경우, 초 대각선의 마지막 요소와 하위 대각선의 첫 번째 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5a812208d3ae75e4f5c273197394db05dc66f0f9" translate="yes" xml:space="preserve">
          <source>In Candidate Sampling, this operation facilitates virtually removing sampled classes which happen to match target classes. This is done in Sampled Softmax and Sampled Logistic.</source>
          <target state="translated">후보 샘플링에서이 작업을 수행하면 대상 클래스와 일치하는 샘플 클래스를 거의 제거 할 수 있습니다. 이는 Sampled Softmax 및 Sampled Logistic에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="6d03c984270e6b66cc992ac2d4de0113fb1792f7" translate="yes" xml:space="preserve">
          <source>In Keras models, sometimes variables are created when the model is first called, instead of construction time. Examples include 1) sequential models without input shape pre-defined, or 2) subclassed models. Pass var_list as callable in these cases.</source>
          <target state="translated">Keras 모델에서는 구성 시간 대신 모델을 처음 호출 할 때 변수가 생성되는 경우가 있습니다. 예를 들어 1) 입력 모양이 사전 정의되지 않은 순차 모델 또는 2) 서브 클래스 모델이 있습니다. 이 경우 var_list를 호출 가능한 것으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="6d24dc0640eec7767c8580a01fe0f2534a32f8b6" translate="yes" xml:space="preserve">
          <source>In Python, this scatter add operation would look like this:</source>
          <target state="translated">파이썬에서이 분산 추가 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17844ec0dbf5e24da91f6ffe78f9342efe5f4f37" translate="yes" xml:space="preserve">
          <source>In Python, this scatter operation would look like this:</source>
          <target state="translated">파이썬에서이 분산 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81965bf71c83e468654101016f87a74649d16e39" translate="yes" xml:space="preserve">
          <source>In Python, this scatter subtract operation would look like this:</source>
          <target state="translated">파이썬에서이 분산 빼기 연산은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="3d8782d76c3f4b01f4fdcf84d62e403122ad04f2" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">TF 2.0에서 &lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; 객체는 Python 반복 가능하므로 Python 반복을 통해 에포크를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb7ca0c46558f03e6086af25fef434bd7045721" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">TF 2.0에서 &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; 객체는 Python 반복 가능하므로 Python 반복을 통해 에포크를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b30346591377f8c72aca3c84be793a8ed9d8c0f" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">TF 2.0에서 &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; 객체는 Python 반복 가능하므로 Python 반복을 통해 에포크를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e9b024a95539e5d2ffaf50c0d7d26e7f011943" translate="yes" xml:space="preserve">
          <source>In TF 2.0, &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; objects are Python iterables which makes it possible to also create epochs through Python iteration:</source>
          <target state="translated">TF 2.0에서 &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; 객체는 Python 반복 가능하므로 Python 반복을 통해 에포크를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fdae45e06a3d82dc5e8823e248b14458447ba71" translate="yes" xml:space="preserve">
          <source>In TensorFlow 1, only the &quot;infer&quot; policy is available.</source>
          <target state="translated">TensorFlow 1에서는 &quot;추론&quot;정책 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5252a64a0f9e26ac451b24dc3a78078e2d45a06e" translate="yes" xml:space="preserve">
          <source>In TensorFlow 2.0, iterating over a TensorShape instance returns values.</source>
          <target state="translated">TensorFlow 2.0에서 TensorShape 인스턴스를 반복하면 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4632390b454bb4fddbcccffafb20fab0ac9e532b" translate="yes" xml:space="preserve">
          <source>In TensorFlow 2.0, representing tensors as protos should no longer be a common workflow. That said, this utility function is still useful for generating TF Serving request protos:</source>
          <target state="translated">TensorFlow 2.0에서 텐서를 프로토로 나타내는 것은 더 이상 일반적인 워크 플로가 아니어야합니다. 즉,이 유틸리티 기능은 TF 서빙 요청 프로토 타입을 생성하는 데 여전히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4d52755e5ee76e2c362b3006fe73af38e7a988b4" translate="yes" xml:space="preserve">
          <source>In TensorFlow distributed environment, each job may have an applicable task id, which is the index of the instance within its task type. This is useful when user needs to run specific code according to task index. For example,</source>
          <target state="translated">TensorFlow 분산 환경에서 각 작업에는 해당 작업 유형 내 인스턴스의 색인 인 적용 가능한 작업 ID가있을 수 있습니다. 사용자가 작업 인덱스에 따라 특정 코드를 실행해야 할 때 유용합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="3c85eb2376f8951b058a131e7a9b908f6bdef73c" translate="yes" xml:space="preserve">
          <source>In TensorFlow distributed environment, each job may have an applicable task type. Valid task types in TensorFlow include 'chief': a worker that is designated with more responsibility, 'worker': a regular worker for training/evaluation, 'ps': a parameter server, or 'evaluator': an evaluator that evaluates the checkpoints for metrics.</source>
          <target state="translated">TensorFlow 분산 환경에서 각 작업에는 적용 가능한 작업 유형이있을 수 있습니다. TensorFlow의 유효한 작업 유형에는 'chief': 더 많은 책임을 맡은 작업자, 'worker': 교육 / 평가를위한 정규 작업자, 'ps': 매개 변수 서버 또는 'evaluator': 체크 포인트를 평가하는 평가자가 포함됩니다. 메트릭입니다.</target>
        </trans-unit>
        <trans-unit id="1127e50fd25c3f8e9dda641959bbb9354598c6f4" translate="yes" xml:space="preserve">
          <source>In TensorFlow, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;s are a common way to define graph execution.</source>
          <target state="translated">TensorFlow에서 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 은 그래프 실행을 정의하는 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e8db8f91b921bd7ce4f80fb0d9da7d36b0960f78" translate="yes" xml:space="preserve">
          <source>In V1, the exported CPU graph is &lt;code&gt;model_fn&lt;/code&gt; as it is. The exported TPU graph wraps &lt;code&gt;tpu.rewrite()&lt;/code&gt; and &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; around &lt;code&gt;model_fn&lt;/code&gt; so &lt;code&gt;model_fn&lt;/code&gt; is on TPU by default. To place ops on CPU, &lt;code&gt;tpu.outside_compilation(host_call, logits)&lt;/code&gt; can be used.</source>
          <target state="translated">V1에서 내 보낸 CPU 그래프는 &lt;code&gt;model_fn&lt;/code&gt; 입니다. 내 보낸 TPU 그래프는 &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; 주위에 &lt;code&gt;model_fn&lt;/code&gt; &lt;code&gt;tpu.rewrite()&lt;/code&gt; 및 TPUPartitionedCallOp 를 래핑 하므로 &lt;code&gt;model_fn&lt;/code&gt; 은 기본적으로 TPU에 있습니다. CPU에 op를 배치하기 위해 &lt;code&gt;tpu.outside_compilation(host_call, logits)&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96357d45f74c44c1cd59ce5a4e69f6c961b9be20" translate="yes" xml:space="preserve">
          <source>In V2, &lt;code&gt;export_saved_model()&lt;/code&gt; sets up &lt;code&gt;params['use_tpu']&lt;/code&gt; flag to let the user know if the code is exporting to TPU (or not). When &lt;code&gt;params['use_tpu']&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, users need to call &lt;code&gt;tpu.rewrite()&lt;/code&gt;, &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; and/or &lt;code&gt;batch_function()&lt;/code&gt;. Alternatively use &lt;code&gt;inference_on_tpu()&lt;/code&gt; which is a convenience wrapper of the three.</source>
          <target state="translated">V2에서 &lt;code&gt;export_saved_model()&lt;/code&gt; 은 &lt;code&gt;params['use_tpu']&lt;/code&gt; 플래그를 설정하여 코드가 TPU로 내보내는 지 여부를 사용자에게 알립니다 . 때 &lt;code&gt;params['use_tpu']&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; , 사용자는 호출 할 필요가 &lt;code&gt;tpu.rewrite()&lt;/code&gt; , &lt;code&gt;TPUPartitionedCallOp&lt;/code&gt; 및 / 또는 &lt;code&gt;batch_function()&lt;/code&gt; . 또는 세 가지 편의 래퍼 인 &lt;code&gt;inference_on_tpu()&lt;/code&gt; 를 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="0ea5307e4ab9dbcd3254304c2d948acdc37b34b0" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or when building a model using &lt;a href=&quot;keras/input&quot;&gt;&lt;code&gt;tf.keras.Input&lt;/code&gt;&lt;/a&gt;, they return the build-time shape of the tensor, which may be partially unknown.</source>
          <target state="translated">A의 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 사용하여 모델을 구축 할 때 &lt;a href=&quot;keras/input&quot;&gt; &lt;code&gt;tf.keras.Input&lt;/code&gt; 을&lt;/a&gt; , 그들은 부분적으로 알 수 있습니다 텐서의 빌드 타임 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6fa5bd380e5aa574a254ecdd687c73cfcb27bf28" translate="yes" xml:space="preserve">
          <source>In a multi-worker setting, we will first attempt to distribute the dataset by attempting to detect whether the dataset is being created out of ReaderDatasets (e.g. TFRecordDataset, TextLineDataset, etc.) and if so, attempting to shard the input files. Note that there has to be at least one input file per worker. If you have less than one input file per worker, we suggest that you should disable distributing your dataset using the method below.</source>
          <target state="translated">다중 작업자 설정에서는 먼저 데이터 세트가 ReaderDatasets (예 : TFRecordDataset, TextLineDataset 등)에서 생성되는지 여부를 감지하고 입력 파일을 분할하려고 시도하여 데이터 세트를 분배하려고 시도합니다. 작업 자당 하나 이상의 입력 파일이 있어야합니다. 작업 자당 입력 ​​파일이 2 개 미만인 경우 아래 방법을 사용하여 데이터 세트 배포를 비활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="dfef8f2d9cb8b91e7e364f089f14bf6f6b4950f4" translate="yes" xml:space="preserve">
          <source>In a pure mathematical sense, a vector-argument vector-valued function &lt;code&gt;f&lt;/code&gt;'s derivatives should be its Jacobian matrix &lt;code&gt;J&lt;/code&gt;. Here we are expressing the Jacobian &lt;code&gt;J&lt;/code&gt; as a function &lt;code&gt;grad_fn&lt;/code&gt; which defines how &lt;code&gt;J&lt;/code&gt; will transform a vector &lt;code&gt;grad_ys&lt;/code&gt; when left-multiplied with it (&lt;code&gt;grad_ys * J&lt;/code&gt;, the vector-Jacobian product, or VJP). This functional representation of a matrix is convenient to use for chain-rule calculation (in e.g. the back-propagation algorithm).</source>
          <target state="translated">순수한 수학적 의미에서 벡터 인수 벡터 값 함수 &lt;code&gt;f&lt;/code&gt; 의 도함수는 야 코비 행렬 &lt;code&gt;J&lt;/code&gt; 여야합니다 . 여기서 우리는 Jacobian &lt;code&gt;J&lt;/code&gt; 를 &lt;code&gt;grad_fn&lt;/code&gt; 함수로 표현하고 있습니다.이 함수 는 &lt;code&gt;J&lt;/code&gt; 가 벡터 &lt;code&gt;grad_ys&lt;/code&gt; 와 왼쪽 곱하기 ( &lt;code&gt;grad_ys * J&lt;/code&gt; , vector-Jacobian product 또는 VJP) 할 때 벡터 grad_ys 를 변환하는 방법을 정의합니다 . 행렬의이 기능적 표현은 체인 규칙 계산 (예 : 역 전파 알고리즘)에 사용하기 편리합니다.</target>
        </trans-unit>
        <trans-unit id="3a1189c10d2b5b4c2dfe6ce8f122a5b82d16ddb6" translate="yes" xml:space="preserve">
          <source>In a replica context, you may freely read the values of variables, but you may only update their value if they specify a way to aggregate the update using the &lt;code&gt;aggregation&lt;/code&gt; parameter in the variable's constructor. In a cross-replica context, you may read or write variables (writes may need to be broadcast to all copies of the variable if it is mirrored).</source>
          <target state="translated">복제본 컨텍스트에서 변수 값을 자유롭게 읽을 수 있지만 변수 생성자 의 &lt;code&gt;aggregation&lt;/code&gt; 매개 변수를 사용하여 업데이트를 집계하는 방법을 지정하는 경우에만 해당 값을 업데이트 할 수 있습니다 . 교차 복제 컨텍스트에서 변수를 읽거나 쓸 수 있습니다 (쓰기가 변수의 미러링 된 경우 모든 사본에 브로드 캐스트해야 할 수도 있음).</target>
        </trans-unit>
        <trans-unit id="5a6a3b1bf3355979185c8ba5fde475cd00334849" translate="yes" xml:space="preserve">
          <source>In a session, computes and returns the value of this variable.</source>
          <target state="translated">세션에서이 변수의 값을 계산하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2522a9b6956696f7d2f65c27000e4d85acba5fa9" translate="yes" xml:space="preserve">
          <source>In a typical asynchronous training environment, it's common to have some stale gradients. For example, with a N-replica asynchronous training, gradients will be applied to the variables N times independently. Depending on each replica's training speed, some gradients might be calculated from copies of the variable from several steps back (N-1 steps on average). This optimizer avoids stale gradients by collecting gradients from all replicas, averaging them, then applying them to the variables in one shot, after which replicas can fetch the new variables and continue.</source>
          <target state="translated">일반적인 비동기식 교육 환경에서는 오래된 그라디언트가 일반적입니다. 예를 들어 N- 복제본 비동기 훈련을 사용하면 그라디언트가 변수 N에 독립적으로 적용됩니다. 각 복제본의 훈련 속도에 따라 몇 단계 뒤로 변수의 사본에서 일부 그라디언트가 계산 될 수 있습니다 (평균 N-1 단계). 이 옵티마이 저는 모든 복제본에서 그라디언트를 수집하여 평균화 한 다음 한 번에 변수에 적용하여 새 변수를 가져오고 계속함으로써 오래된 그라디언트를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="add8c5b79597d8fbfc4deddcbbc75442d1193218" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;row_splits&lt;/code&gt;, ragged tensors provide support for five other row-partitioning schemes:</source>
          <target state="translated">&lt;code&gt;row_splits&lt;/code&gt; 외에도 비정형 텐서는 5 개의 다른 행 분할 체계를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7f5c7e39ca1e2646f184bebbdccd8352fd472889" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;row_splits&lt;/code&gt;, ragged tensors provide support for four other row-partitioning schemes:</source>
          <target state="translated">비정형 텐서는 &lt;code&gt;row_splits&lt;/code&gt; 외에도 4 개의 다른 행 파티셔닝 구성표를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="c4c6856a33d33c73a855c3ce15ea6283e7abc71a" translate="yes" xml:space="preserve">
          <source>In addition to checkpoint files, savers keep a protocol buffer on disk with the list of recent checkpoints. This is used to manage numbered checkpoint files and by &lt;code&gt;latest_checkpoint()&lt;/code&gt;, which makes it easy to discover the path to the most recent checkpoint. That protocol buffer is stored in a file named 'checkpoint' next to the checkpoint files.</source>
          <target state="translated">검사기는 검사 점 파일 외에도 최근 검사 점 목록과 함께 프로토콜 버퍼를 디스크에 보관합니다. 번호가 지정된 체크 포인트 파일을 관리하고 &lt;code&gt;latest_checkpoint()&lt;/code&gt; 를 사용하여 가장 최근의 체크 포인트에 대한 경로를 쉽게 찾을 수 있습니다. 해당 프로토콜 버퍼는 검사 점 파일 옆에 'checkpoint'라는 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="440848afff541ac2b1bbb1684820f47d256a8eae" translate="yes" xml:space="preserve">
          <source>In addition to exporting, this class also garbage collects stale exports.</source>
          <target state="translated">이 클래스는 내보내기 외에도 부실한 내보내기를 수집합니다.</target>
        </trans-unit>
        <trans-unit id="3ba65f5de5f4ca5afe2d4c86c2ddac7a22edaf68" translate="yes" xml:space="preserve">
          <source>In addition to regular Tensors or IndexedSlices, the body may accept and return TensorArray objects. The flows of the TensorArray objects will be appropriately forwarded between loops and during gradient calculations.</source>
          <target state="translated">바디는 일반 텐서 나 IndexedSlices 외에도 TensorArray 객체를 받아 반환 할 수 있습니다. TensorArray 객체의 흐름은 루프간에 그리고 그래디언트 계산 중에 적절하게 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="b83ef61c3670f06537ff1c141b52be7ac2a9fe87" translate="yes" xml:space="preserve">
          <source>In addition to slot variables which should be colocated with their primary variables, optimizers also define non-slot variables. These can be things like &quot;number of step updates performed&quot; or &quot;beta1^t&quot; and &quot;beta2^t&quot;. Each strategy has some policy for which devices those variables should be copied too, called the &quot;non-slot devices&quot; (some subset of the parameter devices). We require that all non-slot variables are allocated on the same device, or mirrored across the same set of devices. You can use &lt;a href=&quot;../../../distribute/strategyextended#non_slot_devices&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt;&lt;/a&gt; to pick a consistent set of devices to pass to both &lt;a href=&quot;../../../distribute/strategyextended#colocate_vars_with&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../../distribute/strategyextended#update_non_slot&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵티마이 저는 1 차 변수와 함께 배치해야하는 슬롯 변수 외에도 슬롯 이외의 변수를 정의합니다. &quot;수행 된 단계 업데이트 수&quot;또는 &quot;beta1 ^ t&quot;및 &quot;beta2 ^ t&quot;와 같은 것일 수 있습니다. 각 전략에는 &quot;비 슬롯 장치&quot;(일부 매개 변수 장치의 일부)라고하는 이러한 변수도 복사해야하는 장치에 대한 정책이 있습니다. 슬롯 이외의 모든 변수는 동일한 장치에 할당되거나 동일한 장치 세트에 미러링되어야합니다. &lt;a href=&quot;../../../distribute/strategyextended#non_slot_devices&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;a href=&quot;../../../distribute/strategyextended#colocate_vars_with&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../../distribute/strategyextended#update_non_slot&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt; &lt;/a&gt; 모두에 전달할 일관된 장치 세트를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="72581f64b9b0dd39e47dc7fa9df7182573016778" translate="yes" xml:space="preserve">
          <source>In addition to slot variables which should be colocated with their primary variables, optimizers also define non-slot variables. These can be things like &quot;number of step updates performed&quot; or &quot;beta1^t&quot; and &quot;beta2^t&quot;. Each strategy has some policy for which devices those variables should be copied too, called the &quot;non-slot devices&quot; (some subset of the parameter devices). We require that all non-slot variables are allocated on the same device, or mirrored across the same set of devices. You can use &lt;a href=&quot;strategyextended#non_slot_devices&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt;&lt;/a&gt; to pick a consistent set of devices to pass to both &lt;a href=&quot;strategyextended#colocate_vars_with&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;strategyextended#update_non_slot&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">옵티마이 저는 1 차 변수와 함께 배치해야하는 슬롯 변수 외에도 슬롯 이외의 변수를 정의합니다. &quot;수행 된 단계 업데이트 수&quot;또는 &quot;beta1 ^ t&quot;및 &quot;beta2 ^ t&quot;와 같은 것일 수 있습니다. 각 전략에는 &quot;비 슬롯 장치&quot;(일부 매개 변수 장치의 일부)라고하는 이러한 변수도 복사해야하는 장치에 대한 정책이 있습니다. 슬롯 이외의 모든 변수는 동일한 장치에 할당되거나 동일한 장치 세트에 미러링되어야합니다. &lt;a href=&quot;strategyextended#non_slot_devices&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.non_slot_devices&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;a href=&quot;strategyextended#colocate_vars_with&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.colocate_vars_with&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;strategyextended#update_non_slot&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended.update_non_slot&lt;/code&gt; &lt;/a&gt; 모두에 전달할 일관된 장치 세트를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d87268b6a8ad6822e1a801c24a40186835816c0b" translate="yes" xml:space="preserve">
          <source>In addition to the above mentioned policies, a policy can also be &quot;infer&quot;. This Policy is deprecated, and it is not recommended. When a layer has an infer policy, it will infer the computation and variable dtype from the first input the first time the layer is called. Once the layer is called for the first time, the layer's policy will change to the dtype of the first input.</source>
          <target state="translated">위에서 언급 한 정책 외에도 정책은 &quot;추론&quot;될 수 있습니다. 이 정책은 더 이상 사용되지 않으며 권장되지 않습니다. 레이어에 추론 정책이 있으면 레이어를 처음 호출 할 때 첫 번째 입력에서 계산 및 변수 dtype을 추론합니다. 레이어가 처음 호출되면 레이어의 정책이 첫 번째 입력의 dtype으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="9b6a36c1b72da17b3ac1903013012d88a399c6a3" translate="yes" xml:space="preserve">
          <source>In addition, either &lt;code&gt;save_checkpoints_steps&lt;/code&gt; or &lt;code&gt;save_checkpoints_secs&lt;/code&gt; can be set (should not be both).</source>
          <target state="translated">또한 &lt;code&gt;save_checkpoints_steps&lt;/code&gt; 또는 &lt;code&gt;save_checkpoints_secs&lt;/code&gt; 를 설정할 수 있습니다 (둘다는 안 됨).</target>
        </trans-unit>
        <trans-unit id="a8be97737386632e5930d1a505669c0ea1a77181" translate="yes" xml:space="preserve">
          <source>In addition, non-raising iteration is supported via &lt;code&gt;get_next_as_optional()&lt;/code&gt;, which returns the next element (if available) wrapped in a &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 &lt;a href=&quot;../experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; 에&lt;/a&gt; 래핑 된 다음 요소 (사용 가능한 경우)를 반환하는 &lt;code&gt;get_next_as_optional()&lt;/code&gt; 통해 비 상승 반복이 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="555925888abcb6ab1ea3af1dd5cd6edbb9ea4874" translate="yes" xml:space="preserve">
          <source>In addition, this operation returns tensors &lt;code&gt;true_expected_count&lt;/code&gt; and &lt;code&gt;sampled_expected_count&lt;/code&gt; representing the number of times each of the target classes (&lt;code&gt;true_classes&lt;/code&gt;) and the sampled classes (&lt;code&gt;sampled_candidates&lt;/code&gt;) is expected to occur in an average tensor of sampled classes. These values correspond to &lt;code&gt;Q(y|x)&lt;/code&gt; defined in &lt;a href=&quot;http://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;this document&lt;/a&gt;. If &lt;code&gt;unique=True&lt;/code&gt;, then these are post-rejection probabilities and we compute them approximately.</source>
          <target state="translated">또한이 작업은 각 대상 클래스 ( &lt;code&gt;true_classes&lt;/code&gt; ) 및 샘플링 된 클래스 ( &lt;code&gt;sampled_candidates&lt;/code&gt; )가 샘플링 된 클래스의 평균 텐서에서 발생할 것으로 예상되는 횟수를 나타내는 &lt;code&gt;true_expected_count&lt;/code&gt; 및 &lt;code&gt;sampled_expected_count&lt;/code&gt; 텐서를 반환합니다 . 이 값 은 &lt;a href=&quot;http://www.tensorflow.org/extras/candidate_sampling.pdf&quot;&gt;이 문서에&lt;/a&gt; 정의 된 &lt;code&gt;Q(y|x)&lt;/code&gt; 해당합니다 . 경우 &lt;code&gt;unique=True&lt;/code&gt; , 다음이 포스트 거부 확률은 우리가 약을 계산한다.</target>
        </trans-unit>
        <trans-unit id="7dcd7b097b6d5afefa90c28e9166ddea07927f7a" translate="yes" xml:space="preserve">
          <source>In all cases, an exception is raised if &lt;em&gt;invalid&lt;/em&gt; parameters are passed, e.g.</source>
          <target state="translated">모든 경우에 &lt;em&gt;유효하지 않은&lt;/em&gt; 매개 변수가 전달 되면 예외가 발생합니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="528f7eb98213e1189f2afa9ee728c00ddb010d6a" translate="yes" xml:space="preserve">
          <source>In all cases, suppose &lt;code&gt;operator&lt;/code&gt; is a &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; of shape &lt;code&gt;[M, N]&lt;/code&gt;, and &lt;code&gt;x.shape = [N, R]&lt;/code&gt;. Then</source>
          <target state="translated">모든 경우에 &lt;code&gt;operator&lt;/code&gt; 가 &lt;code&gt;[M, N]&lt;/code&gt; 모양 의 &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; 이고 &lt;code&gt;x.shape = [N, R]&lt;/code&gt; . 그때</target>
        </trans-unit>
        <trans-unit id="93b282de1b601498957a67e9a5151ecf41c723ca" translate="yes" xml:space="preserve">
          <source>In all generality, they can have the same number of dimensions as the input &lt;code&gt;x&lt;/code&gt;, with identical sizes as &lt;code&gt;x&lt;/code&gt; for the dimensions that are not normalized over (the 'depth' dimension(s)), and dimension 1 for the others which are being normalized over. &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt; in this case would typically be the outputs of &lt;a href=&quot;moments&quot;&gt;&lt;code&gt;tf.nn.moments(..., keepdims=True)&lt;/code&gt;&lt;/a&gt; during training, or running averages thereof during inference.</source>
          <target state="translated">모든 일반성, 그들은 입력으로서 치수 동일한 수의 수 &lt;code&gt;x&lt;/code&gt; 와 같은 동일한 크기, &lt;code&gt;x&lt;/code&gt; 위에 정규화되지 않은 치수를 타인합니다 ( &quot;깊이&quot;치수 (S)) 및 치수도 1은 인되고 정상화되었습니다. 이 경우 &lt;code&gt;mean&lt;/code&gt; 과 &lt;code&gt;variance&lt;/code&gt; 은 일반적으로 훈련 중 &lt;a href=&quot;moments&quot;&gt; &lt;code&gt;tf.nn.moments(..., keepdims=True)&lt;/code&gt; &lt;/a&gt; 의 출력 또는 추론 중 평균 실행입니다.</target>
        </trans-unit>
        <trans-unit id="af9bb28b05876d0ccb840fb8a94305e3cb54b9b8" translate="yes" xml:space="preserve">
          <source>In async execution mode, an error in op/function execution can lead to errors in subsequent ops/functions that are scheduled but not yet executed. Calling this method clears all pending operations and reset the async execution state.</source>
          <target state="translated">비동기 실행 모드에서 작업 / 기능 실행 오류로 인해 예약되었지만 아직 실행되지 않은 후속 작업 / 기능에서 오류가 발생할 수 있습니다. 이 메서드를 호출하면 보류중인 모든 작업이 지워지고 비동기 실행 상태가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="dbe8f97776752806df6355aaaa49e006af4475b5" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;dim(x) == 1&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;dim(x) == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e59ff15195ac0b7ba502c82f75c359a3a89caeb8" translate="yes" xml:space="preserve">
          <source>In case &lt;code&gt;x&lt;/code&gt; is not a symbolic tensor.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 기호 텐서가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="956b77064ba946148cb66db1a94e9bc12bc62027" translate="yes" xml:space="preserve">
          <source>In case a simplified &lt;code&gt;str&lt;/code&gt; version of the path is needed from an &lt;code&gt;os.PathLike&lt;/code&gt; object</source>
          <target state="translated">&lt;code&gt;os.PathLike&lt;/code&gt; 객체 에서 경로 의 단순화 된 &lt;code&gt;str&lt;/code&gt; 버전이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="30551f2608204c57e8337c88a4d6f97d73d92a19" translate="yes" xml:space="preserve">
          <source>In case any gradient cannot be computed (e.g. if gradient function not implemented).</source>
          <target state="translated">그라디언트를 계산할 수없는 경우 (예 : 그라디언트 기능이 구현되지 않은 경우).</target>
        </trans-unit>
        <trans-unit id="1942b63ea63dd70e10beed0fe1ee42f2a0cdf472" translate="yes" xml:space="preserve">
          <source>In case of an invalid savefile.</source>
          <target state="translated">유효하지 않은 저장 파일의 경우.</target>
        </trans-unit>
        <trans-unit id="df42ea719e7879084ed8921f411b4a23cb710e77" translate="yes" xml:space="preserve">
          <source>In case of an invalid value for the &quot;scale&quot;, mode&quot; or &quot;distribution&quot; arguments.</source>
          <target state="translated">&quot;scale&quot;, mode &quot;또는&quot;distribution &quot;인수에 유효하지 않은 값이있는 경우.</target>
        </trans-unit>
        <trans-unit id="49bc9a2673c96fd0fd0baf753f07cc548462df41" translate="yes" xml:space="preserve">
          <source>In case of identity returns the smallest index.</source>
          <target state="translated">ID의 경우 가장 작은 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="27a756fd05962bc6c4d94331c5d62934a1832aad" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;count_mode&lt;/code&gt;.</source>
          <target state="translated">잘못된 &lt;code&gt;count_mode&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="c2e5909e8575c0cbcfc7db58a53aa66c85848f81" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;data_format&lt;/code&gt; value.</source>
          <target state="translated">잘못된 &lt;code&gt;data_format&lt;/code&gt; 값의 경우.</target>
        </trans-unit>
        <trans-unit id="ff1717d00a3a0045ddd9f92c5cc529a4e7c9f003" translate="yes" xml:space="preserve">
          <source>In case of invalid &lt;code&gt;merge_mode&lt;/code&gt; argument.</source>
          <target state="translated">잘못된 &lt;code&gt;merge_mode&lt;/code&gt; 인수의 경우</target>
        </trans-unit>
        <trans-unit id="97f5045ff946d97ba4c9acb1689a743a28154c87" translate="yes" xml:space="preserve">
          <source>In case of invalid argument for &lt;code&gt;weights&lt;/code&gt;, or invalid input shape.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 에 대한 잘못된 인수 또는 잘못된 입력 형태 인 경우.</target>
        </trans-unit>
        <trans-unit id="fcb8a53372e8c458d83ef7d391910d625cbd8153" translate="yes" xml:space="preserve">
          <source>In case of invalid arguments for &lt;code&gt;optimizer&lt;/code&gt;, &lt;code&gt;loss&lt;/code&gt; or &lt;code&gt;metrics&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;optimizer&lt;/code&gt; , &lt;code&gt;loss&lt;/code&gt; 또는 &lt;code&gt;metrics&lt;/code&gt; 대한 잘못된 인수의 경우 .</target>
        </trans-unit>
        <trans-unit id="59e673c8fb2afe88153bb056ca340c78ed246af7" translate="yes" xml:space="preserve">
          <source>In case of invalid layer name or index.</source>
          <target state="translated">레이어 이름 또는 인덱스가 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="21767b805d2046804a0b0734c4781738bfc5c332" translate="yes" xml:space="preserve">
          <source>In case of invalid shape for &lt;code&gt;y&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 인수 에 유효하지 않은 형태의 경우 .</target>
        </trans-unit>
        <trans-unit id="3b74392dc8d34a728d3b0ec6714f69356073b4cb" translate="yes" xml:space="preserve">
          <source>In case of invalid shape of the &lt;code&gt;pred&lt;/code&gt; array (must be 2D).</source>
          <target state="translated">&lt;code&gt;pred&lt;/code&gt; 배열의 모양이 잘못된 경우 (2D 여야 함).</target>
        </trans-unit>
        <trans-unit id="298ea3c5b9bb5ef3bfdac85152badfbfd0186005" translate="yes" xml:space="preserve">
          <source>In case of invalid user-provided arguments.</source>
          <target state="translated">잘못된 사용자 제공 인수의 경우.</target>
        </trans-unit>
        <trans-unit id="be920aa09b321446df6b0f1334f4492100d28e32" translate="yes" xml:space="preserve">
          <source>In case of invalid value.</source>
          <target state="translated">값이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="c4d6f8d31911fd565c48ceb279f3955fdb2afb4f" translate="yes" xml:space="preserve">
          <source>In case of invalid values for &lt;code&gt;truncating&lt;/code&gt; or &lt;code&gt;padding&lt;/code&gt;, or in case of invalid shape for a &lt;code&gt;sequences&lt;/code&gt; entry.</source>
          <target state="translated">&lt;code&gt;truncating&lt;/code&gt; 또는 &lt;code&gt;padding&lt;/code&gt; 에 유효하지 않은 값이 있거나 &lt;code&gt;sequences&lt;/code&gt; 항목 에 유효하지 않은 형태의 경우 .</target>
        </trans-unit>
        <trans-unit id="b7366cef910f45bfb2939d4d4c5cf6cd689029dd" translate="yes" xml:space="preserve">
          <source>In case of mismatch between given number of inputs and expectations of the model.</source>
          <target state="translated">주어진 입력 수와 모델의 기대치가 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="a356d199013f3b93a8b76ba4e11b70567e3a0225" translate="yes" xml:space="preserve">
          <source>In case of mismatch between the provided input data and the model's expectations, or in case a stateful model receives a number of samples that is not a multiple of the batch size.</source>
          <target state="translated">제공된 입력 데이터와 모델의 기대치가 일치하지 않거나 상태 저장 모델이 배치 크기의 배수가 아닌 여러 샘플을 수신하는 경우.</target>
        </trans-unit>
        <trans-unit id="88899ad29ae66b9d00b954a2811e29531475819a" translate="yes" xml:space="preserve">
          <source>In case of mismatch between the provided input data and what the model expects.</source>
          <target state="translated">제공된 입력 데이터와 모델이 예상하는 데이터가 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="5ec3c64c6374329c52184178b1fd4857d4d1aac9" translate="yes" xml:space="preserve">
          <source>In case of tie, the rounding mode used is &quot;half to even&quot;.</source>
          <target state="translated">동점 인 경우, 사용 된 반올림 모드는 &quot;반올림&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="05c8a481504fdcb81f5439304e5ef2205ea5569c" translate="yes" xml:space="preserve">
          <source>In case of unknown &lt;code&gt;data_format&lt;/code&gt; argument.</source>
          <target state="translated">알 수없는 &lt;code&gt;data_format&lt;/code&gt; 인수의 경우.</target>
        </trans-unit>
        <trans-unit id="ab787931384443fb17693b20f0b8c8362027dccc" translate="yes" xml:space="preserve">
          <source>In case of unknown &lt;code&gt;mode&lt;/code&gt; or &lt;code&gt;data_format&lt;/code&gt; argument.</source>
          <target state="translated">알 수없는 &lt;code&gt;mode&lt;/code&gt; 또는 &lt;code&gt;data_format&lt;/code&gt; 인수의 경우.</target>
        </trans-unit>
        <trans-unit id="d126fd29a8ae675359d884c4be757cfd379d70f9" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;layer&lt;/code&gt; argument does not know its input shape.</source>
          <target state="translated">&lt;code&gt;layer&lt;/code&gt; 인수가 입력 모양을 모르는 경우 .</target>
        </trans-unit>
        <trans-unit id="5e569e98d391d8a27e0d7375479c95eedc6a211e" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;layer&lt;/code&gt; argument has multiple output tensors, or is already connected somewhere else (forbidden in &lt;code&gt;Sequential&lt;/code&gt; models).</source>
          <target state="translated">경우에 &lt;code&gt;layer&lt;/code&gt; 인수 다중 출력 텐서를 가지고, 이미 (다른 곳에서 금지 연결되어 &lt;code&gt;Sequential&lt;/code&gt; 모델).</target>
        </trans-unit>
        <trans-unit id="ba5137fc820e731c1a5875992af949685dd9a61a" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;export_meta_graph()&lt;/code&gt;, this function can be used to</source>
          <target state="translated">와 조합 &lt;code&gt;export_meta_graph()&lt;/code&gt; 이 함수에 사용될 수있다</target>
        </trans-unit>
        <trans-unit id="6bee6cf2cd5a89443d441a5ec667007c0d0d0875" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;Adam&lt;/code&gt;, the sparse implementation of this algorithm (used when the gradient is an IndexedSlices object, typically because of &lt;a href=&quot;../../gather&quot;&gt;&lt;code&gt;tf.gather&lt;/code&gt;&lt;/a&gt; or an embedding lookup in the forward pass) only updates variable slices and corresponding &lt;code&gt;m_t&lt;/code&gt;, &lt;code&gt;v_t&lt;/code&gt; terms when that part of the variable was used in the forward pass. This means that the sparse behavior is contrast to the dense behavior (similar to some momentum implementations which ignore momentum unless a variable slice was actually used).</source>
          <target state="translated">달리 &lt;code&gt;Adam&lt;/code&gt; 이 알고리즘의 성긴 구현 (기울기가 IndexedSlices 전형적 때문에, 목적 때 사용 &lt;a href=&quot;../../gather&quot;&gt; &lt;code&gt;tf.gather&lt;/code&gt; &lt;/a&gt; 만 가변 조각 대응 업데이트 또는 순방향 패스 룩업 매립) &lt;code&gt;m_t&lt;/code&gt; , &lt;code&gt;v_t&lt;/code&gt; 의 조건을 때의 일부 변수는 정방향 패스에서 사용되었습니다. 이는 희소 동작이 조밀 동작과 대조된다는 것을 의미합니다 (변수 슬라이스가 실제로 사용되지 않는 한 모멘텀을 무시하는 일부 모멘텀 구현과 유사 함).</target>
        </trans-unit>
        <trans-unit id="472a2f767cd2905e561f41c34043559b02af126d" translate="yes" xml:space="preserve">
          <source>In contrast to the &lt;code&gt;mean&lt;/code&gt; function which returns a scalar with the mean, this function returns an average tensor with the same shape as the input tensors.</source>
          <target state="translated">받는 반면 &lt;code&gt;mean&lt;/code&gt; , 평균과 스칼라 함수를 리턴이 함수는 입력 텐서 같은 형상 평균 텐서를 반환한다.</target>
        </trans-unit>
        <trans-unit id="be45b63e4fad80b73ce37784737cf2cbbeaea97c" translate="yes" xml:space="preserve">
          <source>In contrast, if:</source>
          <target state="translated">반대로 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="911ecdd444d109bdd2686fa0899f4e17288b1949" translate="yes" xml:space="preserve">
          <source>In detail, the grayscale morphological 2-D dilation is the max-sum correlation (for consistency with &lt;code&gt;conv2d&lt;/code&gt;, we use unmirrored filters):</source>
          <target state="translated">구체적으로, 그레이 스케일 형태 학적 2-D 확장은 최대-합 상관 관계입니다 ( &lt;code&gt;conv2d&lt;/code&gt; 와의 일관성을 위해 미러되지 않은 필터를 사용합니다).</target>
        </trans-unit>
        <trans-unit id="010b81280676156048e3aae3d209bcf71a9b3066" translate="yes" xml:space="preserve">
          <source>In detail, the grayscale morphological 2-D erosion is given by:</source>
          <target state="translated">상세하게, 그레이 스케일 형태 학적 2-D 침식은 다음에 의해 주어진다 :</target>
        </trans-unit>
        <trans-unit id="517b8d5a149f4c161ca1ea27c45c37a98c18260e" translate="yes" xml:space="preserve">
          <source>In detail, with the default NHWC format,</source>
          <target state="translated">자세하게는 기본 NHWC 형식으로</target>
        </trans-unit>
        <trans-unit id="39ee2fb212e9ff65eb60f4c2eed006218ac4350f" translate="yes" xml:space="preserve">
          <source>In distributed setting for a non-chief worker, you can use following:</source>
          <target state="translated">비 임시 직원에 대한 분산 설정에서 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="432fd70bbc9af278575edb8550ab4d0e6d429837" translate="yes" xml:space="preserve">
          <source>In each mask field (&lt;code&gt;begin_mask&lt;/code&gt;, &lt;code&gt;end_mask&lt;/code&gt;, &lt;code&gt;ellipsis_mask&lt;/code&gt;, &lt;code&gt;new_axis_mask&lt;/code&gt;, &lt;code&gt;shrink_axis_mask&lt;/code&gt;) the ith bit will correspond to the ith spec.</source>
          <target state="translated">각 마스크 필드 ( &lt;code&gt;begin_mask&lt;/code&gt; , &lt;code&gt;end_mask&lt;/code&gt; , &lt;code&gt;ellipsis_mask&lt;/code&gt; , &lt;code&gt;new_axis_mask&lt;/code&gt; , &lt;code&gt;shrink_axis_mask&lt;/code&gt; )에서 i 번째 비트는 i 번째 스펙에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a827b2d32c94f4d078081b87422b337df7153cca" translate="yes" xml:space="preserve">
          <source>In each repetition, this dataset fills a buffer with &lt;code&gt;buffer_size&lt;/code&gt; elements, then randomly samples elements from this buffer, replacing the selected elements with new elements. For perfect shuffling, set the buffer size equal to the full size of the dataset.</source>
          <target state="translated">각 반복에서이 데이터 세트는 &lt;code&gt;buffer_size&lt;/code&gt; 요소 로 버퍼를 채우고이 버퍼에서 요소를 무작위로 샘플링하여 선택한 요소를 새 요소로 바꿉니다. 완벽한 셔플 링을 위해 버퍼 크기를 데이터 세트의 전체 크기와 동일하게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="ab4f684abeec2fbace4964ba714b6c3030a31435" translate="yes" xml:space="preserve">
          <source>In eager execution the shape is always fully-known.</source>
          <target state="translated">열렬한 실행에서 모양은 항상 완전히 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad9df451db78bb007e8c2331091212546191af9" translate="yes" xml:space="preserve">
          <source>In eager mode, None. In graph mode, an op to update the loss scale.</source>
          <target state="translated">eager 모드에서는 없음. 그래프 모드에서 손실 스케일을 업데이트하는 작업입니다.</target>
        </trans-unit>
        <trans-unit id="b5bcda8bd9453fe45c3ad8b95cc83910933e573a" translate="yes" xml:space="preserve">
          <source>In eager mode, no special code is needed to initialize the table. Example usage in eager mode:</source>
          <target state="translated">열망 모드에서는 테이블을 초기화하는 데 특별한 코드가 필요하지 않습니다. 열망 모드에서의 사용 예 :</target>
        </trans-unit>
        <trans-unit id="8a80543ed8233233bcba2882c158c2bd26a1a267" translate="yes" xml:space="preserve">
          <source>In eager mode, this directly updates the loss scale, so that calling &lt;code&gt;__call__&lt;/code&gt; will return the newly updated loss scale. In graph mode, this returns an op that, when evaluated, updates the loss scale.</source>
          <target state="translated">열망 모드에서 이는 손실 스케일을 직접 업데이트하므로 &lt;code&gt;__call__&lt;/code&gt; 을 호출 하면 새로 업데이트 된 손실 스케일이 반환됩니다. 그래프 모드에서는 평가시 손실 스케일을 업데이트하는 op를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="71ccf90ba0d4e13bfe64aa70496805e8e26edd75" translate="yes" xml:space="preserve">
          <source>In either case above, the numpy ndarray (either the caller provided or the auto-converted) must have the compatible type with dtype.</source>
          <target state="translated">위의 두 경우 모두 numpy ndarray (호출자 또는 자동 변환 된)는 dtype과 호환되는 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b2af86db54b3c6e559c751f3b18febb46377d6d4" translate="yes" xml:space="preserve">
          <source>In every case, these &lt;code&gt;Tensor&lt;/code&gt;s are all floating dtype.</source>
          <target state="translated">모든 경우에 이러한 &lt;code&gt;Tensor&lt;/code&gt; 는 모두 부동 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="df70ac6f46a69a033f507ba69518b4967c5b0477" translate="yes" xml:space="preserve">
          <source>In fact, a higher-level solution to update a distributed variable is by calling &lt;code&gt;assign&lt;/code&gt; on the variable as you would do to a regular &lt;a href=&quot;../../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;. You can call the method in both &lt;em&gt;replica context&lt;/em&gt; and &lt;em&gt;cross-replica context&lt;/em&gt;. For a &lt;em&gt;mirrored variable&lt;/em&gt;, calling &lt;code&gt;assign&lt;/code&gt; in &lt;em&gt;replica context&lt;/em&gt; requires you to specify the &lt;code&gt;aggregation&lt;/code&gt; type in the variable constructor. In that case, the context switching and sync described in steps 2 through 4 are handled for you. If you call &lt;code&gt;assign&lt;/code&gt; on &lt;em&gt;mirrored variable&lt;/em&gt; in &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value or assign values from another mirrored variable or a mirrored &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. For a &lt;em&gt;SyncOnRead variable&lt;/em&gt;, in &lt;em&gt;replica context&lt;/em&gt;, you can simply call &lt;code&gt;assign&lt;/code&gt; on it and no aggregation happens under the hood. In &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value to a SyncOnRead variable. One example case is restoring from a checkpoint: if the &lt;code&gt;aggregation&lt;/code&gt; type of the variable is &lt;a href=&quot;../../../variableaggregation#SUM&quot;&gt;&lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt;&lt;/a&gt;, it is assumed that replica values were added before checkpointing, so at the time of restoring, the value is divided by the number of replicas and then assigned to each replica; if the &lt;code&gt;aggregation&lt;/code&gt; type is &lt;a href=&quot;../../../variableaggregation#MEAN&quot;&gt;&lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt;&lt;/a&gt;, the value is assigned to each replica directly.</source>
          <target state="translated">사실, 분산 변수를 업데이트하는 더 높은 수준의 솔루션 은 일반 &lt;a href=&quot;../../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; 에&lt;/a&gt; 수행하는 것처럼 변수에 &lt;code&gt;assign&lt;/code&gt; 을 호출 하는 것 입니다. &lt;em&gt;복제본 컨텍스트&lt;/em&gt; 및 &lt;em&gt;교차 &lt;/em&gt;&lt;em&gt;복제본 컨텍스트&lt;/em&gt; 모두에서 메소드를 호출 할 수 있습니다 . A의 &lt;em&gt;미러 변수&lt;/em&gt; 호출 &lt;code&gt;assign&lt;/code&gt; 에 &lt;em&gt;복제 상황은&lt;/em&gt; 지정하도록 요구 &lt;code&gt;aggregation&lt;/code&gt; 변수 생성자의 유형입니다. 이 경우 2-4 단계에서 설명한 컨텍스트 전환 및 동기화가 자동으로 처리됩니다. 당신은 호출하는 경우 &lt;code&gt;assign&lt;/code&gt; 에 &lt;em&gt;미러 변수&lt;/em&gt; 에 &lt;em&gt;간 복제 컨텍스트&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;, 단일 값만 할당하거나 다른 미러링 된 변수 또는 미러링 된 &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 의&lt;/a&gt; 값을 할당 할 수 있습니다 . A에 대한 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 에 &lt;em&gt;복제 컨텍스트&lt;/em&gt; , 당신은 단순히 호출 할 수 있습니다 &lt;code&gt;assign&lt;/code&gt; 그것에 더 집계는 후드 아래에 발생하지 않습니다. 년 &lt;em&gt;간 복제 컨텍스트&lt;/em&gt; , 당신은 단지 SyncOnRead 변수에 단일 값을 할당 할 수 있습니다. 한 가지 예는 체크 포인트에서 복원하는 것 입니다. 변수 의 &lt;code&gt;aggregation&lt;/code&gt; 유형이 &lt;a href=&quot;../../../variableaggregation#SUM&quot;&gt; &lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt; &lt;/a&gt; 인 경우 복제본 값이 체크 포인트 전에 추가 된 것으로 간주되므로 복원시 값을 복제본 수로 나눕니다. 그런 다음 각 복제본에 할당됩니다. 만약 &lt;code&gt;aggregation&lt;/code&gt; 유형은 &lt;a href=&quot;../../../variableaggregation#MEAN&quot;&gt; &lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt; &lt;/a&gt; 이며 값은 각 복제본에 직접 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="f09214f6918bfb65897e422e8565cff18e083e90" translate="yes" xml:space="preserve">
          <source>In fact, a higher-level solution to update a distributed variable is by calling &lt;code&gt;assign&lt;/code&gt; on the variable as you would do to a regular &lt;a href=&quot;../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;. You can call the method in both &lt;em&gt;replica context&lt;/em&gt; and &lt;em&gt;cross-replica context&lt;/em&gt;. For a &lt;em&gt;mirrored variable&lt;/em&gt;, calling &lt;code&gt;assign&lt;/code&gt; in &lt;em&gt;replica context&lt;/em&gt; requires you to specify the &lt;code&gt;aggregation&lt;/code&gt; type in the variable constructor. In that case, the context switching and sync described in steps 2 through 4 are handled for you. If you call &lt;code&gt;assign&lt;/code&gt; on &lt;em&gt;mirrored variable&lt;/em&gt; in &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value or assign values from another mirrored variable or a mirrored &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. For a &lt;em&gt;SyncOnRead variable&lt;/em&gt;, in &lt;em&gt;replica context&lt;/em&gt;, you can simply call &lt;code&gt;assign&lt;/code&gt; on it and no aggregation happens under the hood. In &lt;em&gt;cross-replica context&lt;/em&gt;, you can only assign a single value to a SyncOnRead variable. One example case is restoring from a checkpoint: if the &lt;code&gt;aggregation&lt;/code&gt; type of the variable is &lt;a href=&quot;../variableaggregation#SUM&quot;&gt;&lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt;&lt;/a&gt;, it is assumed that replica values were added before checkpointing, so at the time of restoring, the value is divided by the number of replicas and then assigned to each replica; if the &lt;code&gt;aggregation&lt;/code&gt; type is &lt;a href=&quot;../variableaggregation#MEAN&quot;&gt;&lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt;&lt;/a&gt;, the value is assigned to each replica directly.</source>
          <target state="translated">사실, 분산 변수를 업데이트하는 더 높은 수준의 솔루션 은 일반 &lt;a href=&quot;../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; 에&lt;/a&gt; 수행하는 것처럼 변수에 &lt;code&gt;assign&lt;/code&gt; 을 호출 하는 것 입니다. &lt;em&gt;복제본 컨텍스트&lt;/em&gt; 및 &lt;em&gt;교차 &lt;/em&gt;&lt;em&gt;복제본 컨텍스트&lt;/em&gt; 모두에서 메소드를 호출 할 수 있습니다 . A의 &lt;em&gt;미러 변수&lt;/em&gt; 호출 &lt;code&gt;assign&lt;/code&gt; 에 &lt;em&gt;복제 상황은&lt;/em&gt; 지정하도록 요구 &lt;code&gt;aggregation&lt;/code&gt; 변수 생성자의 유형입니다. 이 경우 2-4 단계에서 설명한 컨텍스트 전환 및 동기화가 자동으로 처리됩니다. 당신은 호출하는 경우 &lt;code&gt;assign&lt;/code&gt; 에 &lt;em&gt;미러 변수&lt;/em&gt; 에 &lt;em&gt;간 복제 컨텍스트&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;, 단일 값만 할당하거나 다른 미러링 된 변수 또는 미러링 된 &lt;a href=&quot;distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 의&lt;/a&gt; 값을 할당 할 수 있습니다 . A에 대한 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 에 &lt;em&gt;복제 컨텍스트&lt;/em&gt; , 당신은 단순히 호출 할 수 있습니다 &lt;code&gt;assign&lt;/code&gt; 그것에 더 집계는 후드 아래에 발생하지 않습니다. 년 &lt;em&gt;간 복제 컨텍스트&lt;/em&gt; , 당신은 단지 SyncOnRead 변수에 단일 값을 할당 할 수 있습니다. 한 가지 예는 체크 포인트에서 복원하는 것 입니다. 변수 의 &lt;code&gt;aggregation&lt;/code&gt; 유형이 &lt;a href=&quot;../variableaggregation#SUM&quot;&gt; &lt;code&gt;tf.VariableAggregation.SUM&lt;/code&gt; &lt;/a&gt; 인 경우 복제본 값이 체크 포인트 전에 추가 된 것으로 간주되므로 복원시 값을 복제본 수로 나눕니다. 그런 다음 각 복제본에 할당됩니다. 만약 &lt;code&gt;aggregation&lt;/code&gt; 유형은 &lt;a href=&quot;../variableaggregation#MEAN&quot;&gt; &lt;code&gt;tf.VariableAggregation.MEAN&lt;/code&gt; &lt;/a&gt; 이며 값은 각 복제본에 직접 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="458f9bf1f3a55d57242c3dfd6a8b1b2360358c13" translate="yes" xml:space="preserve">
          <source>In general multiprocessing.Pool can interact quite badly with other, seemingly unrelated, parts of a codebase due to Pool's reliance on fork. This method cleans up all pools which are known to belong to Keras (and thus can be safely terminated).</source>
          <target state="translated">일반적으로 멀티 프로세싱 풀은 포크에 대한 의존성으로 인해 코드베이스의 다른 부분과 관련이없는 것처럼 보일 수 있습니다. 이 방법은 Keras에 속하는 것으로 알려진 모든 풀을 정리하므로 안전하게 종료 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05fa93477d180d1acfa7da38b422f9dbed979a61" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;../../devicespec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;../../devicespec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../../devicespec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;../../devicespec#from_string&quot;&gt; &lt;code&gt;DeviceSpec.from_string&lt;/code&gt; 는&lt;/a&gt; 완전히 교체해야 &lt;a href=&quot;../../devicespec#parse_from_string&quot;&gt; &lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt; 을&lt;/a&gt; 하고 &lt;a href=&quot;../../devicespec#replace&quot;&gt; &lt;code&gt;DeviceSpec.replace&lt;/code&gt; 는&lt;/a&gt; 완전히 직접 설정 속성을 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1759e56b5d26a55f209d28b2c39da67c3d2c868" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;devicespec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;devicespec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;devicespec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;devicespec#from_string&quot;&gt; &lt;code&gt;DeviceSpec.from_string&lt;/code&gt; 는&lt;/a&gt; 완전히 교체해야 &lt;a href=&quot;devicespec#parse_from_string&quot;&gt; &lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt; 을&lt;/a&gt; 하고 &lt;a href=&quot;devicespec#replace&quot;&gt; &lt;code&gt;DeviceSpec.replace&lt;/code&gt; 는&lt;/a&gt; 완전히 직접 설정 속성을 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="0be78576bf089134edc696318f9dc842768f1015" translate="yes" xml:space="preserve">
          <source>In general, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#from_string&quot;&gt;&lt;code&gt;DeviceSpec.from_string&lt;/code&gt;&lt;/a&gt; should completely replace &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#parse_from_string&quot;&gt;&lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#replace&quot;&gt;&lt;code&gt;DeviceSpec.replace&lt;/code&gt;&lt;/a&gt; should completely replace setting attributes directly.</source>
          <target state="translated">일반적으로, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#from_string&quot;&gt; &lt;code&gt;DeviceSpec.from_string&lt;/code&gt; 는&lt;/a&gt; 완전히 교체해야 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#parse_from_string&quot;&gt; &lt;code&gt;DeviceSpec.parse_from_string&lt;/code&gt; 을&lt;/a&gt; 하고 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/DeviceSpec#replace&quot;&gt; &lt;code&gt;DeviceSpec.replace&lt;/code&gt; 는&lt;/a&gt; 완전히 직접 설정 속성을 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6b1248ae5eafe23fc297bb9a228b2f925c57498" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;0 &amp;lt; dim(mask) = K &amp;lt;= dim(tensor)&lt;/code&gt;, and &lt;code&gt;mask&lt;/code&gt;'s shape must match the first K dimensions of &lt;code&gt;tensor&lt;/code&gt;'s shape. We then have: &lt;code&gt;boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]&lt;/code&gt; where &lt;code&gt;(i1,...,iK)&lt;/code&gt; is the ith &lt;code&gt;True&lt;/code&gt; entry of &lt;code&gt;mask&lt;/code&gt; (row-major order). The &lt;code&gt;axis&lt;/code&gt; could be used with &lt;code&gt;mask&lt;/code&gt; to indicate the axis to mask from. In that case, &lt;code&gt;axis + dim(mask) &amp;lt;= dim(tensor)&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt;'s shape must match the first &lt;code&gt;axis + dim(mask)&lt;/code&gt; dimensions of &lt;code&gt;tensor&lt;/code&gt;'s shape.</source>
          <target state="translated">일반적으로 &lt;code&gt;0 &amp;lt; dim(mask) = K &amp;lt;= dim(tensor)&lt;/code&gt; 이며 &lt;code&gt;mask&lt;/code&gt; 의 모양은 &lt;code&gt;tensor&lt;/code&gt; 모양 의 첫 번째 K 치수와 일치해야합니다 . 우리는 다음과 같습니다 &lt;code&gt;boolean_mask(tensor, mask)[i, j1,...,jd] = tensor[i1,...,iK,j1,...,jd]&lt;/code&gt; 여기서, &lt;code&gt;(i1,...,iK)&lt;/code&gt; &lt;code&gt;mask&lt;/code&gt; 의 i 번째 &lt;code&gt;True&lt;/code&gt; 항목입니다 (행 순서). &lt;code&gt;axis&lt;/code&gt; 함께 사용할 수있는 &lt;code&gt;mask&lt;/code&gt; 에서 마스크 할 수있는 축을 나타냅니다. 이 경우에서, &lt;code&gt;axis + dim(mask) &amp;lt;= dim(tensor)&lt;/code&gt; 과 &lt;code&gt;mask&lt;/code&gt; 의 형태는 첫 번째 일치해야 &lt;code&gt;axis + dim(mask)&lt;/code&gt; 의 치수 &lt;code&gt;tensor&lt;/code&gt; 의 형상 '.</target>
        </trans-unit>
        <trans-unit id="df73d635dcf19899192fc8057c9a906f0ba749f2" translate="yes" xml:space="preserve">
          <source>In general, &lt;code&gt;order(c) = order(a) + order(b) - 2*len(axes[0])&lt;/code&gt;.</source>
          <target state="translated">일반적으로 &lt;code&gt;order(c) = order(a) + order(b) - 2*len(axes[0])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8197a907e7eede9a4ab49989b9c67df1ecf6abfd" translate="yes" xml:space="preserve">
          <source>In general, Lambda layers can be convenient for simple stateless computation, but anything more complex should use a subclass Layer instead.</source>
          <target state="translated">일반적으로 Lambda 레이어는 간단한 상태 비 저장 계산에 편리 할 수 ​​있지만 더 복잡한 것은 하위 클래스 인 Layer를 대신 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f38c9626976c1df9169c1e0b677516dea631b670" translate="yes" xml:space="preserve">
          <source>In general, it is recommended to create stateful objects like &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; outside of &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; and passing them as arguments.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; 외부에서 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 과 같은 상태 저장 객체를 만들어 인수로 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="619dfbe395f886ec7d908acd2d16888a420d60c9" translate="yes" xml:space="preserve">
          <source>In general, multi-client tf.distribute strategies such as &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; require task_type and task_id properties to be available in the &lt;code&gt;ClusterResolver&lt;/code&gt; they are using. On the other hand, these concepts are not applicable in single-client strategies, such as &lt;a href=&quot;../experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy&lt;/code&gt;&lt;/a&gt;, because the program is only expected to be run on one task, so there should not be a need to have code branches according to task type and task id.</source>
          <target state="translated">일반적으로, 같은 멀티 클라이언트 tf.distribute 전략 &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; 는&lt;/a&gt; 에서 사용할 수 task_type 및 TASK_ID 특성을 필요로 &lt;code&gt;ClusterResolver&lt;/code&gt; 가 사용하고 있습니다. 반면에 이러한 개념은 &lt;a href=&quot;../experimental/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.TPUStrategy&lt;/code&gt; &lt;/a&gt; 와 같은 단일 클라이언트 전략에는 적용되지 않습니다 . 프로그램이 하나의 작업에서만 실행될 것으로 예상되므로 코드 분기를 가질 필요가 없습니다. 작업 유형 및 작업 ID에 따라.</target>
        </trans-unit>
        <trans-unit id="75611dab36791d918a60f2d742b07af8d1fae0c4" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;equation&lt;/code&gt; is obtained from the more familiar element-wise equation by 1. removing variable names, brackets, and commas, 2. replacing &quot;*&quot; with &quot;,&quot;, 3. dropping summation signs, and 4. moving the output to the right, and replacing &quot;=&quot; with &quot;-&amp;gt;&quot;.</source>
          <target state="translated">일반적으로 &lt;code&gt;equation&lt;/code&gt; 은 변수 이름, 대괄호 및 쉼표를 제거하고 2. &quot;*&quot;를 &quot;,&quot;로 대체하고, 3. 요약 부호를 삭제하고, 4. 출력을 이동하여보다 친숙한 요소 별 방정식에서 구합니다. 오른쪽으로 이동하고 &quot;=&quot;를 &quot;-&amp;gt;&quot;로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="052bab4a4ace4679f5fac38b0fa6d8e9de67b67a" translate="yes" xml:space="preserve">
          <source>In general, to convert the element-wise equation into the &lt;code&gt;equation&lt;/code&gt; string, use the following procedure (intermediate strings for matrix multiplication example provided in parentheses):</source>
          <target state="translated">일반적으로 요소 별 방정식을 &lt;code&gt;equation&lt;/code&gt; 문자열 로 변환하려면 다음 절차를 사용합니다 (괄호 안에 제공된 행렬 곱셈 예제의 중간 문자열).</target>
        </trans-unit>
        <trans-unit id="c259f3cade9e31230407abe615fe31af4bb9832a" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;../../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../distribute/experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="translated">일반적 으로 &lt;a href=&quot;../../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../distribute/experimental/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt; &lt;/a&gt; 와 같은 다중 작업자 &lt;a href=&quot;../../../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 전략을 사용할 때 사용 된 전략과 연관된 &lt;a href=&quot;../../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; 가 있습니다. 이러한 인스턴스는이 속성에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e7eeb79a4204a5424bef497bd6fd4d234294c4f4" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../distribute/experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="translated">일반적 으로 &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../distribute/experimental/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt; &lt;/a&gt; 와 같은 다중 작업자 &lt;a href=&quot;../../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 전략을 사용할 때 사용 된 전략과 연관된 &lt;a href=&quot;../../../distribute/cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; 가 있습니다. 이러한 인스턴스는이 속성에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1852073079600e10293c9450fade374fcb9f2a19" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="translated">일반적 으로 &lt;a href=&quot;multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt; &lt;/a&gt; 와 같은 다중 작업자 &lt;a href=&quot;../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 전략을 사용할 때 사용 된 전략과 연관된 &lt;a href=&quot;../cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; 가 있습니다. 이러한 인스턴스는이 속성에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a77606f598bc444a0148a3b80b85e17cb5930008" translate="yes" xml:space="preserve">
          <source>In general, when using a multi-worker &lt;a href=&quot;../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; strategy such as &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;experimental/tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt;&lt;/a&gt;, there is a &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt;&lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt;&lt;/a&gt; associated with the strategy used, and such an instance is returned by this property.</source>
          <target state="translated">일반적 으로 &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;experimental/tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.TPUStrategy()&lt;/code&gt; &lt;/a&gt; 와 같은 다중 작업자 &lt;a href=&quot;../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 전략을 사용할 때 사용 된 전략과 연관된 &lt;a href=&quot;cluster_resolver/clusterresolver&quot;&gt; &lt;code&gt;tf.distribute.cluster_resolver.ClusterResolver&lt;/code&gt; &lt;/a&gt; 가 있습니다. 이러한 인스턴스는이 속성에 의해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="81ba21f1479a022109ab2f3d99be347c7bb01f17" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;code&gt;with strategy.scope():&lt;/code&gt; API, but this alternative may be convenient in notebooks where you would have to put each cell in a &lt;code&gt;with strategy.scope():&lt;/code&gt; block.</source>
          <target state="translated">일반적으로 &lt;code&gt;with strategy.scope():&lt;/code&gt; API 를 사용해야 하지만,이 대안은 각 셀을 &lt;code&gt;with strategy.scope():&lt;/code&gt; 블록 에 넣어야하는 노트북에서 편리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="c093e0c853b18b211b082dc234fa39265b721fa2" translate="yes" xml:space="preserve">
          <source>In graph mode, this returns an operation which when executed performs the write. In eager mode, the write is performed by the method itself and there is no return value.</source>
          <target state="translated">그래프 모드에서는 실행시 쓰기를 수행하는 작업을 반환합니다. 열망 모드에서, 쓰기는 메소드 자체에 의해 수행되며 리턴 값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="1321491278c9fd1609935b5dea7b2ba0f946dfd9" translate="yes" xml:space="preserve">
          <source>In graph mode, you should typically call this method &lt;em&gt;once&lt;/em&gt; and use its result as the input to another computation. A typical loop will then call &lt;code&gt;tf.Session.run&lt;/code&gt; on the result of that computation. The loop will terminate when the &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt;&lt;code&gt;Iterator.get_next()&lt;/code&gt;&lt;/a&gt; operation raises &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt;. The following skeleton shows how to use this method when building a training loop:</source>
          <target state="translated">그래프 모드에서는 일반적으로이 메서드를 &lt;em&gt;한 번&lt;/em&gt; 호출 하고 그 결과를 다른 계산에 대한 입력으로 사용해야합니다. 그런 다음 일반적인 루프는 해당 계산 결과에 대해 &lt;code&gt;tf.Session.run&lt;/code&gt; 을 호출 합니다. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt; &lt;code&gt;Iterator.get_next()&lt;/code&gt; &lt;/a&gt; 작업이 &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; 를&lt;/a&gt; 발생 시키면 루프가 종료됩니다 . 다음 스켈레톤은 훈련 루프를 만들 때이 방법을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="716f31f5a03aef3f69ebd13d12a35b86aebe2e30" translate="yes" xml:space="preserve">
          <source>In graph mode, you should typically call this method &lt;em&gt;once&lt;/em&gt; and use its result as the input to another computation. A typical loop will then call &lt;code&gt;tf.Session.run&lt;/code&gt; on the result of that computation. The loop will terminate when the &lt;code&gt;Iterator.get_next()&lt;/code&gt; operation raises &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt;. The following skeleton shows how to use this method when building a training loop:</source>
          <target state="translated">그래프 모드에서는 일반적으로이 메소드를 &lt;em&gt;한 번&lt;/em&gt; 호출 하고 그 결과를 다른 계산의 입력으로 사용해야합니다. 그런 다음 일반적인 루프는 해당 계산 결과에서 &lt;code&gt;tf.Session.run&lt;/code&gt; 을 호출 합니다. &lt;code&gt;Iterator.get_next()&lt;/code&gt; 조작이 &lt;a href=&quot;../../../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; 를&lt;/a&gt; 발생 시키면 루프가 종료됩니다 . 다음 스켈레톤은 훈련 루프를 만들 때이 방법을 사용하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="a6ca36a8e0927892e5adf0bea0071edf9a03306d" translate="yes" xml:space="preserve">
          <source>In many common cases, saving models for serving will be as simple as:</source>
          <target state="translated">많은 경우에 서비스를위한 모델 저장은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="0c1e157d5c07c3be9a526b99a8cd938ffdff518e" translate="yes" xml:space="preserve">
          <source>In most cases you can set session arguments as follows:</source>
          <target state="translated">대부분의 경우 세션 인수를 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b24eb32e772a4b559b69c542c15c36c63f4a898a" translate="yes" xml:space="preserve">
          <source>In most functions that accept a LossScale, you can also pass an int (such as</source>
          <target state="translated">LossScale을 허용하는 대부분의 함수에서 int (예 :</target>
        </trans-unit>
        <trans-unit id="39b8e52a139b65c15d15047812c546d3fc8efe99" translate="yes" xml:space="preserve">
          <source>In one of the two cases below:</source>
          <target state="translated">아래 두 가지 경우 중 하나 :</target>
        </trans-unit>
        <trans-unit id="e583468a15187c915f71a5317544c6b871de6462" translate="yes" xml:space="preserve">
          <source>In other words,</source>
          <target state="translated">다시 말해,</target>
        </trans-unit>
        <trans-unit id="36ca12036e617d13dd1e10a27cdcc10a21abe207" translate="yes" xml:space="preserve">
          <source>In other words, if</source>
          <target state="translated">다시 말해</target>
        </trans-unit>
        <trans-unit id="68f09d96ffe8138bea778134c4c062b38232e1d6" translate="yes" xml:space="preserve">
          <source>In other words, it flattens each data samples of a batch.</source>
          <target state="translated">즉, 배치의 각 데이터 샘플을 평탄화합니다.</target>
        </trans-unit>
        <trans-unit id="cdb1bf5db2bd1845e8b9a621343dc2f7674e34e9" translate="yes" xml:space="preserve">
          <source>In other words, the last dimension is treated as the $z$ vector.</source>
          <target state="translated">즉, 마지막 차원은 $ z $ 벡터로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0871ff786a8a3fd603a58b9722f796614ebc2719" translate="yes" xml:space="preserve">
          <source>In other words, the last dimension is treated as the &lt;code&gt;z&lt;/code&gt; vector.</source>
          <target state="translated">즉, 마지막 차원은 &lt;code&gt;z&lt;/code&gt; 벡터 로 취급됩니다 .</target>
        </trans-unit>
        <trans-unit id="78ff35f7c65003df3e7bcf3683132006bf742ac9" translate="yes" xml:space="preserve">
          <source>In parent, replace child_name's old definition with new_child.</source>
          <target state="translated">부모에서 child_name의 이전 정의를 new_child로 바꾸십시오.</target>
        </trans-unit>
        <trans-unit id="d76da88946b010ac70fdfba18e1366302d30f656" translate="yes" xml:space="preserve">
          <source>In particular, all values that are compatible with this TypeSpec must be an instance of this type.</source>
          <target state="translated">특히이 TypeSpec과 호환되는 모든 값은이 유형의 인스턴스 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a5bb936a13cf0b0b5a2a5c1cb9a4facd12daec" translate="yes" xml:space="preserve">
          <source>In particular, the tolerance is reduced to 1e-3 if at least one of the arguments is of type float16.</source>
          <target state="translated">특히, 인수 중 하나 이상이 float16 유형 인 경우 공차는 1e-3으로 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="44d0d4248217b7cffdeccf5ed82b70d82d1494ed" translate="yes" xml:space="preserve">
          <source>In particular, this adds any losses you have added with &lt;code&gt;tf.add_loss()&lt;/code&gt; to any regularization losses that have been added by regularization parameters on layers constructors e.g. &lt;code&gt;tf.layers&lt;/code&gt;. Be very sure to use this if you are constructing a loss_op manually. Otherwise regularization arguments on &lt;code&gt;tf.layers&lt;/code&gt; methods will not function.</source>
          <target state="translated">특히, 이것은 &lt;code&gt;tf.add_loss()&lt;/code&gt; 로 추가 한 손실을 레이어 생성자 (예 : &lt;code&gt;tf.layers&lt;/code&gt; )의 정규화 매개 변수에 의해 추가 된 정규화 손실에 추가합니다 . loss_op를 수동으로 구성하는 경우이 옵션을 사용해야합니다. 그렇지 않으면 &lt;code&gt;tf.layers&lt;/code&gt; 메소드의 정규화 인수 가 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="569e331ba8296ea2e67c10dc906718d574087feb" translate="yes" xml:space="preserve">
          <source>In practice, this is most useful for taking output from operations like QuantizedMatMul that can produce higher bit-depth outputs than their inputs and may have large potential output ranges, but in practice have a distribution of input values that only uses a small fraction of the possible range. By feeding that output into this operator, we can reduce it from 32 bits down to 8 with minimal loss of accuracy.</source>
          <target state="translated">실제로 이것은 입력보다 더 높은 비트 심도 출력을 생성 할 수 있고 잠재적 출력 범위가 클 수있는 QuantizedMatMul과 같은 작업에서 출력을 가져 오는 데 가장 유용하지만 실제로는 가능한 범위. 해당 출력을이 연산자에 공급함으로써 정확도 손실을 최소화하면서 32 비트에서 8 비트로 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e60680116f8f10f4ec9328db9798f3167d053000" translate="yes" xml:space="preserve">
          <source>In python 2.7, make sure to import the following: &lt;code&gt;from __future__ import print_function&lt;/code&gt;</source>
          <target state="translated">Python 2.7에서 다음을 가져와야합니다. &lt;code&gt;from __future__ import print_function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">한마디로 :</target>
        </trans-unit>
        <trans-unit id="88d124b3a5514b4439d86d509898719151ee7194" translate="yes" xml:space="preserve">
          <source>In signal processing, cross-correlation is a measure of similarity of two waveforms as a function of a time-lag applied to one of them. This is also known as a sliding dot product or sliding inner-product.</source>
          <target state="translated">신호 처리에서 교차 상관은 두 파형 중 하나에 적용된 시간 지연의 함수로서 두 파형의 유사성을 측정 한 것입니다. 이것을 슬라이딩 도트 제품 또는 슬라이딩 내부 제품이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="be0bf3082cdcee4f10548b89039a3787e696144d" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;a href=&quot;../../vectorized_map&quot;&gt;&lt;code&gt;tf.vectorized_map&lt;/code&gt;&lt;/a&gt; can be used to automatically convert a function to a vectorized eqivalent.</source>
          <target state="translated">경우에 따라 &lt;a href=&quot;../../vectorized_map&quot;&gt; &lt;code&gt;tf.vectorized_map&lt;/code&gt; &lt;/a&gt; 을 사용하여 함수를 벡터화 된 등가로 자동 ​​변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a8cc8853b99fc4bbc66bb3fd1188773731a713d" translate="yes" xml:space="preserve">
          <source>In some cases, &lt;a href=&quot;vectorized_map&quot;&gt;&lt;code&gt;tf.vectorized_map&lt;/code&gt;&lt;/a&gt; can be used to automatically convert a function to a vectorized eqivalent.</source>
          <target state="translated">경우에 따라 &lt;a href=&quot;vectorized_map&quot;&gt; &lt;code&gt;tf.vectorized_map&lt;/code&gt; &lt;/a&gt; 을 사용하여 함수를 벡터화 된 등가로 자동 ​​변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3834a387ac572a1a80e915dcbd47e2584fd2d76" translate="yes" xml:space="preserve">
          <source>In some cases, such as a metric, we want to accumulate a bunch of updates on each replica independently and only aggregate when reading. This can be a big performance win when the value is read only rarely (maybe the value is only read at the end of an epoch or when checkpointing). These are variables created by passing &lt;code&gt;synchronization=ON_READ&lt;/code&gt; to the variable's constructor (and some value for &lt;code&gt;aggregation&lt;/code&gt;).</source>
          <target state="translated">메트릭과 같은 일부 경우에는 각 복제본에 여러 업데이트를 독립적으로 누적하고 읽을 때만 집계하려고합니다. 값을 거의 읽지 않을 때 (성공이 끝날 때 또는 체크 포인트 할 때만 값을 읽을 수 있음) 성능이 크게 향상 될 수 있습니다. 이러한 변수는 &lt;code&gt;synchronization=ON_READ&lt;/code&gt; 를 변수의 생성자 (및 &lt;code&gt;aggregation&lt;/code&gt; 값 ) 에 전달 하여 생성 된 변수 입니다.</target>
        </trans-unit>
        <trans-unit id="f1db5fe6989f9a4d4881a86d7d0f8ee7689b077f" translate="yes" xml:space="preserve">
          <source>In some cases, the inferred shape may have unknown dimensions. If the caller has additional information about the values of these dimensions, &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;Tensor.set_shape()&lt;/code&gt;&lt;/a&gt; can be used to augment the inferred shape.</source>
          <target state="translated">경우에 따라 유추 된 모양의 크기는 알 수 없습니다. 호출자에게 이러한 차원의 값에 대한 추가 정보가있는 경우 &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;Tensor.set_shape()&lt;/code&gt; &lt;/a&gt; 를 사용하여 유추 된 모양을 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94661b97f98e1631edeff74724d2853ddff0e3b6" translate="yes" xml:space="preserve">
          <source>In some strategies, a default device scope may also be entered: in &lt;code&gt;MultiWorkerMiroredStrategy&lt;/code&gt;, a default device scope of &quot;/CPU:0&quot; is entered on each worker.</source>
          <target state="translated">일부 전략에서는 기본 장치 범위도 입력 할 수 있습니다. &lt;code&gt;MultiWorkerMiroredStrategy&lt;/code&gt; 에서 기본 장치 범위 &quot;/ CPU : 0&quot;이 각 작업자에 입력됩니다.</target>
        </trans-unit>
        <trans-unit id="88eb075661eb4f67a83a555945256eb9a90b0cc1" translate="yes" xml:space="preserve">
          <source>In subsequent layers, there is no need for the &lt;code&gt;input_shape&lt;/code&gt;:</source>
          <target state="translated">후속 레이어에서는 &lt;code&gt;input_shape&lt;/code&gt; 이 필요하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="857fdd5affc004f92507d11901ea9986d0376b16" translate="yes" xml:space="preserve">
          <source>In the &lt;em&gt;chief&lt;/em&gt; task, the &lt;code&gt;Supervisor&lt;/code&gt; works exactly as in the first example above. In the other tasks &lt;code&gt;sv.managed_session()&lt;/code&gt; waits for the Model to have been initialized before returning a session to the training code. The non-chief tasks depend on the chief task for initializing the model.</source>
          <target state="translated">에서 &lt;em&gt;최고&lt;/em&gt; 태스크가, &lt;code&gt;Supervisor&lt;/code&gt; 정확히 위의 첫 번째 예에서와 같이 작동합니다. 다른 작업에서 &lt;code&gt;sv.managed_session()&lt;/code&gt; 은 세션이 훈련 코드로 반환되기 전에 모델이 초기화 될 때까지 기다립니다. 비 임시 작업은 모델을 초기화하는 주요 작업에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="49fca8ddc23c4fbc33f583e5bbd044e3ced4da7d" translate="yes" xml:space="preserve">
          <source>In the TensorFlow Python API, you can instantiate this dataset via the class &lt;a href=&quot;../data/experimental/randomdataset&quot;&gt;&lt;code&gt;tf.data.experimental.RandomDataset&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">TensorFlow Python API에서 &lt;a href=&quot;../data/experimental/randomdataset&quot;&gt; &lt;code&gt;tf.data.experimental.RandomDataset&lt;/code&gt; &lt;/a&gt; 클래스를 통해이 데이터 세트를 인스턴스화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0d0ac75602613f08d522ad4bae89f61c4aea3ea" translate="yes" xml:space="preserve">
          <source>In the above example, the first feature will be looked up in a table that has a learning rate of 0.2 while the second feature will be looked up in a table that has a learning rate of 0.1.</source>
          <target state="translated">위의 예에서 첫 번째 특성은 학습률이 0.2 인 테이블에서 조회되고 두 번째 특성은 학습률이 0.1 인 테이블에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="45e28b216fb36afdc49dad60997d42beaa6422e3" translate="yes" xml:space="preserve">
          <source>In the above example, the first two lines (before the call to &lt;code&gt;distribute&lt;/code&gt;) will be executed on tf.data workers, and the elements provided over RPC. The remaining transformations (after the call to &lt;code&gt;distribute&lt;/code&gt;) will be executed locally.</source>
          <target state="translated">위의 예에서 처음 두 줄 ( &lt;code&gt;distribute&lt;/code&gt; 호출하기 전 )은 tf.data 워커에서 실행되고 요소는 RPC를 통해 제공됩니다. 나머지 변환 ( &lt;code&gt;distribute&lt;/code&gt; 호출 후 )은 로컬에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a86c807225e5481b2e9889d17693e52a348a5bb6" translate="yes" xml:space="preserve">
          <source>In the above example, the input Tensor with the shape of &lt;code&gt;[1, 3]&lt;/code&gt; is broadcasted to output Tensor with shape of &lt;code&gt;[3, 3]&lt;/code&gt;.</source>
          <target state="translated">상기 예에서, &lt;code&gt;[1, 3]&lt;/code&gt; 형태의 입력 텐서 는 &lt;code&gt;[3, 3]&lt;/code&gt; 형태의 텐서를 출력하도록 방송된다 .</target>
        </trans-unit>
        <trans-unit id="6277b5ea0c4836f9eb1fc077e5a179b440871327" translate="yes" xml:space="preserve">
          <source>In the above examples, we assume that the user has a dataset which returns a tuple where the first element of the tuple matches the structure of what was passed as the &lt;code&gt;feature_config&lt;/code&gt; argument to the object initializer. Also we utilize &lt;a href=&quot;../../../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; to get a &lt;a href=&quot;../../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt; in order to increase performance.</source>
          <target state="translated">위의 예에서 사용자에게 튜플의 첫 번째 요소가 &lt;code&gt;feature_config&lt;/code&gt; 인수로 객체 이니셜 라이저 에 전달 된 구조와 일치하는 튜플을 반환하는 데이터 세트가 있다고 가정합니다 . 또한 우리는 활용 &lt;a href=&quot;../../../range&quot;&gt; &lt;code&gt;tf.range&lt;/code&gt; 을&lt;/a&gt; 받으려는 &lt;a href=&quot;../../../while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; 을&lt;/a&gt; 성능을 향상시키기 위해.</target>
        </trans-unit>
        <trans-unit id="0d6b4719a2c3219a2bbde7c4f83c1120564a1d57" translate="yes" xml:space="preserve">
          <source>In the case of dict instances, the sequence consists of the values, sorted by key to ensure deterministic behavior. This is true also for OrderedDict instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in pack_sequence_as. This correctly repacks dicts and OrderedDicts after they have been flattened, and also allows flattening an OrderedDict and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.</source>
          <target state="translated">dict 인스턴스의 경우 시퀀스는 결정적인 동작을 보장하기 위해 키별로 정렬 된 값으로 구성됩니다. OrderedDict 인스턴스에서도 마찬가지입니다. 시퀀스 순서는 무시되고 키의 정렬 순서가 대신 사용됩니다. pack_sequence_as에서도 동일한 규칙이 따릅니다. dicts 및 OrderedDicts가 전개 된 후 올바르게 재 포장되고 OrderedDict를 전개 한 다음 해당 일반 dict를 사용하여 다시 패키징하거나 그 반대로도 가능합니다. 정렬 할 수없는 키가있는 사전은 병합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4802827e52e703aec4f9202f8faaec1cab12a93e" translate="yes" xml:space="preserve">
          <source>In the case of dynamically sized TensorArrays, gradient computation should only be performed on read operations that have themselves been chained via flow to occur only after all writes have executed. That way the final size of the forward TensorArray is known when this operation is called.</source>
          <target state="translated">동적으로 크기가 조정 된 TensorArray의 경우 모든 쓰기가 실행 된 후에 만 ​​발생하도록 흐름을 통해 자체적으로 연결된 읽기 작업에 대해서만 그래디언트 계산을 수행해야합니다. 이렇게하면이 작업이 호출 될 때 순방향 TensorArray의 최종 크기를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aeb2d8441c532154e13fdb15d9d6cebc3cc43934" translate="yes" xml:space="preserve">
          <source>In the case of variable slice assignment, the Variable object to slice (i.e. tensor is the read-only view of this variable).</source>
          <target state="translated">가변 슬라이스 할당의 경우, 슬라이스 할 Variable 객체 (즉, 텐서는이 변수의 읽기 전용보기입니다).</target>
        </trans-unit>
        <trans-unit id="51ed01e4d71ead3866c98e46077be45f69b99800" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, computes for 0 &amp;lt;= b &amp;lt; batch_size, 0 &amp;lt;= x[i] &amp;lt; output_spatial_shape[i], 0 &amp;lt;= c &amp;lt; num_channels:</source>
          <target state="translated">&lt;code&gt;data_format&lt;/code&gt; 이 &quot;NC&quot;로 시작하지 않는 경우 0 &amp;lt;= b &amp;lt;batch_size, 0 &amp;lt;= x [i] &amp;lt;output_spatial_shape [i], 0 &amp;lt;= c &amp;lt;num_channels를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f7489a66c28d483acf8142e46fd3d2bce2a97dfd" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output (but not the &lt;code&gt;filter&lt;/code&gt;) are simply transposed as follows:</source>
          <target state="translated">경우에서 &lt;code&gt;data_format&lt;/code&gt; 은 시작 않는다 &lt;code&gt;&quot;NC&quot;&lt;/code&gt; 는 &lt;code&gt;input&lt;/code&gt; 및 출력 (그러나 &lt;code&gt;filter&lt;/code&gt; 는 다음과 같이 간단하게 전치된다)</target>
        </trans-unit>
        <trans-unit id="15f5b22f7879c5fdc5ce4821da71380664867c9e" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; does start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output (but not the &lt;code&gt;filters&lt;/code&gt;) are simply transposed as follows:</source>
          <target state="translated">하는 경우 &lt;code&gt;data_format&lt;/code&gt; 이 시작 않는다 &lt;code&gt;&quot;NC&quot;&lt;/code&gt; 는 &lt;code&gt;input&lt;/code&gt; 및 출력 (하지만하지 &lt;code&gt;filters&lt;/code&gt; 다음과 같이) 단순히 전치된다 :</target>
        </trans-unit>
        <trans-unit id="14d0f86400986de97cae42ee5dcb99d4d7671a66" translate="yes" xml:space="preserve">
          <source>In the case that &lt;code&gt;data_format&lt;/code&gt; starts with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, the &lt;code&gt;input&lt;/code&gt; and output are simply transposed as follows:</source>
          <target state="translated">그 경우 &lt;code&gt;data_format&lt;/code&gt; 를 함께 시작 &lt;code&gt;&quot;NC&quot;&lt;/code&gt; 의 &lt;code&gt;input&lt;/code&gt; 은 다음과 같이 간단히 전치 출력된다 :</target>
        </trans-unit>
        <trans-unit id="7585f71a96a6a1ba424fe17e28a732edc83fab83" translate="yes" xml:space="preserve">
          <source>In the case where texts contains lists, we assume each entry of the lists to be a token.</source>
          <target state="translated">텍스트에 목록이 포함 된 경우 목록의 각 항목이 토큰 인 것으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="b27ad5d7c7812f56a3419c5193f53b839dec7afb" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;a href=&quot;../../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt; &lt;code&gt;dist_dataset&lt;/code&gt; 는 GLOBAL_BATCH_SIZE 에 의해 일괄 처리되며 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; 에서 &lt;code&gt;for x in dist_dataset&lt;/code&gt; 사용하여 반복합니다 . &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;../../../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 일괄 모든 복제본 데이터 집계를 포함 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; . &lt;a href=&quot;../../../../distribute/strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 올바른 복제본 별 데이터 를 각 복제본에서 실행되는 올바른 &lt;code&gt;replica_fn&lt;/code&gt; 에 공급합니다 .</target>
        </trans-unit>
        <trans-unit id="7b0ee0fc7fad22052facea76762652a1189c53cf" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;a href=&quot;../../../distribute/distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt; &lt;code&gt;dist_dataset&lt;/code&gt; 는 GLOBAL_BATCH_SIZE 에 의해 일괄 처리되며 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; 에서 &lt;code&gt;for x in dist_dataset&lt;/code&gt; 사용하여 반복합니다 . &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;../../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 일괄 모든 복제본 데이터 집계를 포함 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; . &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 올바른 복제본 별 데이터 를 각 복제본에서 실행되는 올바른 &lt;code&gt;replica_fn&lt;/code&gt; 에 공급합니다 .</target>
        </trans-unit>
        <trans-unit id="8de2e5a52ce490990b1fec55c4aff42334fa5999" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;../distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;../distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;../strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;a href=&quot;../distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt; &lt;code&gt;dist_dataset&lt;/code&gt; 는 GLOBAL_BATCH_SIZE 에 의해 일괄 처리되며 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; 에서 &lt;code&gt;for x in dist_dataset&lt;/code&gt; 사용하여 반복합니다 . &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;../distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 일괄 모든 복제본 데이터 집계를 포함 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; . &lt;a href=&quot;../strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 올바른 복제본 별 데이터 를 각 복제본에서 실행되는 올바른 &lt;code&gt;replica_fn&lt;/code&gt; 에 공급합니다 .</target>
        </trans-unit>
        <trans-unit id="f66841e03e2835d1f04c157d851fbcf3d05c9105" translate="yes" xml:space="preserve">
          <source>In the code snippet above, the &lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt;&lt;code&gt;dist_dataset&lt;/code&gt; is batched by &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;, and we iterate through it using &lt;code&gt;for x in dist_dataset&lt;/code&gt;. &lt;code&gt;x&lt;/code&gt; a &lt;a href=&quot;distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; containing data for all replicas, which aggregates to a batch of &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt;. &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; will take care of feeding the right per-replica data in &lt;code&gt;x&lt;/code&gt; to the right &lt;code&gt;replica_fn&lt;/code&gt; executed on each replica.</source>
          <target state="translated">위의 코드 스 니펫에서 &lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; &lt;/a&gt; &lt;code&gt;dist_dataset&lt;/code&gt; 는 GLOBAL_BATCH_SIZE 에 의해 일괄 처리되며 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; 에서 &lt;code&gt;for x in dist_dataset&lt;/code&gt; 사용하여 반복합니다 . &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 일괄 모든 복제본 데이터 집계를 포함 &lt;code&gt;GLOBAL_BATCH_SIZE&lt;/code&gt; . &lt;a href=&quot;strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 올바른 복제본 별 데이터 를 각 복제본에서 실행되는 올바른 &lt;code&gt;replica_fn&lt;/code&gt; 에 공급합니다 .</target>
        </trans-unit>
        <trans-unit id="441c8788356ac631e91eb9d0cc144a89f12dd164" translate="yes" xml:space="preserve">
          <source>In the common case where the 'depth' dimension is the last dimension in the input tensor &lt;code&gt;x&lt;/code&gt;, they may be one dimensional tensors of the same size as the 'depth' dimension. This is the case for example for the common &lt;code&gt;[batch, depth]&lt;/code&gt; layout of fully-connected layers, and &lt;code&gt;[batch, height, width, depth]&lt;/code&gt; for convolutions. &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;variance&lt;/code&gt; in this case would typically be the outputs of &lt;a href=&quot;moments&quot;&gt;&lt;code&gt;tf.nn.moments(..., keepdims=False)&lt;/code&gt;&lt;/a&gt; during training, or running averages thereof during inference.</source>
          <target state="translated">'깊이'치수가 입력 텐서 &lt;code&gt;x&lt;/code&gt; 의 마지막 치수 인 일반적인 경우 , 이들은 '깊이'치수와 동일한 크기의 1 차원 텐서 일 수 있습니다. 예를 들어 완전히 연결된 레이어 의 일반적인 &lt;code&gt;[batch, depth]&lt;/code&gt; 레이아웃과 컨볼 루션의 경우 &lt;code&gt;[batch, height, width, depth]&lt;/code&gt; 에 해당합니다. 이 경우 &lt;code&gt;mean&lt;/code&gt; 및 &lt;code&gt;variance&lt;/code&gt; 은 일반적으로 훈련 중 &lt;a href=&quot;moments&quot;&gt; &lt;code&gt;tf.nn.moments(..., keepdims=False)&lt;/code&gt; &lt;/a&gt; 의 출력 또는 추론 중 평균 실행입니다.</target>
        </trans-unit>
        <trans-unit id="a2fdaa32535bc5d1425dc1f4179459c262cc1196" translate="yes" xml:space="preserve">
          <source>In the event that L and D are positive-definite, and U = V, solves and determinants can be done using a Cholesky factorization.</source>
          <target state="translated">L과 D가 양의 한정이고 U = V 인 경우, hole 레 스키 인수 분해를 사용하여 풀고 결정자를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f900f7fb08d74d77d09a58c36e14dae29b1b5604" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;d&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; are symbolic &lt;code&gt;Tensor&lt;/code&gt; objects, whereas &lt;code&gt;result&lt;/code&gt; is a numpy array that stores a concrete value:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;d&lt;/code&gt; 및 &lt;code&gt;e&lt;/code&gt; 는 기호 &lt;code&gt;Tensor&lt;/code&gt; 객체 인 반면 &lt;code&gt;result&lt;/code&gt; 는 구체적 값을 저장하는 numpy 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f8159cd552f6905daabd6b0759c879dc3cb02b31" translate="yes" xml:space="preserve">
          <source>In the following example, both &lt;code&gt;z&lt;/code&gt; and &lt;code&gt;w&lt;/code&gt; will be scaled by the same &lt;code&gt;y&lt;/code&gt;. It is important to note that if we didn't assign &lt;code&gt;scalar_name&lt;/code&gt; and used a different name for z and w that a &lt;code&gt;ValueError&lt;/code&gt; would be thrown because it couldn't reuse the variable.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;z&lt;/code&gt; 와 &lt;code&gt;w&lt;/code&gt; 는 모두 같은 &lt;code&gt;y&lt;/code&gt; 로 조정됩니다 . &lt;code&gt;scalar_name&lt;/code&gt; 을 할당하지 않고 z와 w에 다른 이름을 사용 하면 변수를 재사용 할 수 없으므로 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 한다는 점에 유의 해야합니다.</target>
        </trans-unit>
        <trans-unit id="af225700bf663e20d927b904a713beaec69b8ae6" translate="yes" xml:space="preserve">
          <source>In the following example, the value returned by &lt;a href=&quot;raggedtensor#numpy&quot;&gt;&lt;code&gt;RaggedTensor.numpy()&lt;/code&gt;&lt;/a&gt; contains three numpy &lt;code&gt;array&lt;/code&gt; objects: one for each row (with &lt;code&gt;rank=1&lt;/code&gt; and &lt;code&gt;dtype=int64&lt;/code&gt;), and one to combine them (with &lt;code&gt;rank=1&lt;/code&gt; and &lt;code&gt;dtype=object&lt;/code&gt;):</source>
          <target state="translated">다음 예제에서 &lt;a href=&quot;raggedtensor#numpy&quot;&gt; &lt;code&gt;RaggedTensor.numpy()&lt;/code&gt; &lt;/a&gt; 의해 반환 된 값 은 세 개의 numpy &lt;code&gt;array&lt;/code&gt; 객체를 포함 합니다. 각 행마다 하나씩 ( &lt;code&gt;rank=1&lt;/code&gt; 및 &lt;code&gt;dtype=int64&lt;/code&gt; 사용 ), 하나는 결합 할 ( &lt;code&gt;rank=1&lt;/code&gt; 및 &lt;code&gt;dtype=object&lt;/code&gt; 사용 ) :</target>
        </trans-unit>
        <trans-unit id="fd46fe1d494a119de52de4263e78cb6431e1f9cf" translate="yes" xml:space="preserve">
          <source>In the following examples, each input in the range &lt;code&gt;[0, 1000000)&lt;/code&gt; is assigned the same value. All other inputs are assigned &lt;code&gt;default_value&lt;/code&gt; 0. Note that a literal 0 in inputs will result in the same default ID.</source>
          <target state="translated">다음 예에서 &lt;code&gt;[0, 1000000)&lt;/code&gt; 범위의 각 입력 에는 동일한 값이 할당됩니다. 다른 모든 입력에는 &lt;code&gt;default_value&lt;/code&gt; 0 이 할당됩니다. 입력 의 리터럴 0은 동일한 기본 ID를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="e4ffded633c0b56e0d92344cf2671f58b989b260" translate="yes" xml:space="preserve">
          <source>In the following shapes, &lt;code&gt;nnz&lt;/code&gt; is the count after taking &lt;code&gt;thresh&lt;/code&gt; into account.</source>
          <target state="translated">다음과 같은 모양으로, &lt;code&gt;nnz&lt;/code&gt; 복용 후 수입니다 &lt;code&gt;thresh&lt;/code&gt; 고려.</target>
        </trans-unit>
        <trans-unit id="7a0a21a5321a939e4c6ec979642cca57482d54e4" translate="yes" xml:space="preserve">
          <source>In the future we may use this object to add more information about result of run without changing the Hook API.</source>
          <target state="translated">앞으로이 API를 사용하여 Hook API를 변경하지 않고 실행 결과에 대한 추가 정보를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76fa778b0319a626a08c3bad3138553249a30e42" translate="yes" xml:space="preserve">
          <source>In the future, there will be additional processing modes. For example, a &quot;one_epoch&quot; mode which partitions the dataset across the tf.data workers, so that the consumers see each element of the dataset only once.</source>
          <target state="translated">앞으로 추가 처리 모드가있을 것입니다. 예를 들어, 소비자가 데이터 세트의 각 요소를 한 번만 볼 수 있도록 데이터 세트를 tf.data 작업자에 걸쳐 분할하는 &quot;one_epoch&quot;모드입니다.</target>
        </trans-unit>
        <trans-unit id="321470037eed07ac96098def67a575832b48e3a6" translate="yes" xml:space="preserve">
          <source>In the general case, produces an output tensor where:</source>
          <target state="translated">일반적인 경우 출력 텐서를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="14120b56799edd7f482d4829806eaaaa1dc71825" translate="yes" xml:space="preserve">
          <source>In the integer case, the random integers are slightly biased unless &lt;code&gt;maxval - minval&lt;/code&gt; is an exact power of two. The bias is small for values of &lt;code&gt;maxval - minval&lt;/code&gt; significantly smaller than the range of the output (either &lt;code&gt;2**32&lt;/code&gt; or &lt;code&gt;2**64&lt;/code&gt;).</source>
          <target state="translated">정수의 경우, &lt;code&gt;maxval - minval&lt;/code&gt; 이 2의 정확한 거듭 제곱이 아니면 임의의 정수는 약간 바이어스됩니다 . &lt;code&gt;maxval - minval&lt;/code&gt; 값이 출력 범위 ( &lt;code&gt;2**32&lt;/code&gt; 또는 &lt;code&gt;2**64&lt;/code&gt; ) 보다 상당히 작은 경우 바이어스가 작습니다 .</target>
        </trans-unit>
        <trans-unit id="80812666c20de5f1b3022c6818967c980a3249c2" translate="yes" xml:space="preserve">
          <source>In the normal case, this returns the grpc path (grpc://1.2.3.4:8470) of first instance in the ClusterSpec returned by the cluster_spec function.</source>
          <target state="translated">일반적인 경우 cluster_spec 함수가 반환 한 ClusterSpec에서 첫 번째 인스턴스의 grpc 경로 (grpc : //1.2.3.4 : 8470)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6055b65c599f09ebc21e3aeb62b02718663e00f7" translate="yes" xml:space="preserve">
          <source>In the returned matrix, all the triangles (filterbanks) have a peak value of 1.0.</source>
          <target state="translated">반환 된 행렬에서 모든 삼각형 (필터 뱅크)의 피크 값은 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="d5d60edca816e4a2eab7c2afcd535e33631948ae" translate="yes" xml:space="preserve">
          <source>In the snippet below, each of the four examples has only a single floating-pointing value, and both &lt;code&gt;y_pred&lt;/code&gt; and &lt;code&gt;y_true&lt;/code&gt; have the shape &lt;code&gt;[batch_size]&lt;/code&gt;.</source>
          <target state="translated">아래 스 니펫에서 네 가지 예제 각각은 단일 부동 소수점 &lt;code&gt;y_true&lt;/code&gt; 가지며 &lt;code&gt;y_pred&lt;/code&gt; 및 y_true 는 &lt;code&gt;[batch_size]&lt;/code&gt; 모양 입니다.</target>
        </trans-unit>
        <trans-unit id="8c495e13d301e9ffca0e963e7389b1c288c748a1" translate="yes" xml:space="preserve">
          <source>In the snippet below, there is &lt;code&gt;# classes&lt;/code&gt; floating pointing values per example. The shape of both &lt;code&gt;y_pred&lt;/code&gt; and &lt;code&gt;y_true&lt;/code&gt; are &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;.</source>
          <target state="translated">아래 스 니펫에는 예제 당 &lt;code&gt;# classes&lt;/code&gt; 부동 소수점 값이 있습니다. &lt;code&gt;y_pred&lt;/code&gt; 및 &lt;code&gt;y_true&lt;/code&gt; 의 모양 은 &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ca0a25a87addb666ce34fdcd635cb0fb4ef8b8c8" translate="yes" xml:space="preserve">
          <source>In the snippet below, there is a single floating point value per example for &lt;code&gt;y_true&lt;/code&gt; and &lt;code&gt;# classes&lt;/code&gt; floating pointing values per example for &lt;code&gt;y_pred&lt;/code&gt;. The shape of &lt;code&gt;y_true&lt;/code&gt; is &lt;code&gt;[batch_size]&lt;/code&gt; and the shape of &lt;code&gt;y_pred&lt;/code&gt; is &lt;code&gt;[batch_size, num_classes]&lt;/code&gt;.</source>
          <target state="translated">(가) 아래의 코드에서, 예를 들어 당 하나의 부동 소수점 값있다 &lt;code&gt;y_true&lt;/code&gt; 및 &lt;code&gt;# classes&lt;/code&gt; 에 대한 예에 따라 값을 가리키는 부동 &lt;code&gt;y_pred&lt;/code&gt; 이 . &lt;code&gt;y_true&lt;/code&gt; 의 모양 은 &lt;code&gt;[batch_size]&lt;/code&gt; 이고 &lt;code&gt;y_pred&lt;/code&gt; 의 모양 은 &lt;code&gt;[batch_size, num_classes]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="edfa06a723b9aaa9b154321c98c5e60a3a87f241" translate="yes" xml:space="preserve">
          <source>In the special case that &lt;code&gt;dilation_rate&lt;/code&gt; is uniformly 1, this simply returns:</source>
          <target state="translated">&lt;code&gt;dilation_rate&lt;/code&gt; 가 균일하게 1 인 특수한 경우 , 이것은 단순히 다음을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1c3bff4b004264f13b9d5870cad9395d93194227" translate="yes" xml:space="preserve">
          <source>In the training program you will just have to run the returned Op.</source>
          <target state="translated">교육 프로그램에서는 반환 된 Op를 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="d2890695a83ce1f36c63f8da28ce25a62b890df2" translate="yes" xml:space="preserve">
          <source>In the training program, every worker will run the train_op as if not synchronized.</source>
          <target state="translated">교육 프로그램에서 모든 작업자는 동기화되지 않은 것처럼 train_op을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="050220458220cef5d8bae5a963a516346fce1ddc" translate="yes" xml:space="preserve">
          <source>In these cases, using &lt;a href=&quot;tensor#shape&quot;&gt;&lt;code&gt;tf.Tensor.shape&lt;/code&gt;&lt;/a&gt; will return more informative results.</source>
          <target state="translated">이 경우 &lt;a href=&quot;tensor#shape&quot;&gt; &lt;code&gt;tf.Tensor.shape&lt;/code&gt; &lt;/a&gt; 를 사용 하면보다 유익한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1fd23dc3b76dcc4f826b1d79ad28663677c68d6" translate="yes" xml:space="preserve">
          <source>In this case if &lt;code&gt;foo.shape&lt;/code&gt; is (5, 5, 5, 5, 5, 5) the final shape of the slice becomes (2, 1, 5, 5, 2, 5). Let us walk step by step through each argument specification.</source>
          <target state="translated">이 경우 &lt;code&gt;foo.shape&lt;/code&gt; 가 (5, 5, 5, 5, 5, 5)이면 슬라이스의 최종 모양은 (2, 1, 5, 5, 2, 5)가됩니다. 각 인수 사양을 단계별로 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="de68be184025a4393a876c4969dd2dac3ec1ddab" translate="yes" xml:space="preserve">
          <source>In this case the last 3 data points are discarded since no full sequence can be generated to include them (the next sequence would have started at index 81, and thus its last step would have gone over 99).</source>
          <target state="translated">이 경우 마지막 3 개의 데이터 포인트는이를 포함 할 전체 시퀀스를 생성 할 수 없기 때문에 삭제됩니다 (다음 시퀀스는 인덱스 81에서 시작되어 마지막 단계가 99 개를 넘었을 것입니다).</target>
        </trans-unit>
        <trans-unit id="2660fc8b716618056f3f2486b9d3eda40cce99bb" translate="yes" xml:space="preserve">
          <source>In this case, no TRT engines will be built or saved in the converted SavedModel. But if input data is available during conversion, we can still build and save the TRT engines to reduce the cost during inference (see option 2 below).</source>
          <target state="translated">이 경우 변환 된 SavedModel에 TRT 엔진이 빌드되거나 저장되지 않습니다. 그러나 변환 중에 입력 데이터를 사용할 수있는 경우에도 추론 중 비용을 줄이기 위해 TRT 엔진을 빌드하고 저장할 수 있습니다 (아래 옵션 2 참조).</target>
        </trans-unit>
        <trans-unit id="e5fc3e497d02a7bd7ecbf4bfc91e80a8c16dab8c" translate="yes" xml:space="preserve">
          <source>In this case, the L2-norm of the output tensor is &lt;code&gt;clip_norm&lt;/code&gt;.</source>
          <target state="translated">이 경우 출력 텐서의 L2-norm은 &lt;code&gt;clip_norm&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fb53270a9519bb4c8fc2a2da8dd867f7bc0eb615" translate="yes" xml:space="preserve">
          <source>In this case, the average L2-norm of the output tensor is &lt;code&gt;clip_norm&lt;/code&gt;.</source>
          <target state="translated">이 경우 출력 텐서의 평균 L2-norm은 &lt;code&gt;clip_norm&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="82633df4f4d329acaa3d11394d5cdde32a611bc2" translate="yes" xml:space="preserve">
          <source>In this case, the default value used is &lt;code&gt;l1=0.01&lt;/code&gt;.</source>
          <target state="translated">이 경우 사용되는 기본값은 &lt;code&gt;l1=0.01&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4f71d9a8d2db7be1d1b1df2b421e4dfeaafef046" translate="yes" xml:space="preserve">
          <source>In this case, the default value used is &lt;code&gt;l2=0.01&lt;/code&gt;.</source>
          <target state="translated">이 경우 사용되는 기본값은 &lt;code&gt;l2=0.01&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="20678523ff7af42a84aac9bea4ae4af2f137e76a" translate="yes" xml:space="preserve">
          <source>In this case, the default values used are &lt;code&gt;l1=0.01&lt;/code&gt; and &lt;code&gt;l2=0.01&lt;/code&gt;.</source>
          <target state="translated">이 경우 사용되는 기본값은 &lt;code&gt;l1=0.01&lt;/code&gt; 및 &lt;code&gt;l2=0.01&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1634e039fe69dd10f4980724390eee9597b30add" translate="yes" xml:space="preserve">
          <source>In this case, there is only one device, so this is only a thin wrapper around the input dataset. It will, however, prefetch the input data to the specified device. The returned distributed dataset can be iterated over similar to how regular datasets can.</source>
          <target state="translated">이 경우 장치가 하나뿐이므로 입력 데이터 세트 주위의 얇은 래퍼 일뿐입니다. 그러나 입력 데이터를 지정된 장치로 프리 페치합니다. 리턴 된 분산 데이터 세트는 일반 데이터 세트와 유사한 방식으로 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e6c4c191f1042cc1f68cb766a50b94ec5bf0741" translate="yes" xml:space="preserve">
          <source>In this case, we are setting both the global and operation-level seed to ensure this result is reproducible. See &lt;a href=&quot;set_seed&quot;&gt;&lt;code&gt;tf.random.set_seed&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">이 경우이 결과를 재현 할 수 있도록 전역 및 작업 수준 시드를 모두 설정합니다. 자세한 내용은 &lt;a href=&quot;set_seed&quot;&gt; &lt;code&gt;tf.random.set_seed&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c08e98fab219660f174a2388abcd7b00423921f2" translate="yes" xml:space="preserve">
          <source>In this example, the input value 'z' resulted in an output of '[UNK]', since 1000 was not in the vocabulary - it got represented as an OOV, and all OOV values are returned as '[OOV}' in the inverse layer. Also, note that for the inverse to work, you must have already set the forward layer vocabulary either directly or via fit() before calling get_vocabulary().</source>
          <target state="translated">이 예에서 입력 값 'z'는 1000이 어휘에 없기 때문에 '[UNK]'의 출력이됩니다. OOV로 표시되고 모든 OOV 값은 '[OOV}'로 반환됩니다. 역 레이어. 또한 역이 작동하려면 get_vocabulary ()를 호출하기 전에 직접 또는 fit ()을 통해 포워드 레이어 어휘를 이미 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a7c2f6499422f484ac6f330b882d5c04cd4e3dc" translate="yes" xml:space="preserve">
          <source>In this example, the input value 1000 resulted in an output of -1, since 1000 was not in the vocabulary - it got represented as an OOV, and all OOV values are returned as -1 in the inverse layer. Also, note that for the inverse to work, you must have already set the forward layer vocabulary either directly or via fit() before calling get_vocabulary().</source>
          <target state="translated">이 예에서 입력 값 1000은 1000이 어휘에 포함되지 않았기 때문에 -1의 출력을 얻었습니다. OOV로 표시되고 모든 OOV 값은 역 레이어에서 -1로 반환됩니다. 또한 역이 작동하려면 get_vocabulary ()를 호출하기 전에 직접 또는 fit ()을 통해 포워드 레이어 어휘를 이미 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="36765b42855ac10a2bf8048f167e7fc07d039efe" translate="yes" xml:space="preserve">
          <source>In this example, we want to trace how much time spent on calling a function, which includes compilation and execution. The compilation can be either getting a cached copy of the binary or actually generating the binary, which is indicated by the boolean &quot;in_cache&quot; returned by jit_compile(). We need to use set_metadata() to pass in_cache because we did not know the in_cache value when the trace was created (and we cannot create the trace after jit_compile(), because we want to measure the entire duration of call()).</source>
          <target state="translated">이 예에서는 컴파일 및 실행을 포함하는 함수 호출에 소요 된 시간을 추적하려고합니다. 컴파일은 바이너리의 캐시 된 복사본을 가져 오거나 실제로 바이너리를 생성 할 수 있으며, 이는 jit_compile ()에서 반환 된 부울 &quot;in_cache&quot;로 표시됩니다. trace가 생성 될 때 in_cache 값을 몰랐기 때문에 set_metadata ()를 사용하여 in_cache를 전달해야합니다 (그리고 call ()의 전체 기간을 측정하고 싶기 때문에 jit_compile () 이후에 추적을 생성 할 수 없습니다).</target>
        </trans-unit>
        <trans-unit id="c2073cc64d02b3bf0e594d35e4cce41ba26845eb" translate="yes" xml:space="preserve">
          <source>In this manner, the output is the best split per features and per node, so that it needs to be combined later to produce the best split for each node (among all possible features).</source>
          <target state="translated">이러한 방식으로 출력은 기능 및 노드 당 최상의 분할이므로 나중에 결합하여 각 노드에 대해 최상의 분할을 생성해야합니다 (가능한 모든 기능 중에서).</target>
        </trans-unit>
        <trans-unit id="72a8363320500d7fb6d0fa2afac0abec913757b2" translate="yes" xml:space="preserve">
          <source>In this way, one engine will be built/saved for each unique input shapes of the TRTEngineOp. This is good for applications that cannot afford building engines during inference but have access to input data that is similar to the one used in production (for example, that has the same input shapes). Also, the generated TRT engines is platform dependent, so we need to run &lt;code&gt;build()&lt;/code&gt; in an environment that is similar to production (e.g. with same type of GPU).</source>
          <target state="translated">이러한 방식으로 TRTEngineOp의 고유 한 입력 형태마다 하나의 엔진이 구축 / 저장됩니다. 이는 추론 중에 엔진을 구축 할 수 없지만 생산에 사용 된 것과 유사한 입력 데이터 (예 : 동일한 입력 모양)에 액세스 할 수있는 응용 프로그램에 적합합니다. 또한 생성 된 TRT 엔진은 플랫폼에 따라 다르므로 프로덕션과 유사한 환경 (예 : 동일한 유형의 GPU)에서 &lt;code&gt;build()&lt;/code&gt; 를 실행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d79a01d9608f76fd6bbb337a8da6d7bca3045f57" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;../../../distribute/strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a the gradient of the loss with respect to the variable.</source>
          <target state="translated">&lt;a href=&quot;../../../distribute/strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수 에서 (업데이트, 변수) 쌍의 목록을 계산하십시오. 예를 들어, 업데이트는 변수에 대한 손실의 기울기 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49a3474d0eadcec0f5e50cac1d06d710f2afe071" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a gradient of the loss with respect to the variable.</source>
          <target state="translated">&lt;a href=&quot;../../../distribute/strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수 에서 (업데이트, 변수) 쌍 목록을 계산합니다. 예를 들어, 업데이트는 변수에 대한 손실의 기울기 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2be7b3f65cefd5207608f7e806a86637c30fe91" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;strategy#experimental_run_v2&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a the gradient of the loss with respect to the variable.</source>
          <target state="translated">&lt;a href=&quot;strategy#experimental_run_v2&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_run_v2&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수 에서 (업데이트, 변수) 쌍의 목록을 계산하십시오. 예를 들어, 업데이트는 변수에 대한 손실의 기울기 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a83b0c1dab2d4de5a70f6316ecc8989d437aa351" translate="yes" xml:space="preserve">
          <source>In your function passed to &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt;, compute a list of (update, variable) pairs. For example, the update might be a gradient of the loss with respect to the variable.</source>
          <target state="translated">&lt;a href=&quot;strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 에&lt;/a&gt; 전달 된 함수 에서 (업데이트, 변수) 쌍 목록을 계산합니다. 예를 들어, 업데이트는 변수에 대한 손실의 기울기 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f49734e2288a63e9d6cf105bcbf81ab57a1bf7f" translate="yes" xml:space="preserve">
          <source>InTopK</source>
          <target state="translated">InTopK</target>
        </trans-unit>
        <trans-unit id="29498645b8e9de5e6fa1f035894033a32dcc0f61" translate="yes" xml:space="preserve">
          <source>InTopKV2</source>
          <target state="translated">InTopKV2</target>
        </trans-unit>
        <trans-unit id="ce8d799de35e2f145c21e92a425ca2ee660eb326" translate="yes" xml:space="preserve">
          <source>Inception V3 model for Keras.</source>
          <target state="translated">Keras의 시작 V3 모델.</target>
        </trans-unit>
        <trans-unit id="7d73f3eef76607d1a301c6ca302e845c6db2ac6e" translate="yes" xml:space="preserve">
          <source>Inception-ResNet V2 model for Keras.</source>
          <target state="translated">Keras를위한 Inception-ResNet V2 모델.</target>
        </trans-unit>
        <trans-unit id="8cf033bd7091b2790e4f777f8b19874075bff1bf" translate="yes" xml:space="preserve">
          <source>Included for symmetry with assertIsInstance.</source>
          <target state="translated">assertIsInstance와의 대칭에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dcefd427b6a3fb13c379c178050dfc9a698717db" translate="yes" xml:space="preserve">
          <source>Included for symmetry with assertIsNone.</source>
          <target state="translated">assertIsNone과의 대칭에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="dd470208c6fa4ca92528cf0186d20c9f5b2f59b7" translate="yes" xml:space="preserve">
          <source>Includes slot variables and additional global variables created by the optimizer in the current default graph.</source>
          <target state="translated">슬롯 변수 및 현재 기본 그래프에서 옵티마이 저가 작성한 추가 전역 변수를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="8c54bd291b44a258e4c2d45445c731a1166f33f9" translate="yes" xml:space="preserve">
          <source>Increases loss scale every &lt;code&gt;increment_period&lt;/code&gt; consecutive steps that finite gradients are encountered. If a nonfinite gradient is encountered, the count is reset back to zero.</source>
          <target state="translated">유한 그라디언트가 발생하는 &lt;code&gt;increment_period&lt;/code&gt; 연속 단계 마다 손실 스케일을 증가시킵니다 . 무한 그라디언트가 발생하면 카운트가 다시 0으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e5b7858555d1e2aa8307bbc5a543b25db84aeba7" translate="yes" xml:space="preserve">
          <source>Incremented when &lt;code&gt;save()&lt;/code&gt; is called. Used to number checkpoints.</source>
          <target state="translated">&lt;code&gt;save()&lt;/code&gt; 가 호출 될 때 증가합니다 . 체크 포인트 번호를 매기는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="728ce17bd1a7957f53eadbd1391ef352561ac235" translate="yes" xml:space="preserve">
          <source>Increments 'ref' until it reaches 'limit'.</source>
          <target state="translated">'제한'에 도달 할 때까지 'ref'를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="7b391a6fad790101cab029c9fe225295336e842c" translate="yes" xml:space="preserve">
          <source>Increments 'ref' until it reaches 'limit'. (deprecated)</source>
          <target state="translated">'limit'에 도달 할 때까지 'ref'를 증가시킵니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="de594db0e57668b8b85789cc78fb4c139b3a182a" translate="yes" xml:space="preserve">
          <source>Increments this variable until it reaches &lt;code&gt;limit&lt;/code&gt;. (deprecated)</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 도달 할 때까지이 변수를 증가시킵니다 . (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="b394c28b7279ea2928e8eb6964bdab03004d76bb" translate="yes" xml:space="preserve">
          <source>Increments variable pointed to by 'resource' until it reaches 'limit'.</source>
          <target state="translated">'제한'에 도달 할 때까지 '자원'이 가리키는 변수를 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="cdb762cdb787c49b81cc06d51b455e4a3ecd0341" translate="yes" xml:space="preserve">
          <source>Index of current step.</source>
          <target state="translated">현재 단계의 색인입니다.</target>
        </trans-unit>
        <trans-unit id="1d219bcbd2ca8f15aeb03cccca9e989e6dc9c7d0" translate="yes" xml:space="preserve">
          <source>Indexing into a 3-tensor:</source>
          <target state="translated">3 텐서로 인덱싱 :</target>
        </trans-unit>
        <trans-unit id="5e79dd26697e6bbf367b2fdeab36765d539b5fbd" translate="yes" xml:space="preserve">
          <source>Indicate that a summary was computed.</source>
          <target state="translated">요약이 계산되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="82dbc404b49d6777aa92664b08fd68f890d9eccb" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated.</source>
          <target state="translated">분산 변수가 집계되는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="355fab5dece9905786ed039c29043ef923b3adf5" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variableaggregation&quot;&gt;&lt;code&gt;tf.VariableAggregation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">분산 변수가 집계되는 방식을 나타냅니다. 허용되는 값은 &lt;a href=&quot;../../variableaggregation&quot;&gt; &lt;code&gt;tf.VariableAggregation&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="00f0ecce80ce2d885c3b8c2bb0d0238071880b87" translate="yes" xml:space="preserve">
          <source>Indicates how a distributed variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;variableaggregation&quot;&gt;&lt;code&gt;tf.VariableAggregation&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">분산 변수가 집계되는 방식을 나타냅니다. 허용되는 값은 &lt;a href=&quot;variableaggregation&quot;&gt; &lt;code&gt;tf.VariableAggregation&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 상수 입니다.</target>
        </trans-unit>
        <trans-unit id="7d8aeb2df9b17e0f40b4d8f5858f3321132bd0c3" translate="yes" xml:space="preserve">
          <source>Indicates how a set of values should be reduced.</source>
          <target state="translated">값 집합을 줄이는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="502061f2d3846ae3f85cff4075516765180924ed" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;batch_shape == []&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;batch_shape == []&lt;/code&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="7f2a3ecc77c9bfd142bdfa3269a1a531f475325d" translate="yes" xml:space="preserve">
          <source>Indicates that &lt;code&gt;event_shape == []&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;event_shape == []&lt;/code&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="1f9580d405e3ceadc7ccac78cfd939bcd2065bff" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="translated">분산 된 변수가 집계되는시기를 나타냅니다. 허용되는 값은 &lt;a href=&quot;../../variablesynchronization&quot;&gt; &lt;code&gt;tf.VariableSynchronization&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 상수 입니다. 기본적으로 동기화는 &lt;code&gt;AUTO&lt;/code&gt; 로 설정되고 현재 &lt;code&gt;DistributionStrategy&lt;/code&gt; 는 동기화시기를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="c2d6c4f854b8135221915994629436858fce328c" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;../../variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize. If &lt;code&gt;synchronization&lt;/code&gt; is set to &lt;code&gt;ON_READ&lt;/code&gt;, &lt;code&gt;trainable&lt;/code&gt; must not be set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">분산 된 변수가 집계되는시기를 나타냅니다. 허용되는 값은 &lt;a href=&quot;../../variablesynchronization&quot;&gt; &lt;code&gt;tf.VariableSynchronization&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 상수 입니다. 기본적으로 동기화는 &lt;code&gt;AUTO&lt;/code&gt; 로 설정되고 현재 &lt;code&gt;DistributionStrategy&lt;/code&gt; 는 동기화시기를 선택합니다. 경우 &lt;code&gt;synchronization&lt;/code&gt; 설정되어 &lt;code&gt;ON_READ&lt;/code&gt; , &lt;code&gt;trainable&lt;/code&gt; 설정되지 않아야 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="585b652a60535a87a9ca42ef02672c3d4be7441b" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed a variable will be aggregated. Accepted values are constants defined in the class &lt;a href=&quot;variablesynchronization&quot;&gt;&lt;code&gt;tf.VariableSynchronization&lt;/code&gt;&lt;/a&gt;. By default the synchronization is set to &lt;code&gt;AUTO&lt;/code&gt; and the current &lt;code&gt;DistributionStrategy&lt;/code&gt; chooses when to synchronize.</source>
          <target state="translated">분산 된 변수가 집계되는시기를 나타냅니다. 허용되는 값은 &lt;a href=&quot;variablesynchronization&quot;&gt; &lt;code&gt;tf.VariableSynchronization&lt;/code&gt; &lt;/a&gt; 클래스에 정의 된 상수 입니다. 기본적으로 동기화는 &lt;code&gt;AUTO&lt;/code&gt; 로 설정되고 현재 &lt;code&gt;DistributionStrategy&lt;/code&gt; 는 동기화시기를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="b98b1943a15cc44f7a930e94a7aaa9be7ea89a2e" translate="yes" xml:space="preserve">
          <source>Indicates when a distributed variable will be synced.</source>
          <target state="translated">분산 변수가 동기화 될시기를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8c75d22921ecccc2882756dcd16f765287e01395" translate="yes" xml:space="preserve">
          <source>Indicates which piece of the RaggedTensor to return, using standard Python semantics (e.g., negative values index from the end). &lt;code&gt;key&lt;/code&gt; may have any of the following types:</source>
          <target state="translated">표준 Python 의미 체계를 사용하여 반환 할 RaggedTensor 부분을 나타냅니다 (예 : 끝에서 음수 값 인덱스). &lt;code&gt;key&lt;/code&gt; 는 다음 유형 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0dd9ad5b5718ae90949c420290ff39b5e8317055" translate="yes" xml:space="preserve">
          <source>Indices are output in row-major order.</source>
          <target state="translated">인덱스는 행 우선 순서로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="56bea990e2e30a7eb039911159d0ee2d92ff71de" translate="yes" xml:space="preserve">
          <source>Indices must be without repeats. This is only tested if &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">인덱스는 반복되지 않아야합니다. &lt;code&gt;validate_indices&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우에만 테스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="b7d1e9061deb0780f8cf8761707437290ba05e6b" translate="yes" xml:space="preserve">
          <source>Indices of elements to mask.</source>
          <target state="translated">마스킹 할 요소의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="d4f1e52513d8b0a7cd11c918b2299a04adcf6867" translate="yes" xml:space="preserve">
          <source>Indices of the sparse gradient to be applied.</source>
          <target state="translated">적용 할 희소 그래디언트의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="1afd7134a89ddbe19e6cadca6ca3f19798d1fd1c" translate="yes" xml:space="preserve">
          <source>Indices should be sorted in lexicographic order, and indices must not contain any repeats. If &lt;code&gt;validate_indices&lt;/code&gt; is True, these properties are checked during execution.</source>
          <target state="translated">색인은 사전 식 순서로 정렬해야하며 색인에는 반복이 포함되어서는 안됩니다. 경우 &lt;code&gt;validate_indices&lt;/code&gt; 은 True입니다, 이러한 속성은 실행시에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="1c195df5805c1138eb51a9a5c959d8b14d48139b" translate="yes" xml:space="preserve">
          <source>Indices should be sorted in lexicographic order, and indices must not contain any repeats. If &lt;code&gt;validate_indices&lt;/code&gt; is true, these properties are checked during execution.</source>
          <target state="translated">색인은 사전 순으로 정렬해야하며 색인에는 반복이 포함되어서는 안됩니다. 경우 &lt;code&gt;validate_indices&lt;/code&gt; 는 사실, 이러한 속성은 실행시에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="b0e0ca5db01771d327910e5e9f88826a2e60ad47" translate="yes" xml:space="preserve">
          <source>InfeedDequeue</source>
          <target state="translated">InfeedDequeue</target>
        </trans-unit>
        <trans-unit id="bcf6bd551bdd1dc178e212ec66098733e64b69f4" translate="yes" xml:space="preserve">
          <source>InfeedDequeueTuple</source>
          <target state="translated">InfeedDequeueTuple</target>
        </trans-unit>
        <trans-unit id="63af23d2efb54dff58bbef1e77ed37bbb7276cc1" translate="yes" xml:space="preserve">
          <source>InfeedEnqueue</source>
          <target state="translated">InfeedEnqueue</target>
        </trans-unit>
        <trans-unit id="149c1ecf9aec0d9d6cc77516abaf46375e31a222" translate="yes" xml:space="preserve">
          <source>InfeedEnqueuePrelinearizedBuffer</source>
          <target state="translated">InfeedEnqueuePrelinearizedBuffer</target>
        </trans-unit>
        <trans-unit id="f3de6b03c8e3115d2e11421b93ac58353f46116c" translate="yes" xml:space="preserve">
          <source>InfeedEnqueueTuple</source>
          <target state="translated">InfeedEnqueueTuple</target>
        </trans-unit>
        <trans-unit id="6b68b09f9769efecac45bf8fdca33e3d2565957a" translate="yes" xml:space="preserve">
          <source>Information about a command-line flag.</source>
          <target state="translated">명령 행 플래그에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="ec0acf85df4b3add32f27c24edcda3c4ac12ef0c" translate="yes" xml:space="preserve">
          <source>Information on how to save this Variable as a slice.</source>
          <target state="translated">이 변수를 슬라이스로 저장하는 방법에 대한 정보.</target>
        </trans-unit>
        <trans-unit id="0e51852bd546da5f45f8e214683a1a350100bb05" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/categoryencoding&quot;&gt;&lt;code&gt;CategoryEncoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/categoryencoding&quot;&gt; &lt;code&gt;CategoryEncoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="baac1737720873667a943deae5dfc7a9206719a0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/integerlookup&quot;&gt;&lt;code&gt;IntegerLookup&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/integerlookup&quot;&gt; &lt;code&gt;IntegerLookup&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5f51cd32183bed67eebdc24505fe9c60be0ff24" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/normalization&quot;&gt;&lt;code&gt;Normalization&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/normalization&quot;&gt; &lt;code&gt;Normalization&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bc4f19f5f5a1aae8d9a70979bdc84b8879158d3e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/stringlookup&quot;&gt;&lt;code&gt;StringLookup&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/stringlookup&quot;&gt; &lt;code&gt;StringLookup&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6d16843c9ea341a1347986bb59d03f16c9fb7aa" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/textvectorization&quot;&gt;&lt;code&gt;TextVectorization&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../../../../../keras/layers/experimental/preprocessing/textvectorization&quot;&gt; &lt;code&gt;TextVectorization&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="97a31c19a22414ef8ef5f357f1617f4cc1d647c1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../estimator/runconfig&quot;&gt;&lt;code&gt;RunConfig&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../../../estimator/runconfig&quot;&gt; &lt;code&gt;RunConfig&lt;/code&gt; &lt;/a&gt; : RunConfig</target>
        </trans-unit>
        <trans-unit id="f3d75bd146887dd05312c665b5ee9485003d0b9e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/callbacks/callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../../keras/callbacks/callback&quot;&gt; &lt;code&gt;Callback&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="137a14a45c0bb4c7ff0cd0805c170a01887b76aa" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/callbacks/tensorboard&quot;&gt;&lt;code&gt;TensorBoard&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../../../keras/callbacks/tensorboard&quot;&gt; &lt;code&gt;TensorBoard&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f48823b67183fe4d3982fdf099fd964de492638" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../../keras/layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="101288461115cd97710e1c4a718e36857f88eeb0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../../keras/layers/rnn&quot;&gt;&lt;code&gt;RNN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;../../../../keras/layers/rnn&quot;&gt; &lt;code&gt;RNN&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c98cf787068e63e655af32c1f75becc1009cb055" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;Dataset&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;Dataset&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b69b334b62f492a552001cca525723b81da0f8c3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="92ca55cab0329d064ac4fac10f97a987dd809443" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt;&lt;code&gt;StrategyExtended&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt; &lt;code&gt;StrategyExtended&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce2f291600404f60ebcf454fa3465a5983be16e9" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling1d&quot;&gt;&lt;code&gt;AveragePooling1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/averagepooling1d&quot;&gt; &lt;code&gt;AveragePooling1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="42a8a44e1d03faeea5270e723f842a3c2b65a425" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling2d&quot;&gt;&lt;code&gt;AveragePooling2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/averagepooling2d&quot;&gt; &lt;code&gt;AveragePooling2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1dbcb4046a301b62c85eab641c002d5100bb5b1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/averagepooling3d&quot;&gt;&lt;code&gt;AveragePooling3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/averagepooling3d&quot;&gt; &lt;code&gt;AveragePooling3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f3c972c579e20efad3f3479906c3fc65c603f93" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv1d&quot;&gt;&lt;code&gt;Conv1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;../../../keras/layers/conv1d&quot;&gt; &lt;code&gt;Conv1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f254da78653b4606006651809bbe544bb36c261f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv2d&quot;&gt;&lt;code&gt;Conv2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/conv2d&quot;&gt; &lt;code&gt;Conv2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0effe74634550b4623dd89f19fb3491982b74c2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv2dtranspose&quot;&gt;&lt;code&gt;Conv2DTranspose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/conv2dtranspose&quot;&gt; &lt;code&gt;Conv2DTranspose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f697c3bc6da2ce250b73eefb92542a6c67912d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv3d&quot;&gt;&lt;code&gt;Conv3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/conv3d&quot;&gt; &lt;code&gt;Conv3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8a3fb6f41c3a9e4dc192dd3ed365c7f15d77fc2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/conv3dtranspose&quot;&gt;&lt;code&gt;Conv3DTranspose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/conv3dtranspose&quot;&gt; &lt;code&gt;Conv3DTranspose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29b1fcf2404228be9923887f99e1f80308a0f551" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/dense&quot;&gt;&lt;code&gt;Dense&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/dense&quot;&gt; &lt;code&gt;Dense&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0af60cb1a6134b54526b90870c8a41324c86484" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/dropout&quot;&gt;&lt;code&gt;Dropout&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/dropout&quot;&gt; &lt;code&gt;Dropout&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e68321961235af8baeb6a5bf163c3912867702ac" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/flatten&quot;&gt;&lt;code&gt;Flatten&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/flatten&quot;&gt; &lt;code&gt;Flatten&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc8c1e4f9a9c221452851820ebe247974471806e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28a3a29fe589494fc0af3d023b9cb3692724e795" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool1d&quot;&gt;&lt;code&gt;MaxPool1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/maxpool1d&quot;&gt; &lt;code&gt;MaxPool1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7584250f981dacb4544b81a0445f6abdf4dac4c8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool2d&quot;&gt;&lt;code&gt;MaxPool2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/maxpool2d&quot;&gt; &lt;code&gt;MaxPool2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="154fe6589fea17c9dbbfd13300c3302b5cbec52a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/maxpool3d&quot;&gt;&lt;code&gt;MaxPool3D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/maxpool3d&quot;&gt; &lt;code&gt;MaxPool3D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7ff649eddfed113ec4b0f9190c07241e844f314" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/separableconv1d&quot;&gt;&lt;code&gt;SeparableConv1D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/separableconv1d&quot;&gt; &lt;code&gt;SeparableConv1D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76bebda566676ef2b3fefccf517c4294e818101f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../keras/layers/separableconv2d&quot;&gt;&lt;code&gt;SeparableConv2D&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../../keras/layers/separableconv2d&quot;&gt; &lt;code&gt;SeparableConv2D&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0a3c9aaf5c80873ddedbb167634670d3320e6f1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../lookup/statichashtable&quot;&gt;&lt;code&gt;StaticHashTable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../../lookup/statichashtable&quot;&gt; &lt;code&gt;StaticHashTable&lt;/code&gt; &lt;/a&gt; : StaticHashTable</target>
        </trans-unit>
        <trans-unit id="8a3bebd87957ebec2bdeed2ec6c3fd343e87182a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../../lookup/staticvocabularytable&quot;&gt;&lt;code&gt;StaticVocabularyTable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../../lookup/staticvocabularytable&quot;&gt; &lt;code&gt;StaticVocabularyTable&lt;/code&gt; &lt;/a&gt; : StaticVocabularyTable</target>
        </trans-unit>
        <trans-unit id="1684aa0ac086b4c33905e11ca938ca00eeb69e59" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/estimator/estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;../../compat/v1/estimator/estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aefa14b86c312089f44417b29a0fefe55dd55580" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/densefeatures&quot;&gt;&lt;code&gt;DenseFeatures&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../compat/v1/keras/layers/densefeatures&quot;&gt; &lt;code&gt;DenseFeatures&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fb19ef7b8a7a993bf890f5f9f8e3aa82a58da54c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/gru&quot;&gt;&lt;code&gt;GRU&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;../../compat/v1/keras/layers/gru&quot;&gt; &lt;code&gt;GRU&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25bbb6425736acc7eba310b4733d000e527fdb41" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/grucell&quot;&gt;&lt;code&gt;GRUCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;../../compat/v1/keras/layers/grucell&quot;&gt; &lt;code&gt;GRUCell&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6399774002d5547cc32cc9d4b9edee523ac71de" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/lstm&quot;&gt;&lt;code&gt;LSTM&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">: 상속 &lt;a href=&quot;../../compat/v1/keras/layers/lstm&quot;&gt; &lt;code&gt;LSTM&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6e365aef9a953772960e2a2d0594d4484de5f37" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../compat/v1/keras/layers/lstmcell&quot;&gt;&lt;code&gt;LSTMCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;../../compat/v1/keras/layers/lstmcell&quot;&gt; &lt;code&gt;LSTMCell&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="61def0c79e4e14034ebc42dd5e16bbb937237db8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../devicespec&quot;&gt;&lt;code&gt;DeviceSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../devicespec&quot;&gt; &lt;code&gt;DeviceSpec&lt;/code&gt; &lt;/a&gt; : DeviceSpec</target>
        </trans-unit>
        <trans-unit id="e22d1fd60d17bfd6bb8dea29e2d168c3d11cab79" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../estimator/sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../estimator/sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt; : SessionRunHook</target>
        </trans-unit>
        <trans-unit id="c823efc68822885dff47a787a20718225f30976c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0253e6a8463328df70cf0bde386ae58d5d4a52b3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d380ebfc4ac0e11225bf40c85216fcb9ab9ca5be" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ac000ff3e9397e03d5c9b3dd15afcd623075932" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../ones_initializer&quot;&gt;&lt;code&gt;ones_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../ones_initializer&quot;&gt; &lt;code&gt;ones_initializer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="431bc7dc03654938db639520210941a6890ffea2" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../optimizers/optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../optimizers/optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2e1cf9747c58dbedac3aa16db0a27265a12d8699" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_normal_initializer&quot;&gt;&lt;code&gt;random_normal_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../random_normal_initializer&quot;&gt; &lt;code&gt;random_normal_initializer&lt;/code&gt; &lt;/a&gt; : random_normal_initializer</target>
        </trans-unit>
        <trans-unit id="c23d9d73d8c84d12ce7849fdfb684631d2c7f4d1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_normal_initializer&quot;&gt;&lt;code&gt;random_normal_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../random_normal_initializer&quot;&gt; &lt;code&gt;random_normal_initializer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7949d09e2384198677c50c86af2bf0ed68fd209" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_uniform_initializer&quot;&gt;&lt;code&gt;random_uniform_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../../random_uniform_initializer&quot;&gt; &lt;code&gt;random_uniform_initializer&lt;/code&gt; &lt;/a&gt; : random_uniform_initializer</target>
        </trans-unit>
        <trans-unit id="0b8b6d3e6850689ca8d44a060f6f5dacbcbb2309" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../random_uniform_initializer&quot;&gt;&lt;code&gt;random_uniform_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../random_uniform_initializer&quot;&gt; &lt;code&gt;random_uniform_initializer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="30e65a22887b2ddde41692586ecc0c1e8dec9c5b" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../truncated_normal_initializer&quot;&gt;&lt;code&gt;truncated_normal_initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;../../truncated_normal_initializer&quot;&gt; &lt;code&gt;truncated_normal_initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1829a659c829a9f36645de8ac301505b51be50d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../utils/sequence&quot;&gt;&lt;code&gt;Sequence&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../utils/sequence&quot;&gt; &lt;code&gt;Sequence&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f0e5a6aee3812cf9bfb851074c2d13a47b335f5d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;Variable&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;Variable&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b72a646568595cd082eabef4131c846b923b5942" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../../zeros_initializer&quot;&gt;&lt;code&gt;zeros_initializer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../../zeros_initializer&quot;&gt; &lt;code&gt;zeros_initializer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b555e28ab5ffb41e3c4dc14c70bf133942c54b2c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../callback&quot;&gt; &lt;code&gt;Callback&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f9bc9d9bcf253cedabcee6c97ec168ce829644a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../compat/v1/estimator/estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;../compat/v1/estimator/estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="25426e2a5713897c0289518989a9cd3a8db983ff" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;../estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="080d3ec42c2add7514a21ad699a8fc4784f62dcf" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../keras/layers/batchnormalization&quot;&gt;&lt;code&gt;BatchNormalization&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../keras/layers/batchnormalization&quot;&gt; &lt;code&gt;BatchNormalization&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7fd82eb6ae25585268bdb2e754aa9b0cea42c0fc" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="90ccbe17f941cfb541dacdc6e6f8df9e364e9903" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3343ff80aad6eccce0b0ff9a92e6f1138ded04de" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../model&quot;&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 &lt;a href=&quot;../model&quot;&gt; &lt;code&gt;Model&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9bc653a3de4a5b711fa178780efa227044183c6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../module&quot;&gt;&lt;code&gt;Module&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../module&quot;&gt; &lt;code&gt;Module&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bae83d89b65139dbc57c20256c7416930811a62f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4dfd48c0fad88d69677a52e92941c20045e7f8d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../optimizers/schedules/learningrateschedule&quot;&gt;&lt;code&gt;LearningRateSchedule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;../optimizers/schedules/learningrateschedule&quot;&gt; &lt;code&gt;LearningRateSchedule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bac031a4f0d93559c0b5a038481a55db80bffb1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;../sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt; : SessionRunHook</target>
        </trans-unit>
        <trans-unit id="d1e8fe6f775917267679cd58b67ba07d4031d153" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e7d0440491afa6fb0a72459e5330c1c6c5f3a9fd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../train/optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;../train/optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09f24deac9eb963d66c92025a28b74323dca2a37" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;../typespec&quot;&gt;&lt;code&gt;TypeSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;../typespec&quot;&gt; &lt;code&gt;TypeSpec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ac0a165f2cf448ecb4b394e261add8aee2b6e02" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;argumentparser&quot;&gt;&lt;code&gt;ArgumentParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;argumentparser&quot;&gt; &lt;code&gt;ArgumentParser&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b53c52c65f50149ff85e0e72be5e18e5ebd0627" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;argumentserializer&quot;&gt;&lt;code&gt;ArgumentSerializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;argumentserializer&quot;&gt; &lt;code&gt;ArgumentSerializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80e09409191cf57a51dbc558605c61bf1e959f0f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;baselistparser&quot;&gt;&lt;code&gt;BaseListParser&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;baselistparser&quot;&gt; &lt;code&gt;BaseListParser&lt;/code&gt; &lt;/a&gt; : BaseListParser</target>
        </trans-unit>
        <trans-unit id="cc4c26c0cc8fd71ef96bcb06650fc6ea34b1a676" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;callback&quot;&gt;&lt;code&gt;Callback&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;callback&quot;&gt; &lt;code&gt;Callback&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a3e2923879231076529ff16964e3254f28644a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;clusterresolver&quot;&gt;&lt;code&gt;ClusterResolver&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;clusterresolver&quot;&gt; &lt;code&gt;ClusterResolver&lt;/code&gt; &lt;/a&gt; : ClusterResolver</target>
        </trans-unit>
        <trans-unit id="f56dfe51ff751c5c35642aef72a91e03dc8eb325" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conditionalaccumulatorbase&quot;&gt;&lt;code&gt;ConditionalAccumulatorBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;conditionalaccumulatorbase&quot;&gt; &lt;code&gt;ConditionalAccumulatorBase&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4451c0007ffb8c85d8049d366dd976e53638d7d6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;constraint&quot;&gt;&lt;code&gt;Constraint&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;constraint&quot;&gt; &lt;code&gt;Constraint&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0e4caf5e5194b7ac96cde7a55cf4136f8f46fdba" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv1d&quot;&gt;&lt;code&gt;Conv1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;conv1d&quot;&gt; &lt;code&gt;Conv1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9cf3bf045963ef0e24f8894a2e9152ee83749492" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;Conv2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;Conv2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="283b19ef5cabdd9464503df3847e05e6683b4c31" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;conv3d&quot;&gt;&lt;code&gt;Conv3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;conv3d&quot;&gt; &lt;code&gt;Conv3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f2e2d2138c18dd431317480b04654c2a90d72819" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;crossdeviceops&quot;&gt;&lt;code&gt;CrossDeviceOps&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;crossdeviceops&quot;&gt; &lt;code&gt;CrossDeviceOps&lt;/code&gt; &lt;/a&gt; : CrossDeviceOps</target>
        </trans-unit>
        <trans-unit id="22140b78b2e4625ecb8d6cb9f4e06748658330fb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;dataset&quot;&gt;&lt;code&gt;Dataset&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;dataset&quot;&gt; &lt;code&gt;Dataset&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa02fcf49761dd366a56034083175af69d0964fc" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;distribution&quot;&gt;&lt;code&gt;Distribution&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;distribution&quot;&gt; &lt;code&gt;Distribution&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b51b20c1f658b10e05c97ac0210ccc81f121087" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;dropout&quot;&gt;&lt;code&gt;Dropout&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;dropout&quot;&gt; &lt;code&gt;Dropout&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e878e37e306fee3dbc483d11717bf9341c22b53e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;error&quot;&gt;&lt;code&gt;Error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;error&quot;&gt; &lt;code&gt;Error&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5dfc58dfa8f92ceeec773d4079a01572ca2cd806" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;estimator&quot;&gt;&lt;code&gt;Estimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;estimator&quot;&gt; &lt;code&gt;Estimator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7a2ae2c02899c2e4f78d776e809915721c13881a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;exporter&quot;&gt; &lt;code&gt;Exporter&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58dcf205446e67668da4cee5c19d32d67d820dc8" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;exportoutput&quot;&gt;&lt;code&gt;ExportOutput&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;exportoutput&quot;&gt; &lt;code&gt;ExportOutput&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84e5436e8e1add9f0b776920cdc41d900f226bb9" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;flag&quot;&gt;&lt;code&gt;Flag&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;flag&quot;&gt; &lt;code&gt;Flag&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0db0c480f0cb5392640cfdd5f72b4e7ae28a556" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;gamma&quot;&gt;&lt;code&gt;Gamma&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;gamma&quot;&gt; &lt;code&gt;Gamma&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ef4a4c2192c1e1137ac1cdc387d568a072f314d" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;head&quot;&gt;&lt;code&gt;Head&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;head&quot;&gt; &lt;code&gt;Head&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7e6a2ad1e98cf96c2f87570045e8cc2185aec4bd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a30dfeb3ba7f1f880dbdb0a428cbd9056f33e550" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;iterator&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;iterator&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea34304998eb45063cccb9f7518ed59ed029b3fb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;keras/initializers/initializer&quot;&gt;&lt;code&gt;Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속자 : &lt;a href=&quot;keras/initializers/initializer&quot;&gt; &lt;code&gt;Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="208224ad9829e548920e4711cb9800c0bbf02a79" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1074de264eed43a2c35c1e9e34add7d6f6407038" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;layers/layer&quot;&gt;&lt;code&gt;Layer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 : &lt;a href=&quot;layers/layer&quot;&gt; &lt;code&gt;Layer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f23330460480edbb4fc738157f7a5471232f7c83" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;learningrateschedule&quot;&gt;&lt;code&gt;LearningRateSchedule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;learningrateschedule&quot;&gt; &lt;code&gt;LearningRateSchedule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a1c3867710811bb11042f959bfcb4d5f8b519a0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;linearoperator&quot;&gt;&lt;code&gt;LinearOperator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;linearoperator&quot;&gt; &lt;code&gt;LinearOperator&lt;/code&gt; &lt;/a&gt; : LinearOperator</target>
        </trans-unit>
        <trans-unit id="f62175fd1a3fcbb5f5a876a78c6edd7356485def" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;lossscale&quot;&gt;&lt;code&gt;LossScale&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;lossscale&quot;&gt; &lt;code&gt;LossScale&lt;/code&gt; &lt;/a&gt; : LossScale</target>
        </trans-unit>
        <trans-unit id="bb33eb889582345ba3f1d78863f8d00b235c5ee1" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;mean&quot;&gt;&lt;code&gt;Mean&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;mean&quot;&gt; &lt;code&gt;Mean&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23b8f0e2c60442efd1f3f24a1b9098b8e3720a04" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;metric&quot;&gt;&lt;code&gt;Metric&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;metric&quot;&gt; &lt;code&gt;Metric&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3491dcb6475f6cdcd9bfbfb9a50f3b524fc4f8b0" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;model&quot;&gt;&lt;code&gt;Model&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 &lt;a href=&quot;model&quot;&gt; &lt;code&gt;Model&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d14b97aeea22bcdb096843d7cfb8024f32a8d496" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;multiflag&quot;&gt;&lt;code&gt;MultiFlag&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;multiflag&quot;&gt; &lt;code&gt;MultiFlag&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80158f4961cf1668db5fd8c4f7cefdd6b4f0b29a" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;operror&quot;&gt;&lt;code&gt;OpError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;operror&quot;&gt; &lt;code&gt;OpError&lt;/code&gt; &lt;/a&gt; : OpError</target>
        </trans-unit>
        <trans-unit id="5d0af4ebd255fd6f617c8d538add3730d1f29225" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;optimizer&quot;&gt;&lt;code&gt;Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;optimizer&quot;&gt; &lt;code&gt;Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04c2e54a79367272f125c78e8460cacd30e00ebd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;queuebase&quot;&gt;&lt;code&gt;QueueBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;queuebase&quot;&gt; &lt;code&gt;QueueBase&lt;/code&gt; &lt;/a&gt; : QueueBase</target>
        </trans-unit>
        <trans-unit id="5ccbec78a7b42e602f358942d26c9d05f169ed7c" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;readerbase&quot;&gt;&lt;code&gt;ReaderBase&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;readerbase&quot;&gt; &lt;code&gt;ReaderBase&lt;/code&gt; &lt;/a&gt; : ReaderBase</target>
        </trans-unit>
        <trans-unit id="ad0372cd2d15c62f344d2a9750b22878629b0740" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;regressionhead&quot;&gt;&lt;code&gt;RegressionHead&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;regressionhead&quot;&gt; &lt;code&gt;RegressionHead&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3e3d5b150747f41525b95698f7bbd95312e28809" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;regularizer&quot;&gt;&lt;code&gt;Regularizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;regularizer&quot;&gt; &lt;code&gt;Regularizer&lt;/code&gt; &lt;/a&gt; : 정규화 기</target>
        </trans-unit>
        <trans-unit id="41240b7c3505b27c7d0d17bd731d675d120e69a7" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnn&quot;&gt;&lt;code&gt;RNN&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속받은 사람 : &lt;a href=&quot;rnn&quot;&gt; &lt;code&gt;RNN&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d4bc99967778b197915dfb1e03b3aac7430e2d06" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnncell&quot;&gt;&lt;code&gt;RNNCell&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rnncell&quot;&gt; &lt;code&gt;RNNCell&lt;/code&gt; &lt;/a&gt; : RNNCell</target>
        </trans-unit>
        <trans-unit id="92968f787ed32c0b2652202feacd0e1bb742a548" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;rnnestimator&quot;&gt;&lt;code&gt;RNNEstimator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;rnnestimator&quot;&gt; &lt;code&gt;RNNEstimator&lt;/code&gt; &lt;/a&gt; 에서 상속</target>
        </trans-unit>
        <trans-unit id="35b9f8a26efc7813a5fc71ac2e35eb36ea0752ed" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sequenceenqueuer&quot;&gt;&lt;code&gt;SequenceEnqueuer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 속됨 : &lt;a href=&quot;sequenceenqueuer&quot;&gt; &lt;code&gt;SequenceEnqueuer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9097ee84e0043bad50f3732959fe4f03cde569e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sessioncreator&quot;&gt;&lt;code&gt;SessionCreator&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;sessioncreator&quot;&gt; &lt;code&gt;SessionCreator&lt;/code&gt; &lt;/a&gt; : SessionCreator</target>
        </trans-unit>
        <trans-unit id="f16acebe1259f779d2c3a0f7a4d97de5b66ad39f" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;sessionrunhook&quot;&gt;&lt;code&gt;SessionRunHook&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;sessionrunhook&quot;&gt; &lt;code&gt;SessionRunHook&lt;/code&gt; &lt;/a&gt; : SessionRunHook</target>
        </trans-unit>
        <trans-unit id="78de757e66b0204e828d8e24b165b9614dcddef6" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;stacktracefilter&quot;&gt;&lt;code&gt;StackTraceFilter&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;stacktracefilter&quot;&gt; &lt;code&gt;StackTraceFilter&lt;/code&gt; &lt;/a&gt; : StackTraceFilter</target>
        </trans-unit>
        <trans-unit id="1314e1f7b68e8d2e740d84aa7ff167503f726bd3" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;stacktracetransform&quot;&gt;&lt;code&gt;StackTraceTransform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상 &lt;a href=&quot;stacktracetransform&quot;&gt; &lt;code&gt;StackTraceTransform&lt;/code&gt; &lt;/a&gt; : StackTraceTransform</target>
        </trans-unit>
        <trans-unit id="74e8664d5defb70dad460e27e606424d03ad7f8e" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;Strategy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">상속 대상 : &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;Strategy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5b5461c11487a577320988d6c7910a14af6eabb" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;typespec&quot;&gt;&lt;code&gt;TypeSpec&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;typespec&quot;&gt; &lt;code&gt;TypeSpec&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7923ecf7967dad1a15ad737b679bd8050b2a8bd" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;variancescaling&quot;&gt;&lt;code&gt;VarianceScaling&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다음에서 상속 : &lt;a href=&quot;variancescaling&quot;&gt; &lt;code&gt;VarianceScaling&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53c43532e5cbca0b52801f19115633789d7d2a84" translate="yes" xml:space="preserve">
          <source>Inherits From: &lt;a href=&quot;wrapper&quot;&gt;&lt;code&gt;Wrapper&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;wrapper&quot;&gt; &lt;code&gt;Wrapper&lt;/code&gt; &lt;/a&gt; : 포장지</target>
        </trans-unit>
        <trans-unit id="a3dde0fdb1c7620a5dbdcc30fcd0ab45a5b2ebfb" translate="yes" xml:space="preserve">
          <source>Initial seed for workers, will be incremented by one for each worker.</source>
          <target state="translated">작업자의 초기 시드는 각 작업자에 대해 하나씩 증가합니다.</target>
        </trans-unit>
        <trans-unit id="896a5ab9538c1a67c1f3e659ad90640e62f8b8da" translate="yes" xml:space="preserve">
          <source>Initialization:</source>
          <target state="translated">Initialization:</target>
        </trans-unit>
        <trans-unit id="6b4c4e02ed448c5a81def9a1e3687e52b103b145" translate="yes" xml:space="preserve">
          <source>Initialization: At creation time the hooked session does following things in given order:</source>
          <target state="translated">초기화 : 생성시 후크 된 세션은 주어진 순서대로 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="08031e322fd9617e1573ed5dbfa09ff216adcc09" translate="yes" xml:space="preserve">
          <source>Initialization: At creation time the monitored session does following things in given order:</source>
          <target state="translated">초기화 : 생성시 모니터링 된 세션은 다음 순서대로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b0355561fecfea92594a45fdcb6ca88daca19bec" translate="yes" xml:space="preserve">
          <source>Initialize Categorical distributions using class log-probabilities. (deprecated)</source>
          <target state="translated">클래스 로그 확률을 사용하여 범주 형 분포를 초기화합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="eb53dcaa811ac7688015872c0307120a73670815" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorAdjoint&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorAdjoint&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="750f138f781c88fbb0701d39c348820ff999fad8" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorBlockDiag&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="f39eb5cba37cc32a15ef159441cb53292159952a" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorComposition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorComposition&lt;/code&gt; 을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b05907b33c8a9de0c0979de3f32b251ac1c8aad" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorDiag&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorDiag&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="693135b5de80f140c35b24fa0e2aef0094c05d68" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorFullMatrix&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="bbd6633639933b006a538ab0aef4fdf5a8441992" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorHouseholder&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorHouseholder&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="0fc6c13d8271533b4e0c6a52055f390134df1f4e" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorIdentity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorIdentity&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="e00c7d507871b6245d20ab7f29a8de43b054e478" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorInversion&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorInversion&lt;/code&gt; 을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="5d4e66ea801fb0915db2ab44c3588f99c13535da" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorKronecker&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorKronecker&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="eeb390cc0f4fac75926a62916c88ab4b661c42c4" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorLowRankUpdate&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9d706bfa28f87040a2e0b40cdf0afbf7e16b64a" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorLowerTriangular&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="7588d86ee76ca246898555ddb33325423ac0aa2d" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorPermutation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorPermutation&lt;/code&gt; 을 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad616170739db723a76b2a6610fee8afdb496005" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorScaledIdentity&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="cf523f71058bd9f6bac48a09bd89a7d0645d188b" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorToeplitz&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorToeplitz&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac13eedefc7b6b32a2cd134693fd9e0177e8fcf6" translate="yes" xml:space="preserve">
          <source>Initialize a &lt;code&gt;LinearOperatorZeros&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorZeros&lt;/code&gt; 를 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="738190cdc5cd301e6242cb86b444286367b38ff6" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Beta distributions. (deprecated)</source>
          <target state="translated">베타 배포 일괄 처리를 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="dc7ea2e4332b90aa477204eac854c35a52c9e897" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Dirichlet distributions. (deprecated)</source>
          <target state="translated">Dirichlet 배포 배치를 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="fc8d3695b732b4c84d7528c8d6686ac5b6c4efba" translate="yes" xml:space="preserve">
          <source>Initialize a batch of DirichletMultinomial distributions. (deprecated)</source>
          <target state="translated">DirichletMultinomial 배포 배치를 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="e92be9f5b309bd342947a735a43d5120077fec20" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Multinomial distributions. (deprecated)</source>
          <target state="translated">다항 분포의 배치를 초기화합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="a08179d319a047367bc8f5fa7409bac517eae691" translate="yes" xml:space="preserve">
          <source>Initialize a batch of Uniform distributions. (deprecated)</source>
          <target state="translated">균일 분포의 배치를 초기화합니다. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="7176bd72795dadb8c783acaefcff5df66a240124" translate="yes" xml:space="preserve">
          <source>Initialize an &lt;code&gt;LinearOperatorCirculant2D&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorCirculant2D&lt;/code&gt; 를 초기화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9b868fe74c4ce2558ee85147bd4de2aef5e9e70" translate="yes" xml:space="preserve">
          <source>Initialize an &lt;code&gt;LinearOperatorCirculant&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LinearOperatorCirculant&lt;/code&gt; 를 초기화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9f8049ed73769cea9db916044a5c096b1780e5ad" translate="yes" xml:space="preserve">
          <source>Initialize ophint argument.</source>
          <target state="translated">ophint 인수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="5f66672d1a211feccb2663e524389cc7bbdc9544" translate="yes" xml:space="preserve">
          <source>Initialize self. See help(type(self)) for accurate signature.</source>
          <target state="translated">자기를 초기화하십시오. 정확한 서명은 help (type (self))를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="774126eedb486505371aeb53fcb908707fda92f1" translate="yes" xml:space="preserve">
          <source>Initialize the &lt;code&gt;LinearOperator&lt;/code&gt;. (deprecated arguments)</source>
          <target state="translated">&lt;code&gt;LinearOperator&lt;/code&gt; 를 초기화하십시오 . (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="ab2e1f2d631fceec84acd055ae017bb35b138793" translate="yes" xml:space="preserve">
          <source>Initialize the KL registrar. (deprecated)</source>
          <target state="translated">KL 등록 기관을 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="a6ebdd831ac3202b3781c72a34d4adf2eae8f045" translate="yes" xml:space="preserve">
          <source>Initialize the TPU devices.</source>
          <target state="translated">TPU 장치를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="92e2d30e35ba9382e113f9b082b909176f6d30a2" translate="yes" xml:space="preserve">
          <source>Initialize the basic LSTM cell. (deprecated)</source>
          <target state="translated">기본 LSTM 셀을 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="b590a960cba96e3ec2bd76607c374e10df648ac8" translate="yes" xml:space="preserve">
          <source>Initialize the context manager.</source>
          <target state="translated">컨텍스트 관리자를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="fa67a798e83e54f567e4c72f649b904fcbc46e99" translate="yes" xml:space="preserve">
          <source>Initialize the converter.</source>
          <target state="translated">변환기를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="bc16e43bd3119b5ee14cd85b3e95a73c462f9e60" translate="yes" xml:space="preserve">
          <source>Initialize the parameters for an LSTM cell.</source>
          <target state="translated">LSTM 셀의 매개 변수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="a276f0d2cb8c74827ade5547808ad2460ab61df8" translate="yes" xml:space="preserve">
          <source>Initialize the parameters for an LSTM cell. (deprecated)</source>
          <target state="translated">LSTM 셀의 매개 변수를 초기화하십시오. (더 이상 사용되지 않음)</target>
        </trans-unit>
        <trans-unit id="f8de61c60cae88e66471bf5bc57e9c4fbd41701f" translate="yes" xml:space="preserve">
          <source>InitializeTable</source>
          <target state="translated">InitializeTable</target>
        </trans-unit>
        <trans-unit id="5aed30f7b6fc98dc524f5833e005c4e4ec7a42cb" translate="yes" xml:space="preserve">
          <source>InitializeTableFromDataset</source>
          <target state="translated">InitializeTableFromDataset</target>
        </trans-unit>
        <trans-unit id="7c3bd8734fc960e9600fa97e6141676591a46831" translate="yes" xml:space="preserve">
          <source>InitializeTableFromTextFile</source>
          <target state="translated">InitializeTableFromTextFile</target>
        </trans-unit>
        <trans-unit id="c2a3468a32393944b646bf84f4d3a50fe75c3793" translate="yes" xml:space="preserve">
          <source>InitializeTableFromTextFileV2</source>
          <target state="translated">InitializeTableFromTextFileV2</target>
        </trans-unit>
        <trans-unit id="d595985e2c5ded73f4a9de35a2d130afb6f8c587" translate="yes" xml:space="preserve">
          <source>InitializeTableV2</source>
          <target state="translated">InitializeTableV2</target>
        </trans-unit>
        <trans-unit id="444bc80fd9904870633d2e8861ecfda9efc99b9c" translate="yes" xml:space="preserve">
          <source>Initializer base class: all Keras initializers inherit from this class.</source>
          <target state="translated">이니셜 라이저 기본 클래스 : 모든 Keras 이니셜 라이저는이 클래스에서 상속합니다.</target>
        </trans-unit>
        <trans-unit id="7f0a3f70258a349042e3af55ded6d87eee852d82" translate="yes" xml:space="preserve">
          <source>Initializer base class: all initializers inherit from this class.</source>
          <target state="translated">이니셜 라이저 기본 클래스 : 모든 이니셜 라이저는이 클래스에서 상속됩니다.</target>
        </trans-unit>
        <trans-unit id="7408f1164bc8abcd3cd06ec2d69e780bd33dcfc9" translate="yes" xml:space="preserve">
          <source>Initializer capable of adapting its scale to the shape of weights tensors.</source>
          <target state="translated">무게 텐서의 모양에 맞게 스케일을 조정할 수있는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="3f3e650f5d31cec8ee9c79d6f7e362575199454d" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;embeddings&lt;/code&gt; matrix (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">위한 이니셜 &lt;code&gt;embeddings&lt;/code&gt; 매트릭스 (참조 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cd4d0f3ab47bea318b1c37c93519d1a1da732eeb" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrices.</source>
          <target state="translated">&lt;code&gt;kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 .</target>
        </trans-unit>
        <trans-unit id="7ba628f9ea30369bd578dc8d48cd1e3d28bf5c41" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">에 대한 초기화 &lt;code&gt;kernel&lt;/code&gt; 가중치 매트릭스 (참조 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5ba55c172dc5eab60693e689ec7fb38d97b36486" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">에 대한 초기화 &lt;code&gt;kernel&lt;/code&gt; 가중치 매트릭스 (참조 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e6e262bd0196c6fec5362e38ce4fd7bd8f850ecb" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs.</source>
          <target state="translated">입력 값의 선형 변환에 사용되는 &lt;code&gt;kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 .</target>
        </trans-unit>
        <trans-unit id="781ea722b1bd54fe46786e4b204fb94df6ff4f4f" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs. Default: &lt;code&gt;glorot_uniform&lt;/code&gt;.</source>
          <target state="translated">입력 값의 선형 변환에 사용되는 &lt;code&gt;kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 . 기본값 : &lt;code&gt;glorot_uniform&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c20a701e64041d46893780c75432a86bf96c2ef" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix, used for the linear transformation of the inputs..</source>
          <target state="translated">입력 값의 선형 변환에 사용되는 &lt;code&gt;kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 .</target>
        </trans-unit>
        <trans-unit id="9c985b4c4c3a2d5a5db286eb608a6aaa41c24744" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;kernel&lt;/code&gt; weights matrix.</source>
          <target state="translated">&lt;code&gt;kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 .</target>
        </trans-unit>
        <trans-unit id="4e4305dd5a4f4497e59c08e01b2b9016f38ddc44" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state.</source>
          <target state="translated">반복 상태의 선형 변환에 사용되는 &lt;code&gt;recurrent_kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 .</target>
        </trans-unit>
        <trans-unit id="f4be5e35088634a9fc1d3d2f991d38a5e1787388" translate="yes" xml:space="preserve">
          <source>Initializer for the &lt;code&gt;recurrent_kernel&lt;/code&gt; weights matrix, used for the linear transformation of the recurrent state. Default: &lt;code&gt;orthogonal&lt;/code&gt;.</source>
          <target state="translated">반복 상태의 선형 변환에 사용되는 &lt;code&gt;recurrent_kernel&lt;/code&gt; 가중치 행렬의 이니셜 라이저입니다 . 기본값 : &lt;code&gt;orthogonal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9af38116f02da6c39b58cc8da4c28be61a81d876" translate="yes" xml:space="preserve">
          <source>Initializer for the beta weight.</source>
          <target state="translated">베타 가중치에 대한 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="d3d51bc1b3c7639715a0b517ddb1db22866613a8" translate="yes" xml:space="preserve">
          <source>Initializer for the beta weight. Defaults to zeros.</source>
          <target state="translated">베타 가중치에 대한 이니셜 라이저입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="70e4f24e2d42625333b9e3d5b356c24fd8e1ddcd" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이어스 벡터에 대한 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; &lt;/a&gt; ( keras.initializers 참조 ).</target>
        </trans-unit>
        <trans-unit id="db262f6cbeba981795f8d7953bf4533bf6250526" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector (see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">바이어스 벡터에 대한 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; &lt;/a&gt; ( keras.initializers 참조 ).</target>
        </trans-unit>
        <trans-unit id="2f2ea2379cb97d28a3c54f26c8c1f8072222138c" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector.</source>
          <target state="translated">바이어스 벡터의 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="2f270770d498ec4fc3655cf0eb9baa466587762d" translate="yes" xml:space="preserve">
          <source>Initializer for the bias vector. Default: &lt;code&gt;zeros&lt;/code&gt;.</source>
          <target state="translated">바이어스 벡터의 이니셜 라이저입니다. 기본값 : &lt;code&gt;zeros&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5201cba3e441bccae15337f6e669e493ac9d21b9" translate="yes" xml:space="preserve">
          <source>Initializer for the depthwise kernel matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">깊이 별 커널 행렬에 대한 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; &lt;/a&gt; ( keras.initializers 참조 ).</target>
        </trans-unit>
        <trans-unit id="9928e7831c90bb494792ace6d7b7f956169e16ae" translate="yes" xml:space="preserve">
          <source>Initializer for the gamma weight.</source>
          <target state="translated">감마 가중치에 대한 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="add6797439df2873a8707c82ca252f6c8be936c5" translate="yes" xml:space="preserve">
          <source>Initializer for the gamma weight. Defaults to ones.</source>
          <target state="translated">감마 가중치에 대한 이니셜 라이저입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="06ecf7540e5a3ff8d2e0717705278320e8321a60" translate="yes" xml:space="preserve">
          <source>Initializer for the moving mean.</source>
          <target state="translated">이동 평균에 대한 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="f890659b046c43e8f9396b0f7812624e17bdaae2" translate="yes" xml:space="preserve">
          <source>Initializer for the moving variance.</source>
          <target state="translated">이동 분산에 대한 이니셜 라이저입니다.</target>
        </trans-unit>
        <trans-unit id="629a0ebdff9c5f3c21412ceaf83712cd99c7c93e" translate="yes" xml:space="preserve">
          <source>Initializer for the pointwise kernel matrix ( see &lt;a href=&quot;../initializers&quot;&gt;&lt;code&gt;keras.initializers&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">포인트 별 커널 행렬에 대한 &lt;a href=&quot;../initializers&quot;&gt; &lt;code&gt;keras.initializers&lt;/code&gt; &lt;/a&gt; ( keras.initializers 참조 ).</target>
        </trans-unit>
        <trans-unit id="de36279d1a9e86d4e1cde4822bb5ee964eb2fb05" translate="yes" xml:space="preserve">
          <source>Initializer for the variable if one is created. Can either be an initializer object or a Tensor. If it's a Tensor, its shape must be known unless validate_shape is False.</source>
          <target state="translated">변수가 생성 된 경우 이니셜 라이저입니다. 이니셜 라이저 객체 또는 Tensor 일 수 있습니다. Tensor 인 경우 validate_shape가 False가 아니면 그 모양을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="a23be94303001d621e4dc7d04c27de3d1b3679cf" translate="yes" xml:space="preserve">
          <source>Initializer function for the bias.</source>
          <target state="translated">편향에 대한 초기화 함수.</target>
        </trans-unit>
        <trans-unit id="86357e48ce6faf014cf422087761d8012cac0b71" translate="yes" xml:space="preserve">
          <source>Initializer function for the weight matrix. If &lt;code&gt;None&lt;/code&gt; (default), weights are initialized using the default initializer used by &lt;a href=&quot;../get_variable&quot;&gt;&lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">가중치 행렬을위한 초기화 함수. 경우 &lt;code&gt;None&lt;/code&gt; (기본값), 무게는 기본값을 사용하여 초기화되지 않습니다에 의해 사용되는 초기화 &lt;a href=&quot;../get_variable&quot;&gt; &lt;code&gt;tf.compat.v1.get_variable&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ea33d8e91f4848f1335260de0a767bf9d2fc824f" translate="yes" xml:space="preserve">
          <source>Initializer function for the weights.</source>
          <target state="translated">가중치에 대한 이니셜 라이저 기능.</target>
        </trans-unit>
        <trans-unit id="394655039e380227cacb4c80f86e6cac564639ab" translate="yes" xml:space="preserve">
          <source>Initializer instance (callable).</source>
          <target state="translated">이니셜 라이저 인스턴스 (호출 가능).</target>
        </trans-unit>
        <trans-unit id="f60811326fed85c17ddc6a9fa74dd3e187f5f2eb" translate="yes" xml:space="preserve">
          <source>Initializer that generates a truncated normal distribution.</source>
          <target state="translated">잘린 정규 분포를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="28a79d9ea883c4f5cd6e250dbcccda1f34cc830e" translate="yes" xml:space="preserve">
          <source>Initializer that generates an orthogonal matrix.</source>
          <target state="translated">직교 행렬을 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="1792d0500f8e70d942738b949ce3b4da4a9ed270" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors initialized to 0.</source>
          <target state="translated">0으로 초기화 된 텐서를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="a36980b211658b282787d0374f188f82dec6bdb5" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors initialized to 1.</source>
          <target state="translated">1로 초기화 된 텐서를 생성하는 이니셜 라이저</target>
        </trans-unit>
        <trans-unit id="15754fbc0acedd6e5262c409c57d5c268cae842f" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with a normal distribution.</source>
          <target state="translated">정규 분포로 텐서를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="2e48457893b98a46c7f6098fecb5c04951df9791" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with a uniform distribution.</source>
          <target state="translated">분포가 균일 한 텐서를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="3bee63cb84d4df7eb9ae6d89ea8269883a3a2f73" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors with constant values.</source>
          <target state="translated">상수 값으로 텐서를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="a63680d71f7ed8d10b2e994835a64ae1af02ec9e" translate="yes" xml:space="preserve">
          <source>Initializer that generates tensors without scaling variance.</source>
          <target state="translated">스케일링 분산없이 텐서를 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="1ad2d9eaadec9573877dacc1cb60e6be8ac9c172" translate="yes" xml:space="preserve">
          <source>Initializer that generates the identity matrix.</source>
          <target state="translated">항등 행렬을 생성하는 이니셜 라이저.</target>
        </trans-unit>
        <trans-unit id="ba3489968dced82d9caa31fe8dbca460cc2e2ca7" translate="yes" xml:space="preserve">
          <source>Initializer.</source>
          <target state="translated">Initializer.</target>
        </trans-unit>
        <trans-unit id="c300579a9fafe19c627626ad79a72342dd2efc6f" translate="yes" xml:space="preserve">
          <source>Initializers allow you to pre-specify an initialization strategy, encoded in the Initializer object, without knowing the shape and dtype of the variable being initialized.</source>
          <target state="translated">이니셜 라이저를 사용하면 초기화되는 변수의 모양과 dtype을 알지 못해도 Initializer 개체에 인코딩 된 초기화 전략을 미리 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d27c91c237b2a008f7246947c44a699389b5681f" translate="yes" xml:space="preserve">
          <source>Initializers should implement a &lt;code&gt;__call__&lt;/code&gt; method with the following signature:</source>
          <target state="translated">이니셜 라이저는 다음 서명을 사용하여 &lt;code&gt;__call__&lt;/code&gt; 메서드를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ae3569d509cdfe1b8eeda1c03736c231164aa1d" translate="yes" xml:space="preserve">
          <source>Initializes &lt;code&gt;FinalOpHook&lt;/code&gt; with ops to run at the end of the session.</source>
          <target state="translated">세션 종료시 실행되도록 op를 사용하여 &lt;code&gt;FinalOpHook&lt;/code&gt; 을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="0af270707bfe64bad53b93831ed2ef62271f7b4f" translate="yes" xml:space="preserve">
          <source>Initializes EnumParser.</source>
          <target state="translated">EnumParser를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0c6c3eb42679c70ce8e567e3a3d01b9974f44165" translate="yes" xml:space="preserve">
          <source>Initializes SessionRunContext.</source>
          <target state="translated">SessionRunContext를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f9d8cdaca3e42fa2ece9b86eebceb7ecac5115af" translate="yes" xml:space="preserve">
          <source>Initializes TPU and returns a TPUClusterResolver.</source>
          <target state="translated">TPU를 초기화하고 TPUClusterResolver를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1e9596221f894466401f26eb2ad3d3bb9bca21a0" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesClassifier&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;BoostedTreesClassifier&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="641a92d161ea17f97b3f75efe25bd49c3aff8e50" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesEstimator&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;BoostedTreesEstimator&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="8291a5b18fc232c8c600a8530a9160b317faf613" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;BoostedTreesRegressor&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;BoostedTreesRegressor&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="bf1dbcb62a62aa47798f17328b9db5bfda87a371" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;CheckpointInputPipelineHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CheckpointInputPipelineHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="575a2d3cd1c6cefb0d8c20d7511f5f2328199dea" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;CheckpointSaverHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;CheckpointSaverHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="a2bf50de7719118633c38d4887574c861cacae90" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNClassifier&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;DNNClassifier&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="9c551665d393a8ff2ebb59249f9845ad31f5e64c" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNEstimator&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;DNNEstimator&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="0cd3fbf5dea3545531f5a1265c354ed7b46e1d19" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;DNNRegressor&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;DNNRegressor&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="0af051ae925bb350c4f5229f3c01f96feb14a59b" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;FeedFnHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;FeedFnHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="cc1915707125a14da164ca446507b73fb2b92efa" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;GlobalStepWaiterHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GlobalStepWaiterHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="cbbe5f2cbae68cf255194ac13f981b98c75307c1" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;InMemoryEvaluatorHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;InMemoryEvaluatorHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="d129af7a0307c26eab90b28ebd51b9618ad292be" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LinearEstimator&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;LinearEstimator&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="44409c31c23e5093785e966d4116f3612c1704af" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LinearRegressor&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;LinearRegressor&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="c02d624ee0a9807bd61d94c49113d6ab4a74c47b" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;LoggingTensorHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;LoggingTensorHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="11306ffe02fcfd7255133712c0c10d8f6b861a21" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;NanTensorHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;NanTensorHook&lt;/code&gt; 을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="546f19884e0d132fdd88d1130640aa01b21aace9" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RNNClassifier&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;RNNClassifier&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="dea803d756c15f8ac4cf7e7ccc1c8153c06bdd9a" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;RNNEstimator&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;RNNEstimator&lt;/code&gt; 인스턴스를 초기화 합니다.</target>
        </trans-unit>
        <trans-unit id="6e2ad4948c5069b73b42132f07ca898494bfe604" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;StopAtStepHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;StopAtStepHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="ecebafebcc1ed7893c42ca6adbe3a6e7c3f3d309" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;SummarySaverHook&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;SummarySaverHook&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="cbd3617c2d5051723d22bb771dbeeefc7cb141af" translate="yes" xml:space="preserve">
          <source>Initializes a &lt;code&gt;TFRecordWriter&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TFRecordWriter&lt;/code&gt; 를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="4b9e921bd19e339c3c62dd30db062a771c9111c7" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineClassifier instance.</source>
          <target state="translated">BaselineClassifier 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f2ca17291afb7e8cb98eae1421a6d34024556fe2" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineEstimator instance.</source>
          <target state="translated">BaselineEstimator 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="6df9376ec784999b4324a701a11055ec4641b248" translate="yes" xml:space="preserve">
          <source>Initializes a BaselineRegressor instance.</source>
          <target state="translated">BaselineRegressor 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a0774ef910763d2c62bd641db60c78cc26f5f0c0" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedClassifier instance.</source>
          <target state="translated">DNNLinearCombinedClassifier 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="783d0c854480043cc2c0181e9e30a857fc22e30e" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedEstimator instance.</source>
          <target state="translated">DNNLinearCombinedEstimator 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="739deeaaeb79fadd6c52fea70a1826f73947e113" translate="yes" xml:space="preserve">
          <source>Initializes a DNNLinearCombinedRegressor instance.</source>
          <target state="translated">DNNLinearCombinedRegressor 인스턴스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="0c40d6ce99ac68c2b27ea09e79d9aa0795cdf29d" translate="yes" xml:space="preserve">
          <source>Initializes a UnionClusterResolver with other ClusterResolvers.</source>
          <target state="translated">다른 ClusterResolvers로 UnionClusterResolver를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="33532b330cba4da4287395c3bcee952368758bde" translate="yes" xml:space="preserve">
          <source>Initializes a chief session creator.</source>
          <target state="translated">최고 세션 작성자를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f0fbe2018ecf0aac090ce758a3b9ad7c64b0d419" translate="yes" xml:space="preserve">
          <source>Initializes a distributed TPU system for use with TensorFlow.</source>
          <target state="translated">TensorFlow와 함께 사용할 분산 TPU 시스템을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f9ecfd4934d70f84d7899a79d879721a3e413c28" translate="yes" xml:space="preserve">
          <source>Initializes a hook that takes periodic profiling snapshots.</source>
          <target state="translated">주기적 프로파일 링 스냅 샷을 생성하는 후크를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="997de8101a00d090e563fabad75f25c03ff57046" translate="yes" xml:space="preserve">
          <source>Initializes a new KubernetesClusterResolver.</source>
          <target state="translated">새로운 KubernetesClusterResolver를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="639ee79e578c9c1534d9a97348960057ce542dee" translate="yes" xml:space="preserve">
          <source>Initializes a table from a text file.</source>
          <target state="translated">텍스트 파일에서 테이블을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a000286aa35868ad7a4442c66081e50874ea4509" translate="yes" xml:space="preserve">
          <source>Initializes a worker session creator.</source>
          <target state="translated">작업자 세션 작성자를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="52e2a9b43cb09a5b97b21e2638d508223e7d9295" translate="yes" xml:space="preserve">
          <source>Initializes an InputContext object.</source>
          <target state="translated">InputContext 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="9f766a8a68267cac7d59732c88bb6823db3efc5f" translate="yes" xml:space="preserve">
          <source>Initializes summary writing for graph execution mode.</source>
          <target state="translated">그래프 실행 모드에 대한 요약 쓰기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a923a4b25ad6812b374a90843b54d284a15dffcb" translate="yes" xml:space="preserve">
          <source>Initializes the &lt;code&gt;step_context&lt;/code&gt; argument for a &lt;code&gt;step_fn&lt;/code&gt; invocation.</source>
          <target state="translated">&lt;code&gt;step_fn&lt;/code&gt; 호출에 대한 &lt;code&gt;step_context&lt;/code&gt; 인수를 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="064630dcdc1b915396129f044f0af7f3ed3178c1" translate="yes" xml:space="preserve">
          <source>Initializes the TPUStrategy object.</source>
          <target state="translated">TPUStrategy 객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="a095094fc43a8f61df14737cdbd7e74e010345c8" translate="yes" xml:space="preserve">
          <source>Initializes the given &lt;code&gt;table&lt;/code&gt; with &lt;code&gt;keys&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; tensors.</source>
          <target state="translated">&lt;code&gt;keys&lt;/code&gt; 와 &lt;code&gt;values&lt;/code&gt; 텐서로 주어진 &lt;code&gt;table&lt;/code&gt; 을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="5015344a3098f58ff7e43767db7a65fd51001358" translate="yes" xml:space="preserve">
          <source>Initializes the loss scale class.</source>
          <target state="translated">손실 척도 클래스를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="25a3e19a4075de6c96af04a4d7d33034705f5421" translate="yes" xml:space="preserve">
          <source>Initializes the multi device iterator with the given dataset.</source>
          <target state="translated">지정된 데이터 세트로 다중 장치 반복기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="2a2ebcb62e07bfa23fe63ff902381554659598f7" translate="yes" xml:space="preserve">
          <source>Initializes the object.</source>
          <target state="translated">객체를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="96c249c719463e9cbe91e8dfab76ecf97217371c" translate="yes" xml:space="preserve">
          <source>Initializes the parameters for an RNN cell.</source>
          <target state="translated">RNN 셀의 매개 변수를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="926bdaa7bd8079fe9e99087d53c0e1e6f3926945" translate="yes" xml:space="preserve">
          <source>Initializes the summary writer.</source>
          <target state="translated">요약 작성기를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="8ce5d08116a5422425173483db4afb40e381960e" translate="yes" xml:space="preserve">
          <source>Initializes the table from a text file.</source>
          <target state="translated">텍스트 파일에서 테이블을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="166aee7623091cf78477483a2b69d759bad97f4c" translate="yes" xml:space="preserve">
          <source>Initializes this loss scale optimizer.</source>
          <target state="translated">이 손실 스케일 최적화 프로그램을 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="420eb1414b9510458affd7d7f221b2d916a76daf" translate="yes" xml:space="preserve">
          <source>Initializes this strategy with an optional &lt;code&gt;cluster_resolver&lt;/code&gt;.</source>
          <target state="translated">선택적 &lt;code&gt;cluster_resolver&lt;/code&gt; 로이 전략을 초기화합니다 .</target>
        </trans-unit>
        <trans-unit id="0d2c52d1b5ccc55d62f5f28f184bbca571994a96" translate="yes" xml:space="preserve">
          <source>Initializes with a device to reduce to and a way to accumulate.</source>
          <target state="translated">축소하고 축적하는 방법으로 장치를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="b0239e06bf33c2a0502643ba3bac0a932d185f3a" translate="yes" xml:space="preserve">
          <source>Initializing variables on startup, restoring them from the most recent checkpoint after a crash, or wait for checkpoints to become available.</source>
          <target state="translated">시작시 변수 초기화, 충돌 후 가장 최근의 검사 점에서 변수를 복원하거나 검사 점이 사용 가능할 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="6cfc0b3ada9a1caff4180ec7edad85d08676e0cf" translate="yes" xml:space="preserve">
          <source>Injects a new target into a function built by make_decorator.</source>
          <target state="translated">make_decorator가 빌드 한 함수에 새로운 대상을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="678429d49a474ad8ec94a587c28e389acd6369f3" translate="yes" xml:space="preserve">
          <source>InplaceAdd</source>
          <target state="translated">InplaceAdd</target>
        </trans-unit>
        <trans-unit id="ec6af4517abefc843097599d82d36ce1eb1a270d" translate="yes" xml:space="preserve">
          <source>InplaceSub</source>
          <target state="translated">InplaceSub</target>
        </trans-unit>
        <trans-unit id="f0e0363a75f31977f3e73ce8f596bfbdfd61bf73" translate="yes" xml:space="preserve">
          <source>InplaceUpdate</source>
          <target state="translated">InplaceUpdate</target>
        </trans-unit>
        <trans-unit id="c43b6bd566f5c25fdb732766cd21b9ae75943d6a" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Tensor&lt;/code&gt; of 4 dimensions.</source>
          <target state="translated">4 차원의 &lt;code&gt;Tensor&lt;/code&gt; 를 입력 합니다.</target>
        </trans-unit>
        <trans-unit id="555cccc16566c1858242a991bb2d577980094119" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;Tensor&lt;/code&gt; of arbitrary dimensionality.</source>
          <target state="translated">임의 차원의 &lt;code&gt;Tensor&lt;/code&gt; 를 입력 합니다.</target>
        </trans-unit>
        <trans-unit id="a47e882af7f7b4bf59f38df7ea0de6601132847c" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; keyed by head name, or logits &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt;. For many applications, the &lt;code&gt;Tensor&lt;/code&gt; shape is &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt;. If logits is a &lt;code&gt;Tensor&lt;/code&gt;, it will split the &lt;code&gt;Tensor&lt;/code&gt; along the last dimension and distribute it appropriately among the heads. Check &lt;code&gt;MultiHead&lt;/code&gt; for examples.</source>
          <target state="translated">헤드 이름으로 입력 된 &lt;code&gt;dict&lt;/code&gt; 를 입력하거나 &lt;code&gt;[D0, D1, ... DN, logits_dimension]&lt;/code&gt; 모양으로 &lt;code&gt;Tensor&lt;/code&gt; 를 로짓 합니다. 많은 애플리케이션에서 &lt;code&gt;Tensor&lt;/code&gt; 모양은 &lt;code&gt;[batch_size, logits_dimension]&lt;/code&gt; 입니다. 로짓이 &lt;code&gt;Tensor&lt;/code&gt; 이면 마지막 차원을 따라 &lt;code&gt;Tensor&lt;/code&gt; 를 분할 하고 헤드 사이에 적절하게 배포합니다. 예를 &lt;code&gt;MultiHead&lt;/code&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="55df84b1e295dfaf67dfff1b3a1fdcf1773c8846" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; keyed by head name. For each head, the label value can be integer or string &lt;code&gt;Tensor&lt;/code&gt; with shape matching its corresponding &lt;code&gt;logits&lt;/code&gt;.&lt;code&gt;labels&lt;/code&gt; is a required argument when &lt;code&gt;mode&lt;/code&gt; equals &lt;code&gt;TRAIN&lt;/code&gt; or &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="translated">헤드 이름으로 입력 된 &lt;code&gt;dict&lt;/code&gt; 입력. 각 헤드에 대해 레이블 값은 해당 &lt;code&gt;logits&lt;/code&gt; 과 일치하는 모양을 가진 정수 또는 문자열 &lt;code&gt;Tensor&lt;/code&gt; 일 수 있습니다 . &lt;code&gt;labels&lt;/code&gt; 필수 인수입니다 &lt;code&gt;mode&lt;/code&gt; 동일 &lt;code&gt;TRAIN&lt;/code&gt; 또는 &lt;code&gt;EVAL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="7d0ae41f6575650de2d584cfceb38b4e40bc36c9" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; mapping string feature names to &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects containing the values for that feature in a minibatch. Often to be used to fetch example-weight tensor.</source>
          <target state="translated">&lt;code&gt;SparseTensor&lt;/code&gt; 해당 기능에 대한 값을 포함하는 &lt;code&gt;Tensor&lt;/code&gt; 또는 SparseTensor 객체에 문자열 기능 이름을 매핑하는 &lt;code&gt;dict&lt;/code&gt; 를 입력 합니다. 종종 예제 가중치 텐서를 가져 오는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cbc3579a5d678f887fecef572ddf9366f2f9c7cc" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;dict&lt;/code&gt; of &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;SparseTensor&lt;/code&gt; 객체 의 입력 &lt;code&gt;dict&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ae71208250add9941ed13ea2029409afa7b93fb" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set1&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set1_indices&lt;/code&gt;, &lt;code&gt;set1_values&lt;/code&gt;, and &lt;code&gt;set1_shape&lt;/code&gt;. For &lt;code&gt;set1&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same as &lt;code&gt;set2&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but ignored.</source>
          <target state="translated">입력 &lt;code&gt;set1&lt;/code&gt; A는 &lt;code&gt;SparseTensor&lt;/code&gt; 로 표시 &lt;code&gt;set1_indices&lt;/code&gt; , &lt;code&gt;set1_values&lt;/code&gt; 및 &lt;code&gt;set1_shape&lt;/code&gt; . 들면 &lt;code&gt;set1&lt;/code&gt; 기록 &lt;code&gt;n&lt;/code&gt; , 1 &lt;code&gt;n-1&lt;/code&gt; 차원과 동일해야 &lt;code&gt;set2&lt;/code&gt; . 차원 &lt;code&gt;n&lt;/code&gt; 은 세트의 값을 포함하고 중복은 허용되지만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="58c336a84296dacace527a71edd564eea1f7ffa2" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set2&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set2_indices&lt;/code&gt;, &lt;code&gt;set2_values&lt;/code&gt;, and &lt;code&gt;set2_shape&lt;/code&gt;. For &lt;code&gt;set2&lt;/code&gt; ranked &lt;code&gt;n&lt;/code&gt;, 1st &lt;code&gt;n-1&lt;/code&gt; dimensions must be the same as &lt;code&gt;set1&lt;/code&gt;. Dimension &lt;code&gt;n&lt;/code&gt; contains values in a set, duplicates are allowed but ignored.</source>
          <target state="translated">입력 &lt;code&gt;set2&lt;/code&gt; A는 &lt;code&gt;SparseTensor&lt;/code&gt; 로 표시 &lt;code&gt;set2_indices&lt;/code&gt; , &lt;code&gt;set2_values&lt;/code&gt; 및 &lt;code&gt;set2_shape&lt;/code&gt; . 들면 &lt;code&gt;set2&lt;/code&gt; 기록 &lt;code&gt;n&lt;/code&gt; , 1 &lt;code&gt;n-1&lt;/code&gt; 차원과 동일해야 &lt;code&gt;set1&lt;/code&gt; . 차원 &lt;code&gt;n&lt;/code&gt; 은 세트의 값을 포함하고 중복은 허용되지만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c8f99bc7303fea77788e4b5a62891d37be161744" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;set&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt; represented by &lt;code&gt;set_indices&lt;/code&gt;, &lt;code&gt;set_values&lt;/code&gt;, and &lt;code&gt;set_shape&lt;/code&gt;. The last dimension contains values in a set, duplicates are allowed but ignored.</source>
          <target state="translated">입력 &lt;code&gt;set&lt;/code&gt; A는 &lt;code&gt;SparseTensor&lt;/code&gt; 로 표시 &lt;code&gt;set_indices&lt;/code&gt; , &lt;code&gt;set_values&lt;/code&gt; 및 &lt;code&gt;set_shape&lt;/code&gt; . 마지막 차원에는 집합의 값이 포함되어 있으며 중복은 허용되지만 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5f66030afeade18b9456df8065e5c951d6d480c2" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;tensor&lt;/code&gt; or &lt;code&gt;variable&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;tensor&lt;/code&gt; 또는 &lt;code&gt;variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc0e981b33830b81d9ff2818d62f005b2928c167" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;tf.Example&lt;/code&gt; objects:</source>
          <target state="translated">입력 &lt;code&gt;tf.Example&lt;/code&gt; 객체 :</target>
        </trans-unit>
        <trans-unit id="027ba0d2bd1ac3c2c0126ee6ab5e33bed78269f7" translate="yes" xml:space="preserve">
          <source>Input Numpy array.</source>
          <target state="translated">Numpy 배열을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="4e22ca8ccf9f6c32e67d850f39a63b8ae3ce0acb" translate="yes" xml:space="preserve">
          <source>Input PIL Image instance.</source>
          <target state="translated">PIL 이미지 인스턴스를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="393b83efcad37fe7f24fb15bdef2bbd7b9a13b1f" translate="yes" xml:space="preserve">
          <source>Input data (i.e. often &lt;code&gt;sess.graph_def&lt;/code&gt;),</source>
          <target state="translated">입력 데이터 (예 : 종종 &lt;code&gt;sess.graph_def&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="3c8492f8050f5a2252c39818c585ca67b9a56893" translate="yes" xml:space="preserve">
          <source>Input data. It could be:</source>
          <target state="translated">입력 데이터. 그것은 수:</target>
        </trans-unit>
        <trans-unit id="4273256e3bf47b078b718fcd16e88b74b26a5f2c" translate="yes" xml:space="preserve">
          <source>Input data. It could be: - A Numpy array (or array-like), or a list of arrays (in case the model has multiple inputs). - A TensorFlow tensor, or a list of tensors (in case the model has multiple inputs).</source>
          <target state="translated">입력 데이터. -Numpy 배열 (또는 배열 유사) 또는 배열 목록 (모델에 여러 입력이있는 경우). -TensorFlow 텐서 또는 텐서 목록 (모델에 여러 입력이있는 경우).</target>
        </trans-unit>
        <trans-unit id="7804e6f6c4e4eb9aa841a2db499d73f590eec04d" translate="yes" xml:space="preserve">
          <source>Input data. Numpy array of rank 4 or a tuple. If tuple, the first element should contain the images and the second element another numpy array or a list of numpy arrays that gets passed to the output without any modifications. Can be used to feed the model miscellaneous data along with the images. In case of grayscale data, the channels axis of the image array should have value 1, in case of RGB data, it should have value 3, and in case of RGBA data, it should have value 4.</source>
          <target state="translated">입력 데이터. 랭크 4 또는 튜플의 Numpy 배열. 튜플 인 경우 첫 번째 요소는 이미지를 포함하고 두 번째 요소는 다른 numpy 배열 또는 수정없이 출력에 전달되는 numpy 배열 목록을 포함해야합니다. 이미지와 함께 모델 기타 데이터를 공급하는 데 사용할 수 있습니다. 그레이 스케일 데이터의 경우 이미지 배열의 채널 축은 값 1, RGB 데이터의 경우 값 3, RGBA 데이터의 경우 값 4를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="bfe0277ca1258b71f70bd599617a938764ac3895" translate="yes" xml:space="preserve">
          <source>Input images and output images must be quantized types.</source>
          <target state="translated">입력 이미지와 출력 이미지는 양자화 유형이어야합니다.</target>
        </trans-unit>
        <trans-unit id="73f2bad16eec61ee4379ef2b4aeb9cc4c2a4a510" translate="yes" xml:space="preserve">
          <source>Input images can be of different types but output images are always float.</source>
          <target state="translated">입력 이미지는 다른 유형일 수 있지만 출력 이미지는 항상 부동입니다.</target>
        </trans-unit>
        <trans-unit id="db26f74f2a7583e55f737d0b7c1d7bc9abb03c30" translate="yes" xml:space="preserve">
          <source>Input is an unknown function or string, i.e., the input does not denote any defined function.</source>
          <target state="translated">입력이 알 수없는 함수 또는 문자열입니다. 즉, 입력이 정의 된 함수를 나타내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4239004a11dea4c51531321c98ec214cc8cbb13c" translate="yes" xml:space="preserve">
          <source>Input logits.</source>
          <target state="translated">입력 로짓.</target>
        </trans-unit>
        <trans-unit id="fda1e7a11af1cc3301f80e9a5418b19a3ab29bb4" translate="yes" xml:space="preserve">
          <source>Input mask tensor (potentially None) or list of input mask tensors.</source>
          <target state="translated">입력 마스크 텐서 (잠재적으로 없음) 또는 입력 마스크 텐서 목록.</target>
        </trans-unit>
        <trans-unit id="edbe051ef8c9da1130a2117a0a044159ca1b63de" translate="yes" xml:space="preserve">
          <source>Input may or may not have padding at the end. See EncodeBase64 for padding. Web-safe means that input must use - and _ instead of + and /.</source>
          <target state="translated">입력은 끝에 패딩이 있거나 없을 수 있습니다. 패딩에 대해서는 EncodeBase64를 참조하십시오. 웹 안전은 입력이 + 및 / 대신-및 _를 사용해야 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="f8658e95ed1bbcd180ec9de2eb39b3ac7043313a" translate="yes" xml:space="preserve">
          <source>Input of &lt;code&gt;train&lt;/code&gt; and &lt;code&gt;evaluate&lt;/code&gt; should have following features, otherwise there will be a &lt;code&gt;KeyError&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;train&lt;/code&gt; 입력 및 &lt;code&gt;evaluate&lt;/code&gt; 에는 다음과 같은 기능이 있어야합니다. 그렇지 않으면 &lt;code&gt;KeyError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="88e394c2930956f582ca9ae4eef0469cb05766cc" translate="yes" xml:space="preserve">
          <source>Input of &lt;code&gt;train&lt;/code&gt; and &lt;code&gt;evaluate&lt;/code&gt; should have following features, otherwise there will be a KeyError:</source>
          <target state="translated">&lt;code&gt;train&lt;/code&gt; 입력 및 &lt;code&gt;evaluate&lt;/code&gt; 에는 다음 기능이 있어야합니다. 그렇지 않으면 KeyError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebfa8d05c9d2a729345a882e4621644a960bf43d" translate="yes" xml:space="preserve">
          <source>Input pipelines based on Queues are not supported when eager execution is enabled. Please use the &lt;a href=&quot;../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; API to ingest data under eager execution.</source>
          <target state="translated">열성적인 실행이 활성화되면 대기열 기반의 입력 파이프 라인이 지원되지 않습니다. &lt;a href=&quot;../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; API를 사용하여 간절히 실행중인 데이터를 수집하십시오.</target>
        </trans-unit>
        <trans-unit id="598edbed9cb4bf5b632040c88948229e65c299b6" translate="yes" xml:space="preserve">
          <source>Input points. See &lt;a href=&quot;../../../../estimator/estimator#evaluate&quot;&gt;&lt;code&gt;tf.estimator.Estimator.evaluate&lt;/code&gt;&lt;/a&gt;. Only one batch is retrieved.</source>
          <target state="translated">입력 포인트. &lt;a href=&quot;../../../../estimator/estimator#evaluate&quot;&gt; &lt;code&gt;tf.estimator.Estimator.evaluate&lt;/code&gt; 를&lt;/a&gt; 참조 하세요 . 하나의 배치 만 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1a6c78aba2a9c76b9d951d8db1402d9aba390207" translate="yes" xml:space="preserve">
          <source>Input points. See &lt;a href=&quot;../../../../estimator/estimator#predict&quot;&gt;&lt;code&gt;tf.estimator.Estimator.predict&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 포인트. &lt;a href=&quot;../../../../estimator/estimator#predict&quot;&gt; &lt;code&gt;tf.estimator.Estimator.predict&lt;/code&gt; 를&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="d0931987f07b0aec0f450122b07367564fc58ded" translate="yes" xml:space="preserve">
          <source>Input requirements:</source>
          <target state="translated">입력 요구 사항 :</target>
        </trans-unit>
        <trans-unit id="3dc6f8eee6bce10a8537a2917c22a3cc2c8dc7ed" translate="yes" xml:space="preserve">
          <source>Input samples. It could be:</source>
          <target state="translated">입력 샘플. 그것은 수:</target>
        </trans-unit>
        <trans-unit id="1edc3b92bc5323054e3dc2775081c31d37f39632" translate="yes" xml:space="preserve">
          <source>Input shape is not specified. None value for dimension in input_tensor.</source>
          <target state="translated">입력 형태가 지정되지 않았습니다. input_tensor의 차원 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="6150fd4490609fe6a3c79de568883b2478811095" translate="yes" xml:space="preserve">
          <source>Input shape, as an integer shape tuple (or list of shape tuples, one tuple per input tensor).</source>
          <target state="translated">정수 모양 튜플 (또는 모양 튜플 목록, 입력 텐 서당 하나의 튜플)로 입력 모양.</target>
        </trans-unit>
        <trans-unit id="73a2fcb17cd33f0bbcaa985f8ff933859938cfdb" translate="yes" xml:space="preserve">
          <source>Input shape:</source>
          <target state="translated">입력 모양 :</target>
        </trans-unit>
        <trans-unit id="59eecd0cfa473638c7d2777b11ac1545f57165a4" translate="yes" xml:space="preserve">
          <source>Input shape: A single or list of string, int32 or int64 &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt; or &lt;code&gt;RaggedTensor&lt;/code&gt; of shape &lt;code&gt;[batch_size, ...,]&lt;/code&gt;</source>
          <target state="translated">입력 형태 : 단일 또는 문자열 목록, int32 또는 int64 &lt;code&gt;Tensor&lt;/code&gt; , &lt;code&gt;SparseTensor&lt;/code&gt; 또는 &lt;code&gt;RaggedTensor&lt;/code&gt; 형태 &lt;code&gt;[batch_size, ...,]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9fadd4c954d4398a6a8aa787506ce19f5ddef089" translate="yes" xml:space="preserve">
          <source>Input shape: Arbitrary. Use the keyword argument &lt;code&gt;input_shape&lt;/code&gt; (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Same shape as input.</source>
          <target state="translated">입력 형태 : 임의. 이 레이어를 모델의 첫 번째 레이어로 사용할 때 키워드 인수 &lt;code&gt;input_shape&lt;/code&gt; (정수 튜플, 샘플 축을 포함하지 않음)를 사용합니다. 출력 모양 : 입력과 동일한 모양.</target>
        </trans-unit>
        <trans-unit id="406a1ac666c22757785ff154ffb25a854854e54d" translate="yes" xml:space="preserve">
          <source>Input shape: Arbitrary. Use the keyword argument &lt;code&gt;input_shape&lt;/code&gt; (tuple of integers, does not include the samples axis) when using this layer as the first layer in a model. Output shape: Same shape as input. Reference:</source>
          <target state="translated">입력 형태 : 임의. 이 레이어를 모델의 첫 번째 레이어로 사용할 때 키워드 인수 &lt;code&gt;input_shape&lt;/code&gt; (정수 튜플, 샘플 축을 포함하지 않음)를 사용합니다. 출력 모양 : 입력과 동일한 모양. 참고:</target>
        </trans-unit>
        <trans-unit id="aaaf155b1421e874b8972d3235373826e11ba63d" translate="yes" xml:space="preserve">
          <source>Input shape: a list of string or int tensors or sparse tensors of shape &lt;code&gt;[batch_size, d1, ..., dm]&lt;/code&gt;</source>
          <target state="translated">입력 형태 : 문자열 또는 int 텐서 목록 또는 형태의 희소 텐서 &lt;code&gt;[batch_size, d1, ..., dm]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="924a9478691303fe05bafb1fc1238c07cb44c3db" translate="yes" xml:space="preserve">
          <source>Input tensor or list of input tensors.</source>
          <target state="translated">입력 텐서 또는 입력 텐서 목록.</target>
        </trans-unit>
        <trans-unit id="d26122fe46ad936a639db8a98f7a7d831a07c743" translate="yes" xml:space="preserve">
          <source>Input tensor or variable.</source>
          <target state="translated">텐서 또는 변수를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="9dba3b7a1a9cdef336ee977c7f2a6df0eea23b06" translate="yes" xml:space="preserve">
          <source>Input tensor to annotate.</source>
          <target state="translated">주석을 달려면 텐서를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="411356d9f9c5901fb808283dc5ce56a97f9f81c2" translate="yes" xml:space="preserve">
          <source>Input tensor to crop.</source>
          <target state="translated">자르기 위해 텐서를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="aa6f81b7596b400c309065016d4f825b54519070" translate="yes" xml:space="preserve">
          <source>Input tensor, or list/tuple of input tensors.</source>
          <target state="translated">입력 텐서 또는 입력 텐서의 목록 / 튜플.</target>
        </trans-unit>
        <trans-unit id="36402c7384044ec8d1afe082a66fd774f30b26a5" translate="yes" xml:space="preserve">
          <source>Input tensor.</source>
          <target state="translated">입력 텐서.</target>
        </trans-unit>
        <trans-unit id="83473fd83a8c624217c365881f9195c2e91b4bf5" translate="yes" xml:space="preserve">
          <source>Input text (string).</source>
          <target state="translated">입력 텍스트 (문자열).</target>
        </trans-unit>
        <trans-unit id="bb11121330c8874b43826ca8a1da1c1d3c194fb5" translate="yes" xml:space="preserve">
          <source>Inputs and outputs of the computation must be at least rank-1 Tensors.</source>
          <target state="translated">계산의 입력 및 출력은 최소 순위 1 텐서 여야합니다.</target>
        </trans-unit>
        <trans-unit id="e7fe0dcaa3f3ef9a8f095388d2bf7868e5702be9" translate="yes" xml:space="preserve">
          <source>Inputs are &lt;code&gt;query&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; and &lt;code&gt;key&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt;. The calculation follows the steps:</source>
          <target state="translated">입력은 &lt;code&gt;query&lt;/code&gt; 형상 텐서 &lt;code&gt;[batch_size, Tq, dim]&lt;/code&gt; , &lt;code&gt;value&lt;/code&gt; 형상의 텐서 &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; 와 &lt;code&gt;key&lt;/code&gt; 형상 텐서 &lt;code&gt;[batch_size, Tv, dim]&lt;/code&gt; . 계산은 다음 단계를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="1c0e56ccaddb0c8890b27ec9abecd06903924122" translate="yes" xml:space="preserve">
          <source>Inputs are not masked or strictly right padded.</source>
          <target state="translated">입력이 마스크되지 않거나 엄격하게 오른쪽으로 채워지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b70811df5293dc1d88b0b4d8c3745fc0c3e2e349" translate="yes" xml:space="preserve">
          <source>Inputs are tensor and if the tensors contains more than one element, an element-wise logical XOR is computed.</source>
          <target state="translated">입력은 텐서이며 텐서에 둘 이상의 요소가 포함되어 있으면 요소 별 논리 XOR이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="23d064e3d9a6fa10428c435dfb012de3079138c9" translate="yes" xml:space="preserve">
          <source>Inputs are the logits, not probabilities.</source>
          <target state="translated">입력은 확률이 아니라 로짓입니다.</target>
        </trans-unit>
        <trans-unit id="137804bd98ee5ed803aad41b3b2bb45555e950ca" translate="yes" xml:space="preserve">
          <source>Inputs must be a &lt;code&gt;CategoricalColumn&lt;/code&gt; created by any of the &lt;code&gt;categorical_column_*&lt;/code&gt; function. Here is an example of using &lt;code&gt;embedding_column&lt;/code&gt; with &lt;code&gt;DNNClassifier&lt;/code&gt;:</source>
          <target state="translated">입력 값은 &lt;code&gt;categorical_column_*&lt;/code&gt; 함수 중 하나에 의해 생성 된 &lt;code&gt;CategoricalColumn&lt;/code&gt; 이어야합니다 . 다음은 &lt;code&gt;DNNClassifier&lt;/code&gt; 와 &lt;code&gt;embedding_column&lt;/code&gt; 을 사용하는 예입니다 .</target>
        </trans-unit>
        <trans-unit id="78623993ab6e74c3ee21bef7821841777f171f6b" translate="yes" xml:space="preserve">
          <source>Inputs must be a list of categorical columns created by any of the &lt;code&gt;categorical_column_*&lt;/code&gt; function. They must all be of the same type and have the same arguments except &lt;code&gt;key&lt;/code&gt;. E.g. they can be categorical_column_with_vocabulary_file with the same vocabulary_file. Some or all columns could also be weighted_categorical_column.</source>
          <target state="translated">입력 값은 &lt;code&gt;categorical_column_*&lt;/code&gt; 함수 중 하나에 의해 생성 된 범주 열 목록이어야합니다 . 그것들은 모두 같은 타입이어야하고 &lt;code&gt;key&lt;/code&gt; 를 제외하고 같은 인자를 가져야합니다 . 예를 들어, 같은 vocabulary_file을 가진 categorical_column_with_vocabulary_file 일 수 있습니다. 일부 또는 모든 열은 weighted_categorical_column 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1efe96c91fcd8bed8fa1d7ca844191407c209f4" translate="yes" xml:space="preserve">
          <source>Inputs must be of same size and shape.</source>
          <target state="translated">입력은 크기와 모양이 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="5cc1e2618a909f1924de892464f8fe683c626f63" translate="yes" xml:space="preserve">
          <source>Inputs of the SignatureDef defined as a proto map of string to tensor info.</source>
          <target state="translated">텐서 정보에 대한 문자열의 프로토 맵으로 정의 된 SignatureDef의 입력입니다.</target>
        </trans-unit>
        <trans-unit id="0a13494d1fa9208f2eba7e981b495a987da5cd5a" translate="yes" xml:space="preserve">
          <source>Inputs, if use masking, are strictly right-padded.</source>
          <target state="translated">마스킹을 사용하는 경우 입력은 엄격하게 오른쪽으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="023ec1ebccdae7f83573df2912447d135544d80b" translate="yes" xml:space="preserve">
          <source>Inputs/Outputs mapping for children hints.</source>
          <target state="translated">어린이 힌트에 대한 입력 / 출력 매핑.</target>
        </trans-unit>
        <trans-unit id="0f102a3cf4073e5d93951de1381197dd8a18010c" translate="yes" xml:space="preserve">
          <source>Insert a &lt;code&gt;Masking&lt;/code&gt; layer with &lt;code&gt;mask_value=0.&lt;/code&gt; before the LSTM layer:</source>
          <target state="translated">&lt;code&gt;mask_value=0.&lt;/code&gt; 으로 &lt;code&gt;Masking&lt;/code&gt; 레이어를 삽입하십시오 . LSTM 레이어 이전 :</target>
        </trans-unit>
        <trans-unit id="bfe1c55114da692160a20eed9799d0591600c538" translate="yes" xml:space="preserve">
          <source>Insert an item at a given position.</source>
          <target state="translated">주어진 위치에 항목을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="4289ec1fa78fdfefe11042b9998b439fa9c81395" translate="yes" xml:space="preserve">
          <source>Insert name scopes that name ops according to context, like the function they were defined in.</source>
          <target state="translated">정의 된 함수와 같이 컨텍스트에 따라 ops의 이름을 지정하는 이름 범위를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="3070ae425dbe8df14be97a01e4f83025dd75be12" translate="yes" xml:space="preserve">
          <source>Insert of control dependencies in the generated code.</source>
          <target state="translated">생성 된 코드에 제어 종속성을 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="a1f87207530b85579b12d1c5e52ad8a13807845e" translate="yes" xml:space="preserve">
          <source>Inserts a dimension of 1 into a tensor's shape.</source>
          <target state="translated">1의 치수를 텐서 모양에 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="29b723ab1ad43456db942b0b8bd7c8d59bddf967" translate="yes" xml:space="preserve">
          <source>Inserts a dimension of 1 into a tensor's shape. (deprecated arguments)</source>
          <target state="translated">1의 치수를 텐서 모양에 삽입합니다. (더 이상 사용되지 않는 인수)</target>
        </trans-unit>
        <trans-unit id="1d269ecf38e8f23806fcb544f73ec6c7d82059d0" translate="yes" xml:space="preserve">
          <source>Inserts a placeholder for a sparse tensor that will be always fed.</source>
          <target state="translated">항상 공급되는 희소 텐서의 자리 표시자를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="2f562655f77a6d82ddf22ccda7140bb2b957c8a1" translate="yes" xml:space="preserve">
          <source>Inserts a placeholder for a tensor that will be always fed.</source>
          <target state="translated">항상 공급 될 텐서의 자리 표시자를 삽입합니다.</target>
        </trans-unit>
        <trans-unit id="c3bbe50b7a8e09f46aa5f5b6f4c704a039abb44e" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="translated">내부 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 후 &lt;a href=&quot;../../config/experimental_run_functions_eagerly&quot;&gt; &lt;code&gt;tf.config.experimental_run_functions_eagerly(True)&lt;/code&gt; &lt;/a&gt; 라고합니다 :</target>
        </trans-unit>
        <trans-unit id="88242efed2a90369bd7739cd77fd6bb5c625b08a" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;../../config/run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="translated">내부 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 후 &lt;a href=&quot;../../config/run_functions_eagerly&quot;&gt; &lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt; &lt;/a&gt; 라고합니다 :</target>
        </trans-unit>
        <trans-unit id="ac98a58dead80c80e907d0722a4a50459411da6d" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">내부 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7a059d78a854aeca57acd67a3369e631a93c4c21" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after</source>
          <target state="translated">후 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 내부</target>
        </trans-unit>
        <trans-unit id="ec60a47239e5418aff75738619bde1b49257788d" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; after &lt;a href=&quot;config/run_functions_eagerly&quot;&gt;&lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt;&lt;/a&gt; is called:</source>
          <target state="translated">내부 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 후 &lt;a href=&quot;config/run_functions_eagerly&quot;&gt; &lt;code&gt;tf.config.run_functions_eagerly(True)&lt;/code&gt; &lt;/a&gt; 라고합니다 :</target>
        </trans-unit>
        <trans-unit id="f3a75c2b38172e2164e085145cea76fd33af363c" translate="yes" xml:space="preserve">
          <source>Inside &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">내부 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ec79e0ca854d631053514bae0e263ceb9c0d6303" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;v1.Graph&lt;/code&gt;&lt;/a&gt; context it checks both the buildtime and runtime shapes. This is stricter than &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; which only checks the buildtime shape.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;graph&quot;&gt; &lt;code&gt;v1.Graph&lt;/code&gt; &lt;/a&gt; 컨텍스트 내 에서 빌드 시간 및 런타임 모양을 모두 확인합니다. 이것은 빌드 &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; 형태 만 확인하는 tf.Tensor.set_shape 보다 엄격 합니다.</target>
        </trans-unit>
        <trans-unit id="82afdb80382fb2fc992e989613b663643ddaa8e4" translate="yes" xml:space="preserve">
          <source>Inside a &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, if the scope name already exists, the name will be made unique by appending &lt;code&gt;_n&lt;/code&gt;. For example, calling &lt;code&gt;my_op&lt;/code&gt; the second time will generate &lt;code&gt;MyOp_1/a&lt;/code&gt;, etc.</source>
          <target state="translated">&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 내부 에서 범위 이름이 이미 존재하는 경우 &lt;code&gt;_n&lt;/code&gt; 을 추가하여 이름이 고유하게됩니다 . 예를 들어 &lt;code&gt;my_op&lt;/code&gt; 를 두 번째로 호출 하면 &lt;code&gt;MyOp_1/a&lt;/code&gt; 등 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e2cab75c40098f2631f31b554fa63d8c8ec4f9a" translate="yes" xml:space="preserve">
          <source>Inside a &lt;code&gt;with strategy.scope():&lt;/code&gt; code block, this thread will use a variable creator set by &lt;code&gt;strategy&lt;/code&gt;, and will enter its &quot;cross-replica context&quot;.</source>
          <target state="translated">내부 &lt;code&gt;with strategy.scope():&lt;/code&gt; 코드 블록이 스레드에 의해 변수 제작자 세트를 사용 &lt;code&gt;strategy&lt;/code&gt; , 그것의 &quot;크로스 - 복제 컨텍스트&quot;를 입력합니다.</target>
        </trans-unit>
        <trans-unit id="2d5243ea93579bbab1a7b795e88dfd8e5238e331" translate="yes" xml:space="preserve">
          <source>Inside a transformation function for &lt;code&gt;tf.dataset&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;tf.dataset&lt;/code&gt; 에 대한 변환 함수 내부 :</target>
        </trans-unit>
        <trans-unit id="d4b06861e26c80e2e1dae15e440b54ad617bc0bb" translate="yes" xml:space="preserve">
          <source>Inspect per replica values:</source>
          <target state="translated">복제본 별 값 검사 :</target>
        </trans-unit>
        <trans-unit id="acc357acb9630e774fef71bd6f4e9fe4746202ac" translate="yes" xml:space="preserve">
          <source>Inspect the &lt;a href=&quot;../typespec&quot;&gt;&lt;code&gt;tf.TypeSpec&lt;/code&gt;&lt;/a&gt; of the data generated by &lt;code&gt;DistributedDataset&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DistributedDataset&lt;/code&gt; 에 의해 생성 된 데이터 의 &lt;a href=&quot;../typespec&quot;&gt; &lt;code&gt;tf.TypeSpec&lt;/code&gt; &lt;/a&gt; 을 검사합니다 .</target>
        </trans-unit>
        <trans-unit id="6a53dd6e8ab19c662119f50b518c24c49162ee4b" translate="yes" xml:space="preserve">
          <source>Instance of &lt;a href=&quot;../model&quot;&gt;&lt;code&gt;keras.models.Model&lt;/code&gt;&lt;/a&gt;. Reference of the model being trained.</source>
          <target state="translated">&lt;a href=&quot;../model&quot;&gt; &lt;code&gt;keras.models.Model&lt;/code&gt; 의&lt;/a&gt; 인스턴스 . 훈련중인 모델에 대한 참조.</target>
        </trans-unit>
        <trans-unit id="7a130b5a080aaac67de31b1fa82cb3dfac9a1069" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;ImageDataGenerator&lt;/code&gt; to use for random transformations and normalization.</source>
          <target state="translated">임의 변환 및 정규화에 사용할 &lt;code&gt;ImageDataGenerator&lt;/code&gt; 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="b0cf2092da978e7620ab63b4e192bd7a04ad4b4b" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;Model&lt;/code&gt; (could be a functional model or a Sequential model).</source>
          <target state="translated">&lt;code&gt;Model&lt;/code&gt; 인스턴스 (기능적 모델 또는 순차 모델 일 수 있음).</target>
        </trans-unit>
        <trans-unit id="33b43b03a6052c1e3c68139c3abf477e110080e9" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;ReparameterizationType&lt;/code&gt;. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#FULLY_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.FULLY_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, this &lt;code&gt;Distribution&lt;/code&gt; can be reparameterized in terms of some standard distribution with a function whose Jacobian is constant for the support of the standard distribution. If &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#NOT_REPARAMETERIZED&quot;&gt;&lt;code&gt;distributions.NOT_REPARAMETERIZED&lt;/code&gt;&lt;/a&gt;, then no such reparameterization is available.</source>
          <target state="translated">&lt;code&gt;ReparameterizationType&lt;/code&gt; 의 인스턴스 . 경우 &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#FULLY_REPARAMETERIZED&quot;&gt; &lt;code&gt;distributions.FULLY_REPARAMETERIZED&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;Distribution&lt;/code&gt; 그의 코비는 표준 분포의 지원을위한 일정한 기능을 일부 표준 배포판의 관점에서 reparameterized 할 수 있습니다. 경우 &lt;a href=&quot;https://www.tensorflow.org/probability/api_docs/python/tfp/distributions#NOT_REPARAMETERIZED&quot;&gt; &lt;code&gt;distributions.NOT_REPARAMETERIZED&lt;/code&gt; &lt;/a&gt; , 다음 그러한 변수화 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a571b362fde52d2a6b69563361ddf991b6c92df5" translate="yes" xml:space="preserve">
          <source>Instance of &lt;code&gt;TensorShape&lt;/code&gt;, or list of instances of &lt;code&gt;TensorShape&lt;/code&gt; if the layer expects a list of inputs (one instance per input).</source>
          <target state="translated">&lt;code&gt;TensorShape&lt;/code&gt; 인스턴스 또는 레이어에 입력 목록이 &lt;code&gt;TensorShape&lt;/code&gt; 경우 TensorShape 인스턴스 목록 (입력 당 인스턴스 하나).</target>
        </trans-unit>
        <trans-unit id="52a058c45032e7de16ba71c01fab3738d287a42a" translate="yes" xml:space="preserve">
          <source>Instances of &lt;code&gt;NumpyWrapper&lt;/code&gt; are checkpointable objects, and will be saved and restored from checkpoints along with TensorFlow state like variables.</source>
          <target state="translated">&lt;code&gt;NumpyWrapper&lt;/code&gt; 의 인스턴스 는 검사 점 개체이며 변수와 같은 TensorFlow 상태와 함께 검사 점에서 저장 및 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="78eccaaba0fdade93205fff1e00fbadcaeaba337" translate="yes" xml:space="preserve">
          <source>Instances of this class represent a loss scale. Calling instances of this class returns the loss scale as a scalar float32 tensor, while method &lt;code&gt;update()&lt;/code&gt; updates the loss scale depending on the values of the gradients. Optimizers use instances of this class to scale loss and gradients.</source>
          <target state="translated">이 클래스의 인스턴스는 손실 척도를 나타냅니다. 이 클래스의 인스턴스를 호출하면 손실 스케일을 스칼라 float32 텐서로 반환하는 반면 &lt;code&gt;update()&lt;/code&gt; 메서드 는 그래디언트 값에 따라 손실 스케일을 업데이트합니다. 최적화 프로그램은이 클래스의 인스턴스를 사용하여 손실 및 그라디언트를 조정합니다.</target>
        </trans-unit>
        <trans-unit id="abc0db5b227fc3047fc2a6c06364fc3c54136965" translate="yes" xml:space="preserve">
          <source>Instances of this class represent how sampling is reparameterized.</source>
          <target state="translated">이 클래스의 인스턴스는 샘플링을 다시 매개 변수화하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a0b4097742556a6fb1f2198ba723bf3c67e4062b" translate="yes" xml:space="preserve">
          <source>Instances of this dataset are also created as a result of the &lt;code&gt;hoist_random_uniform&lt;/code&gt; static optimization. Whether this optimization is performed is determined by the &lt;code&gt;experimental_optimization.hoist_random_uniform&lt;/code&gt; option of &lt;a href=&quot;../data/options&quot;&gt;&lt;code&gt;tf.data.Options&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 데이터 세트의 인스턴스도 &lt;code&gt;hoist_random_uniform&lt;/code&gt; 정적 최적화 의 결과로 생성됩니다 . 이 최적화가 수행되는지 여부 는 &lt;a href=&quot;../data/options&quot;&gt; &lt;code&gt;tf.data.Options&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;experimental_optimization.hoist_random_uniform&lt;/code&gt; 옵션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e23834d9ad625b0a72d7e2f1be4a4069c499c5c" translate="yes" xml:space="preserve">
          <source>Instantiate an identity matrix and returns it.</source>
          <target state="translated">항등 행렬을 인스턴스화하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9adc3a521be5ffb465cee66aa19ff8ac84ae4cea" translate="yes" xml:space="preserve">
          <source>Instantiates a &lt;code&gt;LearningRateSchedule&lt;/code&gt; from its config.</source>
          <target state="translated">구성에서 &lt;code&gt;LearningRateSchedule&lt;/code&gt; 을 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="e819f31f0ce693841e6703a84bf49642d0f0646a" translate="yes" xml:space="preserve">
          <source>Instantiates a &lt;code&gt;Loss&lt;/code&gt; from its config (output of &lt;code&gt;get_config()&lt;/code&gt;).</source>
          <target state="translated">구성에서 &lt;code&gt;Loss&lt;/code&gt; 을 인스턴스화합니다 ( &lt;code&gt;get_config()&lt;/code&gt; 출력 ).</target>
        </trans-unit>
        <trans-unit id="6ba64f03d4a9f988022614425c9d39f3e4c08eec" translate="yes" xml:space="preserve">
          <source>Instantiates a Keras function.</source>
          <target state="translated">Keras 함수를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="86be24bfd95437c4ccded5012ad87863f17418f2" translate="yes" xml:space="preserve">
          <source>Instantiates a Keras model from its config.</source>
          <target state="translated">구성에서 Keras 모델을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="bc64840a2606c1465edcdf6de298724ac46c006a" translate="yes" xml:space="preserve">
          <source>Instantiates a Mobile NASNet model in ImageNet mode.</source>
          <target state="translated">ImageNet 모드에서 Mobile NASNet 모델을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="18a38d91d8d2817de0090aee963f8e886b2ccdc4" translate="yes" xml:space="preserve">
          <source>Instantiates a NASNet model in ImageNet mode.</source>
          <target state="translated">ImageNet 모드에서 NASNet 모델을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="e1139b10a46081f05ee7e89e2f44088cc63dc7ce" translate="yes" xml:space="preserve">
          <source>Instantiates a layer from a config dictionary.</source>
          <target state="translated">구성 사전에서 계층을 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="f2e8a39a6c72f1d2adbc3a7102dbfb7499d810f2" translate="yes" xml:space="preserve">
          <source>Instantiates a placeholder tensor and returns it.</source>
          <target state="translated">자리 표시 자 텐서를 인스턴스화하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="56fcc9aa753f9745e6fd3098bb85d40d054e5bf6" translate="yes" xml:space="preserve">
          <source>Instantiates a variable and returns it.</source>
          <target state="translated">변수를 인스턴스화하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e4ee72f81497fc62ef8381301600c750a4c3bf6b" translate="yes" xml:space="preserve">
          <source>Instantiates a variable with values drawn from a normal distribution.</source>
          <target state="translated">정규 분포에서 가져온 값으로 변수를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="25c5cf039c5c919ae65a83e5f4aa30370b25a668" translate="yes" xml:space="preserve">
          <source>Instantiates a variable with values drawn from a uniform distribution.</source>
          <target state="translated">균일 분포에서 가져온 값으로 변수를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="20d6d4e9f45134915d0ed9873dfceccd0144de71" translate="yes" xml:space="preserve">
          <source>Instantiates an all-ones variable and returns it.</source>
          <target state="translated">all-ones 변수를 인스턴스화하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ddc4e890d0448de00a1911ddc70ef24681ca3b6" translate="yes" xml:space="preserve">
          <source>Instantiates an all-ones variable of the same shape as another tensor.</source>
          <target state="translated">다른 텐서와 동일한 모양의 올인원 변수를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="05d54627ce37da1dd958b8c24f85136425c8109f" translate="yes" xml:space="preserve">
          <source>Instantiates an all-zeros variable and returns it.</source>
          <target state="translated">모두 0 인 변수를 인스턴스화하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94d5c94851b51c4270f6a95b7c0475db1f95de16" translate="yes" xml:space="preserve">
          <source>Instantiates an all-zeros variable of the same shape as another tensor.</source>
          <target state="translated">다른 텐서와 동일한 모양의 모든 0 변수를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="473a492fa8efc4ff13a257196fc8bcdbedc7a3be" translate="yes" xml:space="preserve">
          <source>Instantiates an initializer from a configuration dictionary.</source>
          <target state="translated">구성 사전에서 이니셜 라이저를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="37c35605484e0d745ddc5664f56cd31ede10bf0c" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet121 architecture.</source>
          <target state="translated">Densenet121 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="5653e7446bf8e535b95649a14a1a4040bb848a0b" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet169 architecture.</source>
          <target state="translated">Densenet169 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="f508e422c41ca1583ddcf82367eac1c471fd48b0" translate="yes" xml:space="preserve">
          <source>Instantiates the Densenet201 architecture.</source>
          <target state="translated">Densenet201 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="2b9dfa1e763ba9c6ee2a8efbc3b3a17aaaf64ef6" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB0 architecture.</source>
          <target state="translated">EfficientNetB0 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="ee114842722aaf43b1f00ba82ed047ce9ea3625c" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB1 architecture.</source>
          <target state="translated">EfficientNetB1 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="d49a42cfb87e77c9458417cc44f0470e88bd18fb" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB2 architecture.</source>
          <target state="translated">EfficientNetB2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="ec05ff7ddf6d159bc29b6ab06f9919b453979907" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB3 architecture.</source>
          <target state="translated">EfficientNetB3 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="e274afe59e85bd28123c509e293ddef256fc47e7" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB4 architecture.</source>
          <target state="translated">EfficientNetB4 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="670cd5b074f325a33ec1e7cb64c2835e0650303e" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB5 architecture.</source>
          <target state="translated">EfficientNetB5 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="6190fec6179c6ac2542069c4aa38c7426259e5fb" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB6 architecture.</source>
          <target state="translated">EfficientNetB6 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="7d01c143ca90bb8d3f8102a2cb478d8ce8006779" translate="yes" xml:space="preserve">
          <source>Instantiates the EfficientNetB7 architecture.</source>
          <target state="translated">EfficientNetB7 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="75adf7e363222d5982bb56012c80c73ff05f830f" translate="yes" xml:space="preserve">
          <source>Instantiates the Inception v3 architecture.</source>
          <target state="translated">Inception v3 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="8d78bcfb25bd570f535140464bdf38a98cccde81" translate="yes" xml:space="preserve">
          <source>Instantiates the Inception-ResNet v2 architecture.</source>
          <target state="translated">Inception-ResNet v2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="70b89338d0787e01e1e52b18673f6ae4ee703c4d" translate="yes" xml:space="preserve">
          <source>Instantiates the MobileNetV2 architecture.</source>
          <target state="translated">MobileNetV2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="531578a4574367ea2e522f8daeb216a6ce63c736" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet101 architecture.</source>
          <target state="translated">ResNet101 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="125861983e29828c299a903f43d798714d2a4065" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet101V2 architecture.</source>
          <target state="translated">ResNet101V2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="bb8086b3c4c214259579bd6fac585cf9962ba4b8" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet152 architecture.</source>
          <target state="translated">ResNet152 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="64e500067287dc9f9611a296525538c5abcd7cc2" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet152V2 architecture.</source>
          <target state="translated">ResNet152V2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="27fa3302c8b3ab65c7c2bc821f6a3c6a294198d4" translate="yes" xml:space="preserve">
          <source>Instantiates the ResNet50V2 architecture.</source>
          <target state="translated">ResNet50V2 아키텍처를 인스턴스화합니다.</target>
        </trans-unit>
        <trans-unit id="a0ef306da9dababdc7dcdebe674cef89859a3705" translate="yes" xml:space="preserve">
          <source>Instead of a string enum, prefer &lt;code&gt;DEFINE_enum_class&lt;/code&gt;, which allows defining enums from an &lt;code&gt;enum.Enum&lt;/code&gt; class.</source>
          <target state="translated">문자열 열거 형 대신 &lt;code&gt;DEFINE_enum_class&lt;/code&gt; 선호 하는 &lt;code&gt;enum.Enum&lt;/code&gt; 클래스 에서 열거 형을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">이 대신에 :</target>
        </trans-unit>
        <trans-unit id="512626e184ef04fe486402828c5c025627c4c4b2" translate="yes" xml:space="preserve">
          <source>Instead of working with &lt;code&gt;Tensor&lt;/code&gt; objects, most operations work with &lt;code&gt;TensorArray&lt;/code&gt; objects directly.</source>
          <target state="translated">대부분 의 작업은 &lt;code&gt;Tensor&lt;/code&gt; 객체 를 사용하는 대신 &lt;code&gt;TensorArray&lt;/code&gt; 객체를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5af1b9159af411b6d7c635a164a0a3cae7782b83" translate="yes" xml:space="preserve">
          <source>Instead, use TensorFlow collections like &lt;a href=&quot;tensorarray&quot;&gt;&lt;code&gt;tf.TensorArray&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">대신 &lt;a href=&quot;tensorarray&quot;&gt; &lt;code&gt;tf.TensorArray&lt;/code&gt; &lt;/a&gt; 와 같은 TensorFlow 컬렉션을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="986b3aa1fa9c8a53c78f4ac79b77467a9d988af6" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;tensor.experimental_ref()&lt;/code&gt;.</source>
          <target state="translated">대신에 &lt;code&gt;tensor.experimental_ref()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6172bfc8c17542f600fe289d1b62d9a4b7a9359b" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;tensor.ref()&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;tensor.ref()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c4f88879032bd2f2457bad138fb5059212807b2a" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;variable.experimental_ref()&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;variable.experimental_ref()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e3ce0ddf9c926093dd6fb8689fc2f4b12d054544" translate="yes" xml:space="preserve">
          <source>Instead, we can use &lt;code&gt;variable.ref()&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;variable.ref()&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="865bac3875319b333427170b8f58a76d52bdfa96" translate="yes" xml:space="preserve">
          <source>Instead, wrap nested &lt;code&gt;@tf.custom_gradients&lt;/code&gt; in another function:</source>
          <target state="translated">대신 다른 함수에서 중첩 된 &lt;code&gt;@tf.custom_gradients&lt;/code&gt; 를 래핑하십시오 .</target>
        </trans-unit>
        <trans-unit id="48fdffce381680dc01bd7387e5ff47c9e92e8b06" translate="yes" xml:space="preserve">
          <source>Int (default: 32).</source>
          <target state="translated">Int (기본값 : 32).</target>
        </trans-unit>
        <trans-unit id="9aaccd55781d8df00a39c7af94d3d28b37361602" translate="yes" xml:space="preserve">
          <source>Int (default: None).</source>
          <target state="translated">Int (기본값 : 없음).</target>
        </trans-unit>
        <trans-unit id="aaec79069c9826c094fc28bfba022f7ba15126dc" translate="yes" xml:space="preserve">
          <source>Int or tuple of int (length 2) How many units should be trimmed off at the beginning and end of the cropping dimension (axis 1). If a single int is provided, the same value will be used for both.</source>
          <target state="translated">Int 또는 int의 튜플 (길이 2) 자르기 차원 (축 1)의 시작과 끝에서 잘라야하는 단위 수입니다. 단일 int가 제공되면 둘 다에 동일한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e182a1f01e97f35d5924b841ddd0d35ebe2837ad" translate="yes" xml:space="preserve">
          <source>Int specifying the channels axis. &lt;code&gt;axis=-1&lt;/code&gt; corresponds to data format &lt;code&gt;channels_last', and&lt;/code&gt;axis=1&lt;code&gt;corresponds to data format&lt;/code&gt;channels_first`.</source>
          <target state="translated">채널 축을 지정하는 정수입니다. &lt;code&gt;axis=-1&lt;/code&gt; 은 데이터 형식 &lt;code&gt;channels_last', and&lt;/code&gt; &lt;code&gt;corresponds to data format&lt;/code&gt; 하고 axis = 1 은 데이터 형식 channels_first'에 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="23c1fe0f3b374162b4a2ca48b5634cc5e178bbe3" translate="yes" xml:space="preserve">
          <source>Int, how many dropout mask will be generated. It is useful for cell that has internal weights fused together.</source>
          <target state="translated">Int, 생성 될 드롭 아웃 마스크 수입니다. 내부 가중치가 함께 융합 된 셀에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91567b0bdb3e9d727777ac8dfb086e5450943279" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 2 integers. The upsampling factors for rows and columns.</source>
          <target state="translated">Int 또는 2 개 정수의 튜플입니다. 행과 열에 대한 업 샘플링 인자.</target>
        </trans-unit>
        <trans-unit id="58d4b52ccd5a5944ba036967e1e0013e3a712e87" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints.</source>
          <target state="translated">Int 또는 2 int의 튜플 또는 2 int의 2 튜플의 튜플.</target>
        </trans-unit>
        <trans-unit id="1094de6d5b113921eb5a29974615186e064dad7a" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 3 integers. The upsampling factors for dim1, dim2 and dim3.</source>
          <target state="translated">Int 또는 3 개의 정수로 구성된 튜플입니다. dim1, dim2 및 dim3에 대한 업 샘플링 인자.</target>
        </trans-unit>
        <trans-unit id="605a79b8c702d3c89a259892042db0a515f2131e" translate="yes" xml:space="preserve">
          <source>Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints.</source>
          <target state="translated">Int, 또는 3 개 정수의 튜플 또는 2 개 정수의 3 개 튜플의 튜플.</target>
        </trans-unit>
        <trans-unit id="7c26a9027902710fd5c332e37e53db69471e1a23" translate="yes" xml:space="preserve">
          <source>Int, or tuple of int (length 2), or dictionary.</source>
          <target state="translated">Int 또는 int의 튜플 (길이 2) 또는 사전.</target>
        </trans-unit>
        <trans-unit id="ce684fb120f5dbcc5717f1102bb3deb9fd23c797" translate="yes" xml:space="preserve">
          <source>Int. Degree range for random rotations.</source>
          <target state="translated">Int. 임의 회전의 각도 범위.</target>
        </trans-unit>
        <trans-unit id="33b74cc7edd585738b5f3ce8b9218040b2725b64" translate="yes" xml:space="preserve">
          <source>Int. Do not re-evaluate unless the last evaluation was started at least this many seconds ago. Of course, evaluation does not occur if no new checkpoints are available, hence, this is the minimum.</source>
          <target state="translated">Int. 마지막 평가가이 몇 초 전에 시작된 경우가 아니면 재평가하지 마십시오. 물론 새 체크 포인트를 사용할 수 없으면 평가가 발생하지 않으므로 이것이 최소입니다.</target>
        </trans-unit>
        <trans-unit id="e678a94768fbb08f3be3daec9e20719ff102cce6" translate="yes" xml:space="preserve">
          <source>Int. Positive number of steps for which to evaluate model. If &lt;code&gt;None&lt;/code&gt;, evaluates until &lt;code&gt;input_fn&lt;/code&gt; raises an end-of-input exception. See &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt;&lt;code&gt;Estimator.evaluate&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">Int. 모델을 평가할 단계의 양수입니다. 경우 &lt;code&gt;None&lt;/code&gt; 일까지 평가하여 &lt;code&gt;input_fn&lt;/code&gt; 는 최종의 입력 예외가 발생하지 않는다. 자세한 내용은 &lt;a href=&quot;../compat/v1/estimator/estimator#evaluate&quot;&gt; &lt;code&gt;Estimator.evaluate&lt;/code&gt; &lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="b68a61eb5205896629486296aef43add0c23c824" translate="yes" xml:space="preserve">
          <source>Int. Positive number of total steps for which to train model. If &lt;code&gt;None&lt;/code&gt;, train forever. The training &lt;code&gt;input_fn&lt;/code&gt; is not expected to generate &lt;code&gt;OutOfRangeError&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt; exceptions. See the &lt;code&gt;train_and_evaluate&lt;/code&gt; stop condition section for details.</source>
          <target state="translated">Int. 모델을 학습시킬 총 단계의 양수입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 영원히 훈련. 훈련 &lt;code&gt;input_fn&lt;/code&gt; 은 &lt;code&gt;OutOfRangeError&lt;/code&gt; 또는 &lt;code&gt;StopIteration&lt;/code&gt; 예외 를 생성하지 않습니다 . 자세한 내용은 &lt;code&gt;train_and_evaluate&lt;/code&gt; 정지 조건 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="128d22b45ec9bf45bb8958a64657b9ae9b3016e7" translate="yes" xml:space="preserve">
          <source>Int. Start evaluating after waiting for this many seconds.</source>
          <target state="translated">Int. 이 시간을 기다린 후 평가를 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="c893667a4725d4728d8955120def8bd0caef8554" translate="yes" xml:space="preserve">
          <source>Int. global step this summary is associated with. If &lt;code&gt;None&lt;/code&gt;, it will try to fetch the current step.</source>
          <target state="translated">Int. 이 요약이 연관된 글로벌 단계입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 현재 단계를 가져 오기 위해 노력할 것입니다.</target>
        </trans-unit>
        <trans-unit id="c2f1b9c838e3bdee9d4226dd5a70ef1f7d198e1a" translate="yes" xml:space="preserve">
          <source>Integer &amp;gt;= 2, number of on GPUs on which to create model replicas.</source>
          <target state="translated">정수&amp;gt; = 2, 모델 복제본을 생성 할 GPU의 수입니다.</target>
        </trans-unit>
        <trans-unit id="dc5a90a943564f7a628a84e21312bf2ef63b9877" translate="yes" xml:space="preserve">
          <source>Integer (scalar), number of axes.</source>
          <target state="translated">정수 (스칼라), 축 수입니다.</target>
        </trans-unit>
        <trans-unit id="632b435479a4f941ea8cb031b6434f5cf0246f4a" translate="yes" xml:space="preserve">
          <source>Integer &lt;code&gt;Tensor&lt;/code&gt; with shape [D1, ... DN, k] where N &amp;gt;= 1. Commonly, N=1 and predictions has shape [batch size, k]. The final dimension contains the top &lt;code&gt;k&lt;/code&gt; predicted class indices. [D1, ... DN] must match &lt;code&gt;labels&lt;/code&gt;.</source>
          <target state="translated">형태가 [D1, ... DN, k] 인 정수 &lt;code&gt;Tensor&lt;/code&gt; 여기서 N&amp;gt; = 1. 일반적으로 N = 1이고 예측은 [배치 크기, k] 형태를 갖습니다. 최종 차원에는 상위 &lt;code&gt;k&lt;/code&gt; 개의 예측 클래스 인덱스가 포함됩니다. [D1, ... DN]은 &lt;code&gt;labels&lt;/code&gt; 과 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ba10e8d77de8d85dc8f7ffede369439ca46e1793" translate="yes" xml:space="preserve">
          <source>Integer class ID for which we want binary metrics. This should be in range [0, num_classes), where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. If class_id is outside this range, the method returns NAN.</source>
          <target state="translated">이진 메트릭을 원하는 정수 클래스 ID입니다. 범위는 [0, num_classes) 여야합니다. 여기서 num_classes는 &lt;code&gt;predictions&lt;/code&gt; 의 마지막 차원입니다 . class_id가이 범위를 벗어나면 메서드는 NAN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e7584ef68ba028e33c608eba25f0800f58fd323d" translate="yes" xml:space="preserve">
          <source>Integer class ID for which we want binary metrics. This should be in range [0, num_classes], where num_classes is the last dimension of &lt;code&gt;predictions&lt;/code&gt;. If &lt;code&gt;class_id&lt;/code&gt; is outside this range, the method returns NAN.</source>
          <target state="translated">이진 메트릭을 원하는 정수 클래스 ID입니다. 범위는 [0, num_classes] 여야합니다. 여기서 num_classes는 &lt;code&gt;predictions&lt;/code&gt; 의 마지막 차원입니다 . 경우 &lt;code&gt;class_id&lt;/code&gt; 이 범위를 벗어나, 방법은 NAN을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f540c874285d721d8fcd0d3ea0c7ef0568ca56a6" translate="yes" xml:space="preserve">
          <source>Integer dtype to use.</source>
          <target state="translated">사용할 정수 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="47a5d193b7855cdee378a1f1325316aa3d36fe9d" translate="yes" xml:space="preserve">
          <source>Integer ground truth values.</source>
          <target state="translated">정수 지상 진실 값.</target>
        </trans-unit>
        <trans-unit id="a8db02371b65068479c3c0bd540c1643d1742823" translate="yes" xml:space="preserve">
          <source>Integer hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function. If not given, a default key is used.</source>
          <target state="translated">&lt;code&gt;FingerprintCat64&lt;/code&gt; 함수에서 사용할 정수 hash_key입니다 . 지정하지 않으면 기본 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4fb0bee49a715975c31f963e5f0149fa6c8ed7e6" translate="yes" xml:space="preserve">
          <source>Integer hash_key that will be used by the &lt;code&gt;FingerprintCat64&lt;/code&gt; function. If not given, will use a default key.</source>
          <target state="translated">&lt;code&gt;FingerprintCat64&lt;/code&gt; 함수에서 사용할 정수 hash_key입니다 . 지정하지 않으면 기본 키를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9d56b77568017246afb3e6304f9b0829a9d58f81" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch of computation. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of a dataset, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 계산 배치 당 샘플 수입니다. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치가 생성되므로).</target>
        </trans-unit>
        <trans-unit id="c9865f8ea271cb814a62944707f966161b1f988f" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch of computation. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of a dataset, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 계산 배치 당 샘플 수입니다. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치가 생성되므로).</target>
        </trans-unit>
        <trans-unit id="ec55393c87a831154f49f5a6c6a96f32c7c0366d" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of dataset, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 배치 당 샘플 수. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치가 생성되므로).</target>
        </trans-unit>
        <trans-unit id="55cf10e04b5ec63fa0038e1d594552454650016f" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per batch. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of dataset, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 배치 당 샘플 수. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치가 생성되므로).</target>
        </trans-unit>
        <trans-unit id="2980185c242625e64631aa2188651861e27ce5fc" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per gradient update. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 그라디언트 업데이트 당 샘플 수. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치를 생성하므로).</target>
        </trans-unit>
        <trans-unit id="56bbc8f9459243c926740f24c7bc12e664a5dec2" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per gradient update. If unspecified, &lt;code&gt;batch_size&lt;/code&gt; will default to 32. Do not specify the &lt;code&gt;batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 그라디언트 업데이트 당 샘플 수. 지정 하지 않으면 &lt;code&gt;batch_size&lt;/code&gt; 는 기본적으로 32로 설정됩니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형식 인 경우 &lt;code&gt;batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치를 생성하므로).</target>
        </trans-unit>
        <trans-unit id="a869efbb667ad57f17e3cba30053054a9847d5f8" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per validation batch. If unspecified, will default to &lt;code&gt;batch_size&lt;/code&gt;. Do not specify the &lt;code&gt;validation_batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 검증 배치 당 샘플 수. 지정하지 않으면 기본값은 &lt;code&gt;batch_size&lt;/code&gt; 입니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형태 인 경우 &lt;code&gt;validation_batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치를 생성하므로).</target>
        </trans-unit>
        <trans-unit id="877acce569d433d882bfc7dcaaef24db8428c9c3" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Number of samples per validation batch. If unspecified, will default to &lt;code&gt;batch_size&lt;/code&gt;. Do not specify the &lt;code&gt;validation_batch_size&lt;/code&gt; if your data is in the form of datasets, generators, or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; instances (since they generate batches).</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 검증 배치 당 샘플 수. 지정하지 않으면 기본값은 &lt;code&gt;batch_size&lt;/code&gt; 입니다. 데이터가 데이터 세트, 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 인스턴스 의 형태 인 경우 &lt;code&gt;validation_batch_size&lt;/code&gt; 를 지정하지 마십시오 (배치를 생성하므로).</target>
        </trans-unit>
        <trans-unit id="e8221094e8ae1087245a4899dd4587e32e1631a3" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the &lt;code&gt;steps_per_epoch&lt;/code&gt; argument. This argument is not supported with array inputs.</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 한 세대가 완료되었다고 선언하고 다음 세대를 시작하기 전의 총 단계 (샘플 배치) 수입니다. TensorFlow 데이터 텐서와 같은 입력 텐서를 사용하여 학습 할 때 기본값 &lt;code&gt;None&lt;/code&gt; 은 데이터 세트의 샘플 수를 배치 크기로 나눈 값과 같거나 결정할 수없는 경우 1입니다. x가 &lt;a href=&quot;../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 데이터 세트이고 'steps_per_epoch'가 None이면 입력 데이터 세트가 소진 될 때까지 epoch가 실행됩니다. 무한 반복 데이터 세트를 전달할 때 &lt;code&gt;steps_per_epoch&lt;/code&gt; 인수를 지정해야합니다 . 이 인수는 배열 입력에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17b5325521dae896ba091f0c622bb685243a752c" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring one epoch finished and starting the next epoch. When training with input tensors such as TensorFlow data tensors, the default &lt;code&gt;None&lt;/code&gt; is equal to the number of samples in your dataset divided by the batch size, or 1 if that cannot be determined. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset, and 'steps_per_epoch' is None, the epoch will run until the input dataset is exhausted. When passing an infinitely repeating dataset, you must specify the &lt;code&gt;steps_per_epoch&lt;/code&gt; argument. This argument is not supported with array inputs.</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 한 세대가 완료되었다고 선언하고 다음 세대를 시작하기 전의 총 단계 (샘플 배치) 수입니다. TensorFlow 데이터 텐서와 같은 입력 텐서를 사용하여 학습 할 때 기본값 &lt;code&gt;None&lt;/code&gt; 은 데이터 세트의 샘플 수를 배치 크기로 나눈 값과 같거나 결정할 수없는 경우 1입니다. x가 &lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 데이터 세트이고 'steps_per_epoch'가 None이면 입력 데이터 세트가 소진 될 때까지 epoch가 실행됩니다. 무한 반복 데이터 세트를 전달할 때 &lt;code&gt;steps_per_epoch&lt;/code&gt; 인수를 지정해야합니다 . 이 인수는 배열 입력에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e9bfe8f19e849a992284a80f1a5980131517eec2" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 평가 라운드가 완료되었음을 선언하기 전의 총 단계 수 (샘플 배치)입니다. 기본값 &lt;code&gt;None&lt;/code&gt; 으로 무시됩니다 . x가 &lt;a href=&quot;../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 데이터 세트이고 &lt;code&gt;steps&lt;/code&gt; 가 None이면 데이터 세트가 소진 될 때까지 'evaluate'가 실행됩니다. 이 인수는 배열 입력에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8ebe399fc79d830decb4088d9908b0a0d7cf8e87" translate="yes" xml:space="preserve">
          <source>Integer or &lt;code&gt;None&lt;/code&gt;. Total number of steps (batches of samples) before declaring the evaluation round finished. Ignored with the default value of &lt;code&gt;None&lt;/code&gt;. If x is a &lt;a href=&quot;../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; dataset and &lt;code&gt;steps&lt;/code&gt; is None, 'evaluate' will run until the dataset is exhausted. This argument is not supported with array inputs.</source>
          <target state="translated">Integer 또는 &lt;code&gt;None&lt;/code&gt; . 평가 라운드가 완료되었음을 선언하기 전의 총 단계 수 (샘플 배치)입니다. 기본값 &lt;code&gt;None&lt;/code&gt; 으로 무시됩니다 . x가 &lt;a href=&quot;../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 데이터 세트이고 &lt;code&gt;steps&lt;/code&gt; 가 None이면 데이터 세트가 소진 될 때까지 'evaluate'가 실행됩니다. 이 인수는 배열 입력에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e5f9a2d337158bb6ad4889e0b1e861a66788f5ae" translate="yes" xml:space="preserve">
          <source>Integer or List/Tuple. The axis or axes to normalize across. Typically this is the features axis/axes. The left-out axes are typically the batch axis/axes. This argument defaults to &lt;code&gt;-1&lt;/code&gt;, the last dimension in the input.</source>
          <target state="translated">정수 또는 목록 / 튜플. 정규화 할 축입니다. 일반적으로 피처 축 / 축입니다. 왼쪽 축은 일반적으로 배치 축 / 축입니다. 이 인수의 기본값 은 입력의 마지막 차원 인 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1eccdff7a407865cbfbdc69eea10f4bd5a37039a" translate="yes" xml:space="preserve">
          <source>Integer or Long, dimensionality of the output space.</source>
          <target state="translated">출력 공간의 정수 또는 긴 차원.</target>
        </trans-unit>
        <trans-unit id="2b058f1f30deac1321d12aaea555f116fa6dcac5" translate="yes" xml:space="preserve">
          <source>Integer or TensorShape: size of outputs produced by this cell.</source>
          <target state="translated">정수 또는 TensorShape :이 셀에서 생성 된 출력 크기.</target>
        </trans-unit>
        <trans-unit id="c85d071ff67fea5317214e2c8376aa4e5f8888ac" translate="yes" xml:space="preserve">
          <source>Integer or iterable of integers. Axes to reverse.</source>
          <target state="translated">정수 또는 정수의 반복 가능. 반전 할 축.</target>
        </trans-unit>
        <trans-unit id="7ee228302b0384ee03ffd17e6827b3463a0b3348" translate="yes" xml:space="preserve">
          <source>Integer or tuple of integers, axis or axes along which to take the dot product. If a tuple, should be two integers corresponding to the desired axis from the first input and the desired axis from the second input, respectively. Note that the size of the two selected axes must match.</source>
          <target state="translated">내적을 취할 정수, 축 또는 축의 정수 또는 튜플. 튜플 인 경우 각각 첫 번째 입력의 원하는 축과 두 번째 입력의 원하는 축에 해당하는 두 개의 정수 여야합니다. 선택한 두 축의 크기가 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="5999e6dc053e2977702144f72bbcd35aee55179e" translate="yes" xml:space="preserve">
          <source>Integer or tuple of integers, the axis or axes that should be &quot;kept&quot;. These axes are not be summed over when calculating the normalization statistics. By default the last axis, the &lt;code&gt;features&lt;/code&gt; axis is kept and any &lt;code&gt;space&lt;/code&gt; or &lt;code&gt;time&lt;/code&gt; axes are summed. Each element in the the axes that are kept is normalized independently. If &lt;code&gt;axis&lt;/code&gt; is set to 'None', the layer will perform scalar normalization (diving the input by a single scalar value). The &lt;code&gt;batch&lt;/code&gt; axis, 0, is always summed over (&lt;code&gt;axis=0&lt;/code&gt; is not allowed).</source>
          <target state="translated">정수 또는 정수의 튜플, &quot;유지&quot;해야하는 축 또는 축. 이러한 축은 정규화 통계를 계산할 때 합산되지 않습니다. 기본적으로 마지막 축은 &lt;code&gt;features&lt;/code&gt; 축이 유지되고 모든 &lt;code&gt;space&lt;/code&gt; 또는 &lt;code&gt;time&lt;/code&gt; 축이 합산됩니다. 유지되는 축의 각 요소는 독립적으로 정규화됩니다. 경우 &lt;code&gt;axis&lt;/code&gt; '없음'으로 설정되면, 층 스칼라 정규화 (다이빙 단일 스칼라 값에 의해 입력)을 수행한다. &lt;code&gt;batch&lt;/code&gt; 축 0은 항상 (합산되고 &lt;code&gt;axis=0&lt;/code&gt; 허용되지 않는다).</target>
        </trans-unit>
        <trans-unit id="90f12259e9abc566ecc3b05524f7d03fd2cfe6bc" translate="yes" xml:space="preserve">
          <source>Integer specifying the dimension index at which to expand the shape of &lt;code&gt;input&lt;/code&gt;. Given an input of D dimensions, &lt;code&gt;axis&lt;/code&gt; must be in range &lt;code&gt;[-(D+1), D]&lt;/code&gt; (inclusive).</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 형태를 확장 할 차원 인덱스를 지정하는 정수 입니다. D 차원 입력이 주어지면 &lt;code&gt;axis&lt;/code&gt; &lt;code&gt;[-(D+1), D]&lt;/code&gt; (포함) 범위에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9c8cacca8698bf82625320d9b131a8bbb189fa16" translate="yes" xml:space="preserve">
          <source>Integer specifying the number of times to read through the dataset. If None, cycles through the dataset forever. Defaults to &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">데이터 세트를 읽을 횟수를 지정하는 정수입니다. None이면 데이터 세트를 영원히 순환합니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="48ed15721d2c6d90008e99eaa483ba3f10bfd42a" translate="yes" xml:space="preserve">
          <source>Integer specifying the ragged rank for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. Must be greater than zero.</source>
          <target state="translated">반환 된 &lt;code&gt;RaggedTensor&lt;/code&gt; 의 비정형 순위를 지정하는 정수 입니다. 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="6519af9839eeba13e1e3740388939a4fa489a7c0" translate="yes" xml:space="preserve">
          <source>Integer, axis along which the softmax normalization is applied.</source>
          <target state="translated">소프트 맥스 정규화가 적용되는 정수, 축.</target>
        </trans-unit>
        <trans-unit id="4d462894a57295d00bad79d961363f1631df9a74" translate="yes" xml:space="preserve">
          <source>Integer, expected rank of the input.</source>
          <target state="translated">입력의 예상 순위 인 정수입니다.</target>
        </trans-unit>
        <trans-unit id="a62aa1ce6b98f050a623a72f064615f7ebaa28d3" translate="yes" xml:space="preserve">
          <source>Integer, how many top-guesses to return. Defaults to 5.</source>
          <target state="translated">정수, 반환 할 최고 추측 수입니다. 기본값은 5입니다.</target>
        </trans-unit>
        <trans-unit id="3611bec378f4b1d08160ba75818e35ce0f93549b" translate="yes" xml:space="preserve">
          <source>Integer, index of batch within the current epoch.</source>
          <target state="translated">정수, 현재 시대 내 배치의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="49d62c86ad8d866ffc788d8720b66c0f5e1be2cd" translate="yes" xml:space="preserve">
          <source>Integer, index of epoch.</source>
          <target state="translated">정수, 에포크 인덱스.</target>
        </trans-unit>
        <trans-unit id="e1d657f1197d0e928e79d10b7b8d03e4e1ddc001" translate="yes" xml:space="preserve">
          <source>Integer, index of layer.</source>
          <target state="translated">정수, 레이어 인덱스.</target>
        </trans-unit>
        <trans-unit id="7b561718573e7177a1eac4fbcbc3cc498d676fdb" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric.</source>
          <target state="translated">@k 메트릭의 경우 정수, k.</target>
        </trans-unit>
        <trans-unit id="7e1b6cc9500ca213cd3d0d99297a95ed6f3fd50e" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric. Only used for the default op name.</source>
          <target state="translated">@k 메트릭의 경우 정수, k. 기본 작업 이름에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="52761a9a4283c1bc429a5480ab3ec7776b2ca8db" translate="yes" xml:space="preserve">
          <source>Integer, k for @k metric. This will calculate an average precision for range &lt;code&gt;[1,k]&lt;/code&gt;, as documented above.</source>
          <target state="translated">@k 메트릭의 경우 정수, k. 위에 설명 된대로 범위 &lt;code&gt;[1,k]&lt;/code&gt; 의 평균 정밀도를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7dd36e6413d49b9537f7506be11f776c7d3c71a0" translate="yes" xml:space="preserve">
          <source>Integer, maximum rank of the input.</source>
          <target state="translated">정수, 입력의 최대 순위.</target>
        </trans-unit>
        <trans-unit id="e08ffbff16740d8bc9516f3946ce07004cac1737" translate="yes" xml:space="preserve">
          <source>Integer, minimum rank of the input.</source>
          <target state="translated">입력의 정수, 최소 순위입니다.</target>
        </trans-unit>
        <trans-unit id="fc9adb0e2ec41b5e471885175b1bf95f7edf8655" translate="yes" xml:space="preserve">
          <source>Integer, number of classes to consider.</source>
          <target state="translated">고려할 클래스의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="d27732837f81f5463d8f22501064a789937c5355" translate="yes" xml:space="preserve">
          <source>Integer, number of epochs to iterate over data. If &lt;code&gt;None&lt;/code&gt; will run forever.</source>
          <target state="translated">정수, 데이터를 반복 할 Epoch 수입니다. 경우 &lt;code&gt;None&lt;/code&gt; 영원히 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="756d2f5bfa1491c14c543cdef058099c4a02c7b9" translate="yes" xml:space="preserve">
          <source>Integer, number of rows/columns.</source>
          <target state="translated">정수, 행 / 열 수.</target>
        </trans-unit>
        <trans-unit id="8d1f994bd3e44dc5bab28185ee0d3ebc20ffca14" translate="yes" xml:space="preserve">
          <source>Integer, number of threads used for reading and enqueueing. In order to have predicted and repeatable order of reading and enqueueing, such as in prediction and evaluation mode, &lt;code&gt;num_threads&lt;/code&gt; should be 1.</source>
          <target state="translated">읽기 및 대기열에 넣는 데 사용되는 정수, 스레드 수입니다. 예측 및 평가 모드에서와 같이 예측 및 반복 가능한 읽기 및 대기열 삽입 순서를 가지려면 &lt;code&gt;num_threads&lt;/code&gt; 가 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="18288dd031d517cfdcd834085b33c2abfce77bab" translate="yes" xml:space="preserve">
          <source>Integer, optional number of classes to classify images into, only to be specified if &lt;code&gt;include_top&lt;/code&gt; is True, and if no &lt;code&gt;weights&lt;/code&gt; argument is specified.</source>
          <target state="translated">이미지를 분류 할 클래스의 선택적 수인 정수이며 &lt;code&gt;include_top&lt;/code&gt; 이 True이고 &lt;code&gt;weights&lt;/code&gt; 인수가 지정 되지 않은 경우에만 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cf1871917c279bfb78ebdc3c2e0743674ed63b10" translate="yes" xml:space="preserve">
          <source>Integer, or None. Factor by which to downscale. E.g. 2 will halve the input. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="translated">정수 또는 없음. 축소 할 요인. 예를 들어 2는 입력을 절반으로 줄입니다. None이면 기본값은 &lt;code&gt;pool_size&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ed9c65455c7ec7abdfccef38a621dc178eac27f2" translate="yes" xml:space="preserve">
          <source>Integer, or None. Specifies how much the pooling window moves for each pooling step. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="translated">정수 또는 없음. 각 풀링 단계에 대해 풀링 창이 이동하는 정도를 지정합니다. None이면 기본값은 &lt;code&gt;pool_size&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="83b1cb642daf858515eca24974112fed3f4eda5c" translate="yes" xml:space="preserve">
          <source>Integer, random seed.</source>
          <target state="translated">정수, 임의의 시드.</target>
        </trans-unit>
        <trans-unit id="5520bbbf4a96e6a5c4b5b06bd200711c43958c41" translate="yes" xml:space="preserve">
          <source>Integer, random seed. Will use a random numpy integer when not specified.</source>
          <target state="translated">정수, 임의의 시드. 지정되지 않은 경우 임의의 numpy 정수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="968237390c8614c7a696335a1225258fb805d241" translate="yes" xml:space="preserve">
          <source>Integer, repetition factor.</source>
          <target state="translated">정수, 반복 인자.</target>
        </trans-unit>
        <trans-unit id="264e939c19b3f58405d2a50cba3a1680fb5e9096" translate="yes" xml:space="preserve">
          <source>Integer, size of a batch.</source>
          <target state="translated">정수, 배치 크기.</target>
        </trans-unit>
        <trans-unit id="6c1a622ea56d7a867dad89ba08cf28b246d08f31" translate="yes" xml:space="preserve">
          <source>Integer, size of batches to return.</source>
          <target state="translated">반환 할 배치의 정수, 크기입니다.</target>
        </trans-unit>
        <trans-unit id="7832b33757b55335554c75f07149fc0123c05315" translate="yes" xml:space="preserve">
          <source>Integer, size of queue to accumulate.</source>
          <target state="translated">누적 할 큐의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="73acbfd02c64cde7c7d343aff1fa25e08d1cb5ef" translate="yes" xml:space="preserve">
          <source>Integer, size of the average pooling windows.</source>
          <target state="translated">정수, 평균 풀링 창의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8bfa7ccddd5c7b3f54d3e32cc02d165c9b48661f" translate="yes" xml:space="preserve">
          <source>Integer, size of the max pooling window.</source>
          <target state="translated">정수, 최대 풀링 창의 크기.</target>
        </trans-unit>
        <trans-unit id="2ed72656810565497136a688b72e432ebfed4fb3" translate="yes" xml:space="preserve">
          <source>Integer, the axis that should be normalized (typically the features axis). For instance, after a &lt;code&gt;Conv2D&lt;/code&gt; layer with &lt;code&gt;data_format=&quot;channels_first&quot;&lt;/code&gt;, set &lt;code&gt;axis=1&lt;/code&gt; in &lt;code&gt;BatchNormalization&lt;/code&gt;.</source>
          <target state="translated">정수, 정규화해야하는 축 (일반적으로 기능 축). 예를 들어 &lt;code&gt;data_format=&quot;channels_first&quot;&lt;/code&gt; 인 &lt;code&gt;Conv2D&lt;/code&gt; 레이어 뒤에 BatchNormalization 에서 &lt;code&gt;axis=1&lt;/code&gt; 을 &lt;code&gt;BatchNormalization&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="020ea74d267152d1abff3869457ed35e7f440945" translate="yes" xml:space="preserve">
          <source>Integer, the axis that should be normalized. (typically the features axis).</source>
          <target state="translated">정수, 정규화되어야하는 축. (일반적으로 기능 축).</target>
        </trans-unit>
        <trans-unit id="a6a43ff40e1f9e474e4c712af800f92e564d4913" translate="yes" xml:space="preserve">
          <source>Integer, the dimensionality of the output space (i.e. the number of filters in the convolution).</source>
          <target state="translated">정수, 출력 공간의 차원 (예 : 컨볼 루션의 필터 수).</target>
        </trans-unit>
        <trans-unit id="b610dfd9ecc1049624b3de2024a90db568d1cf07" translate="yes" xml:space="preserve">
          <source>Integer, the dimensionality of the output space (i.e. the number of output filters in the convolution).</source>
          <target state="translated">정수, 출력 공간의 차원 (예 : 컨볼 루션의 출력 필터 수).</target>
        </trans-unit>
        <trans-unit id="d8819f86173a8bca874d8aee9f0470a39d17dbfe" translate="yes" xml:space="preserve">
          <source>Integer, the height of the output shape.</source>
          <target state="translated">정수, 출력 모양의 높이.</target>
        </trans-unit>
        <trans-unit id="3e17f88143adecb575931142178922e1f292bca6" translate="yes" xml:space="preserve">
          <source>Integer, the number of scalars in &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">정수에서 스칼라의 수 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26487eb49125ef03870c0b659a881b807b193aa6" translate="yes" xml:space="preserve">
          <source>Integer, the width of the output shape.</source>
          <target state="translated">정수, 출력 도형의 너비.</target>
        </trans-unit>
        <trans-unit id="1bd273ac6a47ca8cb36aefa50612c554a6d42ca7" translate="yes" xml:space="preserve">
          <source>Integer, tuple of 2 integers, or None. Strides values. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="translated">정수, 2 개 정수의 튜플 또는 없음. 걸음 가치. None이면 기본값은 &lt;code&gt;pool_size&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a05e7e32a0a856148bde05e620e4a31af13622d8" translate="yes" xml:space="preserve">
          <source>Integer, tuple of 2 integers, or None. Strides values. Specifies how far the pooling window moves for each pooling step. If None, it will default to &lt;code&gt;pool_size&lt;/code&gt;.</source>
          <target state="translated">정수, 2 개 정수의 튜플 또는 없음. 걸음 가치. 각 풀링 단계에 대해 풀링 창이 이동하는 거리를 지정합니다. None이면 기본값은 &lt;code&gt;pool_size&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a9fbd2feec40ae60d2527e32c4735ba4f6949693" translate="yes" xml:space="preserve">
          <source>Integer. Dimension of the dense embedding.</source>
          <target state="translated">정수. 고밀도 임베딩의 치수입니다.</target>
        </trans-unit>
        <trans-unit id="af39051e9e4b562c28e9a14aea3e781886cc1d8d" translate="yes" xml:space="preserve">
          <source>Integer. Epoch at which to start training (useful for resuming a previous training run).</source>
          <target state="translated">정수. 훈련을 시작할 Epoch (이전 훈련 실행을 재개하는 데 유용함).</target>
        </trans-unit>
        <trans-unit id="2829e20dc8a95a905ae11cb111c6f5ce9e14cab2" translate="yes" xml:space="preserve">
          <source>Integer. If specified, refers to a dimension of the input tensor, such that quantization will be per slice along that dimension.</source>
          <target state="translated">정수. 지정된 경우 입력 텐서의 차원을 참조하여 양자화가 해당 차원을 따라 슬라이스 당 수행되도록합니다.</target>
        </trans-unit>
        <trans-unit id="155a6c0384cc7d6005f32e2cdc3809924edbbb8b" translate="yes" xml:space="preserve">
          <source>Integer. Number of epochs to train the model. An epoch is an iteration over the entire &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; data provided. Note that in conjunction with &lt;code&gt;initial_epoch&lt;/code&gt;, &lt;code&gt;epochs&lt;/code&gt; is to be understood as &quot;final epoch&quot;. The model is not trained for a number of iterations given by &lt;code&gt;epochs&lt;/code&gt;, but merely until the epoch of index &lt;code&gt;epochs&lt;/code&gt; is reached.</source>
          <target state="translated">정수. 모델을 훈련 할 Epoch 수입니다. 에포크는 제공된 전체 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 데이터에 대한 반복 입니다. 와 함께 유의 &lt;code&gt;initial_epoch&lt;/code&gt; , &lt;code&gt;epochs&lt;/code&gt; &quot;최종 에폭&quot;으로서 이해되어야한다. 모델은 &lt;code&gt;epochs&lt;/code&gt; 에 의해 주어진 여러 반복에 대해 학습 되지 않고 단지 인덱스 &lt;code&gt;epochs&lt;/code&gt; 의 epoch까지만 학습됩니다. 에 도달 .</target>
        </trans-unit>
        <trans-unit id="65631ff0724feabaccec4abc08da39ab086c3adc" translate="yes" xml:space="preserve">
          <source>Integer. Size of the queue for pending events and summaries.</source>
          <target state="translated">정수. 보류중인 이벤트 및 요약에 대한 대기열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="38ed747fc26142e27c2c7f14fa48a57b250a55b1" translate="yes" xml:space="preserve">
          <source>Integer. Size of the vocabulary, i.e. maximum integer index + 1.</source>
          <target state="translated">정수. 어휘의 크기, 즉 최대 정수 인덱스 + 1</target>
        </trans-unit>
        <trans-unit id="68da2a75ba273567e4ed4a88dd4f1b24839014f8" translate="yes" xml:space="preserve">
          <source>Integer. Upsampling factor.</source>
          <target state="translated">정수. 업 샘플링 인자.</target>
        </trans-unit>
        <trans-unit id="86b26edd58891203d3630f5778a3b8ce101f4387" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="translated">정수. 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 입력에만 사용됩니다. 프로세스 기반 스레딩을 사용할 때 스핀 업할 최대 프로세스 수입니다. 지정되지 않은 경우 &lt;code&gt;workers&lt;/code&gt; 는 기본적으로 1로 설정됩니다. 0이면 메인 스레드에서 생성기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="3e1dd01fbd0a0e315fb17382ec430a1e09ccd62f" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;../utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="translated">정수. 생성기 또는 &lt;a href=&quot;../utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 입력에만 사용됩니다. 생성기 대기열의 최대 크기입니다. 지정하지 않으면 &lt;code&gt;max_queue_size&lt;/code&gt; 의 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="15a95c0266c9ac916ee83cc2715cb7f4a9453c87" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum number of processes to spin up when using process-based threading. If unspecified, &lt;code&gt;workers&lt;/code&gt; will default to 1. If 0, will execute the generator on the main thread.</source>
          <target state="translated">정수. 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 입력에만 사용됩니다. 프로세스 기반 스레딩을 사용할 때 스핀 업할 최대 프로세스 수입니다. 지정되지 않은 경우 &lt;code&gt;workers&lt;/code&gt; 는 기본적으로 1로 설정됩니다. 0이면 메인 스레드에서 생성기를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="026625dde93ca9f9da22c49466b3704e8d8d9ede" translate="yes" xml:space="preserve">
          <source>Integer. Used for generator or &lt;a href=&quot;utils/sequence&quot;&gt;&lt;code&gt;keras.utils.Sequence&lt;/code&gt;&lt;/a&gt; input only. Maximum size for the generator queue. If unspecified, &lt;code&gt;max_queue_size&lt;/code&gt; will default to 10.</source>
          <target state="translated">정수. 생성기 또는 &lt;a href=&quot;utils/sequence&quot;&gt; &lt;code&gt;keras.utils.Sequence&lt;/code&gt; &lt;/a&gt; 입력에만 사용됩니다. 생성기 대기열의 최대 크기입니다. 지정하지 않으면 &lt;code&gt;max_queue_size&lt;/code&gt; 의 기본값은 10입니다.</target>
        </trans-unit>
        <trans-unit id="10ef96833f4704c59b53b19fc9aaaf4497588d54" translate="yes" xml:space="preserve">
          <source>Integer. Used to create a random seed.</source>
          <target state="translated">정수. 임의의 시드를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="46fe9ca590793172ed8cbbdd39a8aa90fd85af4d" translate="yes" xml:space="preserve">
          <source>Intended for &quot;grouping&quot; multiple checkpoints in a sharded checkpoint setup.</source>
          <target state="translated">분할 된 체크 포인트 설정에서 여러 체크 포인트를 &quot;그룹화&quot;하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1c415d05fde4b20fb3d078c3ec3eea128c860727" translate="yes" xml:space="preserve">
          <source>Intended for use in gradient code which might deal with &lt;code&gt;IndexedSlices&lt;/code&gt; objects, which are easy to multiply by a scalar but more expensive to multiply with arbitrary tensors.</source>
          <target state="translated">스칼라로 쉽게 곱할 수 있지만 임의의 텐서와 곱하기에는 더 비싼 &lt;code&gt;IndexedSlices&lt;/code&gt; 객체를 처리 할 수있는 그래디언트 코드에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="09de4915cfc5e9dec66a0e4b3cf98d49d13a1bf5" translate="yes" xml:space="preserve">
          <source>Interface for listeners that take action before or after checkpoint save.</source>
          <target state="translated">체크 포인트 저장 전후에 조치를 취하는 리스너에 대한 인터페이스.</target>
        </trans-unit>
        <trans-unit id="7966d1ee34aecdadb5e17da45b8dc52964483fe6" translate="yes" xml:space="preserve">
          <source>Interface for the head/top of a model.</source>
          <target state="translated">모델의 헤드 / 톱 인터페이스.</target>
        </trans-unit>
        <trans-unit id="970dc6a3a66245c62ed217c2880dacf860847f5f" translate="yes" xml:space="preserve">
          <source>Interface representing a stateful summary writer object.</source>
          <target state="translated">상태 저장 요약 작성기 객체를 나타내는 인터페이스.</target>
        </trans-unit>
        <trans-unit id="267b20fba551cfdfeaade8ce47b964dcb7474511" translate="yes" xml:space="preserve">
          <source>Interleave the values from the &lt;code&gt;data&lt;/code&gt; tensors into a single tensor.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 텐서 의 값을 단일 텐서에 인터리브하십시오 .</target>
        </trans-unit>
        <trans-unit id="9d395369c8c508d85c7ffcfcd89cd26ab4bce1e5" translate="yes" xml:space="preserve">
          <source>InterleaveDataset</source>
          <target state="translated">InterleaveDataset</target>
        </trans-unit>
        <trans-unit id="dfeb3be591d4b480789b9b8465a40c757f82e1e8" translate="yes" xml:space="preserve">
          <source>Internal helper function for 'sp_t / dense_t'.</source>
          <target state="translated">'sp_t / dense_t'에 대한 내부 도우미 기능.</target>
        </trans-unit>
        <trans-unit id="e702c08b377f90299d4d1edf33ea46f8d70ab908" translate="yes" xml:space="preserve">
          <source>Internal scopes and variable names should not depend on any arguments that are not supplied to &lt;code&gt;make_template&lt;/code&gt;. In general you will get a ValueError telling you that you are trying to reuse a variable that doesn't exist if you make a mistake.</source>
          <target state="translated">내부 범위와 변수 이름은 &lt;code&gt;make_template&lt;/code&gt; 에 제공되지 않은 인수에 의존해서는 안됩니다 . 일반적으로 실수를하면 존재하지 않는 변수를 재사용하려고한다는 ValueError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a8a9d8482fb70d4cb98a40c92c111baaae956ec4" translate="yes" xml:space="preserve">
          <source>Internally, &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; can build more than one graph, to support arguments with different data types or shapes, since TensorFlow can build more efficient graphs that are specialized on shapes and dtypes. &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; also treats any pure Python value as opaque objects, and builds a separate graph for each set of Python arguments that it encounters.</source>
          <target state="translated">내부적으로 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 은 여러 데이터 유형 또는 모양의 인수를 지원하기 위해 둘 이상의 그래프를 작성할 수 있습니다. TensorFlow는 모양 및 dtype에 특화된보다 효율적인 그래프를 작성할 수 있기 때문입니다. &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 은 또한 순수한 Python 값을 불투명 한 객체로 취급하고, 발생하는 각 Python 인수 세트에 대해 별도의 그래프를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="3754c7a802c267bca9422c11ea6f0ba375d68725" translate="yes" xml:space="preserve">
          <source>Internally, &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; adds outside compilation attributes to all ops in &lt;code&gt;computation&lt;/code&gt;. During later graph pass, these ops with outside compilation attribute is extracted out and replicated into a host-side graph. Inputs to this extract host-side graph is sent from TPU computation graph to host graph via a pair of XlaSendToHost and XlaRecvFromHost ops. Note that using &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; may result in tensor transfer between TPU and CPU, leading to non-trivial performance impact.</source>
          <target state="translated">내부적으로 &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; 은 &lt;code&gt;computation&lt;/code&gt; 모든 op에 외부 컴파일 속성을 추가합니다 . 나중에 그래프를 통과하는 동안 외부 컴파일 속성을 가진 이러한 op가 추출되어 호스트 측 그래프로 복제됩니다. 이 추출 호스트 측 그래프에 대한 입력은 XlaSendToHost 및 XlaRecvFromHost ops 쌍을 통해 TPU 계산 그래프에서 호스트 그래프로 전송됩니다. &lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; 을 사용 하면 TPU와 CPU간에 텐서 전송이 발생하여 사소한 성능 영향을 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3b11c4a32c583b06a946fb7dece277cfaecec4c" translate="yes" xml:space="preserve">
          <source>Internally, a &lt;code&gt;RaggedTensor&lt;/code&gt; consists of a concatenated list of values that are partitioned into variable-length rows. In particular, each &lt;code&gt;RaggedTensor&lt;/code&gt; consists of:</source>
          <target state="translated">내부적으로 &lt;code&gt;RaggedTensor&lt;/code&gt; 는 가변 길이 행으로 분할 된 연결된 값 목록으로 구성됩니다. 특히 각 &lt;code&gt;RaggedTensor&lt;/code&gt; 는 다음으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="255d2ec4d3c0d9058219b6e2356af764fe41dab1" translate="yes" xml:space="preserve">
          <source>Internally, images are either stored in as one &lt;code&gt;float32&lt;/code&gt; per channel per pixel (implicitly, values are assumed to lie in &lt;code&gt;[0,1)&lt;/code&gt;) or one &lt;code&gt;uint8&lt;/code&gt; per channel per pixel (values are assumed to lie in &lt;code&gt;[0,255]&lt;/code&gt;).</source>
          <target state="translated">내부적으로 이미지는 픽셀 당 채널당 하나의 &lt;code&gt;float32&lt;/code&gt; (암시 적으로 값은 &lt;code&gt;[0,1)&lt;/code&gt; 에있는 것으로 가정 ) 또는 픽셀 당 채널당 하나의 &lt;code&gt;uint8&lt;/code&gt; (값은 &lt;code&gt;[0,255]&lt;/code&gt; 에있는 것으로 가정 )에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="39d19ba05c07ee939684f9bc5632fa152a3e99c6" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;../../../nn/conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; is reshaped to &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt;, and the filter is reshaped to &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt;. The result is then reshaped back to &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">내부적으로이 연산은 입력 텐서를 재구성하고 &lt;a href=&quot;../../../nn/conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 예를 들어 &lt;code&gt;data_format&lt;/code&gt; 이 &quot;NC&quot;로 시작하지 않으면 &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; 모양의 텐서 가 &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt; 로 다시 형성되고 필터는 &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt; . 결과는 다시 &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (out_width는 conv2d에서와 같이 stride 및 padding의 함수 임)로 다시 형성되고 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ccc43cd3b01644683dd7e060724d61cbe55125e2" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;../../../nn/conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape [batch, in_width, in_channels] is reshaped to [batch, 1, in_width, in_channels], and the filter is reshaped to [1, filter_width, in_channels, out_channels]. The result is then reshaped back to [batch, out_width, out_channels] (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">내부적으로이 op는 입력 텐서를 재구성하고 &lt;a href=&quot;../../../nn/conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 예를 들어 &lt;code&gt;data_format&lt;/code&gt; 이 &quot;NC&quot;로 시작하지 않으면 [batch, in_width, in_channels] 모양의 텐서가 [batch, 1, in_width, in_channels]로 재구성되고 필터는 [1, filter_width, in_channels, out_channels]. 그런 다음 결과는 [batch, out_width, out_channels] (여기서 out_width는 conv2d에서 보폭과 패딩의 함수 임)로 다시 모양이 바뀌고 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7c69ad0876e39d22ce51635e4a30f9a378a7dbe4" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &quot;NC&quot;, a tensor of shape [batch, in_width, in_channels] is reshaped to [batch, 1, in_width, in_channels], and the filter is reshaped to [1, filter_width, in_channels, out_channels]. The result is then reshaped back to [batch, out_width, out_channels] (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">내부적으로이 op는 입력 텐서를 재구성하고 &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 예를 들어 &lt;code&gt;data_format&lt;/code&gt; 이 &quot;NC&quot;로 시작하지 않으면 [batch, in_width, in_channels] 모양의 텐서가 [batch, 1, in_width, in_channels]로 재구성되고 필터는 [1, filter_width, in_channels, out_channels]. 그런 다음 결과는 [batch, out_width, out_channels] (여기서 out_width는 conv2d에서 보폭과 패딩의 함수 임)로 다시 모양이 바뀌고 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="77366db31216abb65fcc3e1ddedf30536706afa8" translate="yes" xml:space="preserve">
          <source>Internally, this op reshapes the input tensors and invokes &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;tf.nn.conv2d&lt;/code&gt;&lt;/a&gt;. For example, if &lt;code&gt;data_format&lt;/code&gt; does not start with &lt;code&gt;&quot;NC&quot;&lt;/code&gt;, a tensor of shape &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; is reshaped to &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt;, and the filter is reshaped to &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt;. The result is then reshaped back to &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (where out_width is a function of the stride and padding as in conv2d) and returned to the caller.</source>
          <target state="translated">내부적으로이 연산은 입력 텐서를 재구성하고 &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;tf.nn.conv2d&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 예를 들어 &lt;code&gt;data_format&lt;/code&gt; 이 &lt;code&gt;&quot;NC&quot;&lt;/code&gt; 로 시작하지 않으면 &lt;code&gt;batch_shape + [in_width, in_channels]&lt;/code&gt; 모양의 텐서 가 &lt;code&gt;batch_shape + [1, in_width, in_channels]&lt;/code&gt; 로 모양이 변경되고 필터는 &lt;code&gt;[1, filter_width, in_channels, out_channels]&lt;/code&gt; . 결과는 다시 &lt;code&gt;batch_shape + [out_width, out_channels]&lt;/code&gt; (out_width는 conv2d에서와 같이 stride 및 padding의 함수 임)로 다시 형성되고 호출자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="917c90b98804c8a00e2f1f77d52497e6cc4c5478" translate="yes" xml:space="preserve">
          <source>Interpolation formula inspired by section 4 of Davis &amp;amp; Goadrich 2006.</source>
          <target state="translated">Davis &amp;amp; Goadrich 2006의 섹션 4에서 영감을 얻은 보간 공식.</target>
        </trans-unit>
        <trans-unit id="eff3de259388706cb8f11066e0a617e4e6f361f0" translate="yes" xml:space="preserve">
          <source>Interpolation method used to resample the image if the target size is different from that of the loaded image. Supported methods are &quot;nearest&quot;, &quot;bilinear&quot;, and &quot;bicubic&quot;. If PIL version 1.1.3 or newer is installed, &quot;lanczos&quot; is also supported. If PIL version 3.4.0 or newer is installed, &quot;box&quot; and &quot;hamming&quot; are also supported. By default, &quot;nearest&quot; is used.</source>
          <target state="translated">대상 크기가로드 된 이미지의 크기와 다른 경우 이미지를 다시 샘플링하는 데 사용되는 보간 방법입니다. 지원되는 방법은 &quot;nearest&quot;, &quot;bilinear&quot;및 &quot;bicubic&quot;입니다. PIL 버전 1.1.3 이상이 설치된 경우 &quot;lanczos&quot;도 지원됩니다. PIL 버전 3.4.0 이상이 설치된 경우 &quot;box&quot;및 &quot;hamming&quot;도 지원됩니다. 기본적으로 &quot;nearest&quot;가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c6a83be95e3b71f9242daf3a730745b97d6a8590" translate="yes" xml:space="preserve">
          <source>Interpolation method used to resample the image if the target size is different from that of the loaded image. Supported methods are &lt;code&gt;&quot;nearest&quot;&lt;/code&gt;, &lt;code&gt;&quot;bilinear&quot;&lt;/code&gt;, and &lt;code&gt;&quot;bicubic&quot;&lt;/code&gt;. If PIL version 1.1.3 or newer is installed, &lt;code&gt;&quot;lanczos&quot;&lt;/code&gt; is also supported. If PIL version 3.4.0 or newer is installed, &lt;code&gt;&quot;box&quot;&lt;/code&gt; and &lt;code&gt;&quot;hamming&quot;&lt;/code&gt; are also supported. By default, &lt;code&gt;&quot;nearest&quot;&lt;/code&gt; is used.</source>
          <target state="translated">대상 크기가로드 된 이미지의 크기와 다른 경우 이미지를 다시 샘플링하는 데 사용되는 보간 방법입니다. 지원되는 방법은 &lt;code&gt;&quot;nearest&quot;&lt;/code&gt; , &lt;code&gt;&quot;bilinear&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;bicubic&quot;&lt;/code&gt; 입니다. PIL 버전 1.1.3 이상이 설치된 경우 &lt;code&gt;&quot;lanczos&quot;&lt;/code&gt; 도 지원됩니다. PIL 버전 3.4.0 이상이 설치된 경우 &lt;code&gt;&quot;box&quot;&lt;/code&gt; 및 &lt;code&gt;&quot;hamming&quot;&lt;/code&gt; 도 지원됩니다. 기본적으로 &lt;code&gt;&quot;nearest&quot;&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d41d1157db67f4ae8d3353790336143377bd1fb" translate="yes" xml:space="preserve">
          <source>Interpolation mode. Supported values: &quot;nearest&quot;, &quot;bilinear&quot;.</source>
          <target state="translated">보간 모드. 지원되는 값 : &quot;nearest&quot;, &quot;bilinear&quot;.</target>
        </trans-unit>
        <trans-unit id="4b1b48a15bee98562ab2271bf7c674c69c76f9d7" translate="yes" xml:space="preserve">
          <source>Interpreter interface for TensorFlow Lite Models.</source>
          <target state="translated">TensorFlow Lite 모델의 인터프리터 인터페이스.</target>
        </trans-unit>
        <trans-unit id="cd0dc8bec74842908edb1323c813960ee0d10418" translate="yes" xml:space="preserve">
          <source>Intuitively, separable convolutions can be understood as a way to factorize a convolution kernel into two smaller kernels, or as an extreme version of an Inception block.</source>
          <target state="translated">직관적으로, 분리 가능한 컨벌루션은 컨볼 루션 커널을 두 개의 작은 커널로 분해하는 방법 또는 익셉션 블록의 극단적 인 버전으로 이해 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e82e41a0aefa660a1c7caa85a3e51aff86500f3e" translate="yes" xml:space="preserve">
          <source>Inv</source>
          <target state="translated">Inv</target>
        </trans-unit>
        <trans-unit id="4f28f8a2e4fbc807a9598103ca92496ec62e9283" translate="yes" xml:space="preserve">
          <source>InvGrad</source>
          <target state="translated">InvGrad</target>
        </trans-unit>
        <trans-unit id="58add683489305dc7550dd9711b45a710de33407" translate="yes" xml:space="preserve">
          <source>Invalid &lt;code&gt;PhysicalDevice&lt;/code&gt; specified.</source>
          <target state="translated">잘못된 &lt;code&gt;PhysicalDevice&lt;/code&gt; 가 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="765dc4833ea51f9712325654e6149e4320ae0357" translate="yes" xml:space="preserve">
          <source>Invalid IDs (&amp;lt; 0) are pruned from input IDs and weights, as well as any IDs with non-positive weight. For an entry with no features, the embedding vector for &lt;code&gt;default_id&lt;/code&gt; is returned, or the 0-vector if &lt;code&gt;default_id&lt;/code&gt; is not supplied.</source>
          <target state="translated">유효하지 않은 ID (&amp;lt;0)는 입력 ID 및 가중치와 양수가 아닌 ID에서 정리됩니다. 기능이없는 항목의 경우 &lt;code&gt;default_id&lt;/code&gt; 에 대한 포함 벡터 가 반환되거나 &lt;code&gt;default_id&lt;/code&gt; 가 제공되지 않으면 0- 벡터가 반환 됩니다.</target>
        </trans-unit>
        <trans-unit id="c83be98b0df67b85dda471c4f0e08d9948550727" translate="yes" xml:space="preserve">
          <source>Invalid arguments.</source>
          <target state="translated">잘못된 인수입니다.</target>
        </trans-unit>
        <trans-unit id="7227e77ba4898ce78f530c7179daf1d58aee3eba" translate="yes" xml:space="preserve">
          <source>Invalid input type.</source>
          <target state="translated">입력 유형이 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="5ad0fc9e3c1773fd6f82ccad6e0477a808a3ba38" translate="yes" xml:space="preserve">
          <source>Invalid signature keys.</source>
          <target state="translated">잘못된 서명 키.</target>
        </trans-unit>
        <trans-unit id="0bc32d3cdc428cf1f9b21217961b07a8ba0776de" translate="yes" xml:space="preserve">
          <source>InvalidArgumentError: When &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have incomptatible shapes or types.</source>
          <target state="translated">InvalidArgumentError : &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 호환되지 않는 모양 또는 유형이있는 경우.</target>
        </trans-unit>
        <trans-unit id="b0224cb82fac3bd64320723e2cfea88c4cb1de8e" translate="yes" xml:space="preserve">
          <source>Inverse 2D fast Fourier transform.</source>
          <target state="translated">역 2D 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="f86113a2dbd7ed935c16e9099b42fb7e6dba6038" translate="yes" xml:space="preserve">
          <source>Inverse 2D real-valued fast Fourier transform.</source>
          <target state="translated">역 2D 실수 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="bf6cbaad72f3eb6b8fa736b0c48f1b4b54ba4d45" translate="yes" xml:space="preserve">
          <source>Inverse 3D fast Fourier transform.</source>
          <target state="translated">역 3D 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="729fe142f2358fcfd2d893f486c7ef7071098901" translate="yes" xml:space="preserve">
          <source>Inverse 3D real-valued fast Fourier transform.</source>
          <target state="translated">역 3D 실수 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="2b74c26781dc19d8cf865c887430b83b4bb874bf" translate="yes" xml:space="preserve">
          <source>Inverse error function of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 오차 함수 .</target>
        </trans-unit>
        <trans-unit id="2769447bdda650e2de43a09ec7f4f9b88e781719" translate="yes" xml:space="preserve">
          <source>Inverse fast Fourier transform.</source>
          <target state="translated">역 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="59aef4232893465c6aaa96756ca11d4d57c9f509" translate="yes" xml:space="preserve">
          <source>Inverse lookup</source>
          <target state="translated">역 조회</target>
        </trans-unit>
        <trans-unit id="eca1ad1de11fec11fe41231e47070833956358bf" translate="yes" xml:space="preserve">
          <source>Inverse of the &lt;code&gt;serialize&lt;/code&gt; function.</source>
          <target state="translated">&lt;code&gt;serialize&lt;/code&gt; 기능의 역수 .</target>
        </trans-unit>
        <trans-unit id="21739830573f1c06f7716e20676dc8044ac7dbe1" translate="yes" xml:space="preserve">
          <source>Inverse real-valued fast Fourier transform.</source>
          <target state="translated">역 실수 고속 푸리에 변환.</target>
        </trans-unit>
        <trans-unit id="e844690a2086d9678b13582fd4701152c826641f" translate="yes" xml:space="preserve">
          <source>Invert</source>
          <target state="translated">Invert</target>
        </trans-unit>
        <trans-unit id="454fcced1bbd08f2febd8b9e63fda971abd10063" translate="yes" xml:space="preserve">
          <source>Invert (flip) each bit of supported types; for example, type &lt;code&gt;uint8&lt;/code&gt; value 01010101 becomes 10101010.</source>
          <target state="translated">지원되는 각 유형의 비트를 반전 (뒤집기)하십시오. 예를 들어, &lt;code&gt;uint8&lt;/code&gt; 값 01010101 유형 은 10101010이됩니다.</target>
        </trans-unit>
        <trans-unit id="bed096656d7fe5e741cc84abd73ada3bd6383ffb" translate="yes" xml:space="preserve">
          <source>InvertPermutation</source>
          <target state="translated">InvertPermutation</target>
        </trans-unit>
        <trans-unit id="91d644123d1e143b7bcae5cd3ca4411f53cc0582" translate="yes" xml:space="preserve">
          <source>Invoke the interpreter.</source>
          <target state="translated">인터프리터를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="a3b88b5d9fb1f01311b785a98dab39ae651b2e05" translate="yes" xml:space="preserve">
          <source>Invokes a python function to compute func(input)-&amp;gt;output.</source>
          <target state="translated">func (input)-&amp;gt; output을 계산하기 위해 파이썬 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="07bd56502c92792eb48f74185c5de124c19b5f15" translate="yes" xml:space="preserve">
          <source>Invokes the &lt;code&gt;Loss&lt;/code&gt; instance.</source>
          <target state="translated">&lt;code&gt;Loss&lt;/code&gt; 인스턴스 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b13fc57aaccb54faea2366b6fa9ef75d7f668372" translate="yes" xml:space="preserve">
          <source>Is the column count of the product large (&amp;gt;&amp;gt; 1)?</source>
          <target state="translated">제품의 열 수가 많습니까 (&amp;gt;&amp;gt; 1)?</target>
        </trans-unit>
        <trans-unit id="b8d5c82b816bc835c62912b744400ff40c02617e" translate="yes" xml:space="preserve">
          <source>Is the density of &lt;code&gt;A&lt;/code&gt; larger than approximately 15%?</source>
          <target state="translated">&lt;code&gt;A&lt;/code&gt; 의 밀도 가 약 15 %보다 큽니까?</target>
        </trans-unit>
        <trans-unit id="c601bf8fc05bd7645229907978ac2511d637fa1a" translate="yes" xml:space="preserve">
          <source>Is the value of the flag allowed to be None.</source>
          <target state="translated">None이 될 수있는 플래그의 값입니다.</target>
        </trans-unit>
        <trans-unit id="643c612596426f0fec64f232c9d5aef6f88c639b" translate="yes" xml:space="preserve">
          <source>IsBoostedTreesEnsembleInitialized</source>
          <target state="translated">IsBoostedTreesEnsembleInitialized</target>
        </trans-unit>
        <trans-unit id="77075fc1d53795c8c08144c8db26e03533240f78" translate="yes" xml:space="preserve">
          <source>IsBoostedTreesQuantileStreamResourceInitialized</source>
          <target state="translated">IsBoostedTreesQuantileStreamResourceInitialized</target>
        </trans-unit>
        <trans-unit id="12c95b5f06bb33c3c5be9c54bc9046e6da772489" translate="yes" xml:space="preserve">
          <source>IsFinite</source>
          <target state="translated">IsFinite</target>
        </trans-unit>
        <trans-unit id="b3060aaecf7335f09adf39163594f94ba1f28def" translate="yes" xml:space="preserve">
          <source>IsInf</source>
          <target state="translated">IsInf</target>
        </trans-unit>
        <trans-unit id="d0fa60fb2ee6d1b84448737ee8599591dd40c001" translate="yes" xml:space="preserve">
          <source>IsNan</source>
          <target state="translated">IsNan</target>
        </trans-unit>
        <trans-unit id="46d7b64826025485ac80b869ef64ad6ef233f634" translate="yes" xml:space="preserve">
          <source>IsVariableInitialized</source>
          <target state="translated">IsVariableInitialized</target>
        </trans-unit>
        <trans-unit id="e9232fd5729c418e2cf69329c493d9342acec23c" translate="yes" xml:space="preserve">
          <source>Issue tracker</source>
          <target state="translated">이슈 트래커</target>
        </trans-unit>
        <trans-unit id="c555417d6e9840ed1ca167f3f620882b41feafca" translate="yes" xml:space="preserve">
          <source>It accumulates all the values from out_backprop into the feature dimension. For NHWC data format, the feature dimension is the last. For NCHW data format, the feature dimension is the third-to-last.</source>
          <target state="translated">out_backprop의 모든 값을 피쳐 차원으로 누적합니다. NHWC 데이터 형식의 경우 기능 차원이 마지막입니다. NCHW 데이터 형식의 경우 기능 차원은 마지막에서 세 번째입니다.</target>
        </trans-unit>
        <trans-unit id="848468d378f385a5eff1c3e14e7c9c6b9f132b4d" translate="yes" xml:space="preserve">
          <source>It allows a small gradient when the unit is not active:</source>
          <target state="translated">장치가 활성화되지 않은 경우 작은 그라디언트를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="15b30b164c5d405f36fa8233e2a4a5041ac0f62c" translate="yes" xml:space="preserve">
          <source>It allows a small gradient when the unit is not active: &lt;code&gt;f(x) = alpha * x for x &amp;lt; 0&lt;/code&gt;, &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">단위가 활성화되지 않은 경우 작은 기울기를 허용합니다 : &lt;code&gt;f(x) = alpha * x for x &amp;lt; 0&lt;/code&gt; 경우 &lt;code&gt;f(x) = x for x &amp;gt;= 0&lt;/code&gt; alpha * x , x&amp;gt; = 0의 경우 f (x) = x .</target>
        </trans-unit>
        <trans-unit id="32fedff7c0ca1dff1ca98fad88e05d900e06abf4" translate="yes" xml:space="preserve">
          <source>It allows you to take a bunch of TensorFlow ops and annotate the construction such that toco knows how to convert it to tflite. This embeds a pseudo function in a TensorFlow graph. This allows embedding high-level API usage information in a lower level TensorFlow implementation so that an alternative implementation can be substituted later.</source>
          <target state="translated">그것은 당신이 TensorFlow ops의 무리를 가지고 toco가 그것을 tflite로 변환하는 방법을 알 수 있도록 구성에 주석을 달 수 있습니다. 이것은 의사 함수를 TensorFlow 그래프에 포함시킵니다. 이를 통해 하위 레벨 TensorFlow 구현에 고급 API 사용 정보를 임베드하여 나중에 대체 구현을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="476f3a0bb3e98caba9635badab1de855ab2206de" translate="yes" xml:space="preserve">
          <source>It also assumes that all id values lie in the range [0, p0), where p0 is the sum of the size of params along dimension 0.</source>
          <target state="translated">또한 모든 id 값이 [0, p0) 범위에 있다고 가정합니다. 여기서 p0은 차원 0에 따른 매개 변수 크기의 합입니다.</target>
        </trans-unit>
        <trans-unit id="268056cfbb264bea0c41c6a1efa283fdafc29f69" translate="yes" xml:space="preserve">
          <source>It also parses argument as comma-separated list of strings if requested.</source>
          <target state="translated">또한 요청 된 경우 인수를 쉼표로 구분 된 문자열 목록으로 구문 분석합니다.</target>
        </trans-unit>
        <trans-unit id="486eade8a1729dd16d206df5323836f9c26ec548" translate="yes" xml:space="preserve">
          <source>It assigns out-of-vocabulary keys to buckets based in their hashes.</source>
          <target state="translated">어휘를 기반으로 버킷에 어휘가없는 키를 할당합니다.</target>
        </trans-unit>
        <trans-unit id="7a36235a0369fe7b8f72b7109e7cf4f2d22578c2" translate="yes" xml:space="preserve">
          <source>It can also be used with a custom &lt;code&gt;model_fn&lt;/code&gt;. Example:</source>
          <target state="translated">사용자 정의 &lt;code&gt;model_fn&lt;/code&gt; 과 함께 사용할 수도 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d753925b5debe450dc477ca87f5806e3bd88bad5" translate="yes" xml:space="preserve">
          <source>It can also return a subnormal number.</source>
          <target state="translated">또한 비정규 숫자를 반환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69008dcfdf00653df58396b47fd62a5606a4097" translate="yes" xml:space="preserve">
          <source>It can be passed into &lt;a href=&quot;../tpustrategy&quot;&gt;&lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt;&lt;/a&gt; to support TF2 training on Cloud TPUs.</source>
          <target state="translated">Cloud TPU에서 TF2 학습을 지원하기 위해 &lt;a href=&quot;../tpustrategy&quot;&gt; &lt;code&gt;tf.distribute.TPUStrategy&lt;/code&gt; &lt;/a&gt; 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="14d6407e1c3a121bea2730155a982791be2b5c57" translate="yes" xml:space="preserve">
          <source>It can be represented by an Integer, a TensorShape or a tuple of Integers or TensorShapes.</source>
          <target state="translated">Integer, TensorShape 또는 Integers 또는 TensorShapes의 튜플로 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2bfd7eb4e49405ccfcdad2d46274023e1bf999" translate="yes" xml:space="preserve">
          <source>It can be viewed as convenient wrapper of the following code:</source>
          <target state="translated">다음 코드의 편리한 래퍼로 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="851d18a55b1a7d8f809ccad34a86887bc5acef62" translate="yes" xml:space="preserve">
          <source>It can either wrap an existing tensor (pass an &lt;code&gt;input_tensor&lt;/code&gt; argument) or create a placeholder tensor (pass arguments &lt;code&gt;input_shape&lt;/code&gt;, and optionally, &lt;code&gt;dtype&lt;/code&gt;).</source>
          <target state="translated">기존 텐서를 랩핑하거나 ( &lt;code&gt;input_tensor&lt;/code&gt; 인수 전달) 자리 표시 자 텐서를 생성 할 수 있습니다 ( &lt;code&gt;input_shape&lt;/code&gt; 인수 및 선택적으로 &lt;code&gt;dtype&lt;/code&gt; 전달 ).</target>
        </trans-unit>
        <trans-unit id="15ac3bcf9184c700a5153c1382ad28ba06bb3727" translate="yes" xml:space="preserve">
          <source>It crops along spatial dimensions, i.e. height and width.</source>
          <target state="translated">공간 차원, 즉 높이와 너비를 따라 자릅니다.</target>
        </trans-unit>
        <trans-unit id="d2b114021f685a568fa7427074087bbb555c68ea" translate="yes" xml:space="preserve">
          <source>It crops along the time dimension (axis 1).</source>
          <target state="translated">시간 차원을 따라 자릅니다 (축 1).</target>
        </trans-unit>
        <trans-unit id="23e5e7b4e88d6267db0beb6a8ef4742eb7948a30" translate="yes" xml:space="preserve">
          <source>It determines the scale from one of input_min and input_max, then updates the other one to maximize the representable range.</source>
          <target state="translated">input_min 및 input_max 중 하나에서 스케일을 결정한 다음 다른 하나를 업데이트하여 표현 가능한 범위를 최대화합니다.</target>
        </trans-unit>
        <trans-unit id="50c49b5169d29ab097a8aff807662666883b1d66" translate="yes" xml:space="preserve">
          <source>It does not allow cell clipping, a projection layer, and does not use peep-hole connections: it is the basic baseline.</source>
          <target state="translated">셀 클리핑, 투영 레이어를 허용하지 않으며 들여다 보는 구멍 연결을 사용하지 않습니다. 기본 기준선입니다.</target>
        </trans-unit>
        <trans-unit id="6b5f31c782dbbe7c2f3add466394784c60b5c232" translate="yes" xml:space="preserve">
          <source>It doesn't support custom saver logic (such as ExponentialMovingAverage support)</source>
          <target state="translated">커스텀 세이버 로직 (ExponentialMovingAverage 지원 등)은 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="45051dd91200e3bf9ba59dd2436f0164ef584605" translate="yes" xml:space="preserve">
          <source>It doesn't support multi-node distributed mode.</source>
          <target state="translated">다중 노드 분산 모드를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="489f42ddeaa2f25f8e720115125e5a0a2b41d1ec" translate="yes" xml:space="preserve">
          <source>It doesn't support saveable objects other than variables (such as boosted tree support)</source>
          <target state="translated">변수 이외의 저장 가능한 객체 (예 : 부스트 트리 지원)는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80d27c6a3c091aa8b38e2cae300405b91db71c40" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with &lt;code&gt;stddev = sqrt(1 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(1 / fan_in)&lt;/code&gt; 하여 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="b5e99b6e8055bbe5e5eab07a52b329d5a27c1e5d" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with &lt;code&gt;stddev = sqrt(2 / (fan_in + fan_out))&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor and &lt;code&gt;fan_out&lt;/code&gt; is the number of output units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(2 / (fan_in + fan_out))&lt;/code&gt; 하여 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수이고 &lt;code&gt;fan_out&lt;/code&gt; 은 가중치 텐서 의 출력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="a4e494a282bcac9914c8d339f910277f94b89c75" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with &lt;code&gt;stddev = sqrt(2 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(2 / fan_in)&lt;/code&gt; 하여 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="1d4854b6f38f71edebdd9e6527324a084528dc03" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with standard deviation (after truncation) given by &lt;code&gt;stddev = sqrt(1 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(1 / fan_in)&lt;/code&gt; 의해 주어진 표준 편차 (절단 후)를 중심으로 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="706d32c6afa42ca96cd3027b8882b964f42483dc" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with standard deviation (after truncation) given by &lt;code&gt;stddev = sqrt(2 / (fan_in + fan_out))&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor and &lt;code&gt;fan_out&lt;/code&gt; is the number of output units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(2 / (fan_in + fan_out))&lt;/code&gt; 의해 주어진 표준 편차 (절단 후)를 중심으로 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수이고 &lt;code&gt;fan_out&lt;/code&gt; 은 수입니다. 무게 텐서의 출력 단위.</target>
        </trans-unit>
        <trans-unit id="5f33594cfa3f89fac81e308daeac3f28ace4e60f" translate="yes" xml:space="preserve">
          <source>It draws samples from a truncated normal distribution centered on 0 with standard deviation (after truncation) given by &lt;code&gt;stddev = sqrt(2 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">&lt;code&gt;stddev = sqrt(2 / fan_in)&lt;/code&gt; 의해 주어진 표준 편차 (절단 후)를 중심으로 0을 중심으로 잘린 정규 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="c44f8959e90c766cfbd08c0d20f313e9e3b3ed0c" translate="yes" xml:space="preserve">
          <source>It draws samples from a uniform distribution within [-limit, limit] where &lt;code&gt;limit&lt;/code&gt; is &lt;code&gt;sqrt(3 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">[-limit, limit] 내의 균일 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;limit&lt;/code&gt; 은 &lt;code&gt;sqrt(3 / fan_in)&lt;/code&gt; 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="0c37fca6c106b6324e898740a4adc0fc1b97b0ac" translate="yes" xml:space="preserve">
          <source>It draws samples from a uniform distribution within [-limit, limit] where &lt;code&gt;limit&lt;/code&gt; is &lt;code&gt;sqrt(6 / (fan_in + fan_out))&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor and &lt;code&gt;fan_out&lt;/code&gt; is the number of output units in the weight tensor.</source>
          <target state="translated">[-limit, limit] 내의 균일 분포에서 표본을 추출합니다. 여기서 &lt;code&gt;limit&lt;/code&gt; 은 &lt;code&gt;sqrt(6 / (fan_in + fan_out))&lt;/code&gt; 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수이고 &lt;code&gt;fan_out&lt;/code&gt; 은 가중치 의 출력 단위 수입니다. 텐서.</target>
        </trans-unit>
        <trans-unit id="d5718aadde33ef95a3c3b4c608c444a227584762" translate="yes" xml:space="preserve">
          <source>It draws samples from a uniform distribution within [-limit, limit] where &lt;code&gt;limit&lt;/code&gt; is &lt;code&gt;sqrt(6 / fan_in)&lt;/code&gt; where &lt;code&gt;fan_in&lt;/code&gt; is the number of input units in the weight tensor.</source>
          <target state="translated">[-limit, limit] 내의 균일 분포에서 샘플을 추출합니다. 여기서 &lt;code&gt;limit&lt;/code&gt; 은 &lt;code&gt;sqrt(6 / fan_in)&lt;/code&gt; 여기서 &lt;code&gt;fan_in&lt;/code&gt; 은 가중치 텐서의 입력 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="2febf38aad008dd8d426dbf0c0eec923fb762a50" translate="yes" xml:space="preserve">
          <source>It follows the re2 syntax (&lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt;)</source>
          <target state="translated">re2 구문 ( &lt;a href=&quot;https://github.com/google/re2/wiki/Syntax&quot;&gt;https://github.com/google/re2/wiki/Syntax&lt;/a&gt; )을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="2ce5558a20bb38a79c8e709107600e4d5c1bcc0e" translate="yes" xml:space="preserve">
          <source>It follows:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="827600f9ebad20c3d360f7ada83d7c19942edb1c" translate="yes" xml:space="preserve">
          <source>It generates one key-value pair per line. The type of table key and value are specified by &lt;code&gt;key_dtype&lt;/code&gt; and &lt;code&gt;value_dtype&lt;/code&gt;, respectively. Similarly the content of the key and value are specified by the key_index and value_index.</source>
          <target state="translated">행당 하나의 키-값 쌍을 생성합니다. 테이블 키 및 값의 유형은 각각 &lt;code&gt;key_dtype&lt;/code&gt; 및 &lt;code&gt;value_dtype&lt;/code&gt; 에 의해 지정됩니다 . 마찬가지로 키 및 값의 내용은 key_index 및 value_index로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="2a2d379bdfeecbddb9707ada090d34ce0eb68820" translate="yes" xml:space="preserve">
          <source>It has no &lt;code&gt;shape&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 인수 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="2fde7e3aa3c7336499bb0ce7f6c8bfa735f0c7e7" translate="yes" xml:space="preserve">
          <source>It has no semantics. Multiple threads may be given the same name. The initial name is set by the constructor.</source>
          <target state="translated">의미가 없습니다. 여러 스레드에 동일한 이름을 지정할 수 있습니다. 초기 이름은 생성자가 설정합니다.</target>
        </trans-unit>
        <trans-unit id="ed60a4b6265732d2fa03f9b15dad2f0c4814cf0b" translate="yes" xml:space="preserve">
          <source>It inserts one key-value pair into the table for each line of the file. The key and value is extracted from the whole line content, elements from the split line based on &lt;code&gt;delimiter&lt;/code&gt; or the line number (starting from zero). Where to extract the key and value from a line is specified by &lt;code&gt;key_index&lt;/code&gt; and &lt;code&gt;value_index&lt;/code&gt;.</source>
          <target state="translated">파일의 각 행에 대해 하나의 키-값 쌍을 테이블에 삽입합니다. 키와 값은 &lt;code&gt;delimiter&lt;/code&gt; 또는 줄 번호 (0부터 시작)를 기준으로 전체 줄 내용, 분할 줄의 요소에서 추출됩니다 . 행에서 키와 값을 추출 할 위치는 &lt;code&gt;key_index&lt;/code&gt; 및 &lt;code&gt;value_index&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff1533a7a658edcda661aa3acac6f89856e6dad8" translate="yes" xml:space="preserve">
          <source>It is a variant of Adam based on the infinity norm. Default parameters follow those provided in the paper. Adamax is sometimes superior to adam, specially in models with embeddings.</source>
          <target state="translated">그것은 무한대 규범을 기반으로 한 아담의 변형입니다. 기본 매개 변수는 용지에 제공된 매개 변수를 따릅니다. Adamax는 특히 임베딩이있는 모델에서 adam보다 우수합니다.</target>
        </trans-unit>
        <trans-unit id="955c4d5479692fb3fb02dcf43ca1d09989fd795e" translate="yes" xml:space="preserve">
          <source>It is also useful if two separate functions must share a resource, but we wish to ensure the usage is exclusive.</source>
          <target state="translated">두 개의 개별 함수가 하나의 리소스를 공유해야하는 경우에도 유용하지만 사용은 배타적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4e8cf5144bd436ea5d5f7533e412ea077ab03b38" translate="yes" xml:space="preserve">
          <source>It is an alias to &lt;a href=&quot;../../math/reduce_std&quot;&gt;&lt;code&gt;tf.math.reduce_std&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../math/reduce_std&quot;&gt; &lt;code&gt;tf.math.reduce_std&lt;/code&gt; &lt;/a&gt; 의 별칭 입니다.</target>
        </trans-unit>
        <trans-unit id="f0f570f38fd92cf23fa60ef5c841b94dd8f127d9" translate="yes" xml:space="preserve">
          <source>It is an alias to &lt;a href=&quot;../../random/normal&quot;&gt;&lt;code&gt;tf.random.normal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../../random/normal&quot;&gt; &lt;code&gt;tf.random.normal&lt;/code&gt; &lt;/a&gt; 의 별칭 입니다.</target>
        </trans-unit>
        <trans-unit id="6cc1aebb0123c4b4407bc2e3691fc09aa422b356" translate="yes" xml:space="preserve">
          <source>It is an error if &lt;code&gt;shape&lt;/code&gt; is not 1-D.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 이 1-D가 아닌 경우 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="3d404ea6191185d9005bf406cb6c69748b8eec2b" translate="yes" xml:space="preserve">
          <source>It is an error if the model cannot be recovered and no &lt;code&gt;init_op&lt;/code&gt; or &lt;code&gt;init_fn&lt;/code&gt; or &lt;code&gt;local_init_op&lt;/code&gt; are passed.</source>
          <target state="translated">모델을 복구 할 수없고 &lt;code&gt;init_op&lt;/code&gt; , &lt;code&gt;init_fn&lt;/code&gt; 또는 &lt;code&gt;local_init_op&lt;/code&gt; 가 전달 되지 않으면 오류 입니다.</target>
        </trans-unit>
        <trans-unit id="69dae8d4745b98f4c44352740deadff10964a8ba" translate="yes" xml:space="preserve">
          <source>It is an error to set &lt;code&gt;new_shape&lt;/code&gt; as [3, 7] since this represents a rank-2 tensor while &lt;code&gt;sp_input&lt;/code&gt; is rank-3. This is either a ValueError during graph construction (if both shapes are known) or an OpError during run time.</source>
          <target state="translated">그것은 집합 오류라고 &lt;code&gt;new_shape&lt;/code&gt; 같이 3, 7] 동안이 랭크 2 텐서를 나타내므로 &lt;code&gt;sp_input&lt;/code&gt; 가 등급 3이다. 이는 그래프 구성 중 ValueError (두 모양이 모두 알려진 경우)이거나 런타임 중 OpError입니다.</target>
        </trans-unit>
        <trans-unit id="5ccfc49f1d16ffbdbdaecc99b012e0441a365f79" translate="yes" xml:space="preserve">
          <source>It is commonly observed that a monotonically decreasing learning rate, whose degree of change is carefully chosen, results in a better performing model. This function applies a polynomial decay function to a provided initial &lt;code&gt;learning_rate&lt;/code&gt; to reach an &lt;code&gt;end_learning_rate&lt;/code&gt; in the given &lt;code&gt;decay_steps&lt;/code&gt;.</source>
          <target state="translated">변화의 정도를 신중하게 선택한 단조 적으로 감소하는 학습 속도가 더 나은 모델을 만드는 것으로 일반적으로 관찰됩니다. 이 함수는 주어진 &lt;code&gt;decay_steps&lt;/code&gt; 에서 &lt;code&gt;end_learning_rate&lt;/code&gt; 에 도달 하기 위해 제공된 초기 &lt;code&gt;learning_rate&lt;/code&gt; 에 다항식 감쇠 함수를 적용합니다 .</target>
        </trans-unit>
        <trans-unit id="03e5a933480c8e3d46c5c53fb5c1fb8807a8d4c2" translate="yes" xml:space="preserve">
          <source>It is commonly observed that a monotonically decreasing learning rate, whose degree of change is carefully chosen, results in a better performing model. This schedule applies a polynomial decay function to an optimizer step, given a provided &lt;code&gt;initial_learning_rate&lt;/code&gt;, to reach an &lt;code&gt;end_learning_rate&lt;/code&gt; in the given &lt;code&gt;decay_steps&lt;/code&gt;.</source>
          <target state="translated">변화의 정도를 신중하게 선택한 단조 적으로 감소하는 학습 속도가 더 나은 모델을 만드는 것으로 일반적으로 관찰됩니다. 이 스케줄은 제공된 &lt;code&gt;initial_learning_rate&lt;/code&gt; 가 지정된 다항식 감쇠 함수를 옵티 마이저 단계 에 적용하여 지정된 &lt;code&gt;decay_steps&lt;/code&gt; 에서 &lt;code&gt;end_learning_rate&lt;/code&gt; 에 도달합니다 .</target>
        </trans-unit>
        <trans-unit id="c93ff388d20bf1c51a314c792b28b638ccdd22f0" translate="yes" xml:space="preserve">
          <source>It is computed as:</source>
          <target state="translated">다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4b2f8c7d8951354526292dd7c61c73dc1e2912" translate="yes" xml:space="preserve">
          <source>It is considered legacy, and we recommend the use of &lt;a href=&quot;../../../keras/layers/layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">레거시로 간주 &lt;a href=&quot;../../../keras/layers/layer&quot;&gt; &lt;code&gt;tf.keras.layers.Layer&lt;/code&gt; &lt;/a&gt; 대신 tf.keras.layers.Layer 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="ca77b624a75c9021a46466722c1068b482eb54c8" translate="yes" xml:space="preserve">
          <source>It is difficult or expensive to express the desired transform with vectorized operations.</source>
          <target state="translated">벡터화 된 연산으로 원하는 변환을 표현하는 것은 어렵거나 비용이 많이 듭니다.</target>
        </trans-unit>
        <trans-unit id="6cf416effc655d4fb910a766ac33121955c51ad5" translate="yes" xml:space="preserve">
          <source>It is difficult to map expected label by a classifier such as &lt;code&gt;DNNClassifier&lt;/code&gt; to corresponding tf.parse_example spec. This utility encodes it by getting related information from users (key, dtype).</source>
          <target state="translated">&lt;code&gt;DNNClassifier&lt;/code&gt; 와 같은 분류 자에 의해 예상되는 레이블 을 해당 tf.parse_example 스펙 에 맵핑하는 것은 어렵습니다 . 이 유틸리티는 사용자 (key, dtype)로부터 관련 정보를 가져 와서 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="d4595134772db8c55f6625b52919e18fd5135f7c" translate="yes" xml:space="preserve">
          <source>It is difficult to map expected label by a regressor such as &lt;code&gt;DNNRegressor&lt;/code&gt; to corresponding tf.parse_example spec. This utility encodes it by getting related information from users (key, dtype).</source>
          <target state="translated">&lt;code&gt;DNNRegressor&lt;/code&gt; 와 같은 회귀 변수를 사용하여 예상되는 레이블 을 해당 tf.parse_example 사양 에 매핑하는 것은 어렵습니다 . 이 유틸리티는 사용자 (key, dtype)로부터 관련 정보를 가져 와서 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="230736ba631f5bba2d333739bd324940edb51e40" translate="yes" xml:space="preserve">
          <source>It is equivalent to a combination of decode and crop, but much faster by only decoding partial jpeg image.</source>
          <target state="translated">디코딩과 자르기의 조합과 동일하지만 부분 JPEG 이미지 만 디코딩하면 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f482cc1679df2f8fe4d9714245cd09b761e0e0a1" translate="yes" xml:space="preserve">
          <source>It is expected to call &lt;code&gt;call_for_each_replica(fn, ...)&lt;/code&gt; for any operations which potentially can be replicated across replicas (i.e. multiple GPUs) even if there is only CPU or one GPU. When defining the &lt;code&gt;fn&lt;/code&gt;, extra caution needs to be taken:</source>
          <target state="translated">CPU 또는 GPU가 하나 뿐인 경우에도 복제본 (예 : 여러 GPU)에서 복제 될 수있는 모든 작업에 대해 &lt;code&gt;call_for_each_replica(fn, ...)&lt;/code&gt; 를 호출 해야합니다. &lt;code&gt;fn&lt;/code&gt; 을 정의 할 때는 다음 과 같은주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="055fe1b6696e0cb19f02734d3009620768799505" translate="yes" xml:space="preserve">
          <source>It is generally recommend to use the functional layer API via &lt;code&gt;Input&lt;/code&gt;, (which creates an &lt;code&gt;InputLayer&lt;/code&gt;) without directly using &lt;code&gt;InputLayer&lt;/code&gt;.</source>
          <target state="translated">일반적 통해 기능성 층 API의 사용을 권유되는 &lt;code&gt;Input&lt;/code&gt; , (AN 생성되는 &lt;code&gt;InputLayer&lt;/code&gt; 를 직접 이용하지 않고) &lt;code&gt;InputLayer&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="0c1dce56c1c334dd954c808267845c4fe7fb7b16" translate="yes" xml:space="preserve">
          <source>It is okay to call SmartUnsetAll() repeatedly, as later calls have no effect if no SmartSet() calls have been made.</source>
          <target state="translated">SmartSet () 호출이 없으면 나중에 호출해도 효과가 없으므로 SmartUnsetAll ()을 반복해서 호출해도됩니다.</target>
        </trans-unit>
        <trans-unit id="cbc09d683ec73ca98ba02f3223c5c735b9c8958d" translate="yes" xml:space="preserve">
          <source>It is okay to call UnsetAll() repeatedly, as later calls have no effect if no Set() calls have been made.</source>
          <target state="translated">Set () 호출이 없으면 나중에 호출해도 효과가 없으므로 UnsetAll ()을 반복해서 호출해도됩니다.</target>
        </trans-unit>
        <trans-unit id="039e1ffae676b4a9189fbfca71673de319a2eb02" translate="yes" xml:space="preserve">
          <source>It is passed a &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; in addition to &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;kwargs&lt;/code&gt;. The function typically runs one training step in the session.</source>
          <target state="translated">&lt;code&gt;args&lt;/code&gt; 및 &lt;code&gt;kwargs&lt;/code&gt; 외에도 &lt;a href=&quot;../session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; 이 전달 됩니다. 이 기능은 일반적으로 세션에서 하나의 교육 단계를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="aca1618972ec9b371117c6d5a8231067b2c91856" translate="yes" xml:space="preserve">
          <source>It is possible that not all nodes can be split on each feature. Hence, the list of possible nodes can differ between the features. Therefore, we return &lt;code&gt;node_ids_list&lt;/code&gt; for each feature, containing the list of nodes that this feature can be used to split.</source>
          <target state="translated">모든 노드가 각 기능에서 분할 될 수있는 것은 아닙니다. 따라서 가능한 노드 목록은 기능마다 다를 수 있습니다. 따라서이 기능을 사용하여 분할하는 데 사용할 수있는 노드 목록이 포함 된 각 기능에 대해 &lt;code&gt;node_ids_list&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="4edaba6091fd1339a6d60adfd68c1d64381243cd" translate="yes" xml:space="preserve">
          <source>It is preferable to use the numerically stabler function &lt;code&gt;i0e(x)&lt;/code&gt; instead.</source>
          <target state="translated">수치 적으로 안정적인 함수 &lt;code&gt;i0e(x)&lt;/code&gt; 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b32ab7a8ad30e94f34a9078c64b561ecc649a7ac" translate="yes" xml:space="preserve">
          <source>It is preferable to use the numerically stabler function &lt;code&gt;i1e(x)&lt;/code&gt; instead.</source>
          <target state="translated">수치 적으로 안정적인 함수 &lt;code&gt;i1e(x)&lt;/code&gt; 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6b93771e2eea8ed58862ab78dc26277eff1f5044" translate="yes" xml:space="preserve">
          <source>It is preferable to use the numerically stabler function &lt;code&gt;k0e(x)&lt;/code&gt; instead.</source>
          <target state="translated">대신 수치 적으로 안정된 함수 &lt;code&gt;k0e(x)&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="a499a0cf38aa059c98a94a9f0254d7566a3ef4d2" translate="yes" xml:space="preserve">
          <source>It is preferable to use the numerically stabler function &lt;code&gt;k1e(x)&lt;/code&gt; instead.</source>
          <target state="translated">대신 수치 적으로 안정된 함수 &lt;code&gt;k1e(x)&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5b68cac92e718665f740d5404a0bac254e090156" translate="yes" xml:space="preserve">
          <source>It is recommended to accept tensors only in the first argument. This way, all tensors are casted to the layer's compute dtype. &lt;code&gt;MyLayer&lt;/code&gt; should therefore be written as:</source>
          <target state="translated">첫 번째 인수에서만 텐서를 수락하는 것이 좋습니다. 이런 식으로 모든 텐서는 레이어의 계산 dtype으로 캐스팅됩니다. 따라서 &lt;code&gt;MyLayer&lt;/code&gt; 는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8a6022b1da15bcd7ce9fa43852b7ff4b3a38075" translate="yes" xml:space="preserve">
          <source>It is recommended to benchmark each in the setting of interest to pick the most efficient one (in terms of speed and memory usage). Correct choice of implementation can lead to dramatic speed improvements (e.g. 50X), potentially at the expense of RAM.</source>
          <target state="translated">속도와 메모리 사용량 측면에서 가장 효율적인 것을 선택하려면 관심있는 설정에서 각각 벤치 마크하는 것이 좋습니다. 올바른 구현 선택은 잠재적으로 RAM을 희생시키면서 극적인 속도 향상 (예 : 50X)으로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de80edb49783b8cb8ef6ce6354c0c43e1747ba2d" translate="yes" xml:space="preserve">
          <source>It is recommended to call this method like this:</source>
          <target state="translated">이 방법을 다음과 같이 호출하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7f32b049c5b6760e31f453ac16ca6b1bd157e5d8" translate="yes" xml:space="preserve">
          <source>It is recommended to pass all args via name.</source>
          <target state="translated">이름을 통해 모든 인수를 전달하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="826574bd08bd207a37a5ac7010635a34563d3f0d" translate="yes" xml:space="preserve">
          <source>It is required that 1 &amp;lt;= N &amp;lt;= 3.</source>
          <target state="translated">1 &amp;lt;= N &amp;lt;= 3이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4ab75a5dfd5237dbd24c019f2a7b88bf53a10583" translate="yes" xml:space="preserve">
          <source>It is similar to an LSTM layer, but the input transformations and recurrent transformations are both convolutional.</source>
          <target state="translated">LSTM 레이어와 비슷하지만 입력 변환과 반복 변환은 모두 컨볼 루션입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
