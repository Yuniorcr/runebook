<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="aa5c5726c89ba714fd92a6d9ec32e87f3dcb6e2d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt; must be a dense &lt;code&gt;Tensor&lt;/code&gt; with shape matching &lt;code&gt;logits&lt;/code&gt;, namely &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;. If &lt;code&gt;label_vocabulary&lt;/code&gt; given, &lt;code&gt;labels&lt;/code&gt; must be a string &lt;code&gt;Tensor&lt;/code&gt; with values from the vocabulary. If &lt;code&gt;label_vocabulary&lt;/code&gt; is not given, &lt;code&gt;labels&lt;/code&gt; must be float &lt;code&gt;Tensor&lt;/code&gt; with values in the interval &lt;code&gt;[0, 1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; 은 형태 일치 &lt;code&gt;logits&lt;/code&gt; 이있는 밀도가 높은 &lt;code&gt;Tensor&lt;/code&gt; 여야합니다 ( 즉, &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; . 경우 &lt;code&gt;label_vocabulary&lt;/code&gt; 가 주어진 &lt;code&gt;labels&lt;/code&gt; 문자열이어야합니다 &lt;code&gt;Tensor&lt;/code&gt; 어휘에서 값을. &lt;code&gt;label_vocabulary&lt;/code&gt; 가 제공되지 않은 경우 &lt;code&gt;labels&lt;/code&gt; 은 &lt;code&gt;[0, 1]&lt;/code&gt; 간격의 값을 갖는 부동 &lt;code&gt;Tensor&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="34a33f46c8d272c1062b68d66e4a99c17ab85729" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt;: This is the second item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same (for multi-head models). If mode is &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;labels=None&lt;/code&gt; will be passed. If the &lt;code&gt;model_fn&lt;/code&gt;'s signature does not accept &lt;code&gt;mode&lt;/code&gt;, the &lt;code&gt;model_fn&lt;/code&gt; must still be able to handle &lt;code&gt;labels=None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; : &lt;code&gt;train&lt;/code&gt; , &lt;code&gt;evaluate&lt;/code&gt; 및 &lt;code&gt;predict&lt;/code&gt; 전달 된 &lt;code&gt;input_fn&lt;/code&gt; 에서 반환 된 두 번째 항목 입니다. 이것은 단일 &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 또는 동일한 &lt;code&gt;dict&lt;/code&gt; 여야합니다 (멀티 헤드 모델의 경우). mode가 &lt;a href=&quot;../../../estimator/modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; 인&lt;/a&gt; 경우 &lt;code&gt;labels=None&lt;/code&gt; 이 전달됩니다. 는 IF &lt;code&gt;model_fn&lt;/code&gt; 의 서명이 동의하지 않는 &lt;code&gt;mode&lt;/code&gt; 의 &lt;code&gt;model_fn&lt;/code&gt; 은 아직 처리되지 할 수 있어야 &lt;code&gt;labels=None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b534e955a0fec180b3b30cfc9f9a467b20d707" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;labels&lt;/code&gt;: This is the second item returned from the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt;, &lt;code&gt;evaluate&lt;/code&gt;, and &lt;code&gt;predict&lt;/code&gt;. This should be a single &lt;a href=&quot;../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;dict&lt;/code&gt; of same (for multi-head models). If mode is &lt;a href=&quot;modekeys#PREDICT&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;labels=None&lt;/code&gt; will be passed. If the &lt;code&gt;model_fn&lt;/code&gt;'s signature does not accept &lt;code&gt;mode&lt;/code&gt;, the &lt;code&gt;model_fn&lt;/code&gt; must still be able to handle &lt;code&gt;labels=None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;labels&lt;/code&gt; : &lt;code&gt;train&lt;/code&gt; , &lt;code&gt;evaluate&lt;/code&gt; 및 &lt;code&gt;predict&lt;/code&gt; 전달 된 &lt;code&gt;input_fn&lt;/code&gt; 에서 반환 된 두 번째 항목 입니다. 이것은 단일 &lt;a href=&quot;../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 또는 동일한 &lt;code&gt;dict&lt;/code&gt; 여야합니다 (멀티 헤드 모델의 경우). mode가 &lt;a href=&quot;modekeys#PREDICT&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys.PREDICT&lt;/code&gt; 인&lt;/a&gt; 경우 &lt;code&gt;labels=None&lt;/code&gt; 이 전달됩니다. 는 IF &lt;code&gt;model_fn&lt;/code&gt; 의 서명이 동의하지 않는 &lt;code&gt;mode&lt;/code&gt; 의 &lt;code&gt;model_fn&lt;/code&gt; 은 아직 처리되지 할 수 있어야 &lt;code&gt;labels=None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47ff272ccbf5820fc5f544d483247e5517027693" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lam&lt;/code&gt; is the rate parameter describing the distribution(s).</source>
          <target state="translated">&lt;code&gt;lam&lt;/code&gt; 은 분포를 설명하는 rate 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="9a476d3612642270646a91ca6a2fb8c3818d6f15" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;layer_names&lt;/code&gt; (attribute), a list of strings (ordered names of model layers).</source>
          <target state="translated">&lt;code&gt;layer_names&lt;/code&gt; (속성), 문자열 목록 (모델 레이어의 정렬 된 이름).</target>
        </trans-unit>
        <trans-unit id="55edc3c96bf5b380e30d289b4039efd5f2e76e6f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;len(tensors_list)&lt;/code&gt; threads will be started, with thread &lt;code&gt;i&lt;/code&gt; enqueuing the tensors from &lt;code&gt;tensors_list[i]&lt;/code&gt;. &lt;code&gt;tensors_list[i1][j]&lt;/code&gt; must match &lt;code&gt;tensors_list[i2][j]&lt;/code&gt; in type and shape, except in the first dimension if &lt;code&gt;enqueue_many&lt;/code&gt; is true.</source>
          <target state="translated">&lt;code&gt;len(tensors_list)&lt;/code&gt; 스레드 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;tensors_list[i]&lt;/code&gt; 에서 텐서를 대기열에 포함 시키면서 len (tensors_list) 스레드가 시작됩니다 . &lt;code&gt;tensors_list[i1][j]&lt;/code&gt; 일치해야 &lt;code&gt;tensors_list[i2][j]&lt;/code&gt; 경우 제 치수를 제외하고, 종류 및 형상 &lt;code&gt;enqueue_many&lt;/code&gt; 는 사실이다.</target>
        </trans-unit>
        <trans-unit id="9e6955483e26cf8ecb0bde11891718c9524e18ed" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;linear_model&lt;/code&gt; assigns weights for the presence of &quot;a&quot;, &quot;b&quot;, &quot;c' implicitly, just like &lt;code&gt;indicator_column&lt;/code&gt;, while &lt;code&gt;input_layer&lt;/code&gt; explicitly requires wrapping each of categorical columns with an &lt;code&gt;embedding_column&lt;/code&gt; or an &lt;code&gt;indicator_column&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;linear_model&lt;/code&gt; 의 &quot;A&quot;, &quot;B&quot;, 단지 같은 암시 적으로 'C'의 존재에 대한 양수인의 무게 &lt;code&gt;indicator_column&lt;/code&gt; , 동안 &lt;code&gt;input_layer&lt;/code&gt; 가 명시 적으로 범주 열 각각의 포장이 필요 &lt;code&gt;embedding_column&lt;/code&gt; 또는 &lt;code&gt;indicator_column&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7850bc2307fb979df68f487993be50d0b7eca0da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list&amp;lt;int&amp;gt;&lt;/code&gt;, batch size per bucket. Length should be &lt;code&gt;len(bucket_boundaries) + 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;list&amp;lt;int&amp;gt;&lt;/code&gt; , 버킷 당 배치 크기. 길이는 &lt;code&gt;len(bucket_boundaries) + 1&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="484ed1503dec5e27d4e3d2379c723fbc1680e393" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list&amp;lt;int&amp;gt;&lt;/code&gt;, upper length boundaries of the buckets.</source>
          <target state="translated">&lt;code&gt;list&amp;lt;int&amp;gt;&lt;/code&gt; , 버킷의 상한 길이 경계.</target>
        </trans-unit>
        <trans-unit id="3adf35ff73175ed292eaea44a0f496fd0cf264c4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lo '-' hi&lt;/code&gt;: matches character &lt;code&gt;c&lt;/code&gt; for &lt;code&gt;lo &amp;lt;= c &amp;lt;= hi&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;lo '-' hi&lt;/code&gt; : 문자와 일치 &lt;code&gt;c&lt;/code&gt; 에 대한 &lt;code&gt;lo &amp;lt;= c &amp;lt;= hi&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0bc140b5ba01fefe4f35c576fc62c3f1b24cc9d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loc = mu&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;loc = mu&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="00d6bd8bbf067690f3a8f42f7844dfe21f75d15d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;local_init_op&lt;/code&gt;: An op to initialize the local variables. Picked from and stored into the &lt;code&gt;LOCAL_INIT_OP&lt;/code&gt; collection in the graph by default.</source>
          <target state="translated">&lt;code&gt;local_init_op&lt;/code&gt; : 로컬 변수를 초기화하는 op입니다. 기본적으로 그래프 의 &lt;code&gt;LOCAL_INIT_OP&lt;/code&gt; 콜렉션에서 선택하여 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="4d0081c802f205d12d31d9d13174278779c2dccb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log(cosh(x))&lt;/code&gt; is approximately equal to &lt;code&gt;(x ** 2) / 2&lt;/code&gt; for small &lt;code&gt;x&lt;/code&gt; and to &lt;code&gt;abs(x) - log(2)&lt;/code&gt; for large &lt;code&gt;x&lt;/code&gt;. This means that 'logcosh' works mostly like the mean squared error, but will not be so strongly affected by the occasional wildly incorrect prediction.</source>
          <target state="translated">&lt;code&gt;log(cosh(x))&lt;/code&gt; 는 작은 &lt;code&gt;x&lt;/code&gt; 의 경우 &lt;code&gt;(x ** 2) / 2&lt;/code&gt; 와 같고 큰 &lt;code&gt;x&lt;/code&gt; 의 경우 &lt;code&gt;abs(x) - log(2)&lt;/code&gt; 와 같습니다 . 즉, 'logcosh'는 대부분 평균 제곱 오차와 비슷하게 작동하지만 가끔 발생하는 부정확 한 예측의 영향을 크게받지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="d80c1c2a4a19344a430ab51ad65a2da7f27203ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log_step_count_steps&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;log_step_count_steps&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="260def2a87e2043a69adfd873b2d47d764b3e628" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logcosh = log((exp(x) + exp(-x))/2)&lt;/code&gt;, where x is the error (y_pred - y_true)</source>
          <target state="translated">&lt;code&gt;logcosh = log((exp(x) + exp(-x))/2)&lt;/code&gt; , 여기서 x는 오류입니다 (y_pred-y_true)</target>
        </trans-unit>
        <trans-unit id="3bcfd80dfd9cf7e448c409721a4a911fd18e9a4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logcosh = log((exp(x) + exp(-x))/2)&lt;/code&gt;, where x is the error &lt;code&gt;y_pred - y_true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;logcosh = log((exp(x) + exp(-x))/2)&lt;/code&gt; , 여기서 x는 오류 &lt;code&gt;y_pred - y_true&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0d89fc8ccc3cb3692ec1726061dc09465495a55f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; must have the same dtype (either &lt;code&gt;float16&lt;/code&gt;, &lt;code&gt;float32&lt;/code&gt;, or &lt;code&gt;float64&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;logits&lt;/code&gt; 과 &lt;code&gt;labels&lt;/code&gt; 은 동일한 dtype ( &lt;code&gt;float16&lt;/code&gt; , &lt;code&gt;float32&lt;/code&gt; 또는 &lt;code&gt;float64&lt;/code&gt; ) 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="34de2a13ee5e4419fe77996f40e228a5384809bb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; must have the same type and shape.</source>
          <target state="translated">&lt;code&gt;logits&lt;/code&gt; 과 &lt;code&gt;labels&lt;/code&gt; 은 유형과 모양이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="cff5e31fc6dd2759963a3ee8f43525b52a54c4f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loss = maximum(neg - pos + 1, 0)&lt;/code&gt; where &lt;code&gt;neg = sum(y_true * y_pred)&lt;/code&gt; and &lt;code&gt;pos = maximum(1 - y_true)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;loss = maximum(neg - pos + 1, 0)&lt;/code&gt; 여기서 &lt;code&gt;neg = sum(y_true * y_pred)&lt;/code&gt; 및 &lt;code&gt;pos = maximum(1 - y_true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="95b7ef588ec956d4e9a283f4a7146355afa114ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loss = maximum(neg - pos + 1, 0)&lt;/code&gt; where &lt;code&gt;neg=maximum((1-y_true)*y_pred) and pos=sum(y_true*y_pred)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;loss = maximum(neg - pos + 1, 0)&lt;/code&gt; 여기서 &lt;code&gt;neg=maximum((1-y_true)*y_pred) and pos=sum(y_true*y_pred)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="53901e1ec7e83b6df82a0401f9872a40626fe0e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;loss&lt;/code&gt; multiplied by &lt;a href=&quot;lossscaleoptimizer#loss_scale&quot;&gt;&lt;code&gt;LossScaleOptimizer.loss_scale()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;loss&lt;/code&gt; 에 &lt;a href=&quot;lossscaleoptimizer#loss_scale&quot;&gt; &lt;code&gt;LossScaleOptimizer.loss_scale()&lt;/code&gt; &lt;/a&gt; 곱한 값 입니다.</target>
        </trans-unit>
        <trans-unit id="3a81ccf9b40ab52ced51d32ec1d2390947f9c3ea" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;low = a&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;low = a&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="239a907b393e3c3c40fa112182f09a2d06776957" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;lu&lt;/code&gt; as returned by &lt;a href=&quot;lu&quot;&gt;&lt;code&gt;tf.linalg.lu&lt;/code&gt;&lt;/a&gt;, i.e., if &lt;code&gt;matmul(P, matmul(L, U)) = X&lt;/code&gt; then &lt;code&gt;lower_upper = L + U - eye&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;lu&lt;/code&gt; &lt;a href=&quot;lu&quot;&gt; &lt;code&gt;tf.linalg.lu&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 lu , 즉 &lt;code&gt;matmul(P, matmul(L, U)) = X&lt;/code&gt; then &lt;code&gt;lower_upper = L + U - eye&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44045a38b8e2b064441307e8c25b390dc6cbf457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_tensor_proto&lt;/code&gt; accepts &quot;values&quot; of a python scalar, a python list, a numpy ndarray, or a numpy scalar.</source>
          <target state="translated">&lt;code&gt;make_tensor_proto&lt;/code&gt; 는 python 스칼라, python 목록, numpy ndarray 또는 numpy 스칼라의 &quot;값&quot;을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="2695854393c2c28c70761920dbc73274604d58d4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;make_tensor_proto&lt;/code&gt; then converts the numpy array to a tensor proto.</source>
          <target state="translated">&lt;code&gt;make_tensor_proto&lt;/code&gt; 다음 make_tensor_proto 는 numpy 배열을 텐서 프로토로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="33a2635b6fa45073c3bc33d320ea83d6d5651bd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;managed_session()&lt;/code&gt; launches the &quot;summary&quot; and &quot;checkpoint&quot; threads which use either the optionally &lt;code&gt;summary_op&lt;/code&gt; and &lt;code&gt;saver&lt;/code&gt; passed to the constructor, or default ones created automatically by the supervisor. If you want to run your own summary and checkpointing logic, disable these services by passing &lt;code&gt;None&lt;/code&gt; to the &lt;code&gt;summary_op&lt;/code&gt; and &lt;code&gt;saver&lt;/code&gt; parameters.</source>
          <target state="translated">&lt;code&gt;managed_session()&lt;/code&gt; 은 생성자에 전달 된 선택적으로 &lt;code&gt;summary_op&lt;/code&gt; 및 &lt;code&gt;saver&lt;/code&gt; 또는 수퍼바이저가 자동으로 만든 기본 스레드를 사용하는 &quot;요약&quot;및 &quot;검사 점&quot;스레드를 시작합니다 . 자체 요약 및 검사 점 논리를 실행 하려면 &lt;code&gt;summary_op&lt;/code&gt; 및 &lt;code&gt;saver&lt;/code&gt; 매개 변수에 &lt;code&gt;None&lt;/code&gt; 을 전달하여 이러한 서비스를 비활성화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4e40a3c0decb60770898a47b38b724ad826cae8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;managed_session()&lt;/code&gt; launches the Checkpoint and Summary services (threads). If you need more services to run you can simply launch them in the block controlled by &lt;code&gt;managed_session()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;managed_session()&lt;/code&gt; 은 검사 점 및 요약 서비스 (스레드)를 시작합니다. 더 많은 서비스를 실행해야하는 경우 &lt;code&gt;managed_session()&lt;/code&gt; 의해 제어되는 블록에서 서비스를 시작하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="ab21dfcba501cd43177f2de77f197f7fb967f4cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;managed_session()&lt;/code&gt; only supports initializing the model by running an &lt;code&gt;init_op&lt;/code&gt; or restoring from the latest checkpoint. If you have special initialization needs, see how to specify a &lt;code&gt;local_init_op&lt;/code&gt; when creating the supervisor. You can also use the &lt;code&gt;SessionManager&lt;/code&gt; directly to create a session and check if it could be initialized automatically.</source>
          <target state="translated">&lt;code&gt;managed_session()&lt;/code&gt; 은 &lt;code&gt;init_op&lt;/code&gt; 을 실행 하거나 최신 검사 점에서 복원 하여 모델 초기화 만 지원 합니다. 특별한 초기화가 필요한 경우 감독자를 만들 때 &lt;code&gt;local_init_op&lt;/code&gt; 를 지정하는 방법을 참조하십시오 . 당신은 또한 사용할 수 있습니다 &lt;code&gt;SessionManager&lt;/code&gt; 에를 세션을 생성하고 자동으로 초기화 할 수 있는지 확인하기 위해 직접.</target>
        </trans-unit>
        <trans-unit id="201aa3ae8a71f8bb17d4d2d931230c54afc09cb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn(fn, elems).shape = [elems.shape[0]] + fn(elems[0]).shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_fn(fn, elems).shape = [elems.shape[0]] + fn(elems[0]).shape&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ee6e3ceb8bf229e6cd64cd04a70bd8d08f46e21d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; also supports functions with multi-arity inputs and outputs:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 다중 인수 입력 및 출력 기능도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="ee6de8604631cd5411d1f60cb9fac1e74850f809" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; should typically only be used if one of the following is true:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 일반적으로 다음 중 하나에 해당하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c661aed00fba94745113e1e563ea2cc2b90d3de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; supports &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; inputs and outputs. In particular:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 입력 및 출력을 지원합니다 . 특히:</target>
        </trans-unit>
        <trans-unit id="d117e98154d3dbec85d15035ba171afb475d4398" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; supports &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; inputs and outputs. In particular:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; 입력 및 출력을 지원합니다 . 특히:</target>
        </trans-unit>
        <trans-unit id="eaa771543eb789e3e396d2b8501f4652d1cb6001" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; supports &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; inputs and outputs. In particular:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 입력 및 출력을 지원합니다 . 특히:</target>
        </trans-unit>
        <trans-unit id="28f5ce5b818ae273b3fb94de467ded2c322dd036" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; supports &lt;a href=&quot;sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt; inputs and outputs. In particular:</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 은 &lt;a href=&quot;sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; 입력 및 출력을 지원합니다 . 특히:</target>
        </trans-unit>
        <trans-unit id="716c9b777272e5bc061680a77ab36241b5735310" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; unstacks &lt;code&gt;elems&lt;/code&gt; on axis 0 to obtain a sequence of elements; calls &lt;code&gt;fn&lt;/code&gt; to transform each element; and then stacks the transformed values back together.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; unstacks의 &lt;code&gt;elems&lt;/code&gt; 을 요소들의 시퀀스를 획득하기 위해 축 0; &lt;code&gt;fn&lt;/code&gt; 을 호출 하여 각 요소를 변환합니다. 그런 다음 변환 된 값을 다시 함께 쌓습니다.</target>
        </trans-unit>
        <trans-unit id="2e3a5af806d007c68cd49875a051817f865ebcdc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; vs. vectorized operations</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 대 벡터화 된 작업</target>
        </trans-unit>
        <trans-unit id="d7cf3c23430ce8a9950e720b818c6a06386a1479" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_fn&lt;/code&gt; will apply the operations used by &lt;code&gt;fn&lt;/code&gt; to each element of &lt;code&gt;elems&lt;/code&gt;, resulting in &lt;code&gt;O(elems.shape[0])&lt;/code&gt; total operations. This is somewhat mitigated by the fact that &lt;code&gt;map_fn&lt;/code&gt; can process elements in parallel. However, a transform expressed using &lt;code&gt;map_fn&lt;/code&gt; is still typically less efficient than an equivalent transform expressed using vectorized operations.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 는 에 의해 사용되는 연산 적용 &lt;code&gt;fn&lt;/code&gt; 각 요소에 &lt;code&gt;elems&lt;/code&gt; 결과 &lt;code&gt;O(elems.shape[0])&lt;/code&gt; 전체 동작. 이것은 &lt;code&gt;map_fn&lt;/code&gt; 이 요소를 병렬로 처리 할 수 있다는 사실로 인해 다소 완화됩니다 . 그러나 &lt;code&gt;map_fn&lt;/code&gt; 을 사용하여 표현 된 변환은 일반적으로 벡터화 된 작업을 사용하여 표현 된 동등한 변환보다 여전히 덜 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="7da6a90591fbf9148be1fe73695bb84fb434d4de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;map_func&lt;/code&gt; can accept as arguments and return any type of dataset element.</source>
          <target state="translated">&lt;code&gt;map_func&lt;/code&gt; 는 인수로 허용하고 모든 유형의 데이터 세트 요소를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b8c563c56d6ce26d393808650d41613ce585083" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask&lt;/code&gt; (boolean tensor encoding masked timesteps in the input, used in RNN layers)</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; (입력에서 마스킹 된 시간 단계를 인코딩하는 부울 텐서, RNN 레이어에서 사용됨)</target>
        </trans-unit>
        <trans-unit id="bc0550b7418c271a20285a09ff80f6d3adc8ab64" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mask&lt;/code&gt;: Boolean input mask.</source>
          <target state="translated">&lt;code&gt;mask&lt;/code&gt; : 부울 입력 마스크.</target>
        </trans-unit>
        <trans-unit id="4511d84f5bd44b98de89476fe12f118e1b13633b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;master&lt;/code&gt; is determined by looking up &lt;code&gt;task_type&lt;/code&gt; and &lt;code&gt;task_id&lt;/code&gt; in the &lt;code&gt;cluster_spec&lt;/code&gt;. Defaults to ''.</source>
          <target state="translated">&lt;code&gt;master&lt;/code&gt; 는 &lt;code&gt;cluster_spec&lt;/code&gt; 에서 &lt;code&gt;task_type&lt;/code&gt; 및 &lt;code&gt;task_id&lt;/code&gt; 를 찾아서 결정됩니다 . 기본값은 ''입니다.</target>
        </trans-unit>
        <trans-unit id="753411c18fa101e75a96a3c406d85d10a0e7b898" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form square matrices. If &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the strictly upper triangular part of each inner-most matrix is assumed to be zero and not accessed. If &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then the strictly lower triangular part of each inner-most matrix is assumed to be zero and not accessed. &lt;code&gt;rhs&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; 은 가장 안쪽의 2 차원이 정사각형 행렬을 형성하는 &lt;code&gt;[..., M, M]&lt;/code&gt; 모양의 텐서입니다 . 경우 &lt;code&gt;lower&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 상 삼각 원점으로 가정하고 액세스되지 않는다. 경우 &lt;code&gt;lower&lt;/code&gt; 있다 &lt;code&gt;False&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 하 삼각 부분을 제로로 가정하고 액세스되지 않는다. &lt;code&gt;rhs&lt;/code&gt; 는 모양의 텐서입니다 &lt;code&gt;[..., M, N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9189bf65251a0bbda14bc822b3c739fa55376f08" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form square matrices. If &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the strictly upper triangular part of each inner-most matrix is assumed to be zero and not accessed. If &lt;code&gt;lower&lt;/code&gt; is False then the strictly lower triangular part of each inner-most matrix is assumed to be zero and not accessed. &lt;code&gt;rhs&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; 은 가장 안쪽 2 차원이 정사각 행렬을 형성 하는 모양 &lt;code&gt;[..., M, M]&lt;/code&gt; 의 텐서입니다 . 경우 &lt;code&gt;lower&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 상 삼각 원점으로 가정하고 액세스되지 않는다. 경우 &lt;code&gt;lower&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 하 삼각 부분 거짓 제로로 가정하고 액세스되지 않는다. &lt;code&gt;rhs&lt;/code&gt; 는 모양의 텐서입니다 &lt;code&gt;[..., M, K]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a08758df47eba4f780777a4a1bc5be514b7ce752" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, M]&lt;/code&gt; whose inner-most 2 dimensions form square matrices. If &lt;code&gt;lower&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; then the strictly upper triangular part of each inner-most matrix is assumed to be zero and not accessed. If &lt;code&gt;lower&lt;/code&gt; is False then the strictly lower triangular part of each inner-most matrix is assumed to be zero and not accessed. &lt;code&gt;rhs&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; 은 가장 안쪽의 2 차원이 정사각형 행렬을 형성하는 &lt;code&gt;[..., M, M]&lt;/code&gt; 모양의 텐서입니다 . 경우 &lt;code&gt;lower&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 상 삼각 원점으로 가정하고 액세스되지 않는다. 경우 &lt;code&gt;lower&lt;/code&gt; 각각의 가장 안쪽 행렬의 엄격 하 삼각 부분 거짓 제로로 가정하고 액세스되지 않는다. &lt;code&gt;rhs&lt;/code&gt; 는 모양의 텐서입니다 &lt;code&gt;[..., M, N]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c5925f624642c492652d2efffb321561eb861a63" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt; whose inner-most 2 dimensions form &lt;code&gt;M&lt;/code&gt;-by-&lt;code&gt;N&lt;/code&gt; matrices. Rhs is a tensor of shape &lt;code&gt;[..., M, K]&lt;/code&gt; whose inner-most 2 dimensions form &lt;code&gt;M&lt;/code&gt;-by-&lt;code&gt;K&lt;/code&gt; matrices. The computed output is a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[..., N, K]&lt;/code&gt; whose inner-most 2 dimensions form &lt;code&gt;M&lt;/code&gt;-by-&lt;code&gt;K&lt;/code&gt; matrices that solve the equations &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; in the least squares sense.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; 형상의 텐서 &lt;code&gt;[..., M, N]&lt;/code&gt; 그 가장 안쪽 2 차원 형태 &lt;code&gt;M&lt;/code&gt; -by- &lt;code&gt;N&lt;/code&gt; 의 행렬. RHS는 형상의 텐서 &lt;code&gt;[..., M, K]&lt;/code&gt; 그 가장 안쪽 2 차원 형태 &lt;code&gt;M&lt;/code&gt; -by- &lt;code&gt;K&lt;/code&gt; 의 행렬. 계산 된 출력은이다 &lt;code&gt;Tensor&lt;/code&gt; 형상 &lt;code&gt;[..., N, K]&lt;/code&gt; 그 가장 안쪽 2 차원 형태 &lt;code&gt;M&lt;/code&gt; -by- &lt;code&gt;K&lt;/code&gt; 의 등식을 해결 행렬 &lt;code&gt;matrix[..., :, :] * output[..., :, :] = rhs[..., :, :]&lt;/code&gt; 최소 제곱 의미에서 , :, :] = rhs [..., :, :] .</target>
        </trans-unit>
        <trans-unit id="1f7c90b0c6a7d79530a9d75426a92b4a58e0fb95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt; is a tensor of shape &lt;code&gt;[..., M, N]&lt;/code&gt; whose inner-most 2 dimensions form real or complex matrices of size &lt;code&gt;[M, N]&lt;/code&gt;. &lt;code&gt;Rhs&lt;/code&gt; is a tensor of the same type as &lt;code&gt;matrix&lt;/code&gt; and shape &lt;code&gt;[..., M, K]&lt;/code&gt;. The output is a tensor shape &lt;code&gt;[..., N, K]&lt;/code&gt; where each output matrix solves each of the equations &lt;code&gt;matrix[..., :, :]&lt;/code&gt; * &lt;code&gt;output[..., :, :]&lt;/code&gt; = &lt;code&gt;rhs[..., :, :]&lt;/code&gt; in the least squares sense.</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; 은 가장 안쪽에있는 2 차원이 &lt;code&gt;[M, N]&lt;/code&gt; 크기의 실수 또는 복소 행렬을 형성하는 &lt;code&gt;[..., M, N]&lt;/code&gt; 모양의 텐서입니다 . &lt;code&gt;Rhs&lt;/code&gt; 는 &lt;code&gt;matrix&lt;/code&gt; 및 모양 &lt;code&gt;[..., M, K]&lt;/code&gt; 와 동일한 유형의 텐서입니다 . 출력은 텐서 모양 &lt;code&gt;[..., N, K]&lt;/code&gt; 여기서 각 출력 행렬은 &lt;code&gt;matrix[..., :, :]&lt;/code&gt; * &lt;code&gt;output[..., :, :]&lt;/code&gt; = &lt;code&gt;rhs[..., :, :]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9bc8e47ee3592d8bc1ffb9ab2af56014457deca" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt;=\(A \in \Re^{m \times n}\), &lt;code&gt;rhs&lt;/code&gt;=\(B \in \Re^{m \times k}\), &lt;code&gt;output&lt;/code&gt;=\(X \in \Re^{n \times k}\), &lt;code&gt;l2_regularizer&lt;/code&gt;=\(\lambda\).</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; = \ (A \ in \ Re ^ {m \ times n} \), &lt;code&gt;rhs&lt;/code&gt; = \ (B \ in \ Re ^ {m \ times k} \), &lt;code&gt;output&lt;/code&gt; = \ (X \ in \ Re ^ {n \ times k} \), &lt;code&gt;l2_regularizer&lt;/code&gt; = \ (\ lambda \)입니다.</target>
        </trans-unit>
        <trans-unit id="2bfdaad8fe4d3dc48dc452ef976063111621a66b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;matrix&lt;/code&gt;=\(A \in \mathbb{C}^{m \times n}\), &lt;code&gt;rhs&lt;/code&gt;=\(B \in \mathbb{C}^{m \times k}\), &lt;code&gt;output&lt;/code&gt;=\(X \in \mathbb{C}^{n \times k}\), &lt;code&gt;l2_regularizer&lt;/code&gt;=\(\lambda \in \mathbb{R}\).</source>
          <target state="translated">&lt;code&gt;matrix&lt;/code&gt; = \ (A \ in \ mathbb {C} ^ {m \ times n} \), &lt;code&gt;rhs&lt;/code&gt; = \ (B \ in \ mathbb {C} ^ {m \ times k} \), &lt;code&gt;output&lt;/code&gt; = \ (X \ \ mathbb {C} ^ {n \ times k} \), &lt;code&gt;l2_regularizer&lt;/code&gt; = \ (\ lambda \ in \ mathbb {R} \).</target>
        </trans-unit>
        <trans-unit id="deb021c5491d3506ec3b333d798e1638c6bf357f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max&lt;/code&gt; means that global max pooling will be applied.</source>
          <target state="translated">&lt;code&gt;max&lt;/code&gt; 는 글로벌 최대 풀링이 적용됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="780d0411f288c9c4c561812eb42c5972a27aa1a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_delta&lt;/code&gt; must be in the interval &lt;code&gt;[0, 0.5]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;max_delta&lt;/code&gt; 는 &lt;code&gt;[0, 0.5]&lt;/code&gt; 간격에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="de98d7209ef393e3658dfba41d6de117dccea49c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max_to_keep&lt;/code&gt; indicates the maximum number of recent checkpoint files to keep. As new files are created, older files are deleted. If None or 0, no checkpoints are deleted from the filesystem but only the last one is kept in the &lt;code&gt;checkpoint&lt;/code&gt; file. Defaults to 5 (that is, the 5 most recent checkpoint files are kept.)</source>
          <target state="translated">&lt;code&gt;max_to_keep&lt;/code&gt; 은 유지할 최근 체크 포인트 파일의 최대 수를 나타냅니다. 새 파일이 작성되면 이전 파일이 삭제됩니다. None 또는 0 인 경우 검사 점은 파일 시스템에서 삭제되지 않지만 마지막 &lt;code&gt;checkpoint&lt;/code&gt; 파일에 유지 됩니다. 기본값은 5입니다 (즉, 가장 최근 5 개의 체크 포인트 파일이 유지됨).</target>
        </trans-unit>
        <trans-unit id="62fd55d0f011cfd6c1e86d889ea9b346d1c87818" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;maxlength&lt;/code&gt; (if set);</source>
          <target state="translated">&lt;code&gt;maxlength&lt;/code&gt; (설정된 경우);</target>
        </trans-unit>
        <trans-unit id="107316499e97cd27bf6521566f27943369c4a7c8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mean&lt;/code&gt; is the average of all values in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; 은 &lt;code&gt;x&lt;/code&gt; 의 모든 값의 평균입니다.</target>
        </trans-unit>
        <trans-unit id="7faff67f10f1e2a3e20331e013f312ae640058d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;variance&lt;/code&gt;, &lt;code&gt;offset&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are all expected to be of one of two shapes:</source>
          <target state="translated">&lt;code&gt;mean&lt;/code&gt; , &lt;code&gt;variance&lt;/code&gt; , &lt;code&gt;offset&lt;/code&gt; 및 &lt;code&gt;scale&lt;/code&gt; 은 모두 두 가지 모양 중 하나 일 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="dceb68d825a4e33b9fea0a034c6ca432b27e73fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;merge_call()&lt;/code&gt; is used to communicate between the replicas and re-enter the cross-replica context. All replicas pause their execution having encountered a &lt;code&gt;merge_call()&lt;/code&gt; call. After that the &lt;code&gt;merge_fn&lt;/code&gt;-function is executed. Its results are then unwrapped and given back to each replica call. After that execution resumes until &lt;code&gt;fn&lt;/code&gt; is complete or encounters another &lt;code&gt;merge_call()&lt;/code&gt;. Example:</source>
          <target state="translated">&lt;code&gt;merge_call()&lt;/code&gt; 은 복제본간에 통신하고 복제본 컨텍스트를 다시 입력하는 데 사용됩니다. 모든 복제본은 &lt;code&gt;merge_call()&lt;/code&gt; 호출 이 발생하여 실행을 일시 중지합니다 . 그 후 &lt;code&gt;merge_fn&lt;/code&gt; -function 이 실행됩니다. 그런 다음 결과가 랩핑 해제되고 각 복제본 호출에 다시 제공됩니다. 그 후 &lt;code&gt;fn&lt;/code&gt; 이 완료되거나 다른 &lt;code&gt;merge_call()&lt;/code&gt; 발생할 때까지 실행이 재개됩니다 . 예:</target>
        </trans-unit>
        <trans-unit id="4e517c3984ceade4aecc16a96953c6e4bd66ff3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;meshgrid&lt;/code&gt; supports cartesian ('xy') and matrix ('ij') indexing conventions. When the &lt;code&gt;indexing&lt;/code&gt; argument is set to 'xy' (the default), the broadcasting instructions for the first two dimensions are swapped.</source>
          <target state="translated">&lt;code&gt;meshgrid&lt;/code&gt; 는 직교 ( 'xy') 및 행렬 ( 'ij') 색인 규칙을 지원합니다. 때 &lt;code&gt;indexing&lt;/code&gt; 인수가 'XY'(기본값)로 설정되어, 처음 두 차원의 방송 지침이 교환된다.</target>
        </trans-unit>
        <trans-unit id="a269a7fa032fac5b2f4910c95e28deee4f3ed0a1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;method&lt;/code&gt; can be one of:</source>
          <target state="translated">&lt;code&gt;method&lt;/code&gt; 은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff76289dadc56ad506b6536609c4ad4995fb6c5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;min_jpeg_quality&lt;/code&gt; must be in the interval &lt;code&gt;[0, 100]&lt;/code&gt; and less than &lt;code&gt;max_jpeg_quality&lt;/code&gt;. &lt;code&gt;max_jpeg_quality&lt;/code&gt; must be in the interval &lt;code&gt;[0, 100]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;min_jpeg_quality&lt;/code&gt; 는 &lt;code&gt;[0, 100]&lt;/code&gt; 간격에 있고 max_jpeg_quality 보다 &lt;code&gt;max_jpeg_quality&lt;/code&gt; 합니다. &lt;code&gt;max_jpeg_quality&lt;/code&gt; 는 &lt;code&gt;[0, 100]&lt;/code&gt; 간격에 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="e50e430733d4031575b1b9f7b2ccee2e80e570ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;minlength&lt;/code&gt; (if set, and &lt;code&gt;minlength &amp;gt; reduce_max(values)&lt;/code&gt;);</source>
          <target state="translated">&lt;code&gt;minlength&lt;/code&gt; (설정된 경우 및 &lt;code&gt;minlength &amp;gt; reduce_max(values)&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="a571d601a6a8caa4dfe06b3715fd0505a77be29d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; -- Optional. Specifies if this is training, evaluation or prediction. See &lt;a href=&quot;../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;params&lt;/code&gt; -- Optional &lt;code&gt;dict&lt;/code&gt; of hyperparameters. Will receive what is passed to Estimator in &lt;code&gt;params&lt;/code&gt; parameter. This allows to configure Estimators from hyper parameter tuning.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; - 선택 사항. 학습, 평가 또는 예측인지 지정합니다. &lt;a href=&quot;../../../estimator/modekeys&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . &lt;code&gt;params&lt;/code&gt; - 하이퍼 파라미터의 선택적 &lt;code&gt;dict&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; 매개 변수 로 Estimator에 전달 된 내용을 수신합니다 . 이를 통해 하이퍼 매개 변수 튜닝에서 에스티 메이터를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8b1768fcec0bada9695eccc1bdeb41beb8e91b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt; -- Optional. Specifies if this is training, evaluation or prediction. See &lt;a href=&quot;modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt;. &lt;code&gt;params&lt;/code&gt; -- Optional &lt;code&gt;dict&lt;/code&gt; of hyperparameters. Will receive what is passed to Estimator in &lt;code&gt;params&lt;/code&gt; parameter. This allows to configure Estimators from hyper parameter tuning.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; - 선택 사항. 학습, 평가 또는 예측인지 지정합니다. &lt;a href=&quot;modekeys&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 . &lt;code&gt;params&lt;/code&gt; - 하이퍼 파라미터의 선택적 &lt;code&gt;dict&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; 매개 변수 로 Estimator에 전달 된 내용을 수신합니다 . 이를 통해 하이퍼 매개 변수 튜닝에서 에스티 메이터를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e44fd3969bdb460d346be6270eeedf5bf1c5eeee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt;: Optional. Specifies if this is training, evaluation or prediction. See &lt;a href=&quot;../../../estimator/modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; : 선택 사항. 이것이 훈련, 평가 또는 예측인지를 지정합니다. &lt;a href=&quot;../../../estimator/modekeys&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fe020c233373b41dfe3e73b0f3c671fe958a6709" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mode&lt;/code&gt;: Optional. Specifies if this is training, evaluation or prediction. See &lt;a href=&quot;modekeys&quot;&gt;&lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; : 선택 사항. 이것이 훈련, 평가 또는 예측인지를 지정합니다. &lt;a href=&quot;modekeys&quot;&gt; &lt;code&gt;tf.estimator.ModeKeys&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1e0332f6abf1f7ae3f141ab4bf2d2cfd7ac1466c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;model_dir&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;model_dir&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="02f44c8932e91b0716c0a01ed63154fb04d95534" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;model_fn&lt;/code&gt; should return &lt;code&gt;TPUEstimatorSpec&lt;/code&gt;, which expects the &lt;code&gt;eval_metrics&lt;/code&gt; for TPU evaluation. If eval_on_tpu is False, the evaluation will execute on CPU or GPU; in this case the following discussion on TPU evaluation does not apply.</source>
          <target state="translated">&lt;code&gt;model_fn&lt;/code&gt; 은 TPUEstimatorSpec 을 리턴해야 &lt;code&gt;TPUEstimatorSpec&lt;/code&gt; , 이는 TPU 평가를위한 &lt;code&gt;eval_metrics&lt;/code&gt; 를 예상합니다 . eval_on_tpu가 False이면 평가는 CPU 또는 GPU에서 실행됩니다. 이 경우 TPU 평가에 대한 다음 설명은 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee8b33312cec6b45c344fef791efe6c47661f476" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;n&lt;/code&gt; bytes of the file (or whole file) in bytes mode or &lt;code&gt;n&lt;/code&gt; bytes of the string if in string (regular) mode.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 바이트 모드에서 파일 (또는 전체 파일)의 바이트 또는 &lt;code&gt;n&lt;/code&gt; 문자열 문자열의 경우 (일반) 모드의 바이트.</target>
        </trans-unit>
        <trans-unit id="df5f416a9b5733a2eac498dc25e9c5d79f1b6b78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;names&lt;/code&gt; can be any iterable, but if &lt;code&gt;names&lt;/code&gt; is a string, it is treated as a single collection name.</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 은 반복 가능할 수 있지만 &lt;code&gt;names&lt;/code&gt; 이 문자열 인 경우 단일 콜렉션 이름으로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="af34ccfc9c86db5b479221e0d0d3cd3df6c98350" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt;. &lt;code&gt;NodeDef&lt;/code&gt; for the &lt;code&gt;Operation&lt;/code&gt;. Used for attributes of &lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt;, typically &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;op&lt;/code&gt;, and &lt;code&gt;device&lt;/code&gt;. The &lt;code&gt;input&lt;/code&gt; attribute is irrelevant here as it will be computed when generating the model.</source>
          <target state="translated">&lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt; . &lt;code&gt;NodeDef&lt;/code&gt; 에 대한 &lt;code&gt;Operation&lt;/code&gt; . &lt;code&gt;node_def_pb2.NodeDef&lt;/code&gt; 의 속성 ( 일반적으로 &lt;code&gt;name&lt;/code&gt; , &lt;code&gt;op&lt;/code&gt; 및 &lt;code&gt;device&lt;/code&gt; )에 사용 됩니다. &lt;code&gt;input&lt;/code&gt; 모델을 생성 할 때이 계산 될 것이다 속성은 여기에 무관하다.</target>
        </trans-unit>
        <trans-unit id="c3334340105a28a8d17de44dacf09bd9f32fb4fb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_bits&lt;/code&gt; is the bitwidth of the quantization; between 2 and 16, inclusive.</source>
          <target state="translated">&lt;code&gt;num_bits&lt;/code&gt; 는 양자화의 비트 폭 입니다. 2에서 16 사이입니다.</target>
        </trans-unit>
        <trans-unit id="5b916b335c7388604c32473b8905043445520b8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_oov_buckets&lt;/code&gt; and &lt;code&gt;default_value&lt;/code&gt; are both specified.</source>
          <target state="translated">&lt;code&gt;num_oov_buckets&lt;/code&gt; 및 &lt;code&gt;default_value&lt;/code&gt; 가 모두 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f907957fb79d16f8fcc5805418190436f3dcc208" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_oov_buckets&lt;/code&gt; is a negative integer.</source>
          <target state="translated">&lt;code&gt;num_oov_buckets&lt;/code&gt; 는 음의 정수입니다.</target>
        </trans-unit>
        <trans-unit id="c6120062e56dd23e9bb088799ef65c77300cfcee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_prefix_dims = indices.ndims - 1&lt;/code&gt;&lt;code&gt;batch_dim = num_prefix_dims + 1&lt;/code&gt;&lt;code&gt;updates.shape = indices.shape + var.shape[batch_dim:]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;num_prefix_dims = indices.ndims - 1&lt;/code&gt; &lt;code&gt;batch_dim = num_prefix_dims + 1&lt;/code&gt; &lt;code&gt;updates.shape = indices.shape + var.shape[batch_dim:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d6525bb51d4773222ea852bb2ac3834dd72e3100" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_prefix_dims = sparse_delta.indices.ndims - 1&lt;/code&gt;&lt;code&gt;batch_dim = num_prefix_dims + 1&lt;/code&gt;&lt;code&gt;sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[ batch_dim:]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;num_prefix_dims = sparse_delta.indices.ndims - 1&lt;/code&gt; &lt;code&gt;batch_dim = num_prefix_dims + 1&lt;/code&gt; &lt;code&gt;sparse_delta.updates.shape = sparse_delta.indices.shape + var.shape[ batch_dim:]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f828cc0720b999a08a7f4102e218edb8ec31ba17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_ps_replicas&lt;/code&gt; is set by counting the number of nodes listed in the &lt;code&gt;ps&lt;/code&gt; attribute of &lt;code&gt;cluster_spec&lt;/code&gt;. Defaults to 0.</source>
          <target state="translated">&lt;code&gt;num_ps_replicas&lt;/code&gt; 는 &lt;code&gt;cluster_spec&lt;/code&gt; 의 &lt;code&gt;ps&lt;/code&gt; 속성에 나열된 노드 수를 계산하여 설정됩니다 . 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="419f9e3ce59724644a1225fc4b8b8f842b8bc60b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_segments&lt;/code&gt; should equal the number of distinct segment IDs.</source>
          <target state="translated">&lt;code&gt;num_segments&lt;/code&gt; 는 고유 한 세그먼트 ID 수와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="68799da72fece464d6acf37bd7fa6dad701ad4b7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_split&lt;/code&gt;&lt;code&gt;SparseTensor&lt;/code&gt; objects resulting from splitting &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;num_split&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 분할되어 발생하는 &lt;code&gt;SparseTensor&lt;/code&gt; 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="5d73feca3ad0f45546a60e77e205d74b81fa88a5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_vocab_offset&lt;/code&gt; enables use in the partitioned variable case, and should generally be set through examining partitioning info. The format of the files should be a text file, with each line containing a single entity within the vocabulary.</source>
          <target state="translated">&lt;code&gt;num_vocab_offset&lt;/code&gt; 은 분할 변수의 경우에 사용할 수 있으며 일반적으로 분할 정보를 검토하여 설정해야합니다. 파일 형식은 텍스트 파일이어야하며 각 줄에는 어휘 내의 단일 엔티티가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8890e65c2e76e8f98ca5fe26b2d3f88e870a93d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;num_worker_replicas&lt;/code&gt; is set by counting the number of nodes listed in the &lt;code&gt;worker&lt;/code&gt; and &lt;code&gt;chief&lt;/code&gt; attributes of &lt;code&gt;cluster_spec&lt;/code&gt;. Defaults to 1.</source>
          <target state="translated">&lt;code&gt;num_worker_replicas&lt;/code&gt; 는 &lt;code&gt;worker&lt;/code&gt; 에 나열된 노드 수 와 &lt;code&gt;cluster_spec&lt;/code&gt; 의 &lt;code&gt;chief&lt;/code&gt; 속성을 계산하여 설정됩니다 . 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="cb71f93c55b5e166e47dcff7adbc5b5409f4c18d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;numpy.dtype&lt;/code&gt;. The type of elements for the returned &lt;code&gt;RaggedTensor&lt;/code&gt;. If not specified, then a default is chosen based on the scalar values in &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy.dtype&lt;/code&gt; . 반환 된 &lt;code&gt;RaggedTensor&lt;/code&gt; 의 요소 유형입니다 . 지정하지 않으면 &lt;code&gt;pylist&lt;/code&gt; 의 스칼라 값을 기반으로 기본값이 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="3a7bad4ad12d13881c84bfd2a59b05dd1fe6aab5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offset&lt;/code&gt; is zero except when the alignment of the diagonal is to the right.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 은 대각선 정렬이 오른쪽 인 경우를 제외하고 0입니다.</target>
        </trans-unit>
        <trans-unit id="8e0b91096254b940e7e020fad3ace367303af7f8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;offsets&lt;/code&gt; is an &lt;code&gt;int64&lt;/code&gt; tensor with shape &lt;code&gt;[D1...DN, (num_chars)]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;offsets&lt;/code&gt; 은 모양이 &lt;code&gt;[D1...DN, (num_chars)]&lt;/code&gt; 인 &lt;code&gt;int64&lt;/code&gt; 텐서입니다 .</target>
        </trans-unit>
        <trans-unit id="ff00cf7cd0e954feb62e6e90092e7b1fff9f25f2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_batch_begin&lt;/code&gt; and &lt;code&gt;on_batch_end&lt;/code&gt; expect two positional arguments: &lt;code&gt;batch&lt;/code&gt;, &lt;code&gt;logs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;on_batch_begin&lt;/code&gt; 및 &lt;code&gt;on_batch_end&lt;/code&gt; 에는 두 개의 위치 인수 인 &lt;code&gt;batch&lt;/code&gt; , &lt;code&gt;logs&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="813875a69dfbb6b8abf24144da16fd062a09923c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_epoch_begin&lt;/code&gt; and &lt;code&gt;on_epoch_end&lt;/code&gt; expect two positional arguments: &lt;code&gt;epoch&lt;/code&gt;, &lt;code&gt;logs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;on_epoch_begin&lt;/code&gt; 및 &lt;code&gt;on_epoch_end&lt;/code&gt; 는 두 개의 위치 인수를 예상합니다 : &lt;code&gt;epoch&lt;/code&gt; , &lt;code&gt;logs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc1236396eab699cdc1ef79468b729cc0394346a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_train_begin&lt;/code&gt; and &lt;code&gt;on_train_end&lt;/code&gt; expect one positional argument: &lt;code&gt;logs&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;on_train_begin&lt;/code&gt; 과 &lt;code&gt;on_train_end&lt;/code&gt; 는 하나의 위치 인수를 예상합니다 : &lt;code&gt;logs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5ac7342015557e2663452342ebb273918ca737d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;on_value&lt;/code&gt; and &lt;code&gt;off_value&lt;/code&gt; must have matching data types. If &lt;code&gt;dtype&lt;/code&gt; is also provided, they must be the same data type as specified by &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;on_value&lt;/code&gt; 와 &lt;code&gt;off_value&lt;/code&gt; 는 일치하는 데이터 유형을 가져야 합니다. 경우 &lt;code&gt;dtype&lt;/code&gt; 또한 제공되고, 그들에 의해 지정된 것과 같은 타입이어야 &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09d76d60e1aa2433ebee4f0cebbf17084aabd60a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant()&lt;/code&gt; involves a size &lt;code&gt;N&lt;/code&gt;&lt;code&gt;reduce_prod&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator.determinant()&lt;/code&gt; 는 크기 &lt;code&gt;N&lt;/code&gt; &lt;code&gt;reduce_prod&lt;/code&gt; 를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="b250959e9500f947675e6a27dc60fe1e8ee82e05" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(1)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.determinant()&lt;/code&gt; 는 &lt;code&gt;O(1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ee921e65b455e602fd88e73c07fdcedb3475132" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(B1*...*Bb)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.determinant()&lt;/code&gt; 는 &lt;code&gt;O(B1*...*Bb)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47da1f2cf6b5cf8ab2f59e5e872d4e9595ecf123" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(D1*...*Dd)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.determinant()&lt;/code&gt; 는 &lt;code&gt;O(D1*...*Dd)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="732428d4b359acad5170dd78848ddef489b962de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant()&lt;/code&gt; is &lt;code&gt;O(L_determinant + L_solve*N*K + K^2*N + K^3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.determinant()&lt;/code&gt; 는 &lt;code&gt;O(L_determinant + L_solve*N*K + K^2*N + K^3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="894ab7854cfe8e76bb8c9c2875a208b84e05f28d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.determinant&lt;/code&gt; has complexity equal to the sum of the &lt;code&gt;determinant&lt;/code&gt; complexities of the operators on the diagonal.</source>
          <target state="translated">&lt;code&gt;operator.determinant&lt;/code&gt; 는 대각 연산자 의 &lt;code&gt;determinant&lt;/code&gt; 복잡도의 합과 같은 복잡도를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="bd2e540a6bdb028580ac7370e55c70b7c927abc5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; involves &lt;code&gt;N * R&lt;/code&gt; multiplications.</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 에는 &lt;code&gt;N * R&lt;/code&gt; 곱셈이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="124db9324d8661ebe4e9afa41fec828420d7b989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; involves &lt;code&gt;N^2 * R&lt;/code&gt; multiplications.</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 에는 &lt;code&gt;N^2 * R&lt;/code&gt; 곱셈이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8019beb3c67695296e87d0a91a36ca22a2d4f513" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; is &lt;code&gt;O(1)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 &lt;code&gt;O(1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4f14ba6d8a39abb1a0e543563fedabca7c972dec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; is &lt;code&gt;O(D1*...*Dd*N*R)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 &lt;code&gt;O(D1*...*Dd*N*R)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25deba38371be9eb02dd690be87960b1e730398e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; is &lt;code&gt;O(L_matmul*N*R + K*N*R)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 &lt;code&gt;O(L_matmul*N*R + K*N*R)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9852461d24383df730a7b18adab4c36ffb6e961d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; is &lt;code&gt;O(M * N * R)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 &lt;code&gt;O(M * N * R)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4b200ad861bc5c145f1dcb5bd0a79e47b517f21f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; is &lt;code&gt;O(R*N*Log[N])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 &lt;code&gt;O(R*N*Log[N])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4ce1c9d8cba0b346a246bd06c51c30d9dedb2649" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul(x)&lt;/code&gt; will take O(N * R) time.</source>
          <target state="translated">&lt;code&gt;operator.matmul(x)&lt;/code&gt; 는 O (N * R) 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="9eeeb6564a5a5bc5d982a49186b39bf5a7682dc7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.matmul&lt;/code&gt; has complexity equal to the sum of the &lt;code&gt;matmul&lt;/code&gt; complexities of the individual operators.</source>
          <target state="translated">&lt;code&gt;operator.matmul&lt;/code&gt; 은 개별 연산자 의 &lt;code&gt;matmul&lt;/code&gt; 복잡성의 합과 같은 복잡성 을가집니다 .</target>
        </trans-unit>
        <trans-unit id="53417a02f05b295dfff4b08b09532f29068876bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; involves &lt;code&gt;N * R&lt;/code&gt; size &lt;code&gt;N&lt;/code&gt; back-substitutions.</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;N * R&lt;/code&gt; 크기 &lt;code&gt;N&lt;/code&gt; 역 치환을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="88d873db3385cf9c867476c411d37014bb5c2db3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; involves &lt;code&gt;N&lt;/code&gt; divisions and &lt;code&gt;N * R&lt;/code&gt; multiplications.</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;N&lt;/code&gt; 나누기와 &lt;code&gt;N * R&lt;/code&gt; 곱셈을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="45cff67c1b8150d40d6938e7138b1c2d387d7f77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(1)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;O(1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05019c5ab426b029be9dde63aa6a19ef2a14e53b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(D1*...*Dd*N*R)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;O(D1*...*Dd*N*R)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c37d70c8cb8fc1c27b5de68235a874b4cd27233c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(L_matmul*N*R + N*K*R + K^2*R + K^3)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;O(L_matmul*N*R + N*K*R + K^2*R + K^3)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d7a2b5d3a587e1b8fedd72b482a6f21eddc57799" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; is &lt;code&gt;O(R*N*Log[N])&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 &lt;code&gt;O(R*N*Log[N])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b42eeca8a7ed56ada68d5f6a73284bdd5541840e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve(x)&lt;/code&gt; will take O(N * R) time.</source>
          <target state="translated">&lt;code&gt;operator.solve(x)&lt;/code&gt; 는 O (N * R) 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="fc9f472c09542411a90e93ac65f1d871715a9d42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator.solve&lt;/code&gt; has complexity equal to the sum of the &lt;code&gt;solve&lt;/code&gt; complexities of the operators on the diagonal and the &lt;code&gt;matmul&lt;/code&gt; complexities of the operators off the diagonal.</source>
          <target state="translated">&lt;code&gt;operator.solve&lt;/code&gt; 는 복잡도가가의 합 가지고 &lt;code&gt;solve&lt;/code&gt; 대각선상의 운영자의 복잡성을 &lt;code&gt;matmul&lt;/code&gt; 대각선 오프 연산자 복잡성.</target>
        </trans-unit>
        <trans-unit id="8b0b3492d639fbb64b409d8721e56f3596802e9e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;options.run_metadata&lt;/code&gt; argument of &lt;code&gt;tf.Session.Run&lt;/code&gt; is used to collect metadata about execution. This hook sets the metadata and dumps it in Chrome Trace format.</source>
          <target state="translated">&lt;code&gt;options.run_metadata&lt;/code&gt; &lt;code&gt;tf.Session.Run&lt;/code&gt; 의options.run_metadata 인수는 실행에 대한 메타 데이터를 수집하는 데 사용됩니다. 이 후크는 메타 데이터를 설정하고 Chrome 추적 형식으로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="26e1a6664301a08a0690f2de7f1f29cf06aab375" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ordering_amd_value&lt;/code&gt; stores the AMD ordering: &lt;code&gt;[1 2 3 0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ordering_amd_value&lt;/code&gt; 는 AMD 주문을 저장합니다 : &lt;code&gt;[1 2 3 0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2105dc593b456c8afbc378b15d84c53e19ed5544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output = ragged.from_nested_row_splits(output_dense_values, output_nested_splits)&lt;/code&gt; is the output tensor.</source>
          <target state="translated">&lt;code&gt;output = ragged.from_nested_row_splits(output_dense_values, output_nested_splits)&lt;/code&gt; 는 출력 텐서입니다.</target>
        </trans-unit>
        <trans-unit id="9bc0de1b795320319e5110fb000cfffa0bc896cc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f594955b003518356687922d114c7f8686187d1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output.shape = params.shape[:axis] + indices.shape[batch_dims:] + params.shape[axis + 1:]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output.shape = params.shape[:axis] + indices.shape[batch_dims:] + params.shape[axis + 1:]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2193b495c82fa96d40cf04d74efc6ad7cb3c673" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output&lt;/code&gt;[..., i] = sum_k (&lt;code&gt;a&lt;/code&gt;[..., i, k] * &lt;code&gt;b&lt;/code&gt;[..., k]), for all indices i.</source>
          <target state="translated">&lt;code&gt;output&lt;/code&gt; 모든 인덱스 i에 대한 출력 [..., i] = sum_k ( &lt;code&gt;a&lt;/code&gt; [..., i, k] * &lt;code&gt;b&lt;/code&gt; [..., k]).</target>
        </trans-unit>
        <trans-unit id="98e0dea2eff3337ed9d685067362daee5e67df00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[..., 0]&lt;/code&gt; contains hue, &lt;code&gt;output[..., 1]&lt;/code&gt; contains saturation, and &lt;code&gt;output[..., 2]&lt;/code&gt; contains value. All HSV values are in &lt;code&gt;[0,1]&lt;/code&gt;. A hue of 0 corresponds to pure red, hue 1/3 is pure green, and 2/3 is pure blue.</source>
          <target state="translated">&lt;code&gt;output[..., 0]&lt;/code&gt; 은 색조를 포함하고 &lt;code&gt;output[..., 1]&lt;/code&gt; 은 채도를 포함하며 &lt;code&gt;output[..., 2]&lt;/code&gt; 는 값을 포함합니다. 모든 HSV 값은 &lt;code&gt;[0,1]&lt;/code&gt; 에 있습니다. 색조 0은 순수한 빨강에 해당하고, 색조 1/3은 순수한 녹색, 2/3는 순수한 청색입니다.</target>
        </trans-unit>
        <trans-unit id="afae030d04f3a2eea94e7329e94fcd7e13331d17" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[..., i, j] = sum_k (a[..., i, k] * b[..., k, j])&lt;/code&gt;, for all indices &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;j&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output[..., i, j] = sum_k (a[..., i, k] * b[..., k, j])&lt;/code&gt; 모든 인덱스 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;j&lt;/code&gt; 에 대해 output [..., i, j] = sum_k (a [..., i, k] * b [..., k, j]) .</target>
        </trans-unit>
        <trans-unit id="bb1a0fef5f148931a60402636a12729d8d5d3425" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output[i, j, k, ..., m, n] = 1{m=n} * diagonal[i, j, k, ..., n]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d9dc2e257c4eb17f7e0dcc10de515166ef6ddaf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]&lt;/code&gt; for &lt;code&gt;m == n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output[i, j, k, ..., m, n] = diagonal[i, j, k, ..., n]&lt;/code&gt; for &lt;code&gt;m == n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b18f1215d94791dda6fbb58d6922737d15b1116" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]&lt;/code&gt; for &lt;code&gt;m != n&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;output[i, j, k, ..., m, n] = input[i, j, k, ..., m, n]&lt;/code&gt; &lt;code&gt;m != n&lt;/code&gt; 대한 input [i, j, k, ..., m, n] .</target>
        </trans-unit>
        <trans-unit id="647b9c0572b0fa18d4d16e9a149f6fa142c25fa2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]&lt;/code&gt; and 0 everywhere else.</source>
          <target state="translated">&lt;code&gt;output[i1,..., ik, i1,..., ik] = diagonal[i1, ..., ik]&lt;/code&gt; 및 다른 곳에서는 0입니다.</target>
        </trans-unit>
        <trans-unit id="e88b043f54928a5e38e2622893b3d7ac0f7b55e5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;p&lt;/code&gt; as returned by &lt;code&gt;tf.linag.lu&lt;/code&gt;, i.e., if &lt;code&gt;matmul(P, matmul(L, U)) = X&lt;/code&gt; then &lt;code&gt;perm = argmax(P)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;tf.linag.lu&lt;/code&gt; 에 의해 반환됩니다 . 즉, &lt;code&gt;matmul(P, matmul(L, U)) = X&lt;/code&gt; 이면 &lt;code&gt;perm = argmax(P)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="37026b4b25297f8566cc02c0b281d227fb3ef80f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;paddings&lt;/code&gt; and &lt;code&gt;crops&lt;/code&gt; are int32 Tensors of rank 2 and shape [N, 2]</source>
          <target state="translated">&lt;code&gt;paddings&lt;/code&gt; 및 &lt;code&gt;crops&lt;/code&gt; 은 int32 순위 2 및 모양의 텐서 [N, 2]</target>
        </trans-unit>
        <trans-unit id="bb72633b6559bebce67e7683c28657f06a3733dd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_interleave()&lt;/code&gt; maps &lt;code&gt;map_func&lt;/code&gt; across its input to produce nested datasets, and outputs their elements interleaved. Unlike &lt;a href=&quot;../dataset#interleave&quot;&gt;&lt;code&gt;tf.data.Dataset.interleave&lt;/code&gt;&lt;/a&gt;, it gets elements from &lt;code&gt;cycle_length&lt;/code&gt; nested datasets in parallel, which increases the throughput, especially in the presence of stragglers. Furthermore, the &lt;code&gt;sloppy&lt;/code&gt; argument can be used to improve performance, by relaxing the requirement that the outputs are produced in a deterministic order, and allowing the implementation to skip over nested datasets whose elements are not readily available when requested.</source>
          <target state="translated">&lt;code&gt;parallel_interleave()&lt;/code&gt; 는 입력에 &lt;code&gt;map_func&lt;/code&gt; 를 매핑 하여 중첩 된 데이터 세트를 생성하고 해당 요소를 인터리브합니다. &lt;a href=&quot;../dataset#interleave&quot;&gt; &lt;code&gt;tf.data.Dataset.interleave&lt;/code&gt; &lt;/a&gt; 와는 달리 , &lt;code&gt;cycle_length&lt;/code&gt; 중첩 데이터 세트에서 요소를 병렬로 가져 오므로 특히 스래 글러 가 있는 경우 처리량이 증가합니다. 또한 출력이 결정적인 순서로 생성되어야한다는 요구 사항을 완화하고 구현시 요청시 요소를 쉽게 사용할 수없는 중첩 된 데이터 세트를 건너 뛸 수 있도록 하여 &lt;code&gt;sloppy&lt;/code&gt; 인수를 사용하여 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eae5717a638495f49fb50c73ece61796ce32450d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;parallel_stack&lt;/code&gt; will copy pieces of the input into the output as they become available, in some situations this can provide a performance benefit.</source>
          <target state="translated">&lt;code&gt;parallel_stack&lt;/code&gt; 은 사용 가능한 입력을 출력에 복사합니다. 일부 상황에서는 성능상의 이점을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be8a6d6ccfadda2ac8df9e2c26afafb696f75883" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params = ragged.from_nested_row_splits(params_dense_values, params_nested_splits)&lt;/code&gt; provides the values that should be gathered.</source>
          <target state="translated">&lt;code&gt;params = ragged.from_nested_row_splits(params_dense_values, params_nested_splits)&lt;/code&gt; 는 수집해야하는 값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d880a49bd3f88d1dab858c25244bef9a33adf648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt; has reserved keys already.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 는 이미 키를 예약했습니다.</target>
        </trans-unit>
        <trans-unit id="65a399d1f4d2c711d5abc32cc2240fe0c22dab97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;params&lt;/code&gt;: Optional &lt;code&gt;dict&lt;/code&gt; of hyperparameters. Will receive what is passed to Estimator in &lt;code&gt;params&lt;/code&gt; parameter. This allows to configure Estimators from hyper parameter tuning.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; : 하이퍼 파라미터의 선택적 &lt;code&gt;dict&lt;/code&gt; . &lt;code&gt;params&lt;/code&gt; 매개 변수 로 Estimator에 전달 된 내용을 수신합니다 . 이를 통해 하이퍼 파라미터 튜닝에서 Estimators를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09071a5dd22428393cf8c4f7a69c918e749762f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pos&lt;/code&gt; and &lt;code&gt;len&lt;/code&gt; must have the same shape, otherwise a &lt;code&gt;ValueError&lt;/code&gt; is thrown on Op creation.</source>
          <target state="translated">&lt;code&gt;pos&lt;/code&gt; 와 &lt;code&gt;len&lt;/code&gt; 은 같은 모양이어야합니다. 그렇지 않으면 Op 생성시 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7f273873fbbabc4394545267781b3c0ab3e99fb3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;precision_at_k&lt;/code&gt; creates two local variables, &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt;, that are used to compute the precision@k frequency. This frequency is ultimately returned as &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; by total (&lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; + &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;precision_at_k&lt;/code&gt; 는 precision @ k 주파수를 계산하는 데 사용되는 두 개의 로컬 변수 &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; 및 &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; 를 만듭니다. 이 빈도는 궁극적으로 &lt;code&gt;precision_at_&amp;lt;k&amp;gt;&lt;/code&gt; 로 반환됩니다 . 즉, &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; 를 총계 ( &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; + &lt;code&gt;false_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; )로 간단히 나누는 dem 등원 연산입니다 .</target>
        </trans-unit>
        <trans-unit id="8a32ea7dd9a16b4b8c0f5571d89acc61504ad4bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pred_fn_pairs&lt;/code&gt; could be a dictionary in v1. However, tf.Tensor and tf.Variable are no longer hashable in v2, so cannot be used as a key for a dictionary. Please use a list or a tuple instead.</source>
          <target state="translated">&lt;code&gt;pred_fn_pairs&lt;/code&gt; 는 v1의 사전 일 수 있습니다. 그러나 tf.Tensor 및 tf.Variable은 v2에서 더 이상 해시 가능하지 않으므로 사전의 키로 사용할 수 없습니다. 대신 목록이나 튜플을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1ab8a5eed70a61d5488049997bbb9460fcfb177b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;prepare_session()&lt;/code&gt; initializes or restores a model. It requires &lt;code&gt;init_op&lt;/code&gt; and &lt;code&gt;saver&lt;/code&gt; as an argument.</source>
          <target state="translated">&lt;code&gt;prepare_session()&lt;/code&gt; 은 모델을 초기화하거나 복원합니다. 인수로 &lt;code&gt;init_op&lt;/code&gt; 및 &lt;code&gt;saver&lt;/code&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="09dd2ff00546c8d676ad315b6b62370c5d4bda1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess_collapse_repeated=False&lt;/code&gt;, &lt;code&gt;ctc_merge_repeated=False&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;preprocess_collapse_repeated=False&lt;/code&gt; , &lt;code&gt;ctc_merge_repeated=False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="500def01c290ed4333c81f7cea1528eea50c993d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess_collapse_repeated=False&lt;/code&gt;, &lt;code&gt;ctc_merge_repeated=True&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;preprocess_collapse_repeated=False&lt;/code&gt; , &lt;code&gt;ctc_merge_repeated=True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="613bbe35ec735c26d418a3175bfc88a9a6be986e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess_collapse_repeated=True&lt;/code&gt;, &lt;code&gt;ctc_merge_repeated=False&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;preprocess_collapse_repeated=True&lt;/code&gt; , &lt;code&gt;ctc_merge_repeated=False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="050f75af3a169156ec30db4e3ce787faacd9e11e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;preprocess_collapse_repeated=True&lt;/code&gt;, &lt;code&gt;ctc_merge_repeated=True&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;preprocess_collapse_repeated=True&lt;/code&gt; , &lt;code&gt;ctc_merge_repeated=True&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d98c315781a4d61a821f3e9a17d585068e91bf1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;probs = pi = [pi_0, ..., pi_{K-1}]&lt;/code&gt;, &lt;code&gt;pi_j &amp;gt; 0&lt;/code&gt;, &lt;code&gt;sum_j pi_j = 1&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;probs = pi = [pi_0, ..., pi_{K-1}]&lt;/code&gt; , &lt;code&gt;pi_j &amp;gt; 0&lt;/code&gt; , &lt;code&gt;sum_j pi_j = 1&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="a60dd2ac8cf95b98d085cd01df6b006079df22c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;protocol&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;protocol&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="b598c10ce4c4e3b659319ec126d482ed67255860" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rank(output) = rank(data)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rank(output) = rank(data)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ea87326a5df38f99832da68be7ab01425a1a6ac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rankdir&lt;/code&gt; argument passed to PyDot, a string specifying the format of the plot: 'TB' creates a vertical plot; 'LR' creates a horizontal plot.</source>
          <target state="translated">&lt;code&gt;rankdir&lt;/code&gt; 전달되는 rankdir 인수, 플롯의 형식을 지정하는 문자열 : 'TB'는 수직 플롯을 생성합니다. 'LR'은 수평 플롯을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5ae3695dc299363fbb4d0a406660a863e3679a06" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rate = beta&lt;/code&gt;, &lt;code&gt;beta &amp;gt; 0&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;rate = beta&lt;/code&gt; , &lt;code&gt;beta &amp;gt; 0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="37c0190236715ac9e320b19eed23ad87b9c79d3c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reader_func&lt;/code&gt; is a user specified function that accepts a single argument: (1) a Dataset of Datasets, each representing a &quot;split&quot; of elements of the original dataset. The cardinality of the input dataset matches the number of the shards specified in the &lt;code&gt;shard_func&lt;/code&gt; (see above). The function should return a Dataset of elements of the original dataset.</source>
          <target state="translated">&lt;code&gt;reader_func&lt;/code&gt; 는 단일 인수를 허용하는 사용자 지정 함수입니다. (1) 데이터 세트의 데이터 세트, 각 데이터 세트는 원래 데이터 세트 요소의 &quot;분할&quot;을 나타냅니다. 입력 데이터 세트의 카디널리티는 &lt;code&gt;shard_func&lt;/code&gt; 에 지정된 샤드 수와 일치합니다 (위 참조). 함수는 원래 데이터 세트 요소의 데이터 세트를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2f36a7fe13d75365a3c6f9ea8e0526dc67f72f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ready_for_local_init_op&lt;/code&gt;: An op to verify that global state has been initialized and it is alright to run &lt;code&gt;local_init_op&lt;/code&gt;. Picked from and stored into the &lt;code&gt;READY_FOR_LOCAL_INIT_OP&lt;/code&gt; collection in the graph by default. This is needed when the initialization of local variables depends on the values of global variables.</source>
          <target state="translated">&lt;code&gt;ready_for_local_init_op&lt;/code&gt; : 전역 상태가 초기화되었고 &lt;code&gt;local_init_op&lt;/code&gt; 를 실행하는 것이 괜찮은지 확인하는 op 입니다. 기본적으로 그래프 의 &lt;code&gt;READY_FOR_LOCAL_INIT_OP&lt;/code&gt; 컬렉션에서 선택하여 저장합니다 . 지역 변수의 초기화가 전역 변수의 값에 의존 할 때 필요합니다.</target>
        </trans-unit>
        <trans-unit id="579f589fb2812eb40314afcc8b2380e849de88b8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ready_op&lt;/code&gt;: An op to verify that the variables are initialized. Picked from and stored into the &lt;code&gt;READY_OP&lt;/code&gt; collection in the graph by default.</source>
          <target state="translated">&lt;code&gt;ready_op&lt;/code&gt; : 변수가 초기화되었는지 확인하는 op입니다. 기본적으로 그래프 의 &lt;code&gt;READY_OP&lt;/code&gt; 컬렉션에서 선택하여 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="01a7d572eab947495076fa304aed2592a5397b31" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recovery_wait_secs&lt;/code&gt; is the number of seconds between checks that the model is ready. It is used by processes to wait for a model to be initialized or restored. Defaults to 30 seconds.</source>
          <target state="translated">&lt;code&gt;recovery_wait_secs&lt;/code&gt; 는 모델이 준비되었는지 확인하는 시간 (초)입니다. 프로세스가 모델의 초기화 또는 복원을 기다리는 데 사용됩니다. 기본값은 30 초입니다.</target>
        </trans-unit>
        <trans-unit id="6669a01bafa24ae941c3569a36a184d4952b1453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recurrent_activation&lt;/code&gt; == &lt;code&gt;sigmoid&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;recurrent_activation&lt;/code&gt; _ &lt;code&gt;sigmoid&lt;/code&gt; == 시그 모이 드</target>
        </trans-unit>
        <trans-unit id="bdc3899fa43fc5f362d8a0b2e22d584f2eadee6d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;recurrent_dropout&lt;/code&gt; == 0</source>
          <target state="translated">&lt;code&gt;recurrent_dropout&lt;/code&gt; == 0</target>
        </trans-unit>
        <trans-unit id="a07f6275d343c5529d84e46c5cf290dd9941a8fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reduce_max(values) + 1&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;reduce_max(values) + 1&lt;/code&gt; 그렇지 않으면.</target>
        </trans-unit>
        <trans-unit id="92a6acfab4230a596c8f6336ad367eca8ef7a75a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; with rank &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;indices&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ref&lt;/code&gt; 는 순위 &lt;code&gt;P&lt;/code&gt; 의 &lt;code&gt;Tensor&lt;/code&gt; 이고 &lt;code&gt;indices&lt;/code&gt; 는 순위 &lt;code&gt;Q&lt;/code&gt; 의 &lt;code&gt;Tensor&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="48625c88ffea768012bd3adb9993ec5a64eb8689" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reset_after&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;reset_after&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="4e421a974a04d9ea6d2a4f6ab261aeac3e4d796e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;reshuffle_each_iteration&lt;/code&gt; controls whether the shuffle order should be different for each epoch. In TF 1.X, the idiomatic way to create epochs was through the &lt;code&gt;repeat&lt;/code&gt; transformation:</source>
          <target state="translated">&lt;code&gt;reshuffle_each_iteration&lt;/code&gt; 은 셔플 순서가 각 에포크마다 달라야하는지 여부를 제어합니다. TF 1.X에서 신기원을 만드는 관용적 방법은 &lt;code&gt;repeat&lt;/code&gt; 변환 을 통해 이루어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="1f3459cef2a93faed6b0e35aa82b37bd4a0418bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;restore()&lt;/code&gt; either assigns values immediately if variables to restore have been created already, or defers restoration until the variables are created. Dependencies added after this call will be matched if they have a corresponding object in the checkpoint (the restore request will queue in any trackable object waiting for the expected dependency to be added).</source>
          <target state="translated">&lt;code&gt;restore()&lt;/code&gt; 는 복원 할 변수가 이미 생성 된 경우 즉시 값을 할당하거나 변수가 생성 될 때까지 복원을 연기합니다. 이 호출 후에 추가 된 종속성은 체크 포인트에 해당 개체가있는 경우 일치합니다 (예상 종속성이 추가되기를 기다리는 추적 가능한 개체의 복원 요청이 대기열에 있음).</target>
        </trans-unit>
        <trans-unit id="0ab9c69356fb5d8d42ef34be4404c4453f1da602" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result()&lt;/code&gt;: Computes and returns a value for the metric from the state variables.</source>
          <target state="translated">&lt;code&gt;result()&lt;/code&gt; : 상태 변수에서 메트릭 값을 계산하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="86e500c0abe3d36fd8d2ab72f87f401fde5ea586" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result.rank = values.rank + 1&lt;/code&gt;. &lt;code&gt;result.ragged_rank = values.ragged_rank + 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;result.rank = values.rank + 1&lt;/code&gt; 입니다. &lt;code&gt;result.ragged_rank = values.ragged_rank + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c51804a545a69c2eeb611a01f2a193621041af52" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result[i1...iN, j]&lt;/code&gt; is the Unicode codepoint for the &lt;code&gt;j&lt;/code&gt;th character in &lt;code&gt;input[i1...iN]&lt;/code&gt;, when decoded using &lt;code&gt;input_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;result[i1...iN, j]&lt;/code&gt; 는 &lt;code&gt;input_encoding&lt;/code&gt; 을 사용하여 디코딩 할 때 &lt;code&gt;input[i1...iN]&lt;/code&gt; 의 &lt;code&gt;j&lt;/code&gt; 번째 문자에 대한 유니 코드 코드 포인트입니다 .</target>
        </trans-unit>
        <trans-unit id="dbdda62089d365adeaaf4c6a5c5bb418cd69326d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result[i1...iN, j]&lt;/code&gt; is the substring of &lt;code&gt;input[i1...iN]&lt;/code&gt; that encodes its &lt;code&gt;j&lt;/code&gt;th character, when decoded using &lt;code&gt;input_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;result[i1...iN, j]&lt;/code&gt; 는 &lt;code&gt;input_encoding&lt;/code&gt; 을 사용하여 디코딩 할 때 &lt;code&gt;j&lt;/code&gt; 번째 문자 를 인코딩하는 &lt;code&gt;input[i1...iN]&lt;/code&gt; 의 하위 문자열입니다 .</target>
        </trans-unit>
        <trans-unit id="d405a5989bce5b74a11d7121956de2968df53cee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;result[i1...iN]&lt;/code&gt; is the string formed by concatenating the Unicode codepoints &lt;code&gt;input[1...iN, :]&lt;/code&gt;, encoded using &lt;code&gt;output_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;result[i1...iN]&lt;/code&gt; 은 &lt;code&gt;output_encoding&lt;/code&gt; 을 사용하여 인코딩 된 유니 코드 코드 포인트 &lt;code&gt;input[1...iN, :]&lt;/code&gt; 를 연결하여 형성된 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="4ebc1f8d0b2a3ce28c2f35181ca9157b2f138fba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rgb&lt;/code&gt;: Output an RGB JPEG image. The &lt;code&gt;channels&lt;/code&gt; dimension of &lt;code&gt;image&lt;/code&gt; must be 3.</source>
          <target state="translated">&lt;code&gt;rgb&lt;/code&gt; : RGB JPEG 이미지를 출력합니다. &lt;code&gt;image&lt;/code&gt; 의 &lt;code&gt;channels&lt;/code&gt; 크기는 3이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d6fab150da8dba9fdc68e6973316f200a4fd09cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; is a batch matrix with compatible shape for &lt;code&gt;solve&lt;/code&gt; if</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 는 &lt;code&gt;solve&lt;/code&gt; if 와 호환되는 형태의 배치 매트릭스입니다.</target>
        </trans-unit>
        <trans-unit id="ecf897dd105e8b6535740a073798bea464f063df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rhs&lt;/code&gt; is matrix to the right of multiplication. It has shape &lt;code&gt;[..., M, N]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rhs&lt;/code&gt; 는 곱셈의 오른쪽에있는 행렬입니다. 모양은 &lt;code&gt;[..., M, N]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="63dafbb542c6c870e244b7aa6d1bb0949a8d2979" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;row_lengths&lt;/code&gt;: a vector with shape &lt;code&gt;[nrows]&lt;/code&gt;, which specifies the length of each row.</source>
          <target state="translated">&lt;code&gt;row_lengths&lt;/code&gt; : 각 행의 길이를 지정하는 &lt;code&gt;[nrows]&lt;/code&gt; 모양의 벡터입니다 .</target>
        </trans-unit>
        <trans-unit id="505129edd5057a9a60dc8a1c4f50bf2de594835b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;row_limits&lt;/code&gt;: a vector with shape &lt;code&gt;[nrows]&lt;/code&gt;, which specifies the stop offset of each row. Equivalent to &lt;code&gt;row_splits[1:]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;row_limits&lt;/code&gt; : 각 행의 정지 오프셋을 지정하는 &lt;code&gt;[nrows]&lt;/code&gt; 모양의 벡터입니다 . 동등 &lt;code&gt;row_splits[1:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="233def4eb0b6c8453033607dd7b01b4541f4cae8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;row_remapping&lt;/code&gt; must have exactly &lt;code&gt;num_rows&lt;/code&gt; entries. Row &lt;code&gt;i&lt;/code&gt; of the output matrix will be initialized from the row corresponding to index &lt;code&gt;row_remapping[i]&lt;/code&gt; in the old &lt;code&gt;Tensor&lt;/code&gt; from the checkpoint.</source>
          <target state="translated">&lt;code&gt;row_remapping&lt;/code&gt; 에는 정확히 &lt;code&gt;num_rows&lt;/code&gt; 항목 이 있어야 합니다. 행 &lt;code&gt;i&lt;/code&gt; 출력 매트릭스의 인덱스에 대응하는 행에서 초기화한다 &lt;code&gt;row_remapping[i]&lt;/code&gt; 이전에 &lt;code&gt;Tensor&lt;/code&gt; 검문소에서.</target>
        </trans-unit>
        <trans-unit id="174167e0bff10306fdeb1b5097c2065cd1a30817" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;row_splits[i+1] - row_splits[i]&lt;/code&gt; is the number of characters in the &lt;code&gt;i&lt;/code&gt;th string (in row-major order).</source>
          <target state="translated">&lt;code&gt;row_splits[i+1] - row_splits[i]&lt;/code&gt; 는 &lt;code&gt;i&lt;/code&gt; 번째 문자열 의 문자 수입니다 (행 우선 순서).</target>
        </trans-unit>
        <trans-unit id="993e8f9041a3ce5de998e8d77ddc54d507333384" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;row_starts&lt;/code&gt;: a vector with shape &lt;code&gt;[nrows]&lt;/code&gt;, which specifies the start offset of each row. Equivalent to &lt;code&gt;row_splits[:-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;row_starts&lt;/code&gt; : 각 행의 시작 오프셋을 지정하는 &lt;code&gt;[nrows]&lt;/code&gt; 모양의 벡터입니다 . 상당 &lt;code&gt;row_splits[:-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38bc7a6007a318a4e4d21c689a0717bf7f0ef583" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.flat_values.shape = [nvals] + rt.shape[rt.ragged_rank + 1:]&lt;/code&gt; (where &lt;code&gt;nvals&lt;/code&gt; is the number of items in the flattened dimensions).</source>
          <target state="translated">&lt;code&gt;rt.flat_values.shape = [nvals] + rt.shape[rt.ragged_rank + 1:]&lt;/code&gt; (여기서 &lt;code&gt;nvals&lt;/code&gt; 는 병합 된 차원의 항목 수입니다).</target>
        </trans-unit>
        <trans-unit id="659e173038c083629e7b4d0ce837c061e72d975f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.nested_row_lengths()&lt;/code&gt; is a tuple containing the &lt;code&gt;row_lengths&lt;/code&gt; tensors for all ragged dimensions in &lt;code&gt;rt&lt;/code&gt;, ordered from outermost to innermost.</source>
          <target state="translated">&lt;code&gt;rt.nested_row_lengths()&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 모든 비정형 치수에 대한 &lt;code&gt;row_lengths&lt;/code&gt; 텐서를 포함하는 튜플 입니다.</target>
        </trans-unit>
        <trans-unit id="2401662788cf09541ead1c1f177f5de737074526" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.nested_row_splits&lt;/code&gt; is a tuple containing the &lt;code&gt;row_splits&lt;/code&gt; tensors for all ragged dimensions in &lt;code&gt;rt&lt;/code&gt;, ordered from outermost to innermost. In particular, &lt;code&gt;rt.nested_row_splits = (rt.row_splits,) + value_splits&lt;/code&gt; where:</source>
          <target state="translated">&lt;code&gt;rt.nested_row_splits&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 모든 비정형 치수에 대한 &lt;code&gt;row_splits&lt;/code&gt; 텐서를 포함하는 튜플 입니다. 특히 &lt;code&gt;rt.nested_row_splits = (rt.row_splits,) + value_splits&lt;/code&gt; 여기서</target>
        </trans-unit>
        <trans-unit id="ad036c0ba2b0959cf1e933c63de523d5bcea7bac" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.nested_value_rowids&lt;/code&gt; is a tuple containing the &lt;code&gt;value_rowids&lt;/code&gt; tensors for all ragged dimensions in &lt;code&gt;rt&lt;/code&gt;, ordered from outermost to innermost. In particular, &lt;code&gt;rt.nested_value_rowids = (rt.value_rowids(),) + value_ids&lt;/code&gt; where:</source>
          <target state="translated">&lt;code&gt;rt.nested_value_rowids&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 모든 비정형 치수에 대한 &lt;code&gt;value_rowids&lt;/code&gt; 텐서를 포함하는 튜플 입니다. 특히, &lt;code&gt;rt.nested_value_rowids = (rt.value_rowids(),) + value_ids&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="02e1c61525758f7a465a540e113a41163f7a1f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.row_lengths()[i]&lt;/code&gt; indicates the number of values in the &lt;code&gt;i&lt;/code&gt;th row of &lt;code&gt;rt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rt.row_lengths()[i]&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 &lt;code&gt;i&lt;/code&gt; 번째 행 에있는 값의 수를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="279b0358704b60065824b9cbfce31e67043d2523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.row_splits&lt;/code&gt; specifies where the values for each row begin and end in &lt;code&gt;rt.values&lt;/code&gt;. In particular, the values for row &lt;code&gt;rt[i]&lt;/code&gt; are stored in the slice &lt;code&gt;rt.values[rt.row_splits[i]:rt.row_splits[i+1]]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rt.row_splits&lt;/code&gt; 는 각 행의 값이 &lt;code&gt;rt.values&lt;/code&gt; 로 시작하고 끝나는 위치를 지정 합니다. 특히, 행 &lt;code&gt;rt[i]&lt;/code&gt; 의 값 은 슬라이스 &lt;code&gt;rt.values[rt.row_splits[i]:rt.row_splits[i+1]]&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1292c14ec557ab6896493786a68e1322e2388e4e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.value_rowids()&lt;/code&gt; corresponds one-to-one with the outermost dimension of &lt;code&gt;rt.values&lt;/code&gt;, and specifies the row containing each value. In particular, the row &lt;code&gt;rt[row]&lt;/code&gt; consists of the values &lt;code&gt;rt.values[j]&lt;/code&gt; where &lt;code&gt;rt.value_rowids()[j] == row&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rt.value_rowids()&lt;/code&gt; 는 &lt;code&gt;rt.values&lt;/code&gt; 의 가장 바깥 쪽 차원과 일대일 로 대응하며 각 값을 포함하는 행을 지정합니다. 특히 &lt;code&gt;rt[row]&lt;/code&gt; 은 &lt;code&gt;rt.values[j]&lt;/code&gt; 값으로 구성되며 여기서 &lt;code&gt;rt.value_rowids()[j] == row&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6d7394aabfe69b1f24d3e6b6314b3e3ecf92b167" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.values.shape = [nvals] + rt.shape[2:]&lt;/code&gt; (where &lt;code&gt;nvals&lt;/code&gt; is the number of items in the outer two dimensions of &lt;code&gt;rt&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;rt.values.shape = [nvals] + rt.shape[2:]&lt;/code&gt; (여기서 &lt;code&gt;nvals&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 바깥 두 차원에있는 항목 수입니다 ).</target>
        </trans-unit>
        <trans-unit id="3a2eaaba7b8f626a85344bd55881a32ff6516bc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.values&lt;/code&gt; is a potentially ragged tensor formed by flattening the two outermost dimensions of &lt;code&gt;rt&lt;/code&gt; into a single dimension.</source>
          <target state="translated">&lt;code&gt;rt.values&lt;/code&gt; 는 &lt;code&gt;rt&lt;/code&gt; 의 가장 바깥 쪽 두 치수를 단일 치수로 편 평화하여 형성되는 잠재적으로 거친 텐서 입니다.</target>
        </trans-unit>
        <trans-unit id="daba2e9836693b700454a5e5739d473487a95035" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;rt.with_flat_values(map_fn(fn, rt.flat_values))&lt;/code&gt; (otherwise)</source>
          <target state="translated">&lt;code&gt;rt.with_flat_values(map_fn(fn, rt.flat_values))&lt;/code&gt; (그렇지 않은 경우)</target>
        </trans-unit>
        <trans-unit id="cf20f18403db0f739d347498f6373358f3986fd0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;run_restore_ops(session=None)&lt;/code&gt;: When graph building, runs restore operations. If no &lt;code&gt;session&lt;/code&gt; is explicitly specified, the default session is used. No effect when executing eagerly (restore operations are run eagerly). May only be called when &lt;code&gt;save_path&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;run_restore_ops(session=None)&lt;/code&gt; : 그래프 작성시 복원 작업을 실행합니다. &lt;code&gt;session&lt;/code&gt; 이 명시 적으로 지정 되지 않으면 기본 세션이 사용됩니다. 열심히 실행할 때는 효과가 없습니다 (복원 작업이 열심히 실행 됨). &lt;code&gt;save_path&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우에만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f1d0f7ea393e1950dd444064c975eb2ca55ac28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample_n_shape = [n] + batch_shape + event_shape&lt;/code&gt;, where &lt;code&gt;sample_n_shape&lt;/code&gt; is the shape of the &lt;code&gt;Tensor&lt;/code&gt; returned from &lt;code&gt;sample_n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is the number of samples, &lt;code&gt;batch_shape&lt;/code&gt; defines how many independent distributions there are, and &lt;code&gt;event_shape&lt;/code&gt; defines the shape of samples from each of those independent distributions. Samples are independent along the &lt;code&gt;batch_shape&lt;/code&gt; dimensions, but not necessarily so along the &lt;code&gt;event_shape&lt;/code&gt; dimensions (depending on the particulars of the underlying distribution).</source>
          <target state="translated">&lt;code&gt;sample_n_shape = [n] + batch_shape + event_shape&lt;/code&gt; . 여기서 &lt;code&gt;sample_n_shape&lt;/code&gt; 는 &lt;code&gt;sample_n&lt;/code&gt; 에서 반환 된 &lt;code&gt;Tensor&lt;/code&gt; 의 모양이고 , &lt;code&gt;n&lt;/code&gt; 은 샘플 수이며, &lt;code&gt;batch_shape&lt;/code&gt; 는 독립 분포의 수를 정의하고 , &lt;code&gt;event_shape&lt;/code&gt; 는 각각의 독립적 인 분포 에서 샘플의 모양을 정의합니다. 분포. 표본은 &lt;code&gt;batch_shape&lt;/code&gt; 차원을 따라 독립적 이지만 반드시 기본 분포의 세부 사항에 따라 &lt;code&gt;event_shape&lt;/code&gt; 차원을 따라는 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="096c431363e368732e0d07c7928e6ff5d0ccb912" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sample_weight_mode&lt;/code&gt; for backward compatibility.</source>
          <target state="translated">&lt;code&gt;sample_weight_mode&lt;/code&gt; 이전 버전과의 호환성을위한 sample_weight_mode .</target>
        </trans-unit>
        <trans-unit id="c2b45c7f5b4c3272c0deb6fa92bcf0c5f0048453" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; is a basic convenience wrapper around the &lt;code&gt;write&lt;/code&gt; method, sequentially numbering checkpoints using &lt;code&gt;save_counter&lt;/code&gt; and updating the metadata used by &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. More advanced checkpoint management, for example garbage collection and custom numbering, may be provided by other utilities which also wrap &lt;code&gt;write&lt;/code&gt; (&lt;a href=&quot;../../../train/checkpointmanager&quot;&gt;&lt;code&gt;tf.train.CheckpointManager&lt;/code&gt;&lt;/a&gt; for example).</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 주위에 기본적인 편의 래퍼 &lt;code&gt;write&lt;/code&gt; 순차적 검문소 넘버링 사용 방법 &lt;code&gt;save_counter&lt;/code&gt; 를 에 의해 사용되는 메타 데이터를 업데이트 &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; 를&lt;/a&gt; . 가비지 수집 및 사용자 지정 번호 지정과 같은 고급 검사 점 관리는 &lt;code&gt;write&lt;/code&gt; 를 래핑하는 다른 유틸리티 ( 예 : &lt;a href=&quot;../../../train/checkpointmanager&quot;&gt; &lt;code&gt;tf.train.CheckpointManager&lt;/code&gt; )&lt;/a&gt; 에 의해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55ed7a91924f9f2621271525e9d214a3e1cd4e91" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; is a basic convenience wrapper around the &lt;code&gt;write&lt;/code&gt; method, sequentially numbering checkpoints using &lt;code&gt;save_counter&lt;/code&gt; and updating the metadata used by &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. More advanced checkpoint management, for example garbage collection and custom numbering, may be provided by other utilities which also wrap &lt;code&gt;write&lt;/code&gt; (&lt;a href=&quot;checkpointmanager&quot;&gt;&lt;code&gt;tf.train.CheckpointManager&lt;/code&gt;&lt;/a&gt; for example).</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 주위에 기본적인 편의 래퍼 &lt;code&gt;write&lt;/code&gt; 순차적 검문소 넘버링 사용 방법 &lt;code&gt;save_counter&lt;/code&gt; 를 에 의해 사용되는 메타 데이터를 업데이트 &lt;a href=&quot;latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; 를&lt;/a&gt; . 가비지 수집 및 사용자 지정 번호 지정과 같은 고급 검사 점 관리는 &lt;code&gt;write&lt;/code&gt; 를 래핑하는 다른 유틸리티 ( 예 : &lt;a href=&quot;checkpointmanager&quot;&gt; &lt;code&gt;tf.train.CheckpointManager&lt;/code&gt; )&lt;/a&gt; 에 의해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a939db147d15e406d22cd09b388b6a795c3cac5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save&lt;/code&gt; is a basic convenience wrapper around the &lt;code&gt;write&lt;/code&gt; method, sequentially numbering checkpoints using &lt;code&gt;save_counter&lt;/code&gt; and updating the metadata used by &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. More advanced checkpoint management, for example garbage collection and custom numbering, may be provided by other utilities which also wrap &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;read&lt;/code&gt;. (&lt;a href=&quot;checkpointmanager&quot;&gt;&lt;code&gt;tf.train.CheckpointManager&lt;/code&gt;&lt;/a&gt; for example).</source>
          <target state="translated">&lt;code&gt;save&lt;/code&gt; 는 &lt;code&gt;write&lt;/code&gt; 메서드를 둘러싼 기본 편의 래퍼로 &lt;code&gt;save_counter&lt;/code&gt; 를 사용하여 체크 포인트에 순차적으로 번호를 지정 하고 &lt;a href=&quot;latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; 에서&lt;/a&gt; 사용하는 메타 데이터를 업데이트합니다 . 가비지 수집 및 사용자 지정 번호 지정과 같은 고급 검사 점 관리는 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;read&lt;/code&gt; 래핑하는 다른 유틸리티에서 제공 할 수 있습니다 . ( 예 : &lt;a href=&quot;checkpointmanager&quot;&gt; &lt;code&gt;tf.train.CheckpointManager&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9f1ca9f5e5fb1ca5b4dac73f9ddaae95024dd61a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_checkpoints_secs&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;save_checkpoints_secs&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="28f94d35778bf3776d320dfda972efeec8a1e4d6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_checkpoints_steps&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;save_checkpoints_steps&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="298cfd5d22817bb3de7fed3a3ac26a6cc570f8df" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;save_summary_steps&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;save_summary_steps&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="d20e694ebe37590b8c97b79e469ad47273396d92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;saver&lt;/code&gt;: A &lt;a href=&quot;saver&quot;&gt;&lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt;&lt;/a&gt; object taking care of saving the variables. Picked from and stored into the &lt;code&gt;SAVERS&lt;/code&gt; collection in the graph by default.</source>
          <target state="translated">&lt;code&gt;saver&lt;/code&gt; : 변수 저장을 관리 하는 &lt;a href=&quot;saver&quot;&gt; &lt;code&gt;tf.compat.v1.train.Saver&lt;/code&gt; &lt;/a&gt; 객체. 기본적으로 그래프 의 &lt;code&gt;SAVERS&lt;/code&gt; 콜렉션에서 선택하여 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="701dae60e66abb935332db7834dda3cb904f8a55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scaffold_fn&lt;/code&gt; is a function running on CPU to generate the &lt;code&gt;Scaffold&lt;/code&gt;. This function should not capture any Tensors in &lt;code&gt;model_fn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scaffold_fn&lt;/code&gt; 은 CPU에서 실행되어 &lt;code&gt;Scaffold&lt;/code&gt; 를 생성하는 함수 입니다. 이 함수는 model_fn의 &lt;code&gt;model_fn&lt;/code&gt; 캡처하면 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="640be46715bda9f9db4927e137232063ad014751" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scalar * x&lt;/code&gt; of the same type (&lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;) as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;scalar * x&lt;/code&gt; 동일한 타입 (의 &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;IndexedSlices&lt;/code&gt; )를 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="888d51ba7dacb4e2258b862e963d5f354dc225cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;scale = sigma&lt;/code&gt;, and,</source>
          <target state="translated">&lt;code&gt;scale = sigma&lt;/code&gt; 및</target>
        </trans-unit>
        <trans-unit id="d20f667d797ffb5214c5d9af6b6b37fa9b824539" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self is other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self is other&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="942894e8d67e67d1dae9279c9712881c1725efe0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.dtype&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[B1, ..., Bn]&lt;/code&gt; representing &lt;code&gt;n&lt;/code&gt; different calculations of (Shanon) cross entropy.</source>
          <target state="translated">&lt;code&gt;self.dtype&lt;/code&gt; (Shanon) 교차 엔트로피의 &lt;code&gt;n&lt;/code&gt; 개의 다른 계산을 나타내는 &lt;code&gt;[B1, ..., Bn]&lt;/code&gt; 모양의 self.dtype &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d59a30e57b8e77069af7d20914b31a68bc4056a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self.dtype&lt;/code&gt;&lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;[B1, ..., Bn]&lt;/code&gt; representing &lt;code&gt;n&lt;/code&gt; different calculations of the Kullback-Leibler divergence.</source>
          <target state="translated">&lt;code&gt;self.dtype&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; 모양 &lt;code&gt;[B1, ..., Bn]&lt;/code&gt; 은 Kullback-Leibler 발산의 &lt;code&gt;n&lt;/code&gt; 개의 다른 계산을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="22dc56ff474339754a6ad15eb062739bba5ec320" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;self&lt;/code&gt;, for chaining.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 연결을위한 self .</target>
        </trans-unit>
        <trans-unit id="4bbf6bf5718e138d08610cc8dbe7bccba474f2b5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequence_features&lt;/code&gt; contains &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, and &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor; and each&lt;/code&gt;FixedLenSequenceFeature&lt;code&gt;is mapped to a&lt;/code&gt;Tensor&lt;code&gt;, each of the specified type. The shape will be&lt;/code&gt;(B,T,) + df.dense_shape&lt;code&gt;for&lt;/code&gt;FixedLenSequenceFeaturedf&lt;code&gt;, where&lt;/code&gt;B&lt;code&gt;is the batch size, and&lt;/code&gt;T&lt;code&gt;is the length of the associated&lt;/code&gt;FeatureList&lt;code&gt;in the&lt;/code&gt;SequenceExample&lt;code&gt;. For instance,&lt;/code&gt;FixedLenSequenceFeature([])&lt;code&gt;yields a scalar 2-D&lt;/code&gt;Tensor&lt;code&gt;of static shape&lt;/code&gt;[None, None]&lt;code&gt;and dynamic shape&lt;/code&gt;[B, T]&lt;code&gt;, while&lt;/code&gt;FixedLenSequenceFeature([k])&lt;code&gt;(for&lt;/code&gt;int k &amp;gt;= 1&lt;code&gt;) yields a 3-D matrix&lt;/code&gt;Tensor&lt;code&gt;of static shape&lt;/code&gt;[None, None, k]&lt;code&gt;and dynamic shape&lt;/code&gt;[B, T, k]`.</source>
          <target state="translated">&lt;code&gt;sequence_features&lt;/code&gt; 는 &lt;code&gt;VarLenFeature&lt;/code&gt; , &lt;code&gt;RaggedFeature&lt;/code&gt; 및 &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; 객체를 포함합니다. 각 &lt;code&gt;VarLenFeature&lt;/code&gt; 는 (A)에 맵핑된다 &lt;code&gt;SparseTensor&lt;/code&gt; ; 각 &lt;code&gt;RaggedFeature&lt;/code&gt; 는 RaggedTensor 에 맵핑됩니다 &lt;code&gt;RaggedTensor; and each&lt;/code&gt; FixedLenSequenceFeature &lt;code&gt;is mapped to a&lt;/code&gt; &lt;code&gt;, each of the specified type. The shape will be&lt;/code&gt; Tensor에 맵핑됩니다 . 형상 것 (B, T) + df.dense_shape &lt;code&gt;for&lt;/code&gt; FixedLenSequenceFeaturedf &lt;code&gt;, where&lt;/code&gt; B는 &lt;code&gt;is the batch size, and&lt;/code&gt; T는 &lt;code&gt;is the length of the associated&lt;/code&gt; FeatureList &lt;code&gt;in the&lt;/code&gt; SequenceExample &lt;code&gt;. For instance,&lt;/code&gt; FixedLenSequenceFeature ([]) &lt;code&gt;of static shape&lt;/code&gt; [없음, 없음] &lt;code&gt;and dynamic shape&lt;/code&gt; [B, T] &lt;code&gt;yields a scalar 2-D&lt;/code&gt; 텐서 를 생성하는 &lt;code&gt;, while&lt;/code&gt; FixedLenSequenceFeature ([k]) &lt;code&gt;(for&lt;/code&gt; int k&amp;gt; = 1 &lt;code&gt;) yields a 3-D matrix&lt;/code&gt; &lt;code&gt;of static shape&lt;/code&gt; [없음, 없음, k] &lt;code&gt;and dynamic shape&lt;/code&gt; [B, T, k]`의 텐서 .</target>
        </trans-unit>
        <trans-unit id="455672ec5f5fdd65f368b855563836558c00064f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequence_features&lt;/code&gt; contains &lt;code&gt;VarLenFeature&lt;/code&gt;, &lt;code&gt;RaggedFeature&lt;/code&gt;, and &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; objects. Each &lt;code&gt;VarLenFeature&lt;/code&gt; is mapped to a &lt;code&gt;SparseTensor&lt;/code&gt;; each &lt;code&gt;RaggedFeature&lt;/code&gt; is mapped to a &lt;code&gt;RaggedTensor&lt;/code&gt;; and each &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; is mapped to a &lt;code&gt;Tensor&lt;/code&gt;, each of the specified type. The shape will be &lt;code&gt;(T,) + df.dense_shape&lt;/code&gt; for &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt;&lt;code&gt;df&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the length of the associated &lt;code&gt;FeatureList&lt;/code&gt; in the &lt;code&gt;SequenceExample&lt;/code&gt;. For instance, &lt;code&gt;FixedLenSequenceFeature([])&lt;/code&gt; yields a scalar 1-D &lt;code&gt;Tensor&lt;/code&gt; of static shape &lt;code&gt;[None]&lt;/code&gt; and dynamic shape &lt;code&gt;[T]&lt;/code&gt;, while &lt;code&gt;FixedLenSequenceFeature([k])&lt;/code&gt; (for &lt;code&gt;int k &amp;gt;= 1&lt;/code&gt;) yields a 2-D matrix &lt;code&gt;Tensor&lt;/code&gt; of static shape &lt;code&gt;[None, k]&lt;/code&gt; and dynamic shape &lt;code&gt;[T, k]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sequence_features&lt;/code&gt; 는 &lt;code&gt;VarLenFeature&lt;/code&gt; , &lt;code&gt;RaggedFeature&lt;/code&gt; 및 &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; 객체를 포함합니다. 각 &lt;code&gt;VarLenFeature&lt;/code&gt; 는 (A)에 맵핑된다 &lt;code&gt;SparseTensor&lt;/code&gt; ; 각 &lt;code&gt;RaggedFeature&lt;/code&gt; 는 (A)에 맵핑된다 &lt;code&gt;RaggedTensor&lt;/code&gt; ; 각 &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; 는 지정된 유형의 &lt;code&gt;Tensor&lt;/code&gt; 에 맵핑됩니다 . &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; &lt;code&gt;df&lt;/code&gt; 의 모양은 &lt;code&gt;(T,) + df.dense_shape&lt;/code&gt; 이며 , 여기서 &lt;code&gt;T&lt;/code&gt; 는 &lt;code&gt;SequenceExample&lt;/code&gt; 에서 연관된 &lt;code&gt;FeatureList&lt;/code&gt; 의 길이입니다 . 예를 들어 &lt;code&gt;FixedLenSequenceFeature([])&lt;/code&gt; 는 정적 모양 &lt;code&gt;[None]&lt;/code&gt; 및 동적 모양 &lt;code&gt;[T]&lt;/code&gt; 의 스칼라 1 차원 &lt;code&gt;Tensor&lt;/code&gt; 를 생성하는 반면, &lt;code&gt;FixedLenSequenceFeature([k])&lt;/code&gt; ( &lt;code&gt;int k &amp;gt;= 1&lt;/code&gt; ) 는 정적 모양 의 2 차원 행렬 &lt;code&gt;Tensor&lt;/code&gt; 를 생성합니다 &lt;code&gt;[None, k]&lt;/code&gt; 및 동적 모양 &lt;code&gt;[T, k]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57e736be49a84e8b40dc80450065180d02bd1c38" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sequence_numeric_column&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sequence_numeric_column&lt;/code&gt;.</target>
        </trans-unit>
        <trans-unit id="5e7476fff789379be5c4b1b83d6b6b5104bdfb81" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;session_config&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;session_config&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="d81de1cc4500f69787ff2c5a192e802f6a35040e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;set_verbosity&lt;/code&gt; takes precedence over the environment variable.</source>
          <target state="translated">&lt;code&gt;set_verbosity&lt;/code&gt; 가 환경 변수보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="1513bf02644d5c3e93962479acf633ee1c421345" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shape(output) = [d0, d1, ... dn-1, p1, ..., pm]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shape(output) = [d0, d1, ... dn-1, p1, ..., pm]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c90893c98e4957bd24bbac61faf4a747446793f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shape(output) = [d0, d1, ..., dn-1, p1, ..., pm]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shape(output) = [d0, d1, ..., dn-1, p1, ..., pm]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="646e1b99b5affb2b371b514c133ec4f47a08906a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shape(output) = [d0, p1, ..., pm]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shape(output) = [d0, p1, ..., pm]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0aaa61f583ce883d03b9138f11b6d9aa310b7f33" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shard&lt;/code&gt; is deterministic. The Dataset produced by &lt;code&gt;A.shard(n, i)&lt;/code&gt; will contain all elements of A whose index mod n = i.</source>
          <target state="translated">&lt;code&gt;shard&lt;/code&gt; 는 결정 론적입니다. &lt;code&gt;A.shard(n, i)&lt;/code&gt; 의해 생성 된 데이터 세트 는 인덱스 mod n = i 인 A의 모든 요소를 ​​포함합니다.</target>
        </trans-unit>
        <trans-unit id="fe299aa0f0618d84fb30e2b5cf7f66552498765e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;shard_func&lt;/code&gt; is a user specified function that maps input elements to snapshot shards.</source>
          <target state="translated">&lt;code&gt;shard_func&lt;/code&gt; 는 입력 요소를 스냅 샷 샤드에 매핑하는 사용자 지정 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1dcc1ec2e318b69511c73950d4da3d7fcee8816b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt; is a 1-D int64 tensor with 2 elements representing the crop height and width. The values must be non negative.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 는 자르기 높이와 너비를 나타내는 2 개의 요소가있는 1-D int64 텐서입니다. 값은 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="29529f9eb0c76ce6c7788061dab623cd7b560101" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;size&lt;/code&gt;: A list of ints for the resulting &lt;a href=&quot;../sparse/sparsetensor#dense_shape&quot;&gt;&lt;code&gt;SparseTensor.dense_shape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; : 결과 &lt;a href=&quot;../sparse/sparsetensor#dense_shape&quot;&gt; &lt;code&gt;SparseTensor.dense_shape&lt;/code&gt; &lt;/a&gt; 의 정수 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="0d7a5bb3b3af7d7172ab9e3c549a5e7718ed1964" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slice-spec&lt;/code&gt; itself is a &lt;code&gt;:&lt;/code&gt;-separated list: &lt;code&gt;slice0:slice1:...:sliceN-1&lt;/code&gt; where each &lt;code&gt;sliceI&lt;/code&gt; is either:</source>
          <target state="translated">&lt;code&gt;slice-spec&lt;/code&gt; 자체는이다 &lt;code&gt;:&lt;/code&gt; 단락 지어진리스트 : &lt;code&gt;slice0:slice1:...:sliceN-1&lt;/code&gt; 각 여기서 &lt;code&gt;sliceI&lt;/code&gt; 가 하나이고 :</target>
        </trans-unit>
        <trans-unit id="c4892d4fbf4ea6f6d2b7117edf2d98a5c1d355e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;slice&lt;/code&gt; containing integer constants and/or scalar integer &lt;code&gt;Tensor&lt;/code&gt;s</source>
          <target state="translated">&lt;code&gt;slice&lt;/code&gt; 정수 상수 및 / 또는 스칼라 정수 함유 &lt;code&gt;Tensor&lt;/code&gt; 의</target>
        </trans-unit>
        <trans-unit id="410cc8601818ff361ec6e287c1fae93e167e9764" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sp_ids&lt;/code&gt; and &lt;code&gt;sp_weights&lt;/code&gt; (if not None) are &lt;code&gt;SparseTensor&lt;/code&gt;s with rank of 2. Embeddings are always aggregated along the last dimension.</source>
          <target state="translated">&lt;code&gt;sp_ids&lt;/code&gt; 및 &lt;code&gt;sp_weights&lt;/code&gt; (None이 아닌 경우)는 순위가 2 인 &lt;code&gt;SparseTensor&lt;/code&gt; 입니다. 임베딩은 항상 마지막 차원을 따라 집계됩니다.</target>
        </trans-unit>
        <trans-unit id="fc3ff6cf078ef0710be0d171fe1da3f0cc135558" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sparse_delta.updates.shape[:num_prefix_dims]&lt;/code&gt;&lt;code&gt;== sparse_delta.indices.shape[:num_prefix_dims]&lt;/code&gt;&lt;code&gt;== var.shape[:num_prefix_dims]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;sparse_delta.updates.shape[:num_prefix_dims]&lt;/code&gt; &lt;code&gt;== sparse_delta.indices.shape[:num_prefix_dims]&lt;/code&gt; &lt;code&gt;== var.shape[:num_prefix_dims]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13c63d6457d0c8427e5e9d180b421f9f1c18aba4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sparse_recall_at_k&lt;/code&gt; creates two local variables, &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; and &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt;, that are used to compute the recall_at_k frequency. This frequency is ultimately returned as &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt;: an idempotent operation that simply divides &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; by total (&lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; + &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;sparse_recall_at_k&lt;/code&gt; 는 call_at_k 빈도를 계산하는 데 사용되는 두 개의 로컬 변수 &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; 및 &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; 를 작성합니다. 이 빈도는 궁극적으로 &lt;code&gt;recall_at_&amp;lt;k&amp;gt;&lt;/code&gt; 로 리턴됩니다 . 즉, 단순히 &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; 를 총계 ( &lt;code&gt;true_positive_at_&amp;lt;k&amp;gt;&lt;/code&gt; + &lt;code&gt;false_negative_at_&amp;lt;k&amp;gt;&lt;/code&gt; )로 나누는 dem 등원 연산입니다 .</target>
        </trans-unit>
        <trans-unit id="50186bc137fc825b9d736a9391df19045f5dec78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start,length&lt;/code&gt; where &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are integers. In that case the slice covers &lt;code&gt;length&lt;/code&gt; indices starting at &lt;code&gt;start&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start,length&lt;/code&gt; 여기서 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;length&lt;/code&gt; 는 정수입니다. 이 경우 슬라이스는 &lt;code&gt;start&lt;/code&gt; 에서 시작하는 &lt;code&gt;length&lt;/code&gt; 인덱스를 포함 합니다 .</target>
        </trans-unit>
        <trans-unit id="fec5d3c06e0437e6d7d56b2f803fa66385f5f6ee" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;start_offsets[i1...iN, j]&lt;/code&gt; is the start byte offset for the &lt;code&gt;j&lt;/code&gt;th character in &lt;code&gt;input[i1...iN]&lt;/code&gt;, when decoded using &lt;code&gt;input_encoding&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;start_offsets[i1...iN, j]&lt;/code&gt; 에 대한 오프 스타트 바이트이다 &lt;code&gt;j&lt;/code&gt; 에서 번째 문자를 &lt;code&gt;input[i1...iN]&lt;/code&gt; 이용하여 디코딩하면 &lt;code&gt;input_encoding&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2d4cf6574011d4275672dc4576b2b5078a990ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stddev&lt;/code&gt; is the standard deviation of all values in &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;stddev&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 에있는 모든 값의 표준 편차입니다.</target>
        </trans-unit>
        <trans-unit id="c7ce3dfcbc5a08d2bf869880697b7e7d8b753829" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;steps&lt;/code&gt; batches are processed, or</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 배치가 처리되거나</target>
        </trans-unit>
        <trans-unit id="f04a293cb88e34e3d3d998b0311c5605db296405" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop_gradients&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or a list of tensors to be considered constant with respect to all &lt;code&gt;xs&lt;/code&gt;. These tensors will not be backpropagated through, as though they had been explicitly disconnected using &lt;code&gt;stop_gradient&lt;/code&gt;. Among other things, this allows computation of partial derivatives as opposed to total derivatives. For example:</source>
          <target state="translated">&lt;code&gt;stop_gradients&lt;/code&gt; 는 A는 &lt;code&gt;Tensor&lt;/code&gt; 또는 텐서 목록 모두에 대해 일정한 것으로 간주되는 &lt;code&gt;xs&lt;/code&gt; . 이 텐서는 &lt;code&gt;stop_gradient&lt;/code&gt; 를 사용하여 명시 적으로 연결이 끊어진 것처럼 역 전파되지 않습니다 . 무엇보다도 이것은 총 미분과는 대조적으로 부분 미분을 계산할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c82839dd2177057b14346e206228d504e00b3998" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop_gradients&lt;/code&gt; provides a way of stopping gradient after the graph has already been constructed, as compared to &lt;a href=&quot;../../stop_gradient&quot;&gt;&lt;code&gt;tf.stop_gradient&lt;/code&gt;&lt;/a&gt; which is used during graph construction. When the two approaches are combined, backpropagation stops at both &lt;a href=&quot;../../stop_gradient&quot;&gt;&lt;code&gt;tf.stop_gradient&lt;/code&gt;&lt;/a&gt; nodes and nodes in &lt;code&gt;stop_gradients&lt;/code&gt;, whichever is encountered first.</source>
          <target state="translated">&lt;code&gt;stop_gradients&lt;/code&gt; 는 그래프 구성 중에 사용되는 &lt;a href=&quot;../../stop_gradient&quot;&gt; &lt;code&gt;tf.stop_gradient&lt;/code&gt; &lt;/a&gt; 와 비교하여 그래프가 이미 구성된 후 그라디언트를 중지하는 방법을 제공합니다 . 두 가지 방법이 결합되면, 역 전파는 모두 정차 &lt;a href=&quot;../../stop_gradient&quot;&gt; &lt;code&gt;tf.stop_gradient&lt;/code&gt; 의&lt;/a&gt; 노드와 노드 &lt;code&gt;stop_gradients&lt;/code&gt; 처음 발생 중.</target>
        </trans-unit>
        <trans-unit id="7d592e88c6e89dac3def86f96105f9ab7be7eedb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;stop_gradients&lt;/code&gt; provides a way of stopping gradient after the graph has already been constructed, as compared to &lt;a href=&quot;stop_gradient&quot;&gt;&lt;code&gt;tf.stop_gradient&lt;/code&gt;&lt;/a&gt; which is used during graph construction. When the two approaches are combined, backpropagation stops at both &lt;a href=&quot;stop_gradient&quot;&gt;&lt;code&gt;tf.stop_gradient&lt;/code&gt;&lt;/a&gt; nodes and nodes in &lt;code&gt;stop_gradients&lt;/code&gt;, whichever is encountered first.</source>
          <target state="translated">&lt;code&gt;stop_gradients&lt;/code&gt; 는 그래프 구성 중에 사용되는 &lt;a href=&quot;stop_gradient&quot;&gt; &lt;code&gt;tf.stop_gradient&lt;/code&gt; &lt;/a&gt; 와 비교하여 그래프가 이미 구성된 후 그라디언트를 중지하는 방법을 제공합니다 . 두 가지 방법이 결합되면, 역 전파는 모두 정차 &lt;a href=&quot;stop_gradient&quot;&gt; &lt;code&gt;tf.stop_gradient&lt;/code&gt; 의&lt;/a&gt; 노드와 노드 &lt;code&gt;stop_gradients&lt;/code&gt; 처음 발생 중.</target>
        </trans-unit>
        <trans-unit id="2ac173e6c5970356f9db9390f19c148430319b19" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str&lt;/code&gt;, base directory for the checkpoint files.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; , 체크 포인트 파일의 기본 디렉토리.</target>
        </trans-unit>
        <trans-unit id="0866988e84ef3e8ae4f13f933c19ac36bba877e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str&lt;/code&gt;, base name for the checkpoint files.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; , 체크 포인트 파일의 기본 이름.</target>
        </trans-unit>
        <trans-unit id="e60a2aab2a7377619bc57d8b23628565ac450380" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;str&lt;/code&gt;, metric to track. &quot;loss&quot;, &quot;accuracy&quot;, etc.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; , 추적 할 메트릭. &quot;손실&quot;, &quot;정확도&quot;등</target>
        </trans-unit>
        <trans-unit id="157a9c40a3f7e9a5114d65dfa28aa9ba69eb0058" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strategy&lt;/code&gt; is installed in the global context as the &quot;current&quot; strategy. Inside this scope, &lt;a href=&quot;../../../../distribute/get_strategy&quot;&gt;&lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt;&lt;/a&gt; will now return this strategy. Outside this scope, it returns the default no-op strategy.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 은 &quot;현재&quot;전략으로 글로벌 컨텍스트에 설치됩니다. 이 범위 내에서 &lt;a href=&quot;../../../../distribute/get_strategy&quot;&gt; &lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt; &lt;/a&gt; 는 이제이 전략을 반환합니다. 이 범위 밖에서는 기본 no-op 전략을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5a1ef8f5d39bdac6e53d69ced216d1c0dcef3a2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strategy&lt;/code&gt; is installed in the global context as the &quot;current&quot; strategy. Inside this scope, &lt;a href=&quot;../../../distribute/get_strategy&quot;&gt;&lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt;&lt;/a&gt; will now return this strategy. Outside this scope, it returns the default no-op strategy.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 은 &quot;현재&quot;전략으로 글로벌 컨텍스트에 설치됩니다. 이 범위 내에서 &lt;a href=&quot;../../../distribute/get_strategy&quot;&gt; &lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt; &lt;/a&gt; 는 이제이 전략을 반환합니다. 이 범위 밖에서는 기본 no-op 전략을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f32e0aaef5d9e606ac50c57a5cd2eccb73887797" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strategy&lt;/code&gt; is installed in the global context as the &quot;current&quot; strategy. Inside this scope, &lt;a href=&quot;../get_strategy&quot;&gt;&lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt;&lt;/a&gt; will now return this strategy. Outside this scope, it returns the default no-op strategy.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 은 &quot;현재&quot;전략으로 글로벌 컨텍스트에 설치됩니다. 이 범위 내에서 &lt;a href=&quot;../get_strategy&quot;&gt; &lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt; &lt;/a&gt; 는 이제이 전략을 반환합니다. 이 범위 밖에서는 기본 no-op 전략을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e9f9e024f1a430ac575adc9e1710f54236427160" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strategy&lt;/code&gt; is installed in the global context as the &quot;current&quot; strategy. Inside this scope, &lt;a href=&quot;get_strategy&quot;&gt;&lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt;&lt;/a&gt; will now return this strategy. Outside this scope, it returns the default no-op strategy.</source>
          <target state="translated">&lt;code&gt;strategy&lt;/code&gt; 은 &quot;현재&quot;전략으로 글로벌 컨텍스트에 설치됩니다. 이 범위 내에서 &lt;a href=&quot;get_strategy&quot;&gt; &lt;code&gt;tf.distribute.get_strategy()&lt;/code&gt; &lt;/a&gt; 는 이제이 전략을 반환합니다. 이 범위 밖에서는 기본 no-op 전략을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b510d5ecc3e75f40a3cd995a2bec3190d8a09b25" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;strides&lt;/code&gt; controls the strides for the depthwise convolution only, since the pointwise convolution has implicit strides of &lt;code&gt;[1, 1, 1, 1]&lt;/code&gt;. Must have &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt;. For the most common case of the same horizontal and vertical strides, &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt;. If any value in &lt;code&gt;rate&lt;/code&gt; is greater than 1, we perform atrous depthwise convolution, in which case all values in the &lt;code&gt;strides&lt;/code&gt; tensor must be equal to 1.</source>
          <target state="translated">&lt;code&gt;strides&lt;/code&gt; 점별 컨벌루션에는 &lt;code&gt;[1, 1, 1, 1]&lt;/code&gt; 의 암시 적 보폭이 있으므로 스트라이드는 깊이 컨벌루션에 대한 보폭 만 제어합니다 . &lt;code&gt;strides[0] = strides[3] = 1&lt;/code&gt; 이어야 합니다. 동일한 가로 및 세로 보폭의 가장 일반적인 경우 &lt;code&gt;strides = [1, stride, stride, 1]&lt;/code&gt; 입니다. &lt;code&gt;rate&lt;/code&gt; 의 값 이 1보다 크면 깊이 깊이 컨볼 루션을 수행합니다.이 경우 &lt;code&gt;strides&lt;/code&gt; 텐서의 모든 값은 1과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="c302298ac79e2595af9cc5f3284321eee4e8a7a7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt; or &lt;code&gt;VariableScope&lt;/code&gt;: the scope to open.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;VariableScope&lt;/code&gt; : 열 범위입니다.</target>
        </trans-unit>
        <trans-unit id="cd25f81cbd6d88c8677ad6092d75ed73118910c6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;, the directory to save the profile traces to. Defaults to the current directory.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; , 프로필 추적을 저장할 디렉터리입니다. 기본값은 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="c26eba6251ec787665d9d01eb2f69abed99513f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;string&lt;/code&gt;, the directory to save the summaries to. Only used if no &lt;code&gt;summary_writer&lt;/code&gt; is supplied.</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; , 요약을 저장할 디렉토리입니다. &lt;code&gt;summary_writer&lt;/code&gt; 가 제공 되지 않은 경우에만 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3ff6038467fa0d3c19029df6575065ca2918d4d7" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;structure&lt;/code&gt; is or contains a dict with non-sortable keys.</source>
          <target state="translated">&lt;code&gt;structure&lt;/code&gt; 가 정렬 불가능한 키가있는 dict이거나 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f0073066231c5cb71862111bf7a6a903f8b42dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;summary_op&lt;/code&gt;: An op to run and merge the summaries in the graph. Picked from and stored into the &lt;code&gt;SUMMARY_OP&lt;/code&gt; collection in the graph by default.</source>
          <target state="translated">&lt;code&gt;summary_op&lt;/code&gt; : 그래프에서 요약을 실행하고 병합하는 op입니다. 기본적으로 그래프 의 &lt;code&gt;SUMMARY_OP&lt;/code&gt; 콜렉션에서 선택하여 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="d3d900a58bd65ce454850135c6ba3d721ce6d9f4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sync_rep_local_step&lt;/code&gt;, one per replica. Compared against the global_step in each accumulator to check for staleness of the gradients.</source>
          <target state="translated">&lt;code&gt;sync_rep_local_step&lt;/code&gt; , 복제 본당 하나씩. 각 누산기의 global_step과 비교하여 그래디언트의 부실을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9e5c58a9a8bc7751af35c500c6d89b68a34a4c5b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task&lt;/code&gt; has two attributes: &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;, where &lt;code&gt;type&lt;/code&gt; can be any of the task types in &lt;code&gt;cluster&lt;/code&gt;. When &lt;code&gt;TF_CONFIG&lt;/code&gt; contains said information, the following properties are set on this class:</source>
          <target state="translated">&lt;code&gt;task&lt;/code&gt; 는 &lt;code&gt;type&lt;/code&gt; 과 &lt;code&gt;index&lt;/code&gt; 의 두 가지 속성을 갖습니다. 여기서 &lt;code&gt;type&lt;/code&gt; 은 &lt;code&gt;cluster&lt;/code&gt; 의 작업 유형 중 하나 일 수 있습니다 . 때 &lt;code&gt;TF_CONFIG&lt;/code&gt; 이 정보 말했다 포함, 다음과 같은 속성이 클래스에 설정되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="52f95bdc64cdf099113879949d697a6a7428d6fa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_id&lt;/code&gt; is set to &lt;code&gt;TF_CONFIG['task']['index']&lt;/code&gt;. Must set if &lt;code&gt;cluster_spec&lt;/code&gt; is present; must be 0 (the default value) if &lt;code&gt;cluster_spec&lt;/code&gt; is not set.</source>
          <target state="translated">&lt;code&gt;task_id&lt;/code&gt; 는 &lt;code&gt;TF_CONFIG['task']['index']&lt;/code&gt; 로 설정 됩니다. &lt;code&gt;cluster_spec&lt;/code&gt; 이 있으면 설정해야합니다 . &lt;code&gt;cluster_spec&lt;/code&gt; 이 설정되지 않은 경우 0 (기본값)이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="85042f5c165e23af0729d3fe3cadfcf9a03da360" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;task_type&lt;/code&gt; is set to &lt;code&gt;TF_CONFIG['task']['type']&lt;/code&gt;. Must set if &lt;code&gt;cluster_spec&lt;/code&gt; is present; must be &lt;code&gt;worker&lt;/code&gt; (the default value) if &lt;code&gt;cluster_spec&lt;/code&gt; is not set.</source>
          <target state="translated">&lt;code&gt;task_type&lt;/code&gt; 은 &lt;code&gt;TF_CONFIG['task']['type']&lt;/code&gt; 로 설정 됩니다. &lt;code&gt;cluster_spec&lt;/code&gt; 이 있으면 설정해야합니다 . &lt;code&gt;cluster_spec&lt;/code&gt; 이 설정되지 않은 경우 &lt;code&gt;worker&lt;/code&gt; (기본값) 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="9735698eaa85add902fa78ed54ea94be6539a0e2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor&lt;/code&gt; can have up to 8 dimensions. The number of dimensions of &lt;code&gt;tensor&lt;/code&gt; must equal the number of elements in &lt;code&gt;dims&lt;/code&gt;. In other words:</source>
          <target state="translated">&lt;code&gt;tensor&lt;/code&gt; 는 최대 8 개의 차원을 가질 수 있습니다. &lt;code&gt;tensor&lt;/code&gt; 의 차원 수는 &lt;code&gt;dims&lt;/code&gt; 의 요소 수와 같아야합니다 . 다시 말해:</target>
        </trans-unit>
        <trans-unit id="4f5383048b9882b730b190f5d2adde2465702aa8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor&lt;/code&gt; can have up to 8 dimensions. The number of dimensions specified in &lt;code&gt;axis&lt;/code&gt; may be 0 or more entries. If an index is specified more than once, a InvalidArgument error is raised.</source>
          <target state="translated">&lt;code&gt;tensor&lt;/code&gt; 는 최대 8 개의 치수를 가질 수 있습니다. &lt;code&gt;axis&lt;/code&gt; 지정된 차원 수는 0 개 이상의 항목 일 수 있습니다. 인덱스가 두 번 이상 지정되면 InvalidArgument 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="87428df2bdd46e820e90d79e12c89993f724781c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor_dtype=[&quot;float32&quot;, &quot;float64&quot;]&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;tensor_dtype=[&quot;float32&quot;, &quot;float64&quot;]&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="16eb6fb348d2cc46bc57d244beea3c51673190c2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor_dtype=[tf.float32, tf.float64]&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;tensor_dtype=[tf.float32, tf.float64]&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="8ed3ef7ab5b32079179007b5aa11f7c81534f07f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor_dtype=lambda dtype: dtype.is_integer&lt;/code&gt;. This filter operates in a logical AND relation with &lt;code&gt;op_regex&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensor_dtype=lambda dtype: dtype.is_integer&lt;/code&gt; . 이 필터는 &lt;code&gt;op_regex&lt;/code&gt; 와 논리적 AND 관계로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="e1c21a6c5569e64c2415faec768b5e09d8d129c3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tensor_dtypes=(tf.int32, tf.bool)&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;tensor_dtypes=(tf.int32, tf.bool)&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="eea9f81ae8baaa76ae48fa0e6d7a66d4d5e51ea4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.abs(x[i] - y[i]) &amp;lt;= atol + rtol * tf.abs(y[i])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tf.abs(x[i] - y[i]) &amp;lt;= atol + rtol * tf.abs(y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="815075f9ecb0ce1358e89e00bc4a873050707b70" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.accumulate_n_v2&lt;/code&gt; performs the same operation as &lt;a href=&quot;../math/add_n&quot;&gt;&lt;code&gt;tf.add_n&lt;/code&gt;&lt;/a&gt;, but does not wait for all of its inputs to be ready before beginning to sum. This can save memory if inputs are ready at different times, since minimum temporary storage is proportional to the output size rather than the inputs size.</source>
          <target state="translated">&lt;code&gt;tf.accumulate_n_v2&lt;/code&gt; 의 수행과 같은 작업을 &lt;a href=&quot;../math/add_n&quot;&gt; &lt;code&gt;tf.add_n&lt;/code&gt; 는&lt;/a&gt; 모든 입력이 합계 시작하기 전에 준비를 위해, 그러나 기다리지 않습니다. 최소 임시 저장은 입력 크기가 아닌 출력 크기에 비례하기 때문에 입력이 다른 시간에 준비된 경우 메모리를 절약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a9d27975146474d515a98214aa3d369287b788f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.batch_gather&lt;/code&gt;(&lt;strong&gt;params&lt;/strong&gt;, &lt;strong&gt;indices&lt;/strong&gt;, name=&lt;code&gt;None&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;tf.batch_gather&lt;/code&gt; ( &lt;strong&gt;params&lt;/strong&gt; , &lt;strong&gt;index&lt;/strong&gt; , name = &lt;code&gt;None&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d877e1970df773ebaff68c06753c4edc12d7de8d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.data.Dataset.from_tensor_slices((range(4), range(4))).window(2)&lt;/code&gt; produces &lt;code&gt;{({0, 1}, {0, 1}), ({2, 3}, {2, 3})}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tf.data.Dataset.from_tensor_slices((range(4), range(4))).window(2)&lt;/code&gt; 는 &lt;code&gt;{({0, 1}, {0, 1}), ({2, 3}, {2, 3})}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9967cccbbf69fe66a1d7357dcc814a62b322fd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.data.Dataset.from_tensor_slices({&quot;a&quot;: range(4)}).window(2)&lt;/code&gt; produces &lt;code&gt;{ {&quot;a&quot;: {0, 1} }, {&quot;a&quot;: {2, 3} } }&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tf.data.Dataset.from_tensor_slices({&quot;a&quot;: range(4)}).window(2)&lt;/code&gt; 는 &lt;code&gt;{ {&quot;a&quot;: {0, 1} }, {&quot;a&quot;: {2, 3} } }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f77ac2be56ffd64588af4aa5a33734dc2781cb92" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.data.Dataset.range(7).window(2)&lt;/code&gt; produces &lt;code&gt;{ {0, 1}, {2, 3}, {4, 5}, {6} }&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tf.data.Dataset.range(7).window(2)&lt;/code&gt; 는 &lt;code&gt;{ {0, 1}, {2, 3}, {4, 5}, {6} }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5445633a145b893fdd0c8202bfe123e09966f839" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.data.Dataset.range(7).window(3, 1, 2, True)&lt;/code&gt; produces &lt;code&gt;{ {0, 2, 4}, {1, 3, 5}, {2, 4, 6} }&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tf.data.Dataset.range(7).window(3, 1, 2, True)&lt;/code&gt; 는 &lt;code&gt;{ {0, 2, 4}, {1, 3, 5}, {2, 4, 6} }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b528d8466e744c6b97b67bd8f738fd650e3cb81a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.data.Dataset.range(7).window(3, 2, 1, True)&lt;/code&gt; produces &lt;code&gt;{ {0, 1, 2}, {2, 3, 4}, {4, 5, 6} }&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;tf.data.Dataset.range(7).window(3, 2, 1, True)&lt;/code&gt; 는 &lt;code&gt;{ {0, 1, 2}, {2, 3, 4}, {4, 5, 6} }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d8df28f2427c6d1355e5ca4636d6478f962ebabd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.distribute.is_cross_replica_context()&lt;/code&gt; returns True.</source>
          <target state="translated">&lt;code&gt;tf.distribute.is_cross_replica_context()&lt;/code&gt; 는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ca32be50cf9d3e420f53dec1e24140a70071ded5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.io.RaggedFeature.UniformRowLength(length: int)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tf.io.RaggedFeature.UniformRowLength(length: int)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87688c86fcf929af7a6da356cb1123555e83ad4a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.io.RaggedFeature.UniformRowLength(length: int)&lt;/code&gt;. Where &lt;code&gt;key&lt;/code&gt; is a key for a &lt;code&gt;Feature&lt;/code&gt; in the input &lt;code&gt;Example&lt;/code&gt;, whose parsed &lt;code&gt;Tensor&lt;/code&gt; will be the resulting row-partitioning tensor.</source>
          <target state="translated">&lt;code&gt;tf.io.RaggedFeature.UniformRowLength(length: int)&lt;/code&gt; 입니다. 여기서 &lt;code&gt;key&lt;/code&gt; 는 입력 &lt;code&gt;Example&lt;/code&gt; 의 &lt;code&gt;Feature&lt;/code&gt; 에 대한 키 이며 구문 분석 된 &lt;code&gt;Tensor&lt;/code&gt; 는 결과 행 분할 텐서가됩니다.</target>
        </trans-unit>
        <trans-unit id="770dd6d152166eae73c8e4b7108e8cf41c2d6493" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.newaxis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; as in NumPy.</source>
          <target state="translated">&lt;code&gt;tf.newaxis&lt;/code&gt; 는 NumPy에서와 같이 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9b927018ddf166561a1d3c2abf218df786ebfd9f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.reshape(t, [])&lt;/code&gt; reshapes a tensor &lt;code&gt;t&lt;/code&gt; with one element to a scalar.</source>
          <target state="translated">&lt;code&gt;tf.reshape(t, [])&lt;/code&gt; 는 하나의 요소가있는 텐서 &lt;code&gt;t&lt;/code&gt; 를 스칼라로 재구성합니다 .</target>
        </trans-unit>
        <trans-unit id="6457105a3010e3a88bf1eb75bee16a9a893a3fb4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.stack([self.jacobian(y[i], x[i]) for i in range(x.shape[0])])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tf.stack([self.jacobian(y[i], x[i]) for i in range(x.shape[0])])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ba0e8272744f95a9368b75d2bc26029eb9c47a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; is used to run ops in &lt;code&gt;computation&lt;/code&gt; on CPU instead of running on TPU. For example, users can run ops that are not supported on TPU's (e.g. tf.summary.write()) by explicitly placing those ops on CPU's. Below usage of outside compilation will place ops in &lt;code&gt;computation_with_string_ops&lt;/code&gt; on CPU.</source>
          <target state="translated">&lt;code&gt;tf.tpu.outside_compilation()&lt;/code&gt; 은 TPU에서 실행하는 대신 CPU 에서 &lt;code&gt;computation&lt;/code&gt; 에서 연산 을 실행하는 데 사용됩니다 . 예를 들어, 사용자는 CPU에 해당 op를 명시 적으로 배치하여 TPU에서 지원되지 않는 op (예 : tf.summary.write ())를 실행할 수 있습니다. 외부 편집의 사용 아래에 작전 배치됩니다 &lt;code&gt;computation_with_string_ops&lt;/code&gt; CPU에.</target>
        </trans-unit>
        <trans-unit id="f827ef804a9fea8322ddfcea5bedf64965318aba" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tf_random_seed&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;tf_random_seed&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="3906af07206c75ccc935bdb7caaa06fba191bdcf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thresh == 0.11&lt;/code&gt;: only .1 and 0 will vanish, and the remaining three index/value pairs will be returned.</source>
          <target state="translated">&lt;code&gt;thresh == 0.11&lt;/code&gt; : .1과 0 만 사라지고 나머지 3 개의 인덱스 / 값 쌍이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="840431cfadf98dbe30b989cfe95b424774984efc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thresh == 0.21&lt;/code&gt;: .1, 0, and -.2 will vanish.</source>
          <target state="translated">&lt;code&gt;thresh == 0.21&lt;/code&gt; : .1, 0 및 -.2가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="280c5585cd8673436307d1e8de4951a6d4518079" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;thresh == 0&lt;/code&gt; (the default): all 5 index/value pairs will be returned.</source>
          <target state="translated">&lt;code&gt;thresh == 0&lt;/code&gt; (기본값) : 5 개의 인덱스 / 값 쌍이 모두 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6fbb5be51f10a7438ecd0f27bf948f0f3fd2e4dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threshold == 0.11&lt;/code&gt;: only .1 and 0 will vanish, and the remaining three index/value pairs will be returned.</source>
          <target state="translated">&lt;code&gt;threshold == 0.11&lt;/code&gt; : 0.1과 0 만 사라지고 나머지 3 개의 인덱스 / 값 쌍이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="19895fc3943918169aa21d91246293503c2a9c77" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threshold == 0.21&lt;/code&gt;: .1, 0, and -.2 will vanish.</source>
          <target state="translated">&lt;code&gt;threshold == 0.21&lt;/code&gt; : .1, 0 및 -.2가 사라집니다.</target>
        </trans-unit>
        <trans-unit id="62854c37a81c7c882290f830c805947d95e36e54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;threshold == 0&lt;/code&gt; (the default): all 5 index/value pairs will be returned.</source>
          <target state="translated">&lt;code&gt;threshold == 0&lt;/code&gt; (기본값) : 5 개의 인덱스 / 값 쌍이 모두 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f2a91f2dc27ec33c1246cb8ad2b99f9bbcef2d2c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;total_count = N&lt;/code&gt;, &lt;code&gt;N&lt;/code&gt; a positive integer,</source>
          <target state="translated">&lt;code&gt;total_count = N&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 양의 정수,</target>
        </trans-unit>
        <trans-unit id="894f63534ae12bdd65a3f05d7f6fd44607b7875c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trace(x)&lt;/code&gt; returns the sum along the main diagonal of each inner-most matrix in x. If x is of rank &lt;code&gt;k&lt;/code&gt; with shape &lt;code&gt;[I, J, K, ..., L, M, N]&lt;/code&gt;, then output is a tensor of rank &lt;code&gt;k-2&lt;/code&gt; with dimensions &lt;code&gt;[I, J, K, ..., L]&lt;/code&gt; where</source>
          <target state="translated">&lt;code&gt;trace(x)&lt;/code&gt; 는 x에서 가장 안쪽의 각 행렬의 주 대각선을 따라 합계를 반환합니다. X는 랭크 인 경우 &lt;code&gt;k&lt;/code&gt; 형상 &lt;code&gt;[I, J, K, ..., L, M, N]&lt;/code&gt; 다음 출력 랭크의 텐서 &lt;code&gt;k-2&lt;/code&gt; 치수 &lt;code&gt;[I, J, K, ..., L]&lt;/code&gt; 어디서</target>
        </trans-unit>
        <trans-unit id="22eea82c4a0d366026b86edbfc54b509e8e28f4d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;trace&lt;/code&gt; is useful when debugging, and it always executes during the tracing phase, that is, when the TF graph is constructed.</source>
          <target state="translated">&lt;code&gt;trace&lt;/code&gt; 은 디버깅 할 때 유용하며 추적 단계 동안, 즉 TF 그래프가 구성 될 때 항상 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="148442a2bc8014edaa16e11e8793efe5996a8115" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;train_distribute&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;train_distribute&lt;/code&gt;,</target>
        </trans-unit>
        <trans-unit id="671b9be00a68f860a4ddc23ebc7404ed6cd5a0b9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;training&lt;/code&gt; (boolean, whether the call is in inference mode or training mode)</source>
          <target state="translated">&lt;code&gt;training&lt;/code&gt; (부울, 호출이 추론 모드인지 훈련 모드인지 여부)</target>
        </trans-unit>
        <trans-unit id="797d94d0899887290903cb84b70f420ee5812e9c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;training&lt;/code&gt;: Boolean scalar tensor of Python boolean indicating whether the &lt;code&gt;call&lt;/code&gt; is meant for training or inference.</source>
          <target state="translated">&lt;code&gt;training&lt;/code&gt; : &lt;code&gt;call&lt;/code&gt; 부울 이 훈련 또는 추론을위한 것인지 여부를 나타내는 Python 부울의 부울 스칼라 텐서 .</target>
        </trans-unit>
        <trans-unit id="6ddf80f347a201a2af9e15a414de394f0dca0a1a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;training=False&lt;/code&gt;: The layer will normalize its inputs using the mean and variance of its moving statistics, learned during training.</source>
          <target state="translated">&lt;code&gt;training=False&lt;/code&gt; : 레이어는 훈련 중 학습 된 이동 통계의 평균 및 분산을 사용하여 입력을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="bace120514017367dd8ae7d19a63e77c4918a9db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;training=True&lt;/code&gt;: The layer will normalize its inputs using the mean and variance of the current batch of inputs.</source>
          <target state="translated">&lt;code&gt;training=True&lt;/code&gt; : 레이어는 현재 입력 배치의 평균 및 분산을 사용하여 입력을 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="63088d71cd0e7ad927ebda44a2f187c15d002895" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;true_fn&lt;/code&gt; and &lt;code&gt;false_fn&lt;/code&gt; both return lists of output tensors. &lt;code&gt;true_fn&lt;/code&gt; and &lt;code&gt;false_fn&lt;/code&gt; must have the same non-zero number and type of outputs.</source>
          <target state="translated">&lt;code&gt;true_fn&lt;/code&gt; 및 &lt;code&gt;false_fn&lt;/code&gt; 은 모두 출력 텐서 목록을 반환합니다. &lt;code&gt;true_fn&lt;/code&gt; 및 &lt;code&gt;false_fn&lt;/code&gt; 은 0이 아닌 수와 유형의 출력을 가져야 합니다.</target>
        </trans-unit>
        <trans-unit id="3919ec281af11819e8b74f85033a1b4e0125fe3a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tuple&lt;/code&gt; containing any of the above (for multidimensional indexing)</source>
          <target state="translated">&lt;code&gt;tuple&lt;/code&gt; 위의 항목을 포함하는 튜플 (다차원 인덱싱 용)</target>
        </trans-unit>
        <trans-unit id="8d008c8fb97a0447b9b91db778d1e6dc1c686dc4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tuple&lt;/code&gt; containing any of the above (for multidimentional indexing)</source>
          <target state="translated">&lt;code&gt;tuple&lt;/code&gt; 상기 중 어느 것을 포함하는 튜플 (다차원 인덱스 용)</target>
        </trans-unit>
        <trans-unit id="7f227b3fcf44645f574b5f889736afe316c8bd0f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unconnected_gradients&lt;/code&gt; determines the value returned for each x in xs if it is unconnected in the graph to ys. By default this is None to safeguard against errors. Mathematically these gradients are zero which can be requested using the &lt;code&gt;'zero'&lt;/code&gt; option. &lt;code&gt;tf.UnconnectedGradients&lt;/code&gt; provides the following options and behaviors:</source>
          <target state="translated">&lt;code&gt;unconnected_gradients&lt;/code&gt; 는 그래프에서 ys에 연결되지 않은 경우 xs의 각 x에 대해 반환되는 값을 결정합니다. 기본적으로 이것은 오류를 방지하기 위해 없음입니다. 수학적으로 이러한 그라디언트는 0이며 &lt;code&gt;'zero'&lt;/code&gt; 옵션을 사용하여 요청할 수 있습니다 . &lt;code&gt;tf.UnconnectedGradients&lt;/code&gt; 는 다음 옵션 및 동작을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="10c92e5196997b9a0fd9bec426230e09a5b3916a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;uniform_row_length&lt;/code&gt;: A scalar tensor, specifying the length of every row. This row-partitioning scheme may only be used if all rows have the same length.</source>
          <target state="translated">&lt;code&gt;uniform_row_length&lt;/code&gt; : 모든 행의 길이를 지정하는 스칼라 텐서. 이 행 분할 방식은 모든 행의 길이가 동일한 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="295c980e1d2597f85400bb2e6593ddcc1845a231" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unique_name&lt;/code&gt; is used to generate structured names, separated by &lt;code&gt;&quot;/&quot;&lt;/code&gt;, to help identify operations when debugging a graph. Operation names are displayed in error messages reported by the TensorFlow runtime, and in various visualization tools such as TensorBoard.</source>
          <target state="translated">&lt;code&gt;unique_name&lt;/code&gt; 은 &lt;code&gt;&quot;/&quot;&lt;/code&gt; 로 구분 된 구조화 된 이름을 생성 하여 그래프를 디버깅 할 때 조작을 식별하는 데 사용됩니다. 작업 이름은 TensorFlow 런타임에서보고 된 오류 메시지와 TensorBoard와 같은 다양한 시각화 도구에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2bfff02397e8817c544b00954e9fd1488a5f2c3e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;unroll&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;unroll&lt;/code&gt; 은 &lt;code&gt;False&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="604abf505f0c8e22dc322040092b14c23c7fb7db" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;update_state()&lt;/code&gt;: Has all updates to the state variables like: self.var.assign_add(...).</source>
          <target state="translated">&lt;code&gt;update_state()&lt;/code&gt; : self.var.assign_add (...)와 같은 상태 변수에 대한 모든 업데이트가 있습니다.</target>
        </trans-unit>
        <trans-unit id="89b82b6e27a8bb5e2c50fb4cc27e4cd73ed5ef9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updates.shape[:num_prefix_dims]&lt;/code&gt;&lt;code&gt;== indices.shape[:num_prefix_dims]&lt;/code&gt;&lt;code&gt;== var.shape[:num_prefix_dims]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;updates.shape[:num_prefix_dims]&lt;/code&gt; &lt;code&gt;== indices.shape[:num_prefix_dims]&lt;/code&gt; &lt;code&gt;== var.shape[:num_prefix_dims]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b353a4d01bad34e4441bfa97fea0bbe112b5c61" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;updates&lt;/code&gt; is &lt;code&gt;Tensor&lt;/code&gt; of rank &lt;code&gt;Q-1+P-K&lt;/code&gt; with shape:</source>
          <target state="translated">&lt;code&gt;updates&lt;/code&gt; 는 &lt;code&gt;Q-1+P-K&lt;/code&gt; 등급의 &lt;code&gt;Tensor&lt;/code&gt; 모양입니다.</target>
        </trans-unit>
        <trans-unit id="94a942cb5078fae23f62b6fb3e4087909d68dae0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;use_bias&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;use_bias&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 입니다</target>
        </trans-unit>
        <trans-unit id="f543e5d42e72942a9dfe1eb9122761a760b07947" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;validate_indices&lt;/code&gt;: DEPRECATED. If this operation is assigned to CPU, values in &lt;code&gt;indices&lt;/code&gt; are always validated to be within range. If assigned to GPU, out-of-bound indices result in safe but unspecified behavior, which may include raising an error.</source>
          <target state="translated">&lt;code&gt;validate_indices&lt;/code&gt; : DEPRECATED. 이 작업이 CPU에 할당되면 &lt;code&gt;indices&lt;/code&gt; 값 이 항상 범위 내에 있는지 확인됩니다. GPU에 할당 된 경우 경계를 벗어난 인덱스는 안전하지만 지정되지 않은 동작을 발생시켜 오류 발생을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb32510516f233262bf1ee179820c25568a5c5b0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value&lt;/code&gt; safely cast to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 안전하게 캐스팅 &lt;code&gt;dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30939ecc0801d5d67e6e615965e6e956cbd91cb" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value_key&lt;/code&gt; specifies the feature key for a variable-length list of values; and &lt;code&gt;partitions&lt;/code&gt; specifies zero or more feature keys for partitioning those values into higher dimensions. Each element of &lt;code&gt;partitions&lt;/code&gt; must be one of the following:</source>
          <target state="translated">&lt;code&gt;value_key&lt;/code&gt; 는 가변 길이 값 목록의 기능 키를 지정합니다. 및 &lt;code&gt;partitions&lt;/code&gt; 지정 제로 또는 더 높은 차원에 해당 값을 구획 이상의 기능 키. &lt;code&gt;partitions&lt;/code&gt; 각 요소 는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d5ed97fee6371373b8412f13291d9bd100c70a14" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value_key&lt;/code&gt;: The name of key for a &lt;code&gt;Feature&lt;/code&gt; in the &lt;code&gt;Example&lt;/code&gt; whose parsed &lt;code&gt;Tensor&lt;/code&gt; will be the resulting &lt;a href=&quot;../sparse/sparsetensor#values&quot;&gt;&lt;code&gt;SparseTensor.values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;value_key&lt;/code&gt; : 구문 분석 된 &lt;code&gt;Tensor&lt;/code&gt; 가 결과 &lt;a href=&quot;../sparse/sparsetensor#values&quot;&gt; &lt;code&gt;SparseTensor.values&lt;/code&gt; &lt;/a&gt; 인 &lt;code&gt;Example&lt;/code&gt; 의 &lt;code&gt;Feature&lt;/code&gt; 에 대한 키 이름입니다 .</target>
        </trans-unit>
        <trans-unit id="714d256be3a4996123973d1196888fdae4b70163" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value_rowids&lt;/code&gt; and &lt;code&gt;nrows&lt;/code&gt;: &lt;code&gt;value_rowids&lt;/code&gt; is a vector with shape &lt;code&gt;[nvals]&lt;/code&gt;, corresponding one-to-one with &lt;code&gt;values&lt;/code&gt;, which specifies each value's row index. In particular, the row &lt;code&gt;rt[row]&lt;/code&gt; consists of the values &lt;code&gt;rt.values[j]&lt;/code&gt; where &lt;code&gt;value_rowids[j]==row&lt;/code&gt;. &lt;code&gt;nrows&lt;/code&gt; is an integer scalar that specifies the number of rows in the &lt;code&gt;RaggedTensor&lt;/code&gt;. (&lt;code&gt;nrows&lt;/code&gt; is used to indicate trailing empty rows.)</source>
          <target state="translated">&lt;code&gt;value_rowids&lt;/code&gt; 및 &lt;code&gt;nrows&lt;/code&gt; : &lt;code&gt;value_rowids&lt;/code&gt; 는 모양이 &lt;code&gt;[nvals]&lt;/code&gt; 인 벡터 이며 &lt;code&gt;values&lt;/code&gt; 과 일대일로 대응 되며 각 값의 행 인덱스를 지정합니다. 특히 &lt;code&gt;rt[row]&lt;/code&gt; 은 &lt;code&gt;rt.values[j]&lt;/code&gt; 값으로 구성되며 여기서 &lt;code&gt;value_rowids[j]==row&lt;/code&gt; 입니다. &lt;code&gt;nrows&lt;/code&gt; 는 &lt;code&gt;RaggedTensor&lt;/code&gt; 의 행 수를 지정하는 정수 스칼라입니다 . ( &lt;code&gt;nrows&lt;/code&gt; 는 후행 빈 행을 나타내는 데 사용됩니다.)</target>
        </trans-unit>
        <trans-unit id="d6f130315a2be267de45a5b36fc0cebf40208942" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value_splits = ()&lt;/code&gt; if &lt;code&gt;rt.values&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value_splits = ()&lt;/code&gt; 경우 &lt;code&gt;rt.values&lt;/code&gt; 는 A는 &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52807a928d403c030532fe0aa0c705a04886dcf5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;value_splits = rt.values.nested_row_splits&lt;/code&gt; otherwise.</source>
          <target state="translated">&lt;code&gt;value_splits = rt.values.nested_row_splits&lt;/code&gt; 그렇지 않으면.</target>
        </trans-unit>
        <trans-unit id="37919a4feb071a741ac1a024ce80d80a3560695a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values&lt;/code&gt; is simply &lt;code&gt;sp_values.values&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 은 단순히 &lt;code&gt;sp_values.values&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7face91423814c6d0b2c776f53f965813931d351" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values&lt;/code&gt;: A 1-D tensor of any type and shape &lt;code&gt;[N]&lt;/code&gt;, which supplies the values for each element in &lt;code&gt;indices&lt;/code&gt;. For example, given &lt;code&gt;indices=[[1,3], [2,4]]&lt;/code&gt;, the parameter &lt;code&gt;values=[18, 3.6]&lt;/code&gt; specifies that element [1,3] of the sparse tensor has a value of 18, and element [2,4] of the tensor has a value of 3.6.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; : 모든 유형 및 모양의 1 차원 텐서 &lt;code&gt;[N]&lt;/code&gt; 로 , 각 요소의 값을 &lt;code&gt;indices&lt;/code&gt; 합니다. 예를 들어, &lt;code&gt;indices=[[1,3], [2,4]]&lt;/code&gt; 인 경우 매개 변수 &lt;code&gt;values=[18, 3.6]&lt;/code&gt; 은 희소 텐서의 [1,3] 요소에 18 값이 있고 [ 텐서의 2,4]의 값은 3.6입니다.</target>
        </trans-unit>
        <trans-unit id="aa34aa08651f9d69dbe26cc6731124cb0ee9cc59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;values&lt;/code&gt;: A &lt;code&gt;Tensor&lt;/code&gt; of any dtype with shape &lt;code&gt;[D0, D1, ..., Dn]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; : 모양이 &lt;code&gt;[D0, D1, ..., Dn]&lt;/code&gt; dtype 의 &lt;code&gt;Tensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f55503c2f9eb26695df561a0276c3b2c018499b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var_list&lt;/code&gt; must be a list of &lt;code&gt;Variable&lt;/code&gt; or &lt;code&gt;Tensor&lt;/code&gt; objects. This method creates shadow variables for all elements of &lt;code&gt;var_list&lt;/code&gt;. Shadow variables for &lt;code&gt;Variable&lt;/code&gt; objects are initialized to the variable's initial value. They will be added to the &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; collection. For &lt;code&gt;Tensor&lt;/code&gt; objects, the shadow variables are initialized to 0 and zero debiased (see docstring in &lt;code&gt;assign_moving_average&lt;/code&gt; for more details).</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 는 &lt;code&gt;Variable&lt;/code&gt; 또는 &lt;code&gt;Tensor&lt;/code&gt; 객체 의 목록이어야 합니다. 이 메소드는 &lt;code&gt;var_list&lt;/code&gt; 의 모든 요소에 대한 쉐도우 변수를 만듭니다 . &lt;code&gt;Variable&lt;/code&gt; 객체의 그림자 변수 는 변수의 초기 값으로 초기화됩니다. 그것들은 &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; 컬렉션에 추가됩니다 . 들면 &lt;code&gt;Tensor&lt;/code&gt; 개체 그림자 변수 (참조 문에 참조 0으로 초기화되어 제로 debiased &lt;code&gt;assign_moving_average&lt;/code&gt; 자세한 내용).</target>
        </trans-unit>
        <trans-unit id="a79096dd852bce13eefaf7b58d1d7a81516f8343" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var_list&lt;/code&gt; specifies the variables that will be saved and restored. It can be passed as a &lt;code&gt;dict&lt;/code&gt; or a list:</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 는 저장 및 복원 될 변수를 지정합니다. &lt;code&gt;dict&lt;/code&gt; 또는 list 로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77612e7bf05dedba7748de3b458a0acd6c0ab784" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vocabulary_file&lt;/code&gt; is missing or cannot be opened.</source>
          <target state="translated">&lt;code&gt;vocabulary_file&lt;/code&gt; 이 없거나 열 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f31ac297811109eab7018115efe4be6f13c83e8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;vocabulary_size&lt;/code&gt; is missing or &amp;lt; 1.</source>
          <target state="translated">&lt;code&gt;vocabulary_size&lt;/code&gt; 가 누락되었거나 1 미만입니다.</target>
        </trans-unit>
        <trans-unit id="2b2818f13c35d7a4fef8380ae907be0f6a6b0a93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;w_ru&lt;/code&gt; can be segmented into 4 different matrices.</source>
          <target state="translated">&lt;code&gt;w_ru&lt;/code&gt; 는 4 개의 다른 행렬로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d9825e3dd7cc3d275d125000799f71bfdb65525" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;wait_for_session()&lt;/code&gt; waits for a model to be initialized by other processes.</source>
          <target state="translated">&lt;code&gt;wait_for_session()&lt;/code&gt; 은 다른 프로세스에 의해 모델이 초기화 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="240d9afc23665503718aa7615612e28120095e24" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weights&lt;/code&gt; acts as a coefficient for the loss. If a scalar is provided, then the loss is simply scaled by the given value. If &lt;code&gt;weights&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; of shape &lt;code&gt;[batch_size]&lt;/code&gt;, then the total loss for each sample of the batch is rescaled by the corresponding element in the &lt;code&gt;weights&lt;/code&gt; vector. If the shape of &lt;code&gt;weights&lt;/code&gt; matches the shape of &lt;code&gt;predictions&lt;/code&gt;, then the loss of each measurable element of &lt;code&gt;predictions&lt;/code&gt; is scaled by the corresponding value of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 는 손실 계수로 작용합니다. 스칼라가 제공되면 손실은 주어진 값으로 간단히 조정됩니다. 경우 &lt;code&gt;weights&lt;/code&gt; A는 &lt;code&gt;Tensor&lt;/code&gt; 형상은 &lt;code&gt;[batch_size]&lt;/code&gt; 다음 배치의 각각의 샘플에 대한 총 손실은의 대응 요소에 의해 재 스케일링되는 &lt;code&gt;weights&lt;/code&gt; 벡터. 형상 경우 &lt;code&gt;weights&lt;/code&gt; 의 형상과 일치 &lt;code&gt;predictions&lt;/code&gt; 다음의 각 측정 원소의 손실 &lt;code&gt;predictions&lt;/code&gt; 의 대응하는 값에 의해 스케일링되는 &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a38eab8c10e30c06130f9a83da075fede481276d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weights&lt;/code&gt; acts as a coefficient for the loss. If a scalar is provided, then the loss is simply scaled by the given value. If &lt;code&gt;weights&lt;/code&gt; is a tensor of shape &lt;code&gt;[batch_size]&lt;/code&gt;, then the loss weights apply to each corresponding sample.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 는 손실 계수로 작용합니다. 스칼라가 제공되면 손실은 주어진 값으로 간단히 조정됩니다. 경우 &lt;code&gt;weights&lt;/code&gt; 형상의 텐서 인 &lt;code&gt;[batch_size]&lt;/code&gt; 다음 손실 가중치는 각각 대응하는 샘플에 적용된다.</target>
        </trans-unit>
        <trans-unit id="1434f805ebb4fbe6c9df03b5666230fa99fbc0ec" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weights&lt;/code&gt; acts as a coefficient for the loss. If a scalar is provided, then the loss is simply scaled by the given value. If &lt;code&gt;weights&lt;/code&gt; is a tensor of size &lt;code&gt;[batch_size]&lt;/code&gt;, then the total loss for each sample of the batch is rescaled by the corresponding element in the &lt;code&gt;weights&lt;/code&gt; vector.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 는 손실 계수로 작용합니다. 스칼라가 제공되면 손실은 주어진 값으로 간단히 조정됩니다. 경우 &lt;code&gt;weights&lt;/code&gt; 크기의 텐서 인 &lt;code&gt;[batch_size]&lt;/code&gt; 다음 배치의 각각의 샘플에 대한 총 손실은의 대응 요소에 의해 재 스케일링되는 &lt;code&gt;weights&lt;/code&gt; 벡터.</target>
        </trans-unit>
        <trans-unit id="83889f9b6b34ccbb04b78c7a7e2bdacc8ba5caa1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;weights&lt;/code&gt; acts as a coefficient for the loss. If a scalar is provided, then the loss is simply scaled by the given value. If &lt;code&gt;weights&lt;/code&gt; is a tensor of size &lt;code&gt;[batch_size]&lt;/code&gt;, then the total loss for each sample of the batch is rescaled by the corresponding element in the &lt;code&gt;weights&lt;/code&gt; vector. If the shape of &lt;code&gt;weights&lt;/code&gt; matches the shape of &lt;code&gt;predictions&lt;/code&gt;, then the loss of each measurable element of &lt;code&gt;predictions&lt;/code&gt; is scaled by the corresponding value of &lt;code&gt;weights&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 는 손실 계수로 작용합니다. 스칼라가 제공되면 손실은 주어진 값으로 간단히 조정됩니다. 경우 &lt;code&gt;weights&lt;/code&gt; 크기의 텐서 인 &lt;code&gt;[batch_size]&lt;/code&gt; 다음 배치의 각각의 샘플에 대한 총 손실은의 대응 요소에 의해 재 스케일링되는 &lt;code&gt;weights&lt;/code&gt; 벡터. 형상 경우 &lt;code&gt;weights&lt;/code&gt; 의 형상과 일치 &lt;code&gt;predictions&lt;/code&gt; 다음의 각 측정 원소의 손실 &lt;code&gt;predictions&lt;/code&gt; 의 대응하는 값에 의해 스케일링되는 &lt;code&gt;weights&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72785cacd008cff8541310d033989f383baa044b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;while_loop&lt;/code&gt; implements non-strict semantics, enabling multiple iterations to run in parallel. The maximum number of parallel iterations can be controlled by &lt;code&gt;parallel_iterations&lt;/code&gt;, which gives users some control over memory consumption and execution order. For correct programs, &lt;code&gt;while_loop&lt;/code&gt; should return the same result for any parallel_iterations &amp;gt; 0.</source>
          <target state="translated">&lt;code&gt;while_loop&lt;/code&gt; 는 엄격하지 않은 의미를 구현하여 여러 반복이 병렬로 실행될 수 있도록합니다. 병렬 반복의 최대 수를 제어 할 수 &lt;code&gt;parallel_iterations&lt;/code&gt; 사용자에게 메모리 소비 및 실행 순서를 일부 제어를 제공한다. 올바른 프로그램의 경우 &lt;code&gt;while_loop&lt;/code&gt; 는 parallel_iterations&amp;gt; 0에 대해 동일한 결과를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="713b0fc22821db0f21fff82db6c1560f146d36da" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write&lt;/code&gt; does not number checkpoints, increment &lt;code&gt;save_counter&lt;/code&gt;, or update the metadata used by &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. It is primarily intended for use by higher level checkpoint management utilities. &lt;code&gt;save&lt;/code&gt; provides a very basic implementation of these features.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 는 체크 포인트에 번호를 &lt;code&gt;save_counter&lt;/code&gt; 거나 save_counter를 증가 시키 거나 &lt;a href=&quot;../../../train/latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; 가&lt;/a&gt; 사용하는 메타 데이터를 업데이트 하지 않습니다 . 주로 고급 검사 점 관리 유틸리티에서 사용하도록 만들어졌습니다. &lt;code&gt;save&lt;/code&gt; 는 이러한 기능을 매우 기본적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="51ddb7fd4bcc0933b773796e19686e5885fd3c95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;write&lt;/code&gt; does not number checkpoints, increment &lt;code&gt;save_counter&lt;/code&gt;, or update the metadata used by &lt;a href=&quot;latest_checkpoint&quot;&gt;&lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt;&lt;/a&gt;. It is primarily intended for use by higher level checkpoint management utilities. &lt;code&gt;save&lt;/code&gt; provides a very basic implementation of these features.</source>
          <target state="translated">&lt;code&gt;write&lt;/code&gt; 는 체크 포인트에 번호를 &lt;code&gt;save_counter&lt;/code&gt; 거나 save_counter를 증가 시키 거나 &lt;a href=&quot;latest_checkpoint&quot;&gt; &lt;code&gt;tf.train.latest_checkpoint&lt;/code&gt; 가&lt;/a&gt; 사용하는 메타 데이터를 업데이트 하지 않습니다 . 주로 고급 검사 점 관리 유틸리티에서 사용하도록 만들어졌습니다. &lt;code&gt;save&lt;/code&gt; 는 이러한 기능을 매우 기본적으로 구현합니다.</target>
        </trans-unit>
        <trans-unit id="f84ddfacd76c034cbb445b9b2709556460d1bbc2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x * log1p(y)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x * log1p(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="362f5ba7e6596e2efc8a5be34316c6a0c1e8160f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x / y&lt;/code&gt; evaluated in floating point.</source>
          <target state="translated">&lt;code&gt;x / y&lt;/code&gt; 부동 소수점에서 x / y 평가.</target>
        </trans-unit>
        <trans-unit id="a54d5566b86217cb67b2c6e5cafb5aac909bdde2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x / y&lt;/code&gt; returns the quotient of x and y.</source>
          <target state="translated">&lt;code&gt;x / y&lt;/code&gt; 는 x와 y의 몫을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="cb4ec0fef104577ba917ac0c79751cf670af8e86" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x / y&lt;/code&gt; rounded down.</source>
          <target state="translated">&lt;code&gt;x / y&lt;/code&gt; 내림.</target>
        </trans-unit>
        <trans-unit id="6097dcab013032da28b581dd65c6e5e71c7bf244" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x in S^{k-1}&lt;/code&gt;, i.e., the &lt;code&gt;(k-1)&lt;/code&gt;-simplex,</source>
          <target state="translated">&lt;code&gt;x in S^{k-1}&lt;/code&gt; , 즉 &lt;code&gt;(k-1)&lt;/code&gt; -simplex,</target>
        </trans-unit>
        <trans-unit id="786104e6349d4e0c07e86385c90ba103ef37cc66" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.shape[0]&lt;/code&gt; : 100 : append to output shape</source>
          <target state="translated">&lt;code&gt;x.shape[0]&lt;/code&gt; : 100 : 출력 모양에 추가</target>
        </trans-unit>
        <trans-unit id="60e7f6d00277776404da39057d36450e548fc457" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x.shape[1]&lt;/code&gt; : 20 : do not append to output shape, dimension 1 of &lt;code&gt;x&lt;/code&gt; has been summed over. (&lt;code&gt;dot_axes[0]&lt;/code&gt; = 1)</source>
          <target state="translated">&lt;code&gt;x.shape[1]&lt;/code&gt; : 20 : 출력 모양에 추가하지 않습니다 . &lt;code&gt;x&lt;/code&gt; 의 차원 1 이 합산되었습니다. ( &lt;code&gt;dot_axes[0]&lt;/code&gt; = 1)</target>
        </trans-unit>
        <trans-unit id="8750d18a0c99edc276aecb1282ebcfd23320fda2" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same numeric type. If the inputs are floating point, the output will have the same type. If the inputs are integral, the inputs are cast to &lt;code&gt;float32&lt;/code&gt; for &lt;code&gt;int8&lt;/code&gt; and &lt;code&gt;int16&lt;/code&gt; and &lt;code&gt;float64&lt;/code&gt; for &lt;code&gt;int32&lt;/code&gt; and &lt;code&gt;int64&lt;/code&gt; (matching the behavior of Numpy).</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 숫자 유형이어야합니다. 입력이 부동 소수점 인 경우 출력의 유형은 동일합니다. 입력이 필수 인 경우, 입력이 캐스팅되어 &lt;code&gt;float32&lt;/code&gt; 에 대해 &lt;code&gt;int8&lt;/code&gt; 및 &lt;code&gt;int16&lt;/code&gt; 및 &lt;code&gt;float64&lt;/code&gt; 에 대한 &lt;code&gt;int32&lt;/code&gt; 및 &lt;code&gt;int64&lt;/code&gt; (NumPy와의 동작을 일치).</target>
        </trans-unit>
        <trans-unit id="ae1476a377ccf9036856469cca53f482a3e1c715" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same type, and the result will have the same type as well.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 유형이어야하며 결과도 같은 유형입니다.</target>
        </trans-unit>
        <trans-unit id="de7a983c8086da94175a92b83634c263c6a52ed1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; does not have rank at least &lt;code&gt;rank&lt;/code&gt;, but the rank cannot be statically determined.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 순위가 최소 &lt;code&gt;rank&lt;/code&gt; 가 아니지만 순위를 정적으로 결정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bd6e5f5de74e2f02004a0761e008b3e043e03d79" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; does not have rank in &lt;code&gt;ranks&lt;/code&gt;, but the rank cannot be statically determined.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 순위에 &lt;code&gt;ranks&lt;/code&gt; 가 없지만 순위를 정적으로 결정할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="07961df059e18dfd9e5fb27020b179973ed12cc6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a batch matrix with compatible shape for &lt;code&gt;matmul&lt;/code&gt; if</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 &lt;code&gt;matmul&lt;/code&gt; if 와 호환되는 모양을 가진 배치 행렬입니다</target>
        </trans-unit>
        <trans-unit id="c4ad20f657d1137650e53e18f479f3ff481ff757" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a sequence of (nested structures of) &lt;code&gt;Tensor&lt;/code&gt; inputs to the function.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 함수에 대한 &lt;code&gt;Tensor&lt;/code&gt; 입력 의 시퀀스 (중첩 된 구조) 입니다.</target>
        </trans-unit>
        <trans-unit id="bda9c20328479b4852018d7c802c8710e9efa046" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is a sequence of &lt;code&gt;Tensor&lt;/code&gt; inputs to the function.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 함수에 대한 일련의 &lt;code&gt;Tensor&lt;/code&gt; 입력입니다.</target>
        </trans-unit>
        <trans-unit id="31ac8fe650441d10bc7dd1bf17f542d7067acd78" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is changed in-place since the function is mainly used internally to standardize images and feed them to your network. If a copy of &lt;code&gt;x&lt;/code&gt; would be created instead it would have a significant performance cost. If you want to apply this method without changing the input in-place you can call the method creating a copy before:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 내부적으로 이미지를 표준화하고 네트워크에 공급하는 데 주로 사용되기 때문에 내부적으로 변경됩니다. &lt;code&gt;x&lt;/code&gt; 의 복사본이 대신 생성되면 상당한 성능 비용이 발생합니다. 입력을 변경하지 않고이 메서드를 적용하려면 이전에 복사본을 만드는 메서드를 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb9b5e08f3aa0df6376328ce8785118b714c1873" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is changed in-place since the function is mainly used internally to standarize images and feed them to your network. If a copy of &lt;code&gt;x&lt;/code&gt; would be created instead it would have a significant performance cost. If you want to apply this method without changing the input in-place you can call the method creating a copy before:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 이 기능은 주로 이미지를 표준화하고 네트워크에 공급하기 위해 내부적으로 사용되므로 x 가 현재 위치에서 변경되었습니다. &lt;code&gt;x&lt;/code&gt; 의 사본이 대신 작성되면 상당한 성능 비용이 발생합니다. 입력을 변경하지 않고이 메소드를 적용하려면 먼저 사본을 작성하는 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="30ae84982c725773533eafcc255342f241353f8f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;x&lt;/code&gt; is not a dict or array.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 는 dict 또는 배열이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e0b58b8d16ef1e012623036ac159378b9dd240f9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y = sign(x) = -1&lt;/code&gt; if &lt;code&gt;x &amp;lt; 0&lt;/code&gt;; 0 if &lt;code&gt;x == 0&lt;/code&gt;; 1 if &lt;code&gt;x &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;y = sign(x) = -1&lt;/code&gt; &lt;code&gt;x &amp;lt; 0&lt;/code&gt; 경우 y = 부호 (x) = -1 ; 만약 0 &lt;code&gt;x == 0&lt;/code&gt; ; 1이면 &lt;code&gt;x &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8781b4c809de5172fd069d763c42f75cabd758f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y.shape[0]&lt;/code&gt; : 100 : do not append to output shape, always ignore first dimension of &lt;code&gt;y&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;y.shape[0]&lt;/code&gt; : 100 : 출력 모양에 추가하지 않고 항상 &lt;code&gt;y&lt;/code&gt; 의 첫 번째 차원을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="014efd34c7ac3e103f9b43882b41d6dc719fd204" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y.shape[1]&lt;/code&gt; : 30 : append to output shape</source>
          <target state="translated">&lt;code&gt;y.shape[1]&lt;/code&gt; : 30 : 출력 모양에 추가</target>
        </trans-unit>
        <trans-unit id="40719df09ec17a803fb0624a91049d4021792cdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y.shape[2]&lt;/code&gt; : 20 : do not append to output shape, dimension 2 of &lt;code&gt;y&lt;/code&gt; has been summed over. (&lt;code&gt;dot_axes[1]&lt;/code&gt; = 2) &lt;code&gt;output_shape&lt;/code&gt; = &lt;code&gt;(100, 30)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;y.shape[2]&lt;/code&gt; : 20 : 출력 모양에 추가하지 않습니다 . &lt;code&gt;y&lt;/code&gt; 의 차원 2 가 합산되었습니다. ( &lt;code&gt;dot_axes[1]&lt;/code&gt; = 2) &lt;code&gt;output_shape&lt;/code&gt; = &lt;code&gt;(100, 30)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d31e425e0d47a79c4ee7454ebf457707d70be287" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; is a (nested structure of) &lt;code&gt;Tensor&lt;/code&gt; outputs of applying TensorFlow operations in &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 에 TensorFlow 연산을 적용한 &lt;code&gt;Tensor&lt;/code&gt; 출력의 (중첩 된 구조) 입니다.</target>
        </trans-unit>
        <trans-unit id="15037aafea957b9ef266d06605cafa94a8657f7e" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y&lt;/code&gt; is a &lt;code&gt;Tensor&lt;/code&gt; or sequence of &lt;code&gt;Tensor&lt;/code&gt; outputs of applying TensorFlow operations in &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;f&lt;/code&gt; 에서 &lt;code&gt;x&lt;/code&gt; 에 텐서 플로우 연산을 적용 하는 &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;Tensor&lt;/code&gt; 출력 시퀀스입니다 .</target>
        </trans-unit>
        <trans-unit id="177174d186c8a34b2e9d84974c7fc45b527d347a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y_pred&lt;/code&gt; and &lt;code&gt;y_true&lt;/code&gt; should be passed in as vectors of probabilities, rather than as labels. If necessary, use &lt;a href=&quot;../../one_hot&quot;&gt;&lt;code&gt;tf.one_hot&lt;/code&gt;&lt;/a&gt; to expand &lt;code&gt;y_true&lt;/code&gt; as a vector.</source>
          <target state="translated">&lt;code&gt;y_pred&lt;/code&gt; 및 &lt;code&gt;y_true&lt;/code&gt; 는 레이블이 아닌 확률 벡터로 전달되어야합니다. 필요한 경우 &lt;a href=&quot;../../one_hot&quot;&gt; &lt;code&gt;tf.one_hot&lt;/code&gt; &lt;/a&gt; 을 사용하여 y_true 를 벡터 로 확장 &lt;code&gt;y_true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8d3aabffef2f0f9e7c0624d05788257f03bea48" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y_true&lt;/code&gt; and &lt;code&gt;y_pred&lt;/code&gt; should have the same shape.</source>
          <target state="translated">&lt;code&gt;y_true&lt;/code&gt; 와 &lt;code&gt;y_pred&lt;/code&gt; 의 모양은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="8be54ba04c47a3c48855f5b6a7f4fd9259d78e2a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;y_true&lt;/code&gt; values are expected to be -1 or 1. If binary (0 or 1) labels are provided we will convert them to -1 or 1.</source>
          <target state="translated">&lt;code&gt;y_true&lt;/code&gt; 값은 -1 또는 1이어야합니다. 이진 (0 또는 1) 레이블이 제공되면 -1 또는 1로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="97a04e6985caa80419aca491f5b4963b5189489c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ys&lt;/code&gt; and &lt;code&gt;xs&lt;/code&gt; are each a &lt;code&gt;Tensor&lt;/code&gt; or a list of tensors. &lt;code&gt;grad_ys&lt;/code&gt; is a list of &lt;code&gt;Tensor&lt;/code&gt;, holding the gradients received by the &lt;code&gt;ys&lt;/code&gt;. The list must be the same length as &lt;code&gt;ys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ys&lt;/code&gt; 와 &lt;code&gt;xs&lt;/code&gt; 는 각각 &lt;code&gt;Tensor&lt;/code&gt; 또는 텐서 목록입니다. &lt;code&gt;grad_ys&lt;/code&gt; 는 &lt;code&gt;ys&lt;/code&gt; 에 의해 수신 된 그라디언트를 보유하는 &lt;code&gt;Tensor&lt;/code&gt; 목록입니다 . 리스트의 길이는 &lt;code&gt;ys&lt;/code&gt; 와 같아야합니다 .</target>
        </trans-unit>
        <trans-unit id="cc4870c378f5be9f241f3d88916cb190e126680b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; is polymorphic&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 은 다형성입니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f0963bb900a0acb53b1b1dbaa5998d29cb197e8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Consuming SavedModels asynchronously&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;저장된 모델을 비동기 적으로 소비&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1f60bd3e2de23785f73f07eed1afbfb51b5ef6c1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Data parallelism&lt;/em&gt; is where we run multiple copies of the model on different slices of the input data. This is in contrast to &lt;em&gt;model parallelism&lt;/em&gt; where we divide up a single copy of a model across multiple devices. Note: we only support data parallelism for now, but hope to add support for model parallelism in the future.</source>
          <target state="translated">&lt;em&gt;데이터 병렬 처리&lt;/em&gt; 는 입력 데이터의 다른 슬라이스에서 모델의 여러 사본을 실행하는 곳입니다. 이는 &lt;em&gt;모델&lt;/em&gt; 의 단일 사본을 여러 장치로 나누는 &lt;em&gt;모델 병렬성&lt;/em&gt; 과 대조됩니다 . 참고 : 현재는 데이터 병렬 처리 만 지원하지만 향후 모델 병렬 처리에 대한 지원을 추가 할 수 있도록 노력하겠습니다.</target>
        </trans-unit>
        <trans-unit id="c4b4afd93f288f7cdac41f03870a9805312ad726" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Debug logging in AutoGraph&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;AutoGraph의 디버그 로깅&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4b89a531c7276420c3c020512c62db4504a2c1da" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Distribute-aware layers&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;분산 인식 레이어&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e168c09c43e9da3acc751c6bf376aff124f26a5a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Distributed value&lt;/em&gt;: Distributed value is represented by the base class &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; is useful to represent values on multiple devices, and it contains a map from replica id to values. Two representative kinds of &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; are &quot;PerReplica&quot; and &quot;Mirrored&quot; values.</source>
          <target state="translated">&lt;em&gt;분산 값&lt;/em&gt; : 분산 값은 기본 클래스 &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 로&lt;/a&gt; 표시됩니다 . &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 는 여러 장치에서 값을 나타내는 데 유용하며 복제본 ID에서 값으로의 맵을 포함합니다. &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 의&lt;/a&gt; 두 가지 대표적인 종류 는 &quot;PerReplica&quot;및 &quot;Mirrored&quot;값입니다.</target>
        </trans-unit>
        <trans-unit id="6623c046a3f4db74e6b119cb15e45fdd22ea8749" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Distributed value&lt;/em&gt;: Distributed value is represented by the base class &lt;a href=&quot;distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; is useful to represent values on multiple devices, and it contains a map from replica id to values. Two representative kinds of &lt;a href=&quot;distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt; are &quot;PerReplica&quot; and &quot;Mirrored&quot; values.</source>
          <target state="translated">&lt;em&gt;분산 값&lt;/em&gt; : 분산 값은 기본 클래스 &lt;a href=&quot;distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 로&lt;/a&gt; 표시됩니다 . &lt;a href=&quot;distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; 는 여러 장치에서 값을 나타내는 데 유용하며 복제본 ID에서 값으로의 맵을 포함합니다. &lt;a href=&quot;distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; 의&lt;/a&gt; 두 가지 대표적인 종류 는 &quot;PerReplica&quot;및 &quot;Mirrored&quot;값입니다.</target>
        </trans-unit>
        <trans-unit id="91b3ac8f71f44fc2aaf6f7b21a2a9892f37925bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example Usage&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;사용법 예&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7778d7489c6a62c13ac40396eea8a8ff664a6fca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Example usage&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;사용법 예&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2abe32adb48107f5de1087c0a61cda1b2b3cc8dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Features&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Features&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="798eb35f1e8f42993c637a5eda6d6f299ba357a1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fully-known shape:&lt;/em&gt; has a known number of dimensions and a known size for each dimension. e.g. &lt;code&gt;TensorShape([16, 256])&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;완전히 알려진 모양 :&lt;/em&gt; 알려진 차원 수와 각 차원에 대해 알려진 크기가 있습니다. 예. &lt;code&gt;TensorShape([16, 256])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a753dd59f4dc5b7977df41992d06406a670f61c4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Glossary&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Glossary&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aedad927dcc5f273711871833d55596127d0de47" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Guides&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Guides&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8975a65b88fb11b1a4a781f6ded0b8fa5cf5eb32" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How to update a distributed variable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;분산 변수를 업데이트하는 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d2c706c091d8683f86f21946441cc2834bb67ecc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;How to update a variable&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;변수를 업데이트하는 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="fc319e564126d6147a3b6d36c8038aeb37a79a3d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Importing SavedModels from TensorFlow 1.x&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;TensorFlow 1.x에서 저장된 모델 가져 오기&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="114dfae46b5581feb427a06e59a262af1de8f0e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Input signatures&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;입력 서명&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d203702aa2788b436a9e39dbe7cb0af7256b38be" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Limitation&lt;/em&gt;: this Op only broadcasts the dense side to the sparse side, but not the other direction.</source>
          <target state="translated">&lt;em&gt;제한&lt;/em&gt; :이 Op는 밀도가 높은 쪽만 희소 한쪽으로 만 브로드 캐스트하지만 다른 방향으로는 브로드 캐스트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aae3ed54270268ffb3b111648fbe42dfb9d26dbd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Loading Keras models&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Keras 모델로드&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="199fda6a516d16b5d99f00f4818f4cc123a6818a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Locality&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Locality&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="97196a6a668191b8365569fbe19f926502882241" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;MIN_COMBINED Mode Example&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;MIN_COMBINED 모드 예&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6f4d3fb928ec4cb834fd2d0c8c06cd22d77b929c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Mirrored variables&lt;/em&gt;: These are variables that are copied to multiple devices, where we keep the copies in sync by applying the same updates to every copy. Normally would only be used with sync training.</source>
          <target state="translated">&lt;em&gt;미러링 된 변수&lt;/em&gt; : 여러 장치에 복사되는 변수로 모든 복사본에 동일한 업데이트를 적용하여 복사본을 동기화합니다. 일반적으로 동기화 훈련에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75b7bb6bbfa54cbe87956ffead2b1af661c63759" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Mirrored variables&lt;/em&gt;: These are variables that are created on multiple devices, where we keep the variables in sync by applying the same updates to every copy. Mirrored variables are created with &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_WRITE...)&lt;/code&gt;&lt;/a&gt;. Normally they are only used in synchronous training.</source>
          <target state="translated">&lt;em&gt;미러링 된 변수&lt;/em&gt; : 여러 기기에서 생성되는 변수로, 모든 사본에 동일한 업데이트를 적용하여 변수를 동기화 상태로 유지합니다. 미러링 된 변수는 &lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_WRITE...)&lt;/code&gt; &lt;/a&gt; 됩니다. 일반적으로 동기식 훈련에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="078c57e40d1fadf596a2336268bcd2327be2b866" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Mirrored variables&lt;/em&gt;: These are variables that are created on multiple devices, where we keep the variables in sync by applying the same updates to every copy. Mirrored variables are created with &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_WRITE...)&lt;/code&gt;&lt;/a&gt;. Normally they are only used in synchronous training.</source>
          <target state="translated">&lt;em&gt;미러링 된 변수&lt;/em&gt; : 여러 기기에서 생성되는 변수로, 모든 사본에 동일한 업데이트를 적용하여 변수를 동기화 상태로 유지합니다. 미러링 된 변수는 &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_WRITE...)&lt;/code&gt; &lt;/a&gt; 됩니다. 일반적으로 동기식 훈련에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2ec0448891bceb0b5fe7da7b3eea7261616c59d2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.:&lt;/em&gt; If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, you must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;em&gt;NB :&lt;/em&gt; 경우 &lt;code&gt;dynamic_pad&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 당신이 있는지 확인해야 하나 (ⅰ) &lt;code&gt;shapes&lt;/code&gt; 인수가 전달되는, 또는 (ⅱ)에서 텐서의 모든 &lt;code&gt;tensors&lt;/code&gt; 완벽하게 정의 된 모양이 있어야합니다. 이러한 조건 중 어느 것도 유지되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="70c204dea30ebc379fea45bb0535fd5e00bc9030" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.:&lt;/em&gt; If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, you must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors_list&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;em&gt;NB :&lt;/em&gt; 경우 &lt;code&gt;dynamic_pad&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 당신이 있는지 확인해야 하나 (ⅰ) &lt;code&gt;shapes&lt;/code&gt; 인수가 전달되는, 또는 (ⅱ)에서 텐서의 모든 &lt;code&gt;tensors_list&lt;/code&gt; 이 완벽하게 정의 된 모양이 있어야합니다. 이러한 조건 중 어느 것도 유지되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="891ee7108e779a01055d57c1188435175c63d622" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.:&lt;/em&gt; You must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;em&gt;주의 :&lt;/em&gt; (i) &lt;code&gt;shapes&lt;/code&gt; 인수가 전달되거나 (ii) 텐서의 모든 &lt;code&gt;tensors&lt;/code&gt; 가 완전히 정의 된 모양을 가져야합니다. 이러한 조건 중 어느 것도 유지되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0cebb1905bb8bfddbe3682c43532c9c1fda25f6c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; Before invoking &lt;a href=&quot;operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;em&gt;NB &lt;/em&gt;&lt;a href=&quot;operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되었고 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="8ddaf935cdd6e6eaa7330b8fc4bc65789b7e6032" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; Before invoking &lt;a href=&quot;sparsetensor#eval&quot;&gt;&lt;code&gt;SparseTensor.eval()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;em&gt;NB &lt;/em&gt;&lt;a href=&quot;sparsetensor#eval&quot;&gt; &lt;code&gt;SparseTensor.eval()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되었고 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="49ab796d377717740016aa78a9df87b28816554d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; Before invoking &lt;a href=&quot;tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;em&gt;NB &lt;/em&gt;&lt;a href=&quot;tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되었고 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="0adb0092ee033aa45e0687eb92304dce7f375e3d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; Entering a &lt;code&gt;with sess.as_default():&lt;/code&gt; block does not affect the current default graph. If you are using multiple graphs, and &lt;code&gt;sess.graph&lt;/code&gt; is different from the value of &lt;a href=&quot;get_default_graph&quot;&gt;&lt;code&gt;tf.compat.v1.get_default_graph&lt;/code&gt;&lt;/a&gt;, you must explicitly enter a &lt;code&gt;with sess.graph.as_default():&lt;/code&gt; block to make &lt;code&gt;sess.graph&lt;/code&gt; the default graph.</source>
          <target state="translated">&lt;em&gt;NB &lt;/em&gt; &lt;code&gt;with sess.as_default():&lt;/code&gt; 블록을 입력 하면 현재 기본 그래프에 영향을 미치지 않습니다. 여러 그래프를 사용하고있는 경우 &lt;code&gt;sess.graph&lt;/code&gt; 가 의 값과 다른 &lt;a href=&quot;get_default_graph&quot;&gt; &lt;code&gt;tf.compat.v1.get_default_graph&lt;/code&gt; &lt;/a&gt; , 당신은 명시 적으로 입력해야합니다 &lt;code&gt;with sess.graph.as_default():&lt;/code&gt; 만들기 위해 블록 &lt;code&gt;sess.graph&lt;/code&gt; 기본 그래프.</target>
        </trans-unit>
        <trans-unit id="d69b75367a0ed258d02306204677149d2f266cb1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; If either &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt; is completely unknown, concatenation will discard information about the other shape. In future, we might support concatenation that preserves this information for use with slicing.</source>
          <target state="translated">&lt;em&gt;NB&lt;/em&gt; 만약이 중 하나를 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 완전히 알 수없는, 연결은 다른 형태에 대한 정보를 폐기합니다. 나중에 슬라이싱에 사용하기 위해이 정보를 보존하는 연결을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52681c6e74b4b249720e02b5c1fa1d1029b29ea" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; If the failed op was synthesized at runtime, e.g. a &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Recv&lt;/code&gt; op, there will be no corresponding &lt;a href=&quot;../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; object. In that case, this will return &lt;code&gt;None&lt;/code&gt;, and you should instead use the &lt;a href=&quot;operror#node_def&quot;&gt;&lt;code&gt;tf.errors.OpError.node_def&lt;/code&gt;&lt;/a&gt; to discover information about the op.</source>
          <target state="translated">&lt;em&gt;NB&lt;/em&gt; 실패한 op가 런타임에 합성 된 경우 (예 : &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Recv&lt;/code&gt; op) 해당 &lt;a href=&quot;../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; 객체 가 없습니다 . 이 경우 &lt;code&gt;None&lt;/code&gt; 이 반환 되고 대신 &lt;a href=&quot;operror#node_def&quot;&gt; &lt;code&gt;tf.errors.OpError.node_def&lt;/code&gt; &lt;/a&gt; 를 사용 하여 op에 대한 정보를 검색 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1bd856fcd5b1db7944508e5e9b6c88acb05018fe" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; The &lt;code&gt;as_default&lt;/code&gt; context manager &lt;em&gt;does not&lt;/em&gt; close the session when you exit the context, and you must close the session explicitly.</source>
          <target state="translated">&lt;em&gt;NB &lt;/em&gt; &lt;code&gt;as_default&lt;/code&gt; 의 컨텍스트 매니저는 &lt;em&gt;하지 않습니다&lt;/em&gt; 닫기 컨텍스트를 종료 세션, 당신은 명시 적으로 세션을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="656c008463c0ff3d79fc8ed9938f48987767c7ee" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; The control dependencies context applies &lt;em&gt;only&lt;/em&gt; to ops that are constructed within the context. Merely using an op or tensor in the context does not add a control dependency. The following example illustrates this point:</source>
          <target state="translated">&lt;em&gt;NB&lt;/em&gt; 제어 종속성 컨텍스트는 컨텍스트 내에 구성된 op &lt;em&gt;에만&lt;/em&gt; 적용 &lt;em&gt;됩니다&lt;/em&gt; . 컨텍스트에서 op 또는 텐서를 사용하더라도 제어 종속성이 추가되지 않습니다. 다음 예제는이 점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e7620dc4f0af3a74d7f4f571a2f2cb6ab6a1045c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;N.B.&lt;/em&gt; The default session is a property of the current thread. If you create a new thread, and wish to use the default session in that thread, you must explicitly add a &lt;code&gt;with sess.as_default():&lt;/code&gt; in that thread's function.</source>
          <target state="translated">&lt;em&gt;NB&lt;/em&gt; 기본 세션은 현재 스레드의 속성입니다. 새 스레드를 작성하고 해당 스레드에서 기본 세션을 사용하려면 해당 스레드의 함수에서 &lt;code&gt;with sess.as_default():&lt;/code&gt; 를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9746a33c66f73627685eeb9c2184b027c001800e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="76540bb5052f6159e8900b0301eb9559d9696374" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스팅을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="efe30fbfda5325b7cf2b648134d4a95fa26aaa19" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="67c5f335c99f9667cff4f73110cadf47a0021df7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/less&quot;&gt;&lt;code&gt;math.less&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/less&quot;&gt; &lt;code&gt;math.less&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11e298f667be9bc6b4648b938062492f0e1fd8bd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/less_equal&quot;&gt;&lt;code&gt;math.less_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/less_equal&quot;&gt; &lt;code&gt;math.less_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b126242de961de19f36b68e5f8cd1f5f4f19b8ca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/logical_and&quot;&gt;&lt;code&gt;math.logical_and&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/logical_and&quot;&gt; &lt;code&gt;math.logical_and&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f0e8f061a6d059a769e36ffc3e542a87799a1db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;../../math/logical_or&quot;&gt;&lt;code&gt;math.logical_or&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;../../math/logical_or&quot;&gt; &lt;code&gt;math.logical_or&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="99559a7261f7a42ee46d72e3e9c429b23d115166" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;add&quot;&gt;&lt;code&gt;math.add&lt;/code&gt;&lt;/a&gt; supports broadcasting. &lt;code&gt;AddN&lt;/code&gt; does not. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;add&quot;&gt; &lt;code&gt;math.add&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. &lt;code&gt;AddN&lt;/code&gt; 은 그렇지 않습니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4a84a4e889afc92326df20e4bc706d940d12c0c7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98e7abfa065d2d84f0a602b6628b20c259592560" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스팅을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27236cfe7b683d6bffe0917f375105559b793631" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd4e2824e4e20b892dd86fff3a9b727263459485" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;less&quot;&gt;&lt;code&gt;math.less&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;less&quot;&gt; &lt;code&gt;math.less&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d30b8982b2f1da1983b73c1292b588c8b0870182" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;less_equal&quot;&gt;&lt;code&gt;math.less_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;less_equal&quot;&gt; &lt;code&gt;math.less_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="192106b99913a403ffa00484864b92bae578a209" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;logical_and&quot;&gt;&lt;code&gt;math.logical_and&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;logical_and&quot;&gt; &lt;code&gt;math.logical_and&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e8ab01d0ae22e03e1e5afcde2bbb1ba7c2e97f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;logical_or&quot;&gt;&lt;code&gt;math.logical_or&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;logical_or&quot;&gt; &lt;code&gt;math.logical_or&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae9ef2dcb6bf1731ab2cf7b010c953a0ec4cc7d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/add&quot;&gt;&lt;code&gt;math.add&lt;/code&gt;&lt;/a&gt; supports broadcasting. &lt;code&gt;AddN&lt;/code&gt; does not. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/add&quot;&gt; &lt;code&gt;math.add&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. &lt;code&gt;AddN&lt;/code&gt; 은 그렇지 않습니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6aa2e87de4ec340a6c52b9b8dcb68abaa94bf044" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="263a26391ec23fb7f099d9038ae56f5dae41aa98" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스팅을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="199faa13ca7f3cb125274bf60b9bb6bbb57f7a4f" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c10415ed0a09f21b695967b22990e2e66b8412c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/less&quot;&gt;&lt;code&gt;math.less&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/less&quot;&gt; &lt;code&gt;math.less&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf89ff665268506d258975ed50443f9a13db4a62" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/less_equal&quot;&gt;&lt;code&gt;math.less_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/less_equal&quot;&gt; &lt;code&gt;math.less_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7b0c2f85f8e67e8fe044e9b345c7f6957fc06211" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/logical_and&quot;&gt;&lt;code&gt;math.logical_and&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/logical_and&quot;&gt; &lt;code&gt;math.logical_and&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09a3cd7b4908de073464365e6960ca8c33e3eb69" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/logical_or&quot;&gt;&lt;code&gt;math.logical_or&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/logical_or&quot;&gt; &lt;code&gt;math.logical_or&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="721325a08d91476b3c6ca66d461a341ea05c4877" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b0ff3beb09a30d54b6f624b2cc93c99c98877c4d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;maximum&quot;&gt;&lt;code&gt;math.maximum&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;maximum&quot;&gt; &lt;code&gt;math.maximum&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="beb4ed4e923cb5787a092fe948abe0bf12388008" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;minimum&quot;&gt;&lt;code&gt;math.minimum&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;minimum&quot;&gt; &lt;code&gt;math.minimum&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c5ac4bcae8b9c7152d82cbe6d9f7cc21df9c0918" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95309c01422708765416d7060309d52454d50d30" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;a href=&quot;squared_difference&quot;&gt;&lt;code&gt;math.squared_difference&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;a href=&quot;squared_difference&quot;&gt; &lt;code&gt;math.squared_difference&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="788fdec55c25c1331a771a84e62d11445457b151" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;Div&lt;/code&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;Div&lt;/code&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3a125fe6c49cc2e6124906aa40ea8c6a46f9acc" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;Substr&lt;/code&gt; supports broadcasting up to two dimensions. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;Substr&lt;/code&gt; 은 최대 2 차원 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35210ba8bd5af1e9bd426d3ede054053c45b293e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;Subtract&lt;/code&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;Subtract&lt;/code&gt; 는 방송을 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a012b0e1a536de9b123bdcfb7d0b603cfa9e67b1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;floor_div&lt;/code&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;floor_div&lt;/code&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ccb7c8f62465ab6153dea86c3b22d55bb51da051" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;truncatediv&lt;/code&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;truncatediv&lt;/code&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0a205f4d7f1997b2e284c4cc3a74629247bcdd25" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: &lt;code&gt;truncatemod&lt;/code&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : &lt;code&gt;truncatemod&lt;/code&gt; 는 브로드 캐스트를 지원합니다. 방송에 대한 자세한 내용은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ddcc493d9b4cf744c68aa13be155b2b94647e11" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;NOTE&lt;/em&gt;: Bitcast is implemented as a low-level cast, so machines with different endian orderings will give different results.</source>
          <target state="translated">&lt;em&gt;참고&lt;/em&gt; : 비트 캐스트는 하위 수준 캐스트로 구현되므로 엔디안 순서가 다른 컴퓨터는 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="206bb7da216d3072e22f1bb71ff46f8e7469e412" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter servers&lt;/em&gt;: These are machines that hold a single copy of parameters/variables, used by some strategies (right now just &lt;a href=&quot;../../distribute/experimental/parameterserverstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.ParameterServerStrategy&lt;/code&gt;&lt;/a&gt;). All replicas that want to operate on a variable retrieve it at the beginning of a step and send an update to be applied at the end of the step. These can in priniciple support either sync or async training, but right now we only have support for async training with parameter servers. Compare to &lt;a href=&quot;../../distribute/experimental/centralstoragestrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.CentralStorageStrategy&lt;/code&gt;&lt;/a&gt;, which puts all variables on a single device on the same machine (and does sync training), and &lt;a href=&quot;../../distribute/mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, which mirrors variables to multiple devices (see below).</source>
          <target state="translated">&lt;em&gt;매개 변수 서버&lt;/em&gt; : 일부 전략에서 사용되는 매개 변수 / 변수의 단일 사본을 보유하는 머신입니다 (현재 &lt;a href=&quot;../../distribute/experimental/parameterserverstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.ParameterServerStrategy&lt;/code&gt; &lt;/a&gt; ). 변수에서 작동하려는 모든 복제본은 단계 시작시 변수를 검색하고 단계 끝에 적용 할 업데이트를 보냅니다. 이것들은 원칙적으로 동기화 또는 비동기 훈련을 지원할 수 있지만 현재는 매개 변수 서버를 사용한 비동기 훈련 만 지원합니다. 비교 대상 &lt;a href=&quot;../../distribute/experimental/centralstoragestrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.CentralStorageStrategy&lt;/code&gt; &lt;/a&gt; 동일한 시스템에서 단일 장치에 모든 변수를두고 (동기화 및 트레이닝을 수행) 및 &lt;a href=&quot;../../distribute/mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt; , 여러 장치에 미러 변수 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="b97d4e3eaf39600496f9954718509d5b0547716a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Parameter servers&lt;/em&gt;: These are machines that hold a single copy of parameters/variables, used by some strategies (right now just &lt;a href=&quot;distribute/experimental/parameterserverstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.ParameterServerStrategy&lt;/code&gt;&lt;/a&gt;). All replicas that want to operate on a variable retrieve it at the beginning of a step and send an update to be applied at the end of the step. These can in priniciple support either sync or async training, but right now we only have support for async training with parameter servers. Compare to &lt;a href=&quot;distribute/experimental/centralstoragestrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.CentralStorageStrategy&lt;/code&gt;&lt;/a&gt;, which puts all variables on a single device on the same machine (and does sync training), and &lt;a href=&quot;distribute/mirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt;&lt;/a&gt;, which mirrors variables to multiple devices (see below).</source>
          <target state="translated">&lt;em&gt;매개 변수 서버&lt;/em&gt; : 일부 전략에서 사용되는 매개 변수 / 변수의 단일 사본을 보유하는 머신입니다 (현재 &lt;a href=&quot;distribute/experimental/parameterserverstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.ParameterServerStrategy&lt;/code&gt; &lt;/a&gt; ). 변수에서 작동하려는 모든 복제본은 단계 시작시 변수를 검색하고 단계 끝에 적용 할 업데이트를 보냅니다. 이것들은 원칙적으로 동기화 또는 비동기 훈련을 지원할 수 있지만 현재는 매개 변수 서버를 사용한 비동기 훈련 만 지원합니다. 비교 대상 &lt;a href=&quot;distribute/experimental/centralstoragestrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.CentralStorageStrategy&lt;/code&gt; &lt;/a&gt; 동일한 시스템에서 단일 장치에 모든 변수를두고 (동기화 및 트레이닝을 수행) 및 &lt;a href=&quot;distribute/mirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.MirroredStrategy&lt;/code&gt; &lt;/a&gt; , 여러 장치에 미러 변수 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="34787eed0a3cef9c5b6406998fe6fa66d5bbabb0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Partially-known shape:&lt;/em&gt; has a known number of dimensions, and an unknown size for one or more dimension. e.g. &lt;code&gt;TensorShape([None, 256])&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;부분적으로 알려진 모양 :&lt;/em&gt; 알려진 차원 수와 하나 이상의 차원에 대해 알 수없는 크기가 있습니다. 예 : &lt;code&gt;TensorShape([None, 256])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b36226478fd781982ed07ee27a3ef79bc1139ae2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Reductions&lt;/em&gt; and &lt;em&gt;all-reduce&lt;/em&gt;: A &lt;em&gt;reduction&lt;/em&gt; is a method of aggregating multiple values into one value, like &quot;sum&quot; or &quot;mean&quot;. If a strategy is doing sync training, we will perform a reduction on the gradients to a parameter from all replicas before applying the update. &lt;em&gt;All-reduce&lt;/em&gt; is an algorithm for performing a reduction on values from multiple devices and making the result available on all of those devices.</source>
          <target state="translated">&lt;em&gt;감소&lt;/em&gt; 및 &lt;em&gt;전체 감소&lt;/em&gt; : &lt;em&gt;감소&lt;/em&gt; 는 &quot;합계&quot;또는 &quot;평균&quot;과 같이 여러 값을 하나의 값으로 집계하는 방법입니다. 전략이 동기화 훈련을 수행하는 경우 업데이트를 적용하기 전에 모든 복제본의 매개 변수에 대한 그라디언트 감소를 수행합니다. &lt;em&gt;All-reduce&lt;/em&gt; 는 여러 장치의 값을 &lt;em&gt;줄이고 모든&lt;/em&gt; 장치에서 결과를 사용할 수 있도록하는 알고리즘입니다.</target>
        </trans-unit>
        <trans-unit id="7945c08c394ff2c16d680c3c9ad25bdc1a1d7897" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Replica context vs. Cross-replica context&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;복제 컨텍스트와 교차 복제 컨텍스트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="38a4b9eb335430efdaaa16cad03a476718c95daa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Replica context&lt;/em&gt; vs. &lt;em&gt;Cross-replica context&lt;/em&gt; vs &lt;em&gt;Update context&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;복제 컨텍스트&lt;/em&gt; 대 &lt;em&gt;교차 복제 컨텍스트&lt;/em&gt; 대 &lt;em&gt;업데이트 컨텍스트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07cc62a05c793c6e4c8be64fcea016eb601c4ad8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requirements&lt;/em&gt;: 0 &amp;lt;= begin[i] &amp;lt;= begin[i] + size[i] &amp;lt;= Di for i in [0, n)</source>
          <target state="translated">&lt;em&gt;요구 사항&lt;/em&gt; : 0 &amp;lt;= begin [i] &amp;lt;= begin [i] + size [i] &amp;lt;= Di for i in [0, n)</target>
        </trans-unit>
        <trans-unit id="df0d6135f586970361e780f5811506a43b555cd7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requirements&lt;/em&gt;: &lt;code&gt;0 != strides[i] for i in [0, m)&lt;/code&gt;&lt;code&gt;ellipsis_mask must be a power of two (only one ellipsis)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;요구 사항&lt;/em&gt; : &lt;code&gt;0 != strides[i] for i in [0, m)&lt;/code&gt; &lt;code&gt;ellipsis_mask must be a power of two (only one ellipsis)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58dc975f8be36a7e5d8e03ed8ee6f16c8541fce7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SCALED mode Example&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;스케일 모드 예&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4ea5ee25bfb251e500e6d395691df627a81e4039" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SavedModel serialization&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;저장된 모델 직렬화&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="858dec0ea6f9cb9f54bad1615aab5c500f959027" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SavedModel serialization&lt;/em&gt; (not yet added)</source>
          <target state="translated">&lt;em&gt;저장된 모델 직렬화&lt;/em&gt; (아직 추가되지 않음)</target>
        </trans-unit>
        <trans-unit id="9589aa5a843b95c3373aff04e2b925d19813663e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Sync on read variables&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;읽기 변수에서 동기화&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7e5ff535946f7817806ff94d83c7930f1e96694e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SyncOnRead variables&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;SyncOnRead 변수&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a169b3167101fb6df060ac94a64c2ab239f2f485" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SyncOnRead variables&lt;/em&gt; are created by &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_READ...)&lt;/code&gt;&lt;/a&gt;, and they are created on multiple devices. In replica context, each component variable on the local replica can perform reads and writes without synchronization with each other. When the &lt;em&gt;SyncOnRead variable&lt;/em&gt; is read in cross-replica context, the values from component variables are aggregated and returned.</source>
          <target state="translated">&lt;em&gt;SyncOnRead 변수&lt;/em&gt; 는 &lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_READ...)&lt;/code&gt; &lt;/a&gt; 에 의해 생성되며 여러 장치에서 생성됩니다. 복제본 컨텍스트에서 로컬 복제본의 각 구성 요소 변수는 서로 동기화하지 않고 읽기 및 쓰기를 수행 할 수 있습니다. 때 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 간 복제 문맥 판독 성분 변수의 값이 집계되어 반환된다.</target>
        </trans-unit>
        <trans-unit id="0ae892fa22a7664920b6622b7f5e99be043d87f4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SyncOnRead variables&lt;/em&gt; are created by &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_READ...)&lt;/code&gt;&lt;/a&gt;, and they are created on multiple devices. In replica context, each component variable on the local replica can perform reads and writes without synchronization with each other. When the &lt;em&gt;SyncOnRead variable&lt;/em&gt; is read in cross-replica context, the values from component variables are aggregated and returned.</source>
          <target state="translated">&lt;em&gt;SyncOnRead 변수&lt;/em&gt; 는 &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable(...synchronization=tf.VariableSynchronization.ON_READ...)&lt;/code&gt; &lt;/a&gt; 에 의해 생성되며 여러 장치에서 생성됩니다. 복제본 컨텍스트에서 로컬 복제본의 각 구성 요소 변수는 서로 동기화하지 않고 읽기 및 쓰기를 수행 할 수 있습니다. 때 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 간 복제 문맥 판독 성분 변수의 값이 집계되어 반환된다.</target>
        </trans-unit>
        <trans-unit id="cd3efaa86f376902411e5aca24eb54370ff00e66" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;SyncOnRead variables&lt;/em&gt; bring a lot of custom configuration difficulty to the underlying logic, so we do not encourage users to instantiate and use &lt;em&gt;SyncOnRead variable&lt;/em&gt; on their own. We have mainly used &lt;em&gt;SyncOnRead variables&lt;/em&gt; for use cases such as batch norm and metrics. For performance reasons, we often don't need to keep these statistics in sync every step and they can be accumulated on each replica independently. The only time we want to sync them is reporting or checkpointing, which typically happens in cross-replica context. &lt;em&gt;SyncOnRead variables&lt;/em&gt; are also often used by advanced users who want to control when variable values are aggregated. For example, users sometimes want to maintain gradients independently on each replica for a couple of steps without aggregation.</source>
          <target state="translated">&lt;em&gt;SyncOnRead 변수&lt;/em&gt; 는 기본 논리에 많은 사용자 지정 구성 문제를 가져 &lt;em&gt;오므로&lt;/em&gt; 사용자가 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 를 직접 인스턴스화하고 사용하도록 권장하지 않습니다 . 우리는 주로 배치 규범 및 메트릭과 같은 사용 사례에 &lt;em&gt;SyncOnRead 변수&lt;/em&gt; 를 사용했습니다. 성능상의 이유로 이러한 통계를 매 단계마다 동기화 할 필요가 없으며 각 복제본에 독립적으로 누적 될 수 있습니다. 동기화하려는 유일한 시간은보고 또는 체크 포인트이며, 일반적으로 교차 복제 컨텍스트에서 발생합니다. &lt;em&gt;SyncOnRead 변수&lt;/em&gt;변수 값이 집계되는시기를 제어하려는 고급 사용자도 자주 사용합니다. 예를 들어 사용자는 집계없이 몇 단계 동안 각 복제본에서 독립적으로 그라데이션을 유지하고자하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d468c878a585d2572e97385ed6e6acefcba101" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Synchronous&lt;/em&gt;, or more commonly &lt;em&gt;sync&lt;/em&gt;, training is where the updates from each replica are aggregated together before updating the model variables. This is in contrast to &lt;em&gt;asynchronous&lt;/em&gt;, or &lt;em&gt;async&lt;/em&gt; training, where each replica updates the model variables independently. You may also have replicas partitioned into groups which are in sync within each group but async between groups.</source>
          <target state="translated">&lt;em&gt;동기식&lt;/em&gt; 또는보다 일반적으로 &lt;em&gt;동기화&lt;/em&gt; 되는 교육은 모델 변수를 업데이트하기 전에 각 복제본의 업데이트가 집계되는 곳입니다. 이는 각 복제본이 모델 변수를 독립적으로 업데이트하는 &lt;em&gt;비동기식&lt;/em&gt; 또는 &lt;em&gt;비동기식&lt;/em&gt; 훈련 과 대조됩니다 . 각 그룹 내에서는 동기화되지만 그룹 간에는 비동기 인 그룹으로 분할 된 복제본이있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0736ff761025b0245aa332e5101fa79e249faa6c" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Tutorials&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Tutorials&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="db7f6fb016751604a76d71222eb227c61c2203d5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unknown shape:&lt;/em&gt; has an unknown number of dimensions, and an unknown size in all dimensions. e.g. &lt;code&gt;TensorShape(None)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;알 수없는 모양 :&lt;/em&gt; 알 수없는 차원 수와 모든 차원에 알 수없는 크기가 있습니다. 예 : &lt;code&gt;TensorShape(None)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b07a8079f81b54047ba970111303ebb31fdeea5" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unwrapping&lt;/em&gt; and &lt;em&gt;merging&lt;/em&gt;: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;strategy.run(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;strategy.run()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on device &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on device &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which leads to one common object if the returned values are the same object from every replica, or a &lt;code&gt;DistributedValues&lt;/code&gt; object otherwise.</source>
          <target state="translated">&lt;em&gt;언 래핑&lt;/em&gt; 과 &lt;em&gt;병합&lt;/em&gt; : 함수 호출 고려 &lt;code&gt;fn&lt;/code&gt; 같은 다수 복제본을 &lt;code&gt;strategy.run(fn, args=[w])&lt;/code&gt; 인자와 &lt;code&gt;w&lt;/code&gt; 하는 것은이다 &lt;a href=&quot;../../distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; . 즉, &lt;code&gt;w&lt;/code&gt; 는 복제본 ID &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;w0&lt;/code&gt; , 복제본 ID &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;w1&lt;/code&gt; 등 을 취하는 맵을 갖게됩니다 . &lt;code&gt;strategy.run()&lt;/code&gt; 은 &lt;code&gt;fn&lt;/code&gt; 을 호출하기 전에 &lt;code&gt;w&lt;/code&gt; 를 풀기 때문에 디바이스 &lt;code&gt;d0&lt;/code&gt; 에서 &lt;code&gt;fn(w1)&lt;/code&gt; &lt;code&gt;fn(w0)&lt;/code&gt; , 디바이스 에서 fn (w1) 을 호출 합니다. &lt;code&gt;d1&lt;/code&gt; 그런 다음 &lt;code&gt;fn()&lt;/code&gt; 의 반환 값을 병합하여 반환 된 값이 모든 복제본의 동일한 객체 인 경우 하나의 공통 객체로 연결되고 그렇지 않으면 &lt;code&gt;DistributedValues&lt;/code&gt; 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="8064beb6a79772191744e4464d91d16048479718" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unwrapping&lt;/em&gt; and &lt;em&gt;merging&lt;/em&gt;: Consider calling a function &lt;code&gt;fn&lt;/code&gt; on multiple replicas, like &lt;code&gt;strategy.run(fn, args=[w])&lt;/code&gt; with an argument &lt;code&gt;w&lt;/code&gt; that is a &lt;a href=&quot;distribute/distributedvalues&quot;&gt;&lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt;&lt;/a&gt;. This means &lt;code&gt;w&lt;/code&gt; will have a map taking replica id &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;w0&lt;/code&gt;, replica id &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;w1&lt;/code&gt;, etc. &lt;code&gt;strategy.run()&lt;/code&gt; unwraps &lt;code&gt;w&lt;/code&gt; before calling &lt;code&gt;fn&lt;/code&gt;, so it calls &lt;code&gt;fn(w0)&lt;/code&gt; on device &lt;code&gt;d0&lt;/code&gt;, &lt;code&gt;fn(w1)&lt;/code&gt; on device &lt;code&gt;d1&lt;/code&gt;, etc. It then merges the return values from &lt;code&gt;fn()&lt;/code&gt;, which leads to one common object if the returned values are the same object from every replica, or a &lt;code&gt;DistributedValues&lt;/code&gt; object otherwise.</source>
          <target state="translated">&lt;em&gt;언 래핑&lt;/em&gt; 과 &lt;em&gt;병합&lt;/em&gt; : 함수 호출 고려 &lt;code&gt;fn&lt;/code&gt; 같은 다수 복제본을 &lt;code&gt;strategy.run(fn, args=[w])&lt;/code&gt; 인자와 &lt;code&gt;w&lt;/code&gt; 하는 것은이다 &lt;a href=&quot;distribute/distributedvalues&quot;&gt; &lt;code&gt;tf.distribute.DistributedValues&lt;/code&gt; &lt;/a&gt; . 즉, &lt;code&gt;w&lt;/code&gt; 는 복제본 ID &lt;code&gt;0&lt;/code&gt; 에서 &lt;code&gt;w0&lt;/code&gt; , 복제본 ID &lt;code&gt;1&lt;/code&gt; 에서 &lt;code&gt;w1&lt;/code&gt; 등 을 취하는 맵을 갖게됩니다 . &lt;code&gt;strategy.run()&lt;/code&gt; 은 &lt;code&gt;fn&lt;/code&gt; 을 호출하기 전에 &lt;code&gt;w&lt;/code&gt; 를 풀기 때문에 디바이스 &lt;code&gt;d0&lt;/code&gt; 에서 &lt;code&gt;fn(w1)&lt;/code&gt; &lt;code&gt;fn(w0)&lt;/code&gt; , 디바이스 에서 fn (w1) 을 호출 합니다. &lt;code&gt;d1&lt;/code&gt; 그런 다음 &lt;code&gt;fn()&lt;/code&gt; 의 반환 값을 병합하여 반환 된 값이 모든 복제본의 동일한 객체 인 경우 하나의 공통 객체로 연결되고 그렇지 않으면 &lt;code&gt;DistributedValues&lt;/code&gt; 객체가됩니다.</target>
        </trans-unit>
        <trans-unit id="623e69a1404187abf194ba82d8b4b010822c1b03" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Variables may only be created once&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;변수는 한 번만 만들 수 있습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1ed0abef546a8ebf074771df143e0d919deaf4f3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What happens when Strategy.scope is entered?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Strategy.scope를 입력하면 어떻게 되나요?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="828daacfd8a42794fffdca8d416bfcbebd07cf0e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;What should be in scope and what should be outside?&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;범위 내에 있어야하고 외부에 있어야하는 것은 무엇입니까?&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b0ea93a2a3e1dce6ce69cb9acc3992ecccffddf0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;axis (int) attribute&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;축 (int) 속성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="849285c696116e50331df23838e0bc4b0f458e8a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;constant&lt;/em&gt;: &lt;code&gt;(k k k k | a b c d | k k k k)&lt;/code&gt; The input is extended by filling all values beyond the edge with the same constant value k = 0.</source>
          <target state="translated">&lt;em&gt;constant&lt;/em&gt; : &lt;code&gt;(k k k k | a b c d | k k k k)&lt;/code&gt; 동일한 상수 값 k = 0으로 에지 너머의 모든 값을 채워 입력이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="08652daad26fe217ef0c054b74da9d4303e4f97e" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;ensure_minimum_range (float) attribute&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;ensure_minimum_range (float) 속성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="405d2fd39b79c455b88ced5c54baa9d2ce1a0464" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;narrow_range (bool) attribute&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;좁은 범위 (부울) 속성&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="63622fb05e0f6a3395b32adc1cede804cf4b05dd" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;reflect&lt;/em&gt;: &lt;code&gt;(d c b a | a b c d | d c b a)&lt;/code&gt; The input is extended by reflecting about the edge of the last pixel.</source>
          <target state="translated">&lt;em&gt;reflect&lt;/em&gt; : &lt;code&gt;(d c b a | a b c d | d c b a)&lt;/code&gt; 입력은 마지막 픽셀의 가장자리에 대해 반사하여 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec2bcd65c870429640a7336a6fe96cae101e4ad" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;replica context&lt;/em&gt; is when we are in some function that is being called once for each replica. Otherwise we are in cross-replica context, which is useful for calling &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; methods which operate across the replicas (like &lt;code&gt;reduce_to()&lt;/code&gt;). By default you start in a replica context (the &quot;default single replica context&quot;) and then some methods can switch you back and forth. There is a third mode you can be in called &lt;em&gt;update context&lt;/em&gt; used when updating variables.</source>
          <target state="translated">&lt;em&gt;복제본 컨텍스트&lt;/em&gt; 는 각 복제본에 대해 한 번 호출되는 함수에있을 때입니다. 그렇지 않으면 우리는 복제 간 컨텍스트에 있으며 복제본에서 작동 하는 &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 데 유용합니다 ( &lt;code&gt;reduce_to()&lt;/code&gt; ). 기본적으로 복제본 컨텍스트 ( &quot;기본 단일 복제본 컨텍스트&quot;)에서 시작한 다음 일부 방법으로 앞뒤로 전환 할 수 있습니다. 변수를 업데이트 할 때 사용되는 &lt;em&gt;업데이트 컨텍스트&lt;/em&gt; 라는 세 번째 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9de11b11ce0fd959ef95813d0c462f0415eb1555" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;replica context&lt;/em&gt; is when we are in some function that is being called once for each replica. Otherwise we are in cross-replica context, which is useful for calling &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; methods which operate across the replicas (like &lt;code&gt;reduce_to()&lt;/code&gt;). By default you start in a replica context (the &quot;default single replica context&quot;) and then some methods can switch you back and forth. There is a third mode you can be in called &lt;em&gt;update context&lt;/em&gt; used when updating variables.</source>
          <target state="translated">&lt;em&gt;복제본 컨텍스트&lt;/em&gt; 는 각 복제본에 대해 한 번 호출되는 함수에있을 때입니다. 그렇지 않으면 우리는 복제 간 컨텍스트에 있으며 복제본에서 작동 하는 &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 메소드 를 호출하는 데 유용합니다 ( &lt;code&gt;reduce_to()&lt;/code&gt; ). 기본적으로 복제본 컨텍스트 ( &quot;기본 단일 복제본 컨텍스트&quot;)에서 시작한 다음 일부 방법으로 앞뒤로 전환 할 수 있습니다. 변수를 업데이트 할 때 사용되는 &lt;em&gt;업데이트 컨텍스트&lt;/em&gt; 라는 세 번째 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7ffd0d12138578bb5da4913ea9427b0f47b712d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;wrap&lt;/em&gt;: &lt;code&gt;(a b c d | a b c d | a b c d)&lt;/code&gt;</source>
          <target state="translated">&lt;em&gt;줄 바꿈&lt;/em&gt; : &lt;code&gt;(a b c d | a b c d | a b c d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d56af7c63d734482b36063970981d6fe5bd9d2a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;wrap&lt;/em&gt;: &lt;code&gt;(a b c d | a b c d | a b c d)&lt;/code&gt; The input is extended by wrapping around to the opposite edge.</source>
          <target state="translated">&lt;em&gt;wrap&lt;/em&gt; : &lt;code&gt;(a b c d | a b c d | a b c d)&lt;/code&gt; 입력이 반대쪽 가장자리로 둘러싸여 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="b90905db93f694a7a108e1ee29842c8db0d602b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the input flow_in:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;입력 flow_in에 대한 참고 사항 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="55b41906ddc26aa391abf00df1db611e24d48846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A note about the source attribute:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;소스 속성에 대한 참고 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7ea40e5844882bf39c5adebdfc6d2de8599abf1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;About setting &lt;code&gt;layer.trainable = False&lt;/code&gt; on a `BatchNormalization layer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;`BatchNormalization 레이어에서 &lt;code&gt;layer.trainable = False&lt;/code&gt; 설정 정보 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c8786405ec1d37df3c5cac6d0416a3b3f578f1db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;abs&quot;&gt;&lt;code&gt;tf.abs&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;abs&quot;&gt; &lt;code&gt;tf.abs&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba4d021a2d7170aeec50730517a02d491f1520f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;accuracy&quot;&gt;&lt;code&gt;tf.metrics.Accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;accuracy&quot;&gt; &lt;code&gt;tf.metrics.Accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="601ec293e3df1da73969102e176b6579ea09fe10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;acos&quot;&gt;&lt;code&gt;tf.acos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;acos&quot;&gt; &lt;code&gt;tf.acos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3bd72b98b52fee45bd44aa19d51a795c40facc6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;acosh&quot;&gt;&lt;code&gt;tf.acosh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;acosh&quot;&gt; &lt;code&gt;tf.acosh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="891de16db9c5801b22293e68446ad9af87bfa9c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;adadelta&quot;&gt;&lt;code&gt;tf.optimizers.Adadelta&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;adadelta&quot;&gt; &lt;code&gt;tf.optimizers.Adadelta&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29ae97395ea4d22e32a5f2778b698eadb8c14a87" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;adagrad&quot;&gt;&lt;code&gt;tf.optimizers.Adagrad&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;adagrad&quot;&gt; &lt;code&gt;tf.optimizers.Adagrad&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98e5d44c521259ed64be00535515d306d820531d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;adam&quot;&gt;&lt;code&gt;tf.optimizers.Adam&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;adam&quot;&gt; &lt;code&gt;tf.optimizers.Adam&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32441bd05e0100ae3dc27993ca0e4c2ebc990efd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;adamax&quot;&gt;&lt;code&gt;tf.optimizers.Adamax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;adamax&quot;&gt; &lt;code&gt;tf.optimizers.Adamax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae9930689ce8e16b856859f3e648a447f9ee324e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;add&quot;&gt;&lt;code&gt;tf.add&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;add&quot;&gt; &lt;code&gt;tf.add&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8c563bac9e4bb069b74a34caaa70c9849f420d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;add_n&quot;&gt;&lt;code&gt;tf.add_n&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;add_n&quot;&gt; &lt;code&gt;tf.add_n&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="191187d1554cb2bcfb3a85a2ac5b8e2016a02d25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;all_candidate_sampler&quot;&gt;&lt;code&gt;tf.nn.all_candidate_sampler&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;all_candidate_sampler&quot;&gt; &lt;code&gt;tf.nn.all_candidate_sampler&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bee21f148c21bc6ba3f454a69083af59fd5e136d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;argmax&quot;&gt;&lt;code&gt;tf.argmax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;argmax&quot;&gt; &lt;code&gt;tf.argmax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="08983bec1638b7c9a3f51d01576f8ce7c7fe7bfc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;argmin&quot;&gt;&lt;code&gt;tf.argmin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;argmin&quot;&gt; &lt;code&gt;tf.argmin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a858d5fd35eb58939755b3446eeeac359295a643" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;as_dtype&quot;&gt;&lt;code&gt;tf.as_dtype&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;as_dtype&quot;&gt; &lt;code&gt;tf.as_dtype&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="24778d0e2b56905d56d8502c4009ea844c6c7161" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;as_string&quot;&gt;&lt;code&gt;tf.as_string&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;as_string&quot;&gt; &lt;code&gt;tf.as_string&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc873832ee400c9f5fa11f8a29092fe4671e42b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;as_text&quot;&gt;&lt;code&gt;tf.compat.as_str&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;as_text&quot;&gt; &lt;code&gt;tf.compat.as_str&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b9b0d4ef31e7d854587dcbd4dc3a0f313a5a90d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;asin&quot;&gt;&lt;code&gt;tf.asin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;asin&quot;&gt; &lt;code&gt;tf.asin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0d40a9ba3128302a02faba462906ea798bb1110" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;asinh&quot;&gt;&lt;code&gt;tf.asinh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;asinh&quot;&gt; &lt;code&gt;tf.asinh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="db633e896091588a02cd54ab218621bf0b02cee0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;assert&quot;&gt;&lt;code&gt;tf.Assert&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;assert&quot;&gt; &lt;code&gt;tf.Assert&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e97f6b62194132e6076da9076bd2881446bb1e3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;assert_equal&quot;&gt;&lt;code&gt;tf.assert_equal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;assert_equal&quot;&gt; &lt;code&gt;tf.assert_equal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f39fe63bb2160ef66017ed05684ca26a16cf324b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;assert_greater&quot;&gt;&lt;code&gt;tf.assert_greater&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;assert_greater&quot;&gt; &lt;code&gt;tf.assert_greater&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d2fee8d1bc43bfedbcb804ad12dc2154bfd9241" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;assert_less&quot;&gt;&lt;code&gt;tf.assert_less&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;assert_less&quot;&gt; &lt;code&gt;tf.assert_less&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cbc2f81235eeda4296447567ce00335903426f25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;assert_rank&quot;&gt;&lt;code&gt;tf.assert_rank&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;assert_rank&quot;&gt; &lt;code&gt;tf.assert_rank&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4f4bc87d3294c338dd168e824e75234f32fe04c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;atan&quot;&gt;&lt;code&gt;tf.atan&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;atan&quot;&gt; &lt;code&gt;tf.atan&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44cde3598056101788d7c3aa42fe1d78a78c2500" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;atan2&quot;&gt;&lt;code&gt;tf.atan2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;atan2&quot;&gt; &lt;code&gt;tf.atan2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6d8998b4167a62aca739ad3b716327762933df42" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;atanh&quot;&gt;&lt;code&gt;tf.atanh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;atanh&quot;&gt; &lt;code&gt;tf.atanh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2bb908f824e4dbf6dcbde32314d88aef67e0ef8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;auc&quot;&gt;&lt;code&gt;tf.metrics.AUC&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;auc&quot;&gt; &lt;code&gt;tf.metrics.AUC&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33a46eaadd60201eae935f3cba623ffca55968d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;averagepooling1d&quot;&gt;&lt;code&gt;tf.keras.layers.AvgPool1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;averagepooling1d&quot;&gt; &lt;code&gt;tf.keras.layers.AvgPool1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2ac9da2bf15ea62adffc47f562fe6f6a87c0f007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;averagepooling2d&quot;&gt;&lt;code&gt;tf.keras.layers.AvgPool2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;averagepooling2d&quot;&gt; &lt;code&gt;tf.keras.layers.AvgPool2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb11f490a0b4027c60a8c59766030c1d9e1c25ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;averagepooling3d&quot;&gt;&lt;code&gt;tf.keras.layers.AvgPool3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;averagepooling3d&quot;&gt; &lt;code&gt;tf.keras.layers.AvgPool3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9601c33b066a82e5bd748a6a73bfbf0b5db1be60" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;binary_accuracy&quot;&gt;&lt;code&gt;tf.metrics.binary_accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;binary_accuracy&quot;&gt; &lt;code&gt;tf.metrics.binary_accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8577db8a02119844ef07ff1d7a6338453bbadadd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;binary_crossentropy&quot;&gt;&lt;code&gt;tf.keras.metrics.binary_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;binary_crossentropy&quot;&gt;&lt;code&gt;tf.losses.binary_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;binary_crossentropy&quot;&gt;&lt;code&gt;tf.metrics.binary_crossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;binary_crossentropy&quot;&gt; &lt;code&gt;tf.keras.metrics.binary_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;binary_crossentropy&quot;&gt; &lt;code&gt;tf.losses.binary_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;binary_crossentropy&quot;&gt; &lt;code&gt;tf.metrics.binary_crossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="60543389a3058b2b4c34a9f2aa6e03087bc21a63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;binaryaccuracy&quot;&gt;&lt;code&gt;tf.metrics.BinaryAccuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;binaryaccuracy&quot;&gt; &lt;code&gt;tf.metrics.BinaryAccuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3c951217a0b324110cdb0e797fba6802370781b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;binarycrossentropy&quot;&gt;&lt;code&gt;tf.losses.BinaryCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;binarycrossentropy&quot;&gt; &lt;code&gt;tf.losses.BinaryCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fe901d9a20207c235d6a069d101c940cec4da103" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;binarycrossentropy&quot;&gt;&lt;code&gt;tf.metrics.BinaryCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;binarycrossentropy&quot;&gt; &lt;code&gt;tf.metrics.BinaryCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="86247cb8b6cbc8d7113d87342c1feec55d3e097d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cast&quot;&gt;&lt;code&gt;tf.dtypes.cast&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;cast&quot;&gt; &lt;code&gt;tf.dtypes.cast&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6dfe9dddfd8320b1ef0915359a9b46795205fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categorical_accuracy&quot;&gt;&lt;code&gt;tf.metrics.categorical_accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categorical_accuracy&quot;&gt; &lt;code&gt;tf.metrics.categorical_accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b4ed2d5b32e84ab173fdecfa9c419af51d8d350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categorical_crossentropy&quot;&gt;&lt;code&gt;tf.keras.metrics.categorical_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;categorical_crossentropy&quot;&gt;&lt;code&gt;tf.losses.categorical_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;categorical_crossentropy&quot;&gt;&lt;code&gt;tf.metrics.categorical_crossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categorical_crossentropy&quot;&gt; &lt;code&gt;tf.keras.metrics.categorical_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;categorical_crossentropy&quot;&gt; &lt;code&gt;tf.losses.categorical_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;categorical_crossentropy&quot;&gt; &lt;code&gt;tf.metrics.categorical_crossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95a3731daaa7b11d0d5421195513228156616872" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categorical_hinge&quot;&gt;&lt;code&gt;tf.losses.categorical_hinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categorical_hinge&quot;&gt; &lt;code&gt;tf.losses.categorical_hinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c0de727c340bb1f2d1d9fb3dc6e075f1f76e0f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categoricalaccuracy&quot;&gt;&lt;code&gt;tf.metrics.CategoricalAccuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categoricalaccuracy&quot;&gt; &lt;code&gt;tf.metrics.CategoricalAccuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c33d9a7df334bffa5be31f64a01b36fe9df58e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categoricalcrossentropy&quot;&gt;&lt;code&gt;tf.losses.CategoricalCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categoricalcrossentropy&quot;&gt; &lt;code&gt;tf.losses.CategoricalCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6f4b168f3ab69b3222efcabd6e1f8f5a602bf95" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categoricalcrossentropy&quot;&gt;&lt;code&gt;tf.metrics.CategoricalCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categoricalcrossentropy&quot;&gt; &lt;code&gt;tf.metrics.CategoricalCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b1c7b5a9b24ad618d439226c59d5d678976cdcc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categoricalhinge&quot;&gt;&lt;code&gt;tf.losses.CategoricalHinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categoricalhinge&quot;&gt; &lt;code&gt;tf.losses.CategoricalHinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d96d3932652349c815a6e09fd812bb5de4ddc380" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;categoricalhinge&quot;&gt;&lt;code&gt;tf.metrics.CategoricalHinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;categoricalhinge&quot;&gt; &lt;code&gt;tf.metrics.CategoricalHinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b07f3aadfbbf800c207aa27bad3fac4aac7e9fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;complex&quot;&gt;&lt;code&gt;tf.complex&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;complex&quot;&gt; &lt;code&gt;tf.complex&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="018c2f17ac85727e6274f12d531eda8d4d3e18de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;constant_initializer&quot;&gt;&lt;code&gt;tf.initializers.Constant&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;constant_initializer&quot;&gt;&lt;code&gt;tf.initializers.constant&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;constant_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.Constant&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;constant_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.constant&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;constant_initializer&quot;&gt; &lt;code&gt;tf.initializers.Constant&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constant_initializer&quot;&gt; &lt;code&gt;tf.initializers.constant&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constant_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.Constant&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;constant_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.constant&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb4c849f0e4b54d3817e67284130efe3a76f1526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;conv1d&quot;&gt;&lt;code&gt;tf.keras.layers.Convolution1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;conv1d&quot;&gt; &lt;code&gt;tf.keras.layers.Convolution1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4217f51564e74a66b77ee9fabf2b2fcf658916fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;conv2d&quot;&gt;&lt;code&gt;tf.keras.layers.Convolution2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;conv2d&quot;&gt; &lt;code&gt;tf.keras.layers.Convolution2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77483f4c459d7ba4ebbcde1507dba3a16d1b7a09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;conv2dtranspose&quot;&gt;&lt;code&gt;tf.keras.layers.Convolution2DTranspose&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;conv2dtranspose&quot;&gt; &lt;code&gt;tf.keras.layers.Convolution2DTranspose&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="23477027d5d34078f5b4e70a60d7a1a84e4f527c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;conv3d&quot;&gt;&lt;code&gt;tf.keras.layers.Convolution3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;conv3d&quot;&gt; &lt;code&gt;tf.keras.layers.Convolution3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="02e6f15f15d8a7ccd972e1b43c3a3cf4ac6ef846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;conv3dtranspose&quot;&gt;&lt;code&gt;tf.keras.layers.Convolution3DTranspose&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;conv3dtranspose&quot;&gt; &lt;code&gt;tf.keras.layers.Convolution3DTranspose&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9eecbbadedc54fef95fff59be15dedb53fb4e1bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cos&quot;&gt;&lt;code&gt;tf.cos&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;cos&quot;&gt; &lt;code&gt;tf.cos&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7b86485d006d98698456b1f6b9ffe24fb84e0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cosh&quot;&gt;&lt;code&gt;tf.cosh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;cosh&quot;&gt; &lt;code&gt;tf.cosh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="958e4326a9ebbfb82e2cb9a86e8b3446e3fcdd1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cosine_similarity&quot;&gt;&lt;code&gt;tf.losses.cosine_similarity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;cosine_similarity&quot;&gt; &lt;code&gt;tf.losses.cosine_similarity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40d3805055ee769ef9c4bd9a583679de3067102d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cosinesimilarity&quot;&gt;&lt;code&gt;tf.losses.CosineSimilarity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;cosinesimilarity&quot;&gt; &lt;code&gt;tf.losses.CosineSimilarity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e238ab7d057341c3b67e104af002015dc1c6902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cosinesimilarity&quot;&gt;&lt;code&gt;tf.metrics.CosineSimilarity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;cosinesimilarity&quot;&gt; &lt;code&gt;tf.metrics.CosineSimilarity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0aa33a25b6a3a9acd470b7e259465789a5759d2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;cumsum&quot;&gt;&lt;code&gt;tf.cumsum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;cumsum&quot;&gt; &lt;code&gt;tf.cumsum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd521eb88ad557f232b77fcc604595bd0d6b325b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_and_crop_jpeg&quot;&gt;&lt;code&gt;tf.image.decode_and_crop_jpeg&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_and_crop_jpeg&quot;&gt; &lt;code&gt;tf.image.decode_and_crop_jpeg&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8f81923a9f5ee628804f75809032055f03fce9f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_bmp&quot;&gt;&lt;code&gt;tf.image.decode_bmp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_bmp&quot;&gt; &lt;code&gt;tf.image.decode_bmp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fba45799d5f910ac2b7a4ea4573c1c1c720eae7d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_gif&quot;&gt;&lt;code&gt;tf.image.decode_gif&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_gif&quot;&gt; &lt;code&gt;tf.image.decode_gif&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="835eb0d5292c66d514db42599c8f2cc0abd2ab23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_image&quot;&gt;&lt;code&gt;tf.image.decode_image&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;decode_image&quot;&gt; &lt;code&gt;tf.image.decode_image&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d41b20f1cd18c97a16f208529fddc93a056a64bf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_jpeg&quot;&gt;&lt;code&gt;tf.image.decode_jpeg&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_jpeg&quot;&gt; &lt;code&gt;tf.image.decode_jpeg&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d0f7132af6a32a55c5d156a3d560f857e5f58b09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_png&quot;&gt;&lt;code&gt;tf.image.decode_png&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_png&quot;&gt; &lt;code&gt;tf.image.decode_png&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3cc73b574e951ddbe97d330006e3c6938757a69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;decode_predictions&quot;&gt;&lt;code&gt;tf.keras.applications.resnet50.decode_predictions&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;decode_predictions&quot;&gt; &lt;code&gt;tf.keras.applications.resnet50.decode_predictions&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c5051f18c8ed8a46067174e28bcda44ed0592eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;densenet121&quot;&gt;&lt;code&gt;tf.keras.applications.densenet.DenseNet121&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;densenet121&quot;&gt; &lt;code&gt;tf.keras.applications.densenet.DenseNet121&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2bfe37b2681f7f654b8cb2cc91b037f2e1809ea1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;densenet169&quot;&gt;&lt;code&gt;tf.keras.applications.densenet.DenseNet169&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;densenet169&quot;&gt; &lt;code&gt;tf.keras.applications.densenet.DenseNet169&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b025264667a1bbbce44333ab01ca6a29a29f2260" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;densenet201&quot;&gt;&lt;code&gt;tf.keras.applications.densenet.DenseNet201&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;densenet201&quot;&gt; &lt;code&gt;tf.keras.applications.densenet.DenseNet201&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10baff4ddb3f7ecb9862b950c1c02a47f8d7e141" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.initializers.deserialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.initializers.deserialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3fcd59aa6d08f929fa4a82b1bab626326a24f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.losses.deserialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.losses.deserialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ab3b4b3beb8b919d2cfa642a9967b65b943c55f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.metrics.deserialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.metrics.deserialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="538bb241737fa678ac18f9002c18c72f4b3e2c58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.optimizers.deserialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.optimizers.deserialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4b0b2f1e36750eacc5c8fed27a3479ee7f526ca1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;deserialize&quot;&gt;&lt;code&gt;tf.optimizers.schedules.deserialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;deserialize&quot;&gt; &lt;code&gt;tf.optimizers.schedules.deserialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3bf559a8f54fab38656361daaa82ff4dbb6cc99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;divide&quot;&gt;&lt;code&gt;tf.divide&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;divide&quot;&gt; &lt;code&gt;tf.divide&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a6de5d20066441434f15f6735ad7e29640b56e84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;dtype&quot;&gt;&lt;code&gt;tf.DType&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;dtype&quot;&gt; &lt;code&gt;tf.DType&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b03299f37fc58b80d76b80f5fd5488edc5ca635d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;dynamiclossscale&quot;&gt;&lt;code&gt;tf.train.experimental.DynamicLossScale&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;dynamiclossscale&quot;&gt; &lt;code&gt;tf.train.experimental.DynamicLossScale&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aa79414e1bb3c52ef6d7fed078c21167a67b97fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;eig&quot;&gt;&lt;code&gt;tf.linalg.eig&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;eig&quot;&gt; &lt;code&gt;tf.linalg.eig&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20102fa884ff5988093779e2664caf39fcda172b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;eigvals&quot;&gt;&lt;code&gt;tf.linalg.eigvals&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;eigvals&quot;&gt; &lt;code&gt;tf.linalg.eigvals&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87e23db44b8d4a07d6e33fea087e8e19dad0b8f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;einsum&quot;&gt;&lt;code&gt;tf.linalg.einsum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;einsum&quot;&gt; &lt;code&gt;tf.linalg.einsum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="65f0542339ed92ad4dc2d5922e931b37c8b12b13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;encode_jpeg&quot;&gt;&lt;code&gt;tf.image.encode_jpeg&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;encode_jpeg&quot;&gt; &lt;code&gt;tf.image.encode_jpeg&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0d46e67c4fed4f1122d6521ec2ffe4ee22f72ce2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;equal&quot;&gt;&lt;code&gt;tf.equal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;equal&quot;&gt; &lt;code&gt;tf.equal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a208c38ebf6ded02824d149bbd1c8c2b71b1f1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;exp&quot;&gt;&lt;code&gt;tf.exp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;exp&quot;&gt; &lt;code&gt;tf.exp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23d3546a59ea87a3062902bf1f02d478c293676" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;exponentialdecay&quot;&gt;&lt;code&gt;tf.optimizers.schedules.ExponentialDecay&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;exponentialdecay&quot;&gt; &lt;code&gt;tf.optimizers.schedules.ExponentialDecay&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="15422835e3728f3b335bfcbc01b14442d097e2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;extract_jpeg_shape&quot;&gt;&lt;code&gt;tf.image.extract_jpeg_shape&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;extract_jpeg_shape&quot;&gt; &lt;code&gt;tf.image.extract_jpeg_shape&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bf90eccbee1e5770dd0fd500322040b326794a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;eye&quot;&gt;&lt;code&gt;tf.linalg.eye&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;eye&quot;&gt; &lt;code&gt;tf.linalg.eye&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9ecfb81de31353d1adb333a0d23456d7b769239a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;falsenegatives&quot;&gt;&lt;code&gt;tf.metrics.FalseNegatives&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;falsenegatives&quot;&gt; &lt;code&gt;tf.metrics.FalseNegatives&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82954297b38f54cc01b08e9908f863899d45bf4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;falsepositives&quot;&gt;&lt;code&gt;tf.metrics.FalsePositives&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;falsepositives&quot;&gt; &lt;code&gt;tf.metrics.FalsePositives&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="52c6cfb012a47fd5ec5b019c148e93a68095a820" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;fixed_unigram_candidate_sampler&quot;&gt;&lt;code&gt;tf.nn.fixed_unigram_candidate_sampler&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;fixed_unigram_candidate_sampler&quot;&gt; &lt;code&gt;tf.nn.fixed_unigram_candidate_sampler&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2d6b56ef41acb3750b4ce4b175dbf29be812cd25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;fixedlossscale&quot;&gt;&lt;code&gt;tf.train.experimental.FixedLossScale&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;fixedlossscale&quot;&gt; &lt;code&gt;tf.train.experimental.FixedLossScale&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2a08e0012a8d6fe2a62200ba323b3cd63c803a74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;floor&quot;&gt;&lt;code&gt;tf.floor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;floor&quot;&gt; &lt;code&gt;tf.floor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e3fdb4632f3fbd18e0c67f598ea1cffbdeec2ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;floormod&quot;&gt;&lt;code&gt;tf.math.mod&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;floormod&quot;&gt; &lt;code&gt;tf.math.mod&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f8d3fa063aa50ea71dd78f19cdd31b827daf928" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;ftrl&quot;&gt;&lt;code&gt;tf.optimizers.Ftrl&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;ftrl&quot;&gt; &lt;code&gt;tf.optimizers.Ftrl&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11b13df482e2b6d17839231f302b52ac9492e9f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get&quot;&gt;&lt;code&gt;tf.initializers.get&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;get&quot;&gt; &lt;code&gt;tf.initializers.get&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cb1c0cb7857e0266d711032de7e0be973e952d32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get&quot;&gt;&lt;code&gt;tf.losses.get&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;get&quot;&gt; &lt;code&gt;tf.losses.get&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6efe9a95c8b3f420643781014068537031af46d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get&quot;&gt;&lt;code&gt;tf.metrics.get&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;get&quot;&gt; &lt;code&gt;tf.metrics.get&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5cc33e75b4e1c5f4261a7b03c970ea2db93ea4dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get&quot;&gt;&lt;code&gt;tf.optimizers.get&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;get&quot;&gt; &lt;code&gt;tf.optimizers.get&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec9656e83883198b0286fa59e8cb1fedfb49721a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get_logical_device_configuration&quot;&gt;&lt;code&gt;tf.config.experimental.get_virtual_device_configuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;get_logical_device_configuration&quot;&gt; &lt;code&gt;tf.config.experimental.get_virtual_device_configuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7395b616fb9e5922a73a470bad7d1dd1a6be8b46" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;get_visible_devices&quot;&gt;&lt;code&gt;tf.config.experimental.get_visible_devices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;get_visible_devices&quot;&gt; &lt;code&gt;tf.config.experimental.get_visible_devices&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cd03b6453a594b88e2de107c2e5ca55819a926a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalaveragepooling1d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalAvgPool1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalaveragepooling1d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalAvgPool1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a14f18710b96902680e7e4e6f052d0f9bb89f3d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalaveragepooling2d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalAvgPool2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalaveragepooling2d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalAvgPool2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8490ea4e2da1bd1400d4e63707a222d764b5bb24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalaveragepooling3d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalAvgPool3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalaveragepooling3d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalAvgPool3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c50438b2d61f3d24696789d74844be3bde6902a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalmaxpool1d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalMaxPooling1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalmaxpool1d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalMaxPooling1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="441f0020e05880e5e9140083daa2ae16aeb75c63" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalmaxpool2d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalMaxPooling2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalmaxpool2d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalMaxPooling2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d52572d0bab10674b48d8eb39bb2ee66a6691c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;globalmaxpool3d&quot;&gt;&lt;code&gt;tf.keras.layers.GlobalMaxPooling3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;globalmaxpool3d&quot;&gt; &lt;code&gt;tf.keras.layers.GlobalMaxPooling3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3c1a5dc46594a8992326658510d64986ae0ed6e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;glorotnormal&quot;&gt;&lt;code&gt;tf.initializers.GlorotNormal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;glorotnormal&quot;&gt;&lt;code&gt;tf.initializers.glorot_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;glorotnormal&quot;&gt;&lt;code&gt;tf.keras.initializers.glorot_normal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;glorotnormal&quot;&gt; &lt;code&gt;tf.initializers.GlorotNormal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;glorotnormal&quot;&gt; &lt;code&gt;tf.initializers.glorot_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;glorotnormal&quot;&gt; &lt;code&gt;tf.keras.initializers.glorot_normal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c782094148c38b93c119bf30f6c212fd7ecfd172" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;glorotuniform&quot;&gt;&lt;code&gt;tf.initializers.GlorotUniform&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;glorotuniform&quot;&gt;&lt;code&gt;tf.initializers.glorot_uniform&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;glorotuniform&quot;&gt;&lt;code&gt;tf.keras.initializers.glorot_uniform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;glorotuniform&quot;&gt; &lt;code&gt;tf.initializers.GlorotUniform&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;glorotuniform&quot;&gt; &lt;code&gt;tf.initializers.glorot_uniform&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;glorotuniform&quot;&gt; &lt;code&gt;tf.keras.initializers.glorot_uniform&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd7d8897b4f7b40db6d7ab1d8a7709578f93aa66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;gradienttape&quot;&gt;&lt;code&gt;tf.autodiff.GradientTape&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;gradienttape&quot;&gt; &lt;code&gt;tf.autodiff.GradientTape&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b223991345176803577f10773605ce7a26372aac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;greater&quot;&gt;&lt;code&gt;tf.greater&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;greater&quot;&gt; &lt;code&gt;tf.greater&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="710d7f34806cae6c50e1ff24335da21c90e113da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;greater_equal&quot;&gt;&lt;code&gt;tf.greater_equal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;greater_equal&quot;&gt; &lt;code&gt;tf.greater_equal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ec18336f616ca106c339ef01c9e577894ef3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;he_normal&quot;&gt;&lt;code&gt;tf.initializers.he_normal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;he_normal&quot;&gt; &lt;code&gt;tf.initializers.he_normal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d4691e87fce2cad111d522720452c5b84cef37b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;he_uniform&quot;&gt;&lt;code&gt;tf.initializers.he_uniform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;he_uniform&quot;&gt; &lt;code&gt;tf.initializers.he_uniform&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a8c1c8de0598d138d7bf101cd4edbed3e36a0a0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;hinge&quot;&gt;&lt;code&gt;tf.losses.Hinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;hinge&quot;&gt; &lt;code&gt;tf.losses.Hinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f66a8dd9975c3ca28ff088e35b811d7b23d1273" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;hinge&quot;&gt;&lt;code&gt;tf.metrics.Hinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;hinge&quot;&gt; &lt;code&gt;tf.metrics.Hinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b8785c3f2bb5e487e7767d7a581464ccb99aab2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;huber&quot;&gt;&lt;code&gt;tf.losses.Huber&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;huber&quot;&gt; &lt;code&gt;tf.losses.Huber&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74e883356e5b8f7a31cff2977f2b0ba70830d3b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;tf.initializers.Identity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;tf.initializers.identity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;identity&quot;&gt;&lt;code&gt;tf.keras.initializers.identity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;tf.initializers.Identity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;tf.initializers.identity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;identity&quot;&gt; &lt;code&gt;tf.keras.initializers.identity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea17f8463b4737c40e4e34dd04ae41da435a5071" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;import_graph_def&quot;&gt;&lt;code&gt;tf.import_graph_def&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;import_graph_def&quot;&gt; &lt;code&gt;tf.import_graph_def&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ad81c80f0175e466b81f6dd3e10b885e5c0dd3f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;in_top_k&quot;&gt;&lt;code&gt;tf.nn.in_top_k&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;in_top_k&quot;&gt; &lt;code&gt;tf.nn.in_top_k&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="933bd7ad4f4ef7552e1dea6c381bc0ef76bed10d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;inceptionresnetv2&quot;&gt;&lt;code&gt;tf.keras.applications.inception_resnet_v2.InceptionResNetV2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;inceptionresnetv2&quot;&gt; &lt;code&gt;tf.keras.applications.inception_resnet_v2.InceptionResNetV2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7458602002d38754bdcf83a4d5876230e1a6860" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;inceptionv3&quot;&gt;&lt;code&gt;tf.keras.applications.inception_v3.InceptionV3&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;inceptionv3&quot;&gt; &lt;code&gt;tf.keras.applications.inception_v3.InceptionV3&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae5ce02a9af485b2c2882e23a8d7a129533ad6a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;initializer&quot;&gt;&lt;code&gt;tf.initializers.Initializer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;initializer&quot;&gt; &lt;code&gt;tf.initializers.Initializer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06888e5a98e33c1b146bf28ce797842219e6d8cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;initializers&quot;&gt;&lt;code&gt;tf.initializers&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;initializers&quot;&gt; &lt;code&gt;tf.initializers&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cabfe1d7c1613fa967c2fe08fb0462146de773b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;input&quot;&gt;&lt;code&gt;tf.keras.layers.Input&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;input&quot;&gt; &lt;code&gt;tf.keras.layers.Input&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0f6b796cd81502a8adf91b8e231ad67ca9621820" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;inversetimedecay&quot;&gt;&lt;code&gt;tf.optimizers.schedules.InverseTimeDecay&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;inversetimedecay&quot;&gt; &lt;code&gt;tf.optimizers.schedules.InverseTimeDecay&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c4c00c479a41816c487fbc62dd5eb1b3908d450" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;is_jpeg&quot;&gt;&lt;code&gt;tf.image.is_jpeg&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;is_jpeg&quot;&gt; &lt;code&gt;tf.image.is_jpeg&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33b9b4f08f9258ebd3165f01f144c29b9675d063" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.keras.losses.kld&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.keras.losses.kullback_leibler_divergence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.keras.metrics.KLD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.keras.metrics.kld&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.keras.metrics.kullback_leibler_divergence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.losses.KLD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.losses.kld&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.losses.kullback_leibler_divergence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.metrics.KLD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.metrics.kld&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;kld&quot;&gt;&lt;code&gt;tf.metrics.kullback_leibler_divergence&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.keras.losses.kld&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.keras.losses.kullback_leibler_divergence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.keras.metrics.KLD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.keras.metrics.kld&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.keras.metrics.kullback_leibler_divergence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.losses.KLD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.losses.kld&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.losses.kullback_leibler_divergence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.metrics.KLD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.metrics.kld&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;kld&quot;&gt; &lt;code&gt;tf.metrics.kullback_leibler_divergence&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="334451b1786ec5297e904f355e33cc71360cad09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;kldivergence&quot;&gt;&lt;code&gt;tf.losses.KLDivergence&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;kldivergence&quot;&gt; &lt;code&gt;tf.losses.KLDivergence&lt;/code&gt; &lt;/a&gt; . KLDivergence</target>
        </trans-unit>
        <trans-unit id="634aa3cd77c51179f61bc0489632b0f7354f9e80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;kldivergence&quot;&gt;&lt;code&gt;tf.metrics.KLDivergence&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;kldivergence&quot;&gt; &lt;code&gt;tf.metrics.KLDivergence&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f62acf97cf05f70c93b631e7913daaa15562d2b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;l2_normalize&quot;&gt;&lt;code&gt;tf.linalg.l2_normalize&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;l2_normalize&quot;&gt;&lt;code&gt;tf.nn.l2_normalize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;l2_normalize&quot;&gt; &lt;code&gt;tf.linalg.l2_normalize&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;l2_normalize&quot;&gt; &lt;code&gt;tf.nn.l2_normalize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7f1ccdac91ccb3cc5fdc2ee01ea15c8b03f281ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;learned_unigram_candidate_sampler&quot;&gt;&lt;code&gt;tf.nn.learned_unigram_candidate_sampler&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;learned_unigram_candidate_sampler&quot;&gt; &lt;code&gt;tf.nn.learned_unigram_candidate_sampler&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4cb2d5fa54a45e5040997b61302f2babc78a7160" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;learningrateschedule&quot;&gt;&lt;code&gt;tf.optimizers.schedules.LearningRateSchedule&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;learningrateschedule&quot;&gt; &lt;code&gt;tf.optimizers.schedules.LearningRateSchedule&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2b8e966ab826b086b27c0307a12f11d14e0716d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;lecun_normal&quot;&gt;&lt;code&gt;tf.initializers.lecun_normal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;lecun_normal&quot;&gt; &lt;code&gt;tf.initializers.lecun_normal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b753bb04ff1857c032a1f70c69b9d05556ff7892" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;lecun_uniform&quot;&gt;&lt;code&gt;tf.initializers.lecun_uniform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;lecun_uniform&quot;&gt; &lt;code&gt;tf.initializers.lecun_uniform&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4352d0261d644ede220cb07974f154e077043ba9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;less&quot;&gt;&lt;code&gt;tf.less&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;less&quot;&gt; &lt;code&gt;tf.less&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="219b997a0f1acbd6e1fcfacf25f4fa580e81d7c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;less_equal&quot;&gt;&lt;code&gt;tf.less_equal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;less_equal&quot;&gt; &lt;code&gt;tf.less_equal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38285c0a6379cf340fbdf81e884834bddb22eb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;list_logical_devices&quot;&gt;&lt;code&gt;tf.config.experimental.list_logical_devices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;list_logical_devices&quot;&gt; &lt;code&gt;tf.config.experimental.list_logical_devices&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88f4f04a55a81fa8e0b01a2006728d5c3456dccf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;list_physical_devices&quot;&gt;&lt;code&gt;tf.config.experimental.list_physical_devices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;list_physical_devices&quot;&gt; &lt;code&gt;tf.config.experimental.list_physical_devices&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0da6a0f5d0e1b1acd2fdd7cdcfe6f7ba80de3ddf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;local_response_normalization&quot;&gt;&lt;code&gt;tf.nn.lrn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;local_response_normalization&quot;&gt; &lt;code&gt;tf.nn.lrn&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff4f3a199bbff961a8a683490ecca3b37dae8309" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;log_softmax&quot;&gt;&lt;code&gt;tf.math.log_softmax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;log_softmax&quot;&gt; &lt;code&gt;tf.math.log_softmax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f8776fc9e5a506eb0c4242237dd2faee9f2ad946" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logcosh&quot;&gt;&lt;code&gt;tf.losses.LogCosh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;logcosh&quot;&gt; &lt;code&gt;tf.losses.LogCosh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d5862f19ccb1d4bc93ffd05532ea4897526793d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logcosherror&quot;&gt;&lt;code&gt;tf.metrics.LogCoshError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;logcosherror&quot;&gt; &lt;code&gt;tf.metrics.LogCoshError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8c48ede964a59b0f71f9a9a78c5d3a43cb23724" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logical_and&quot;&gt;&lt;code&gt;tf.logical_and&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;logical_and&quot;&gt; &lt;code&gt;tf.logical_and&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="825cc1196b3bf16d6e60d22aa0bfdec1a1c2956f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logical_not&quot;&gt;&lt;code&gt;tf.logical_not&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;logical_not&quot;&gt; &lt;code&gt;tf.logical_not&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="507b7778fdd4760f7edbe7b466b4582d3a6c18ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logical_or&quot;&gt;&lt;code&gt;tf.logical_or&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;logical_or&quot;&gt; &lt;code&gt;tf.logical_or&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8ffa03e440b81d33a983bfa37ca270da209a401" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;logicaldeviceconfiguration&quot;&gt;&lt;code&gt;tf.config.experimental.VirtualDeviceConfiguration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;logicaldeviceconfiguration&quot;&gt; &lt;code&gt;tf.config.experimental.VirtualDeviceConfiguration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3edf027eb7659d878360f96cf94df51de46f2aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;loss&quot;&gt;&lt;code&gt;tf.losses.Loss&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;loss&quot;&gt; &lt;code&gt;tf.losses.Loss&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7c308812eafb22490a75a69c747b532649f6d0eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;losses&quot;&gt;&lt;code&gt;tf.losses&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;losses&quot;&gt; &lt;code&gt;tf.losses&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29d0dc4871dc9639dfd8e2f75ee0aecfd429ed9e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;lossscale&quot;&gt;&lt;code&gt;tf.train.experimental.LossScale&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;lossscale&quot;&gt; &lt;code&gt;tf.train.experimental.LossScale&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="54db9aa723fc8af88dee594fd47d26fea38e6511" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.keras.losses.mae&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.keras.losses.mean_absolute_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.keras.metrics.MAE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.keras.metrics.mae&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.keras.metrics.mean_absolute_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.losses.MAE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.losses.mae&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.losses.mean_absolute_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.metrics.MAE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.metrics.mae&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mae&quot;&gt;&lt;code&gt;tf.metrics.mean_absolute_error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.keras.losses.mae&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.keras.losses.mean_absolute_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.keras.metrics.MAE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.keras.metrics.mae&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.keras.metrics.mean_absolute_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.losses.MAE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.losses.mae&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.losses.mean_absolute_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.metrics.MAE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.metrics.mae&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mae&quot;&gt; &lt;code&gt;tf.metrics.mean_absolute_error&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="45df923b83163bfbcd3daa690ac37c7aefb5ee3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.keras.losses.mape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.keras.losses.mean_absolute_percentage_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.keras.metrics.MAPE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.keras.metrics.mape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.keras.metrics.mean_absolute_percentage_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.losses.MAPE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.losses.mape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.losses.mean_absolute_percentage_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.metrics.MAPE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.metrics.mape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mape&quot;&gt;&lt;code&gt;tf.metrics.mean_absolute_percentage_error&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.keras.losses.mape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.keras.losses.mean_absolute_percentage_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.keras.metrics.MAPE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.keras.metrics.mape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.keras.metrics.mean_absolute_percentage_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.losses.MAPE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.losses.mape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.losses.mean_absolute_percentage_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.metrics.MAPE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.metrics.mape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mape&quot;&gt; &lt;code&gt;tf.metrics.mean_absolute_percentage_error&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6586157c409c394731f2a9fd84c1e6152a7e0c4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5fc1933b8f8a5835dd35ef028910843f3bcdb95c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;maximum&quot;&gt;&lt;code&gt;tf.maximum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;maximum&quot;&gt; &lt;code&gt;tf.maximum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b969d1bceb2019d3f8f50b7aba2f7b3f9b58aacc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;maxnorm&quot;&gt;&lt;code&gt;tf.keras.constraints.max_norm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;maxnorm&quot;&gt; &lt;code&gt;tf.keras.constraints.max_norm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cda6174482b988e638715d1ebe988bbfaca93fab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;maxpool1d&quot;&gt;&lt;code&gt;tf.keras.layers.MaxPooling1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;maxpool1d&quot;&gt; &lt;code&gt;tf.keras.layers.MaxPooling1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fd23354dcbd89839d7076e6ba53fad876afee71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;maxpool2d&quot;&gt;&lt;code&gt;tf.keras.layers.MaxPooling2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;maxpool2d&quot;&gt; &lt;code&gt;tf.keras.layers.MaxPooling2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a623b16c91a73b5ff95834aeeb546d3794631e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;maxpool3d&quot;&gt;&lt;code&gt;tf.keras.layers.MaxPooling3D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;maxpool3d&quot;&gt; &lt;code&gt;tf.keras.layers.MaxPooling3D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3e860d9f0d8f6b00a0a7f269f7c3c47adef9fef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mean&quot;&gt;&lt;code&gt;tf.metrics.Mean&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;mean&quot;&gt; &lt;code&gt;tf.metrics.Mean&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="afc8befbd8d688fbaff408599b8bf2c1bd33df47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meanabsoluteerror&quot;&gt;&lt;code&gt;tf.losses.MeanAbsoluteError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meanabsoluteerror&quot;&gt; &lt;code&gt;tf.losses.MeanAbsoluteError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="73dec8a5d2a296c6e3fbd68cf5ef7a055617005c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meanabsoluteerror&quot;&gt;&lt;code&gt;tf.metrics.MeanAbsoluteError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meanabsoluteerror&quot;&gt; &lt;code&gt;tf.metrics.MeanAbsoluteError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3f9c7bc0417d7f467ed9050b684660cdf957b622" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meanabsolutepercentageerror&quot;&gt;&lt;code&gt;tf.losses.MeanAbsolutePercentageError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meanabsolutepercentageerror&quot;&gt; &lt;code&gt;tf.losses.MeanAbsolutePercentageError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f846a63b96c5e0dc28f40f226bfa852a404c8ee9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meanabsolutepercentageerror&quot;&gt;&lt;code&gt;tf.metrics.MeanAbsolutePercentageError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meanabsolutepercentageerror&quot;&gt; &lt;code&gt;tf.metrics.MeanAbsolutePercentageError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d471437765c8fdb5558941dc5fd076dcd39acdfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meaniou&quot;&gt;&lt;code&gt;tf.metrics.MeanIoU&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meaniou&quot;&gt; &lt;code&gt;tf.metrics.MeanIoU&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ea22284f778ef325add7e702144735916489aaaf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meanrelativeerror&quot;&gt;&lt;code&gt;tf.metrics.MeanRelativeError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meanrelativeerror&quot;&gt; &lt;code&gt;tf.metrics.MeanRelativeError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="028c2e23c46e250a6eaef95a629ef072b630ec2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meansquarederror&quot;&gt;&lt;code&gt;tf.losses.MeanSquaredError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meansquarederror&quot;&gt; &lt;code&gt;tf.losses.MeanSquaredError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62a344d8ed47ba951dea2aafd7b0c07a241cd102" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meansquarederror&quot;&gt;&lt;code&gt;tf.metrics.MeanSquaredError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meansquarederror&quot;&gt; &lt;code&gt;tf.metrics.MeanSquaredError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fdf832c7442adef363dad321a65213bef82cbac7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meansquaredlogarithmicerror&quot;&gt;&lt;code&gt;tf.losses.MeanSquaredLogarithmicError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meansquaredlogarithmicerror&quot;&gt; &lt;code&gt;tf.losses.MeanSquaredLogarithmicError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="156d9d4e8b90b17d3c2b96384b5ae35e467f20b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meansquaredlogarithmicerror&quot;&gt;&lt;code&gt;tf.metrics.MeanSquaredLogarithmicError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meansquaredlogarithmicerror&quot;&gt; &lt;code&gt;tf.metrics.MeanSquaredLogarithmicError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e962b07987d2fb505b9b59fde9c3d6e4413c7b67" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;meantensor&quot;&gt;&lt;code&gt;tf.metrics.MeanTensor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;meantensor&quot;&gt; &lt;code&gt;tf.metrics.MeanTensor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4d51886ad9305b5bf4a65d0b44f361e35d3ca7c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;metric&quot;&gt;&lt;code&gt;tf.metrics.Metric&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;metric&quot;&gt; &lt;code&gt;tf.metrics.Metric&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d9f23949f0818b7a52ad1d56e777cd514c9e959" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;metrics&quot;&gt;&lt;code&gt;tf.metrics&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;metrics&quot;&gt; &lt;code&gt;tf.metrics&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d296da1a21696a5fdd83c1b33879bebf15ec6567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;minimum&quot;&gt;&lt;code&gt;tf.minimum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;minimum&quot;&gt; &lt;code&gt;tf.minimum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b663d37ce859889613ce814f157eb332446ecc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;minmaxnorm&quot;&gt;&lt;code&gt;tf.keras.constraints.min_max_norm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;minmaxnorm&quot;&gt; &lt;code&gt;tf.keras.constraints.min_max_norm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8891cb34fc55bf2a2b560f94c4f0c1ab59209b65" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mobilenet&quot;&gt;&lt;code&gt;tf.keras.applications.mobilenet.MobileNet&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;mobilenet&quot;&gt; &lt;code&gt;tf.keras.applications.mobilenet.MobileNet&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ef136a94770200b0234261bfbba3de7e4341866d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mobilenetv2&quot;&gt;&lt;code&gt;tf.keras.applications.mobilenet_v2.MobileNetV2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;mobilenetv2&quot;&gt; &lt;code&gt;tf.keras.applications.mobilenet_v2.MobileNetV2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a440413adcd274e2fedfe10cb86cadde62fc5fdd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;model&quot;&gt;&lt;code&gt;tf.keras.models.Model&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;model&quot;&gt; &lt;code&gt;tf.keras.models.Model&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb869e733f5fa0d7888c337665a4e5a3c05b469d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.keras.losses.mean_squared_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.keras.losses.mse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.keras.metrics.MSE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.keras.metrics.mean_squared_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.keras.metrics.mse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.losses.MSE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.losses.mean_squared_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.losses.mse&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.metrics.MSE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.metrics.mean_squared_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;mse&quot;&gt;&lt;code&gt;tf.metrics.mse&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.keras.losses.mean_squared_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.keras.losses.mse&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.keras.metrics.MSE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.keras.metrics.mean_squared_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.keras.metrics.mse&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.losses.MSE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.losses.mean_squared_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.losses.mse&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.metrics.MSE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.metrics.mean_squared_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;mse&quot;&gt; &lt;code&gt;tf.metrics.mse&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b3e6884cd502fb123e0454b4f018e9c7a485f4aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.keras.losses.mean_squared_logarithmic_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.keras.losses.msle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.keras.metrics.MSLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.keras.metrics.mean_squared_logarithmic_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.keras.metrics.msle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.losses.MSLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.losses.mean_squared_logarithmic_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.losses.msle&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.metrics.MSLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.metrics.mean_squared_logarithmic_error&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;msle&quot;&gt;&lt;code&gt;tf.metrics.msle&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.keras.losses.mean_squared_logarithmic_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.keras.losses.msle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.keras.metrics.MSLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.keras.metrics.mean_squared_logarithmic_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.keras.metrics.msle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.losses.MSLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.losses.mean_squared_logarithmic_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.losses.msle&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.metrics.MSLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.metrics.mean_squared_logarithmic_error&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;msle&quot;&gt; &lt;code&gt;tf.metrics.msle&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f390596170508b21016b3a44396b1bee4907dcee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="209f4e29bf16e424ba14ee416a398ff45c96bb03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;nadam&quot;&gt;&lt;code&gt;tf.optimizers.Nadam&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;nadam&quot;&gt; &lt;code&gt;tf.optimizers.Nadam&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3966584937ffd1324aec66ee6aba4bc6c332567d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;nasnetlarge&quot;&gt;&lt;code&gt;tf.keras.applications.nasnet.NASNetLarge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;nasnetlarge&quot;&gt; &lt;code&gt;tf.keras.applications.nasnet.NASNetLarge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3564eb014de26f8c773c5c58eb0b29f1d1feeac9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;nasnetmobile&quot;&gt;&lt;code&gt;tf.keras.applications.nasnet.NASNetMobile&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;nasnetmobile&quot;&gt; &lt;code&gt;tf.keras.applications.nasnet.NASNetMobile&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9aecc4d3cb2ab7fa047c0b03ae25744d197363fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;negative&quot;&gt;&lt;code&gt;tf.negative&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;negative&quot;&gt; &lt;code&gt;tf.negative&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb297dd5af4ae451d46bc1e79d08c751efabbc53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;nonneg&quot;&gt;&lt;code&gt;tf.keras.constraints.non_neg&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;nonneg&quot;&gt; &lt;code&gt;tf.keras.constraints.non_neg&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c43c59375d9553aee261308085516e44c12d65ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;norm&quot;&gt;&lt;code&gt;tf.linalg.norm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;norm&quot;&gt; &lt;code&gt;tf.linalg.norm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cae5df55c9a879b047b299bbf270a30a49ac30d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;not_equal&quot;&gt;&lt;code&gt;tf.not_equal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;not_equal&quot;&gt; &lt;code&gt;tf.not_equal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a826259948759906f7f42fe53362f10ac025b2e8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;ones_initializer&quot;&gt;&lt;code&gt;tf.initializers.Ones&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ones_initializer&quot;&gt;&lt;code&gt;tf.initializers.ones&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ones_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.Ones&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ones_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.ones&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;ones_initializer&quot;&gt; &lt;code&gt;tf.initializers.Ones&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ones_initializer&quot;&gt; &lt;code&gt;tf.initializers.ones&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ones_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.Ones&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ones_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.ones&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="81746ab5a831e0987bef3a2a896515a3dfcb280c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;optimizer&quot;&gt;&lt;code&gt;tf.optimizers.Optimizer&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;optimizer&quot;&gt; &lt;code&gt;tf.optimizers.Optimizer&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e27a9a4dbbf17be533fce054671da1e2410205be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;optimizers&quot;&gt;&lt;code&gt;tf.optimizers&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;optimizers&quot;&gt; &lt;code&gt;tf.optimizers&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="77b99c1499ce10f9b1fb322d1f3348d998f6f6ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;orthogonal&quot;&gt;&lt;code&gt;tf.initializers.Orthogonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;orthogonal&quot;&gt;&lt;code&gt;tf.initializers.orthogonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;orthogonal&quot;&gt;&lt;code&gt;tf.keras.initializers.orthogonal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;orthogonal&quot;&gt; &lt;code&gt;tf.initializers.Orthogonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;orthogonal&quot;&gt; &lt;code&gt;tf.initializers.orthogonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;orthogonal&quot;&gt; &lt;code&gt;tf.keras.initializers.orthogonal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="129fc8dd03221c00b077d88f1c8682c2b4dbdc22" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;piecewiseconstantdecay&quot;&gt;&lt;code&gt;tf.optimizers.schedules.PiecewiseConstantDecay&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;piecewiseconstantdecay&quot;&gt; &lt;code&gt;tf.optimizers.schedules.PiecewiseConstantDecay&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fdb70d1e757221b0a65dba39c1ba37537f1b5a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;poisson&quot;&gt;&lt;code&gt;tf.losses.Poisson&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;poisson&quot;&gt; &lt;code&gt;tf.losses.Poisson&lt;/code&gt; &lt;/a&gt; . 포아송</target>
        </trans-unit>
        <trans-unit id="ef8ce9d334aa1c9e7a34a78773772398007ac352" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;poisson&quot;&gt;&lt;code&gt;tf.metrics.Poisson&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;poisson&quot;&gt; &lt;code&gt;tf.metrics.Poisson&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3fecab080688194c1bd49139b5a333754984f678" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;polynomialdecay&quot;&gt;&lt;code&gt;tf.optimizers.schedules.PolynomialDecay&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;polynomialdecay&quot;&gt; &lt;code&gt;tf.optimizers.schedules.PolynomialDecay&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b5b58c916f04bcd506d94466f9a028e16e5c0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;pow&quot;&gt;&lt;code&gt;tf.pow&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;pow&quot;&gt; &lt;code&gt;tf.pow&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5b72f63e5dbcf137243531acc18e1af727f4f218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;precision&quot;&gt;&lt;code&gt;tf.metrics.Precision&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;precision&quot;&gt; &lt;code&gt;tf.metrics.Precision&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bb42f9ae161d3f0d6bdc912beea6256b07cc70f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;precisionatrecall&quot;&gt;&lt;code&gt;tf.metrics.PrecisionAtRecall&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;precisionatrecall&quot;&gt; &lt;code&gt;tf.metrics.PrecisionAtRecall&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3be3e2b8eff39071c71bd22c7a3c056202c09fcf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;preprocess_input&quot;&gt;&lt;code&gt;tf.keras.applications.resnet50.preprocess_input&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;preprocess_input&quot;&gt; &lt;code&gt;tf.keras.applications.resnet50.preprocess_input&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acf6161f310d8b6d649ba88b07e72a4ef48d1b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;radialconstraint&quot;&gt;&lt;code&gt;tf.keras.constraints.radial_constraint&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;radialconstraint&quot;&gt; &lt;code&gt;tf.keras.constraints.radial_constraint&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c688596486de12b137a17435850e9e15cd8869b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;random_normal_initializer&quot;&gt;&lt;code&gt;tf.initializers.RandomNormal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;random_normal_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;random_normal_initializer&quot;&gt; &lt;code&gt;tf.initializers.RandomNormal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;random_normal_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.RandomNormal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="524c377438054bcee9f0c2e8ad833f6972a7859d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;random_uniform_initializer&quot;&gt;&lt;code&gt;tf.initializers.RandomUniform&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;random_uniform_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.RandomUniform&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;random_uniform_initializer&quot;&gt; &lt;code&gt;tf.initializers.RandomUniform&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;random_uniform_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.RandomUniform&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9563c3c65cb720b9d0bcb1356611a92b8ab06775" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;recall&quot;&gt;&lt;code&gt;tf.metrics.Recall&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;recall&quot;&gt; &lt;code&gt;tf.metrics.Recall&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9edc85f99ead6c3b81cd680ac86243a7579c3a58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_all&quot;&gt;&lt;code&gt;tf.math.reduce_all&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_all&quot;&gt; &lt;code&gt;tf.math.reduce_all&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b5da926c63edca99b676209d0f06d20db5843e15" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_any&quot;&gt;&lt;code&gt;tf.reduce_any&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_any&quot;&gt; &lt;code&gt;tf.reduce_any&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="054c0191bec2e18a4ee58e2acb4b2651e790a846" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_logsumexp&quot;&gt;&lt;code&gt;tf.reduce_logsumexp&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_logsumexp&quot;&gt; &lt;code&gt;tf.reduce_logsumexp&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fc2541d7051e40a0f0aeeb3f6841572ecc3691a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_max&quot;&gt;&lt;code&gt;tf.reduce_max&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_max&quot;&gt; &lt;code&gt;tf.reduce_max&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50c130acf3f7ceb09028aa4dd6f90206201ec7ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_mean&quot;&gt;&lt;code&gt;tf.reduce_mean&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_mean&quot;&gt; &lt;code&gt;tf.reduce_mean&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93d5cf38c44eadacd371c4f8f6925e6ad0ae9238" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_min&quot;&gt;&lt;code&gt;tf.reduce_min&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_min&quot;&gt; &lt;code&gt;tf.reduce_min&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="597e3279612fa9eab8694486e5fa734419859ad3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_prod&quot;&gt;&lt;code&gt;tf.reduce_prod&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_prod&quot;&gt; &lt;code&gt;tf.reduce_prod&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91cd187337b118fb6dc5028ffda359bd70f7e13e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduce_sum&quot;&gt;&lt;code&gt;tf.reduce_sum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduce_sum&quot;&gt; &lt;code&gt;tf.reduce_sum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b604b71c9b9b4253ae864b085d4fb6978682f51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;reduction&quot;&gt;&lt;code&gt;tf.losses.Reduction&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;reduction&quot;&gt; &lt;code&gt;tf.losses.Reduction&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68d74e8dd756793a8f48150b849a2d63bfad36b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet101&quot;&gt;&lt;code&gt;tf.keras.applications.resnet.ResNet101&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet101&quot;&gt; &lt;code&gt;tf.keras.applications.resnet.ResNet101&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb2f73ac92522e6a4b4d7da0c5b2a0ec97759f49" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet101v2&quot;&gt;&lt;code&gt;tf.keras.applications.resnet_v2.ResNet101V2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet101v2&quot;&gt; &lt;code&gt;tf.keras.applications.resnet_v2.ResNet101V2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2fb6aafd5a04c1579969302c49be417f0403b7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet152&quot;&gt;&lt;code&gt;tf.keras.applications.resnet.ResNet152&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet152&quot;&gt; &lt;code&gt;tf.keras.applications.resnet.ResNet152&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93b4534284bd51ff01987b34b113a276a16b6f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet152v2&quot;&gt;&lt;code&gt;tf.keras.applications.resnet_v2.ResNet152V2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet152v2&quot;&gt; &lt;code&gt;tf.keras.applications.resnet_v2.ResNet152V2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2fa4a43d174cd348674584e75d3a65808a228b38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet50&quot;&gt;&lt;code&gt;tf.keras.applications.resnet.ResNet50&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;resnet50&quot;&gt;&lt;code&gt;tf.keras.applications.resnet50.ResNet50&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet50&quot;&gt; &lt;code&gt;tf.keras.applications.resnet.ResNet50&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;resnet50&quot;&gt; &lt;code&gt;tf.keras.applications.resnet50.ResNet50&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f472feeec0f52b357053365bf2b2e645b5961d0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;resnet50v2&quot;&gt;&lt;code&gt;tf.keras.applications.resnet_v2.ResNet50V2&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;resnet50v2&quot;&gt; &lt;code&gt;tf.keras.applications.resnet_v2.ResNet50V2&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6a6ff31b1d7a598e1895c5fe986abd8129acc37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;rmsprop&quot;&gt;&lt;code&gt;tf.optimizers.RMSprop&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;rmsprop&quot;&gt; &lt;code&gt;tf.optimizers.RMSprop&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="05da0d5bb24f6e398ce88bf455ed73b1d57c0b62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;rootmeansquarederror&quot;&gt;&lt;code&gt;tf.metrics.RootMeanSquaredError&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;rootmeansquarederror&quot;&gt; &lt;code&gt;tf.metrics.RootMeanSquaredError&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a24dee4b01e6c3154038714415895a9a76ade6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;round&quot;&gt;&lt;code&gt;tf.round&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;round&quot;&gt; &lt;code&gt;tf.round&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1852a7d58df8a0657a4532c4da6663b0bb7c6376" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;saturate_cast&quot;&gt;&lt;code&gt;tf.saturate_cast&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;saturate_cast&quot;&gt; &lt;code&gt;tf.saturate_cast&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="33832845abd9c1aa3ba084f275aeac916323030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;scalar_mul&quot;&gt;&lt;code&gt;tf.scalar_mul&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;scalar_mul&quot;&gt; &lt;code&gt;tf.scalar_mul&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="31b731094fa729ed75eba55643bd6dee39f29814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;schedules&quot;&gt;&lt;code&gt;tf.optimizers.schedules&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;schedules&quot;&gt; &lt;code&gt;tf.optimizers.schedules&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8896ba42920458e91fb886df7b08237465f6dd56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sensitivityatspecificity&quot;&gt;&lt;code&gt;tf.metrics.SensitivityAtSpecificity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;sensitivityatspecificity&quot;&gt; &lt;code&gt;tf.metrics.SensitivityAtSpecificity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e4e5cdbc9767c1a233ddcbf2f55738c382ba48c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;separableconv1d&quot;&gt;&lt;code&gt;tf.keras.layers.SeparableConvolution1D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;separableconv1d&quot;&gt; &lt;code&gt;tf.keras.layers.SeparableConvolution1D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ded967fc259b3bddd9f7d0f547a126702d7161c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;separableconv2d&quot;&gt;&lt;code&gt;tf.keras.layers.SeparableConvolution2D&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;separableconv2d&quot;&gt; &lt;code&gt;tf.keras.layers.SeparableConvolution2D&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="999364b7b2121155a3ad51e7a41ee8270e40a4ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sequential&quot;&gt;&lt;code&gt;tf.keras.models.Sequential&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sequential&quot;&gt; &lt;code&gt;tf.keras.models.Sequential&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4691564d60b2a660bdb34907e536ed1e652d220" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.initializers.serialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.initializers.serialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb30f23df518a68a1835b50a80dda71d4f0e4d09" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.losses.serialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.losses.serialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a33d7ec2cee507963e803fbbed0391add337625e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.metrics.serialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.metrics.serialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="840513594fee9904737566107ec4e490f76b69aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.optimizers.schedules.serialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.optimizers.schedules.serialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f366d7dedaddea4ae78fdfe819272872b03892ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;serialize&quot;&gt;&lt;code&gt;tf.optimizers.serialize&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;serialize&quot;&gt; &lt;code&gt;tf.optimizers.serialize&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acc221b2f8ae3499b4c9cb8975b855c17229e526" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;set_logical_device_configuration&quot;&gt;&lt;code&gt;tf.config.experimental.set_virtual_device_configuration&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;set_logical_device_configuration&quot;&gt; &lt;code&gt;tf.config.experimental.set_virtual_device_configuration&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8b6e82e4bd21a4fac4f8420bcc949fcd62bc7341" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;set_visible_devices&quot;&gt;&lt;code&gt;tf.config.experimental.set_visible_devices&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;set_visible_devices&quot;&gt; &lt;code&gt;tf.config.experimental.set_visible_devices&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1dbdaa2567c283639506d74d8eea70eb08895743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sgd&quot;&gt;&lt;code&gt;tf.optimizers.SGD&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;sgd&quot;&gt; &lt;code&gt;tf.optimizers.SGD&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="daedafa50ecb5e9c46225059bb17e1b5aad4d7b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sigmoid&quot;&gt;&lt;code&gt;tf.nn.sigmoid&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sigmoid&quot;&gt;&lt;code&gt;tf.sigmoid&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sigmoid&quot;&gt; &lt;code&gt;tf.nn.sigmoid&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sigmoid&quot;&gt; &lt;code&gt;tf.sigmoid&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d2e21f1c3bb650eaf518021a2ce0d756aff7f31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sign&quot;&gt;&lt;code&gt;tf.sign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sign&quot;&gt; &lt;code&gt;tf.sign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dcf6cb8b89ea279f53d9f7b655b6dc51a9f880d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sin&quot;&gt;&lt;code&gt;tf.sin&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sin&quot;&gt; &lt;code&gt;tf.sin&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="303cb619ab44d8635d583c9a144193271b4b7b6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sinh&quot;&gt;&lt;code&gt;tf.sinh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sinh&quot;&gt; &lt;code&gt;tf.sinh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bffdd43570305ae9f061d19f51170a02a5d1f9c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;softmax&quot;&gt;&lt;code&gt;tf.math.softmax&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;softmax&quot;&gt; &lt;code&gt;tf.math.softmax&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec06935478d251ff7f9f38f37fa90dc050642afa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;softplus&quot;&gt;&lt;code&gt;tf.nn.softplus&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;softplus&quot;&gt; &lt;code&gt;tf.nn.softplus&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e82945676090aaba43f36148079e51016e2cbb8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;softsign&quot;&gt;&lt;code&gt;tf.math.softsign&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;softsign&quot;&gt; &lt;code&gt;tf.math.softsign&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f64dfb90481932f995abfbd3345315291ef2969c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;space_to_batch&quot;&gt;&lt;code&gt;tf.nn.space_to_batch&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;space_to_batch&quot;&gt; &lt;code&gt;tf.nn.space_to_batch&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e4adfcf21207fec3a01e2777bed803e932426a25" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparse_categorical_accuracy&quot;&gt;&lt;code&gt;tf.metrics.sparse_categorical_accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparse_categorical_accuracy&quot;&gt; &lt;code&gt;tf.metrics.sparse_categorical_accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9b3664ef3551f57a59f728de55ce1a012785b146" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt;&lt;code&gt;tf.keras.metrics.sparse_categorical_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt;&lt;code&gt;tf.losses.sparse_categorical_crossentropy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt;&lt;code&gt;tf.metrics.sparse_categorical_crossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt; &lt;code&gt;tf.keras.metrics.sparse_categorical_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt; &lt;code&gt;tf.losses.sparse_categorical_crossentropy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;sparse_categorical_crossentropy&quot;&gt; &lt;code&gt;tf.metrics.sparse_categorical_crossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="353c094f085ba85e976539c3f283de83180d7b7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparse_top_k_categorical_accuracy&quot;&gt;&lt;code&gt;tf.metrics.sparse_top_k_categorical_accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparse_top_k_categorical_accuracy&quot;&gt; &lt;code&gt;tf.metrics.sparse_top_k_categorical_accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c3af5617002ad378f8695e6ed6368e63b16baa2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparsecategoricalaccuracy&quot;&gt;&lt;code&gt;tf.metrics.SparseCategoricalAccuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparsecategoricalaccuracy&quot;&gt; &lt;code&gt;tf.metrics.SparseCategoricalAccuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7631916f181dbb677c7b6164cf22b9121bc8941a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparsecategoricalcrossentropy&quot;&gt;&lt;code&gt;tf.losses.SparseCategoricalCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparsecategoricalcrossentropy&quot;&gt; &lt;code&gt;tf.losses.SparseCategoricalCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28c1a040fb6c48a0e2cdd11503c03ea5eb023a68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparsecategoricalcrossentropy&quot;&gt;&lt;code&gt;tf.metrics.SparseCategoricalCrossentropy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparsecategoricalcrossentropy&quot;&gt; &lt;code&gt;tf.metrics.SparseCategoricalCrossentropy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af23d32f132f02c74aad84ecc4202982b3e75ae5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40cbec15bbd4ca2bf06bc612e46a38dda925c1ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sparsetopkcategoricalaccuracy&quot;&gt;&lt;code&gt;tf.metrics.SparseTopKCategoricalAccuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sparsetopkcategoricalaccuracy&quot;&gt; &lt;code&gt;tf.metrics.SparseTopKCategoricalAccuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cc788d5fbcf85ecc7553061251bdd3eabda016ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;specificityatsensitivity&quot;&gt;&lt;code&gt;tf.metrics.SpecificityAtSensitivity&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;specificityatsensitivity&quot;&gt; &lt;code&gt;tf.metrics.SpecificityAtSensitivity&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2196f2ee528e67a475982bfc1902eb89f59786e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sqrt&quot;&gt;&lt;code&gt;tf.sqrt&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sqrt&quot;&gt; &lt;code&gt;tf.sqrt&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68bf42b311ccfd3f3a687449caad7aa971a00a35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sqrtm&quot;&gt;&lt;code&gt;tf.matrix_square_root&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sqrtm&quot;&gt; &lt;code&gt;tf.matrix_square_root&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="50f0f5b14d5a5faa6fa47d6348b0db4f4c759388" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;square&quot;&gt;&lt;code&gt;tf.square&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;square&quot;&gt; &lt;code&gt;tf.square&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="85e930fa1033713e9e74bdac3e37bc12a71124ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;squared_hinge&quot;&gt;&lt;code&gt;tf.keras.metrics.squared_hinge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;squared_hinge&quot;&gt;&lt;code&gt;tf.losses.squared_hinge&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;squared_hinge&quot;&gt;&lt;code&gt;tf.metrics.squared_hinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;squared_hinge&quot;&gt; &lt;code&gt;tf.keras.metrics.squared_hinge&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;squared_hinge&quot;&gt; &lt;code&gt;tf.losses.squared_hinge&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;squared_hinge&quot;&gt; &lt;code&gt;tf.metrics.squared_hinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="93ba92deb0c94e5738c393d7e00e6a6496849408" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;squaredhinge&quot;&gt;&lt;code&gt;tf.losses.SquaredHinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;squaredhinge&quot;&gt; &lt;code&gt;tf.losses.SquaredHinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1258526a6525b726f9c78782f792d56dbf0e7410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;squaredhinge&quot;&gt;&lt;code&gt;tf.metrics.SquaredHinge&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;squaredhinge&quot;&gt; &lt;code&gt;tf.metrics.SquaredHinge&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9ebbe2316c085e7086fc37092c876840e2c6b0c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;subtract&quot;&gt;&lt;code&gt;tf.subtract&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;subtract&quot;&gt; &lt;code&gt;tf.subtract&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a9a610cc50b947f3d057efb31198f831a1dd97c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;sum&quot;&gt;&lt;code&gt;tf.metrics.Sum&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;sum&quot;&gt; &lt;code&gt;tf.metrics.Sum&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="29c8af5007d1845a199fd5ccf7afa063243d9e52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;tan&quot;&gt;&lt;code&gt;tf.tan&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;tan&quot;&gt; &lt;code&gt;tf.tan&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="91b544c7997db055d8adebd981e092a900be934c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;tanh&quot;&gt;&lt;code&gt;tf.nn.tanh&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;tanh&quot;&gt;&lt;code&gt;tf.tanh&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;tanh&quot;&gt; &lt;code&gt;tf.nn.tanh&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;tanh&quot;&gt; &lt;code&gt;tf.tanh&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1644d32dc624a8ca52372eddc940f40a66ab6b28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;tensordot&quot;&gt;&lt;code&gt;tf.linalg.tensordot&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;tensordot&quot;&gt; &lt;code&gt;tf.linalg.tensordot&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="204b7de118d421135b7ec0ab37ad63c51d4512f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;top_k&quot;&gt;&lt;code&gt;tf.nn.top_k&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;top_k&quot;&gt; &lt;code&gt;tf.nn.top_k&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7108ce22a34a52954ba54978efa13507d51051f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;top_k_categorical_accuracy&quot;&gt;&lt;code&gt;tf.metrics.top_k_categorical_accuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;top_k_categorical_accuracy&quot;&gt; &lt;code&gt;tf.metrics.top_k_categorical_accuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae0ba859ab6158579b0a5539b268db302481b6c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;topkcategoricalaccuracy&quot;&gt;&lt;code&gt;tf.metrics.TopKCategoricalAccuracy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;topkcategoricalaccuracy&quot;&gt; &lt;code&gt;tf.metrics.TopKCategoricalAccuracy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="974926081ed705a7331c9f0f33a25ea501c9d76a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;truediv&quot;&gt;&lt;code&gt;tf.truediv&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;truediv&quot;&gt; &lt;code&gt;tf.truediv&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4250171cca714a069e78139896d05c70529fa22c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;truenegatives&quot;&gt;&lt;code&gt;tf.metrics.TrueNegatives&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;truenegatives&quot;&gt; &lt;code&gt;tf.metrics.TrueNegatives&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c2af9acb473afe1ebc64abdb5ab4e7b358b37cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;truepositives&quot;&gt;&lt;code&gt;tf.metrics.TruePositives&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;truepositives&quot;&gt; &lt;code&gt;tf.metrics.TruePositives&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f4ab8b4c6cb45fe7ff16afa10c48b714a68d99ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;truncatednormal&quot;&gt;&lt;code&gt;tf.initializers.TruncatedNormal&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;truncatednormal&quot;&gt; &lt;code&gt;tf.initializers.TruncatedNormal&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f10e88b3f99a83c7d50f17994c75b874b8270e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;unitnorm&quot;&gt;&lt;code&gt;tf.keras.constraints.unit_norm&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;unitnorm&quot;&gt; &lt;code&gt;tf.keras.constraints.unit_norm&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06b6b732e2f5f850566a0797daf8e9fea199ad47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;variancescaling&quot;&gt;&lt;code&gt;tf.initializers.VarianceScaling&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별명&lt;/strong&gt; : &lt;a href=&quot;variancescaling&quot;&gt; &lt;code&gt;tf.initializers.VarianceScaling&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="20809c49ef11f5e85efa1103a8b1975c88aaef11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;vgg16&quot;&gt;&lt;code&gt;tf.keras.applications.vgg16.VGG16&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;vgg16&quot;&gt; &lt;code&gt;tf.keras.applications.vgg16.VGG16&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="926b6113392092fc555b081f2868bc6723217d5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;vgg19&quot;&gt;&lt;code&gt;tf.keras.applications.vgg19.VGG19&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;vgg19&quot;&gt; &lt;code&gt;tf.keras.applications.vgg19.VGG19&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9f3214da0b373de7069317147437a12d46091aca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;xception&quot;&gt;&lt;code&gt;tf.keras.applications.xception.Xception&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;xception&quot;&gt; &lt;code&gt;tf.keras.applications.xception.Xception&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c990bfc40f841f591ba2d290b1684820b1a6e0ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;zero_fraction&quot;&gt;&lt;code&gt;tf.nn.zero_fraction&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;zero_fraction&quot;&gt; &lt;code&gt;tf.nn.zero_fraction&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a1a713c9905c468bb105cb4104a42ef31ee5c01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Aliases&lt;/strong&gt;: &lt;a href=&quot;zeros_initializer&quot;&gt;&lt;code&gt;tf.initializers.Zeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zeros_initializer&quot;&gt;&lt;code&gt;tf.initializers.zeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zeros_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.Zeros&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;zeros_initializer&quot;&gt;&lt;code&gt;tf.keras.initializers.zeros&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;별칭&lt;/strong&gt; : &lt;a href=&quot;zeros_initializer&quot;&gt; &lt;code&gt;tf.initializers.Zeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zeros_initializer&quot;&gt; &lt;code&gt;tf.initializers.zeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zeros_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.Zeros&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;zeros_initializer&quot;&gt; &lt;code&gt;tf.keras.initializers.zeros&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7543001d2938598c3496713622485b953a64e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applying a dense layer to a sequence using ellipses&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;타원을 사용하여 시퀀스에 조밀 한 레이어 적용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="07fce5b4175f07dfa0f8ac32f1e3840275498e2f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Applying a dense layer to a sequence&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시퀀스에 조밀 한 레이어 적용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02698c38b0fe7b526f4791649bf3e665dd33e7b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Biased dense layer with einsums&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;아인 섬이있는 편향된 조밀 층&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f71eb406fe88b3487c4eed178d7483480ce971c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bin-counting every item in individual batches&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;개별 배치의 모든 항목을 빈 계산&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0d3938f709d023e0bf83106a81f3b56d6ca9633" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bin-counting on a certain axis&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;특정 축에 대한 빈 계산&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49150a8d40e7d4643efdcf75a496fc5cec19f17f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bin-counting with binary_output&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;binary_output을 사용한 빈 계산&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="43c7b28546fd7e44352c33783627578ee789de50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bin-counting with defined output shape&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정의 된 출력 형태로 빈 카운팅&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5028c11203ed8d7faf40801b59371359fc5d5782" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Binary bin-counting&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;바이너리 빈 카운팅&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="340d9de2d15cb8b2374e852ae53aa5ad12911ade" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; Be sure to properly pre-process your inputs to the application. Please see &lt;a href=&quot;inception_resnet_v2/preprocess_input&quot;&gt;&lt;code&gt;applications.inception_resnet_v2.preprocess_input&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 애플리케이션에 대한 입력을 적절히 사전 처리해야합니다. 예제는 &lt;a href=&quot;inception_resnet_v2/preprocess_input&quot;&gt; &lt;code&gt;applications.inception_resnet_v2.preprocess_input&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dff4926e7101730d3e0f9d77a6456884ea75eba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; Be sure to properly pre-process your inputs to the application. Please see &lt;a href=&quot;inception_v3/preprocess_input&quot;&gt;&lt;code&gt;applications.inception_v3.preprocess_input&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 애플리케이션에 대한 입력을 적절히 사전 처리해야합니다. 예제는 &lt;a href=&quot;inception_v3/preprocess_input&quot;&gt; &lt;code&gt;applications.inception_v3.preprocess_input&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9c6adc61abe53c3ad003124c7134548d9dcdb08b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; Be sure to properly pre-process your inputs to the application. Please see &lt;a href=&quot;mobilenet_v2/preprocess_input&quot;&gt;&lt;code&gt;applications.mobilenet_v2.preprocess_input&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 애플리케이션에 대한 입력을 적절히 사전 처리해야합니다. 예제는 &lt;a href=&quot;mobilenet_v2/preprocess_input&quot;&gt; &lt;code&gt;applications.mobilenet_v2.preprocess_input&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="621b536ae9e5d0d22ffa7b2ff332a138f74fb07a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; Be sure to properly pre-process your inputs to the application. Please see &lt;a href=&quot;resnet_v2/preprocess_input&quot;&gt;&lt;code&gt;applications.resnet_v2.preprocess_input&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 애플리케이션에 대한 입력을 적절히 사전 처리해야합니다. 예제는 &lt;a href=&quot;resnet_v2/preprocess_input&quot;&gt; &lt;code&gt;applications.resnet_v2.preprocess_input&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="72907b44813724f669dc2e106b4e2e9c2c4ae0bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; Passing python scalars or lists as arguments to &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; will always build a new graph. To avoid this, pass numeric arguments as Tensors whenever possible:</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 파이썬 스칼라 또는 목록을 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 에&lt;/a&gt; 인수로 전달 하면 항상 새로운 그래프가 작성됩니다. 이를 피하려면 가능한 경우 숫자 인수를 텐서로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="e68b51971b67058ef5470b35c37404d8b278be9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; if you don't use the result of &lt;a href=&quot;ensure_shape&quot;&gt;&lt;code&gt;tf.ensure_shape&lt;/code&gt;&lt;/a&gt; the check may not run.</source>
          <target state="translated">&lt;strong&gt;주의 : &lt;/strong&gt;&lt;a href=&quot;ensure_shape&quot;&gt; &lt;code&gt;tf.ensure_shape&lt;/code&gt; &lt;/a&gt; 의 결과를 사용하지 않으면 검사가 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dd54b8ad9a1cea44a10c4fce1e80bd311bf6f50" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt;&lt;code&gt;set_shape&lt;/code&gt; ensures that the applied shape is compatible with the existing shape, but it does not check at runtime. Setting incorrect shapes can result in inconsistencies between the statically-known graph and the runtime value of tensors. For runtime validation of the shape, use &lt;a href=&quot;ensure_shape&quot;&gt;&lt;code&gt;tf.ensure_shape&lt;/code&gt;&lt;/a&gt; instead. It also modifies the &lt;code&gt;shape&lt;/code&gt; of the tensor.</source>
          <target state="translated">&lt;strong&gt;주의 : &lt;/strong&gt; &lt;code&gt;set_shape&lt;/code&gt; 는 적용된 모양이 기존 모양과 호환되는지 확인하지만 런타임에는 확인하지 않습니다. 잘못된 모양을 설정하면 정적으로 알려진 그래프와 텐서의 런타임 값이 일치하지 않을 수 있습니다. 모양의 런타임 유효성 검사를 위해 대신 &lt;a href=&quot;ensure_shape&quot;&gt; &lt;code&gt;tf.ensure_shape&lt;/code&gt; 를&lt;/a&gt; 사용하십시오. 또한 텐서 의 &lt;code&gt;shape&lt;/code&gt; 을 수정합니다 .</target>
        </trans-unit>
        <trans-unit id="072896e14262fdc12fbd51b94955b1a491ffa6ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Component&lt;/strong&gt;: The leaf in the nested structure of an element.</source>
          <target state="translated">&lt;strong&gt;구성 요소&lt;/strong&gt; : &lt;strong&gt;요소&lt;/strong&gt; 의 중첩 구조에있는 리프입니다.</target>
        </trans-unit>
        <trans-unit id="3b6468ae3f5c5f3c79862d722100716fbe46525a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Element&lt;/strong&gt;: A single output from calling &lt;code&gt;next()&lt;/code&gt; on a dataset iterator. Elements may be nested structures containing multiple components. For example, the element &lt;code&gt;(1, (3, &quot;apple&quot;))&lt;/code&gt; has one tuple nested in another tuple. The components are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;&quot;apple&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;요소&lt;/strong&gt; : 데이터 세트 반복기에서 &lt;code&gt;next()&lt;/code&gt; 호출의 단일 출력입니다 . 요소는 여러 구성 요소를 포함하는 중첩 구조 일 수 있습니다. 예를 들어 &lt;code&gt;(1, (3, &quot;apple&quot;))&lt;/code&gt; 에는 다른 튜플에 중첩 된 하나의 튜플이 있습니다. 구성 요소는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 및 &lt;code&gt;&quot;apple&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fb2ac514ceb663db094a87e37fb3e64edb73813" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Element&lt;/strong&gt;: A single output from calling &lt;code&gt;next()&lt;/code&gt; on a dataset iterator. Elements may be nested structures containing multiple components. For example, the element &lt;code&gt;(1, (3, &quot;apple&quot;))&lt;/code&gt; has one tuple nested in another tuple. The components are &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt;, and &lt;code&gt;&quot;apple&quot;&lt;/code&gt;. &lt;strong&gt;Component&lt;/strong&gt;: The leaf in the nested structure of an element.</source>
          <target state="translated">&lt;strong&gt;요소&lt;/strong&gt; : 데이터 세트 반복자에서 &lt;code&gt;next()&lt;/code&gt; 호출의 단일 출력 . 요소는 여러 구성 요소를 포함하는 중첩 구조 일 수 있습니다. 예를 들어, 요소 &lt;code&gt;(1, (3, &quot;apple&quot;))&lt;/code&gt; 에는 다른 튜플에 중첩 된 하나의 튜플이 있습니다. 구성 요소는 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 및 &lt;code&gt;&quot;apple&quot;&lt;/code&gt; 입니다. &lt;strong&gt;구성 요소&lt;/strong&gt; : &lt;strong&gt;요소&lt;/strong&gt; 의 중첩 구조에있는 잎.</target>
        </trans-unit>
        <trans-unit id="eee5a199ee48a34a0cc9134ad8533202fc7fcb52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 1 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba5182d053766559c8a796587cc6e079b0edece9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4168878b06eaa6917a0f012585506612f5054ea6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Example:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4557d05685700e6c14c1f60bd54f168cb36af4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important:&lt;/strong&gt; Any Python side-effects (appending to a list, printing with &lt;code&gt;print&lt;/code&gt;, etc) will only happen once, when &lt;code&gt;func&lt;/code&gt; is traced. To have side-effects executed into your &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; they need to be written as TF ops:</source>
          <target state="translated">&lt;strong&gt;중요 :&lt;/strong&gt; 모든 Python 부작용 (목록에 추가, print로 &lt;code&gt;print&lt;/code&gt; 등)은 &lt;code&gt;func&lt;/code&gt; 가 추적 될 때 한 번만 발생 합니다. &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 에서&lt;/a&gt; 부작용을 실행하려면 TF ops로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7203c9abfc7485495e0c5e255df158725c988774" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: This ragged tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;../../../tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../../operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; :이 울퉁불퉁 한 텐서는 평가되면 오류를 생성합니다. &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;../../../tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; 값을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e80463fbe85926b290da0511e6cecfcb3d24d1a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: This sparse tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;../../tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; :이 희박한 텐서는 평가되면 오류를 생성합니다. &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;../../tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; 값을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f064b09999624b3b3170ff99173722aea4555c71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Important&lt;/strong&gt;: This tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;../../tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../../operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;중요&lt;/strong&gt; :이 텐서는 평가되면 오류를 생성합니다. &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;../../tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; 값을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ff286ee3e6f69560dd76cd3667b74fbdab41855f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Instead of calling this op directly most users will want to use the NumPy-style slicing syntax (e.g. &lt;code&gt;tensor[..., 3:4:-1, tf.newaxis, 3]&lt;/code&gt;), which is supported via &lt;a href=&quot;tensor#__getitem__&quot;&gt;&lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;variable#__getitem__&quot;&gt;&lt;code&gt;tf.Variable.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt;&lt;/a&gt;.&lt;/strong&gt; The interface of this op is a low-level encoding of the slicing syntax.</source>
          <target state="translated">&lt;strong&gt;이 op를 직접 호출하는 대신 대부분의 사용자는 &lt;code&gt;tensor[..., 3:4:-1, tf.newaxis, 3]&lt;/code&gt; 를 통해 지원되는 NumPy 스타일 슬라이싱 구문 (예 : tensor [..., 3 : 4 : -1, tf.newaxis, 3] )을 사용 &lt;a href=&quot;tensor#__getitem__&quot;&gt; &lt;code&gt;tf.Tensor.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;variable#__getitem__&quot;&gt; &lt;code&gt;tf.Variable.&lt;strong&gt;getitem&lt;/strong&gt;&lt;/code&gt; &lt;/a&gt; . &lt;/strong&gt;이 op의 인터페이스는 슬라이싱 구문의 저수준 인코딩입니다.</target>
        </trans-unit>
        <trans-unit id="b325173363db6a034007faa8ff7825641051b93e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Keras and Distribution Strategies&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Keras 및 배포 전략&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91c7262188154233201092f7b303a9099d83ffd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Any Python side-effects (appending to a list, printing with &lt;code&gt;print&lt;/code&gt;, etc) will only happen once, when &lt;code&gt;func&lt;/code&gt; is traced. To have side-effects executed into your &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; they need to be written as TF ops:</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 모든 Python 부작용 (목록에 추가, print으로 &lt;code&gt;print&lt;/code&gt; 등)은 &lt;code&gt;func&lt;/code&gt; 가 추적 될 때 한 번만 발생 합니다. &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 에&lt;/a&gt; 부작용을 실행하려면 TF ops로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="c7028655a0c9f625b3bd92014965267c6d27d041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 사용 중인 &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다 (각 복제본에 대해 한 번).</target>
        </trans-unit>
        <trans-unit id="a956f2f47c3048d51184eded238f28147d9d58cd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementation being used, and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times (once for each replica).</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 사용 중인 &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다 (각 복제본에 대해 한 번).</target>
        </trans-unit>
        <trans-unit id="e81871031112066d454d3e602038f4120264aadc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the implementation of &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times. If &lt;code&gt;fn&lt;/code&gt; is annotated with &lt;a href=&quot;../../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; is called inside a &lt;a href=&quot;../../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, eager execution is disabled and &lt;code&gt;fn&lt;/code&gt; is called once (or once per replica, if you are using MirroredStrategy) to generate a Tensorflow graph, which will then be reused for execution with new inputs. Otherwise, if eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; will be called every step just like regular python code.</source>
          <target state="translated">&lt;strong&gt;요점 : &lt;/strong&gt;&lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다. 경우 &lt;code&gt;fn&lt;/code&gt; 주석을 붙일 수 &lt;a href=&quot;../../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../distribute/strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 이&lt;/a&gt; 돌며라고 &lt;a href=&quot;../../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , 열망 실행이 비활성화되고 &lt;code&gt;fn&lt;/code&gt; Tensorflow 그래프를 생성하는 (당신이 MirroredStrategy를 사용하는 경우, 복제 당 또는 후) 일단라고 , 새로운 입력으로 실행을 위해 재사용됩니다. 그렇지 않으면 eager 실행이 활성화되면 &lt;code&gt;fn&lt;/code&gt; 은 일반 파이썬 코드처럼 모든 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="97e6d2bc55d2a6b1a35a405024831005bb382cfa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the implementation of &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times. If &lt;code&gt;fn&lt;/code&gt; is annotated with &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; is called inside a &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, eager execution is disabled and &lt;code&gt;fn&lt;/code&gt; is called once (or once per replica, if you are using MirroredStrategy) to generate a Tensorflow graph, which will then be reused for execution with new inputs. Otherwise, if eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; will be called every step just like regular python code.</source>
          <target state="translated">&lt;strong&gt;요점 : &lt;/strong&gt;&lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다. 경우 &lt;code&gt;fn&lt;/code&gt; 주석을 붙일 수 &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../distribute/strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 이&lt;/a&gt; 돌며라고 &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , 열망 실행이 비활성화되고 &lt;code&gt;fn&lt;/code&gt; Tensorflow 그래프를 생성하는 (당신이 MirroredStrategy를 사용하는 경우, 복제 당 또는 후) 일단라고 , 새로운 입력으로 실행을 위해 재사용됩니다. 그렇지 않으면 eager 실행이 활성화되면 &lt;code&gt;fn&lt;/code&gt; 은 일반 파이썬 코드처럼 모든 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e8c8fd77c81b3ac1a98cd8bfff97a8b2d9b7fc34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the implementation of &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times. If &lt;code&gt;fn&lt;/code&gt; is annotated with &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; is called inside a &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, eager execution is disabled and &lt;code&gt;fn&lt;/code&gt; is called once (or once per replica, if you are using MirroredStrategy) to generate a Tensorflow graph, which will then be reused for execution with new inputs. Otherwise, if eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; will be called every step just like regular python code.</source>
          <target state="translated">&lt;strong&gt;요점 : &lt;/strong&gt;&lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다. 경우 &lt;code&gt;fn&lt;/code&gt; 주석을 붙일 수 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 이&lt;/a&gt; 돌며라고 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , 열망 실행이 비활성화되고 &lt;code&gt;fn&lt;/code&gt; Tensorflow 그래프를 생성하는 (당신이 MirroredStrategy를 사용하는 경우, 복제 당 또는 후) 일단라고 , 새로운 입력으로 실행을 위해 재사용됩니다. 그렇지 않으면 eager 실행이 활성화되면 &lt;code&gt;fn&lt;/code&gt; 은 일반 파이썬 코드처럼 모든 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="083e421442868d5197eb67ba2c583ca6f000e302" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; Depending on the implementation of &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; and whether eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; may be called one or more times. If &lt;code&gt;fn&lt;/code&gt; is annotated with &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;strategy#run&quot;&gt;&lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt;&lt;/a&gt; is called inside a &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, eager execution is disabled and &lt;code&gt;fn&lt;/code&gt; is called once (or once per replica, if you are using MirroredStrategy) to generate a Tensorflow graph, which will then be reused for execution with new inputs. Otherwise, if eager execution is enabled, &lt;code&gt;fn&lt;/code&gt; will be called every step just like regular python code.</source>
          <target state="translated">&lt;strong&gt;요점 : &lt;/strong&gt;&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현 및 eager 실행 활성화 여부 에 따라 &lt;code&gt;fn&lt;/code&gt; 이 한 번 이상 호출 될 수 있습니다. 경우 &lt;code&gt;fn&lt;/code&gt; 주석을 붙일 수 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;strategy#run&quot;&gt; &lt;code&gt;tf.distribute.Strategy.run&lt;/code&gt; 이&lt;/a&gt; 돌며라고 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; , 열망 실행이 비활성화되고 &lt;code&gt;fn&lt;/code&gt; Tensorflow 그래프를 생성하는 (당신이 MirroredStrategy를 사용하는 경우, 복제 당 또는 후) 일단라고 , 새로운 입력으로 실행을 위해 재사용됩니다. 그렇지 않으면 eager 실행이 활성화되면 &lt;code&gt;fn&lt;/code&gt; 은 일반 파이썬 코드처럼 모든 단계에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="56426e2324d375e9e2e6f663367c6daf2da3004e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The &lt;a href=&quot;../../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;키 포인트 : &lt;/strong&gt;&lt;a href=&quot;../../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 은&lt;/a&gt; 에 의해 반환 &lt;code&gt;dataset_fn&lt;/code&gt; 당 복제 배치 크기 달리해야 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; 글로벌 배치 크기를 사용합니다. 이것은 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb5fd90f91c098708c04c00908dbbe4221d94e7a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The &lt;a href=&quot;../../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;키 포인트 : &lt;/strong&gt;&lt;a href=&quot;../../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 은&lt;/a&gt; 에 의해 반환 &lt;code&gt;dataset_fn&lt;/code&gt; 당 복제 배치 크기 달리해야 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; 글로벌 배치 크기를 사용합니다. 이것은 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c4be0a90affa16991a019aed328732cff9dc9b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The &lt;a href=&quot;../../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;키 포인트 : &lt;/strong&gt;&lt;a href=&quot;../../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 은&lt;/a&gt; 에 의해 반환 &lt;code&gt;dataset_fn&lt;/code&gt; 당 복제 배치 크기 달리해야 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; 글로벌 배치 크기를 사용합니다. 이것은 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2856af99217bb005f228a6a3c556c358e00c78c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; returned by &lt;code&gt;dataset_fn&lt;/code&gt; should have a per-replica batch size, unlike &lt;code&gt;experimental_distribute_dataset&lt;/code&gt;, which uses the global batch size. This may be computed using &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;키 포인트 : &lt;/strong&gt;&lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 은&lt;/a&gt; 에 의해 반환 &lt;code&gt;dataset_fn&lt;/code&gt; 당 복제 배치 크기 달리해야 &lt;code&gt;experimental_distribute_dataset&lt;/code&gt; 글로벌 배치 크기를 사용합니다. 이것은 &lt;code&gt;input_context.get_per_replica_batch_size&lt;/code&gt; 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6d3684a9ee2ed352cbf098032897c15d3a18b72e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; The ordering of communications must be identical in all replicas.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 통신 순서는 모든 복제본에서 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="42403cb63bc427663eb64a60076b9f0b32557183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; This ragged tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 이 비정형 텐서는 평가되면 오류를 생성합니다. 그 값은 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7d1d69d60e8c3dee60f3c715d25adcfb14e6a391" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; This sparse tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 이 희소 텐서는 평가되면 오류를 생성합니다. 그 값은 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5c53092416abe6314ad23332c797a30d96a42183" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key Point:&lt;/strong&gt; This tensor will produce an error if evaluated. Its value must be fed using the &lt;code&gt;feed_dict&lt;/code&gt; optional argument to &lt;code&gt;Session.run()&lt;/code&gt;, &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; 이 텐서는 평가되면 오류를 생성합니다. 그 값은 &lt;code&gt;Session.run()&lt;/code&gt; , &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/Operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;feed_dict&lt;/code&gt; 선택적 인수를 사용하여 제공되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9b2d0aa50dd3d2485808ecd8721e90afc70caeb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N.B.&lt;/strong&gt; The &lt;a href=&quot;py_func&quot;&gt;&lt;code&gt;tf.compat.v1.py_func()&lt;/code&gt;&lt;/a&gt; operation has the following known limitations:</source>
          <target state="translated">&lt;strong&gt;NB &lt;/strong&gt;&lt;a href=&quot;py_func&quot;&gt; &lt;code&gt;tf.compat.v1.py_func()&lt;/code&gt; &lt;/a&gt; 연산은 다음의 알려진 한계가있다 :</target>
        </trans-unit>
        <trans-unit id="205e4c8c61e5f938132df221414b8f22c18bc1a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;N.B.&lt;/strong&gt; The device scope may be overridden by op wrappers or other library code. For example, a variable assignment op &lt;code&gt;v.assign()&lt;/code&gt; must be colocated with the &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;&lt;code&gt;v&lt;/code&gt;, and incompatible device scopes will be ignored.</source>
          <target state="translated">&lt;strong&gt;NB&lt;/strong&gt; 장치 범위는 op 래퍼 또는 다른 라이브러리 코드로 재정의 될 수 있습니다. 예를 들어 변수 할당 op &lt;code&gt;v.assign()&lt;/code&gt; 은 &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; &lt;code&gt;v&lt;/code&gt; 와 함께 배치해야 하며 호환되지 않는 장치 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e3874800429f235d4fc4bc0c9f42a585c6c5a292" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE: This method is still in testing, and the API may change.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :이 방법은 아직 테스트 중이며 API가 변경 될 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e108131c675f80c4066f65f4de79711c16c695a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; For this operation, the probability of a given label is considered exclusive. That is, soft classes are not allowed, and the &lt;code&gt;labels&lt;/code&gt; vector must provide a single specific index for the true class for each row of &lt;code&gt;logits&lt;/code&gt; (each minibatch entry). For soft softmax classification with a probability distribution for each entry, see &lt;code&gt;softmax_cross_entropy_with_logits_v2&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 작업에서는 특정 레이블의 확률이 배타적 인 것으로 간주됩니다. 즉, 소프트 수업은 허용되지 않습니다되고, &lt;code&gt;labels&lt;/code&gt; 벡터의 각 행에 대해 진정한 클래스에 대해 하나의 특정 인덱스를 제공해야합니다 &lt;code&gt;logits&lt;/code&gt; (각 minibatch 항목). 각 항목에 대한 확률 분포를 갖는 soft softmax 분류는 &lt;code&gt;softmax_cross_entropy_with_logits_v2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dbcff6fc44b52db5d91d92be753cb86fee274e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; While the classes are mutually exclusive, their probabilities need not be. All that is required is that each row of &lt;code&gt;labels&lt;/code&gt; is a valid probability distribution. If they are not, the computation of the gradient will be incorrect.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 클래스는 상호 배타적이지만 확률은 아닙니다. &lt;code&gt;labels&lt;/code&gt; 각 행이 유효한 확률 분포이면됩니다. 그렇지 않으면 그래디언트 계산이 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de4c08d90e298e68e1e6cf2a6efaf976879ecc78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Floating point comparison to zero is done by exact floating point equality check. Small values are &lt;strong&gt;not&lt;/strong&gt; rounded to zero for purposes of the nonzero check.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 0에 대한 부동 소수점 비교는 정확한 부동 소수점 동등성 검사에 의해 수행됩니다. 0이 아닌 확인을 위해 작은 값은 0으로 반올림 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbd2253824af4eaf0cb14ae98b091252f1b7b54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Resampling is performed via rejection sampling; some fraction of the input values will be dropped.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 리샘플링은 거부 샘플링을 통해 수행됩니다. 입력 값의 일부가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6612c87c3eaf9f82d20ab32af14a83a02e246c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Strings are compared against zero-length empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;. Any string with a size greater than zero is already considered as nonzero.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; 문자열은 길이가 0 인 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 과 비교됩니다 . 크기가 0보다 큰 문자열은 이미 0이 아닌 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="0754c518656ae4fb005fabaa30c6a961555fdc77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; The output of this function should be used. If it is not, a warning will be logged or an error may be raised. To mark the output as used, call its .mark_used() method.</source>
          <target state="translated">&lt;strong&gt;참고이&lt;/strong&gt; 기능의 출력을 사용해야합니다. 그렇지 않으면 경고가 기록되거나 오류가 발생할 수 있습니다. 출력을 사용 된 것으로 표시하려면 .mark_used () 메소드를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d8f20cdcbd79ed6a85c156a83a7bd787f469edd1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE&lt;/strong&gt; Using a colocation scope resets any existing device constraints.</source>
          <target state="translated">&lt;strong&gt;주&lt;/strong&gt; 코 로케이션 범위를 사용하면 기존 장치 제약 조건이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="956782c52ea38c5ba42d8e9bea72e5f1fbadbb77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTES&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;NOTES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9919bde726d88c949e4eae01a21d2ecd86b4e97a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note that to avoid confusion, it is required to pass only named arguments to this function.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;혼동을 피하려면 이름 지정된 인수 만이 함수에 전달해야합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5e56caba055918fe26ffa2b102a8ebbec1070c8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; A gradient is not defined for this function, so it can't be used in training models that need gradient descent.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수에는 그라디언트가 정의되어 있지 않으므로 그라디언트 디센트가 필요한 학습 모델에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bafa51209f9bef7b32b4c09fa4dafbfdf0bd4c6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; All eager &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; values are immutable (in contrast to &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;). There is nothing especially &lt;em&gt;constant&lt;/em&gt; about the value returned from &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt;. This function it is not fundamentally different from &lt;a href=&quot;convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;. The name &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; comes from the symbolic APIs (like &lt;a href=&quot;data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; or keras functional models) where the &lt;code&gt;value&lt;/code&gt; is embeded in a &lt;code&gt;Const&lt;/code&gt; node in the &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;constant&quot;&gt;&lt;code&gt;tf.constant&lt;/code&gt;&lt;/a&gt; is useful for asserting that the value can be embedded that way.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 값은 변경할 수 없습니다 ( &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; 과 달리 ). &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 에서 반환 된 값에 대해서는 특별히 &lt;em&gt;상수&lt;/em&gt; 가 없습니다 . 이 함수는 기본적으로 &lt;a href=&quot;convert_to_tensor&quot;&gt; &lt;code&gt;tf.convert_to_tensor&lt;/code&gt; &lt;/a&gt; 와 다릅니다 . &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 라는 이름 은 &lt;code&gt;value&lt;/code&gt; 이 &lt;code&gt;Const&lt;/code&gt; 에 포함 된 기호 API ( &lt;a href=&quot;data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt; 또는 keras 기능 모델)에서 비롯 됩니다. 노드에&lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; &lt;/a&gt; 합니다. &lt;a href=&quot;constant&quot;&gt; &lt;code&gt;tf.constant&lt;/code&gt; &lt;/a&gt; 는 값이 그런 식으로 포함될 수 있다고 주장하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2d58944560f705066678a65784e2eef9f1cd79a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; All the losses are added to the &lt;code&gt;GraphKeys.LOSSES&lt;/code&gt; collection by default.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 손실은 기본적으로 &lt;code&gt;GraphKeys.LOSSES&lt;/code&gt; 컬렉션에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9f6e7aeb228bdbae17ed11952e121f8e4384a34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Although the transformation creates a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;, the transformation must be the final &lt;code&gt;Dataset&lt;/code&gt; in the input pipeline.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 변환이 &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; 을&lt;/a&gt; 생성하더라도 변환은 입력 파이프 라인 의 최종 &lt;code&gt;Dataset&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="99be2eb687ff2fd8282d4b283887c2562ff6d7d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Because internal calculations are done using &lt;code&gt;float64&lt;/code&gt; and casting has &lt;code&gt;floor&lt;/code&gt; semantics, we must manually map zero outcomes to the smallest possible positive floating-point value, i.e., &lt;code&gt;np.finfo(dtype).tiny&lt;/code&gt;. This means that &lt;code&gt;np.finfo(dtype).tiny&lt;/code&gt; occurs more frequently than it otherwise should. This bias can only happen for small values of &lt;code&gt;alpha&lt;/code&gt;, i.e., &lt;code&gt;alpha &amp;lt;&amp;lt; 1&lt;/code&gt; or large values of &lt;code&gt;beta&lt;/code&gt;, i.e., &lt;code&gt;beta &amp;gt;&amp;gt; 1&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;float64&lt;/code&gt; 를 사용하여 내부 계산을 수행 하고 캐스팅에 &lt;code&gt;floor&lt;/code&gt; 시맨틱이 있으므로 가능한 작은 양의 부동 소수점 값 (예 : &lt;code&gt;np.finfo(dtype).tiny&lt;/code&gt; 0 개의 결과를 수동으로 매핑해야합니다 . 이것은 &lt;code&gt;np.finfo(dtype).tiny&lt;/code&gt; 가 다른 것보다 자주 발생 한다는 것을 의미 합니다. 이 편향은 작은 &lt;code&gt;alpha&lt;/code&gt; 값 , 즉 &lt;code&gt;alpha &amp;lt;&amp;lt; 1&lt;/code&gt; 또는 큰 &lt;code&gt;beta&lt;/code&gt; 값 , 즉 &lt;code&gt;beta &amp;gt;&amp;gt; 1&lt;/code&gt; 대해서만 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4ead3dfcbe7bf8c2c5683857ed5df7bbba17aba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Before invoking &lt;a href=&quot;operation#run&quot;&gt;&lt;code&gt;Operation.run()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;operation#run&quot;&gt; &lt;code&gt;Operation.run()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되어야하며 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c5c9aaccf8ab2063a50940e2fca38d4662907d4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Before invoking &lt;a href=&quot;sparsetensor#eval&quot;&gt;&lt;code&gt;SparseTensor.eval()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;sparsetensor#eval&quot;&gt; &lt;code&gt;SparseTensor.eval()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되어야하며 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c82603605d2665f91835c8e26eb2977acca03e6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Before invoking &lt;a href=&quot;tensor#eval&quot;&gt;&lt;code&gt;Tensor.eval()&lt;/code&gt;&lt;/a&gt;, its graph must have been launched in a session, and either a default session must be available, or &lt;code&gt;session&lt;/code&gt; must be specified explicitly.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;tensor#eval&quot;&gt; &lt;code&gt;Tensor.eval()&lt;/code&gt; &lt;/a&gt; 호출하기 전에 그래프가 세션에서 시작되어야하며 기본 세션을 사용할 수 있거나 &lt;code&gt;session&lt;/code&gt; 명시 적으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1d7c01ef221b91d46ea19366b09377e1d55998f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Bitcast is implemented as a low-level cast, so machines with different endian orderings will give different results.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 비트 캐스트는 저수준 캐스트로 구현되므로 엔디안 순서가 다른 시스템은 다른 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e9171509f45c6e92fd3666fa5c37943ad880856c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; By default this optimizer is lazy, i.e. it will not apply the gradient update of zero to rows that were not looked up. You can change this behavior by setting &lt;code&gt;lazy_adam&lt;/code&gt; to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 기본적으로이 옵티마이 저는 지연됩니다. 즉, 조회되지 않은 행에 0의 그래디언트 업데이트를 적용하지 않습니다. &lt;code&gt;lazy_adam&lt;/code&gt; 을 &lt;code&gt;False&lt;/code&gt; 로 설정 하여이 동작을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7bedacc8dd7449c4b91f8d69f2297a94c8c8c2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; By default this uses a log-uniform (Zipfian) distribution for sampling, so your labels must be sorted in order of decreasing frequency to achieve good results. For more details, see &lt;a href=&quot;../../../random/log_uniform_candidate_sampler&quot;&gt;&lt;code&gt;tf.random.log_uniform_candidate_sampler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 기본적으로 샘플링에는 로그 균일 (Zipfian) 분포가 사용되므로 좋은 결과를 얻으려면 빈도를 낮추기 위해 레이블을 정렬해야합니다. 자세한 내용은 &lt;a href=&quot;../../../random/log_uniform_candidate_sampler&quot;&gt; &lt;code&gt;tf.random.log_uniform_candidate_sampler&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77ec054d2de263954ece86806dace019ae704776" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; By default this uses a log-uniform (Zipfian) distribution for sampling, so your labels must be sorted in order of decreasing frequency to achieve good results. For more details, see &lt;a href=&quot;../random/log_uniform_candidate_sampler&quot;&gt;&lt;code&gt;tf.random.log_uniform_candidate_sampler&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 기본적으로 샘플링에는 로그 균일 (Zipfian) 분포가 사용되므로 좋은 결과를 얻으려면 빈도를 낮추기 위해 레이블을 정렬해야합니다. 자세한 내용은 &lt;a href=&quot;../random/log_uniform_candidate_sampler&quot;&gt; &lt;code&gt;tf.random.log_uniform_candidate_sampler&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7e4d5b2576b7bf5ea094b68970d06ecb4defec41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Calling &lt;code&gt;add_metric()&lt;/code&gt; with the result of a metric object on a Functional Model, as shown in the example below, is not supported. This is because we cannot trace the metric result tensor back to the model's inputs.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 아래 예제와 같이 기능 모델에서 메트릭 개체의 결과로 &lt;code&gt;add_metric()&lt;/code&gt; 을 호출 하는 것은 지원되지 않습니다. 이는 메트릭 결과 텐서를 모델의 입력으로 다시 추적 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="8ef548c5804796fb1e34bb5917636bcd55023a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Currently, the innermost dimension of the tensor must be divisible by 8.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 텐서의 가장 안쪽 차원은 8로 나눌 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f40735ffbccbbb77abe28a5b9af0442b520e58f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Currently, the user cannot add any more transformations to a distributed dataset.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 사용자는 분산 데이터 세트에 더 이상 변환을 추가 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="a526188ea50a489bcd9e2df436fd356b3365a95a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Elementwise binary operations in TensorFlow follow &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;numpy-style broadcasting&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; TensorFlow의 요소 별 이진 연산은 &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;numpy 스타일 브로드 캐스팅을&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b061b1787f3b2bb1cc25e10e2fc62196d26c120" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Entering a &lt;code&gt;with sess.as_default():&lt;/code&gt; block does not affect the current default graph. If you are using multiple graphs, and &lt;code&gt;sess.graph&lt;/code&gt; is different from the value of &lt;a href=&quot;get_default_graph&quot;&gt;&lt;code&gt;tf.compat.v1.get_default_graph&lt;/code&gt;&lt;/a&gt;, you must explicitly enter a &lt;code&gt;with sess.graph.as_default():&lt;/code&gt; block to make &lt;code&gt;sess.graph&lt;/code&gt; the default graph.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;with sess.as_default():&lt;/code&gt; 블록 과 함께 a 를 입력 하면 현재 기본 그래프에 영향을주지 않습니다. 여러 그래프를 사용하고있는 경우 &lt;code&gt;sess.graph&lt;/code&gt; 가 의 값과 다른 &lt;a href=&quot;get_default_graph&quot;&gt; &lt;code&gt;tf.compat.v1.get_default_graph&lt;/code&gt; &lt;/a&gt; , 당신은 명시 적으로 입력해야합니다 &lt;code&gt;with sess.graph.as_default():&lt;/code&gt; 만들기 위해 블록 &lt;code&gt;sess.graph&lt;/code&gt; 기본 그래프.</target>
        </trans-unit>
        <trans-unit id="188768bdacaebf188783f8f6e1720caf7f9dcc0d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Entering a scope does not automatically distribute a computation, except in the case of high level training framework like keras &lt;code&gt;model.fit&lt;/code&gt;. If you're not using &lt;code&gt;model.fit&lt;/code&gt;, you need to use &lt;code&gt;strategy.run&lt;/code&gt; API to explicitly distribute that computation. See an example in the &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/custom_training&quot;&gt;custom training loop tutorial&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; keras &lt;code&gt;model.fit&lt;/code&gt; 과 같은 높은 수준의 학습 프레임 워크의 경우를 제외하고 범위를 입력해도 계산이 자동으로 분산되지 않습니다 . &lt;code&gt;model.fit&lt;/code&gt; 을 사용하지 않는 경우 해당 계산을 명시 적으로 배포 하기 위해 &lt;code&gt;strategy.run&lt;/code&gt; API를 사용해야 합니다. &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/custom_training&quot;&gt;사용자 지정 학습 루프 자습서&lt;/a&gt; 의 예를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="313561e529e79e1abeed6b5f6d85e731db7f1cce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Estimator.predict returns a Python generator. Please consume all the data from the generator so that TPUEstimator can shutdown the TPU system properly for user.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Estimator.predict는 Python 생성기를 반환합니다. TPUEstimator가 사용자를 위해 TPU 시스템을 올바르게 종료 할 수 있도록 생성기의 모든 데이터를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31e106976baa5dfb409ec92f1b3391ca1094e313" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Floating point comparison to zero is done by exact floating point equality check. Small values are &lt;strong&gt;not&lt;/strong&gt; rounded to zero for purposes of the nonzero check.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 0에 대한 부동 소수점 비교는 정확한 부동 소수점 동등성 검사를 통해 수행됩니다. 0이 아닌 검사를 위해 작은 값은 0으로 반올림 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a47bc7ca60e39c78ed3180a718d2ca90ccb5d3c4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For backwards compatibility, this method returns a list. If the given job was defined with a sparse set of task indices, the length of this list may not reflect the number of tasks defined in this job. Use the &lt;a href=&quot;clusterspec#num_tasks&quot;&gt;&lt;code&gt;tf.train.ClusterSpec.num_tasks&lt;/code&gt;&lt;/a&gt; method to find the number of tasks defined in a particular job.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이전 버전과의 호환성을 위해이 메서드는 목록을 반환합니다. 주어진 작업이 희소 작업 색인 집합으로 정의 된 경우이 목록의 길이는이 작업에 정의 된 작업 수를 반영하지 않을 수 있습니다. &lt;a href=&quot;clusterspec#num_tasks&quot;&gt; &lt;code&gt;tf.train.ClusterSpec.num_tasks&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 특정 작업에 정의 된 작업 수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="55d1f3d9e4071bea5d1fc36dc56632c9e4a4c359" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For most usage of &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, there should be no need to call these methods, since TensorFlow libraries (such as optimizers) already call these methods when needed on your behalf.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 대부분의 사용&lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;경우 TensorFlow 라이브러리 (예 : 옵티 마이저)가 사용자 대신 필요할 때 이미이 메소드를 호출 하므로이 메소드를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="28e1a29b71fbda06397b61ef051e5ed475564914" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For most usage of &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt;, there should be no need to call these methods, since TensorFlow libraries (such as optimizers) already call these methods when needed on your behalf.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 대부분의 사용&lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt;경우 TensorFlow 라이브러리 (예 : 옵티 마이저)가 사용자 대신 필요할 때 이미이 메소드를 호출 하므로이 메소드를 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="02c904863a707f3c9d541533edbc9037481e1597" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For new &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementations, please put all logic in a subclass of &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt;&lt;/a&gt;. The only code needed for the &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; subclass is for instantiating your subclass of &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;__init__&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 새로운 &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현의 경우 모든 논리를 &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt; &lt;/a&gt; 의 서브 클래스에 넣으십시오 . &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 서브 클래스에 필요한 유일한 코드는 tf.distribute.StrategyExtended의 서브 클래스를 인스턴스화하는 것입니다 &lt;a href=&quot;../../../distribute/strategyextended&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;__init__&lt;/code&gt; 메소드 에서 입니다.</target>
        </trans-unit>
        <trans-unit id="07096365fba1529389d4324d5f860cb3abc67f94" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For new &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementations, please put all logic in a subclass of &lt;a href=&quot;strategyextended&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt;&lt;/a&gt;. The only code needed for the &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; subclass is for instantiating your subclass of &lt;a href=&quot;strategyextended&quot;&gt;&lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;__init__&lt;/code&gt; method.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 새로운 &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현의 경우 모든 논리를 &lt;a href=&quot;strategyextended&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt; &lt;/a&gt; 의 서브 클래스에 넣으십시오 . &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 서브 클래스에 필요한 유일한 코드는 tf.distribute.StrategyExtended의 서브 클래스를 인스턴스화하는 것입니다 &lt;a href=&quot;strategyextended&quot;&gt; &lt;code&gt;tf.distribute.StrategyExtended&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;__init__&lt;/code&gt; 메소드 에서 입니다.</target>
        </trans-unit>
        <trans-unit id="8fc90997dd872e575f2b70db30c92b7851dda51d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For the cache to be finalized, the input dataset must be iterated through in its entirety. Otherwise, subsequent iterations will not use cached data.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 캐시를 마무리하려면 입력 데이터 세트를 완전히 반복해야합니다. 그렇지 않으면 후속 반복에서 캐시 된 데이터를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6ea646830f635135571b09169dfa1da418c8fecb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For this operation, the probability of a given label is considered exclusive. That is, soft classes are not allowed, and the &lt;code&gt;labels&lt;/code&gt; vector must provide a single specific index for the true class for each row of &lt;code&gt;logits&lt;/code&gt; (each minibatch entry). For soft softmax classification with a probability distribution for each entry, see &lt;code&gt;softmax_cross_entropy_with_logits_v2&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 작업에서는 지정된 레이블의 확률이 배타적 인 것으로 간주됩니다. 즉, 소프트 수업은 허용되지 않습니다되고, &lt;code&gt;labels&lt;/code&gt; 벡터의 각 행에 대해 진정한 클래스에 대해 하나의 특정 인덱스를 제공해야합니다 &lt;code&gt;logits&lt;/code&gt; (각 minibatch 항목). 각 항목에 대한 확률 분포가있는 소프트 소프트 맥스 분류는 &lt;code&gt;softmax_cross_entropy_with_logits_v2&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e899c3a9a5658deb6008340ee07285f146c2b0d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Functions taking &lt;code&gt;Tensor&lt;/code&gt; arguments can also take anything accepted by &lt;a href=&quot;../../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;Tensor&lt;/code&gt; 인수를 사용하는 함수 는 &lt;a href=&quot;../../convert_to_tensor&quot;&gt; &lt;code&gt;tf.convert_to_tensor&lt;/code&gt; 에서&lt;/a&gt; 허용하는 모든 항목을 취할 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="a68a31880c2296781f85054c12313db4a2cfcfab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Functions taking &lt;code&gt;Tensor&lt;/code&gt; arguments can also take anything accepted by &lt;a href=&quot;convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;Tensor&lt;/code&gt; 인수를 사용하는 함수 는 &lt;a href=&quot;convert_to_tensor&quot;&gt; &lt;code&gt;tf.convert_to_tensor&lt;/code&gt; 에서&lt;/a&gt; 허용하는 모든 항목을 취할 수도 있습니다. .</target>
        </trans-unit>
        <trans-unit id="895f4381234654ad2ac6ce750be62a4ec4cb453a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, you must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;dynamic_pad&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 당신도 (내가)이 있는지 확인해야합니다 &lt;code&gt;shapes&lt;/code&gt; 인수를 전달하거나, (ⅱ)에서 텐서의 모든 &lt;code&gt;tensors&lt;/code&gt; 완벽하게 정의 된 모양이 있어야합니다. 이러한 조건이 모두 충족되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2e3b0dc94c99def3b70e0fd00c5347adacbcaba4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If &lt;code&gt;dynamic_pad&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, you must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors_list&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;dynamic_pad&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; , 당신도 (내가)이 있는지 확인해야합니다 &lt;code&gt;shapes&lt;/code&gt; 인수를 전달하거나, (ⅱ)에서 텐서의 모든 &lt;code&gt;tensors_list&lt;/code&gt; 이 완벽하게 정의 된 모양이 있어야합니다. 이러한 조건이 모두 충족되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="99ef694944cfc1a2d8bc4ca82d4d24f612f38cde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소. 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e69df00670bc5bf917aceee5e9af06d79a07bdfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소. 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d7452e9b27f15e039faa953ff186491c5f538162" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If &lt;code&gt;generator&lt;/code&gt; depends on mutable global variables or other external state, be aware that the runtime may invoke &lt;code&gt;generator&lt;/code&gt; multiple times (in order to support repeating the &lt;code&gt;Dataset&lt;/code&gt;) and at any time between the call to &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; and the production of the first element from the generator. Mutating global variables or external state can cause undefined behavior, and we recommend that you explicitly cache any external state in &lt;code&gt;generator&lt;/code&gt; before calling &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;generator&lt;/code&gt; 가변 전역 변수 나 기타 외부 상태에 따라, 런타임이 호출 할 수 있음을 인식 &lt;code&gt;generator&lt;/code&gt; (반복 지원하기 위해 여러 번 &lt;code&gt;Dataset&lt;/code&gt; )과 호출 사이에 언제든지 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 및 생산 생성기의 첫 번째 요소. 전역 변수 또는 외부 상태를 변경하면 정의되지 않은 동작이 발생할 수 있으므로 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;code&gt;generator&lt;/code&gt; 에서 외부 상태를 명시 적으로 캐시하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="6d0cbba451c9b4b575670d40ea7e0c840acb93b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If a function has been decorated with &lt;a href=&quot;../../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, pass its underlying Python function, rather than the callable that `tf.function creates:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 함수가 &lt;a href=&quot;../../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 으로 장식 된 경우 `tf.function이 생성하는 호출 가능 함수 대신 기본 Python 함수를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="b5c374975918994b914b3f102f9ae3ecc041e4e2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If a function has been decorated with &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;, pass its underlying Python function, rather than the callable that `tf.function creates:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 함수가 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 으로 장식 된 경우 `tf.function이 생성하는 호출 가능 함수 대신 기본 Python 함수를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="45fefb043b607684e7d120e967d57a823678666e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If a non-numeric data type output is desired (&lt;a href=&quot;../tf#string&quot;&gt;&lt;code&gt;tf.string&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../tf#bool&quot;&gt;&lt;code&gt;tf.bool&lt;/code&gt;&lt;/a&gt;, etc.), both &lt;code&gt;on_value&lt;/code&gt; and &lt;code&gt;off_value&lt;/code&gt;&lt;em&gt;must&lt;/em&gt; be provided to &lt;code&gt;one_hot&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 숫자가 아닌 데이터 유형 출력 ( &lt;a href=&quot;../tf#string&quot;&gt; &lt;code&gt;tf.string&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../tf#bool&quot;&gt; &lt;code&gt;tf.bool&lt;/code&gt; &lt;/a&gt; 등)을 원하는 경우 &lt;code&gt;on_value&lt;/code&gt; 및 &lt;code&gt;off_value&lt;/code&gt; 를 &lt;code&gt;one_hot&lt;/code&gt; 에 제공 &lt;em&gt;해야합니다&lt;/em&gt; . .</target>
        </trans-unit>
        <trans-unit id="21b91d30befdefec6c985beecda2442f6e95a555" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If an exception is being passed in, in must be in the context of handling the exception (i.e. &lt;code&gt;try: ... except Exception as ex: ...&lt;/code&gt;) and not a newly created one.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 예외가 전달되는 경우 예외를 처리 할 수있는 컨텍스트에 있어야합니다 (예 &lt;code&gt;try: ... except Exception as ex: ...&lt;/code&gt; 새로 작성된 아닌 ).</target>
        </trans-unit>
        <trans-unit id="1c3a94436b5df8ea745267afd586f097c965daeb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If either &lt;code&gt;self&lt;/code&gt; or &lt;code&gt;other&lt;/code&gt; is completely unknown, concatenation will discard information about the other shape. In future, we might support concatenation that preserves this information for use with slicing.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 두 경우 &lt;code&gt;self&lt;/code&gt; 또는 &lt;code&gt;other&lt;/code&gt; 완전히 알 수없는, 연결이 다른 형태에 대한 정보를 폐기합니다. 향후에는 슬라이싱에 사용하기 위해이 정보를 보존하는 연결을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba2cb6ae41b6c0b4dd0c62edc94ab60d10f678ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If inputs are shaped &lt;code&gt;(batch,)&lt;/code&gt; without a feature axis, then flattening adds an extra channel dimension and output shape is &lt;code&gt;(batch, 1)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 입력이 피쳐 축없이 쉐이핑 &lt;code&gt;(batch,)&lt;/code&gt; 경우 플랫 화는 추가 채널 치수를 추가하고 출력 쉐이프는 &lt;code&gt;(batch, 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="af43f64b76fc402943d3a50a6bbf72c2c26ab97c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If not all checkpoints exist, the length of the returned mtimes list will be smaller than the length of &lt;code&gt;checkpoint_prefixes&lt;/code&gt; list, so mapping checkpoints to corresponding mtimes will not be possible.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 검사 점이 존재하지 않으면 반환 된 mtimes 목록의 길이는 &lt;code&gt;checkpoint_prefixes&lt;/code&gt; 목록 검사 점을 해당 mtime에 매핑 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="df111cb84cdb3ddebd13178dfad14ce3db312b59" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the failed op was synthesized at runtime, e.g. a &lt;code&gt;Send&lt;/code&gt; or &lt;code&gt;Recv&lt;/code&gt; op, there will be no corresponding &lt;a href=&quot;../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; object. In that case, this will return &lt;code&gt;None&lt;/code&gt;, and you should instead use the &lt;a href=&quot;operror#node_def&quot;&gt;&lt;code&gt;tf.errors.OpError.node_def&lt;/code&gt;&lt;/a&gt; to discover information about the op.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 실패한 작업이 런타임에 합성 된 경우 (예 : &lt;code&gt;Send&lt;/code&gt; 또는 &lt;code&gt;Recv&lt;/code&gt; 작업) 해당 &lt;a href=&quot;../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; 객체 가 없습니다 . 이 경우 &lt;code&gt;None&lt;/code&gt; 을 반환 하고 대신 &lt;a href=&quot;operror#node_def&quot;&gt; &lt;code&gt;tf.errors.OpError.node_def&lt;/code&gt; &lt;/a&gt; 를 사용하여 작업 에 대한 정보를 검색 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4532c5bdff7d69b85c054607165e851c68a1e4b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the input to the layer has a rank greater than 2, then &lt;code&gt;Dense&lt;/code&gt; computes the dot product between the &lt;code&gt;inputs&lt;/code&gt; and the &lt;code&gt;kernel&lt;/code&gt; along the last axis of the &lt;code&gt;inputs&lt;/code&gt; and axis 1 of the &lt;code&gt;kernel&lt;/code&gt; (using &lt;a href=&quot;../../tensordot&quot;&gt;&lt;code&gt;tf.tensordot&lt;/code&gt;&lt;/a&gt;). For example, if input has dimensions &lt;code&gt;(batch_size, d0, d1)&lt;/code&gt;, then we create a &lt;code&gt;kernel&lt;/code&gt; with shape &lt;code&gt;(d1, units)&lt;/code&gt;, and the &lt;code&gt;kernel&lt;/code&gt; operates along axis 2 of the &lt;code&gt;input&lt;/code&gt;, on every sub-tensor of shape &lt;code&gt;(1, 1, d1)&lt;/code&gt; (there are &lt;code&gt;batch_size * d0&lt;/code&gt; such sub-tensors). The output in this case will have shape &lt;code&gt;(batch_size, d0, units)&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 레이어에 입력이 2보다 랭크 이상을 갖는 경우, &lt;code&gt;Dense&lt;/code&gt; 사이의 내적을 계산하는 &lt;code&gt;inputs&lt;/code&gt; 및 &lt;code&gt;kernel&lt;/code&gt; 의 마지막 축을 따라 &lt;code&gt;inputs&lt;/code&gt; 및 1 축 &lt;code&gt;kernel&lt;/code&gt; (사용 &lt;a href=&quot;../../tensordot&quot;&gt; &lt;code&gt;tf.tensordot&lt;/code&gt; 을&lt;/a&gt; ). 입력 기준이있는 경우 예를 들어, &lt;code&gt;(batch_size, d0, d1)&lt;/code&gt; , 우리는 크리에이트 &lt;code&gt;kernel&lt;/code&gt; 형상 &lt;code&gt;(d1, units)&lt;/code&gt; 및 &lt;code&gt;kernel&lt;/code&gt; 의 축 (2)에 따라 동작 &lt;code&gt;input&lt;/code&gt; 형상의 각 서브 텐서에, &lt;code&gt;(1, 1, d1)&lt;/code&gt; ( &lt;code&gt;batch_size * d0&lt;/code&gt; 이러한 하위 텐서가 있습니다). 이 경우 출력은 모양을 갖습니다. &lt;code&gt;(batch_size, d0, units)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c69b1dda1e3184bbf8ab003e5e663e0c54bfe7f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the input to the layer has a rank greater than 2, then it is flattened prior to the initial dot product with &lt;code&gt;kernel&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 레이어에 대한 입력의 순위가 2보다 큰 경우 &lt;code&gt;kernel&lt;/code&gt; 있는 초기 내적 제품보다 먼저 평탄화됩니다. 됩니다.</target>
        </trans-unit>
        <trans-unit id="9f53e48abe3279f4ed3b6800358bb6216e070933" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If the input_min, input_max are specified, they do not need to equal the actual minimum and maximum values in the tensor. e.g. in some cases it may be beneficial to specify these values such that the low probability extremes of the input distribution are clipped.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; input_min, input_max가 지정되면 텐서의 실제 최소값 및 최대 값과 같을 필요가 없습니다. 예를 들어 어떤 경우에는 입력 분포의 낮은 확률 극단이 잘 리도록 이러한 값을 지정하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8791f8c55ec21ee128813be78f7d7e38cfc71037" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If there are multiple ClusterResolvers exposing ClusterSpecs with the same job name, we will merge the list/dict of workers.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 동일한 작업 이름으로 ClusterSpec을 노출하는 여러 ClusterResolvers가있는 경우 작업자 목록 / dict를 병합합니다.</target>
        </trans-unit>
        <trans-unit id="2b48fb0b25f67e35cc47d25a7a4e1e64735c568c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If this dataset is a function of global state (e.g. a random number generator), then different repetitions may produce different elements.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 데이터 세트가 전역 상태의 함수 인 경우 (예 : 난수 생성기), 다른 반복은 다른 요소를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c22cfd6b6abfca515dc0fbcaa3806d527eab64ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you are concatenating along a new axis consider using stack. E.g.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 새 축을 따라 연결하는 경우 스택 사용을 고려하십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="cbf074a72491b6aacdd934de1433cbbe0bac32c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If you are not using &lt;a href=&quot;compat/v1&quot;&gt;&lt;code&gt;compat.v1&lt;/code&gt;&lt;/a&gt; libraries, you should not need this, (or &lt;code&gt;feed_dict&lt;/code&gt; or &lt;code&gt;Session&lt;/code&gt;). In eager execution (or within &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;) you do not need to call &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;compat/v1&quot;&gt; &lt;code&gt;compat.v1&lt;/code&gt; &lt;/a&gt; 라이브러리를 사용하지 않는 경우이 라이브러리 (또는 &lt;code&gt;feed_dict&lt;/code&gt; 또는 &lt;code&gt;Session&lt;/code&gt; ) 가 필요하지 않습니다 . eager 실행 (또는 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 내에서 ) 에서는 &lt;code&gt;eval&lt;/code&gt; 을 호출 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3085774b673af461ac31534c68394d3d72b66809" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If your code is running on TPUs, be sure to call &lt;a href=&quot;../../config/set_soft_device_placement&quot;&gt;&lt;code&gt;tf.config.set_soft_device_placement(True)&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;enable_dump_debug_info&quot;&gt;&lt;code&gt;tf.debugging.experimental.enable_dump_debug_info()&lt;/code&gt;&lt;/a&gt; as this API uses automatic outside compilation on TPUs. For example:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 코드가 TPU에서 실행중인 경우이 API는 TPU에서 자동 외부 컴파일을 사용하므로 &lt;a href=&quot;enable_dump_debug_info&quot;&gt; &lt;code&gt;tf.debugging.experimental.enable_dump_debug_info()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;../../config/set_soft_device_placement&quot;&gt; &lt;code&gt;tf.config.set_soft_device_placement(True)&lt;/code&gt; &lt;/a&gt; 를 호출 해야 합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="fbd7284ad95735e566e59a0cdd9fa010d8a83de7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If your code is running on TPUs, be sure to call &lt;a href=&quot;../config/set_soft_device_placement&quot;&gt;&lt;code&gt;tf.config.set_soft_device_placement(True)&lt;/code&gt;&lt;/a&gt; before calling &lt;a href=&quot;enable_check_numerics&quot;&gt;&lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt;&lt;/a&gt; as this API uses automatic outside compilation on TPUs. For example:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 코드가 TPU에서 실행중인 경우이 API는 TPU에서 자동 외부 컴파일을 사용하므로 &lt;a href=&quot;enable_check_numerics&quot;&gt; &lt;code&gt;tf.debugging.enable_check_numerics()&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 &lt;a href=&quot;../config/set_soft_device_placement&quot;&gt; &lt;code&gt;tf.config.set_soft_device_placement(True)&lt;/code&gt; &lt;/a&gt; 를 호출 해야 합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e4bc3f7a1f3603719e759b933672dc9e0f453801" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If your program backpropagates through this function, you should replace it with a call to tf.linalg.eig (possibly ignoring the second output) to avoid computing the eigen decomposition twice. This is because the eigenvectors are used to compute the gradient w.r.t. the eigenvalues. See _SelfAdjointEigV2Grad in linalg_grad.py.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 프로그램이이 기능을 통해 역 전파되는 경우 고유 분해를 두 번 계산하지 않도록 tf.linalg.eig (두 번째 출력 무시) 호출로 대체해야합니다. 이는 고유 벡터가 고유 값의 기울기를 계산하는 데 사용되기 때문입니다. linalg_grad.py의 _SelfAdjointEigV2Grad를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fb5baee5a0c24def8fa60819158664d0d8ff33c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; If your program backpropagates through this function, you should replace it with a call to tf.linalg.eigh (possibly ignoring the second output) to avoid computing the eigen decomposition twice. This is because the eigenvectors are used to compute the gradient w.r.t. the eigenvalues. See _SelfAdjointEigV2Grad in linalg_grad.py.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 프로그램이이 기능을 통해 역 전파되는 경우 고유 분해를 두 번 계산하지 않도록 tf.linalg.eigh (두 번째 출력 무시) 호출로 대체해야합니다. 이는 고유 벡터가 고유 값의 기울기를 계산하는 데 사용되기 때문입니다. linalg_grad.py의 _SelfAdjointEigV2Grad를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b50aa9c9deed24f0154842d9a1888aebd1de27a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In Jupyter notebooks and colabs, &lt;a href=&quot;print&quot;&gt;&lt;code&gt;tf.print&lt;/code&gt;&lt;/a&gt; prints to the notebook cell outputs. It will not write to the notebook kernel's console logs.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Jupyter 노트북 및 colab에서 &lt;a href=&quot;print&quot;&gt; &lt;code&gt;tf.print&lt;/code&gt; &lt;/a&gt; 는 노트북 셀 출력으로 인쇄됩니다. 노트북 커널의 콘솔 로그에는 쓰지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e894c3f7d329e0b5e9cda28f5a044d1c9b85650" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In TensorFlow 2.0, AutoGraph is automatically applied when using &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This module contains lower-level APIs for advanced use.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; TensorFlow 2.0에서는 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 AutoGraph가 자동으로 적용됩니다 . 이 모듈에는 고급 사용을위한 하위 수준 API가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7e892e32b5530f8fb2d69328bc6bf3932a7baa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In TensorFlow 2.0, AutoGraph is automatically applied when using &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;. This module contains lower-level APIs for advanced use.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; TensorFlow 2.0에서는 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 AutoGraph가 자동으로 적용됩니다 . 이 모듈에는 고급 사용을위한 하위 수준 API가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="38b3f5cf8b34807a9a3bd90cba5c6472bf0977f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In contrast to TPU training/evaluation, the &lt;code&gt;input_fn&lt;/code&gt; for prediction &lt;em&gt;should&lt;/em&gt; raise an end-of-input exception (&lt;code&gt;OutOfRangeError&lt;/code&gt; or &lt;code&gt;StopIteration&lt;/code&gt;), which serves as the stopping signal to &lt;code&gt;TPUEstimator&lt;/code&gt;. To be precise, the ops created by &lt;code&gt;input_fn&lt;/code&gt; produce one batch of the data. The &lt;code&gt;predict()&lt;/code&gt; API processes one batch at a time. When reaching the end of the data source, an end-of-input exception should be raised by one of these operations. The user usually does not need to do this manually. As long as the dataset is not repeated forever, the &lt;a href=&quot;../../../../data&quot;&gt;&lt;code&gt;tf.data&lt;/code&gt;&lt;/a&gt; API will raise an end-of-input exception automatically after the last batch has been produced.</source>
          <target state="translated">&lt;strong&gt;주 :&lt;/strong&gt; TPU 훈련 / 평가 달리, &lt;code&gt;input_fn&lt;/code&gt; 예측을 &lt;em&gt;한다&lt;/em&gt; 끝의 입력 예외 (상향 &lt;code&gt;OutOfRangeError&lt;/code&gt; 또는 &lt;code&gt;StopIteration&lt;/code&gt; 을 행 정지 신호로서 제공) &lt;code&gt;TPUEstimator&lt;/code&gt; 를 . 정확하게 말하면 &lt;code&gt;input_fn&lt;/code&gt; 에 의해 생성 된 연산 은 데이터의 배치를 생성합니다. &lt;code&gt;predict()&lt;/code&gt; API는 한 번에 하나 개의 배치를 처리합니다. 데이터 소스의 끝에 도달하면 이러한 조작 중 하나에 의해 입력 종료 예외가 발생해야합니다. 사용자는 일반적으로이 작업을 수동으로 수행 할 필요가 없습니다. 데이터 세트가 영원히 반복되지 않는 한 &lt;a href=&quot;../../../../data&quot;&gt; &lt;code&gt;tf.data&lt;/code&gt; &lt;/a&gt;API는 마지막 배치가 생성 된 후 입력 끝 예외를 자동으로 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="a475eb4e9aec8440ddf193299f107378d8da80ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In eager mode, &lt;code&gt;computation&lt;/code&gt; will have &lt;code&gt;@tf.function&lt;/code&gt; semantics.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 열망 모드에서는 &lt;code&gt;computation&lt;/code&gt; 있을 것이다 &lt;code&gt;@tf.function&lt;/code&gt; 의미.</target>
        </trans-unit>
        <trans-unit id="01753111f3e6a7f3d210a004fcd0b51494115cb8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In order to support complex complex, please provide an input tensor of &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 복합 단지를 지원하기 위해,의 입력 텐서 제공하십시오 &lt;code&gt;complex64&lt;/code&gt; 또는 &lt;code&gt;complex128&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a33dcc55ecafb3e1e2c91eb37b9296e541de8666" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In the case where &lt;code&gt;num_true&lt;/code&gt; &amp;gt; 1, we assign to each target class the target probability 1 / &lt;code&gt;num_true&lt;/code&gt; so that the target probabilities sum to 1 per-example.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;num_true&lt;/code&gt; &amp;gt; 1 인 경우 각 확률에 목표 확률 1 / &lt;code&gt;num_true&lt;/code&gt; 를 할당하여 목표 확률이 예당 1이 되도록합니다.</target>
        </trans-unit>
        <trans-unit id="97758676bb06b1d389eb83510dc24ab1857356dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It is illegal to &quot;directly&quot; use tensors created inside a cond branch outside it, e.g. by storing a reference to a branch tensor in the python state. If you need to use a tensor created in a branch function you should return it as an output of the branch function and use the output from &lt;a href=&quot;cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 예를 들어 파이썬 상태에서 분기 텐서에 대한 참조를 저장하여 외부의 분기 분기 내부에서 작성된 텐서를 &quot;직접&quot;사용하는 것은 불법입니다. 분기 함수에서 작성된 텐서를 사용해야하는 경우 분기 함수의 출력으로 반환하고 대신 &lt;a href=&quot;cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt; 의 출력을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f57feda68e7ee5d405173d9a964adf741b063f86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It is legitimate to call &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt;&lt;code&gt;Iterator.get_next()&lt;/code&gt;&lt;/a&gt; multiple times, e.g. when you are distributing different elements to multiple devices in a single step. However, a common pitfall arises when users call &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt;&lt;code&gt;Iterator.get_next()&lt;/code&gt;&lt;/a&gt; in each iteration of their training loop. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt;&lt;code&gt;Iterator.get_next()&lt;/code&gt;&lt;/a&gt; adds ops to the graph, and executing each op allocates resources (including threads); as a consequence, invoking it in every iteration of a training loop causes slowdown and eventual resource exhaustion. To guard against this outcome, we log a warning when the number of uses crosses a fixed threshold of suspiciousness.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt; &lt;code&gt;Iterator.get_next()&lt;/code&gt; &lt;/a&gt; 여러 번 호출하는 것은 합법적입니다 . 예를 들어 한 단계로 여러 장치에 다른 요소를 배포하는 경우입니다. 그러나 사용자 가 훈련 루프의 각 반복에서 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt; &lt;code&gt;Iterator.get_next()&lt;/code&gt; &lt;/a&gt; 를 호출 할 때 일반적인 함정이 발생 합니다. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Iterator#get_next&quot;&gt; &lt;code&gt;Iterator.get_next()&lt;/code&gt; &lt;/a&gt; 는 그래프에 작업을 추가하고 각 작업을 실행하면 리소스 (스레드 포함)가 할당됩니다. 결과적으로 훈련 루프의 모든 반복에서 호출하면 속도가 느려지고 궁극적으로 리소스가 고갈됩니다. 이 결과를 방지하기 위해 사용 횟수가 고정 된 의심 임계 값을 초과 할 때 경고를 기록합니다.</target>
        </trans-unit>
        <trans-unit id="fde47f309dc31138840c64b44b38398c8b7897ad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It is more efficient to first &lt;a href=&quot;../bitcast&quot;&gt;&lt;code&gt;tf.bitcast&lt;/code&gt;&lt;/a&gt; your tensors into &lt;code&gt;int32&lt;/code&gt; or &lt;code&gt;int64&lt;/code&gt; and perform the bitcount on the result, than to feed in 8- or 16-bit inputs and then aggregate the resulting counts.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 처음에 더 효율적입니다 &lt;a href=&quot;../bitcast&quot;&gt; &lt;code&gt;tf.bitcast&lt;/code&gt; &lt;/a&gt; 에 당신의 텐서 &lt;code&gt;int32&lt;/code&gt; 또는 &lt;code&gt;int64&lt;/code&gt; 및 8 비트 또는 16 비트 입력에 공급보다는, 그 결과에 bitcount을 수행하고 그 결과 수를 집계.</target>
        </trans-unit>
        <trans-unit id="bd6d83bdf03bc69c5f65292a37218324d26cea1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It is not recommended to set this to float16 for training, as this will likely cause numeric stability issues. Instead, mixed precision, which is using a mix of float16 and float32, can be used by calling &lt;code&gt;tf.keras.mixed_precision.experimental.set_policy('mixed_float16')&lt;/code&gt;. See the &lt;a href=&quot;https://www.tensorflow.org/guide/keras/mixed_precision&quot;&gt;mixed precision guide&lt;/a&gt; for details.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 숫자 안정성 문제가 발생할 수 있으므로 학습을 위해 float16으로 설정하지 않는 것이 좋습니다. 대신 float16과 float32를 혼합하여 사용하는 혼합 정밀도는 &lt;code&gt;tf.keras.mixed_precision.experimental.set_policy('mixed_float16')&lt;/code&gt; 를 호출하여 사용할 수 있습니다 . 자세한 내용은 &lt;a href=&quot;https://www.tensorflow.org/guide/keras/mixed_precision&quot;&gt;혼합 정밀도 가이드&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="b8fc1a832b2592a53fdd234fa174ac65217b1af7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; It would be useful to allow a variable number of target classes per example. We hope to provide this functionality in a future release. For now, if you have a variable number of target classes, you can pad them out to a constant number by either repeating them or by padding with an otherwise unused class.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 예제 당 가변 개수의 대상 클래스를 허용하는 것이 좋습니다. 향후 릴리스에서이 기능을 제공 할 수 있도록 노력하겠습니다. 지금은 가변 수의 대상 클래스가있는 경우이를 반복하거나 사용하지 않는 클래스로 채워서 상수 수로 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eac08567a6fdb3b5f3c8ed23daa8245e28f00d99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Like other &lt;code&gt;Dataset&lt;/code&gt; methods, prefetch operates on the elements of the input dataset. It has no concept of examples vs. batches. &lt;code&gt;examples.prefetch(2)&lt;/code&gt; will prefetch two elements (2 examples), while &lt;code&gt;examples.batch(20).prefetch(2)&lt;/code&gt; will prefetch 2 elements (2 batches, of 20 examples each).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다른 &lt;code&gt;Dataset&lt;/code&gt; 메서드 와 마찬가지로 프리 페치는 입력 데이터 세트의 요소에서 작동합니다. 예제 대 배치의 개념이 없습니다. &lt;code&gt;examples.prefetch(2)&lt;/code&gt; 는 두 개의 요소 (2 개의 예제 ) 를 프리 페치하는 반면, &lt;code&gt;examples.batch(20).prefetch(2)&lt;/code&gt; 는 2 개의 요소 (각 20 개의 예제 중 2 개의 배치 ) 를 프리 페치합니다.</target>
        </trans-unit>
        <trans-unit id="07a692a83a81da1f77548252a571e9cbd182554c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; MLIR-Based TensorFlow Compiler is under active development and has missing features, please refrain from using. This API exists for development and testing only.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; MLIR 기반 TensorFlow 컴파일러는 현재 개발 중이며 누락 된 기능이 있으므로 사용을 자제 해주세요. 이 API는 개발 및 테스트 용으로 만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="ffc37e7db8ecf584fa1569b95502544e309cce13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; MUST mirror the behavior of the C++ AppendFlagsIntoFile from &lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt; 에서 C ++ AppendFlagsIntoFile의 동작을 미러링해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c2e5b4c0eb774fb4245c1bbab69d97c44f18e13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; MUST mirror the behavior of the C++ CommandlineFlagsIntoString from &lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt; 에서 C ++ CommandlineFlagsIntoString의 동작을 미러링해야합니다.</target>
        </trans-unit>
        <trans-unit id="4c461638f60065f5e4c6026723c6b14f99680781" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Most users will not call this initializer directly, and will instead use &lt;code&gt;Dataset.make_initializable_iterator()&lt;/code&gt; or &lt;code&gt;Dataset.make_one_shot_iterator()&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 대부분의 사용자는이 초기화 프로그램을 직접 호출하지 않고 대신 &lt;code&gt;Dataset.make_initializable_iterator()&lt;/code&gt; 또는 &lt;code&gt;Dataset.make_one_shot_iterator()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="05b61347e668e1833ac8ce17f2d299aa02d6665e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Near image edges the filtering kernel may be partially outside the image boundaries. For these pixels, only input pixels inside the image will be included in the filter sum, and the output value will be appropriately normalized.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이미지 가장자리 근처에 필터링 커널이 부분적으로 이미지 경계 밖에있을 수 있습니다. 이러한 픽셀의 경우 이미지 내부의 입력 픽셀 만 필터 합계에 포함되고 출력 값이 적절하게 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="945ca499c1b7a95da9df44ca812f784ec2d0761c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not all &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; implementations currently support TensorFlow's partitioned variables (where a single variable is split across multiple devices) at this time.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 모든 &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 구현이 현재 TensorFlow의 분할 된 변수 (단일 변수가 여러 장치에 분할 된)를 지원 하지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e32cb088f94bf719789bbc5023c4de834ab0fd57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Not all iterators support checkpointing yet. Attempting to save the state of an unsupported iterator will throw an error.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 반복자가 아직 검사 점을 지원하지는 않습니다. 지원되지 않는 반복자의 상태를 저장하려고하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="13aa780fd74a39047a2c41b2455925c0b22aed73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Prefer using the Tensor division operator or tf.divide which obey Python 3 division operator semantics.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Python 3 나누기 연산자 의미 체계를 따르는 Tensor 나누기 연산자 또는 tf.divide를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="53e51e1b7f876fd1300da20dc37fa28a103140ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Prefer using the Tensor operator or tf.divide which obey Python division operator semantics.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Python 나누기 연산자 의미 체계를 따르는 Tensor 연산자 또는 tf.divide를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="164766f92b1c40f1abdfa89faaefd21276b403d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regardless of the value of merge_repeated, if the maximum index of a given time and batch corresponds to the blank index &lt;code&gt;(num_classes - 1)&lt;/code&gt;, no new element is emitted.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; merge_repeated의 값에 관계없이 주어진 시간 및 배치의 최대 색인이 공백 색인 &lt;code&gt;(num_classes - 1)&lt;/code&gt; 해당하는 경우 새 요소가 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2bc4e8e71b81da74384d92dcda95c6958fc2a9b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Resampling is performed via rejection sampling; some fraction of the input values will be dropped.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 리샘플링은 거부 샘플링을 통해 수행됩니다. 입력 값의 일부가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="156d1fcd1ef4eebbb9259769399bc75aec78289e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Restarting training from saved &lt;code&gt;meta_graph&lt;/code&gt; only works if the device assignments have not changed.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 저장된 &lt;code&gt;meta_graph&lt;/code&gt; 에서 학습을 다시 시작 하는 것은 기기 할당이 변경되지 않은 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fb34490e3db6fb5f579f4539c1b76510f0fecef8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Strings are compared against zero-length empty string &lt;code&gt;&quot;&quot;&lt;/code&gt;. Any string with a size greater than zero is already considered as nonzero.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 문자열은 길이가 0 인 빈 문자열 &lt;code&gt;&quot;&quot;&lt;/code&gt; 과 비교됩니다 . 크기가 0보다 큰 모든 문자열은 이미 0이 아닌 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="a59a13a71a369049859edbd7dda2e1f3a8f3adde" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Task id (the property field &lt;code&gt;task_id&lt;/code&gt;) is tracking the index of the node among all nodes with the SAME task type. For example, given the cluster definition as follows:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 작업 ID (속성 필드 &lt;code&gt;task_id&lt;/code&gt; )는 SAME 작업 유형의 모든 노드에서 노드의 인덱스를 추적합니다. 예를 들어, 다음과 같이 클러스터 정의가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="9ce8cdae9e5a2391fb0e0c3ffedc42e4d78a449c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The 'out of vocabulary' character is only used for words that were present in the training set but are not included because they're not making the &lt;code&gt;num_words&lt;/code&gt; cut here. Words that were not seen in the training set but are in the test set have simply been skipped.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; '어휘 부족'문자는 학습 세트에있는 단어에만 사용되지만 여기 에서 &lt;code&gt;num_words&lt;/code&gt; 를 자르지 않기 때문에 포함되지 않습니다 . 훈련 세트에는 없지만 테스트 세트에는있는 단어는 건너 뛰었습니다.</target>
        </trans-unit>
        <trans-unit id="035835272963e354994740057ad1d9ea669d5e1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;a href=&quot;numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; operation has the following known limitations:</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 의&lt;/a&gt; 동작은 다음과 같은 알려진 제한 사항이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a93d34af5a4aa074f67f0e49e39fc1377c3af48a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;a href=&quot;py_func&quot;&gt;&lt;code&gt;tf.compat.v1.py_func()&lt;/code&gt;&lt;/a&gt; operation has the following known limitations:</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;py_func&quot;&gt; &lt;code&gt;tf.compat.v1.py_func()&lt;/code&gt; &lt;/a&gt; 작업이 다음과 같은 알려진 제한 사항이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1b0cbefa8728c3863e564195f26182928d92259e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;as_default&lt;/code&gt; context manager &lt;em&gt;does not&lt;/em&gt; close the session when you exit the context, and you must close the session explicitly.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;as_default&lt;/code&gt; 의 컨텍스트 관리자가 &lt;em&gt;되지 않습니다&lt;/em&gt; 당신이 상황을 종료 할 때 세션을 닫고, 명시 적으로 세션을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="fe8d5f873e9f3ae43d1f5e4160709395f5093284" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The &lt;code&gt;ctc_greedy_decoder&lt;/code&gt; is a special case of the &lt;code&gt;ctc_beam_search_decoder&lt;/code&gt; with &lt;code&gt;top_paths=1&lt;/code&gt; and &lt;code&gt;beam_width=1&lt;/code&gt; (but that decoder is faster for this special case).</source>
          <target state="translated">&lt;strong&gt;주 : &lt;/strong&gt; &lt;code&gt;ctc_greedy_decoder&lt;/code&gt; 는 의 특별한 경우이다 &lt;code&gt;ctc_beam_search_decoder&lt;/code&gt; 와 &lt;code&gt;top_paths=1&lt;/code&gt; 및 &lt;code&gt;beam_width=1&lt;/code&gt; (하지만, 디코더는이 특별한 경우에 대해 빠르다).</target>
        </trans-unit>
        <trans-unit id="9f0d2f4414e849eb1f6ea8c160a840e2b5604e85" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The behavior of dropout has changed between TensorFlow 1.x and 2.x. When converting 1.x code, please use named arguments to ensure behavior stays consistent.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 드롭 아웃 동작은 TensorFlow 1.x와 2.x 사이에서 변경되었습니다. 1.x 코드를 변환 할 때 명명 된 인수를 사용하여 동작이 일관되게 유지되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="0fb84744a0be14f8a2fd2aaefdab9a50eda54013" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The calls to &lt;code&gt;enqueue&lt;/code&gt; have &lt;code&gt;training&lt;/code&gt; set to &lt;code&gt;True&lt;/code&gt; when &lt;code&gt;embedding.apply_gradients&lt;/code&gt; is used and set to &lt;code&gt;False&lt;/code&gt; when &lt;code&gt;embedding.apply_gradients&lt;/code&gt; is not present in the function. If you don't follow this pattern you may cause an error to be raised or the tpu may deadlock.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 에 대한 호출 &lt;code&gt;enqueue&lt;/code&gt; 한 &lt;code&gt;training&lt;/code&gt; 에 세트를 &lt;code&gt;True&lt;/code&gt; 때 &lt;code&gt;embedding.apply_gradients&lt;/code&gt; 가 사용하고 설정 &lt;code&gt;False&lt;/code&gt; 때 &lt;code&gt;embedding.apply_gradients&lt;/code&gt; 이 기능에 존재하지 않습니다. 이 패턴을 따르지 않으면 오류가 발생하거나 tpu가 교착 상태가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69dbbf90fa74e42dd03521a6af50fb247c816580" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The context managers will always be exited without any error information. This is an unfortunate implementation detail due to some internals of how unittest runs tests.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 컨텍스트 관리자는 항상 오류 정보없이 종료됩니다. 이것은 unittest가 테스트를 실행하는 방법의 일부 내부로 인해 불행한 구현 세부 사항입니다.</target>
        </trans-unit>
        <trans-unit id="8cf8b3a04d6e5e4fe9f40ebff95c9fed7ee287f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The control dependencies context applies &lt;em&gt;only&lt;/em&gt; to ops that are constructed within the context. Merely using an op or tensor in the context does not add a control dependency. The following example illustrates this point:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 제어 종속성 컨텍스트는 컨텍스트 내에서 생성 된 작업 &lt;em&gt;에만&lt;/em&gt; 적용 &lt;em&gt;됩니다&lt;/em&gt; . 컨텍스트에서 op 또는 tensor를 사용하는 것만으로는 제어 종속성이 추가되지 않습니다. 다음 예는이 점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="404d313d22c2763a1ae43fac77fb31fe89ce1e14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The conversion functions will execute in order of priority, followed by order of registration. To ensure that a conversion function &lt;code&gt;F&lt;/code&gt; runs before another conversion function &lt;code&gt;G&lt;/code&gt;, ensure that &lt;code&gt;F&lt;/code&gt; is registered with a smaller priority than &lt;code&gt;G&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 변환 기능은 등록 순서에 따라 우선 순위에 따라 실행됩니다. 변환 함수 &lt;code&gt;F&lt;/code&gt; 가 다른 변환 함수 &lt;code&gt;G&lt;/code&gt; 보다 먼저 실행 되도록하려면 &lt;code&gt;F&lt;/code&gt; 가 &lt;code&gt;G&lt;/code&gt; 보다 낮은 우선 순위로 등록되어 있는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="760992e16b3fafca3f4384537e8c5c81b3b08537" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the dataset and iterator related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;../dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 구현 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히 &lt;a href=&quot;../dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출 한 Python 프로그램과 동일한 프로세스의 장치에 데이터 셋 및 반복기 관련 작업을 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 메서드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="744328dcd0cdac98b626a7a1371bc48c4d8455b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the dataset and iterator related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 구현 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히 &lt;a href=&quot;dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출 한 Python 프로그램과 동일한 프로세스의 장치에 데이터 셋 및 반복기 관련 작업을 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 메서드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="63bba68a05d59615d88716e843b19ad073c20f90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the dataset and iterator related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 구현 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출 한 Python 프로그램과 동일한 프로세스의 장치에 데이터 셋 및 반복기 관련 작업을 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 메서드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="bfde6e96bcffe879be07966e0a236ca4f7098c57" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The current implementation of &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt; uses &lt;a href=&quot;../../../numpy_function&quot;&gt;&lt;code&gt;tf.numpy_function&lt;/code&gt;&lt;/a&gt; and inherits the same constraints. In particular, it requires the dataset and iterator related operations to be placed on a device in the same process as the Python program that called &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt;&lt;code&gt;Dataset.from_generator()&lt;/code&gt;&lt;/a&gt;. The body of &lt;code&gt;generator&lt;/code&gt; will not be serialized in a &lt;code&gt;GraphDef&lt;/code&gt;, and you should not use this method if you need to serialize your model and restore it in a different environment.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 구현 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 사용 &lt;a href=&quot;../../../numpy_function&quot;&gt; &lt;code&gt;tf.numpy_function&lt;/code&gt; 을&lt;/a&gt; 같은 제약 조건을 상속합니다. 특히 &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/data/Dataset#from_generator&quot;&gt; &lt;code&gt;Dataset.from_generator()&lt;/code&gt; &lt;/a&gt; 를 호출 한 Python 프로그램과 동일한 프로세스의 장치에 데이터 셋 및 반복기 관련 작업을 배치해야합니다 . &lt;code&gt;generator&lt;/code&gt; 본문은 &lt;code&gt;GraphDef&lt;/code&gt; 에서 직렬화 되지 않으며 모델을 직렬화하고 다른 환경에서 복원해야하는 경우이 메서드를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="2eb7b8af8019265b6ed02b0cf85e9e5fc91fe9fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default behavior of this method is to return filenames in a non-deterministic random shuffled order. Pass a &lt;code&gt;seed&lt;/code&gt; or &lt;code&gt;shuffle=False&lt;/code&gt; to get results in a deterministic order.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 메서드의 기본 동작은 비 결정적 임의 셔플 된 순서로 파일 이름을 반환하는 것입니다. 패스 &lt;code&gt;seed&lt;/code&gt; 또는 &lt;code&gt;shuffle=False&lt;/code&gt; 결정적 순서로 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d06327f7aa18802f2bc660a1e2ac7094ec43ddb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default graph is a property of the current thread. If you create a new thread, and wish to use the default graph in that thread, you must explicitly add a &lt;code&gt;with g.as_default():&lt;/code&gt; in that thread's function.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 기본 그래프는 현재 스레드의 속성입니다. 새 스레드를 만들고 해당 스레드에서 기본 그래프를 사용하려면 해당 스레드의 함수에 &lt;code&gt;with g.as_default():&lt;/code&gt; 를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ec428c5d3868f2b88ea5740676c114a86e53415c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default graph is a property of the current thread. This function applies only to the current thread. Calling this function while a &lt;a href=&quot;session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;interactivesession&quot;&gt;&lt;code&gt;tf.compat.v1.InteractiveSession&lt;/code&gt;&lt;/a&gt; is active will result in undefined behavior. Using any previously created &lt;a href=&quot;../../operation&quot;&gt;&lt;code&gt;tf.Operation&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects after calling this function will result in undefined behavior. Raises: AssertionError: If this function is called within a nested graph.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 기본 그래프는 현재 스레드의 속성입니다. 이 함수는 현재 스레드에만 적용됩니다. &lt;a href=&quot;session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;interactivesession&quot;&gt; &lt;code&gt;tf.compat.v1.InteractiveSession&lt;/code&gt; &lt;/a&gt; 이 활성화 된 상태에서이 함수를 호출하면 정의되지 않은 동작이 발생합니다. 이 함수를 호출 한 후 이전에 만든 &lt;a href=&quot;../../operation&quot;&gt; &lt;code&gt;tf.Operation&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 개체를 사용하면 정의되지 않은 동작이 발생합니다. 발생 : AssertionError : 중첩 된 그래프 내에서이 함수가 호출 된 경우.</target>
        </trans-unit>
        <trans-unit id="14ad71b86cb964a06180801eef67bea94af33be3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default kernel implementation for MatMul on GPUs uses cublas.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; GPU에서 MatMul의 기본 커널 구현은 입방체를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d248e34e6d8b23fd33be856703ae7d60a7a0414a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default session is a property of the current thread. If you create a new thread, and wish to use the default session in that thread, you must explicitly add a &lt;code&gt;with sess.as_default():&lt;/code&gt; in that thread's function.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 기본 세션은 현재 스레드의 속성입니다. 새 스레드를 만들고 해당 스레드에서 기본 세션을 사용하려면 해당 스레드의 함수에 &lt;code&gt;with sess.as_default():&lt;/code&gt; 를 명시 적으로 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="32bf2f9bae892ab8f91e4d3338ab2d1e3d75b460" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The default value is also presented to the user in the help string, so it is important that it be a legal value for this flag.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 기본값은 사용자에게 도움말 문자열로도 표시되므로이 플래그의 올바른 값이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c6891c52ba1ce4de5f9aafd13231e0b65876f804" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The device scope may be overridden by op wrappers or other library code. For example, a variable assignment op &lt;code&gt;v.assign()&lt;/code&gt; must be colocated with the &lt;a href=&quot;variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt;&lt;code&gt;v&lt;/code&gt;, and incompatible device scopes will be ignored.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 장치 범위는 op 래퍼 또는 기타 라이브러리 코드로 재정의 될 수 있습니다. 예를 들어, 변수 할당 op &lt;code&gt;v.assign()&lt;/code&gt; 은 &lt;a href=&quot;variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; &lt;code&gt;v&lt;/code&gt; 와 같은 위치에 있어야 하며 호환되지 않는 장치 범위는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="c1eb4e09f128d3a1e6714cec1bd6ea1d3d4f97d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The directory and its contents will be recursively cleared before creation. This ensures that there is no pre-existing state.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 디렉터리와 그 내용은 만들기 전에 재귀 적으로 지워집니다. 이렇게하면 기존 상태가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f04ae9601001d5d9f822e1818510d97a4f6ec4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The directory layout and file format used for saving the dataset is considered an implementation detail and may change. For this reason, datasets saved through &lt;a href=&quot;save&quot;&gt;&lt;code&gt;tf.data.experimental.save&lt;/code&gt;&lt;/a&gt; should only be consumed through &lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.data.experimental.load&lt;/code&gt;&lt;/a&gt;, which is guaranteed to be backwards compatible.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 데이터 세트를 저장하는 데 사용되는 디렉토리 레이아웃 및 파일 형식은 구현 세부 사항으로 간주되며 변경 될 수 있습니다. 이러한 이유로 말미암아 구원 데이터 세트 &lt;a href=&quot;save&quot;&gt; &lt;code&gt;tf.data.experimental.save&lt;/code&gt; 을&lt;/a&gt; 통해서만 섭취해야 &lt;a href=&quot;load&quot;&gt; &lt;code&gt;tf.data.experimental.load&lt;/code&gt; &lt;/a&gt; 하위 호환성이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="acb8663b4dfdaffa219a2fabcb0fafdd535e5c31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The following assumes that &quot;examples.tfrecord&quot; contains 42 records.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 다음은 &quot;examples.tfrecord&quot;에 42 개의 레코드가 포함되어 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e3d333b0c72035f243f46dc70a1761bc23b917bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The gradient computation on GPU is faster for large matrices but not for large batch dimensions when the submatrices are small. In this case it might be faster to use the CPU.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; GPU의 그래디언트 계산은 큰 행렬의 경우 더 빠르지 만 부분 행렬이 작은 경우 큰 배치 차원의 경우가 아닙니다. 이 경우 CPU를 사용하는 것이 더 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe0790d7a7d17829e1115287cd6637c52839dc55" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The mode is undefined when &lt;code&gt;concentration1 &amp;lt;= 1&lt;/code&gt; or &lt;code&gt;concentration0 &amp;lt;= 1&lt;/code&gt;. If &lt;code&gt;self.allow_nan_stats&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is used for undefined modes. If &lt;code&gt;self.allow_nan_stats&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an exception is raised when one or more modes are undefined.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;concentration1 &amp;lt;= 1&lt;/code&gt; 또는 &lt;code&gt;concentration0 &amp;lt;= 1&lt;/code&gt; 경우 모드가 정의되지 않습니다 . 경우 &lt;code&gt;self.allow_nan_stats&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 이는 정의되지 않은 모드에 사용됩니다. 경우 &lt;code&gt;self.allow_nan_stats&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; 하나 개 이상의 모드가 정의 될 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe9b78f430227a5f26ee32752754786425dff34b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The mode is undefined when any &lt;code&gt;concentration &amp;lt;= 1&lt;/code&gt;. If &lt;code&gt;self.allow_nan_stats&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;NaN&lt;/code&gt; is used for undefined modes. If &lt;code&gt;self.allow_nan_stats&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an exception is raised when one or more modes are undefined.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;concentration &amp;lt;= 1&lt;/code&gt; 경우 모드가 정의되지 않습니다 . 경우 &lt;code&gt;self.allow_nan_stats&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;NaN&lt;/code&gt; 이는 정의되지 않은 모드에 사용됩니다. 경우 &lt;code&gt;self.allow_nan_stats&lt;/code&gt; 이 있다 &lt;code&gt;False&lt;/code&gt; 하나 개 이상의 모드가 정의 될 때 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6c1ecb14516c8d08b9c046a52500bfbef375477f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order in which the data is processed by the workers when using &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; is not guaranteed. This is typically required if you are using &lt;a href=&quot;../../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; to scale prediction. You can however insert an index for each element in the batch and order outputs accordingly. Refer to &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;this snippet&lt;/a&gt; for an example of how to order outputs.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 작업자가 데이터를 처리하는 순서 는 보장되지 않습니다. 이는 일반적으로 &lt;a href=&quot;../../../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 를 사용하여 예측을 확장 하는 경우 필요합니다 . 그러나 배치의 각 요소에 대한 색인을 삽입하고 그에 따라 출력을 정렬 할 수 있습니다. 출력을 주문하는 방법의 예는 &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;이 스 니펫&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8723e8d5538874e884f6c958145b53d80db0410" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order in which the data is processed by the workers when using &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; is not guaranteed. This is typically required if you are using &lt;a href=&quot;../../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; to scale prediction. You can however insert an index for each element in the batch and order outputs accordingly. Refer to &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;this snippet&lt;/a&gt; for an example of how to order outputs.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../../../distribute/strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 작업자가 데이터를 처리하는 순서 는 보장되지 않습니다. 이는 일반적으로 &lt;a href=&quot;../../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 를 사용하여 예측을 확장 하는 경우 필요합니다 . 그러나 배치의 각 요소에 대한 색인을 삽입하고 그에 따라 출력을 정렬 할 수 있습니다. 출력을 주문하는 방법의 예는 &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;이 스 니펫&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="29f0995d858ec49507cbd1894b34922271eba02d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order in which the data is processed by the workers when using &lt;a href=&quot;../strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; is not guaranteed. This is typically required if you are using &lt;a href=&quot;../../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; to scale prediction. You can however insert an index for each element in the batch and order outputs accordingly. Refer to &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;this snippet&lt;/a&gt; for an example of how to order outputs.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 작업자가 데이터를 처리하는 순서 는 보장되지 않습니다. 이는 일반적으로 &lt;a href=&quot;../../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 를 사용하여 예측을 확장 하는 경우 필요합니다 . 그러나 배치의 각 요소에 대한 색인을 삽입하고 그에 따라 출력을 정렬 할 수 있습니다. 출력을 주문하는 방법의 예는 &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;이 스 니펫&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb53ce1388b335d91ed0ce94b9bd9203339e834e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order in which the data is processed by the workers when using &lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; is not guaranteed. This is typically required if you are using &lt;a href=&quot;../distribute&quot;&gt;&lt;code&gt;tf.distribute&lt;/code&gt;&lt;/a&gt; to scale prediction. You can however insert an index for each element in the batch and order outputs accordingly. Refer to &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;this snippet&lt;/a&gt; for an example of how to order outputs.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;strategy#experimental_distribute_dataset&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_dataset&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 사용할 때 작업자가 데이터를 처리하는 순서 는 보장되지 않습니다. 이는 일반적으로 &lt;a href=&quot;../distribute&quot;&gt; &lt;code&gt;tf.distribute&lt;/code&gt; &lt;/a&gt; 를 사용하여 예측을 확장 하는 경우 필요합니다 . 그러나 배치의 각 요소에 대한 색인을 삽입하고 그에 따라 출력을 정렬 할 수 있습니다. 출력을 주문하는 방법의 예는 &lt;a href=&quot;https://www.tensorflow.org/tutorials/distribute/input#caveats&quot;&gt;이 스 니펫&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="838d96ab35810d664694480576ac4870e896a554" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order of elements yielded by this transformation is deterministic, as long as &lt;code&gt;map_func&lt;/code&gt; is a pure function and &lt;code&gt;deterministic=True&lt;/code&gt;. If &lt;code&gt;map_func&lt;/code&gt; contains any stateful operations, the order in which that state is accessed is undefined.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;map_func&lt;/code&gt; 가 순수 함수이고 &lt;code&gt;deterministic=True&lt;/code&gt; 인 한이 변환으로 생성되는 요소의 순서는 결정적 입니다. &lt;code&gt;map_func&lt;/code&gt; 에 상태 저장 작업이 포함 된 경우 해당 상태에 액세스하는 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="74b4930c71a7fa40adfa4b461d0a51e968df2092" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The order of the files returned is deterministic.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반환되는 파일의 순서는 결정적입니다.</target>
        </trans-unit>
        <trans-unit id="b94a4231d4231e702eb6b452267c9315c3fb6dfe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The output of &lt;a href=&quot;../math/asin&quot;&gt;&lt;code&gt;tf.math.asin&lt;/code&gt;&lt;/a&gt; will lie within the invertible range of sine, i.e [-pi/2, pi/2].</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/asin&quot;&gt; &lt;code&gt;tf.math.asin&lt;/code&gt; &lt;/a&gt; 의 출력은 반전 가능한 사인 범위 (예 : [-pi / 2, pi / 2]) 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="d19db6336ef0df7bd5dbd48cfda98f5a14858bb5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The output of &lt;a href=&quot;../math/atan&quot;&gt;&lt;code&gt;tf.math.atan&lt;/code&gt;&lt;/a&gt; will lie within the invertible range of tan, i.e (-pi/2, pi/2).</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/atan&quot;&gt; &lt;code&gt;tf.math.atan&lt;/code&gt; &lt;/a&gt; 의 출력은 tan의 반전 가능한 범위, 즉 (-pi / 2, pi / 2) 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d5857cfcbf36efc0249ee90c690adf5f2d29291" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The output of &lt;a href=&quot;asin&quot;&gt;&lt;code&gt;tf.math.asin&lt;/code&gt;&lt;/a&gt; will lie within the invertible range of sine, i.e [-pi/2, pi/2].</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;asin&quot;&gt; &lt;code&gt;tf.math.asin&lt;/code&gt; &lt;/a&gt; 의 출력은 반전 가능한 사인 범위 (예 : [-pi / 2, pi / 2]) 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="256544a7496bd2537a0a18528bc4392680e5e878" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The output of &lt;a href=&quot;atan&quot;&gt;&lt;code&gt;tf.math.atan&lt;/code&gt;&lt;/a&gt; will lie within the invertible range of tan, i.e (-pi/2, pi/2).</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;atan&quot;&gt; &lt;code&gt;tf.math.atan&lt;/code&gt; &lt;/a&gt; 의 출력은 tan의 반전 가능한 범위, 즉 (-pi / 2, pi / 2) 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="47fb0262bcdea1f42ac49a8c59feec40afe3e0dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The output of this function should be used. If it is not, a warning will be logged or an error may be raised. To mark the output as used, call its .mark_used() method.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수의 출력을 사용해야합니다. 그렇지 않은 경우 경고가 기록되거나 오류가 발생할 수 있습니다. 출력을 사용됨으로 표시하려면 .mark_used () 메서드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="03f87400f9a0adc4171b03a90bb439a0c28cc2d4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The rank of a tensor is not the same as the rank of a matrix. The rank of a tensor is the number of indices required to uniquely select each element of the tensor. Rank is also known as &quot;order&quot;, &quot;degree&quot;, or &quot;ndims.&quot;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 텐서의 순위는 행렬의 순위와 동일하지 않습니다. 텐서의 순위는 텐서의 각 요소를 고유하게 선택하는 데 필요한 인덱스 수입니다. 순위는 &quot;order&quot;, &quot;degree&quot;또는 &quot;ndims&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="aab1e3026a9b342984d6d83f512c7e81881d153c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The returned iterator will be in an uninitialized state, and you must run the &lt;code&gt;iterator.initializer&lt;/code&gt; operation before using it:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 리턴 된 반복기는 초기화되지 않은 상태가되며 사용하기 전에 &lt;code&gt;iterator.initializer&lt;/code&gt; 조작을 실행해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2b2d795cb5c197012e6a08134fddcd7c1753fdd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The returned iterator will be initialized automatically. A &quot;one-shot&quot; iterator does not currently support re-initialization.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반환 된 반복기는 자동으로 초기화됩니다. &quot;원샷&quot;반복자는 현재 재 초기화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ba4d027ae0c6be560b01d85d4853391cba564f38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The returned iterator will be initialized automatically. A &quot;one-shot&quot; iterator does not currently support re-initialization. For that see &lt;code&gt;make_initializable_iterator&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반환 된 이터레이터는 자동으로 초기화됩니다. &quot;원샷&quot;반복자는 현재 재 초기화를 지원하지 않습니다. 이에 대해서는 &lt;code&gt;make_initializable_iterator&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="034ce5cb1fb1a4e89c8808ac7588a33e0ceb61be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The returned iterator will be initialized automatically. A &quot;one-shot&quot; iterator does not support re-initialization.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반환 된 반복기는 자동으로 초기화됩니다. &quot;원샷&quot;반복자는 다시 초기화를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a50d787631f60f5ca00f1274f4b9dafb2e666aea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The true SSIM is only defined on grayscale. This function does not perform any colorspace transform. (If input is already YUV, then it will compute YUV SSIM average.)</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 실제 SSIM은 회색조에서만 정의됩니다. 이 기능은 색 공간 변환을 수행하지 않습니다. (입력이 이미 YUV 인 경우 YUV SSIM 평균을 계산합니다.)</target>
        </trans-unit>
        <trans-unit id="bafcefcfc393c6d976722ba19878c58c39cef307" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; The true SSIM is only defined on grayscale. This function does not perform any colorspace transform. (If the input is already YUV, then it will compute YUV SSIM average.)</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 실제 SSIM은 그레이 스케일에서만 정의됩니다. 이 함수는 색상 공간 변환을 수행하지 않습니다. (입력이 이미 YUV이면 YUV SSIM 평균을 계산합니다.)</target>
        </trans-unit>
        <trans-unit id="7e205f5520d23e81e0ae5aa565bede7c9d4216da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This API is not compatible with the use of &lt;a href=&quot;../../cond&quot;&gt;&lt;code&gt;tf.cond&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../while_loop&quot;&gt;&lt;code&gt;tf.while_loop&lt;/code&gt;&lt;/a&gt;, and will raise a &lt;code&gt;ValueError&lt;/code&gt; if you attempt to call it in such a graph.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 API는 &lt;a href=&quot;../../cond&quot;&gt; &lt;code&gt;tf.cond&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../while_loop&quot;&gt; &lt;code&gt;tf.while_loop&lt;/code&gt; &lt;/a&gt; 의 사용과 호환되지 않으며 이러한 그래프에서 호출하려고 하면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="163a8b0658fe7b9a8d07b33f0efdaca356b01b14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This API is only supported in TPUStrategy for now. This adds an annotation to &lt;code&gt;tensor&lt;/code&gt; specifying that operations on &lt;code&gt;tensor&lt;/code&gt; will be invoked on logical core device id &lt;code&gt;logical_device_id&lt;/code&gt;. When model parallelism is used, the default behavior is that all ops are placed on zero-th logical device.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 API는 현재 TPUStrategy에서만 지원됩니다. 이에 주석 추가 &lt;code&gt;tensor&lt;/code&gt; 에 작업 지정하기 &lt;code&gt;tensor&lt;/code&gt; 논리의 핵심 장치 ID에 호출됩니다 &lt;code&gt;logical_device_id&lt;/code&gt; 을 . 모델 병렬 처리를 사용하는 경우 기본 동작은 모든 작업이 0 번째 논리 장치에 배치되는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f0f124a83f30259767672e830f40aa1d5d31a220" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This API is only supported in TPUStrategy for now. This adds an annotation to tensor &lt;code&gt;tensor&lt;/code&gt; specifying that operations on &lt;code&gt;tensor&lt;/code&gt; will be be split among multiple logical devices. Tensor &lt;code&gt;tensor&lt;/code&gt; will be split across dimensions specified by &lt;code&gt;partition_dimensions&lt;/code&gt;. The dimensions of &lt;code&gt;tensor&lt;/code&gt; must be divisible by corresponding value in &lt;code&gt;partition_dimensions&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 API는 현재 TPUStrategy에서만 지원됩니다. 이 텐서에 주석을 추가 &lt;code&gt;tensor&lt;/code&gt; 에 작업 지정하기 &lt;code&gt;tensor&lt;/code&gt; 여러 논리 장치간에 분할 할 수있을 것입니다. 텐서 &lt;code&gt;tensor&lt;/code&gt; 는 &lt;code&gt;partition_dimensions&lt;/code&gt; 로 지정된 차원으로 분할 됩니다. &lt;code&gt;tensor&lt;/code&gt; 의 차원은 &lt;code&gt;partition_dimensions&lt;/code&gt; 의 해당 값으로 나눌 수 있어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="424af9b0179bbab4f68d4e2ae52163ed1bb3d27a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This API is only supported in TPUStrategy for now. This adds an annotation to tensor &lt;code&gt;tensor&lt;/code&gt; specifying that operations on &lt;code&gt;tensor&lt;/code&gt; will be invoked on all logical devices.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 API는 현재 TPUStrategy에서만 지원됩니다. 이 텐서에 주석을 추가 &lt;code&gt;tensor&lt;/code&gt; 에 작업 지정하기 &lt;code&gt;tensor&lt;/code&gt; 모든 논리 장치에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="8c8b653893ce9fbd84592d8d34957a9a414da95e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This Op is &lt;em&gt;not&lt;/em&gt; intended to be called by the user; instead users should call &lt;a href=&quot;../einsum&quot;&gt;&lt;code&gt;tf.einsum&lt;/code&gt;&lt;/a&gt; directly. It is a hidden Op used by &lt;a href=&quot;../einsum&quot;&gt;&lt;code&gt;tf.einsum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 Op는 사용자가 호출하기위한 것이 &lt;em&gt;아닙니다&lt;/em&gt; . 대신 사용자는 &lt;a href=&quot;../einsum&quot;&gt; &lt;code&gt;tf.einsum&lt;/code&gt; 을&lt;/a&gt; 직접 호출 해야 합니다. &lt;a href=&quot;../einsum&quot;&gt; &lt;code&gt;tf.einsum&lt;/code&gt; 에서&lt;/a&gt; 사용하는 숨겨진 Op 입니다.</target>
        </trans-unit>
        <trans-unit id="f6b39d6d68564a6317c374f50dd0eb82ce48914f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This condition is validated only when &lt;code&gt;self.validate_args = True&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 조건은 &lt;code&gt;self.validate_args = True&lt;/code&gt; 경우에만 유효합니다 .</target>
        </trans-unit>
        <trans-unit id="4a5f45593b177ed014fb664c9953d383199b5d19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This constructor validates the given &lt;code&gt;name&lt;/code&gt;. Valid scope names match one of the following regular expressions:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 생성자는 주어진 &lt;code&gt;name&lt;/code&gt; 유효성을 검사합니다 . 유효한 범위 이름은 다음 정규식 중 하나와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="addf9a43cfda83ad0b012329b93b808f2a45ef03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This currently only supports self-adjoint operators.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 자체 인접 연산자 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="667d511226df38b3e2b2991bad70aa9a79689f53" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This differs from &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; in that it sets the static shape of the resulting tensor and enforces it at runtime, raising an error if the tensor's runtime shape is incompatible with the specified shape. &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt; sets the static shape of the tensor without enforcing it at runtime, which may result in inconsistencies between the statically-known shape of tensors and the runtime value of tensors.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이는 결과 텐서의 정적 모양을 설정하고 런타임에 적용한다는 점에서 &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; 와 다릅니다 . 텐서의 런타임 모양이 지정된 모양과 호환되지 않으면 오류가 발생합니다. &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; &lt;/a&gt; 는 런타임에 적용하지 않고 텐서의 정적 모양을 설정하므로 정적으로 알려진 텐서의 모양과 텐서의 런타임 값 사이에 불일치가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="721d04669a24a59286489a3baf068c716566d1e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This estimator is also known as wide-n-deep.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 추정기는 광폭 깊이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="e2a1805386356d81621a233e2fc0e9e1d18b5c5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This flag has no effect on functions passed into tf.data transformations as arguments. tf.data functions are never executed eagerly and are always executed as a compiled Tensorflow Graph.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 플래그는 tf.data 변환에 인수로 전달되는 함수에 영향을주지 않습니다. tf.data 함수는 열심히 실행되지 않으며 항상 컴파일 된 Tensorflow 그래프로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4c2ac9d4fa6414ff7ab3aebf23137949e5e53a3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function diverges from default Numpy behavior for &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;string&lt;/code&gt; types when &lt;code&gt;None&lt;/code&gt; is present in a Python list or scalar. Rather than silently converting &lt;code&gt;None&lt;/code&gt; values, an error will be thrown.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수 는 Python 목록 또는 스칼라에 &lt;code&gt;None&lt;/code&gt; 이 있으면 &lt;code&gt;float&lt;/code&gt; 및 &lt;code&gt;string&lt;/code&gt; 유형에 대한 기본 Numpy 동작 과 다릅니다 . &lt;code&gt;None&lt;/code&gt; 값을 자동으로 변환하는 대신 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b60462d09f7f3eb880316a0d7ab83a1e991723a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is executed as a graph function in graph mode. This means: a) Operations on the same resource are executed in textual order. This should make it easier to do things like add the updated value of a variable to another, for example. b) You don't need to worry about collecting the update ops to execute. All update ops added to the graph by this function will be executed. As a result, code should generally work the same way with graph or eager execution.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 그래프 모드에서 그래프 기능으로 실행됩니다. 이것은 다음을 의미합니다. a) 동일한 리소스에 대한 작업이 텍스트 순서로 실행됩니다. 예를 들어 변수의 업데이트 된 값을 다른 변수에 추가하는 등의 작업을보다 쉽게 ​​수행 할 수 있어야합니다. b) 실행하기 위해 업데이트 작업을 수집하는 것에 대해 걱정할 필요가 없습니다. 이 기능으로 그래프에 추가 된 모든 업데이트 작업이 실행됩니다. 결과적으로 코드는 일반적으로 그래프 또는 열성적인 실행과 동일한 방식으로 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="18ac6c678a378be6d0ffdbb37fc4714b8d49dc48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is implemented by trying to fetch the values of the variables. If one of the variables is not initialized a message may be logged by the C++ runtime. This is expected.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 변수 값을 가져 오려고 구현됩니다. 변수 중 하나가 초기화되지 않은 경우 C ++ 런타임에 의해 메시지가 기록 될 수 있습니다. 이것은 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="49f5f75217c4f016c3de1f23a2a0013b9777e82e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function is obsolete and will be removed in 6 months. Please change your implementation to use &lt;code&gt;report_uninitialized_variables()&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 더 이상 사용되지 않으며 6 개월 후에 제거됩니다. &lt;code&gt;report_uninitialized_variables()&lt;/code&gt; 를 사용하도록 구현을 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="b429df736b658ebeb79cde89785c1c06bf47ad86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function will only be available through the v1 compatibility library as tf.compat.v1.saved_model.builder.MethodNameUpdater.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 tf.compat.v1.saved_model.builder.MethodNameUpdater로 v1 호환성 라이브러리를 통해서만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36bf614522f75b69ee7c62cc55a990d0a9ee9206" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This function will only be available through the v1 compatibility library as tf.compat.v1.saved_model.builder.SavedModelBuilder or tf.compat.v1.saved_model.Builder. Tensorflow 2.0 will introduce a new object-based method of creating SavedModels.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 v1 호환성 라이브러리를 통해 tf.compat.v1.saved_model.builder.SavedModelBuilder 또는 tf.compat.v1.saved_model.Builder로만 사용할 수 있습니다. Tensorflow 2.0은 새로운 모델 기반의 저장된 모델 생성 방법을 도입 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="181577a76a3032f2b7835eb21280fd058b8e0490" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This has a shorthand &lt;a href=&quot;linalg/matrix_transpose&quot;&gt;&lt;code&gt;linalg.matrix_transpose&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 여기에는 약칭 &lt;a href=&quot;linalg/matrix_transpose&quot;&gt; &lt;code&gt;linalg.matrix_transpose&lt;/code&gt; 가&lt;/a&gt; 있습니다.)</target>
        </trans-unit>
        <trans-unit id="64a1dd79c36eaee83bade0a3a7d06de10f2ab047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This interface is experimental and expected to change. In particular, we expect to add other implementations of &lt;code&gt;StatsAggregator&lt;/code&gt; that provide different ways of exporting statistics, and add more types of statistics.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 인터페이스는 실험용이며 변경 될 예정입니다. 특히, 통계를 내보내는 다른 방법을 제공하고 더 많은 유형의 통계를 추가하는 다른 &lt;code&gt;StatsAggregator&lt;/code&gt; 구현을 추가 할 것으로 예상됩니다 .</target>
        </trans-unit>
        <trans-unit id="d8be512bebf343dc2e862b3bbe4bd39b775adf69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an escape hatch for existing uses of &lt;code&gt;filter&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;filter&lt;/code&gt; as this method will be removed in V2.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 V2 기능에서 작동하지 않는 기존 &lt;code&gt;filter&lt;/code&gt; 사용을위한 탈출 해치입니다 . 이 방법은 V2에서 제거 되므로 새로운 사용은 권장하지 않으며 기존 사용은 &lt;code&gt;filter&lt;/code&gt; 으로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="702c77478d2787334530aec5bccfbe8498d9e987" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an escape hatch for existing uses of &lt;code&gt;map&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;map&lt;/code&gt; as this method will be removed in V2.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 V2 기능에서 작동하지 않는 기존 &lt;code&gt;map&lt;/code&gt; 사용을위한 탈출 해치입니다 . 이 방법은 V2에서 제거 되므로 새로운 사용은 권장하지 않으며 기존 사용은 &lt;code&gt;map&lt;/code&gt; 으로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="777578106f314f430e45051910e246bc2efa13ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an escape hatch for existing uses of &lt;code&gt;map_and_batch&lt;/code&gt; that do not work with V2 functions. New uses are strongly discouraged and existing uses should migrate to &lt;code&gt;map_and_batch&lt;/code&gt; as this method will not be removed in V2.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 V2 기능에서 작동하지 않는 &lt;code&gt;map_and_batch&lt;/code&gt; 의 기존 사용을위한 이스케이프 해치입니다 . 이 방법은 V2에서 제거되지 않으므로 새로운 사용은 권장되지 않으며 기존 사용은 &lt;code&gt;map_and_batch&lt;/code&gt; 로 마이그레이션해야합니다 .</target>
        </trans-unit>
        <trans-unit id="af66f8d31c5e75082961eb29b1ef3e0e780b3558" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is an experimental feature.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 실험적인 기능입니다.</target>
        </trans-unit>
        <trans-unit id="e66b43ec1cc2e89fca27d94f7c7c3cd357fec78b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not a &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt;. For example, it cannot do following:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 &lt;a href=&quot;../session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; &lt;/a&gt; 이 아닙니다 . 예를 들어 다음을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="680f69c882d4a3e125175dbae072798c55b820a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not guaranteed to be the same ID as the XLA replica ID use for low-level operations such as collective_permute.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 ID는 Collective_permute와 같은 저수준 작업에 사용되는 XLA 복제본 ID와 동일한 ID가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="200269ca4ebd4acb70ed4e09db8e5e3676b83936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is not the same as the &lt;code&gt;self.name_scope.name&lt;/code&gt; which includes parent module names.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이는 상위 모듈 이름을 포함 하는 &lt;code&gt;self.name_scope.name&lt;/code&gt; 과 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e00f08803f031b136a8a8cc06eeae80bfeef6d84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is similar to &lt;a href=&quot;../../sysconfig/get_build_info&quot;&gt;&lt;code&gt;tf.sysconfig.get_build_info&lt;/code&gt;&lt;/a&gt; in that both functions can return information relating to GPUs. However, this function returns run-time information about a specific device (such as a GPU's compute capability), while &lt;a href=&quot;../../sysconfig/get_build_info&quot;&gt;&lt;code&gt;tf.sysconfig.get_build_info&lt;/code&gt;&lt;/a&gt; returns compile-time information about how TensorFlow was built (such as what version of CUDA TensorFlow was built for).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 두 함수 모두 GPU 관련 정보를 반환 할 수 있다는 점 에서 &lt;a href=&quot;../../sysconfig/get_build_info&quot;&gt; &lt;code&gt;tf.sysconfig.get_build_info&lt;/code&gt; &lt;/a&gt; 와 비슷합니다 . 그러나이 함수는 특정 기기 (예 : GPU의 컴퓨팅 기능)에 대한 런타임 정보를 반환 하는 반면 &lt;a href=&quot;../../sysconfig/get_build_info&quot;&gt; &lt;code&gt;tf.sysconfig.get_build_info&lt;/code&gt; &lt;/a&gt; 는 TensorFlow가 빌드 된 방식 (예 : CUDA TensorFlow의 빌드 버전)에 대한 컴파일 시간 정보를 반환합니다. .</target>
        </trans-unit>
        <trans-unit id="f0fe671a61ef8497ccca8956534bfe3bf4b7e3d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is still in testing, and the API may change.**</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 메서드는 아직 테스트 중이며 API가 변경 될 수 있습니다. **</target>
        </trans-unit>
        <trans-unit id="13718771104bd1bfa4ccb2a5be74eba9e7ec3936" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method takes an argument that defines the structure of the value that would be contained in the returned &lt;code&gt;Optional&lt;/code&gt; if it had a value.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 메서드는 값이있는 경우 반환 된 &lt;code&gt;Optional&lt;/code&gt; 에 포함될 값의 구조를 정의하는 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="3c2233b7e7e1565ef6cac7a7426d21199c0b0dd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This modified program still works fine as a single program. The single program marks itself as the chief.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 수정 된 프로그램은 여전히 ​​단일 프로그램으로 잘 작동합니다. 단일 프로그램은 스스로를 최고로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="9073be559455fa6ad8b96d9c3a947d5faec7845d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This only returns values on the worker initiated by this client. When using a &lt;a href=&quot;../../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; like &lt;a href=&quot;../../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, each worker will be its own client, and this function will only return values computed on that worker.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 클라이언트가 시작한 작업자의 값만 반환합니다. &lt;a href=&quot;../../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;../../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 사용하는 경우 각 작업자는 자신의 클라이언트가 되며이 함수는 해당 작업자에서 계산 된 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9651a9fc8d2af68ef6c7da028de30cda41c53d79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This only returns values on the worker initiated by this client. When using a &lt;a href=&quot;../../../distribute/strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; like &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, each worker will be its own client, and this function will only return values computed on that worker.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 클라이언트가 시작한 작업자의 값만 반환합니다. &lt;a href=&quot;../../../distribute/strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;../../../distribute/experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 사용하는 경우 각 작업자는 자신의 클라이언트가 되며이 함수는 해당 작업자에서 계산 된 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eaad4572315df131e24a653938c3f3338f0038e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This only returns values on the worker initiated by this client. When using a &lt;a href=&quot;../strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; like &lt;a href=&quot;multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, each worker will be its own client, and this function will only return values computed on that worker.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 클라이언트가 시작한 작업자의 값만 반환합니다. &lt;a href=&quot;../strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 사용하는 경우 각 작업자는 자신의 클라이언트가 되며이 함수는 해당 작업자에서 계산 된 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="21e19757e1e6e0746c43f395ca50e5f1bb6bff6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This only returns values on the worker initiated by this client. When using a &lt;a href=&quot;strategy&quot;&gt;&lt;code&gt;tf.distribute.Strategy&lt;/code&gt;&lt;/a&gt; like &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, each worker will be its own client, and this function will only return values computed on that worker.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 클라이언트가 시작한 작업자의 값만 반환합니다. &lt;a href=&quot;strategy&quot;&gt; &lt;code&gt;tf.distribute.Strategy&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;a href=&quot;experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 사용하는 경우 각 작업자는 자신의 클라이언트가 되며이 함수는 해당 작업자에서 계산 된 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f5c4a626e9c85c3c7f5795905fc7ab4a5168277" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This op prints to the standard error. It is not currently compatible with jupyter notebook (printing to the notebook &lt;em&gt;server's&lt;/em&gt; output, not into the notebook).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 op는 표준 오류로 인쇄됩니다. 현재 jupyter 노트북 (노트북이 아닌 노트북 &lt;em&gt;서버의&lt;/em&gt; 출력에 인쇄)과 호환 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ac6b9111cdcc3d0dcebd0e24d08476f2a6b6a61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This operation does not support integer types.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 작업은 정수 유형을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f3c19c29b8971dfcb10b2ef91482ef6597eb574" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This operation is not supported by all queues. If a queue does not support DequeueUpTo, then a &lt;a href=&quot;../errors/unimplementederror&quot;&gt;&lt;code&gt;tf.errors.UnimplementedError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 작업은 모든 대기열에서 지원되지 않습니다. 대기열이 DequeueUpTo를 지원하지 않으면 &lt;a href=&quot;../errors/unimplementederror&quot;&gt; &lt;code&gt;tf.errors.UnimplementedError&lt;/code&gt; &lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9ef082186ade2149cd103c398e1eade461a6fe90" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This operation must run on the same device as its input. This may be enforced via the &lt;code&gt;colocate_with&lt;/code&gt; mechanism.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 작업은 입력과 동일한 장치에서 실행해야합니다. 이것은 &lt;code&gt;colocate_with&lt;/code&gt; 메커니즘을 통해 시행 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d0f4dd8db8f6f9c15ccbddb1483f70c4a84cb8d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This overrides default initialization ops of specified variables and redefines dtype.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이는 지정된 변수의 기본 초기화 작업을 무시하고 dtype을 재정의합니다.</target>
        </trans-unit>
        <trans-unit id="ceae0ce07d554d0617d745e71e2cc5d53f076d17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This should only be called outside of any TensorFlow scope to avoid improper nesting.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 부적절한 중첩을 피하기 위해 TensorFlow 범위 밖에서 만 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="936de133ea96674bf984ff570538d32123edbaae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This strategy only works with the Estimator API. Pass an instance of this strategy to the &lt;code&gt;experimental_distribute&lt;/code&gt; argument when you create the &lt;code&gt;RunConfig&lt;/code&gt;. This instance of &lt;code&gt;RunConfig&lt;/code&gt; should then be passed to the &lt;code&gt;Estimator&lt;/code&gt; instance on which &lt;code&gt;train_and_evaluate&lt;/code&gt; is called.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 전략은 Estimator API에서만 작동합니다. &lt;code&gt;RunConfig&lt;/code&gt; 를 작성할 때이 전략의 인스턴스를 &lt;code&gt;experimental_distribute&lt;/code&gt; 인수에 전달하십시오 . 그런 다음이 &lt;code&gt;RunConfig&lt;/code&gt; 인스턴스를 &lt;code&gt;Estimator&lt;/code&gt; &lt;code&gt;train_and_evaluate&lt;/code&gt; 가 호출 되는 Estimator 인스턴스 .</target>
        </trans-unit>
        <trans-unit id="9c88b61312f02630239be05135cd02c96e73948a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This will zero-out the file. This ensures there is no pre-existing state. NOTE: If the file already exists, it will be made writable and overwritten.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이렇게하면 파일이 제로 아웃됩니다. 이렇게하면 기존 상태가 없습니다. 참고 : 파일이 이미 존재하는 경우 쓰기 가능하고 덮어 쓰게됩니다.</target>
        </trans-unit>
        <trans-unit id="0bc2f55b5fd94dbd3f35ecb564066b2452af154b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Unlike &lt;a href=&quot;../expand_dims&quot;&gt;&lt;code&gt;tf.expand_dims&lt;/code&gt;&lt;/a&gt; this function includes a default value for the &lt;code&gt;axis&lt;/code&gt;: &lt;code&gt;-1&lt;/code&gt;. So if `axis is not specified, an inner dimension is added.</source>
          <target state="translated">&lt;strong&gt;주 :&lt;/strong&gt; 달리 &lt;a href=&quot;../expand_dims&quot;&gt; &lt;code&gt;tf.expand_dims&lt;/code&gt; &lt;/a&gt; 이 함수에 대한 디폴트 값을 포함하는 &lt;code&gt;axis&lt;/code&gt; : &lt;code&gt;-1&lt;/code&gt; . 따라서`axis가 지정되지 않은 경우 내부 차원이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="bbef03f4e2db8bcd7a7cb2a9491e3b7c25e9ed97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Unlike what is described in the paper and unlike what is used in the Scikit-Learn implementation, the output of this layer does not apply the &lt;code&gt;sqrt(2 / D)&lt;/code&gt; normalization factor.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 백서에 설명 된 것과 Scikit-Learn 구현에 사용 된 것과 달리이 레이어의 출력은 &lt;code&gt;sqrt(2 / D)&lt;/code&gt; 정규화 인자를 적용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c1e33ec7a61bac95e9398677153286c4369aa0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Using a colocation scope resets any existing device constraints.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 코 로케이션 범위를 사용하면 기존 장치 제약 조건이 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="41d488c819bc6c83574884e422acc9a23a3aeb37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We do not support creating weighted metrics in Keras and converting them to weighted metrics in the Estimator API using &lt;code&gt;model_to_estimator&lt;/code&gt;. You will have to create these metrics directly on the estimator spec using the &lt;code&gt;add_metrics&lt;/code&gt; function.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;model_to_estimator&lt;/code&gt; 에서 가중치 측정 항목을 생성하고 model_to_estimator를 사용하여 Estimator API에서 가중치 측정 항목으로 변환하는 것을 지원하지 않습니다 . &lt;code&gt;add_metrics&lt;/code&gt; 함수를 사용하여 에스티 메이터 사양에서 직접 이러한 메트릭을 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f7b4fdb6d1b7eaa78faa3746a3bfb56ccc5ab7fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; We use element names that are consistent with those used by the C++ command-line flag library, from &lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt; We also use a few new elements (e.g.,</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://github.com/gflags/gflags&quot;&gt;https://github.com/gflags/gflags&lt;/a&gt; 에서 C ++ 명령 줄 플래그 라이브러리에서 사용하는 것과 일치하는 요소 이름을 사용합니다. 또한 몇 가지 새로운 요소 (예 :</target>
        </trans-unit>
        <trans-unit id="fa4eb49e1a736787fc1ab316337724caba0dccc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When instantiated under a TPUStrategy, this class can only be created once per call to &lt;a href=&quot;../initialize_tpu_system&quot;&gt;&lt;code&gt;tf.tpu.experimental.initialize_tpu_system&lt;/code&gt;&lt;/a&gt;. If you wish to re-initialize the embedding engine you must re-initialize the tpu as well. Doing this will clear any variables from TPU, so ensure you have checkpointed before you do this. If a further instances of the class are needed, set the &lt;code&gt;initialize_tpu_embedding&lt;/code&gt; argument to &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; TPUStrategy에서 인스턴스화 할 때이 클래스는 &lt;a href=&quot;../initialize_tpu_system&quot;&gt; &lt;code&gt;tf.tpu.experimental.initialize_tpu_system&lt;/code&gt; &lt;/a&gt; 호출 당 한 번만 만들 수 있습니다 . 임베딩 엔진을 다시 초기화하려면 tpu도 다시 초기화해야합니다. 이렇게하면 TPU에서 모든 변수가 지워 지므로이 작업을 수행하기 전에 체크 포인트가 있는지 확인하세요. 클래스의 추가 인스턴스가 필요한 경우 &lt;code&gt;initialize_tpu_embedding&lt;/code&gt; 인수를 &lt;code&gt;False&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a8309e46682c6a53c25a9d2670828ec614cff077" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When restoring the iterator, the existing iterator state is completely discarded. This means that any changes you may have made to the Dataset graph will be discarded as well! This includes the new Dataset graph that you may have built during validation. So, while running validation, make sure to run the initializer for the validation input pipeline after restoring the checkpoint.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 반복기를 복원 할 때 기존 반복기 상태는 완전히 삭제됩니다. 이는 데이터 세트 그래프에 대한 모든 변경 사항도 무시됨을 의미합니다! 여기에는 검증 중에 구축했을 수있는 새로운 데이터 세트 그래프가 포함됩니다. 따라서 유효성 검사를 실행하는 동안 검사 점을 복원 한 후 유효성 검사 입력 파이프 라인에 대한 이니셜 라이저를 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="0d1008a565c1268e0214ce9f6d649d89767e5649" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When using symbolic tensors, such as when using the Keras API, tf.shape() will return the shape of the symbolic tensor.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Keras API를 사용할 때와 같이 기호 텐서를 사용할 때 tf.shape ()는 기호 텐서의 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8bd8116a9c6f220f4668f23e39068564cae3256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; When using symbolic tensors, such as when using the Keras functional API, tf.shape() will return the shape of the symbolic tensor.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; Keras 기능 API를 사용할 때와 같이 기호 텐서를 사용하면 tf.shape ()는 기호 텐서의 모양을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ce267c5a9ca5393b4bb75f2369d161385827c28" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; While the classes are mutually exclusive, their probabilities need not be. All that is required is that each row of &lt;code&gt;labels&lt;/code&gt; is a valid probability distribution. If they are not, the computation of the gradient will be incorrect.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 클래스는 상호 배타적이지만 확률은 그럴 필요가 없습니다. 필요한 것은 &lt;code&gt;labels&lt;/code&gt; 각 행이 유효한 확률 분포라는 것입니다. 그렇지 않으면 그래디언트 계산이 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="0a339d196d1b15614e859cfbb182dbc2530cdc17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; While the mixed precision rewrite changes the datatype of various layers throughout the model, the same accuracy reached in float32 is expected. If a &lt;code&gt;NaN&lt;/code&gt; gradient occurs with dynamic loss scaling, the model update for that batch is skipped. In this case, the global step count is not incremented, and the &lt;code&gt;LossScaleOptimizer&lt;/code&gt; attempts to decrease the loss scaling value to avoid &lt;code&gt;NaN&lt;/code&gt; values in subsequent iterations. This approach has been shown to achieve the same accuracy as float32 and, in most cases, better training throughput.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 혼합 정밀도 재 작성은 모델 전체에서 다양한 레이어의 데이터 유형을 변경하지만 float32에서 도달 한 것과 동일한 정확도가 예상됩니다. 동적 손실 스케일링 으로 &lt;code&gt;NaN&lt;/code&gt; 그라디언트가 발생하면 해당 배치의 모델 업데이트를 건너 뜁니다. 이 경우, 전체 단계 수는 증가하지 않으며 &lt;code&gt;LossScaleOptimizer&lt;/code&gt; 는 &lt;code&gt;NaN&lt;/code&gt; 을 피하기 위해 손실 스케일링 값을 낮추려고 시도합니다. 후속 반복에서 값 . 이 접근법은 float32와 동일한 정확도를 달성하고 대부분의 경우 더 나은 교육 처리량을 달성하는 것으로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="96c1c0bbbeb0d1377961b3fce8a14a9e63e9fcc9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Will be removed in TensorFlow 2.x since DeviceSpecs will become immutable.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; DeviceSpecs는 변경할 수 없으므로 TensorFlow 2.x에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="a33715a77ce3cb00bf502c3145c122109e67b2b2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You must ensure that either (i) the &lt;code&gt;shapes&lt;/code&gt; argument is passed, or (ii) all of the tensors in &lt;code&gt;tensors&lt;/code&gt; must have fully-defined shapes. &lt;code&gt;ValueError&lt;/code&gt; will be raised if neither of these conditions holds.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; (i) &lt;code&gt;shapes&lt;/code&gt; 인수가 전달 되었는지 또는 (ii) 텐서의 모든 &lt;code&gt;tensors&lt;/code&gt; 가 완전히 정의 된 형태를 가져야합니다. 이러한 조건이 모두 충족되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="98fd8281cf7dfd2920b180c5eb7253914145ace8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You rarely need to call &lt;code&gt;unique_name()&lt;/code&gt; directly. Most of the time you just need to create &lt;code&gt;with g.name_scope()&lt;/code&gt; blocks to generate structured names.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;unique_name()&lt;/code&gt; 직접 호출 할 필요는 거의 없습니다 . 대부분의 경우 구조화 된 이름을 생성 하기 위해 &lt;code&gt;with g.name_scope()&lt;/code&gt; 블록으로 만들어야 합니다.</target>
        </trans-unit>
        <trans-unit id="f8c20bb2528737bbd8309e6cb76ed636bf6ac2cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; You should specify &lt;code&gt;training=True&lt;/code&gt; when using &lt;code&gt;embedding.apply_gradients&lt;/code&gt; as above and &lt;code&gt;training=False&lt;/code&gt; when not using &lt;code&gt;embedding.apply_gradients&lt;/code&gt; (e.g. for frozen embeddings or when doing evaluation).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 당신은 지정해야 &lt;code&gt;training=True&lt;/code&gt; 사용하는 경우 &lt;code&gt;embedding.apply_gradients&lt;/code&gt; 을 위와 같이하고 &lt;code&gt;training=False&lt;/code&gt; 사용하지 않을 경우 &lt;code&gt;embedding.apply_gradients&lt;/code&gt; 를 (예를 들어, 냉동 묻어 또는 평가를 수행하기위한).</target>
        </trans-unit>
        <trans-unit id="565fb9e8148a2d7b94b5e6a5a0a2fca30e8e539c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; creates local counter &lt;code&gt;epochs&lt;/code&gt;. Use &lt;code&gt;local_variables_initializer()&lt;/code&gt; to initialize local variables.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 로컬 카운터 &lt;code&gt;epochs&lt;/code&gt; 만듭니다 . 사용 &lt;code&gt;local_variables_initializer()&lt;/code&gt; 를 하여 로컬 변수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="ca3e9618bf8e3b767a07b520a159d422c02b3f3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; error checking is done on a best-effort basis, and errors aren't guaranteed to be caught upon dataset creation. (e.g. providing in a placeholder tensor bypasses the early checking, and will instead result in an error during a session.run call.)</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 오류 검사는 최선을 다해 수행되며 데이터 세트 생성시 오류가 포착되지 않을 수도 있습니다. (예를 들어 자리 표시 자 텐서를 제공하면 초기 검사를 우회하고 대신 session.run 호출 중에 오류가 발생합니다.)</target>
        </trans-unit>
        <trans-unit id="7dcdd2dfa04c5fb9401aa9259515aa7abb6223e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; even if &lt;code&gt;b&lt;/code&gt; is zero, the sparsity structure of the output does not change.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;b&lt;/code&gt; 가 0 이더라도 출력의 희소성 구조는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02658220fc38b691eb47d246ccef86b0c13c1b11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;, then this operation takes &lt;code&gt;O(N)&lt;/code&gt; time, where &lt;code&gt;N&lt;/code&gt; is the number of elements in the squeezed dimensions.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 만약 &lt;code&gt;input&lt;/code&gt; A는 &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; ,이 동작에 걸리는 &lt;code&gt;O(N)&lt;/code&gt; 여기서, 시간 &lt;code&gt;N&lt;/code&gt; 을 압착 차원의 요소 수이다.</target>
        </trans-unit>
        <trans-unit id="d873e10c47b3ad276946e5e8fc02a9c21d342c45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if &lt;code&gt;input&lt;/code&gt; is a &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;, then this operation takes &lt;code&gt;O(N)&lt;/code&gt; time, where &lt;code&gt;N&lt;/code&gt; is the number of elements in the squeezed dimensions.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 만약 &lt;code&gt;input&lt;/code&gt; A는 &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; ,이 동작에 걸리는 &lt;code&gt;O(N)&lt;/code&gt; 여기서, 시간 &lt;code&gt;N&lt;/code&gt; 을 압착 차원의 요소 수이다.</target>
        </trans-unit>
        <trans-unit id="b7b25d4b2cecc5883d042c6dae3da87faad53e6c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if &lt;code&gt;num_epochs&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, this function creates local counter &lt;code&gt;epochs&lt;/code&gt;. Use &lt;code&gt;local_variables_initializer()&lt;/code&gt; to initialize local variables.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;num_epochs&lt;/code&gt; 가 되지 않습니다 &lt;code&gt;None&lt;/code&gt; ,이 기능은 로컬 카운터 생성 &lt;code&gt;epochs&lt;/code&gt; . 사용 &lt;code&gt;local_variables_initializer()&lt;/code&gt; 를 하여 로컬 변수를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="378d8f8fd5040d982fca462d5dc323100e80eaad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if &lt;code&gt;output_is_sparse&lt;/code&gt; is True, a gradient is not defined for this function, so it can't be used in training models that need gradient descent.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 경우 &lt;code&gt;output_is_sparse&lt;/code&gt; 가 True 인이 그라데이션 하강을 필요로 교육 모델에서 사용할 수 없습니다, 그래서 그라데이션는이 함수를 위해 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="52d3f1e304a7f955479465e1fff9d60004aa2fe1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if you use the &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; decorator, any non-TensorFlow Python code that you may have written in your function won't get executed. See &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; for more details. The recommendation would be to debug without &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; but switch to it to get performance benefits of running &lt;code&gt;map_fn&lt;/code&gt; in parallel.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 데코레이터 를 사용하는 경우 함수에 작성했을 수있는 TensorFlow가 아닌 ​​Python 코드는 실행되지 않습니다. 자세한 내용은 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 을 참조하십시오. 권장 사항은 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 없이 디버깅 하는 &lt;code&gt;map_fn&lt;/code&gt; , map_fn 을 병렬 로 실행하여 성능 이점을 얻으려면 전환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="90a43fa1c1cf4052ed368d95308014e45193e0df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; if you use the &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; decorator, any non-TensorFlow Python code that you may have written in your function won't get executed. See &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; for more details. The recommendation would be to debug without &lt;a href=&quot;function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt; but switch to it to get performance benefits of running &lt;code&gt;map_fn&lt;/code&gt; in parallel.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 데코레이터 를 사용하는 경우 함수에 작성했을 수있는 TensorFlow가 아닌 ​​Python 코드는 실행되지 않습니다. 자세한 내용은 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 을 참조하십시오. 권장 사항은 &lt;a href=&quot;function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; 없이 디버깅 하는 &lt;code&gt;map_fn&lt;/code&gt; , map_fn 을 병렬 로 실행하여 성능 이점을 얻으려면 전환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7db9c211e04257ba6705041699c5ecfbc35da9a2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; in the docstrings of all DEFINE* functions, &quot;registers&quot; is short for &quot;creates a new flag and registers it&quot;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 모든 DEFINE * 함수의 독 스트링에서 &quot;registers&quot;는 &quot;새 플래그를 만들고 등록합니다&quot;의 약자입니다.</target>
        </trans-unit>
        <trans-unit id="32684035190ec91e3765f6721c30db404817fc31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; it cannot retrieve &lt;code&gt;task_type&lt;/code&gt;, &lt;code&gt;task_id&lt;/code&gt; or &lt;code&gt;rpc_layer&lt;/code&gt;. To use it with some distribution strategies like &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, you will need to specify &lt;code&gt;task_type&lt;/code&gt; and &lt;code&gt;task_id&lt;/code&gt; by setting these attributes.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;task_type&lt;/code&gt; , &lt;code&gt;task_id&lt;/code&gt; 또는 &lt;code&gt;rpc_layer&lt;/code&gt; 는 검색 할 수 없습니다 . &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 와 같은 일부 배포 전략과 함께 사용하려면 이러한 속성을 설정하여 &lt;code&gt;task_type&lt;/code&gt; 및 &lt;code&gt;task_id&lt;/code&gt; 를 지정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="44817aeb6844f63adfe893852dae4cc3924b10f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; layer attributes cannot be modified after the layer has been called once (except the &lt;code&gt;trainable&lt;/code&gt; attribute).</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 레이어 속성은 레이어가 한 번 호출 된 후에 수정할 수 없습니다 ( &lt;code&gt;trainable&lt;/code&gt; 속성 제외 ).</target>
        </trans-unit>
        <trans-unit id="47fb5575dc3f3082c051b92e8d88ecd3696b25fa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; multiple &lt;code&gt;FeatureConfig&lt;/code&gt; objects can use the same &lt;code&gt;TableConfig&lt;/code&gt; object, allowing different features to share the same table:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 여러 &lt;code&gt;FeatureConfig&lt;/code&gt; 객체가 동일한 &lt;code&gt;TableConfig&lt;/code&gt; 객체를 사용할 수 있으므로 서로 다른 기능이 동일한 테이블을 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="906642102a8aec54040c5311989acb8f23ef92ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; shift is currently not used; the true mean is computed and used.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 현재 shift는 사용되지 않습니다. 진정한 평균이 계산되어 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e0129ef18259388a0ff347368d70038a60b7cc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the copy distribution may continue to depend on the original initialization arguments.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 사본 배포는 원래 초기화 인수에 계속 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18f1737b16509fdafe607a371af3d21966100e19" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the implementation follows &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html&quot;&gt;&lt;code&gt;numpy.allclose&lt;/code&gt;&lt;/a&gt; (and numpy.testing.assert_allclose). It checks whether two arrays are element-wise equal within a tolerance. The relative difference (&lt;code&gt;rtol * abs(b)&lt;/code&gt;) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 구현은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/generated/numpy.allclose.html&quot;&gt; &lt;code&gt;numpy.allclose&lt;/code&gt; &lt;/a&gt; (및 numpy.testing.assert_allclose)를 따릅니다. 두 배열이 공차 내에서 요소별로 동일한 지 확인합니다. 상대 차이 ( &lt;code&gt;rtol * abs(b)&lt;/code&gt; ) 및 절대 차이 &lt;code&gt;atol&lt;/code&gt; 을 함께 더해 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 절대 차이와 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="09f0a8a327483b26bd492c96cad9d0d37124ecc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the newer &lt;code&gt;AutoTrackable&lt;/code&gt; API is not supported by &lt;code&gt;Saver&lt;/code&gt;. In this case, the &lt;a href=&quot;../../../train/checkpoint&quot;&gt;&lt;code&gt;tf.train.Checkpoint&lt;/code&gt;&lt;/a&gt; class should be used.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 최신 &lt;code&gt;AutoTrackable&lt;/code&gt; API는 &lt;code&gt;Saver&lt;/code&gt; 에서 지원되지 않습니다 . 이 경우 &lt;a href=&quot;../../../train/checkpoint&quot;&gt; &lt;code&gt;tf.train.Checkpoint&lt;/code&gt; &lt;/a&gt; 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8541934342970715284958c1f30fc2ff55d7845f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; the timestamp is computed when the op is executed, not when it is added to the graph.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; 타임 스탬프는 그래프에 추가 될 때가 아니라 op가 실행될 때 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b1a2cc32f5075212dc76f5da3b76a37ed35448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this cluster resolver cannot retrieve &lt;code&gt;task_type&lt;/code&gt;, &lt;code&gt;task_id&lt;/code&gt; or &lt;code&gt;rpc_layer&lt;/code&gt;. To use it with some distribution strategies like &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt;&lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt;&lt;/a&gt;, you will need to specify &lt;code&gt;task_type&lt;/code&gt; and &lt;code&gt;task_id&lt;/code&gt; in the constructor.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 클러스터 해석기는 &lt;code&gt;task_type&lt;/code&gt; , &lt;code&gt;task_id&lt;/code&gt; 또는 &lt;code&gt;rpc_layer&lt;/code&gt; 를 검색 할 수 없습니다 . &lt;a href=&quot;../experimental/multiworkermirroredstrategy&quot;&gt; &lt;code&gt;tf.distribute.experimental.MultiWorkerMirroredStrategy&lt;/code&gt; &lt;/a&gt; 와 같은 일부 배포 전략과 함께 사용하려면 생성자에서 &lt;code&gt;task_type&lt;/code&gt; 및 &lt;code&gt;task_id&lt;/code&gt; 를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7722ecc3e42be19089627df7fe0d1efdb2dd4a40" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this function does not verify the implied matrix is actually invertible nor is this condition checked even when &lt;code&gt;validate_args=True&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 함수는 암시 적 행렬이 실제로 뒤집을 수 있는지 확인하지 않으며 &lt;code&gt;validate_args=True&lt;/code&gt; 인 경우에도이 조건을 확인하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f0572fbc1fb7588f4a052f10be2500e68627de9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this function is not for public use, only for internal libraries.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 기능은 공용 용이 아니며 내부 라이브러리 전용입니다.</target>
        </trans-unit>
        <trans-unit id="901ff7aea250aad6a580da2e6b367d93572157c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this is an experimental API and subject to changes.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 API는 실험용이며 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fb5e9c9117296d729cc4c0ac6e6799364b99e38" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this is only useful for TensorFlow 1.x.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 TensorFlow 1.x에만 유용합니다.</target>
        </trans-unit>
        <trans-unit id="05316d933fd19a494bcc101bd2a7cf1d9c25b691" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; this method uses reflection to find variables on the current instance and submodules. For performance reasons you may wish to cache the result of calling this method if you don't expect the return value to change.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 방법은 리플렉션을 사용하여 현재 인스턴스 및 하위 모듈에서 변수를 찾습니다. 성능상의 이유로 반환 값이 변경되지 않을 경우이 메서드를 호출 한 결과를 캐시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b271218c90bd94a2719d1107f9eadc9109fbdae0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; though similar to Python's I/O implementation, there are semantic differences to make &lt;a href=&quot;../gfile&quot;&gt;&lt;code&gt;tf.io.gfile&lt;/code&gt;&lt;/a&gt; more efficient for backing filesystems. For example, a write mode file will not be opened until the first write call, to minimize RPC invocations in network filesystems.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; Python의 I / O 구현과 유사하지만 &lt;a href=&quot;../gfile&quot;&gt; &lt;code&gt;tf.io.gfile&lt;/code&gt; 을&lt;/a&gt; 파일 시스템 백업에보다 효율적 으로 만드는 의미 상 차이가 있습니다. 예를 들어, 쓰기 모드 파일은 네트워크 파일 시스템에서 RPC 호출을 최소화하기 위해 첫 번째 쓰기 호출이있을 때까지 열리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2493e9ebd9cb9464d4fe706b693bb928f6cf5350" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; v2 control flow is always enabled inside of tf.function.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; v2 제어 플로우는 항상 tf.function 내에서 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="5e0cdc927c149c7c11603690e16b6cad02eb8fda" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; v2 control flow is always enabled inside of tf.function. Calling this function has no effect in that case.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; v2 제어 플로우는 항상 tf.function 내에서 사용 가능합니다. 이 경우이 함수를 호출해도 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="726f5169354d6badf322e0de77f82d10c2404cce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; v2 control flow is always enabled inside of tf.function. Calling this function is not required.</source>
          <target state="translated">&lt;strong&gt;노트 :&lt;/strong&gt; v2 제어 플로우는 항상 tf.function 내에서 사용 가능합니다. 이 기능을 호출 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="dd41042d27925cd4404627a2b5417c03f44d5354" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; we use strings, and not the types.*Type constants because our flags can have more exotic types, e.g., 'comma separated list of strings', 'whitespace separated list of strings', etc.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 우리의 플래그는 '쉼표로 구분 된 문자열 목록', '공백으로 구분 된 문자열 목록'등과 같은 더 이국적인 유형을 가질 수 있기 때문에 유형이 아닌 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5699a3a3fc12877ba22447cec0476d2eb466924b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when doing embedding lookup on &lt;code&gt;embedding_weights&lt;/code&gt;, &quot;div&quot; partition strategy will be used. Support for other partition strategy will be added later.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 에 조회 삽입 할 때 &lt;code&gt;embedding_weights&lt;/code&gt; , &quot;DIV&quot;파티션 전략이 사용됩니다. 다른 파티션 전략에 대한 지원은 나중에 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="555f802e9ab2d7e5df5ef38ed025791b22a72e18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when doing embedding lookup on &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;bias&lt;/code&gt;, &quot;div&quot; partition strategy will be used. Support for other partition strategy will be added later.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt; &lt;code&gt;weights&lt;/code&gt; 및 &lt;code&gt;bias&lt;/code&gt; 에 대한 내장 조회를 수행 할 때 &quot;div&quot;분할 전략이 사용됩니다. 다른 파티션 전략에 대한 지원은 나중에 추가 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="c9def8680fc7e1f80e2baf97e19921cfaed39f17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when training, the moving_mean and moving_variance need to be updated. By default the update ops are placed in &lt;code&gt;tf.GraphKeys.UPDATE_OPS&lt;/code&gt;, so they need to be executed alongside the &lt;code&gt;train_op&lt;/code&gt;. Also, be sure to add any batch_normalization ops before getting the update_ops collection. Otherwise, update_ops will be empty, and training/inference will not work properly. For example:</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 학습시 moving_mean 및 moving_variance를 업데이트해야합니다. 기본적으로 업데이트 작업은 &lt;code&gt;tf.GraphKeys.UPDATE_OPS&lt;/code&gt; 에 배치 되므로 &lt;code&gt;train_op&lt;/code&gt; 와 함께 실행해야합니다 . 또한 update_ops 컬렉션을 가져 오기 전에 batch_normalization ops를 추가하십시오. 그렇지 않으면 update_ops가 비어 있고 교육 / 추론이 제대로 작동하지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e6e9b25a9380919eb2569d94b193ad5770e4823" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; when using this with @tf.functions, the step value will be captured at the time the function is traced, so changes to the step outside the function will not be reflected inside the function unless using a &lt;a href=&quot;../../variable&quot;&gt;&lt;code&gt;tf.Variable&lt;/code&gt;&lt;/a&gt; step.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; @ tf.functions와 함께 사용하면 함수가 추적 될 때 단계 값이 캡처되므로 &lt;a href=&quot;../../variable&quot;&gt; &lt;code&gt;tf.Variable&lt;/code&gt; &lt;/a&gt; 단계를 사용하지 않으면 함수 외부 단계의 변경 사항이 함수 내부에 반영되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="2fe87258f924e45c7b40de4da0a472ef023d3253" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; with large batch sizes, the computation on the GPU may be slow, if either &lt;code&gt;partial_pivoting=True&lt;/code&gt; or there are multiple right-hand sides (&lt;code&gt;K &amp;gt; 1&lt;/code&gt;). If this issue arises, consider if it's possible to disable pivoting and have &lt;code&gt;K = 1&lt;/code&gt;, or, alternatively, consider using CPU.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 큰 배치 크기의 경우 &lt;code&gt;partial_pivoting=True&lt;/code&gt; 이거나 오른쪽이 여러 개 ( &lt;code&gt;K &amp;gt; 1&lt;/code&gt; ) 인 경우 GPU에서 계산이 느려질 수 있습니다 . 이 문제가 발생하면 피벗을 비활성화하고 &lt;code&gt;K = 1&lt;/code&gt; 가질 수 있는지 고려 하거나 CPU 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bcd917828cf85f44184034bdbcf3bb8a81a3480d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;math.add&lt;/code&gt;&lt;/a&gt; supports broadcasting. &lt;code&gt;AddN&lt;/code&gt; does not. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;math.add&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스팅을 지원합니다. &lt;code&gt;AddN&lt;/code&gt; 은 그렇지 않습니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="588a7ad9cb201350ac8da930f199a386745168cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="8d527f734b1bd6271c3f1320aca4d478865f8763" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="96ec5f512a52f78a223fbb1fc2acb8c722e7d272" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스팅을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="f1384822bb42ae9f2722da31c1adcb1891880524" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/less&quot;&gt;&lt;code&gt;math.less&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/less&quot;&gt; &lt;code&gt;math.less&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="6df61ac2cd4f4bce1248dc4dc9f7d245bbfc6705" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/less_equal&quot;&gt;&lt;code&gt;math.less_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/less_equal&quot;&gt; &lt;code&gt;math.less_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스팅을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="c1642beaced747f1b00bb8867ea035b43c948a4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/logical_or&quot;&gt;&lt;code&gt;math.logical_or&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/logical_or&quot;&gt; &lt;code&gt;math.logical_or&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="fd00909bea343af2b33fc8eeaad71f3b2cdf8748" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;../math/squared_difference&quot;&gt;&lt;code&gt;math.squared_difference&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;../math/squared_difference&quot;&gt; &lt;code&gt;math.squared_difference&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="42ec377314a4823e5ff40fb1cfeef06486f5364c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;add&quot;&gt;&lt;code&gt;math.add&lt;/code&gt;&lt;/a&gt; supports broadcasting. &lt;code&gt;AddN&lt;/code&gt; does not. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;add&quot;&gt; &lt;code&gt;math.add&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스팅을 지원합니다. &lt;code&gt;AddN&lt;/code&gt; 은 그렇지 않습니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="f1e07fee326c1255b28dfecfd1cf0a97b6fe9d78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;distributeddataset&quot;&gt;&lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt;&lt;/a&gt; instances are &lt;em&gt;not&lt;/em&gt; of type &lt;a href=&quot;../data/dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt;. It only supports two usages we will mention below: iteration and &lt;code&gt;element_spec&lt;/code&gt;. We don't support any other APIs to transform or inspect the dataset.</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;distributeddataset&quot;&gt; &lt;code&gt;tf.distribute.DistributedDataset&lt;/code&gt; 의&lt;/a&gt; 인스턴스는 &lt;em&gt;없는&lt;/em&gt; 타입의 &lt;a href=&quot;../data/dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; . 아래에서 언급 할 두 가지 사용법, iteration 및 &lt;code&gt;element_spec&lt;/code&gt; 만 지원합니다 . 데이터 세트를 변환하거나 검사하기위한 다른 API는 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8d1ac54822583230419dd2d3c2f3c4c73ed99b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="f8a6ef57e0d61e64bda6543865c9e31380b0f567" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="f7dbbdba9a500ccfdecdea5e2d10d86bb3157028" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스팅을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="f43237b2cbab63dd8293cbc3271a147bfdfd0b8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/floormod&quot;&gt;&lt;code&gt;math.floormod&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/floormod&quot;&gt; &lt;code&gt;math.floormod&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="551deb8a108562f230e7c43a4d377fd0c3552109" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/greater&quot;&gt;&lt;code&gt;math.greater&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/greater&quot;&gt; &lt;code&gt;math.greater&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="3cd3be1bdda38e956a0c94f6e0dbc37704b3ba27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/greater_equal&quot;&gt;&lt;code&gt;math.greater_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/greater_equal&quot;&gt; &lt;code&gt;math.greater_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스팅을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="0d7c60b79e06313b2f63e2ef1daefea6e453df8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/less&quot;&gt;&lt;code&gt;math.less&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/less&quot;&gt; &lt;code&gt;math.less&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="e093530ee35bc2c30bc616eb1cac7342b08e48b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/less_equal&quot;&gt;&lt;code&gt;math.less_equal&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/less_equal&quot;&gt; &lt;code&gt;math.less_equal&lt;/code&gt; &lt;/a&gt; 은 브로드 캐스팅을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
        <trans-unit id="90b62d3db60aa3e2e949cc00e027dcd3a31ec0c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/logical_or&quot;&gt;&lt;code&gt;math.logical_or&lt;/code&gt;&lt;/a&gt; supports broadcasting. More about broadcasting &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : &lt;/strong&gt;&lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/math/logical_or&quot;&gt; &lt;code&gt;math.logical_or&lt;/code&gt; &lt;/a&gt; 는 방송을 지원합니다. &lt;a href=&quot;http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아보기</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
