<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="tensorflow">
    <body>
      <group id="tensorflow">
        <trans-unit id="b55a60b064830f9883032828fbe6f4b068812e2f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enqueue_many&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;tensors_list[i]&lt;/code&gt; is assumed to represent a batch of examples, where the first dimension is indexed by example, and all members of &lt;code&gt;tensors_list[i]&lt;/code&gt; should have the same size in the first dimension. The slices of any input tensor &lt;code&gt;x&lt;/code&gt; are treated as examples, and the output tensors will have shape &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;enqueue_many&lt;/code&gt; 가 인 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;tensors_list[i]&lt;/code&gt; 제 치수 예에 의해 인덱싱 예제의 배치를 나타내는 것으로 가정하고, 모든 멤버 &lt;code&gt;tensors_list[i]&lt;/code&gt; 제 차원에서 동일한 크기를 가져야한다. 입력 텐서 &lt;code&gt;x&lt;/code&gt; 의 슬라이스는 예제로 취급되며 출력 텐서는 &lt;code&gt;[batch_size] + x.shape[1:]&lt;/code&gt; 모양을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="836e7db05d88c2184b063f2c9c00ed1ec43300d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;estimator&lt;/code&gt; is not of type &lt;a href=&quot;../estimator&quot;&gt;&lt;code&gt;tf.estimator.Estimator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;estimator&lt;/code&gt; 가 &lt;a href=&quot;../estimator&quot;&gt; &lt;code&gt;tf.estimator.Estimator&lt;/code&gt; &lt;/a&gt; 유형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="6738e0e3984368cde96a4a476d2cdaa918be36c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive==True&lt;/code&gt;, all predicates are evaluated, and an exception is thrown if more than one of the predicates evaluates to &lt;code&gt;True&lt;/code&gt;. If &lt;code&gt;exclusive==False&lt;/code&gt;, execution stops at the first predicate which evaluates to True, and the tensors generated by the corresponding function are returned immediately. If none of the predicates evaluate to True, this operation returns the tensors generated by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;exclusive==True&lt;/code&gt; , 모든 조건이 평가되고, 예외가에 술어 평가하여 하나 이상의 경우에 슬로우됩니다 &lt;code&gt;True&lt;/code&gt; . &lt;code&gt;exclusive==False&lt;/code&gt; 경우 , True로 평가되는 첫 번째 술어에서 실행이 중지되고 해당 함수에 의해 생성 된 텐서가 즉시 리턴됩니다. 술어가 True로 평가되지 않으면이 조작은 &lt;code&gt;default&lt;/code&gt; 생성 된 텐서를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="c1db350e8759c17cd115f23013c64e6af556ea62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exclusive_resource_access == True&lt;/code&gt; and another &lt;code&gt;CriticalSection&lt;/code&gt; has an execution requesting the same resources as &lt;code&gt;fn&lt;/code&gt;&lt;code&gt;. Note, even if&lt;/code&gt;exclusive_resource_access&lt;code&gt;is&lt;/code&gt;True&lt;code&gt;, if another execution in another&lt;/code&gt;CriticalSection&lt;code&gt;was created without&lt;/code&gt;exclusive_resource_access=True&lt;code&gt;, a&lt;/code&gt;ValueError` will be raised.</source>
          <target state="translated">경우 &lt;code&gt;exclusive_resource_access == True&lt;/code&gt; 과 다른 &lt;code&gt;CriticalSection&lt;/code&gt; 같은 자원을 요청 실행이 &lt;code&gt;fn&lt;/code&gt; &lt;code&gt;. Note, even if&lt;/code&gt; exclusive_resource_access가 &lt;code&gt;is&lt;/code&gt; 진정한 &lt;code&gt;, if another execution in another&lt;/code&gt; 크리티컬 섹션이 &lt;code&gt;was created without&lt;/code&gt; exclusive_resource_access = TRUE &lt;code&gt;, a&lt;/code&gt; ValueError`가 발생됩니다.</target>
        </trans-unit>
        <trans-unit id="260e3949ec868b21a057005c57e5ab81d4a234b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;external_state_policy&lt;/code&gt; is not one of 'warn', 'ignore' or 'fail'.</source>
          <target state="translated">&lt;code&gt;external_state_policy&lt;/code&gt; 가 'warn', 'ignore'또는 'fail'중 하나가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="03bdec9947eaedf4bdce7a6822bddea8728620a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;f&lt;/code&gt; uses &lt;code&gt;Variable&lt;/code&gt;s (that are not part of the inputs), i.e. through &lt;code&gt;get_variable&lt;/code&gt;, then &lt;code&gt;grad_fn&lt;/code&gt; should have signature &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt;, where &lt;code&gt;variables&lt;/code&gt; is a list of the &lt;code&gt;Variable&lt;/code&gt;s, and return a 2-tuple &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt;, where &lt;code&gt;grad_xs&lt;/code&gt; is the same as above, and &lt;code&gt;grad_vars&lt;/code&gt; is a &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; with the derivatives of &lt;code&gt;Tensor&lt;/code&gt;s in &lt;code&gt;y&lt;/code&gt; with respect to the variables (that is, grad_vars has one Tensor per variable in variables).</source>
          <target state="translated">경우 &lt;code&gt;f&lt;/code&gt; 사용하여 &lt;code&gt;Variable&lt;/code&gt; (입력의 일부가 아닌)들, 즉 관통 &lt;code&gt;get_variable&lt;/code&gt; 다음 &lt;code&gt;grad_fn&lt;/code&gt; 서명이 있어야 &lt;code&gt;g(*grad_ys, variables=None)&lt;/code&gt; , &lt;code&gt;variables&lt;/code&gt; 의리스트 인 &lt;code&gt;Variable&lt;/code&gt; 들, 및 2- 튜플을 반환 &lt;code&gt;(grad_xs, grad_vars)&lt;/code&gt; , 여기서 &lt;code&gt;grad_xs&lt;/code&gt; 는 위와 동일하고 &lt;code&gt;grad_vars&lt;/code&gt; 는 변수와 관련하여 &lt;code&gt;y&lt;/code&gt; 에서 &lt;code&gt;Tensor&lt;/code&gt; s 의 파생물 이있는 &lt;code&gt;list&amp;lt;Tensor&amp;gt;&lt;/code&gt; 입니다 (즉, grad_vars는 변수의 변수 당 하나의 Tensor를 가짐).</target>
        </trans-unit>
        <trans-unit id="372309d6842fa4a199f338a43c95a0cfee85deea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; an algorithm based on the numerically robust complete orthogonal decomposition is used. This computes the minimum-norm least-squares solution, even when \(A\) is rank deficient. This path is typically 6-7 times slower than the fast path. If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;l2_regularizer&lt;/code&gt; is ignored.</source>
          <target state="translated">경우 &lt;code&gt;fast&lt;/code&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 수적으로 강력한 완전한 직교 분해를 기반으로하는 알고리즘이 사용됩니다. \ (A \)의 순위가 부족하더라도 최소 표준 최소 제곱 솔루션을 계산합니다. 이 경로는 일반적으로 빠른 경로보다 6-7 배 느립니다. 경우 &lt;code&gt;fast&lt;/code&gt; 입니다 &lt;code&gt;False&lt;/code&gt; 다음 &lt;code&gt;l2_regularizer&lt;/code&gt; 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="99ca2eb7416e2e7ca018fd9bd0de4034a8a44c56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^H A + \lambda I)^{-1} A^H B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^H (A A^H + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \mathbb{C}^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or \(\lambda\) is sufficiently large.</source>
          <target state="translated">경우 &lt;code&gt;fast&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 후 용액을 촐레 스키 분해를 사용하여 일반 식을 해결함으로써 계산된다. 특히, \ (m \ ge n \)이면 \ (X = (A ^ HA + \ lambda I) ^ {-1} A ^ HB \), 최소 제곱 문제를 푸는 \ (X = \ mathrm { argmin} _ {Z \ in \ Re ^ {n \ times k}} || AZ-B || _F ^ 2 + \ lambda || Z || _F ^ 2 \). \ (m \ lt n \)이면 &lt;code&gt;output&lt;/code&gt; \ (X = A ^ H (AA ^ H + \ lambda I) ^ {-1} B \)로 계산되며, (\ (\ lambda = 0 \)의 경우)는 아래에 대한 최소 노름 솔루션입니다. 결정된 선형 시스템, 즉 \ (X = \ mathrm {argmin} _ {Z \ in \ mathbb {C} ^ {n \ times k}} || Z || _F ^ 2 \), \ (AZ = B \). 빠른 경로는 \ (A \)가 수치 적으로 전체 순위이고 조건 번호가 \ (\ mathrm {cond} (A) \ lt \ frac {1} {\ sqrt {\ epsilon_ {mach} 인 경우에만 수치 적으로 안정적입니다. }} \) 또는 \ (\ lambda \)가 충분히 큽니다.</target>
        </trans-unit>
        <trans-unit id="a2174f4ab172cb4e074462ef83b691a3c79ee539" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k} } ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach} } }\) or\(\lambda\) is sufficiently large.</source>
          <target state="translated">경우 &lt;code&gt;fast&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 후 용액을 촐레 스키 분해를 사용하여 일반 식을 해결함으로써 계산된다. 구체적으로 말하면, \ (m \ ge n \)이면 \ (X = (A ^ TA + \ lambda I) ^ {-1} A ^ TB \), 최소 제곱 문제 \ (X = \ mathrm { argmin} _ {Z \ in \ Re ^ {n \ times k}} || AZ-B || _F ^ 2 + \ lambda || Z || _F ^ 2 \). \ (m \ lt n \)이면 &lt;code&gt;output&lt;/code&gt; \ (X = A ^ T (AA ^ T + \ lambda I) ^ {-1} B \)로 계산되며, (\ (\ lambda = 0 \)의 경우)는 아래에 대한 최소 표준 솔루션입니다. 결정된 선형 시스템, 즉 \ (X = \ mathrm {argmin} _ {Z \ in \ Re ^ {n \ times k}} || Z || _F ^ 2 \), \ (AZ = B \). 빠른 경로는 \ (A \)가 수치 적으로 전체 순위이고 조건 번호가 \ (\ mathrm {cond} (A) \ lt \ frac {1} {\ sqrt {\ epsilon_ {mach} 인 경우에만 수치 적으로 안정적입니다. }} \) 또는 \ (\ lambda \)가 충분히 큽니다.</target>
        </trans-unit>
        <trans-unit id="27049f19ad9a7d096760e3d9b009bb4362edc6f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fast&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then the solution is computed by solving the normal equations using Cholesky decomposition. Specifically, if \(m \ge n\) then \(X = (A^T A + \lambda I)^{-1} A^T B\), which solves the least-squares problem \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||A Z - B||_F^2 + \lambda ||Z||_F^2\). If \(m \lt n\) then &lt;code&gt;output&lt;/code&gt; is computed as \(X = A^T (A A^T + \lambda I)^{-1} B\), which (for \(\lambda = 0\)) is the minimum-norm solution to the under-determined linear system, i.e. \(X = \mathrm{argmin}_{Z \in \Re^{n \times k}} ||Z||_F^2 \), subject to \(A Z = B\). Notice that the fast path is only numerically stable when \(A\) is numerically full rank and has a condition number \(\mathrm{cond}(A) \lt \frac{1}{\sqrt{\epsilon_{mach}}}\) or\(\lambda\) is sufficiently large.</source>
          <target state="translated">&lt;code&gt;fast&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 Cholesky 분해를 사용하여 정규 방정식을 풀면 해가 계산됩니다. 특히, \ (m \ ge n \)이면 \ (X = (A ^ TA + \ lambda I) ^ {-1} A ^ TB \)는 최소 제곱 문제를 해결합니다. \ (X = \ mathrm { argmin} _ {Z \ in \ Re ^ {n \ times k}} || AZ-B || _F ^ 2 + \ lambda || Z || _F ^ 2 \). \ (m \ lt n \)이면 &lt;code&gt;output&lt;/code&gt; 는 \ (X = A ^ T (AA ^ T + \ lambda I) ^ {-1} B \)로 계산되며, (\ (\ lambda = 0 \)의 경우) 결정된 선형 시스템, 즉 \ (AZ = B \)에 따라 \ (X = \ mathrm {argmin} _ {Z \ in \ Re ^ {n \ times k}} || Z || _F ^ 2 \). 빠른 경로는 \ (A \)가 전체적으로 순위가 높고 조건 번호가 \ (\ mathrm {cond} (A) \ lt \ frac {1} {\ sqrt {\ epsilon_ {mach} 인 경우에만 수치 적으로 안정적입니다. }} \) 또는 \ (\ lambda \)가 충분히 큽니다.</target>
        </trans-unit>
        <trans-unit id="10418c72e5c6dd6e80851e9e8fb65566fa234438" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are invalid or refer to a &lt;code&gt;Tensor&lt;/code&gt; that doesn't exist.</source>
          <target state="translated">경우 &lt;code&gt;fetches&lt;/code&gt; 또는 &lt;code&gt;feed_dict&lt;/code&gt; 의 키가 무효 또는 참조 &lt;code&gt;Tensor&lt;/code&gt; 이 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6bb23faf339d41deeb0901d589753c2877206d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_dict&lt;/code&gt; keys are of an inappropriate type.</source>
          <target state="translated">경우 &lt;code&gt;fetches&lt;/code&gt; 또는 &lt;code&gt;feed_dict&lt;/code&gt; 의 키는 부적절한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="171762a498ab89f9d232219b63ff0405f3d5e480" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fetches&lt;/code&gt; or &lt;code&gt;feed_list&lt;/code&gt; cannot be interpreted as arguments to &lt;code&gt;tf.Session.run&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fetches&lt;/code&gt; 또는 &lt;code&gt;feed_list&lt;/code&gt; 는 인수로 해석 할 수없는 &lt;code&gt;tf.Session.run&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60b0573faec6681d2a2b616ba938701aadfaca62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flat_sequence&lt;/code&gt; and &lt;code&gt;structure&lt;/code&gt; have different element counts.</source>
          <target state="translated">&lt;code&gt;flat_sequence&lt;/code&gt; 와 &lt;code&gt;structure&lt;/code&gt; 요소 수가 다른 경우 .</target>
        </trans-unit>
        <trans-unit id="dbb91a9d86d6c9aaea4ef3aa45e8bf4a6c340bf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; attempts to lock this &lt;code&gt;CriticalSection&lt;/code&gt; in any nested or lazy way that may cause a deadlock.</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 시도는이 잠그는 &lt;code&gt;CriticalSection&lt;/code&gt; 교착 상태가 발생할 수있는 중첩 또는 게으른 방법을.</target>
        </trans-unit>
        <trans-unit id="1551e8f73c2d83fbf8fd44dd46181ffa8358ded1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 반환 &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 의, 다음 사용 &lt;a href=&quot;../../raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; 을&lt;/a&gt; 같은과 &lt;code&gt;ragged_rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e23aa87bbeb1e4675017eca04866dd1e388f7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 반환 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 다양한 크기와 함께 S, 다음 사용 &lt;a href=&quot;../../raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; 을&lt;/a&gt; 함께 &lt;code&gt;ragged_rank=0&lt;/code&gt; (ragged_rank = 1이됩니다) 하나의 누더기 텐서로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0eeacd3486db351366bde57a63394d991f15f982" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with the same &lt;code&gt;ragged_rank&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 반환 &lt;a href=&quot;raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 의, 다음 사용 &lt;a href=&quot;raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; 을&lt;/a&gt; 같은과 &lt;code&gt;ragged_rank&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be8d08d8e9b16ba0b500650cfa5d8f331678f73b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s with varying sizes, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;ragged_rank=0&lt;/code&gt; to combine them into a single ragged tensor (which will have ragged_rank=1).</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 반환 &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 다양한 크기와 함께 S, 다음 사용 &lt;a href=&quot;raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; 을&lt;/a&gt; 함께 &lt;code&gt;ragged_rank=0&lt;/code&gt; (ragged_rank = 1이됩니다) 하나의 누더기 텐서로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b10e6e3b3df2442237b2da671f13b9920466825a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt; returns a tuple (or nested structure) of tensors, then the result is formed by stacking corresponding elements from those structures.</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 텐서의 튜플 (또는 중첩 구조)를 리턴하고 그 결과를 그 구조에서 대응하는 요소를 적층하여 형성된다.</target>
        </trans-unit>
        <trans-unit id="9c1e8c321f941bc85990b6de55c2da7f3b805f5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fn&lt;/code&gt;'s input and output signatures are different, then the output signature must be specified using &lt;code&gt;fn_output_signature&lt;/code&gt;. (The input and output signatures are differ if their structures, dtypes, or tensor types do not match). E.g.:</source>
          <target state="translated">경우 &lt;code&gt;fn&lt;/code&gt; 의 입력 및 출력 서명이 다른, 출력 서명을 사용하여 지정해야합니다 &lt;code&gt;fn_output_signature&lt;/code&gt; 을 . (구조, dtype 또는 텐서 유형이 일치하지 않으면 입력 및 출력 서명이 다릅니다). 예 :</target>
        </trans-unit>
        <trans-unit id="931822ee2a64108c4c50b471e87b1dbdbef3f83b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fns[i]&lt;/code&gt; is not callable for any i, or &lt;code&gt;default&lt;/code&gt; is not callable.</source>
          <target state="translated">경우 &lt;code&gt;fns[i]&lt;/code&gt; 모든 I에 대한 호출하지 않거나 &lt;code&gt;default&lt;/code&gt; 호출하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ac46406112566e4c8d7fd9007e8f023b0bb2d1e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;format&lt;/code&gt; is not specified or is the empty string, a default format is picked in function of the number of channels in &lt;code&gt;image&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;format&lt;/code&gt; 빈 문자열을 지정되지 않았거나, 기본 형식은 채널 수의 기능으로 선택됩니다 &lt;code&gt;image&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c2863837c3f4cf6e88645c28db902644e8cef28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;frame_length&lt;/code&gt;, &lt;code&gt;frame_step&lt;/code&gt;, &lt;code&gt;pad_value&lt;/code&gt;, or &lt;code&gt;axis&lt;/code&gt; are not scalar.</source>
          <target state="translated">경우 &lt;code&gt;frame_length&lt;/code&gt; , &lt;code&gt;frame_step&lt;/code&gt; , &lt;code&gt;pad_value&lt;/code&gt; , 또는 &lt;code&gt;axis&lt;/code&gt; 스칼라 없습니다.</target>
        </trans-unit>
        <trans-unit id="57b26f5a78e8c279b178b9ade3dd5bc6d06da127" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a &lt;code&gt;Callable&lt;/code&gt; which is equivalent to &lt;code&gt;func&lt;/code&gt;, but is not converted by AutoGraph. If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a &lt;code&gt;Callable&lt;/code&gt; equivalent to the above case.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 없음]하는 반환 &lt;code&gt;Callable&lt;/code&gt; 에 해당 &lt;code&gt;func&lt;/code&gt; 하지만 사인에 의해 변환되지 않습니다. 경우 &lt;code&gt;func&lt;/code&gt; 아무도 없으며, 하나의 호출 할 때,하는 장식 반환 &lt;code&gt;func&lt;/code&gt; 인수하는 반환 &lt;code&gt;Callable&lt;/code&gt; 위의 경우에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="adab4fd150cb2345d1e66d4e52b3914d1ce9e9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;a href=&quot;tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 없음], 컴파일 된 함수를 실행 (0 개 이상의 반환하는 호출 반환 &lt;a href=&quot;tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; 이&lt;/a&gt; 객체 참조). 경우 &lt;code&gt;func&lt;/code&gt; 아무도 없으며, 하나의 호출 할 때,하는 장식 반환 &lt;code&gt;func&lt;/code&gt; 인수, 위의 경우에 호출 상당을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f898cef9866995880d01892817ec2175fe439d2e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not None, returns a callable that will execute the compiled function (and return zero or more &lt;code&gt;tf.Tensor&lt;/code&gt; objects). If &lt;code&gt;func&lt;/code&gt; is None, returns a decorator that, when invoked with a single &lt;code&gt;func&lt;/code&gt; argument, returns a callable equivalent to the case above.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 가 None이 아닌 경우 컴파일 된 함수를 실행하는 호출 가능을 반환하고 0 개 이상의 &lt;code&gt;tf.Tensor&lt;/code&gt; 객체를 반환합니다 . &lt;code&gt;func&lt;/code&gt; 가 None 인 경우 단일 &lt;code&gt;func&lt;/code&gt; 인수로 호출 할 때 위의 경우와 동등한 호출 가능자를 반환하는 데코레이터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e85ff520cc5fc0cf0177cb0ed9640cb244dce5fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;func&lt;/code&gt; is not callable or if the structures do not match each other by depth tree.</source>
          <target state="translated">경우 &lt;code&gt;func&lt;/code&gt; 호출되지 않았거나 구조 깊이 트리에 의해 서로 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="62acbfcfb14ee0a398f34c8b9aa49c710246709d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;global_norm == infinity&lt;/code&gt; then the entries in &lt;code&gt;t_list&lt;/code&gt; are all set to &lt;code&gt;NaN&lt;/code&gt; to signal that an error occurred.</source>
          <target state="translated">&lt;code&gt;global_norm == infinity&lt;/code&gt; 경우 &lt;code&gt;t_list&lt;/code&gt; 의 항목 은 모두 &lt;code&gt;NaN&lt;/code&gt; 으로 설정되어 오류가 발생했음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2956cad21f5b56edbff8960414c25d760e131d03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;grads_and_vars&lt;/code&gt; is malformed.</source>
          <target state="translated">경우 &lt;code&gt;grads_and_vars&lt;/code&gt; 가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="06180e8a961bb714a028db31c783968b59694720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;graph_def&lt;/code&gt; is not a &lt;code&gt;GraphDef&lt;/code&gt; proto, &lt;code&gt;input_map&lt;/code&gt; is not a dictionary mapping strings to &lt;code&gt;Tensor&lt;/code&gt; objects, or &lt;code&gt;return_elements&lt;/code&gt; is not a list of strings.</source>
          <target state="translated">경우 &lt;code&gt;graph_def&lt;/code&gt; 는 하지 않은 것입니다 &lt;code&gt;GraphDef&lt;/code&gt; 의 프로토는, &lt;code&gt;input_map&lt;/code&gt; 가 에 대한 사전 매핑 문자열이 아닌 &lt;code&gt;Tensor&lt;/code&gt; 개체 또는 &lt;code&gt;return_elements&lt;/code&gt; 는 문자열 목록이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="461aea0814d7e39649d6d120c06dd3be55715069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hash_bucket_size &amp;lt; 1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hash_bucket_size &amp;lt; 1&lt;/code&gt; 경우 .</target>
        </trans-unit>
        <trans-unit id="6d6361bf1f4ec971c2401c5cbb45657531e4fd66" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;identifier&lt;/code&gt; cannot be interpreted.</source>
          <target state="translated">&lt;code&gt;identifier&lt;/code&gt; 를 해석 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="85643c6bb3df08bc9a3e4fee59e6d92e89835fa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; is not a 4D tensor.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; 가 4D 텐서가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="8202744147fe643212bcfe0c85cc04cbaa3a7c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 4-D였다 4 D 플로트 텐서 형상 &lt;code&gt;[batch, target_height, target_width, channels]&lt;/code&gt; 경우 &lt;code&gt;image&lt;/code&gt; 3-D, 선수는 3-D 플로트 텐서 형상 &lt;code&gt;[target_height, target_width, channels]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e92f8fb84781c3e7b4d7c52dbb4a1a2a181a567" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;image&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; If &lt;code&gt;image&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[width, height, channels]&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;image&lt;/code&gt; 4-D였다 4 D 플로트 텐서 형상 &lt;code&gt;[batch, width, height, channels]&lt;/code&gt; 경우 &lt;code&gt;image&lt;/code&gt; 3-D였다 형상의 3-D 플로트 텐서 &lt;code&gt;[width, height, channels]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7b22ec650a9bcf3dbd00caf73b8addae20e1363f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, a 4-D float Tensor of shape &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt;. If &lt;code&gt;images&lt;/code&gt; was 3-D, a 3-D float Tensor of shape &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;images&lt;/code&gt; 4-D, 형상의 4-D 플로트 텐서이었다 &lt;code&gt;[batch, new_height, new_width, channels]&lt;/code&gt; . 경우 &lt;code&gt;images&lt;/code&gt; 3-D, 형상의 3-D 플로트 텐서이었다 &lt;code&gt;[new_height, new_width, channels]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2952b0ed613f675460838f4f741f5f9164c5ef5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;images&lt;/code&gt; was 4-D, return a 1-D float Tensor of shape &lt;code&gt;[batch]&lt;/code&gt; with the total variation for each image in the batch. If &lt;code&gt;images&lt;/code&gt; was 3-D, return a scalar float with the total variation for that image.</source>
          <target state="translated">경우 &lt;code&gt;images&lt;/code&gt; 4-D이고, 형상의 1-D 플로트 텐서 복귀 &lt;code&gt;[batch]&lt;/code&gt; 배치의 각각의 이미지에 대한 총 변화량. &lt;code&gt;images&lt;/code&gt; 가 3 차원 인 경우 해당 이미지 의 전체 변형이 포함 된 스칼라 부동 소수점을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eda69d01cfcf1f44ffd4da2f558f423b426b0614" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; contains duplicates, then their updates are accumulated (summed).</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 에 중복이 포함 된 경우 업데이트가 누적됩니다 (합산).</target>
        </trans-unit>
        <trans-unit id="a94358a58fd92ac955695f20a84f5c03cc0dc2c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a RaggedTensor, the 'axis' argument must be positive and refer to a non-ragged axis. The output will be equivalent to applying 'one_hot' on the values of the RaggedTensor, and creating a new RaggedTensor from the result.</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; RaggedTensor되면, '축'인수는 긍정적 및 비 누더기 축에 참조해야합니다. 출력은 RaggedTensor의 값에 'one_hot'을 적용하고 결과에서 새 RaggedTensor를 작성하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b6eba702090dea64afc7969a9f079a18321fa1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a matrix (batch) with shape &lt;code&gt;[batch, features]&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 형상의 매트릭스 (배치)이다 &lt;code&gt;[batch, features]&lt;/code&gt; 출력 형상 것이다 :</target>
        </trans-unit>
        <trans-unit id="2c8651ec95be2ea9a0cc30128faa66b9c2d43d29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a permutation and &lt;code&gt;len(indices) == params.shape[0]&lt;/code&gt; then this operation will permute &lt;code&gt;params&lt;/code&gt; accordingly.</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 순열이고 &lt;code&gt;len(indices) == params.shape[0]&lt;/code&gt; 순열 것 다음이 동작 &lt;code&gt;params&lt;/code&gt; 따라서.</target>
        </trans-unit>
        <trans-unit id="b7efb1cc16c63ea7b0aac3e018a11b41a9ddc9ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 스칼라가 출력 형상은 길이의 벡터 것 &lt;code&gt;depth&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2cb59a7c31ae2fe8c97ecae2fc219f2e5547664d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a scalar the output shape will be a vector of length &lt;code&gt;depth&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 스칼라가 출력 형상은 길이의 벡터 것이다 &lt;code&gt;depth&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a13c16c0eff3a5bb88de38a8d8307ec6511d293" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices&lt;/code&gt; is a vector of length &lt;code&gt;features&lt;/code&gt;, the output shape will be:</source>
          <target state="translated">경우 &lt;code&gt;indices&lt;/code&gt; 길이의 벡터이다 &lt;code&gt;features&lt;/code&gt; 출력 형태가 될 것이다 :</target>
        </trans-unit>
        <trans-unit id="6c438e9ba6fd98b2384d247334493173a26303ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;initializer&lt;/code&gt; is None, only out-of-vocabulary buckets are used.</source>
          <target state="translated">경우 &lt;code&gt;initializer&lt;/code&gt; 없음입니다 만 아웃 오브 어휘 버킷이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d93109613b12250a30b715aa9a4045da0bba426f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input&lt;/code&gt; is already real, it is returned unchanged.</source>
          <target state="translated">경우 &lt;code&gt;input&lt;/code&gt; 이미 현실, 그것은 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2d73039dfcb009dbb9d3ba38b336fb7dee149a81" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_map&lt;/code&gt;, or &lt;code&gt;return_elements&lt;/code&gt; contains names that do not appear in &lt;code&gt;graph_def&lt;/code&gt;, or &lt;code&gt;graph_def&lt;/code&gt; is not well-formed (e.g. it refers to an unknown tensor).</source>
          <target state="translated">경우 &lt;code&gt;input_map&lt;/code&gt; , 또는 &lt;code&gt;return_elements&lt;/code&gt; 가 나타나지 않는 이름이 포함 &lt;code&gt;graph_def&lt;/code&gt; , 또는 &lt;code&gt;graph_def&lt;/code&gt; 잘 형성되지 않는다 (예 : 그것은 알 수없는 텐서를 의미한다).</target>
        </trans-unit>
        <trans-unit id="4c620f70974120bd9cb3db4d33f50222f323be76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;input_output_dtype = DTYPE&lt;/code&gt; 경우 :</target>
        </trans-unit>
        <trans-unit id="3def506820299b2293f03f5c9b04dcb9fe22d72c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; don't all have same shape and dtype or the shape cannot be inferred.</source>
          <target state="translated">경우 &lt;code&gt;inputs&lt;/code&gt; 모두 같은 모양과 DTYPE이 없거나 모양을 유추 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="91e1e38e57c32a085e042e248a4488df18c84ff2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the arity and type of &lt;code&gt;state_name&lt;/code&gt; does not match that of &lt;code&gt;cell.state_size&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;inputs&lt;/code&gt; 하지 &lt;code&gt;None&lt;/code&gt; 또는 빈 목록, 또는 인수에 대응와 유형 경우 &lt;code&gt;state_name&lt;/code&gt; 의 일치하지 않는 &lt;code&gt;cell.state_size&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="8bec6ea37f82cfa7f2a1d5f2d2008b4707ac6ca5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;inputs&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or an empty list, or if the input depth (column size) cannot be inferred from inputs via shape inference.</source>
          <target state="translated">경우 &lt;code&gt;inputs&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 형상 유추를 통해 입력을 유추 할 수 없거나 빈리스트, 또는 입력하는 경우 깊이 (컬럼 사이즈).</target>
        </trans-unit>
        <trans-unit id="7ce85c6dd49fe3b8c73feae72b7f6738cadc8bb8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == False&lt;/code&gt;, callers should expect the operator to not have &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;is_X == False&lt;/code&gt; 발신자가 운영자를 기대해야하지 &lt;code&gt;X&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d0afbb1278c738c0d57964d82ebe25d5d9dff4ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == None&lt;/code&gt; (the default), callers should have no expectation either way.</source>
          <target state="translated">경우 &lt;code&gt;is_X == None&lt;/code&gt; (기본값), 발신자가 더 기대 하나 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd1b93088ca4115b8f08bd9ab8fb507c261ccce5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X == True&lt;/code&gt;, callers should expect the operator to have the property &lt;code&gt;X&lt;/code&gt;. This is a promise that should be fulfilled, but is &lt;em&gt;not&lt;/em&gt; a runtime assert. For example, finite floating point precision may result in these promises being violated.</source>
          <target state="translated">경우 &lt;code&gt;is_X == True&lt;/code&gt; 발신자는 운영자가 속성을 감수해야합니다 &lt;code&gt;X&lt;/code&gt; 를 . 이것은 이행되어야 할 약속이지만 런타임 주장 은 &lt;em&gt;아닙니다&lt;/em&gt; . 예를 들어, 유한 부동 소수점 정밀도로 인해 이러한 약속이 위반 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c22402e2171c4c1f4ba6b2ff7b70ec7ea74f958a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_X&lt;/code&gt; flags are set in an inconsistent way.</source>
          <target state="translated">&lt;code&gt;is_X&lt;/code&gt; 플래그가 일관되지 않은 방식으로 설정된 경우 .</target>
        </trans-unit>
        <trans-unit id="a3a0cb7162dd9573a93c2d5e4c0945712cc80b22" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_square&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="96697908c1dc3e043634cbbd44dc5cfb701b564b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;is_tensor(x)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;, it is safe to assume that &lt;code&gt;x&lt;/code&gt; is a tensor or can be converted to a tensor using &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;is_tensor(x)&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 를 리턴 하면 , &lt;code&gt;x&lt;/code&gt; 가 텐서 라고 가정 하거나 &lt;code&gt;ops.convert_to_tensor(x)&lt;/code&gt; 사용하여 텐서로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a212a196f90ac2693f3cbfad3f8cd8e36d111b25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;iterator&lt;/code&gt; has reached the end of the sequence, the returned &lt;code&gt;Optional&lt;/code&gt; will have no value.</source>
          <target state="translated">경우 &lt;code&gt;iterator&lt;/code&gt; 순서의 마지막에 이른, 반환 된 &lt;code&gt;Optional&lt;/code&gt; 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecaa2a4898946decfeefef48b42990281e4ae0fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster, or no task with index &lt;code&gt;task_index&lt;/code&gt; is defined in that job.</source>
          <target state="translated">&lt;code&gt;job_name&lt;/code&gt; 이이 클러스터의 작업 이름을 지정하지 않거나 해당 작업에 &lt;code&gt;task_index&lt;/code&gt; 인덱스 가있는 작업이 정의되어 있지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="d396b2b2293caff3f0f5c227bcb99f143d81fabe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;job_name&lt;/code&gt; does not name a job in this cluster.</source>
          <target state="translated">&lt;code&gt;job_name&lt;/code&gt; 이이 클러스터의 작업 이름을 지정하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="e8999131f1f1d024304557a7b65fc9bac0014050" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k&lt;/code&gt; varies dynamically, use &lt;code&gt;TopKV2&lt;/code&gt; below.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; 가 동적으로 변하는 경우 아래 &lt;code&gt;TopKV2&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0dfaf8985bf78fa71a42c9e60b969cc11b499ddc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is a slice and &lt;code&gt;self&lt;/code&gt; is completely unknown and the step is set.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 조각하고 &lt;code&gt;self&lt;/code&gt; 전혀 알려져 있지 단계가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8a027ba8554cd07c7f749c881765338f4424e936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is an integer, returns the dimension at that index; otherwise if &lt;code&gt;key&lt;/code&gt; is a slice, returns a TensorShape whose dimensions are those selected by the slice from &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 정수, 해당 인덱스의 차원을 반환 그렇지 않은 경우 &lt;code&gt;key&lt;/code&gt; 가 슬라이스이면 &lt;code&gt;self&lt;/code&gt; 의 슬라이스에 의해 선택된 크기를 갖는 TensorShape를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="3cd7fb4c21c7339eff15c78196173b6566f9d7fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is not supported.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c6f0ea9ed966ce6ace9ccb5bbc1f609e2328ffa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;key&lt;/code&gt; is out of bounds.</source>
          <target state="translated">경우 &lt;code&gt;key&lt;/code&gt; 범위를 벗어났습니다.</target>
        </trans-unit>
        <trans-unit id="af8f886f9d669bed2a03baa8589f72cb8d4d6ce7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_key&lt;/code&gt; is not one of the &lt;code&gt;features&lt;/code&gt; keys.</source>
          <target state="translated">&lt;code&gt;label_key&lt;/code&gt; 가 &lt;code&gt;features&lt;/code&gt; 키 중 하나가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="442f4dde96ff9cbee6d4ed0116902353d0432184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;float32&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size, image_size[0], image_size[1], num_channels)&lt;/code&gt;, encoding images (see below for rules regarding &lt;code&gt;num_channels&lt;/code&gt;).</source>
          <target state="translated">경우 &lt;code&gt;label_mode&lt;/code&gt; 가 포함되지 않은 경우, 그 산출 &lt;code&gt;float32&lt;/code&gt; 형상 텐서 &lt;code&gt;(batch_size, image_size[0], image_size[1], num_channels)&lt;/code&gt; 이미지를 인코딩 (관한 규칙 아래 참조 &lt;code&gt;num_channels&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="02ec12a31086fac5b8d9ae1402e7448374b19b18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_mode&lt;/code&gt; is None, it yields &lt;code&gt;string&lt;/code&gt; tensors of shape &lt;code&gt;(batch_size,)&lt;/code&gt;, containing the contents of a batch of text files.</source>
          <target state="translated">경우 &lt;code&gt;label_mode&lt;/code&gt; 은 없음입니다, 그것은 산출 &lt;code&gt;string&lt;/code&gt; 형태의 텐서 &lt;code&gt;(batch_size,)&lt;/code&gt; 텍스트 파일의 배치의 내용을 포함.</target>
        </trans-unit>
        <trans-unit id="99d5159794e9527572e582d5291c29b2551e8bac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/2:</source>
          <target state="translated">&lt;code&gt;label_smoothing&lt;/code&gt; 이 0이 아닌 경우 레이블을 1/2쪽으로 스무딩하십시오.</target>
        </trans-unit>
        <trans-unit id="8bfcf6c3ee662c4541e7fcc138561099e2c68bfc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing)</source>
          <target state="translated">경우 &lt;code&gt;label_smoothing&lt;/code&gt; 이 제로이며, 1 / num_classes으로 레이블을 부드럽게 : new_onehot_labels = onehot_labels * (1 - label_smoothing)</target>
        </trans-unit>
        <trans-unit id="c4fc91aecf4a1093b877f40965090f1148dd8d17" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_smoothing&lt;/code&gt; is nonzero, smooth the labels towards 1/num_classes: new_onehot_labels = onehot_labels * (1 - label_smoothing) + label_smoothing / num_classes</source>
          <target state="translated">&lt;code&gt;label_smoothing&lt;/code&gt; 이 0이 아닌 경우 레이블을 1 / num_classes쪽으로 스무딩하십시오. new_onehot_labels = onehot_labels * (1-label_smoothing) + label_smoothing / num_classes</target>
        </trans-unit>
        <trans-unit id="9535e210890193a55032b616d005eda7ed94d172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;label_vocabulary&lt;/code&gt; is given, a string &lt;code&gt;SparseTensor&lt;/code&gt;. The &lt;code&gt;dense_shape&lt;/code&gt; must be &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; and the values within &lt;code&gt;label_vocabulary&lt;/code&gt; or a multi-hot tensor of shape &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;label_vocabulary&lt;/code&gt; 이 주어진 문자열 &lt;code&gt;SparseTensor&lt;/code&gt; . &lt;code&gt;dense_shape&lt;/code&gt; 이 있어야 &lt;code&gt;[D0, D1, ... DN, ?]&lt;/code&gt; 와 내부 값 &lt;code&gt;label_vocabulary&lt;/code&gt; 또는 형상의 다중 핫 텐서 &lt;code&gt;[D0, D1, ... DN, n_classes]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9d181f00ed5063e3bb83d7190390a7aaf79b6d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;latest_filename&lt;/code&gt; contains path components, or if it collides with &lt;code&gt;save_path&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;latest_filename&lt;/code&gt; 이 경로 구성 요소가 포함되어 있습니다, 또는 충돌하는 경우 &lt;code&gt;save_path&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45779bfea581324e20f83680029d5b035eaab380" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; is not a layer instance.</source>
          <target state="translated">경우 &lt;code&gt;layer&lt;/code&gt; 레이어 인스턴스가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="e57faa88fcd4abc6c75a30eb2b606c25bc0cb752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;layer&lt;/code&gt; or &lt;code&gt;backward_layer&lt;/code&gt; is not a &lt;code&gt;Layer&lt;/code&gt; instance.</source>
          <target state="translated">경우 &lt;code&gt;layer&lt;/code&gt; 또는 &lt;code&gt;backward_layer&lt;/code&gt; 은 하지 않은 것입니다 &lt;code&gt;Layer&lt;/code&gt; 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="967c37ef4813eebb4b3f478746ba7d5ff73bdc1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(embedding_weights) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;embedding_weights&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;len(embedding_weights) &amp;gt; 1&lt;/code&gt; , 각 요소 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;ids&lt;/code&gt; 요소 사이에 분배 &lt;code&gt;embedding_weights&lt;/code&gt; 연속 방식으로 우리에게 파티션에 할당 ID를 의미하는 &quot;DIV&quot;분할 전략에 따라. 예를 들어 13 개의 ID는 &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt; 와 같이 5 개의 파티션으로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="8126c22e40c006b2f71cc6c83da730cd7198f562" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(keys) &amp;lt; 2&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;len(keys) &amp;lt; 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30f7fb451ff0e7c028617b0faa305894fcff0b32" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(nested_values_rowids) != len(nested_nrows)&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;len(nested_values_rowids) != len(nested_nrows)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="85e212b49e9635f45f33c86b9912893cbd223a5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt; , 각 요소 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;ids&lt;/code&gt; 요소 사이에 분배 &lt;code&gt;params&lt;/code&gt; 연속 방식으로 우리에게 파티션에 할당 ID를 의미하는 &quot;DIV&quot;분할 전략에 따라. 예를 들어 13 개의 ID는 &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt; 와 같이 5 개의 파티션으로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="84e776cdbcc3444233893bed8e8a175d8a296b35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element &lt;code&gt;id&lt;/code&gt; of &lt;code&gt;ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &lt;code&gt;partition_strategy&lt;/code&gt;. In all strategies, if the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="translated">경우 &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt; , 각 요소 &lt;code&gt;id&lt;/code&gt; 의 &lt;code&gt;ids&lt;/code&gt; 요소 사이에 분배 &lt;code&gt;params&lt;/code&gt; 받는있어서 &lt;code&gt;partition_strategy&lt;/code&gt; . 모든 전략에서 id 공간이 파티션 수를 균등하게 나누지 않으면 첫 번째 &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; 파티션 각각에 하나 이상의 id가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="7c76724b7d1351d823fe9209abfbdddf28992103" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt;, each element of &lt;code&gt;sp_ids&lt;/code&gt; is partitioned between the elements of &lt;code&gt;params&lt;/code&gt; according to the &quot;div&quot; partition strategy, which means we assign ids to partitions in a contiguous manner. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;len(params) &amp;gt; 1&lt;/code&gt; 의 각 요소 &lt;code&gt;sp_ids&lt;/code&gt; 이 요소 사이에 분배 &lt;code&gt;params&lt;/code&gt; 은 &quot;DIV&quot;분할 전략에 따라 어떤 수단 우리 연속 방식으로 파티션에 할당 IDS. 예를 들어 13 개의 ID는 &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt; 와 같이 5 개의 파티션으로 분할됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d08097191b4f17f118cbfefba6aecf799282429" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt;, then:</source>
          <target state="translated">경우 &lt;code&gt;len(partitions) &amp;gt; 1&lt;/code&gt; 후 :</target>
        </trans-unit>
        <trans-unit id="5f370b423121a48298eb43a3a0c878f9941513c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 0&lt;/code&gt; (the default), then:</source>
          <target state="translated">만약 &lt;code&gt;len(partitions) == 0&lt;/code&gt; (기본값), 다음 :</target>
        </trans-unit>
        <trans-unit id="6cf134dcb33104f575f6a123d3a075fe42f5e61f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len(partitions) == 1&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;len(partitions) == 1&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="c7d16e6c5a371d846babf4540ef4a499f5ff7e85" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;len&lt;/code&gt; defines a substring that would extend beyond the length of the input string, or if &lt;code&gt;len&lt;/code&gt; is negative, then as many characters as possible are used.</source>
          <target state="translated">만약 &lt;code&gt;len&lt;/code&gt; 입력 문자열의 길이를 넘어 확장 할 경우, 또는 문자열을 정의 &lt;code&gt;len&lt;/code&gt; 부정적이며, 다음 가능한 한 많은 문자가 사용으로는.</target>
        </trans-unit>
        <trans-unit id="58c0544760219e22513b48eb9e261f94e98a41ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;lengths&lt;/code&gt; has shape &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; the resulting tensor &lt;code&gt;mask&lt;/code&gt; has dtype &lt;code&gt;dtype&lt;/code&gt; and shape &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt;, with</source>
          <target state="translated">경우 &lt;code&gt;lengths&lt;/code&gt; 형상을 갖는 &lt;code&gt;[d_1, d_2, ..., d_n]&lt;/code&gt; 얻어진 텐서 &lt;code&gt;mask&lt;/code&gt; DTYPE 갖는다 &lt;code&gt;dtype&lt;/code&gt; 및 형상 &lt;code&gt;[d_1, d_2, ..., d_n, maxlen]&lt;/code&gt; 와를</target>
        </trans-unit>
        <trans-unit id="3c5b2be06fb7017b079751ddda7b22925baf4691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;log_input&lt;/code&gt; and &lt;code&gt;targets&lt;/code&gt; do not have the same shape.</source>
          <target state="translated">경우 &lt;code&gt;log_input&lt;/code&gt; 와 &lt;code&gt;targets&lt;/code&gt; 같은 모양이 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8564534874792c985f423f360729ff591b2b7d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; do not have the same shape.</source>
          <target state="translated">경우 &lt;code&gt;logits&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; 같은 모양이 없습니다.</target>
        </trans-unit>
        <trans-unit id="495c5ec6c6d28f35484c4fc66c26cf6d9595cae1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mark_as_used&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt;, which is the default, a new unique name is created and marked as in use. If it's set to &lt;code&gt;False&lt;/code&gt;, the unique name is returned without actually being marked as used. This is useful when the caller simply wants to know what the name to be created will be.</source>
          <target state="translated">&lt;code&gt;mark_as_used&lt;/code&gt; 가 기본값 인 &lt;code&gt;True&lt;/code&gt; 로 설정 되면 새 고유 이름이 작성되고 사용중인 것으로 표시됩니다. &lt;code&gt;False&lt;/code&gt; 로 설정되면 실제로 사용 된 것으로 표시되지 않고 고유 이름이 리턴됩니다. 이것은 호출자가 생성 될 이름이 무엇인지 알고 자 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cd1e44d4c7d6ed45c9cd26023b5058f4d025374d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/image'.</source>
          <target state="translated">경우 &lt;code&gt;max_images&lt;/code&gt; 은 1, 요약 값 태그 '입니다 &lt;em&gt;태그&lt;/em&gt; / 이미지'.</target>
        </trans-unit>
        <trans-unit id="08e4a9009970f0585fad5a33338c65900faf027d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_images&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/image/0', '&lt;em&gt;tag&lt;/em&gt;/image/1', etc.</source>
          <target state="translated">경우 &lt;code&gt;max_images&lt;/code&gt; 가 1보다 크면, 요약 값 태그는 '로 순차적으로 생성 된 &lt;em&gt;태그&lt;/em&gt; / 이미지 / 0 &quot;,&quot; &lt;em&gt;태그&lt;/em&gt; / 이미지 / 1'등</target>
        </trans-unit>
        <trans-unit id="61766419fa18559947b6a6ba67bb03f1eea12328" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/audio'.</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 은 1, 요약 값 태그 '는 &lt;em&gt;이름&lt;/em&gt; / 오디오'.</target>
        </trans-unit>
        <trans-unit id="c93a8d469ca0a24100be9b2896764722aaf3a271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;name&lt;/em&gt;/image'.</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 은 1, 요약 값 태그 '는 &lt;em&gt;이름&lt;/em&gt; / 이미지'.</target>
        </trans-unit>
        <trans-unit id="258df073bb92dd67ccc339545de0afc021f5a3dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is 1, the summary value tag is '&lt;em&gt;tag&lt;/em&gt;/audio'.</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 은 1, 요약 값 태그 '입니다 &lt;em&gt;태그&lt;/em&gt; / 오디오'.</target>
        </trans-unit>
        <trans-unit id="3eb078f131932fa68d289f9e59ad97e8c707aaf6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/audio/0', '&lt;em&gt;name&lt;/em&gt;/audio/1', etc</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 가 1보다 크면, 요약 값 태그는 '로 순차적으로 생성되는 &lt;em&gt;이름&lt;/em&gt; / 오디오 / 0', ' &lt;em&gt;이름&lt;/em&gt; / 오디오 / 1'등</target>
        </trans-unit>
        <trans-unit id="c79a7ab3177da8b28168b7f679889bedd40abf53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;name&lt;/em&gt;/image/0', '&lt;em&gt;name&lt;/em&gt;/image/1', etc.</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 가 1보다 크면, 요약 값 태그는 '로 순차적으로 생성되는 &lt;em&gt;이름&lt;/em&gt; / 이미지 / 0', ' &lt;em&gt;이름&lt;/em&gt; / 이미지 / 1'등</target>
        </trans-unit>
        <trans-unit id="2bb63258c4a86e0f68d75252c89470c99c03722a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_outputs&lt;/code&gt; is greater than 1, the summary value tags are generated sequentially as '&lt;em&gt;tag&lt;/em&gt;/audio/0', '&lt;em&gt;tag&lt;/em&gt;/audio/1', etc.</source>
          <target state="translated">경우 &lt;code&gt;max_outputs&lt;/code&gt; 가 1보다 크면, 요약 값 태그는 '로 순차적으로 생성 된 &lt;em&gt;태그&lt;/em&gt; / 오디오 / 0 &quot;,&quot; &lt;em&gt;태그&lt;/em&gt; / 오디오 / 1'등</target>
        </trans-unit>
        <trans-unit id="619dc874e12b9ab9cd2cb9215273176742fd29ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;max_to_keep&lt;/code&gt; is not a positive integer.</source>
          <target state="translated">&lt;code&gt;max_to_keep&lt;/code&gt; 이 양의 정수가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="a3d66f411337b07f0dab269875b71de9a6838978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mdcts&lt;/code&gt; is not at least rank 2.</source>
          <target state="translated">&lt;code&gt;mdcts&lt;/code&gt; 가 최소 순위 2가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="71e15c8d0da73bb687041dfc28fe499db780dc07" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in output. This means that if consecutive logits' maximum indices are the same, only the first of these is emitted. The sequence &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label) becomes</source>
          <target state="translated">&lt;code&gt;merge_repeated&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 반복되는 클래스를 출력에 병합합니다. 이는 연속 로짓의 최대 인덱스가 동일하면 첫 번째 로그 만 방출됨을 의미합니다. 순서 &lt;code&gt;A B B * B * B&lt;/code&gt; (여기서 '*'는 빈 레이블)가됩니다.</target>
        </trans-unit>
        <trans-unit id="7bac502b4b4499617b3003913f73281a64e6d6e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;merge_repeated&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, merge repeated classes in the output beams. This means that if consecutive entries in a beam are the same, only the first of these is emitted. That is, when the sequence is &lt;code&gt;A B B * B * B&lt;/code&gt; (where '*' is the blank label), the return value is:</source>
          <target state="translated">&lt;code&gt;merge_repeated&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 출력 빔에서 반복되는 클래스를 병합합니다. 즉, 빔의 연속 항목이 동일하면 첫 번째 항목 만 방출됩니다. 즉, 시퀀스가 &lt;code&gt;A B B * B * B&lt;/code&gt; (여기서 '*'는 공백 레이블) 인 경우 리턴 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f5f8af2740a968e311c9b89d559f686de2b0a59" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt; max &amp;lt; 0&lt;/code&gt;: &lt;code&gt;min_adj = min - max&lt;/code&gt; and &lt;code&gt;max_adj = 0&lt;/code&gt;.</source>
          <target state="translated">만일 &lt;code&gt;min &amp;lt; max &amp;lt; 0&lt;/code&gt; : &lt;code&gt;min_adj = min - max&lt;/code&gt; 및 &lt;code&gt;max_adj = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1304f8f39dbe5a8f6d6eeae3733c3fcf4be17ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;min &amp;lt;= 0 &amp;lt;= max&lt;/code&gt;: &lt;code&gt;scale = (max - min) / (2^num_bits - 1)&lt;/code&gt;, &lt;code&gt;min_adj = scale * round(min / scale)&lt;/code&gt; and &lt;code&gt;max_adj = max + min_adj - min&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;min &amp;lt;= 0 &amp;lt;= max&lt;/code&gt; : &lt;code&gt;scale = (max - min) / (2^num_bits - 1)&lt;/code&gt; , &lt;code&gt;min_adj = scale * round(min / scale)&lt;/code&gt; 및 &lt;code&gt;max_adj = max + min_adj - min&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0984202fa4f5e645b2c5a40e37b9b5a9dd3c9893" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;minlength&lt;/code&gt; and &lt;code&gt;maxlength&lt;/code&gt; are not given, returns a vector with length &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; if &lt;code&gt;arr&lt;/code&gt; is non-empty, and length 0 otherwise. If &lt;code&gt;weights&lt;/code&gt; are non-None, then index &lt;code&gt;i&lt;/code&gt; of the output stores the sum of the value in &lt;code&gt;weights&lt;/code&gt; at each index where the corresponding value in &lt;code&gt;arr&lt;/code&gt; is &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;minlength&lt;/code&gt; 및 &lt;code&gt;maxlength&lt;/code&gt; 제공되지 않습니다, 길이와 벡터 반환 &lt;code&gt;tf.reduce_max(arr) + 1&lt;/code&gt; 경우 &lt;code&gt;arr&lt;/code&gt; 달리 비 비어, 길이 0. &lt;code&gt;weights&lt;/code&gt; 가 None이 아닌 경우 , 출력의 인덱스 &lt;code&gt;i&lt;/code&gt; 는 &lt;code&gt;arr&lt;/code&gt; 의 해당 값 이 &lt;code&gt;i&lt;/code&gt; 인 각 인덱스 의 값 합계를 &lt;code&gt;weights&lt;/code&gt; 로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="bc775b5309c51edeb837cf49c77d15d49ce193f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.evaluate&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c70c96ae2eb1390ba94985d15df3380acf18bf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.evaluate&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.evaluate&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b1ffe619d3d50b4c85a21621ff8dceb52857ee3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.fit&lt;/code&gt; 은 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b17b3f8cacf3362c475a9bbfd7a287c45fefb5e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.fit&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.fit&lt;/code&gt; 은 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0faade3b34e959ce96253cdd4a1d86434d240213" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.predict&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="50a072772fc22e466963013635b8c683c63ebd28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.predict&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e1686ca69810a585f4306a0c7eb54ba0fea271e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.predict_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed39d59f9e1dad8c20bb30e50c137ed4963428b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.predict_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.predict_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="127df10a5d3eac7073f1f68ddbc93e21b0620769" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.test_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="376bca6d71b04ff763045a323c905bd6843fc382" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.test_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.test_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a36ed8e1819cbdc2c4ff0e176448e312ac1adb1f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.train_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d00b583578569b2cefa9231d3ff9433b12727048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;model.train_on_batch&lt;/code&gt; is wrapped in &lt;a href=&quot;../function&quot;&gt;&lt;code&gt;tf.function&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;model.train_on_batch&lt;/code&gt; 는 에 싸여 &lt;a href=&quot;../function&quot;&gt; &lt;code&gt;tf.function&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="27d5dd3eab0c124af031b708e6db7bb2cc0d63fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n_classes&lt;/code&gt; &amp;lt; 2.</source>
          <target state="translated">만약 &lt;code&gt;n_classes&lt;/code&gt; 는 &amp;lt;2.</target>
        </trans-unit>
        <trans-unit id="2f6d4550e5a6bf869f60e3fa1a350b466e933f5c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; are both provided, &lt;code&gt;index&lt;/code&gt; will take precedence. Indices are based on order of horizontal graph traversal (bottom-up).</source>
          <target state="translated">경우 &lt;code&gt;name&lt;/code&gt; 과 &lt;code&gt;index&lt;/code&gt; 모두 제공되는, &lt;code&gt;index&lt;/code&gt; 우선합니다. 지수는 수평 그래프 순회 (하단) 순서를 기준으로합니다.</target>
        </trans-unit>
        <trans-unit id="1c0d8013d0f068829822dba8e7f64091561f2075" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to a tensor in this graph.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이이 그래프의 텐서와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="ad8bc95945a72ec4e28c81731e09e5a537858c4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; does not correspond to an operation in this graph.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이이 그래프의 작업과 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="3dac99a82a4855fd92c0429d41a455207d7330df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a string.</source>
          <target state="translated">&lt;code&gt;name&lt;/code&gt; 이 문자열이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="9372fbbb9f4a9e0103eaf09446f99e6060f9ec7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name&lt;/code&gt; is not a valid scope name, according to the rules above.</source>
          <target state="translated">위의 규칙에 따라 이름이 유효한 범위 &lt;code&gt;name&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="72ec307ac7cb35e0dc1e4fe050cb0aec22f90730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;name_or_scope&lt;/code&gt; is not None, it is used as is. If &lt;code&gt;name_or_scope&lt;/code&gt; is None, then &lt;code&gt;default_name&lt;/code&gt; is used. In that case, if the same name has been previously used in the same scope, it will be made unique by appending &lt;code&gt;_N&lt;/code&gt; to it.</source>
          <target state="translated">경우 &lt;code&gt;name_or_scope&lt;/code&gt; 가 없음], 그것을있는 그대로 사용된다. 경우 &lt;code&gt;name_or_scope&lt;/code&gt; 은 없음입니다, 다음 &lt;code&gt;default_name&lt;/code&gt; 이 사용됩니다. 이 경우 같은 범위에서 같은 이름을 이미 사용한 경우에는 &lt;code&gt;_N&lt;/code&gt; 을 추가하여 고유 이름으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c871ac5f537b233d37ba8ba81c7ba4171a5f3e99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; has dimension sizes that are too small.</source>
          <target state="translated">경우 &lt;code&gt;new_shape&lt;/code&gt; 는 차원 크기가 너무 작은 것을.</target>
        </trans-unit>
        <trans-unit id="ad1c2af83bbee922d1c0918f60ae2fcb275044f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, returns a copy of &lt;code&gt;sp_input&lt;/code&gt; with its shape reset to the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;. This will be a shape consisting of all zeros if sp_input has no values.</source>
          <target state="translated">경우 &lt;code&gt;new_shape&lt;/code&gt; 은 아무도 없다, 사본 반환 &lt;code&gt;sp_input&lt;/code&gt; 을 의 꽉 경계 상자 모양의 리셋 &lt;code&gt;sp_input&lt;/code&gt; . sp_input에 값이없는 경우 모두 0으로 구성된 모양이됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca15a59d7a7782d5db584a1d747b2599f5ff187" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is None, the returned SparseTensor will have a shape [2, 3, 4], which is the tight bounding box of &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;new_shape&lt;/code&gt; 가 포함되지 않은 경우, 반환 SparseTensor은 타이트한 바운딩 박스 형상 [2, 3, 4], 것이다 &lt;code&gt;sp_input&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="d5b570d610cf7a295b2ffb10a0e162c56ba33211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is determined during graph build to have dimension sizes that are too small.</source>
          <target state="translated">그래프 빌드 중에 &lt;code&gt;new_shape&lt;/code&gt; 가 너무 작은 차원 크기를 갖는 것으로 결정된 경우 .</target>
        </trans-unit>
        <trans-unit id="2be9809aee367331cf17f4bd9c80ab0565a944bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; is provided, then it must be larger or equal in all dimensions compared to the shape of &lt;code&gt;sp_input&lt;/code&gt;. When this condition is met, the returned SparseTensor will have its shape reset to &lt;code&gt;new_shape&lt;/code&gt; and its indices and values unchanged from that of &lt;code&gt;sp_input.&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;new_shape&lt;/code&gt; 이 제공되는데, 그것은의 형상에 비해 모든 치수 더 크거나 같아야 &lt;code&gt;sp_input&lt;/code&gt; . 이 조건이 충족되면 반환 된 SparseTensor의 모양이 &lt;code&gt;new_shape&lt;/code&gt; 로 재설정 되고 해당 색인 및 값은 &lt;code&gt;sp_input.&lt;/code&gt; 값과 달라지지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="64e5cd1143e41daf1ced06d3243bd74d575211e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;new_shape&lt;/code&gt; represents a tensor with a different rank from that of &lt;code&gt;sp_input&lt;/code&gt; (if shapes are known when graph is constructed).</source>
          <target state="translated">경우 &lt;code&gt;new_shape&lt;/code&gt; 은 와는 다른 순위 텐서 나타내는 &lt;code&gt;sp_input&lt;/code&gt; 을 (그래프가 구축 될 때, 형태가 공지되어있는 경우).</target>
        </trans-unit>
        <trans-unit id="b3d289ff2fb51015d3982713a0b861287cc457fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nrows&lt;/code&gt; is incompatible with &lt;code&gt;value_rowids&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;nrows&lt;/code&gt; 가 &lt;code&gt;value_rowids&lt;/code&gt; 와 호환되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="d86dd9f224593f5a9a65b67de61c8f3febf1ab7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num&lt;/code&gt; is unspecified and cannot be inferred.</source>
          <target state="translated">경우 &lt;code&gt;num&lt;/code&gt; 정의되어 있지 않기 때문에 유추 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8e3e0c6e2098ecdeded1338dea9690c0f2076053" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_classes&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then &lt;code&gt;num_classes&lt;/code&gt; will be set to one plus the maximum value in either predictions or labels. Class labels are expected to start at 0. For example, if &lt;code&gt;num_classes&lt;/code&gt; is 3, then the possible labels would be &lt;code&gt;[0, 1, 2]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_classes&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음 &lt;code&gt;num_classes&lt;/code&gt; 는 하나 세트 플러스 중 하나를 예측 또는 라벨의 최대 값이됩니다. 클래스 레이블은 0에서 시작합니다. 예를 들어 &lt;code&gt;num_classes&lt;/code&gt; 가 3이면 가능한 레이블은 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2b01b0239cb5897c1f2262ed4d7ba81bcf45a0b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_columns&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="translated">&lt;code&gt;num_columns&lt;/code&gt; 가 비 스칼라 또는 음수로 정적으로 결정된 경우 .</target>
        </trans-unit>
        <trans-unit id="8b02682a5d13fd2735399ea0a59eeecd0b50698a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_cores_per_replica&lt;/code&gt; is not 1, 2, 4, 8, ..., 128.</source>
          <target state="translated">&lt;code&gt;num_cores_per_replica&lt;/code&gt; 가 1, 2, 4, 8, ..., 128이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="8cd499df460f2dd2f7fc2c6f79c89aefd06f4920" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_diags == 1&lt;/code&gt;, the output tensor is of rank &lt;code&gt;r - 1&lt;/code&gt; with shape &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; and values:</source>
          <target state="translated">경우 &lt;code&gt;num_diags == 1&lt;/code&gt; 출력 텐서 랭크이며 &lt;code&gt;r - 1&lt;/code&gt; 형상 &lt;code&gt;[I, J, ..., L, max_diag_len]&lt;/code&gt; 및 값 :</target>
        </trans-unit>
        <trans-unit id="e8ca4ee1f13309dc6f6b05d5f1ba5df5368509b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt; is not positive.</source>
          <target state="translated">&lt;code&gt;num_mel_bins&lt;/code&gt; 가 양수가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="0df0e8535951dd9f3d98a16079db075547e06704" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_mel_bins&lt;/code&gt;/&lt;code&gt;num_spectrogram_bins&lt;/code&gt;/&lt;code&gt;sample_rate&lt;/code&gt; are not positive, &lt;code&gt;lower_edge_hertz&lt;/code&gt; is negative, frequency edges are incorrectly ordered, &lt;code&gt;upper_edge_hertz&lt;/code&gt; is larger than the Nyquist frequency.</source>
          <target state="translated">경우 &lt;code&gt;num_mel_bins&lt;/code&gt; / &lt;code&gt;num_spectrogram_bins&lt;/code&gt; / &lt;code&gt;sample_rate&lt;/code&gt; 긍정적 없으며, &lt;code&gt;lower_edge_hertz&lt;/code&gt; 은 , 네거티브 주파수 에지가 잘못 정렬이다 &lt;code&gt;upper_edge_hertz&lt;/code&gt; 는 나이키 스트 주파수보다 크다.</target>
        </trans-unit>
        <trans-unit id="a71702fb3b8232853d975af1bf3071cd46c3b1ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), then &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(num_or_size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;num_or_size_splits[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_or_size_splits&lt;/code&gt; 은 1-D 텐서 (또는 목록)은 다음 &lt;code&gt;value&lt;/code&gt; 으로 분할 &lt;code&gt;len(num_or_size_splits)&lt;/code&gt; 소자. &lt;code&gt;i&lt;/code&gt; 번째 요소 의 모양은 크기가 &lt;code&gt;num_or_size_splits[i]&lt;/code&gt; 차원 &lt;code&gt;axis&lt;/code&gt; 따르는 것을 제외하고 는 &lt;code&gt;value&lt;/code&gt; 과 동일한 크기를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="2c715ccae994cba7abe259313788d2138f8a5aa1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is a 1-D Tensor (or list), we call it &lt;code&gt;size_splits&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; is split into &lt;code&gt;len(size_splits)&lt;/code&gt; elements. The shape of the &lt;code&gt;i&lt;/code&gt;-th element has the same size as the &lt;code&gt;value&lt;/code&gt; except along dimension &lt;code&gt;axis&lt;/code&gt; where the size is &lt;code&gt;size_splits[i]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_or_size_splits&lt;/code&gt; 은 1-D 텐서 (또는 목록), 우리는 호출 &lt;code&gt;size_splits&lt;/code&gt; 및 &lt;code&gt;value&lt;/code&gt; 으로 분할 인 &lt;code&gt;len(size_splits)&lt;/code&gt; 소자. &lt;code&gt;i&lt;/code&gt; 번째 요소 의 모양은 크기가 &lt;code&gt;size_splits[i]&lt;/code&gt; 차원 &lt;code&gt;axis&lt;/code&gt; 따르는 것을 제외하고 &lt;code&gt;value&lt;/code&gt; 과 크기가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e425839a9eabf146225bfd1f11c4b5874f2adbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_split&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;num_split&lt;/code&gt; evenly divides &lt;code&gt;value.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_or_size_splits&lt;/code&gt; 는 정수이며, 다음 &lt;code&gt;value&lt;/code&gt; 사이즈에 따라 분할되는 &lt;code&gt;axis&lt;/code&gt; 에 &lt;code&gt;num_split&lt;/code&gt; 작은 텐서는. 이를 위해서는 &lt;code&gt;num_split&lt;/code&gt; 이 &lt;code&gt;value.shape[axis]&lt;/code&gt; 균등하게 나눕니다 .</target>
        </trans-unit>
        <trans-unit id="86da9a142cb59be1ce483a5fcfad2cac22a8d043" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_or_size_splits&lt;/code&gt; is an integer, then &lt;code&gt;value&lt;/code&gt; is split along the dimension &lt;code&gt;axis&lt;/code&gt; into &lt;code&gt;num_or_size_splits&lt;/code&gt; smaller tensors. This requires that &lt;code&gt;value.shape[axis]&lt;/code&gt; is divisible by &lt;code&gt;num_or_size_splits&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_or_size_splits&lt;/code&gt; 는 정수이며, 다음 &lt;code&gt;value&lt;/code&gt; 차원을 따라 분할되는 &lt;code&gt;axis&lt;/code&gt; 에 &lt;code&gt;num_or_size_splits&lt;/code&gt; 작은 텐서는. 이를 위해서는 &lt;code&gt;value.shape[axis]&lt;/code&gt; 가 &lt;code&gt;num_or_size_splits&lt;/code&gt; 로 나눌 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="450b92a44da53848f27208da6d233973284dc0ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_partitions&lt;/code&gt; is an &lt;code&gt;int&lt;/code&gt; (not a &lt;code&gt;Tensor&lt;/code&gt;), then this is equivalent to &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;num_partitions&lt;/code&gt; 가 이다 &lt;code&gt;int&lt;/code&gt; (하지 &lt;code&gt;Tensor&lt;/code&gt; ), 이것은와 등가이다 &lt;code&gt;tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f769bea836beac98909e735795b268401e27cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_required&lt;/code&gt; &amp;lt; 1</source>
          <target state="translated">&lt;code&gt;num_required&lt;/code&gt; &amp;lt;1 인 경우</target>
        </trans-unit>
        <trans-unit id="d0c4741e676875df5f8a0b09ab68db16b833e851" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; is determined statically to be non-scalar, or negative.</source>
          <target state="translated">&lt;code&gt;num_rows&lt;/code&gt; 가 비 스칼라 또는 음수로 정적으로 결정된 경우 .</target>
        </trans-unit>
        <trans-unit id="b4d2e4a3dd2b3d6799b99f0fed96f253cc3a96f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_rows&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt; is ref-type (e.g. Variable).</source>
          <target state="translated">경우 &lt;code&gt;num_rows&lt;/code&gt; 또는 &lt;code&gt;batch_shape&lt;/code&gt; 은 REF 유형 (예 : 변수)입니다.</target>
        </trans-unit>
        <trans-unit id="579c0d608dfebee22c27bc3846a042bea0ea2e57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;num_shards &amp;lt;= 0&lt;/code&gt;</source>
          <target state="translated">만약 &lt;code&gt;num_shards &amp;lt;= 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5c5d7600c41cb44c71f5d9a769d0cc3ba62e628f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not a type we support attempting to convert to types.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 유형하지 않습니다 우리는 유형 변환을 시도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7d2f62aecc189f0d6978a16f51136df1dfdafa83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not an object in the graph.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 그래프의 객체가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="54195d19d2e45a3ab90b981e987d80bc875dcff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is not trackable.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 를 추적 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="d091a8b497d7d4382ab7948a754eedb14901ffe3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is of an appropriate type but invalid. For example, an invalid string.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 적절한 유형 만 유효하다. 예를 들어, 잘못된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="4931305edfb2d837c5c9e074234ca80b1ec8bcc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;off_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;0&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;off_value&lt;/code&gt; 이 제공되지 않으며,이 값을 기본값으로 &lt;code&gt;0&lt;/code&gt; 형과 &lt;code&gt;dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f5adee6d1a5e5c25242f126e70ed57f928baf19" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;on_value&lt;/code&gt; is not provided, it will default to the value &lt;code&gt;1&lt;/code&gt; with type &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;on_value&lt;/code&gt; 가 제공되지 않으면 기본값 은 &lt;code&gt;dtype&lt;/code&gt; 유형 의 값 &lt;code&gt;1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be75a55bcf9630188e5d84c928dfdd3d3057e4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; then &lt;code&gt;ignore_existing&lt;/code&gt; must be &lt;code&gt;True&lt;/code&gt; and the new scope resets all colocation and device constraints.</source>
          <target state="translated">경우 &lt;code&gt;op&lt;/code&gt; 없다 &lt;code&gt;None&lt;/code&gt; 다음 &lt;code&gt;ignore_existing&lt;/code&gt; 해야 &lt;code&gt;True&lt;/code&gt; 새로운 범위는 모든 코 로케이션 및 장치 제약을 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="6d6efe500a1e419471950274e32a27e9f28c978e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not a string.</source>
          <target state="translated">&lt;code&gt;op_type&lt;/code&gt; 이 문자열이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="420392368983977b5577e7d27b9eef71c57ac5d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type&lt;/code&gt; is not string.</source>
          <target state="translated">&lt;code&gt;op_type&lt;/code&gt; 이 문자열이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="4f506668c89a50f1d244e06bffb9e5da4a3f93cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_type_map&lt;/code&gt; is not a dictionary mapping strings to strings.</source>
          <target state="translated">&lt;code&gt;op_type_map&lt;/code&gt; 이 사전이 아닌 경우 문자열을 문자열로 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="70782498d2a8b5e1fb1b956108ea7f9d6947614f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operator.is_non_singular&lt;/code&gt; is False.</source>
          <target state="translated">&lt;code&gt;operator.is_non_singular&lt;/code&gt; 가 False 인 경우 .</target>
        </trans-unit>
        <trans-unit id="81ce4b8c411300123f420f7b7764c943a472c9df" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty or are non-square.</source>
          <target state="translated">&lt;code&gt;operators&lt;/code&gt; 가 비어 있거나 정사각형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="fb14b3c75832ddae6eceb4089bb41e04164cec51" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty, contains an erroneous number of elements, or contains operators with incompatible shapes.</source>
          <target state="translated">경우 &lt;code&gt;operators&lt;/code&gt; 비어있는, 요소의 잘못된 번호를 포함, 또는 호환되지 않는 모양 사업자를 포함한다.</target>
        </trans-unit>
        <trans-unit id="0178108ccd428b63c875a900e226b0c7611cbd90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;operators&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;operators&lt;/code&gt; 가 비어있는 경우 .</target>
        </trans-unit>
        <trans-unit id="2cfd171ea5e20a03c796a10ad68feaaf52cc516f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like [batch] matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_composed&lt;/code&gt; acts like the [batch] matrix formed with the multiplication &lt;code&gt;A1 A2...AJ&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;opj&lt;/code&gt; [배치] 매트릭스와 같은 역할 &lt;code&gt;Aj&lt;/code&gt; 다음 &lt;code&gt;op_composed&lt;/code&gt; 승산 형성된 [배치] 매트릭스와 같은 역할을 &lt;code&gt;A1 A2...AJ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c5724412cb951216de778a1bb8c5e384913867" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; acts like a [batch] square matrix &lt;code&gt;Aj&lt;/code&gt;, then &lt;code&gt;op_combined&lt;/code&gt; acts like the [batch] square matrix formed by having each matrix &lt;code&gt;Aj&lt;/code&gt; on the main diagonal.</source>
          <target state="translated">&lt;code&gt;opj&lt;/code&gt; 가 [배치] 정방 행렬 &lt;code&gt;Aj&lt;/code&gt; 와 같이 작용하는 경우 , &lt;code&gt;op_combined&lt;/code&gt; 는 주 대각선에 각각의 행렬 &lt;code&gt;Aj&lt;/code&gt; 를 가짐으로써 형성된 [배치] 정사각 행렬과 같이 작용한다 .</target>
        </trans-unit>
        <trans-unit id="70c95e66ca24f2c6cab4d98e44a70b5b962a0ab7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">경우 &lt;code&gt;opj&lt;/code&gt; 형상 보유 &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt; 다음 결합 연산자를 갖는 형상 &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt; , &lt;code&gt;broadcast_batch_shape&lt;/code&gt; 가 의 상호 브로드 캐스트 &lt;code&gt;batch_shape_j&lt;/code&gt; , &lt;code&gt;j = 1,...,J&lt;/code&gt; 중간 가정을 배치 모양 방송. 조합 된 형상이 잘 정의되어 있어도, 정의 된 운영자의 방법에서 방송 능력의 부족으로 인해 조합 된 운영자의 방법이 실패 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6d412d219703e29a2801725218983e3abe4d8a5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then the composed operator will have shape equal to &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt;, where the product is over all operators.</source>
          <target state="translated">경우 &lt;code&gt;opj&lt;/code&gt; 형상 보유 &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; 다음 합성 오퍼레이터 형상이 동일한 것 &lt;code&gt;broadcast_batch_shape + [prod M_j, prod N_j]&lt;/code&gt; 제품 모든 운영자 이상이다.</target>
        </trans-unit>
        <trans-unit id="3035e177d8f7c6c99dae97a0ceb7953b26b8092b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;opj&lt;/code&gt; has shape &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt;, then we must have &lt;code&gt;N_j = M_{j+1}&lt;/code&gt;, in which case the composed operator has shape equal to &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 1,...,J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the composed shape is well defined, the composed operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">&lt;code&gt;opj&lt;/code&gt; 가 &lt;code&gt;batch_shape_j + [M_j, N_j]&lt;/code&gt; 모양 인 경우 N_j &lt;code&gt;N_j = M_{j+1}&lt;/code&gt; 이 있어야합니다.이 경우 구성된 연산자의 모양은 &lt;code&gt;broadcast_batch_shape + [M_1, N_J]&lt;/code&gt; 와 동일합니다. 여기서 &lt;code&gt;broadcast_batch_shape&lt;/code&gt; 는 상호 브로드 캐스트입니다. 중간 배치 형태 브로드 캐스트를 가정하면 &lt;code&gt;batch_shape_j&lt;/code&gt; , &lt;code&gt;j = 1,...,J&lt;/code&gt; 구성된 형태가 잘 정의되어 있어도, 정의 된 운영자의 방법에서 방송 능력의 부족으로 인해 작성된 운영자의 방법이 실패 할 수있다.</target>
        </trans-unit>
        <trans-unit id="6ee93e7db0e30b7b5ccbb4d4fe3fae08772f421e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ord&lt;/code&gt; or &lt;code&gt;axis&lt;/code&gt; is invalid.</source>
          <target state="translated">경우 &lt;code&gt;ord&lt;/code&gt; 또는 &lt;code&gt;axis&lt;/code&gt; 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c905352aaa38aa4276b9e3ddc88efb6fafdbe603" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;outputs_from_all_shards&lt;/code&gt; is true, the outputs from all shards of &lt;code&gt;computation&lt;/code&gt; are concatenated back together along their &lt;code&gt;output_shard_axes&lt;/code&gt;. Otherwise, each output is taken from an arbitrary shard.</source>
          <target state="translated">경우 &lt;code&gt;outputs_from_all_shards&lt;/code&gt; 는 사실, 모든 파편으로부터 출력 &lt;code&gt;computation&lt;/code&gt; 들이 함께 다시 함께 연결된다 &lt;code&gt;output_shard_axes&lt;/code&gt; . 그렇지 않으면 각 출력은 임의의 샤드에서 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9c1db6d79ffe07ebfaf8de704e064c8ef0b35ebe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pad_end&lt;/code&gt; is True, window positions that are past the end of the &lt;code&gt;axis&lt;/code&gt; dimension are padded with &lt;code&gt;pad_value&lt;/code&gt; until the window moves fully past the end of the dimension. Otherwise, only window positions that fully overlap the &lt;code&gt;axis&lt;/code&gt; dimension are produced.</source>
          <target state="translated">경우 &lt;code&gt;pad_end&lt;/code&gt; 가 True 인,의 끝을지나있는 창 위치 &lt;code&gt;axis&lt;/code&gt; 차원으로 채워집니다 &lt;code&gt;pad_value&lt;/code&gt; 완전히 차원의 끝을지나 창 이동할 때까지. 그렇지 않으면 &lt;code&gt;axis&lt;/code&gt; 치수와 완전히 겹치는 창 위치 만 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="25d3dd5a787fb24d03624723b6ac3cb1fb7aafbe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;padding = &quot;SAME&quot;&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="0d24b307563d3f47caf57f6854d09c49e17b493e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt;, then:</source>
          <target state="translated">만약 &lt;code&gt;padding = &quot;VALID&quot;&lt;/code&gt; 다음 :</target>
        </trans-unit>
        <trans-unit id="11ca6ba85b93d818d20fc26499223569c33f6979" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;params&lt;/code&gt; is empty.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 가 비어있는 경우 .</target>
        </trans-unit>
        <trans-unit id="daf5b935b68f7f3addfed5f414c654714bb029cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;div&quot;&lt;/code&gt;, we assign ids to partitions in a contiguous manner. In this case, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;partition_strategy&lt;/code&gt; 가 &lt;code&gt;&quot;div&quot;&lt;/code&gt; 인 경우 파티션 에 ID를 연속적인 방식으로 할당합니다. 이 경우 13 개의 id가 &lt;code&gt;[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]&lt;/code&gt; 와 같이 5 개의 파티션으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="8acefec1523d308517a865bae60c7cc0aa4b6057" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;partition_strategy&lt;/code&gt; is &lt;code&gt;&quot;mod&quot;&lt;/code&gt;, we assign each id to partition &lt;code&gt;p = id % len(params)&lt;/code&gt;. For instance, 13 ids are split across 5 partitions as: &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;partition_strategy&lt;/code&gt; 가 &lt;code&gt;&quot;mod&quot;&lt;/code&gt; 인 경우 각 ID를 파티션 &lt;code&gt;p = id % len(params)&lt;/code&gt; 할당합니다 . 예를 들어 13 개의 id는 &lt;code&gt;[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]&lt;/code&gt; 와 같이 5 개의 파티션으로 분할됩니다.</target>
        </trans-unit>
        <trans-unit id="d9c4832f7e4328cf39f111c97dc0ee8e31c623cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for reading.</source>
          <target state="translated">읽기 위해 &lt;code&gt;path&lt;/code&gt; 를 열 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="e74a52c15c25f1deff61b03412dd4b9ef7402c3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; cannot be opened for writing.</source>
          <target state="translated">쓰기 위해 &lt;code&gt;path&lt;/code&gt; 를 열 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="32dcb7eb9b33345678e978099f889acba18b6559" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pos&lt;/code&gt; specifies an index which is out of range for any of the input strings, then an &lt;code&gt;InvalidArgumentError&lt;/code&gt; is thrown.</source>
          <target state="translated">경우 &lt;code&gt;pos&lt;/code&gt; 지정 입력 문자열의 임의의 범위를 벗어 인덱스, 다음 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 발생된다.</target>
        </trans-unit>
        <trans-unit id="03ca2ac0f5daf2ce02e137acee45f05e52ca4ccb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred&lt;/code&gt; is true, the &lt;code&gt;data&lt;/code&gt; input is forwarded to &lt;code&gt;output_true&lt;/code&gt;. Otherwise, the data goes to &lt;code&gt;output_false&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;pred&lt;/code&gt; 사실은 &lt;code&gt;data&lt;/code&gt; 입력에 전달됩니다 &lt;code&gt;output_true&lt;/code&gt; . 그렇지 않으면 데이터가 &lt;code&gt;output_false&lt;/code&gt; 로 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="2d6e53d36d6444935a96915d1d79cd000b99cfed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is a list but does not contain 2-tuples.</source>
          <target state="translated">경우 &lt;code&gt;pred_fn_pairs&lt;/code&gt; 목록입니다 만 2 튜플이 포함되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="02938a2c875b72d48bca1955864a514d0d9f55e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/dictionary.</source>
          <target state="translated">&lt;code&gt;pred_fn_pairs&lt;/code&gt; 가 목록 / 사전이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="0803575352c843b52cd64dde7a3cf2cb1dfc4156" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pred_fn_pairs&lt;/code&gt; is not a list/tuple.</source>
          <target state="translated">&lt;code&gt;pred_fn_pairs&lt;/code&gt; 가 목록 / 튜플이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="8bfbd5fb700df00f8f689300a675fa3f95d1aad0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;sensitivity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="translated">경우 &lt;code&gt;predictions&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; 경우, 일치하지 않는 모양이 &lt;code&gt;weights&lt;/code&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; 과 그 모양이 일치하지 않는 &lt;code&gt;predictions&lt;/code&gt; 경우, 또는 &lt;code&gt;sensitivity&lt;/code&gt; 하지 0과 1 사이, 또는 두 경우이다 &lt;code&gt;metrics_collections&lt;/code&gt; 또는 &lt;code&gt;updates_collections&lt;/code&gt; 은 목록이나 튜플 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="abf2fb54afc0a18a4d2f2c8afb5a2f3962603b49" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if &lt;code&gt;specificity&lt;/code&gt; is not between 0 and 1, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="translated">경우 &lt;code&gt;predictions&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; 경우, 일치하지 않는 모양이 &lt;code&gt;weights&lt;/code&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; 과 그 모양이 일치하지 않는 &lt;code&gt;predictions&lt;/code&gt; 경우, 또는 &lt;code&gt;specificity&lt;/code&gt; 하지 0과 1 사이, 또는 경우입니다 중 하나 &lt;code&gt;metrics_collections&lt;/code&gt; 또는 &lt;code&gt;updates_collections&lt;/code&gt; 은 목록이나 튜플 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6566667c2b1365a10aad1c89c55d266db371015d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="translated">경우 &lt;code&gt;predictions&lt;/code&gt; 및 &lt;code&gt;labels&lt;/code&gt; 일치하지 않는 모양이 경우, 또는 &lt;code&gt;weights&lt;/code&gt; 되지 않습니다 &lt;code&gt;None&lt;/code&gt; 과 그 모양이 일치하지 않는 &lt;code&gt;predictions&lt;/code&gt; , 또는 두 경우 &lt;code&gt;metrics_collections&lt;/code&gt; 또는 &lt;code&gt;updates_collections&lt;/code&gt; 이 목록 또는 튜플이 없습니다.</target>
        </trans-unit>
        <trans-unit id="952ccf888d95d822b40e43d22e37817a337a6956" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;predictions&lt;/code&gt; shape doesn't match &lt;code&gt;labels&lt;/code&gt; shape, or &lt;code&gt;axis&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, &lt;code&gt;predictions&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;predictions&lt;/code&gt; 모양이 일치하지 않는 &lt;code&gt;labels&lt;/code&gt; 모양, 또는 &lt;code&gt;axis&lt;/code&gt; , &lt;code&gt;labels&lt;/code&gt; , &lt;code&gt;predictions&lt;/code&gt; 또는 &lt;code&gt;weights&lt;/code&gt; 없다 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7deb2d39051bc835be02d8f59da912bfcce83c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; is True, then a preprocessing step runs before loss calculation, wherein repeated labels passed to the loss are merged into single labels. This is useful if the training labels come from, e.g., forced alignments and therefore have unnecessary repetitions.</source>
          <target state="translated">경우 &lt;code&gt;preprocess_collapse_repeated&lt;/code&gt; True 인 다음, 전처리 단계가 실행 손실에 전달 반복 레이블이 하나의 라벨에 통합되는 것을 특징으로하는 손실 계산, 전. 이는 훈련 레이블이 예를 들어 강제 정렬에서 유래하여 불필요한 반복이있는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="021bcc8eda694846961d1929e447de455777799b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;queue&lt;/code&gt; or &lt;code&gt;enqueue_ops&lt;/code&gt; are not provided when not restoring from &lt;code&gt;queue_runner_def&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;queue&lt;/code&gt; 또는 &lt;code&gt;enqueue_ops&lt;/code&gt; 가 에서 복원하지 않을 경우 제공되지 않습니다 &lt;code&gt;queue_runner_def&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="164ac4e2b4a18286f06657a73f0ee558a2997841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor.</source>
          <target state="translated">경우 &lt;code&gt;rate&lt;/code&gt; 아닌 &lt;code&gt;[0, 1)&lt;/code&gt; 경우 또는 &lt;code&gt;x&lt;/code&gt; 부동 소수점 텐서 아니다.</target>
        </trans-unit>
        <trans-unit id="e55af12f0841b7b616eb136847a3820481361af7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rate&lt;/code&gt; is not in &lt;code&gt;[0, 1)&lt;/code&gt; or if &lt;code&gt;x&lt;/code&gt; is not a floating point tensor. &lt;code&gt;rate=1&lt;/code&gt; is disallowed, because the output would be all zeros, which is likely not what was intended.</source>
          <target state="translated">경우 &lt;code&gt;rate&lt;/code&gt; 아닌 &lt;code&gt;[0, 1)&lt;/code&gt; 경우 또는 &lt;code&gt;x&lt;/code&gt; 부동 소수점 텐서 아니다. &lt;code&gt;rate=1&lt;/code&gt; 은 허용되지 않습니다. 왜냐하면 출력이 의도 한 것과 다를 가능성이있는 모두 0이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e2e7bb60ddbe91fd7e6b982336b25fa2822fa9ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reader&lt;/code&gt; is of the wrong type.</source>
          <target state="translated">경우 &lt;code&gt;reader&lt;/code&gt; 잘못된 타입이다.</target>
        </trans-unit>
        <trans-unit id="c3d718c63c1f1f0484423b570fc9531a8eff9cfe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ready_op&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, the model is not checked for readiness.</source>
          <target state="translated">경우 &lt;code&gt;ready_op&lt;/code&gt; 이 없는 &lt;code&gt;None&lt;/code&gt; ,이 모델은 준비를 위해 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7957aaf8b9510d63a4030b611485abaa1905453d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt;: Result (on all replicas): {'a': 2, 'b': [21, 49.5]}</source>
          <target state="translated">&lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;MEAN&lt;/code&gt; 인 경우 : 결과 (모든 복제본에서) : { 'a': 2, 'b': [21, 49.5]}</target>
        </trans-unit>
        <trans-unit id="e4c642304f745aaea2e1c1147192fb97d8fc30e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt;: Result (on all replicas): {'a': 4, 'b': [42, 99]}</source>
          <target state="translated">만약 &lt;code&gt;reduce_op&lt;/code&gt; == &lt;code&gt;SUM&lt;/code&gt; : 결과 (모든 복제본) { 'A': 4 ', B': [42, 99]}</target>
        </trans-unit>
        <trans-unit id="e0e30804ebbc33a2fc0166b120175f12f1b8b76b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, similar to the indexing rules in Python.</source>
          <target state="translated">경우 &lt;code&gt;reduction_axes&lt;/code&gt; 가 어떤 항목이있다, 모든 치수가 감소되고, 단일 요소 텐서가 반환된다. 또한 축은 Python의 색인 규칙과 유사하게 음수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="482cc696ec3bec581c709c5132a29fbf3c487797" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reduction_axes&lt;/code&gt; has no entries, all dimensions are reduced, and a tensor with a single element is returned. Additionally, the axes can be negative, which are interpreted according to the indexing rules in Python.</source>
          <target state="translated">경우 &lt;code&gt;reduction_axes&lt;/code&gt; 가 어떤 항목이있다, 모든 치수가 감소되고, 단일 요소 텐서가 반환된다. 또한 축은 음수 일 수 있으며 이는 파이썬의 색인 규칙에 따라 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="7f48379c242cda6f408083ddc4d5f3cb83c5bd03" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return_sequences&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="d35fbb8939197c7ac96515a84b436c62c4114b16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: 5D tensor with shape: &lt;code&gt;(samples, timesteps, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 5D tensor with shape: &lt;code&gt;(samples, timesteps, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'.</source>
          <target state="translated">만약 &lt;code&gt;return_sequences&lt;/code&gt; : 형상 5D 텐서 : &lt;code&gt;(samples, timesteps, filters, new_rows, new_cols)&lt;/code&gt; : 만약 형상 data_format = 'channels_first'또는 5D 텐서 &lt;code&gt;(samples, timesteps, new_rows, new_cols, filters)&lt;/code&gt; data_format = 'channels_last 간다면.</target>
        </trans-unit>
        <trans-unit id="5e96de43a368a04807126c38f92e9d01f46e8303" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_sequences&lt;/code&gt;: N-D tensor with shape &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt;, where &lt;code&gt;output_size&lt;/code&gt; could be a high dimension tensor shape, or &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; when &lt;code&gt;time_major&lt;/code&gt; is True.</source>
          <target state="translated">만약 &lt;code&gt;return_sequences&lt;/code&gt; : 모양 ND 텐서 &lt;code&gt;[batch_size, timesteps, output_size]&lt;/code&gt; , &lt;code&gt;output_size&lt;/code&gt; 는 높은 차원 텐서 모양, 또는 수 &lt;code&gt;[timesteps, batch_size, output_size]&lt;/code&gt; 때 &lt;code&gt;time_major&lt;/code&gt; 은 True입니다.</target>
        </trans-unit>
        <trans-unit id="cf834b2e8c72ada021e5e5fa26d98ff38d8ebe5e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each 4D tensor with shape: &lt;code&gt;(samples, filters, new_rows, new_cols)&lt;/code&gt; if data_format='channels_first' or 4D tensor with shape: &lt;code&gt;(samples, new_rows, new_cols, filters)&lt;/code&gt; if data_format='channels_last'. &lt;code&gt;rows&lt;/code&gt; and &lt;code&gt;cols&lt;/code&gt; values might have changed due to padding.</source>
          <target state="translated">만약 &lt;code&gt;return_state&lt;/code&gt; : 텐서의 목록을 표시합니다. 첫 번째 텐서는 출력입니다. 나머지 텐서는 마지막 상태입니다. 각 4D 텐서에는 모양 : &lt;code&gt;(samples, filters, new_rows, new_cols)&lt;/code&gt; if data_format = 'channels_first'또는 4D tensor with shape : &lt;code&gt;(samples, new_rows, new_cols, filters)&lt;/code&gt; if data_format = 'channels_last' . 패딩으로 인해 &lt;code&gt;rows&lt;/code&gt; 및 &lt;code&gt;cols&lt;/code&gt; 값이 변경되었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8de50555e0eeebb193b44d9f99c305b469369c4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;return_state&lt;/code&gt;: a list of tensors. The first tensor is the output. The remaining tensors are the last states, each with shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt;, where &lt;code&gt;state_size&lt;/code&gt; could be a high dimension tensor shape.</source>
          <target state="translated">&lt;code&gt;return_state&lt;/code&gt; 인 경우 : 텐서 목록. 첫 번째 텐서는 출력입니다. 나머지 텐서는 각각 모양이 &lt;code&gt;[batch_size, state_size]&lt;/code&gt; 인 마지막 상태이며 , 여기서 &lt;code&gt;state_size&lt;/code&gt; 는 고차원 텐서 모양 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c98b068e115a7b1a126126186d96ebd64c8bfe6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;row_splits&lt;/code&gt; is an empty list.</source>
          <target state="translated">경우 &lt;code&gt;row_splits&lt;/code&gt; 빈 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ffb605686f7d9f5fc6c475658638babbcf6232d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use &lt;code&gt;sample_weight&lt;/code&gt; of 0 to mask values.</source>
          <target state="translated">경우 &lt;code&gt;sample_weight&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 무게는 1.의 기본값 &lt;code&gt;sample_weight&lt;/code&gt; 값을 마스크 0.</target>
        </trans-unit>
        <trans-unit id="8e28d91535a97ad650cc949f37258bb71da692f0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false negatives.</source>
          <target state="translated">경우 &lt;code&gt;sample_weight&lt;/code&gt; 이 주어집니다, 위음성의 가중치의 합을 계산합니다. 이 메트릭은 오 탐지 수를 추적하는 데 사용되는 하나의 로컬 변수 &lt;code&gt;accumulator&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="255358980ac8b58546dfe37fcb80b61a3fab0190" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of false positives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of false positives.</source>
          <target state="translated">경우 &lt;code&gt;sample_weight&lt;/code&gt; 이 주어집니다, 오탐 (false positive)의 가중치의 합을 계산합니다. 이 메트릭은 오 탐지 수를 추적하는 데 사용되는 하나의 로컬 변수 &lt;code&gt;accumulator&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0a327cf38b6bc10153f472fc600865ad7c34dc87" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true negatives. This metric creates one local variable, &lt;code&gt;accumulator&lt;/code&gt; that is used to keep track of the number of true negatives.</source>
          <target state="translated">경우 &lt;code&gt;sample_weight&lt;/code&gt; 이 주어진다 사실 네거티브의 가중치의 합을 계산합니다. 이 측정 항목은 실제 음수의 수를 추적하는 데 사용되는 하나의 로컬 변수 &lt;code&gt;accumulator&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="157668b96cb6839360efaa68f2be010a0995a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sample_weight&lt;/code&gt; is given, calculates the sum of the weights of true positives. This metric creates one local variable, &lt;code&gt;true_positives&lt;/code&gt; that is used to keep track of the number of true positives.</source>
          <target state="translated">경우 &lt;code&gt;sample_weight&lt;/code&gt; 이 주어 진정한 양성의 가중치의 합을 계산합니다. 이 메트릭은 true 긍정 수를 추적하는 데 사용되는 하나의 로컬 변수 &lt;code&gt;true_positives&lt;/code&gt; 를 작성 합니다.</target>
        </trans-unit>
        <trans-unit id="1e99ed35485fa039a5ec399ab8ebf0bb9e48f66d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;scale&lt;/code&gt; or &lt;code&gt;center&lt;/code&gt; are enabled, the layer will scale the normalized outputs by broadcasting them with a trainable variable &lt;code&gt;gamma&lt;/code&gt;, and center the outputs by broadcasting with a trainable variable &lt;code&gt;beta&lt;/code&gt;. &lt;code&gt;gamma&lt;/code&gt; will default to a ones tensor and &lt;code&gt;beta&lt;/code&gt; will default to a zeros tensor, so that centering and scaling are no-ops before training has begun.</source>
          <target state="translated">경우 &lt;code&gt;scale&lt;/code&gt; 또는 &lt;code&gt;center&lt;/code&gt; 활성화되어, 층이 학습 가능한 변수로 방송함으로써 정규화 출력을 확장 할 수 &lt;code&gt;gamma&lt;/code&gt; 및 학습 가능한 변수로하여 방송 출력을 중심 &lt;code&gt;beta&lt;/code&gt; . &lt;code&gt;gamma&lt;/code&gt; 는 기본적으로 1 텐서가되고 &lt;code&gt;beta&lt;/code&gt; 는 기본적으로 0 텐서가되므로 훈련이 시작되기 전에 센터링과 스케일링이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2da19779e187c2e650651bd30fa0693bb089d6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_non_singular&lt;/code&gt; or &lt;code&gt;is_square&lt;/code&gt; is False.</source>
          <target state="translated">경우 &lt;code&gt;self.is_non_singular&lt;/code&gt; 또는 &lt;code&gt;is_square&lt;/code&gt; 은 False입니다.</target>
        </trans-unit>
        <trans-unit id="48227b911119a516c4d8c5a10f56b38e2c7b085a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.is_square&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self.is_square&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="7e7a2e7a633e9dd2077225b20b7446adffe78f77" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible (see is_compatible_with).</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 가 호환되지 않는 경우 (is_compatible_with 참조).</target>
        </trans-unit>
        <trans-unit id="76678c2c433bcbde5907f519d3fe1c0a7ff4a4ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are not compatible.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 가 호환되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="23ed2a5d39e1cb42af886c61df533070e9fe88a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent shapes with the same rank.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 와 &lt;code&gt;other&lt;/code&gt; 가 같은 순위의 모양을 나타내지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="e45c24232f29a913f2a86b78d61193ec7a0ecbe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; do not represent the same shape.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 과 &lt;code&gt;other&lt;/code&gt; 이 같은 모양을 나타내지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="b0e0efa59d0ad24d8ba4a6fa76b6d4d0ad5e1aff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not have a known value for every dimension.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 모든 차원에 대해 알려진 값을 가지고 있지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="451641d83eca8517ac4bb5051d5fc61e52bf5cea" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at least the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 적어도 주어진 &lt;code&gt;rank&lt;/code&gt; 의 모양을 나타내지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="595c977a574f63ee86be4dd6f2c6b66f30a423e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with at most the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 주어진 &lt;code&gt;rank&lt;/code&gt; 의 모양을 나타내지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="ab3f402cb6f12b2b990c1d375019237fc953c651" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; does not represent a shape with the given &lt;code&gt;rank&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 주어진 &lt;code&gt;rank&lt;/code&gt; 의 모양을 나타내지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="cd0283c3881ae85d735ecc7e5f6bee51fe71c8d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is an unknown shape with an unknown rank.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 알려지지 않은 순위를 가진 알려지지 않은 모양 인 경우 .</target>
        </trans-unit>
        <trans-unit id="bffe63db0549b3cd56cefe8885a84cdb4b1bd6c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is an empty string, each element of the &lt;code&gt;source&lt;/code&gt; is split into individual strings, each containing one byte. (This includes splitting multibyte sequences of UTF-8.) If delimiter contains multiple bytes, it is treated as a set of delimiters with each considered a potential split point.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 빈 문자열의 각 요소 &lt;code&gt;source&lt;/code&gt; , 각각의 스트링에 각각 포함하는 한 바이트 분할된다. (여기에는 UTF-8의 멀티 바이트 시퀀스 분할이 포함됩니다.) 분리 문자에 여러 바이트가 포함 된 경우, 각각 분리 가능한 것으로 간주되는 분리 문자 세트로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="9fdfb5a1f94fc643caca96a1c21220a86e536291" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, &lt;code&gt;input&lt;/code&gt; of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and &lt;code&gt;sep&lt;/code&gt; of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the start or end if the string has leading or trailing whitespace.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 주어진다 연속 구분 기호가 함께 그룹화되지 않고 빈 문자열을 구분하는 것으로 간주됩니다. 예를 들어, &lt;code&gt;input&lt;/code&gt; 의 &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; 및 &lt;code&gt;sep&lt;/code&gt; 의 &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; 복귀 &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt; . 경우 &lt;code&gt;sep&lt;/code&gt; 없음 빈 문자열이없는 연속적인 공백 단일 세퍼레이터로 간주하고, 문자열이 선행 또는 후행 공백 경우 결과의 시작 또는 끝에서 빈 문자열을 포함하는 것.</target>
        </trans-unit>
        <trans-unit id="92dd030f8c8e48b20c9e8313f19f4213c360c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is given, consecutive delimiters are not grouped together and are deemed to delimit empty strings. For example, source of &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; and sep of &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; returns &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt;. If &lt;code&gt;sep&lt;/code&gt; is None or an empty string, consecutive whitespace are regarded as a single separator, and the result will contain no empty strings at the startor end if the string has leading or trailing whitespace.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 주어진다 연속 구분 기호가 함께 그룹화되지 않고 빈 문자열을 구분하는 것으로 간주됩니다. 예를 들어 &lt;code&gt;&quot;1&amp;lt;&amp;gt;2&amp;lt;&amp;gt;&amp;lt;&amp;gt;3&quot;&lt;/code&gt; 소스 와 &lt;code&gt;&quot;&amp;lt;&amp;gt;&quot;&lt;/code&gt; 의 sep 는 &lt;code&gt;[&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;]&lt;/code&gt; 반환합니다 . 경우 &lt;code&gt;sep&lt;/code&gt; 없음 빈 문자열이없는 연속적인 공백 단일 세퍼레이터로 간주하고, 문자열이 선행 또는 후행 공백 경우 결과는 startor 단부에 빈 문자열을 포함하는 것.</target>
        </trans-unit>
        <trans-unit id="410d562c0da8a3bf9960cfbc34a9467e74826468" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sequence&lt;/code&gt; format, &lt;code&gt;diagonals&lt;/code&gt; is list or tuple of three tensors: &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt;, each having shape [..., M]. Last element of &lt;code&gt;superdiag&lt;/code&gt; first element of &lt;code&gt;subdiag&lt;/code&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;sequence&lt;/code&gt; 형식 &lt;code&gt;diagonals&lt;/code&gt; 목록 또는 세 텐서의 튜플이다 : &lt;code&gt;[superdiag, maindiag, subdiag]&lt;/code&gt; 각각 갖는 형상 ..., M]. 마지막 요소 &lt;code&gt;superdiag&lt;/code&gt; 의 첫 번째 요소 &lt;code&gt;subdiag&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d4e69b0caa45c8dda4e5a80e1ddb9661eb89a96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; does not describe a well-formed topology.</source>
          <target state="translated">&lt;code&gt;serialized&lt;/code&gt; 경우 올바른 형식의 토폴로지를 설명하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9275c1cc2beb3aadef035909c57a8214c7cb4e18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;device_coordinates&lt;/code&gt; is not a rank 4 numpy int32 array that describes a valid coordinate mapping.</source>
          <target state="translated">경우 &lt;code&gt;serialized&lt;/code&gt; 없다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;device_coordinates&lt;/code&gt; 는 유효한 매핑 좌표에 대해 설명 순위 4 NumPy와의 INT32 배열이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="1ebed2d9ba6ebe4d7486ba61e6980ca257015166" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;serialized&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;mesh_shape&lt;/code&gt; is not a sequence of 4 positive integers.</source>
          <target state="translated">경우 &lt;code&gt;serialized&lt;/code&gt; 없습니다 &lt;code&gt;None&lt;/code&gt; 과 &lt;code&gt;mesh_shape&lt;/code&gt; 은 4 양 개의 정수의 순서가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="48cd1c4325dfb3d13a2d209689253e4d7ddd0b5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sess&lt;/code&gt; is not a &lt;code&gt;Session&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sess&lt;/code&gt; 가 &lt;code&gt;Session&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="7934bc8a2624320349f9c139def414a89ff0e04b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises any exceptions then &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">경우 &lt;code&gt;session.run()&lt;/code&gt; 다음 예외를 제기 &lt;code&gt;after_run()&lt;/code&gt; 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="09784c2129ebb38568a3c1d9df7ccc60926fc6ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;session.run()&lt;/code&gt; raises exception other than OutOfRangeError or StopIteration then &lt;code&gt;end()&lt;/code&gt; is not called. Note the difference between &lt;code&gt;end()&lt;/code&gt; and &lt;code&gt;after_run()&lt;/code&gt; behavior when &lt;code&gt;session.run()&lt;/code&gt; raises OutOfRangeError or StopIteration. In that case &lt;code&gt;end()&lt;/code&gt; is called but &lt;code&gt;after_run()&lt;/code&gt; is not called.</source>
          <target state="translated">경우 &lt;code&gt;session.run()&lt;/code&gt; 다음 OutOfRangeError 또는 StopIteration을 이외의 예외 제기 &lt;code&gt;end()&lt;/code&gt; 호출되지 않습니다. &lt;code&gt;session.run()&lt;/code&gt; OutOfRangeError 또는 StopIteration을 발생시키는 경우 &lt;code&gt;end()&lt;/code&gt; 와 &lt;code&gt;after_run()&lt;/code&gt; 동작 의 차이점에 유의하십시오 . 이 경우 &lt;code&gt;end()&lt;/code&gt; 는 호출되지만 &lt;code&gt;after_run()&lt;/code&gt; 은 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="57fd1127c11716bc2d9489a6deb8f1692eefbda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has more than one inferred (== -1) dimension.</source>
          <target state="translated">경우 &lt;code&gt;shape&lt;/code&gt; 추정 이상의 (== -1) 치수를 갖는다.</target>
        </trans-unit>
        <trans-unit id="acdb39fad8818509a7732132e218e156173f9c64" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is not compatible with the current shape of this tensor.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 이이 텐서의 현재 모양과 호환되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="26186007203a58d8911a11ba346690902e600819" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is set, the &lt;code&gt;value&lt;/code&gt; is reshaped to match. Scalars are expanded to fill the &lt;code&gt;shape&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;shape&lt;/code&gt; 설정되면, &lt;code&gt;value&lt;/code&gt; 일치로 재편된다. 스칼라가 &lt;code&gt;shape&lt;/code&gt; 을 채우기 위해 확장됩니다 .</target>
        </trans-unit>
        <trans-unit id="69ba8d826fa53cdf396fee409e1ec4f0ecdb1a26" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; is specified, then the result is padded and/or truncated to the specified shape.</source>
          <target state="translated">경우에 &lt;code&gt;shape&lt;/code&gt; 지정되고, 그 결과는 패딩 및 / 또는 소정의 형상으로 절단된다.</target>
        </trans-unit>
        <trans-unit id="89232de163bc637ce58f4516f0bdef60a5ef7e2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signal&lt;/code&gt;'s rank is less than 2, or &lt;code&gt;frame_step&lt;/code&gt; is not a scalar integer.</source>
          <target state="translated">경우 &lt;code&gt;signal&lt;/code&gt; 의 순위보다 2, 또는 &lt;code&gt;frame_step&lt;/code&gt; 는 스칼라 정수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7166a5ed0f15f536c01b378a69cfaac5e2d9fa6b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_length&lt;/code&gt; is not a multiple of &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;signals&lt;/code&gt; 적어도 1 레벨 아니다 &lt;code&gt;frame_length&lt;/code&gt; 스칼라 없거나 &lt;code&gt;frame_length&lt;/code&gt; 의 배수가 아닌 &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="613ee7740260ce62973f1ab1c65d17f5e2743235" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;signals&lt;/code&gt; is not at least rank 1, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, or &lt;code&gt;frame_step&lt;/code&gt; is not scalar.</source>
          <target state="translated">경우 &lt;code&gt;signals&lt;/code&gt; 적어도 1 레벨 아니다 &lt;code&gt;frame_length&lt;/code&gt; 스칼라 없거나 &lt;code&gt;frame_step&lt;/code&gt; 는 스칼라 아니다.</target>
        </trans-unit>
        <trans-unit id="8f4fbedf928e2361e80160d5a67f755abc60ef5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;skip_mismatch&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; when &lt;code&gt;by_name&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;by_name&lt;/code&gt; 이 &lt;code&gt;False&lt;/code&gt; 일 때 &lt;code&gt;skip_mismatch&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 설정된 경우 .</target>
        </trans-unit>
        <trans-unit id="c3a1b0007ac4afd8d13976ea5e308a532f9b01d8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;source_column&lt;/code&gt; is not a numeric column, or if it is not one-dimensional.</source>
          <target state="translated">경우 &lt;code&gt;source_column&lt;/code&gt; 이 숫자 열 아니거나 하나의 차원이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="3306aee7110cf653f0faca81ca3e2580c65d51bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; 다음 &lt;code&gt;output.shape = [D0, D1, ..., Dn, vocab_size]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb1cc9cf91251c8b6f3f93a0a55857068bb3f279" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt;, then &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;sp_ids.dense_shape = [D0, D1, ..., Dn, K]&lt;/code&gt; 다음 &lt;code&gt;output.shape = [D0, D1, ..., Dn] + vocab_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4411ef14581c867217d2df04414ed49d9c28a03e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; and &lt;code&gt;vocab_size&lt;/code&gt; are lists of different lengths.</source>
          <target state="translated">경우 &lt;code&gt;sp_ids&lt;/code&gt; 및 &lt;code&gt;vocab_size&lt;/code&gt; 는 서로 다른 길이의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="6813a559b2946e19be42f85a8a034ff7dcf1bfbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_ids&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;, or if &lt;code&gt;sp_weights&lt;/code&gt; is neither &lt;code&gt;None&lt;/code&gt; nor &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sp_ids&lt;/code&gt; 은 하지 않은 것입니다 &lt;code&gt;SparseTensor&lt;/code&gt; 경우, 또는 &lt;code&gt;sp_weights&lt;/code&gt; 도없는 &lt;code&gt;None&lt;/code&gt; 아니다 &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b895834e50bd2bdfc0f0a3b5d865361c9f8f5a82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_input&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sp_input&lt;/code&gt; 은 하지 않은 것입니다 &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6be8e1370082dd375f634c0413b359c49efd2d0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_inputs&lt;/code&gt; is not a list of &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;sp_inputs&lt;/code&gt; 의 목록이 아닙니다 &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e04f80ce0bfacac0faf532947db58f9eff4ce40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sp_values&lt;/code&gt; is not a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;sp_ids&lt;/code&gt; is neither a &lt;code&gt;SparseTensor&lt;/code&gt; nor a list thereof. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a &lt;code&gt;Tensor&lt;/code&gt; or a Python int and &lt;code&gt;sp_ids&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;. Or if &lt;code&gt;vocab_size&lt;/code&gt; is not a or list thereof and &lt;code&gt;sp_ids&lt;/code&gt; is a list.</source>
          <target state="translated">경우 &lt;code&gt;sp_values&lt;/code&gt; 은 하지 않은 것입니다 &lt;code&gt;SparseTensor&lt;/code&gt; . 또는 &lt;code&gt;sp_ids&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 도 아니고 그 목록도 아닌 경우 . 또는 &lt;code&gt;vocab_size&lt;/code&gt; 가 &lt;code&gt;Tensor&lt;/code&gt; 가 아니 거나 Python int이고 &lt;code&gt;sp_ids&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 . 또는 &lt;code&gt;vocab_size&lt;/code&gt; 가 또는 목록이 아니고 &lt;code&gt;sp_ids&lt;/code&gt; 가 목록 인 경우.</target>
        </trans-unit>
        <trans-unit id="f4962e7412ce58eae8b3acf5a207ac8244f0115d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;splits&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;splits&lt;/code&gt; 이 유효하지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="8902e3e27b9aa6fb1875d3d80d84c7f114fa6048" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. Similarly, if &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt;, then &lt;code&gt;output[i]&lt;/code&gt; will be an empty list. This behavior is consistent with the Python &lt;code&gt;range&lt;/code&gt; function, but differs from the &lt;a href=&quot;../range&quot;&gt;&lt;code&gt;tf.range&lt;/code&gt;&lt;/a&gt; op, which returns an error for these cases.</source>
          <target state="translated">경우 &lt;code&gt;start[i] &amp;lt; limits[i] and deltas[i] &amp;gt; 0&lt;/code&gt; , 다음, &lt;code&gt;output[i]&lt;/code&gt; 빈리스트가 될 것이다. 마찬가지로 &lt;code&gt;start[i] &amp;gt; limits[i] and deltas[i] &amp;lt; 0&lt;/code&gt; 인 경우 &lt;code&gt;output[i]&lt;/code&gt; 은 빈 목록이됩니다. 이 동작은 Python &lt;code&gt;range&lt;/code&gt; 함수 와 일치 하지만 이러한 경우 오류를 반환하는 &lt;a href=&quot;../range&quot;&gt; &lt;code&gt;tf.range&lt;/code&gt; &lt;/a&gt; op 와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5badd1435f6f82ed12933a662ffbe1ffaf9781d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is a nested list or tuple, then the return value is a nested list or tuple (of the same structure) of &lt;code&gt;2-D&lt;/code&gt; tensors with the shapes &lt;code&gt;[batch_size, s]&lt;/code&gt; for each s in &lt;code&gt;state_size&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;state_size&lt;/code&gt; 가 중첩 된 목록 또는 튜플은, 반환 값은 중첩 된 목록 또는 (동일한 구조) 튜플 &lt;code&gt;2-D&lt;/code&gt; 형상으로 텐서 &lt;code&gt;[batch_size, s]&lt;/code&gt; 에서 각 초 동안 &lt;code&gt;state_size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07e559f7a73c999870c14a2000e0cc3df988ce1a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;state_size&lt;/code&gt; is an int or TensorShape, then the return value is a &lt;code&gt;N-D&lt;/code&gt; tensor of shape &lt;code&gt;[batch_size, state_size]&lt;/code&gt; filled with zeros.</source>
          <target state="translated">경우 &lt;code&gt;state_size&lt;/code&gt; 을 int로 또는 TensorShape이며, 반환 값은 A는 &lt;code&gt;N-D&lt;/code&gt; 형상 텐서 &lt;code&gt;[batch_size, state_size]&lt;/code&gt; 0으로 채워은.</target>
        </trans-unit>
        <trans-unit id="14e4d62f9d346901366838d3fd80a552973404e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;steps &amp;lt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae2daed203e1d66c3418d4aa986f8e07fde11a25" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stfts&lt;/code&gt; is not at least rank 2, &lt;code&gt;frame_length&lt;/code&gt; is not scalar, &lt;code&gt;frame_step&lt;/code&gt; is not scalar, or &lt;code&gt;fft_length&lt;/code&gt; is not scalar.</source>
          <target state="translated">경우 &lt;code&gt;stfts&lt;/code&gt; 는 적어도 계급이 아닌, &lt;code&gt;frame_length&lt;/code&gt; , 스칼라하지 &lt;code&gt;frame_step&lt;/code&gt; 은 스칼라가 아니거나 &lt;code&gt;fft_length&lt;/code&gt; 는 스칼라 없습니다.</target>
        </trans-unit>
        <trans-unit id="4532e386d825d27cc0d8910075cfb30bf2a4f779" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is a scalar, &lt;code&gt;flat_sequence&lt;/code&gt; must be a single-element list; in this case the return value is &lt;code&gt;flat_sequence[0]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;structure&lt;/code&gt; 스칼라이며, &lt;code&gt;flat_sequence&lt;/code&gt; 는 단일 요소 목록이어야합니다 이 경우 리턴 값은 &lt;code&gt;flat_sequence[0]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b494d6e33a53c7ae07fa0e82931781adc7922732" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;structure&lt;/code&gt; is or contains a dict instance, the keys will be sorted to pack the flat sequence in deterministic order. This is true also for &lt;code&gt;OrderedDict&lt;/code&gt; instances: their sequence order is ignored, the sorting order of keys is used instead. The same convention is followed in &lt;code&gt;flatten&lt;/code&gt;. This correctly repacks dicts and &lt;code&gt;OrderedDict&lt;/code&gt;s after they have been flattened, and also allows flattening an &lt;code&gt;OrderedDict&lt;/code&gt; and then repacking it back using a corresponding plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be flattened.</source>
          <target state="translated">경우 &lt;code&gt;structure&lt;/code&gt; 이거나 DICT의 인스턴스를 포함, 키는 결정적 순서로 플랫 시퀀스 팩을 정렬됩니다. &lt;code&gt;OrderedDict&lt;/code&gt; 인스턴스 에서도 마찬가지입니다 . 시퀀스 순서는 무시되고 키의 정렬 순서가 대신 사용됩니다. 동일한 규칙이 &lt;code&gt;flatten&lt;/code&gt; 됩니다. dicts 및 &lt;code&gt;OrderedDict&lt;/code&gt; 가 전개 된 후 올바르게 재 포장되고 &lt;code&gt;OrderedDict&lt;/code&gt; 를 전개 한 다음 해당 일반 dict를 사용하여 다시 패키징하거나 그 반대로도 가능합니다. 정렬 할 수없는 키가있는 사전은 병합 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ff0d1fded6b11da7576139681c5785b18ee22e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;t_list&lt;/code&gt; is not a sequence.</source>
          <target state="translated">&lt;code&gt;t_list&lt;/code&gt; 가 시퀀스가 ​​아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="1bcaf1babb5a597a989c73bcfde0a0be8176fa94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tags&lt;/code&gt; don't match a MetaGraph in the SavedModel.</source>
          <target state="translated">&lt;code&gt;tags&lt;/code&gt; 가 저장된 모델의 메타 그래프와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="54db97109d39c461225af09edb4e2c6bad57c86a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; does not correspond to a tensor in &lt;code&gt;graph&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensor_info&lt;/code&gt; 가 &lt;code&gt;graph&lt;/code&gt; 의 텐서와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="67b5d1cfd94a3b115343c2aead810deecbcee0e6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensor_info&lt;/code&gt; is malformed.</source>
          <target state="translated">경우 &lt;code&gt;tensor_info&lt;/code&gt; 가 잘못되었습니다.</target>
        </trans-unit>
        <trans-unit id="787d21eabc723ffca9e50ef1a89051d32bffd148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tensors&lt;/code&gt; does not contain any &lt;code&gt;Tensor&lt;/code&gt; or &lt;code&gt;IndexedSlices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tensors&lt;/code&gt; &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;IndexedSlices&lt;/code&gt; 가 포함되어 있지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="80e0188994bf5b19fa20e0c1686170da44726237" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; repeatedly. Otherwise it calls it every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop is requested.</source>
          <target state="translated">경우 &lt;code&gt;timer_interval_secs&lt;/code&gt; 없음 스레드 통화 없다 &lt;code&gt;target(*args, **kwargs)&lt;/code&gt; 반복. 그렇지 않으면 &lt;code&gt;timer_interval_secs&lt;/code&gt; 초 마다 호출합니다 . 중지가 요청되면 스레드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="76359a8d4d73a2a3ba1c31d55e4ea69973764917" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timer_interval_secs&lt;/code&gt; is None the thread calls &lt;code&gt;target(args)&lt;/code&gt; repeatedly. Otherwise &lt;code&gt;target(args)&lt;/code&gt; is called every &lt;code&gt;timer_interval_secs&lt;/code&gt; seconds. The thread terminates when a stop of the coordinator is requested.</source>
          <target state="translated">경우 &lt;code&gt;timer_interval_secs&lt;/code&gt; 는 없음 스레드 통화 없다 &lt;code&gt;target(args)&lt;/code&gt; 를 반복. 그렇지 않으면 &lt;code&gt;target(args)&lt;/code&gt; 가 &lt;code&gt;timer_interval_secs&lt;/code&gt; 초 마다 호출됩니다 . 조정자의 중지가 요청되면 스레드가 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="39df2528537689a6ff6d7670c2bc27741338adc3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, recall will be computed as how often on average a class among the labels of a batch entry is in the top-k predictions.</source>
          <target state="translated">경우 &lt;code&gt;top_k&lt;/code&gt; 가 설정되어 리콜은 상단-K 예측에 얼마나 자주 배치 항목의 라벨들 수 평균 클래스에 다음과 같이 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="22ad2e08fc56749566578c3ac9018bef993d749c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;top_k&lt;/code&gt; is set, we'll calculate precision as how often on average a class among the top-k classes with the highest predicted values of a batch entry is correct and can be found in the label for that entry.</source>
          <target state="translated">경우 &lt;code&gt;top_k&lt;/code&gt; 가 설정되어 얼마나 자주 배치 항목의 가장 높은 예측 값으로 상위-K 클래스들 수 평균의 클래스가 정확하고 해당 항목의 레이블에서 찾을 수 있습니다, 우리는 정밀도를 계산하는 것이다.</target>
        </trans-unit>
        <trans-unit id="58bafb59f0fd772a45f6640d18cc022786a6b29d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;topology&lt;/code&gt; is not &lt;code&gt;Topology&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;topology&lt;/code&gt; 가 &lt;code&gt;Topology&lt;/code&gt; 개체 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="3b4920d5aadd2fd1903db2747b34401a1a55495e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trainable&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; the variable is also added to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;trainable&lt;/code&gt; 인 &lt;code&gt;True&lt;/code&gt; 변수는 그래프 컬렉션에 추가 &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31d01c2f769b22b55d39dc7167bfe34f407bcd3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;transpose_a&lt;/code&gt; and &lt;code&gt;adjoint_a&lt;/code&gt;, or &lt;code&gt;transpose_b&lt;/code&gt; and &lt;code&gt;adjoint_b&lt;/code&gt; are both set to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;transpose_a&lt;/code&gt; 및 &lt;code&gt;adjoint_a&lt;/code&gt; , 또는 &lt;code&gt;transpose_b&lt;/code&gt; 및 &lt;code&gt;adjoint_b&lt;/code&gt; 으로 설정되어 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83e4b2e1a7e2f83da1dc94074e53cc0a41fefd20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;norm&lt;/code&gt; is &lt;code&gt;ortho&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 이다 &lt;code&gt;1&lt;/code&gt; 과 &lt;code&gt;norm&lt;/code&gt; 이다 &lt;code&gt;ortho&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29a14472bd70b91d2d821d4767673189e3c32c45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;3&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None,&lt;/code&gt;axis&lt;code&gt;is not&lt;/code&gt;-1&lt;code&gt;, or&lt;/code&gt;norm&lt;code&gt;is not&lt;/code&gt;None&lt;code&gt;or&lt;/code&gt;'ortho'`.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; 또는 &lt;code&gt;3&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 은 하지 않습니다 &lt;code&gt;None,&lt;/code&gt; 축이 &lt;code&gt;is not&lt;/code&gt; -1 &lt;code&gt;, or&lt;/code&gt; 규범 &lt;code&gt;is not&lt;/code&gt; 없음 &lt;code&gt;or&lt;/code&gt; 'ortho'`.</target>
        </trans-unit>
        <trans-unit id="7b8a412620e4f0db59b941b58e4ea5b61c2aadb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type&lt;/code&gt; is not &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt;, &lt;code&gt;3&lt;/code&gt; or &lt;code&gt;4&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;-1&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or greater than 0, or &lt;code&gt;norm&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; or &lt;code&gt;'ortho'&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type&lt;/code&gt; 아니다 &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; , &lt;code&gt;3&lt;/code&gt; 또는 &lt;code&gt;4&lt;/code&gt; , &lt;code&gt;axis&lt;/code&gt; 아닌 &lt;code&gt;-1&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; 있지 않습니다 &lt;code&gt;None&lt;/code&gt; 0보다 크거나 혹은 &lt;code&gt;norm&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 또는 &lt;code&gt;'ortho'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfe5af8b4eee174a0116628b333e223b110eaba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;type_value&lt;/code&gt; cannot be converted to a &lt;code&gt;DType&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;type_value&lt;/code&gt; 는 A를 변환 할 수 없습니다 &lt;code&gt;DType&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2f5898ab52e0b7a1f47284ea2d111ba5b883073" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;units&lt;/code&gt;, &lt;code&gt;cell_type&lt;/code&gt;, and &lt;code&gt;rnn_cell_fn&lt;/code&gt; are not compatible.</source>
          <target state="translated">경우 &lt;code&gt;units&lt;/code&gt; , &lt;code&gt;cell_type&lt;/code&gt; 및 &lt;code&gt;rnn_cell_fn&lt;/code&gt; 는 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d94e19ec763d0a214f62d7c38f7e3bd893e8f1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is False, it runs standard full batch K-means. Each training step runs a single iteration of K-Means and must process the full input at once. To run in this mode, the &lt;code&gt;input_fn&lt;/code&gt; passed to &lt;code&gt;train&lt;/code&gt; must return the entire input dataset.</source>
          <target state="translated">경우 &lt;code&gt;use_mini_batch&lt;/code&gt; 은 거짓, 그것은 표준 전체 배치 K-수단을 실행합니다. 각 교육 단계는 K-Means의 단일 반복을 실행하며 전체 입력을 한 번에 처리해야합니다. 이 모드에서 실행하려면 &lt;code&gt;input_fn&lt;/code&gt; 에 전달 &lt;code&gt;train&lt;/code&gt; 전체 입력 데이터 집합을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="fbda24875bef97bbb29fa5aa5d61e455a7519b95" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;use_mini_batch&lt;/code&gt; is True, it runs a generalization of the mini-batch K-means algorithm. It runs multiple iterations, where each iteration is composed of &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps. Each training step accumulates the contribution from one mini-batch into temporary storage. Every &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; steps, the cluster centers are updated and the temporary storage cleared for the next iteration. For example: the entire dataset contains 64k examples, where the batch size is 64. User can choose mini_batch_steps_per_iteration = 100 to run 10% of the entire data every iteration in order to update the cluster centers. Note that: * If &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt;, the algorithm reduces to the standard K-means mini-batch algorithm. * If &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt;, the algorithm becomes an asynchronous version of the full-batch algorithm. However, there is no guarantee by this implementation that each input is seen exactly once per iteration. Also, different updates are applied asynchronously without locking. So this asynchronous version may not behave exactly like a full-batch version.</source>
          <target state="translated">경우 &lt;code&gt;use_mini_batch&lt;/code&gt; 는 사실, 그것은 미니 배치 K-수단 알고리즘의 일반화를 실행합니다. 여러 반복을 실행하며 각 반복은 &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; 단계 로 구성 됩니다. 각 교육 단계는 하나의 미니 배치에서 임시 스토리지로의 기여를 축적합니다. 모든 &lt;code&gt;mini_batch_steps_per_iteration&lt;/code&gt; 단계 마다 클러스터 센터가 업데이트되고 다음 반복을 위해 임시 스토리지가 지워집니다. 예를 들어, 전체 데이터 세트에 배치 크기가 64 인 64k 예제가 포함되어 있습니다. 사용자는 mini_batch_steps_per_iteration = 100을 선택하여 클러스터 센터를 업데이트하기 위해 반복마다 전체 데이터의 10 %를 실행할 수 있습니다. * &lt;code&gt;mini_batch_steps_per_iteration=1&lt;/code&gt; 인 경우알고리즘은 표준 K- 평균 미니 배치 알고리즘으로 축소됩니다. * &lt;code&gt;mini_batch_steps_per_iteration = num_inputs / batch_size&lt;/code&gt; 인 경우 알고리즘은 전체 배치 알고리즘의 비동기 버전이됩니다. 그러나이 구현에서는 각 입력이 반복 당 정확히 한 번만 표시된다는 보장이 없습니다. 또한 잠금없이 다른 업데이트가 비동기 적으로 적용됩니다. 따라서이 비동기 버전은 전체 배치 버전과 똑같이 동작하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0de9b1589edff3edb12b3507ec1953380c622e7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, &lt;code&gt;SparseToSparseSetOperation&lt;/code&gt; validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="translated">경우 &lt;code&gt;validate_indices&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; , &lt;code&gt;SparseToSparseSetOperation&lt;/code&gt; 는 의 순서와 범위의 유효성을 확인 &lt;code&gt;set1&lt;/code&gt; 및 &lt;code&gt;set2&lt;/code&gt; 인덱스를.</target>
        </trans-unit>
        <trans-unit id="260ea41f74c472364a81400bd73602e6cf8bf5c1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set1&lt;/code&gt; and &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="translated">경우 &lt;code&gt;validate_indices&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 이 영업 이익의 순서와 범위의 유효성을 확인 &lt;code&gt;set1&lt;/code&gt; 및 &lt;code&gt;set2&lt;/code&gt; 인덱스를.</target>
        </trans-unit>
        <trans-unit id="daa3579a7c6b92c6e873864921b371fc1cfef25a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set2&lt;/code&gt; indices.</source>
          <target state="translated">경우 &lt;code&gt;validate_indices&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 이 영업 이익의 순서와 범위의 유효성을 검사 &lt;code&gt;set2&lt;/code&gt; 인덱스를.</target>
        </trans-unit>
        <trans-unit id="3d3305a90fa51b42ef64ce98951aa13c81a456e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;validate_indices&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this op validates the order and range of &lt;code&gt;set&lt;/code&gt; indices.</source>
          <target state="translated">경우 &lt;code&gt;validate_indices&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 이 영업 이익의 순서와 범위의 유효성을 확인 &lt;code&gt;set&lt;/code&gt; 인덱스를.</target>
        </trans-unit>
        <trans-unit id="1abfdc44d511adbb90473745fa524076478dca31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is a list, then the length of the list must be equal to the number of elements implied by the desired shape of the tensor. If the total number of elements in &lt;code&gt;value&lt;/code&gt; is not equal to the number of elements required by the tensor shape, the initializer will raise a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 리스트는, 그리스트의 길이는 텐서의 원하는 형상에 의해 암시 소자의 수와 동일해야한다. &lt;code&gt;value&lt;/code&gt; 의 총 요소 수가 텐서 모양에 필요한 요소의 수와 같지 않으면 이니셜 라이저는 &lt;code&gt;TypeError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="1f123d9bcbe68894415e895e218694c01aa94734" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is an &lt;code&gt;IndexedSlices&lt;/code&gt; or &lt;code&gt;SparseTensor&lt;/code&gt; it is returned unmodified. Otherwise, it is converted to a &lt;code&gt;Tensor&lt;/code&gt; using &lt;code&gt;convert_to_tensor()&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;value&lt;/code&gt; 입니다 &lt;code&gt;IndexedSlices&lt;/code&gt; 또는 &lt;code&gt;SparseTensor&lt;/code&gt; 가 수정되지 않은 반환됩니다. 그렇지 않으면 &lt;code&gt;convert_to_tensor()&lt;/code&gt; 사용하여 &lt;code&gt;Tensor&lt;/code&gt; 로 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="f99b9bc1783a763e0074d7f02eada525fcb32905" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;value&lt;/code&gt; is empty, the result is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 비어 있으면 결과는 &lt;code&gt;nan&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fc11671e327afed930dbaa313b8e03a128124801" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is a &lt;code&gt;TensorProto&lt;/code&gt;, it is immediately returned; &lt;code&gt;dtype&lt;/code&gt; and &lt;code&gt;shape&lt;/code&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; A는 &lt;code&gt;TensorProto&lt;/code&gt; , 그것은 즉시 반환됩니다; &lt;code&gt;dtype&lt;/code&gt; 과 &lt;code&gt;shape&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3985f33eae49407759fdafe7e97f1ceb123a61" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is empty, if &lt;code&gt;axis&lt;/code&gt; is out of bounds or if the input tensors have different ranks.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 비어있는 경우 &lt;code&gt;axis&lt;/code&gt; 범위를 벗어났습니다 또는 입력 텐서는 다른 계급이있는 경우.</target>
        </trans-unit>
        <trans-unit id="c4991d0b9279a9695b7dc9ffd7b6d11392cfa51c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not iterable or is one of &lt;code&gt;Tensor&lt;/code&gt;, &lt;code&gt;SparseTensor&lt;/code&gt;, &lt;code&gt;np.array&lt;/code&gt;, &lt;a href=&quot;../compat#bytes_or_text_types&quot;&gt;&lt;code&gt;tf.compat.bytes_or_text_types&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 반복 가능하지 않거나 중 하나입니다 &lt;code&gt;Tensor&lt;/code&gt; , &lt;code&gt;SparseTensor&lt;/code&gt; , &lt;code&gt;np.array&lt;/code&gt; , &lt;a href=&quot;../compat#bytes_or_text_types&quot;&gt; &lt;code&gt;tf.compat.bytes_or_text_types&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="adcccd399060c3499bb9a842249a7c23159bb96d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this implements logic like:</source>
          <target state="translated">경우 &lt;code&gt;var&lt;/code&gt; 여러 장치의 미러는,이 구현 로직과 같은 :</target>
        </trans-unit>
        <trans-unit id="e259007ec837353b25e8dee0a7ca91b5e9dd17dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var&lt;/code&gt; is mirrored across multiple devices, then this method implements logic as following:</source>
          <target state="translated">경우 &lt;code&gt;var&lt;/code&gt; 여러 장치, 다음과 같이이 메소드 구현 로직의 미러는 :</target>
        </trans-unit>
        <trans-unit id="11eede5a4c994c0e0896bbe89af7ae79fa5c41fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; contains anything else than &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 에 &lt;code&gt;Variable&lt;/code&gt; 객체 이외의 것이 포함 된 경우 .</target>
        </trans-unit>
        <trans-unit id="3f399b1c4fa48e152a02dd3bfffed24395c183ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is empty, however, the function still returns an Op that can be run. That Op just has no effect.</source>
          <target state="translated">그러나 &lt;code&gt;var_list&lt;/code&gt; 가 비어 있으면 이 함수는 계속 실행할 수있는 Op를 반환합니다. 그 Op는 아무 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8be83695571e67c755a97c6fc16febe7943e3a10" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;var_list&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 가 유효하지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="42bb3b276bc1fc0235ac461a83cafa45706822f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;variational_recurrent&lt;/code&gt; is set to &lt;code&gt;True&lt;/code&gt; (&lt;strong&gt;NOT&lt;/strong&gt; the default behavior), then the same dropout mask is applied at every step, as described in: &lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;A Theoretically Grounded Application of Dropout in Recurrent Neural Networks. Y. Gal, Z. Ghahramani&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;variational_recurrent&lt;/code&gt; 가 설정되어 &lt;code&gt;True&lt;/code&gt; ( &lt;strong&gt;NOT&lt;/strong&gt; : 기본 동작)에 설명 된대로 다음 같은 드롭 아웃 마스크는, 모든 단계에서 적용되는 &lt;a href=&quot;https://arxiv.org/abs/1512.05287&quot;&gt;재발 성 신경 회로망에서 드롭 아웃의 이론적 접지 된 응용 프로그램. Y. Gal, Z. Ghahramani&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="215c7e26218a7cf0186a8ee346eb2c5afd2709e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is not a &lt;code&gt;NumericColumn&lt;/code&gt; instance.</source>
          <target state="translated">경우 &lt;code&gt;weight_column&lt;/code&gt; 은 하지 않은 것입니다 &lt;code&gt;NumericColumn&lt;/code&gt; 의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="237eb51162671a05da58da5d5961835a0202c7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;weight_column&lt;/code&gt; 은 지정된 가중치 모양이어야 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 또는 &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f989491367f7caf9a09da24af74f0b79ec083b91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; or &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;weight_column&lt;/code&gt; 은 지정된 가중치 형상이어야 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; , &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; 또는 &lt;code&gt;[D0, D1, ... DN, label_dimension]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84597725a0c8b36564c590276f692f8221e6d0bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weight_column&lt;/code&gt; is specified, weights must be of shape &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt;, or &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;weight_column&lt;/code&gt; 은 지정된 가중치 형상이어야 &lt;code&gt;[D0, D1, ... DN]&lt;/code&gt; 또는 &lt;code&gt;[D0, D1, ... DN, 1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47c0cda9fe6b3ac05940dedc576a336a807a2582" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; or the shape is not compatible with &lt;code&gt;losses&lt;/code&gt;, or if the number of dimensions (rank) of either &lt;code&gt;losses&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; is missing.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 또는 형상과 호환되지 &lt;code&gt;losses&lt;/code&gt; 또는 하나의 치수 (순위)의 수 있다면 &lt;code&gt;losses&lt;/code&gt; 또는 &lt;code&gt;weights&lt;/code&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="4b457250beb9be8c779a4f43124b54d808dbb483" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, weights default to 1. Use weights of 0 to mask values.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이면 가중치 는 기본적으로 1로 설정됩니다. 가중치를 0으로 사용하여 값을 마스크하십시오.</target>
        </trans-unit>
        <trans-unit id="3b2a2aef63c2b4c5eddf622788b9b18a8c0afbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is None, determines the type of the output bins.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 포함되지 않은 경우, 출력 빈들의 유형을 결정한다.</target>
        </trans-unit>
        <trans-unit id="a8c3bdec09ee152e2fea08d1e1e856d94bfdf3de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 과 그 모양이 일치하지 않는 &lt;code&gt;predictions&lt;/code&gt; 하거나하는 경우, 또는 &lt;code&gt;metrics_collections&lt;/code&gt; 또는 &lt;code&gt;updates_collections&lt;/code&gt; 이 목록 또는 튜플 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0d1cbd19298e182234a3c7035094b3c9f4488462" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;values&lt;/code&gt;, or if either &lt;code&gt;metrics_collections&lt;/code&gt; or &lt;code&gt;updates_collections&lt;/code&gt; are not a list or tuple.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 과 그 모양이 일치하지 않는 &lt;code&gt;values&lt;/code&gt; 중 하나를하는 경우, 또는 &lt;code&gt;metrics_collections&lt;/code&gt; 또는 &lt;code&gt;updates_collections&lt;/code&gt; 이 목록 또는 튜플 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ada8b39f6dc45d6686ae7823833c9a7be0ec5faf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, then each prediction contributes its corresponding weight to the total value of the confusion matrix cell.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 , 각 예측은 해당 가중치를 혼동 행렬 셀의 총 값에 기여합니다.</target>
        </trans-unit>
        <trans-unit id="34ed67f8fd358a60d4e9d51cdfe3288db982de76" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is greater than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally crops along that dimension. If &lt;code&gt;width&lt;/code&gt; or &lt;code&gt;height&lt;/code&gt; is smaller than the specified &lt;code&gt;target_width&lt;/code&gt; or &lt;code&gt;target_height&lt;/code&gt; respectively, this op centrally pads with 0 along that dimension.</source>
          <target state="translated">경우 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 지정된보다 큰 &lt;code&gt;target_width&lt;/code&gt; 또는 &lt;code&gt;target_height&lt;/code&gt; 각각이 OP 중앙 그 치수를 따라 잘라. 경우 &lt;code&gt;width&lt;/code&gt; 또는 &lt;code&gt;height&lt;/code&gt; 지정된보다 작은 &lt;code&gt;target_width&lt;/code&gt; 또는 &lt;code&gt;target_height&lt;/code&gt; 각각이 치수를 따라 0이 연산 중앙 패드.</target>
        </trans-unit>
        <trans-unit id="92ed9d6131464277d99f7646cff60c8796c93393" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;../../math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 상기 &lt;code&gt;tf.add&lt;/code&gt; 동작이 실행되고 &lt;code&gt;tf.square&lt;/code&gt; 동작은 실행되지 않는다. 이후 &lt;code&gt;z&lt;/code&gt; 의 적어도 한 지점에 필요한 &lt;code&gt;cond&lt;/code&gt; 상기 &lt;a href=&quot;../../math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; 동작은 항상 무조건적으로 실행된다.</target>
        </trans-unit>
        <trans-unit id="f425000aaa59c101d7ba3f9fb85256ac75c9e8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x &amp;lt; y&lt;/code&gt;, the &lt;code&gt;tf.add&lt;/code&gt; operation will be executed and &lt;code&gt;tf.square&lt;/code&gt; operation will not be executed. Since &lt;code&gt;z&lt;/code&gt; is needed for at least one branch of the &lt;code&gt;cond&lt;/code&gt;, the &lt;a href=&quot;math/multiply&quot;&gt;&lt;code&gt;tf.multiply&lt;/code&gt;&lt;/a&gt; operation is always executed, unconditionally.</source>
          <target state="translated">경우 &lt;code&gt;x &amp;lt; y&lt;/code&gt; 상기 &lt;code&gt;tf.add&lt;/code&gt; 동작이 실행되고 &lt;code&gt;tf.square&lt;/code&gt; 동작은 실행되지 않는다. 이후 &lt;code&gt;z&lt;/code&gt; 의 적어도 한 지점에 필요한 &lt;code&gt;cond&lt;/code&gt; 상기 &lt;a href=&quot;math/multiply&quot;&gt; &lt;code&gt;tf.multiply&lt;/code&gt; &lt;/a&gt; 동작은 항상 무조건적으로 실행된다.</target>
        </trans-unit>
        <trans-unit id="832ed76572de81853b5503e616fb7ad5eedb4aed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is anything other than non-quantized integer.</source>
          <target state="translated">&lt;code&gt;x.dtype&lt;/code&gt; 이 양자화되지 않은 정수가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="cf3892e6d88b8a24b1edde46aeb1e02d77563762" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.dtype&lt;/code&gt; is not a non-quantized integer type.</source>
          <target state="translated">&lt;code&gt;x.dtype&lt;/code&gt; 이 비 양자화 정수 유형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ce40d9c537cb43d8e1af25ac354efd39d19fafdf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x.shape&lt;/code&gt; is not thes same as &lt;code&gt;y.shape&lt;/code&gt;, they will be broadcast to a compatible shape. (More about broadcasting &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;here&lt;/a&gt;.)</source>
          <target state="translated">경우 &lt;code&gt;x.shape&lt;/code&gt; 가 아닌 같은 살전 &lt;code&gt;y.shape&lt;/code&gt; , 그들은 호환 모양에 방송됩니다. ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html&quot;&gt;여기에서&lt;/a&gt; 방송에 대해 자세히 알아 보세요 .)</target>
        </trans-unit>
        <trans-unit id="8e96c4fa15a730ffac011c15425ea745071f028e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 동일하지이다 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="297d1fb5c3c14a94d30b09dddf10abc41cfa8dee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not provided (both are None):</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; (모두 없음 없음)이 제공되지 않는다 :</target>
        </trans-unit>
        <trans-unit id="803864858079bcf1272480039ae2206a7be4c3bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided (both have non-None values):</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제공된다 (모두 비 없음 값을 갖는다) :</target>
        </trans-unit>
        <trans-unit id="ef4cc2647cbcb811bf2321aed25eaa8d1038324d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are provided: A &lt;code&gt;Tensor&lt;/code&gt; with the same type as &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, and shape that is broadcast from &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;. Otherwise, a &lt;code&gt;Tensor&lt;/code&gt; with shape &lt;code&gt;(num_true, dim_size(condition))&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 제공 같습니다 &lt;code&gt;Tensor&lt;/code&gt; 와 같은 형태로 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 에서 방송되고, 형상 &lt;code&gt;condition&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; . 그렇지 않으면 모양이 있는 &lt;code&gt;Tensor&lt;/code&gt; &lt;code&gt;(num_true, dim_size(condition))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad1bd6d19f89942e84389e6c169c715ab56481a5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are reals, this will return the floating-point division.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 실수이고, 이는 부동 소수점 나눗셈을 반환한다.</target>
        </trans-unit>
        <trans-unit id="893814a956c9c9c06f80ca1e2c4bbfa03a3a2f47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have different dtypes.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 다른 dtype을 갖는 경우 .</target>
        </trans-unit>
        <trans-unit id="3f69de924efbdf9b3c63012131b1b697392bf070" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;bfloat16&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;bfloat16&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="cc734366be07fc2f625cfb460bf82e6c13b36b24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex128&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;complex128&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="26a817fbc98a27accbded2d643fd8d39a33d9ce6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;complex64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;complex64&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="24fcc9cc94e7ac80655cda5ee52d4f9df30053c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;dtype&lt;/code&gt; 으로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="8b7911ea01a9bc4c0cafc5a4bdae2a3e4331c165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;float32&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="931fbc164fb944daabf612ed523b88a84ada8883" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;float64&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="1aa4ab5f92b95479e59a006482757e4c9953c52a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;int32&lt;/code&gt; 로 캐스팅 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="95975368b7f95512f0de618f68dbee3011dd9b31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; cannot be cast to the &lt;code&gt;int64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;int64&lt;/code&gt; 로 캐스트 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="91834a574113cb46f5aae57836f11c53a2984dba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a different rank, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 상이한 랭크 가지고 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 형상 &lt;code&gt;x&lt;/code&gt; 인쇄를하고 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="ee4c81ef26436a2682343a27498b170ef1bb7eff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a non-integer type, &lt;code&gt;message&lt;/code&gt;, as well as the dtype of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 정수가 아닌 타입 갖는다 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라의 DTYPE &lt;code&gt;x&lt;/code&gt; 인쇄하고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="91d266cfb0782577238e40aae35cafb92819efcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has a rank lower than &lt;code&gt;rank&lt;/code&gt;, &lt;code&gt;message&lt;/code&gt;, as well as the shape of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 하부보다 순위가 &lt;code&gt;rank&lt;/code&gt; , &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 형상 &lt;code&gt;x&lt;/code&gt; 인쇄 및 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="b0d7c16b1c964db596a362f7e65c837d16f72864" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; has shape &lt;code&gt;(s1, s2, s3)&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;, the output will have shape &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 형상을 갖고 &lt;code&gt;(s1, s2, s3)&lt;/code&gt; 과 &lt;code&gt;axis&lt;/code&gt; 인 &lt;code&gt;1&lt;/code&gt; , 출력 형태를 가질 것이다 &lt;code&gt;(s1, s2 * rep, s3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="462b9044715afd0ebdf56bf7fbea531186505184" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.abs(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c4aba8143c54e7a6d9e46a577473bf33d777660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i0e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c627df3998e3060d22ab74298fa9d1cd985e9495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.bessel_i1e(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="44f9cddabc7760ae0a95bb7dd6468e150137da94" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.erf(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c5e7efe72880d19e7af394d00d8433be450c92d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.negative(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e07936dab82ee4885e6d659527e4c5ac457c891" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.sign(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="42088fc82e406aa5224d738cba01bdcc601c6795" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.sqrt(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e3946f9af72ad0a07071e4e7717e70504b6aaf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.square(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ba052d0ea61514a5070671f03e1e45a14734d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a &lt;code&gt;SparseTensor&lt;/code&gt;, returns &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 &lt;code&gt;SparseTensor(x.indices, tf.math.tanh(x.values, ...), x.dense_shape)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37f745c2ffe497f380fc665cd9e1671ab1f2a720" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a tensor and &lt;code&gt;coeffs&lt;/code&gt; is a list n + 1 tensors, this function returns the value of the n-th order polynomial</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 텐서이고 &lt;code&gt;coeffs&lt;/code&gt; 리스트 텐서 N + 1이며,이 함수는 제 n 차 다항식의 값을 반환</target>
        </trans-unit>
        <trans-unit id="e00f3ba3841dfdaf669fce32a84357b364f2fa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is complex, setting conjugate=True gives the conjugate transpose:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 복소수 인 경우 conjugate = True로 설정하면 켤레 전치가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="69e057f1302f585f5922f3c3a18b760dc9042871" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;gt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 아니다&amp;gt; = 0 도처 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승된다.</target>
        </trans-unit>
        <trans-unit id="f9d353171456976e630d0a86d03f725176648c08" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not &amp;lt;= 0 everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 아닌 &amp;lt;= 0 사방 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 인쇄 및 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="01d56b08bff3bee26005503ba42cfa3d1076bb9a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not a numeric tensor.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 숫자 텐서가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="a80fa1fece372f13db8582203c7da75b28f136c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater or equal to &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 크지 않거나 동일한 &lt;code&gt;y&lt;/code&gt; 소자 현명 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="8945369b8f94d01838a340d55daf17a3d1d0af50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not greater than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 없는보다 큰 &lt;code&gt;y&lt;/code&gt; 소자 현명 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="73a28e0a51a5a1358482bd1d2c5d701b270800d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less or equal than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이하가 아니거나 같 &lt;code&gt;y&lt;/code&gt; 소자 현명 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="50217a1adc5af624b2db0c79520eab9a84830ef9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not less than &lt;code&gt;y&lt;/code&gt; element-wise, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 이상인 &lt;code&gt;y&lt;/code&gt; 소자 현명 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="d6794554e1188cfc1e4c17fab928f93b523433cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not negative everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 사방에 음수가, &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 최초의 &lt;code&gt;summarize&lt;/code&gt; 의 엔트리 &lt;code&gt;x&lt;/code&gt; 인쇄 및 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68a88deab70057f102ed7d4f57ffb05621b00f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not positive everywhere, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 사방에 긍정적 아니라, &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 최초의 &lt;code&gt;summarize&lt;/code&gt; 의 엔트리 &lt;code&gt;x&lt;/code&gt; 인쇄 및 &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="05ca699d60153153cfb210e0569b848d0973f500" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is real, it is returned unchanged.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 진짜, 그것은 변경되지 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a945f29840dadf91f914c8be913e68d58d4600b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is complex, the Jacobian will still be real but the corresponding Jacobian dimension(s) will be twice as large. This is required even if both input and output is complex since TensorFlow graphs are not necessarily holomorphic, and may have gradients not expressible as complex numbers. For example, if &lt;code&gt;x&lt;/code&gt; is complex with shape &lt;code&gt;[m]&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is complex with shape &lt;code&gt;[n]&lt;/code&gt;, each Jacobian &lt;code&gt;J&lt;/code&gt; will have shape &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; with</source>
          <target state="translated">경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 복잡 코비안은 여전히 실제되지만 대응 코비안 치수 (들)은 큰 배 것이다. TensorFlow 그래프가 반드시 동형 일 필요는 없으며 입력 값과 출력값이 모두 복잡하더라도 복소수로 표현할 수없는 그래디언트가있을 수 있습니다. 예를 들어, &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;[m]&lt;/code&gt; 모양으로 복소수 이고 &lt;code&gt;y&lt;/code&gt; 가 &lt;code&gt;[n]&lt;/code&gt; 모양으로 복소수 이면 각 Jacobian &lt;code&gt;J&lt;/code&gt; 는 &lt;code&gt;[m * 2, n * 2]&lt;/code&gt; 모양을 갖 습니다.</target>
        </trans-unit>
        <trans-unit id="b72659759aef98d470e47569f98300becf74fe6a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;param&lt;/code&gt; or &lt;code&gt;scalar&lt;/code&gt; does not have a shape that satisfies all specified constraints, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of the first encountered violating tensor are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; , &lt;code&gt;param&lt;/code&gt; 또는 &lt;code&gt;scalar&lt;/code&gt; 만족 지정된 모든 제약하는 형태가없는 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 첫째 &lt;code&gt;summarize&lt;/code&gt; 첫 번째 발생한 위반 텐서의 항목이 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb4201e11c9c9b78cc34cdf99933fa6d07a53697" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to than the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 음의 또는 큰 폭과 같거나보다 &lt;code&gt;x&lt;/code&gt; 결과 구현 비트가 정의한다.</target>
        </trans-unit>
        <trans-unit id="01d4e2631b92dda8971f5f7cd4af31e88891e1af" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y&lt;/code&gt; is negative, or greater than or equal to the width of &lt;code&gt;x&lt;/code&gt; in bits the result is implementation defined.</source>
          <target state="translated">경우 &lt;code&gt;y&lt;/code&gt; 보다 네거티브 또는 그 이상인지의 폭과 동일한 &lt;code&gt;x&lt;/code&gt; 비트의 결과는 정의의 구현이다.</target>
        </trans-unit>
        <trans-unit id="30b7dec1cb97dae047ef8c7594503313f7bd0667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;y_true&lt;/code&gt; cannot be cast to the &lt;code&gt;y_pred.dtype&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;y_true&lt;/code&gt; 을 받는 캐스트 할 수없는 &lt;code&gt;y_pred.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="630404ed0aa98c724f5f45b2443214bdd9885f07" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;all&lt;/em&gt; underlying ClusterSpecs expose the set of workers as lists, we will concatenate the lists of workers, starting with the list of workers from the first ClusterResolver passed into the constructor.</source>
          <target state="translated">경우 &lt;em&gt;모든&lt;/em&gt; 기본 ClusterSpecs이 목록으로 노동자의 집합을 노출, 우리는 생성자에 전달 된 첫 번째 ClusterResolver 노동자의 목록을 시작으로 노동자의 목록을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="271b382563c95b776c249c61da000dbb2aa88697" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;any&lt;/em&gt; of the ClusterSpecs expose the set of workers as a dict, we will treat all the sets of workers as dicts (even if they are returned as lists) and will only merge them into a dict if there is no conflicting keys. If there is a conflicting key, we will raise a &lt;code&gt;KeyError&lt;/code&gt;.</source>
          <target state="translated">ClusterSpecs &lt;em&gt;중&lt;/em&gt; 하나가 작업자 세트를 dict로 표시하는 경우 &lt;em&gt;모든&lt;/em&gt; 작업자 세트를 dicts (리스트로 리턴하더라도)로 처리하고 충돌하는 키가없는 경우에만 dict로 병합합니다. 충돌하는 키가 있으면 &lt;code&gt;KeyError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="cbce25fbc64a35da3d529cbda0471472ace6aaab" translate="yes" xml:space="preserve">
          <source>If False, all variables will be regular Variables. If True, experimental ResourceVariables with well-defined semantics will be used instead. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="translated">False이면 모든 변수가 일반 변수가됩니다. True이면 의미가 잘 정의 된 실험적인 ResourceVariables가 대신 사용됩니다. 기본값은 False입니다 (나중에 True로 변경됨). 즉시 실행이 활성화되면이 인수는 항상 True가됩니다.</target>
        </trans-unit>
        <trans-unit id="e276bd2d482be3a780920df708c8f5a926a98964" translate="yes" xml:space="preserve">
          <source>If False, allows the variable to be initialized with a value of unknown shape. If True, the default, the shape of initial_value must be known. For this to be used the initializer must be a Tensor and not an initializer object.</source>
          <target state="translated">False이면 알 수없는 형태의 값으로 변수를 초기화 할 수 있습니다. True이면 기본값 인 initial_value의 모양을 알아야합니다. 이를 사용하려면 이니셜 라이저가 이니셜 라이저 객체가 아닌 Tensor 여야합니다.</target>
        </trans-unit>
        <trans-unit id="16e22caea5a7edd671d9649e9073545eec0be196" translate="yes" xml:space="preserve">
          <source>If False, creates a regular Variable. If true, creates an experimental ResourceVariable instead with well-defined semantics. Defaults to False (will later change to True). When eager execution is enabled this argument is always forced to be True.</source>
          <target state="translated">False이면 일반 변수를 만듭니다. true 인 경우 잘 정의 된 의미 체계를 사용하는 대신 실험적 ResourceVariable을 만듭니다. 기본값은 False입니다 (나중에 True로 변경됨). 즉시 실행이 활성화되면이 인수는 항상 True가됩니다.</target>
        </trans-unit>
        <trans-unit id="04652b076209c80110035f6f97fb9f7b67a0e75d" translate="yes" xml:space="preserve">
          <source>If False, evaluation runs on CPU or GPU. In this case, the model_fn must return &lt;code&gt;EstimatorSpec&lt;/code&gt; when called with &lt;code&gt;mode&lt;/code&gt; as &lt;code&gt;EVAL&lt;/code&gt;.</source>
          <target state="translated">False 인 경우 평가는 CPU 또는 GPU에서 실행됩니다. 이 경우 model_fn은 &lt;code&gt;mode&lt;/code&gt; 를 &lt;code&gt;EVAL&lt;/code&gt; 로 호출 할 때 &lt;code&gt;EstimatorSpec&lt;/code&gt; 을 반환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e086138a94bde8908ba51196ac86730005707798" translate="yes" xml:space="preserve">
          <source>If False, will not initialize the TPU embedding engine. If this is set to False and another instance of this class has not initialized the tpu embedding engine, the creation of this object will fail.</source>
          <target state="translated">False 인 경우 TPU 임베딩 엔진을 초기화하지 않습니다. 이것이 False로 설정되고이 클래스의 다른 인스턴스가 tpu 임베딩 엔진을 초기화하지 않은 경우이 객체 생성이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="9477cf4113441b48552d8e491777b39b333163eb" translate="yes" xml:space="preserve">
          <source>If JIT compilation is enabled.</source>
          <target state="translated">JIT 컴파일이 사용 가능한 경우</target>
        </trans-unit>
        <trans-unit id="e0e5b865ff2f6414405c0b49034de9bd0d05490c" translate="yes" xml:space="preserve">
          <source>If TensorFlow 2 behavior has been disabled with &lt;a href=&quot;../../../compat/v1/disable_v2_behavior&quot;&gt;&lt;code&gt;tf.compat.v1.disable_v2_behavior()&lt;/code&gt;&lt;/a&gt;, this will instead return a special &quot;_infer&quot; policy which infers the dtype from the dtype of the first input the first time the layer is called. This behavior matches the behavior that existed in TensorFlow 1.</source>
          <target state="translated">&lt;a href=&quot;../../../compat/v1/disable_v2_behavior&quot;&gt; &lt;code&gt;tf.compat.v1.disable_v2_behavior()&lt;/code&gt; &lt;/a&gt; 사용하여 TensorFlow 2 동작이 비활성화 된 경우 대신 레이어가 처음 호출 될 때 첫 번째 입력의 dtype에서 dtype을 유추하는 특수 &quot;_infer&quot;정책을 반환합니다. 이 동작은 TensorFlow 1에 존재했던 동작과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6f404c4959ef2567bb4bc7e15658d38db76c0a4b" translate="yes" xml:space="preserve">
          <source>If True also add all the variables to the graph collection &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt;.</source>
          <target state="translated">True면 모든 변수를 그래프 컬렉션 &lt;code&gt;GraphKeys.TRAINABLE_VARIABLES&lt;/code&gt; 에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="bdbb03e95c787ba1c8f64df66541fd60be1bfc22" translate="yes" xml:space="preserve">
          <source>If True and a cluster resolver is passed, will automatically enter the master task device scope, which indicates the master becomes the default device to run ops. It won't do anything if a cluster spec is passed. Will throw an error if the caller is currently already in some device scope.</source>
          <target state="translated">True이고 클러스터 해석기가 전달되면 마스터 작업 장치 범위에 자동으로 들어가며 이는 마스터가 작업을 실행하는 기본 장치가됨을 나타냅니다. 클러스터 사양이 전달되면 아무 작업도 수행하지 않습니다. 호출자가 현재 이미 일부 장치 범위에있는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da81f3101e16617f966c55c3724a76a3db849aad" translate="yes" xml:space="preserve">
          <source>If True use locks for update operation.</source>
          <target state="translated">True이면 업데이트 작업에 잠금을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="50606798e5dc09832e581473d48fd9163dfd0de2" translate="yes" xml:space="preserve">
          <source>If True use locks for update operations.</source>
          <target state="translated">True이면 업데이트 작업에 잠금을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f18d1c4bb0479df3bb2fd4bef403529bc00af30" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on CPU.</source>
          <target state="translated">True 인 경우 &lt;code&gt;export_saved_model()&lt;/code&gt; 은 CPU에서 제공하기 위해 메타 그래프를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="65e46cba6288401db88fe775842baf3f9c1c8ca9" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;export_saved_model()&lt;/code&gt; exports a metagraph for serving on TPU. Note that unsupported export modes such as EVAL will be ignored. For those modes, only a CPU model will be exported. Currently, export_to_tpu only supports PREDICT.</source>
          <target state="translated">True 인 경우 &lt;code&gt;export_saved_model()&lt;/code&gt; 은 TPU에서 제공 할 메타 그래프를 내 보냅니다. EVAL과 같이 지원되지 않는 내보내기 모드는 무시됩니다. 이러한 모드의 경우 CPU 모델 만 내보내집니다. 현재 export_to_tpu는 PREDICT 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fc4f98c4d9f76c842e647c36ac96ebc2b65b042e" translate="yes" xml:space="preserve">
          <source>If True, BINARY, COUNT, and TFIDF modes will have their outputs padded to max_tokens, even if the number of unique tokens in the vocabulary is less than max_tokens.</source>
          <target state="translated">True 인 경우 BINARY, COUNT 및 TFIDF 모드는 어휘의 고유 토큰 수가 max_tokens보다 적더라도 출력이 max_tokens로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="391332487ec275420b33d243c1ac17e1902deb89" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. The latter behavior will soon be deprecated.</source>
          <target state="translated">True 인 경우 허용 및 반환 된 상태는 &lt;code&gt;c_state&lt;/code&gt; 및 &lt;code&gt;m_state&lt;/code&gt; 의 2- 튜플입니다 . False이면 열 축을 따라 연결됩니다. 후자의 동작은 곧 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="113a224ce2e757deca52721b8506e41e1dc90aaa" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are 2-tuples of the &lt;code&gt;c_state&lt;/code&gt; and &lt;code&gt;m_state&lt;/code&gt;. If False, they are concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="translated">True 인 경우 허용 및 반환 된 상태는 &lt;code&gt;c_state&lt;/code&gt; 및 &lt;code&gt;m_state&lt;/code&gt; 의 2- 튜플입니다 . False이면 열 축을 따라 연결됩니다. 이 후자의 동작은 곧 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="89a273cd953f2e6f16efd2683deb6890fa9d7c47" translate="yes" xml:space="preserve">
          <source>If True, accepted and returned states are n-tuples, where &lt;code&gt;n = len(cells)&lt;/code&gt;. If False, the states are all concatenated along the column axis. This latter behavior will soon be deprecated.</source>
          <target state="translated">True 인 경우 허용 및 반환 된 상태는 n- 튜플이며 여기서 &lt;code&gt;n = len(cells)&lt;/code&gt; 입니다. False이면 상태가 모두 열 축을 따라 연결됩니다. 이 후자의 동작은 곧 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd0a94f25d503070a259cd5b2ceafd4021f39e98" translate="yes" xml:space="preserve">
          <source>If True, add a tuple around the gradients returned for an operations. This avoids some race conditions.</source>
          <target state="translated">True이면 작업에 대해 반환 된 그래디언트 주위에 튜플을 추가합니다. 이것은 일부 경쟁 조건을 피합니다.</target>
        </trans-unit>
        <trans-unit id="d74b57e3173462240140a06214d8da8416d87029" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored.</source>
          <target state="translated">True이면 정규화 된 텐서 에 &lt;code&gt;beta&lt;/code&gt; 오프셋을 추가 합니다. False이면 &lt;code&gt;beta&lt;/code&gt; 가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="f17ce9d21dc91dfe50d81f38bea0d0d40f40033c" translate="yes" xml:space="preserve">
          <source>If True, add offset of &lt;code&gt;beta&lt;/code&gt; to normalized tensor. If False, &lt;code&gt;beta&lt;/code&gt; is ignored. Defaults to True.</source>
          <target state="translated">True이면 정규화 된 텐서 에 &lt;code&gt;beta&lt;/code&gt; 오프셋을 추가 합니다. False이면 &lt;code&gt;beta&lt;/code&gt; 가 무시됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="c0777a1250cd96104d9d7801c2393119800216b9" translate="yes" xml:space="preserve">
          <source>If True, attempt to run as many ops as possible on GPU.</source>
          <target state="translated">True 인 경우 GPU에서 가능한 한 많은 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d9bf5662552a40062f21a263f219715b015ae1e0" translate="yes" xml:space="preserve">
          <source>If True, create a chief supervisor in charge of initializing and restoring the model. If False, create a supervisor that relies on a chief supervisor for inits and restore.</source>
          <target state="translated">True 인 경우 모델 초기화 및 복원을 담당하는 최고 감독자를 만듭니다. False 인 경우 초기화 및 복원을 위해 최고 감독자에게 의존하는 감독자를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ef3778eb93235434d49db78d5f20f8989c18b3ad" translate="yes" xml:space="preserve">
          <source>If True, enables collection of executed graphs. It includes ones from tf.function invocation and ones from the legacy graph mode. The default is True.</source>
          <target state="translated">True 인 경우 실행 된 그래프 수집을 활성화합니다. 여기에는 tf.function 호출의 항목과 레거시 그래프 모드의 항목이 포함됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="c1cf29bff8b8f38721019968f2ae60f5a20e2f70" translate="yes" xml:space="preserve">
          <source>If True, enables the advanced profiler. Enabling profiler implicitly enables the graph collection. The profiler may incur a high memory overhead. The default is False.</source>
          <target state="translated">True이면 고급 프로파일 러를 활성화합니다. 프로파일 러를 활성화하면 암시 적으로 그래프 수집이 활성화됩니다. 프로파일 러는 높은 메모리 오버 헤드를 유발할 수 있습니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="5011109864df2f142f96a528ddcbf806ba9347ba" translate="yes" xml:space="preserve">
          <source>If True, equal elements in the original tensor will not be re-ordered in the returned order. Unstable sort is not yet implemented, but will eventually be the default for performance reasons. If you require a stable order, pass &lt;code&gt;stable=True&lt;/code&gt; for forwards compatibility.</source>
          <target state="translated">True이면 원래 텐서의 동일한 요소가 반환 된 순서로 다시 정렬되지 않습니다. 불안정한 정렬은 아직 구현되지 않았지만 결국 성능상의 이유로 기본값이 될 것입니다. 안정적인 주문이 필요한 경우 순방향 호환성을 위해 &lt;code&gt;stable=True&lt;/code&gt; 를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="750ecb9c072b7cf4ffc15ea96ce3af855fbca2b7" translate="yes" xml:space="preserve">
          <source>If True, gradients are normalized by the estimated variance of the gradient; if False, by the uncentered second moment. Setting this to True may help with training, but is slightly more expensive in terms of computation and memory. Defaults to False.</source>
          <target state="translated">True 인 경우 기울기는 기울기의 추정 된 분산으로 정규화됩니다. 거짓이면 중심이 맞지 않는 두 번째 순간까지. True로 설정하면 훈련에 도움이 될 수 있지만 계산 및 메모리 측면에서 약간 더 비쌉니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="cd1e2a28dcb00e4c427b5e6f9a7e2d06a8784cd1" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. Defaults to True. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="translated">True이면 &lt;code&gt;gamma&lt;/code&gt; 를 곱합니다 . False이면 &lt;code&gt;gamma&lt;/code&gt; 가 사용되지 않습니다. 기본값은 True입니다. 다음 레이어가 선형 일 때 (예 : &lt;a href=&quot;../../nn/relu&quot;&gt; &lt;code&gt;nn.relu&lt;/code&gt; &lt;/a&gt; ), 스케일링은 다음 레이어에서 수행되므로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b9c004ec547a81c042012784ef627e9dddd1b00" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="translated">True이면 &lt;code&gt;gamma&lt;/code&gt; 를 곱합니다 . False이면 &lt;code&gt;gamma&lt;/code&gt; 가 사용되지 않습니다. 다음 레이어가 선형 일 때 (예 : &lt;a href=&quot;../../../nn/relu&quot;&gt; &lt;code&gt;nn.relu&lt;/code&gt; &lt;/a&gt; ), 스케일링은 다음 레이어에서 수행되므로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4a76a1bcdfeeb85e09efa687176e35259e81cc6" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;../../nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="translated">True이면 &lt;code&gt;gamma&lt;/code&gt; 를 곱합니다 . False이면 &lt;code&gt;gamma&lt;/code&gt; 가 사용되지 않습니다. 다음 레이어가 선형 일 때 (예 : &lt;a href=&quot;../../nn/relu&quot;&gt; &lt;code&gt;nn.relu&lt;/code&gt; &lt;/a&gt; ), 스케일링은 다음 레이어에서 수행되므로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e283886c9fed9473765fda234d0e06956531313" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling can be done by the next layer.</source>
          <target state="translated">True이면 &lt;code&gt;gamma&lt;/code&gt; 를 곱합니다 . False이면 &lt;code&gt;gamma&lt;/code&gt; 가 사용되지 않습니다. 다음 레이어가 선형 일 때 (예 : &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt; &lt;code&gt;nn.relu&lt;/code&gt; &lt;/a&gt; ), 스케일링은 다음 레이어에서 수행 할 수 있으므로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="578ce0342e27bfeebf914f2f2252b95c5ffdce19" translate="yes" xml:space="preserve">
          <source>If True, multiply by &lt;code&gt;gamma&lt;/code&gt;. If False, &lt;code&gt;gamma&lt;/code&gt; is not used. When the next layer is linear (also e.g. &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt;&lt;code&gt;nn.relu&lt;/code&gt;&lt;/a&gt;), this can be disabled since the scaling will be done by the next layer.</source>
          <target state="translated">True이면 &lt;code&gt;gamma&lt;/code&gt; 를 곱합니다 . False이면 &lt;code&gt;gamma&lt;/code&gt; 가 사용되지 않습니다. 다음 레이어가 선형 일 때 (예 : &lt;a href=&quot;https://www.tensorflow.org/api_docs/python/tf/nn/relu&quot;&gt; &lt;code&gt;nn.relu&lt;/code&gt; &lt;/a&gt; ), 스케일링은 다음 레이어에서 수행되므로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf1db80fd9a3060fcc2a7c235a1f90b8709a624c" translate="yes" xml:space="preserve">
          <source>If True, normalize the feature importances.</source>
          <target state="translated">True 인 경우 기능 중요도를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="2572de1e262e97ff64e6ca8e29487895501fe54b" translate="yes" xml:space="preserve">
          <source>If True, output has same structure as &lt;code&gt;loop_vars&lt;/code&gt;. If eager execution is enabled, this is ignored (and always treated as True).</source>
          <target state="translated">True면 출력은 &lt;code&gt;loop_vars&lt;/code&gt; 와 동일한 구조를 갖습니다 . 즉시 실행이 활성화 된 경우 무시됩니다 (항상 True로 처리됨).</target>
        </trans-unit>
        <trans-unit id="1287bfecf53fede4f7f673c3e991544f7e20e027" translate="yes" xml:space="preserve">
          <source>If True, pin all ops to &lt;code&gt;/device:GPU:0&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 모든 작업을 &lt;code&gt;/device:GPU:0&lt;/code&gt; 에 고정 합니다.</target>
        </trans-unit>
        <trans-unit id="5e192ab1f5235c570eacfb2b1b53f1c396eaad43" translate="yes" xml:space="preserve">
          <source>If True, save optimizer's state together.</source>
          <target state="translated">True이면 최적화 프로그램의 상태를 함께 저장합니다.</target>
        </trans-unit>
        <trans-unit id="ef179526c8ef1ce4119a23e41f41dc6bbf275cc0" translate="yes" xml:space="preserve">
          <source>If True, the TPU embedding computations will overlap with the TensorCore computations (and hence will be one step old). Set to True for improved performance.</source>
          <target state="translated">True 인 경우 TPU 임베딩 계산이 TensorCore 계산과 겹치므로 한 단계 오래된 것입니다. 성능 향상을 위해 True로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="12eba52a55d85913f21962c92ad731adf7bfc10e" translate="yes" xml:space="preserve">
          <source>If True, the axis indicated in &lt;code&gt;axis&lt;/code&gt; are kept with size 1. Otherwise, the dimensions in &lt;code&gt;axis&lt;/code&gt; are removed from the output shape.</source>
          <target state="translated">True이면 축에 표시된 &lt;code&gt;axis&lt;/code&gt; 이 크기 1로 유지됩니다. 그렇지 않으면 &lt;code&gt;axis&lt;/code&gt; 치수 가 출력 모양에서 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3328c5b57ecb2ae47c200ab88a84221b9f503cf1" translate="yes" xml:space="preserve">
          <source>If True, the function is always compiled by &lt;a href=&quot;https://www.tensorflow.org/xla&quot;&gt;XLA&lt;/a&gt;. XLA may be more efficient in some cases (e.g. TPU, XLA_GPU, dense tensor computations).</source>
          <target state="translated">True이면 함수는 항상 &lt;a href=&quot;https://www.tensorflow.org/xla&quot;&gt;XLA에&lt;/a&gt; 의해 컴파일됩니다 . XLA는 경우에 따라 더 효율적일 수 있습니다 (예 : TPU, XLA_GPU, 고밀도 텐서 계산).</target>
        </trans-unit>
        <trans-unit id="311c0ba812861cff25aa3a9a763749c510b7f41b" translate="yes" xml:space="preserve">
          <source>If True, the returned numpy array is allowed to have partially evaluated values. Values that can't be evaluated will be None.</source>
          <target state="translated">True이면 반환 된 numpy 배열이 부분적으로 평가 된 값을 가질 수 있습니다. 평가할 수없는 값은 없음이됩니다.</target>
        </trans-unit>
        <trans-unit id="c7548f67ca3f064fd3f0736913e9f476ffa808ee" translate="yes" xml:space="preserve">
          <source>If True, this function will return False if node_def represents a variable-related op.</source>
          <target state="translated">True 인 경우 node_def가 변수 관련 작업을 나타내는 경우이 함수는 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b84fe947ee0716714799cf00df4c8c6faaa998a2" translate="yes" xml:space="preserve">
          <source>If True, this op will output 1 instead of the number of times a token appears (equivalent to one_hot + reduce_any instead of one_hot + reduce_add). Defaults to False.</source>
          <target state="translated">True 인 경우이 작업은 토큰이 나타나는 횟수 대신 1을 출력합니다 (one_hot + reduce_add 대신 one_hot + reduce_any와 동일). 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="30683a16709876cdbcd01a89ffad431f68ee9878" translate="yes" xml:space="preserve">
          <source>If True, try colocating gradients with the corresponding op.</source>
          <target state="translated">True 인 경우 그라디언트를 해당 작업과 함께 배치 해보십시오.</target>
        </trans-unit>
        <trans-unit id="0e39587c26c87189210d23066cfee0e73fa2a42e" translate="yes" xml:space="preserve">
          <source>If _ensure_non_none_value is True, then return value is not None.</source>
          <target state="translated">_ensure_non_none_value가 True이면 반환 값은 None이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="f3e656fc2aac4582c753c4ae45093be443f6a61f" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt; is used to compute gradients instead of &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt;&lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt;&lt;/a&gt;, the loss and gradients must be scaled manually. This can be done by calling &lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt;&lt;/a&gt; before passing the loss to &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt;&lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt;&lt;/a&gt; after computing the gradients with &lt;a href=&quot;../../../gradienttape&quot;&gt;&lt;code&gt;tf.GradientTape&lt;/code&gt;&lt;/a&gt;. For example:</source>
          <target state="translated">경우 &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; 이&lt;/a&gt; 대신 계산 그라디언트에 사용되는 &lt;a href=&quot;../../optimizers/optimizer#minimize&quot;&gt; &lt;code&gt;LossScaleOptimizer.minimize&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;lossscaleoptimizer#get_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_gradients&lt;/code&gt; &lt;/a&gt; , 손실 및 그라디언트 수동으로 조정해야합니다. &lt;a href=&quot;lossscaleoptimizer#get_scaled_loss&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_scaled_loss&lt;/code&gt; &lt;/a&gt; 손실을 전달하기 전에 LossScaleOptimizer.get_scaled_loss 를 호출 하고 &lt;a href=&quot;lossscaleoptimizer#get_unscaled_gradients&quot;&gt; &lt;code&gt;LossScaleOptimizer.get_unscaled_gradients&lt;/code&gt; &lt;/a&gt; 그라디언트를 계산 한 후 &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; 를 호출 &lt;a href=&quot;../../../gradienttape&quot;&gt; &lt;code&gt;tf.GradientTape&lt;/code&gt; &lt;/a&gt; 됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c62a01cf3e585d852286d2db8a969d75001530e3" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;compat/v1/session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; is used, an &lt;code&gt;Operation&lt;/code&gt; of a &lt;a href=&quot;graph&quot;&gt;&lt;code&gt;tf.Graph&lt;/code&gt;&lt;/a&gt; can be executed by passing it to &lt;code&gt;tf.Session.run&lt;/code&gt;. &lt;code&gt;op.run()&lt;/code&gt; is a shortcut for calling &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;compat/v1/session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; 가&lt;/a&gt; 사용된다 &lt;code&gt;Operation&lt;/code&gt; (A)의 &lt;a href=&quot;graph&quot;&gt; &lt;code&gt;tf.Graph&lt;/code&gt; 은&lt;/a&gt; 그것을 통과시킴으로써 수행 될 수 &lt;code&gt;tf.Session.run&lt;/code&gt; . &lt;code&gt;op.run()&lt;/code&gt; 은 &lt;code&gt;tf.compat.v1.get_default_session().run(op)&lt;/code&gt; 호출을위한 바로 가기입니다 .</target>
        </trans-unit>
        <trans-unit id="865785682fb36eb7c051375ddba9ba312f45e409" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;CheckpointManager&lt;/code&gt; was previously used in &lt;code&gt;directory&lt;/code&gt;, its state will be restored. This includes the list of managed checkpoints and the timestamp bookkeeping necessary to support &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt;. The behavior of the new &lt;code&gt;CheckpointManager&lt;/code&gt; will be the same as the previous &lt;code&gt;CheckpointManager&lt;/code&gt;, including cleaning up existing checkpoints if appropriate.</source>
          <target state="translated">&lt;code&gt;CheckpointManager&lt;/code&gt; 가 &lt;code&gt;directory&lt;/code&gt; 에서 이미 사용 된 경우 상태가 복원됩니다. 여기에는 관리 체크 포인트 목록과 &lt;code&gt;keep_checkpoint_every_n_hours&lt;/code&gt; 지원에 필요한 타임 스탬프 부기 목록이 포함됩니다 . 새 &lt;code&gt;CheckpointManager&lt;/code&gt; 의 동작은 적절한 경우 기존 체크 포인트 정리를 포함 하여 이전 &lt;code&gt;CheckpointManager&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="5e64e8f1b8de75ff0a5ee5be594f66e107865c9e" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DeviceSpec&lt;/code&gt; is partially specified, it will be merged with other &lt;code&gt;DeviceSpec&lt;/code&gt;s according to the scope in which it is defined. &lt;code&gt;DeviceSpec&lt;/code&gt; components defined in inner scopes take precedence over those defined in outer scopes.</source>
          <target state="translated">경우 &lt;code&gt;DeviceSpec&lt;/code&gt; 가 부분 지정하고, 그것은 서로 병합 될 &lt;code&gt;DeviceSpec&lt;/code&gt; S가 정의 된 범위에 따라. 내부 범위에 정의 된 &lt;code&gt;DeviceSpec&lt;/code&gt; 구성 요소는 외부 범위에 정의 된 구성 요소보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="d433cac1256b5f0c29a6caba9953c430b9d228df" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;file_pattern&lt;/code&gt; matches several files, &lt;code&gt;preferred_shard&lt;/code&gt; can be used to hint in which file the requested tensor is likely to be found. This op will first open the file at index &lt;code&gt;preferred_shard&lt;/code&gt; in the list of matching files and try to restore tensors from that file. Only if some tensors or tensor slices are not found in that first file, then the Op opens all the files. Setting &lt;code&gt;preferred_shard&lt;/code&gt; to match the value passed as the &lt;code&gt;shard&lt;/code&gt; input of a matching &lt;code&gt;Save&lt;/code&gt; Op may speed up Restore. This attribute only affects performance, not correctness. The default value -1 means files are processed in order.</source>
          <target state="translated">&lt;code&gt;file_pattern&lt;/code&gt; 이 여러 파일과 일치 하는 경우 &lt;code&gt;preferred_shard&lt;/code&gt; 를 사용하여 요청 된 텐서를 찾을 수있는 파일을 힌트 할 수 있습니다. 이 작업은 먼저 일치하는 파일 목록의 &lt;code&gt;preferred_shard&lt;/code&gt; 색인에서 파일을 열고 해당 파일에서 텐서를 복원하려고 시도합니다. 첫 번째 파일에서 일부 텐서 또는 텐서 슬라이스를 찾을 수없는 경우에만 Op가 모든 파일을 엽니 다. 일치하는 &lt;code&gt;Save&lt;/code&gt; 의 &lt;code&gt;shard&lt;/code&gt; 입력으로 전달 된 값과 일치하도록 &lt;code&gt;preferred_shard&lt;/code&gt; 를 설정하면 복원 속도가 빨라질 수 있습니다. 이 속성은 정확성이 아닌 성능에만 영향을줍니다. 기본값 -1은 파일이 순서대로 처리됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b14ed379de0c6fb8eb346774c644654872622bf9" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;timeout_fn&lt;/code&gt; was specified, that function is called and if it returns a true boolean value the iterator stops yielding.</source>
          <target state="translated">경우 &lt;code&gt;timeout_fn&lt;/code&gt; 을 지정, 그 함수를 호출하고 진정한 부울 값을 반환하는 경우 반복자는 항복을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0d849b7664051e2a1b340cdeff76439f664435a0" translate="yes" xml:space="preserve">
          <source>If a TypeSpec cannot be built for &lt;code&gt;value&lt;/code&gt;, because its type is not supported.</source>
          <target state="translated">type이 지원되지 않기 때문에 &lt;code&gt;value&lt;/code&gt; 에 대해 TypeSpec을 빌드 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="8164a55457820e6cea959683381dc10013ab7da4" translate="yes" xml:space="preserve">
          <source>If a component has an unknown rank, and the &lt;code&gt;padded_shapes&lt;/code&gt; argument is not set.</source>
          <target state="translated">구성 요소에 알 수없는 순위가 있고 &lt;code&gt;padded_shapes&lt;/code&gt; 인수가 설정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="5ec58a27134b5cd408fe0ba957abfdf776222edc" translate="yes" xml:space="preserve">
          <source>If a custom &lt;code&gt;window_fn&lt;/code&gt; is used with &lt;a href=&quot;stft&quot;&gt;&lt;code&gt;tf.signal.stft&lt;/code&gt;&lt;/a&gt;, it must be passed to &lt;a href=&quot;inverse_stft_window_fn&quot;&gt;&lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">사용자 정의 경우 &lt;code&gt;window_fn&lt;/code&gt; 가 사용됩니다 &lt;a href=&quot;stft&quot;&gt; &lt;code&gt;tf.signal.stft&lt;/code&gt; &lt;/a&gt; , 그것은에 전달해야 &lt;a href=&quot;inverse_stft_window_fn&quot;&gt; &lt;code&gt;tf.signal.inverse_stft_window_fn&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="04707a712ceddb742b3bc71b93c045408830d3e4" translate="yes" xml:space="preserve">
          <source>If a default TensorFlow session is available, we will return it.</source>
          <target state="translated">기본 TensorFlow 세션이 사용 가능한 경우 반환합니다.</target>
        </trans-unit>
        <trans-unit id="213ed962ed066bee6b7b5cbd37c8e4427241d34e" translate="yes" xml:space="preserve">
          <source>If a dimension should not be cropped, pass the full size of that dimension. For example, RGB images can be cropped with &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt;.</source>
          <target state="translated">치수를자를 수없는 경우 해당 치수의 전체 크기를 전달하십시오. 예를 들어 RGB 이미지는 &lt;code&gt;size = [crop_height, crop_width, 3]&lt;/code&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc9ba83547b410d42bf62831041b3d3149565986" translate="yes" xml:space="preserve">
          <source>If a function is passed in.</source>
          <target state="translated">함수가 전달 된 경우.</target>
        </trans-unit>
        <trans-unit id="47ff9a74ff30c04f2722c0fc8f7a3a5f1b3d917a" translate="yes" xml:space="preserve">
          <source>If a gradient of &lt;code&gt;None&lt;/code&gt; is passed in any position of the nested structure, then an gradient update with a zero gradient is applied for that feature. For optimizers like SGD or Adagrad, this is the same as applying no update at all. For lazy Adam and other sparsely applied optimizers with decay, ensure you understand the effect of applying a zero gradient.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 그라디언트가 중첩 된 구조의 임의 위치에 전달되면 그라디언트가 0 인 그라디언트 업데이트가 해당 기능에 적용됩니다. SGD 또는 Adagrad와 같은 최적화 프로그램의 경우 업데이트를 전혀 적용하지 않는 것과 동일합니다. 게으른 Adam 및 감소가있는 기타 드물게 적용된 옵티마이 저의 경우 제로 그래디언트 적용의 효과를 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="c35ca212a0c42d1f0472871e7f4f8866f1ab08bf" translate="yes" xml:space="preserve">
          <source>If a key is not found in the barrier, this operation will create a new incomplete element. If a key is found in the barrier, and the element already has a value at component_index, this operation will fail with INVALID_ARGUMENT, and leave the barrier in an undefined state.</source>
          <target state="translated">장벽에서 키를 찾을 수없는 경우이 작업은 새로운 불완전한 요소를 생성합니다. 배리어에서 키가 발견되고 요소에 이미 component_index 값이있는 경우이 작업은 INVALID_ARGUMENT로 실패하고 배리어를 정의되지 않은 상태로 둡니다.</target>
        </trans-unit>
        <trans-unit id="505d4a9c3cd6d1154b285ae8ef2d9c20d907de11" translate="yes" xml:space="preserve">
          <source>If a key is not present in the table, it is silently ignored.</source>
          <target state="translated">키가 테이블에 없으면 자동으로 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="21703450259fbf9667e7b00b4bfd861d99657501" translate="yes" xml:space="preserve">
          <source>If a layer's compute and variable dtypes differ, &lt;code&gt;add_weight&lt;/code&gt; will wrap floating-point variables with a special wrapper called an &lt;code&gt;AutoCastVariable&lt;/code&gt;. This wrapper is identical to the original variable except it casts itself to the layer's compute dtype when used within &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;. Outside &lt;a href=&quot;../../layers/layer#call&quot;&gt;&lt;code&gt;Layer.call&lt;/code&gt;&lt;/a&gt;, the variable is not casted.</source>
          <target state="translated">레이어의 계산 및 변수 dtype이 다른 경우 &lt;code&gt;add_weight&lt;/code&gt; 는 &lt;code&gt;AutoCastVariable&lt;/code&gt; 이라는 특수 래퍼로 부동 소수점 변수를 래핑 합니다. 내에 사용될 때 레이어의 계산 DTYPE 자체를 제외 캐스팅이 랩퍼는 원래 변수 동일 &lt;a href=&quot;../../layers/layer#call&quot;&gt; &lt;code&gt;Layer.call&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;../../layers/layer#call&quot;&gt; &lt;code&gt;Layer.call&lt;/code&gt; &lt;/a&gt; 외부 에서는 변수가 캐스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e8f77e769af992f7a98efcdf6867f7871af8dee" translate="yes" xml:space="preserve">
          <source>If a matrix is not invertible there is no guarantee what the op does. It may detect the condition and raise an exception or it may simply return a garbage result.</source>
          <target state="translated">행렬이 돌이킬 수없는 경우 op의 기능이 보장되지 않습니다. 조건을 감지하여 예외를 발생 시키거나 단순히 가비지 결과를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90d360255fc2e1f2162c5178513396009fd20bac" translate="yes" xml:space="preserve">
          <source>If a negative number is large, its sigmoid will approach to 0 since the formula will be &lt;code&gt;y = 1 / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">음수가 크면 수식이 &lt;code&gt;y = 1 / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c949e4db2e61ac473a1157a4b3514a3881108e88" translate="yes" xml:space="preserve">
          <source>If a non-&lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; non-&lt;code&gt;None&lt;/code&gt; gradient is passed in, or a &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; of the incorrect shape is passed in. Also if the size of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="translated">비 &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 비 &lt;code&gt;None&lt;/code&gt; 그라디언트가 전달되거나 잘못된 모양 의 &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 가 전달되는 경우. 또한 &lt;code&gt;gradients&lt;/code&gt; 시퀀스 크기가 &lt;code&gt;feature_config&lt;/code&gt; 의 해당 시퀀스와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="b9178c569fd77ec0b3d985f9eb129b9d6a07af9f" translate="yes" xml:space="preserve">
          <source>If a non-TPU name is used when constructing a TPUClusterResolver, that will be returned instead (e.g. If the tpus argument's value when constructing this TPUClusterResolver was 'grpc://10.240.1.2:8470', 'grpc://10.240.1.2:8470' will be returned).</source>
          <target state="translated">TPUClusterResolver를 구성 할 때 비 TPU 이름이 사용되면 대신 반환됩니다 (예 :이 TPUClusterResolver를 구성 할 때 tpus 인수의 값이 'grpc : //10.240.1.2 : 8470', 'grpc : //10.240.1.2 인 경우) : 8470 '이 반환됩니다).</target>
        </trans-unit>
        <trans-unit id="d8aa2a02a92b82ba7a81289463203b5673fab674" translate="yes" xml:space="preserve">
          <source>If a particular element is zero, the reciprocal for that element is also set to zero.</source>
          <target state="translated">특정 요소가 0이면 해당 요소의 역수도 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d73c24b67d544bb4ac9de98fe14e9ccd643c7a4d" translate="yes" xml:space="preserve">
          <source>If a partitioner is provided, a &lt;code&gt;PartitionedVariable&lt;/code&gt; is returned. Accessing this object as a &lt;code&gt;Tensor&lt;/code&gt; returns the shards concatenated along the partition axis.</source>
          <target state="translated">파티 셔 너가 제공되면 &lt;code&gt;PartitionedVariable&lt;/code&gt; 이 반환됩니다. 이 객체를 &lt;code&gt;Tensor&lt;/code&gt; 로 액세스 하면 파티션 축을 따라 연결된 샤드가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="893ecf49aee9a3ba330d87aa2fef55d4be74ece6" translate="yes" xml:space="preserve">
          <source>If a positive number is large, then its sigmoid will approach to 1 since the formula will be &lt;code&gt;y = &amp;lt;large_num&amp;gt; / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</source>
          <target state="translated">양수가 크면 수식이 &lt;code&gt;y = &amp;lt;large_num&amp;gt; / (1 + &amp;lt;large_num&amp;gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="347be984824f2221b441d6cd30c6293ef1ba4e6f" translate="yes" xml:space="preserve">
          <source>If a registered conversion function returns an invalid value.</source>
          <target state="translated">등록 된 변환 함수가 잘못된 값을 반환하는 경우.</target>
        </trans-unit>
        <trans-unit id="ead5b4e0e57f258ec5dc0e4180801aec2a6848cc" translate="yes" xml:space="preserve">
          <source>If a slice range is negative size.</source>
          <target state="translated">슬라이스 범위가 음수 인 경우.</target>
        </trans-unit>
        <trans-unit id="2123a41f061b2e74cae724869e7d376295c37aa5" translate="yes" xml:space="preserve">
          <source>If a task_type and task_id is given, this will override the &lt;code&gt;master&lt;/code&gt; string passed into the initialization function.</source>
          <target state="translated">task_type 및 task_id가 제공되면 초기화 함수에 전달 된 &lt;code&gt;master&lt;/code&gt; 문자열 을 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="523e96cfbd593dd2c3baf3ac9053a63ba05d9124" translate="yes" xml:space="preserve">
          <source>If a tensor is produced by an operation of type &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;, its shape may be inferred if there is a registered shape function for &lt;code&gt;&quot;Foo&quot;&lt;/code&gt;. See &lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;Shape functions&lt;/a&gt; for details of shape functions and how to register them. Alternatively, the shape may be set explicitly using &lt;a href=&quot;tensor#set_shape&quot;&gt;&lt;code&gt;tf.Tensor.set_shape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텐서이 타입의 동작에 의해 생산되는 경우 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; 에 대한 등록 형상 함수가있는 경우, 그 형상이 추론 될 수있다 &lt;code&gt;&quot;Foo&quot;&lt;/code&gt; . &lt;a href=&quot;https://tensorflow.org/extend/adding_an_op#shape_functions_in_c&quot;&gt;모양 함수에&lt;/a&gt; 대한 자세한 내용과 등록 방법 은 모양 함수 를 참조하십시오 . 또는 &lt;a href=&quot;tensor#set_shape&quot;&gt; &lt;code&gt;tf.Tensor.set_shape&lt;/code&gt; 를&lt;/a&gt; 사용하여 모양을 명시 적으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="243834e6c2d91813583c07dbf83d5550f40b05d8" translate="yes" xml:space="preserve">
          <source>If a variable has a moving average, use the moving average variable name as the restore name; otherwise, use the variable name.</source>
          <target state="translated">변수에 이동 평균이있는 경우 이동 평균 변수 이름을 복원 이름으로 사용하십시오. 그렇지 않으면 변수 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f642e4be5d733e10310c09fcad00792974d1e540" translate="yes" xml:space="preserve">
          <source>If all of these are true, then 2 properties are enforced by the template:</source>
          <target state="translated">이 모든 것이 참이면 템플릿에 의해 2 가지 속성이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b47c01f63765154c2063ab037b98cdf2e6643b0d" translate="yes" xml:space="preserve">
          <source>If all operators do not have the same &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">모든 연산자에 동일한 &lt;code&gt;dtype&lt;/code&gt; 이없는 경우 .</target>
        </trans-unit>
        <trans-unit id="ab2a2942673f420e3b9df9018ebc3c57937a2a61" translate="yes" xml:space="preserve">
          <source>If all replicas do not have equal numbers of input tensors.</source>
          <target state="translated">모든 복제본에 동일한 수의 입력 텐서가없는 경우.</target>
        </trans-unit>
        <trans-unit id="a5c6117c645e2d99da3c1e80d1e84fe0fe64cc20" translate="yes" xml:space="preserve">
          <source>If amsgrad = False: Initialization:</source>
          <target state="translated">amsgrad = False 인 경우 : 초기화 :</target>
        </trans-unit>
        <trans-unit id="9b404c2a8925caf71a7bb356a68b571d47740e1b" translate="yes" xml:space="preserve">
          <source>If amsgrad = True: Initialization:</source>
          <target state="translated">amsgrad = True 인 경우 : 초기화 :</target>
        </trans-unit>
        <trans-unit id="5cf3f3e1c44e12d92c5b7fbf8235942d050af3de" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; object is created and the &lt;code&gt;apply()&lt;/code&gt; method is called on a list of variables, these variables will be added to the &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; collection. This convenience function returns the contents of that collection.</source>
          <target state="translated">는 IF &lt;code&gt;ExponentialMovingAverage&lt;/code&gt; 의 객체가 생성되고이있다 &lt;code&gt;apply()&lt;/code&gt; 방법은 변수들의리스트라고하고, 이러한 변수가 추가 될 것이다 &lt;code&gt;GraphKeys.MOVING_AVERAGE_VARIABLES&lt;/code&gt; 의 컬렉션. 이 편의 함수는 해당 컬렉션의 내용을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0573b0aef7d01f68ba24860a81d945b1c44866a3" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;initializer&lt;/code&gt; is provided, then the output of &lt;code&gt;fn&lt;/code&gt; must have the same structure as &lt;code&gt;initializer&lt;/code&gt;; and the first argument of &lt;code&gt;fn&lt;/code&gt; must match this structure.</source>
          <target state="translated">는 IF &lt;code&gt;initializer&lt;/code&gt; 제공되고, 다음의 출력 &lt;code&gt;fn&lt;/code&gt; 동일한 구조 있어야 &lt;code&gt;initializer&lt;/code&gt; ; &lt;code&gt;fn&lt;/code&gt; 의 첫 번째 인수는 이 구조와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fdb898be79288ab3685a0b600db22aa721876bf" translate="yes" xml:space="preserve">
          <source>If an empty TPU name is specified and this is running in a Google Cloud environment.</source>
          <target state="translated">빈 TPU 이름이 지정되고 Google Cloud 환경에서 실행중인 경우.</target>
        </trans-unit>
        <trans-unit id="3f4864ad2daae673720e2d27a04ea8d707ae17bf" translate="yes" xml:space="preserve">
          <source>If an exception has been passed to &lt;code&gt;request_stop&lt;/code&gt;, this raises it.</source>
          <target state="translated">&lt;code&gt;request_stop&lt;/code&gt; 에 예외가 전달되면 예외가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="dee0a66565fe36d81b4afeadf3a4154301be5114" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; or any other type, then it is batched as normal.</source>
          <target state="translated">입력 요소가 &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 또는 기타 유형이면 정상적으로 일괄 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="bb5361ff44853948b5da97bedf499f8fcd750746" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; contains one or more axes with unknown size (i.e., &lt;code&gt;shape[i]=None&lt;/code&gt;), then the output will contain a &lt;a href=&quot;../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt; that is ragged up to any of such dimensions.</source>
          <target state="translated">입력 요소가있는 경우 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 그 정적 &lt;a href=&quot;../../tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; 가&lt;/a&gt; 알려지지 크기 (즉, 하나 개 이상의 축을 포함 &lt;code&gt;shape[i]=None&lt;/code&gt; ), 출력은 포함 &lt;a href=&quot;../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 같은 임의까지 울퉁불퉁되고 치수.</target>
        </trans-unit>
        <trans-unit id="3ecf5202d359cddeca2f06d60fe52705eafbb971" translate="yes" xml:space="preserve">
          <source>If an input element is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt; whose static &lt;a href=&quot;../../tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt; is fully defined, then it is batched as normal.</source>
          <target state="translated">입력 요소가있는 경우 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 그 정적 &lt;a href=&quot;../../tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt; 완전히 정의되며, 그때 이것은 정상으로 일괄 처리된다.</target>
        </trans-unit>
        <trans-unit id="e0f250f8ea55b97372b4bf0fcda3313dba275f0b" translate="yes" xml:space="preserve">
          <source>If an input feature is of numeric type, you can use &lt;code&gt;categorical_column_with_identity&lt;/code&gt;, or &lt;code&gt;bucketized_column&lt;/code&gt;, as in the example:</source>
          <target state="translated">입력 기능이 숫자 유형 인 경우 예와 같이 &lt;code&gt;categorical_column_with_identity&lt;/code&gt; 또는 &lt;code&gt;bucketized_column&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b4df35e958a9276d82646b052362b7eee1aacc9" translate="yes" xml:space="preserve">
          <source>If an invalid &lt;code&gt;device_policy&lt;/code&gt; is passed.</source>
          <target state="translated">잘못된 &lt;code&gt;device_policy&lt;/code&gt; 가 전달 된 경우.</target>
        </trans-unit>
        <trans-unit id="f4624eedb4b71470bfe8956d0d864fba18f93e56" translate="yes" xml:space="preserve">
          <source>If an invalid checkpoint_format was given.</source>
          <target state="translated">유효하지 않은 checkpoint_format이 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="da437886a8c1d8088049789df846da293dab7ad9" translate="yes" xml:space="preserve">
          <source>If an unknown keyword argument is provided.</source>
          <target state="translated">알 수없는 키워드 인수가 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="86d660c47dfcbd8f8bb7bbe04503dea8a280958f" translate="yes" xml:space="preserve">
          <source>If an unordered dictionary is used for &lt;code&gt;pred_fn_pairs&lt;/code&gt;, the order of the conditional tests is not guaranteed. However, the order is guaranteed to be deterministic, so that variables created in conditional branches are created in fixed order across runs.</source>
          <target state="translated">정렬되지 않은 사전이 &lt;code&gt;pred_fn_pairs&lt;/code&gt; 에 사용되는 경우 조건부 테스트 순서가 보장되지 않습니다. 그러나 순서는 결정론 적이므로 조건부 분기에서 작성된 변수는 실행에서 고정 된 순서로 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="61aa7f26dc9bfe59ac61dcb0d725f8942ad22bbc" translate="yes" xml:space="preserve">
          <source>If an unsupported output stream is specified.</source>
          <target state="translated">지원되지 않는 출력 스트림이 지정된 경우.</target>
        </trans-unit>
        <trans-unit id="c34e1255c75e9685892d9a437bf03466f99ad3c0" translate="yes" xml:space="preserve">
          <source>If another profiling session is running.</source>
          <target state="translated">다른 프로파일 링 세션이 실행중인 경우.</target>
        </trans-unit>
        <trans-unit id="4eb5ae0b72f49cc4b3190b35c502746c1bde1aa5" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected shape.</source>
          <target state="translated">인수에 예상 된 모양이없는 경우.</target>
        </trans-unit>
        <trans-unit id="75a04c132d63131668f4d5fc00adc259012cb811" translate="yes" xml:space="preserve">
          <source>If any argument does not have the expected type.</source>
          <target state="translated">인수에 예상 된 유형이없는 경우.</target>
        </trans-unit>
        <trans-unit id="104cc4757aab1efc5d6e568cd9b973a80e1046b2" translate="yes" xml:space="preserve">
          <source>If any argument is not a subclass of &lt;code&gt;ClusterResolvers&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;ClusterResolvers&lt;/code&gt; 의 하위 클래스가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ab7bb5e26ed6f3d67fb39638574da3ab5aaddabc" translate="yes" xml:space="preserve">
          <source>If any downstream layer does not support masking yet receives such an input mask, an exception will be raised.</source>
          <target state="translated">다운 스트림 계층이 마스킹을 지원하지 않지만 이러한 입력 마스크를 수신하면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="634aed1eed17dfb056b4ad2197a898ad89414116" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are equal, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">어느 경우 원소 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 동일이다 &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="e7d1ad99b5dd0129899030412bf73fb9c778531c" translate="yes" xml:space="preserve">
          <source>If any elements of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are not close, &lt;code&gt;message&lt;/code&gt;, as well as the first &lt;code&gt;summarize&lt;/code&gt; entries of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are printed, and &lt;code&gt;InvalidArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">임의의 요소 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 확대되지 않으며, &lt;code&gt;message&lt;/code&gt; 뿐만 아니라 제 &lt;code&gt;summarize&lt;/code&gt; 의 항목 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 인쇄되고, &lt;code&gt;InvalidArgumentError&lt;/code&gt; 가 상승한다.</target>
        </trans-unit>
        <trans-unit id="b2f25882615aa702375e83fa7b9e7593fb4f3fdf" translate="yes" xml:space="preserve">
          <source>If any input is &lt;code&gt;RaggedTensor&lt;/code&gt;, the output is &lt;code&gt;RaggedTensor&lt;/code&gt;. Else, if any input is &lt;code&gt;SparseTensor&lt;/code&gt;, the output is &lt;code&gt;SparseTensor&lt;/code&gt;. Otherwise, the output is &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">입력이 &lt;code&gt;RaggedTensor&lt;/code&gt; 이면 출력은 &lt;code&gt;RaggedTensor&lt;/code&gt; 입니다. 그렇지 않으면 입력이 &lt;code&gt;SparseTensor&lt;/code&gt; 인 경우 출력은 &lt;code&gt;SparseTensor&lt;/code&gt; 입니다. 그렇지 않으면 출력은 &lt;code&gt;Tensor&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="201389c22590633c83c5b057c8d7d1a9efd7136f" translate="yes" xml:space="preserve">
          <source>If any input value is negative, the values are shifted so input value 0.0 is at 127. They are then rescaled so that either the smallest value is 0, or the largest one is 255.</source>
          <target state="translated">입력 값이 음수이면 값이 이동되어 입력 값 0.0이 127이됩니다. 그런 다음 가장 작은 값이 0이거나 가장 큰 값이 255가되도록 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="21b041f5bb8cb3bba32b9d99d9f1fdb9761357eb" translate="yes" xml:space="preserve">
          <source>If any member of graph_parents is &lt;code&gt;None&lt;/code&gt; or not a &lt;code&gt;Tensor&lt;/code&gt;.</source>
          <target state="translated">graph_parents의 멤버가 &lt;code&gt;None&lt;/code&gt; 이거나 &lt;code&gt;Tensor&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ebd7e9a74a89a38f74d24f08a15f6aa84c314887" translate="yes" xml:space="preserve">
          <source>If any of flag name has not already been defined as a flag.</source>
          <target state="translated">플래그 이름이 아직 플래그로 정의되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="153ed179add7feb8b47efeb5504c4b40f4f6d107" translate="yes" xml:space="preserve">
          <source>If any of the &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;SequenceDenseColumn&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;feature_columns&lt;/code&gt; 중 하나 가 &lt;code&gt;SequenceDenseColumn&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="d115bf20c796ffd7a6d941e51d60620411f1bb26" translate="yes" xml:space="preserve">
          <source>If any of the arguments is malformed.</source>
          <target state="translated">인수 중 하나라도 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="ccb5d0547ad1a9683e114915c25a63c2d054f87a" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not of the expected type.</source>
          <target state="translated">인수가 예상 된 유형이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="4b59ddf1a6f470800772a366cfe28702ffe98aef" translate="yes" xml:space="preserve">
          <source>If any of the arguments is not the expected type.</source>
          <target state="translated">인수가 예상 유형이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="1365eb07064dc9e5659eda64b059892f78c64922" translate="yes" xml:space="preserve">
          <source>If any of the byte counts are non-positive.</source>
          <target state="translated">바이트 수가 양수가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="954800413b711cf77096d24081094c2560662f68" translate="yes" xml:space="preserve">
          <source>If any of the following is not &lt;code&gt;True&lt;/code&gt;: &lt;code&gt;{is_self_adjoint, is_non_singular, is_positive_definite}&lt;/code&gt;.</source>
          <target state="translated">다음 중 하나라도 &lt;code&gt;True&lt;/code&gt; 가 아닌 경우 : &lt;code&gt;{is_self_adjoint, is_non_singular, is_positive_definite}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da67b8db41666513a4a8f6b2c5ae9ca64b54a414" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;FeatureColumn&lt;/code&gt; instance.</source>
          <target state="translated">주어진 &lt;code&gt;feature_columns&lt;/code&gt; 가 &lt;code&gt;FeatureColumn&lt;/code&gt; 인스턴스 가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="246f099f519bd12e56fd8882d96401944e27101b" translate="yes" xml:space="preserve">
          <source>If any of the given &lt;code&gt;feature_columns&lt;/code&gt; is not a &lt;code&gt;_FeatureColumn&lt;/code&gt; instance.</source>
          <target state="translated">주어진 &lt;code&gt;feature_columns&lt;/code&gt; 가 &lt;code&gt;_FeatureColumn&lt;/code&gt; 인스턴스 가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="51d6ef4de5d42bc2c9ae983cfc7b923fa4135bcc" translate="yes" xml:space="preserve">
          <source>If any of the input arguments is invalid.</source>
          <target state="translated">입력 인수가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="164009727aa4b17dc13b64037a5217df8ac2bf3c" translate="yes" xml:space="preserve">
          <source>If any of the keys is &lt;code&gt;HashedCategoricalColumn&lt;/code&gt;.</source>
          <target state="translated">키가 &lt;code&gt;HashedCategoricalColumn&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="ba75ce60ce4642b689e137daa52fd305c211ad0e" translate="yes" xml:space="preserve">
          <source>If any of the keys is neither a string nor &lt;code&gt;CategoricalColumn&lt;/code&gt;.</source>
          <target state="translated">키가 문자열도 아니고 &lt;code&gt;CategoricalColumn&lt;/code&gt; 도 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="fc0212db7cd6e76755e5faced8786020695bc785" translate="yes" xml:space="preserve">
          <source>If any of the keys or values in &lt;code&gt;var_list&lt;/code&gt; are not unique.</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 의 키 또는 값 이 고유하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="8ae347247aa1f1565248180b4e03047133773f20" translate="yes" xml:space="preserve">
          <source>If any of the model checkpoint paths conflict with the file containing CheckpointSate.</source>
          <target state="translated">모델 체크 포인트 경로가 CheckpointSate를 포함하는 파일과 충돌하는 경우.</target>
        </trans-unit>
        <trans-unit id="1c849b28a0dd88d012bdea7f8413112695383378" translate="yes" xml:space="preserve">
          <source>If any of the pods returned by the master is not in the &lt;code&gt;Running&lt;/code&gt; phase.</source>
          <target state="translated">마스터에서 반환 된 포드가 &lt;code&gt;Running&lt;/code&gt; 단계에없는 경우.</target>
        </trans-unit>
        <trans-unit id="35a55c237aa2b737807fdc64d01d2bf3e0fcbec6" translate="yes" xml:space="preserve">
          <source>If any property name in &lt;code&gt;kwargs&lt;/code&gt; does not exist or is not allowed to be replaced, or both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="translated">&lt;code&gt;kwargs&lt;/code&gt; 의 속성 이름이 존재하지 않거나 대체 할 수없는 경우 또는 &lt;code&gt;save_checkpoints_steps&lt;/code&gt; 및 &lt;code&gt;save_checkpoints_secs&lt;/code&gt; 가 모두 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="306dd5fe96f1dd91f7030ff1c2b06063fea92e01" translate="yes" xml:space="preserve">
          <source>If any thread is still alive after &lt;code&gt;request_stop()&lt;/code&gt; is called and the grace period expires.</source>
          <target state="translated">&lt;code&gt;request_stop()&lt;/code&gt; 이 호출되고 유예 기간이 만료 된 후에도 스레드가 여전히 살아있는 경우 .</target>
        </trans-unit>
        <trans-unit id="95fe57fa1855b6ddf46278b8183ad2b9df4c0217" translate="yes" xml:space="preserve">
          <source>If any unsupported dtype is provided.</source>
          <target state="translated">지원되지 않는 dtype이 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="18da86b931d75b280e98e54522ffc353ef05d29a" translate="yes" xml:space="preserve">
          <source>If args contains no &lt;code&gt;RaggedTensors&lt;/code&gt;, or if the &lt;code&gt;nested_splits&lt;/code&gt; of the input &lt;code&gt;RaggedTensor&lt;/code&gt;s are not identical.</source>
          <target state="translated">args에 &lt;code&gt;RaggedTensors&lt;/code&gt; 가 없거나 입력 &lt;code&gt;RaggedTensor&lt;/code&gt; 의 &lt;code&gt;nested_splits&lt;/code&gt; 가 동일하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="61c271fb50f50246bb17c3667097bcb19f1551e4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;shape&lt;/code&gt; requests a &lt;code&gt;SparseTensor&lt;/code&gt; with a different number of elements than &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">인수의 경우 &lt;code&gt;shape&lt;/code&gt; 요청 신호 &lt;code&gt;SparseTensor&lt;/code&gt; 을 보다 더 요소를 다른 번호로 &lt;code&gt;sp_input&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4d100e9a09233d86bf60e11ff4ca5463af5b29d" translate="yes" xml:space="preserve">
          <source>If argument validation fails.</source>
          <target state="translated">인수 유효성 검사가 실패한 경우.</target>
        </trans-unit>
        <trans-unit id="8fd4e1e21beb2600328c24eca5c8e19102684d0c" translate="yes" xml:space="preserve">
          <source>If attempting to run this model with a backend that does not support separable convolutions.</source>
          <target state="translated">분리 가능한 컨볼 루션을 지원하지 않는 백엔드로이 모델을 실행하려는 경우.</target>
        </trans-unit>
        <trans-unit id="10228106a0685e5f9e6380b371aad2f9a86e3ea7" translate="yes" xml:space="preserve">
          <source>If autoresolve_task is not a boolean or a callable.</source>
          <target state="translated">autoresolve_task가 부울 또는 콜 러블이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="4f88c47fc9b05b10f2fcb778ad61c4f172bb0d49" translate="yes" xml:space="preserve">
          <source>If axis is not a constant scalar, or the direction is invalid.</source>
          <target state="translated">축이 상수 스칼라가 아니거나 방향이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="b7ac540ff691a4908db4956927f427a38b150efe" translate="yes" xml:space="preserve">
          <source>If axis is specified, min_range and max_range</source>
          <target state="translated">축이 지정되면 min_range 및 max_range</target>
        </trans-unit>
        <trans-unit id="8b680e1777690485d0fdfbf495668b50dad1ab84" translate="yes" xml:space="preserve">
          <source>If batch length of predictions is not the same and &lt;code&gt;yield_single_examples&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">예측의 배치 길이가 동일하지 않고 &lt;code&gt;yield_single_examples&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="29d8d77b2a9b5e983e90c9ba56dc5a68dc113814" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 &lt;code&gt;Tensor&lt;/code&gt; 인 경우 . 대신 &lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="775f28b59c8769a12239d3417a4f08d984979d9e" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;Tensor&lt;/code&gt;s. Use &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 &lt;code&gt;Tensor&lt;/code&gt; 인 경우 . 대신 &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="3d8debb3f5cf7c56d30004043d17c49987b6983b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;lengths&lt;/code&gt; and &lt;code&gt;padding&lt;/code&gt; are specified.</source>
          <target state="translated">경우 모두 &lt;code&gt;lengths&lt;/code&gt; 와 &lt;code&gt;padding&lt;/code&gt; 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="48546b5e8ae477de70d764bfd8c77f00989a5ce4" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;meta_graph_def&lt;/code&gt; is not an instance of &lt;code&gt;MetaGraphDef&lt;/code&gt;.</source>
          <target state="translated">두 경우 &lt;code&gt;meta_graph_def&lt;/code&gt; 는 의 인스턴스가 아닌 &lt;code&gt;MetaGraphDef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f91f4a4adbe074ac1d6bf586eeffdce44715c8f" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;num_parallel_batches&lt;/code&gt; and &lt;code&gt;num_parallel_calls&lt;/code&gt; are specified.</source>
          <target state="translated">모두 만약 &lt;code&gt;num_parallel_batches&lt;/code&gt; 및 &lt;code&gt;num_parallel_calls&lt;/code&gt; 이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="65a7c1288e03a43af5c0b5b4959caddd04931614" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;queue_runner_def&lt;/code&gt; and &lt;code&gt;queue&lt;/code&gt; are both specified.</source>
          <target state="translated">두 경우 &lt;code&gt;queue_runner_def&lt;/code&gt; 및 &lt;code&gt;queue&lt;/code&gt; 둘 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="2c07e75ecd5ecce1ea77bb485d5ad418536da4f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;run_every_secs&lt;/code&gt; and &lt;code&gt;run_every_steps&lt;/code&gt; are set.</source>
          <target state="translated">경우 모두 &lt;code&gt;run_every_secs&lt;/code&gt; 및 &lt;code&gt;run_every_steps&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3b90a4d783183b4de07e57fdd2cda84e4f3d07f0" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;save_checkpoints_steps&lt;/code&gt; and &lt;code&gt;save_checkpoints_secs&lt;/code&gt; are set.</source>
          <target state="translated">경우 모두 &lt;code&gt;save_checkpoints_steps&lt;/code&gt; 및 &lt;code&gt;save_checkpoints_secs&lt;/code&gt; 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0e1845445c62ee220acb45756953aeaef35c9fdb" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and (&lt;code&gt;batch_input_shape&lt;/code&gt; or &lt;code&gt;batch_shape&lt;/code&gt;) are provided.</source>
          <target state="translated">두 경우 &lt;code&gt;shape&lt;/code&gt; 과 ( &lt;code&gt;batch_input_shape&lt;/code&gt; 또는 &lt;code&gt;batch_shape&lt;/code&gt; 가 ) 제공된다.</target>
        </trans-unit>
        <trans-unit id="49e738c4c4deeba9768a8d9501a25e362ab98273" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;tensor&lt;/code&gt; are None.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 과 &lt;code&gt;tensor&lt;/code&gt; 가 모두 None 이면 .</target>
        </trans-unit>
        <trans-unit id="f91cac691d81a79e3b90cd7a4ecc5bd41bc69a32" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;sparse&lt;/code&gt; and &lt;code&gt;ragged&lt;/code&gt; are provided.</source>
          <target state="translated">모두 만약 &lt;code&gt;sparse&lt;/code&gt; 및 &lt;code&gt;ragged&lt;/code&gt; 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7ffff115e30b8d1d1e68c2e6877b5bdce943abab" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;steps&lt;/code&gt; and &lt;code&gt;max_steps&lt;/code&gt; are not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 와 &lt;code&gt;max_steps&lt;/code&gt; 가 모두 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="2dca817d8bae391a4a501847a98642b28665de5b" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;train_op_fn&lt;/code&gt; and &lt;code&gt;optimizer&lt;/code&gt; are &lt;code&gt;None&lt;/code&gt; in TRAIN mode, or if both are set. If &lt;code&gt;mode&lt;/code&gt; is not in Estimator's &lt;code&gt;ModeKeys&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;train_op_fn&lt;/code&gt; 과 &lt;code&gt;optimizer&lt;/code&gt; 가 모두 TRAIN 모드에서 &lt;code&gt;None&lt;/code&gt; 이거나 둘 다 설정된 경우. &lt;code&gt;mode&lt;/code&gt; 가 &lt;code&gt;ModeKeys&lt;/code&gt; 의 ModeKeys에 없는 경우 .</target>
        </trans-unit>
        <trans-unit id="c64d8facbe458ef00eeabe91ddcd150a12b58055" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;variable_def&lt;/code&gt; and initial_value are specified.</source>
          <target state="translated">모두 만약 &lt;code&gt;variable_def&lt;/code&gt; 및 initial_value이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa72f53d68fdd3e50b946d2a8a64e217e60056c2" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are None, then this operation returns the coordinates of true elements of &lt;code&gt;condition&lt;/code&gt;. The coordinates are returned in a 2-D tensor where the first dimension (rows) represents the number of true elements, and the second dimension (columns) represents the coordinates of the true elements. Keep in mind, the shape of the output tensor can vary depending on how many true values there are in input. Indices are output in row-major order.</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 아무도없는,이 동작은 마찬가지 요소의 좌표를 반환 &lt;code&gt;condition&lt;/code&gt; . 좌표는 2 차원 텐서로 반환되며 여기서 첫 번째 차원 (행)은 실제 요소의 수를 나타내고 두 번째 차원 (열)은 실제 요소의 좌표를 나타냅니다. 출력 텐서의 모양은 입력에있는 실제 값의 수에 따라 다를 수 있습니다. 인덱스는 주요 행 순서로 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="4cc42a8c9ad46f8f728657a164104073727b3972" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are empty, this is trivially satisfied.</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 비어있는,이 하찮게 만족된다.</target>
        </trans-unit>
        <trans-unit id="7eb29e91b27b7529865331e0ce47bff962ea89f5" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;thresh&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;thresh&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;thresh == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">두 인수가 모두 드문 경우 다음과 같이 &quot;클리핑&quot;을 수행합니다. 기본적으로 일부 인덱스에서 두 값의 합이 0이면 출력 &lt;code&gt;SparseTensor&lt;/code&gt; 는 인덱스의 특정 위치를 계속 포함하여 해당 값 슬롯에 0을 저장합니다. 이를 무시하기 위해 호출자가 &lt;code&gt;thresh&lt;/code&gt; 를 지정할 수 있습니다. 이는 합계의 크기가 &lt;code&gt;thresh&lt;/code&gt; 보다 엄격하게 작 으면 해당 값과 색인이 포함되지 않음을 나타냅니다. 특히, &lt;code&gt;thresh == 0.0&lt;/code&gt; (기본값)은 모든 것이 유지되고 실제 임계 값은 양수 값에 대해서만 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="487e5ccf75b74d8c7372b9cbc5feed31632e6692" translate="yes" xml:space="preserve">
          <source>If both arguments are sparse, we perform &quot;clipping&quot; as follows. By default, if two values sum to zero at some index, the output &lt;code&gt;SparseTensor&lt;/code&gt; would still include that particular location in its index, storing a zero in the corresponding value slot. To override this, callers can specify &lt;code&gt;threshold&lt;/code&gt;, indicating that if the sum has a magnitude strictly smaller than &lt;code&gt;threshold&lt;/code&gt;, its corresponding value and index would then not be included. In particular, &lt;code&gt;threshold == 0.0&lt;/code&gt; (default) means everything is kept and actual thresholding happens only for a positive value.</source>
          <target state="translated">두 인수가 모두 드문 경우 다음과 같이 &quot;클리핑&quot;을 수행합니다. 기본적으로 일부 인덱스에서 두 값의 합이 0이면 출력 &lt;code&gt;SparseTensor&lt;/code&gt; 는 인덱스의 특정 위치를 계속 포함하여 해당 값 슬롯에 0을 저장합니다. 이를 무시하기 위해 호출자는 &lt;code&gt;threshold&lt;/code&gt; 을 지정할 수 있으며, 합계의 크기가 &lt;code&gt;threshold&lt;/code&gt; 보다 엄격하게 작 으면 해당 값과 색인이 포함되지 않음을 나타냅니다. 특히 &lt;code&gt;threshold == 0.0&lt;/code&gt; (기본값)은 모든 것이 유지되고 실제 임계 값은 양수 값에 대해서만 발생 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="2faa6168ffe9b5fd63bbf70e84a310f2b55cd9a8" translate="yes" xml:space="preserve">
          <source>If both checkpoint_dir and checkpoint_filename_with_path are set.</source>
          <target state="translated">checkpoint_dir 및 checkpoint_filename_with_path가 모두 설정된 경우.</target>
        </trans-unit>
        <trans-unit id="6c7781516620b3f8fffd28bff7dc8bb9d94e125f" translate="yes" xml:space="preserve">
          <source>If both classes and scores are set, they are interpreted as zipped, so each score corresponds to the class at the same index. Clients should not depend on the order of the entries.</source>
          <target state="translated">클래스와 점수가 모두 설정되면 압축 된 것으로 해석되므로 각 점수는 동일한 색인의 클래스에 해당합니다. 고객은 출품작의 순서에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="0d803087c359d71d2ff29aa729231f7ed5aaf6ec" translate="yes" xml:space="preserve">
          <source>If both conjugate_output and transpose_output are &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="translated">conjugate_output과 transpose_output이 모두 &lt;code&gt;true&lt;/code&gt; 이면 다음 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bd8cfec215c2c5f209ae8f622e020ddb585417b2" translate="yes" xml:space="preserve">
          <source>If both graph and graph_def are passed to the method.</source>
          <target state="translated">graph와 graph_def가 모두 메소드에 전달되는 경우.</target>
        </trans-unit>
        <trans-unit id="15f976dcd1cff06450253bab18a12e98d1d32310" translate="yes" xml:space="preserve">
          <source>If both keras_model and keras_model_path was given.</source>
          <target state="translated">keras_model 및 keras_model_path가 모두 제공된 경우.</target>
        </trans-unit>
        <trans-unit id="88070f92b57f1d5fc2c333131e1e62338c2c40cc" translate="yes" xml:space="preserve">
          <source>If both linear_feature_columns and dnn_features_columns are empty at the same time.</source>
          <target state="translated">linear_feature_columns와 dnn_features_columns가 동시에 비어있는 경우.</target>
        </trans-unit>
        <trans-unit id="ea8fd75dd7d2ee81283a96566ccce43e17dd69df" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;condition&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must be broadcastable to the same shape.</source>
          <target state="translated">None이 아닌 경우 &lt;code&gt;condition&lt;/code&gt; , &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 를 동일한 모양으로 브로드 캐스트 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="97e1ce433328491ec96b5d0ae14362cbabdcecfd" translate="yes" xml:space="preserve">
          <source>If both non-None, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. The &lt;code&gt;condition&lt;/code&gt; tensor must be a scalar if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are scalar. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are tensors of higher rank, then &lt;code&gt;condition&lt;/code&gt; must be either a vector with size matching the first dimension of &lt;code&gt;x&lt;/code&gt;, or must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">None이 아닌 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 모양은 동일해야합니다. &lt;code&gt;condition&lt;/code&gt; 텐서 경우 스칼라이어야 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 스칼라이다. 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 더 높은 랭크의 텐서는 다음 &lt;code&gt;condition&lt;/code&gt; 크기의 제 치수와 일치하는 벡터이어야 &lt;code&gt;x&lt;/code&gt; , 또는 동일한 형상 있어야 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88898c92dbb5ee5caa8215c3b9cf8b45aa7b86e0" translate="yes" xml:space="preserve">
          <source>If both predictions and labels are not 1-D vectors and have mismatched shapes, or if &lt;code&gt;weights&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; and its shape doesn't match &lt;code&gt;predictions&lt;/code&gt;.</source>
          <target state="translated">예측과 레이블이 모두 1 차원 벡터 가 아니고 모양이 일치하지 않거나 &lt;code&gt;weights&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아니고 모양이 &lt;code&gt;predictions&lt;/code&gt; 과 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="79506ecb295374cd6b889ab3864fa6e7c7d48486" translate="yes" xml:space="preserve">
          <source>If both session and graph_def are provided.</source>
          <target state="translated">session 및 graph_def가 모두 제공되는 경우.</target>
        </trans-unit>
        <trans-unit id="acbf49639653cdfa17021b7bac7ebfe7fd55ca8b" translate="yes" xml:space="preserve">
          <source>If both the global and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">글로벌 및 오퍼레이션 시드가 모두 설정된 경우 : 랜덤 시드를 판별하기 위해 두 시드가 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="56d176cd1c614313ea4d92304b5919bf83d47ec0" translate="yes" xml:space="preserve">
          <source>If both the graph-level and the operation seed are set: Both seeds are used in conjunction to determine the random sequence.</source>
          <target state="translated">그래프 수준과 연산 시드가 모두 설정된 경우 : 두 시드는 무작위 시퀀스를 결정하기 위해 함께 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83ab65bb9cb8ad8b0b3f23c16f12a6dd295a6353" translate="yes" xml:space="preserve">
          <source>If called inside a &lt;code&gt;with strategy.scope():&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;with strategy.scope():&lt;/code&gt; 내부에서 호출되는 경우 : .</target>
        </trans-unit>
        <trans-unit id="bf8c5f745f58975c02acd22d252d5ec6f5107427" translate="yes" xml:space="preserve">
          <source>If called on a non-persistent tape with eager execution enabled and without enabling experimental_use_pfor.</source>
          <target state="translated">eager 실행을 사용하고 experiment_use_pfor를 사용하지 않고 비 영구 테이프에서 호출하는 경우.</target>
        </trans-unit>
        <trans-unit id="3fd9e24f01558b732ceb8dcd58453b4958bdd228" translate="yes" xml:space="preserve">
          <source>If called when object wasn't created under a &lt;code&gt;TPUStrategy&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;TPUStrategy&lt;/code&gt; 에서 객체가 생성되지 않았을 때 호출되는 경우 .</target>
        </trans-unit>
        <trans-unit id="2542f71c3cc80904a8ebcec3d207ae388a4fa9d7" translate="yes" xml:space="preserve">
          <source>If called with a non-chief Supervisor.</source>
          <target state="translated">수석 감독관이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="574c82e941303e797d51c4233086b82a03679cdf" translate="yes" xml:space="preserve">
          <source>If called with eager execution</source>
          <target state="translated">간절한 실행으로 호출되면</target>
        </trans-unit>
        <trans-unit id="e9f2eb2150a17d9cd67925c75d8e7cc6f7f0cadd" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled and &lt;code&gt;loss&lt;/code&gt; is not callable.</source>
          <target state="translated">eager 실행이 활성화 된 상태에서 호출 되고 &lt;code&gt;loss&lt;/code&gt; 호출 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="28345bb392e0302d6098655db8680a1e02e1c3df" translate="yes" xml:space="preserve">
          <source>If called with eager execution enabled.</source>
          <target state="translated">즉시 실행이 활성화 된 상태로 호출 된 경우.</target>
        </trans-unit>
        <trans-unit id="6498421806c61d63dafdda8fc836f385f363c358" translate="yes" xml:space="preserve">
          <source>If called with eager mode enabled.</source>
          <target state="translated">eager 모드가 활성화 된 상태에서 호출되는 경우.</target>
        </trans-unit>
        <trans-unit id="2644de4a188b77bdf5d0da83c2c6d802937ca848" translate="yes" xml:space="preserve">
          <source>If called with partitioned variable regularization and eager execution is enabled.</source>
          <target state="translated">분할 된 변수 정규화로 호출하면 즉시 실행이 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="981bade383730db3cda301a6fb4a9c301167251d" translate="yes" xml:space="preserve">
          <source>If called with sparse = True and ragged = True.</source>
          <target state="translated">sparse = True 및 ragged = True로 호출되는 경우.</target>
        </trans-unit>
        <trans-unit id="93f9f6999464c58974327ddd22b42ad2da9c296b" translate="yes" xml:space="preserve">
          <source>If called with the callable and arguments omitted, will return a context object used like this::</source>
          <target state="translated">callable 및 arguments를 생략하고 호출하면 다음과 같은 컨텍스트 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0093e9bdc160ff2fd3f4220aa3b82009d3743553" translate="yes" xml:space="preserve">
          <source>If called without a default &lt;a href=&quot;../session&quot;&gt;&lt;code&gt;tf.compat.v1.Session&lt;/code&gt;&lt;/a&gt; registered.</source>
          <target state="translated">기본 &lt;a href=&quot;../session&quot;&gt; &lt;code&gt;tf.compat.v1.Session&lt;/code&gt; 을&lt;/a&gt; 등록 하지 않고 호출하는 경우 .</target>
        </trans-unit>
        <trans-unit id="09679b75631570067dfc643dc0450d3185c06a15" translate="yes" xml:space="preserve">
          <source>If checkpoint is True and no name was specified.</source>
          <target state="translated">체크 포인트가 True이고 이름이 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="6e4f6a9857dccfef8e796c3e4e86b7476649d934" translate="yes" xml:space="preserve">
          <source>If cmd is 'scope' or 'graph', returns GraphNodeProto proto. If cmd is 'op' or 'code', returns MultiGraphNodeProto proto. Side effect: stdout/file/timeline.json depending on options['output']</source>
          <target state="translated">cmd가 'scope'또는 'graph'이면 GraphNodeProto 프로토를 반환합니다. cmd가 'op'또는 'code'이면 MultiGraphNodeProto 프로토 타입을 리턴합니다. 부작용 : 옵션에 따른 stdout / file / timeline.json [ 'output']</target>
        </trans-unit>
        <trans-unit id="780a855c8f95a645f3f19d73eeb415bbf7a48612" translate="yes" xml:space="preserve">
          <source>If compression_type is invalid.</source>
          <target state="translated">compression_type이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="172afde33c387d0bea150ccbe8dc6cc41072ff66" translate="yes" xml:space="preserve">
          <source>If conjugate is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a.dtype&lt;/code&gt; is either &lt;code&gt;complex64&lt;/code&gt; or &lt;code&gt;complex128&lt;/code&gt; then the values of &lt;code&gt;a&lt;/code&gt; are conjugated and transposed.</source>
          <target state="translated">복합 인 경우 &lt;code&gt;True&lt;/code&gt; 과 &lt;code&gt;a.dtype&lt;/code&gt; 는 중입니다 &lt;code&gt;complex64&lt;/code&gt; 또는 &lt;code&gt;complex128&lt;/code&gt; 다음의 값 &lt;code&gt;a&lt;/code&gt; 결합하고 전치된다.</target>
        </trans-unit>
        <trans-unit id="fee45e4b7147e79f84915e1d51de6d4a4803e7d8" translate="yes" xml:space="preserve">
          <source>If conjugate_output is &lt;code&gt;true&lt;/code&gt;, returns:</source>
          <target state="translated">conjugate_output이 &lt;code&gt;true&lt;/code&gt; 이면 다음 을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0fba8fa85c76e287a1fe2de2a680888f41efe3fe" translate="yes" xml:space="preserve">
          <source>If data_format ='channels_first' 4D tensor with shape: &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">data_format = 'channels_first'모양이있는 4D 텐서 인 경우 : &lt;code&gt;(samples, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54b8064bacba3ba82e646ea2151170bb26cf1df6" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</source>
          <target state="translated">data_format = 'channels_first'모양이있는 5D 텐서 : &lt;code&gt;(samples, time, channels, rows, cols)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6846cfb3158e1bd91d37169c22b71a8ea3739620" translate="yes" xml:space="preserve">
          <source>If data_format='channels_first' 5D tensor with shape: &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</source>
          <target state="translated">data_format = 'channels_first'모양이있는 5D 텐서 인 경우 : &lt;code&gt;(samples, time, filters, output_row, output_col)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ac99ea61f4e7b17282390b961f6eda2ff80a416" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 4D tensor with shape: &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; where &lt;code&gt;o_row&lt;/code&gt; and &lt;code&gt;o_col&lt;/code&gt; depend on the shape of the filter and the padding</source>
          <target state="translated">data_format = 'channels_last'모양이 4D 텐서 인 경우 : &lt;code&gt;(samples, output_row, output_col, filters)&lt;/code&gt; 여기서 &lt;code&gt;o_row&lt;/code&gt; 및 &lt;code&gt;o_col&lt;/code&gt; 은 필터의 모양 과 패딩에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="75fa04bbee972fde32d36caa3e44ea33b4fe50fc" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</source>
          <target state="translated">data_format = 'channels_last'모양이있는 5D 텐서 인 경우 : &lt;code&gt;(samples, time, output_row, output_col, filters)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00479e6d45ac4e2661436ea4b5a406c2b0a2af7a" translate="yes" xml:space="preserve">
          <source>If data_format='channels_last' 5D tensor with shape: &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</source>
          <target state="translated">data_format = 'channels_last'모양이있는 5D 텐서 인 경우 : &lt;code&gt;(samples, time, rows, cols, channels)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6cc722ef0e9570f15a63451bd645878be8a8452" translate="yes" xml:space="preserve">
          <source>If delegate loading is used on unsupported platform.</source>
          <target state="translated">지원되지 않는 플랫폼에서 델리게이트 로딩이 사용되는 경우.</target>
        </trans-unit>
        <trans-unit id="d63165fe5adeb1fdb48dac5762016f67811f8889" translate="yes" xml:space="preserve">
          <source>If delete_old_dirs is true, attempts to delete recursively the dirname of each path in the input checkpoint_prefixes. This is useful when those paths are non user-facing temporary locations.</source>
          <target state="translated">delete_old_dirs가 true이면 입력 checkpoint_prefixes에서 각 경로의 dirname을 재귀 적으로 삭제하려고합니다. 이는 해당 경로가 사용자와 접하지 않는 임시 위치 일 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="160c1f322fbaf6f7ee50e6f699b208383b0194b4" translate="yes" xml:space="preserve">
          <source>If delimiter is not a string.</source>
          <target state="translated">구분자가 문자열이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="d715a83b67f7e7c89236f98ea91f6e13726547ae" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's &lt;code&gt;adapt()&lt;/code&gt; method on a data set, which will analyze the data set, determine the frequency of individual string values, and create a vocabulary from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="translated">원하는 경우 사용자는 데이터 세트 에서이 레이어의 &lt;code&gt;adapt()&lt;/code&gt; 메서드를 호출 하여 데이터 세트를 분석하고 개별 문자열 값의 빈도를 결정하며 여기에서 어휘를 생성 할 수 있습니다. 이 어휘는이 레이어의 구성 옵션에 따라 크기에 제한이 없거나 제한 될 수 있습니다. 입력에 최대 어휘 크기보다 더 많은 고유 값이있는 경우 가장 자주 사용되는 용어가 어휘를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="248964e67e0d3fce70856809b6338807ca585aa9" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual integer or string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="translated">원하는 경우 사용자는 데이터 세트에서이 레이어의 adapt () 메서드를 호출 할 수 있습니다. 이 레이어가 조정되면 데이터 세트를 분석하고 개별 정수 또는 문자열 값의 빈도를 결정하고 여기에서 '어휘'를 생성합니다. 이 어휘는이 레이어의 구성 옵션에 따라 크기에 제한이 없거나 제한 될 수 있습니다. 입력에 최대 어휘 크기보다 더 많은 고유 값이있는 경우 가장 자주 사용되는 용어가 어휘를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a21162df807938f113483d7bdf2b2cb1dc591185" translate="yes" xml:space="preserve">
          <source>If desired, the user can call this layer's adapt() method on a dataset. When this layer is adapted, it will analyze the dataset, determine the frequency of individual string values, and create a 'vocabulary' from them. This vocabulary can have unlimited size or be capped, depending on the configuration options for this layer; if there are more unique values in the input than the maximum vocabulary size, the most frequent terms will be used to create the vocabulary.</source>
          <target state="translated">원하는 경우 사용자는 데이터 세트에서이 레이어의 adapt () 메서드를 호출 할 수 있습니다. 이 레이어가 조정되면 데이터 세트를 분석하고 개별 문자열 값의 빈도를 결정하며 여기에서 '어휘'를 생성합니다. 이 어휘는이 레이어의 구성 옵션에 따라 크기에 제한이 없거나 제한 될 수 있습니다. 입력에 최대 어휘 크기보다 더 많은 고유 값이있는 경우 가장 자주 사용되는 용어가 어휘를 생성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ff536a283d0c5634c5bc5433d6ad8c509ee37ad0" translate="yes" xml:space="preserve">
          <source>If desired_samples is set, then the audio will be cropped or padded with zeroes to the requested length.</source>
          <target state="translated">desired_samples를 설정하면 오디오가 자르거나 요청 된 길이의 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="64e144d6092560a27e1887bcdaf10a00b30d267c" translate="yes" xml:space="preserve">
          <source>If device placements are logged.</source>
          <target state="translated">기기 게재 위치가 기록 된 경우</target>
        </trans-unit>
        <trans-unit id="697f21a90462730341e2696aa513a52a271ce192" translate="yes" xml:space="preserve">
          <source>If device scopes are not properly nested.</source>
          <target state="translated">장치 범위가 제대로 중첩되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="f9291d64f354b112d4b4f3e8e525fef7cb19907b" translate="yes" xml:space="preserve">
          <source>If device_fn is not &lt;code&gt;None&lt;/code&gt;, it overrides the default device function used in &lt;code&gt;Estimator&lt;/code&gt;. Otherwise the default one is used.</source>
          <target state="translated">device_fn이 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;Estimator&lt;/code&gt; 에 사용 된 기본 장치 기능을 재정의합니다 . 그렇지 않으면 기본 설정이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0b94e1ea2398bda06ea8694498f1fb19cf4f6efb" translate="yes" xml:space="preserve">
          <source>If dims cannot be converted to a list of dimensions.</source>
          <target state="translated">치수를 치수 목록으로 변환 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="f9b5d926c5ac01aa937713a473626aab510091b2" translate="yes" xml:space="preserve">
          <source>If dtype of &lt;code&gt;on_value&lt;/code&gt; and &lt;code&gt;off_value&lt;/code&gt; don't match one another</source>
          <target state="translated">&lt;code&gt;on_value&lt;/code&gt; 와 &lt;code&gt;off_value&lt;/code&gt; 의 dtype 이 서로 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="37752ac4840b02cfca9a8f3dd25a0b640ddd01e2" translate="yes" xml:space="preserve">
          <source>If dtype of either &lt;code&gt;on_value&lt;/code&gt; or &lt;code&gt;off_value&lt;/code&gt; don't match &lt;code&gt;dtype&lt;/code&gt;</source>
          <target state="translated">만약 하나의 DTYPE &lt;code&gt;on_value&lt;/code&gt; 또는 &lt;code&gt;off_value&lt;/code&gt; 이 일치하지 않는 &lt;code&gt;dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80dde0979dfeaa6bd587ee11a441e44988883279" translate="yes" xml:space="preserve">
          <source>If dtype of the input is &lt;code&gt;int32&lt;/code&gt; and dtype of the &lt;code&gt;clip_value_min&lt;/code&gt; or &lt;code&gt;clip_value_max&lt;/code&gt; is &lt;code&gt;float32&lt;/code&gt;</source>
          <target state="translated">입력의 dtype이 &lt;code&gt;int32&lt;/code&gt; 이고 &lt;code&gt;clip_value_min&lt;/code&gt; 또는 &lt;code&gt;clip_value_max&lt;/code&gt; 의 dtype 이 &lt;code&gt;float32&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="08188b171505f22eaa07320217d7cb0b3f94833f" translate="yes" xml:space="preserve">
          <source>If dtype of the input is not a floating point or complex type.</source>
          <target state="translated">입력의 dtype이 부동 소수점 또는 복합 유형이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="9657f3ec9bff2adddd273db7e164c0f58e7fc0f8" translate="yes" xml:space="preserve">
          <source>If each &lt;code&gt;op_jj&lt;/code&gt; on the diagonal has shape &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt;, then the combined operator has shape &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt;, where &lt;code&gt;broadcast_batch_shape&lt;/code&gt; is the mutual broadcast of &lt;code&gt;batch_shape_j&lt;/code&gt;, &lt;code&gt;j = 0, 1, ..., J&lt;/code&gt;, assuming the intermediate batch shapes broadcast. Even if the combined shape is well defined, the combined operator's methods may fail due to lack of broadcasting ability in the defining operators' methods.</source>
          <target state="translated">대각선의 각 &lt;code&gt;op_jj&lt;/code&gt; 모양이 &lt;code&gt;batch_shape_j + [M_j, M_j]&lt;/code&gt; 이면 결합 된 연산자의 모양은 &lt;code&gt;broadcast_batch_shape + [sum M_j, sum M_j]&lt;/code&gt; . 여기서 &lt;code&gt;broadcast_batch_shape&lt;/code&gt; 는 &lt;code&gt;batch_shape_j&lt;/code&gt; , &lt;code&gt;j = 0, 1, ..., J&lt;/code&gt; 의 상호 브로드 캐스트입니다 . , J , 중간 배치 모양이 방송된다고 가정합니다. 결합 된 형태가 잘 정의되어 있더라도 운영자의 방법을 정의하는 방송 능력이 부족하여 결합 된 운영자의 방법이 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f773f4a0b6ef385d8cc73446bd42bb5c0d9a3771" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled after creating/executing a TensorFlow graph, or if options provided conflict with a previous call to this function.</source>
          <target state="translated">TensorFlow 그래프를 생성 / 실행 한 후 즉시 실행이 활성화 된 경우 또는 제공된 옵션이이 함수에 대한 이전 호출과 충돌하는 경우.</target>
        </trans-unit>
        <trans-unit id="63c1f0445f129f396fc0b13399b1bb388306a7c1" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and a function is passed in.</source>
          <target state="translated">즉시 실행이 활성화되고 함수가 전달 된 경우.</target>
        </trans-unit>
        <trans-unit id="af2f83ce7126d01f3c06de26aa60b7f6ac61c0aa" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled and&lt;code&gt;var_list&lt;/code&gt; does not specify a list of variables to save.</source>
          <target state="translated">&lt;code&gt;var_list&lt;/code&gt; 실행이 활성화되고 var_list 가 저장할 변수 목록을 지정하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="94bfffa7113c3bf007ae681c0fa31393f368fdc2" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled ops created under this context manager will be added to the graph instead of executed eagerly.</source>
          <target state="translated">열성적인 실행이 활성화되면이 컨텍스트 관리자에서 생성 된 작업이 열성적으로 실행되는 대신 그래프에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="25e2032ce88f649e7ec61962dfe0f982a0afa762" translate="yes" xml:space="preserve">
          <source>If eager execution is enabled.</source>
          <target state="translated">즉시 실행이 활성화 된 경우.</target>
        </trans-unit>
        <trans-unit id="a0ee55d70583c3e11eb60bef5ef2ced62457c4e9" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;hypothesis&lt;/code&gt; or &lt;code&gt;truth&lt;/code&gt; are not a &lt;code&gt;SparseTensor&lt;/code&gt;.</source>
          <target state="translated">어느 경우 &lt;code&gt;hypothesis&lt;/code&gt; 또는 &lt;code&gt;truth&lt;/code&gt; 하지 않은 있습니다 &lt;code&gt;SparseTensor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="824be958493bfb410b4a85bc242595893b6d4fb4" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;steps&lt;/code&gt; or &lt;code&gt;max_steps &amp;lt;= 0&lt;/code&gt;.</source>
          <target state="translated">하나 만약 &lt;code&gt;steps&lt;/code&gt; 또는 &lt;code&gt;max_steps &amp;lt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b47b36b34d98e0679cc6c53cff08c20a7dcfe2cb" translate="yes" xml:space="preserve">
          <source>If either argument is not a &lt;code&gt;GraphDef&lt;/code&gt;.</source>
          <target state="translated">두 인수 중 하나가 &lt;code&gt;GraphDef&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="38b6ebdcf4ccf71906f53c9d13666a5c374b90ce" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true</source>
          <target state="translated">활성화 된 경우 다음 중 하나라도 참이면 CPU에 작업이 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="e670cc4a3f83ee25d0b6a6e5c98cd6a71ebb20d0" translate="yes" xml:space="preserve">
          <source>If enabled, an op will be placed on CPU if any of the following are true 1. there's no GPU implementation for the OP 2. no GPU devices are known or registered 3. need to co-locate with reftype input(s) which are from CPU</source>
          <target state="translated">활성화 된 경우 다음 중 하나에 해당하는 경우 op가 CPU에 배치됩니다. 1. OP에 대한 GPU 구현이 없습니다. 2. GPU 장치가 알려 지거나 등록되지 않았습니다. 3. 참조 유형 입력과 함께 배치해야합니다. CPU에서</target>
        </trans-unit>
        <trans-unit id="63b0a6125d1477cb280541ff0da2e678b55452fd" translate="yes" xml:space="preserve">
          <source>If examples is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">예가 &lt;code&gt;None&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="784a250668a12b694a60559c3d84175bc70e490e" translate="yes" xml:space="preserve">
          <source>If exit_without_error is true, the process will exit normally, otherwise it will exit with a SIGABORT signal.</source>
          <target state="translated">exit_without_error가 참이면 프로세스가 정상적으로 종료되고 그렇지 않으면 SIGABORT 신호와 함께 종료됩니다.</target>
        </trans-unit>
        <trans-unit id="cb053d1301598dac02cff078c183716e72ed8191" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, all inputs' shapes must match, except for the concat dimension. If expand_nonconcat_dim is True, then inputs' shapes are allowed to vary among all inputs.</source>
          <target state="translated">expand_nonconcat_dim이 False이면 concat 차원을 제외하고 모든 입력 모양이 일치해야합니다. expand_nonconcat_dim이 True이면 입력의 모양이 모든 입력에 따라 달라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae461a693ecc478ea610fcc38768106721e2c8f" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is False, then the output shape is identical to the inputs', except along the concat dimension, where it is the sum of the inputs' sizes along that dimension.</source>
          <target state="translated">expand_nonconcat_dim이 False이면 출력 치수는 해당 치수를 따라 입력 크기의 합인 concat 치수를 제외하고 입력과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b6cd7aa57520c6214227753ed1c290366a7b241e" translate="yes" xml:space="preserve">
          <source>If expand_nonconcat_dim is True, then the output shape along the non-concat dimensions will be expand to be the largest among all inputs, and it is the sum of the inputs sizes along the concat dimension.</source>
          <target state="translated">expand_nonconcat_dim이 True 인 경우 비 연속 치수를 따라 출력 모양이 모든 입력 중에서 가장 크게 확장되며 이는 연쇄 치수를 따라 입력 크기의 합입니다.</target>
        </trans-unit>
        <trans-unit id="12864773eaab4c0d7f585b96ba78a0e95386a506" translate="yes" xml:space="preserve">
          <source>If false, the output nmsed boxes, scores and classes are padded/clipped to &lt;code&gt;max_total_size&lt;/code&gt;. If true, the output nmsed boxes, scores and classes are padded to be of length &lt;code&gt;max_size_per_class&lt;/code&gt;*&lt;code&gt;num_classes&lt;/code&gt;, unless it exceeds &lt;code&gt;max_total_size&lt;/code&gt; in which case it is clipped to &lt;code&gt;max_total_size&lt;/code&gt;. Defaults to false.</source>
          <target state="translated">false이면 출력 nmsed 상자, 점수 및 클래스가 &lt;code&gt;max_total_size&lt;/code&gt; 로 패딩 / 클리핑됩니다 . 참이면, 출력 nmsed 박스 점수 및 클래스 길이 될 패딩이다 &lt;code&gt;max_size_per_class&lt;/code&gt; * &lt;code&gt;num_classes&lt;/code&gt; 가 초과되지 않는 한, &lt;code&gt;max_total_size&lt;/code&gt; 가 잘린되는 경우 &lt;code&gt;max_total_size&lt;/code&gt; 를 . 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="29536533b7425b7b6f6f46b7c0caaaf741547425" translate="yes" xml:space="preserve">
          <source>If gamma is negative.</source>
          <target state="translated">감마가 음수이면.</target>
        </trans-unit>
        <trans-unit id="48bc65a965bdec97a72d64adbdbd2e91ae8af762" translate="yes" xml:space="preserve">
          <source>If given, ensures the output has length at least &lt;code&gt;minlength&lt;/code&gt;, padding with zeros at the end if necessary.</source>
          <target state="translated">주어진 경우 출력의 길이가 &lt;code&gt;minlength&lt;/code&gt; 이상 인지 확인하고 필요한 경우 끝에 0으로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="850346f60197b83bee288e72b70f6de3db5f0a8d" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;arr&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="translated">주어진 경우, &lt;code&gt;maxlength&lt;/code&gt; 보다 크거나 같은 &lt;code&gt;arr&lt;/code&gt; 값을 건너 뛰어 출력의 길이가 &lt;code&gt;maxlength&lt;/code&gt; 이하인지 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="b1bedce8da3ba8708a050eca4c25f36172efb8c8" translate="yes" xml:space="preserve">
          <source>If given, skips values in &lt;code&gt;values&lt;/code&gt; that are equal or greater than &lt;code&gt;maxlength&lt;/code&gt;, ensuring that the output has length at most &lt;code&gt;maxlength&lt;/code&gt;.</source>
          <target state="translated">주어진 경우 &lt;code&gt;maxlength&lt;/code&gt; 보다 크거나 같은 값의 &lt;code&gt;values&lt;/code&gt; 을 건너 뛰어 출력의 길이가 최대 &lt;code&gt;maxlength&lt;/code&gt; 임을 확인 합니다.</target>
        </trans-unit>
        <trans-unit id="904f78c9c6ff546dab3b5725280de3f83affea10" translate="yes" xml:space="preserve">
          <source>If global step is not provided, the staleness cannot be checked.</source>
          <target state="translated">글로벌 단계가 제공되지 않으면 부실 상태를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="684b25bfd8962e05d99fb3f7f04a26800350f93f" translate="yes" xml:space="preserve">
          <source>If grad is of the wrong shape</source>
          <target state="translated">졸업생의 모양이 잘못된 경우</target>
        </trans-unit>
        <trans-unit id="2b342725a93b6c1c8e4b3915db7e2e97ff7ab962" translate="yes" xml:space="preserve">
          <source>If greater than 0 then smooth the labels.</source>
          <target state="translated">0보다 크면 레이블을 다듬습니다.</target>
        </trans-unit>
        <trans-unit id="52f5a4e3f1411b344474e9d7a8bc5d911b5175d8" translate="yes" xml:space="preserve">
          <source>If greater than &lt;code&gt;0&lt;/code&gt; then smooth the labels.</source>
          <target state="translated">&lt;code&gt;0&lt;/code&gt; 보다 크면 레이블을 다듬습니다.</target>
        </trans-unit>
        <trans-unit id="b2ad5583d7bf74d16da967efa8cbb84ea5b0c957" translate="yes" xml:space="preserve">
          <source>If h5py is not available and the weight file is in HDF5 format.</source>
          <target state="translated">h5py를 사용할 수없고 가중치 파일이 HDF5 형식 인 경우.</target>
        </trans-unit>
        <trans-unit id="14ea4430736129715f7271fcff39b30fa4c0d755" translate="yes" xml:space="preserve">
          <source>If h5py is not available when attempting to save in HDF5 format.</source>
          <target state="translated">HDF5 형식으로 저장하려고 할 때 h5py를 사용할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="f095b725e0a83d6762ff132445f344e05020f422" translate="yes" xml:space="preserve">
          <source>If hints are set incorrectly.</source>
          <target state="translated">힌트가 잘못 설정된 경우.</target>
        </trans-unit>
        <trans-unit id="f5fdf8a3fd0e485a281ac125b001fbd1f55d1ac7" translate="yes" xml:space="preserve">
          <source>If histogram_freq is set and no validation data is provided.</source>
          <target state="translated">histogram_freq가 설정되고 검증 데이터가 제공되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="5b6cab13cfa666ca9015cb19f120bb30a762f9b4" translate="yes" xml:space="preserve">
          <source>If initializer is &lt;code&gt;None&lt;/code&gt; (the default), the default initializer passed in the variable scope will be used. If that one is &lt;code&gt;None&lt;/code&gt; too, a &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; will be used. The initializer can also be a Tensor, in which case the variable is initialized to this value and shape.</source>
          <target state="translated">이니셜 라이저가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 변수 범위에 전달 된 기본 이니셜 라이저가 사용됩니다. 그 중 하나가 없으면 &lt;code&gt;None&lt;/code&gt; , 너무 &lt;code&gt;glorot_uniform_initializer&lt;/code&gt; 이 사용됩니다. 이니셜 라이저는 텐서 일 수도 있으며,이 경우 변수는이 값과 모양으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="10990b204b37f5fa91dbe2ef30fcaf924248b00a" translate="yes" xml:space="preserve">
          <source>If input is not a &lt;a href=&quot;../dataset&quot;&gt;&lt;code&gt;tf.data.Dataset&lt;/code&gt;&lt;/a&gt; or an &lt;a href=&quot;../iterator&quot;&gt;&lt;code&gt;tf.data.Iterator&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">입력이 &lt;a href=&quot;../dataset&quot;&gt; &lt;code&gt;tf.data.Dataset&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../iterator&quot;&gt; &lt;code&gt;tf.data.Iterator&lt;/code&gt; &lt;/a&gt; 객체 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="2c9612495d1ea687b814d88c5bccfce311dbb1b1" translate="yes" xml:space="preserve">
          <source>If input value shapes have rank-&lt;code&gt;R&lt;/code&gt;, then the output TensorArray will contain elements whose shapes are rank-&lt;code&gt;(R-1)&lt;/code&gt;.</source>
          <target state="translated">입력 값 모양의 순위가 &lt;code&gt;R&lt;/code&gt; 인 경우 출력 TensorArray에는 모양의 순위가 &lt;code&gt;(R-1)&lt;/code&gt; 인 요소가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="45c77beb165c1701c210a5bf5acb9740e347fcd8" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filter&lt;/code&gt; 모양 과 일치하지 않는 경우, 패딩이 &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;SAME&quot;&lt;/code&gt; 이외의 경우 또는 data_format이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="b752dfc0612478ea8d685cf1e617bd3c1d83ebd2" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, if &lt;code&gt;output_shape&lt;/code&gt; is not at 3-element vector, if &lt;code&gt;padding&lt;/code&gt; is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if &lt;code&gt;data_format&lt;/code&gt; is invalid.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filter&lt;/code&gt; 의 모양 과 일치하지 않는 경우, &lt;code&gt;output_shape&lt;/code&gt; 가 요소를 3 개 가진 벡터가 아닌 경우, &lt;code&gt;padding&lt;/code&gt; 이 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; 이외 의 경우 또는 &lt;code&gt;data_format&lt;/code&gt; 이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="a8d7f5300b03eeb800fd6998605d11f0f2eae57d" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filter&lt;/code&gt;'s shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filter&lt;/code&gt; 의 모양 과 일치하지 않거나 패딩이 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; 이외 의 경우 .</target>
        </trans-unit>
        <trans-unit id="6d6cae4ac7f38121f981199147df481f96e3c52a" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt; shape, if padding is other than &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; or &lt;code&gt;&quot;SAME&quot;&lt;/code&gt;, or if data_format is invalid.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filters&lt;/code&gt; 모양 과 일치하지 않는 경우, 패딩이 &lt;code&gt;&quot;VALID&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;SAME&quot;&lt;/code&gt; 이외의 경우 또는 data_format이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="7238a8127bc3b5b9a1ee3eb0627ccf770c4ae056" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;, or if the &lt;code&gt;rate&lt;/code&gt; is less than one, or if the output_shape is not a tensor with 4 elements.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filters&lt;/code&gt; 'shape 와 일치하지 않거나 패딩이 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; 이외의 경우 또는 &lt;code&gt;rate&lt;/code&gt; 이 1 미만이거나 output_shape가 4 개 요소가있는 텐서가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="dd231bf9fdacb69a5963dd5fc07c998be7bf172c" translate="yes" xml:space="preserve">
          <source>If input/output depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="translated">입력 / 출력 깊이가 &lt;code&gt;filters&lt;/code&gt; 의 모양 과 일치하지 않거나 패딩이 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; 이외 의 경우 .</target>
        </trans-unit>
        <trans-unit id="9bab3017e220504110ded7561dc6180055162263" translate="yes" xml:space="preserve">
          <source>If input_signature contains a non-TensorSpec object.</source>
          <target state="translated">input_signature에 비 TensorSpec 객체가 포함 된 경우.</target>
        </trans-unit>
        <trans-unit id="c386ea372433836d4288cf5ce90403d9aebc9525" translate="yes" xml:space="preserve">
          <source>If input_tensor is &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt;, the lookup result is &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt;.</source>
          <target state="translated">input_tensor가 &lt;code&gt;[&quot;emerson&quot;, &quot;lake&quot;, &quot;palmer&quot;, &quot;king&quot;, &quot;crimson&quot;]&lt;/code&gt; 인 경우 조회 결과는 &lt;code&gt;[0, 1, 2, 4, 7]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2ce072ba553bd0ced40a36046cee33cd2be18df" translate="yes" xml:space="preserve">
          <source>If inputs are invalid types, or if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have different types.</source>
          <target state="translated">입력이 유효하지 않은 유형이거나 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 다른 유형을 갖는 경우 .</target>
        </trans-unit>
        <trans-unit id="937342562c6c12fe45a02ebc5e107d2f78b33211" translate="yes" xml:space="preserve">
          <source>If inputs are not tensors, they will be converted to tensors. See &lt;a href=&quot;../convert_to_tensor&quot;&gt;&lt;code&gt;tf.convert_to_tensor&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력이 텐서가 아닌 경우 텐서로 변환됩니다. &lt;a href=&quot;../convert_to_tensor&quot;&gt; &lt;code&gt;tf.convert_to_tensor&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3cb57fcb38985bdb74f964ec67623f1bd14e689" translate="yes" xml:space="preserve">
          <source>If inputs are shaped &lt;code&gt;(batch,)&lt;/code&gt; without a channel dimension, then flattening adds an extra channel dimension and output shapes are &lt;code&gt;(batch, 1)&lt;/code&gt;.</source>
          <target state="translated">입력에 채널 치수가없는 형태 &lt;code&gt;(batch,)&lt;/code&gt; 가있는 경우 병합하면 채널 치수가 추가되고 출력 형태는 &lt;code&gt;(batch, 1)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="bf2f55ccc279229fe129dedb78a6ad7fa6f4a7cc" translate="yes" xml:space="preserve">
          <source>If inputs is None or an empty list.</source>
          <target state="translated">입력이 없음 또는 빈 목록 인 경우.</target>
        </trans-unit>
        <trans-unit id="e14a37bc1250ce29bfed6cf06b06706687540d99" translate="yes" xml:space="preserve">
          <source>If inputs or outputs is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">입력 또는 출력이 &lt;code&gt;None&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="738230ba7fe766eb31fbdde5eb405514647a0533" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;operator&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 의 모양이 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 및 &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; 경우 모든 연산의 복잡성이 &lt;code&gt;B1*...*Bb&lt;/code&gt; 만큼 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="f96eb77ff2ebfe9cc28cc3c35cc4a7ac58b190bc" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;operator&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; have shape &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; and &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt;, every operation increases in complexity by &lt;code&gt;B1*...*Bb&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;operator&lt;/code&gt; 와 &lt;code&gt;x&lt;/code&gt; 의 모양이 &lt;code&gt;[B1,...,Bb, N, N]&lt;/code&gt; 및 &lt;code&gt;[B1,...,Bb, N, R]&lt;/code&gt; 경우 모든 연산의 복잡성이 &lt;code&gt;B1*...*Bb&lt;/code&gt; 만큼 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="8c63a6d67533a63bed1e0240ed43f76ae36414b8" translate="yes" xml:space="preserve">
          <source>If instead a &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; with &lt;code&gt;default_value = -1.0&lt;/code&gt; and &lt;code&gt;shape=[]&lt;/code&gt; is used then the output will look like:</source>
          <target state="translated">만일 대신 &lt;code&gt;FixedLenSequenceFeature&lt;/code&gt; 와 &lt;code&gt;default_value = -1.0&lt;/code&gt; 및 &lt;code&gt;shape=[]&lt;/code&gt; 출력 모양을 한 후 사용된다 :</target>
        </trans-unit>
        <trans-unit id="40adf7e5387b8489f0ffa9f4f324e8e0ce220b98" translate="yes" xml:space="preserve">
          <source>If int: How many zeros to add at the beginning and end of the padding dimension (axis 1).</source>
          <target state="translated">int : 패딩 차원의 시작과 끝에 추가 할 영 (0) 수 (축 1)</target>
        </trans-unit>
        <trans-unit id="c440d21ae6487ba9289b79947d47d6f17645dab0" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to depth, height, and width.</source>
          <target state="translated">int 인 경우 : 동일한 대칭 자르기가 깊이, 높이 및 너비에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="0ad0224bfc863947c553eb515cd3685802c8418c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric cropping is applied to height and width.</source>
          <target state="translated">int 인 경우 : 동일한 대칭 자르기가 높이와 너비에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="4438a656974fdeb329935741ed684baf3991a64c" translate="yes" xml:space="preserve">
          <source>If int: the same symmetric padding is applied to height and width.</source>
          <target state="translated">int : 높이와 너비에 동일한 대칭 패딩이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="35116c98450f720c42b3658d1258e91546d16954" translate="yes" xml:space="preserve">
          <source>If internal = False. Note that this method is intended only for internal use.</source>
          <target state="translated">내부 = False 인 경우. 이 방법은 내부 용으로 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15715c466e373aacdb51a0877bb847b6ca4afb0b" translate="yes" xml:space="preserve">
          <source>If it encounters an error (e.g. session is in an invalid state, or network errors occur).</source>
          <target state="translated">오류가 발생하는 경우 (예 : 세션이 잘못된 상태이거나 네트워크 오류가 발생하는 경우).</target>
        </trans-unit>
        <trans-unit id="b5e13d5017f46659d268ce30f514bf0071b12303" translate="yes" xml:space="preserve">
          <source>If it is None, all &lt;code&gt;device()&lt;/code&gt; invocations from the enclosing context will be ignored.</source>
          <target state="translated">None 인 경우 , 엔 클로징 컨텍스트에서 모든 &lt;code&gt;device()&lt;/code&gt; 호출이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ef96e811e54b2027efeda53b92e404a485dc4193" translate="yes" xml:space="preserve">
          <source>If it is None, unnormalized dct4 is used, if it is &quot;ortho&quot; orthonormal dct4 is used.</source>
          <target state="translated">None이면 정규화되지 않은 dct4가 사용되고, &quot;ortho&quot;이면 orthonormal dct4가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfc30b45f6aa3b5c14c0ae463c80d1818d9e01fe" translate="yes" xml:space="preserve">
          <source>If it is a device name string, all operations constructed in this context will be assigned to the device with that name, unless overridden by a nested &lt;code&gt;device()&lt;/code&gt; context.</source>
          <target state="translated">장치 이름 문자열 인 경우 중첩 된 &lt;code&gt;device()&lt;/code&gt; 컨텍스트로 재정의되지 않는 한이 컨텍스트에서 생성 된 모든 작업이 해당 이름으로 장치에 할당됩니다 .</target>
        </trans-unit>
        <trans-unit id="c5baf9468ce1d581b9eebf008c02586f0513f4b8" translate="yes" xml:space="preserve">
          <source>If it is a function, it will be treated as a function from Operation objects to device name strings, and invoked each time a new Operation is created. The Operation will be assigned to the device with the returned name.</source>
          <target state="translated">함수 인 경우 Operation 객체에서 장치 이름 문자열에 이르는 함수로 처리되며 새 Operation이 생성 될 때마다 호출됩니다. 반환 된 이름으로 장치에 작업이 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="029d0ac515384df1e368e1e371b6232459f15b2e" translate="yes" xml:space="preserve">
          <source>If iterator does not support checkpointing.</source>
          <target state="translated">반복기가 체크 포인트를 지원하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="60e9423338b763ecced828cd53d616bb10a88e52" translate="yes" xml:space="preserve">
          <source>If keras_model has not been compiled.</source>
          <target state="translated">keras_model이 컴파일되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="db73d9b90027e216149b4b949806b1ee26b98dcf" translate="yes" xml:space="preserve">
          <source>If known at graph construction time, filename used for variable loading/saving.</source>
          <target state="translated">그래프 생성시 알려진 경우 변수로드 / 저장에 사용되는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6771f2297bd8cb07650783afbbc78e61937b9a06" translate="yes" xml:space="preserve">
          <source>If label is used in &lt;code&gt;feature_columns&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;feature_columns&lt;/code&gt; 에서 레이블이 사용되는 경우 .</target>
        </trans-unit>
        <trans-unit id="9c7710d3f3b7456252ed02c1f1e66d4f4bf4c6ac" translate="yes" xml:space="preserve">
          <source>If label_key argument is provided, returns a &lt;code&gt;Dataset&lt;/code&gt; of tuple comprising of feature dictionaries and label.</source>
          <target state="translated">label_key 인수가 제공되면 기능 사전 및 레이블로 구성된 튜플 의 &lt;code&gt;Dataset&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="7de987675ff17795ab301bc41d5b2434a203cd40" translate="yes" xml:space="preserve">
          <source>If last_checkpoints is not a list.</source>
          <target state="translated">last_checkpoints가 목록이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="13779508c02ec978c697bbe57313fdf67fe0477e" translate="yes" xml:space="preserve">
          <source>If last_checkpoints_with_time is not a list.</source>
          <target state="translated">last_checkpoints_with_time이 목록이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="3dcc6e856bdd1179e8069f1fe13fd542e0500b2a" translate="yes" xml:space="preserve">
          <source>If len(input_shard_axes) != len(inputs)</source>
          <target state="translated">만약 len (input_shard_axes)! = len (inputs)</target>
        </trans-unit>
        <trans-unit id="2fb334df24c9579c81c1988b3200bbe9b7befd52" translate="yes" xml:space="preserve">
          <source>If len(output_shard_axes) != len(outputs from &lt;code&gt;computation&lt;/code&gt;)</source>
          <target state="translated">len (output_shard_axes)! = len ( &lt;code&gt;computation&lt;/code&gt; 에서 출력 )</target>
        </trans-unit>
        <trans-unit id="dc09e06652849b4243e73d3cebb00ac8c8528b69" translate="yes" xml:space="preserve">
          <source>If logits are scalars (need to have rank &amp;gt;= 1) or if the rank of the labels is not equal to the rank of the logits minus one.</source>
          <target state="translated">로짓이 스칼라 인 경우 (순위가 1보다 커야 함) 또는 레이블의 순위가 로짓의 순위에서 1을 뺀 값과 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="74a9c00e10f0a30b035b3972813d0c5d1001a05f" translate="yes" xml:space="preserve">
          <source>If loss_scale_value is less than 1.</source>
          <target state="translated">loss_scale_value가 1보다 작은 경우</target>
        </trans-unit>
        <trans-unit id="c424513363e598474e7006a1b25045c0bfee1b11" translate="yes" xml:space="preserve">
          <source>If lower_bound or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">lower_bound 또는 upper_bound가 설정된 경우이 플래그는 지정된 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c86764cba8090e4b738e2dccdd96c8da3f0010d" translate="yes" xml:space="preserve">
          <source>If lower_bound, or upper_bound are set, then this flag must be within the given range.</source>
          <target state="translated">lower_bound 또는 upper_bound가 설정된 경우이 플래그는 지정된 범위 내에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="b744a1d7c3b92dd76e179f6bd1b1ff66d763286f" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device.</source>
          <target state="translated">&lt;code&gt;PhysicalDevice&lt;/code&gt; 에 대해 메모리 증가가 사용 가능한 경우 런타임 초기화가 디바이스에 모든 메모리를 할당하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd3fe4729c6c6665ba5d979840f51083f4d41d85" translate="yes" xml:space="preserve">
          <source>If memory growth is enabled for a &lt;code&gt;PhysicalDevice&lt;/code&gt;, the runtime initialization will not allocate all memory on the device. Memory growth cannot be configured on a &lt;code&gt;PhysicalDevice&lt;/code&gt; with virtual devices configured.</source>
          <target state="translated">&lt;code&gt;PhysicalDevice&lt;/code&gt; 에 대해 메모리 증가가 사용 가능한 경우 런타임 초기화가 디바이스에 모든 메모리를 할당하지는 않습니다. 가상 장치가 구성된 &lt;code&gt;PhysicalDevice&lt;/code&gt; 장치 에서는 메모리 증가를 구성 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="a6d0cbfe8725ceb18dabe8bbc056a3473d718190" translate="yes" xml:space="preserve">
          <source>If missing variables in current graph, or if missing checkpoints or tensors in checkpoints.</source>
          <target state="translated">현재 그래프에서 변수가 누락되었거나 체크 포인트에서 체크 포인트 또는 텐서가 누락 된 경우.</target>
        </trans-unit>
        <trans-unit id="fefb38872b3b0a9ef3e5c04bb1786c3ce57d227f" translate="yes" xml:space="preserve">
          <source>If more than one such registered method exists, the method whose registered classes have the shortest sum MRO paths to the input types is used.</source>
          <target state="translated">그러한 등록 된 메소드가 둘 이상 존재하는 경우, 등록 된 클래스가 입력 유형에 대한 가장 짧은 합계 MRO 경로를 갖는 메소드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ae06d56729266c936751b0d6b4a49cea1d77595" translate="yes" xml:space="preserve">
          <source>If more than one such shortest path exists, the first method identified in the search is used (favoring a shorter MRO distance to &lt;code&gt;type(distribution_a)&lt;/code&gt;).</source>
          <target state="translated">이러한 최단 경로가 둘 이상 존재하는 경우 검색에서 식별 된 첫 번째 방법이 사용됩니다 ( &lt;code&gt;type(distribution_a)&lt;/code&gt; 대한 짧은 MRO 거리 선호 ).</target>
        </trans-unit>
        <trans-unit id="722f663586a3c2fd0a85e136dad3e99bf4d7d908" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;feature_columns&lt;/code&gt; are given with &lt;code&gt;Di&lt;/code&gt;&lt;code&gt;num_elements&lt;/code&gt; each, their outputs are concatenated. So, the final &lt;code&gt;Tensor&lt;/code&gt; has shape &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt;.</source>
          <target state="translated">여러 개의 &lt;code&gt;feature_columns&lt;/code&gt; 에 &lt;code&gt;Di&lt;/code&gt; &lt;code&gt;num_elements&lt;/code&gt; 가 각각 제공되면 해당 출력이 연결됩니다. 따라서 최종 &lt;code&gt;Tensor&lt;/code&gt; 모양은 &lt;code&gt;[batch_size, T, D0 + D1 + ... + Dn]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="03c107a7651f56240affd9bf4b6bd3d81744ad9c" translate="yes" xml:space="preserve">
          <source>If multiple workers or threads all execute &lt;code&gt;count&lt;/code&gt; in parallel, there is no guarantee that access to the variable &lt;code&gt;v&lt;/code&gt; is atomic at any point within any thread's calculation of &lt;code&gt;count&lt;/code&gt;. In fact, even implementing an atomic counter that guarantees that the user will see each value &lt;code&gt;0, 1, ...,&lt;/code&gt; is currently impossible.</source>
          <target state="translated">여러 작업자 또는 스레드가 모두 병렬로 &lt;code&gt;count&lt;/code&gt; 를 실행 하는 경우 스레드의 &lt;code&gt;count&lt;/code&gt; 계산 내에서 변수 &lt;code&gt;v&lt;/code&gt; 에 대한 액세스 가 원자 적이라는 보장은 없습니다 . 실제로, 사용자가 각 값 &lt;code&gt;0, 1, ...,&lt;/code&gt; 볼 수 있도록 보장하는 원자 카운터를 구현하는 것조차 현재 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="9739a5fb4739612d4146a5dc1689746a7ba63d4e" translate="yes" xml:space="preserve">
          <source>If name is malformed.</source>
          <target state="translated">이름이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="aef6af9a98489f657ca168be41baf35e4d8bb8b1" translate="yes" xml:space="preserve">
          <source>If name is not a string.</source>
          <target state="translated">이름이 문자열이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="67481c8ed92bcb02951bb04ea04056c1ee8ecbc1" translate="yes" xml:space="preserve">
          <source>If needed, the JPEG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">필요한 경우 JPEG 인코딩 이미지는 요청 된 색상 채널 수에 맞게 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="675d725df0fc2c1253c204b76da4504e0b572994" translate="yes" xml:space="preserve">
          <source>If needed, the PNG-encoded image is transformed to match the requested number of color channels.</source>
          <target state="translated">필요한 경우 PNG로 인코딩 된 이미지가 요청 된 색상 채널 수와 일치하도록 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="024d81b6c90a954567799332b341be59c768b8e4" translate="yes" xml:space="preserve">
          <source>If neither keras_model nor keras_model_path was given.</source>
          <target state="translated">keras_model도 keras_model_path도 제공되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="4a4a46df302381b3a15b3175bfe7b5ee7e4f7f3c" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set, we get different results for every call to the random op and every re-run of the program:</source>
          <target state="translated">전역 시드 나 작업 시드가 설정되지 않은 경우 임의 op에 대한 모든 호출과 프로그램의 모든 다시 실행에 대해 다른 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a80f90092a9cdc14926ec279ccf684a91409808f" translate="yes" xml:space="preserve">
          <source>If neither the global seed nor the operation seed is set: A randomly picked seed is used for this op.</source>
          <target state="translated">글로벌 시드 나 작업 시드가 설정되지 않은 경우 : 임의로 선택된 시드가이 op에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="eb376915a9049b9705726662829e324ea799d8d9" translate="yes" xml:space="preserve">
          <source>If neither the graph-level nor the operation seed is set: A random seed is used for this op.</source>
          <target state="translated">그래프 수준과 연산 시드가 설정되지 않은 경우 :이 연산에는 임의의 시드가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="53a2b49f6fe46128f61f59f18f91203c8cae5da5" translate="yes" xml:space="preserve">
          <source>If nest is not a sequence, tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="translated">nest가 시퀀스, 튜플 (또는 명명 된 튜플), dict 또는 attrs 클래스가 아닌 경우 단일 요소 목록 인 [nest]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6e5c490bd2e442ff07025163116fecd6250620d3" translate="yes" xml:space="preserve">
          <source>If nest is not a structure , tuple (or a namedtuple), dict, or an attrs class, then returns a single-element list: [nest].</source>
          <target state="translated">nest가 구조체, 튜플 (또는 명명 된 튜플), dict 또는 attrs 클래스가 아닌 경우 단일 요소 목록 인 [nest]를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f8fa99a78720209af5fdde779900c0982d9d43c7" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;graph&lt;/code&gt; argument is specified when constructing the session, the default graph will be launched in the session. If you are using more than one graph (created with &lt;a href=&quot;../../graph&quot;&gt;&lt;code&gt;tf.Graph()&lt;/code&gt;&lt;/a&gt;) in the same process, you will have to use different sessions for each graph, but each graph can be used in multiple sessions. In this case, it is often clearer to pass the graph to be launched explicitly to the session constructor.</source>
          <target state="translated">세션을 구성 할 때 &lt;code&gt;graph&lt;/code&gt; 인수를 지정 하지 않으면 세션에서 기본 그래프가 시작됩니다. 동일한 프로세스에서 둘 이상의 그래프 ( &lt;a href=&quot;../../graph&quot;&gt; &lt;code&gt;tf.Graph()&lt;/code&gt; &lt;/a&gt; 생성 ) 를 사용하는 경우 각 그래프마다 다른 세션을 사용해야하지만 각 그래프는 여러 세션에서 사용될 수 있습니다. 이 경우 그래프를 명시 적으로 시작하여 세션 생성자에게 전달하는 것이 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="e03528b8eed8bab907807380295710ea8ffbc199" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;initializer&lt;/code&gt; is provided, the output structure and dtypes of &lt;code&gt;fn&lt;/code&gt; are assumed to be the same as its input; and in this case, the first argument of &lt;code&gt;fn&lt;/code&gt; must match the structure of &lt;code&gt;elems&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;initializer&lt;/code&gt; 가 제공 되지 않으면 출력 구조와 &lt;code&gt;fn&lt;/code&gt; 의 dtype은 입력과 동일하다고 가정합니다. 이 경우 &lt;code&gt;fn&lt;/code&gt; 의 첫 번째 인수 는 &lt;code&gt;elems&lt;/code&gt; 의 구조와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ddf22c89a9b612e91a4b8184e53a33000a173de" translate="yes" xml:space="preserve">
          <source>If no KL method is defined for distribution types of &lt;code&gt;distribution_a&lt;/code&gt; and &lt;code&gt;distribution_b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distribution_a&lt;/code&gt; 및 &lt;code&gt;distribution_b&lt;/code&gt; 배포 유형에 대해 KL 방법이 정의되지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="035ae05d5610deba6220ec987dcb29d297b9b3f8" translate="yes" xml:space="preserve">
          <source>If no TPU devices found for eager execution or if run in a tf.function.</source>
          <target state="translated">즉시 실행을위한 TPU 기기가 없거나 tf.function에서 실행되는 경우</target>
        </trans-unit>
        <trans-unit id="7e28ee02c99929146a3bc75c017bc3b5e90a8d33" translate="yes" xml:space="preserve">
          <source>If no TPU devices found in eager mode.</source>
          <target state="translated">eager 모드에서 TPU 기기를 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="68b01a5baff506f77205b70c8cfa23729c5d8d96" translate="yes" xml:space="preserve">
          <source>If no TPUs are specified.</source>
          <target state="translated">TPU가 지정되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="65c93d808857c17377358a34f196f771ace213e9" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;logits&lt;/code&gt; to Tensor.</source>
          <target state="translated">&lt;code&gt;logits&lt;/code&gt; 을 위해 Tensor에 등록 된 변환 함수가없는 경우 .</target>
        </trans-unit>
        <trans-unit id="89aa17961e0651e59900316456981d934e3912a8" translate="yes" xml:space="preserve">
          <source>If no conversion function is registered for &lt;code&gt;value&lt;/code&gt; to &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; &lt;code&gt;value&lt;/code&gt; 에 대한 변환 함수가 등록되지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="4db2dd7673a719bd18a4a69659d6bb176d96588c" translate="yes" xml:space="preserve">
          <source>If no docstring is given, only returns the method name.</source>
          <target state="translated">docstring이 제공되지 않으면 메소드 이름 만 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4a269e9e969aae169d3e3205ccb3dae3b6b4e358" translate="yes" xml:space="preserve">
          <source>If no error is raised, the Op outputs the value of the variable before the increment.</source>
          <target state="translated">오류가 발생하지 않으면 Op는 증분 전에 변수 값을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="216c8a5f35ff33f04b721aaf62c762669c33d560" translate="yes" xml:space="preserve">
          <source>If no global Keras session exists at this point: we will create a new global session.</source>
          <target state="translated">이 시점에서 글로벌 Keras 세션이 존재하지 않는 경우 : 새로운 글로벌 세션을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c28b8b28787cacd056df528e92f88cbe1e1036f8" translate="yes" xml:space="preserve">
          <source>If no replica exists in the task which contains the logical core.</source>
          <target state="translated">논리 코어를 포함하는 작업에 복제본이없는 경우.</target>
        </trans-unit>
        <trans-unit id="7b9d82b8205b36e56cf0f7278c52946e01c5133b" translate="yes" xml:space="preserve">
          <source>If no resource containers are provided, all containers are reset.</source>
          <target state="translated">자원 컨테이너가 제공되지 않으면 모든 컨테이너가 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="9cfd8b71191efc1c0a6b8d84ed8d6d888915fc70" translate="yes" xml:space="preserve">
          <source>If no structure is provided or if the structures do not match each other by type.</source>
          <target state="translated">구조가 제공되지 않거나 구조가 유형별로 서로 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="a0c82db29e90e42775efa5d5de870d187dc07ca3" translate="yes" xml:space="preserve">
          <source>If no summaries were collected, returns None. Otherwise returns a scalar &lt;code&gt;Tensor&lt;/code&gt; of type &lt;code&gt;string&lt;/code&gt; containing the serialized &lt;code&gt;Summary&lt;/code&gt; protocol buffer resulting from the merging.</source>
          <target state="translated">요약이 수집되지 않은 경우 없음을 리턴합니다. 그렇지 않으면 병합으로 인한 직렬화 된 &lt;code&gt;Summary&lt;/code&gt; 프로토콜 버퍼를 포함하는 &lt;code&gt;string&lt;/code&gt; 유형 의 스칼라 &lt;code&gt;Tensor&lt;/code&gt; 를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="07aeae9b6a2b7fb92c4e8a6abe9157cd51416be3" translate="yes" xml:space="preserve">
          <source>If no trace event is collected.</source>
          <target state="translated">추적 이벤트가 수집되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="4677f5431e44aba52c3e416d441c3560e1d07b3e" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;arr&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="translated">None이 아닌 경우 arr과 동일한 모양이어야합니다. &lt;code&gt;arr&lt;/code&gt; 의 각 값에 대해 빈은 1이 아닌 해당 가중치만큼 증가합니다.</target>
        </trans-unit>
        <trans-unit id="dd9edd2e4ca6ef4287be04923df066082872634f" translate="yes" xml:space="preserve">
          <source>If non-None, must be the same shape as arr. For each value in &lt;code&gt;value&lt;/code&gt;, the bin will be incremented by the corresponding weight instead of 1.</source>
          <target state="translated">None이 아닌 경우 arr과 동일한 모양이어야합니다. 각 값에 대해 &lt;code&gt;value&lt;/code&gt; , 빈은 대응하는 무게 대신에 1 씩 증가한다.</target>
        </trans-unit>
        <trans-unit id="a9de9fbe1c63a1ea93130c03e9fe3eb64adbc926" translate="yes" xml:space="preserve">
          <source>If none of a node's properties match the specified regexes, the node is not displayed nor accounted.</source>
          <target state="translated">지정된 등록 정보와 일치하는 노드 등록 정보가 없으면 노드가 표시되거나 설명되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d16008e222530e277dd5205338188d4326227051" translate="yes" xml:space="preserve">
          <source>If none of the TPUs specified exists.</source>
          <target state="translated">지정된 TPU가없는 경우.</target>
        </trans-unit>
        <trans-unit id="1ced5d0a9dde1412d62e35e74cea6874de5d3669" translate="yes" xml:space="preserve">
          <source>If none of the variables have gradients.</source>
          <target state="translated">변수에 기울기가없는 경우.</target>
        </trans-unit>
        <trans-unit id="5673c073f97a964e32cf1b429bfe01540d5a66bb" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each replica of the computation uses only one core, and there is either only one replica, or the number of replicas is equal to the number of cores in the TPU system.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 TPU 토폴로지의 물리적 코어와 계산에서 논리적 코어 간의 매핑을 설명 하는 &lt;code&gt;DeviceAssignment&lt;/code&gt; 입니다. &lt;code&gt;None&lt;/code&gt; 인 경우 기본 장치 할당을 사용합니다 . &lt;code&gt;DeviceAssignment&lt;/code&gt; 은 계산에서 사용하는 각 복제본 하나 개의 코어, 그리고 어느 하나 개의 복제가 또는 복제 수가 TPU 시스템에서의 코어의 개수와 동일한 경우 생략 될 수있다.</target>
        </trans-unit>
        <trans-unit id="63c3c2c305c31754539127b6a5866a20f758c70f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a &lt;code&gt;DeviceAssignment&lt;/code&gt; describing the mapping between logical cores in the computation with physical cores in the TPU topology. Uses a default device assignment if &lt;code&gt;None&lt;/code&gt;. The &lt;code&gt;DeviceAssignment&lt;/code&gt; may be omitted if each shard of the computation uses only one core, and there is either only one shard, or the number of shards is equal to the number of cores in the TPU system.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 TPU 토폴로지의 물리적 코어와 계산에서 논리적 코어 간의 매핑을 설명 하는 &lt;code&gt;DeviceAssignment&lt;/code&gt; 입니다. &lt;code&gt;None&lt;/code&gt; 인 경우 기본 장치 할당을 사용합니다 . &lt;code&gt;DeviceAssignment&lt;/code&gt; 은 연산의 각 샤드 단지 하나의 코어를 사용하고,이 하나 개의 파편이 하나, 또는 파편의 수가 TPU 시스템에서의 코어의 개수와 동일한 경우 생략 될 수있다.</target>
        </trans-unit>
        <trans-unit id="509f2c9c1b984e6b680ad3a5e1fe26de648c4e5c" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a function that can be used to normalize the value of the tensor after &lt;code&gt;default_value&lt;/code&gt; is applied for parsing. Normalizer function takes the input &lt;code&gt;Tensor&lt;/code&gt; as its argument, and returns the output &lt;code&gt;Tensor&lt;/code&gt;. (e.g. lambda x: (x - 3.0) / 4.2). Please note that even though the most common use case of this function is normalization, it can be used for any kind of Tensorflow transformations.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아니라면 &lt;code&gt;default_value&lt;/code&gt; 가 파싱에 적용된 후 텐서의 값을 정규화하는 데 사용할 수있는 함수입니다 . Normalizer 함수는 입력 &lt;code&gt;Tensor&lt;/code&gt; 를 인수로 취하고 출력 &lt;code&gt;Tensor&lt;/code&gt; 를 반환합니다 . (예 : 람다 x : (x-3.0) / 4.2). 이 함수의 가장 일반적인 사용 사례는 정규화이지만 모든 종류의 Tensorflow 변환에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d465b2cf7ea11a58a6ed9a1556935218d29d6da5" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, a nested structure of &lt;a href=&quot;../../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;s, &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s or &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s, matching the above, except that the tensors should be of float type (and they will be downcast to &lt;a href=&quot;../../../../tf#float32&quot;&gt;&lt;code&gt;tf.float32&lt;/code&gt;&lt;/a&gt;). For &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;s we assume the &lt;code&gt;indices&lt;/code&gt; are the same for the parallel entries from &lt;code&gt;features&lt;/code&gt; and similarly for &lt;a href=&quot;../../../raggedtensor&quot;&gt;&lt;code&gt;tf.RaggedTensor&lt;/code&gt;&lt;/a&gt;s we assume the row_splits are the same.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 의 중첩 구조 &lt;a href=&quot;../../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; S, &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; S 또는 &lt;a href=&quot;../../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; &lt;/a&gt; 의 상기 텐서는 플로트 타입이어야한다 (그리고 그들에게 다운 캐스트 될 것을 제외하고, 상기 매칭 &lt;a href=&quot;../../../../tf#float32&quot;&gt; &lt;code&gt;tf.float32&lt;/code&gt; &lt;/a&gt; ). 들어 &lt;a href=&quot;../../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; 가&lt;/a&gt; 이야 우리는 가정 &lt;code&gt;indices&lt;/code&gt; 에서 병렬 항목에 대해 동일 &lt;code&gt;features&lt;/code&gt; 과 유사에 대한 &lt;a href=&quot;../../../raggedtensor&quot;&gt; &lt;code&gt;tf.RaggedTensor&lt;/code&gt; 은&lt;/a&gt; 우리가 row_splits이 같은 생각이야.</target>
        </trans-unit>
        <trans-unit id="296b8e3c4315ff90baa92063d3b0326d08c56ad9" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, all embeddings are l2-normalized to max_norm before combining.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아니라면 모든 임베딩은 결합하기 전에 l2 정규화되어 max_norm으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="47a1ff929b229da4f9b213bdd01bc92916d8726d" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value, before combining.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아니라면 결합하기 전에 l2- 노름이이 값보다 크면 각 임베딩이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="7c8b1dcbe91b12c711cbead26da96a3057eeec76" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, each embedding is clipped if its l2-norm is larger than this value.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아닌 경우 l2-norm이이 값보다 크면 각 임베딩이 잘립니다.</target>
        </trans-unit>
        <trans-unit id="8e4186fef74e41eb06f918c4810fccf1e45e8a26" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, embedding values are l2-normalized to this value.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아니라면 임베딩 값은이 값으로 l2 정규화됩니다.</target>
        </trans-unit>
        <trans-unit id="978a020b0f46543fd45be34416a7ef4179cb602b" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from '_FeatureColumn' to the associated output &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 이 아니라면 '_FeatureColumn'에서 관련 출력 &lt;code&gt;Tensor&lt;/code&gt; 로의 매핑으로 채워질 사전이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="7f0bb7cd728839a79f7e1f1bd44743d45c0411f7" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to associated list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = { _NumericColumn( key='numeric_feature1', shape=(1,): [</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 에서 매핑으로 채워집니다 사전 있어야합니다 &lt;code&gt;_FeatureColumn&lt;/code&gt; 의 관련 목록에 &lt;code&gt;Variable&lt;/code&gt; 들. 예를 들어, 호출 후 cols_to_vars = {_NumericColumn (key = 'numeric_feature1', shape = (1,) : [</target>
        </trans-unit>
        <trans-unit id="56c7e1c63640853eaa42afa057c2f45c362c9288" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, must be a dictionary that will be filled with a mapping from &lt;code&gt;_FeatureColumn&lt;/code&gt; to list of &lt;code&gt;Variable&lt;/code&gt;s. For example, after the call, we might have cols_to_vars = {_EmbeddingColumn( categorical_column=_HashedCategoricalColumn( key='sparse_feature', hash_bucket_size=5, dtype=tf.string), dimension=10): [</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 에서 매핑으로 채워집니다 사전 있어야합니다 &lt;code&gt;_FeatureColumn&lt;/code&gt; 의 목록에 &lt;code&gt;Variable&lt;/code&gt; 들. 예를 들어, 호출 후 cols_to_vars = {_EmbeddingColumn (categorical_column = _HashedCategoricalColumn (key = 'sparse_feature', hash_bucket_size = 5, dtype = tf.string), dimension = 10) : [</target>
        </trans-unit>
        <trans-unit id="13ea74e730c8fdc7dced991be0cb79988348a460" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 상기 &lt;code&gt;InfeedQueue&lt;/code&gt; 가 있는 입력으로 인수 튜플를 추가 &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2fa459e00f71f8fbe5145fbae6b30aae29c969f" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; from which to append a tuple of arguments as inputs to computation.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 상기 &lt;code&gt;InfeedQueue&lt;/code&gt; 이 되는 계산에 대한 입력으로서 인수 튜플을 추가한다.</target>
        </trans-unit>
        <trans-unit id="df8b0ec37f8675dfef5175140fbc30d7548facce" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt;, the &lt;code&gt;InfeedQueue&lt;/code&gt; to use to augment the inputs of &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 의 &lt;code&gt;InfeedQueue&lt;/code&gt; 는 의 입력을 증가시키기 위해 사용하는 &lt;code&gt;computation&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2adb13355e2e9171a471537a4efe3cc9a47e4197" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;logdir&lt;/code&gt; was passed to the constructor as the services need a log directory.</source>
          <target state="translated">그렇지 않으면 서비스에 로그 디렉토리가 필요하므로 &lt;code&gt;logdir&lt;/code&gt; 이 생성자에 전달되었습니다.</target>
        </trans-unit>
        <trans-unit id="cc1544fb6f5eb544c03d6decbe78bbddfc4cc1a8" translate="yes" xml:space="preserve">
          <source>If not None, a &lt;code&gt;TPUEmbeddingConfiguration&lt;/code&gt; proto describing the desired configuration of the hardware embedding lookup tables. If embedding_config is None, no hardware embeddings can be used.</source>
          <target state="translated">None이 아닌 경우 하드웨어 임베딩 조회 테이블의 원하는 구성을 설명 하는 &lt;code&gt;TPUEmbeddingConfiguration&lt;/code&gt; 프로토입니다. embedding_config가 None이면 하드웨어 임베딩을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f42570ffb6aa4e9f054aeab69979c5e90ad1417" translate="yes" xml:space="preserve">
          <source>If not None, names in &lt;code&gt;tensor_info&lt;/code&gt; are prefixed with this string before lookup.</source>
          <target state="translated">None이 아니라면, &lt;code&gt;tensor_info&lt;/code&gt; 의 이름은 조회 전에이 문자열로 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="d5fdaefdedc8dd17a71aedc92fd4aa257320fff9" translate="yes" xml:space="preserve">
          <source>If not initialized with a &lt;a href=&quot;layer&quot;&gt;&lt;code&gt;tf.keras.layers.Layer&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;layer&quot;&gt; &lt;code&gt;tf.keras.layers.Layer&lt;/code&gt; &lt;/a&gt; 인스턴스로 초기화되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="3fd2102800b8c57e0c21e6fddab9285a922daf0b" translate="yes" xml:space="preserve">
          <source>If not inside a distributed scope, this is equivalent to:</source>
          <target state="translated">분산 범위 내에 있지 않은 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad750d422dbc04ae2bf1f5c8900ca8fc0b781343" translate="yes" xml:space="preserve">
          <source>If not inside of tf.function and not executing eagerly.</source>
          <target state="translated">tf.function 내부에 있지 않고 열심히 실행하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="80902a1672b889ee91d8c5e7f1e1ffb78350bede" translate="yes" xml:space="preserve">
          <source>If not using control flow v2.</source>
          <target state="translated">제어 흐름 v2를 사용하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="551cd382db7d04818e99686d5a2ef23e2c65b884" translate="yes" xml:space="preserve">
          <source>If not within a tpu_shard_context or group_assignment is invalid.</source>
          <target state="translated">tpu_shard_context 또는 group_assignment 내에 있지 않으면 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1152353c368563e8f451606390529f3dcdfc2374" translate="yes" xml:space="preserve">
          <source>If num_required &amp;lt; 1</source>
          <target state="translated">num_required &amp;lt;1 인 경우</target>
        </trans-unit>
        <trans-unit id="4f2d5188835a8dc9b2fc6daea0dbacadcb317cb6" translate="yes" xml:space="preserve">
          <source>If num_shards &amp;lt;= 0</source>
          <target state="translated">num_shards &amp;lt;= 0 인 경우</target>
        </trans-unit>
        <trans-unit id="cc823222acd9e434530a8993ce4e2336f5e34158" translate="yes" xml:space="preserve">
          <source>If num_tokens are smaller than replicas_to_aggregate - total_num_replicas.</source>
          <target state="translated">num_tokens가 replicas_to_aggregate-total_num_replicas보다 작은 경우.</target>
        </trans-unit>
        <trans-unit id="cdaea2a087144406be71543156cf54bff456a8e9" translate="yes" xml:space="preserve">
          <source>If obj is an instance, then it is its class that will actually be stubbed. Note that the method Set() does not do that: if obj is an instance, it (and not its class) will be stubbed.</source>
          <target state="translated">obj가 인스턴스이면 실제로 스텁되는 클래스입니다. Set () 메소드는 그렇게하지 않습니다. obj가 인스턴스라면 클래스가 아닌 인스턴스가 스텁됩니다.</target>
        </trans-unit>
        <trans-unit id="12e486f660da647d480cd7f2ffdcdd861bede3fe" translate="yes" xml:space="preserve">
          <source>If objects in &lt;code&gt;kwargs&lt;/code&gt; are not trackable.</source>
          <target state="translated">&lt;code&gt;kwargs&lt;/code&gt; 의 개체를 추적 할 수없는 경우 .</target>
        </trans-unit>
        <trans-unit id="7ae90fa036abf3772d3d0631e8f4275b836203c5" translate="yes" xml:space="preserve">
          <source>If on the other hand the spectrum is Hermitian, then this operator corresponds to a real-valued matrix, and setting &lt;code&gt;input_output_dtype&lt;/code&gt; to a real type is fine.</source>
          <target state="translated">반면에 스펙트럼이 에르 미트 (Hermitian) 인 경우이 연산자는 실수 값 행렬에 해당하며 &lt;code&gt;input_output_dtype&lt;/code&gt; 을 실수 유형으로 설정 하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="3497dacd218f5e562f9d613938110d69a5766635" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">하나의 &lt;code&gt;SparseTensor&lt;/code&gt; 와 하나의 &lt;code&gt;Tensor&lt;/code&gt; 가 전달되면 &lt;code&gt;Tensor&lt;/code&gt; 를 리턴합니다 . 두 인수는 경우 &lt;code&gt;SparseTensor&lt;/code&gt; 의이 리턴한다 &lt;code&gt;SparseTensor&lt;/code&gt; 을 . 논증의 순서는 중요하지 않습니다. 두 개의 조밀 한 &lt;code&gt;Tensor&lt;/code&gt; 를 추가 하려면 바닐라 &lt;a href=&quot;../../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="18fe14991d61b8d26bb58197035c8d2daabc8b92" translate="yes" xml:space="preserve">
          <source>If one &lt;code&gt;SparseTensor&lt;/code&gt; and one &lt;code&gt;Tensor&lt;/code&gt; are passed in, returns a &lt;code&gt;Tensor&lt;/code&gt;. If both arguments are &lt;code&gt;SparseTensor&lt;/code&gt;s, this returns a &lt;code&gt;SparseTensor&lt;/code&gt;. The order of arguments does not matter. Use vanilla &lt;a href=&quot;../math/add&quot;&gt;&lt;code&gt;tf.add()&lt;/code&gt;&lt;/a&gt; for adding two dense &lt;code&gt;Tensor&lt;/code&gt;s.</source>
          <target state="translated">하나의 &lt;code&gt;SparseTensor&lt;/code&gt; 와 하나의 &lt;code&gt;Tensor&lt;/code&gt; 가 전달되면 &lt;code&gt;Tensor&lt;/code&gt; 를 리턴합니다 . 두 인수는 경우 &lt;code&gt;SparseTensor&lt;/code&gt; 의이 리턴한다 &lt;code&gt;SparseTensor&lt;/code&gt; 을 . 논증의 순서는 중요하지 않습니다. 두 개의 조밀 한 &lt;code&gt;Tensor&lt;/code&gt; 를 추가 하려면 바닐라 &lt;a href=&quot;../math/add&quot;&gt; &lt;code&gt;tf.add()&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="d4f0585e78e733116b83480d150410db915cb539" translate="yes" xml:space="preserve">
          <source>If one KL method is registered between any pairs of classes in these two parent hierarchies, it is used.</source>
          <target state="translated">이 두 상위 계층에서 클래스 쌍 사이에 하나의 KL 메소드가 등록 된 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1936b0b1103e6183e81d24cc6b618d20c1ed3535" translate="yes" xml:space="preserve">
          <source>If one component of 1-D tensor &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; may be unknown.</source>
          <target state="translated">1 차원 텐서 &lt;code&gt;shape&lt;/code&gt; 의 한 구성 요소가 특수 값 -1이면 전체 크기가 일정하게 유지되도록 해당 차원의 크기가 계산됩니다. 특히 &lt;code&gt;[-1]&lt;/code&gt; 의 &lt;code&gt;shape&lt;/code&gt; 은 1 차원으로 평평 해집니다. &lt;code&gt;shape&lt;/code&gt; 구성 요소는 최대 하나만 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="221196929093898b7fbc8387574ba6a574c7e5f8" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;new_shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;new_shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;new_shape&lt;/code&gt; must be the same as the number of dense elements originally implied by &lt;code&gt;input_shape&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_shape&lt;/code&gt; 의 한 구성 요소 가 특수 값 -1이면 전체 밀도 크기가 일정하게 유지되도록 해당 차원의 크기가 계산됩니다. &lt;code&gt;new_shape&lt;/code&gt; 의 최대 하나의 구성 요소는 -1이 될 수 있습니다. &lt;code&gt;new_shape&lt;/code&gt; 가 암시하는 조밀 한 요소 의 수는 원래 &lt;code&gt;input_shape&lt;/code&gt; 가 암시하는 조밀 한 요소의 수와 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="ea084c2ad5e28df87d0ca52cc75d071fe917e285" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total dense size remains constant. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1. The number of dense elements implied by &lt;code&gt;shape&lt;/code&gt; must be the same as the number of dense elements originally represented by &lt;code&gt;sp_input&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 한 구성 요소 가 특수 값 -1이면 전체 치밀한 크기가 일정하게 유지되도록 해당 차원의 크기가 계산됩니다. 최대 하나의 &lt;code&gt;shape&lt;/code&gt; 구성 요소는 -1 일 수 있습니다. &lt;code&gt;shape&lt;/code&gt; 의해 암시 된 고밀도 요소 의 수는 원래 &lt;code&gt;sp_input&lt;/code&gt; 으로 표시되는 고밀도 요소의 수와 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="bafb2065764a06f54947439b6949d0053558bc8a" translate="yes" xml:space="preserve">
          <source>If one component of &lt;code&gt;shape&lt;/code&gt; is the special value -1, the size of that dimension is computed so that the total size remains constant. In particular, a &lt;code&gt;shape&lt;/code&gt; of &lt;code&gt;[-1]&lt;/code&gt; flattens into 1-D. At most one component of &lt;code&gt;shape&lt;/code&gt; can be -1.</source>
          <target state="translated">&lt;code&gt;shape&lt;/code&gt; 한 구성 요소 가 특수 값 -1이면 전체 크기가 일정하게 유지되도록 해당 차원의 크기가 계산됩니다. 특히, &lt;code&gt;[-1]&lt;/code&gt; 의 &lt;code&gt;shape&lt;/code&gt; 은 1-D로 평탄화된다. 최대 하나의 &lt;code&gt;shape&lt;/code&gt; 구성 요소는 -1 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce3fdef10714c187a3c205cc8298fa8e63609f57" translate="yes" xml:space="preserve">
          <source>If one of the arguments is invalid.</source>
          <target state="translated">인수 중 하나가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="1b262dc519863d0a0c455b46653404b98d409a27" translate="yes" xml:space="preserve">
          <source>If one of the tasks crashes and restarts, &lt;code&gt;managed_session()&lt;/code&gt; checks if the Model is initialized. If yes, it just creates a session and returns it to the training code that proceeds normally. If the model needs to be initialized, the chief task takes care of reinitializing it; the other tasks just wait for the model to have been initialized.</source>
          <target state="translated">작업 중 하나가 충돌하고 다시 시작되면 &lt;code&gt;managed_session()&lt;/code&gt; 이 모델이 초기화되었는지 확인합니다. 그렇다면 세션을 생성하고 정상적으로 진행되는 교육 코드로 반환합니다. 모델을 초기화해야하는 경우 주 작업은 모델을 다시 초기화합니다. 다른 작업은 모델이 초기화 될 때까지 기다립니다.</target>
        </trans-unit>
        <trans-unit id="bbb12d851ea0d6c46ec595443cab53217c732f23" translate="yes" xml:space="preserve">
          <source>If one or both of the inputs contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices/vectors (rank-2/1 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">입력 중 하나 또는 둘 다에 0이 많은 경우 해당 &lt;code&gt;a_is_sparse&lt;/code&gt; 또는 &lt;code&gt;b_is_sparse&lt;/code&gt; 플래그를 &lt;code&gt;True&lt;/code&gt; 로 설정하여보다 효율적인 곱셈 알고리즘을 사용할 수 있습니다 . 이들은 &lt;code&gt;False&lt;/code&gt; 기본적으로. 이 최적화는 데이터 유형이 &lt;code&gt;bfloat16&lt;/code&gt; 또는 &lt;code&gt;float32&lt;/code&gt; 인 일반 행렬 / 벡터 (랭크 -2/1 텐서)에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17b326f6ea020b628ceba1332baab40e28fbf23a" translate="yes" xml:space="preserve">
          <source>If one or both of the matrices contain a lot of zeros, a more efficient multiplication algorithm can be used by setting the corresponding &lt;code&gt;a_is_sparse&lt;/code&gt; or &lt;code&gt;b_is_sparse&lt;/code&gt; flag to &lt;code&gt;True&lt;/code&gt;. These are &lt;code&gt;False&lt;/code&gt; by default. This optimization is only available for plain matrices (rank-2 tensors) with datatypes &lt;code&gt;bfloat16&lt;/code&gt; or &lt;code&gt;float32&lt;/code&gt;.</source>
          <target state="translated">행렬 중 하나 또는 둘 다에 0이 많은 경우 해당 &lt;code&gt;a_is_sparse&lt;/code&gt; 또는 &lt;code&gt;b_is_sparse&lt;/code&gt; 플래그를 &lt;code&gt;True&lt;/code&gt; 로 설정하여보다 효율적인 곱셈 알고리즘을 사용할 수 있습니다 . 이들은 &lt;code&gt;False&lt;/code&gt; 기본적으로. 이 최적화는 데이터 유형이 &lt;code&gt;bfloat16&lt;/code&gt; 또는 &lt;code&gt;float32&lt;/code&gt; 인 일반 행렬 (랭크 -2 텐서)에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="56f4daf089aff0f2fa2e66596a4c62c77c048c8b" translate="yes" xml:space="preserve">
          <source>If one row of &lt;code&gt;transforms&lt;/code&gt; is &lt;code&gt;[a0, a1, a2, b0, b1, b2, c0, c1]&lt;/code&gt;, then it maps the &lt;em&gt;output&lt;/em&gt; point &lt;code&gt;(x, y)&lt;/code&gt; to a transformed &lt;em&gt;input&lt;/em&gt; point &lt;code&gt;(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)&lt;/code&gt;, where &lt;code&gt;k = c0 x + c1 y + 1&lt;/code&gt;. If the transformed point lays outside of the input image, the output pixel is set to 0.</source>
          <target state="translated">&lt;code&gt;transforms&lt;/code&gt; 한 행 이 &lt;code&gt;[a0, a1, a2, b0, b1, b2, c0, c1]&lt;/code&gt; 이면 &lt;em&gt;출력&lt;/em&gt; 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 변환 된 &lt;em&gt;입력&lt;/em&gt; 점 &lt;code&gt;(x', y') = ((a0 x + a1 y + a2) / k, (b0 x + b1 y + b2) / k)&lt;/code&gt; , 여기서 &lt;code&gt;k = c0 x + c1 y + 1&lt;/code&gt; . 변형 된 점이 입력 이미지 외부에 있으면 출력 픽셀은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b2cec49ea279d810bcec33c21637d3e3e971bbbb" translate="yes" xml:space="preserve">
          <source>If only classes is set, it is interpreted as providing top-k results in descending order.</source>
          <target state="translated">클래스 만 설정하면 상위 k 결과를 내림차순으로 제공하는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="75620cc03e8dc3221a8a09a86626829819275026" translate="yes" xml:space="preserve">
          <source>If only scores is set, it is interpreted as providing a score for every class in order of class ID.</source>
          <target state="translated">점수 만 설정된 경우 클래스 ID 순서대로 모든 클래스에 점수를 제공하는 것으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="667b41a8af9aff900724c27ad2e8c154d2639d32" translate="yes" xml:space="preserve">
          <source>If optimizer is not one of tf.tpu.experimental.embedding.(SGD, Adam or Adagrad).</source>
          <target state="translated">Optimizer가 tf.tpu.experimental.embedding. (SGD, Adam 또는 Adagrad) 중 하나가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="14c9d9f46c8a297896e15240808cdbc2b353bfe6" translate="yes" xml:space="preserve">
          <source>If p and logits are passed, or if neither are passed.</source>
          <target state="translated">p와 logits가 전달되거나 둘 다 전달되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="ba5e99215ee01b17ad5ac6edb796d60bac8b52d6" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;, specifies the shape of the convolution kernel/pooling window as an integer Tensor of shape [&amp;gt;=num_spatial_dims]. If padding = &quot;VALID&quot;, filter_shape is ignored and need not be specified.</source>
          <target state="translated">padding = &quot;SAME&quot;이면 컨볼 루션 커널 / 풀링 창의 모양을 정수 Tensor of shape [&amp;gt; = num_spatial_dims]로 지정합니다. padding = &quot;VALID&quot;이면 filter_shape가 무시되며 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b2e0db46aec01ec30dc1082790031dd6d15b166e" translate="yes" xml:space="preserve">
          <source>If padding = &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">패딩 = &quot;SAME&quot;인 경우 : output_spatial_shape [i] = ceil (input_spatial_shape [i] / strides [i])</target>
        </trans-unit>
        <trans-unit id="fcdcd97fe86754396f4eb68d73df8c9d73f8dba1" translate="yes" xml:space="preserve">
          <source>If padding = &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (window_shape[i] - 1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">패딩 = &quot;VALID&quot;인 경우 : output_spatial_shape [i] = ceil ((input_spatial_shape [i]-(window_shape [i]-1) * dilation_rate [i]) / strides [i]).</target>
        </trans-unit>
        <trans-unit id="05f33b626808fecfebc52bc856e9c14717da266f" translate="yes" xml:space="preserve">
          <source>If padding == &quot;SAME&quot;: output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])</source>
          <target state="translated">패딩 == &quot;SAME&quot;인 경우 : output_spatial_shape [i] = ceil (input_spatial_shape [i] / strides [i])</target>
        </trans-unit>
        <trans-unit id="136aa13ad4e629923ef043b74c86f4e39f2b8ae0" translate="yes" xml:space="preserve">
          <source>If padding == &quot;VALID&quot;: output_spatial_shape[i] = ceil((input_spatial_shape[i] - (spatial_filter_shape[i]-1) * dilation_rate[i]) / strides[i]).</source>
          <target state="translated">패딩 == &quot;VALID&quot;인 경우 : output_spatial_shape [i] = ceil ((input_spatial_shape [i]-(spatial_filter_shape [i] -1) * dilation_rate [i]) / strides [i]).</target>
        </trans-unit>
        <trans-unit id="f7b6860ab2b51cdf0388bf04a8450a071066af7a" translate="yes" xml:space="preserve">
          <source>If positive, the feature is a sequence feature with the corresponding maximum sequence length. If the sequence is longer than this, it will be truncated. If 0, the feature is not a sequence feature.</source>
          <target state="translated">양수인 경우 기능은 해당하는 최대 시퀀스 길이를 가진 시퀀스 기능입니다. 시퀀스가 이보다 길면 잘립니다. 0 인 경우 기능은 시퀀스 기능이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="bb4fb2200f1abc514276162cb92eabdf216c950b" translate="yes" xml:space="preserve">
          <source>If possible you should use &lt;code&gt;assertRegex&lt;/code&gt;, which is a simpler version of this method. &lt;code&gt;assertRegex&lt;/code&gt; takes a single regular expression (a string or re compiled object) instead of a list.</source>
          <target state="translated">가능하면 이 메소드의 더 간단한 버전 인 &lt;code&gt;assertRegex&lt;/code&gt; 를 사용해야합니다 . &lt;code&gt;assertRegex&lt;/code&gt; 는 목록 대신 단일 정규식 (문자열 또는 재 컴파일 된 객체)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="06742f16b6eea52463f3c33907285332cf099a29" translate="yes" xml:space="preserve">
          <source>If possible, you should use assertCountEqual instead of assertSameElements.</source>
          <target state="translated">가능하면 assertSameElements 대신 assertCountEqual을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="614678e645a7e3d66b077654721dda0404775036" translate="yes" xml:space="preserve">
          <source>If prefix is an empty sequence, it will raise an error unless whole is also an empty sequence.</source>
          <target state="translated">접두사가 빈 시퀀스이면 전체도 빈 시퀀스가 ​​아닌 한 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="47be90f234e2dd2a2a123f6a39d9360729095139" translate="yes" xml:space="preserve">
          <source>If prefix is not a sequence, it will raise an error if the first element of whole does not match.</source>
          <target state="translated">접두사가 시퀀스가 ​​아닌 경우 전체의 첫 번째 요소가 일치하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4456cc620a8e8e1b60e289bbd83d6240b8855aef" translate="yes" xml:space="preserve">
          <source>If previously created threads for the given session are still running, no new threads will be created.</source>
          <target state="translated">주어진 세션에 대해 이전에 작성된 스레드가 여전히 실행중인 경우 새 스레드가 작성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="935d994a9d9f9a8a4651374980a9727dd4176a43" translate="yes" xml:space="preserve">
          <source>If provided the global step number is appended to &lt;code&gt;save_path&lt;/code&gt; to create the checkpoint filenames. The optional argument can be a &lt;code&gt;Tensor&lt;/code&gt;, a &lt;code&gt;Tensor&lt;/code&gt; name or an integer.</source>
          <target state="translated">제공된 경우 전역 단계 번호가 &lt;code&gt;save_path&lt;/code&gt; 에 추가되어 체크 포인트 파일 이름을 만듭니다. 선택적 인수는 &lt;code&gt;Tensor&lt;/code&gt; , &lt;code&gt;Tensor&lt;/code&gt; 이름 또는 정수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6505b900cbe26dd0628fad67c8abdd95daefb1a9" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 &lt;code&gt;y&lt;/code&gt; 와 동일한 유형 이고 &lt;code&gt;condition&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 로 브로드 캐스팅 할 수있는 모양을 갖는 Tensor .</target>
        </trans-unit>
        <trans-unit id="b2ebfa3cb3d2b0a0319a06e522f9afca9b3a453d" translate="yes" xml:space="preserve">
          <source>If provided, a Tensor which is of the same type as &lt;code&gt;y&lt;/code&gt;, and has a shape broadcastable with &lt;code&gt;condition&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 &lt;code&gt;y&lt;/code&gt; 와 동일한 유형 이고 &lt;code&gt;condition&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 로 브로드 캐스팅 할 수있는 모양을 갖는 Tensor입니다 .</target>
        </trans-unit>
        <trans-unit id="a7e190b7a73646673bf3b834de40d541abeb2140" translate="yes" xml:space="preserve">
          <source>If provided, contains a name of a &quot;known&quot; function this implements. For example &quot;mycompany.my_recurrent_cell&quot;. This is stored as an attribute in inference function, which can then be detected when processing serialized function. See &lt;a href=&quot;https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md&quot;&gt;standardizing composite ops&lt;/a&gt;</source>
          <target state="translated">제공된 경우 이것이 구현하는 &quot;알려진&quot;함수의 이름을 포함합니다. 예 : &quot;mycompany.my_recurrent_cell&quot;. 이것은 추론 함수의 속성으로 저장되며 직렬화 된 함수를 처리 할 때 감지 할 수 있습니다. &lt;a href=&quot;https://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md&quot;&gt;복합 작업 표준화&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="0dd1c318ea1071c0386e26e997ff535d9d7da5b2" translate="yes" xml:space="preserve">
          <source>If provided, parameters will be passed to each &lt;code&gt;Callback&lt;/code&gt; via &lt;a href=&quot;callback#set_params&quot;&gt;&lt;code&gt;Callback.set_params&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공 한 경우, 매개 변수가 각각 전달됩니다 &lt;code&gt;Callback&lt;/code&gt; 을 통해 &lt;a href=&quot;callback#set_params&quot;&gt; &lt;code&gt;Callback.set_params&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1e75e5a1f64ca198b5be947e9d08bf1483b9ae0e" translate="yes" xml:space="preserve">
          <source>If range_given == False, the initial input_min, input_max will be determined automatically as the minimum and maximum values in the input tensor, otherwise the specified values of input_min, input_max are used.</source>
          <target state="translated">range_given == False이면 초기 input_min, input_max가 입력 텐서의 최소값과 최대 값으로 자동으로 결정됩니다. 그렇지 않으면 지정된 input_min, input_max 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="93a0d6e60eb82597465ad27ec661d2094826eef2" translate="yes" xml:space="preserve">
          <source>If range_given=True, the maximum input value that needs to be represented in the quantized representation. If axis is specified, this should be a vector of maximum values for each slice along axis.</source>
          <target state="translated">range_given = True 인 경우 양자화 된 표현으로 표현해야하는 최대 입력 값입니다. 축이 지정되면 축을 따라 각 슬라이스에 대한 최대 값으로 구성된 벡터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a29e16a712314dbeb26dae11afbe28b3144fe882" translate="yes" xml:space="preserve">
          <source>If range_given=True, the minimum input value, that needs to be represented in the quantized representation. If axis is specified, this should be a vector of minimum values for each slice along axis.</source>
          <target state="translated">range_given = True, 최소 입력 값이면 양자화 된 표현으로 표현되어야합니다. 축이 지정되면 축을 따라 각 슬라이스에 대한 최소값으로 구성된 벡터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="341f17f161cd76784a4d0ca890a541c032caae40" translate="yes" xml:space="preserve">
          <source>If rank of &lt;code&gt;condition&lt;/code&gt; is greater than rank of expressions.</source>
          <target state="translated">의 순위 경우 &lt;code&gt;condition&lt;/code&gt; 표현의 순위보다 더 크다.</target>
        </trans-unit>
        <trans-unit id="55b41a1af83d2a93715620f2355e250fc52515b3" translate="yes" xml:space="preserve">
          <source>If rate is set to &lt;code&gt;0&lt;/code&gt; the input is returned, unchanged:</source>
          <target state="translated">rate가 &lt;code&gt;0&lt;/code&gt; 으로 설정 되면 입력이 변경되지 않고 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a4673a94db4f6c34f4aee3756479ca96ccf05ec9" translate="yes" xml:space="preserve">
          <source>If ready_for_local_init_op is not None but local_init_op is None</source>
          <target state="translated">ready_for_local_init_op이 None이 아니지만 local_init_op이 None 인 경우</target>
        </trans-unit>
        <trans-unit id="f13d81516362b4032d992ee7026437f786c08d61" translate="yes" xml:space="preserve">
          <source>If reduction is not a valid cross-shard reduction.</source>
          <target state="translated">감소가 유효한 교차 샤드 감소가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="f5a119b1872be8a1e53e996eedc55e37414996ed" translate="yes" xml:space="preserve">
          <source>If regexes is the empty list, the matching will always fail.</source>
          <target state="translated">정규 표현식이 빈 목록이면 일치하는 것이 항상 실패합니다.</target>
        </trans-unit>
        <trans-unit id="80440764c99d48a4d795f521af9a42a08a91983b" translate="yes" xml:space="preserve">
          <source>If requested more GPUs per node then available or requested more tasks then assigned tasks or resolving missing values from the environment failed.</source>
          <target state="translated">노드 당 더 많은 GPU를 요청하면 더 많은 작업을 사용할 수 있거나 요청한 다음 할당 된 작업 또는 환경에서 누락 된 값 해결에 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="e7fe2d8006b52d6565c302d5fd04437409f9fb2a" translate="yes" xml:space="preserve">
          <source>If result is empty but the gradient is nonzero.</source>
          <target state="translated">결과가 비어 있지만 그라디언트가 0이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="987747562432e3f06305cc2152c8a49d1c73905b" translate="yes" xml:space="preserve">
          <source>If result type is incompatible with &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">결과 유형이 &lt;code&gt;dtype&lt;/code&gt; 과 호환되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="bd2d3ef0e0ba16ab30b7cbfeba73a83b309a4c52" translate="yes" xml:space="preserve">
          <source>If running inside a tf.function.</source>
          <target state="translated">tf.function 내부에서 실행되는 경우.</target>
        </trans-unit>
        <trans-unit id="903b4a597f4844b0d172060958b46a04076c6f57" translate="yes" xml:space="preserve">
          <source>If save and restore ops weren't built.</source>
          <target state="translated">저장 및 복원 작업이 빌드되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fbbaa0275dbd84220e47ad7f03f7672526f446b5" translate="yes" xml:space="preserve">
          <source>If save format is hdf5, and h5py is not available.</source>
          <target state="translated">저장 형식이 hdf5이고 h5py를 사용할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6aaf33d3510248f2ccf226e35da12a582cc0f4ec" translate="yes" xml:space="preserve">
          <source>If save_path is None or not a valid checkpoint.</source>
          <target state="translated">save_path가 None이거나 유효한 체크 포인트가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="ab8b71f4c8233230d90cf75030653b89e7ac8f3b" translate="yes" xml:space="preserve">
          <source>If sep is not a string.</source>
          <target state="translated">sep가 문자열이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="c6a0eb571e3f74bb0679d5102f7da6c4488fd506" translate="yes" xml:space="preserve">
          <source>If session wasn't passed and no default session.</source>
          <target state="translated">세션이 전달되지 않았고 기본 세션이없는 경우.</target>
        </trans-unit>
        <trans-unit id="1052e1262f17b2ce83bec58b3858ca5adcbd4113" translate="yes" xml:space="preserve">
          <source>If set, &lt;code&gt;padding_width&lt;/code&gt; pad values will be added to both sides of each sequence. Defaults to &lt;code&gt;ngram_width&lt;/code&gt;-1. Must be greater than</source>
          <target state="translated">설정하면 &lt;code&gt;padding_width&lt;/code&gt; 패드 값이 각 시퀀스의 양쪽에 추가됩니다. 기본값은 &lt;code&gt;ngram_width&lt;/code&gt; -1입니다. 보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="42713d8f147f419359cb2f9d97685f1b466cd841" translate="yes" xml:space="preserve">
          <source>If set, directory containing summary files with eval metrics. By default, &lt;code&gt;estimator.eval_dir()&lt;/code&gt; will be used.</source>
          <target state="translated">설정된 경우 평가 메트릭이있는 요약 파일이 포함 된 디렉토리입니다. 기본적으로 &lt;code&gt;estimator.eval_dir()&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1b85a897129ee78e5ab69037f1060f3b5a56aa8c" translate="yes" xml:space="preserve">
          <source>If set, initial_value will be converted to the given type. If &lt;code&gt;None&lt;/code&gt;, either the datatype will be kept (if &lt;code&gt;initial_value&lt;/code&gt; is a Tensor), or &lt;code&gt;convert_to_tensor&lt;/code&gt; will decide.</source>
          <target state="translated">설정하면 initial_value가 주어진 유형으로 변환됩니다. 경우 &lt;code&gt;None&lt;/code&gt; , 중 데이터 유형이 유지됩니다 (경우 &lt;code&gt;initial_value&lt;/code&gt; 이 텐서이다), 또는 &lt;code&gt;convert_to_tensor&lt;/code&gt; 가 결정합니다.</target>
        </trans-unit>
        <trans-unit id="0f050a1aecaf98e6e971ad7ddbad7946578f6991" translate="yes" xml:space="preserve">
          <source>If set, it overrides the maximum degree of intra-op parallelism.</source>
          <target state="translated">설정하면 최대 병렬 처리 수준의 병렬 처리보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="406b1726c99d9d0143b0b00beee8d5df87d7ea20" translate="yes" xml:space="preserve">
          <source>If set, the dataset will use a private threadpool of the given size.</source>
          <target state="translated">설정된 경우 데이터 세트는 지정된 크기의 전용 스레드 풀을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ffc52c5a8474455aaec22a4147fbe64f35824f18" translate="yes" xml:space="preserve">
          <source>If set, the first &lt;code&gt;fixed_length&lt;/code&gt; bytes of each element will be converted. Data will be zero-padded or truncated to the specified length.</source>
          <target state="translated">설정되면 각 요소 의 첫 번째 &lt;code&gt;fixed_length&lt;/code&gt; 바이트가 변환됩니다. 데이터는 0으로 채워지거나 지정된 길이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="3647e794d90ebd60c57ea22288d32190cb697002" translate="yes" xml:space="preserve">
          <source>If set, values outside of range &lt;code&gt;[0, num_buckets)&lt;/code&gt; will be replaced with this value. If not set, values &amp;gt;= num_buckets will cause a failure while values &amp;lt; 0 will be dropped.</source>
          <target state="translated">설정하면 &lt;code&gt;[0, num_buckets)&lt;/code&gt; 범위를 벗어난 값 이이 값으로 대체됩니다. 설정하지 않으면&amp;gt; = num_buckets 값은 실패를 일으키고 값 &amp;lt;0은 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="6ce3f4499675c06927ac9cd4d0513f29af599d8a" translate="yes" xml:space="preserve">
          <source>If several adjustments are chained it is advisable to minimize the number of redundant conversions by first converting the images to the most natural data type and representation.</source>
          <target state="translated">여러 조정이 연결되어있는 경우 먼저 이미지를 가장 자연스러운 데이터 유형 및 표현으로 변환하여 중복 변환 수를 최소화하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88e247aff5f095d2ffb3872d7179387704922d50" translate="yes" xml:space="preserve">
          <source>If shape is not convertible to a &lt;a href=&quot;tensorshape&quot;&gt;&lt;code&gt;tf.TensorShape&lt;/code&gt;&lt;/a&gt;, or dtype is not convertible to a &lt;a href=&quot;dtypes/dtype&quot;&gt;&lt;code&gt;tf.DType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">모양을 &lt;a href=&quot;tensorshape&quot;&gt; &lt;code&gt;tf.TensorShape&lt;/code&gt; &lt;/a&gt; 로 변환 할 수 없거나 dtype을 tf.DType으로 변환 할 수 &lt;a href=&quot;dtypes/dtype&quot;&gt; &lt;code&gt;tf.DType&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67c0f7d09583d4af41119ac2d7c50e6404fd2384" translate="yes" xml:space="preserve">
          <source>If shapes are not known during graph construction time, and during run time it is found out that the ranks do not match.</source>
          <target state="translated">그래프 구성 시간 및 런타임 동안 모양을 알 수없는 경우 순위가 일치하지 않는 것으로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="aa925c0adaddfe1830079b9cbafb10c52df9958b" translate="yes" xml:space="preserve">
          <source>If shapes do not conform.</source>
          <target state="translated">모양이 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="bba5d55fa813047e7fe0ec9851608cd7190123e3" translate="yes" xml:space="preserve">
          <source>If shapes is not a list of shapes, or the lengths of dtypes and shapes do not match, or if names is specified and the lengths of dtypes and names do not match.</source>
          <target state="translated">모양이 모양 목록이 아니거나 dtype 및 모양의 길이가 일치하지 않거나 이름이 지정되고 dtype 및 이름의 길이가 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="1814dc3de1048c3554d33e04a6570bd1af7a3688" translate="yes" xml:space="preserve">
          <source>If soft placement is enabled.</source>
          <target state="translated">소프트 배치가 활성화 된 경우</target>
        </trans-unit>
        <trans-unit id="e7fbbf1e215e574da65fd180d3efd4ed7169ba5a" translate="yes" xml:space="preserve">
          <source>If some arguments are invalid.</source>
          <target state="translated">일부 인수가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="74009976d1af3f8ace2767a5d190d7dc5534103a" translate="yes" xml:space="preserve">
          <source>If some of the variables are not &lt;code&gt;Variable&lt;/code&gt; objects.</source>
          <target state="translated">일부 변수가 &lt;code&gt;Variable&lt;/code&gt; 객체 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="188670dc4033de3caf330c736da12315f5461a5c" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; at an interval of &lt;code&gt;run_every_secs&lt;/code&gt; seconds. Defaults to 60 seconds. Either this or &lt;code&gt;run_every_steps&lt;/code&gt; must be set.</source>
          <target state="translated">지정된 경우, 호출은 &lt;code&gt;should_stop_fn&lt;/code&gt; 의 간격으로 &lt;code&gt;run_every_secs&lt;/code&gt; 의 초. 기본값은 60 초입니다. this 또는 &lt;code&gt;run_every_steps&lt;/code&gt; 를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa858aa25d35679553ae73d53e82c00273b66b4f" translate="yes" xml:space="preserve">
          <source>If specified, calls &lt;code&gt;should_stop_fn&lt;/code&gt; every &lt;code&gt;run_every_steps&lt;/code&gt; steps. Either this or &lt;code&gt;run_every_secs&lt;/code&gt; must be set.</source>
          <target state="translated">지정된 경우, 호출은 &lt;code&gt;should_stop_fn&lt;/code&gt; 모든 &lt;code&gt;run_every_steps&lt;/code&gt; 의 단계를. this 또는 &lt;code&gt;run_every_secs&lt;/code&gt; 를 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="21bd4dafdeb31f10310614cb3babca1c0cb7f9de" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has mismatched rank.</source>
          <target state="translated">정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 일치하지 않는 것으로 확인되면 .</target>
        </trans-unit>
        <trans-unit id="94bfd962b0c1330f3e7f6c21b07640c3d065f10e" translate="yes" xml:space="preserve">
          <source>If static checks determine &lt;code&gt;x&lt;/code&gt; has wrong rank.</source>
          <target state="translated">정적 검사에서 &lt;code&gt;x&lt;/code&gt; 의 순위가 잘못되었다고 판단하는 경우 .</target>
        </trans-unit>
        <trans-unit id="b7c4513de4ff5d6eb54788b5e3829e4f82d9ad05" translate="yes" xml:space="preserve">
          <source>If static checks determine any shape constraint is violated.</source>
          <target state="translated">정적 검사에서 형상 제약 조건을 위반 한 것으로 확인되면.</target>
        </trans-unit>
        <trans-unit id="de409eb237796976a466cb4b77c35e672e5c4b3d" translate="yes" xml:space="preserve">
          <source>If supplied, a list of integers which specifies the intended dense shape to run embedding lookup for this feature on TensorCore. The batch dimension can be left None or -1 to indicate a dynamic shape. Only rank 2 shapes currently supported.</source>
          <target state="translated">제공된 경우 TensorCore에서이 기능에 대한 임베딩 조회를 실행하기 위해 의도 된 조밀 한 모양을 지정하는 정수 목록입니다. 배치 차원은 동적 모양을 나타 내기 위해 없음 또는 -1로 둘 수 있습니다. 현재 랭크 2 셰이프 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="4311c10b99cf9dea10540595aa38757622923396" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong shape or type.</source>
          <target state="translated">텐서의 모양이나 유형이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="e4dc9cf7a428ffb3a2a2d1adf68ef64f616003b5" translate="yes" xml:space="preserve">
          <source>If tensor has the wrong type.</source>
          <target state="translated">텐서의 유형이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="dcba33c2663325e71d7455b176c4a928e4d72364" translate="yes" xml:space="preserve">
          <source>If that attempt is unsuccessful (e.g. the dataset is created from a Dataset.range), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this method of sharding is selected. In this case, consider using &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead.</source>
          <target state="translated">해당 시도가 실패하면 (예 : Dataset.range에서 데이터 세트가 생성됨) 처리 파이프 라인 끝에 &lt;code&gt;.shard&lt;/code&gt; 오퍼레이션을 추가하여 마지막에 데이터 세트를 균등하게 샤딩합니다 . 이로 인해 모든 작업자에 대해 모든 데이터에 대한 전체 사전 처리 파이프 라인이 실행되고 각 작업자는 중복 작업을 수행하게됩니다. 이 샤딩 방법을 선택하면 경고가 인쇄됩니다. 이 경우 대신 &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3358bfa17db34ad277d96d5332d507879fea9dd9" translate="yes" xml:space="preserve">
          <source>If the &quot;checkpoint&quot; file contains a valid CheckpointState proto, returns it.</source>
          <target state="translated">&quot;checkpoint&quot;파일에 유효한 CheckpointState proto가 포함되어 있으면이를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7258ed382efb992fab747cb709315af27fa6a0ea" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;distributediterator&quot;&gt;&lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt;&lt;/a&gt; has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="translated">는 IF &lt;a href=&quot;distributediterator&quot;&gt; &lt;code&gt;tf.distribute.DistributedIterator&lt;/code&gt; 이&lt;/a&gt; 순서의 끝에 도달, 반환 &lt;a href=&quot;../experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; 는&lt;/a&gt; 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="c134a85184e534f88d7fb96668ca546c1278640d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Estimator&lt;/code&gt; has not produced a checkpoint yet.</source>
          <target state="translated">경우 &lt;code&gt;Estimator&lt;/code&gt; 아직 체크 포인트를 생산하지 않았다.</target>
        </trans-unit>
        <trans-unit id="40288d720b884ba08bda933b7028c5bbc2ac3f76" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;GraphDef&lt;/code&gt;s do not match.</source>
          <target state="translated">&lt;code&gt;GraphDef&lt;/code&gt; 가 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="51d23a673705ea572eb958c26ad999633860bb8c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Variable&lt;/code&gt; is of type string, this provides an estimate of how large each scalar in the &lt;code&gt;Variable&lt;/code&gt; is.</source>
          <target state="translated">경우 &lt;code&gt;Variable&lt;/code&gt; string 유형이다, 이것은 각 스칼라 방법 대형의 추정치 제공 &lt;code&gt;Variable&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3317e8f03ad0ddae193d8c356cad6a0931714dea" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;choice_dataset&lt;/code&gt; arguments have the wrong type.</source>
          <target state="translated">는 IF &lt;code&gt;datasets&lt;/code&gt; 또는 &lt;code&gt;choice_dataset&lt;/code&gt; 인수는 잘못된 유형이있다.</target>
        </trans-unit>
        <trans-unit id="24f07f80fdcf6b0d82e35cb67ed69ccf18348c88" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;datasets&lt;/code&gt; or &lt;code&gt;weights&lt;/code&gt; arguments have the wrong type.</source>
          <target state="translated">는 IF &lt;code&gt;datasets&lt;/code&gt; 또는 &lt;code&gt;weights&lt;/code&gt; 인수는 잘못된 유형이있다.</target>
        </trans-unit>
        <trans-unit id="c85f20c0c380f317916cf91653305134b56d70aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; method under the same Python namespace has been invoked before, calling this method disables it. If no call to &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; has been made, calling this method is a no-op. Calling this method more than once is idempotent.</source>
          <target state="translated">이전에 동일한 Python 네임 스페이스 에서 &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; 메소드를 호출 한 경우이 메소드를 호출하면 사용 안함으로 설정됩니다. 아무 호출하면 &lt;code&gt;enable_dump_debug_info()&lt;/code&gt; 이루어지지 않았다,이 메소드를 호출하면 (자), 조작은 없다. 이 메소드를 두 번 이상 호출하면 dem 등성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="850f4f3695a83977b57e13df3d06b8e2f6c6277a" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;graph_def&lt;/code&gt; would be too large.</source>
          <target state="translated">는 IF &lt;code&gt;graph_def&lt;/code&gt; 가 너무 큰 것입니다.</target>
        </trans-unit>
        <trans-unit id="5c57e73738d6d60cc61fb52afa5770fd921df6c3" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="translated">는 IF &lt;code&gt;initial_accumulator_value&lt;/code&gt; 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a8e3475ccb7eea2e81161fcedd13db73d199519" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;initial_gradient_squared_accumulator_value&lt;/code&gt; is invalid.</source>
          <target state="translated">는 IF &lt;code&gt;initial_gradient_squared_accumulator_value&lt;/code&gt; 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d77a52bdc6af3b48e4538f386e66464280d5e564" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;inputs&lt;/code&gt; has dynamic shapes and you would like to automatically bucketize the inputs to avoid XLA recompilation. See the advanced example below:</source>
          <target state="translated">는 IF &lt;code&gt;inputs&lt;/code&gt; 동적 모양을 가지고 있으며, 자동 XLA 재 컴파일을 방지하기 위해 입력을 bucketize 싶습니다. 아래의 고급 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5ec1331f66efc3c89fcaeb5f189cdbc3f3c7a5f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shape[split_dim]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt;. Slices &lt;code&gt;[0 : shape[split_dim] % num_split]&lt;/code&gt; gets one extra dimension. For example, if &lt;code&gt;split_dim = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is</source>
          <target state="translated">경우] &lt;code&gt;shape[split_dim]&lt;/code&gt; 정수 배가 아닌 &lt;code&gt;num_split&lt;/code&gt; . 슬라이스 &lt;code&gt;[0 : shape[split_dim] % num_split]&lt;/code&gt; 은 하나의 추가 차원을 얻습니다. 예를 들어, &lt;code&gt;split_dim = 1&lt;/code&gt; 이고 &lt;code&gt;num_split = 2&lt;/code&gt; 이고 입력이</target>
        </trans-unit>
        <trans-unit id="58ba5c8db0186a187e8ec3f75cb6e513ca601471" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensor_list_list&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;shapes&lt;/code&gt; 지정되지 않은, 그리고 요소로부터 유추 할 수없는 &lt;code&gt;tensor_list_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24aa66c5edeb6fff7370d5b6a8be818bade3ce0b" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;shapes&lt;/code&gt; 지정되지 않은, 그리고 요소로부터 유추 할 수없는 &lt;code&gt;tensors&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e5484cde99e3216708fd00c33daac67c9c0ad62" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; are not specified, and cannot be inferred from the elements of &lt;code&gt;tensors_list&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;shapes&lt;/code&gt; 지정되지 않은, 그리고 요소로부터 유추 할 수없는 &lt;code&gt;tensors_list&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a32d73aea60310abf91b1e01ff102173ff94bf4c" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;shapes&lt;/code&gt; argument is specified, each component of a queue element must have the respective fixed shape. If it is unspecified, different queue elements may have different shapes, but the use of &lt;code&gt;dequeue_many&lt;/code&gt; is disallowed.</source>
          <target state="translated">상기 중간 &lt;code&gt;shapes&lt;/code&gt; 인수 지정된 큐 소자의 각 구성 요소는 각각의 고정 된 형상을 가져야한다. 지정하지 않으면 다른 큐 요소의 모양이 다를 수 있지만 &lt;code&gt;dequeue_many&lt;/code&gt; 사용 은 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7226982fe5b09f7a9182c06848094e1377702d50" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;signatures&lt;/code&gt; argument is omitted, &lt;code&gt;obj&lt;/code&gt; will be searched for &lt;code&gt;@tf.function&lt;/code&gt;-decorated methods. If exactly one &lt;code&gt;@tf.function&lt;/code&gt; is found, that method will be used as the default signature for the SavedModel. This behavior is expected to change in the future, when a corresponding &lt;a href=&quot;load&quot;&gt;&lt;code&gt;tf.saved_model.load&lt;/code&gt;&lt;/a&gt; symbol is added. At that point signatures will be completely optional, and any &lt;code&gt;@tf.function&lt;/code&gt; attached to &lt;code&gt;obj&lt;/code&gt; or its dependencies will be exported for use with &lt;code&gt;load&lt;/code&gt;.</source>
          <target state="translated">는 IF &lt;code&gt;signatures&lt;/code&gt; 인수를 생략, &lt;code&gt;obj&lt;/code&gt; 검색됩니다 &lt;code&gt;@tf.function&lt;/code&gt; 방법을 -decorated. 정확히 하나의 &lt;code&gt;@tf.function&lt;/code&gt; 을 찾으면 해당 메소드가 SavedModel의 기본 서명으로 사용됩니다. 이 동작은 해당 &lt;a href=&quot;load&quot;&gt; &lt;code&gt;tf.saved_model.load&lt;/code&gt; &lt;/a&gt; 기호가 추가 될 때 향후 변경 될 것으로 예상 됩니다. 이 시점에서 서명은 완전히 선택 사항이며 &lt;code&gt;obj&lt;/code&gt; 또는 해당 종속 &lt;code&gt;@tf.function&lt;/code&gt; 연결된 @ tf.function 은 &lt;code&gt;load&lt;/code&gt; 와 함께 사용하기 위해 내보내집니다 .</target>
        </trans-unit>
        <trans-unit id="7fd7e686a1dc65c75a2588abd9db94c81edb3064" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; is not an integer multiple of &lt;code&gt;num_split&lt;/code&gt; each slice starting from 0:&lt;code&gt;shape[axis] % num_split&lt;/code&gt; gets extra one dimension. For example, if &lt;code&gt;axis = 1&lt;/code&gt; and &lt;code&gt;num_split = 2&lt;/code&gt; and the input is:</source>
          <target state="translated">경우] &lt;code&gt;sp_input.dense_shape[axis]&lt;/code&gt; 정수 배가 아닌 &lt;code&gt;num_split&lt;/code&gt; 는 0부터 각 슬라이스 : &lt;code&gt;shape[axis] % num_split&lt;/code&gt; 여분의 하나의 사이즈를 얻는다. 예를 들어, &lt;code&gt;axis = 1&lt;/code&gt; 이고 &lt;code&gt;num_split = 2&lt;/code&gt; 이고 입력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57e7719d24c0316d5621496138e5a812699ce17f" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stride&lt;/code&gt; parameter is greater than 1, then each window will skip &lt;code&gt;(stride - 1)&lt;/code&gt; input elements between each element that appears in the window. Output windows will still contain &lt;code&gt;size&lt;/code&gt; elements regardless of the value of &lt;code&gt;stride&lt;/code&gt;.</source>
          <target state="translated">경우] &lt;code&gt;stride&lt;/code&gt; 파라미터는 1보다 큰 경우, 각 윈도우는 이동한다 &lt;code&gt;(stride - 1)&lt;/code&gt; 창에 표시하는 각 구성 요소 사이의 입력 요소. 출력 창에는 &lt;code&gt;stride&lt;/code&gt; 값에 관계없이 여전히 &lt;code&gt;size&lt;/code&gt; 요소 가 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="de3eb54590375091b7c8a0790f145904bd9715ba" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;filters&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="translated">상기 중간 &lt;code&gt;value&lt;/code&gt; 깊이는 일치하지 않는 &lt;code&gt;filters&lt;/code&gt; '모양, 또는 패딩이 아닌 경우 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2801a9f9503028fe01b709b764a0b08f0e710d4" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; depth does not match &lt;code&gt;kernel&lt;/code&gt;' shape, or if padding is other than &lt;code&gt;'VALID'&lt;/code&gt; or &lt;code&gt;'SAME'&lt;/code&gt;.</source>
          <target state="translated">상기 중간 &lt;code&gt;value&lt;/code&gt; 깊이는 일치하지 않는 &lt;code&gt;kernel&lt;/code&gt; '모양, 또는 패딩이 아닌 경우 &lt;code&gt;'VALID'&lt;/code&gt; 또는 &lt;code&gt;'SAME'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4350b881d5074f040b3c42be06cd154a0ce36814" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;value&lt;/code&gt; is a tensor not of given &lt;code&gt;dtype&lt;/code&gt; in graph mode.</source>
          <target state="translated">&lt;code&gt;value&lt;/code&gt; 이 그래프 모드에서 주어진 &lt;code&gt;dtype&lt;/code&gt; 이 아닌 텐서 인 경우 .</target>
        </trans-unit>
        <trans-unit id="130adade1f1a1eb5f1353a2cb7fb49bd034b04c8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;weights&lt;/code&gt; argument is specified and does not match the length of the &lt;code&gt;datasets&lt;/code&gt; element.</source>
          <target state="translated">경우 &lt;code&gt;weights&lt;/code&gt; 인수가 지정되고의 길이와 일치하지 않는 &lt;code&gt;datasets&lt;/code&gt; 요소를.</target>
        </trans-unit>
        <trans-unit id="06af6343f99ab2414ab6f7df25e2f6714e027807" translate="yes" xml:space="preserve">
          <source>If the Kubernetes Python client is not installed and no &lt;code&gt;override_client&lt;/code&gt; is passed in.</source>
          <target state="translated">Kubernetes Python 클라이언트가 설치되어 있지 않고 &lt;code&gt;override_client&lt;/code&gt; 가 전달 되지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="fd5d5a953bc259f0271e19fc5d6c07aed62f3c39" translate="yes" xml:space="preserve">
          <source>If the SavedModel directory already exists and isn't empty.</source>
          <target state="translated">SavedModel 디렉토리가 이미 존재하고 비어 있지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="adb08920384c4a4c56e663c608090b5d9d7a8070" translate="yes" xml:space="preserve">
          <source>If the WarmStartSettings contains prev_var_name or VocabInfo configuration for variable names that are not used. This is to ensure a stronger check for variable configuration than relying on users to examine the logs.</source>
          <target state="translated">WarmStartSettings에 사용되지 않는 변수 이름에 대한 prev_var_name 또는 VocabInfo 구성이 포함 된 경우. 이는 사용자가 로그를 조사하는 것보다 변수 구성을보다 강력하게 확인하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="aeef1d7dca0a515d92122f1e23dc5bfa84989757" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">위의 일괄 분할 및 데이터 세트 분할 논리가 바람직 하지 않은 경우 자동 분할 또는 분할을 수행하지 않는 &lt;a href=&quot;../../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 대신 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="12dc57ccab95dcb91583b36ab94e270b350ccee7" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">위의 일괄 분할 및 데이터 세트 분할 논리가 바람직 하지 않은 경우 자동 분할 또는 분할을 수행하지 않는 &lt;a href=&quot;../../../distribute/strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 대신 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="b57079beaf471dbb9d3f9aeebd7728587fba24ba" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">위의 일괄 분할 및 데이터 세트 분할 논리가 바람직 하지 않은 경우 자동 분할 또는 분할을 수행하지 않는 &lt;a href=&quot;../strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 대신 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="406a399aec9f3ac354fde4744023824e2671b245" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt;&lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt;&lt;/a&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">위의 일괄 분할 및 데이터 세트 분할 논리가 바람직 하지 않은 경우 자동 분할 또는 분할을 수행하지 않는 &lt;a href=&quot;strategy#experimental_distribute_datasets_from_function&quot;&gt; &lt;code&gt;tf.distribute.Strategy.experimental_distribute_datasets_from_function&lt;/code&gt; 을&lt;/a&gt; 대신 사용하세요 .</target>
        </trans-unit>
        <trans-unit id="112da864d4b1f24e488ea72104bf36a2900d9125" translate="yes" xml:space="preserve">
          <source>If the above batch splitting and dataset sharding logic is undesirable, please use &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; instead, which does not do any automatic splitting or sharding.</source>
          <target state="translated">위의 일괄 분할 및 데이터 세트 샤딩 로직이 바람직 하지 않은 경우 자동 분할 또는 샤딩을 수행하지 않는 &lt;code&gt;experimental_distribute_datasets_from_function&lt;/code&gt; 대신 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c05cf6d5da583a19c043c4546b8addef87e9dda3" translate="yes" xml:space="preserve">
          <source>If the answer to several of these questions is yes, consider converting the &lt;code&gt;SparseTensor&lt;/code&gt; to a dense one and using &lt;a href=&quot;../linalg/matmul&quot;&gt;&lt;code&gt;tf.matmul&lt;/code&gt;&lt;/a&gt; with &lt;code&gt;a_is_sparse=True&lt;/code&gt;.</source>
          <target state="translated">이러한 몇 가지 질문에 대한 대답이 예인 경우 &lt;code&gt;SparseTensor&lt;/code&gt; 를 밀도가 높은 것으로 변환하고 &lt;code&gt;a_is_sparse=True&lt;/code&gt; 와 함께 tf.matmul을 사용 &lt;a href=&quot;../linalg/matmul&quot;&gt; &lt;code&gt;tf.matmul&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03d4d4ad09e2435c621916ddd6a1d50f3469707d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;dtype&lt;/code&gt; is not specified, then the type is inferred from the type of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;dtype&lt;/code&gt; 을 지정하지 않으면 type은 &lt;code&gt;value&lt;/code&gt; 유형에서 유추됩니다 .</target>
        </trans-unit>
        <trans-unit id="a7a755586c48ee50759898fa7c989f8e67d40736" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;global_step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">&lt;code&gt;staircase&lt;/code&gt; 인수 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;global_step / decay_steps&lt;/code&gt; 는 정수 나누기이며 감쇠 학습률은 계단 함수를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d1f01cc54fa41c0d32fd1e24bafe662f494d520d" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;staircase&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;step / decay_steps&lt;/code&gt; is an integer division and the decayed learning rate follows a staircase function.</source>
          <target state="translated">인수 &lt;code&gt;staircase&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;step / decay_steps&lt;/code&gt; 는 정수 나누기이며 감쇠 된 학습률은 계단 함수를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="e346c3059dbd94f214dc5577c884d86380f954b5" translate="yes" xml:space="preserve">
          <source>If the arguments are not an allowed type.</source>
          <target state="translated">인수가 허용 된 유형이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="8963d4f9837f2142579419ad4b548a6f26586097" translate="yes" xml:space="preserve">
          <source>If the arguments do not have the appropriate type.</source>
          <target state="translated">인수에 적절한 유형이없는 경우.</target>
        </trans-unit>
        <trans-unit id="6f8ebe15b04c5c4a7996a68d6b6095e7fba23d0d" translate="yes" xml:space="preserve">
          <source>If the arguments have the wrong type.</source>
          <target state="translated">인수의 유형이 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="f5461a118a1f9cee1e8fdbbebb257329c594b169" translate="yes" xml:space="preserve">
          <source>If the attempt to shard by file is unsuccessful (i.e. the dataset is not read from files), we will shard the dataset evenly at the end by appending a &lt;code&gt;.shard&lt;/code&gt; operation to the end of the processing pipeline. This will cause the entire preprocessing pipeline for all the data to be run on every worker, and each worker will do redundant work. We will print a warning if this route is selected.</source>
          <target state="translated">파일로 분할하려는 시도가 실패한 경우 (즉, 데이터 세트가 파일에서 읽히지 않음) 처리 파이프 라인 끝에 &lt;code&gt;.shard&lt;/code&gt; 작업을 추가하여 데이터 세트를 균등하게 분할 합니다. 이렇게하면 모든 데이터에 대한 전체 전처리 파이프 라인이 모든 작업자에서 실행되고 각 작업자는 중복 작업을 수행합니다. 이 경로가 선택되면 경고를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="55881dcd47167c577d9f3a17b426b645d5d9a3a1" translate="yes" xml:space="preserve">
          <source>If the attribute cannot be found.</source>
          <target state="translated">속성을 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="a38c88d9d6337fe7cece5f81a29f0e638b688c37" translate="yes" xml:space="preserve">
          <source>If the checkpoint has not been consumed completely, then the list of restore ops will grow as more objects are added to the dependency graph.</source>
          <target state="translated">검사 점이 완전히 소비되지 않은 경우 종속성 그래프에 더 많은 개체가 추가되면 복원 작업 목록이 커집니다.</target>
        </trans-unit>
        <trans-unit id="a6f46ebca037e3275747c4060df65546e7f35655" translate="yes" xml:space="preserve">
          <source>If the clip_norm tensor is not a 0-D scalar tensor.</source>
          <target state="translated">clip_norm 텐서가 0D 스칼라 텐서가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="322354248713025e3d6689fb7a7b7d477c48e541" translate="yes" xml:space="preserve">
          <source>If the code being run raises an exception, that exception is reported to the coordinator and the thread terminates. The coordinator will then request all the other threads it coordinates to stop.</source>
          <target state="translated">실행중인 코드에서 예외가 발생하면 해당 예외가 코디네이터에게보고되고 스레드가 종료됩니다. 그런 다음 코디네이터는 조정하려는 다른 모든 스레드를 중지하도록 요청합니다.</target>
        </trans-unit>
        <trans-unit id="d7979f58f3ff709afb03169a221ab568ed8d0b58" translate="yes" xml:space="preserve">
          <source>If the collection exists, this returns the list itself, which can be modified in place to change the collection. If the collection does not exist, it is created as an empty list and the list is returned.</source>
          <target state="translated">컬렉션이 존재하면 컬렉션 자체를 수정하기 위해 수정 될 수있는 목록 자체가 반환됩니다. 컬렉션이 존재하지 않으면 빈 목록으로 만들어지고 목록이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16e2e93d9e738ccca07e48ed484e074d5b9423d1" translate="yes" xml:space="preserve">
          <source>If the coordinates are both normalized and centered, they range from -1.0 to 1.0. The coordinates (-1.0, -1.0) correspond to the upper left corner, the lower right corner is located at (1.0, 1.0) and the center is at (0, 0).</source>
          <target state="translated">좌표가 정규화되고 중심이되면 -1.0에서 1.0 사이입니다. 좌표 (-1.0, -1.0)는 왼쪽 위 모서리에 해당하고 오른쪽 아래 모서리는 (1.0, 1.0)에 있으며 가운데는 (0, 0)에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ff57f39749c34bbe8fe0401b61997435557e382" translate="yes" xml:space="preserve">
          <source>If the coordinates are normalized but not centered, 0.0 and 1.0 correspond to the minimum and maximum of each height and width dimension.</source>
          <target state="translated">좌표가 정규화되었지만 중앙에 있지 않은 경우 0.0 및 1.0은 각 높이 및 너비 치수의 최소 및 최대에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="ccc9ff36ea56cfa9e765b3c8d0c91355e08ae564" translate="yes" xml:space="preserve">
          <source>If the coordinates are not normalized they are interpreted as numbers of pixels.</source>
          <target state="translated">좌표가 정규화되지 않으면 픽셀 수로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0a9b966bb81ad2605ac867ad5ef2ce7ea8c2375c" translate="yes" xml:space="preserve">
          <source>If the current thread has no default &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt;.</source>
          <target state="translated">현재 스레드에 기본 &lt;code&gt;tf.contrib.summary.SummaryWriter&lt;/code&gt; 가없는 경우 .</target>
        </trans-unit>
        <trans-unit id="a9db9b059080921cd6c062dbce6bf5607f4a3a62" translate="yes" xml:space="preserve">
          <source>If the dataset length is unknown or infinite, or if eager execution is not enabled.</source>
          <target state="translated">데이터 세트 길이를 알 수 없거나 무한한 경우 또는 즉시 실행이 활성화되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="4ea3d6caf73fa0c188e4b9504d662b3328e66ed1" translate="yes" xml:space="preserve">
          <source>If the default option of sharding the saved dataset was used, the element order of the saved dataset will be preserved when loading it.</source>
          <target state="translated">저장된 데이터 셋을 분할하는 기본 옵션이 사용 된 경우 저장된 데이터 셋의 요소 순서는로드 할 때 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d9562bf6c9ebf00a96c5a59cf2cf0460fffaaaae" translate="yes" xml:space="preserve">
          <source>If the deprecated &lt;code&gt;split_dim&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt; are both non None.</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;split_dim&lt;/code&gt; 및 &lt;code&gt;axis&lt;/code&gt; 가 모두 None이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="25f2c255dc162a384dc28be1433b4029caea49f5" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">차원이 상수이면 (예 : &lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 차원에서 해당 길이까지 채워집니다.</target>
        </trans-unit>
        <trans-unit id="791f44cfdf8ef290ec842dbce59a72390416ce7a" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">차원이 상수이면 (예 : &lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 차원에서 해당 길이까지 채워집니다.</target>
        </trans-unit>
        <trans-unit id="e002c71d640bbe2622e030008cf7b64978256ffa" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">차원이 상수이면 (예 : &lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 차원에서 해당 길이까지 채워집니다.</target>
        </trans-unit>
        <trans-unit id="191bc9524d6bf196a57d9a494c82f21595b508cf" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to that length in that dimension.</source>
          <target state="translated">차원이 상수이면 (예 : &lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(37)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 차원에서 해당 길이까지 채워집니다.</target>
        </trans-unit>
        <trans-unit id="8ee6305f8f5ea21e225c1270e43da8cf1fa7c5eb" translate="yes" xml:space="preserve">
          <source>If the dimension is a constant, the component will be padded out to that length in that dimension.</source>
          <target state="translated">치수가 상수 인 경우 구성 요소는 해당 치수의 해당 길이로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="340852a05739f6c28dacec87f71405e50e7f1da1" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">치수를 알 수없는 경우 (예 : &lt;a href=&quot;../../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 치수에있는 모든 요소의 최대 길이로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="552f501db3f78e9dbef2993feeab6983fea583c8" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">치수를 알 수없는 경우 (예 : &lt;a href=&quot;../../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 치수에있는 모든 요소의 최대 길이로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="5bdf9b1d41ce2f6dc0c751ffe579fd03e7de2703" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../compat/v1/dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">치수를 알 수없는 경우 (예 : &lt;a href=&quot;../compat/v1/dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 치수에있는 모든 요소의 최대 길이로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="eb0dd7527d5cb7b1a0e894b67170a54d79baca84" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown (e.g. &lt;a href=&quot;../dimension&quot;&gt;&lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt;&lt;/a&gt;), the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">치수를 알 수없는 경우 (예 : &lt;a href=&quot;../dimension&quot;&gt; &lt;code&gt;tf.compat.v1.Dimension(None)&lt;/code&gt; &lt;/a&gt; ) 구성 요소는 해당 치수에있는 모든 요소의 최대 길이로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="a8bfe46894536a1da19abd0f232f48aef12d3373" translate="yes" xml:space="preserve">
          <source>If the dimension is unknown, the component will be padded out to the maximum length of all elements in that dimension.</source>
          <target state="translated">치수를 알 수없는 경우 구성 요소는 해당 치수에있는 모든 요소의 최대 길이까지 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7cd57dc9acb453b70e46365a7208d407f12c6c9d" translate="yes" xml:space="preserve">
          <source>If the dtype is not floating point</source>
          <target state="translated">dtype이 부동 소수점이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="6fbb6086ed5b3f6f6f1921ca38eed44d66ed5c39" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric or boolean.</source>
          <target state="translated">dtype이 숫자 또는 부울이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="44fab38327b7bc8adbedea6107ee772a4670d5cf" translate="yes" xml:space="preserve">
          <source>If the dtype is not numeric.</source>
          <target state="translated">dtype이 숫자가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="ad56bd7d35410bb8c499cb702a271e4c16b2c44e" translate="yes" xml:space="preserve">
          <source>If the entity could not be converted.</source>
          <target state="translated">엔티티를 변환 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="ac307030ed380432cc7d8c7f0c1aee738c5a7f19" translate="yes" xml:space="preserve">
          <source>If the exception is an OpError, the op stack is also included in the message predicate search.</source>
          <target state="translated">예외가 OpError 인 경우 op 스택은 메시지 술어 검색에도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="3d22d4ab8d6d8dcc370d2b9e225550b1aaf6aab5" translate="yes" xml:space="preserve">
          <source>If the existing scope already has the given variables.</source>
          <target state="translated">기존 범위에 이미 주어진 변수가있는 경우.</target>
        </trans-unit>
        <trans-unit id="fcaf8005ea2c08911435025591bcbbf4aad115b1" translate="yes" xml:space="preserve">
          <source>If the file exists, it will be overwritten.</source>
          <target state="translated">파일이 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="7dfe25f9b58e72feb123504aceee09af71a08930" translate="yes" xml:space="preserve">
          <source>If the first entry of a shape is &lt;code&gt;...&lt;/code&gt; (type &lt;code&gt;Ellipsis&lt;/code&gt;) or '*' that indicates a variable number of outer dimensions of unspecified size, i.e. the constraint applies to the inner-most dimensions only.</source>
          <target state="translated">모양의 첫 번째 항목이 지정되지 않은 크기의 가변적 인 외부 치수 수를 나타내는 &lt;code&gt;...&lt;/code&gt; ( &lt;code&gt;Ellipsis&lt;/code&gt; 유형 ) 또는 '*'인 경우, 구속 조건은 가장 안쪽의 치수에만 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3897e75c09282eed9bd085faaf64f74b8d961c5c" translate="yes" xml:space="preserve">
          <source>If the function is expressible as TensorFlow ops, use:</source>
          <target state="translated">함수가 TensorFlow ops로 표현 가능한 경우 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="71d42c11a5bae209f5c9a583478a2ea75e6c109c" translate="yes" xml:space="preserve">
          <source>If the function returns a false boolean value then the iterator resumes the wait for new checkpoints. At this point the timeout logic applies again.</source>
          <target state="translated">함수가 false 부울 값을 리턴하면 반복기는 새 체크 포인트 대기를 재개합니다. 이 시점에서 타임 아웃 로직이 다시 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="92539ae5f5eea4cb1a88d428f58d55fcd395ace7" translate="yes" xml:space="preserve">
          <source>If the given TensorArray gradient already exists, returns a reference to it.</source>
          <target state="translated">주어진 TensorArray 그래디언트가 이미 존재하는 경우 이에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="36167bdd84c2e1b5bd383edebcbb2793bbc3bfe8" translate="yes" xml:space="preserve">
          <source>If the given local job name is not present in the cluster specification, it will be automatically added, using an unused port on the localhost.</source>
          <target state="translated">지정된 로컬 작업 이름이 클러스터 스펙에 없으면 로컬 호스트에서 사용되지 않은 포트를 사용하여 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ebfcc47390b8469a3d9d1e9bff51d80dfd3f6b82" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">제공된 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 가 음수이면 값이 삭제되고 세그먼트 합계에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="51397e8be959c9339c89ea29fb852fcfaf3a6efa" translate="yes" xml:space="preserve">
          <source>If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, then the corresponding value is dropped, and will not be included in the result.</source>
          <target state="translated">주어진 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 가 음수이면 해당 값이 삭제되고 결과에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05fe8b0760cfbd76be7917dd8b4c1ecc11a9be28" translate="yes" xml:space="preserve">
          <source>If the global seed is set but the operation seed is not set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">전역 시드가 설정되었지만 작업 시드가 설정되지 않은 경우 임의 op에 대한 모든 호출에 대해 결과가 다르지만 프로그램을 다시 실행할 때마다 동일한 순서가 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1cb1ccdb9d0fb5cdc68def8fd22357b5d55b9a41" translate="yes" xml:space="preserve">
          <source>If the global step tensor has a non-integer type, or if it is not a &lt;code&gt;Variable&lt;/code&gt;.</source>
          <target state="translated">전역 단계 텐서에 정수가 아닌 유형이 있거나 &lt;code&gt;Variable&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="37adaeda8b3d990b4e6abd16ea3a36a4fae5fd30" translate="yes" xml:space="preserve">
          <source>If the googleapiclient is not installed.</source>
          <target state="translated">googleapiclient가 설치되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="07c722d6a3fdb4516b25d1b44abbde8c28b71d62" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is empty.</source>
          <target state="translated">grads_and_vars가 비어있는 경우.</target>
        </trans-unit>
        <trans-unit id="044a241e356a4ce21f0db32daa27e993efe355cd" translate="yes" xml:space="preserve">
          <source>If the grads_and_vars is malformed.</source>
          <target state="translated">grads_and_vars가 잘못된 경우.</target>
        </trans-unit>
        <trans-unit id="975a2d5b2c4bf3df8f3609b1a1d61c4de3349336" translate="yes" xml:space="preserve">
          <source>If the graph contains any numeric operations in a control flow structure.</source>
          <target state="translated">그래프에 제어 흐름 구조의 숫자 연산이 포함 된 경우.</target>
        </trans-unit>
        <trans-unit id="bba86599b1172a9ff9081ad6d128cd8a8ab922af" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is not set, but the operation seed is set: A default graph-level seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">그래프 수준 시드가 설정되지 않았지만 작업 시드가 설정된 경우 : 기본 그래프 수준 시드 및 지정된 작업 시드가 임의 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2b1abeab43afe5e63d9f398a048dcc795e5cb2b2" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically (determined by the current graph size) picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence.</source>
          <target state="translated">그래프 수준 시드가 설정되어 있지만 작업 시드가 설정되어 있지 않은 경우 : 시스템이 결정적으로 (현재 그래프 크기로 결정) 그래프 수준 시드와 함께 연산 시드를 선택하여 고유 한 임의 시퀀스를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="2074e1b9dbac3bfaead9cf32a369b30715a5e3a0" translate="yes" xml:space="preserve">
          <source>If the graph-level seed is set, but the operation seed is not: The system deterministically picks an operation seed in conjunction with the graph-level seed so that it gets a unique random sequence. Within the same version of tensorflow and user code, this sequence is deterministic. However across different versions, this sequence might change. If the code depends on particular seeds to work, specify both graph-level and operation-level seeds explicitly.</source>
          <target state="translated">그래프 수준 시드가 설정되어 있지만 작업 시드가 설정되지 않은 경우 : 시스템은 고유 한 임의 시퀀스를 얻도록 그래프 수준 시드와 함께 작업 시드를 결정적으로 선택합니다. 동일한 버전의 tensorflow 및 사용자 코드 내에서이 시퀀스는 결정적입니다. 그러나 다른 버전에서이 순서는 변경 될 수 있습니다. 코드가 작동 할 특정 시드에 의존하는 경우 그래프 수준 및 작업 수준 시드를 명시 적으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="273dd82b098bc3f4a8d0ecbea77a28fe92b0cc88" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(embedding_weights)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="translated">id 공간이 파티션 수를 균등하게 나누지 않으면 첫 번째 &lt;code&gt;(max_id + 1) % len(embedding_weights)&lt;/code&gt; 파티션 각각에 하나 이상의 ID가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="4d56891a8942eff2e058fb60914ffc8f8e21bff9" translate="yes" xml:space="preserve">
          <source>If the id space does not evenly divide the number of partitions, each of the first &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; partitions will be assigned one more id.</source>
          <target state="translated">id 공간이 파티션 수를 균등하게 나누지 않으면 첫 번째 &lt;code&gt;(max_id + 1) % len(params)&lt;/code&gt; 파티션 각각에 하나 이상의 ID가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="94b8c3b3a987d5c982d1d7b66e503b4bb62627ad" translate="yes" xml:space="preserve">
          <source>If the indices in &lt;code&gt;key&lt;/code&gt; have an unsupported type.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 의 인덱스에 지원되지 않는 유형이있는 경우.</target>
        </trans-unit>
        <trans-unit id="f945cc45b60ebd8654614b2026ef5c9e8db51451" translate="yes" xml:space="preserve">
          <source>If the initial &lt;code&gt;ndims&lt;/code&gt; of &lt;code&gt;ref&lt;/code&gt;, &lt;code&gt;indices&lt;/code&gt;, and &lt;code&gt;updates&lt;/code&gt; are not the same.</source>
          <target state="translated">초기의 경우 &lt;code&gt;ndims&lt;/code&gt; 의 &lt;code&gt;ref&lt;/code&gt; , &lt;code&gt;indices&lt;/code&gt; 및 &lt;code&gt;updates&lt;/code&gt; 동일하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d9da5b2044d1a6c27127643a17ee6306fc4af59c" translate="yes" xml:space="preserve">
          <source>If the initial value is not specified, or does not have a shape and &lt;code&gt;validate_shape&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">초기 값이 지정되지 않았거나 모양이없고 &lt;code&gt;validate_shape&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 .</target>
        </trans-unit>
        <trans-unit id="ef2419d82193089ac5125bbee3f22c17cb283853" translate="yes" xml:space="preserve">
          <source>If the initializer cannot create a tensor of the requested dtype.</source>
          <target state="translated">이니셜 라이저가 요청 된 dtype의 텐서를 만들 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="e6d4dc856ab835ed492ac9cb4bd626e0cdeb79ec" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;, The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="translated">입력 &lt;code&gt;indices&lt;/code&gt; 가 순위 &lt;code&gt;N&lt;/code&gt; 이면 출력은 순위 &lt;code&gt;N+1&lt;/code&gt; 이고 새 축은 차원 &lt;code&gt;axis&lt;/code&gt; 생성됩니다 (기본값 : 새 축이 끝에 추가됨).</target>
        </trans-unit>
        <trans-unit id="05b0de00712b693414eb54609b6c524990f67c51" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;indices&lt;/code&gt; is rank &lt;code&gt;N&lt;/code&gt;, the output will have rank &lt;code&gt;N+1&lt;/code&gt;. The new axis is created at dimension &lt;code&gt;axis&lt;/code&gt; (default: the new axis is appended at the end).</source>
          <target state="translated">입력 &lt;code&gt;indices&lt;/code&gt; 가 순위 &lt;code&gt;N&lt;/code&gt; 인 경우 출력의 순위는 &lt;code&gt;N+1&lt;/code&gt; 입니다. 새 축은 치수 &lt;code&gt;axis&lt;/code&gt; 작성됩니다 (기본값 : 새 축이 끝에 추가됨).</target>
        </trans-unit>
        <trans-unit id="17fd4b6f3df9f76ded25e1a15c4bac4ee5a468ba" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;value&lt;/code&gt; is not one of the expected types.</source>
          <target state="translated">입력 &lt;code&gt;value&lt;/code&gt; 이 예상 유형 중 하나가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="bc46517b63dc57aa5b1ac644c2f1d4dc634d82fc" translate="yes" xml:space="preserve">
          <source>If the input arguments contain multiple &lt;code&gt;RaggedTensor&lt;/code&gt;s, then they must have identical &lt;code&gt;nested_row_splits&lt;/code&gt;.</source>
          <target state="translated">입력 인수에 여러 개의 &lt;code&gt;RaggedTensor&lt;/code&gt; 가 포함 된 경우 동일한 &lt;code&gt;nested_row_splits&lt;/code&gt; 가 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f2a67481586f4794a55075ae0b8d77938a8ca45c" translate="yes" xml:space="preserve">
          <source>If the input comes from a QuantizedRelu6, the output type is quint8 (range of 0-255) but the possible range of QuantizedRelu6 is 0-6. The min_range and max_range values are therefore 0.0 and 6.0. Dequantize on quint8 will take each value, cast to float, and multiply by 6 / 255. Note that if quantizedtype is qint8, the operation will additionally add each value by 128 prior to casting.</source>
          <target state="translated">입력이 QuantizedRelu6에서 온 경우, 출력 유형은 quint8 (0-255 범위)이지만 QuantizedRelu6의 가능한 범위는 0-6입니다. 따라서 min_range 및 max_range 값은 0.0과 6.0입니다. quint8에서 역 양자화는 각 값을 가져 와서 부동으로 캐스트하고 6/255를 곱합니다. 양자화 유형이 qint8 인 경우, 조작은 캐스트 전에 각 값을 128 씩 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6426b4bfc81de4b1c9b426a44f2ae50a814240f6" translate="yes" xml:space="preserve">
          <source>If the input datatype &lt;code&gt;T&lt;/code&gt; is larger than the output datatype &lt;code&gt;type&lt;/code&gt; then the shape changes from [...] to [..., sizeof(&lt;code&gt;T&lt;/code&gt;)/sizeof(&lt;code&gt;type&lt;/code&gt;)].</source>
          <target state="translated">입력 데이터 유형 &lt;code&gt;T&lt;/code&gt; 가 출력 데이터 유형 &lt;code&gt;type&lt;/code&gt; 보다 크면 모양이 [...]에서 [..., sizeof ( &lt;code&gt;T&lt;/code&gt; ) / sizeof ( &lt;code&gt;type&lt;/code&gt; ))로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="ad23e3edc7d3493eaa2fe45269414dec76430c00" translate="yes" xml:space="preserve">
          <source>If the input height/width is even and the target height/width is odd (or inversely), the input image is left-padded by 1 pixel.</source>
          <target state="translated">입력 높이 / 너비가 짝수이고 대상 높이 / 너비가 홀수 (또는 역으로)이면 입력 이미지에 1 픽셀 씩 왼쪽이 채워집니다.</target>
        </trans-unit>
        <trans-unit id="3d4571fc930ec815d2a6c8980432dbfead6d756c" translate="yes" xml:space="preserve">
          <source>If the input ids are ragged tensors, partition variables are not supported and the partition strategy and the max_norm are ignored. The results of the lookup are concatenated into a dense tensor. The returned tensor has shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt;.</source>
          <target state="translated">입력 ID가 비정형 텐서 인 경우 파티션 변수가 지원되지 않으며 파티션 전략 및 max_norm이 무시됩니다. 조회 결과는 조밀 한 텐서로 연결됩니다. 반환 된 텐서는 shape &lt;code&gt;shape(ids) + shape(params)[1:]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="35273ad2487bd080e83fb5c9ed1a4b3f1830c00d" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="translated">입력 값이 벡터 (순위 -1) 인 경우 벡터에서 &lt;code&gt;k&lt;/code&gt; 개의 가장 큰 항목을 찾고 해당 값과 인덱스를 벡터로 출력합니다. 따라서 &lt;code&gt;values[j]&lt;/code&gt; 는 &lt;code&gt;input&lt;/code&gt; 에서 &lt;code&gt;j&lt;/code&gt; 번째로 큰 항목 이고 인덱스는 &lt;code&gt;indices[j]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="efd823ef3819942e402b7fb91e3ba05b9a1b32f9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank-1), finds the entries which is the nth-smallest value in the vector and outputs their values as scalar tensor.</source>
          <target state="translated">입력 값이 벡터 (rank-1)이면 벡터에서 n 번째로 작은 항목을 찾아 그 값을 스칼라 텐서로 출력합니다.</target>
        </trans-unit>
        <trans-unit id="2000d65cb54af404f075a90dd29fef64452cdfe9" translate="yes" xml:space="preserve">
          <source>If the input is a vector (rank=1), finds the &lt;code&gt;k&lt;/code&gt; largest entries in the vector and outputs their values and indices as vectors. Thus &lt;code&gt;values[j]&lt;/code&gt; is the &lt;code&gt;j&lt;/code&gt;-th largest entry in &lt;code&gt;input&lt;/code&gt;, and its index is &lt;code&gt;indices[j]&lt;/code&gt;.</source>
          <target state="translated">입력 값이 벡터 (rank = 1)이면 벡터에서 &lt;code&gt;k&lt;/code&gt; 개의 가장 큰 항목을 찾아 값과 인덱스를 벡터로 출력합니다. 따라서 &lt;code&gt;values[j]&lt;/code&gt; 는 &lt;code&gt;input&lt;/code&gt; 에서 &lt;code&gt;j&lt;/code&gt; 번째로 큰 항목이며 인덱스는 &lt;code&gt;indices[j]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="25639d61413f3474f585047a2bb63baa71a0472f" translate="yes" xml:space="preserve">
          <source>If the input is prefixed by a Byte Order Mark needed to determine encoding (e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that BOM will be consumed and not emitted into the output. If the input encoding is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is interpreted as a non-breaking-space and is preserved in the output (including always for UTF-8).</source>
          <target state="translated">인코딩을 결정하는 데 필요한 바이트 순서 표시가 입력에 접두어로 붙으면 (예 : 인코딩이 UTF-16이고 BOM이 빅 엔디안을 나타내는 경우) 해당 BOM이 소비되어 출력으로 방출되지 않습니다. 입력 인코딩이 명시 적 엔디안 (예 : UTF-16-BE)으로 표시되면 BOM은 비 공백 공간으로 해석되어 출력에 유지됩니다 (항상 UTF-8 포함).</target>
        </trans-unit>
        <trans-unit id="1c4e8d7712b75c855eb7c3cf4d70a0943cb24389" translate="yes" xml:space="preserve">
          <source>If the input pipeline is shared between training and validation, restoring the checkpoint during validation may override the validation input pipeline.</source>
          <target state="translated">입력 파이프 라인이 교육과 유효성 검사간에 공유되는 경우 유효성 검사 중 검사 점을 복원하면 유효성 검사 입력 파이프 라인이 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72b72274c82e5eac3f5bdc28763a89bcac429b41" translate="yes" xml:space="preserve">
          <source>If the input signature cannot be inferred from the model.</source>
          <target state="translated">모델에서 입력 서명을 유추 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6c1251694f974cc1b4075b791d370851197bfaaf" translate="yes" xml:space="preserve">
          <source>If the input tensor has rank &lt;code&gt;R_in&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, and &lt;code&gt;new_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;, then &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_in]&lt;/code&gt;, &lt;code&gt;input_shape&lt;/code&gt; has length &lt;code&gt;R_in&lt;/code&gt;, &lt;code&gt;output_indices&lt;/code&gt; has shape &lt;code&gt;[N, R_out]&lt;/code&gt;, and &lt;code&gt;output_shape&lt;/code&gt; has length &lt;code&gt;R_out&lt;/code&gt;.</source>
          <target state="translated">입력 텐서에 &lt;code&gt;R_in&lt;/code&gt; 순위 및 비어 있지 않은 &lt;code&gt;N&lt;/code&gt; 개의 값이 있고 &lt;code&gt;new_shape&lt;/code&gt; 의 길이가 &lt;code&gt;R_out&lt;/code&gt; 인 경우 &lt;code&gt;input_indices&lt;/code&gt; 의 모양은 &lt;code&gt;[N, R_in]&lt;/code&gt; , &lt;code&gt;input_shape&lt;/code&gt; 의 길이는 &lt;code&gt;R_in&lt;/code&gt; , &lt;code&gt;output_indices&lt;/code&gt; 의 모양은 &lt;code&gt;[N, R_out]&lt;/code&gt; 이고 &lt;code&gt;output_shape&lt;/code&gt; 의 길이는 &lt;code&gt;R_out&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="de105d3b1e2a42d85103cbee9a5ac005bccac197" translate="yes" xml:space="preserve">
          <source>If the input values are all positive, they are rescaled so the largest one is 255.</source>
          <target state="translated">입력 값이 모두 양수이면 가장 큰 값이 255가되도록 크기가 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="c0ad8b47d990bec6ccbeeba5c4178e748476355f" translate="yes" xml:space="preserve">
          <source>If the inputs are complex.</source>
          <target state="translated">입력이 복잡한 경우.</target>
        </trans-unit>
        <trans-unit id="f925aa60776a7244d7085eecc014f09b4f812e92" translate="yes" xml:space="preserve">
          <source>If the interpreter could not resize the input tensor.</source>
          <target state="translated">인터프리터가 입력 텐서의 크기를 조정할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="6ad9551aaf11bca3406af0087bc0fe5a5694ca06" translate="yes" xml:space="preserve">
          <source>If the interpreter could not set the tensor.</source>
          <target state="translated">인터프리터가 텐서를 설정할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="c4087490d7b8bf7d3b2fedba5ad1da327138905e" translate="yes" xml:space="preserve">
          <source>If the interpreter was unable to create.</source>
          <target state="translated">통역사가 만들 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="e20c962df688017d296d76cbc25fc4a6e797657b" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="translated">반복기가 시퀀스의 끝에 도달하면 반환 된 &lt;a href=&quot;../../experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; 에&lt;/a&gt; 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="7d05f1367e6298a309c7cc96ff6c0839630b43b4" translate="yes" xml:space="preserve">
          <source>If the iterator has reached the end of the sequence, the returned &lt;a href=&quot;../experimental/optional&quot;&gt;&lt;code&gt;tf.experimental.Optional&lt;/code&gt;&lt;/a&gt; will have no value.</source>
          <target state="translated">반복기가 시퀀스의 끝에 도달하면 반환 된 &lt;a href=&quot;../experimental/optional&quot;&gt; &lt;code&gt;tf.experimental.Optional&lt;/code&gt; 에&lt;/a&gt; 값이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9ca643cb2629c831ff2614bca40312edb51c292" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;begin_mask&lt;/code&gt; is set, &lt;code&gt;begin[i]&lt;/code&gt; is ignored and the fullest possible range in that dimension is used instead. &lt;code&gt;end_mask&lt;/code&gt; works analogously, except with the end range.</source>
          <target state="translated">&lt;code&gt;begin_mask&lt;/code&gt; 의 i 번째 비트 가 설정되면 &lt;code&gt;begin[i]&lt;/code&gt; 가 무시되고 해당 차원에서 가능한 최대 범위가 대신 사용됩니다. &lt;code&gt;end_mask&lt;/code&gt; 는 종료 범위를 제외하고 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="53b6f32d8b994e08e60c897ec2633fae0ba3393e" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;ellipsis_mask&lt;/code&gt; is set, as many unspecified dimensions as needed will be inserted between other dimensions. Only one non-zero bit is allowed in &lt;code&gt;ellipsis_mask&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ellipsis_mask&lt;/code&gt; 의 i 번째 비트 가 설정되면 필요에 따라 지정되지 않은 치수가 다른 치수 사이에 삽입됩니다. &lt;code&gt;ellipsis_mask&lt;/code&gt; 에는 0이 아닌 비트 만 허용됩니다 .</target>
        </trans-unit>
        <trans-unit id="14e0da661bbe2e071831b21ea708a674b65e3553" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;new_axis_mask&lt;/code&gt; is set, then &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, and &lt;code&gt;stride&lt;/code&gt; are ignored and a new length 1 dimension is added at this point in the output tensor.</source>
          <target state="translated">&lt;code&gt;new_axis_mask&lt;/code&gt; 의 i 번째 비트 가 설정되면 &lt;code&gt;begin&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; 및 &lt;code&gt;stride&lt;/code&gt; 가 무시 되고이 시점에서 출력 텐서의 새 길이 1 치수가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea9295a32ee3d172d0de2b9a21ab6620d9c7aaa3" translate="yes" xml:space="preserve">
          <source>If the ith bit of &lt;code&gt;shrink_axis_mask&lt;/code&gt; is set, it implies that the ith specification shrinks the dimensionality by 1, taking on the value at index &lt;code&gt;begin[i]&lt;/code&gt;. &lt;code&gt;end[i]&lt;/code&gt; and &lt;code&gt;strides[i]&lt;/code&gt; are ignored in this case. For example in Python one might do &lt;code&gt;foo[:, 3, :]&lt;/code&gt; which would result in &lt;code&gt;shrink_axis_mask&lt;/code&gt; equal to 2.</source>
          <target state="translated">&lt;code&gt;shrink_axis_mask&lt;/code&gt; 의 i 번째 비트 가 설정되면 i 번째 스펙은 index &lt;code&gt;begin[i]&lt;/code&gt; 의 값을 사용하여 차원을 1 씩 줄 입니다. &lt;code&gt;end[i]&lt;/code&gt; 및 &lt;code&gt;strides[i]&lt;/code&gt; 는 무시됩니다. 예를 들어 파이썬에서 &lt;code&gt;foo[:, 3, :]&lt;/code&gt; 를 수행하면 &lt;code&gt;shrink_axis_mask&lt;/code&gt; 가 2가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec51310fe28dab35d237c5de7a060e05f980a65d" translate="yes" xml:space="preserve">
          <source>If the keras_model_path is a GCS URI.</source>
          <target state="translated">keras_model_path가 GCS URI 인 경우.</target>
        </trans-unit>
        <trans-unit id="5acffbcc3c0cad783d61073d1795d38ade292db7" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키가 &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.SparseTensor&lt;/code&gt; &lt;/a&gt; 인 경우 값은 &lt;a href=&quot;sparsetensorvalue&quot;&gt; &lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt; &lt;/a&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="069b207c0f431f445482fbf976b09b4c58fbe160" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt;&lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt;&lt;/a&gt;, the value should be a &lt;a href=&quot;sparsetensorvalue&quot;&gt;&lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">키가 &lt;a href=&quot;../../sparse/sparsetensor&quot;&gt; &lt;code&gt;tf.sparse.SparseTensor&lt;/code&gt; &lt;/a&gt; 인 경우 값은 &lt;a href=&quot;sparsetensorvalue&quot;&gt; &lt;code&gt;tf.compat.v1.SparseTensorValue&lt;/code&gt; 여야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0adb28fdab6cc893d9c3156f443e8c35c99d1ae8" translate="yes" xml:space="preserve">
          <source>If the key is a &lt;a href=&quot;../../tensor&quot;&gt;&lt;code&gt;tf.Tensor&lt;/code&gt;&lt;/a&gt;, the value may be a Python scalar, string, list, or numpy ndarray that can be converted to the same &lt;code&gt;dtype&lt;/code&gt; as that tensor. Additionally, if the key is a &lt;a href=&quot;placeholder&quot;&gt;&lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt;&lt;/a&gt;, the shape of the value will be checked for compatibility with the placeholder.</source>
          <target state="translated">키가 &lt;a href=&quot;../../tensor&quot;&gt; &lt;code&gt;tf.Tensor&lt;/code&gt; &lt;/a&gt; 인 경우 값은 해당 텐서 와 동일한 &lt;code&gt;dtype&lt;/code&gt; 으로 변환 할 수있는 Python 스칼라, 문자열, 목록 또는 numpy ndarray 일 수 있습니다 . 또한 키가 &lt;a href=&quot;placeholder&quot;&gt; &lt;code&gt;tf.compat.v1.placeholder&lt;/code&gt; &lt;/a&gt; 인 경우 값의 모양이 자리 표시 자와의 호환성을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="1d4c6296ff5f1ed16700becf51c667373e1f81ef" translate="yes" xml:space="preserve">
          <source>If the key is a nested tuple of &lt;code&gt;Tensor&lt;/code&gt;s or &lt;code&gt;SparseTensor&lt;/code&gt;s, the value should be a nested tuple with the same structure that maps to their corresponding values as above.</source>
          <target state="translated">키가 &lt;code&gt;Tensor&lt;/code&gt; 또는 &lt;code&gt;SparseTensor&lt;/code&gt; 의 중첩 튜플 인 경우 값은 위와 같이 해당 값에 매핑되는 동일한 구조를 갖는 중첩 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c0ed05e65efc99254033bbf6b2b8901e04b16293" translate="yes" xml:space="preserve">
          <source>If the last dimension is empty, we follow the convention that the sum over the empty set is zero, and the product is one.</source>
          <target state="translated">마지막 차원이 비어 있으면 빈 집합에 대한 합계가 0이고 곱이 1이라는 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="63f876d8411766c17a710087a716357c2f545e8f" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;sorted_sequence &amp;gt;= 2^31-1&lt;/code&gt; elements. If the total size of values exceeds &lt;code&gt;2^31 - 1&lt;/code&gt; elements. If the first &lt;code&gt;N-1&lt;/code&gt; dimensions of the two tensors don't match.</source>
          <target state="translated">&lt;code&gt;sorted_sequence &amp;gt;= 2^31-1&lt;/code&gt; 요소 의 마지막 차원 인 경우 . 값의 총 크기가 &lt;code&gt;2^31 - 1&lt;/code&gt; 요소를 초과하는 경우 . 두 텐서 의 첫 번째 &lt;code&gt;N-1&lt;/code&gt; 차원이 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="99de0b684ff53cc972b2e916eef8dd972d4a9ba5" translate="yes" xml:space="preserve">
          <source>If the layer has not been built, this method will call &lt;code&gt;build&lt;/code&gt; on the layer. This assumes that the layer will later be used with inputs that match the input shape provided here.</source>
          <target state="translated">레이어가 작성되지 않은 경우이 메소드는 레이어에서 &lt;code&gt;build&lt;/code&gt; 를 호출 합니다. 이것은 나중에 레이어가 여기에 제공된 입력 모양과 일치하는 입력과 함께 사용된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0c93baadf61368eb61a32573a61ace4b23530d53" translate="yes" xml:space="preserve">
          <source>If the layer's &lt;code&gt;call&lt;/code&gt; method takes a &lt;code&gt;mask&lt;/code&gt; argument (as some Keras layers do), its default value will be set to the mask generated for &lt;code&gt;inputs&lt;/code&gt; by the previous layer (if &lt;code&gt;input&lt;/code&gt; did come from a layer that generated a corresponding mask, i.e. if it came from a Keras layer with masking support.</source>
          <target state="translated">레이어의 &lt;code&gt;call&lt;/code&gt; 메서드가 일부 Keras 레이어처럼 &lt;code&gt;mask&lt;/code&gt; 인수를 사용하는 경우 기본값 은 이전 레이어의 &lt;code&gt;inputs&lt;/code&gt; 에 대해 생성 된 마스크로 설정됩니다 ( &lt;code&gt;input&lt;/code&gt; 이 해당 마스크를 생성 한 레이어에서 온 경우 ( 예 : 마스크) 마스킹을 지원하는 Keras 레이어에서 나왔습니다.</target>
        </trans-unit>
        <trans-unit id="9914ccb05442f0fd9eeac8901bc8d04826b15b98" translate="yes" xml:space="preserve">
          <source>If the max is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">최대 주어진 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96d2c8a21f840629380501d04af2dc4fe3e1ab06" translate="yes" xml:space="preserve">
          <source>If the maximum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the smallest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt;.</source>
          <target state="translated">주어진 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 에 대해 최대 값이 비어 있으면 특정 숫자 유형에 대해 가능한 가장 작은 값인 &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::lowest()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="b06b3bf831b0d35a3637fb432a42854a21f98016" translate="yes" xml:space="preserve">
          <source>If the mean is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">평균은 주어진 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1140e9402fba81b2c59500e980fdae7cc9b73760" translate="yes" xml:space="preserve">
          <source>If the min is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">최소는 주어진 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00f33d9bbb883644d8d348d1d1e555c9c61673c2" translate="yes" xml:space="preserve">
          <source>If the minimum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs the largest possible value for the specific numeric type, &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">주어진 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 에 대해 최소값이 비어 있으면 특정 숫자 유형에 대해 가능한 최대 값 인 &lt;code&gt;output[i] = numeric_limits&amp;lt;T&amp;gt;::max()&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="cb66ec88de963b30ef4f8246ae8014a7fd55e5c4" translate="yes" xml:space="preserve">
          <source>If the mode is 'MIN_FIRST', then this approach is used:</source>
          <target state="translated">모드가 'MIN_FIRST'이면이 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ef024d8d4793bf018279248fd541d506ae2395b" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, dequantization is performed by multiplying each input value by a scaling_factor. (Thus an input of 0 always maps to 0.0).</source>
          <target state="translated">모드가 &lt;code&gt;SCALED&lt;/code&gt; 인 경우, 각 입력 값에 scaling_factor를 곱하여 역 양자화가 수행됩니다. (따라서 0의 입력은 항상 0.0에 매핑됩니다).</target>
        </trans-unit>
        <trans-unit id="db1124a69fc0391f15200d7a79013fb471df1704" translate="yes" xml:space="preserve">
          <source>If the mode is &lt;code&gt;SCALED&lt;/code&gt;, the quantization is performed by multiplying each input value by a scaling_factor. The scaling_factor is determined from &lt;code&gt;min_range&lt;/code&gt; and &lt;code&gt;max_range&lt;/code&gt; to be as large as possible such that the range from &lt;code&gt;min_range&lt;/code&gt; to &lt;code&gt;max_range&lt;/code&gt; is representable within values of type T.</source>
          <target state="translated">모드가 &lt;code&gt;SCALED&lt;/code&gt; 인 경우, 각 입력 값에 scaling_factor를 곱하여 양자화가 수행됩니다. scaling_factor은 판정 &lt;code&gt;min_range&lt;/code&gt; 및 &lt;code&gt;max_range&lt;/code&gt; 가능한 한 큰 수의 범위되도록 &lt;code&gt;min_range&lt;/code&gt; 에 &lt;code&gt;max_range&lt;/code&gt; 는 입력 값 내에 T. 표현할 수있다</target>
        </trans-unit>
        <trans-unit id="6383b459b0c33d463602987492ae422c09b13402" translate="yes" xml:space="preserve">
          <source>If the model cannot be initialized or recovered.</source>
          <target state="translated">모델을 초기화하거나 복구 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="2c659fe038e40df626c10048932fee8c629877e2" translate="yes" xml:space="preserve">
          <source>If the model cannot be recovered successfully then it is initialized by running the &lt;code&gt;init_op&lt;/code&gt; and calling &lt;code&gt;init_fn&lt;/code&gt; if they are provided. The &lt;code&gt;local_init_op&lt;/code&gt; is also run after init_op and init_fn, regardless of whether the model was recovered successfully, but only if &lt;code&gt;ready_for_local_init_op&lt;/code&gt; passes.</source>
          <target state="translated">모델이 성공적으로 다음 복구 할 수없는 경우는 실행하여 초기화 &lt;code&gt;init_op&lt;/code&gt; 을 하고 전화 &lt;code&gt;init_fn&lt;/code&gt; 그들이 제공하는 경우. &lt;code&gt;local_init_op&lt;/code&gt; 는 또한 init_op 후에 실행되고 init_fn에 관계없이 모델이 성공적으로 복구되었지만 경우에만 여부 &lt;code&gt;ready_for_local_init_op&lt;/code&gt; 가 전달합니다.</target>
        </trans-unit>
        <trans-unit id="42710bc33bad38e07caf615faa21fedd716ffc30" translate="yes" xml:space="preserve">
          <source>If the model is a subclassed model, and serving_only is False.</source>
          <target state="translated">모델이 서브 클래스 모델이고 serving_only가 False 인 경우.</target>
        </trans-unit>
        <trans-unit id="e493d4d88dd6364973cb16adddea7f1d7c9e11b9" translate="yes" xml:space="preserve">
          <source>If the model is recovered from a checkpoint it is assumed that all global variables have been initialized, in particular neither &lt;code&gt;init_op&lt;/code&gt; nor &lt;code&gt;init_fn&lt;/code&gt; will be executed.</source>
          <target state="translated">모델이 검사 점에서 복구되면 모든 전역 변수가 초기화 된 것으로 가정합니다. 특히 &lt;code&gt;init_op&lt;/code&gt; 또는 &lt;code&gt;init_fn&lt;/code&gt; 이 실행 되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="4d6f1b8c16d5b51d1c9ded9f1446f976cc11e129" translate="yes" xml:space="preserve">
          <source>If the model was never compiled or,</source>
          <target state="translated">모델이 컴파일되지 않았거나</target>
        </trans-unit>
        <trans-unit id="30f9d9bb5e085ae4acbe52e70dd3531828c8a5fc" translate="yes" xml:space="preserve">
          <source>If the number of dimensions in &lt;code&gt;st_input&lt;/code&gt; is not known statically, or is not two.</source>
          <target state="translated">&lt;code&gt;st_input&lt;/code&gt; 의 차원 수가 정적으로 알려지지 않았거나 2가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="6d3c99a79852c902d9b814a851d58f44663386e0" translate="yes" xml:space="preserve">
          <source>If the number of inputs per replica does not match the number of formal parameters to &lt;code&gt;computation&lt;/code&gt;.</source>
          <target state="translated">복제 본당 입력 수가 &lt;code&gt;computation&lt;/code&gt; 대한 공식 매개 변수의 수와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="fa742d76ae217bc9948872afe6ac45118d433ee3" translate="yes" xml:space="preserve">
          <source>If the op is not an &lt;code&gt;Operation&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Operation&lt;/code&gt; 이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="012fe8f2af0ac138febd5985745621393340a0d8" translate="yes" xml:space="preserve">
          <source>If the operation fails.</source>
          <target state="translated">작업이 실패한 경우.</target>
        </trans-unit>
        <trans-unit id="dc6ec351ebdb083f3d17d8e986dd67bae3d01101" translate="yes" xml:space="preserve">
          <source>If the operation seed is not set but the global seed is set: The system picks an operation seed from a stream of seeds determined by the global seed.</source>
          <target state="translated">오퍼레이션 시드가 설정되지 않았지만 글로벌 시드가 설정된 경우 : 시스템은 글로벌 시드에 의해 결정된 시드 스트림에서 오퍼레이션 시드를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="150c78cb9921ff6cbc2920415e1cb51a5f161b3f" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, but the global seed is not set: A default global seed and the specified operation seed are used to determine the random sequence.</source>
          <target state="translated">작업 시드가 설정되었지만 전역 시드가 설정되지 않은 경우 : 기본 전역 시드 및 지정된 작업 시드가 임의 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="61786c3241da39066c5d1cad1bbd7d232ac2fec8" translate="yes" xml:space="preserve">
          <source>If the operation seed is set, we get different results for every call to the random op, but the same sequence for every re-run of the program:</source>
          <target state="translated">연산 시드가 설정되면 임의 op에 대한 모든 호출에 대해 다른 결과를 얻지 만 프로그램을 다시 실행할 때마다 동일한 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="c7c4d1aa2a7f3d9f64a5d7440278a03c364673f0" translate="yes" xml:space="preserve">
          <source>If the operator is marked as self-adjoint (via &lt;code&gt;is_self_adjoint&lt;/code&gt;) this computation can be more efficient.</source>
          <target state="translated">연산자가 &lt;code&gt;is_self_adjoint&lt;/code&gt; 를 통해 self-adjoint로 표시되면 이 계산이 더 효율적일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62e7cf664c32974cdff913c7188633271cc1c617" translate="yes" xml:space="preserve">
          <source>If the operator is square, this is also the sum of the eigenvalues.</source>
          <target state="translated">연산자가 제곱 인 경우 고유 값의 합이기도합니다.</target>
        </trans-unit>
        <trans-unit id="7cfb48973a04dbb9b6d9a3a87eb33a91ec4619ce" translate="yes" xml:space="preserve">
          <source>If the output type was qint8 ([-128, 127]), the operation will additionally subtract each value by 128 prior to casting, so that the range of values aligns with the range of qint8.</source>
          <target state="translated">출력 유형이 qint8 ([-128, 127]) 인 경우, 조작은 캐스팅 전에 추가로 각 값을 128 씩 빼서 값의 범위가 qint8의 범위와 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="4dff92bc587fce4bff2b2db8dd6919485f299911" translate="yes" xml:space="preserve">
          <source>If the partitioner hits the &lt;code&gt;max_shards&lt;/code&gt; limit, then each shard may end up larger than &lt;code&gt;max_shard_bytes&lt;/code&gt;. By default &lt;code&gt;max_shards&lt;/code&gt; equals &lt;code&gt;None&lt;/code&gt; and no limit on the number of shards is enforced.</source>
          <target state="translated">파티 &lt;code&gt;max_shards&lt;/code&gt; 한계에 도달하면 각 샤드가 &lt;code&gt;max_shard_bytes&lt;/code&gt; 보다 커질 수 있습니다. 기본적으로 &lt;code&gt;max_shards&lt;/code&gt; 에 해당되지 &lt;code&gt;None&lt;/code&gt; 과 파편의 수에는 제한이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a942f30d3b77fdc54336a28fc3dfef09ecbb6824" translate="yes" xml:space="preserve">
          <source>If the path is not found, or the resource can't be opened.</source>
          <target state="translated">경로를 찾을 수 없거나 리소스를 열 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="f7a2a3fd0faa56bc31e1b5e49c1d047a10c2ec07" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [20, 16] for fractional max pooling.</source>
          <target state="translated">풀링 시퀀스가 ​​[0, 2, 4]이면 인덱스 2에서 16이 두 번 사용됩니다. 결과는 부분 최대 풀링의 경우 [20, 16]이됩니다.</target>
        </trans-unit>
        <trans-unit id="d38bf0235baac14c6561ea9c91b1aa0b7e9bc6ea" translate="yes" xml:space="preserve">
          <source>If the pooling sequence is [0, 2, 4], then 16, at index 2 will be used twice. The result would be [41/3, 26/3] for fractional avg pooling.</source>
          <target state="translated">풀링 시퀀스가 ​​[0, 2, 4]이면 인덱스 2에서 16이 두 번 사용됩니다. 결과는 부분 평균 풀링의 경우 [41/3, 26/3]입니다.</target>
        </trans-unit>
        <trans-unit id="f1885aec51a609f73968bad4dfc16b73c835fa1e" translate="yes" xml:space="preserve">
          <source>If the product is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 1&lt;/code&gt;.</source>
          <target state="translated">생성물은 주어진 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14b06ad55e535b3bc2a49abca7c87697d17d429c" translate="yes" xml:space="preserve">
          <source>If the program crashes and is restarted, the managed session automatically reinitialize variables from the most recent checkpoint.</source>
          <target state="translated">프로그램이 충돌하고 다시 시작되면 관리 세션은 가장 최근의 검사 점에서 변수를 자동으로 다시 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="d33c70c7d1ae55398bb222a1899dc0ece170d6c0" translate="yes" xml:space="preserve">
          <source>If the provided TPU is not healthy.</source>
          <target state="translated">제공된 TPU가 정상이 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="0b0821c52d17cc27d0dcda253ed0746d3cde7110" translate="yes" xml:space="preserve">
          <source>If the provided tag was already used for this type of event.</source>
          <target state="translated">제공된 태그가이 유형의 이벤트에 이미 사용 된 경우.</target>
        </trans-unit>
        <trans-unit id="3975f76c6a1a580f5974df80a91da72b3d715f48" translate="yes" xml:space="preserve">
          <source>If the provided weights list does not match the layer's specifications.</source>
          <target state="translated">제공된 가중치 목록이 레이어의 사양과 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="2a357164b0c5580a5330506915d75a024dc5cd8a" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are fewer than &lt;code&gt;n&lt;/code&gt; elements, then an OutOfRange error is returned.</source>
          <target state="translated">큐가 닫히고 요소 가 &lt;code&gt;n&lt;/code&gt; 개 미만 이면 OutOfRange 오류가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7ec15897d06f9071c5e97fa6f104995494c3c020" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are less than &lt;code&gt;n&lt;/code&gt; elements left, then an &lt;code&gt;OutOfRange&lt;/code&gt; exception is raised.</source>
          <target state="translated">큐가 닫히고 &lt;code&gt;n&lt;/code&gt; 개 미만의 요소가 남아 있으면 &lt;code&gt;OutOfRange&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e6d8db12ae869e217b426b4397efdcf921300b07" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than 0 but less than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of returning an OutOfRange error like QueueDequeueMany, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are 0 elements left in the queue, then an OutOfRange error is returned just like in QueueDequeueMany. Otherwise the behavior is identical to QueueDequeueMany:</source>
          <target state="translated">큐가 닫혀 있고 0 개 이상 &lt;code&gt;n&lt;/code&gt; 개 미만의 요소가 남아있는 경우 QueueDequeueMany와 같은 OutOfRange 오류를 반환하는 대신 &lt;code&gt;n&lt;/code&gt; 개 미만의 요소가 즉시 반환됩니다. 큐가 닫히고 큐에 0 개의 요소가 남아 있으면 QueueDequeueMany와 마찬가지로 OutOfRange 오류가 반환됩니다. 그렇지 않으면 동작은 QueueDequeueMany와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2909c49e7094efd16c1e6b533233682195cdca40" translate="yes" xml:space="preserve">
          <source>If the queue is closed and there are more than &lt;code&gt;0&lt;/code&gt; but fewer than &lt;code&gt;n&lt;/code&gt; elements remaining, then instead of raising a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; like &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt;, less than &lt;code&gt;n&lt;/code&gt; elements are returned immediately. If the queue is closed and there are &lt;code&gt;0&lt;/code&gt; elements left in the queue, then a &lt;a href=&quot;../errors/outofrangeerror&quot;&gt;&lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt;&lt;/a&gt; is raised just like in &lt;code&gt;dequeue_many&lt;/code&gt;. Otherwise the behavior is identical to &lt;code&gt;dequeue_many&lt;/code&gt;.</source>
          <target state="translated">큐는 폐쇄하고있을 경우보다 더 &lt;code&gt;0&lt;/code&gt; 그러나보다 적은 &lt;code&gt;n&lt;/code&gt; 원소가 잔류하고 대신 올리는 &lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; 을&lt;/a&gt; 같은 &lt;code&gt;tf.QueueBase.dequeue_many&lt;/code&gt; 미만, &lt;code&gt;n&lt;/code&gt; 원소가 바로 반환된다. 큐가 폐쇄하고있을 경우 &lt;code&gt;0&lt;/code&gt; 큐에 남아있는 요소는 다음 &lt;a href=&quot;../errors/outofrangeerror&quot;&gt; &lt;code&gt;tf.errors.OutOfRangeError&lt;/code&gt; 은&lt;/a&gt; 단지처럼 발생 &lt;code&gt;dequeue_many&lt;/code&gt; . 그렇지 않으면 동작은 &lt;code&gt;dequeue_many&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="dbed72aba5ba28d95f2d72fff5e20ff3a4222092" translate="yes" xml:space="preserve">
          <source>If the queue is empty when this operation executes, it will block until there is an element to dequeue.</source>
          <target state="translated">이 작업이 실행될 때 대기열이 비어 있으면 대기열에서 제외시킬 요소가있을 때까지 대기열이 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="90be429384e7a1cfa4ccd2802a141dfd6052e934" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until all of the elements have been enqueued.</source>
          <target state="translated">이 작업이 실행될 때 큐가 가득 찬 경우 모든 요소가 큐에 들어갈 때까지 큐가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="eabf4447a0d7c1faf56f579f18de2be7b3ff884c" translate="yes" xml:space="preserve">
          <source>If the queue is full when this operation executes, it will block until the element has been enqueued.</source>
          <target state="translated">이 작업이 실행될 때 큐가 가득 찬 경우 요소가 큐에 들어갈 때까지 큐가 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="55a8dc3be231a05be089bfed8d162468d9d0ecca" translate="yes" xml:space="preserve">
          <source>If the result is midway between two representable values, the even representable is chosen. For example:</source>
          <target state="translated">결과가 표현 가능한 두 값 사이의 중간이면 짝수 표현이 선택됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="40ce55e23a050e14a92b2bf375cac16edef873d6" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 의 결과가 RaggedTensor 여야하는 경우 &lt;code&gt;RaggedTensor&lt;/code&gt; 을 사용하여 &lt;a href=&quot;../../raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; &lt;/a&gt; 를 지정 &lt;code&gt;fn_output_signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b62832016e2c0ed4032fbaf21eee5f5a78f0a04" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;RaggedTensor&lt;/code&gt;, then use a &lt;a href=&quot;raggedtensorspec&quot;&gt;&lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 의 결과가 RaggedTensor 여야하는 경우 &lt;code&gt;RaggedTensor&lt;/code&gt; 을 사용하여 &lt;a href=&quot;raggedtensorspec&quot;&gt; &lt;code&gt;tf.RaggedTensorSpec&lt;/code&gt; &lt;/a&gt; 를 지정 &lt;code&gt;fn_output_signature&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59689227b3cca92043b54ed174b643ad8bc510ae" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;../../sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 의 결과가 SparseTensor 여야하는 경우 &lt;code&gt;SparseTensor&lt;/code&gt; 을 사용하여 &lt;a href=&quot;../../sparsetensorspec&quot;&gt; &lt;code&gt;tf.SparseTensorSpec&lt;/code&gt; &lt;/a&gt; 를 지정 &lt;code&gt;fn_output_signature&lt;/code&gt; . &lt;code&gt;fn&lt;/code&gt; 에서 반환 된 개별 &lt;code&gt;SparseTensor&lt;/code&gt; 는 차원이 하나 더 있는 단일 &lt;code&gt;SparseTensor&lt;/code&gt; 로 쌓 입니다.</target>
        </trans-unit>
        <trans-unit id="ed8cf573a4e8bfa0d4b2566b9b0bc2c82137a852" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;map_fn&lt;/code&gt; should be a &lt;code&gt;SparseTensor&lt;/code&gt;, then use a &lt;a href=&quot;sparsetensorspec&quot;&gt;&lt;code&gt;tf.SparseTensorSpec&lt;/code&gt;&lt;/a&gt; to specify &lt;code&gt;fn_output_signature&lt;/code&gt;. The individual &lt;code&gt;SparseTensor&lt;/code&gt;s returned by &lt;code&gt;fn&lt;/code&gt; will be stacked into a single &lt;code&gt;SparseTensor&lt;/code&gt; with one more dimension.</source>
          <target state="translated">&lt;code&gt;map_fn&lt;/code&gt; 의 결과가 SparseTensor 여야하는 경우 &lt;code&gt;SparseTensor&lt;/code&gt; 을 사용하여 &lt;a href=&quot;sparsetensorspec&quot;&gt; &lt;code&gt;tf.SparseTensorSpec&lt;/code&gt; &lt;/a&gt; 를 지정 &lt;code&gt;fn_output_signature&lt;/code&gt; . &lt;code&gt;fn&lt;/code&gt; 에서 반환 된 개별 &lt;code&gt;SparseTensor&lt;/code&gt; 는 차원이 하나 더 있는 단일 &lt;code&gt;SparseTensor&lt;/code&gt; 로 쌓 입니다.</target>
        </trans-unit>
        <trans-unit id="db7235f6b7d8d91626523bb002062bf9af9f3e79" translate="yes" xml:space="preserve">
          <source>If the same tensor or variable is specified multiple times in &lt;code&gt;primals&lt;/code&gt;.</source>
          <target state="translated">동일한 텐서 또는 변수가 &lt;code&gt;primals&lt;/code&gt; 에서 여러 번 지정된 경우 .</target>
        </trans-unit>
        <trans-unit id="300ebf80fc956f29ae859b8d3c6560c81957725b" translate="yes" xml:space="preserve">
          <source>If the saved model file does not exist, or cannot be successfully parsed.</source>
          <target state="translated">저장된 모델 파일이 없거나 성공적으로 구문 분석 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="344be155e24f53b90446aa0dd405ae181b247cdf" translate="yes" xml:space="preserve">
          <source>If the scalar values in &lt;code&gt;pylist&lt;/code&gt; have inconsistent nesting depth; or if ragged_rank or inner_shape are incompatible with &lt;code&gt;pylist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pylist&lt;/code&gt; 의 스칼라 값에 일관성없는 중첩 깊이가있는 경우 또는 ragged_rank 또는 inner_shape은과 호환되지 않는 경우 &lt;code&gt;pylist&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5fe61fb730912ad313c279c46346170b788594e" translate="yes" xml:space="preserve">
          <source>If the scope name already exists, the name will be made unique by appending &lt;code&gt;_n&lt;/code&gt;. For example, calling &lt;code&gt;my_op&lt;/code&gt; the second time will generate &lt;code&gt;MyOp_1/a&lt;/code&gt;, etc.</source>
          <target state="translated">범위 이름이 이미 존재하면 &lt;code&gt;_n&lt;/code&gt; 을 추가하여 이름을 고유하게 만듭니다. 예를 들어, &lt;code&gt;my_op&lt;/code&gt; 를 두 번 호출 하면 &lt;code&gt;MyOp_1/a&lt;/code&gt; 등 이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="108c455c6020e7fdfe033c5720678463a8369595" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative, or either &lt;code&gt;target_height&lt;/code&gt; or &lt;code&gt;target_width&lt;/code&gt; is not positive.</source>
          <target state="translated">&lt;code&gt;image&lt;/code&gt; 의 모양이 &lt;code&gt;target_*&lt;/code&gt; &lt;code&gt;offset_*&lt;/code&gt; 또는 target_ * 인수 와 호환되지 않거나 &lt;code&gt;offset_height&lt;/code&gt; 또는 &lt;code&gt;offset_width&lt;/code&gt; 가 음수이거나 &lt;code&gt;target_height&lt;/code&gt; 또는 &lt;code&gt;target_width&lt;/code&gt; 가 양수가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="2204e01ba6ff9a32e0d7fcf9a1b417b5a5274710" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;image&lt;/code&gt; is incompatible with the &lt;code&gt;offset_*&lt;/code&gt; or &lt;code&gt;target_*&lt;/code&gt; arguments, or either &lt;code&gt;offset_height&lt;/code&gt; or &lt;code&gt;offset_width&lt;/code&gt; is negative.</source>
          <target state="translated">형상 경우 &lt;code&gt;image&lt;/code&gt; 과 호환되지 &lt;code&gt;offset_*&lt;/code&gt; 또는 &lt;code&gt;target_*&lt;/code&gt; 중 어느 하나의 인수 또는 &lt;code&gt;offset_height&lt;/code&gt; 또는 &lt;code&gt;offset_width&lt;/code&gt; 부정적이다.</target>
        </trans-unit>
        <trans-unit id="37af20a631a4a1fcb4791bfe44a71bac00f8303e" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;multi_class_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid, or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;multi_class_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="translated">의 모양 경우 &lt;code&gt;logits&lt;/code&gt; 가 의 일치하지 않는 &lt;code&gt;multi_class_labels&lt;/code&gt; 또는 경우의 모양 &lt;code&gt;weights&lt;/code&gt; 무효 인 경우, 또는 &lt;code&gt;weights&lt;/code&gt; 아무도 없다. 또한 &lt;code&gt;multi_class_labels&lt;/code&gt; 또는 &lt;code&gt;logits&lt;/code&gt; 가 None 인 경우.</target>
        </trans-unit>
        <trans-unit id="88047769983b00d370c7aa8a73273e36c97d3bd7" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;logits&lt;/code&gt; doesn't match that of &lt;code&gt;onehot_labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;weights&lt;/code&gt; is None. Also if &lt;code&gt;onehot_labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="translated">의 모양 경우 &lt;code&gt;logits&lt;/code&gt; 가 의 일치하지 않는 &lt;code&gt;onehot_labels&lt;/code&gt; 또는 경우의 모양 &lt;code&gt;weights&lt;/code&gt; 유효하지 않은 경우, 또는 &lt;code&gt;weights&lt;/code&gt; 아무도 없다. 또한 &lt;code&gt;onehot_labels&lt;/code&gt; 또는 &lt;code&gt;logits&lt;/code&gt; 가 None 인 경우.</target>
        </trans-unit>
        <trans-unit id="3b08ab83a17beb9a37d9f3f65ec8143060cd7263" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="translated">&lt;code&gt;predictions&lt;/code&gt; 의 모양이 &lt;code&gt;labels&lt;/code&gt; 의 모양 과 일치하지 않거나 &lt;code&gt;weights&lt;/code&gt; 의 모양 이 유효하지 않거나 &lt;code&gt;labels&lt;/code&gt; 또는 &lt;code&gt;predictions&lt;/code&gt; 이 없음 인 경우.</target>
        </trans-unit>
        <trans-unit id="a7553b5398dd554109ba0a10bde0fcd1930ed049" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;predictions&lt;/code&gt; doesn't match that of &lt;code&gt;labels&lt;/code&gt; or if the shape of &lt;code&gt;weights&lt;/code&gt; is invalid. Also if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;predictions&lt;/code&gt; is None.</source>
          <target state="translated">&lt;code&gt;predictions&lt;/code&gt; 의 모양이 &lt;code&gt;labels&lt;/code&gt; 의 모양 과 일치하지 않거나 &lt;code&gt;weights&lt;/code&gt; 의 모양 이 유효하지 않은 경우. 또한 &lt;code&gt;labels&lt;/code&gt; 또는 &lt;code&gt;predictions&lt;/code&gt; 이 없음 인 경우.</target>
        </trans-unit>
        <trans-unit id="8fe4384c06dff4646d7a21614fb5b0db31008230" translate="yes" xml:space="preserve">
          <source>If the shape of &lt;code&gt;sample_weight&lt;/code&gt; is invalid.</source>
          <target state="translated">&lt;code&gt;sample_weight&lt;/code&gt; 의 모양 이 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="3fd25b920cd34ef33927a979c45194f34614408b" translate="yes" xml:space="preserve">
          <source>If the shape of the input cannot be inferred from the arguments.</source>
          <target state="translated">인수에서 입력의 모양을 추론 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="a54dcf4080998972f139ff7554df53efbf2918b1" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is more than two-dimensional, a matrix of shape &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; is initialized, where &lt;code&gt;n&lt;/code&gt; is the length of the shape vector. The matrix is subsequently reshaped to give a tensor of the desired shape.</source>
          <target state="translated">초기화 할 텐서의 모양이 2 차원 이상인 경우, 모양의 행렬 &lt;code&gt;(shape[0] * ... * shape[n - 2], shape[n - 1])&lt;/code&gt; 이 초기화됩니다. 여기서 &lt;code&gt;n&lt;/code&gt; 은 모양 벡터의 길이. 매트릭스는이어서 원하는 형상의 텐서를 제공하도록 재 성형된다.</target>
        </trans-unit>
        <trans-unit id="b8d51b3cc2d47981a522a4c9c34d0625aae79fab" translate="yes" xml:space="preserve">
          <source>If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.</source>
          <target state="translated">초기화하는 텐서의 형상이 2 차원 인 경우, 정규 분포로부터 도출 된 난수 행렬의 QR 분해로부터 얻어진 직교 행렬로 초기화된다. 행렬에 열보다 적은 행이 있으면 출력에 직교 행이 있습니다. 그렇지 않으면 출력에 직교 열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="411bd1e755c6445ce89548664295dcd91a5d4f8f" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; do not match in any dimension other than the last dimension.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 모양이 마지막 차원이 아닌 다른 차원에서 일치하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="88be12eb5c7fd4e220c4fe96c602fca142984f22" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, and &lt;code&gt;axes&lt;/code&gt; are incompatible.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;axes&lt;/code&gt; 의 모양 이 호환되지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="2a0c1592ab9cdd3bf5f1c096b576c80fbc8d2ff4" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; don't match or if &lt;code&gt;labels&lt;/code&gt; or &lt;code&gt;logits&lt;/code&gt; is None.</source>
          <target state="translated">&lt;code&gt;logits&lt;/code&gt; 과 &lt;code&gt;labels&lt;/code&gt; 의 모양이 일치하지 않거나 &lt;code&gt;labels&lt;/code&gt; 또는 &lt;code&gt;logits&lt;/code&gt; 이 없음 인 경우.</target>
        </trans-unit>
        <trans-unit id="5dafbcea11dbd05f2198f43ce1950635ed08ea45" translate="yes" xml:space="preserve">
          <source>If the shapes of &lt;code&gt;logits&lt;/code&gt;, &lt;code&gt;labels&lt;/code&gt;, and &lt;code&gt;weights&lt;/code&gt; are incompatible, or if any of them are None.</source>
          <target state="translated">&lt;code&gt;logits&lt;/code&gt; , &lt;code&gt;labels&lt;/code&gt; 및 &lt;code&gt;weights&lt;/code&gt; 의 모양 이 호환되지 않거나 둘 중 하나라도 없음 인 경우.</target>
        </trans-unit>
        <trans-unit id="bb7df478231ff6f50f0a79744cfc374602c1a9d3" translate="yes" xml:space="preserve">
          <source>If the slice indices aren't int, slice, ellipsis, tf.newaxis or scalar int32/int64 tensors.</source>
          <target state="translated">슬라이스 인덱스가 int, slice, ellipsis, tf.newaxis 또는 스칼라 int32 / int64 텐서가 아닌 경우.</target>
        </trans-unit>
        <trans-unit id="c59791a0403cf8a35ad3d5f8e04ef9fd71c74268" translate="yes" xml:space="preserve">
          <source>If the static &lt;code&gt;inputs&lt;/code&gt; dimensions don't match with the values given in &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="translated">정적 &lt;code&gt;inputs&lt;/code&gt; 차원이 &lt;code&gt;maximum_shapes&lt;/code&gt; 에 제공된 값과 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="305adc686f0d35611fc45f59ebff259e89edb85d" translate="yes" xml:space="preserve">
          <source>If the string_tensor is a null Python list. At runtime, will fail with an assertion if string_tensor becomes a null tensor.</source>
          <target state="translated">string_tensor가 null Python 목록 인 경우. 런타임시 string_tensor가 null 텐서가되면 어설 션과 함께 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e8ee97b5be1b0def3d40b95369d5a5715a3eff8d" translate="yes" xml:space="preserve">
          <source>If the structure of inputs per replica does not match the structure of &lt;code&gt;maximum_shapes&lt;/code&gt;.</source>
          <target state="translated">복제 본당 입력 구조가 &lt;code&gt;maximum_shapes&lt;/code&gt; 의 구조와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="2d30e9d875fd192cb3baaabd913b4b57914b7a37" translate="yes" xml:space="preserve">
          <source>If the structures of &lt;code&gt;output_shapes&lt;/code&gt; and &lt;code&gt;output_types&lt;/code&gt; are not the same.</source>
          <target state="translated">&lt;code&gt;output_shapes&lt;/code&gt; 및 &lt;code&gt;output_types&lt;/code&gt; 의 구조가 동일하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="0ef1c30d1f578546d2ac2a550f76da4a58e33bff" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;.</source>
          <target state="translated">합이 소정의 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="873ee7c62a98d7de613cf70bb2470219e6db5cb9" translate="yes" xml:space="preserve">
          <source>If the sum is empty for a given segment ID &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;output[i] = 0&lt;/code&gt;. If the given segment ID &lt;code&gt;i&lt;/code&gt; is negative, the value is dropped and will not be added to the sum of the segment.</source>
          <target state="translated">합이 소정의 세그먼트 ID 비어있는 경우 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;output[i] = 0&lt;/code&gt; . 제공된 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 가 음수이면 값이 삭제되고 세그먼트 합계에 추가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b513c82152e6957978048500ff9bfbeecd96db7" translate="yes" xml:space="preserve">
          <source>If the task_type or task_id is not specified and the &lt;code&gt;TF_CONFIG&lt;/code&gt; environment variable does not contain a task section.</source>
          <target state="translated">task_type 또는 task_id가 지정 되지 않고 &lt;code&gt;TF_CONFIG&lt;/code&gt; 환경 변수에 작업 섹션이 포함되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="e36e9fd8063e68e549307244c175aa35d72257cf" translate="yes" xml:space="preserve">
          <source>If the tensor has rank &lt;code&gt;R&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; non-empty values, &lt;code&gt;input_indices&lt;/code&gt; has shape &lt;code&gt;[N, R]&lt;/code&gt;, input_values has length &lt;code&gt;N&lt;/code&gt;, and input_shape has length &lt;code&gt;R&lt;/code&gt;.</source>
          <target state="translated">텐서에 &lt;code&gt;R&lt;/code&gt; 등급이 있고 비어 있지 않은 &lt;code&gt;N&lt;/code&gt; 개의 값이있는 경우 &lt;code&gt;input_indices&lt;/code&gt; 의 형태는 &lt;code&gt;[N, R]&lt;/code&gt; 이고 input_values의 길이는 &lt;code&gt;N&lt;/code&gt; 이며 input_shape의 길이는 &lt;code&gt;R&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59713476f3de6c632928eea81b1fc2ac46a8cac3" translate="yes" xml:space="preserve">
          <source>If the tensor is not scalar (rank 0), or if its shape is unknown.</source>
          <target state="translated">텐서가 스칼라 (순위 0)가 아니거나 모양을 알 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="23837fad92f5de53c22f485995bbc7eb51b99864" translate="yes" xml:space="preserve">
          <source>If the tensor's data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="translated">텐서의 데이터 유형이 &lt;code&gt;tf_type&lt;/code&gt; 과 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="10bfa6ca2caca4913525a3c6982871f158747c35" translate="yes" xml:space="preserve">
          <source>If the tensors data type doesn't match &lt;code&gt;tf_type&lt;/code&gt;.</source>
          <target state="translated">텐서 데이터 유형이 &lt;code&gt;tf_type&lt;/code&gt; 과 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="20a6d43b61a912e98de11addfc5b73fcd9317a33" translate="yes" xml:space="preserve">
          <source>If the timeout expires and no &lt;code&gt;timeout_fn&lt;/code&gt; was specified, the iterator stops yielding.</source>
          <target state="translated">시간 종료가 만료되고 &lt;code&gt;timeout_fn&lt;/code&gt; 이 지정 되지 않은 경우 반복기는 수율을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="0ce0283a8891c6dd66c32b4615d78fc780d2dda4" translate="yes" xml:space="preserve">
          <source>If the two objects compare equal then they will automatically compare almost equal.</source>
          <target state="translated">두 객체가 동일하게 비교되면 자동으로 거의 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="35ceb4feec8fb5679f604323d53b185248a5db16" translate="yes" xml:space="preserve">
          <source>If the two sequences compare equal then they will automatically compare almost equal.</source>
          <target state="translated">두 시퀀스가 ​​동일하게 비교되면 자동으로 거의 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="9eae4d4a1fd60b32f2c7d8f6f2a10067a9a6d7e6" translate="yes" xml:space="preserve">
          <source>If the two shapes can not be broadcasted.</source>
          <target state="translated">두 모양을 방송 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="0d3475d1b1b8cd88a2f94da998df8de0a1aae9b7" translate="yes" xml:space="preserve">
          <source>If the two structures differ in the type of sequence in any of their substructures. Only possible if &lt;code&gt;check_types&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">두 구조의 하위 구조에서 시퀀스 유형이 다른 경우. &lt;code&gt;check_types&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우에만 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="95bfb47b075490744ea9721025fb70fedba814a4" translate="yes" xml:space="preserve">
          <source>If the two structures do not have the same number of elements or if the two structures are not nested in the same way.</source>
          <target state="translated">두 구조의 요소 수가 같지 않거나 두 구조가 같은 방식으로 중첩되지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="73def4adcaec6420d05f38da2b9b05aadf56707a" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;features&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;. Similarly for &lt;code&gt;weights&lt;/code&gt;, if not &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;features&lt;/code&gt; 시퀀스 유형이 &lt;code&gt;feature_config&lt;/code&gt; 의 해당 시퀀스와 일치하지 않는 경우 . &lt;code&gt;None&lt;/code&gt; 이 아니라면 &lt;code&gt;weights&lt;/code&gt; 에 대해서도 비슷 합니다.</target>
        </trans-unit>
        <trans-unit id="4c31d4a26026b902293fe12faee2cc27d70da5f2" translate="yes" xml:space="preserve">
          <source>If the type of any sequence in &lt;code&gt;gradients&lt;/code&gt; does not match corresponding sequence in &lt;code&gt;feature_config&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;gradients&lt;/code&gt; 시퀀스 유형이 &lt;code&gt;feature_config&lt;/code&gt; 의 해당 시퀀스와 일치하지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="2de6747c93c96034acd5b828eb4c1ac1d1759818" translate="yes" xml:space="preserve">
          <source>If the underlying model isn't configured to compute accuracy. You should pass &lt;code&gt;metrics=[&quot;accuracy&quot;]&lt;/code&gt; to the &lt;code&gt;.compile()&lt;/code&gt; method of the model.</source>
          <target state="translated">기본 모델이 정확도를 계산하도록 구성되지 않은 경우. 모델 의 &lt;code&gt;.compile()&lt;/code&gt; 메소드에 &lt;code&gt;metrics=[&quot;accuracy&quot;]&lt;/code&gt; 를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="64507e1140a9c0626ea583b5e87dbd260bda51eb" translate="yes" xml:space="preserve">
          <source>If the value of the &lt;code&gt;trainable&lt;/code&gt; attribute is changed after calling &lt;code&gt;compile()&lt;/code&gt; on a model, the new value doesn't take effect for this model until &lt;code&gt;compile()&lt;/code&gt; is called again.</source>
          <target state="translated">모델에서 &lt;code&gt;compile()&lt;/code&gt; 을 호출 한 후 &lt;code&gt;trainable&lt;/code&gt; 속성 값 이 변경 되면 &lt;code&gt;compile()&lt;/code&gt; 다시 호출 할 때까지이 모델에 새 값이 적용되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0ec166eb5f0480259a89fe33597cbbfaf40ea475" translate="yes" xml:space="preserve">
          <source>If the values in axes exceed the rank of the corresponding tensor.</source>
          <target state="translated">좌표축의 값이 해당 텐서의 순위를 초과하는 경우.</target>
        </trans-unit>
        <trans-unit id="fcd89116881b160da2d890f238051b8324a1b3f6" translate="yes" xml:space="preserve">
          <source>If the variable was initialized to zero, you can divide by &lt;code&gt;1 - momentum ** num_updates&lt;/code&gt; to debias it (Section 3 of &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Kingma et al., 2015&lt;/a&gt;):</source>
          <target state="translated">변수가 0으로 초기화 된 경우 &lt;code&gt;1 - momentum ** num_updates&lt;/code&gt; 로 나눌 수 있습니다 ( &lt;a href=&quot;https://arxiv.org/abs/1412.6980&quot;&gt;Kingma et al., 2015&lt;/a&gt; 의 섹션 3 ).</target>
        </trans-unit>
        <trans-unit id="bc2bf8a9253fdc438cae9ed780e601ca5be3a051" translate="yes" xml:space="preserve">
          <source>If the vocabulary cannot be set when this function is called. This happens when &quot;binary&quot;, &quot;count&quot;, and &quot;tfidf&quot; modes, if &quot;pad_to_max_tokens&quot; is False and the layer itself has already been called.</source>
          <target state="translated">이 함수가 호출 될 때 어휘를 설정할 수없는 경우. 이는 &quot;binary&quot;, &quot;count&quot;및 &quot;tfidf&quot;모드에서 &quot;pad_to_max_tokens&quot;가 False이고 레이어 자체가 이미 호출 된 경우 발생합니다.</target>
        </trans-unit>
        <trans-unit id="364282886e323bb3ccb0f79b39dcdce0b99762de" translate="yes" xml:space="preserve">
          <source>If there are conflicting keys detected when merging two or more dictionaries, this exception is raised.</source>
          <target state="translated">둘 이상의 사전을 병합 할 때 충돌하는 키가 감지되면이 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a726849408c4956726cdbe5ad4e4c413105f47a" translate="yes" xml:space="preserve">
          <source>If there are errors during the file save operation.</source>
          <target state="translated">파일 저장 작업 중에 오류가있는 경우.</target>
        </trans-unit>
        <trans-unit id="388fe17c0df4d7e0778657b27663a6a6e2a4aad0" translate="yes" xml:space="preserve">
          <source>If there are filesystem / directory listing errors.</source>
          <target state="translated">파일 시스템 / 디렉토리 나열 오류가있는 경우.</target>
        </trans-unit>
        <trans-unit id="8acb8371bc3eb15ec09be518ceef07a3ea9797ba" translate="yes" xml:space="preserve">
          <source>If there are no arguments passed.</source>
          <target state="translated">전달 된 인수가없는 경우.</target>
        </trans-unit>
        <trans-unit id="397c97cfbe31f32ae505b25e33933f6512b38899" translate="yes" xml:space="preserve">
          <source>If there are too many inputs, the inputs do not match, or input data is missing.</source>
          <target state="translated">입력이 너무 많으면 입력이 일치하지 않거나 입력 데이터가 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="9279bebc813b4c73813e2c61b0ade7210ad036f6" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="translated">사이에 충돌이있는 경우 &lt;code&gt;predict_keys&lt;/code&gt; 및 &lt;code&gt;predictions&lt;/code&gt; . 예를 들어 &lt;code&gt;predict_keys&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아니라 &lt;a href=&quot;../../../../estimator/estimatorspec#predictions&quot;&gt; &lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;dict&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="899df9e02e8493f5b070e1bc0642e86903996f5d" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../../../estimator/estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="translated">사이에 충돌이있는 경우 &lt;code&gt;predict_keys&lt;/code&gt; 및 &lt;code&gt;predictions&lt;/code&gt; . 예를 들어 &lt;code&gt;predict_keys&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아니라 &lt;a href=&quot;../../../estimator/estimatorspec#predictions&quot;&gt; &lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;dict&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="c84b959e75c6d0c07150d6bf472c7eaa938705d4" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;../estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="translated">사이에 충돌이있는 경우 &lt;code&gt;predict_keys&lt;/code&gt; 및 &lt;code&gt;predictions&lt;/code&gt; . 예를 들어 &lt;code&gt;predict_keys&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아니라 &lt;a href=&quot;../estimatorspec#predictions&quot;&gt; &lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;dict&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="8fba7df71af1734c3900ec5722da912184e87acd" translate="yes" xml:space="preserve">
          <source>If there is a conflict between &lt;code&gt;predict_keys&lt;/code&gt; and &lt;code&gt;predictions&lt;/code&gt;. For example if &lt;code&gt;predict_keys&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt; but &lt;a href=&quot;estimatorspec#predictions&quot;&gt;&lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt;&lt;/a&gt; is not a &lt;code&gt;dict&lt;/code&gt;.</source>
          <target state="translated">사이에 충돌이있는 경우 &lt;code&gt;predict_keys&lt;/code&gt; 및 &lt;code&gt;predictions&lt;/code&gt; . 예를 들어 &lt;code&gt;predict_keys&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 이 아니라 &lt;a href=&quot;estimatorspec#predictions&quot;&gt; &lt;code&gt;tf.estimator.EstimatorSpec.predictions&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;dict&lt;/code&gt; 가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="d869a15febad2f275c04757cafb49397fc0fa415" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">마지막 부분 배치가있는 경우 결과 모양이 복제본간에 일관되도록 축을 지정해야합니다. 따라서 마지막 배치의 크기가 6이고 [0, 1, 2, 3] 및 [4, 5]로 나뉘어지면 &lt;code&gt;axis=0&lt;/code&gt; 을 지정하지 않으면 모양이 일치하지 않습니다 . 지정하면 &lt;a href=&quot;../../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; 을&lt;/a&gt; 이용한 &lt;code&gt;axis=0&lt;/code&gt; 컴퓨팅 제 명암이 올바른 분모를 사용 &lt;code&gt;reduce_mean&lt;/code&gt; 일부 값 나가는 각 복제에 대한 스칼라 값을 그 평균 수단이 기능을 얻는 &lt;code&gt;1/8&lt;/code&gt; 및 기타 &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c72f727cca64a808cf7c4b7c3edec0a4599f0ee" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">마지막 부분 배치가있는 경우 결과 모양이 복제본간에 일관되도록 축을 지정해야합니다. 따라서 마지막 배치의 크기가 6이고 [0, 1, 2, 3] 및 [4, 5]로 나뉘어지면 &lt;code&gt;axis=0&lt;/code&gt; 을 지정하지 않으면 모양이 일치하지 않습니다 . 지정하면 &lt;a href=&quot;../../../distribute/reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; 을&lt;/a&gt; 이용한 &lt;code&gt;axis=0&lt;/code&gt; 컴퓨팅 제 명암이 올바른 분모를 사용 &lt;code&gt;reduce_mean&lt;/code&gt; 일부 값 나가는 각 복제에 대한 스칼라 값을 그 평균 수단이 기능을 얻는 &lt;code&gt;1/8&lt;/code&gt; 및 기타 &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="611167fb33b99cb5686e6e2a810b98db2c2349ad" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;../reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">마지막 부분 배치가있는 경우 결과 모양이 복제본간에 일관되도록 축을 지정해야합니다. 따라서 마지막 배치의 크기가 6이고 [0, 1, 2, 3] 및 [4, 5]로 나뉘어지면 &lt;code&gt;axis=0&lt;/code&gt; 을 지정하지 않으면 모양이 일치하지 않습니다 . 지정하면 &lt;a href=&quot;../reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; 을&lt;/a&gt; 이용한 &lt;code&gt;axis=0&lt;/code&gt; 컴퓨팅 제 명암이 올바른 분모를 사용 &lt;code&gt;reduce_mean&lt;/code&gt; 일부 값 나가는 각 복제에 대한 스칼라 값을 그 평균 수단이 기능을 얻는 &lt;code&gt;1/8&lt;/code&gt; 및 기타 &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9048470fa4efaf23b25ac2170e5cb511464506dc" translate="yes" xml:space="preserve">
          <source>If there is a last partial batch, you will need to specify an axis so that the resulting shape is consistent across replicas. So if the last batch has size 6 and it is divided into [0, 1, 2, 3] and [4, 5], you would get a shape mismatch unless you specify &lt;code&gt;axis=0&lt;/code&gt;. If you specify &lt;a href=&quot;reduceop#MEAN&quot;&gt;&lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt;&lt;/a&gt;, using &lt;code&gt;axis=0&lt;/code&gt; will use the correct denominator of 6. Contrast this with computing &lt;code&gt;reduce_mean&lt;/code&gt; to get a scalar value on each replica and this function to average those means, which will weigh some values &lt;code&gt;1/8&lt;/code&gt; and others &lt;code&gt;1/4&lt;/code&gt;.</source>
          <target state="translated">마지막 부분 배치가있는 경우 결과 모양이 복제본간에 일관되도록 축을 지정해야합니다. 따라서 마지막 배치의 크기가 6이고 [0, 1, 2, 3] 및 [4, 5]로 나뉘어지면 &lt;code&gt;axis=0&lt;/code&gt; 을 지정하지 않으면 모양이 일치하지 않습니다 . 지정하면 &lt;a href=&quot;reduceop#MEAN&quot;&gt; &lt;code&gt;tf.distribute.ReduceOp.MEAN&lt;/code&gt; 을&lt;/a&gt; 이용한 &lt;code&gt;axis=0&lt;/code&gt; 컴퓨팅 제 명암이 올바른 분모를 사용 &lt;code&gt;reduce_mean&lt;/code&gt; 일부 값 나가는 각 복제에 대한 스칼라 값을 그 평균 수단이 기능을 얻는 &lt;code&gt;1/8&lt;/code&gt; 및 기타 &lt;code&gt;1/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7191342d52aa3d47ff7927195bf323c54a2bcc" translate="yes" xml:space="preserve">
          <source>If there is a shape mismatch between the inputs and the shapes cannot be broadcasted to match.</source>
          <target state="translated">입력 사이에 모양 불일치가 있고 모양을 일치시키기 위해 브로드 캐스트 할 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="d85ee17d394a0c122c1d9a09f179d26aa5670744" translate="yes" xml:space="preserve">
          <source>If there is no KL method registered specifically for &lt;code&gt;type(distribution_a)&lt;/code&gt; and &lt;code&gt;type(distribution_b)&lt;/code&gt;, then the class hierarchies of these types are searched.</source>
          <target state="translated">&lt;code&gt;type(distribution_a)&lt;/code&gt; 및 &lt;code&gt;type(distribution_b)&lt;/code&gt; 대해 특별히 등록 된 KL 메소드가 없으면 이러한 유형의 클래스 계층 구조가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0aad6242676f764d7914e7304fd4bc4d049fdd75" translate="yes" xml:space="preserve">
          <source>If there is no TypeSpec that is compatible with both &lt;code&gt;self&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 및 &lt;code&gt;other&lt;/code&gt; 와 호환되는 TypeSpec이없는 경우 .</target>
        </trans-unit>
        <trans-unit id="2c8e6b1b3d8134f559708fe8c9597d36901255cf" translate="yes" xml:space="preserve">
          <source>If there is no active profiling session.</source>
          <target state="translated">활성 프로파일 링 세션이없는 경우.</target>
        </trans-unit>
        <trans-unit id="dd7912243ede8abeeda54d04f710e447b16a7a2e" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 0.</source>
          <target state="translated">주어진 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 에 대한 항목이 없으면 0을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="cf1d14f3c88546018feaf0d39b2b59114e95d67f" translate="yes" xml:space="preserve">
          <source>If there is no entry for a given segment ID &lt;code&gt;i&lt;/code&gt;, it outputs 1.</source>
          <target state="translated">주어진 세그먼트 ID &lt;code&gt;i&lt;/code&gt; 에 대한 항목이 없으면 1을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="8b273aa994678829ffd0b282cbffdded4906ae32" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;Session&lt;/code&gt; is in an invalid state (e.g. has been closed).</source>
          <target state="translated">이 &lt;code&gt;Session&lt;/code&gt; 이 유효하지 않은 상태 (예 : 종료 됨) 인 경우.</target>
        </trans-unit>
        <trans-unit id="5311650ce8de279027f2e15a0c08573e4eb50ee1" translate="yes" xml:space="preserve">
          <source>If this is callable, it should be a function of one argument that inspects the passed-in exception and returns True (success) or False (please fail the test). Otherwise, the error message is expected to match this regular expression partially.</source>
          <target state="translated">이것이 호출 가능한 경우 전달 된 예외를 검사하고 True (성공) 또는 False (테스트에 실패하십시오)를 반환하는 하나의 인수 함수 여야합니다. 그렇지 않으면 오류 메시지가이 정규식과 부분적으로 일치 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="905304f1bcc984112aa96111001589bd421fac68" translate="yes" xml:space="preserve">
          <source>If this is called before apply_gradients().</source>
          <target state="translated">apply_gradients () 전에 호출되는 경우.</target>
        </trans-unit>
        <trans-unit id="7bf5400cdc3e4d05bcb2e0233a34376a166c6575" translate="yes" xml:space="preserve">
          <source>If this is not the case for your loss (if, for example, your loss references a &lt;code&gt;Variable&lt;/code&gt; of one of the model's layers), you can wrap your loss in a zero-argument lambda. These losses are not tracked as part of the model's topology since they can't be serialized.</source>
          <target state="translated">이것이 손실이 아닌 경우 (예를 들어 손실 이 모델 계층 중 하나의 &lt;code&gt;Variable&lt;/code&gt; 를 참조하는 경우 ) 손실을 제로 인수 람다로 묶을 수 있습니다. 이러한 손실은 직렬화 할 수 없으므로 모델 토폴로지의 일부로 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a16f543cad9c6d848f192a10e84648afb82147fd" translate="yes" xml:space="preserve">
          <source>If this layer is used when using tf.distribute strategy to train models across devices/workers, there will be an allreduce call to aggregate batch statistics across all replicas at every training step. Without tf.distribute strategy, this layer behaves as a regular &lt;a href=&quot;../batchnormalization&quot;&gt;&lt;code&gt;tf.keras.layers.BatchNormalization&lt;/code&gt;&lt;/a&gt; layer.</source>
          <target state="translated">tf.distribute 전략을 사용하여 장치 / 작업자간에 모델을 교육 할 때이 계층을 사용하면 모든 교육 단계에서 모든 복제본에 대한 일괄 통계를 집계하는 allreduce 호출이 발생합니다. tf.distribute 전략이 없으면이 레이어는 일반 &lt;a href=&quot;../batchnormalization&quot;&gt; &lt;code&gt;tf.keras.layers.BatchNormalization&lt;/code&gt; &lt;/a&gt; 레이어 로 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="3fe81d5d5eaf76d2a5be367788954521f73bd4d6" translate="yes" xml:space="preserve">
          <source>If this method is called inside defun.</source>
          <target state="translated">이 메서드가 defun 내부에서 호출되면.</target>
        </trans-unit>
        <trans-unit id="a3a84b9a7746118e73d604dc320af07d2b1b6de8" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_scaled_loss&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">이 메소드를 호출하면 &lt;code&gt;get_scaled_loss&lt;/code&gt; 도 호출해야합니다. 예제 는 &lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="90126041d843d207c1a230dd608378fc394de215" translate="yes" xml:space="preserve">
          <source>If this method is called, &lt;code&gt;get_unscaled_gradients&lt;/code&gt; should also be called. See the &lt;a href=&quot;lossscaleoptimizer&quot;&gt;&lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt;&lt;/a&gt; doc for an example.</source>
          <target state="translated">이 메소드가 호출되면 &lt;code&gt;get_unscaled_gradients&lt;/code&gt; 도 호출되어야합니다. 예제 는 &lt;a href=&quot;lossscaleoptimizer&quot;&gt; &lt;code&gt;tf.keras.mixed_precision.experimental.LossScaleOptimizer&lt;/code&gt; &lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="668c59e4c87d0ca62e75f8e9f92138d3a33081f3" translate="yes" xml:space="preserve">
          <source>If this op does not have an attr with the given &lt;code&gt;name&lt;/code&gt;.</source>
          <target state="translated">이 작업에 주어진 &lt;code&gt;name&lt;/code&gt; 의 속성이없는 경우 .</target>
        </trans-unit>
        <trans-unit id="6ab5fd845bbcbc69da7d15bc16ce0eb8f62203dd" translate="yes" xml:space="preserve">
          <source>If this op is configured to not have padding, or if it is configured to add padding with &lt;code&gt;padding_width&lt;/code&gt; set to less than ngram_width-1, it is possible that a sequence, or a sequence plus padding, is smaller than the ngram width. In that case, no ngrams will be generated for that sequence. This can be prevented by setting &lt;code&gt;preserve_short_sequences&lt;/code&gt;, which will cause the op to always generate at least one ngram per non-empty sequence.</source>
          <target state="translated">이 op가 패딩을 갖지 않도록 구성되거나 &lt;code&gt;padding_width&lt;/code&gt; 가 ngram_width-1보다 작게 설정된 패딩을 추가하도록 구성된 경우 시퀀스 또는 시퀀스 플러스 패딩이 ngram 너비보다 작을 수 있습니다. 이 경우 해당 시퀀스에 대해 ngram이 생성되지 않습니다. &lt;code&gt;preserve_short_sequences&lt;/code&gt; 를 설정하면이를 방지 할 수 있습니다.이 경우 op가 비어 있지 않은 시퀀스 당 적어도 하나의 ngram을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="ab839358f55486546d3d029071a450dcaefa7d5b" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">이 오퍼레이터가 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 복귀 &lt;code&gt;M&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ce9f7e3db7531975f11e7f4a68cd88c0d560996" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">이 오퍼레이터가 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 복귀 &lt;code&gt;N&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="62e8ab46dc91b8378fc928855066ea5b3d23a6e6" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape&lt;/code&gt;.</source>
          <target state="translated">이 연산자 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 복귀 &lt;code&gt;TensorShape([B1,...,Bb, M, N])&lt;/code&gt; , 당량 &lt;code&gt;A.shape&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="689aa8d64b08329267dae138eebcb059972cf24c" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt;, equivalent to &lt;code&gt;A.shape[:-2]&lt;/code&gt;</source>
          <target state="translated">이 연산자가 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; 인 배치 행렬 &lt;code&gt;A&lt;/code&gt; 처럼 작동하면 A.shape [ 와 동일한 &lt;code&gt;TensorShape([B1,...,Bb])&lt;/code&gt; 를 &lt;code&gt;A.shape[:-2]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e16fa6d80d3c7cfd9673c1871d91dcd51542d167" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns &lt;code&gt;b + 2&lt;/code&gt;.</source>
          <target state="translated">이 오퍼레이터가 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 반환 &lt;code&gt;b + 2&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03127ec398775f2a4051ba0c818b1ec18cf14baf" translate="yes" xml:space="preserve">
          <source>If this operator acts like the batch matrix &lt;code&gt;A&lt;/code&gt; with &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt;, then this returns a &lt;code&gt;Tensor&lt;/code&gt; holding &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt;, equivalent to &lt;a href=&quot;../shape&quot;&gt;&lt;code&gt;tf.shape(A)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 연산자 배치 매트릭스와 같은 역할을하는 경우 와 &lt;code&gt;A.shape = [B1,...,Bb, M, N]&lt;/code&gt; ,이 리턴 &lt;code&gt;Tensor&lt;/code&gt; 유지 &lt;code&gt;[B1,...,Bb, M, N]&lt;/code&gt; 에 동등한 &lt;a href=&quot;../shape&quot;&gt; &lt;code&gt;tf.shape(A)&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
