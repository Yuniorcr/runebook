<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rails">
    <body>
      <group id="rails">
        <trans-unit id="d4aa95a3ac525010d9d553d3d539f76c08530f29" translate="yes" xml:space="preserve">
          <source>If the application has multiple databases &lt;code&gt;default_hash&lt;/code&gt; will return the first config hash for the environment.</source>
          <target state="translated">응용 프로그램에 여러 데이터베이스가있는 경우 &lt;code&gt;default_hash&lt;/code&gt; 는 환경에 대한 첫 번째 구성 해시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="fb1aab9339cac818d842e223a95e7f4e26a1a6fc" translate="yes" xml:space="preserve">
          <source>If the application has multiple databases &lt;code&gt;find_db_config&lt;/code&gt; will return the first DatabaseConfig for the environment.</source>
          <target state="translated">응용 프로그램에 여러 데이터베이스가있는 경우 &lt;code&gt;find_db_config&lt;/code&gt; 는 환경에 대한 첫 번째 DatabaseConfig를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f680842e1a02b973e8a00e3a8dd67a7c3319c24b" translate="yes" xml:space="preserve">
          <source>If the application is receiving a POST, PUT, DELETE, or PATCH request the application will automatically write to the primary. For the specified time after the write the application will read from the primary. For a GET or HEAD request the application will read from the replica unless there was a recent write.</source>
          <target state="translated">애플리케이션이 POST, PUT, DELETE 또는 PATCH 요청을 수신하는 경우 애플리케이션은 자동으로 기본에 작성합니다. 쓰기 후 지정된 시간 동안 응용 프로그램은 기본에서 읽습니다. GET 또는 HEAD 요청의 경우 최근 쓰기가 없으면 애플리케이션이 복제본에서 읽습니다.</target>
        </trans-unit>
        <trans-unit id="909fc810dae4f27a7bbf51eefe6ac6990dff14c0" translate="yes" xml:space="preserve">
          <source>If the application is receiving a POST, PUT, DELETE, or PATCH request the application will automatically write to the writer database. For the specified time after the write, the application will read from the primary. For a GET or HEAD request the application will read from the replica unless there was a recent write.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50ee9914ee15dcddb5ea41c1f07a06211d2c93b3" translate="yes" xml:space="preserve">
          <source>If the application is using legacy handling, returns true if `connection_handler.prevent_writes` is set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9cb1ccc90bd501b359f2efe7ca8f3573c3959c8" translate="yes" xml:space="preserve">
          <source>If the application is using the new connection handling will return true based on `current_preventing_writes`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="326b22dd6ad7847de589279464886345310126e4" translate="yes" xml:space="preserve">
          <source>If the application reloads &lt;code&gt;Foo&lt;/code&gt;, it will reload &lt;code&gt;Foo::InnerClass&lt;/code&gt; too.</source>
          <target state="translated">응용 프로그램이 &lt;code&gt;Foo&lt;/code&gt; 를 다시로드하면 &lt;code&gt;Foo::InnerClass&lt;/code&gt; 도 다시로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="db2293cef2136baca8a7b93f90673cf39b14d10d" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;false&lt;/code&gt; (default is &lt;code&gt;nil&lt;/code&gt;), the context is set to &lt;code&gt;:create&lt;/code&gt; if &lt;a href=&quot;persistence#method-i-new_record-3F&quot;&gt;new_record?&lt;/a&gt; is &lt;code&gt;true&lt;/code&gt;, and to &lt;code&gt;:update&lt;/code&gt; if it is not.</source>
          <target state="translated">인수가 &lt;code&gt;false&lt;/code&gt; 인 경우 (기본값은 &lt;code&gt;nil&lt;/code&gt; ) 컨텍스트는 &lt;code&gt;:create&lt;/code&gt; if &lt;a href=&quot;persistence#method-i-new_record-3F&quot;&gt;new_record?&lt;/a&gt; 이다 &lt;code&gt;true&lt;/code&gt; 과에 &lt;code&gt;:update&lt;/code&gt; 그렇지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="ac479f598d7a18aa8574ef0192142fbdf57ba66e" translate="yes" xml:space="preserve">
          <source>If the argument is &lt;code&gt;nil&lt;/code&gt; an empty array is returned.</source>
          <target state="translated">인수가 &lt;code&gt;nil&lt;/code&gt; 이면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2046e4902050e114601a1f73a8a4cd63259a9aa" translate="yes" xml:space="preserve">
          <source>If the argument is a regular hash with keys &lt;code&gt;:key&lt;/code&gt; and +&amp;ldquo;key&amp;rdquo;+ only one of the values end up in the receiver, but which one is unspecified.</source>
          <target state="translated">인수가 keys &lt;code&gt;:key&lt;/code&gt; 및 +&amp;ldquo;key&amp;rdquo;+ 가있는 일반 해시 인 경우 값 중 하나만 수신자에서 끝나지만 지정되지 않은 값입니다.</target>
        </trans-unit>
        <trans-unit id="325a0f07bed101c05c27938ff0c0d61231ed5daa" translate="yes" xml:space="preserve">
          <source>If the argument is an &lt;code&gt;IO&lt;/code&gt; it needs to respond to &lt;code&gt;rewind&lt;/code&gt; to be able to retry. Regular files respond to &lt;code&gt;rewind&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;IO&lt;/code&gt; 인 경우 다시 시도 하려면 &lt;code&gt;rewind&lt;/code&gt; 에 응답해야합니다 . 일반 파일은 &lt;code&gt;rewind&lt;/code&gt; 응답합니다 .</target>
        </trans-unit>
        <trans-unit id="c86fa94e4c85e9b7de6cada7ae5acbfdc209ad77" translate="yes" xml:space="preserve">
          <source>If the argument responds to &lt;code&gt;to_ary&lt;/code&gt; the method is invoked. &lt;code&gt;Kernel#Array&lt;/code&gt; moves on to try &lt;code&gt;to_a&lt;/code&gt; if the returned value is &lt;code&gt;nil&lt;/code&gt;, but &lt;code&gt;Array.wrap&lt;/code&gt; returns an array with the argument as its single element right away.</source>
          <target state="translated">인수가 &lt;code&gt;to_ary&lt;/code&gt; 에 응답 하면 메소드가 호출됩니다. 반환 된 값이 &lt;code&gt;nil&lt;/code&gt; 이면 &lt;code&gt;Kernel#Array&lt;/code&gt; 는 &lt;code&gt;to_a&lt;/code&gt; 를 시도 하지만 &lt;code&gt;Array.wrap&lt;/code&gt; 은 인수를 단일 요소로 즉시 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41cd3a71604d9e843f2f91cca28d83b7278bc07d" translate="yes" xml:space="preserve">
          <source>If the array contains items that respond to &lt;code&gt;id&lt;/code&gt;, however, the symbol &lt;code&gt;:db&lt;/code&gt; may be passed as argument. That's typically used with collections of Active Record objects. Returned strings are:</source>
          <target state="translated">그러나 배열에 &lt;code&gt;id&lt;/code&gt; 에 응답하는 항목이 포함 된 경우 &lt;code&gt;:db&lt;/code&gt; 기호 가 인수로 전달 될 수 있습니다. 일반적으로 Active Record 개체의 컬렉션에 사용됩니다. 반환 된 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d1a8481496ba475a6221bc0678c9e41eadfe7f28" translate="yes" xml:space="preserve">
          <source>If the associated object has already been retrieved from the database for this object, the cached version will be returned. To override this behavior (and force a database read), call &lt;code&gt;#reload_association&lt;/code&gt; on the parent object.</source>
          <target state="translated">연관된 오브젝트가이 오브젝트의 데이터베이스에서 이미 검색된 경우 캐시 된 버전이 리턴됩니다. 이 동작을 무시하고 데이터베이스를 강제로 읽으 려면 부모 개체에서 &lt;code&gt;#reload_association&lt;/code&gt; 을 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd7406b4360425aaa9836f7b1c871148c2cf19e8" translate="yes" xml:space="preserve">
          <source>If the associated object is already saved, &lt;code&gt;fields_for&lt;/code&gt; autogenerates a hidden input with the &lt;code&gt;id&lt;/code&gt; of the saved record. You can disable this by passing &lt;code&gt;include_id: false&lt;/code&gt; to &lt;code&gt;fields_for&lt;/code&gt;.</source>
          <target state="translated">연관된 오브젝트가 이미 저장된 경우 &lt;code&gt;fields_for&lt;/code&gt; 는 저장된 레코드 의 &lt;code&gt;id&lt;/code&gt; 로 숨겨진 입력을 자동 생성합니다 . &lt;code&gt;include_id: false&lt;/code&gt; 를 &lt;code&gt;fields_for&lt;/code&gt; 에 전달하여이를 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8c0c0a2268466b90cbd0d19ea4fd9c935c11564" translate="yes" xml:space="preserve">
          <source>If the association on the join model is a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;&lt;code&gt;belongs_to&lt;/code&gt;&lt;/a&gt;, the collection can be modified and the records on the &lt;code&gt;:through&lt;/code&gt; model will be automatically created and removed as appropriate. Otherwise, the collection is read-only, so you should manipulate the &lt;code&gt;:through&lt;/code&gt; association directly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7e3e35c9e6408f86f98236f54c35fb677605bb6" translate="yes" xml:space="preserve">
          <source>If the association on the join model is a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt;, the collection can be modified and the records on the &lt;code&gt;:through&lt;/code&gt; model will be automatically created and removed as appropriate. Otherwise, the collection is read-only, so you should manipulate the &lt;code&gt;:through&lt;/code&gt; association directly.</source>
          <target state="translated">결합 모델의 연관이 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 이면, 콜렉션을 수정할 수 있으며 &lt;code&gt;:through&lt;/code&gt; 모델 의 레코드 가 자동으로 작성되고 제거됩니다. 그렇지 않으면 콜렉션이 읽기 전용이므로 &lt;code&gt;:through&lt;/code&gt; 연관을 직접 조작해야합니다 .</target>
        </trans-unit>
        <trans-unit id="98b11abf71641fea4a9eb3516297f9ce3d317a60" translate="yes" xml:space="preserve">
          <source>If the attribute will change, the result will be an array containing the original value and the new value about to be saved.</source>
          <target state="translated">속성이 변경되면 결과는 원래 값과 저장하려는 새 값을 포함하는 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="abc08bce3c6bd92decb8682fb71c627eef62c39e" translate="yes" xml:space="preserve">
          <source>If the block passed to the method only takes one parameter, it will yield an event object to the block:</source>
          <target state="translated">메소드에 전달 된 블록이 하나의 매개 변수 만 사용하면 블록에 이벤트 오브젝트가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1e04aa7986db4a6025797859ae6d071fe498f89b" translate="yes" xml:space="preserve">
          <source>If the cached data refers to a constant that is unknown at that point, the autoloading mechanism is triggered and if it succeeds the deserialization is retried transparently.</source>
          <target state="translated">캐시 된 데이터가 해당 시점에서 알려지지 않은 상수를 참조하면 자동 로딩 메커니즘이 트리거되고 성공하면 역 직렬화가 투명하게 재 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="3fad63c232bd8516eeb4fdd2908396ef6298bc7a" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;update&lt;/code&gt; fails, calling the &lt;code&gt;update&lt;/code&gt; action in this controller will render the &lt;code&gt;edit.html.erb&lt;/code&gt; template belonging to the same controller.</source>
          <target state="translated">&lt;code&gt;update&lt;/code&gt; 호출이 실패하면 이 컨트롤러에서 &lt;code&gt;update&lt;/code&gt; 작업을 호출 하면 동일한 컨트롤러에 속하는 &lt;code&gt;edit.html.erb&lt;/code&gt; 템플릿 이 렌더링 됩니다.</target>
        </trans-unit>
        <trans-unit id="16cd334d2e15cae6ee63be60a754872d86228099" translate="yes" xml:space="preserve">
          <source>If the callback chain was halted, returns &lt;code&gt;false&lt;/code&gt;. Otherwise returns the result of the block, &lt;code&gt;nil&lt;/code&gt; if no callbacks have been set, or &lt;code&gt;true&lt;/code&gt; if callbacks have been set but no block is given.</source>
          <target state="translated">콜백 체인이 중지 된 경우 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 . 그렇지 않으면 블록의 결과를 반환하고, 콜백이 설정되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; , 콜백이 설정되었지만 블록이 제공되지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="41c725c6024bced2df392feb33d1c57a94be32f1" translate="yes" xml:space="preserve">
          <source>If the callback method is declared this way, it won't be necessary to instantiate a &lt;code&gt;PictureFileCallbacks&lt;/code&gt; object.</source>
          <target state="translated">콜백 메소드가 이런 식으로 선언되면 &lt;code&gt;PictureFileCallbacks&lt;/code&gt; 객체 를 인스턴스화 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="1c4eaca745cedef97a53c140559bbe1f6d49b699" translate="yes" xml:space="preserve">
          <source>If the callback renders or redirects, the action will not run. If there are additional callbacks scheduled to run after that callback, they are also cancelled.</source>
          <target state="translated">콜백이 렌더링되거나 리디렉션되면 작업이 실행되지 않습니다. 해당 콜백 이후에 추가 콜백이 실행되도록 예약 된 경우 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="2784a39d87d3eb7ac3e4e522ea28602c361bb4bb" translate="yes" xml:space="preserve">
          <source>If the categories &amp;ldquo;2008 stuff&amp;rdquo; and &amp;ldquo;Christmas&amp;rdquo; return true when the method &lt;code&gt;archived?&lt;/code&gt; is called, this would return:</source>
          <target state="translated">메소드가 &lt;code&gt;archived?&lt;/code&gt; 될 때 &quot;2008 stuff&quot;및 &quot;Christmas&quot;범주가 true를 반환하는 경우 호출되면 다음을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8166306f0157b1a8dd560d1d779cbab37120bc5d" translate="yes" xml:space="preserve">
          <source>If the class has an initializer, it must accept no arguments.</source>
          <target state="translated">클래스에 이니셜 라이저가 있으면 인수를 허용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="60e9c66606c8b362e2f076c77691827cc9c68751" translate="yes" xml:space="preserve">
          <source>If the client wants HTML, we just redirect them back to the person list. If they want JavaScript, then it is an Ajax request and we render the JavaScript template associated with this action. Lastly, if the client wants XML, we render the created person as XML, but with a twist: we also include the person's company in the rendered XML, so you get something like this:</source>
          <target state="translated">고객이 HTML을 원한다면, 사용자 목록으로 다시 리디렉션하면됩니다. 자바 스크립트를 원하는 경우 Ajax 요청이며이 조치와 연관된 JavaScript 템플리트를 렌더링합니다. 마지막으로, 클라이언트가 XML을 원한다면 생성 된 사람을 XML로 렌더링하지만, 왜곡 된 방식으로 사람의 회사도 렌더링 된 XML에 포함 시키므로 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e8ac405dee5bd727438c7f644b7f729f1f6da4d" translate="yes" xml:space="preserve">
          <source>If the code block is provided, then it will be run and its result returned.</source>
          <target state="translated">코드 블록이 제공되면 코드 블록이 실행되고 결과가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cc3cada6acaa9bd09b8ed52dcd9735c77ae53d60" translate="yes" xml:space="preserve">
          <source>If the collection has been already loaded &lt;code&gt;size&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; are equivalent. If not and you are going to need the records anyway &lt;code&gt;length&lt;/code&gt; will take one less query. Otherwise &lt;code&gt;size&lt;/code&gt; is more efficient.</source>
          <target state="translated">컬렉션이 이미로드 된 경우 &lt;code&gt;size&lt;/code&gt; 와 &lt;code&gt;length&lt;/code&gt; 는 같습니다. 그렇지 않은 경우 어쨌든 &lt;code&gt;length&lt;/code&gt; 가 필요한 레코드 는 하나 더 적은 쿼리가 필요합니다 . 그렇지 않으면 &lt;code&gt;size&lt;/code&gt; 가 더 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="34e946ebf3ea03c136bdeda35b3d897d8593404f" translate="yes" xml:space="preserve">
          <source>If the collection is empty the root element is &amp;ldquo;nil-classes&amp;rdquo; by default:</source>
          <target state="translated">컬렉션이 비어 있으면 루트 요소는 기본적으로 &quot;nil-classes&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="b7f67bf3a1604fd5392ad21dc4b5f43143280301" translate="yes" xml:space="preserve">
          <source>If the collection is empty the root element is by default &quot;nil-classes&quot;. That's a gotcha, for example the root element of the list of contributors above would not be &quot;contributors&quot; if the collection was empty, but &quot;nil-classes&quot;. You may use the &lt;code&gt;:root&lt;/code&gt; option to ensure a consistent root element.</source>
          <target state="translated">컬렉션이 비어 있으면 루트 요소는 기본적으로 &quot;nil-classes&quot;입니다. 예를 들어, 위의 기고자 목록의 루트 요소는 컬렉션이 비어 있으면 &quot;기여자&quot;가 아니라 &quot;nil-classes&quot;가됩니다. &lt;code&gt;:root&lt;/code&gt; 옵션을 사용하여 일관된 루트 요소를 보장 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b613ce8577af2e7ce6ea0ef6a11c0b870b860090" translate="yes" xml:space="preserve">
          <source>If the collection is loaded, the method will iterate through the records to generate the timestamp, otherwise it will trigger one SQL query like:</source>
          <target state="translated">컬렉션이로드되면 메서드는 레코드를 반복하여 타임 스탬프를 생성합니다. 그렇지 않으면 다음과 같은 하나의 SQL 쿼리가 트리거됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5d9921fa6d0738d0807aeb7168f520fca78bec" translate="yes" xml:space="preserve">
          <source>If the condition is any blank-ish object, then &lt;a href=&quot;querymethods#method-i-where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is a no-op and returns the current relation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3893c514cabd2a7f4a09663581d1a86272afca1" translate="yes" xml:space="preserve">
          <source>If the condition is any blank-ish object, then &lt;a href=&quot;querymethods#method-i-where&quot;&gt;where&lt;/a&gt; is a no-op and returns the current relation.</source>
          <target state="translated">조건이 공백 개체 인 경우 &lt;a href=&quot;querymethods#method-i-where&quot;&gt;where&lt;/a&gt; 는 no-op이며 현재 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="341579d3965226e575f4d073b0660419a1fb1f16" translate="yes" xml:space="preserve">
          <source>If the constant is not defined at that point it is not considered to be a missing constant, autoloading is &lt;strong&gt;not&lt;/strong&gt; triggered.</source>
          <target state="translated">이 시점에서 상수가 정의되지 않은 경우 누락 된 상수로 간주 &lt;strong&gt;되지 않으며&lt;/strong&gt; 자동로드가 트리거 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="2d335c8eabf090ac0fa810d002d6a3cd1ab96a1e" translate="yes" xml:space="preserve">
          <source>If the database adapter supports DDL transactions, all migrations will automatically be wrapped in a transaction. There are queries that you can't execute inside a transaction though, and for these situations you can turn the automatic transactions off.</source>
          <target state="translated">데이터베이스 어댑터가 DDL 트랜잭션을 지원하면 모든 마이그레이션이 자동으로 트랜잭션으로 랩핑됩니다. 트랜잭션 내에서 실행할 수없는 쿼리가 있으며 이러한 상황에서는 자동 트랜잭션을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="040f2cbc6393a8808d27fc9022304d799fa6716f" translate="yes" xml:space="preserve">
          <source>If the database column does not exist, the &lt;code&gt;terms_of_service&lt;/code&gt; attribute is entirely virtual. This check is performed only if &lt;code&gt;terms_of_service&lt;/code&gt; is not &lt;code&gt;nil&lt;/code&gt; and by default on save.</source>
          <target state="translated">데이터베이스 열이 존재하지 않는 경우 &lt;code&gt;terms_of_service&lt;/code&gt; 속성은 완전히 가상입니다. 이 검사는 &lt;code&gt;terms_of_service&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우 기본적으로 저장시 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8d9b21364e4a939c4ef36197aedd2645bd258c39" translate="yes" xml:space="preserve">
          <source>If the default name of the join table, based on lexical ordering, is not what you want, you can use the &lt;code&gt;:join_table&lt;/code&gt; option to override the default.</source>
          <target state="translated">어휘 순서를 기반으로하는 조인 테이블의 기본 이름이 원하는 이름이 아닌 경우 &lt;code&gt;:join_table&lt;/code&gt; 옵션을 사용 하여 기본값을 재정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="77fd0e64933c74ff47b477c5c92febf3b85a1998" translate="yes" xml:space="preserve">
          <source>If the env contains &lt;code&gt;rack.early_hints&lt;/code&gt; then the server accepts HTTP2 push for Link headers.</source>
          <target state="translated">env에 &lt;code&gt;rack.early_hints&lt;/code&gt; 가 포함 된 경우 서버는 링크 헤더에 대한 HTTP2 푸시를 승인합니다.</target>
        </trans-unit>
        <trans-unit id="8990289b6081515b6a58646c9a9c238b5e673b53" translate="yes" xml:space="preserve">
          <source>If the error message requires options, then it returns &lt;code&gt;true&lt;/code&gt; with the correct options, or &lt;code&gt;false&lt;/code&gt; with incorrect or missing options.</source>
          <target state="translated">오류 메시지에 옵션이 필요한 경우 올바른 옵션으로 &lt;code&gt;true&lt;/code&gt; 를, 올바르지 않거나 누락 된 옵션으로 &lt;code&gt;false&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="761fe13a5a3046a2803cbf44eb72145b39408185" translate="yes" xml:space="preserve">
          <source>If the error requires options, then it returns &lt;code&gt;true&lt;/code&gt; with the correct options, or &lt;code&gt;false&lt;/code&gt; with incorrect or missing options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="016563f6fc2abaa3eed6fe7a75c9f43f809258c7" translate="yes" xml:space="preserve">
          <source>If the file defines the constant &lt;code&gt;ApplicationController&lt;/code&gt; all is fine, otherwise &lt;code&gt;LoadError&lt;/code&gt; is raised:</source>
          <target state="translated">파일이 상수 &lt;code&gt;ApplicationController&lt;/code&gt; 를 정의하면 모두 &lt;code&gt;LoadError&lt;/code&gt; 이고 그렇지 않으면 LoadError 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1a8a9c3b9356abe0176c5f62cb5eed40e7f64af2" translate="yes" xml:space="preserve">
          <source>If the first argument is not a &lt;code&gt;Symbol&lt;/code&gt;, then it will simply be returned:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eb927638f5d9484fdd901f79219252d10a69c98" translate="yes" xml:space="preserve">
          <source>If the first argument is not a Symbol, then it will simply be returned:</source>
          <target state="translated">첫 번째 인수가 Symbol이 아닌 경우 간단히 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="deb3c71748def15aeb30c6411683535860b363d8" translate="yes" xml:space="preserve">
          <source>If the flush parameter is &lt;code&gt;true&lt;/code&gt;&lt;code&gt;content_for&lt;/code&gt; replaces the blocks it is given. For example:</source>
          <target state="translated">flush 매개 변수가 &lt;code&gt;true&lt;/code&gt; 이면 &lt;code&gt;content_for&lt;/code&gt; 는 주어진 블록을 대체합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="227fed38b2812ba4a10ec8b83efda30f6d3b5739" translate="yes" xml:space="preserve">
          <source>If the generator is invoked with class name Admin, it will check for the presence of &amp;ldquo;AdminDecorator&amp;rdquo;.</source>
          <target state="translated">생성자가 클래스 이름 Admin으로 호출되면 &quot;AdminDecorator&quot;가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e0ab4232b45c5ee76bafe2e9038c8fee8b56a7f1" translate="yes" xml:space="preserve">
          <source>If the given &lt;code&gt;:collection&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; or empty, &lt;code&gt;render&lt;/code&gt; will return &lt;code&gt;nil&lt;/code&gt;. This will allow you to specify a text which will be displayed instead by using this form:</source>
          <target state="translated">주어진 &lt;code&gt;:collection&lt;/code&gt; 이 &lt;code&gt;nil&lt;/code&gt; 이거나 비어 있으면 &lt;code&gt;render&lt;/code&gt; 는 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다. 이를 통해 다음 양식을 사용하여 표시 할 텍스트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="163cef209c505e7bc006f989045e074f140564db" translate="yes" xml:space="preserve">
          <source>If the hash contains an &lt;code&gt;id&lt;/code&gt; key that matches an already associated record, the matching record will be modified:</source>
          <target state="translated">해시 에 이미 연결된 레코드와 일치 하는 &lt;code&gt;id&lt;/code&gt; 키가 포함되어 있으면 일치하는 레코드가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="538e058424ae1c8b0542fd08c3809bc0208c9054" translate="yes" xml:space="preserve">
          <source>If the hash of attributes for an object contains the key &lt;code&gt;_destroy&lt;/code&gt; with a value that evaluates to &lt;code&gt;true&lt;/code&gt; (e.g. 1, '1', true, or 'true') then the object will be destroyed. This form allows users to remove addresses:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="944c4f1b89829d70ab3d6a4ceec13a795ba5b5de" translate="yes" xml:space="preserve">
          <source>If the hash of attributes for an object contains the key &lt;code&gt;_destroy&lt;/code&gt; with a value that evaluates to &lt;code&gt;true&lt;/code&gt; (eg. 1, '1', true, or 'true') then the object will be destroyed. This form allows users to remove addresses:</source>
          <target state="translated">객체의 속성 해시에 &lt;code&gt;true&lt;/code&gt; 로 평가되는 값 (예 : 1, '1', true 또는 'true') 의 키 &lt;code&gt;_destroy&lt;/code&gt; 가 포함되어 있으면 객체가 파괴됩니다. 이 양식을 사용하면 사용자가 주소를 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc95de7c51c2b096fbbe476dc7be217d0ef65e82" translate="yes" xml:space="preserve">
          <source>If the helpers provided by Active Record aren't enough you can use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/DatabaseStatements.html#method-i-execute&quot;&gt;&lt;code&gt;execute&lt;/code&gt;&lt;/a&gt; method to execute arbitrary SQL:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccde5eea872243c7a05d13133b714dc8203a208" translate="yes" xml:space="preserve">
          <source>If the helpers provided by Active Record aren't enough you can use the &lt;code&gt;execute&lt;/code&gt; method to execute arbitrary SQL:</source>
          <target state="translated">Active Record에서 제공하는 헬퍼가 충분하지 않으면 &lt;code&gt;execute&lt;/code&gt; 메소드를 사용하여 임의의 SQL을 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a2541e9774c0fa5c8fd9ed6ba8472389b4bce3f" translate="yes" xml:space="preserve">
          <source>If the image contains EXIF data indicating its angle is 90 or 270 degrees, its width and height are swapped for convenience.</source>
          <target state="translated">이미지에 각도가 90도 또는 270 도임을 나타내는 EXIF ​​데이터가 포함되어 있으면 편의를 위해 너비와 높이가 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="94dfd93f82ee063498e6a6f3b3cff3eff65a5869" translate="yes" xml:space="preserve">
          <source>If the inverse of a command requires several commands, returns array of commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d042e2a8097a1cd9f090ed461b2d2edd91f9489" translate="yes" xml:space="preserve">
          <source>If the join table for a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association has additional columns beyond the two foreign keys, these columns will be added as attributes to records retrieved via that association. Records returned with additional attributes will always be read-only, because Rails cannot save changes to those attributes.</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관에 대한 결합 테이블에 두 개의 외부 키 이외의 추가 열이 있는 경우 해당 열은 해당 연관을 통해 검색된 레코드에 속성으로 추가됩니다. Rails가 해당 속성에 대한 변경 사항을 저장할 수 없으므로 추가 속성으로 반환 된 레코드는 항상 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="86f8b6dcd1415f6f59d2e78135b1a3a0a2a30ef9" translate="yes" xml:space="preserve">
          <source>If the key is not found and an optional code block is not provided, raises a &lt;code&gt;KeyError&lt;/code&gt; exception.</source>
          <target state="translated">키를 찾을 수없고 선택적 코드 블록이 제공되지 않으면 &lt;code&gt;KeyError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ad902096c915fab4245d5fbd18ec7dea5cbf5a18" translate="yes" xml:space="preserve">
          <source>If the locale is set via the URL to the pirate locale (&lt;code&gt;http://localhost:3000?locale=pirate&lt;/code&gt;), the response renders the pirate strings:</source>
          <target state="translated">로케일이 URL을 통해 해적 로케일 ( &lt;code&gt;http://localhost:3000?locale=pirate&lt;/code&gt; )로 설정되면 응답이 해적 문자열을 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="870f530498bda0234d9ea1e6f8bd4f47e257d204" translate="yes" xml:space="preserve">
          <source>If the lookup fails, &lt;code&gt;const_missing&lt;/code&gt; is invoked in the parent. The default implementation of &lt;code&gt;const_missing&lt;/code&gt; raises &lt;code&gt;NameError&lt;/code&gt;, but it can be overridden.</source>
          <target state="translated">조회가 실패하면 부모에서 &lt;code&gt;const_missing&lt;/code&gt; 이 호출됩니다. &lt;code&gt;const_missing&lt;/code&gt; 의 기본 구현 은 &lt;code&gt;NameError&lt;/code&gt; 를 발생 시키지만 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e8149dfbd2231a5c362a4ce424d84c029c05f68" translate="yes" xml:space="preserve">
          <source>If the lookup for the key does not return a Hash suitable for pluralization, an &lt;code&gt;I18n::InvalidPluralizationData&lt;/code&gt; exception is raised.</source>
          <target state="translated">키 검색이 복수형에 적합한 해시를 반환하지 않으면 &lt;code&gt;I18n::InvalidPluralizationData&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81575ba34a98720d93c0d7989dc2912ffddbc6ed" translate="yes" xml:space="preserve">
          <source>If the migration name is of the form &quot;AddColumnToTable&quot; or &quot;RemoveColumnFromTable&quot; and is followed by a list of column names and types then a migration containing the appropriate &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_column&quot;&gt;&lt;code&gt;add_column&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-remove_column&quot;&gt;&lt;code&gt;remove_column&lt;/code&gt;&lt;/a&gt; statements will be created.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f947e905ecb75caaa354b270ae26b2cb288aad3" translate="yes" xml:space="preserve">
          <source>If the migration name is of the form &quot;AddColumnToTable&quot; or &quot;RemoveColumnFromTable&quot; and is followed by a list of column names and types then a migration containing the appropriate &lt;code&gt;add_column&lt;/code&gt; and &lt;code&gt;remove_column&lt;/code&gt; statements will be created.</source>
          <target state="translated">마이그레이션 이름이 &quot;AddColumnToTable&quot;또는 &quot;RemoveColumnFromTable&quot;형식이고 열 이름 및 유형 목록이 오는 경우 적절한 &lt;code&gt;add_column&lt;/code&gt; 및 &lt;code&gt;remove_column&lt;/code&gt; 문을 포함하는 마이그레이션 이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="ece6215196e6f407645658c4394d70b2ec694aab" translate="yes" xml:space="preserve">
          <source>If the migration name is of the form &quot;CreateXXX&quot; and is followed by a list of column names and types then a migration creating the table XXX with the columns listed will be generated. For example:</source>
          <target state="translated">마이그레이션 이름이 &quot;CreateXXX&quot;형식이고 열 이름 및 유형 목록이 오는 경우 열이 나열된 테이블 XXX를 작성하는 마이그레이션이 생성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="70a84627fbfe630a489c29847212ed61d1c93a43" translate="yes" xml:space="preserve">
          <source>If the model is new, a record gets created in the database, otherwise the existing record gets updated.</source>
          <target state="translated">모델이 새 모델이면 데이터베이스에 레코드가 작성되고, 그렇지 않으면 기존 레코드가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="1b0b6f923ae257bf38d6ce3333a84aca4b26fd4c" translate="yes" xml:space="preserve">
          <source>If the module is anonymous or belongs to the top-level, &lt;code&gt;module_parent&lt;/code&gt; returns &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">모듈이 익명이거나 최상위 수준에 속하는 경우 &lt;code&gt;module_parent&lt;/code&gt; 는 &lt;code&gt;Object&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4da9e3a8d78c55de45793184aae4338468d1479c" translate="yes" xml:space="preserve">
          <source>If the name of the other model cannot be derived from the association name, you can use the &lt;code&gt;:class_name&lt;/code&gt; option to supply the model name. For example, if a book belongs to an author, but the actual name of the model containing authors is &lt;code&gt;Patron&lt;/code&gt;, you'd set things up this way:</source>
          <target state="translated">다른 모델의 이름을 연관 이름에서 파생 할 수없는 경우 &lt;code&gt;:class_name&lt;/code&gt; 옵션을 사용 하여 모델 이름을 제공 할 수 있습니다 . 예를 들어, 책이 저자에 속하지만 저자가 포함 된 모델의 실제 이름이 &lt;code&gt;Patron&lt;/code&gt; 인 경우 다음과 같이 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8377507763a4ec6736375f2270c6163f80978c37" translate="yes" xml:space="preserve">
          <source>If the name of the other model cannot be derived from the association name, you can use the &lt;code&gt;:class_name&lt;/code&gt; option to supply the model name. For example, if a part has many assemblies, but the actual name of the model containing assemblies is &lt;code&gt;Gadget&lt;/code&gt;, you'd set things up this way:</source>
          <target state="translated">다른 모델의 이름을 연관 이름에서 파생 할 수없는 경우 &lt;code&gt;:class_name&lt;/code&gt; 옵션을 사용 하여 모델 이름을 제공 할 수 있습니다 . 예를 들어, 부품에 많은 어셈블리가 있지만 어셈블리를 포함하는 모델의 실제 이름이 &lt;code&gt;Gadget&lt;/code&gt; 인 경우 다음과 같이 설정합니다.</target>
        </trans-unit>
        <trans-unit id="97ff49a05f14a74ff483211e15c937e2a750f137" translate="yes" xml:space="preserve">
          <source>If the name of the other model cannot be derived from the association name, you can use the &lt;code&gt;:class_name&lt;/code&gt; option to supply the model name. For example, if a supplier has an account, but the actual name of the model containing accounts is &lt;code&gt;Billing&lt;/code&gt;, you'd set things up this way:</source>
          <target state="translated">다른 모델의 이름을 연관 이름에서 파생 할 수없는 경우 &lt;code&gt;:class_name&lt;/code&gt; 옵션을 사용 하여 모델 이름을 제공 할 수 있습니다 . 예를 들어 공급 업체에 계정이 있지만 계정을 포함하는 모델의 실제 이름이 &lt;code&gt;Billing&lt;/code&gt; 인 경우 다음과 같이 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f94aae77695ec53c01d4b6e6eddcfdcfb24ac73e" translate="yes" xml:space="preserve">
          <source>If the name of the other model cannot be derived from the association name, you can use the &lt;code&gt;:class_name&lt;/code&gt; option to supply the model name. For example, if an author has many books, but the actual name of the model containing books is &lt;code&gt;Transaction&lt;/code&gt;, you'd set things up this way:</source>
          <target state="translated">다른 모델의 이름을 연관 이름에서 파생 할 수없는 경우 &lt;code&gt;:class_name&lt;/code&gt; 옵션을 사용 하여 모델 이름을 제공 할 수 있습니다 . 예를 들어, 저자가 많은 책을 가지고 있지만 books를 포함하는 모델의 실제 이름이 &lt;code&gt;Transaction&lt;/code&gt; 인 경우 다음과 같이 설정합니다.</target>
        </trans-unit>
        <trans-unit id="11b4fb83f4789ed1e001dee831cc8b6b77352264" translate="yes" xml:space="preserve">
          <source>If the nesting is not empty the constant is looked up in its elements and in order. The ancestors of those elements are ignored.</source>
          <target state="translated">중첩이 비어 있지 않으면 상수가 해당 요소에서 순서대로 조회됩니다. 해당 요소의 조상은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="67b2499edc21dcefa2ca3ad43e6fd9a4c40ce34e" translate="yes" xml:space="preserve">
          <source>If the next id was calculated in advance (as in Oracle), it should be passed in as &lt;code&gt;id_value&lt;/code&gt;.</source>
          <target state="translated">다음 ID가 Oracle에서와 같이 미리 계산 된 경우 &lt;code&gt;id_value&lt;/code&gt; 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="dfd0a84ba7da4333cdce8acd27d507e439024639" translate="yes" xml:space="preserve">
          <source>If the number of workers is set to &lt;code&gt;1&lt;/code&gt; or fewer, the tests will not be parallelized.</source>
          <target state="translated">작업자 수를 &lt;code&gt;1&lt;/code&gt; 이하로 설정 하면 테스트가 병렬화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6cc6d814e2ff76852e8129d0558c26d66faa2717" translate="yes" xml:space="preserve">
          <source>If the number of workers passed is 1 or fewer the processes will not be forked and the tests will not be parallelized and the tests will use the original &lt;code&gt;test-database&lt;/code&gt; database.</source>
          <target state="translated">통과 한 작업자 수가 1 이하인 경우 프로세스가 분기되지 않고 테스트가 병렬화되지 않으며 테스트는 원래 &lt;code&gt;test-database&lt;/code&gt; 데이터베이스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8f9d9939f0cd78a05e79047e0433dd766d96823e" translate="yes" xml:space="preserve">
          <source>If the object is not duplicable, &lt;code&gt;deep_dup&lt;/code&gt; will just return it:</source>
          <target state="translated">객체를 &lt;code&gt;deep_dup&lt;/code&gt; 할 수 없는 경우 deep_dup 은 다음 객체 만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="102e580e78b77b9638059d5b3745ebabdaabe3b6" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;code&gt;count&lt;/code&gt; is specified, the singular form will be returned if &lt;code&gt;count == 1&lt;/code&gt;. For any other value of &lt;code&gt;count&lt;/code&gt; the plural will be returned.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;count&lt;/code&gt; 를 지정하면 &lt;code&gt;count == 1&lt;/code&gt; 경우 특이 형이 반환됩니다 . 다른 &lt;code&gt;count&lt;/code&gt; 값에 대해서는 복수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e4887aa76eab30a794195abceff5280255f3b1e0" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;code&gt;locale&lt;/code&gt; is specified, the word will be parameterized as a word of that language. By default, this parameter is set to &lt;code&gt;nil&lt;/code&gt; and it will use the configured &amp;lt;tt&amp;gt;I18n.locale&amp;lt;tt&amp;gt;.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;locale&lt;/code&gt; 이 지정되면 단어는 해당 언어의 단어로 매개 변수화됩니다. 기본적으로이 매개 변수는 &lt;code&gt;nil&lt;/code&gt; 로 설정되며 구성된 &amp;lt;tt&amp;gt; I18n.locale &amp;lt;tt&amp;gt;을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a61ba1e9ee0afd2d8ffc548e3e9947cfdebb27a7" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;code&gt;locale&lt;/code&gt; is specified, the word will be parameterized as a word of that language. By default, this parameter is set to &lt;code&gt;nil&lt;/code&gt; and it will use the configured &lt;code&gt;I18n.locale&lt;/code&gt;.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;locale&lt;/code&gt; 이 지정되면 단어는 해당 언어의 단어로 매개 변수화됩니다. 기본적으로이 매개 변수는 &lt;code&gt;nil&lt;/code&gt; 로 설정되며 구성된 &lt;code&gt;I18n.locale&lt;/code&gt; 을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="a6f204c33fed17f1b258693b08de01fb73e75215" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;code&gt;locale&lt;/code&gt; is specified, the word will be pluralized as a word of that language. By default, this parameter is set to &lt;code&gt;:en&lt;/code&gt;. You must define your own inflection rules for languages other than English.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;locale&lt;/code&gt; 이 지정된 경우 단어는 해당 언어의 단어로 복수화됩니다. 기본적으로이 매개 변수는 &lt;code&gt;:en&lt;/code&gt; 으로 설정되어 있습니다. 영어 이외의 언어에 대한 고유 한 활용 규칙을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="c370ad903b0e1ccf00804193dd9cec24222e49ff" translate="yes" xml:space="preserve">
          <source>If the optional parameter &lt;code&gt;locale&lt;/code&gt; is specified, the word will be singularized as a word of that language. By default, this parameter is set to &lt;code&gt;:en&lt;/code&gt;. You must define your own inflection rules for languages other than English.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;locale&lt;/code&gt; 이 지정된 경우 단어는 해당 언어의 단어로 단 수화됩니다. 기본적으로이 매개 변수는 &lt;code&gt;:en&lt;/code&gt; 으로 설정되어 있습니다. 영어 이외의 언어에 대한 고유 한 활용 규칙을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="dee9b9ab5618fec787452df050a66db133e28f19" translate="yes" xml:space="preserve">
          <source>If the options provided include an &lt;code&gt;if_exists&lt;/code&gt; key, it will be used to check if the column does not exist. This will silently ignore the migration rather than raising if the column was already used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a15cf567f8137845d803f95821d69a0503b3ad" translate="yes" xml:space="preserve">
          <source>If the parameter was nil, the resulting SQL query will be</source>
          <target state="translated">매개 변수가 nil이면 결과 SQL 조회는</target>
        </trans-unit>
        <trans-unit id="c46d978accc2f2a4b15b950d71a4912e0174f02d" translate="yes" xml:space="preserve">
          <source>If the parent object (the one declaring the &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association) is unsaved (that is, &lt;code&gt;new_record?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.</source>
          <target state="translated">상위 오브젝트 ( &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관을 선언하는 오브젝트 )가 저장되지 않은 경우 (즉, &lt;code&gt;new_record?&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 함 ) 하위 오브젝트가 추가 될 때 저장되지 않습니다. 부모가 저장되면 저장되지 않은 모든 연결 구성원이 자동으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9253035efaa95771d21dbdb78c6343a98a0ea95e" translate="yes" xml:space="preserve">
          <source>If the parent object (the one declaring the &lt;code&gt;has_many&lt;/code&gt; association) is unsaved (that is, &lt;code&gt;new_record?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;) then the child objects are not saved when they are added. All unsaved members of the association will automatically be saved when the parent is saved.</source>
          <target state="translated">상위 오브젝트 ( &lt;code&gt;has_many&lt;/code&gt; 연관을 선언하는 오브젝트 )가 저장되지 않은 경우 (즉, &lt;code&gt;new_record?&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 리턴 함 ) 하위 오브젝트가 추가 될 때 저장되지 않습니다. 부모가 저장되면 저장되지 않은 모든 연결 구성원이 자동으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9d95d4c5d57c6c10f4dec813318f4435152d55f4" translate="yes" xml:space="preserve">
          <source>If the parent object (the one declaring the &lt;code&gt;has_one&lt;/code&gt; association) is unsaved (that is, &lt;code&gt;new_record?&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;) then the child objects are not saved. They will automatically when the parent object is saved.</source>
          <target state="translated">부모 객체 ( &lt;code&gt;has_one&lt;/code&gt; 연관을 선언하는 객체 )가 저장되지 않은 경우 (즉, &lt;code&gt;new_record?&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 반환 ), 하위 객체는 저장되지 않습니다. 부모 개체가 저장되면 자동으로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a78ddbc73dbba9e718359b9098c1b6dec6aa075a" translate="yes" xml:space="preserve">
          <source>If the passed hash responds to &lt;code&gt;permitted?&lt;/code&gt; method and the return value of this method is &lt;code&gt;false&lt;/code&gt; an &lt;code&gt;ActiveModel::ForbiddenAttributesError&lt;/code&gt; exception is raised.</source>
          <target state="translated">전달 된 해시가 &lt;code&gt;permitted?&lt;/code&gt; 응답하면 ? 방법 및이 방법의 반환 값은 &lt;code&gt;false&lt;/code&gt; &lt;code&gt;ActiveModel::ForbiddenAttributesError&lt;/code&gt; 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="264da520997c04c07bca1c0606737bdb1990b80a" translate="yes" xml:space="preserve">
          <source>If the process regenerating the entry errors out, the entry will be regenerated after the specified number of seconds. Also note that the life of stale cache is extended only if it expired recently. Otherwise a new value is generated and &lt;code&gt;:race_condition_ttl&lt;/code&gt; does not play any role.</source>
          <target state="translated">항목 재생성 프로세스에서 오류가 발생하면 지정된 시간 (초) 후에 항목이 재생성됩니다. 또한 오래된 캐시의 수명은 최근 만료 된 경우에만 연장됩니다. 그렇지 않으면 새 값이 생성되고 &lt;code&gt;:race_condition_ttl&lt;/code&gt; 이 역할을하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="faaee8fd909b57600e904a5e3792dd07465b53cb" translate="yes" xml:space="preserve">
          <source>If the product's price is 10 then the proper translation for Spanish is &quot;10 &amp;euro;&quot; instead of &quot;&amp;euro;10&quot; but the abstraction cannot give it.</source>
          <target state="translated">제품 가격이 10 인 경우 스페인어에 대한 올바른 번역은 &quot;&amp;euro; 10&quot;대신 &quot;10 &amp;euro;&quot;이지만 추상화는이를 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8548a7c614beefae1ecc04594d5155f43e4f4d46" translate="yes" xml:space="preserve">
          <source>If the receiver is an array of hashes the root element is by default also &quot;objects&quot;:</source>
          <target state="translated">수신자가 해시 배열 인 경우 루트 요소는 기본적으로 &quot;개체&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="628881d48f531a760362d402b30de60357eeb1e4" translate="yes" xml:space="preserve">
          <source>If the receiver responds to &lt;code&gt;convert_key&lt;/code&gt;, the method is called on each of the arguments. This allows &lt;code&gt;except&lt;/code&gt; to play nice with hashes with indifferent access for instance:</source>
          <target state="translated">수신자가 &lt;code&gt;convert_key&lt;/code&gt; 에 응답 하면 메소드는 각 인수에서 호출됩니다. 이 수 &lt;code&gt;except&lt;/code&gt; 예를 들어 무관심 액세스 할 수있는 해시와 플레이 니스 :</target>
        </trans-unit>
        <trans-unit id="c9f17fd73e9e6bbe78975e21e3e00f947aea8330" translate="yes" xml:space="preserve">
          <source>If the record is persisted and unchanged, the attachment is saved to the database immediately. Otherwise, it'll be saved to the DB when the record is next saved.</source>
          <target state="translated">레코드가 유지되고 변경되지 않은 경우 첨부 파일이 데이터베이스에 즉시 저장됩니다. 그렇지 않으면 레코드가 다음에 저장 될 때 DB에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="b9e0aff9de9a4047c05fd0c6a346054672a1196d" translate="yes" xml:space="preserve">
          <source>If the record is persisted and unchanged, the attachments are saved to the database immediately. Otherwise, they'll be saved to the DB when the record is next saved.</source>
          <target state="translated">레코드가 유지되고 변경되지 않은 경우 첨부 파일이 데이터베이스에 즉시 저장됩니다. 그렇지 않으면 레코드가 다음에 저장 될 때 DB에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d7731ebebadbef97bdec390529b6f0db38296fac" translate="yes" xml:space="preserve">
          <source>If the record no longer exists in the database &lt;a href=&quot;recordnotfound&quot;&gt;&lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt;&lt;/a&gt; is raised. Otherwise, in addition to the in-place modification the method returns &lt;code&gt;self&lt;/code&gt; for convenience.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f3b9c80470cdbf8357a8c8495c35aef71ed85fa" translate="yes" xml:space="preserve">
          <source>If the record no longer exists in the database &lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord::RecordNotFound&lt;/a&gt; is raised. Otherwise, in addition to the in-place modification the method returns &lt;code&gt;self&lt;/code&gt; for convenience.</source>
          <target state="translated">데이터베이스에 레코드가 더 이상 존재하지 않으면 &lt;a href=&quot;recordnotfound&quot;&gt;ActiveRecord :: RecordNotFound&lt;/a&gt; 가 발생합니다. 그렇지 않으면 전체 수정 외에이 메소드는 편의를 위해 &lt;code&gt;self&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="718d34739419504d18b253b8814ff3cfc64d4fc2" translate="yes" xml:space="preserve">
          <source>If the relation is the result of a join, you may create a condition which uses any of the tables in the join. For string and array conditions, use the table name in the condition.</source>
          <target state="translated">관계가 조인의 결과 인 경우 조인의 테이블을 사용하는 조건을 만들 수 있습니다. 문자열 및 배열 조건의 경우 조건에서 테이블 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52e8962b99d5f57b067c75b11a43f9ae0c68925b" translate="yes" xml:space="preserve">
          <source>If the returned value from &lt;code&gt;to_ary&lt;/code&gt; is neither &lt;code&gt;nil&lt;/code&gt; nor an &lt;code&gt;Array&lt;/code&gt; object, &lt;code&gt;Kernel#Array&lt;/code&gt; raises an exception, while &lt;code&gt;Array.wrap&lt;/code&gt; does not, it just returns the value.</source>
          <target state="translated">&lt;code&gt;to_ary&lt;/code&gt; 에서 반환 된 값 이 &lt;code&gt;nil&lt;/code&gt; 또는 &lt;code&gt;Array&lt;/code&gt; 객체 가 아닌 경우 &lt;code&gt;Kernel#Array&lt;/code&gt; 는 예외를 발생 &lt;code&gt;Array.wrap&lt;/code&gt; 반면 Array.wrap 은 예외를 발생 시키지 않으며 값만 반환합니다.</target>
        </trans-unit>
        <trans-unit id="68b8b5af912f9f3f893f90e43b61afa533cba712" translate="yes" xml:space="preserve">
          <source>If the server supports Early Hints header links for these assets will be automatically pushed.</source>
          <target state="translated">서버가 Early Hints를 지원하면 이러한 자산에 대한 헤더 링크가 자동으로 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="955d955468d094edb518dd51c17ebc95c034c57e" translate="yes" xml:space="preserve">
          <source>If the specified layout is a:</source>
          <target state="translated">지정된 레이아웃이 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="1ab1f05121c5fae2e6556690c69689301c62259a" translate="yes" xml:space="preserve">
          <source>If the string evaluates to no known constant, or its content is not even a valid constant name, &lt;code&gt;constantize&lt;/code&gt; raises &lt;code&gt;NameError&lt;/code&gt;.</source>
          <target state="translated">알려진 바 없음 일정, 또는 그 내용에 문자열 평가하여도 유효한 상수 이름이 아닌 경우, &lt;code&gt;constantize&lt;/code&gt; 이 제기 &lt;code&gt;NameError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c84a61d243aa1bdf5a41cb546fb76610ea8a96b" translate="yes" xml:space="preserve">
          <source>If the string is invalid then an &lt;code&gt;ArgumentError&lt;/code&gt; could be raised.</source>
          <target state="translated">문자열이 유효하지 않으면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c670a4101a475c6e4985579d6c1ced5675cafc0c" translate="yes" xml:space="preserve">
          <source>If the string is invalid then an &lt;code&gt;ArgumentError&lt;/code&gt; will be raised unlike &lt;code&gt;parse&lt;/code&gt; which usually returns &lt;code&gt;nil&lt;/code&gt; when given an invalid date string.</source>
          <target state="translated">문자열이 유효하지 않으면 유효하지 않은 날짜 문자열이 주어지면 일반적으로 &lt;code&gt;nil&lt;/code&gt; 을 반환하는 &lt;code&gt;parse&lt;/code&gt; 과 달리 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="56c6e4523426e6213b5e6d72ef5cb49bcaa117ce" translate="yes" xml:space="preserve">
          <source>If the supplied array has an incorrect association type, it raises an &lt;code&gt;ActiveRecord::AssociationTypeMismatch&lt;/code&gt; error:</source>
          <target state="translated">제공된 배열에 잘못된 연결 유형이 있으면 &lt;code&gt;ActiveRecord::AssociationTypeMismatch&lt;/code&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dddc51c0472f6ff36a1a18de4ed7f8d5317170b4" translate="yes" xml:space="preserve">
          <source>If the target is &lt;code&gt;nil&lt;/code&gt; and does not respond to the delegated method a &lt;code&gt;Module::DelegationError&lt;/code&gt; is raised. If you wish to instead return &lt;code&gt;nil&lt;/code&gt;, use the &lt;code&gt;:allow_nil&lt;/code&gt; option.</source>
          <target state="translated">대상이 &lt;code&gt;nil&lt;/code&gt; 이고 위임 된 메소드에 응답하지 않으면 &lt;code&gt;Module::DelegationError&lt;/code&gt; 가 발생합니다. 대신 &lt;code&gt;nil&lt;/code&gt; 을 반환 하려면 &lt;code&gt;:allow_nil&lt;/code&gt; 옵션을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1341cea58990aa6ec6fe67eadd6bc5f627288f69" translate="yes" xml:space="preserve">
          <source>If the time components are missing then they will be set to zero.</source>
          <target state="translated">시간 구성 요소가 누락되면 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="cd650c33fd74b171a98018ba8a2845c23f327847" translate="yes" xml:space="preserve">
          <source>If the time or offset components are missing then an &lt;code&gt;ArgumentError&lt;/code&gt; will be raised.</source>
          <target state="translated">시간 또는 오프셋 구성 요소가 누락되면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8fd81be45100cfe1b1041972b9df71468b7ff784" translate="yes" xml:space="preserve">
          <source>If the time or zone components are missing then an &lt;code&gt;ArgumentError&lt;/code&gt; will be raised. This is much stricter than either &lt;code&gt;parse&lt;/code&gt; or &lt;code&gt;iso8601&lt;/code&gt; which allow for missing components.</source>
          <target state="translated">시간 또는 영역 구성 요소가 누락되면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생합니다. 이는 누락 된 구성 요소를 허용하는 &lt;code&gt;parse&lt;/code&gt; 또는 &lt;code&gt;iso8601&lt;/code&gt; 보다 훨씬 엄격 합니다.</target>
        </trans-unit>
        <trans-unit id="d327ab02228ea948f85e55b530b73d9d50df2b37" translate="yes" xml:space="preserve">
          <source>If the time to be constructed lies beyond the range supported by &lt;code&gt;Time&lt;/code&gt; in the runtime platform, usecs are discarded and a &lt;code&gt;DateTime&lt;/code&gt; object is returned instead.</source>
          <target state="translated">생성되는 &lt;code&gt;Time&lt;/code&gt; 이 런타임 플랫폼에서 Time 이 지원하는 범위를 벗어나면 usecs가 삭제되고 대신 &lt;code&gt;DateTime&lt;/code&gt; 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2f31e0ada6b579e9707d60c7d514881b3e20cbd4" translate="yes" xml:space="preserve">
          <source>If there are missing precompiled files in production you will get a &lt;code&gt;Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError&lt;/code&gt; exception indicating the name of the missing file(s).</source>
          <target state="translated">프로덕션에 사전 컴파일 된 파일이 누락 된 경우 누락 된 파일 이름을 나타내는 &lt;code&gt;Sprockets::Helpers::RailsHelper::AssetPaths::AssetNotPrecompiledError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b12462da526f839a100bfa54c206f077be659392" translate="yes" xml:space="preserve">
          <source>If there is a top-level &lt;code&gt;User&lt;/code&gt; Ruby would resolve it in the former example, but wouldn't in the latter. In general, Rails does not emulate the Ruby constant resolution algorithms, but in this case it tries using the following heuristic:</source>
          <target state="translated">최상위 &lt;code&gt;User&lt;/code&gt; 가 있다면 Ruby는 이전 예제에서이를 해결하지만 후자는 그렇지 않습니다. 일반적으로 Rails는 Ruby 상수 해상도 알고리즘을 에뮬레이트하지 않지만이 경우 다음 휴리스틱을 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="f08d0133321eed6a31d75040192b335ce2b93dcd" translate="yes" xml:space="preserve">
          <source>If there is no content type passed in via headers, and there are no attachments, or the message is multipart, then the default content type is used.</source>
          <target state="translated">헤더를 통해 전달 된 컨텐츠 유형이없고 첨부 파일이 없거나 메시지가 다중 파트 인 경우 기본 컨텐츠 유형이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="29c5fad7ca7645efa00c26cd4f224eb59d505e03" translate="yes" xml:space="preserve">
          <source>If there is no such data in the cache (a cache miss), then &lt;code&gt;nil&lt;/code&gt; will be returned. However, if a block has been passed, that block will be passed the key and executed in the event of a cache miss. The return value of the block will be written to the cache under the given cache key, and that return value will be returned.</source>
          <target state="translated">캐시에 그러한 데이터가 없으면 (캐시 ​​누락) &lt;code&gt;nil&lt;/code&gt; 이 리턴됩니다. 그러나 블록이 전달 된 경우 해당 블록은 키를 전달하여 캐시 누락시 실행됩니다. 주어진 캐시 키에 따라 블록의 반환 값이 캐시에 기록되고 그 반환 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ec1aee0234ef6abeb63b383c63a6260f8166542f" translate="yes" xml:space="preserve">
          <source>If there was no &lt;code&gt;where&lt;/code&gt; condition, this would generate the normal set of two queries.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 조건 이 없으면 정상적인 두 쿼리 집합이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="666d7ea3fe425ea1a26795d255c1829b1ec25f94" translate="yes" xml:space="preserve">
          <source>If there were modifications to existing migrations, the test database needs to be rebuilt. This can be done by executing &lt;code&gt;bin/rails db:test:prepare&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e0b6b290b0565fd2d6d8cb415a39ace1f33ecd5" translate="yes" xml:space="preserve">
          <source>If there were modifications to existing migrations, the test database needs to be rebuilt. This can be done by executing &lt;code&gt;rails db:test:prepare&lt;/code&gt;.</source>
          <target state="translated">기존 마이그레이션을 수정 한 경우 테스트 데이터베이스를 다시 작성해야합니다. &lt;code&gt;rails db:test:prepare&lt;/code&gt; 를 실행하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="2befb6cbe498a4296bfc9e9392f33ebabff2d078" translate="yes" xml:space="preserve">
          <source>If there's any element that does not belong to the type of the first one the root node becomes &quot;objects&quot;:</source>
          <target state="translated">첫 번째 유형에 속하지 않는 요소가 있으면 루트 노드는 &quot;개체&quot;가됩니다.</target>
        </trans-unit>
        <trans-unit id="4059accc2f72d4296a7fae6859c0caa84093ce31" translate="yes" xml:space="preserve">
          <source>If this might be a problem for your application, please see &lt;a href=&quot;relation#method-i-create_or_find_by&quot;&gt;&lt;code&gt;create_or_find_by&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8cbe2937a9e64cabe9dae6a72cc5c87fa1ad51" translate="yes" xml:space="preserve">
          <source>If this might be a problem for your application, please see &lt;a href=&quot;relation#method-i-create_or_find_by&quot;&gt;create_or_find_by&lt;/a&gt;.</source>
          <target state="translated">이것이 애플리케이션에 문제가 될 수있는 경우 &lt;a href=&quot;relation#method-i-create_or_find_by&quot;&gt;create_or_find_by&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="92eef42fc65802f45aa971181fa401349bde4477" translate="yes" xml:space="preserve">
          <source>If this read is a hit</source>
          <target state="translated">이 읽기가 히트 인 경우</target>
        </trans-unit>
        <trans-unit id="779d7e63875d0a734d38d9ed82aea5450125e800" translate="yes" xml:space="preserve">
          <source>If this were to occur in a &quot;child&quot; thread, with a waiting parent inside the Executor, it would cause an unavoidable deadlock: the reload must occur before the child thread is executed, but it cannot be safely performed while the parent thread is mid-execution. Child threads should use the Executor instead.</source>
          <target state="translated">이것이 Executor 내부에 대기중인 부모와 함께 &quot;자식&quot;스레드에서 발생하면 피할 수없는 교착 상태가 발생할 수 있습니다. 자식 스레드가 실행되기 전에 재로드가 발생해야하지만 부모 스레드가 중간에있는 동안에는 안전하게 수행 할 수 없습니다 -실행. 자식 스레드는 대신 Executor를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5bdabf6826b8eb76b90cbab11b87d1cf2a8f726" translate="yes" xml:space="preserve">
          <source>If token Authorization header is present, call the login procedure with the present token and options.</source>
          <target state="translated">토큰 인증 헤더가 있으면 현재 토큰 및 옵션으로 로그인 절차를 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="d9ffa91ea0f6817210ca1423c5c49b428fa3f646" translate="yes" xml:space="preserve">
          <source>If true, always save the associated object or destroy it if marked for destruction, when saving the parent object. If false, never save or destroy the associated object. By default, only save the associated object if it's a new record.</source>
          <target state="translated">true 인 경우, 항상 상위 오브젝트를 저장할 때 연관된 오브젝트를 저장하거나 파기 대상으로 표시되면 파기하십시오. False이면 관련 개체를 저장하거나 파괴하지 마십시오. 기본적으로 연결된 개체가 새 레코드 인 경우에만 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="89c9a382b4c07db9e2c72b0b7f7af3cb51c14197" translate="yes" xml:space="preserve">
          <source>If true, always save the associated objects or destroy them if marked for destruction, when saving the parent object. If false, never save or destroy the associated objects. By default, only save associated objects that are new records.</source>
          <target state="translated">true 인 경우 상위 오브젝트를 저장할 때 항상 연관된 오브젝트를 저장하거나 파기 표시가되어 있으면이를 파괴하십시오. False이면 관련 개체를 저장하거나 파괴하지 마십시오. 기본적으로 새 레코드 인 관련 개체 만 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="4999bac24e8ef05c6c11d8204002d682426744c4" translate="yes" xml:space="preserve">
          <source>If true, always save the associated objects or destroy them if marked for destruction, when saving the parent object. If false, never save or destroy the associated objects. By default, only save associated objects that are new records. This option is implemented as a &lt;code&gt;before_save&lt;/code&gt; callback. Because callbacks are run in the order they are defined, associated objects may need to be explicitly saved in any user-defined &lt;code&gt;before_save&lt;/code&gt; callbacks.</source>
          <target state="translated">true 인 경우 상위 오브젝트를 저장할 때 항상 연관된 오브젝트를 저장하거나 파기 표시가되어 있으면이를 파괴하십시오. 거짓 인 경우 관련 개체를 저장하거나 파괴하지 마십시오. 기본적으로 새 레코드 인 관련 개체 만 저장하십시오. 이 옵션은 &lt;code&gt;before_save&lt;/code&gt; 콜백으로 구현됩니다 . 콜백은 정의 된 순서대로 실행되므로 연결된 객체는 사용자 정의 된 &lt;code&gt;before_save&lt;/code&gt; 콜백 에 명시 적으로 저장해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fbafc937e576f16b985cacb7a4452504824fa749" translate="yes" xml:space="preserve">
          <source>If true, destroys any members from the attributes hash with a &lt;code&gt;_destroy&lt;/code&gt; key and a value that evaluates to &lt;code&gt;true&lt;/code&gt; (e.g. 1, '1', true, or 'true'). This option is off by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f462c8b8fe311da55f00ffe0c6e4c38f2f987439" translate="yes" xml:space="preserve">
          <source>If true, destroys any members from the attributes hash with a &lt;code&gt;_destroy&lt;/code&gt; key and a value that evaluates to &lt;code&gt;true&lt;/code&gt; (eg. 1, '1', true, or 'true'). This option is off by default.</source>
          <target state="translated">true 인 경우 &lt;code&gt;_destroy&lt;/code&gt; 키와 &lt;code&gt;true&lt;/code&gt; 로 평가되는 값 (예 : 1, '1', true 또는 'true') 을 사용하여 속성 해시에서 멤버를 삭제합니다 . 이 옵션은 기본적으로 해제되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="88ac43e08613db350e4421c58174fcc52642a983" translate="yes" xml:space="preserve">
          <source>If true, the associated object will be touched (the updated_at/on attributes set to current time) when this record is either saved or destroyed. If you specify a symbol, that attribute will be updated with the current time in addition to the updated_at/on attribute. Please note that with touching no validation is performed and only the &lt;code&gt;after_touch&lt;/code&gt;, &lt;code&gt;after_commit&lt;/code&gt; and &lt;code&gt;after_rollback&lt;/code&gt; callbacks are executed.</source>
          <target state="translated">true 인 경우이 레코드가 저장되거나 소멸 될 때 연관된 오브젝트가 터치됩니다 (update_at / on 속성이 현재 시간으로 설정 됨). 기호를 지정하면 해당 속성이 updated_at / on 속성 외에 현재 시간으로 업데이트됩니다. 터치하면 유효성 검사가 수행되지 않으며 &lt;code&gt;after_touch&lt;/code&gt; , &lt;code&gt;after_commit&lt;/code&gt; 및 &lt;code&gt;after_rollback&lt;/code&gt; 콜백 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="4154a9d0c80dfae87f050873f17b62e301718251" translate="yes" xml:space="preserve">
          <source>If upper components are missing from the string, they are supplied from &lt;a href=&quot;timezone#method-i-now&quot;&gt;#now&lt;/a&gt;:</source>
          <target state="translated">문자열에서 상위 구성 요소가 누락 된 경우 &lt;a href=&quot;timezone#method-i-now&quot;&gt;#now&lt;/a&gt; 에서 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="78500f12e8db34fa2140cb8ba73f6a83a3f37cec" translate="yes" xml:space="preserve">
          <source>If upper components are missing from the string, they are supplied from &lt;a href=&quot;timezone#method-i-now&quot;&gt;&lt;code&gt;TimeZone#now&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aedb852884f618c299acff355e29ed67cf3d17e7" translate="yes" xml:space="preserve">
          <source>If used along with &lt;a href=&quot;associations/classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; then &lt;code&gt;touch&lt;/code&gt; will invoke &lt;code&gt;touch&lt;/code&gt; method on associated object.</source>
          <target state="translated">와 함께 사용하면 &lt;a href=&quot;associations/classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 다음 &lt;code&gt;touch&lt;/code&gt; 호출합니다 &lt;code&gt;touch&lt;/code&gt; 관련 개체에 대한 방법을.</target>
        </trans-unit>
        <trans-unit id="3bbc81c8d45b82313578ca7a5d017889c879ca0e" translate="yes" xml:space="preserve">
          <source>If using &lt;code&gt;dependent: :destroy&lt;/code&gt; on a scoped association, only the scoped objects are destroyed. For example, if a Post model defines &lt;code&gt;has_many :comments, -&amp;gt; { where published: true }, dependent:
:destroy&lt;/code&gt; and &lt;code&gt;destroy&lt;/code&gt; is called on a post, only published comments are destroyed. This means that any unpublished comments in the database would still contain a foreign key pointing to the now deleted post.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;dependent: :destroy&lt;/code&gt; 범위가 지정된 연결에 만 범위가 지정된 개체가 파괴된다. 예를 들어, Post 모델이 &lt;code&gt;has_many :comments, -&amp;gt; { where published: true }, dependent: :destroy&lt;/code&gt; 정의 하면-&amp;gt; {여기서 게시 : true}, 종속 : : destroy 및 &lt;code&gt;destroy&lt;/code&gt; 가 게시물에서 호출되면 게시 된 주석 만 삭제됩니다. 즉, 데이터베이스에서 게시되지 않은 주석에는 여전히 삭제 된 게시물을 가리키는 외래 키가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2be716d9453b3a79ec747fc74867e1b0c279c0d3" translate="yes" xml:space="preserve">
          <source>If using the turbolinks gem, which is included by default in Rails, then include the 'data-turbolinks-track' option which causes turbolinks to check if an asset has been updated and if so loads it into the page:</source>
          <target state="translated">Rails에 기본적으로 포함 된 turbolinks gem을 사용하는 경우 'data-turbolinks-track'옵션을 포함 시켜서 터보 링크가 자산이 업데이트되었는지 확인하고 페이지에로드되는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="411cbf30b6f1bb26027bb966a78768a5c1702f9c" translate="yes" xml:space="preserve">
          <source>If using with the &lt;code&gt;:through&lt;/code&gt; option, the association on the join model must be a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;&lt;code&gt;belongs_to&lt;/code&gt;&lt;/a&gt;, and the records which get deleted are the join records, rather than the associated records.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb0a73e90b844472bfc939a9b22d66e18947d21f" translate="yes" xml:space="preserve">
          <source>If using with the &lt;code&gt;:through&lt;/code&gt; option, the association on the join model must be a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt;, and the records which get deleted are the join records, rather than the associated records.</source>
          <target state="translated">&lt;code&gt;:through&lt;/code&gt; 옵션 과 함께 사용하는 경우 결합 모델의 연관은 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 이어야하며, 삭제 된 레코드는 연관된 레코드가 아닌 결합 레코드입니다.</target>
        </trans-unit>
        <trans-unit id="3dd0cac50b2d9cd0e3e44abe4b065c72b4944d6e" translate="yes" xml:space="preserve">
          <source>If validations for any of the associations fail, their error messages will be applied to the parent.</source>
          <target state="translated">연관에 대한 유효성 검증에 실패하면 해당 오류 메시지가 상위에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="543108e30c8b440e0cb583fcb7471bb46446f4b2" translate="yes" xml:space="preserve">
          <source>If version 20080906120000 is greater than the current version (i.e., it is migrating upwards), this will run the &lt;code&gt;change&lt;/code&gt; (or &lt;code&gt;up&lt;/code&gt;) method on all migrations up to and including 20080906120000, and will not execute any later migrations. If migrating downwards, this will run the &lt;code&gt;down&lt;/code&gt; method on all the migrations down to, but not including, 20080906120000.</source>
          <target state="translated">20080906120000 버전이 현재 버전보다 큰 경우 (즉, 위로 마이그레이션하는 경우) 20080906120000 이하의 모든 마이그레이션 에서 &lt;code&gt;change&lt;/code&gt; (또는 &lt;code&gt;up&lt;/code&gt; ) 메소드를 실행하고 이후 마이그레이션을 실행하지 않습니다. 아래쪽으로 마이그레이션하는 경우 20080906120000 (포함하지 않음)까지의 모든 마이그레이션에서 작동 &lt;code&gt;down&lt;/code&gt; 방법 이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="9e7a68d055ff656ad0ec3fe440224bc39d31dd68" translate="yes" xml:space="preserve">
          <source>If we do want the last &lt;code&gt;where&lt;/code&gt; clause to win then &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/SpawnMethods.html#method-i-merge&quot;&gt;&lt;code&gt;merge&lt;/code&gt;&lt;/a&gt; can be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e0ee4200fcf18cc6d37156067231d5594e1f5e" translate="yes" xml:space="preserve">
          <source>If we do want the last &lt;code&gt;where&lt;/code&gt; clause to win then &lt;code&gt;Relation#merge&lt;/code&gt; can be used.</source>
          <target state="translated">마지막 &lt;code&gt;where&lt;/code&gt; 절을 원하면 &lt;code&gt;Relation#merge&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f43e231b6bc907e26cf6b5598eacd414077c315" translate="yes" xml:space="preserve">
          <source>If we first move the date bits (that have also a relative order of processing, as documented before), and then the time bits we get for example the following computation:</source>
          <target state="translated">먼저 날짜 비트 (이전에 설명한대로 처리 순서도 상대적 임)를 이동하면 시간 비트는 예를 들어 다음 계산을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="02af99c414871a00c8ae1205585a5747e610da1a" translate="yes" xml:space="preserve">
          <source>If we generate another resource with the scaffold generator, we can see that stylesheet, JavaScript, and fixture files are not created anymore. If you want to customize it further, for example to use DataMapper and RSpec instead of Active Record and TestUnit, it's just a matter of adding their gems to your application and configuring your generators.</source>
          <target state="translated">스캐 폴드 생성기로 다른 리소스를 생성하면 더 이상 스타일 시트, JavaScript 및 픽스처 파일이 생성되지 않습니다. 예를 들어 Active Record 및 TestUnit 대신 DataMapper 및 RSpec을 사용하도록 추가로 사용자 정의하려면 보석을 애플리케이션에 추가하고 생성기를 구성하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4faf16a98d4b3560efdab12b3eabe68bfb3186b2" translate="yes" xml:space="preserve">
          <source>If we had used &lt;code&gt;s&lt;/code&gt; rather than &lt;code&gt;server&lt;/code&gt;, Rails would have used the &lt;code&gt;aliases&lt;/code&gt; defined here to find the matching command.</source>
          <target state="translated">우리가 사용했다면 &lt;code&gt;s&lt;/code&gt; 보다는 &lt;code&gt;server&lt;/code&gt; , 레일이 사용했을 &lt;code&gt;aliases&lt;/code&gt; 일치하는 명령을 보려면 여기를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a530f74e1ed369f642d017a02b1b67eb922f375f" translate="yes" xml:space="preserve">
          <source>If we need to modify the session, or state of our integration test, take a look at &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/Session.html&quot;&gt;&lt;code&gt;ActionDispatch::Integration::Session&lt;/code&gt;&lt;/a&gt; to help.</source>
          <target state="translated">세션 또는 통합 테스트 상태를 수정해야하는 경우 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/Session.html&quot;&gt; &lt;code&gt;ActionDispatch::Integration::Session&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="104a55412bd4226897d8dddfe06317d78aaf62b2" translate="yes" xml:space="preserve">
          <source>If we run our test now, we should see a failure:</source>
          <target state="translated">지금 테스트를 실행하면 실패가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="939ee926da74ef6d519dfb921a6839b94c2911a6" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;next&lt;/code&gt;, we won't go deep inside method calls. Instead, &lt;code&gt;byebug&lt;/code&gt; will go to the next line within the same context. In this case, it is the last line of the current method, so &lt;code&gt;byebug&lt;/code&gt; will return to the next line of the caller method.</source>
          <target state="translated">&lt;code&gt;next&lt;/code&gt; 를 사용하면 메소드 호출에 깊이 들어 가지 않습니다. 대신, &lt;code&gt;byebug&lt;/code&gt; 는 동일한 컨텍스트 내에서 다음 줄로 이동합니다. 이 경우 현재 메소드의 마지막 행이므로 &lt;code&gt;byebug&lt;/code&gt; 는 호출자 메소드의 다음 행으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="95f435da6da7f183d3289367776b54193bfb86b0" translate="yes" xml:space="preserve">
          <source>If we use &lt;code&gt;step&lt;/code&gt; in the same situation, &lt;code&gt;byebug&lt;/code&gt; will literally go to the next Ruby instruction to be executed -- in this case, Active Support's &lt;code&gt;week&lt;/code&gt; method.</source>
          <target state="translated">동일한 상황에서 &lt;code&gt;step&lt;/code&gt; 를 사용하면 &lt;code&gt;byebug&lt;/code&gt; 는 문자 그대로 다음 Ruby 명령 (이 경우 Active Support의 &lt;code&gt;week&lt;/code&gt; 방법)으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="0746074725c0e86bb7fbcdf389341bef1fd8cae9" translate="yes" xml:space="preserve">
          <source>If we want this test to pass we can modify it to use &lt;code&gt;assert_raises&lt;/code&gt; like so:</source>
          <target state="translated">이 테스트를 통과하려면 &lt;code&gt;assert_raises&lt;/code&gt; 를 사용 하도록 다음과 같이 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="92798615c4394ee7d59ffecd1d92d98fe8a44600" translate="yes" xml:space="preserve">
          <source>If we want to avoid generating the default &lt;code&gt;app/assets/stylesheets/scaffolds.scss&lt;/code&gt; file when scaffolding a new resource we can disable &lt;code&gt;scaffold_stylesheet&lt;/code&gt;:</source>
          <target state="translated">우리는 기본 발생하지 않도록하려면 &lt;code&gt;app/assets/stylesheets/scaffolds.scss&lt;/code&gt; 우리가 비활성화 할 수있는 새로운 자원 비계 때 파일을 &lt;code&gt;scaffold_stylesheet&lt;/code&gt; 을 :</target>
        </trans-unit>
        <trans-unit id="af8a9da597aa42d9338787c4b4baad8e0a4f18bd" translate="yes" xml:space="preserve">
          <source>If we want to display the properties of all the books in our view, we can do so with an ERB template like this:</source>
          <target state="translated">모든 책의 속성을보기에 표시하려면 다음과 같이 ERB 템플릿을 사용하면됩니다.</target>
        </trans-unit>
        <trans-unit id="5a2be59b4f2e5686e405865f59e6263a2f5b76a8" translate="yes" xml:space="preserve">
          <source>If we wanted to return the lyrics in Karaoke fashion (only sending the line when the singer has finished the previous line), then we could use &lt;code&gt;ActionController::Live&lt;/code&gt; as follows:</source>
          <target state="translated">가라오케 방식으로 가사를 반환하려면 (가수가 이전 라인을 완료했을 때만 라인을 전송) &lt;code&gt;ActionController::Live&lt;/code&gt; 를 다음과 같이 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="94528ace893d4324b19902216f8d9c54908a6aed" translate="yes" xml:space="preserve">
          <source>If we wish for a scope to be applied across all queries to the model we can use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-default_scope&quot;&gt;&lt;code&gt;default_scope&lt;/code&gt;&lt;/a&gt; method within the model itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f0a5ccbc2508e5d171397886b1cf68993fe3933" translate="yes" xml:space="preserve">
          <source>If we wish for a scope to be applied across all queries to the model we can use the &lt;code&gt;default_scope&lt;/code&gt; method within the model itself.</source>
          <target state="translated">범위를 모든 쿼리에서 모델에 적용 하려면 모델 자체 에서 &lt;code&gt;default_scope&lt;/code&gt; 메서드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f2fe4250bc3866922159e939812f4b9de6ce14e0" translate="yes" xml:space="preserve">
          <source>If we wish to remove scoping for any reason we can use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Scoping/Default/ClassMethods.html#method-i-unscoped&quot;&gt;&lt;code&gt;unscoped&lt;/code&gt;&lt;/a&gt; method. This is especially useful if a &lt;code&gt;default_scope&lt;/code&gt; is specified in the model and should not be applied for this particular query.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5420eebfa0a74bb6f2156a405c4fd62f87bcdde2" translate="yes" xml:space="preserve">
          <source>If we wish to remove scoping for any reason we can use the &lt;code&gt;unscoped&lt;/code&gt; method. This is especially useful if a &lt;code&gt;default_scope&lt;/code&gt; is specified in the model and should not be applied for this particular query.</source>
          <target state="translated">어떤 이유로 든 범위 지정을 제거하려면 &lt;code&gt;unscoped&lt;/code&gt; 방법을 사용할 수 있습니다 . 모델에 &lt;code&gt;default_scope&lt;/code&gt; 가 지정되어 있고이 특정 쿼리에 적용해서는 안되는 경우에 특히 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="ba2e7f91c41318ae138fb96d240f69199629e1ea" translate="yes" xml:space="preserve">
          <source>If we're adding a &lt;a href=&quot;duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; of variable length (i.e., years, months, days), move forward from &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, otherwise move forward from &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;&lt;code&gt;utc&lt;/code&gt;&lt;/a&gt;, for accuracy when moving across DST boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef55b2a0c1de051b5062301dc4cd03a33a96b0c5" translate="yes" xml:space="preserve">
          <source>If we're adding a &lt;a href=&quot;duration&quot;&gt;Duration&lt;/a&gt; of variable length (i.e., years, months, days), move forward from &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;time&lt;/a&gt;, otherwise move forward from &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;utc&lt;/a&gt;, for accuracy when moving across DST boundaries.</source>
          <target state="translated">가변 길이 &lt;a href=&quot;duration&quot;&gt;기간&lt;/a&gt; (예 : 년, 월, 일)을 추가하는 경우 DST 경계를 가로 질러 이동할 때 정확성을 위해 &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;시간&lt;/a&gt; 에서 앞으로 이동하거나 그렇지 않으면 &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;utc&lt;/a&gt; 에서 앞으로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="5f53a5df1709d9c548ea4be27da6be9fdc5db1e1" translate="yes" xml:space="preserve">
          <source>If we're subtracting a &lt;a href=&quot;duration&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;&lt;/a&gt; of variable length (i.e., years, months, days), move backward from &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;&lt;code&gt;time&lt;/code&gt;&lt;/a&gt;, otherwise move backward from &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;&lt;code&gt;utc&lt;/code&gt;&lt;/a&gt;, for accuracy when moving across DST boundaries.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09802582f697f26db471e95f53a1dfb8b3de7103" translate="yes" xml:space="preserve">
          <source>If we're subtracting a &lt;a href=&quot;duration&quot;&gt;Duration&lt;/a&gt; of variable length (i.e., years, months, days), move backward from &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;time&lt;/a&gt;, otherwise move backward from &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;utc&lt;/a&gt;, for accuracy when moving across DST boundaries.</source>
          <target state="translated">가변 길이 &lt;a href=&quot;duration&quot;&gt;기간&lt;/a&gt; (예 : 년, 월, 일)을 빼면 DST 경계를 이동할 때 정확도를 위해 &lt;a href=&quot;timewithzone#method-i-time&quot;&gt;시간&lt;/a&gt; 에서 뒤로 이동하거나 그렇지 않으면 &lt;a href=&quot;timewithzone#method-i-utc&quot;&gt;utc&lt;/a&gt; 에서 뒤로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="55b8adaf479fc1ab31cf1abb330ec40c82c3ed06" translate="yes" xml:space="preserve">
          <source>If you absolutely must write from within a function use &lt;code&gt;concat&lt;/code&gt;.</source>
          <target state="translated">함수 내에서 쓰지 않으면 &lt;code&gt;concat&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="4941bdd38d7948e671d22fb59d237b2b4be08e54" translate="yes" xml:space="preserve">
          <source>If you accidentally let a signed id out in the wild that you wish to retract sooner than its expiration date (or maybe you forgot to set an expiration date while meaning to!), you can use the purpose to essentially version the &lt;a href=&quot;signedid#method-i-signed_id&quot;&gt;&lt;code&gt;signed_id&lt;/code&gt;&lt;/a&gt;, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fe0c0873bdf82b9973d613977aa3666e17465f" translate="yes" xml:space="preserve">
          <source>If you add an &lt;code&gt;erb&lt;/code&gt; extension to a JavaScript asset, making it something such as &lt;code&gt;application.js.erb&lt;/code&gt;, you can then use the &lt;code&gt;asset_path&lt;/code&gt; helper in your JavaScript code:</source>
          <target state="translated">JavaScript 자산에 &lt;code&gt;erb&lt;/code&gt; 확장자를 추가하여 &lt;code&gt;application.js.erb&lt;/code&gt; 와 같은 것으로 &lt;code&gt;asset_path&lt;/code&gt; JavaScript 코드에서 asset_path 헬퍼 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0a35fa35a429e820134c379131de760313f6bad8" translate="yes" xml:space="preserve">
          <source>If you already have a controller and just want to generate the test scaffold code for each of the seven default actions, you can use the following command:</source>
          <target state="translated">이미 컨트롤러가 있고 7 개의 기본 조치 각각에 대해 테스트 스캐 폴드 코드를 생성하려는 경우 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce72dd7cc7532651f231502b5342a3264d51451" translate="yes" xml:space="preserve">
          <source>If you already have an abstract class and its name differs from &lt;code&gt;AnimalsRecord&lt;/code&gt; you can pass the &lt;code&gt;--parent&lt;/code&gt; option to indicate you want a different abstract class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d303bd6d004a0ab40503609b954a1d2486a0cbaf" translate="yes" xml:space="preserve">
          <source>If you already have an instance of your model, you can start a transaction and acquire the lock in one go using the following code:</source>
          <target state="translated">이미 모델 인스턴스가있는 경우 다음 코드를 사용하여 트랜잭션을 시작하고 한 번에 잠금을 획득 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b8344ca3c4728a16db43a1e613c8c3ea6a3722" translate="yes" xml:space="preserve">
          <source>If you append onto a safe string, either in-place with &lt;code&gt;concat&lt;/code&gt;/&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, or with &lt;code&gt;+&lt;/code&gt;, the result is a safe string. Unsafe arguments are escaped:</source>
          <target state="translated">&lt;code&gt;concat&lt;/code&gt; / &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 대신 또는 &lt;code&gt;+&lt;/code&gt; 를 사용하여 안전한 문자열을 추가 하면 결과는 안전한 문자열입니다. 안전하지 않은 인수는 이스케이프됩니다.</target>
        </trans-unit>
        <trans-unit id="5f76f6731c7d8cb78ca657ddd6aa54b8e78b5918" translate="yes" xml:space="preserve">
          <source>If you are concerned about the accuracy of &lt;code&gt;started&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; to compute a precise elapsed time then use &lt;code&gt;ActiveSupport::Notifications.monotonic_subscribe&lt;/code&gt;. The given block would receive the same arguments as above but the &lt;code&gt;started&lt;/code&gt; and &lt;code&gt;finished&lt;/code&gt; will have values with an accurate monotonic time instead of wall-clock time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3445f24e94507a148405085662e19af18e903896" translate="yes" xml:space="preserve">
          <source>If you are deploying a production application to a system without any pre-existing JavaScript runtimes, you may want to add one to your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">기존 JavaScript 런타임이없는 시스템에 프로덕션 응용 프로그램을 배포하는 경우 &lt;code&gt;Gemfile&lt;/code&gt; 에 응용 프로그램을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cf48043c78446b99049e03f489aaa37030307995" translate="yes" xml:space="preserve">
          <source>If you are going to modify the association (rather than just read from it), then it is a good idea to set the &lt;code&gt;:inverse_of&lt;/code&gt; option on the source association on the join model. This allows associated records to be built which will automatically create the appropriate join model records when they are saved. (See the 'Association Join Models' section above.)</source>
          <target state="translated">연결을 읽지 않고 연결을 수정하려는 경우 조인 모델의 소스 연결에서 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션 을 설정하는 것이 좋습니다 . 이를 통해 연관된 레코드를 빌드 할 수 있으며,이를 통해 적절한 결합 모델 레코드가 저장 될 때 자동으로 작성됩니다. (위의 'Association Join Models'섹션을 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="719155ba2374a2ea4bfe28fa2148b6c9495794ac" translate="yes" xml:space="preserve">
          <source>If you are going to modify the association (rather than just read from it), then it is a good idea to set the &lt;code&gt;:inverse_of&lt;/code&gt; option.</source>
          <target state="translated">연결을 읽지 않고 연결을 수정하려는 경우 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션 을 설정하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="5906118d2ea5faab8fb5405dd3c648625dee0d06" translate="yes" xml:space="preserve">
          <source>If you are looking for the ones for the stable version, please check &lt;a href=&quot;https://guides.rubyonrails.org&quot;&gt;https://guides.rubyonrails.org&lt;/a&gt; instead.</source>
          <target state="translated">안정된 버전을 찾고 있다면 &lt;a href=&quot;https://guides.rubyonrails.org&quot;&gt;https://guides.rubyonrails.org&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac3687d94c3e8d25f05465acfb7a81cc1a03c981" translate="yes" xml:space="preserve">
          <source>If you are not using Protected Attributes, you can remove any options related to this gem such as &lt;code&gt;whitelist_attributes&lt;/code&gt; or &lt;code&gt;mass_assignment_sanitizer&lt;/code&gt; options.</source>
          <target state="translated">보호 된 속성을 사용하지 않는 경우 &lt;code&gt;whitelist_attributes&lt;/code&gt; 또는 &lt;code&gt;mass_assignment_sanitizer&lt;/code&gt; 옵션 과 같이이 gem과 관련된 옵션을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae505b17f8cc0dcec8e6f7865a4661d2baca773" translate="yes" xml:space="preserve">
          <source>If you are organising your models within modules you can add a prefix to the models within a namespace by defining a singleton method in the parent module called &lt;a href=&quot;modelschema#method-c-table_name_prefix&quot;&gt;::table_name_prefix&lt;/a&gt; which returns your chosen prefix.</source>
          <target state="translated">모듈 내에서 모델을 구성하는 경우 선택한 접두사를 반환하는 &lt;a href=&quot;modelschema#method-c-table_name_prefix&quot;&gt;:: table_name_prefix&lt;/a&gt; 라는 상위 모듈에서 단일 메서드를 정의하여 네임 스페이스 내의 모델에 접두사를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="17bdfde3b0252ca96bc37f5213237b003e5d3bb2" translate="yes" xml:space="preserve">
          <source>If you are organising your models within modules you can add a prefix to the models within a namespace by defining a singleton method in the parent module called &lt;a href=&quot;modelschema#method-c-table_name_prefix&quot;&gt;&lt;code&gt;table_name_prefix&lt;/code&gt;&lt;/a&gt; which returns your chosen prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bc7a57543f4858b11cbddc28afcc28102c22b4" translate="yes" xml:space="preserve">
          <source>If you are organising your models within modules, you can add a suffix to the models within a namespace by defining a singleton method in the parent module called &lt;a href=&quot;modelschema#method-c-table_name_suffix&quot;&gt;::table_name_suffix&lt;/a&gt; which returns your chosen suffix.</source>
          <target state="translated">모듈 내에서 모델을 구성하는 경우 선택한 접미사를 반환하는 &lt;a href=&quot;modelschema#method-c-table_name_suffix&quot;&gt;:: table_name_suffix&lt;/a&gt; 라는 상위 모듈에서 단일 메서드를 정의하여 네임 스페이스 내의 모델에 접미사를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2214f0bfcbab1e61f753515ac75275bf680605a" translate="yes" xml:space="preserve">
          <source>If you are organising your models within modules, you can add a suffix to the models within a namespace by defining a singleton method in the parent module called &lt;a href=&quot;modelschema#method-c-table_name_suffix&quot;&gt;&lt;code&gt;table_name_suffix&lt;/code&gt;&lt;/a&gt; which returns your chosen suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c444436a99f12549c65632f918ac52902d000bd1" translate="yes" xml:space="preserve">
          <source>If you are relying on the ability for external applications or JavaScript to be able to read your Rails app's signed session cookies (or signed cookies in general) you should not set &lt;code&gt;secret_key_base&lt;/code&gt; until you have decoupled these concerns.</source>
          <target state="translated">외부 애플리케이션 또는 JavaScript가 Rails 앱의 서명 된 세션 쿠키 (또는 일반적으로 서명 된 쿠키)를 읽을 수있는 기능에 의존하는 경우 이러한 문제를 분리 할 때까지 &lt;code&gt;secret_key_base&lt;/code&gt; 를 설정하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="445ba00a4943e638d1665dea98dccf8577df2d3c" translate="yes" xml:space="preserve">
          <source>If you are running in a multi-threaded environment, there could be a chance that several threads may be accessing multiple connections simultaneously. So depending on your current request load, you could very well have multiple threads contending for a limited number of connections.</source>
          <target state="translated">다중 스레드 환경에서 실행중인 경우 여러 스레드가 동시에 여러 연결에 액세스 할 수 있습니다. 따라서 현재 요청로드에 따라 제한된 수의 연결에 대해 여러 개의 스레드가 경합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee2384fc6362c046b42ceef3940761a2bd5217d" translate="yes" xml:space="preserve">
          <source>If you are upgrading an existing application and intend to use this option, take care to paste this configuration option only into &lt;code&gt;production.rb&lt;/code&gt; and any other environments you define with production behavior (not &lt;code&gt;application.rb&lt;/code&gt;).</source>
          <target state="translated">기존 애플리케이션을 업그레이드하고이 옵션을 사용하려는 경우이 구성 옵션을 &lt;code&gt;production.rb&lt;/code&gt; 및 프로덕션 동작으로 정의한 다른 환경 ( &lt;code&gt;application.rb&lt;/code&gt; 아님) 에만 붙여 넣으십시오 .</target>
        </trans-unit>
        <trans-unit id="a63db430ab272473aa36c824b5192bdac03ea9f2" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;ActionDispatch::Http::UploadedFile&lt;/code&gt; in your tests to upload files, you will need to change to use the similar &lt;code&gt;Rack::Test::UploadedFile&lt;/code&gt; class instead.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;ActionDispatch::Http::UploadedFile&lt;/code&gt; 파일을 업로드하여 테스트에서, 당신은 유사한 사용하도록 변경해야합니다 &lt;code&gt;Rack::Test::UploadedFile&lt;/code&gt; 대신 클래스를.</target>
        </trans-unit>
        <trans-unit id="72dc49f2cbfcdc5155eea779cf985e4abf789994" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;javascript_include_tag&lt;/code&gt; or &lt;code&gt;stylesheet_link_tag&lt;/code&gt; the Early Hints headers are included by default if supported.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;javascript_include_tag&lt;/code&gt; 을 하거나 &lt;code&gt;stylesheet_link_tag&lt;/code&gt; 초기 힌트를 지원하는 경우 헤더가 기본적으로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="53c8d92a86735b1e60759959c24826b66455fe3d" translate="yes" xml:space="preserve">
          <source>If you are using &lt;code&gt;select&lt;/code&gt; or similar helpers to set a &lt;code&gt;belongs_to&lt;/code&gt; association you must pass the name of the foreign key (in the example above &lt;code&gt;city_id&lt;/code&gt;), not the name of association itself.</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;select&lt;/code&gt; 세트에 또는 유사한 도우미를 &lt;code&gt;belongs_to&lt;/code&gt; 의 연결을 당신은 (위의 예에서는 외부 키의 이름을 통과해야 &lt;code&gt;city_id&lt;/code&gt; ) 협회 자체의 이름이 아닌.</target>
        </trans-unit>
        <trans-unit id="fa85f958859a6abeb3d6ad69de134af0df11a850" translate="yes" xml:space="preserve">
          <source>If you are using Active Storage outside of a Ruby on Rails application, you can configure the service to use like this:</source>
          <target state="translated">Ruby on Rails 애플리케이션 외부에서 Active Storage를 사용하는 경우 다음과 같이 사용하도록 서비스를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbd9fdfb951221d206b51993daf854a86d2bb1c3" translate="yes" xml:space="preserve">
          <source>If you are using RSpec for testing, please see the extra configuration required in the gem's documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd4e70a970e39368135f2460914e31c26cc475c" translate="yes" xml:space="preserve">
          <source>If you are using Rails generators, the scaffold and model generators will create the abstract class for you. Simply pass the database key to the command line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d855c89c5bc04f50b3349c55cba09c1b1c6f89f" translate="yes" xml:space="preserve">
          <source>If you are using Rails with the &quot;Asset Pipeline&quot; enabled, this helper will generate a link to &lt;code&gt;/assets/stylesheets/&lt;/code&gt;. This link is then processed by the Sprockets gem. A stylesheet file can be stored in one of three locations: &lt;code&gt;app/assets&lt;/code&gt;, &lt;code&gt;lib/assets&lt;/code&gt; or &lt;code&gt;vendor/assets&lt;/code&gt;.</source>
          <target state="translated">&quot;자산 파이프 라인&quot;이 활성화 된 상태에서 Rails를 사용하는 경우이 도우미는 &lt;code&gt;/assets/stylesheets/&lt;/code&gt; 대한 링크를 생성합니다 . 이 링크는 Sprockets gem에 의해 처리됩니다. 스타일 시트 파일은 &lt;code&gt;app/assets&lt;/code&gt; , &lt;code&gt;lib/assets&lt;/code&gt; 또는 &lt;code&gt;vendor/assets&lt;/code&gt; 의 세 위치 중 하나에 저장 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa8f14096b9fcc66f71efbcc533449b98681ddd6" translate="yes" xml:space="preserve">
          <source>If you are using Rails with the &lt;a href=&quot;asset_pipeline&quot;&gt;Asset Pipeline&lt;/a&gt; enabled, this helper will generate a link to &lt;code&gt;/assets/javascripts/&lt;/code&gt; rather than &lt;code&gt;public/javascripts&lt;/code&gt; which was used in earlier versions of Rails. This link is then served by the asset pipeline.</source>
          <target state="translated">&lt;a href=&quot;asset_pipeline&quot;&gt;Asset Pipeline이&lt;/a&gt; 활성화 된 상태에서 Rails를 사용하는 경우이 도우미는 이전 버전의 Rails에서 사용 된 &lt;code&gt;public/javascripts&lt;/code&gt; 대신 &lt;code&gt;/assets/javascripts/&lt;/code&gt; 대한 링크를 생성합니다 . 그런 다음이 링크는 자산 파이프 라인에서 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="ec9690ee2ac915bcbc7cb63da012b1ea915393f8" translate="yes" xml:space="preserve">
          <source>If you are using Rspec for testing, please see the extra configuration required in the gem's documentation.</source>
          <target state="translated">테스트에 Rspec을 사용하는 경우 gem 설명서에 필요한 추가 구성을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ee4f0f2881e5187cefdff0a7c312ffca7d05622c" translate="yes" xml:space="preserve">
          <source>If you are using UUIDs instead of integers as the primary key on your models you will need to change the column type of &lt;code&gt;record_id&lt;/code&gt; for the &lt;code&gt;active_storage_attachments&lt;/code&gt; table in the generated migration accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2492b15fd6c23e9dabc86b17db1d6cfbfb7021d" translate="yes" xml:space="preserve">
          <source>If you are using Unicorn with NGINX, you may need to tweak NGINX. &lt;a href=&quot;streaming&quot;&gt;&lt;code&gt;Streaming&lt;/code&gt;&lt;/a&gt; should work out of the box on Rainbows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5b6f9a0a7edbc51fd4880fd9907fe4056841e2" translate="yes" xml:space="preserve">
          <source>If you are using Unicorn with NGINX, you may need to tweak NGINX. &lt;a href=&quot;streaming&quot;&gt;Streaming&lt;/a&gt; should work out of the box on Rainbows.</source>
          <target state="translated">NGINX와 함께 Unicorn을 사용하는 경우 NGINX를 조정해야 할 수도 있습니다. 레인보우에서는 &lt;a href=&quot;streaming&quot;&gt;스트리밍&lt;/a&gt; 이 즉시 작동합니다.</target>
        </trans-unit>
        <trans-unit id="318773fc02cca8479417121d2b442593a6935389" translate="yes" xml:space="preserve">
          <source>If you are using Windows, you have to pass the scripts under the &lt;code&gt;bin&lt;/code&gt; folder directly to the Ruby interpreter e.g. &lt;code&gt;ruby bin\rails server&lt;/code&gt;.</source>
          <target state="translated">Windows를 사용하는 경우 &lt;code&gt;bin&lt;/code&gt; 폴더 아래의 스크립트를 Ruby 인터프리터 (예 : &lt;code&gt;ruby bin\rails server&lt;/code&gt; 직접 전달해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="848b3c95570a4ceb64002b67a8e2c2f5cf74294b" translate="yes" xml:space="preserve">
          <source>If you are using XHR requests other than GET or POST and redirecting after the request then some browsers will follow the redirect using the original request method. This may lead to undesirable behavior such as a double DELETE. To work around this you can return a &lt;code&gt;303 See Other&lt;/code&gt; status code which will be followed using a GET request.</source>
          <target state="translated">GET 또는 POST 이외의 XHR 요청을 사용하고 요청 후 리디렉션하는 경우 일부 브라우저는 원래 요청 방법을 사용하여 리디렉션을 따릅니다. 이로 인해 double DELETE와 같은 바람직하지 않은 동작이 발생할 수 있습니다. 이 문제를 해결하려면 GET 요청을 사용하여 &lt;code&gt;303 See Other&lt;/code&gt; 상태 코드를 반환하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="25174bfad67a96148b06055447e2f51dd70939e7" translate="yes" xml:space="preserve">
          <source>If you are using a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;&lt;code&gt;belongs_to&lt;/code&gt;&lt;/a&gt; on the join model, it is a good idea to set the &lt;code&gt;:inverse_of&lt;/code&gt; option on the &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;&lt;code&gt;belongs_to&lt;/code&gt;&lt;/a&gt;, which will mean that the following example works correctly (where &lt;code&gt;tags&lt;/code&gt; is a &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;&lt;code&gt;has_many&lt;/code&gt;&lt;/a&gt;&lt;code&gt;:through&lt;/code&gt; association):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb1c8f0adc6687ed1d5b0341d7c7679de805e12" translate="yes" xml:space="preserve">
          <source>If you are using a &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; on the join model, it is a good idea to set the &lt;code&gt;:inverse_of&lt;/code&gt; option on the &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt;, which will mean that the following example works correctly (where &lt;code&gt;tags&lt;/code&gt; is a &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;&lt;code&gt;:through&lt;/code&gt; association):</source>
          <target state="translated">당신이 사용하는 경우 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 조인 모델을, 그것을 설정하는 좋은 아이디어입니다 &lt;code&gt;:inverse_of&lt;/code&gt; 온 옵션 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; , 다음의 예 (여기서 제대로 작동한다는 것을 의미 할 &lt;code&gt;tags&lt;/code&gt; A는 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many가 &lt;/a&gt; &lt;code&gt;:through&lt;/code&gt; 협회) :</target>
        </trans-unit>
        <trans-unit id="7cc78d6b1a494dd210f46e6aefce51db6b893bba" translate="yes" xml:space="preserve">
          <source>If you are using a class which includes &lt;code&gt;ActiveModel&lt;/code&gt; and does not inherit from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;, replace &lt;code&gt;activerecord&lt;/code&gt; with &lt;code&gt;activemodel&lt;/code&gt; in the above key paths.</source>
          <target state="translated">&lt;code&gt;ActiveModel&lt;/code&gt; 을 포함 하고 &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 에서 상속되지 않는 클래스를 사용하는 경우 위의 키 경로에서 &lt;code&gt;activerecord&lt;/code&gt; 를 &lt;code&gt;activemodel&lt;/code&gt; 로 바꾸십시오 .</target>
        </trans-unit>
        <trans-unit id="bf37ebbd77567b8ae2ca710572d0e6dd5585255b" translate="yes" xml:space="preserve">
          <source>If you are using a mounted engine and you need to use a &lt;a href=&quot;polymorphicroutes#method-i-polymorphic_url&quot;&gt;#polymorphic_url&lt;/a&gt; pointing at the engine's routes, pass in the engine's route proxy as the first argument to the method. For example:</source>
          <target state="translated">탑재 된 엔진을 사용하고 있고 엔진 경로를 가리키는 &lt;a href=&quot;polymorphicroutes#method-i-polymorphic_url&quot;&gt;#polymorphic_url&lt;/a&gt; 을 사용해야하는 경우 엔진의 경로 프록시를 메서드의 첫 번째 인수로 전달하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cef536dd527911e211681852032b962682c868b8" translate="yes" xml:space="preserve">
          <source>If you are using a mounted engine and you need to use a &lt;a href=&quot;polymorphicroutes#method-i-polymorphic_url&quot;&gt;&lt;code&gt;polymorphic_url&lt;/code&gt;&lt;/a&gt; pointing at the engine's routes, pass in the engine's route proxy as the first argument to the method. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c727cabf9f2c015c78ef81fb4dac0fa22f6017b8" translate="yes" xml:space="preserve">
          <source>If you are using multiple databases, &lt;code&gt;bin/rails dbconsole&lt;/code&gt; will connect to the primary database by default. You can specify which database to connect to using &lt;code&gt;--database&lt;/code&gt; or &lt;code&gt;--db&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="824be7066fd07ff4b7513d8b9c7ffbf4d1fc52e7" translate="yes" xml:space="preserve">
          <source>If you are using sprockets-rails &amp;gt;= 3.2.0 you can configure what happens when an asset lookup is performed and nothing is found. If you turn off &quot;asset fallback&quot; then an error will be raised when an asset cannot be found.</source>
          <target state="translated">스프로킷 레일&amp;gt; = 3.2.0을 사용하는 경우 자산 조회가 수행되고 아무것도 발견되지 않을 때 발생하는 동작을 구성 할 수 있습니다. &quot;자산 대체&quot;를 끄면 자산을 찾을 수 없을 때 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe8682ff6be8c529dfca78f20920f20f2603b75b" translate="yes" xml:space="preserve">
          <source>If you are using the Active Record &lt;code&gt;error_messages_for&lt;/code&gt; helper, you will want to add translations for it.</source>
          <target state="translated">헬퍼에 대해 Active Record &lt;code&gt;error_messages_for&lt;/code&gt; 도우미를 사용하는 경우 번역을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="94c7bd4b114c94e8cba42f0dd2b70a28a0d45b63" translate="yes" xml:space="preserve">
          <source>If you are working on Windows, you should also install the &lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;Ruby Installer Development Kit&lt;/a&gt;.</source>
          <target state="translated">Windows에서 작업중인 경우 &lt;a href=&quot;https://rubyinstaller.org/downloads/&quot;&gt;Ruby Installer Development Kit&lt;/a&gt; 도 설치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="82d6c14b367a755a8abca658062236b8112b0eae" translate="yes" xml:space="preserve">
          <source>If you are working with associations, you can define a reference node between two different fixtures. Here's an example with a &lt;code&gt;belongs_to&lt;/code&gt;/&lt;code&gt;has_many&lt;/code&gt; association:</source>
          <target state="translated">연관 작업을하는 경우 두 개의 다른 조명기 사이에 참조 노드를 정의 할 수 있습니다. 다음은 &lt;code&gt;belongs_to&lt;/code&gt; / &lt;code&gt;has_many&lt;/code&gt; 연관 예제입니다 :</target>
        </trans-unit>
        <trans-unit id="98be677a8c18bc4d260339395016b8e44874aa27" translate="yes" xml:space="preserve">
          <source>If you attempt to assign an object to an association that doesn't match the inferred or specified &lt;code&gt;:class_name&lt;/code&gt;, you'll get an &lt;a href=&quot;../associationtypemismatch&quot;&gt;&lt;code&gt;ActiveRecord::AssociationTypeMismatch&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b5c7b979633e33c18dc9c3674c9fbfbd431d6fd" translate="yes" xml:space="preserve">
          <source>If you attempt to assign an object to an association that doesn't match the inferred or specified &lt;code&gt;:class_name&lt;/code&gt;, you'll get an &lt;a href=&quot;../associationtypemismatch&quot;&gt;ActiveRecord::AssociationTypeMismatch&lt;/a&gt;.</source>
          <target state="translated">유추되거나 지정된 &lt;code&gt;:class_name&lt;/code&gt; 과 일치하지 않는 연결에 개체를 할당하려고 하면 &lt;a href=&quot;../associationtypemismatch&quot;&gt;ActiveRecord :: AssociationTypeMismatch가 나타납니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1716ebfdb98a2dc3522589b8a6d128bcf1f6652d" translate="yes" xml:space="preserve">
          <source>If you call a complicated SQL query which spans multiple tables, the columns specified by the SELECT will be attributes of the model, whether or not they are columns of the corresponding table.</source>
          <target state="translated">여러 테이블에 걸쳐있는 복잡한 SQL 쿼리를 호출하면 SELECT에 의해 지정된 열은 해당 테이블의 열인지 여부에 관계없이 모델의 특성이됩니다.</target>
        </trans-unit>
        <trans-unit id="84afb5a36589a24ecac431de995b3b981d173190" translate="yes" xml:space="preserve">
          <source>If you change something in &lt;code&gt;app/views/user_mailer/welcome_email.html.erb&lt;/code&gt; or the mailer itself, it'll automatically reload and render it so you can visually see the new style instantly. A list of previews are also available in http://localhost:3000/rails/mailers.</source>
          <target state="translated">&lt;code&gt;app/views/user_mailer/welcome_email.html.erb&lt;/code&gt; 또는 메일러 자체 에서 무언가를 변경하면 자동으로 다시로드되어 렌더링되어 새로운 스타일을 즉시 볼 수 있습니다. 미리보기 목록은 http : // localhost : 3000 / rails / mailers에서도 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8f53ef810742e70f9f22bf8f58bbd53ba912c1a" translate="yes" xml:space="preserve">
          <source>If you choose to use MySQL or MariaDB and are using JRuby, your &lt;code&gt;config/database.yml&lt;/code&gt; will look a little different. Here's the development section:</source>
          <target state="translated">MySQL 또는 MariaDB를 사용하기로 선택하고 JRuby를 사용하는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 은 약간 다르게 보입니다. 개발 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6ac4965c5c2bcdbace1d350b6434395c8bcdc4b0" translate="yes" xml:space="preserve">
          <source>If you choose to use MySQL or MariaDB instead of the shipped SQLite3 database, your &lt;code&gt;config/database.yml&lt;/code&gt; will look a little different. Here's the development section:</source>
          <target state="translated">제공된 SQLite3 데이터베이스 대신 MySQL 또는 MariaDB를 사용하도록 선택하면 &lt;code&gt;config/database.yml&lt;/code&gt; 이 약간 다르게 보입니다. 개발 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6f7d8c8274aa60697c0af1f26c580b450283e98d" translate="yes" xml:space="preserve">
          <source>If you choose to use PostgreSQL and are using JRuby, your &lt;code&gt;config/database.yml&lt;/code&gt; will look a little different. Here's the development section:</source>
          <target state="translated">PostgreSQL을 사용하도록 선택하고 JRuby를 사용하는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 은 약간 다르게 보입니다. 개발 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43b20a94adbe08681d270229c651279ddce8957a" translate="yes" xml:space="preserve">
          <source>If you choose to use PostgreSQL, your &lt;code&gt;config/database.yml&lt;/code&gt; will be customized to use PostgreSQL databases:</source>
          <target state="translated">PostgreSQL을 사용하기로 선택한 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 은 PostgreSQL 데이터베이스를 사용하도록 사용자 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="15efb588240d99fb36e3d462566f38deaf9dcbc9" translate="yes" xml:space="preserve">
          <source>If you choose to use SQLite3 and are using JRuby, your &lt;code&gt;config/database.yml&lt;/code&gt; will look a little different. Here's the development section:</source>
          <target state="translated">SQLite3를 사용하도록 선택하고 JRuby를 사용하는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 은 약간 다르게 보입니다. 개발 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81e9e77485464c5e6dcbf90878b86491cfa4792c" translate="yes" xml:space="preserve">
          <source>If you create a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association, you need to explicitly create the joining table. Unless the name of the join table is explicitly specified by using the &lt;code&gt;:join_table&lt;/code&gt; option, Active Record creates the name by using the lexical order of the class names. So a join between author and book models will give the default join table name of &quot;authors_books&quot; because &quot;a&quot; outranks &quot;b&quot; in lexical ordering.</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관 을 작성하는 경우 결합 테이블을 명시 적으로 작성해야합니다. &lt;code&gt;:join_table&lt;/code&gt; 옵션 을 사용하여 조인 테이블의 이름을 명시 적으로 지정하지 않으면 Active Record는 클래스 이름의 어휘 순서를 사용하여 이름을 만듭니다. 따라서 저자와 책 모델 간의 조인은 &quot;a&quot;가 어휘 순서에서 &quot;b&quot;보다 높기 때문에 기본 조인 테이블 이름에 &quot;authors_books&quot;를 부여합니다.</target>
        </trans-unit>
        <trans-unit id="35c6e0aa89528533d3e7d45ddbe92225145db48e" translate="yes" xml:space="preserve">
          <source>If you decide to define Rake tasks, runners, or initializers in an application other than &lt;code&gt;Rails.application&lt;/code&gt;, then you must run them manually.</source>
          <target state="translated">&lt;code&gt;Rails.application&lt;/code&gt; 이외의 응용 프로그램에서 Rake 작업, 러너 또는 이니셜 라이저를 정의하기로 결정한 경우 수동으로 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c6f602abca0abc20529f3eda97c5a3d8a025afa3" translate="yes" xml:space="preserve">
          <source>If you decide to define multiple applications, then the first application that is initialized will be set to &lt;code&gt;Rails.application&lt;/code&gt;, unless you override it with a different application.</source>
          <target state="translated">여러 응용 프로그램을 정의하기로 결정한 경우 다른 응용 프로그램으로 재정의하지 않는 한 초기화 된 첫 번째 응용 프로그램은 &lt;code&gt;Rails.application&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f85edb739df8530dbc19d0bc1b27a21a110b9e3" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;default_url_options&lt;/code&gt; in &lt;code&gt;ApplicationController&lt;/code&gt;, as in the example above, these defaults will be used for all URL generation. The method can also be defined in a specific controller, in which case it only affects URLs generated there.</source>
          <target state="translated">당신이 정의하는 경우 &lt;code&gt;default_url_options&lt;/code&gt; 을 에 &lt;code&gt;ApplicationController&lt;/code&gt; , 위의 예에서와 같이, 이러한 기본값은 모든 URL 생성을 위해 사용됩니다. 이 방법은 특정 컨트롤러에서 정의 할 수도 있으며이 경우 생성 된 URL에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="143fcc6d2800c7f58a705e8a776502a30dd1da56" translate="yes" xml:space="preserve">
          <source>If you delete an article, its associated comments will also need to be deleted, otherwise they would simply occupy space in the database. Rails allows you to use the &lt;code&gt;dependent&lt;/code&gt; option of an association to achieve this. Modify the Article model, &lt;code&gt;app/models/article.rb&lt;/code&gt;, as follows:</source>
          <target state="translated">기사를 삭제하면 관련 주석도 삭제해야합니다. 그렇지 않으면 데이터베이스의 공간을 차지합니다. Rails를 사용하면 연결 의 &lt;code&gt;dependent&lt;/code&gt; 옵션 을 사용하여 이를 달성 할 수 있습니다. 다음과 같이 기사 모델 &lt;code&gt;app/models/article.rb&lt;/code&gt; 를 수정하십시오 .</target>
        </trans-unit>
        <trans-unit id="e4247697d98fceb91717be969dff0907136a92fb" translate="yes" xml:space="preserve">
          <source>If you did not configure the &lt;code&gt;:host&lt;/code&gt; option globally make sure to pass it to &lt;code&gt;url_for&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:host&lt;/code&gt; 옵션을 전체적으로 구성하지 않은 경우 &lt;code&gt;url_for&lt;/code&gt; 로 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="92a84248a85c0345a1f31c7e901bddf26352d033" translate="yes" xml:space="preserve">
          <source>If you did not configure the &lt;code&gt;:host&lt;/code&gt; option globally make sure to pass it to the URL helper.</source>
          <target state="translated">&lt;code&gt;:host&lt;/code&gt; 옵션을 전체적으로 구성하지 않은 경우 URL 도우미에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="19f896a8051227d916889ea44e72bfd1d0512d45" translate="yes" xml:space="preserve">
          <source>If you didn't want to use a generator, you could create your own file inside of &lt;code&gt;app/mailers&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ActionMailer::Base&lt;/code&gt;:</source>
          <target state="translated">생성기를 사용하지 않으려면 &lt;code&gt;app/mailers&lt;/code&gt; 내에 자체 파일을 만들 수 있습니다. &lt;code&gt;ActionMailer::Base&lt;/code&gt; 에서 상속 받도록 하십시오 .</target>
        </trans-unit>
        <trans-unit id="31e7db8dd815a268d841d89ad01529eaae9db9a7" translate="yes" xml:space="preserve">
          <source>If you do not pass a block to the &lt;code&gt;mail&lt;/code&gt; method, it will find all templates in the view paths using by default the mailer name and the method name that it is being called from, it will then create parts for each of these templates intelligently, making educated guesses on correct content type and sequence, and return a fully prepared &lt;code&gt;Mail::Message&lt;/code&gt; ready to call &lt;code&gt;:deliver&lt;/code&gt; on to send.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 메소드에 블록을 전달하지 않으면 기본적으로 메일러 이름과 호출되는 메소드 이름을 사용하여보기 경로에서 모든 템플리트를 찾은 다음 해당 템플리트 각각에 대한 부분을 지능적으로 작성합니다. 올바른 콘텐츠 형식과 순서에 대한 교육 추측을하고 만반의 준비를 반환 &lt;code&gt;Mail::Message&lt;/code&gt; 를 호출 할 준비가 &lt;code&gt;:deliver&lt;/code&gt; 전송에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0fc9a81f86fa1a508a43342942f2f768acb3ed1" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;&lt;code&gt;each_record&lt;/code&gt;&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e49bb87fb9a1a55c72a69389c44e7008d38edb7d" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batchenumerator#method-i-each_record&quot;&gt;each_record에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="81dfe9145ce350052cc620bbaeeee220756570cd" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_each&quot;&gt;&lt;code&gt;find_each&lt;/code&gt;&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4140ab18bcd63be6a412aecefbbbd190489cd2d5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-find_each&quot;&gt;find_each에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d90f9f55d01cd1f2b882f746b59d904d7b9b78a2" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;&lt;code&gt;find_in_batches&lt;/code&gt;&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cb18e1cb1e3c7f393cc6642780d06d1eb6b80c5" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches&lt;/a&gt;, it will return an Enumerator for chaining with other methods:</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-find_in_batches&quot;&gt;find_in_batches에&lt;/a&gt; 블록을 제공하지 않으면 다른 메소드와 연결하기위한 열거자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c5934349dced861f2f9911d802c53bb6eb913d9e" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-in_batches&quot;&gt;&lt;code&gt;in_batches&lt;/code&gt;&lt;/a&gt;, it will return a &lt;a href=&quot;batches/batchenumerator&quot;&gt;&lt;code&gt;BatchEnumerator&lt;/code&gt;&lt;/a&gt; which is enumerable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f027cb4edcde27ee50ad5b5eddd3e7ae2b8487fc" translate="yes" xml:space="preserve">
          <source>If you do not provide a block to &lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches&lt;/a&gt;, it will return a &lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt; which is enumerable.</source>
          <target state="translated">&lt;a href=&quot;batches#method-i-in_batches&quot;&gt;in_batches에&lt;/a&gt; 블록을 제공하지 않으면 열거 가능한 &lt;a href=&quot;batches/batchenumerator&quot;&gt;BatchEnumerator&lt;/a&gt; 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="91eaebfec6f22bd7ed15bbb29289c14182438a70" translate="yes" xml:space="preserve">
          <source>If you do not set the &lt;code&gt;:inverse_of&lt;/code&gt; record, the association will do its best to match itself up with the correct inverse. Automatic inverse detection only works on &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;&lt;code&gt;has_many&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;&lt;code&gt;has_one&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;&lt;code&gt;belongs_to&lt;/code&gt;&lt;/a&gt; associations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a014b6ac6ec93d8bd393971aaa82010a7c491b1f" translate="yes" xml:space="preserve">
          <source>If you do not set the &lt;code&gt;:inverse_of&lt;/code&gt; record, the association will do its best to match itself up with the correct inverse. Automatic inverse detection only works on &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;, and &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; associations.</source>
          <target state="translated">&lt;code&gt;:inverse_of&lt;/code&gt; 레코드를 설정하지 않으면 연결이 올바른 역수와 일치하도록 최선을 다합니다. 자동 역 검출은 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; , &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; 및 &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; 연관 에서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="02910cc77b0be1566c9800df7735a1d0ac74e701" translate="yes" xml:space="preserve">
          <source>If you do not specify a value for this option, a deprecation warning will be emitted. To avoid this, add the following line to your test environment:</source>
          <target state="translated">이 옵션에 값을 지정하지 않으면 사용 중단 경고가 표시됩니다. 이를 피하려면 테스트 환경에 다음 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="eef8af99ea47332d6d11e1ad298d5910dde6559d" translate="yes" xml:space="preserve">
          <source>If you do not want the instance predicate, pass &lt;code&gt;instance_predicate: false&lt;/code&gt; and it will not be defined.</source>
          <target state="translated">인스턴스 술어를 원하지 않으면 &lt;code&gt;instance_predicate: false&lt;/code&gt; 전달 하면 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="48efd90fc348a0d9589d86743ee6c2acc3f50c3d" translate="yes" xml:space="preserve">
          <source>If you do not want your file to be handled via the raw handler, you should add an extension to your file that can be parsed by the appropriate template handler.</source>
          <target state="translated">원시 핸들러를 통해 파일을 처리하지 않으려면 파일에 적절한 템플리트 핸들러로 구문 분석 할 수있는 확장자를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="90936bbeb6985235668f93d357056de557f3bc5f" translate="yes" xml:space="preserve">
          <source>If you do not wish to use HTML5 date and time inputs, Rails provides alternative date and time form helpers that render plain select boxes. These helpers render a select box for each temporal component (e.g. year, month, day, etc). For example, if we have a &lt;code&gt;@person&lt;/code&gt; model object like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="406900a443f2d25a6b532f732fd2e6e6351bbff5" translate="yes" xml:space="preserve">
          <source>If you do pass a block, you can render specific templates of your choice:</source>
          <target state="translated">블록을 전달하면 선택한 특정 템플릿을 렌더링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74ecd23e26826cdd049e7329b893237f73b60f68" translate="yes" xml:space="preserve">
          <source>If you do so, you will have to define manually the class name that is hosting the fixtures (my_products.yml) using the &lt;code&gt;set_fixture_class&lt;/code&gt; method in your test definition:</source>
          <target state="translated">그렇게하면 테스트 정의에서 &lt;code&gt;set_fixture_class&lt;/code&gt; 메소드를 사용하여 조명기 (my_products.yml)를 호스팅하는 클래스 이름을 수동으로 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="85481449311cc99a7d958b46633c218aab3b7af0" translate="yes" xml:space="preserve">
          <source>If you do this, then &lt;code&gt;Mail&lt;/code&gt; will take the file name and work out the mime type. It will also set the Content-Type, Content-Disposition, Content-Transfer-Encoding and encode the contents of the attachment in Base64.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca0e1fc71c14f9f8af7450a60a370b0f48d31113" translate="yes" xml:space="preserve">
          <source>If you do this, then Mail will take the file name and work out the mime type. It will also set the Content-Type, Content-Disposition, Content-Transfer-Encoding and encode the contents of the attachment in Base64.</source>
          <target state="translated">이 작업을 수행하면 Mail은 파일 이름을 사용하여 MIME 유형을 해결합니다. 또한 Content-Type, Content-Disposition, Content-Transfer-Encoding을 설정하고 Base64에서 첨부 파일의 내용을 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="8767744e965d45f97b638be1206c0cffe952975f" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t provide a content type and Active Storage can&amp;rsquo;t determine the file&amp;rsquo;s content type automatically, it defaults to application/octet-stream.</source>
          <target state="translated">컨텐츠 유형을 제공하지 않고 Active Storage가 파일의 컨텐츠 유형을 자동으로 판별 할 수없는 경우, 기본값은 application / octet-stream입니다.</target>
        </trans-unit>
        <trans-unit id="fc9c20b9484d5edd8a9592cdbfabd993cce65aec" translate="yes" xml:space="preserve">
          <source>If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just like normal subclasses with no special magic for differentiating between them or reloading the right type with find.</source>
          <target state="translated">테이블에 유형 열이 정의되어 있지 않으면 단일 테이블 상속이 트리거되지 않습니다. 이 경우 다른 하위 클래스를 구분하거나 find를 사용하여 올바른 유형을 다시로드 할 수있는 특별한 마법이없는 일반 서브 클래스처럼 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f2bc8d4f243e8832712c4be31cca4d7689b2c779" translate="yes" xml:space="preserve">
          <source>If you don't have any special response processing and are using the default rendering mechanism (i.e. you're not using &lt;code&gt;respond_to&lt;/code&gt; or calling render yourself) then you've got an easy helper in &lt;code&gt;fresh_when&lt;/code&gt;:</source>
          <target state="translated">특별한 응답 처리가없고 기본 렌더링 메커니즘을 사용하는 경우 (즉, &lt;code&gt;respond_to&lt;/code&gt; 를 사용하지 않거나 직접 렌더링을 호출하는 경우) &lt;code&gt;fresh_when&lt;/code&gt; 에서 쉬운 도우미가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="536d96169698859e04794d8ff518da4654447b74" translate="yes" xml:space="preserve">
          <source>If you don't have it, you can add the following to your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">없는 경우 &lt;code&gt;Gemfile&lt;/code&gt; 에 다음을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8fe1583558b53ca29247f000ea8f412b9bbd5ca" translate="yes" xml:space="preserve">
          <source>If you don't just want to parlay the broadcast unfiltered to the subscriber, you can also supply a callback that lets you alter what is sent out. The below example shows how you can use this to provide performance introspection in the process:</source>
          <target state="translated">구독자에게 필터링되지 않은 브로드 캐스트를 파레이 링하지 않으려는 경우 전송되는 내용을 변경할 수있는 콜백을 제공 할 수도 있습니다. 아래 예제는이를 사용하여 프로세스에서 성능 내부 검사를 제공하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="eb142a2ca305a5f64af68c8fb9a191fde121a0de" translate="yes" xml:space="preserve">
          <source>If you don't need to attach a form to a model instance, then check out &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;&lt;code&gt;FormTagHelper#form_tag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ff55d0e491430e1f64a9c77d9de71b7cbc9a9a1" translate="yes" xml:space="preserve">
          <source>If you don't need to attach a form to a model instance, then check out &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView::Helpers::FormTagHelper#form_tag&lt;/a&gt;.</source>
          <target state="translated">모델 인스턴스에 폼을 첨부 할 필요가 없으면 &lt;a href=&quot;formtaghelper#method-i-form_tag&quot;&gt;ActionView :: Helpers :: FormTagHelper # form_tag&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="ccd012a92fa2736ea2202478d5a8d02230235625" translate="yes" xml:space="preserve">
          <source>If you don't pass a subject to the &lt;code&gt;mail&lt;/code&gt; method, Action Mailer will try to find it in your translations. The performed lookup will use the pattern &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; to construct the key.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 방법에 제목을 전달하지 않으면 Action Mailer는 번역에서 해당 제목 을 찾으려고 시도합니다. 수행 된 조회는 &lt;code&gt;&amp;lt;mailer_scope&amp;gt;.&amp;lt;action_name&amp;gt;.subject&lt;/code&gt; 패턴을 사용 하여 키를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="43990df1c551a2eb7490c735de41631ffb9f7a25" translate="yes" xml:space="preserve">
          <source>If you don't specify an endpoint, routes will be used as the default endpoint. You can use them just like you use an application's routes:</source>
          <target state="translated">끝점을 지정하지 않으면 경로가 기본 끝점으로 사용됩니다. 응용 프로그램의 경로를 사용하는 것처럼 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="892033cd916d52f004ab4ae9e14cfd8ddedf786b" translate="yes" xml:space="preserve">
          <source>If you don't want to an authenticity token field be rendered at all just pass &lt;code&gt;false&lt;/code&gt;:</source>
          <target state="translated">진위 토큰 필드를 원치 않으면 &lt;code&gt;false&lt;/code&gt; 를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="8cb88ea8687e4075151208607606ccf25698f8be" translate="yes" xml:space="preserve">
          <source>If you don't want to force a layout on to users of the engine, then you can delete this file and reference a different layout in the controllers of your engine.</source>
          <target state="translated">엔진 사용자에게 강제로 레이아웃을 적용하지 않으려면이 파일을 삭제하고 엔진 컨트롤러에서 다른 레이아웃을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="25721c75d7a2c3ad6bd3a5b975b48bea88d6ad0b" translate="yes" xml:space="preserve">
          <source>If you don't want to force the use of a locale in your routes you can use an optional path scope (denoted by the parentheses) like so:</source>
          <target state="translated">경로에서 로캘을 강제로 사용하지 않으려면 다음과 같이 선택적 경로 범위 (괄호로 표시)를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4220d9a84edef742f81d3e912d4afd9142ab026" translate="yes" xml:space="preserve">
          <source>If you don't want to use a generator, you could create your own file inside of &lt;code&gt;app/jobs&lt;/code&gt;, just make sure that it inherits from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">생성기를 사용하지 않으려면 &lt;code&gt;app/jobs&lt;/code&gt; 내에 자체 파일을 만들 수 있습니다 . &lt;code&gt;ApplicationJob&lt;/code&gt; 에서 상속 받도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="3637b43bcc260555a9e865a3fb610bd1839c0baf" translate="yes" xml:space="preserve">
          <source>If you don't want to use a middleware that is included by default in the API-only middleware set, you can remove it with:</source>
          <target state="translated">API 전용 미들웨어 세트에 기본적으로 포함 된 미들웨어를 사용하지 않으려면 다음을 사용하여 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20674bbcbba7835744bdc242bcd09875ead799c3" translate="yes" xml:space="preserve">
          <source>If you eager load an association with a specified &lt;code&gt;:limit&lt;/code&gt; option, it will be ignored, returning all the associated objects:</source>
          <target state="translated">지정된 &lt;code&gt;:limit&lt;/code&gt; 옵션을 사용하여 연결을 열망하는 경우 연결된 모든 객체를 반환하여 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7f46061761309fdc2cd2fc6d585a72e40532ccf5" translate="yes" xml:space="preserve">
          <source>If you enable &lt;code&gt;ParamsWrapper&lt;/code&gt; for &lt;code&gt;:json&lt;/code&gt; format, instead of having to send JSON parameters like this:</source>
          <target state="translated">&lt;code&gt;:json&lt;/code&gt; 형식에 대해 &lt;code&gt;ParamsWrapper&lt;/code&gt; 를 활성화하면 다음 과 같은 JSON 매개 변수를 보내지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="82e3c1aec71b777fae1e7b0b4a0fe046629f64f9" translate="yes" xml:space="preserve">
          <source>If you find your helpers are cluttering &lt;code&gt;test_helper.rb&lt;/code&gt;, you can extract them into separate files. One good place to store them is &lt;code&gt;lib/test&lt;/code&gt;.</source>
          <target state="translated">헬퍼가 &lt;code&gt;test_helper.rb&lt;/code&gt; 를 복잡 하게 만드는 것을 발견하면 별도의 파일로 추출 할 수 있습니다. 그것들을 저장하기에 좋은 곳은 &lt;code&gt;lib/test&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8b7c58a9ca4e48b918d0cc2f3b71b4e044d1e1c9" translate="yes" xml:space="preserve">
          <source>If you find your helpers are cluttering &lt;code&gt;test_helper.rb&lt;/code&gt;, you can extract them into separate files. One good place to store them is &lt;code&gt;test/lib&lt;/code&gt; or &lt;code&gt;test/test_helpers&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30e6213fe0918312e4279adb45e7deef5e07336a" translate="yes" xml:space="preserve">
          <source>If you find your own locale (language) missing from our &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;example translations data&lt;/a&gt; repository for Ruby on Rails, please &lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;fork&lt;/em&gt;&lt;/a&gt; the repository, add your data, and send a &lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;pull request&lt;/a&gt;.</source>
          <target state="translated">Ruby on Rails의 &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n/tree/master/rails/locale&quot;&gt;번역 데이터&lt;/a&gt; 저장소 예제 에서 사용자 고유의 로케일 (언어)이 누락 된 경우 저장소 를 &lt;a href=&quot;https://github.com/guides/fork-a-project-and-submit-your-modifications&quot;&gt;&lt;em&gt;포크&lt;/em&gt;&lt;/a&gt; 하고 데이터를 추가 한 후 &lt;a href=&quot;https://help.github.com/articles/about-pull-requests/&quot;&gt;pull 요청을&lt;/a&gt; 보내십시오 .</target>
        </trans-unit>
        <trans-unit id="aee4c416dc0883b87638d93d75d5ac3f38315db4" translate="yes" xml:space="preserve">
          <source>If you find yourself adding many extra actions to a resourceful route, it's time to stop and ask yourself whether you're disguising the presence of another resource.</source>
          <target state="translated">자원이 많은 경로에 많은 추가 조치를 추가하는 것을 발견 한 경우, 다른 자원의 존재를 위장하고 있는지를 중지하고 스스로에게 물어볼 시간입니다.</target>
        </trans-unit>
        <trans-unit id="2c6521bc5d3e6fcff4069ac2366db8a204b103d7" translate="yes" xml:space="preserve">
          <source>If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope, like below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67863595d8969ae1f5a6fe5426cd6b3cf82732bd" translate="yes" xml:space="preserve">
          <source>If you find yourself wanting to change this option uniformly for all of your routes, you can use a scope.</source>
          <target state="translated">모든 경로에 대해이 옵션을 균일하게 변경하려는 경우 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d790911f53184fb011a5b1f58933b825e09a9ef2" translate="yes" xml:space="preserve">
          <source>If you followed the steps in the &lt;a href=&quot;getting_started#basic-authentication&quot;&gt;Basic Authentication&lt;/a&gt; section, you'll need to add authorization to every request header to get all the tests passing:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c1ed0660af323c6b38280145d4b69ea2250ce1" translate="yes" xml:space="preserve">
          <source>If you followed the steps in the Basic Authentication section, you'll need to add authorization to every request header to get all the tests passing:</source>
          <target state="translated">기본 인증 섹션의 단계를 수행 한 경우 모든 테스트를 통과하려면 모든 요청 헤더에 권한을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="07b3354400b50989138ed2cd6a3c38797d5e394e" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve authors directly from chapters (&lt;code&gt;@chapter.book.author&lt;/code&gt;), then you can make your code somewhat more efficient by including authors in the association from chapters to books:</source>
          <target state="translated">챕터 ( &lt;code&gt;@chapter.book.author&lt;/code&gt; ) 에서 직접 저자를 자주 검색하는 경우 챕터에서 책에 이르는 관련 작성자를 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="73716ae08dcaaac4220267ec92986f29436f62be" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve chapters directly from authors (&lt;code&gt;@author.books.chapters&lt;/code&gt;), then you can make your code somewhat more efficient by including chapters in the association from authors to books:</source>
          <target state="translated">작성자 ( &lt;code&gt;@author.books.chapters&lt;/code&gt; ) 에서 직접 장을 자주 검색하는 경우 저자에서 책에 이르는 연관 장을 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="98a0030b10beafb8e8d4a632de359b4cb60e78fe" translate="yes" xml:space="preserve">
          <source>If you frequently retrieve representatives directly from suppliers (&lt;code&gt;@supplier.account.representative&lt;/code&gt;), then you can make your code somewhat more efficient by including representatives in the association from suppliers to accounts:</source>
          <target state="translated">공급 업체에서 직접 담당자를 자주 검색하는 경우 ( &lt;code&gt;@supplier.account.representative&lt;/code&gt; ) 공급 업체에서 계정으로 연결에 담당자를 포함시켜 코드를 좀 더 효율적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c0aef2c83bdce2045072d5251d85d631c54098" translate="yes" xml:space="preserve">
          <source>If you generate a form like this:</source>
          <target state="translated">다음과 같은 양식을 생성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="5f9908bbf604191f82bab577a8c5260160dab56d" translate="yes" xml:space="preserve">
          <source>If you generate another resource, you can see that we get exactly the same result! This is useful if you want to customize your scaffold templates and/or layout by just creating &lt;code&gt;edit.html.erb&lt;/code&gt;, &lt;code&gt;index.html.erb&lt;/code&gt; and so on inside &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt;.</source>
          <target state="translated">다른 리소스를 생성하면 정확히 같은 결과를 얻을 수 있습니다! &lt;code&gt;lib/templates/erb/scaffold&lt;/code&gt; 안에 &lt;code&gt;edit.html.erb&lt;/code&gt; , &lt;code&gt;index.html.erb&lt;/code&gt; 등을 만들어 스캐 폴드 템플릿 및 / 또는 레이아웃을 사용자 정의하려는 경우에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d8d80a96cb267acb711147a9efacc8f899edfd01" translate="yes" xml:space="preserve">
          <source>If you generated your mailer, the generator does not create stub fixtures for the mailers actions. You'll have to create those files yourself as described above.</source>
          <target state="translated">메일러를 생성 한 경우 생성기는 메일러 조치에 대한 스텁 설비를 작성하지 않습니다. 위에서 설명한대로 해당 파일을 직접 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0fd092a4ccbfde5c34feeb7f091644196fcd76ba" translate="yes" xml:space="preserve">
          <source>If you get the above error, you might want to increase the size of the connection pool by incrementing the &lt;code&gt;pool&lt;/code&gt; option in &lt;code&gt;database.yml&lt;/code&gt;</source>
          <target state="translated">위의 오류가 발생하면 &lt;code&gt;database.yml&lt;/code&gt; 에서 &lt;code&gt;pool&lt;/code&gt; 옵션을 증가시켜 연결 풀의 크기를 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="5abe2a9c4438d6b9d28b46ea384acc62f1555bf4" translate="yes" xml:space="preserve">
          <source>If you got there by a browser request, the browser tab containing the request will be hung until the debugger has finished and the trace has finished processing the entire request.</source>
          <target state="translated">브라우저 요청으로 도착하면 디버거가 완료되고 추적이 전체 요청 처리를 완료 할 때까지 요청이 포함 된 브라우저 탭이 정지됩니다.</target>
        </trans-unit>
        <trans-unit id="90a6bff827a4dfd6e1a87d9ded69a67eee69dad6" translate="yes" xml:space="preserve">
          <source>If you have a &lt;code&gt;config/database.yml&lt;/code&gt; but no &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; then this file will be used to connect to your database:</source>
          <target state="translated">당신이 가지고있는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 하지만 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 파일은 데이터베이스에 연결하는 데 사용됩니다 없습니다</target>
        </trans-unit>
        <trans-unit id="1be4ccdf90899637a9e7f5bb397c6eba29f87752" translate="yes" xml:space="preserve">
          <source>If you have a Rails template that adds all the files in version control, it fails to add the generated binstubs because it gets executed before Bundler:</source>
          <target state="translated">버전 제어에 모든 파일을 추가하는 Rails 템플리트가있는 경우 Bundler 전에 실행되기 때문에 생성 된 binstub을 추가하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="651cf9b965cdd1ee650c11cdee3bd97dad86eb28" translate="yes" xml:space="preserve">
          <source>If you have a content security policy enabled then you can add an automatic nonce value by passing &lt;code&gt;nonce: true&lt;/code&gt; as part of &lt;code&gt;html_options&lt;/code&gt;. Example:</source>
          <target state="translated">컨텐츠 보안 정책을 사용하는 경우 &lt;code&gt;html_options&lt;/code&gt; 의 일부로 &lt;code&gt;nonce: true&lt;/code&gt; 를 전달하여 자동 nonce 값을 추가 할 수 있습니다 . 예:</target>
        </trans-unit>
        <trans-unit id="d0bcd96695c95db679a2cf79bacb1d734c477fd2" translate="yes" xml:space="preserve">
          <source>If you have a custom &lt;code&gt;QC::Queue&lt;/code&gt; subclass you'll need to subclass &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; and override the &lt;code&gt;build_queue&lt;/code&gt; method.</source>
          <target state="translated">사용자 정의 &lt;code&gt;QC::Queue&lt;/code&gt; 서브 클래스 가있는 경우 &lt;code&gt;ActiveJob::QueueAdapters::QueueClassicAdapter&lt;/code&gt; 를 서브 클래스 하고 &lt;code&gt;build_queue&lt;/code&gt; 메소드를 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f9742db575a597c0715ebe3f5762a44ce4ffcebe" translate="yes" xml:space="preserve">
          <source>If you have a layout that by default is applied to all the actions of a controller, you still have the option of rendering a given action or set of actions without a layout, or restricting a layout to only a single action or a set of actions. The &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; options can be passed to the layout call. For example:</source>
          <target state="translated">기본적으로 컨트롤러의 모든 작업에 적용되는 레이아웃이있는 경우 레이아웃없이 주어진 작업 또는 작업 집합을 렌더링하거나 단일 작업 또는 작업 집합으로 만 레이아웃을 제한 할 수 있습니다. . &lt;code&gt;:only&lt;/code&gt; 와 &lt;code&gt;:except&lt;/code&gt; 옵션 레이아웃 호출에 전달 될 수있다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b93e10e3f4ae69640e52527ab8e71609f556eba" translate="yes" xml:space="preserve">
          <source>If you have a more advanced constraint, you can provide an object that responds to &lt;code&gt;matches?&lt;/code&gt; that Rails should use. Let's say you wanted to route all users on a restricted list to the &lt;code&gt;RestrictedListController&lt;/code&gt;. You could do:</source>
          <target state="translated">보다 고급 제약 조건이있는 경우 &lt;code&gt;matches?&lt;/code&gt; 하는 항목에 응답 할 수 있습니까? Rails가 사용해야합니다. 제한된 목록의 모든 사용자를 &lt;code&gt;RestrictedListController&lt;/code&gt; 로 라우팅한다고 가정 해 봅시다 . 당신은 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1b938a1010440c106301e59585e034c76111aae4" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting name can be generated from the channel and model. For example, the following code uses &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionCable/Channel/Streams.html#method-i-stream_for&quot;&gt;&lt;code&gt;stream_for&lt;/code&gt;&lt;/a&gt; to subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;, where &lt;code&gt;Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; is the GlobalID of the Post model.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a560f192ee8ec9a1a15928b0663a0c5d7fd22fe7" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;</source>
          <target state="translated">모델과 관련된 스트림이있는 경우 모델 및 채널에서 사용 된 브로드 캐스트를 생성 할 수 있습니다. 다음 예제는 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 과 같은 브로드 캐스트를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="f173c059eba767e3af7bbb4a57f0feb244fb4cf2" translate="yes" xml:space="preserve">
          <source>If you have a stream that is related to a model, then the broadcasting used can be generated from the model and channel. The following example would subscribe to a broadcasting like &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt;.</source>
          <target state="translated">모델과 관련된 스트림이있는 경우 모델 및 채널에서 사용 된 브로드 캐스트를 생성 할 수 있습니다. 다음 예제는 &lt;code&gt;comments:Z2lkOi8vVGVzdEFwcC9Qb3N0LzE&lt;/code&gt; 와 같은 브로드 캐스트를 구독합니다 .</target>
        </trans-unit>
        <trans-unit id="23d3e7479d62737411a0853d2c697824552afad8" translate="yes" xml:space="preserve">
          <source>If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object, then specify the name of that attribute using this method and it will be handled automatically. The serialization is done through YAML. If &lt;code&gt;class_name&lt;/code&gt; is specified, the serialized object must be of that class on assignment and retrieval. Otherwise &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;&lt;code&gt;SerializationTypeMismatch&lt;/code&gt;&lt;/a&gt; will be raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace6b01aac78a93246d7e4a98a5362a0be559c03" translate="yes" xml:space="preserve">
          <source>If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object, then specify the name of that attribute using this method and it will be handled automatically. The serialization is done through YAML. If &lt;code&gt;class_name&lt;/code&gt; is specified, the serialized object must be of that class on assignment and retrieval. Otherwise &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt; will be raised.</source>
          <target state="translated">데이터베이스에 오브젝트로 저장해야하고 동일한 오브젝트로 검색해야하는 속성이있는 경우이 메소드를 사용하여 해당 속성의 이름을 지정하면 자동으로 처리됩니다. 직렬화는 YAML을 통해 수행됩니다. &lt;code&gt;class_name&lt;/code&gt; 이 지정된 경우 직렬화 오브젝트는 지정 및 검색시 해당 클래스에 속해야합니다. 그렇지 않으면 &lt;a href=&quot;../../serializationtypemismatch&quot;&gt;SerializationTypeMismatch&lt;/a&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2fe32855d22ec254cf4b801e56944535a321053f" translate="yes" xml:space="preserve">
          <source>If you have an empty &lt;code&gt;config/database.yml&lt;/code&gt; file but your &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; is present, then Rails will connect to the database via your environment variable:</source>
          <target state="translated">빈 &lt;code&gt;config/database.yml&lt;/code&gt; 파일이 있지만 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 있으면 Rails는 환경 변수를 통해 데이터베이스에 연결합니다.</target>
        </trans-unit>
        <trans-unit id="b434262d0e0d30d972cd53659122043c19c68e57" translate="yes" xml:space="preserve">
          <source>If you have an extension that should be shared by many associations, you can use a named extension module. For example:</source>
          <target state="translated">여러 연결에서 공유해야하는 확장이 있으면 명명 된 확장 모듈을 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71c2997c2132b3a3c4257c66422181641082fbce" translate="yes" xml:space="preserve">
          <source>If you have an instance of a model to render into a partial, you can use a shorthand syntax:</source>
          <target state="translated">부분적으로 렌더링 할 모델 인스턴스가있는 경우 간단한 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92ab7fbd387e8e24a134b89d84155d191fe3250" translate="yes" xml:space="preserve">
          <source>If you have an instance of the &lt;code&gt;Picture&lt;/code&gt; model, you can get to its parent via &lt;code&gt;@picture.imageable&lt;/code&gt;. To make this work, you need to declare both a foreign key column and a type column in the model that declares the polymorphic interface:</source>
          <target state="translated">&lt;code&gt;Picture&lt;/code&gt; 모델 의 인스턴스가있는 경우 &lt;code&gt;@picture.imageable&lt;/code&gt; 통해 부모에게 접근 할 수 있습니다 . 이 작업을 수행하려면 모델에서 다형성 인터페이스를 선언하는 외래 키 열과 유형 열을 모두 선언해야합니다.</target>
        </trans-unit>
        <trans-unit id="749159229f0a75d73cecb02d4a0dbd7000807ff0" translate="yes" xml:space="preserve">
          <source>If you have both &lt;code&gt;config/database.yml&lt;/code&gt; and &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; set then Rails will merge the configuration together. To better understand this we must see some examples.</source>
          <target state="translated">&lt;code&gt;config/database.yml&lt;/code&gt; 과 &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 이 모두 설정되어 있으면 Rails는 구성을 병합합니다. 이것을 더 잘 이해하려면 몇 가지 예를보아야합니다.</target>
        </trans-unit>
        <trans-unit id="c50df36a34b654a6ac8d59986b79a1a7b827d8ab" translate="yes" xml:space="preserve">
          <source>If you have created namespaced routes, &lt;code&gt;form_with&lt;/code&gt; has a nifty shorthand for that too. If your application has an admin namespace then</source>
          <target state="translated">네임 스페이스가 &lt;code&gt;form_with&lt;/code&gt; 라우트를 생성 한 경우 form_with도 그에 대한 간단한 약어입니다. 응용 프로그램에 관리 네임 스페이스가있는 경우</target>
        </trans-unit>
        <trans-unit id="dfe47051a5d0d7d1fb7c807bed417ae1e0b1f5f4" translate="yes" xml:space="preserve">
          <source>If you have images as application resources this method may conflict with their named routes. The alias &lt;code&gt;path_to_image&lt;/code&gt; is provided to avoid that. Rails uses the alias internally, and plugin authors are encouraged to do so.</source>
          <target state="translated">응용 프로그램 리소스로 이미지가있는 경우이 방법은 명명 된 경로와 충돌 할 수 있습니다. 이를 피하기 위해 &lt;code&gt;path_to_image&lt;/code&gt; 라는 별칭 이 제공됩니다. Rails는 내부적으로 별명을 사용하므로 플러그인 작성자가 권장합니다.</target>
        </trans-unit>
        <trans-unit id="bab616c672f906a24a8da6f399b21cce858459b1" translate="yes" xml:space="preserve">
          <source>If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like &quot;&amp;Atilde;&amp;frac14;&quot; appearing instead of &quot;&amp;uuml;&quot;. Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.</source>
          <target state="translated">이 영역에서 실수를 한 경우 가장 일반적인 증상은 브라우저에 물음표가있는 검은 색 다이아몬드입니다. 또 다른 일반적인 증상은 &quot;&amp;uuml;&quot;대신 &quot;&amp;Atilde;&quot;와 같은 문자입니다. Rails는 자동으로 감지하고 수정할 수있는 이러한 문제의 일반적인 원인을 완화하기 위해 여러 가지 내부 단계를 수행합니다. 그러나 UTF-8로 저장되지 않은 외부 데이터가있는 경우 때때로 Rails에서 자동으로 감지하여 수정할 수없는 이러한 종류의 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9747b5dd1ba72cbbc96b487b18b280e044481aa5" translate="yes" xml:space="preserve">
          <source>If you have multiple engines that need migrations copied over, use &lt;code&gt;railties:install:migrations&lt;/code&gt; instead:</source>
          <target state="translated">마이그레이션을 복사해야하는 엔진이 여러 개인 경우 대신 &lt;code&gt;railties:install:migrations&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2c03fc752a11ff911bd0015f95701be96c600a53" translate="yes" xml:space="preserve">
          <source>If you have other manifests or individual stylesheets and JavaScript files to include, you can add them to the &lt;code&gt;precompile&lt;/code&gt; array in &lt;code&gt;config/initializers/assets.rb&lt;/code&gt;:</source>
          <target state="translated">포함 할 다른 매니페스트 또는 개별 스타일 시트 및 JavaScript 파일이 있는 경우 &lt;code&gt;config/initializers/assets.rb&lt;/code&gt; 의 &lt;code&gt;precompile&lt;/code&gt; 배열에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df82c551ce18fac9bf69f0fb3e927ca6f5be0c45" translate="yes" xml:space="preserve">
          <source>If you include &lt;code&gt;ActionController::Live&lt;/code&gt; in another module that is included in your controller, then you should also extend the module with &lt;code&gt;ActiveSupport::Concern&lt;/code&gt;. Alternatively, you can use the &lt;code&gt;self.included&lt;/code&gt; hook to include &lt;code&gt;ActionController::Live&lt;/code&gt; directly to the controller once the &lt;code&gt;StreamingSupport&lt;/code&gt; is included.</source>
          <target state="translated">컨트롤러에 포함 된 다른 모듈에 &lt;code&gt;ActionController::Live&lt;/code&gt; 를 포함하는 경우 &lt;code&gt;ActiveSupport::Concern&lt;/code&gt; 모듈을 확장해야합니다 . 또는 &lt;code&gt;StreamingSupport&lt;/code&gt; 가 포함 된 후 &lt;code&gt;self.included&lt;/code&gt; 후크를 사용하여 &lt;code&gt;ActionController::Live&lt;/code&gt; 를 컨트롤러에 직접 포함 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e83fc35c3e903402fcb6715e83f3dc96c7f48074" translate="yes" xml:space="preserve">
          <source>If you look in the &lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; file (remember, yours will have a slightly different name), here's what you'll find:</source>
          <target state="translated">&lt;code&gt;db/migrate/YYYYMMDDHHMMSS_create_articles.rb&lt;/code&gt; 파일 을 살펴보면 (이름이 약간 다름을 기억하십시오) 다음과 같은 내용이 있습니다.</target>
        </trans-unit>
        <trans-unit id="36502aac7177104990ac8b7b22d91a84a84b2725" translate="yes" xml:space="preserve">
          <source>If you modify this collection please update the &lt;a href=&quot;api&quot;&gt;&lt;code&gt;API&lt;/code&gt;&lt;/a&gt; of &lt;code&gt;permit&lt;/code&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="790cbfe3352192c73258d08a620394606704f786" translate="yes" xml:space="preserve">
          <source>If you modify this collection please update the &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; of &lt;code&gt;permit&lt;/code&gt; above.</source>
          <target state="translated">이 컬렉션을 수정하면 위 의 &lt;code&gt;permit&lt;/code&gt; &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; 를 업데이트하십시오 .</target>
        </trans-unit>
        <trans-unit id="bae7f8fe46e797c75db60cffb6a878be3fd20cf1" translate="yes" xml:space="preserve">
          <source>If you need a deep copy of an object, you should use &lt;code&gt;deep_dup&lt;/code&gt;. Here is an example:</source>
          <target state="translated">객체의 딥 카피가 필요한 경우 &lt;code&gt;deep_dup&lt;/code&gt; 을 사용해야합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20f29ef1028dace4ea49a793644fd7a8bcc48fc5" translate="yes" xml:space="preserve">
          <source>If you need a different session storage mechanism, you can change it in an initializer:</source>
          <target state="translated">다른 세션 저장 메커니즘이 필요한 경우 이니셜 라이저에서이를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4b77e57774e9b3722fd797c3196cf018bf5f617" translate="yes" xml:space="preserve">
          <source>If you need more complicated composition, or you need to perform dependent validation, you should build a factory method or class to take care of the complicated needs. This could be as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080a325cf371fc82e3e04c5bccb728e7cb6b2a39" translate="yes" xml:space="preserve">
          <source>If you need other headers not listed above, you can either pass them in as part of the headers hash or use the &lt;code&gt;headers['name'] = value&lt;/code&gt; method.</source>
          <target state="translated">위에 나열되지 않은 다른 헤더가 필요한 경우 헤더 해시의 일부로 전달하거나 &lt;code&gt;headers['name'] = value&lt;/code&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba9e58b64601f550695ea6b0b758c33267135a48" translate="yes" xml:space="preserve">
          <source>If you need the attachment to use a service which differs from the globally configured one, pass the &lt;code&gt;:service&lt;/code&gt; option. For instance:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae92042dbed69362c07d535dde7b6b2ed8c402a" translate="yes" xml:space="preserve">
          <source>If you need to access the subject, from or the recipients in the view, you can do that through message object:</source>
          <target state="translated">보기에서 제목 또는 수신자에게 액세스해야하는 경우 메시지 오브젝트를 통해이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="954f1c83a910f9054d1e6e5f93f9071747a3263d" translate="yes" xml:space="preserve">
          <source>If you need to add verification to the beginning of the callback chain, use &lt;code&gt;prepend: true&lt;/code&gt;.</source>
          <target state="translated">콜백 체인의 시작 부분에 검증을 추가해야하는 경우 &lt;code&gt;prepend: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3cd1bbfe07dcda3b0429f966b7d198efb7a51e68" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class&lt;/a&gt;:</source>
          <target state="translated">동일한 뷰에서 동일한 클래스의 여러 인스턴스를 처리해야하는 경우 &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;#dom_class&lt;/a&gt; 접두어를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bddf5ac729f8e7bcbe96669c6e0c554c817abfd8" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;&lt;code&gt;dom_class&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8a89605e408f1e8580b14cac896f52f258bcf7" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id&lt;/a&gt;:</source>
          <target state="translated">동일한 뷰에서 동일한 클래스의 여러 인스턴스를 처리해야하는 경우 &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;#dom_id&lt;/a&gt; 접두어를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5986a3a7fed9824f85e8bde3c4ff1cab736a2387" translate="yes" xml:space="preserve">
          <source>If you need to address multiple instances of the same class in the same view, you can prefix the &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;&lt;code&gt;dom_id&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b929556de32c40e763358a01509979dc414de278" translate="yes" xml:space="preserve">
          <source>If you need to create a link from outside of controller/view context (Background jobs, Cronjobs, etc.), you can access the &lt;code&gt;rails_blob_path&lt;/code&gt; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9359a7d31d917d57f842db261747f4b0f5f8fe8a" translate="yes" xml:space="preserve">
          <source>If you need to create a link from outside of controller/view context (Background jobs, Cronjobs, etc.), you can access the rails_blob_path like this:</source>
          <target state="translated">컨트롤러 /보기 컨텍스트 외부 (배경 작업, Cronjobs 등)에서 링크를 작성해야하는 경우 다음과 같이 rails_blob_path에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa817aba72a4c37421ed41ccfb1a2fc86729bda1" translate="yes" xml:space="preserve">
          <source>If you need to create routes for more than one resource, you can save a bit of typing by defining them all with a single call to &lt;code&gt;resources&lt;/code&gt;:</source>
          <target state="translated">하나 개 이상의 자원에 대한 경로를 작성해야하는 경우, 단일 호출로 그들 모두를 정의하여 입력의 비트를 저장할 수 있습니다 &lt;code&gt;resources&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="34844eee6eff2caf99e5b8e6623c0bf544ac9a15" translate="yes" xml:space="preserve">
          <source>If you need to customize any of these inflections, for example to add an acronym, please have a look at &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt;.</source>
          <target state="translated">예를 들어 약어를 추가하기 위해 이러한 변곡을 사용자 정의해야하는 경우 &lt;code&gt;config/initializers/inflections.rb&lt;/code&gt; 를 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="d0ff08a60c2c6cbbac3f85d7a645ce59935335c4" translate="yes" xml:space="preserve">
          <source>If you need to disconnect a given connection, you can go through the &lt;a href=&quot;remoteconnections&quot;&gt;&lt;code&gt;RemoteConnections&lt;/code&gt;&lt;/a&gt;. You can find the connections you're looking for by searching for the identifier declared on the connection. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d21564526c14a06fa310834e5593a9e78a326e" translate="yes" xml:space="preserve">
          <source>If you need to disconnect a given connection, you can go through the &lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections&lt;/a&gt;. You can find the connections you're looking for by searching for the identifier declared on the connection. For example:</source>
          <target state="translated">지정된 연결을 끊어야하는 경우 &lt;a href=&quot;remoteconnections&quot;&gt;RemoteConnections를&lt;/a&gt; 통해 이동할 수 있습니다 . 연결에 선언 된 식별자를 검색하여 원하는 연결을 찾을 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5c9243255bc5062fcc30a7801758920f6e9c91b" translate="yes" xml:space="preserve">
          <source>If you need to do more complex things with a default scope, you can alternatively define it as a class method:</source>
          <target state="translated">기본 범위로 더 복잡한 작업을 수행해야하는 경우 클래스 방법으로 정의 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b851041864e229f2acaa2e96d1d7ef079e588936" translate="yes" xml:space="preserve">
          <source>If you need to enable &lt;code&gt;strict_loading&lt;/code&gt; to prevent lazy loading of attachment, pass the &lt;code&gt;:strict_loading&lt;/code&gt; option. You can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8647713ae1317ab7239846593f630f5cd5eaba60" translate="yes" xml:space="preserve">
          <source>If you need to enable &lt;code&gt;strict_loading&lt;/code&gt; to prevent lazy loading of attachments, pass the &lt;code&gt;:strict_loading&lt;/code&gt; option. You can do:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64d124bcef6d2f5cc39955a8634ad8736def8c80" translate="yes" xml:space="preserve">
          <source>If you need to interact with your application models, perform database queries, and so on, your task should depend on the &lt;code&gt;environment&lt;/code&gt; task, which will load your application code.</source>
          <target state="translated">응용 프로그램 모델과 상호 작용하고 데이터베이스 쿼리 등을 수행해야하는 경우 작업은 &lt;code&gt;environment&lt;/code&gt; 작업 에 따라 달라지며 이로 인해 응용 프로그램 코드가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="75176359408a8d163e91332794d54bd48802d326" translate="yes" xml:space="preserve">
          <source>If you need to output JSON elsewhere in your HTML, you can just do something like this, as any unsafe characters (including quotation marks) will be automatically escaped for you:</source>
          <target state="translated">HTML의 다른 곳에서 JSON을 출력 해야하는 경우 안전하지 않은 문자 (따옴표 포함)가 자동으로 이스케이프되므로 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="519dd973910d9eb8ae67c8edf32bba83a663bab5" translate="yes" xml:space="preserve">
          <source>If you need to redirect on the condition of something, then be sure to add &amp;ldquo;and return&amp;rdquo; to halt execution.</source>
          <target state="translated">어떤 상황에서 방향을 재지 정해야한다면 실행을 중단하기 위해&amp;ldquo;and return&amp;rdquo;을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4b83190fc0648fde07fde56ea7fac76aabe04f49" translate="yes" xml:space="preserve">
          <source>If you need to run a specific migration up or down, the &lt;code&gt;db:migrate:up&lt;/code&gt; and &lt;code&gt;db:migrate:down&lt;/code&gt; commands will do that. Just specify the appropriate version and the corresponding migration will have its &lt;code&gt;change&lt;/code&gt;, &lt;code&gt;up&lt;/code&gt; or &lt;code&gt;down&lt;/code&gt; method invoked, for example:</source>
          <target state="translated">특정 마이그레이션을 시작 또는 종료해야하는 경우 &lt;code&gt;db:migrate:up&lt;/code&gt; 및 &lt;code&gt;db:migrate:down&lt;/code&gt; 명령이이를 수행합니다. 적절한 버전을 지정하기 만하면 해당 마이그레이션에 &lt;code&gt;change&lt;/code&gt; , &lt;code&gt;up&lt;/code&gt; 또는 &lt;code&gt;down&lt;/code&gt; 메소드가 호출됩니다 (예 :</target>
        </trans-unit>
        <trans-unit id="7b2c971f9e6d96aca70d28e7479cb38c3f266923" translate="yes" xml:space="preserve">
          <source>If you need to send attachments with no content, you need to create an empty view for it, or add an empty body parameter like this:</source>
          <target state="translated">컨텐츠가없는 첨부 파일을 보내려면 빈 뷰를 작성하거나 다음과 같이 빈 본문 매개 변수를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="04f1c647aef975987d77057d6d4fe9c8d4b41c82" translate="yes" xml:space="preserve">
          <source>If you need to share the same extensions between many associations, you can use a named extension module.</source>
          <target state="translated">여러 연결간에 동일한 확장을 공유해야하는 경우 명명 된 확장 모듈을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ba1aa5152edc7d8ae4a1d94e91395ac318fcc31" translate="yes" xml:space="preserve">
          <source>If you need to support a cloud service other than these, you will need to implement the Service. Each service extends &lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt;&lt;code&gt;ActiveStorage::Service&lt;/code&gt;&lt;/a&gt; by implementing the methods necessary to upload and download files to the cloud.</source>
          <target state="translated">이 이외의 클라우드 서비스를 지원해야하는 경우 서비스를 구현해야합니다. 각 서비스는 파일을 클라우드에 업로드 및 다운로드하는 데 필요한 방법을 구현하여 &lt;a href=&quot;https://github.com/rails/rails/blob/master/activestorage/lib/active_storage/service.rb&quot;&gt; &lt;code&gt;ActiveStorage::Service&lt;/code&gt; &lt;/a&gt; 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="2f9831e439ebeb7b38108ed6ec41e90a0ee658bb" translate="yes" xml:space="preserve">
          <source>If you need to track the progress of the file upload, you can pass a third parameter to the &lt;code&gt;DirectUpload&lt;/code&gt; constructor. During the upload, DirectUpload will call the object's &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; method. You can then bind your own progress handler on the XHR.</source>
          <target state="translated">파일 업로드 진행 상황을 추적해야하는 경우 &lt;code&gt;DirectUpload&lt;/code&gt; 생성자에 세 번째 매개 변수를 전달할 수 있습니다 . 업로드하는 동안 DirectUpload는 개체의 &lt;code&gt;directUploadWillStoreFileWithXHR&lt;/code&gt; 메서드를 호출합니다 . 그런 다음 XHR에서 자체 진행 처리기를 바인딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb9860260780994b1b9fb79388dd273a28e808c5" translate="yes" xml:space="preserve">
          <source>If you need to use a MIME type which isn't supported by default, you can register your own handlers in &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; as follows.</source>
          <target state="translated">기본적으로 지원되지 않는 MIME 유형을 사용해야하는 경우 다음과 같이 &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 에 고유 한 핸들러를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b52f04f9154bc87cc9c64117e4b3ebade3b7646" translate="yes" xml:space="preserve">
          <source>If you need to use a different controller namespace inside a &lt;code&gt;namespace&lt;/code&gt; block you can specify an absolute controller path, e.g: &lt;code&gt;get '/foo', to: '/foo#index'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13930cc1194c1e09ba9d62347bc7e108608cf50" translate="yes" xml:space="preserve">
          <source>If you now go to http://localhost:3000/articles/new you'll &lt;em&gt;almost&lt;/em&gt; be able to create an article. Try it! You should get an error that looks like this:</source>
          <target state="translated">이제 http : // localhost : 3000 / articles / new로 이동하면 &lt;em&gt;거의&lt;/em&gt; 기사 를 작성할 수 있습니다. 시도 해봐! 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="798968b5441f3c2daa3ad458545f1e2ddca45cb0" translate="yes" xml:space="preserve">
          <source>If you only want to see the routes that map to a specific controller, there's the -c option.</source>
          <target state="translated">특정 컨트롤러에 매핑 된 경로 만 보려면 -c 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="71785e7b949dee72159074c906445c53a98687be" translate="yes" xml:space="preserve">
          <source>If you open up the newly generated &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; you'll see a fairly empty controller:</source>
          <target state="translated">새로 생성 된 &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; 를 열면 상당히 빈 컨트롤러가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="4b9cddaa7fdaa1c820239b6b620eea0b072e33d0" translate="yes" xml:space="preserve">
          <source>If you pass a &lt;code&gt;Symbol&lt;/code&gt; as the first argument, then a corresponding cache store class under the &lt;a href=&quot;cache&quot;&gt;&lt;code&gt;ActiveSupport::Cache&lt;/code&gt;&lt;/a&gt; namespace will be created. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caf437c6570b9645593ea709f18577d0e37d6c8e" translate="yes" xml:space="preserve">
          <source>If you pass a Symbol as the first argument, then a corresponding cache store class under the &lt;a href=&quot;cache&quot;&gt;ActiveSupport::Cache&lt;/a&gt; namespace will be created. For example:</source>
          <target state="translated">첫 번째 인수로 Symbol을 전달하면 &lt;a href=&quot;cache&quot;&gt;ActiveSupport :: Cache&lt;/a&gt; 네임 스페이스 아래에 해당 캐시 저장소 클래스 가 작성됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddfa7769dcc84943f68c46033b730ce91d513aec" translate="yes" xml:space="preserve">
          <source>If you pass a single integer, returns a substring of one character at that position. The first character of the string is at position 0, the next at position 1, and so on. If a range is supplied, a substring containing characters at offsets given by the range is returned. In both cases, if an offset is negative, it is counted from the end of the string. Returns &lt;code&gt;nil&lt;/code&gt; if the initial offset falls outside the string. Returns an empty string if the beginning of the range is greater than the end of the string.</source>
          <target state="translated">단일 정수를 전달하면 해당 위치에서 한 문자의 하위 문자열을 반환합니다. 문자열의 첫 번째 문자는 위치 0에 있고 다음 문자는 위치 1에 있습니다. 범위가 제공되면 범위에 의해 지정된 오프셋에 문자가 포함 된 하위 문자열이 반환됩니다. 두 경우 모두 오프셋이 음수이면 문자열 끝부터 계산됩니다. 초기 오프셋이 문자열을 벗어나면 &lt;code&gt;nil&lt;/code&gt; 을 반환 합니다. 범위의 시작이 문자열의 끝보다 큰 경우 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="632b8d8ffb1decfb5d4c8badbac89dd3e00fd7a9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;, please refer to the class version of this method for more information.</source>
          <target state="translated">추가 구성 옵션을 전달하면 클래스로 전달되어 &lt;code&gt;options&lt;/code&gt; 사용할 수 있습니다 . 자세한 정보는이 메소드의 클래스 버전을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="682ace517c959a77a771d42d6d9eac363da111c9" translate="yes" xml:space="preserve">
          <source>If you pass any additional configuration options, they will be passed to the class and available as &lt;code&gt;options&lt;/code&gt;:</source>
          <target state="translated">추가 구성 옵션을 전달하면 클래스에 전달되고 &lt;code&gt;options&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b6ba8e3114a56aad325e9b14a29ecad96dca5d8" translate="yes" xml:space="preserve">
          <source>If you pass arguments to &amp;ldquo;yield&amp;rdquo; then this will be passed to the block. One way to use this is to pass an array to layout and treat it as an enumerable.</source>
          <target state="translated">인수를 &quot;yield&quot;에 전달하면 블록으로 전달됩니다. 이것을 사용하는 한 가지 방법은 배열을 레이아웃에 전달하고 열거 가능한 것으로 취급하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ca671450e64d7c78803ba20152fc9ae15ff0cbb" translate="yes" xml:space="preserve">
          <source>If you pass the conditions via hash, you don't need to call &lt;a href=&quot;querymethods#method-i-references&quot;&gt;&lt;code&gt;references&lt;/code&gt;&lt;/a&gt; explicitly, as &lt;a href=&quot;querymethods#method-i-where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; references the tables for you. For example, this will work correctly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f17ab7779351ab1a6884b258f583eb53ffb5b44d" translate="yes" xml:space="preserve">
          <source>If you pass the conditions via hash, you don't need to call &lt;a href=&quot;querymethods#method-i-references&quot;&gt;references&lt;/a&gt; explicitly, as &lt;a href=&quot;querymethods#method-i-where&quot;&gt;where&lt;/a&gt; references the tables for you. For example, this will work correctly:</source>
          <target state="translated">해시를 통해 조건을 전달하는 경우 테이블을 참조하는 &lt;a href=&quot;querymethods#method-i-where&quot;&gt;위치를&lt;/a&gt; 명시 적으로 &lt;a href=&quot;querymethods#method-i-references&quot;&gt;참조&lt;/a&gt; 할 필요가 없습니다 . 예를 들어, 이것은 올바르게 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="3b7db4311465b5c467ecad29ee1f4f9d15f4656a" translate="yes" xml:space="preserve">
          <source>If you prefer logging to a file, configure this instead:</source>
          <target state="translated">파일에 로깅하려는 경우 대신 다음을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="215c252f0c89788189f24e2d9043c91a50b33007" translate="yes" xml:space="preserve">
          <source>If you prefer using threads or are using JRuby, a threaded parallelization option is provided. The threaded parallelizer is backed by Minitest's &lt;code&gt;Parallel::Executor&lt;/code&gt;.</source>
          <target state="translated">스레드를 선호하거나 JRuby를 사용하는 경우 스레드 병렬화 옵션이 제공됩니다. 스레드 병렬 처리기는 Minitest의 &lt;code&gt;Parallel::Executor&lt;/code&gt; 의해 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="a3789852af758cb44c9cde54c2bf2f996f31aeaa" translate="yes" xml:space="preserve">
          <source>If you prefer, &lt;code&gt;:root&lt;/code&gt; may also be set to a custom string key instead as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafe8299d3fe7769815c71c88d087079dcd317d2" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use a symbol instead of a string to specify the action to render:</source>
          <target state="translated">원하는 경우 문자열 대신 기호를 사용하여 렌더링 할 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5759fcb74aeced75f262d2c81cd49c891035e54" translate="yes" xml:space="preserve">
          <source>If you preload your test database with all fixture data (probably by running `bin/rails db:fixtures:load`) and use transactional tests, then you may omit all fixtures declarations in your test cases since all the data's already there and every case rolls back its changes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d10e2bda23cd78a6360473103ead5548519dcba" translate="yes" xml:space="preserve">
          <source>If you preload your test database with all fixture data (probably by running `rails db:fixtures:load`) and use transactional tests, then you may omit all fixtures declarations in your test cases since all the data's already there and every case rolls back its changes.</source>
          <target state="translated">만약 모든 데이터베이스에 모든 조명기 데이터를 미리로드하고 (아마도 rails db : fixtures : load를 실행하여) 트랜잭션 테스트를 사용한다면, 모든 데이터가 이미 존재하고 모든 케이스가 롤백되기 때문에 테스트 케이스에서 모든 조명기 선언을 생략 할 수 있습니다 그 변화.</target>
        </trans-unit>
        <trans-unit id="a283849315c28472c2b88b415ee7f9c3173ca206" translate="yes" xml:space="preserve">
          <source>If you previously stopped the web server to run the controller generator, restart it with &lt;code&gt;bin/rails server&lt;/code&gt;. Now visit http://localhost:3000/articles, and see our text displayed!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="032b750ddc0f2a68782ec3a07a6c02fa0912464e" translate="yes" xml:space="preserve">
          <source>If you re-submit the form now, you may not see any change on the page. Don't worry! This is because Rails by default returns &lt;code&gt;204 No Content&lt;/code&gt; response for an action if we don't specify what the response should be. We just added the &lt;code&gt;create&lt;/code&gt; action but didn't specify anything about how the response should be. In this case, the &lt;code&gt;create&lt;/code&gt; action should save our new article to the database.</source>
          <target state="translated">지금 양식을 다시 제출하면 페이지에 변경 사항이 표시되지 않을 수 있습니다. 걱정 마세요! 응답이 무엇인지 지정하지 않으면 Rails는 기본적으로 액션에 대해 &lt;code&gt;204 No Content&lt;/code&gt; 응답을 반환하기 때문 입니다. 방금 &lt;code&gt;create&lt;/code&gt; action을 추가 했지만 응답 방법에 대해서는 아무것도 지정하지 않았습니다. 이 경우, &lt;code&gt;create&lt;/code&gt; 조치는 새 기사를 데이터베이스에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="0a3ba760f2039016218b42a07ffd0719e51d2c95" translate="yes" xml:space="preserve">
          <source>If you re-submit the form one more time, you'll see something that looks like the following:</source>
          <target state="translated">양식을 한 번 더 다시 제출하면 다음과 같은 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5cb608c0020eca0be434d098953cdecfbe1c340" translate="yes" xml:space="preserve">
          <source>If you refresh http://localhost:3000/articles/new now, you'll get a new error:</source>
          <target state="translated">http : // localhost : 3000 / articles / new를 새로 고치면 새로운 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="62810ba4faad6de0e07c448d86b162e6adf194c5" translate="yes" xml:space="preserve">
          <source>If you refresh the page now, you'll see the exact same form from our example above. Building forms in Rails is really just that easy!</source>
          <target state="translated">지금 페이지를 새로 고치면 위의 예와 정확히 동일한 양식이 표시됩니다. Rails에서 양식을 작성하는 것은 정말 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="d168564efe905e950a12a0bbe8fa883b06949143" translate="yes" xml:space="preserve">
          <source>If you reload http://localhost:3000/articles/new and try to save an article without a title, Rails will send you back to the form, but that's not very useful. You need to tell the user that something went wrong. To do that, you'll modify &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; to check for error messages:</source>
          <target state="translated">http : // localhost : 3000 / articles / new를 다시로드하고 제목없이 기사를 저장하려고하면 Rails에서 양식으로 다시 보내지 만 유용하지는 않습니다. 사용자에게 무언가 잘못되었다고 알려 주어야합니다. 이를 위해 &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; 를 수정 하여 오류 메시지를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8dc2177084e8c394a6a53d12cfdefd8100d07b30" translate="yes" xml:space="preserve">
          <source>If you remember from earlier, one of the Three Hashes of the Apocalypse was &lt;code&gt;flash&lt;/code&gt;.</source>
          <target state="translated">당신이 이전부터 기억한다면, 묵시록의 세 가지 해시 중 하나가 &lt;code&gt;flash&lt;/code&gt; 였습니다.</target>
        </trans-unit>
        <trans-unit id="6bbbbc8ef48ad1bc17685b694d5aad9a5207505f" translate="yes" xml:space="preserve">
          <source>If you remember, we used the &lt;code&gt;bin/rails generate model&lt;/code&gt; command in the &lt;a href=&quot;getting_started&quot;&gt;Getting Started with Rails&lt;/a&gt; guide. We created our first model, and among other things it created test stubs in the &lt;code&gt;test&lt;/code&gt; directory:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dbac9c281a00497859f5bd21c6d9e0516606801" translate="yes" xml:space="preserve">
          <source>If you remember, we used the &lt;code&gt;rails generate model&lt;/code&gt; command in the &lt;a href=&quot;getting_started&quot;&gt;Getting Started with Rails&lt;/a&gt; guide. We created our first model, and among other things it created test stubs in the &lt;code&gt;test&lt;/code&gt; directory:</source>
          <target state="translated">기억 나는 경우, &lt;a href=&quot;getting_started&quot;&gt;Rails 시작하기&lt;/a&gt; 안내서 에서 &lt;code&gt;rails generate model&lt;/code&gt; 명령을 사용했습니다. 우리는 첫 번째 모델을 만들었고 무엇보다도 &lt;code&gt;test&lt;/code&gt; 디렉토리 에 테스트 스텁을 만들었습니다 .</target>
        </trans-unit>
        <trans-unit id="66a7e4fff5ec93b09b720d5b6a8599b8fb7d7ff2" translate="yes" xml:space="preserve">
          <source>If you repeatedly invoke application code from a long-running process, you may want to wrap using the Reloader instead.</source>
          <target state="translated">장기 실행 프로세스에서 애플리케이션 코드를 반복해서 호출하는 경우 대신 리 로더를 사용하여 랩핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7a1fd5aef7d3248f2da5139cc60b8c9d29b34d" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by 5.1 and older, or you are still validating your 5.2 deploy and want to allow you to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">5.1 이상에서 쿠키를 읽거나 5.2 배포의 유효성을 검사하고 &lt;code&gt;Rails.application.config.action_dispatch.use_authenticated_cookie_encryption&lt;/code&gt; 을 &lt;code&gt;false&lt;/code&gt; 로 롤백하도록 허용하려는 경우 쿠키를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="1dfadda751bf13743cb353e426d145dc9b175a37" translate="yes" xml:space="preserve">
          <source>If you require your cookies to be read by Rails 5.2 and older, or you are still validating your 6.0 deploy and want to be able to rollback set &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Rails 5.2 이전 버전에서 쿠키를 읽거나 6.0 배포를 계속 검증하고 &lt;code&gt;Rails.application.config.action_dispatch.use_cookies_with_metadata&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 롤백 할 수 있도록하려는 경우 .</target>
        </trans-unit>
        <trans-unit id="9fc71a9c4e127e7236f9ac5863d445bd51714d2b" translate="yes" xml:space="preserve">
          <source>If you reuse this frequently you could define a &lt;code&gt;labeled_form_with&lt;/code&gt; helper that automatically applies the &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; option:</source>
          <target state="translated">이것을 자주 재사용 하면 &lt;code&gt;builder: LabellingFormBuilder&lt;/code&gt; 를 자동으로 적용 하는 &lt;code&gt;labeled_form_with&lt;/code&gt; 헬퍼를 정의 할 수 있습니다 . LabellingFormBuilder 옵션 :</target>
        </trans-unit>
        <trans-unit id="6cbb87cb4a5f9fbd29ad857e361eaf0f387942e5" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;rails routes&lt;/code&gt;, you'll see that it has defined routes for all the standard RESTful actions. The meaning of the prefix column (and other columns) will be seen later, but for now notice that Rails has inferred the singular form &lt;code&gt;article&lt;/code&gt; and makes meaningful use of the distinction.</source>
          <target state="translated">&lt;code&gt;rails routes&lt;/code&gt; 를 실행 하면 모든 표준 RESTful 작업에 대한 경로가 정의 된 것을 볼 수 있습니다. 접두사 열 (및 다른 열)의 의미는 나중에 볼 수 있지만 지금은 Rails가 단수 형태의 &lt;code&gt;article&lt;/code&gt; 유추 하여 구별을 의미있게 사용 한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68dff2d001ad46e0ca7836ed43da063e6aa4d296" translate="yes" xml:space="preserve">
          <source>If you run the &lt;code&gt;bin/rails db:migrate:status&lt;/code&gt; command, which displays the status (up or down) of each migration, you should see &lt;code&gt;********** NO FILE **********&lt;/code&gt; displayed next to any deleted migration file which was once executed on a specific environment but can no longer be found in the &lt;code&gt;db/migrate/&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5736fbb209b1e7176278dc85bda1088c0f60271" translate="yes" xml:space="preserve">
          <source>If you run the &lt;code&gt;rails db:migrate:status&lt;/code&gt; command, which displays the status (up or down) of each migration, you should see &lt;code&gt;********** NO FILE **********&lt;/code&gt; displayed next to any deleted migration file which was once executed on a specific environment but can no longer be found in the &lt;code&gt;db/migrate/&lt;/code&gt; directory.</source>
          <target state="translated">각 마이그레이션의 상태 (위 또는 아래)를 표시 하는 &lt;code&gt;rails db:migrate:status&lt;/code&gt; 명령 을 실행하면 &lt;code&gt;********** NO FILE **********&lt;/code&gt; 특정 환경에서 한 번 실행되었지만 더 이상 &lt;code&gt;db/migrate/&lt;/code&gt; 디렉토리 에서 찾을 수없는 삭제 된 마이그레이션 파일 옆에 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ddac9227d2dba8d69bc55abee86ae1f7389613d" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;:only_integer&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;, then it will use the</source>
          <target state="translated">&lt;code&gt;:only_integer&lt;/code&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정 하면</target>
        </trans-unit>
        <trans-unit id="19f348f6eb1e1e1b70df686b3c8e3b935bafcace" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;config.time_zone&lt;/code&gt; in the Rails Application, you can access this &lt;a href=&quot;timezone&quot;&gt;&lt;code&gt;TimeZone&lt;/code&gt;&lt;/a&gt; object via &lt;code&gt;Time.zone&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a740b969cec9b8b5c9b7bf367c39be063ba9913" translate="yes" xml:space="preserve">
          <source>If you set &lt;code&gt;config.time_zone&lt;/code&gt; in the Rails Application, you can access this &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; object via &lt;code&gt;Time.zone&lt;/code&gt;:</source>
          <target state="translated">Rails 애플리케이션에서 &lt;code&gt;config.time_zone&lt;/code&gt; 을 설정 하면 &lt;code&gt;Time.zone&lt;/code&gt; 을 통해이 &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; 객체에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e982780a9d946f64c4d7b6f259ce4892a834ec57" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:autosave&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, Rails will save any loaded association members and destroy members that are marked for destruction whenever you save the parent object. Setting &lt;code&gt;:autosave&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; is not the same as not setting the &lt;code&gt;:autosave&lt;/code&gt; option. If the &lt;code&gt;:autosave&lt;/code&gt; option is not present, then new associated objects will be saved, but updated associated objects will not be saved.</source>
          <target state="translated">&lt;code&gt;:autosave&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 Rails는로드 된 연관 멤버를 저장하고 부모 오브젝트를 저장할 때마다 소멸로 표시된 멤버를 삭제합니다. 설정 &lt;code&gt;:autosave&lt;/code&gt; 에 &lt;code&gt;false&lt;/code&gt; 를 설정하지 않는 것과 동일하지 않습니다 &lt;code&gt;:autosave&lt;/code&gt; 옵션을 선택합니다. 는 IF &lt;code&gt;:autosave&lt;/code&gt; 옵션이 존재하지 않는 한 다음 새 연결 개체가 저장되지만 업데이트 관련 개체가 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a5ac83c1930890185af66324fd705be52e7e44d4" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:dependent&lt;/code&gt; option to:</source>
          <target state="translated">&lt;code&gt;:dependent&lt;/code&gt; 옵션을 다음 과 같이 설정 한 경우 :</target>
        </trans-unit>
        <trans-unit id="12dcf0f411660275e0f33063283ddd8270d49a00" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:optional&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the presence of the associated object won't be validated. By default, this option is set to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:optional&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정하면 연결된 객체의 존재가 확인되지 않습니다. 기본적으로이 옵션은 &lt;code&gt;false&lt;/code&gt; 로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f54ae2ad12dfc24f090d30428ebf9feaf86d69cf" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:touch&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then the &lt;code&gt;updated_at&lt;/code&gt; or &lt;code&gt;updated_on&lt;/code&gt; timestamp on the associated object will be set to the current time whenever this object is saved or destroyed:</source>
          <target state="translated">당신이 설정 한 경우 &lt;code&gt;:touch&lt;/code&gt; 에 옵션이 &lt;code&gt;true&lt;/code&gt; 다음 &lt;code&gt;updated_at&lt;/code&gt; 또는 &lt;code&gt;updated_on&lt;/code&gt; 관련 개체에 대한 타임 스탬프는이 객체가 저장되거나 파괴 될 때마다 현재 시간으로 설정됩니다 :</target>
        </trans-unit>
        <trans-unit id="38743afae7adfc5e0e587df5c7c10a6c0f8b74a9" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt;, then associated objects will not be validated whenever you save this object. By default, this is &lt;code&gt;true&lt;/code&gt;: associated objects will be validated when this object is saved.</source>
          <target state="translated">&lt;code&gt;:validate&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정 하면이 객체를 저장할 때마다 연결된 객체의 유효성이 검사되지 않습니다. 기본적으로이 값은 &lt;code&gt;true&lt;/code&gt; 입니다 .이 개체를 저장하면 연결된 개체의 유효성이 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="bb46c33993d0c4a869b2ee45c2a47a55c32ff3a1" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;:validate&lt;/code&gt; option to &lt;code&gt;true&lt;/code&gt;, then associated objects will be validated whenever you save this object. By default, this is &lt;code&gt;false&lt;/code&gt;: associated objects will not be validated when this object is saved.</source>
          <target state="translated">&lt;code&gt;:validate&lt;/code&gt; 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정 하면이 객체를 저장할 때마다 연결된 객체의 유효성이 검사됩니다. 기본적으로이 값은 &lt;code&gt;false&lt;/code&gt; 입니다 .이 개체를 저장할 때 연결된 개체의 유효성이 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46487150d7f14526dc0ba356b10fe44c3d1645d8" translate="yes" xml:space="preserve">
          <source>If you simply want to check for the existence of the object there's a method called &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F&quot;&gt;&lt;code&gt;exists?&lt;/code&gt;&lt;/a&gt;. This method will query the database using the same query as &lt;code&gt;find&lt;/code&gt;, but instead of returning an object or collection of objects it will return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dacf4eb6331a59ac9520410f480184f687ec5233" translate="yes" xml:space="preserve">
          <source>If you simply want to check for the existence of the object there's a method called &lt;code&gt;exists?&lt;/code&gt;. This method will query the database using the same query as &lt;code&gt;find&lt;/code&gt;, but instead of returning an object or collection of objects it will return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">단순히 객체의 존재를 확인하고 싶다면 exist라는 메소드 &lt;code&gt;exists?&lt;/code&gt; . 이 메소드는 &lt;code&gt;find&lt;/code&gt; 와 동일한 쿼리를 사용하여 데이터베이스를 쿼리 하지만 개체 또는 개체 컬렉션을 반환하는 대신 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="67bc3cb65d8184980d212dfd9e822bfdf8b287bc" translate="yes" xml:space="preserve">
          <source>If you specify a Rack application as the endpoint for a matcher, remember that the route will be unchanged in the receiving application. With the following route your Rack application should expect the route to be &lt;code&gt;/admin&lt;/code&gt;:</source>
          <target state="translated">랙 애플리케이션을 매처의 엔드 포인트로 지정하면 수신 애플리케이션에서 라우트가 변경되지 않습니다. 다음 경로를 사용하면 랙 응용 프로그램에서 경로가 &lt;code&gt;/admin&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1008a7039ea28960d769ea99f1ff1f8c59392671" translate="yes" xml:space="preserve">
          <source>If you specify a target version, Active Record will run the required migrations (change, up, down) until it has reached the specified version. The version is the numerical prefix on the migration's filename. For example, to migrate to version 20080906120000 run:</source>
          <target state="translated">대상 버전을 지정하면 Active Record는 지정된 버전에 도달 할 때까지 필요한 마이그레이션 (변경, 위, 아래)을 실행합니다. 버전은 마이그레이션 파일 이름의 숫자 접두사입니다. 예를 들어, 20080906120000 버전으로 마이그레이션하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f651ca4d5d892c8edafc644e3e3a8fd8f269046b" translate="yes" xml:space="preserve">
          <source>If you specify an encoding, Mail will assume that your content is already encoded and not try to Base64 encode it.</source>
          <target state="translated">인코딩을 지정하면 Mail은 내용이 이미 인코딩 된 것으로 가정하고 Base64 인코딩을 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9126865264c6be1e7027d977582109ed0bb142af" translate="yes" xml:space="preserve">
          <source>If you specify your own &lt;code&gt;select&lt;/code&gt;, be sure to include the primary key and foreign key columns of the associated model. If you do not, Rails will throw an error.</source>
          <target state="translated">고유 한 &lt;code&gt;select&lt;/code&gt; 를 지정하는 경우 연관된 모델의 기본 키 및 외래 키 열을 포함해야합니다. 그렇지 않으면 Rails에서 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f16426fc6e7323d088a689b6ea243d576d56117e" translate="yes" xml:space="preserve">
          <source>If you stop the &lt;code&gt;ajax:aborted:file&lt;/code&gt; event, the default behavior of allowing the browser to submit the form via normal means (i.e. non-Ajax submission) will be canceled and the form will not be submitted at all. This is useful for implementing your own Ajax file upload workaround.</source>
          <target state="translated">당신이 중지하면 &lt;code&gt;ajax:aborted:file&lt;/code&gt; 이벤트를 정상적인 수단을 통해 양식을 제출 브라우저를 허용하는 기본 동작 (즉, 비 아약스 제출)이 취소되고 양식이 전혀 제출되지 않습니다. 이는 고유 한 Ajax 파일 업로드 해결 방법을 구현하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="51f455c5e6976e35adebd807b27c3342f5873d91" translate="yes" xml:space="preserve">
          <source>If you submit the form again now, Rails will complain about not finding the &lt;code&gt;show&lt;/code&gt; action. That's not very useful though, so let's add the &lt;code&gt;show&lt;/code&gt; action before proceeding.</source>
          <target state="translated">지금 양식을 다시 제출하면 Rails는 &lt;code&gt;show&lt;/code&gt; 조치를 찾지 못하는 것에 대해 불평 합니다. 그다지 유용하지는 않으므로 진행하기 전에 &lt;code&gt;show&lt;/code&gt; 액션을 추가해 보겠습니다 .</target>
        </trans-unit>
        <trans-unit id="68a6679b4edb22f06a2c4bad7125b30641e15742" translate="yes" xml:space="preserve">
          <source>If you then restart the application and re-trigger the deadlock condition, &lt;code&gt;/rails/locks&lt;/code&gt; will show a summary of all threads currently known to the interlock, which lock level they are holding or awaiting, and their current backtrace.</source>
          <target state="translated">그런 다음 응용 프로그램을 다시 시작하고 교착 상태를 다시 트리거하면 &lt;code&gt;/rails/locks&lt;/code&gt; 는 현재 인터록에 알려진 모든 스레드, 보유 또는 대기중인 잠금 레벨 및 현재 역 추적에 대한 요약을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="45dc06c18ada78f9291ac8e05d04201fde995ce7" translate="yes" xml:space="preserve">
          <source>If you try out this command in a Rails console, you would see that this loads &lt;code&gt;railties/exe/rails&lt;/code&gt;. A part of the file &lt;code&gt;railties/exe/rails&lt;/code&gt; has the following code:</source>
          <target state="translated">Rails 콘솔에서이 명령을 시도하면 &lt;code&gt;railties/exe/rails&lt;/code&gt; 가로드 되는 것을 볼 수 있습니다. 파일 &lt;code&gt;railties/exe/rails&lt;/code&gt; 의 일부 에는 다음 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c7739665b35931a331b95459613cd91721f606b" translate="yes" xml:space="preserve">
          <source>If you try running &lt;code&gt;test_should_create_article&lt;/code&gt; test from &lt;code&gt;articles_controller_test.rb&lt;/code&gt; it will fail on account of the newly added model level validation and rightly so.</source>
          <target state="translated">&lt;code&gt;articles_controller_test.rb&lt;/code&gt; 에서 &lt;code&gt;test_should_create_article&lt;/code&gt; 테스트를 실행하려고 하면 새로 추가 된 모델 레벨 유효성 검사로 인해 실패합니다.</target>
        </trans-unit>
        <trans-unit id="69aa3078e7ba43546bbdbcbcd41e3c86b7e26fa6" translate="yes" xml:space="preserve">
          <source>If you try to define a set of Rake tasks on the instance, these will get passed up to the Rake tasks defined on the application's class.</source>
          <target state="translated">인스턴스에서 일련의 Rake 작업을 정의하려고하면 응용 프로그램 클래스에 정의 된 Rake 작업으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="43891496e6b3634d5b07b0b4f3b41b7a66741e77" translate="yes" xml:space="preserve">
          <source>If you try to render content along with a non-content status code (100-199, 204, 205, or 304), it will be dropped from the response.</source>
          <target state="translated">컨텐츠가 아닌 상태 코드 (100-199, 204, 205 또는 304)와 함께 컨텐츠를 렌더링하려고하면 응답에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="5fd0daa65aa7e1a3f3cac1e33634eb83b028b95e" translate="yes" xml:space="preserve">
          <source>If you try to use more connections than are available, Active Record will block you and wait for a connection from the pool. If it cannot get a connection, a timeout error similar to that given below will be thrown.</source>
          <target state="translated">사용 가능한 것보다 많은 연결을 사용하려고하면 Active Record가 사용자를 차단하고 풀에서 연결을 기다립니다. 연결이되지 않으면 아래와 같은 시간 초과 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3e38a2854f5be3959a8fa63e6b0e3873530985ad" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;form_with&lt;/code&gt; without &lt;code&gt;:model&lt;/code&gt;, you must set it yourself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="860e16f3811842974bde3c3a9af5e24519a3b933" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;readonly&lt;/code&gt;, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 를 사용 하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="b2fff0660301739a755c59746d1897254d0051f8" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt; option, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; or &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; will create books where the confirmed column has the value &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">해시 스타일 &lt;code&gt;where&lt;/code&gt; 옵션 을 사용하는 경우이 연관을 통한 레코드 작성은 해시를 사용하여 자동으로 범위가 지정됩니다. 이 경우 &lt;code&gt;@author.confirmed_books.create&lt;/code&gt; 또는 &lt;code&gt;@author.confirmed_books.build&lt;/code&gt; 를 사용하면 확인 된 열의 값이 &lt;code&gt;true&lt;/code&gt; 인 책을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5dd83d9db514a7dbdd4c85fbd0f778c62753c3a1" translate="yes" xml:space="preserve">
          <source>If you use a hash-style &lt;code&gt;where&lt;/code&gt;, then record creation via this association will be automatically scoped using the hash. In this case, using &lt;code&gt;@parts.assemblies.create&lt;/code&gt; or &lt;code&gt;@parts.assemblies.build&lt;/code&gt; will create orders where the &lt;code&gt;factory&lt;/code&gt; column has the value &quot;Seattle&quot;.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 해시 스타일을 사용하는 경우이 연결을 통한 레코드 작성은 해시를 사용하여 자동으로 범위가 지정됩니다. 이 경우 &lt;code&gt;@parts.assemblies.create&lt;/code&gt; 또는 &lt;code&gt;@parts.assemblies.build&lt;/code&gt; 를 사용하면 &lt;code&gt;factory&lt;/code&gt; 열의 값이 &quot;Seattle&quot;인 주문이 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff0906b2865b4b40c9406d2045692447a90d6ec8" translate="yes" xml:space="preserve">
          <source>If you use a helper method, for example, inside a cached block and you then update that helper, you'll have to bump the cache as well. It doesn't really matter how you do it, but the MD5 of the template file must change. One recommendation is to simply be explicit in a comment, like:</source>
          <target state="translated">예를 들어 캐시 된 블록 내부에서 도우미 메서드를 사용하고 해당 도우미를 업데이트하는 경우 캐시도 충돌해야합니다. 실제로 어떻게 수행하든 중요하지 않지만 템플릿 파일의 MD5는 변경되어야합니다. 한 가지 권장 사항은 다음과 같이 주석에 명시 적으로 명시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b7278a05bf1f7032406ce8df1e82fa5cb69d391c" translate="yes" xml:space="preserve">
          <source>If you use a module, for instance Weblog::PostsController, you will need a template named &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt;.</source>
          <target state="translated">Weblog :: PostsController와 같은 모듈을 사용하는 경우 &lt;code&gt;app/views/layouts/weblog/posts.html.erb&lt;/code&gt; 라는 템플릿이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1ce5a47f8e7e2a9b04c86ebb4fd66b97d7210e50" translate="yes" xml:space="preserve">
          <source>If you use a schema cache and multiple databases you'll need to write an initializer that loads the schema cache from your app. This wasn't an issue we could resolve in time for Rails 6.0 but hope to have it in a future version soon.</source>
          <target state="translated">스키마 캐시와 여러 데이터베이스를 사용하는 경우 앱에서 스키마 캐시를로드하는 이니셜 라이저를 작성해야합니다. 이것은 우리가 Rails 6.0을 위해 제 시간에 해결할 수있는 문제가 아니었지만 곧 차기 버전에서이를 희망하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="07b01820e27e6c2cca211b500d5ba349e7d7df52" translate="yes" xml:space="preserve">
          <source>If you use multiple &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;&lt;code&gt;default_scope&lt;/code&gt;&lt;/a&gt; declarations in your model then they will be merged together:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe42d6b14f3e476da63fc938a5753e0e1a72642" translate="yes" xml:space="preserve">
          <source>If you use multiple &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt; declarations in your model then they will be merged together:</source>
          <target state="translated">모델에서 여러 &lt;a href=&quot;classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt; 선언 을 사용하면 함께 병합됩니다.</target>
        </trans-unit>
        <trans-unit id="be18271788c903adfe66041542c20ad858f726b8" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor plugin&lt;/a&gt;, or actions that return a string, rather than rendering a view, &lt;em&gt;you have to escape the return value in the action&lt;/em&gt;. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the &lt;code&gt;h()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c97ff655888952411fdd288b4e6d761401568a" translate="yes" xml:space="preserve">
          <source>If you use the &lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor plugin&lt;/a&gt;, or actions that return a string, rather than rendering a view, &lt;em&gt;you have to escape the return value in the action&lt;/em&gt;. Otherwise, if the return value contains a XSS string, the malicious code will be executed upon return to the browser. Escape any input value using the h() method.</source>
          <target state="translated">&lt;a href=&quot;https://rubygems.org/gems/in_place_editing&quot;&gt;in_place_editor 플러그인&lt;/a&gt; 또는 뷰를 렌더링하지 않고 문자열을 리턴하는 조치 를 사용하는 경우 &lt;em&gt;action에서 리턴 값을 이스케이프해야합니다&lt;/em&gt; . 그렇지 않으면 반환 값에 XSS 문자열이 포함되어 있으면 악성 코드가 브라우저로 돌아올 때 실행됩니다. h () 메소드를 사용하여 입력 값을 이스케이프하십시오.</target>
        </trans-unit>
        <trans-unit id="42b21ecf5693ca022b4b65f0e8a6a7b79b4dcdcd" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated object will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 메소드 를 사용하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="13fd547389407f2aa534f580945dfbb93b81209d" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;readonly&lt;/code&gt; method, then the associated objects will be read-only when retrieved via the association.</source>
          <target state="translated">&lt;code&gt;readonly&lt;/code&gt; 메소드 를 사용하면 연관을 통해 검색 할 때 연관된 오브젝트가 읽기 전용이됩니다.</target>
        </trans-unit>
        <trans-unit id="e4b4313b28e5174a5005ef4a1de6683090bde533" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;select&lt;/code&gt; method on a &lt;code&gt;belongs_to&lt;/code&gt; association, you should also set the &lt;code&gt;:foreign_key&lt;/code&gt; option to guarantee the correct results.</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 연관 에서 &lt;code&gt;select&lt;/code&gt; 메소드 를 사용하는 경우 , 올바른 결과를 보장하기 위해 &lt;code&gt;:foreign_key&lt;/code&gt; 옵션 도 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2957357fa844d5aa40521acffe133afd9ad46862" translate="yes" xml:space="preserve">
          <source>If you use the cookie session store, this would apply to the &lt;code&gt;session&lt;/code&gt; and &lt;code&gt;flash&lt;/code&gt; hash as well.</source>
          <target state="translated">쿠키 세션 저장소를 사용하는 경우 이는 &lt;code&gt;session&lt;/code&gt; 및 &lt;code&gt;flash&lt;/code&gt; 해시 에도 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="ba2e5aabecb68374b1079b50a06d15a4d4a23aff" translate="yes" xml:space="preserve">
          <source>If you use the popular &lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem for user management, it will automatically expire sessions on sign in and sign out for you. If you roll your own, remember to expire the session after your sign in action (when the session is created). This will remove values from the session, therefore &lt;em&gt;you will have to transfer them to the new session&lt;/em&gt;.</source>
          <target state="translated">사용자 관리에 인기있는 &lt;a href=&quot;https://rubygems.org/gems/devise&quot;&gt;Devise&lt;/a&gt; gem을 사용하는 경우 로그인시 자동으로 세션이 만료되고 로그 아웃됩니다. 직접 롤백하는 경우 로그인 동작 후 (세션이 생성 될 때) 세션을 만료해야합니다. 세션에서 값이 제거되므로 &lt;em&gt;새 세션으로&lt;/em&gt; 값 &lt;em&gt;을 전송해야합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="b260b5b45736153fb5e856c84240bdfdc7061b3c" translate="yes" xml:space="preserve">
          <source>If you used the scaffold generator, a system test skeleton was automatically created for you. If you didn't use the scaffold generator, start by creating a system test skeleton.</source>
          <target state="translated">스캐 폴드 생성기를 사용한 경우 시스템 테스트 스켈레톤이 자동으로 생성됩니다. 스캐 폴드 생성기를 사용하지 않은 경우 먼저 시스템 테스트 스켈레톤을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="8186ba98e8144b29de8b3fe8b6e0a06a9a6ed8eb" translate="yes" xml:space="preserve">
          <source>If you validate the absence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;present?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 관계 를 통해 연결된 개체 가 없는지 확인하면 개체가 없는지 확인 &lt;code&gt;present?&lt;/code&gt; 도 &lt;code&gt;marked_for_destruction?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f7fa8dd05040adec975ca62bfc25061e785c7df" translate="yes" xml:space="preserve">
          <source>If you validate the presence of an object associated via a &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;has_many&lt;/code&gt; relationship, it will check that the object is neither &lt;code&gt;blank?&lt;/code&gt; nor &lt;code&gt;marked_for_destruction?&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;has_many&lt;/code&gt; 관계 를 통해 연결된 개체의 존재를 확인하면 개체가 &lt;code&gt;blank?&lt;/code&gt; 있지 않은지 확인합니다 . 도 &lt;code&gt;marked_for_destruction?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2954c6695d5cbeae327cfd082ce1df3d864274cd" translate="yes" xml:space="preserve">
          <source>If you want Active Record to not output anything, then running &lt;code&gt;bin/rails db:migrate
VERBOSE=false&lt;/code&gt; will suppress all output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8675fa9dbdfda79f0d9e088a9370acf6f7785f3" translate="yes" xml:space="preserve">
          <source>If you want Active Record to not output anything, then running &lt;code&gt;rails db:migrate
VERBOSE=false&lt;/code&gt; will suppress all output.</source>
          <target state="translated">Active Record가 아무 것도 출력하지 않게하려면 &lt;code&gt;rails db:migrate VERBOSE=false&lt;/code&gt; 를 실행 하면 모든 출력이 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="3cc1cd91b1a0194f16983d03fb3c4f3d4e1f13ba" translate="yes" xml:space="preserve">
          <source>If you want a flash value to be carried over to another request, use &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Flash/FlashHash.html#method-i-keep&quot;&gt;&lt;code&gt;flash.keep&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f8328e4e201b7e1606e4bfef13b41ffeba2bde1" translate="yes" xml:space="preserve">
          <source>If you want a flash value to be carried over to another request, use the &lt;code&gt;keep&lt;/code&gt; method:</source>
          <target state="translated">플래시 값을 다른 요청으로 전달하려면 &lt;code&gt;keep&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="630fe8293b9d46b8c896fddf7673500c6efe7a60" translate="yes" xml:space="preserve">
          <source>If you want a gem to behave as an engine, you have to specify an &lt;code&gt;Engine&lt;/code&gt; for it somewhere inside your plugin's &lt;code&gt;lib&lt;/code&gt; folder (similar to how we specify a &lt;code&gt;Railtie&lt;/code&gt;):</source>
          <target state="translated">gem이 엔진처럼 동작하게하려면 플러그인의 &lt;code&gt;lib&lt;/code&gt; 폴더 안에 &lt;code&gt;Engine&lt;/code&gt; 을 지정해야합니다 ( &lt;code&gt;Railtie&lt;/code&gt; 지정 방법과 유사 ).</target>
        </trans-unit>
        <trans-unit id="aee38d59683e989a0bb0adbb29c2bd0c92f4d9ee" translate="yes" xml:space="preserve">
          <source>If you want an exception to be raised when some key is blank, use the bang version:</source>
          <target state="translated">일부 키가 비어있을 때 예외를 발생 시키려면 bang 버전을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="dbf8c6d44dfeb825fa9c702cea0d83c2ebda87b4" translate="yes" xml:space="preserve">
          <source>If you want an exception to be raised when some key is blank, you can use the bang version:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e3876b177bb4a765333ca5c28aca58d164c1eb" translate="yes" xml:space="preserve">
          <source>If you want just MIME type, please use &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; instead.</source>
          <target state="translated">MIME 유형 만 원하면 &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bb3098cfa60a9c82bb0ddbba7d231dfc9ab145cc" translate="yes" xml:space="preserve">
          <source>If you want just the MIME type, please use &lt;code&gt;ActionDispatch::Response#media_type&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="730767bfa8f160596399009706fb4cf9a0a1f899" translate="yes" xml:space="preserve">
          <source>If you want more control on what queue a job will be run you can pass a &lt;code&gt;:queue&lt;/code&gt; option to &lt;code&gt;#set&lt;/code&gt;:</source>
          <target state="translated">작업이 실행될 큐를 더 제어하려면 &lt;code&gt;:queue&lt;/code&gt; 옵션을 &lt;code&gt;#set&lt;/code&gt; 에 전달하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="6ba1356141100b15e0f340107d393a37fa30cbd7" translate="yes" xml:space="preserve">
          <source>If you want more control on what queue a job will be run you can pass a &lt;code&gt;:queue&lt;/code&gt; option to &lt;code&gt;set&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdfd062178bdf53433d9b2b0b20c92f631bd29ca" translate="yes" xml:space="preserve">
          <source>If you want more flexibility you can also pass a block and render specific templates or even render inline or text without using a template file:</source>
          <target state="translated">유연성을 높이려면 블록을 전달하고 템플릿을 사용하지 않고 특정 템플릿을 렌더링하거나 인라인 또는 텍스트를 렌더링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb075b036e1a4a68f429c4ff5cc6a6fc5e17d254" translate="yes" xml:space="preserve">
          <source>If you want to add check constraints like in the examples above, you will have to use &lt;code&gt;structure.sql&lt;/code&gt; as dump method. See &lt;a href=&quot;#schema-dumping-and-you&quot;&gt;Schema Dumping and You&lt;/a&gt;.</source>
          <target state="translated">위의 예제와 같이 검사 제한 조건을 추가하려면 &lt;code&gt;structure.sql&lt;/code&gt; 을 덤프 메소드 로 사용해야 합니다. &lt;a href=&quot;#schema-dumping-and-you&quot;&gt;스키마 덤프 및 사용자를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6819ae67fca06a336a7c220cddca705251c5bd7" translate="yes" xml:space="preserve">
          <source>If you want to add string conditions to your included models, you'll have to explicitly reference them. For example:</source>
          <target state="translated">포함 된 모델에 문자열 조건을 추가하려면 명시 적으로 참조해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcdf79631da776965ca916863b0814010876d14b" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">오브젝트를 저장하지 않고 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관에 오브젝트를 지정 하려면 &lt;code&gt;collection.build&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="049e99eb928b4643b8ed72ec399f9776d18df912" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_many&lt;/code&gt; association without saving the object, use the &lt;code&gt;collection.build&lt;/code&gt; method.</source>
          <target state="translated">객체를 저장하지 않고 &lt;code&gt;has_many&lt;/code&gt; 연관에 객체를 지정 하려면 &lt;code&gt;collection.build&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="881b0e238763be506a07bc64b13764f8fc1d30bc" translate="yes" xml:space="preserve">
          <source>If you want to assign an object to a &lt;code&gt;has_one&lt;/code&gt; association without saving the object, use the &lt;code&gt;build_association&lt;/code&gt; method.</source>
          <target state="translated">오브젝트를 저장하지 않고 &lt;code&gt;has_one&lt;/code&gt; 연관에 오브젝트를 지정 하려면 &lt;code&gt;build_association&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="54e4507250cc520d9ef9f615ef6bd7149e330d17" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is absent, you'll need to test whether the associated object itself is absent, and not the foreign key used to map the association.</source>
          <target state="translated">연결이 없는지 확인하려면 연결을 매핑하는 데 사용되는 외래 키가 아니라 관련 개체 자체가 없는지 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e06a09ea7f3496b2601d56d74f968ca41431796" translate="yes" xml:space="preserve">
          <source>If you want to be sure that an association is present, you'll need to test whether the associated object itself is present, and not the foreign key used to map the association. This way, it is not only checked that the foreign key is not empty but also that the referenced object exists.</source>
          <target state="translated">연관이 있는지 확인하려면 연관을 맵핑하는 데 사용되는 외래 키가 아니라 연관된 오브젝트 자체가 존재하는지 테스트해야합니다. 이런 식으로 외래 키가 비어 있지 않은지뿐만 아니라 참조 된 개체가 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="81e027a9e050661dd1bbf2862087d403e8986023" translate="yes" xml:space="preserve">
          <source>If you want to cache a fragment under certain conditions, you can use &lt;code&gt;cache_if&lt;/code&gt; or &lt;code&gt;cache_unless&lt;/code&gt;:</source>
          <target state="translated">특정 조건에서 조각을 캐시하려면 &lt;code&gt;cache_if&lt;/code&gt; 또는 &lt;code&gt;cache_unless&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="882fdac760d8377266eb2e86f1a03a0b05fa12fe" translate="yes" xml:space="preserve">
          <source>If you want to call &lt;code&gt;order&lt;/code&gt; multiple times, subsequent orders will be appended to the first:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 여러 번 호출 하려면 후속 주문이 첫 번째 주문에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="01478e680e0a3de06aa15384b8c62b6f3e1b9a4d" translate="yes" xml:space="preserve">
          <source>If you want to change the default settings you can change what the system tests are &quot;driven by&quot;. Say you want to change the driver from Selenium to Poltergeist. First add the &lt;code&gt;poltergeist&lt;/code&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;. Then in your &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file do the following:</source>
          <target state="translated">기본 설정을 변경하려는 경우 시스템 테스트를 &quot;구동&quot;하는 내용을 변경할 수 있습니다. 드라이버를 Selenium에서 Poltergeist로 변경한다고 가정하십시오. 먼저 추가 &lt;code&gt;poltergeist&lt;/code&gt; 당신에 보석을 &lt;code&gt;Gemfile&lt;/code&gt; . 그런 다음 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="1a59e99c19298d422cfa70889720f3bf19f4b4d9" translate="yes" xml:space="preserve">
          <source>If you want to clear &lt;code&gt;public/assets&lt;/code&gt; completely, you can use &lt;code&gt;bin/rails assets:clobber&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f61e2bb61d59bbfaa9068fd515324935d10137ae" translate="yes" xml:space="preserve">
          <source>If you want to clear &lt;code&gt;public/assets&lt;/code&gt; completely, you can use &lt;code&gt;rails assets:clobber&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;public/assets&lt;/code&gt; 완전히 지우려면 &lt;code&gt;rails assets:clobber&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="84dce1db9910af536d37104449772f92e11bc938" translate="yes" xml:space="preserve">
          <source>If you want to define the singular form of a resource, you should add additional rules to the &lt;code&gt;Inflector&lt;/code&gt;:</source>
          <target state="translated">단일 형식의 리소스를 정의하려면 &lt;code&gt;Inflector&lt;/code&gt; 에 규칙을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d60b834048a06a8aac5fcc39e4ca479462715455" translate="yes" xml:space="preserve">
          <source>If you want to destroy any of the associated models through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">양식을 통해 관련 모델 중 하나를 파괴하려는 경우 사용 먼저 활성화해야 &lt;code&gt;:allow_destroy&lt;/code&gt; 대한 옵션을 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8cf4512ea7b0117056f5d1547f834737b34adbc7" translate="yes" xml:space="preserve">
          <source>If you want to destroy the associated model through the form, you have to enable it first using the &lt;code&gt;:allow_destroy&lt;/code&gt; option for &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;:</source>
          <target state="translated">당신이 양식을 통해 관련 모델을 파괴하려는 경우 사용 먼저 활성화해야 &lt;code&gt;:allow_destroy&lt;/code&gt; 대한 옵션을 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ffb3f3dbf442bca04532c3a1fda2be7e3a29fd1b" translate="yes" xml:space="preserve">
          <source>If you want to disable Turbolinks for certain links, add a &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; attribute to the tag:</source>
          <target state="translated">특정 링크에 대해 터보 링크를 비활성화 하려면 태그에 &lt;code&gt;data-turbolinks=&quot;false&quot;&lt;/code&gt; 속성을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1b888393b095eb8be9cc49c8e192d63811a4e144" translate="yes" xml:space="preserve">
          <source>If you want to disable color in console, do:</source>
          <target state="translated">콘솔에서 색상을 비활성화하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="daed5f8ad05b12715bab3987fdd0bdbf05e8301e" translate="yes" xml:space="preserve">
          <source>If you want to do something a bit more elaborate when catching errors, you can use &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveSupport/Rescuable/ClassMethods.html#method-i-rescue_from&quot;&gt;&lt;code&gt;rescue_from&lt;/code&gt;&lt;/a&gt;, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e30d33a09c87d83b4cb462987de309752d63489a" translate="yes" xml:space="preserve">
          <source>If you want to do something a bit more elaborate when catching errors, you can use &lt;code&gt;rescue_from&lt;/code&gt;, which handles exceptions of a certain type (or multiple types) in an entire controller and its subclasses.</source>
          <target state="translated">오류를 잡을 때 좀 더 정교하게 작업 하려면 전체 컨트롤러와 하위 클래스에서 특정 유형 (또는 여러 유형)의 예외를 처리 하는 &lt;code&gt;rescue_from&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f99dcc32a45b0fa7d053afb4e497a96c3441d664" translate="yes" xml:space="preserve">
          <source>If you want to ensure that the association it is both present and valid, you also need to use &lt;code&gt;validates_associated&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04738d106004ad91f50efe35fd9254c2801b9859" translate="yes" xml:space="preserve">
          <source>If you want to ensure your destination root is clean before running each test, you can set a setup callback:</source>
          <target state="translated">각 테스트를 실행하기 전에 대상 루트가 깨끗한 지 확인하려면 설정 콜백을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be69844258d0f1e61429e02bacd7a81a4960bfad" translate="yes" xml:space="preserve">
          <source>If you want to escape all content, you should invoke the &lt;code&gt;h&lt;/code&gt; method before calling the text helper.</source>
          <target state="translated">모든 내용을 이스케이프 하려면 텍스트 도우미를 호출하기 전에 &lt;code&gt;h&lt;/code&gt; 메서드를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="9046fa26c6e62782a0a60039d77ec14dd6dd2b1e" translate="yes" xml:space="preserve">
          <source>If you want to explicitly render only certain templates, pass a block:</source>
          <target state="translated">특정 템플릿 만 명시 적으로 렌더링하려면 블록을 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="9095618f3a017358eb1838ae59d25212c838a84b" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to GET, use &lt;code&gt;get&lt;/code&gt; in the router:</source>
          <target state="translated">조치를 GET에 노출 하려면 라우터에서 &lt;code&gt;get&lt;/code&gt; 을 사용 하십시오.</target>
        </trans-unit>
        <trans-unit id="7506b1f3128dfe856087aae91f14a7cef70e262d" translate="yes" xml:space="preserve">
          <source>If you want to expose your action to both GET and POST, use:</source>
          <target state="translated">GET 및 POST 모두에 조치를 노출하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a27c0e7867f5a94de794e1d101f421feff8554b4" translate="yes" xml:space="preserve">
          <source>If you want to find both by &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;orders_count&lt;/code&gt;, you can chain these finders together by simply typing &quot;&lt;code&gt;and&lt;/code&gt;&quot; between the fields. For example, &lt;code&gt;Customer.find_by_first_name_and_orders_count(&quot;Ryan&quot;, 5)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f99a973d61a2033c930918ae7de48be26737ec4" translate="yes" xml:space="preserve">
          <source>If you want to find both by name and locked, you can chain these finders together by simply typing &quot;&lt;code&gt;and&lt;/code&gt;&quot; between the fields. For example, &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt;.</source>
          <target state="translated">이름과 잠금으로 모두 찾으려면 필드 사이에 &quot; &lt;code&gt;and&lt;/code&gt; &quot; 를 입력하여 이러한 파인더를 함께 연결할 수 있습니다. 예를 들어, &lt;code&gt;Client.find_by_first_name_and_locked(&quot;Ryan&quot;, true)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="79e1f98e54f296f2c7e4ea42e01c1fc27040270b" translate="yes" xml:space="preserve">
          <source>If you want to find records using the &lt;code&gt;IN&lt;/code&gt; expression you can pass an array to the conditions hash:</source>
          <target state="translated">&lt;code&gt;IN&lt;/code&gt; 표현식을 사용하여 레코드를 찾으려면 조건 해시에 배열을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe116dd165425bdc3931a3e6b5689e2b4656901a" translate="yes" xml:space="preserve">
          <source>If you want to find the maximum value of a field in your table you can call the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-maximum&quot;&gt;&lt;code&gt;maximum&lt;/code&gt;&lt;/a&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64fa85f08ba7bf321366b6270e9b87b779facc87" translate="yes" xml:space="preserve">
          <source>If you want to find the maximum value of a field in your table you can call the &lt;code&gt;maximum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블에서 필드의 최대 값을 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;maximum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7343d47a6c2ec4585440926fbe9164339f4c0666" translate="yes" xml:space="preserve">
          <source>If you want to find the minimum value of a field in your table you can call the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-minimum&quot;&gt;&lt;code&gt;minimum&lt;/code&gt;&lt;/a&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28c3fda57f94de181be4b5408c0b0847936dab74" translate="yes" xml:space="preserve">
          <source>If you want to find the minimum value of a field in your table you can call the &lt;code&gt;minimum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블에서 필드의 최소값을 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;minimum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="35acdf379b8d1ae4fc99290bd973f67d71f02b00" translate="yes" xml:space="preserve">
          <source>If you want to find the sum of a field for all records in your table you can call the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b488c2a178c88deaa3c422faf6e87ada4f5cdea2" translate="yes" xml:space="preserve">
          <source>If you want to find the sum of a field for all records in your table you can call the &lt;code&gt;sum&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블의 모든 레코드에 대한 필드 합계를 찾으려면 테이블 과 관련된 클래스 에서 &lt;code&gt;sum&lt;/code&gt; 메소드를 호출 할 수 있습니다 . 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afcf2558505ba1fa6f04ecc0d3ef9a8e4515680d" translate="yes" xml:space="preserve">
          <source>If you want to follow along while browsing the Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;source code&lt;/a&gt;, we recommend that you use the &lt;code&gt;t&lt;/code&gt; key binding to open the file finder inside GitHub and find files quickly.</source>
          <target state="translated">Rails &lt;a href=&quot;https://github.com/rails/rails&quot;&gt;소스 코드&lt;/a&gt; 를 탐색하는 동안 따라 가려면 &lt;code&gt;t&lt;/code&gt; 키 바인딩을 사용하여 GitHub에서 파일 찾기를 열고 파일을 빨리 찾는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="4b81c7f5d1059063f5ff1e607628d7b3a231038b" translate="yes" xml:space="preserve">
          <source>If you want to include all of the engine's helpers, you can use the helper method on an engine's instance:</source>
          <target state="translated">엔진의 모든 헬퍼를 포함 시키려면 엔진 인스턴스에서 헬퍼 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4367fc68e01e7cac642cd5f8e973aeffedafdc2c" translate="yes" xml:space="preserve">
          <source>If you want to keep that structure, you'll need to delete the subdirectory from the autoload paths in an initializer:</source>
          <target state="translated">해당 구조를 유지하려면 이니셜 라이저의 자동로드 경로에서 하위 디렉토리를 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="833aa975863b9d65c76d04ff5db68bd93b0c3dd1" translate="yes" xml:space="preserve">
          <source>If you want to link to an action in the same controller, you don't need to specify the &lt;code&gt;:controller&lt;/code&gt; option, as Rails will use the current controller by default.</source>
          <target state="translated">Rails가 기본적으로 현재 컨트롤러를 사용하기 때문에 동일한 컨트롤러에서 액션에 연결하려면 &lt;code&gt;:controller&lt;/code&gt; 옵션 을 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="9ae5a18bce4081d8e4bce6b79dad0a6271339c34" translate="yes" xml:space="preserve">
          <source>If you want to load all posts (including posts with no approved comments), then write your own &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; query using &lt;code&gt;ON&lt;/code&gt;:</source>
          <target state="translated">승인 된 주석이없는 게시물을 포함하여 모든 게시물을로드하려면 &lt;code&gt;ON&lt;/code&gt; 을 사용하여 자신의 &lt;code&gt;LEFT OUTER JOIN&lt;/code&gt; 쿼리를 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="c7608a97b4cc8fee46c8ddb8e25f6f759d653e29" translate="yes" xml:space="preserve">
          <source>If you want to make sure that, upon insertion, all of the records in the persisted association are distinct (so that you can be sure that when you inspect the association that you will never find duplicate records), you should add a unique index on the table itself. For example, if you have a table named &lt;code&gt;readings&lt;/code&gt; and you want to make sure the articles can only be added to a person once, you could add the following in a migration:</source>
          <target state="translated">삽입시 지속되는 연관의 모든 레코드가 고유한지 확인하려면 (연결을 검사 할 때 중복 레코드를 찾을 수 없음을 확인할 수 있도록) 고유 색인을 추가해야합니다. 테이블 자체. 예를 들어 &lt;code&gt;readings&lt;/code&gt; 라는 이름의 테이블이 있고 기사를 한 사람에게 한 번만 추가 할 수있게하려면 마이그레이션에서 다음을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87d7a136709e327488aa669dc1033c97f1e78efb" translate="yes" xml:space="preserve">
          <source>If you want to make the format segment mandatory, so it cannot be omitted, you can supply &lt;code&gt;format: true&lt;/code&gt; like this:</source>
          <target state="translated">형식 세그먼트를 필수로 만들려면 생략 할 수 없으므로 &lt;code&gt;format: true&lt;/code&gt; 을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="eace44e3c9e484f7bc6452f6b288b750cf233233" translate="yes" xml:space="preserve">
          <source>If you want to override the singular form of a resource, you should add additional rules to the inflector via &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveSupport/Inflector.html#method-i-inflections&quot;&gt;&lt;code&gt;inflections&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="202741924d3793a6f39f70128849a1f76eb67a92" translate="yes" xml:space="preserve">
          <source>If you want to perform interpolation on a bulk hash of translations, you need to pass &lt;code&gt;deep_interpolation: true&lt;/code&gt; as a parameter. When you have the following dictionary:</source>
          <target state="translated">번역의 대량 해시에서 보간을 수행하려면 &lt;code&gt;deep_interpolation: true&lt;/code&gt; 를 매개 변수로 전달해야합니다 . 다음 사전이있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b898a526db032ac4b4c17d10ed6b687f6f7a6dcf" translate="yes" xml:space="preserve">
          <source>If you want to provide text formatting other than HTML (due to security), use a mark-up language which is converted to HTML on the server-side. &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; is such a language for Ruby, but without precautions, it is also vulnerable to XSS.</source>
          <target state="translated">보안으로 인해 HTML 이외의 텍스트 서식을 제공하려면 서버 측에서 HTML로 변환되는 마크 업 언어를 사용하십시오. &lt;a href=&quot;http://redcloth.org/&quot;&gt;RedCloth&lt;/a&gt; 는 Ruby의 언어이지만 예방책이 없으면 XSS에도 취약합니다.</target>
        </trans-unit>
        <trans-unit id="0de6137e22655510821e761cfb4e32162cdf37b1" translate="yes" xml:space="preserve">
          <source>If you want to remove session related middleware, do the following:</source>
          <target state="translated">세션 관련 미들웨어를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="437988df35a90760193f1e50466ecd5f8d0cf358" translate="yes" xml:space="preserve">
          <source>If you want to render the view that corresponds to a different template within the same controller, you can use &lt;code&gt;render&lt;/code&gt; with the name of the view:</source>
          <target state="translated">동일한 컨트롤러 내에서 다른 템플릿에 해당하는 뷰를 렌더링하려면 뷰 이름과 함께 &lt;code&gt;render&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="678518a594c94e4ba524c6e692f3d1358ce5f917" translate="yes" xml:space="preserve">
          <source>If you want to replace any header which already exists, first set it to &lt;code&gt;nil&lt;/code&gt; in order to reset the value otherwise another field will be added for the same header.</source>
          <target state="translated">이미 존재하는 헤더를 바꾸려면 먼저 값을 재설정하기 위해 헤더를 &lt;code&gt;nil&lt;/code&gt; 로 설정하십시오. 그렇지 않으면 동일한 헤더에 다른 필드가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5a89ab8db551e352e42182a2cfd9536e4a45123d" translate="yes" xml:space="preserve">
          <source>If you want to route /admin/posts to &lt;code&gt;PostsController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use</source>
          <target state="translated">/ admin / posts를 &lt;code&gt;PostsController&lt;/code&gt; 로 라우팅 하려면 ( &lt;code&gt;Admin::&lt;/code&gt; 모듈 접두어 없음)</target>
        </trans-unit>
        <trans-unit id="71e1116ab58411d02bb9b2741fbbff3dea0caf12" translate="yes" xml:space="preserve">
          <source>If you want to route /posts (without the prefix /admin) to &lt;code&gt;Admin::PostsController&lt;/code&gt;, you could use</source>
          <target state="translated">접두어 / admin없이 / posts를 &lt;code&gt;Admin::PostsController&lt;/code&gt; 하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c22991ae1709bb07298a0afe1f2a901f31ffa538" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/admin/articles&lt;/code&gt; to &lt;code&gt;ArticlesController&lt;/code&gt; (without the &lt;code&gt;Admin::&lt;/code&gt; module prefix), you could use:</source>
          <target state="translated">&lt;code&gt;/admin/articles&lt;/code&gt; 를 &lt;code&gt;ArticlesController&lt;/code&gt; 로 라우팅 하려면 ( &lt;code&gt;Admin::&lt;/code&gt; 모듈 접두어 없음) 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0d8526c069daa42c1a84666facdfaead9045910" translate="yes" xml:space="preserve">
          <source>If you want to route &lt;code&gt;/articles&lt;/code&gt; (without the prefix &lt;code&gt;/admin&lt;/code&gt;) to &lt;code&gt;Admin::ArticlesController&lt;/code&gt;, you could use:</source>
          <target state="translated">접두어 &lt;code&gt;/admin&lt;/code&gt; 없이 &lt;code&gt;/articles&lt;/code&gt; 를 &lt;code&gt;Admin::ArticlesController&lt;/code&gt; 로 라우팅 하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a23182d8fff39aabae6eb6b0d95e07349aebd04" translate="yes" xml:space="preserve">
          <source>If you want to see how many records are in your model's table you could call &lt;code&gt;Client.count&lt;/code&gt; and that will return the number. If you want to be more specific and find all the clients with their age present in the database you can use &lt;code&gt;Client.count(:age)&lt;/code&gt;.</source>
          <target state="translated">모델 테이블에 몇 개의 레코드가 있는지 보려면 &lt;code&gt;Client.count&lt;/code&gt; 를 호출 하면 숫자가 반환됩니다. 더 구체적이고 데이터베이스에 연령이있는 모든 클라이언트를 찾으려면 &lt;code&gt;Client.count(:age)&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b70f9f7465854c77b8d4f4be44560a52b4770205" translate="yes" xml:space="preserve">
          <source>If you want to see how many records are in your model's table you could call &lt;code&gt;Customer.count&lt;/code&gt; and that will return the number. If you want to be more specific and find all the customers with a title present in the database you can use &lt;code&gt;Customer.count(:title)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e82c5e43d22756279d4ed3db5e354e49d83547f" translate="yes" xml:space="preserve">
          <source>If you want to see the average of a certain number in one of your tables you can call the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Calculations.html#method-i-average&quot;&gt;&lt;code&gt;average&lt;/code&gt;&lt;/a&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c82af370bdb1006cbe834871485c7f1ca878b194" translate="yes" xml:space="preserve">
          <source>If you want to see the average of a certain number in one of your tables you can call the &lt;code&gt;average&lt;/code&gt; method on the class that relates to the table. This method call will look something like this:</source>
          <target state="translated">테이블 중 하나에서 특정 숫자의 평균을 보려면 테이블 과 관련된 클래스 의 &lt;code&gt;average&lt;/code&gt; 메서드를 호출하면 됩니다. 이 메소드 호출은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b0feb29eaac36cd5373da76d96fb33a59b720fd" translate="yes" xml:space="preserve">
          <source>If you want to see the exact results of a call to &lt;code&gt;render&lt;/code&gt; without needing to inspect it in a browser, you can call &lt;code&gt;render_to_string&lt;/code&gt;. This method takes exactly the same options as &lt;code&gt;render&lt;/code&gt;, but it returns a string instead of sending a response back to the browser.</source>
          <target state="translated">브라우저에서 검사 할 필요없이 &lt;code&gt;render&lt;/code&gt; 하기위한 정확한 호출 결과를 보려면 &lt;code&gt;render_to_string&lt;/code&gt; 을 호출 할 수 있습니다 . 이 메소드는 &lt;code&gt;render&lt;/code&gt; 와 정확히 동일한 옵션을 사용 하지만 응답을 브라우저로 다시 보내는 대신 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a7297e8d7becaad7e5bce534978dae19770718a3" translate="yes" xml:space="preserve">
          <source>If you want to select a set of records whether or not they have associated records you can use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-left_outer_joins&quot;&gt;&lt;code&gt;left_outer_joins&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb3bcca1fe2eb16c2e4bafbe58abd6079508f7d4" translate="yes" xml:space="preserve">
          <source>If you want to select a set of records whether or not they have associated records you can use the &lt;code&gt;left_outer_joins&lt;/code&gt; method.</source>
          <target state="translated">연관된 레코드가 있는지 여부에 관계없이 레코드 세트를 선택하려는 경우 &lt;code&gt;left_outer_joins&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd867d338e486f51b7e048f7dbfe4bba0ff8db95" translate="yes" xml:space="preserve">
          <source>If you want to send a file that already exists on disk, use the &lt;code&gt;send_file&lt;/code&gt; method.</source>
          <target state="translated">디스크에 이미 존재하는 파일을 보내려면 &lt;code&gt;send_file&lt;/code&gt; 메소드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fa8614479ca836359c8d9b53a1ceb07120d48fe5" translate="yes" xml:space="preserve">
          <source>If you want to send emails right away (from a cronjob for example) just call &lt;code&gt;deliver_now&lt;/code&gt;:</source>
          <target state="translated">예를 들어 cronjob에서 이메일을 바로 보내려면 &lt;code&gt;deliver_now&lt;/code&gt; 로 전화 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b7e40e2a1ad7f940f357a14d957ba15d7fb75371" translate="yes" xml:space="preserve">
          <source>If you want to serve only some assets from your CDN, you can use custom &lt;code&gt;:host&lt;/code&gt; option your asset helper, which overwrites value set in &lt;code&gt;config.action_controller.asset_host&lt;/code&gt;.</source>
          <target state="translated">CDN에서 일부 자산 만 제공하려면 자산 도우미 인 custom &lt;code&gt;:host&lt;/code&gt; 옵션을 사용하면 &lt;code&gt;config.action_controller.asset_host&lt;/code&gt; 에 설정된 값을 덮어 씁니다 .</target>
        </trans-unit>
        <trans-unit id="86a051be540d60a884f81305aac005b33816a13e" translate="yes" xml:space="preserve">
          <source>If you want to set custom headers for a response then &lt;code&gt;response.headers&lt;/code&gt; is the place to do it. The headers attribute is a hash which maps header names to their values, and Rails will set some of them automatically. If you want to add or change a header, just assign it to &lt;code&gt;response.headers&lt;/code&gt; this way:</source>
          <target state="translated">당신이 응답을 설정 사용자 지정 헤더를 원하는 경우 &lt;code&gt;response.headers&lt;/code&gt; 은 그것을 할 수있는 곳입니다. headers 속성은 헤더 이름을 해당 값에 매핑하는 해시이며 Rails는 그 중 일부를 자동으로 설정합니다. 헤더를 추가하거나 변경하려면 다음과 같이 &lt;code&gt;response.headers&lt;/code&gt; 에 할당하십시오 .</target>
        </trans-unit>
        <trans-unit id="099225027f13bd8921cfcbe297f75a2b5bfbff8e" translate="yes" xml:space="preserve">
          <source>If you want to set far future &lt;code&gt;max-age&lt;/code&gt; in your &lt;code&gt;Cache-Control&lt;/code&gt; (and you do), then make sure when you change your assets that your cache is invalidated. For example when changing the smiley face in an image from yellow to blue, you want all visitors of your site to get the new blue face. When using a CDN with the Rails asset pipeline &lt;code&gt;config.assets.digest&lt;/code&gt; is set to true by default so that each asset will have a different file name when it is changed. This way you don't have to ever manually invalidate any items in your cache. By using a different unique asset name instead, your users get the latest asset.</source>
          <target state="translated">&lt;code&gt;Cache-Control&lt;/code&gt; 에서 미래의 &lt;code&gt;max-age&lt;/code&gt; 을 설정 하려면 자산을 변경할 때 캐시가 무효화되었는지 확인하십시오. 예를 들어 이미지에서 웃는 얼굴을 노란색에서 파란색으로 변경할 때 사이트의 모든 방문자가 새 파란 얼굴을 갖기를 원합니다. Rails 자산 파이프 라인과 함께 CDN을 사용하는 경우 각 자산이 변경 될 때 각 파일의 이름이 달라 지도록 기본적으로 &lt;code&gt;config.assets.digest&lt;/code&gt; 가 true로 설정됩니다. 이렇게하면 캐시에있는 항목을 수동으로 무효화 할 필요가 없습니다. 다른 고유 자산 이름을 대신 사용하면 사용자에게 최신 자산이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="3aef9f711923eec46d9db89fdf9587f2d1fc51b2" translate="yes" xml:space="preserve">
          <source>If you want to set up a one-to-one relationship between two models, you'll need to add &lt;code&gt;belongs_to&lt;/code&gt; to one, and &lt;code&gt;has_one&lt;/code&gt; to the other. How do you know which is which?</source>
          <target state="translated">두 모델간에 일대일 관계를 설정하려면 한 모델에 &lt;code&gt;belongs_to&lt;/code&gt; 를 추가 하고 다른 모델에는 &lt;code&gt;has_one&lt;/code&gt; 을 추가해야합니다 . 어느 것이 무엇인지 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="41299ecc49f2b55d12fc783dd8a4bce25cda4533" translate="yes" xml:space="preserve">
          <source>If you want to specify multiple conditions:</source>
          <target state="translated">여러 조건을 지정하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="92432ba849376cfd328bd42af73915abeec976e3" translate="yes" xml:space="preserve">
          <source>If you want to take an existing application and make it an API one, read the following steps.</source>
          <target state="translated">기존 애플리케이션을 가져 와서 API 애플리케이션으로 만들려면 다음 단계를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="426e7b46d2daba4aa620587d8734cf3218fc3ddf" translate="yes" xml:space="preserve">
          <source>If you want to test for mobile sizes on top of testing for desktop, you can create another class that inherits from SystemTestCase and use in your test suite. In this example a file called &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; is created in the &lt;code&gt;/test&lt;/code&gt; directory with the following configuration.</source>
          <target state="translated">데스크탑 테스트 외에 모바일 크기를 테스트하려는 경우 SystemTestCase에서 상속하고 테스트 스위트에서 사용하는 다른 클래스를 작성할 수 있습니다. 이 예제에서 &lt;code&gt;mobile_system_test_case.rb&lt;/code&gt; 라는 파일 은 다음 구성으로 &lt;code&gt;/test&lt;/code&gt; 디렉토리에 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="bb99e9b5714695e3c0d2a4ad4579d004020c4ebf" translate="yes" xml:space="preserve">
          <source>If you want to test the broadcasting made with &lt;code&gt;Channel.broadcast_to&lt;/code&gt;, you shoud use &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; to generate an underlying stream name:</source>
          <target state="translated">&lt;code&gt;Channel.broadcast_to&lt;/code&gt; 로 만든 방송을 테스트 하려면 &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; 를 사용하여 기본 스트림 이름을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="d4e701d54752368aa37f7966f9e0b8b3a1caf9c5" translate="yes" xml:space="preserve">
          <source>If you want to test the broadcasting made with &lt;code&gt;Channel.broadcast_to&lt;/code&gt;, you should use &lt;code&gt;Channel.broadcasting_for&lt;/code&gt; to generate an underlying stream name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ff54b553ef18f239f233ecc554746be0ea932b7" translate="yes" xml:space="preserve">
          <source>If you want to update the current avatar without providing the id, you must add &lt;code&gt;:update_only&lt;/code&gt; option.</source>
          <target state="translated">ID를 제공하지 않고 현재 아바타를 업데이트하려면 &lt;code&gt;:update_only&lt;/code&gt; 옵션을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d7f01918dd89fba4b8c4e6c1531a6a2074a2bdf6" translate="yes" xml:space="preserve">
          <source>If you want to use Spring as your application preloader you need to:</source>
          <target state="translated">Spring을 애플리케이션 프리 로더로 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b965db2407513b5b2b570f23c5d93b00e3101f2d" translate="yes" xml:space="preserve">
          <source>If you want to use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;data URI&lt;/a&gt; - a method of embedding the image data directly into the CSS file - you can use the &lt;code&gt;asset_data_uri&lt;/code&gt; helper.</source>
          <target state="translated">이미지 데이터를 CSS 파일에 직접 포함시키는 방법 인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Data_URI_scheme&quot;&gt;데이터 URI&lt;/a&gt; 를 사용하려는 경우 &lt;code&gt;asset_data_uri&lt;/code&gt; 도우미를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a38b6f313ac095865cc041c45313249a8c891f54" translate="yes" xml:space="preserve">
          <source>If you want to use a headless browser, you could use Headless Chrome or Headless Firefox by adding &lt;code&gt;headless_chrome&lt;/code&gt; or &lt;code&gt;headless_firefox&lt;/code&gt; in the &lt;code&gt;:using&lt;/code&gt; argument.</source>
          <target state="translated">헤드리스 브라우저를 사용 하려면 &lt;code&gt;:using&lt;/code&gt; 인수 에 &lt;code&gt;headless_chrome&lt;/code&gt; 또는 &lt;code&gt;headless_firefox&lt;/code&gt; 를 추가하여 Headless Chrome 또는 Headless Firefox를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8469a734b56d841b8d3b06494a60e3dbb5a95e48" translate="yes" xml:space="preserve">
          <source>If you want to use an inline method, such as a proc, do something like this:</source>
          <target state="translated">proc와 같은 인라인 메소드를 사용하려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="5fa26b8d76c9fedc47af5ee3e2b3adcd7b457e39" translate="yes" xml:space="preserve">
          <source>If you want to use encoding other than Base64 then you will need to pass encoding type along with the pre-encoded content as &lt;code&gt;Mail&lt;/code&gt; doesn't know how to decode the data:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9476b0eea21be4c7ecb97a0e9ba1aba5803590f" translate="yes" xml:space="preserve">
          <source>If you want to use encoding other than Base64 then you will need to pass encoding type along with the pre-encoded content as Mail doesn't know how to decode the data:</source>
          <target state="translated">Base64 이외의 인코딩을 사용하려면 Mail이 데이터를 디코딩하는 방법을 모르기 때문에 미리 인코딩 된 내용과 함께 인코딩 유형을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="83bc651176612167b690b60503d3abc1dba33511" translate="yes" xml:space="preserve">
          <source>If you want to use environment variables, standard SDK configuration files, profiles, IAM instance profiles or task roles, you can omit the &lt;code&gt;access_key_id&lt;/code&gt;, &lt;code&gt;secret_access_key&lt;/code&gt;, and &lt;code&gt;region&lt;/code&gt; keys in the example above. The Amazon S3 Service supports all of the authentication options described in the &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK documentation&lt;/a&gt;.</source>
          <target state="translated">환경 변수, 표준 SDK 구성 파일, 프로파일, IAM 인스턴스 프로파일 또는 작업 역할을 사용하려는 경우 위 예에서 &lt;code&gt;access_key_id&lt;/code&gt; , &lt;code&gt;secret_access_key&lt;/code&gt; 및 &lt;code&gt;region&lt;/code&gt; 키를 생략 할 수 있습니다 . Amazon S3 서비스는 &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK 설명서에&lt;/a&gt; 설명 된 모든 인증 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="15afeaf1c41d990b3fd30dfc9cc276b258825421" translate="yes" xml:space="preserve">
          <source>If you want to use environment variables, standard SDK configuration files, profiles, IAM instance profiles or task roles, you can omit the &lt;code&gt;access_key_id&lt;/code&gt;, &lt;code&gt;secret_access_key&lt;/code&gt;, and &lt;code&gt;region&lt;/code&gt; keys in the example above. The S3 Service supports all of the authentication options described in the &lt;a href=&quot;https://docs.aws.amazon.com/sdk-for-ruby/v3/developer-guide/setup-config.html&quot;&gt;AWS SDK documentation&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78550f6d08d1ff8a685dd59e30382d79dffa8bb2" translate="yes" xml:space="preserve">
          <source>If you want to use multiple Sass files, you should generally use the &lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; rule&lt;/a&gt; instead of these Sprockets directives. When using Sprockets directives, Sass files exist within their own scope, making variables or mixins only available within the document they were defined in.</source>
          <target state="translated">여러 Sass 파일을 사용하려면 일반적으로 이러한 Sprockets 지시문 대신 &lt;a href=&quot;https://sass-lang.com/docs/yardoc/file.SASS_REFERENCE.html#import&quot;&gt;Sass &lt;code&gt;@import&lt;/code&gt; 규칙을&lt;/a&gt; 사용해야합니다 . Sprockets 지시문을 사용할 때 Sass 파일은 자체 범위 내에 존재하므로 정의 된 문서 내에서만 변수 또는 믹스 인을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c94a4e174d42f497da3366d92bc9b0b8bc6401f" translate="yes" xml:space="preserve">
          <source>If you want to use the Direct Upload feature from a JavaScript framework, or you want to integrate custom drag and drop solutions, you can use the &lt;code&gt;DirectUpload&lt;/code&gt; class for this purpose. Upon receiving a file from your library of choice, instantiate a DirectUpload and call its create method. Create takes a callback to invoke when the upload completes.</source>
          <target state="translated">JavaScript 프레임 워크에서 직접 업로드 기능을 사용하거나 사용자 정의 끌어서 놓기 솔루션을 통합하려는 경우 &lt;code&gt;DirectUpload&lt;/code&gt; 클래스를이 목적으로 사용할 수 있습니다 . 선택한 라이브러리에서 파일을 받으면 DirectUpload를 인스턴스화하고 해당 create 메소드를 호출하십시오. 업로드가 완료되면 Create에서 콜백을 호출하여 호출합니다.</target>
        </trans-unit>
        <trans-unit id="0daea374afa45a4f9161d43ce592eeaf4bfcbb83" translate="yes" xml:space="preserve">
          <source>If you want to use the new &lt;code&gt;secrets.yml&lt;/code&gt; convention to store your application's secrets, you need to:</source>
          <target state="translated">새로운 &lt;code&gt;secrets.yml&lt;/code&gt; 규칙을 사용하여 응용 프로그램의 비밀을 저장하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b2f0d4edf0b36ea43e41a3cceafe2919b1796b3" translate="yes" xml:space="preserve">
          <source>If you want to validate that a child record is associated with a parent record, you can use the &lt;code&gt;validates_presence_of&lt;/code&gt; method and the &lt;code&gt;:inverse_of&lt;/code&gt; key as this example illustrates:</source>
          <target state="translated">하위 레코드가 상위 레코드와 연관되어 있는지 유효성 검증하려는 경우, 이 예제에서 설명하는대로 &lt;code&gt;validates_presence_of&lt;/code&gt; 메소드 및 &lt;code&gt;:inverse_of&lt;/code&gt; 키를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="360919c22e7192293a509dac7b1cea6d815c9f8c" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt;), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">부울 필드가 있는지 확인하려면 (실제 값이 &lt;code&gt;true&lt;/code&gt; 및 &lt;code&gt;false&lt;/code&gt; 인 경우 ) &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ea56a09fad8a04faf2bff57737e8a807d3431719" translate="yes" xml:space="preserve">
          <source>If you want to validate the presence of a boolean field (where the real values are true and false), you will want to use &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt;.</source>
          <target state="translated">부울 필드가 있는지 확인하려면 (실제 값이 true 및 false 인 경우) &lt;code&gt;validates_inclusion_of :field_name, in: [true, false]&lt;/code&gt; 을 사용하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="7fa417478846acd30b43d6fde743d8c6ea43060f" translate="yes" xml:space="preserve">
          <source>If you want your mailer to be able to process incoming messages, you'll need to implement a &lt;code&gt;receive&lt;/code&gt; method that accepts the raw email string as a parameter:</source>
          <target state="translated">메일러가 수신 메시지를 처리 ​​할 수있게 하려면 원시 이메일 문자열을 매개 변수로 승인 하는 &lt;code&gt;receive&lt;/code&gt; 메소드 를 구현해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6455c2de3d7a047581e9fcb01755edb3c86f2bbd" translate="yes" xml:space="preserve">
          <source>If you wanted to link to just a magazine:</source>
          <target state="translated">잡지에만 연결하려면 :</target>
        </trans-unit>
        <trans-unit id="80aa2c22d6eb1df175b82bf1820379fab8028400" translate="yes" xml:space="preserve">
          <source>If you were previously loading any of the &lt;code&gt;actioncable&lt;/code&gt;, &lt;code&gt;activestorage&lt;/code&gt;, or &lt;code&gt;rails-ujs&lt;/code&gt; packages through npm/yarn, you must update the names of these dependencies before you can upgrade them to &lt;code&gt;6.0.0&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7776932dfe5e1ba6fe53dedb97b0fcebe5afe5b5" translate="yes" xml:space="preserve">
          <source>If you were to publish your blog online, anyone would be able to add, edit and delete articles or delete comments.</source>
          <target state="translated">블로그를 온라인으로 게시 할 경우 누구나 기사를 추가, 편집 및 삭제할 수 있으며 의견을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="575cb50250b1bf052c4de6c10262311c1b70fb97" translate="yes" xml:space="preserve">
          <source>If you were to use this inside an engine, it would &lt;strong&gt;always&lt;/strong&gt; go to the application's root. If you were to leave off the &lt;code&gt;main_app&lt;/code&gt; &quot;routing proxy&quot; method call, it could potentially go to the engine's or application's root, depending on where it was called from.</source>
          <target state="translated">엔진 내에서 이것을 사용한다면 &lt;strong&gt;항상&lt;/strong&gt; 응용 프로그램의 루트로 이동합니다. &lt;code&gt;main_app&lt;/code&gt; &quot;routing proxy&quot;메소드 호출을 중단해야하는 경우 호출 된 위치에 따라 엔진 또는 애플리케이션의 루트로 이동할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a427f99647eb5e543a3ae1b3a0d916eb1faa0edd" translate="yes" xml:space="preserve">
          <source>If you wish for a migration to do something that Active Record doesn't know how to reverse, you can use &lt;code&gt;reversible&lt;/code&gt;:</source>
          <target state="translated">마이그레이션에서 Active Record가 되돌릴 방법을 모르는 작업을 수행하려는 경우 &lt;code&gt;reversible&lt;/code&gt; 을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1294f3a090948062029c308d3735489561146a22" translate="yes" xml:space="preserve">
          <source>If you wish to assign an object to a &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;&lt;code&gt;has_one&lt;/code&gt;&lt;/a&gt; association without saving it, use the &lt;code&gt;#build_association&lt;/code&gt; method (documented below). The object being replaced will still be saved to update its foreign key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd56c78b0133cc928ce018dc68640e14293ed83" translate="yes" xml:space="preserve">
          <source>If you wish to assign an object to a &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; association without saving it, use the &lt;code&gt;#build_association&lt;/code&gt; method (documented below). The object being replaced will still be saved to update its foreign key.</source>
          <target state="translated">저장하지 않고 &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; 연결에 객체를 할당 하려면 &lt;code&gt;#build_association&lt;/code&gt; 메서드를 사용하십시오 (아래에 설명되어 있음). 교체되는 객체는 외래 키를 업데이트하기 위해 여전히 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a737eea7353d9510092816cd514035cc221c5cdd" translate="yes" xml:space="preserve">
          <source>If you wish to direct your form request to a particular URL, you would use &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; instead. To see more in depth options on what &lt;code&gt;form_with&lt;/code&gt; accepts be sure to &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;check out the API documentation&lt;/a&gt;.</source>
          <target state="translated">양식 요청을 특정 URL로 &lt;code&gt;form_with url: my_nifty_url_path&lt;/code&gt; 대신 form_with url : my_nifty_url_path를 사용하십시오. &lt;code&gt;form_with&lt;/code&gt; 가 받아들이는 것에 대한 더 자세한 옵션을 보려면 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_with&quot;&gt;API 문서&lt;/a&gt; 를 확인 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6402f3e6ee3269544b94ed2afd9f856f4bfe840" translate="yes" xml:space="preserve">
          <source>If you wish to enforce referential integrity at the database level, add the &lt;code&gt;foreign_key: true&lt;/code&gt; option to the &amp;lsquo;reference&amp;rsquo; column declarations above.</source>
          <target state="translated">데이터베이스 레벨에서 참조 무결성을 강제 하려면 위의 'reference'열 선언에 &lt;code&gt;foreign_key: true&lt;/code&gt; 옵션을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="aba5ce0e2d38e3da0ce1fa3f46b615712df3745f" translate="yes" xml:space="preserve">
          <source>If you wish to override the default delivery options (e.g. SMTP credentials) while delivering emails, you can do this using &lt;code&gt;delivery_method_options&lt;/code&gt; in the mailer action.</source>
          <target state="translated">이메일을 전송하는 동안 기본 전송 옵션 (예 : SMTP 신임 정보)을 대체하려는 경우 , 메일러 조치에서 &lt;code&gt;delivery_method_options&lt;/code&gt; 를 사용하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="73db4cc44cef83172126988fcc0374fdc104cea3" translate="yes" xml:space="preserve">
          <source>If you wish to preload the dependent &lt;a href=&quot;richtext&quot;&gt;&lt;code&gt;RichText&lt;/code&gt;&lt;/a&gt; model, you can use the named scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc41a963ec89ff455cd121d6950f47a8727574b" translate="yes" xml:space="preserve">
          <source>If you wish to preload the dependent &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; model, you can use the named scope:</source>
          <target state="translated">종속 &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; 모델 을 사전로드하려는 경우 이름 지정된 범위를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb1522ee64c515deb29423f2f3826f5af6dfceed" translate="yes" xml:space="preserve">
          <source>If you wish to preload the dependent &lt;code&gt;ActionText::RichText&lt;/code&gt; model, assuming your rich text field is named &lt;code&gt;content&lt;/code&gt;, you can use the named scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32d5aaa0eac49f14bbdb07d88277c02905e0a8f3" translate="yes" xml:space="preserve">
          <source>If you wish to reference the application inside the engine in a similar way, use the &lt;code&gt;main_app&lt;/code&gt; helper:</source>
          <target state="translated">비슷한 방식으로 엔진 내부의 응용 프로그램을 참조하려면 &lt;code&gt;main_app&lt;/code&gt; 도우미를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fd695f08aea66e1dfdd7109d7788294f67533eb" translate="yes" xml:space="preserve">
          <source>If you wish to skip some files or components from being generated, you can append the following arguments to your &lt;code&gt;rails new&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e733200282906818655a1aeb77c3effbcc540ff4" translate="yes" xml:space="preserve">
          <source>If you wish to specify disabled option tags, set &lt;code&gt;selected&lt;/code&gt; to be a hash, with &lt;code&gt;:disabled&lt;/code&gt; being either a value or array of values to be disabled. In this case, you can use &lt;code&gt;:selected&lt;/code&gt; to specify selected option tags.</source>
          <target state="translated">당신이 사용할 옵션 태그를 지정하고자하는 경우, 세트 &lt;code&gt;selected&lt;/code&gt; 과 해시로 &lt;code&gt;:disabled&lt;/code&gt; 복지 값이나 값의 배열 비활성화 된 것 중 하나. 이 경우 &lt;code&gt;:selected&lt;/code&gt; 를 사용하여 선택한 옵션 태그를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1883961e42670040cfe5681a132ada93d855a3a7" translate="yes" xml:space="preserve">
          <source>If you wish to specify your own custom joins using &lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;&lt;code&gt;ActiveRecord::QueryMethods#joins&lt;/code&gt;&lt;/a&gt; method, those table names will take precedence over the eager associations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1c9e5119e4d165a495f0f324ad98ec144c7d4d2" translate="yes" xml:space="preserve">
          <source>If you wish to specify your own custom joins using &lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord::QueryMethods#joins&lt;/a&gt; method, those table names will take precedence over the eager associations:</source>
          <target state="translated">&lt;a href=&quot;../querymethods#method-i-joins&quot;&gt;ActiveRecord :: QueryMethods # joins&lt;/a&gt; 메서드 를 사용하여 고유 한 사용자 지정 조인을 지정하려는 경우 해당 테이블 이름이 열성적인 연결보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="7d43afab2b9644ce7058c028f11216ed44e58296" translate="yes" xml:space="preserve">
          <source>If you wish to test out some code without changing any data, you can do that by invoking &lt;code&gt;bin/rails console --sandbox&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81a502737a61e2e278b4a4cb999f6a9c1f6ca22d" translate="yes" xml:space="preserve">
          <source>If you wish to test out some code without changing any data, you can do that by invoking &lt;code&gt;rails console --sandbox&lt;/code&gt;.</source>
          <target state="translated">데이터를 변경하지 않고 일부 코드를 테스트하려면 &lt;code&gt;rails console --sandbox&lt;/code&gt; 를 호출하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55e25e1f3e40c431c5a37b5f3841936bbc4459cd" translate="yes" xml:space="preserve">
          <source>If you wish to use an initializer - code that should run before the engine is loaded - the place for it is the &lt;code&gt;config/initializers&lt;/code&gt; folder. This directory's functionality is explained in the &lt;a href=&quot;configuring#initializers&quot;&gt;Initializers section&lt;/a&gt; of the Configuring guide, and works precisely the same way as the &lt;code&gt;config/initializers&lt;/code&gt; directory inside an application. The same thing goes if you want to use a standard initializer.</source>
          <target state="translated">엔진을로드하기 전에 실행해야하는 이니셜 라이저를 사용하려는 경우 엔진의 위치는 &lt;code&gt;config/initializers&lt;/code&gt; 폴더입니다. 이 디렉토리의 기능은 구성 안내서 의 &lt;a href=&quot;configuring#initializers&quot;&gt;이니셜 라이저 섹션&lt;/a&gt; 에 설명 되어 있으며 응용 프로그램 내의 &lt;code&gt;config/initializers&lt;/code&gt; 디렉토리 와 정확히 동일한 방식으로 작동 합니다. 표준 이니셜 라이저를 사용하려는 경우에도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="c739de938813bf2056a36275c1000bffb09bd3db" translate="yes" xml:space="preserve">
          <source>If you wish, you can manually specify a URL inside of your &lt;code&gt;config/database.yml&lt;/code&gt;</source>
          <target state="translated">원하는 경우 &lt;code&gt;config/database.yml&lt;/code&gt; 내부에 URL을 수동으로 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cc90d44a16c15c685a8b0dbd220cb14b6857e32b" translate="yes" xml:space="preserve">
          <source>If you work in a large application with thousands of routes, a single &lt;code&gt;config/routes.rb&lt;/code&gt; file can become cumbersome and hard to read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c97d373a0e7ea22d66470dc1c030ef33b1bbec4b" translate="yes" xml:space="preserve">
          <source>If you would like to only grab a single record per unique value in a certain field, you can use &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/QueryMethods.html#method-i-distinct&quot;&gt;&lt;code&gt;distinct&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f69437be8ce715e3ad0ef7043ae0bcb2d318c62e" translate="yes" xml:space="preserve">
          <source>If you would like to only grab a single record per unique value in a certain field, you can use &lt;code&gt;distinct&lt;/code&gt;:</source>
          <target state="translated">특정 필드에서 고유 한 값당 단일 레코드 만 가져 오려면 &lt;code&gt;distinct&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed75682776d228d6bff9a8ef48ef887e89b70898" translate="yes" xml:space="preserve">
          <source>If you would like to render a template located outside of the default &lt;code&gt;app/views/mailer_name/&lt;/code&gt; directory, you can apply the &lt;code&gt;prepend_view_path&lt;/code&gt;, like so:</source>
          <target state="translated">기본 &lt;code&gt;app/views/mailer_name/&lt;/code&gt; 디렉토리 외부에있는 템플리트를 렌더링 하려면 다음 과 같이 &lt;code&gt;prepend_view_path&lt;/code&gt; 를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7911382e4c2b67c50379b3d44270b5f5346e6d73" translate="yes" xml:space="preserve">
          <source>If you would like to run migrations only from one engine, you can do it by specifying &lt;code&gt;SCOPE&lt;/code&gt;:</source>
          <target state="translated">하나의 엔진에서만 마이그레이션을 실행하려면 &lt;code&gt;SCOPE&lt;/code&gt; 를 지정하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="790b328e640d82b5da7e75fab70c6282096d3a74" translate="yes" xml:space="preserve">
          <source>If you would prefer missing translations to raise an error, you can opt out of span-wrapping behavior globally by setting &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; or individually by passing &lt;code&gt;raise: true&lt;/code&gt; as an option to &lt;code&gt;translate&lt;/code&gt;.</source>
          <target state="translated">번역이 누락되어 오류가 발생하는 것을 선호하는 경우 &lt;code&gt;ActionView::Base.raise_on_missing_translations = true&lt;/code&gt; 를 설정 하거나 &lt;code&gt;translate&lt;/code&gt; 옵션으로 &lt;code&gt;raise: true&lt;/code&gt; 를 전달 하여 스팬 랩핑 동작을 전체적으로 선택 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="163dd1aa6e91d4f7812597cbffd752f4befdb8ea" translate="yes" xml:space="preserve">
          <source>If you would prefer to have your Rack application receive requests at the root path instead, use &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Base.html#method-i-mount&quot;&gt;&lt;code&gt;mount&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9b08445505f4021362fd6c2de4bd7b9f8fc7ae2" translate="yes" xml:space="preserve">
          <source>If you would prefer to have your Rack application receive requests at the root path instead, use &lt;code&gt;mount&lt;/code&gt;:</source>
          <target state="translated">Rack 응용 프로그램이 대신 루트 경로에서 요청을 받도록하려면 &lt;code&gt;mount&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="609a529e699c85d0968c70e226f8abfff60217a8" translate="yes" xml:space="preserve">
          <source>If you'd like to add an index on the new column, you can do that as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f046f887041093bb4fa70b63dbbb0a559fdea0" translate="yes" xml:space="preserve">
          <source>If you'd like to add an index on the new column, you can do that as well:</source>
          <target state="translated">새 열에 색인을 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2e3f9f8b9bfbcbc17b7a73d37f705ba8c09ceadc" translate="yes" xml:space="preserve">
          <source>If you'd like to add conditions to your find, you could just specify them in there, just like &lt;code&gt;Book.where(&quot;title = 'Introduction to Algorithms'&quot;)&lt;/code&gt;. This will find all books where the &lt;code&gt;title&lt;/code&gt; field value is 'Introduction to Algorithms'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7976c8ec3a7be940920ae427bbf8a122fa920741" translate="yes" xml:space="preserve">
          <source>If you'd like to add conditions to your find, you could just specify them in there, just like &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt;. This will find all clients where the &lt;code&gt;orders_count&lt;/code&gt; field's value is 2.</source>
          <target state="translated">찾기에 조건을 추가하려면 &lt;code&gt;Client.where(&quot;orders_count = '2'&quot;)&lt;/code&gt; 와 같이 조건을 지정하면됩니다 . &lt;code&gt;orders_count&lt;/code&gt; 필드 값이 2 인 모든 클라이언트를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="d19f1f4f9e797b4b1ec650b6359a17ffa7511296" translate="yes" xml:space="preserve">
          <source>If you'd like to delete several records in bulk, you may use &lt;code&gt;destroy_by&lt;/code&gt; or &lt;code&gt;destroy_all&lt;/code&gt; method:</source>
          <target state="translated">여러 레코드를 대량으로 삭제하려면 &lt;code&gt;destroy_by&lt;/code&gt; 또는 &lt;code&gt;destroy_all&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="094da93c96e9c2bdfe4851dfb24e5ff123a7f2b4" translate="yes" xml:space="preserve">
          <source>If you'd like to ensure that communication to your controller is only possible via HTTPS, you should do so by enabling the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/SSL.html&quot;&gt;&lt;code&gt;ActionDispatch::SSL&lt;/code&gt;&lt;/a&gt; middleware via &lt;code&gt;config.force_ssl&lt;/code&gt; in your environment configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e981bfaa7de9368100fa34a45a9739141519f9a" translate="yes" xml:space="preserve">
          <source>If you'd like to ensure that communication to your controller is only possible via HTTPS, you should do so by enabling the &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; middleware via &lt;code&gt;config.force_ssl&lt;/code&gt; in your environment configuration.</source>
          <target state="translated">컨트롤러와의 통신이 HTTPS를 통해서만 가능하도록하려면 환경 구성에서 &lt;code&gt;config.force_ssl&lt;/code&gt; 을 통해 &lt;code&gt;ActionDispatch::SSL&lt;/code&gt; 미들웨어를 활성화해야 합니다.</target>
        </trans-unit>
        <trans-unit id="f1a57ee0ade4cf79a622a368932e1b73a276d9fc" translate="yes" xml:space="preserve">
          <source>If you'd like to use your own SQL to find records in a table you can use &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/Querying.html#method-i-find_by_sql&quot;&gt;&lt;code&gt;find_by_sql&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;find_by_sql&lt;/code&gt; method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bfd2699bc66216d017e05cf9ebcf5a5fc2b1215" translate="yes" xml:space="preserve">
          <source>If you'd like to use your own SQL to find records in a table you can use &lt;code&gt;find_by_sql&lt;/code&gt;. The &lt;code&gt;find_by_sql&lt;/code&gt; method will return an array of objects even if the underlying query returns just a single record. For example you could run this query:</source>
          <target state="translated">고유 한 SQL을 사용하여 테이블에서 레코드를 찾으려면 &lt;code&gt;find_by_sql&lt;/code&gt; 을 사용할 수 있습니다 . &lt;code&gt;find_by_sql&lt;/code&gt; 의 방법도 기본 쿼리가 반환하는 경우 단지 하나의 레코드 객체의 배열을 반환합니다. 예를 들어이 쿼리를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d913a8c49bbd0caa0d0558b5ff8d81df0b5195d4" translate="yes" xml:space="preserve">
          <source>If you'd prefer to use numeric prefixes, you can turn timestamped migrations off by setting:</source>
          <target state="translated">숫자 접두사를 사용하려면 다음을 설정하여 타임 스탬프 마이그레이션을 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30c45e9f8b0ea75206560a6a80a26fb11cca6719" translate="yes" xml:space="preserve">
          <source>If you'd rather play around in the console, &lt;code&gt;bin/rails console&lt;/code&gt; will also work just like a Rails application. Remember: the &lt;code&gt;Article&lt;/code&gt; model is namespaced, so to reference it you must call it as &lt;code&gt;Blorgh::Article&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e07e42c2f306a8f64c34aec429563c444e6909" translate="yes" xml:space="preserve">
          <source>If you'd rather play around in the console, &lt;code&gt;rails console&lt;/code&gt; will also work just like a Rails application. Remember: the &lt;code&gt;Article&lt;/code&gt; model is namespaced, so to reference it you must call it as &lt;code&gt;Blorgh::Article&lt;/code&gt;.</source>
          <target state="translated">콘솔에서 플레이하고 싶다면 Rails &lt;code&gt;rails console&lt;/code&gt; 도 Rails 응용 프로그램처럼 작동합니다. 기억하십시오 : &lt;code&gt;Article&lt;/code&gt; 모델은 네임 스페이스이므로 참조하려면 &lt;code&gt;Blorgh::Article&lt;/code&gt; 이라고해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6532d9f78f750c236c3b6d83a991d12488056704" translate="yes" xml:space="preserve">
          <source>If you're building a Rails application that will be an API server first and foremost, you can start with a more limited subset of Rails and add in features as needed.</source>
          <target state="translated">가장 먼저 API 서버가 될 Rails 애플리케이션을 구축하는 경우 더 제한된 Rails 하위 세트로 시작하여 필요에 따라 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20e3e39f3273389814db32e9d227bc1663081d89" translate="yes" xml:space="preserve">
          <source>If you're defining additional resource routes with a symbol as the first positional argument, be mindful that it is not equivalent to using a string. Symbols infer controller actions while strings infer paths.</source>
          <target state="translated">기호를 첫 번째 위치 인수로 사용하여 추가 리소스 경로를 정의하는 경우 문자열을 사용하는 것과 같지 않습니다. 문자열은 경로를 유추하는 동안 기호는 컨트롤러 동작을 유추합니다.</target>
        </trans-unit>
        <trans-unit id="c858a8636b2b3b43ef9fa37542ac6af20ab4623e" translate="yes" xml:space="preserve">
          <source>If you're familiar with the HTTP protocol, you'll know that &lt;code&gt;get&lt;/code&gt; is a type of request. There are 6 request types supported in Rails functional tests:</source>
          <target state="translated">HTTP 프로토콜에 익숙하다면 &lt;code&gt;get&lt;/code&gt; 이 요청 유형 이라는 것을 알게 될 것입니다 . Rails 기능 테스트에서는 6 가지 요청 유형이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="fc8fe2bd82f04d8f34c233a8938cd887f9fe4b73" translate="yes" xml:space="preserve">
          <source>If you're going to need to use any other methods, you should use &lt;code&gt;reversible&lt;/code&gt; or write the &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; methods instead of using the &lt;code&gt;change&lt;/code&gt; method.</source>
          <target state="translated">다른 방법을 사용해야하는 경우 &lt;code&gt;change&lt;/code&gt; 방법 을 사용하는 대신 &lt;code&gt;reversible&lt;/code&gt; 있거나 &lt;code&gt;up&lt;/code&gt; 및 &lt;code&gt;down&lt;/code&gt; 방법을 작성 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2da9f66c4acf50bc0a779c72300d200c3b9cb2d7" translate="yes" xml:space="preserve">
          <source>If you're going to pass the parameters to an &lt;code&gt;ActiveModel&lt;/code&gt; object (such as &lt;code&gt;User.new(params[:user])&lt;/code&gt;), you might consider passing the model class to the method instead. The &lt;code&gt;ParamsWrapper&lt;/code&gt; will actually try to determine the list of attribute names from the model and only wrap those attributes:</source>
          <target state="translated">매개 변수를 &lt;code&gt;ActiveModel&lt;/code&gt; 객체 (예 : &lt;code&gt;User.new(params[:user])&lt;/code&gt; )에 전달하려는 경우 대신 모델 클래스를 메소드에 전달하는 것을 고려할 수 있습니다. &lt;code&gt;ParamsWrapper&lt;/code&gt; 은 실제로 모델에서 속성 이름의 목록을 확인하고 속성 만 포장하려고합니다 :</target>
        </trans-unit>
        <trans-unit id="096ce5069eb7339a39375acb03a52843c4f452e9" translate="yes" xml:space="preserve">
          <source>If you're not going to be using any of the options like collections or layouts, you can also use the short-hand defaults of render to render partials. Examples:</source>
          <target state="translated">컬렉션이나 레이아웃과 같은 옵션을 사용하지 않을 경우 짧은 기본 렌더링을 사용하여 부분을 렌더링 할 수도 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="c1428a86731299c6d458cfab5f49fba8d9a54cee" translate="yes" xml:space="preserve">
          <source>If you're on MySQL, then do not use Data Definition Language (DDL) operations in nested transactions blocks that are emulated with savepoints. That is, do not execute statements like 'CREATE TABLE' inside such blocks. This is because MySQL automatically releases all savepoints upon executing a DDL operation. When &lt;code&gt;transaction&lt;/code&gt; is finished and tries to release the savepoint it created earlier, a database error will occur because the savepoint has already been automatically released. The following example demonstrates the problem:</source>
          <target state="translated">MySQL을 사용하는 경우 저장 점으로 에뮬레이트 된 중첩 트랜잭션 블록에서 DDL (Data Definition Language) 작업을 사용하지 마십시오. 즉, 이러한 블록 내에서 'CREATE TABLE'과 같은 문을 실행하지 마십시오. MySQL은 DDL 작업을 실행할 때 모든 저장 점을 자동으로 해제하기 때문입니다. 때 &lt;code&gt;transaction&lt;/code&gt; 완료이며 이전에 만든 세이브 포인트를 해제하려고 세이브 포인트가 이미 자동으로 해제되어 있기 때문에, 데이터베이스 오류가 발생합니다. 다음 예제는 문제를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e401cde5d947378c5cb2630d5792af35e1cd426a" translate="yes" xml:space="preserve">
          <source>If you're precompiling your assets (see &lt;a href=&quot;#in-production&quot;&gt;In Production&lt;/a&gt; below), linking to an asset that does not exist will raise an exception in the calling page. This includes linking to a blank string. As such, be careful using &lt;code&gt;image_tag&lt;/code&gt; and the other helpers with user-supplied data.</source>
          <target state="translated">자산을 사전 컴파일하는 경우 ( 아래 &lt;a href=&quot;#in-production&quot;&gt;프로덕션에서&lt;/a&gt; 참조) 존재하지 않는 자산에 연결하면 호출 페이지에서 예외가 발생합니다. 여기에는 빈 문자열에 대한 링크가 포함됩니다. 따라서 &lt;code&gt;image_tag&lt;/code&gt; 및 사용자가 제공 한 데이터와 함께 다른 도우미를 사용하는 데주의하십시오.</target>
        </trans-unit>
        <trans-unit id="3df341ac8f262d7b86a6c04ae7e8cea08aa1a2e1" translate="yes" xml:space="preserve">
          <source>If you're running multiple Ruby on Rails server processes (which is the case if you're using Phusion Passenger or puma clustered mode), then your Rails server process instances won't be able to share cache data with each other. This cache store is not appropriate for large application deployments. However, it can work well for small, low traffic sites with only a couple of server processes, as well as development and test environments.</source>
          <target state="translated">Phusion Passenger 또는 puma clustered 모드를 사용하는 경우 여러 Ruby on Rails 서버 프로세스를 실행하는 경우 Rails 서버 프로세스 인스턴스는 서로 캐시 데이터를 공유 할 수 없습니다. 이 캐시 저장소는 대규모 응용 프로그램 배포에는 적합하지 않습니다. 그러나 개발 및 테스트 환경뿐만 아니라 몇 개의 서버 프로세스 만있는 트래픽이 적은 소규모 사이트에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="9b7c79524790e17cbf7db1c67efd468a1423d66e" translate="yes" xml:space="preserve">
          <source>If you're used to using raw SQL to find database records, then you will generally find that there are better ways to carry out the same operations in Rails. Active Record insulates you from the need to use SQL in most cases.</source>
          <target state="translated">원시 SQL을 사용하여 데이터베이스 레코드를 찾는 데 익숙하다면 일반적으로 Rails에서 동일한 작업을 수행하는 더 좋은 방법이 있다는 것을 알게 될 것입니다. Active Record는 대부분의 경우 SQL을 사용하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="cf43b2e21b48384c946daf0f74a4a7b9ec9b126b" translate="yes" xml:space="preserve">
          <source>If you're using &lt;code&gt;schema_search_path&lt;/code&gt; or other PostgreSQL extensions, you can control how the schema is dumped. Set to &lt;code&gt;:all&lt;/code&gt; to generate all dumps, or to &lt;code&gt;:schema_search_path&lt;/code&gt; to generate from schema search path.</source>
          <target state="translated">&lt;code&gt;schema_search_path&lt;/code&gt; 또는 기타 PostgreSQL 확장을 사용 하는 경우 스키마가 덤프되는 방법을 제어 할 수 있습니다. 모든 덤프를 생성 하려면 &lt;code&gt;:all&lt;/code&gt; 로, 스키마 검색 경로에서 생성 하려면 &lt;code&gt;:schema_search_path&lt;/code&gt; 로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="42abce3f62d319d3f8e39a0650249547967475b6" translate="yes" xml:space="preserve">
          <source>If you're using Windows Subsystem for Linux then there are currently some limitations on file system notifications that mean you should disable the &lt;code&gt;spring&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; gems which you can do by running &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d229ea54e3d521db7d13293be710b7f3c3f89865" translate="yes" xml:space="preserve">
          <source>If you're using Windows Subsystem for Linux then there are currently some limitations on file system notifications that mean you should disable the &lt;code&gt;spring&lt;/code&gt; and &lt;code&gt;listen&lt;/code&gt; gems which you can do by running &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt;.</source>
          <target state="translated">Linux 용 Windows 서브 시스템을 사용하는 경우 파일 시스템 알림에 현재 일부 제한 사항이 있습니다. 즉, &lt;code&gt;rails new blog --skip-spring --skip-listen&lt;/code&gt; 을 실행하여 수행 할 수 있는 &lt;code&gt;spring&lt;/code&gt; 및 &lt;code&gt;listen&lt;/code&gt; gem을 비활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="252ef08bae0df050b53b6a5779527ac92970980d" translate="yes" xml:space="preserve">
          <source>If you're using named routes, they can be easily tested using the original named routes' methods straight in the test case.</source>
          <target state="translated">명명 된 경로를 사용하는 경우 테스트 사례에서 직접 명명 된 경로의 방법을 사용하여 쉽게 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf468826e965e22f66613dde40512c32eb5d1476" translate="yes" xml:space="preserve">
          <source>If you're using password input fields (for any purpose), you might want to configure your application to prevent those parameters from being logged. You can learn about this in the &lt;a href=&quot;security#logging&quot;&gt;Securing Rails Applications&lt;/a&gt; guide.</source>
          <target state="translated">암호 입력 필드를 사용하는 경우 (어떤 목적 으로든) 해당 매개 변수가 기록되지 않도록 응용 프로그램을 구성 할 수 있습니다. 이에 대한 내용은 &lt;a href=&quot;security#logging&quot;&gt;Securing Rails Applications&lt;/a&gt; 안내서 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6052169eaf1bc86bbca65ea47bc1eb643397b147" translate="yes" xml:space="preserve">
          <source>If you're writing a library or component that will invoke application code, you should wrap it with a call to the executor:</source>
          <target state="translated">애플리케이션 코드를 호출 할 라이브러리 또는 컴포넌트를 작성하는 경우 실행 프로그램을 호출하여 랩핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="43117e0ed8eb687cc272466c40042620d7fe982e" translate="yes" xml:space="preserve">
          <source>If you're writing a web service application, you might find yourself more comfortable accepting parameters in JSON format. If the &quot;Content-Type&quot; header of your request is set to &quot;application/json&quot;, Rails will automatically load your parameters into the &lt;code&gt;params&lt;/code&gt; hash, which you can access as you would normally.</source>
          <target state="translated">웹 서비스 응용 프로그램을 작성하는 경우 JSON 형식의 매개 변수를보다 쉽게 ​​받아 들일 수 있습니다. 요청의 &quot;Content-Type&quot;헤더가 &quot;application / json&quot;으로 설정된 경우 Rails는 매개 &lt;code&gt;params&lt;/code&gt; 해시에 매개 변수를 자동으로로드하며 , 일반적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d4d5f61b556e519c6e1e2356999ce42a7ddf62c" translate="yes" xml:space="preserve">
          <source>If you've set specific values, they'll be left alone.</source>
          <target state="translated">특정 값을 설정하면 값이 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="74869c5690f1f8df683db24bb30ead644f992f32" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;first&lt;/code&gt; will return the first record according to this ordering.</source>
          <target state="translated">귀하의 경우 &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;기본 범위는&lt;/a&gt; 주문 방법을 포함, &lt;code&gt;first&lt;/code&gt; 이 순서에 따라 첫 번째 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6835afd1c650ba01f41e5d358bf7f0e864950743" translate="yes" xml:space="preserve">
          <source>If your &lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;default scope&lt;/a&gt; contains an order method, &lt;code&gt;last&lt;/code&gt; will return the last record according to this ordering.</source>
          <target state="translated">&lt;a href=&quot;active_record_querying#applying-a-default-scope&quot;&gt;기본 범위&lt;/a&gt; 에 주문 방법이 포함 된 경우 &lt;code&gt;last&lt;/code&gt; 는이 주문에 따라 마지막 레코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1caa7aca1cdb0d5b52aac0863cedc2558d775ff6" translate="yes" xml:space="preserve">
          <source>If your Capybara configuration requires more setup than provided by Rails, this additional configuration could be added into the &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file.</source>
          <target state="translated">Capybara 구성에 Rails에서 제공 한 것보다 더 많은 설정이 필요한 경우이 추가 구성을 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일에 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5682ba1adb63dcd899a9ab63cfa20e123e47b8a7" translate="yes" xml:space="preserve">
          <source>If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via +html()+. Most jQuery plugins do this. If that is the case, be sure to &lt;code&gt;html_escape&lt;/code&gt; or &lt;code&gt;sanitize&lt;/code&gt; any user-generated content returned by your JSON.</source>
          <target state="translated">JSON을 다운 스트림에 사용하여 DOM에 삽입하는 경우 + html () +를 통해 삽입되는지 여부를 알고 있어야합니다. 대부분의 jQuery 플러그인이이를 수행합니다. 이 경우 JSON에서 반환 한 사용자 생성 콘텐츠 를 &lt;code&gt;html_escape&lt;/code&gt; 하거나 &lt;code&gt;sanitize&lt;/code&gt; 해야합니다.</target>
        </trans-unit>
        <trans-unit id="9e50cba3e4d75fdb113fb9a151d51646192f746e" translate="yes" xml:space="preserve">
          <source>If your JSON is being used downstream for insertion into the DOM, be aware of whether or not it is being inserted via &lt;code&gt;html()&lt;/code&gt;. Most jQuery plugins do this. If that is the case, be sure to &lt;code&gt;html_escape&lt;/code&gt; or &lt;code&gt;sanitize&lt;/code&gt; any user-generated content returned by your JSON.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7fefdf5de1dd35d237a9b1901e9afd42363fae3" translate="yes" xml:space="preserve">
          <source>If your MySQL version is 5.5 or 5.6 and want to use the &lt;code&gt;utf8mb4&lt;/code&gt; character set by default, please configure your MySQL server to support the longer key prefix by enabling &lt;code&gt;innodb_large_prefix&lt;/code&gt; system variable.</source>
          <target state="translated">MySQL 버전이 5.5 또는 5.6이고 기본적으로 &lt;code&gt;utf8mb4&lt;/code&gt; 문자 세트 를 사용하려는 경우 &lt;code&gt;innodb_large_prefix&lt;/code&gt; 시스템 변수 를 활성화하여 더 긴 키 접 두부를 지원하도록 MySQL 서버를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ec6ed42547439a0457afd0ebebe94c88bd5fa87" translate="yes" xml:space="preserve">
          <source>If your application currently depends on MultiJSON directly, you have a few options:</source>
          <target state="translated">애플리케이션이 현재 MultiJSON에 직접 의존하는 경우 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad0d95ee276b14edf1a42c9fa291547930f26681" translate="yes" xml:space="preserve">
          <source>If your application depends on one of these features, you can get them back by adding the &lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt;&lt;code&gt;activesupport-json_encoder&lt;/code&gt;&lt;/a&gt; gem to your &lt;code&gt;Gemfile&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램이 이러한 기능 중 하나에 의존하는 경우, 당신은 추가하여 그들을 다시 얻을 수 &lt;a href=&quot;https://github.com/rails/activesupport-json_encoder&quot;&gt; &lt;code&gt;activesupport-json_encoder&lt;/code&gt; 의&lt;/a&gt; 당신에 보석을 &lt;code&gt;Gemfile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="381e5230923304164bbcf6cb5cafb16c7ce7b7f7" translate="yes" xml:space="preserve">
          <source>If your application has STIs, please check their section in the guide &lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;Autoloading and Reloading Constants (Zeitwerk Mode)&lt;/a&gt;.</source>
          <target state="translated">응용 프로그램에 STI가있는 경우 &lt;a href=&quot;autoloading_and_reloading_constants#single-table-inheritance&quot;&gt;Autoloading and Reloading Constants (Zeitwerk Mode)&lt;/a&gt; 안내서에서 해당 섹션을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="8dbc5db49e45fcf4e2303c426327e0441f8dcc0b" translate="yes" xml:space="preserve">
          <source>If your application has complex routes, Rails provides a number of useful helpers to test them.</source>
          <target state="translated">애플리케이션에 복잡한 경로가있는 경우 Rails는 여러 가지 유용한 도우미를 제공하여 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e74a56a0c5eeea301a713680cbfd78e970264146" translate="yes" xml:space="preserve">
          <source>If your application has many RESTful routes, using &lt;code&gt;:only&lt;/code&gt; and &lt;code&gt;:except&lt;/code&gt; to generate only the routes that you actually need can cut down on memory use and speed up the routing process.</source>
          <target state="translated">응용 프로그램에 많은 RESTful 경로가있는 경우 &lt;code&gt;:only&lt;/code&gt; 및 &lt;code&gt;:except&lt;/code&gt; 를 사용하여 실제로 필요한 경로 만 생성하면 메모리 사용을 줄이고 라우팅 프로세스 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="879f12c0520e9f207457aaa46715d1c53ee57db5" translate="yes" xml:space="preserve">
          <source>If your application has to execute commands in the underlying operating system, there are several methods in Ruby: &lt;code&gt;exec(command)&lt;/code&gt;, &lt;code&gt;syscall(command)&lt;/code&gt;, &lt;code&gt;system(command)&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (&lt;code&gt;;&lt;/code&gt;) or a vertical bar (&lt;code&gt;|&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41f0014e907848cfdeccd3b999808ddc2e11c394" translate="yes" xml:space="preserve">
          <source>If your application has to execute commands in the underlying operating system, there are several methods in Ruby: exec(command), syscall(command), system(command) and &lt;code&gt;command&lt;/code&gt;. You will have to be especially careful with these functions if the user may enter the whole command, or a part of it. This is because in most shells, you can execute another command at the end of the first one, concatenating them with a semicolon (;) or a vertical bar (|).</source>
          <target state="translated">응용 프로그램이 기본 운영 체제에서 명령을 실행해야하는 경우 Ruby에는 exec (command), syscall (command), system (command) 및 &lt;code&gt;command&lt;/code&gt; 와 같은 여러 가지 방법이 있습니다 . 사용자가 전체 명령 또는 그 일부를 입력 할 수있는 경우 이러한 기능에 특히주의해야합니다. 대부분의 쉘에서 첫 번째 명령의 끝에 다른 명령을 실행하여 세미콜론 (;) 또는 수직 막대 (|)로 연결할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="889c5891aad30eb8db5021e9ab63293d15ccf22f" translate="yes" xml:space="preserve">
          <source>If your application includes a locale switching menu, you would then have something like this in it:</source>
          <target state="translated">응용 프로그램에 로케일 전환 메뉴가 포함되어 있으면 다음과 같은 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fc86689b27dc32bd92136eda6001352ad0921b2" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.0.x, you should upgrade to Rails 3.0 before attempting an update to Rails 3.1.</source>
          <target state="translated">응용 프로그램이 현재 3.0.x 이전의 모든 Rails 버전에있는 경우 Rails 3.1로 업데이트하기 전에 Rails 3.0으로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="12223a67df42527d2cbff3ea72dd72f11fc7181b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.1.x, you should upgrade to Rails 3.1 before attempting an update to Rails 3.2.</source>
          <target state="translated">애플리케이션이 현재 3.1.x 이전의 모든 Rails 버전에있는 경우 Rails 3.2로 업데이트하기 전에 Rails 3.1로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf06afce41a26745cb148a584af6c8c383ba496b" translate="yes" xml:space="preserve">
          <source>If your application is currently on any version of Rails older than 3.2.x, you should upgrade to Rails 3.2 before attempting one to Rails 4.0.</source>
          <target state="translated">애플리케이션이 현재 3.2.x 이전의 모든 Rails 버전에있는 경우 Rails 4.0으로 시도하기 전에 Rails 3.2로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="c90ef0b46bf42ed5bf642ff84f742f3bf3110011" translate="yes" xml:space="preserve">
          <source>If your application is deadlocking and you think the Load Interlock may be involved, you can temporarily add the ActionDispatch::DebugLocks middleware to &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 교착 상태이고로드 인터록이 관련되어 있다고 생각되면 ActionDispatch :: DebugLocks 미들웨어를 &lt;code&gt;config/application.rb&lt;/code&gt; 에 임시로 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cc2f17257706e28458d22e8b6cad9d03d6bad0a4" translate="yes" xml:space="preserve">
          <source>If your application is using an &quot;/assets&quot; route for a resource you may want to change the prefix used for assets to avoid conflicts:</source>
          <target state="translated">애플리케이션이 자원에 대해 &quot;/ 자산&quot;경로를 사용하는 경우 충돌을 피하기 위해 자산에 사용되는 접 두부를 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e05fa3e91e37b6cf6fa12bc4e688c1e6edaef466" translate="yes" xml:space="preserve">
          <source>If your application lived at &lt;code&gt;https://example.com&lt;/code&gt;, you would specify the fully-qualified URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt;.</source>
          <target state="translated">애플리케이션이 &lt;code&gt;https://example.com&lt;/code&gt; 에있는 경우 완전한 URL &lt;code&gt;https://example.com/rails/action_mailbox/mailgun/inbound_emails/mime&lt;/code&gt; 를 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="7e4bd7dc0f0e490c584ba6f39585e2d67413ee59" translate="yes" xml:space="preserve">
          <source>If your application lives at &lt;code&gt;https://example.com&lt;/code&gt;, you would configure the Postfix SMTP server to pipe inbound emails to the following command:</source>
          <target state="translated">애플리케이션이 &lt;code&gt;https://example.com&lt;/code&gt; 에있는 경우 인바운드 이메일을 다음 명령으로 파이프하도록 Postfix SMTP 서버를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="daa1c9e216c9d8d165b0c33678ea2b6e0ff6a8b7" translate="yes" xml:space="preserve">
          <source>If your application needs to use the old sanitizer implementation, include &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; in your &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">애플리케이션이 이전 소독제 구현을 사용해야하는 경우 &lt;code&gt;Gemfile&lt;/code&gt; 에 &lt;code&gt;rails-deprecated_sanitizer&lt;/code&gt; 를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="68e455eeb621d690f5b8628124cfcc30d52a5a8e" translate="yes" xml:space="preserve">
          <source>If your application relies on the previous incorrect behaviour, you are encouraged to specify which formats your action accepts, i.e.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1030747ba04510c35d637b99ad76753d7203e5a7" translate="yes" xml:space="preserve">
          <source>If your application stores nested configuration in &lt;code&gt;config/secrets.yml&lt;/code&gt;, all keys are now loaded as symbols, so access using strings should be changed.</source>
          <target state="translated">애플리케이션이 중첩 된 구성을 &lt;code&gt;config/secrets.yml&lt;/code&gt; 에 저장 하면 모든 키가 이제 심볼로로드되므로 문자열을 사용한 액세스를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="b8139193fb989ae2ed172e3931f636d721facb2c" translate="yes" xml:space="preserve">
          <source>If your application uses the top-level &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; class, you should slowly move your code to instead use &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에서 최상위 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 클래스를 사용하는 경우 &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; 대신 코드를 천천히 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="91af82fb39f605eb090b15525e992995690b6439" translate="yes" xml:space="preserve">
          <source>If your application was not updated to Rails 5.2 defaults, the secret_key_base will be found in the old &lt;code&gt;config/secrets.yml&lt;/code&gt; file.</source>
          <target state="translated">애플리케이션이 Rails 5.2 기본값으로 업데이트되지 않은 경우 secret_key_base는 이전 &lt;code&gt;config/secrets.yml&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac9b2e447adcea9fbe7e2a9bd3bc168e61c635fb" translate="yes" xml:space="preserve">
          <source>If your application's secrets may have been exposed, strongly consider changing them. Changing &lt;code&gt;secret_key_base&lt;/code&gt; will expire currently active sessions.</source>
          <target state="translated">응용 프로그램의 비밀이 노출되었을 수 있으면 변경하는 것이 좋습니다. &lt;code&gt;secret_key_base&lt;/code&gt; 를 변경하면 현재 활성 세션이 만료됩니다.</target>
        </trans-unit>
        <trans-unit id="245cc21a5ea8e15077d37f8a07a1b1d7f6bba0ff" translate="yes" xml:space="preserve">
          <source>If your authentication approach includes using a session, you use cookie store for the session, your session cookie is named &lt;code&gt;_session&lt;/code&gt; and the user ID key is &lt;code&gt;user_id&lt;/code&gt; you can use this approach:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0a57381eea06e446a567dd408bdc093cbdd1ce" translate="yes" xml:space="preserve">
          <source>If your cache is on a shared infrastructure, you can define a namespace for your cache entries. If a namespace is defined, it will be prefixed on to every key. The namespace can be either a static value or a Proc. If it is a Proc, it will be invoked when each key is evaluated so that you can use application logic to invalidate keys.</source>
          <target state="translated">캐시가 공유 인프라에있는 경우 캐시 항목의 네임 스페이스를 정의 할 수 있습니다. 네임 스페이스가 정의되면 모든 키 앞에 접두사가 붙습니다. 네임 스페이스는 정적 값이거나 Proc 일 수 있습니다. Proc 인 경우, 각 키가 평가 될 때 호출되어 응용 프로그램 논리를 사용하여 키를 무효화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ac4c43c45266924507181e8d1c66138e18a9e8" translate="yes" xml:space="preserve">
          <source>If your collection cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of a block that returns an array:</source>
          <target state="translated">컬렉션 캐시가 여러 소스에 의존하는 경우 (간단하게 유지하기 위해이를 피하려고 시도) 배열을 반환하는 블록의 일부로 이러한 모든 종속성의 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b951b1cd4019d75cd33aff42a1e533f21ba16a6" translate="yes" xml:space="preserve">
          <source>If your controller has defined &lt;code&gt;@person&lt;/code&gt; and that person's city_id is 2:</source>
          <target state="translated">컨트롤러가 &lt;code&gt;@person&lt;/code&gt; 을 정의 하고 해당 사람의 city_id가 2 인 경우 :</target>
        </trans-unit>
        <trans-unit id="0aecaded96b353fb5bd5f694e20b8584a9b1d3a5" translate="yes" xml:space="preserve">
          <source>If your database supports setting the isolation level for a transaction, you can set it like so:</source>
          <target state="translated">데이터베이스가 트랜잭션의 격리 수준 설정을 지원하는 경우 다음과 같이 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="103ba4b31df0da57a8ec66f6aa656e1b132fd216" translate="yes" xml:space="preserve">
          <source>If your development database has a root user with an empty password, this configuration should work for you. Otherwise, change the username and password in the &lt;code&gt;development&lt;/code&gt; section as appropriate.</source>
          <target state="translated">개발 데이터베이스에 빈 암호를 가진 루트 사용자가있는 경우이 구성이 적합합니다. 그렇지 않으면 &lt;code&gt;development&lt;/code&gt; 섹션 에서 사용자 이름과 비밀번호 를 적절히 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c10c4f115be70f11c744ae41c96edb7a7107b4c" translate="yes" xml:space="preserve">
          <source>If your engine has migrations, you may also want to prepare data for the database in the &lt;code&gt;db/seeds.rb&lt;/code&gt; file. You can load that data using the &lt;code&gt;load_seed&lt;/code&gt; method, e.g.</source>
          <target state="translated">엔진에 마이그레이션이있는 경우 &lt;code&gt;db/seeds.rb&lt;/code&gt; 파일 에서 데이터베이스에 대한 데이터를 준비 할 수도 있습니다 . &lt;code&gt;load_seed&lt;/code&gt; 메소드를 사용하여 해당 데이터를로드 할 수 있습니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="425cd983d81b837debf97e01070fc8dd942a349a" translate="yes" xml:space="preserve">
          <source>If your front-end server supports accelerated file sending, &lt;code&gt;Rack::Sendfile&lt;/code&gt; will offload the actual file sending work to the front-end server.</source>
          <target state="translated">프런트 엔드 서버가 파일 전송 가속화를 지원하는 경우 &lt;code&gt;Rack::Sendfile&lt;/code&gt; 은 실제 파일 전송 작업을 프런트 엔드 서버로 오프로드합니다.</target>
        </trans-unit>
        <trans-unit id="bd8111e3c285dfb7987c6fb762023306b9a5dc95" translate="yes" xml:space="preserve">
          <source>If your migration is irreversible, you should raise &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; from your &lt;code&gt;down&lt;/code&gt; method. If someone tries to revert your migration, an error message will be displayed saying that it can't be done.</source>
          <target state="translated">마이그레이션을 되돌릴 수없는 경우 &lt;code&gt;down&lt;/code&gt; 메소드 에서 &lt;code&gt;ActiveRecord::IrreversibleMigration&lt;/code&gt; 을 높여야 합니다 . 누군가 마이그레이션을 되돌리려 고하면 수행 할 수 없다는 오류 메시지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="b8c3382db198a7dd11c8954262ef38078bc5ca90" translate="yes" xml:space="preserve">
          <source>If your model does not act like an Active Model object, then you should define &lt;code&gt;:to_model&lt;/code&gt; yourself returning a proxy object that wraps your object with Active Model compliant methods.</source>
          <target state="translated">모델이 Active Model 객체처럼 작동하지 않으면 &lt;code&gt;:to_model&lt;/code&gt; 을 정의 하여 Active Model 호환 메소드로 객체를 래핑하는 프록시 객체를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="76baa030465bac752869f817cdc6077b5aeb38ed" translate="yes" xml:space="preserve">
          <source>If your object is already designed to implement all of the Active Model you can use the default &lt;code&gt;:to_model&lt;/code&gt; implementation, which simply returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">객체가 이미 모든 활성 모델을 구현하도록 설계된 경우 기본 &lt;code&gt;:to_model&lt;/code&gt; 구현을 사용할 수 있으며 이는 단순히 &lt;code&gt;self&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1eec21080e87822414c65ee8646ce12bc7a95b25" translate="yes" xml:space="preserve">
          <source>If your railtie has Rake tasks, you can tell &lt;code&gt;Rails&lt;/code&gt; to load them through the method &lt;code&gt;rake_tasks&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05b58e6bdf018a796fd3192e810a7a0d52af9a3b" translate="yes" xml:space="preserve">
          <source>If your railtie has Rake tasks, you can tell Rails to load them through the method &lt;code&gt;rake_tasks&lt;/code&gt;:</source>
          <target state="translated">railtie에 Rake 작업이있는 경우 rake_tasks 메소드를 통해 Rails &lt;code&gt;rake_tasks&lt;/code&gt; 를로드하도록 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="87a60c820f332d2130d62bec29e48f80d0781651" translate="yes" xml:space="preserve">
          <source>If your resource has associations defined, for example, you want to add comments to the document given that the routes are set correctly:</source>
          <target state="translated">예를 들어, 자원에 연관이 정의되어 있으면 경로가 올바르게 설정되어있는 경우 문서에 주석을 추가하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6fe760c48d59a5abc10b50357644a1cefa1de69d" translate="yes" xml:space="preserve">
          <source>If your route needs to respond to more than one HTTP method (or all methods) then using the &lt;code&gt;:via&lt;/code&gt; option on &lt;code&gt;match&lt;/code&gt; is preferable.</source>
          <target state="translated">경로가 둘 이상의 HTTP 메소드 (또는 모든 메소드)에 응답해야하는 경우 &lt;code&gt;match&lt;/code&gt; &lt;code&gt;:via&lt;/code&gt; 옵션 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="14e98748b230ce1d3b61f7ea63fc8bfa9d1c5edb" translate="yes" xml:space="preserve">
          <source>If your system tests verify the deletion of a model with attachments and you're using Active Job, set your test environment to use the inline queue adapter so the purge job is executed immediately rather at an unknown time in the future.</source>
          <target state="translated">시스템 테스트에서 첨부 파일이있는 모델의 삭제를 확인하고 활성 작업을 사용중인 경우 나중에 알 수없는 시간에 제거 작업이 즉시 실행되도록 인라인 큐 어댑터를 사용하도록 테스트 환경을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6bedd4e4c87ec197ef48f07fe917c09d9e5f5451" translate="yes" xml:space="preserve">
          <source>If your table/model specifies any of Active Record's standard timestamp columns (&lt;code&gt;created_at&lt;/code&gt;, &lt;code&gt;created_on&lt;/code&gt;, &lt;code&gt;updated_at&lt;/code&gt;, &lt;code&gt;updated_on&lt;/code&gt;), they will automatically be set to &lt;code&gt;Time.now&lt;/code&gt;.</source>
          <target state="translated">테이블 / 모델이 Active Record의 표준 타임 스탬프 열 ( &lt;code&gt;created_at&lt;/code&gt; , &lt;code&gt;created_on&lt;/code&gt; , &lt;code&gt;updated_at&lt;/code&gt; , &lt;code&gt;updated_on&lt;/code&gt; )을 지정하면 자동으로 &lt;code&gt;Time.now&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="582795cbf5201022212575a8a28b6d7709781eb4" translate="yes" xml:space="preserve">
          <source>If your template cache depends on multiple sources (try to avoid this to keep things simple), you can name all these dependencies as part of an array:</source>
          <target state="translated">템플릿 캐시가 여러 소스에 의존하는 경우 (이를 피하기 위해 시도하지 마십시오) 이러한 모든 종속성의 이름을 배열의 일부로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e1915027d69cb84df21a5be9911cf19bed7a9c1" translate="yes" xml:space="preserve">
          <source>If your test helper contains a call to &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; this can be removed. The check is now done automatically when you &lt;code&gt;require &quot;rails/test_help&quot;&lt;/code&gt;, although leaving this line in your helper is not harmful in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40543e76d91d611a5ec9410b5887ffa0387c4560" translate="yes" xml:space="preserve">
          <source>If your test helper contains a call to &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; this can be removed. The check is now done automatically when you &lt;code&gt;require 'rails/test_help'&lt;/code&gt;, although leaving this line in your helper is not harmful in any way.</source>
          <target state="translated">테스트 도우미에 &lt;code&gt;ActiveRecord::Migration.check_pending!&lt;/code&gt; 이것을 제거 할 수 있습니다. &lt;code&gt;require 'rails/test_help'&lt;/code&gt; 때 자동으로 검사가 수행 되지만, 도우미에이 줄을 남겨 두는 것은 아무 문제가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5aa870b38e91039a2c31c0ec518113cbf1f31ce8" translate="yes" xml:space="preserve">
          <source>If your translations are stored in YAML files, certain keys must be escaped. They are:</source>
          <target state="translated">번역이 YAML 파일에 저장된 경우 특정 키를 이스케이프해야합니다. 그들은:</target>
        </trans-unit>
        <trans-unit id="1185f54ced928c01b83f233ae5ac48bd71437bbc" translate="yes" xml:space="preserve">
          <source>If your user sessions don't store critical data or don't need to be around for long periods (for instance if you just use the flash for messaging), you can consider using &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt;. This will store sessions using the cache implementation you have configured for your application. The advantage of this is that you can use your existing cache infrastructure for storing sessions without requiring any additional setup or administration. The downside, of course, is that the sessions will be ephemeral and could disappear at any time.</source>
          <target state="translated">사용자 세션이 중요한 데이터를 저장하지 않거나 장시간 (예 : 메시징에 플래시를 사용하는 경우) 필요하지 않은 경우 &lt;code&gt;ActionDispatch::Session::CacheStore&lt;/code&gt; 사용을 고려할 수 있습니다 . 응용 프로그램에 대해 구성한 캐시 구현을 사용하여 세션을 저장합니다. 이것의 장점은 추가 설정이나 관리없이 기존 캐시 인프라를 사용하여 세션을 저장할 수 있다는 것입니다. 물론 단점은 세션이 일시적이며 언제든지 사라질 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c10b3295ac930c8b6d0186ae1b2fa25dca24d2a2" translate="yes" xml:space="preserve">
          <source>If your validator is complex enough that you want instance variables, you can easily use a plain old Ruby object instead:</source>
          <target state="translated">유효성 검사기가 인스턴스 변수를 원할 정도로 복잡하면 대신 일반 오래된 Ruby 객체를 쉽게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2363271991ec3d01cf8289a4fbc37afaa3a9611" translate="yes" xml:space="preserve">
          <source>If your views are using &lt;code&gt;render :text&lt;/code&gt;, they will no longer work. The new method of rendering text with MIME type of &lt;code&gt;text/plain&lt;/code&gt; is to use &lt;code&gt;render :plain&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afcb932a25203f1fddef75a94720d32694cde47f" translate="yes" xml:space="preserve">
          <source>If your web application is RESTful, you might be used to additional HTTP verbs, such as PATCH, PUT, or DELETE. Some legacy web browsers, however, do not support them - only GET and POST. Rails uses a hidden &lt;code&gt;_method&lt;/code&gt; field to handle these cases.</source>
          <target state="translated">웹 애플리케이션이 RESTful 인 경우 PATCH, PUT 또는 DELETE와 같은 추가 HTTP 동사에 사용될 수 있습니다. 그러나 일부 레거시 웹 브라우저는 지원하지 않으며 GET 및 POST 만 지원합니다. Rails는 숨겨진 &lt;code&gt;_method&lt;/code&gt; 필드를 사용하여 이러한 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="0afb0954f983960221fe6a682c63294fd2db4dd3" translate="yes" xml:space="preserve">
          <source>If, in the case of this &lt;code&gt;includes&lt;/code&gt; query, there were no books for any authors, all the authors would still be loaded. By using &lt;code&gt;joins&lt;/code&gt; (an INNER JOIN), the join conditions &lt;strong&gt;must&lt;/strong&gt; match, otherwise no records will be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18ed34d58a9a3df6e8627865711db726b025acd9" translate="yes" xml:space="preserve">
          <source>If, in the case of this &lt;code&gt;includes&lt;/code&gt; query, there were no comments for any articles, all the articles would still be loaded. By using &lt;code&gt;joins&lt;/code&gt; (an INNER JOIN), the join conditions &lt;strong&gt;must&lt;/strong&gt; match, otherwise no records will be returned.</source>
          <target state="translated">&lt;code&gt;includes&lt;/code&gt; 쿼리가 포함 된 경우 기사에 대한 주석이 없으면 모든 기사가 계속로드됩니다. 사용하여 &lt;code&gt;joins&lt;/code&gt; (내부 조인)의 조건에 가입 &lt;strong&gt;해야한다&lt;/strong&gt; , 그렇지 않으면 레코드가 반환되지 않습니다, 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a94f011d595752d4e6b5453f8220167ce12c64b9" translate="yes" xml:space="preserve">
          <source>Image analysis provides &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; attributes. Video analysis provides these, as well as &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;angle&lt;/code&gt;, and &lt;code&gt;display_aspect_ratio&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fef5983e69c04936b5e027592d449f0c9aa803" translate="yes" xml:space="preserve">
          <source>Image blobs can have variants that are the result of a set of transformations applied to the original. These variants are used to create thumbnails, fixed-size avatars, or any other derivative image from the original.</source>
          <target state="translated">이미지 블롭에는 원본에 적용된 일련의 변환의 결과 인 변형이있을 수 있습니다. 이러한 변형은 축소판 그림, 고정 크기 아바타 또는 원본의 다른 파생 이미지를 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c26464afe4467cfea083f888c397ad9db64fe0da" translate="yes" xml:space="preserve">
          <source>ImageMagick reference</source>
          <target state="translated">ImageMagick 참조</target>
        </trans-unit>
        <trans-unit id="6b547bf4fc75d103729ab2f9120fc708162824e6" translate="yes" xml:space="preserve">
          <source>ImageProcessing::MiniMagick</source>
          <target state="translated">ImageProcessing::MiniMagick</target>
        </trans-unit>
        <trans-unit id="bb1869013b3837865b83b826ba6cbc2f0478b949" translate="yes" xml:space="preserve">
          <source>ImageProcessing::Vips</source>
          <target state="translated">ImageProcessing::Vips</target>
        </trans-unit>
        <trans-unit id="e59410c44344783744ca127bd399b00f6c4b26d8" translate="yes" xml:space="preserve">
          <source>Images can also be organized into subdirectories if required, and then can be accessed by specifying the directory's name in the tag:</source>
          <target state="translated">필요한 경우 이미지를 하위 디렉토리로 구성한 다음 태그에 디렉토리 이름을 지정하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="042a141a97424ca18ce357d660b1f19cd18e6379" translate="yes" xml:space="preserve">
          <source>Imagine a restricted list deletes &quot;script&quot; from the user input. Now the attacker injects &quot;&amp;lt;scrscriptipt&amp;gt;&quot;, and after the filter, &quot;&amp;lt;script&amp;gt;&quot; remains. Earlier versions of Rails used a restricted list approach for the strip_tags(), strip_links() and sanitize() method. So this kind of injection was possible:</source>
          <target state="translated">제한된 목록이 사용자 입력에서 &quot;스크립트&quot;를 삭제한다고 상상해보십시오. 이제 공격자가 &quot;&amp;lt;scrscriptipt&amp;gt;&quot;을 삽입하고 필터 후에 &quot;&amp;lt;script&amp;gt;&quot;가 남아 있습니다. 이전 버전의 Rails는 strip_tags (), strip_links () 및 sanitize () 메소드에 대해 제한된 목록 접근 방식을 사용했습니다. 따라서 이런 종류의 주사가 가능했습니다.</target>
        </trans-unit>
        <trans-unit id="eec01ec45ec0b8feeb48c1e3a3a89fe989b70ff6" translate="yes" xml:space="preserve">
          <source>Imagine a restricted list deletes &lt;code&gt;&quot;script&quot;&lt;/code&gt; from the user input. Now the attacker injects &lt;code&gt;&quot;&amp;lt;scrscriptipt&amp;gt;&quot;&lt;/code&gt;, and after the filter, &lt;code&gt;&quot;&amp;lt;script&amp;gt;&quot;&lt;/code&gt; remains. Earlier versions of Rails used a restricted list approach for the &lt;code&gt;strip_tags()&lt;/code&gt;, &lt;code&gt;strip_links()&lt;/code&gt; and &lt;code&gt;sanitize()&lt;/code&gt; method. So this kind of injection was possible:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b880b948b508d4c09c27dafc56f6c45e159ad52" translate="yes" xml:space="preserve">
          <source>Imagine a scenario where you have parameters representing a product name and a hash of arbitrary data associated with that product, and you want to permit the product name attribute and also the whole data hash:</source>
          <target state="translated">제품 이름 및 해당 제품과 관련된 임의의 데이터 해시를 나타내는 매개 변수가 있고 제품 ​​이름 속성과 전체 데이터 해시를 허용하려는 시나리오를 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="82efa8ca1d9a12ef2b518545653e0d364d47da15" translate="yes" xml:space="preserve">
          <source>Imagine that this template was in a file called &lt;code&gt;template.rb&lt;/code&gt;. We can use it to modify the outcome of the &lt;code&gt;rails new&lt;/code&gt; command by using the &lt;code&gt;-m&lt;/code&gt; option and passing in the filename:</source>
          <target state="translated">이 템플릿 파일이라는 있다는 상상 &lt;code&gt;template.rb&lt;/code&gt; . &lt;code&gt;-m&lt;/code&gt; 옵션 을 사용 하고 파일 이름을 전달 하여 &lt;code&gt;rails new&lt;/code&gt; 명령 의 결과를 수정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a23c9f6f0d6eb9b1c67997eb11e2e598caca6dc7" translate="yes" xml:space="preserve">
          <source>Imagine that you did have an asset located at &lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; To include this asset inside an application, just use &lt;code&gt;stylesheet_link_tag&lt;/code&gt; and reference the asset as if it were inside the engine:</source>
          <target state="translated">&lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt; 에 자산이 있다고 상상해보십시오. 이 자산을 응용 프로그램에 포함 시키려면 &lt;code&gt;stylesheet_link_tag&lt;/code&gt; 를 사용 하고 엔진 내부에있는 것처럼 자산을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d55ea351b6a54005ce144e1cd6e857f2fb90fd5f" translate="yes" xml:space="preserve">
          <source>Imagine that you did have an asset located at &lt;code&gt;app/assets/stylesheets/blorgh/style.css&lt;/code&gt;. To include this asset inside an application, just use &lt;code&gt;stylesheet_link_tag&lt;/code&gt; and reference the asset as if it were inside the engine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8d65f4b17f25607c90868e7031c68bab93f6d78" translate="yes" xml:space="preserve">
          <source>Imagine you have a series of users that you would like to display and provide a form on that same page to create a new user. The index action of your controller looks like this:</source>
          <target state="translated">같은 페이지에 새 사용자를 작성하기 위해 양식을 표시하고 제공하려는 일련의 사용자가 있다고 가정하십시오. 컨트롤러의 인덱스 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1e96898b6501d3fbdcf2300804027e8c6693dd90" translate="yes" xml:space="preserve">
          <source>Imagine you have a server which mirrors the production environment but is only used for testing. Such a server is commonly called a &quot;staging server&quot;. To define an environment called &quot;staging&quot; for this server, just create a file called &lt;code&gt;config/environments/staging.rb&lt;/code&gt;. Please use the contents of any existing file in &lt;code&gt;config/environments&lt;/code&gt; as a starting point and make the necessary changes from there.</source>
          <target state="translated">프로덕션 환경을 미러링하지만 테스트에만 사용되는 서버가 있다고 가정하십시오. 이러한 서버를 일반적으로 &quot;스테이징 서버&quot;라고합니다. 이 서버에 &quot;staging&quot;이라는 환경을 정의하려면 &lt;code&gt;config/environments/staging.rb&lt;/code&gt; 파일을 작성하십시오 . &lt;code&gt;config/environments&lt;/code&gt; 에있는 기존 파일의 내용을 시작점으로 사용하고 필요한 부분을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="9b0e1a932488fc0faaa2b295c30a9aa45876243c" translate="yes" xml:space="preserve">
          <source>Imagine you need to work with a legacy database containing the following table:</source>
          <target state="translated">다음 테이블이 포함 된 레거시 데이터베이스로 작업해야한다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="382440615e24855ff2336a43658c39e3827929d1" translate="yes" xml:space="preserve">
          <source>Imagine you would like to delegate everything missing from the &lt;code&gt;User&lt;/code&gt; object, to the &lt;code&gt;Profile&lt;/code&gt; one. The &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/Module.html#method-i-delegate_missing_to&quot;&gt;&lt;code&gt;delegate_missing_to&lt;/code&gt;&lt;/a&gt; macro lets you implement this in a breeze:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6970d62a4e47823d1263b678a59e7b3be71b5a0c" translate="yes" xml:space="preserve">
          <source>Imagine you would like to delegate everything missing from the &lt;code&gt;User&lt;/code&gt; object, to the &lt;code&gt;Profile&lt;/code&gt; one. The &lt;code&gt;delegate_missing_to&lt;/code&gt; macro lets you implement this in a breeze:</source>
          <target state="translated">&lt;code&gt;User&lt;/code&gt; 객체 에서 누락 된 모든 것을 &lt;code&gt;Profile&lt;/code&gt; 객체 에 위임한다고 가정합니다 . &lt;code&gt;delegate_missing_to&lt;/code&gt; 의 매크로는 당신이 바람에이를 구현할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="592f461f8f650c9881d19434eb07cf55d51fcec5" translate="yes" xml:space="preserve">
          <source>Immediately forget this connection ever existed. Unlike disconnect!, this will not communicate with the server.</source>
          <target state="translated">이 연결이 존재한다는 것을 즉시 잊어 버리십시오. disconnect!와 달리 서버와 통신하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e978bf8d864e78d060c2d40ba6e8356a7ddb4552" translate="yes" xml:space="preserve">
          <source>ImmutableString</source>
          <target state="translated">ImmutableString</target>
        </trans-unit>
        <trans-unit id="4ba4b37c409e259716fe6f3feb135d41b0df925d" translate="yes" xml:space="preserve">
          <source>Impact of Logs on Performance</source>
          <target state="translated">로그가 성능에 미치는 영향</target>
        </trans-unit>
        <trans-unit id="3541319efbbc447409bc55f973fe6221e45917e9" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the analyzer can extract metadata.</source>
          <target state="translated">구체적인 서브 클래스에서이 메소드를 구현하십시오. 분석기가 메타 데이터를 추출 할 수있는 얼룩이 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="6725be8193f353157ed48984e7bd46897dd0c798" translate="yes" xml:space="preserve">
          <source>Implement this method in a concrete subclass. Have it return true when given a blob from which the previewer can generate an image.</source>
          <target state="translated">구체적인 서브 클래스에서이 메소드를 구현하십시오. 미리보기에서 이미지를 생성 할 수있는 얼룩이 있으면 true를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="0943b924eaaff69505bab9417579906e3e21c340" translate="yes" xml:space="preserve">
          <source>Implement this method in concrete subclasses. It will determine if blob analysis should be done in a job or performed inline. By default, analysis is enqueued in a job.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900dd4ac67347484c1b41e0135def860124558d7" translate="yes" xml:space="preserve">
          <source>Implementing Support for Other Cloud Services</source>
          <target state="translated">다른 클라우드 서비스에 대한 지원 구현</target>
        </trans-unit>
        <trans-unit id="59e6cb8931e9953bd8ed0a4c1524ddf009bd758c" translate="yes" xml:space="preserve">
          <source>Implementing a System Test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beca3b2271c9131a4132ecdb9e1400f3f98aaa03" translate="yes" xml:space="preserve">
          <source>Implementing a system test</source>
          <target state="translated">시스템 테스트 구현</target>
        </trans-unit>
        <trans-unit id="088e2ffa59238fae1077a6a98d6f816ed4781b79" translate="yes" xml:space="preserve">
          <source>Implementing an integration test</source>
          <target state="translated">통합 테스트 구현</target>
        </trans-unit>
        <trans-unit id="be2fc4a7e872958c1218af9bd0f7ec74151da4b2" translate="yes" xml:space="preserve">
          <source>Implements a hash where keys &lt;code&gt;:foo&lt;/code&gt; and &lt;code&gt;&quot;foo&quot;&lt;/code&gt; are considered to be the same.</source>
          <target state="translated">keys &lt;code&gt;:foo&lt;/code&gt; 와 &lt;code&gt;&quot;foo&quot;&lt;/code&gt; 가 같은 것으로 간주 되는 해시를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="c613ef0456cfc282a210d9a952d24027a5dbe57d" translate="yes" xml:space="preserve">
          <source>Implements a mailer preview interceptor that converts image tag src attributes that use inline cid: style URLs to data: style URLs so that they are visible when previewing an HTML email in a web browser.</source>
          <target state="translated">인라인 cid : 스타일 URL을 데이터 : 스타일 URL로 사용하는 이미지 태그 src 속성을 웹 브라우저에서 HTML 이메일을 미리 볼 때 볼 수 있도록 변환하는 메일러 미리보기 인터셉터를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="a674441f3f025c1cea1ff8dac33f29a4af126540" translate="yes" xml:space="preserve">
          <source>Implements methods that allow rendering from a view context. In order to use this module, all you need is to implement view_renderer that returns an &lt;a href=&quot;../renderer&quot;&gt;&lt;code&gt;ActionView::Renderer&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d4e13f56409e0a39f90cdbbbdbcd9d6342ece8" translate="yes" xml:space="preserve">
          <source>Implements methods that allow rendering from a view context. In order to use this module, all you need is to implement view_renderer that returns an &lt;a href=&quot;../renderer&quot;&gt;ActionView::Renderer&lt;/a&gt; object.</source>
          <target state="translated">뷰 컨텍스트에서 렌더링 할 수있는 메소드를 구현합니다. 이 모듈을 사용하려면 &lt;a href=&quot;../renderer&quot;&gt;ActionView :: Renderer&lt;/a&gt; 객체 를 반환하는 view_renderer를 구현하기 만하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="fb34f57d9f45ca19922ff88964fd579af0905627" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;&lt;code&gt;ActiveSupport::LogSubscriber&lt;/code&gt;&lt;/a&gt; for logging notifications when email is delivered or received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24ec6605d9328a8008364cc4c4f420581b79a4a9" translate="yes" xml:space="preserve">
          <source>Implements the &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport::LogSubscriber&lt;/a&gt; for logging notifications when email is delivered or received.</source>
          <target state="translated">전자 메일이 배달되거나 수신 될 때 알림을 기록하기 위해 &lt;a href=&quot;../activesupport/logsubscriber&quot;&gt;ActiveSupport :: LogSubscriber&lt;/a&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="52d6a97892d78e3ae869c7ed2c900dea4e6ebf61" translate="yes" xml:space="preserve">
          <source>Implements the logic behind &lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt;. See &lt;code&gt;rails notes --help&lt;/code&gt; for usage information.</source>
          <target state="translated">&lt;code&gt;Rails::Command::NotesCommand&lt;/code&gt; 의 논리를 구현합니다 . 사용법 정보는 &lt;code&gt;rails notes --help&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35d2e815ecf5eaeaf9463f97d49b56bdcf2cedef" translate="yes" xml:space="preserve">
          <source>Implicit Controller Namespacing</source>
          <target state="translated">암시 적 컨트롤러 이름 간격</target>
        </trans-unit>
        <trans-unit id="cc812dcbced753eec4dd16100a96e45f4f64caaa" translate="yes" xml:space="preserve">
          <source>Implicit dependencies</source>
          <target state="translated">암시 적 종속성</target>
        </trans-unit>
        <trans-unit id="4bc21b467c16e56b3af4d8560fc26cb749a105d4" translate="yes" xml:space="preserve">
          <source>Implicit template rendering is not performed if any attachments or parts have been added to the email. This means that you'll have to manually add each part to the email and set the content type of the email to &lt;code&gt;multipart/alternative&lt;/code&gt;.</source>
          <target state="translated">전자 메일에 첨부 파일이나 부품이 추가 된 경우 암시 적 템플릿 렌더링이 수행되지 않습니다. 즉, 전자 메일에 각 부분을 수동으로 추가하고 전자 메일의 콘텐츠 유형을 &lt;code&gt;multipart/alternative&lt;/code&gt; 로 설정해야 합니다.</target>
        </trans-unit>
        <trans-unit id="4cf6d21cc8c3ec4dc1b9b1edae7488384d03d30c" translate="yes" xml:space="preserve">
          <source>ImplicitRender</source>
          <target state="translated">ImplicitRender</target>
        </trans-unit>
        <trans-unit id="3d2d2635705b855d27d1c5bd73bf96ce3799876d" translate="yes" xml:space="preserve">
          <source>Imports one error Imported errors are wrapped as a &lt;code&gt;NestedError&lt;/code&gt;, providing access to original error object. If attribute or type needs to be overridden, use `override_options`.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1638a243bdb748019bd32183a25a00764fdfe7e" translate="yes" xml:space="preserve">
          <source>Improper abstraction is shown in the following example, where assumptions are made about the ordering of the different parts of the translation. Note that Rails provides a &lt;code&gt;number_to_currency&lt;/code&gt; helper to handle the following case.</source>
          <target state="translated">번역의 다른 부분의 순서에 대한 가정이 만들어지는 다음 예에서 부적절한 추상화가 표시됩니다. Rails는 다음과 같은 경우를 처리하기 위해 &lt;code&gt;number_to_currency&lt;/code&gt; 도우미를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="b4edada1c33243e7a60cafa702c1fa2b5346336b" translate="yes" xml:space="preserve">
          <source>Improving Engine Functionality</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25277a4e2d3aab7b020dc767c1fa2cdd12889e2b" translate="yes" xml:space="preserve">
          <source>Improving engine functionality</source>
          <target state="translated">엔진 기능 향상</target>
        </trans-unit>
        <trans-unit id="fae9a341e3cc54b88e5881c130771b3562076a34" translate="yes" xml:space="preserve">
          <source>In 2007 there was the first tailor-made trojan which stole information from an Intranet, namely the &quot;Monster for employers&quot; web site of Monster.com, an online recruitment web application. Tailor-made Trojans are very rare, so far, and the risk is quite low, but it is certainly a possibility and an example of how the security of the client host is important, too. However, the highest threat to Intranet and Admin applications are XSS and CSRF.</source>
          <target state="translated">2007 년에는 인트라넷, 즉 온라인 채용 웹 응용 프로그램 인 Monster.com의 &quot;Monster for 고용주&quot;웹 사이트에서 정보를 훔친 맞춤형 트로이 목마가있었습니다. 맞춤형 트로이 목마는 지금까지 매우 드물고 위험은 매우 낮지 만 클라이언트 호스트의 보안도 중요한 예일 것입니다. 그러나 인트라넷 및 관리 응용 프로그램에 가장 큰 위협은 XSS 및 CSRF입니다.</target>
        </trans-unit>
        <trans-unit id="fc7c9b4dd5293be1bf0f252a2fee26c14cfe6fc5" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;:classic&lt;/code&gt; mode, interprets a file using &lt;code&gt;mechanism&lt;/code&gt; and marks its defined constants as autoloaded. &lt;code&gt;file_name&lt;/code&gt; can be either a string or respond to &lt;code&gt;to_path&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2d2960eda43e199d87786a86c8eb2c1cc77a5f7" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;:classic&lt;/code&gt; mode, use this method in code that absolutely needs a certain constant to be defined at that point. A typical use case is to make constant name resolution deterministic for constants with the same relative name in different namespaces whose evaluation would depend on load order otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1731e845f49ee922cd9653e1128098f4406bb00" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;app/models/article.rb&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="459e6a935c80dde6e06ed67fe83a90bd9883c215" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode you could technically define several constants at the same top-level and have them all reloaded. For example, given</source>
          <target state="translated">&lt;code&gt;classic&lt;/code&gt; 모드 에서는 기술적으로 동일한 최상위에서 여러 상수를 정의하고 모두 다시로드 할 수 있습니다. 예를 들어, 주어진</target>
        </trans-unit>
        <trans-unit id="95995cd00675017cc92602b8ceb9042f3111bbb1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode, every single missing constant triggers a file lookup that walks the autoload paths.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1349ddfca7a6dc44a435938d98d30b1e8a02dc04" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode, given a missing constant Rails &lt;em&gt;underscores&lt;/em&gt; its name and performs a file lookup. On the other hand, &lt;code&gt;zeitwerk&lt;/code&gt; mode checks first the file system, and &lt;em&gt;camelizes&lt;/em&gt; file names to know the constant those files are expected to define.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="542cf5e02cd8fb77390910ad4c46d85ca2ae6998" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;classic&lt;/code&gt; mode, if &lt;code&gt;app/models/foo.rb&lt;/code&gt; defines &lt;code&gt;Bar&lt;/code&gt;, you won't be able to autoload that file, but eager loading will work because it loads files recursively blindly. This can be a source of errors if you test things first eager loading, execution may fail later autoloading.</source>
          <target state="translated">에서 &lt;code&gt;classic&lt;/code&gt; 모드, 경우 &lt;code&gt;app/models/foo.rb&lt;/code&gt; 정의하는 &lt;code&gt;Bar&lt;/code&gt; , 해당 파일을 자동로드 할 수 없습니다, 그러나 반복적으로 맹목적으로 파일을로드하기 때문에 열망로드 작동합니다. 처음 열망하는 로딩을 테스트하면 나중에 오류가 발생할 수 있습니다. 나중에 자동 로딩이 실행되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0c8108a5c9ee6932aeb4bd9a770d0dfa0e4b1c8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/application.rb&lt;/code&gt; add the following line at the top of the &lt;code&gt;Application&lt;/code&gt; class definition:</source>
          <target state="translated">에서 &lt;code&gt;config/application.rb&lt;/code&gt; 의 맨 위에 다음 줄을 추가 &lt;code&gt;Application&lt;/code&gt; 클래스 정의 :</target>
        </trans-unit>
        <trans-unit id="038e4733f3293952f2c69b8c06c72d61d56cd4cf" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, place the following line:</source>
          <target state="translated">에서 &lt;code&gt;config/environments/development.rb&lt;/code&gt; , 다음 줄을 배치합니다 :</target>
        </trans-unit>
        <trans-unit id="19a666179d9c9c5c55b760fb4bd295bdd2019cf2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/environments/development.rb&lt;/code&gt;, set &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; to configure the format used in responses when errors occur in development mode.</source>
          <target state="translated">에서 &lt;code&gt;config/environments/development.rb&lt;/code&gt; , 세트 &lt;code&gt;config.debug_exception_response_format&lt;/code&gt; 오류가 개발 모드에서 발생할 때 응답에 사용되는 형식을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1432a9900cff26dddc3080234094b35f280b42a8" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;config/routes.rb&lt;/code&gt; you define URL-to-controller mappings, but the reverse is also possible: a URL can be generated from one of your routing definitions. URL generation functionality is centralized in this module.</source>
          <target state="translated">에서 &lt;code&gt;config/routes.rb&lt;/code&gt; 당신이 URL - 컨트롤러 매핑을 정의하지만, 그 반대도 가능하다 : URL이 라우팅 정의 중 하나를 생성 할 수 있습니다. URL 생성 기능은이 모듈에서 중앙 집중식입니다.</target>
        </trans-unit>
        <trans-unit id="1642945971bc58efcad1099a8a64f5268eb8322c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;lib/yaffle.rb&lt;/code&gt;, add &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt;:</source>
          <target state="translated">에서 &lt;code&gt;lib/yaffle.rb&lt;/code&gt; , 추가 &lt;code&gt;require &quot;yaffle/core_ext&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e232716b6d62b50c947b184953eae7d056f56191" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode both loading modes are consistent, they fail and err in the same files.</source>
          <target state="translated">에서 &lt;code&gt;zeitwerk&lt;/code&gt; 모두 로딩 모드가 일치 모드, 그들은 같은 파일에 실패하고 ERR.</target>
        </trans-unit>
        <trans-unit id="d3dd0eb81a86f2c2f3bad5fac62f63aebeb475e1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode that does not matter anymore, you can pick either style.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="475e400522788225e1d381351d350faa5bf84e7b" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode there is only one pass. That pass is done once, not per missing constant, and so it is generally more performant. Subdirectories are visited only if their namespace is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d065b1ebff8f04c244d50631e2955f610e34b0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode you'd do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e673fd939bb83dbf33354669755b6f6e9fd442c0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;zeitwerk&lt;/code&gt; mode, Rails uses &lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt; internally to autoload, reload, and eager load. Rails instantiates and configures a dedicated Zeitwerk instance that manages the project.</source>
          <target state="translated">에서는 &lt;code&gt;zeitwerk&lt;/code&gt; 모드 사용 레일 &lt;a href=&quot;https://github.com/fxn/zeitwerk&quot;&gt;Zeitwerk&lt;/a&gt; 자동로드, 장전하고 싶어 부하 내부적. Rails는 프로젝트를 관리하는 전용 Zeitwerk 인스턴스를 인스턴스화하고 구성합니다.</target>
        </trans-unit>
        <trans-unit id="71ea6f7b46d9cf92e4933e28e9d6bba26cdba1a8" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;development&lt;/strong&gt;, you want quicker startup with incremental loading of application code. So &lt;code&gt;eager_load&lt;/code&gt; should be set to &lt;code&gt;false&lt;/code&gt;, and Rails will autoload files as needed (see &lt;a href=&quot;#autoloading-algorithms&quot;&gt;Autoloading Algorithms&lt;/a&gt; below) -- and then reload them when they change (see &lt;a href=&quot;#constant-reloading&quot;&gt;Constant Reloading&lt;/a&gt; below).</source>
          <target state="translated">에서 &lt;strong&gt;개발&lt;/strong&gt; , 당신은 응용 프로그램 코드의 증가 로딩 빨리 시작합니다. 따라서 &lt;code&gt;eager_load&lt;/code&gt; 는 &lt;code&gt;false&lt;/code&gt; 로 설정해야하며 Rails는 필요에 따라 파일을 &lt;a href=&quot;#autoloading-algorithms&quot;&gt;자동&lt;/a&gt; 로드하고 (아래의 자동로드 알고리즘 참조) 파일이 변경되면 다시로드합니다 (아래의 &lt;a href=&quot;#constant-reloading&quot;&gt;상수 다시로드&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="0f72170ee1c24d4c865ecf78482068999436ea7a" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;production&lt;/strong&gt;, however, you want consistency and thread-safety and can live with a longer boot time. So &lt;code&gt;eager_load&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, and then during boot (before the app is ready to receive requests) Rails loads all files in the &lt;code&gt;eager_load_paths&lt;/code&gt; and then turns off auto loading (NB: autoloading may be needed during eager loading). Not autoloading after boot is a &lt;code&gt;good thing&lt;/code&gt;, as autoloading can cause the app to be have thread-safety problems.</source>
          <target state="translated">그러나 &lt;strong&gt;프로덕션 환경&lt;/strong&gt; 에서는 일관성과 스레드 안전성을 원하며 부팅 시간이 길어질 수 있습니다. 따라서 &lt;code&gt;eager_load&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 로 설정된 다음 부팅하는 동안 (앱이 요청을 수신 할 준비가되기 전에) Rails는 &lt;code&gt;eager_load_paths&lt;/code&gt; 에있는 모든 파일을로드 한 다음 자동로드를 끕니다 (NB : 자동로드가 열릴 때 필요할 수 있음). 자동로드 로 인해 앱에 스레드 안전성 문제가 발생할 수 있으므로 부팅 후 자동로드하지 않는 &lt;code&gt;good thing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c28ff993dbf54f038d30ddbc48a5e0c6ba367dbe" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;production&lt;/strong&gt;, however, you want consistency and thread-safety and can live with a longer boot time. So &lt;code&gt;eager_load&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, and then during boot (before the app is ready to receive requests) Rails loads all files in the &lt;code&gt;eager_load_paths&lt;/code&gt; and then turns off auto loading (NB: autoloading may be needed during eager loading). Not autoloading after boot is a &lt;code&gt;good thing&lt;/code&gt;, as autoloading can cause the app to have thread-safety problems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f92b7014d8bd1687e9d67744b5d5dbfdfdc69342" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;test&lt;/strong&gt;, for speed of execution (of individual tests) &lt;code&gt;eager_load&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, so Rails follows development behaviour.</source>
          <target state="translated">&lt;strong&gt;test&lt;/strong&gt; 에서는 개별 테스트의 실행 속도에 대해 &lt;code&gt;eager_load&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 이므로 Rails는 개발 동작을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="64bc7c7244baf7a888ec03c60f63bef901cae7ee" translate="yes" xml:space="preserve">
          <source>In App</source>
          <target state="translated">앱에서</target>
        </trans-unit>
        <trans-unit id="da5d6eae39d42acaf080e6551490223f993953d3" translate="yes" xml:space="preserve">
          <source>In December 2006, 34,000 actual user names and passwords were stolen in a &lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace phishing attack&lt;/a&gt;. The idea of the attack was to create a profile page named &quot;login_home_index_html&quot;, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.</source>
          <target state="translated">2006 년 12 월 &lt;a href=&quot;http://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace 피싱 공격&lt;/a&gt; 에서 34,000 개의 실제 사용자 이름과 암호가 도난당했습니다 . 이 공격의 아이디어는 &quot;login_home_index_html&quot;이라는 프로필 페이지를 만드는 것이 었으므로 URL은 매우 설득력있게 보였습니다. 특수 제작 된 HTML 및 CSS를 사용하여 페이지에서 실제 MySpace 내용을 숨기고 대신 고유 한 로그인 양식을 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="9413aed7f1c9b4ae2c5ea66dfe9bf55303fc2980" translate="yes" xml:space="preserve">
          <source>In December 2006, 34,000 actual user names and passwords were stolen in a &lt;a href=&quot;https://news.netcraft.com/archives/2006/10/27/myspace_accounts_compromised_by_phishers.html&quot;&gt;MySpace phishing attack&lt;/a&gt;. The idea of the attack was to create a profile page named &quot;login_home_index_html&quot;, so the URL looked very convincing. Specially-crafted HTML and CSS was used to hide the genuine MySpace content from the page and instead display its own login form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95a2bb9868cd89f678d0493fad1f8fb986cade2e" translate="yes" xml:space="preserve">
          <source>In Development</source>
          <target state="translated">개발 중</target>
        </trans-unit>
        <trans-unit id="465280a3f4d120ddf717e03ed4ad4332c4473248" translate="yes" xml:space="preserve">
          <source>In JavaScript files, Sprockets directives begin with &lt;code&gt;//=&lt;/code&gt;. In the above case, the file is using the &lt;code&gt;require&lt;/code&gt; and the &lt;code&gt;require_tree&lt;/code&gt; directives. The &lt;code&gt;require&lt;/code&gt; directive is used to tell Sprockets the files you wish to require. Here, you are requiring the files &lt;code&gt;rails-ujs.js&lt;/code&gt; and &lt;code&gt;turbolinks.js&lt;/code&gt; that are available somewhere in the search path for Sprockets. You need not supply the extensions explicitly. Sprockets assumes you are requiring a &lt;code&gt;.js&lt;/code&gt; file when done from within a &lt;code&gt;.js&lt;/code&gt; file.</source>
          <target state="translated">JavaScript 파일에서 Sprockets 지시문은 &lt;code&gt;//=&lt;/code&gt; 로 시작합니다 . 위의 경우 파일은 &lt;code&gt;require&lt;/code&gt; 및 &lt;code&gt;require_tree&lt;/code&gt; 지시문을 사용합니다. 이 &lt;code&gt;require&lt;/code&gt; 지시어는 톱니에게 필요한하고자하는 파일을 얘기하는 데 사용됩니다. 여기, Sprockets 검색 경로 어딘가에있는 &lt;code&gt;rails-ujs.js&lt;/code&gt; 및 &lt;code&gt;turbolinks.js&lt;/code&gt; 파일이 필요합니다 . 확장명을 명시 적으로 제공 할 필요는 없습니다. 톱니는 당신이 필요로하는 가정 &lt;code&gt;.js&lt;/code&gt; 내에서 수행 할 때 파일 &lt;code&gt;.js&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="03f18111b3979ea4cddec4b3d6254c6c8812f51e" translate="yes" xml:space="preserve">
          <source>In Production</source>
          <target state="translated">생산 중</target>
        </trans-unit>
        <trans-unit id="881b52a0818476cf9a85f46aa68f0a3a1628f652" translate="yes" xml:space="preserve">
          <source>In Rails 3.0 and above, generators don't just look in the source root for templates, they also search for templates in other paths. And one of them is &lt;code&gt;lib/templates&lt;/code&gt;. Since we want to customize &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;, we can do that by simply making a template copy inside &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; with the name &lt;code&gt;helper.rb&lt;/code&gt;. So let's create that file with the following content:</source>
          <target state="translated">Rails 3.0 이상에서 제너레이터는 소스 루트에서 템플릿을 찾을뿐만 아니라 다른 경로에서 템플릿을 검색합니다. 그리고 그들 중 하나는 &lt;code&gt;lib/templates&lt;/code&gt; 입니다. 우리는 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; 를 커스터마이징하기를 원하기 때문에 &lt;code&gt;lib/templates/rails/helper&lt;/code&gt; 안에 &lt;code&gt;helper.rb&lt;/code&gt; 라는 이름 으로 템플릿을 복사 하면 됩니다. 다음과 같은 내용으로 해당 파일을 만들어 봅시다.</target>
        </trans-unit>
        <trans-unit id="3d701b2dca3add4cb90f7c327e5b34c565ff6209" translate="yes" xml:space="preserve">
          <source>In Rails 4.0 when a column or a table is renamed the related indexes are also renamed. If you have migrations which rename the indexes, they are no longer needed.</source>
          <target state="translated">Rails 4.0에서 열 또는 테이블의 이름이 변경되면 관련 인덱스의 이름도 변경됩니다. 인덱스 이름을 바꾸는 마이그레이션이 있으면 더 이상 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1adb17f63f770a578c9bd8dceb71a192376252bb" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; is raised when the action doesn't handle the request format. By default, the exception is handled by responding with 406 Not Acceptable, but you can override that now. In Rails 3, 406 Not Acceptable was always returned. No overrides.</source>
          <target state="translated">Rails 4.0에서는 액션이 요청 형식을 처리하지 않으면 &lt;code&gt;ActionController::UnknownFormat&lt;/code&gt; 이 발생합니다. 기본적으로 예외는 406 Not Acceptable로 응답하여 처리되지만 지금은이를 무시할 수 있습니다. Rails 3에서는 406 Not Acceptable이 항상 반환되었습니다. 무시하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8c55c03013f5a72f0bf3f4390ebed968b1b748e" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, &lt;code&gt;SCRIPT_NAME&lt;/code&gt; is properly nested when engines are mounted on an app that's served from a URL prefix. You no longer have to set &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; to work around overwritten URL prefixes.</source>
          <target state="translated">Rails 4.0에서 &lt;code&gt;SCRIPT_NAME&lt;/code&gt; 은 URL 접두사에서 제공되는 앱에 엔진이 마운트 될 때 올바르게 중첩됩니다. 덮어 쓴 URL 접두사를 해결하기 위해 더 이상 &lt;code&gt;default_url_options[:script_name]&lt;/code&gt; 을 설정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fbd697524f2577109c25789402e832c69d562e7a" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, a generic &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; exception is raised when &lt;code&gt;ParamsParser&lt;/code&gt; fails to parse request params. You will want to rescue this exception instead of the low-level &lt;code&gt;MultiJson::DecodeError&lt;/code&gt;, for example.</source>
          <target state="translated">Rails 4.0에서는 &lt;code&gt;ParamsParser&lt;/code&gt; 가 요청 매개 변수를 구문 분석하지 못하면 일반 &lt;code&gt;ActionDispatch::ParamsParser::ParseError&lt;/code&gt; 예외가 발생 합니다. 예를 들어, 하위 레벨 &lt;code&gt;MultiJson::DecodeError&lt;/code&gt; 대신이 예외를 해결하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="2a1b06b5dc0aa44b96b3b0146a540533fa23c8d9" translate="yes" xml:space="preserve">
          <source>In Rails 4.0, precompiling assets no longer automatically copies non-JS/CSS assets from &lt;code&gt;vendor/assets&lt;/code&gt; and &lt;code&gt;lib/assets&lt;/code&gt;. Rails application and engine developers should put these assets in &lt;code&gt;app/assets&lt;/code&gt; or configure &lt;code&gt;config.assets.precompile&lt;/code&gt;.</source>
          <target state="translated">Rails 4.0에서는 사전 컴파일 링 자산이 더 이상 &lt;code&gt;vendor/assets&lt;/code&gt; 및 &lt;code&gt;lib/assets&lt;/code&gt; 에서 비 JS / CSS 자산을 자동으로 복사하지 않습니다 . Rails 애플리케이션 및 엔진 개발자는 이러한 자산을 &lt;code&gt;app/assets&lt;/code&gt; 에 배치 하거나 &lt;code&gt;config.assets.precompile&lt;/code&gt; 을 구성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e790cb94a07686a3cdc4c05781a0fcaefa57d168" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Job inherits from &lt;code&gt;ActiveJob::Base&lt;/code&gt;. In Rails 5.0, this behavior has changed to now inherit from &lt;code&gt;ApplicationJob&lt;/code&gt;.</source>
          <target state="translated">Rails 4.2에서 활성 작업은 &lt;code&gt;ActiveJob::Base&lt;/code&gt; 에서 상속받습니다 . Rails 5.0에서는이 동작이 &lt;code&gt;ApplicationJob&lt;/code&gt; 에서 상속되도록 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3dd8df2469bc7ba82d934c36883ac1e21582a46d" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, an Active Record model inherits from &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. In Rails 5.0, all models inherit from &lt;code&gt;ApplicationRecord&lt;/code&gt;.</source>
          <target state="translated">Rails 4.2에서 Active Record 모델은 &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 에서 상속받습니다 . Rails 5.0에서는 모든 모델이 &lt;code&gt;ApplicationRecord&lt;/code&gt; 에서 상속됩니다 .</target>
        </trans-unit>
        <trans-unit id="439d6d805d6bd1ed63fe14cf4cd328905a76b44e" translate="yes" xml:space="preserve">
          <source>In Rails 4.2, when a 'before' callback returns &lt;code&gt;false&lt;/code&gt; in Active Record and Active Model, then the entire callback chain is halted. In other words, successive 'before' callbacks are not executed, and neither is the action wrapped in callbacks.</source>
          <target state="translated">Rails 4.2 에서 Active Record와 Active Model에서 'before'콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 전체 콜백 체인이 정지됩니다. 즉, 연속적인 '이전'콜백은 실행되지 않으며 콜백으로 래핑 된 작업도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7dce1a93bbd29712f2b1ec669334dfd3205ce7be" translate="yes" xml:space="preserve">
          <source>In Rails 5, the default log level for the production environment will be changed to &lt;code&gt;:debug&lt;/code&gt; (from &lt;code&gt;:info&lt;/code&gt;). To preserve the current default, add the following line to your &lt;code&gt;production.rb&lt;/code&gt;:</source>
          <target state="translated">Rails 5에서 프로덕션 환경의 기본 로그 레벨은 &lt;code&gt;:debug&lt;/code&gt; (from &lt;code&gt;:info&lt;/code&gt; ) 로 변경됩니다 . 현재 기본값을 유지하려면 &lt;code&gt;production.rb&lt;/code&gt; 에 다음 줄을 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a17e8569da075383aacc8ee0799bf2cfe2223ce" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, how JSON/JSONB attributes are serialized and deserialized changed. Now, if you set a column equal to a &lt;code&gt;String&lt;/code&gt;, Active Record will no longer turn that string into a &lt;code&gt;Hash&lt;/code&gt;, and will instead only return the string. This is not limited to code interacting with models, but also affects &lt;code&gt;:default&lt;/code&gt; column settings in &lt;code&gt;db/schema.rb&lt;/code&gt;. It is recommended that you do not set columns equal to a &lt;code&gt;String&lt;/code&gt;, but pass a &lt;code&gt;Hash&lt;/code&gt; instead, which will be converted to and from a JSON string automatically.</source>
          <target state="translated">Rails 5.0에서는 JSON / JSONB 속성이 직렬화되고 역 직렬화되는 방식이 변경되었습니다. 이제 열을 &lt;code&gt;String&lt;/code&gt; 과 동일하게 설정하면 Active Record는 더 이상 해당 문자열을 &lt;code&gt;Hash&lt;/code&gt; 로 바꾸지 않고 대신 문자열 만 반환합니다. 이는 모델과 상호 작용하는 코드에만 국한되지 않고 &lt;code&gt;db/schema.rb&lt;/code&gt; 의 &lt;code&gt;:default&lt;/code&gt; 열 설정 에도 영향을줍니다 . 열을 &lt;code&gt;String&lt;/code&gt; 과 동일하게 설정하지 말고 대신 &lt;code&gt;Hash&lt;/code&gt; 를 전달 하면 JSON 문자열과 자동으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8805a6baac81772ba5bc008724fb0e7b03fcbd7c" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, returning &lt;code&gt;false&lt;/code&gt; in an Active Record or Active Model callback will not have this side effect of halting the callback chain. Instead, callback chains must be explicitly halted by calling &lt;code&gt;throw(:abort)&lt;/code&gt;.</source>
          <target state="translated">Rails 5.0 에서, Active Record 또는 Active Model 콜백에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 콜백 체인을 정지시키는 부작용이 없습니다. 대신 &lt;code&gt;throw(:abort)&lt;/code&gt; 호출하여 콜백 체인을 명시 적으로 중지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ccfc486350477735c33b236b56a8f69a4fcc517" translate="yes" xml:space="preserve">
          <source>In Rails 5.0, test cases will be executed in random order by default. In anticipation of this change, Rails 4.2 introduced a new configuration option &lt;code&gt;active_support.test_order&lt;/code&gt; for explicitly specifying the test ordering. This allows you to either lock down the current behavior by setting the option to &lt;code&gt;:sorted&lt;/code&gt;, or opt into the future behavior by setting the option to &lt;code&gt;:random&lt;/code&gt;.</source>
          <target state="translated">Rails 5.0에서는 테스트 케이스가 기본적으로 무작위 순서로 실행됩니다. 이러한 변경을 예상하여 Rails 4.2 는 테스트 순서를 명시 적으로 지정하기위한 새로운 구성 옵션 &lt;code&gt;active_support.test_order&lt;/code&gt; 를 도입했습니다 . 이를 통해 옵션을 &lt;code&gt;:sorted&lt;/code&gt; 로 설정하여 현재 동작을 잠 그거나 옵션을 &lt;code&gt;:random&lt;/code&gt; 으로 설정하여 향후 동작을 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b0c195e1af271ce415b466ef143019d7676d6f1" translate="yes" xml:space="preserve">
          <source>In Rails 5.2, assigning to a collection of attachments declared with &lt;code&gt;has_many_attached&lt;/code&gt; appended new files:</source>
          <target state="translated">Rails 5.2에서 &lt;code&gt;has_many_attached&lt;/code&gt; 로 선언 된 첨부 파일 컬렉션에 할당 된 새 파일 :</target>
        </trans-unit>
        <trans-unit id="323b3790573a5c2bed5163a9188184a0d5222ca7" translate="yes" xml:space="preserve">
          <source>In Rails 6.0 and 5.2, all forms using &lt;code&gt;form_with&lt;/code&gt; implement &lt;code&gt;remote: true&lt;/code&gt; by default. These forms will submit data using an XHR (Ajax) request. To disable this include &lt;code&gt;local: true&lt;/code&gt;. To dive deeper see &lt;a href=&quot;working_with_javascript_in_rails#remote-elements&quot;&gt;Working with JavaScript in Rails&lt;/a&gt; guide.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a698bc816989ce5323baf985bfad4f137d42be82" translate="yes" xml:space="preserve">
          <source>In Rails 6.1 it's possible to switch connections for one database instead of all databases globally. To use this feature you must first set &lt;code&gt;config.active_record.legacy_connection_handling&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; in your application configuration. The majority of applications should not need to make any other changes since the public APIs have the same behavior.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc3d019408ba13aa9c4b4955b524de0dd29f745" translate="yes" xml:space="preserve">
          <source>In Rails apps, this middleware is configured to serve assets from the &lt;code&gt;public/&lt;/code&gt; directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6731ddb55b6a64f0e9f7cfc11759cdbf65ec568" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs and controller actions. By convention, each action also maps to particular CRUD operations in a database. A single entry in the routing file, such as</source>
          <target state="translated">Rails에서 유용한 경로는 HTTP 동사와 URL과 컨트롤러 작업 간의 매핑을 제공합니다. 일반적으로 각 작업은 데이터베이스의 특정 CRUD 작업에도 매핑됩니다. 라우팅 파일의 단일 항목 (예 :</target>
        </trans-unit>
        <trans-unit id="a77466629531af636135628e6426524916605e5c" translate="yes" xml:space="preserve">
          <source>In Rails, a resourceful route provides a mapping between HTTP verbs and URLs to controller actions. By convention, each action also maps to a specific CRUD operation in a database. A single entry in the routing file, such as:</source>
          <target state="translated">Rails에서 유용한 경로는 HTTP 동사와 URL을 컨트롤러 작업에 매핑합니다. 일반적으로 각 작업은 데이터베이스의 특정 CRUD 작업에 매핑됩니다. 라우팅 파일에서 다음과 같은 단일 항목 :</target>
        </trans-unit>
        <trans-unit id="8c3a8caddd6cd9e897f742a979983edd518e3c9b" translate="yes" xml:space="preserve">
          <source>In Rails, an &lt;em&gt;association&lt;/em&gt; is a connection between two Active Record models. Why do we need associations between models? Because they make common operations simpler and easier in your code. For example, consider a simple Rails application that includes a model for authors and a model for books. Each author can have many books. Without associations, the model declarations would look like this:</source>
          <target state="translated">레일에서, &lt;em&gt;협회는&lt;/em&gt; 두 개의 액티브 레코드 모델 사이의 연결입니다. 왜 모델 사이에 연관이 필요합니까? 코드에서 일반적인 작업을 더 간단하고 쉽게 할 수 있기 때문입니다. 예를 들어, 저자 모델과 책 모델을 포함하는 간단한 Rails 애플리케이션을 생각해보십시오. 각 저자는 많은 책을 가질 수 있습니다. 연관이 없으면 모델 선언은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56e83cf4d25c00dd476d47cc56bf04c7705eec09" translate="yes" xml:space="preserve">
          <source>In Rails, testing the various actions of a controller is a form of writing functional tests. Remember your controllers handle the incoming web requests to your application and eventually respond with a rendered view. When writing functional tests, you are testing how your actions handle the requests and the expected result or response, in some cases an HTML view.</source>
          <target state="translated">Rails에서 컨트롤러의 다양한 동작 테스트는 기능 테스트 작성의 한 형태입니다. 컨트롤러는 애플리케이션으로 들어오는 웹 요청을 처리하고 결국 렌더링 된 뷰로 응답합니다. 기능 테스트를 작성할 때 조치가 요청 및 예상 결과 또는 응답 (일부 경우 HTML보기)을 처리하는 방법을 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="0d6b371170194bc0f26caa23ed54b666ace3efba" translate="yes" xml:space="preserve">
          <source>In Rails, this is usually achieved by creating the form using &lt;code&gt;form_for&lt;/code&gt; and a number of related helper methods. &lt;code&gt;form_for&lt;/code&gt; generates an appropriate &lt;code&gt;form&lt;/code&gt; tag and yields a form builder object that knows the model the form is about. Input fields are created by calling methods defined on the form builder, which means they are able to generate the appropriate names and default values corresponding to the model attributes, as well as convenient IDs, etc. Conventions in the generated field names allow controllers to receive form data nicely structured in &lt;code&gt;params&lt;/code&gt; with no effort on your side.</source>
          <target state="translated">Rails에서는 일반적으로 &lt;code&gt;form_for&lt;/code&gt; 및 여러 관련 헬퍼 메소드를 사용하여 양식을 작성합니다 . &lt;code&gt;form_for&lt;/code&gt; 는 적절한 &lt;code&gt;form&lt;/code&gt; 태그를 생성하고 양식의 모델을 알고있는 양식 작성기 객체를 생성합니다. 입력 필드는 양식 빌더에 정의 된 메소드를 호출하여 작성됩니다. 즉, 모델 ID에 해당하는 적절한 이름과 기본값 및 편리한 ID 등을 생성 할 수 있습니다. 생성 된 필드 이름의 규칙은 컨트롤러가 수신 할 수 있도록합니다. 당신의 노력없이 &lt;code&gt;params&lt;/code&gt; 로 잘 구조화 된 양식 데이터 .</target>
        </trans-unit>
        <trans-unit id="ecb88f5d832e7f6682e1a0ae438d564ee40bc97a" translate="yes" xml:space="preserve">
          <source>In Rails, web requests are handled by &lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt; and Action View. Typically, Action Controller is concerned with communicating with the database and performing CRUD actions where necessary. Action View is then responsible for compiling the response.</source>
          <target state="translated">Rails에서 웹 요청은 &lt;a href=&quot;action_controller_overview&quot;&gt;Action Controller&lt;/a&gt; 및 Action View에 의해 처리됩니다 . 일반적으로 Action Controller는 데이터베이스와 통신하고 필요한 경우 CRUD 조치를 수행합니다. 그런 다음 조치보기는 응답을 컴파일합니다.</target>
        </trans-unit>
        <trans-unit id="0f84e8f7f3343be9781b8755e807fc7655f5753f" translate="yes" xml:space="preserve">
          <source>In Ruby &amp;lt; 2.5 &lt;code&gt;String::Hash&lt;/code&gt; evaluates to &lt;code&gt;Hash&lt;/code&gt; and the interpreter issues a warning: &quot;toplevel constant Hash referenced by String::Hash&quot;. Starting with 2.5, &lt;code&gt;String::Hash&lt;/code&gt; raises &lt;code&gt;NameError&lt;/code&gt; because &lt;code&gt;Object&lt;/code&gt; is skipped.</source>
          <target state="translated">루비에서 &amp;lt;2.5 &lt;code&gt;String::Hash&lt;/code&gt; 로 평가 &lt;code&gt;Hash&lt;/code&gt; 및 통역 문제 경고 : &quot;문자열 :: 해시에 의해 참조 최상위 상수 해시&quot;. 2.5부터 &lt;code&gt;String::Hash&lt;/code&gt; 제기 &lt;code&gt;NameError&lt;/code&gt; 하기 때문에 &lt;code&gt;Object&lt;/code&gt; 를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="a7a30f953cf4d0929d1f4865a5b10c5e1cf44ed0" translate="yes" xml:space="preserve">
          <source>In a Rails application file names have to match the constants they define, with directories acting as namespaces.</source>
          <target state="translated">Rails 애플리케이션에서 파일 이름은 네임 스페이스 역할을하는 디렉토리와 함께 정의한 상수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="f7eee8371ad89288909147fa07191ccefaa0c267" translate="yes" xml:space="preserve">
          <source>In a Rails application, add or remove analyzers by manipulating &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; in an initializer:</source>
          <target state="translated">Rails 애플리케이션 에서 초기화 &lt;code&gt;Rails.application.config.active_storage.analyzers&lt;/code&gt; 에서 Rails.application.config.active_storage.analyzer 를 조작하여 분석기를 추가하거나 제거하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a649535c68318d0351721556f40ef23a6e164f7" translate="yes" xml:space="preserve">
          <source>In a Rails application, these steps are conventionally handled by a controller's &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt; actions. Let's add a typical implementation of these actions to &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt;, below the &lt;code&gt;show&lt;/code&gt; action:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a752f21ee54a6f792635342e300e65ca1f47dbd3" translate="yes" xml:space="preserve">
          <source>In a Rails console there is no file watcher active regardless of the value of &lt;code&gt;config.cache_classes&lt;/code&gt;. This is so because, normally, it would be confusing to have code reloaded in the middle of a console session, the same way you generally want an individual request to be served by a consistent, non-changing set of application classes and modules.</source>
          <target state="translated">Rails 콘솔에는 &lt;code&gt;config.cache_classes&lt;/code&gt; 값에 관계없이 활성화 된 파일 감시자가 없습니다 . 일반적으로 콘솔 세션 중간에 코드를 다시로드하는 것이 혼란 스럽기 때문에 일관되고 변경되지 않는 응용 프로그램 클래스 및 모듈 세트에서 개별 요청을 처리하는 것과 같은 방식입니다.</target>
        </trans-unit>
        <trans-unit id="271d126f8c9e0941ba1c5dcf24c8eee1adaeb3af" translate="yes" xml:space="preserve">
          <source>In a default Rails application, the Executor callbacks are used to:</source>
          <target state="translated">기본 Rails 애플리케이션에서 Executor 콜백은 다음을 수행하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d71410f0f203089ccf4c45cdf30ed27eaa7be105" translate="yes" xml:space="preserve">
          <source>In a given request, the method is not actually called for every single generated URL. For performance reasons, the returned hash is cached, and there is at most one invocation per request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a1f399aa9a761173b4354a91df7a1e6d6783267" translate="yes" xml:space="preserve">
          <source>In a given request, the method is not actually called for every single generated URL; for performance reasons, the returned hash is cached, there is at most one invocation per request.</source>
          <target state="translated">주어진 요청에서, 메소드는 실제로 생성 된 모든 단일 URL에 대해 호출되지 않습니다. 성능상의 이유로, 리턴 된 해시가 캐시되며 요청 당 최대 하나의 호출이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6a3fb5ca85e3e7566828c53420b6eec7802c016" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program classes need to load their dependencies:</source>
          <target state="translated">일반적인 루비 프로그램에서 클래스는 의존성을로드해야합니다</target>
        </trans-unit>
        <trans-unit id="6bd2c46748362d10f7e077a4a3b403485446d896" translate="yes" xml:space="preserve">
          <source>In a normal Ruby program, dependencies need to be loaded by hand. For example, the following controller uses classes &lt;code&gt;ApplicationController&lt;/code&gt; and &lt;code&gt;Post&lt;/code&gt;, and normally you'd need to put &lt;code&gt;require&lt;/code&gt; calls for them:</source>
          <target state="translated">일반적인 Ruby 프로그램에서는 종속성을 직접로드해야합니다. 예를 들어 다음 컨트롤러는 &lt;code&gt;ApplicationController&lt;/code&gt; 및 &lt;code&gt;Post&lt;/code&gt; 클래스를 사용 하며 일반적으로 &lt;code&gt;require&lt;/code&gt; 호출을해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac0a2911ec6534ec9248c4c1ae1f11192066c33e" translate="yes" xml:space="preserve">
          <source>In a sense, applications need to eager load STI hierarchies regardless of the loading mode.</source>
          <target state="translated">어떤 의미에서 애플리케이션은로드 모드에 관계없이로드 STI 계층을 열망해야합니다.</target>
        </trans-unit>
        <trans-unit id="492e74f0c484a235e0b7869c9c63fccdba258011" translate="yes" xml:space="preserve">
          <source>In a standard Rails application, there's a &lt;code&gt;Gemfile&lt;/code&gt; which declares all dependencies of the application. &lt;code&gt;config/boot.rb&lt;/code&gt; sets &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; to the location of this file. If the &lt;code&gt;Gemfile&lt;/code&gt; exists, then &lt;code&gt;bundler/setup&lt;/code&gt; is required. The require is used by Bundler to configure the load path for your Gemfile's dependencies.</source>
          <target state="translated">표준 Rails 애플리케이션에는 애플리케이션의 모든 종속성을 선언 하는 &lt;code&gt;Gemfile&lt;/code&gt; 이 있습니다. &lt;code&gt;config/boot.rb&lt;/code&gt; 는 &lt;code&gt;ENV['BUNDLE_GEMFILE']&lt;/code&gt; 을이 파일의 위치로 설정합니다. &lt;code&gt;Gemfile&lt;/code&gt; 이 존재 하면 번 들러 &lt;code&gt;bundler/setup&lt;/code&gt; 이 필요합니다. Bundler는 Gemfile의 종속성에 대한로드 경로를 구성하기 위해 require를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2efca34d821f10fdc65229cd31d319da2be59d15" translate="yes" xml:space="preserve">
          <source>In a template for Advertiser#account:</source>
          <target state="translated">Advertiser # account의 템플릿에서 :</target>
        </trans-unit>
        <trans-unit id="52490bd34ae0086f95f318727490682f974da3a4" translate="yes" xml:space="preserve">
          <source>In a view:</source>
          <target state="translated">보기에서 :</target>
        </trans-unit>
        <trans-unit id="e2736192c03ed00ff774577997cd5dbd2315c098" translate="yes" xml:space="preserve">
          <source>In above examples &quot;dear&quot; gets cut first, but then &lt;code&gt;:separator&lt;/code&gt; prevents it.</source>
          <target state="translated">위의 예에서 &quot;dear&quot;가 먼저 잘린 다음 &lt;code&gt;:separator&lt;/code&gt; 가이를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="9ac475981d36c18878c748709fd215ea0991ca21" translate="yes" xml:space="preserve">
          <source>In addition to &quot;before&quot; filters, you can also run filters after an action has been executed, or both before and after.</source>
          <target state="translated">&quot;이전&quot;필터 외에도 작업이 실행 된 후 또는 전후에 필터를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="be5baf55eb66ee1dcb7712d8a5344cd8230e2b25" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;&lt;code&gt;read_attribute_before_type_cast&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;&lt;code&gt;attributes_before_type_cast&lt;/code&gt;&lt;/a&gt;, it declares a method for all attributes with the &lt;code&gt;*_before_type_cast&lt;/code&gt; suffix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9f9d35b8c646e0ba939b09862711d8f92f46954" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt; and &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast&lt;/a&gt;, it declares a method for all attributes with the &lt;code&gt;*_before_type_cast&lt;/code&gt; suffix.</source>
          <target state="translated">&lt;a href=&quot;beforetypecast#method-i-read_attribute_before_type_cast&quot;&gt;read_attribute_before_type_cast&lt;/a&gt; 및 &lt;a href=&quot;beforetypecast#method-i-attributes_before_type_cast&quot;&gt;attributes_before_type_cast&lt;/a&gt; 외에도 &lt;code&gt;*_before_type_cast&lt;/code&gt; 접미어 가있는 모든 속성에 대한 메소드를 선언합니다 .</target>
        </trans-unit>
        <trans-unit id="c19c7591f28c7db08cef693a8cc1a57e75f0daf1" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;AbstractController::UrlFor&lt;/code&gt;, this module accesses the HTTP layer to define URL options like the &lt;code&gt;host&lt;/code&gt;. In order to do so, this module requires the host class to implement &lt;code&gt;env&lt;/code&gt; which needs to be Rack-compatible and &lt;code&gt;request&lt;/code&gt; which is either an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; or an object that responds to the &lt;code&gt;host&lt;/code&gt;, &lt;code&gt;optional_port&lt;/code&gt;, &lt;code&gt;protocol&lt;/code&gt; and &lt;code&gt;symbolized_path_parameter&lt;/code&gt; methods.</source>
          <target state="translated">이 모듈 은 &lt;code&gt;AbstractController::UrlFor&lt;/code&gt; 외에도 HTTP 계층에 액세스하여 &lt;code&gt;host&lt;/code&gt; 와 같은 URL 옵션을 정의 합니다 . 이를 위해,이 모듈 구현하기 위해 호스트 클래스를 필요로 &lt;code&gt;env&lt;/code&gt; 랙 호환 할 필요가 &lt;code&gt;request&lt;/code&gt; 의 어느 쪽의 인스턴스 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 또는 개체를 그에게 응답 &lt;code&gt;host&lt;/code&gt; , &lt;code&gt;optional_port&lt;/code&gt; , &lt;code&gt;protocol&lt;/code&gt; 및 &lt;code&gt;symbolized_path_parameter&lt;/code&gt; 방법.</target>
        </trans-unit>
        <trans-unit id="0c8406462341f19d778a61e152839741ecc45929" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;polymorphic_url&lt;/code&gt; and &lt;code&gt;polymorphic_path&lt;/code&gt; methods, a number of prefixed helpers are available as a shorthand to &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; in options. Those are:</source>
          <target state="translated">&lt;code&gt;polymorphic_url&lt;/code&gt; 및 &lt;code&gt;polymorphic_path&lt;/code&gt; 메소드 외에도 옵션에서 &lt;code&gt;action: &quot;...&quot;&lt;/code&gt; 의 약어로 많은 접두사 헬퍼를 사용할 수 있습니다. 사람들은:</target>
        </trans-unit>
        <trans-unit id="4f7e1642dcfee5fa1064709f46ea588c41a50fed" translate="yes" xml:space="preserve">
          <source>In addition to being available in the database, the fixture's data may also be accessed by using a special dynamic method, which has the same name as the model.</source>
          <target state="translated">데이터베이스에서 사용할 수있을뿐만 아니라 모델과 이름이 같은 특수한 동적 방법을 사용하여 조명기의 데이터에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ef8b9864032ee34f35123efed8c80f6525320f5" translate="yes" xml:space="preserve">
          <source>In addition to resource routing, Rails has powerful support for routing arbitrary URLs to actions. Here, you don't get groups of routes automatically generated by resourceful routing. Instead, you set up each route separately within your application.</source>
          <target state="translated">Rails는 리소스 라우팅 외에도 임의의 URL을 액션으로 라우팅하는 기능을 강력하게 지원합니다. 여기에서는 리소스가 많은 라우팅에 의해 자동으로 생성 된 경로 그룹을 얻지 못합니다. 대신 응용 프로그램 내에서 각 경로를 별도로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="6fb5ad3102fed665dc6fd095dfd966ded3fa35b8" translate="yes" xml:space="preserve">
          <source>In addition to that, Bootsnap needs to disable the iseq cache due to a bug in the interpreter if running Ruby 2.5. Please make sure to depend on at least Bootsnap 1.4.4 in that case.</source>
          <target state="translated">또한 Ruby 2.5를 실행하는 경우 부트 스냅은 인터프리터의 버그로 인해 iseq 캐시를 비활성화해야합니다. 이 경우 최소한 Bootsnap 1.4.4에 의존해야합니다.</target>
        </trans-unit>
        <trans-unit id="57c0d43027cb87304cff970d87c49b5710e2f729" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-date_select&quot;&gt;&lt;code&gt;date_select&lt;/code&gt;&lt;/a&gt; helper, Rails provides &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-time_select&quot;&gt;&lt;code&gt;time_select&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html#method-i-datetime_select&quot;&gt;&lt;code&gt;datetime_select&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0fc62ce9e9f85e142af12c6d43d1dc2be9c2006" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;:include_blank&lt;/code&gt; option documented above, this method also supports a &lt;code&gt;:model&lt;/code&gt; option, which defaults to &lt;a href=&quot;../../activesupport/timezone&quot;&gt;&lt;code&gt;ActiveSupport::TimeZone&lt;/code&gt;&lt;/a&gt;. This may be used by users to specify a different time zone model object. (See &lt;code&gt;time_zone_options_for_select&lt;/code&gt; for more information.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f0707640817a2197a7219d2ab7981419f6d589b" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;:include_blank&lt;/code&gt; option documented above, this method also supports a &lt;code&gt;:model&lt;/code&gt; option, which defaults to &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport::TimeZone&lt;/a&gt;. This may be used by users to specify a different time zone model object. (See &lt;code&gt;time_zone_options_for_select&lt;/code&gt; for more information.)</source>
          <target state="translated">받는 사람 또한 &lt;code&gt;:include_blank&lt;/code&gt; 위의 문서화 된 옵션이 방법은 또한 지원 &lt;code&gt;:model&lt;/code&gt; 에있는 기본 설정 옵션, &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport :: 시간대를&lt;/a&gt; . 사용자가 다른 시간대 모델 개체를 지정하는 데 사용할 수 있습니다. (자세한 내용은 &lt;code&gt;time_zone_options_for_select&lt;/code&gt; 를 참조하십시오.)</target>
        </trans-unit>
        <trans-unit id="7f2aa54d391ee44ae00e7344e86d409d232deb52" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;valid?&lt;/code&gt; and &lt;code&gt;invalid?&lt;/code&gt; methods covered earlier, Rails provides a number of methods for working with the &lt;code&gt;errors&lt;/code&gt; collection and inquiring about the validity of objects.</source>
          <target state="translated">&lt;code&gt;valid?&lt;/code&gt; 것 외에도 ? 및 &lt;code&gt;invalid?&lt;/code&gt; 앞에서 설명한 방법을 통해 Rails는 &lt;code&gt;errors&lt;/code&gt; 수집 작업과 객체의 유효성에 대한 여러 가지 방법을 제공 합니다.</target>
        </trans-unit>
        <trans-unit id="b25623f60c158c6ebcefbfc797a4eee78412b2c9" translate="yes" xml:space="preserve">
          <source>In addition to the above special tags, you can supply a final hash of standard HTML options, such as &lt;code&gt;:class&lt;/code&gt;, &lt;code&gt;:id&lt;/code&gt; or &lt;code&gt;:name&lt;/code&gt;:</source>
          <target state="translated">위의 특수 태그 외에도 &lt;code&gt;:class&lt;/code&gt; , &lt;code&gt;:id&lt;/code&gt; 또는 &lt;code&gt;:name&lt;/code&gt; 과 같은 표준 HTML 옵션의 최종 해시를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3ed198b3314abe269e0167da41dc4271ec9cb08d" translate="yes" xml:space="preserve">
          <source>In addition to the basic accessors, query methods are also automatically available on the Active Record object. Query methods allow you to test whether an attribute value is present. Additionally, when dealing with numeric values, a query method will return false if the value is zero.</source>
          <target state="translated">기본 접근 자 외에도 쿼리 메서드는 Active Record 개체에서 자동으로 사용할 수 있습니다. 쿼리 방법을 사용하면 속성 값이 있는지 테스트 할 수 있습니다. 또한 숫자 값을 처리 할 때 값이 0이면 쿼리 메서드가 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d0a66c08aa6f98ab67dbdc0e69a533f42cbcb5ab" translate="yes" xml:space="preserve">
          <source>In addition to the model, Rails has also made a migration to create the corresponding database table:</source>
          <target state="translated">모델 외에도 Rails는 해당 데이터베이스 테이블을 생성하기 위해 마이그레이션을 수행했습니다.</target>
        </trans-unit>
        <trans-unit id="659fec6072497b31e669b6f4a5b72d04e9dbb1f8" translate="yes" xml:space="preserve">
          <source>In addition to the routes for magazines, this declaration will also route ads to an &lt;code&gt;AdsController&lt;/code&gt;. The ad URLs require a magazine:</source>
          <target state="translated">잡지에 대한 경로 &lt;code&gt;AdsController&lt;/code&gt; 선언은 광고를 AdsController로 라우팅합니다 . 광고 URL에는 잡지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="273d8d34d0d9b7f29ca3c0db3edc85ecc0178162" translate="yes" xml:space="preserve">
          <source>In addition to the standard testing helpers, inheriting from &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; comes with some additional helpers available when writing integration tests. Let's get briefly introduced to the three categories of helpers we get to choose from.</source>
          <target state="translated">표준 테스트 도우미 외에도 &lt;code&gt;ActionDispatch::IntegrationTest&lt;/code&gt; 에서 상속 하면 통합 테스트를 작성할 때 사용할 수있는 추가 도우미가 함께 제공됩니다. 우리가 선택할 수있는 세 가지 도우미 범주에 대해 간단히 소개하겠습니다.</target>
        </trans-unit>
        <trans-unit id="3b76cd292632a3d6bbb2d48a3be80cc0143dce1a" translate="yes" xml:space="preserve">
          <source>In addition to these specific assertions, you also have easy access to various collections that the regular test/unit assertions can be used against. These collections are:</source>
          <target state="translated">이러한 특정 어설 션 외에도 정기적 인 테스트 / 단위 어설 션을 사용할 수있는 다양한 컬렉션에 쉽게 액세스 할 수 있습니다. 이 컬렉션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f54b6c933dbdba4d46f41b497b370c4dc86bcb9" translate="yes" xml:space="preserve">
          <source>In addition to using the routing helpers, Rails can also create paths and URLs from an array of parameters. For example, suppose you have this set of routes:</source>
          <target state="translated">Rails는 라우팅 헬퍼를 사용하는 것 외에도 다양한 파라미터로부터 경로와 URL을 생성 할 수 있습니다. 예를 들어 다음과 같은 경로 집합이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="9a489e96256e076ad81bed57e5b930cbe1f34754" translate="yes" xml:space="preserve">
          <source>In addition to using the standard template helpers provided, creating custom helpers to extract complicated logic or reusable functionality is strongly encouraged. By default, each controller will include all helpers. These helpers are only accessible on the controller through &lt;code&gt;#helpers&lt;/code&gt;</source>
          <target state="translated">제공된 표준 템플릿 헬퍼를 사용하는 것 외에도 복잡한 로직 또는 재사용 가능한 기능을 추출하는 사용자 정의 헬퍼를 작성하는 것이 좋습니다. 기본적으로 각 컨트롤러에는 모든 도우미가 포함됩니다. 이 도우미는 &lt;code&gt;#helpers&lt;/code&gt; 를 통해서만 컨트롤러에서 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a653052b951c629d3ca791ef6bf869c9d73b3cf7" translate="yes" xml:space="preserve">
          <source>In addition, default connection parameters of libpq can be set per environment variables. See &lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html&lt;/a&gt; .</source>
          <target state="translated">또한 환경 변수마다 libpq의 기본 연결 매개 변수를 설정할 수 있습니다. &lt;a href=&quot;https://www.postgresql.org/docs/current/static/libpq-envars.html&quot;&gt;www.postgresql.org/docs/current/static/libpq-envars.html을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="86eb91ad68dda50198619f27072e415d3a33306a" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and flow through a predefined raise/rescue flow to end up as a &lt;code&gt;400 Bad Request&lt;/code&gt; with no effort.</source>
          <target state="translated">또한 매개 변수를 필요에 따라 표시하고 사전 정의 된 상승 / 구조 흐름을 통해 흐르면 노력없이 &lt;code&gt;400 Bad Request&lt;/code&gt; 으로 끝날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37cf4de850ab31fd45274bd24911679d02a7c120" translate="yes" xml:space="preserve">
          <source>In addition, parameters can be marked as required and will flow through a predefined raise/rescue flow that will result in a 400 Bad Request being returned if not all required parameters are passed in.</source>
          <target state="translated">또한 매개 변수는 필요에 따라 표시 될 수 있으며 사전 정의 된 상승 / 구조 흐름을 통해 흐르므로 필요한 모든 매개 변수가 전달되지 않을 경우 400 잘못된 요청이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e1e0d6f445342011a367c696c83fbd3cd58f1a98" translate="yes" xml:space="preserve">
          <source>In addition, the code takes advantage of some of the methods available for an association. We use the &lt;code&gt;create&lt;/code&gt; method on &lt;code&gt;@article.comments&lt;/code&gt; to create and save the comment. This will automatically link the comment so that it belongs to that particular article.</source>
          <target state="translated">또한이 코드는 연결에 사용할 수있는 일부 방법을 활용합니다. 의견을 작성하고 저장하기 위해 &lt;code&gt;@article.comments&lt;/code&gt; 의 &lt;code&gt;create&lt;/code&gt; 메소드를 사용합니다 . 주석이 해당 특정 기사에 속하도록 자동으로 링크됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5e264b6df4bc7992f34cc32e3948724826c818" translate="yes" xml:space="preserve">
          <source>In all of these cases, if you don't provide the leading host (&lt;code&gt;http://www.example.com&lt;/code&gt;), Rails will take those details from the current request.</source>
          <target state="translated">이 모든 경우에 주요 호스트 ( &lt;code&gt;http://www.example.com&lt;/code&gt; )를 제공하지 않으면 Rails는 현재 요청에서 세부 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e3b2d56224656c1d716fe11607fdcc52c7fafa15" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;belongs_to&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;association&lt;/code&gt; 은 &lt;code&gt;belongs_to&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호로 대체됩니다 . 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="0267e786c3a2473c923ff186544a4fe59a3bc697" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;association&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_one&lt;/code&gt;. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;association&lt;/code&gt; 은 &lt;code&gt;has_one&lt;/code&gt; 의 첫 번째 인수로 전달 된 기호로 대체됩니다 . 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="4228a39194d9fa678da42b335b025a8551d95b8d" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_and_belongs_to_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;collection&lt;/code&gt; 은 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호 로 대체 되고 &lt;code&gt;collection_singular&lt;/code&gt; 는 해당 기호의 단일화 된 버전으로 대체됩니다. 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="3664f08539ac9bbd1f271c61e976c587e1e5dc16" translate="yes" xml:space="preserve">
          <source>In all of these methods, &lt;code&gt;collection&lt;/code&gt; is replaced with the symbol passed as the first argument to &lt;code&gt;has_many&lt;/code&gt;, and &lt;code&gt;collection_singular&lt;/code&gt; is replaced with the singularized version of that symbol. For example, given the declaration:</source>
          <target state="translated">이러한 모든 메소드에서 &lt;code&gt;collection&lt;/code&gt; 은 &lt;code&gt;has_many&lt;/code&gt; 에 대한 첫 번째 인수로 전달 된 기호 로 대체 되고 &lt;code&gt;collection_singular&lt;/code&gt; 는 해당 기호의 단일화 된 버전으로 대체됩니다. 예를 들어, 다음과 같이 선언하면 :</target>
        </trans-unit>
        <trans-unit id="76ba7bee8ae02e8825975013dd94ae4e48597265" translate="yes" xml:space="preserve">
          <source>In all other environments, we look for it first in &lt;a href=&quot;application&quot;&gt;ENV&lt;/a&gt;, then credentials.secret_key_base, and finally secrets.secret_key_base. For most applications, the correct place to store it is in the encrypted credentials file.</source>
          <target state="translated">다른 모든 환경에서는 &lt;a href=&quot;application&quot;&gt;ENV&lt;/a&gt; 에서 먼저 찾은 다음 credentials.secret_key_base, secrets.secret_key_base를 찾습니다 . 대부분의 응용 프로그램의 경우 올바른 위치는 암호화 된 자격 증명 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="000084df2bdb044e5363d197d064db2690bafce1" translate="yes" xml:space="preserve">
          <source>In another template for Advertiser#buy, we could have:</source>
          <target state="translated">Advertiser # buy의 다른 템플릿에서 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4870aa44e6a6abc63d2b0ec3e900a2aa278eff45" translate="yes" xml:space="preserve">
          <source>In any case, Rails will not create foreign key columns for you. You need to explicitly define them as part of your migrations.</source>
          <target state="translated">어쨌든 Rails는 외래 키 열을 생성하지 않습니다. 마이그레이션의 일부로 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d11d79019970af8991b8284f111043aec00e832" translate="yes" xml:space="preserve">
          <source>In application.rb.</source>
          <target state="translated">application.rb에서.</target>
        </trans-unit>
        <trans-unit id="da1524f5ec677556dc68e29dcae90e17f86ccaab" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; of the wrapping DOM element are automatically generated, following naming conventions encapsulated by the &lt;a href=&quot;recordidentifier&quot;&gt;&lt;code&gt;RecordIdentifier&lt;/code&gt;&lt;/a&gt; methods &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;&lt;code&gt;dom_id&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;&lt;code&gt;dom_class&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c59320d50acb675849eb2769c537ff63243a3c9" translate="yes" xml:space="preserve">
          <source>In both cases, the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; of the wrapping DOM element are automatically generated, following naming conventions encapsulated by the &lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt; methods &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt; and &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt;:</source>
          <target state="translated">두 경우 모두에서, &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;class&lt;/code&gt; 권취 DOM 요소 자동 캡슐화 명명 규칙에 따라 생성된다 &lt;a href=&quot;recordidentifier&quot;&gt;RecordIdentifier&lt;/a&gt; 방법 &lt;a href=&quot;recordidentifier#method-i-dom_id&quot;&gt;dom_id&lt;/a&gt; 및 &lt;a href=&quot;recordidentifier#method-i-dom_class&quot;&gt;dom_class&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4d6fcdc2547cfa1880e149c6250c44773b88211e" translate="yes" xml:space="preserve">
          <source>In both of these cases, the named route helpers remain the same as if you did not use &lt;code&gt;scope&lt;/code&gt;. In the last case, the following paths map to &lt;code&gt;ArticlesController&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668c56622e7f9451f33d9f93e487e3ef6506b55c" translate="yes" xml:space="preserve">
          <source>In broad strokes, this involves deciding what should be sent as the response and calling an appropriate method to create that response. If the response is a full-blown view, Rails also does some extra work to wrap the view in a layout and possibly to pull in partial views. You'll see all of those paths later in this guide.</source>
          <target state="translated">광범위한 스트로크에서는 응답으로 보낼 대상을 결정하고 해당 메소드를 작성하기 위해 적절한 메소드를 호출해야합니다. 응답이 본격적인 뷰인 경우 Rails는 뷰를 레이아웃으로 감싸고 부분 뷰를 가져 오기 위해 추가 작업을 수행합니다. 이 가이드의 뒷부분에서 이러한 경로를 모두 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f04c0e7fc642bc09b37b52db8f26f85e840c7be4" translate="yes" xml:space="preserve">
          <source>In case &lt;a href=&quot;core#method-c-configurations&quot;&gt;ActiveRecord::Base.configurations&lt;/a&gt; is set (Rails automatically loads the contents of config/database.yml into it), a symbol can also be given as argument, representing a key in the configuration hash:</source>
          <target state="translated">경우 &lt;a href=&quot;core#method-c-configurations&quot;&gt;액티브 :: Base.configurations이&lt;/a&gt; (레일은 자동으로 부하를 설정 / database.yml을 그것에의 내용을) 설정, 기호는 구성 해시의 키를 나타내는 인수로 제공 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="2914a351943b11d907ce8804814e83c9455d5f5b" translate="yes" xml:space="preserve">
          <source>In case if you don't want the helper to generate this hidden field you can specify &lt;code&gt;include_hidden: false&lt;/code&gt; option.</source>
          <target state="translated">도우미가이 숨겨진 필드를 생성하지 못하게하려면 &lt;code&gt;include_hidden: false&lt;/code&gt; 옵션을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="53b57a67e8f0b195f0c2f8ec972106aabad30b2f" translate="yes" xml:space="preserve">
          <source>In case of collision the key in the hash of the argument wins in &lt;code&gt;merge&lt;/code&gt;. You can support option hashes with default values in a compact way with this idiom:</source>
          <target state="translated">충돌이 발생하면 인수 해시의 키가 &lt;code&gt;merge&lt;/code&gt; 에서 승리 합니다. 이 관용구를 사용하여 기본값으로 옵션 해시를 간결하게 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5747e87b6b5262401689f735501c016f96edb770" translate="yes" xml:space="preserve">
          <source>In case of key collision, the value will be the one most recently inserted into the hash:</source>
          <target state="translated">키 충돌의 경우 값은 가장 최근에 해시에 삽입 된 값입니다.</target>
        </trans-unit>
        <trans-unit id="ead9150d71466c198079df9606375a348f7545f7" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;reselect&lt;/code&gt; clause is not used,</source>
          <target state="translated">경우에 &lt;code&gt;reselect&lt;/code&gt; 절은 사용하지 않습니다,</target>
        </trans-unit>
        <trans-unit id="b99031f5395107cae850a34182a86c583a5e8bbc" translate="yes" xml:space="preserve">
          <source>In case the &lt;code&gt;rewhere&lt;/code&gt; clause is not used,</source>
          <target state="translated">경우에 &lt;code&gt;rewhere&lt;/code&gt; 의 절은 사용하지 않습니다,</target>
        </trans-unit>
        <trans-unit id="1b52403da0263fbc97fea21478c66a6efee34f30" translate="yes" xml:space="preserve">
          <source>In case there are multiple transactional callbacks as seen below, the order is reversed.</source>
          <target state="translated">아래와 같이 여러 트랜잭션 콜백이있는 경우 주문이 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="635a341b8073e09a13f08f7515b6ef51d59d28df" translate="yes" xml:space="preserve">
          <source>In case you do need to use this directly, it's instantiated using a hash of transformations where the key is the command and the value is the arguments. Example:</source>
          <target state="translated">이것을 직접 사용해야하는 경우 키가 명령이고 값이 인수 인 변환 해시를 사용하여 인스턴스화됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="460e1765763f34c18d629b3a36b0d40f448fcdd2" translate="yes" xml:space="preserve">
          <source>In case you need to render form fields outside of the context of a form builder, Rails provides tag helpers for common form elements. For example, &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html#method-i-check_box_tag&quot;&gt;&lt;code&gt;check_box_tag&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab38fdbdc2be5e311392ae9dec66807dbc33331a" translate="yes" xml:space="preserve">
          <source>In classic mode, constant autoloading is not thread-safe, though Rails has locks in place for example to make web requests thread-safe when autoloading is enabled, as it is common in &lt;code&gt;development&lt;/code&gt; mode.</source>
          <target state="translated">클래식 모드에서는 지속적인 자동 로딩이 스레드로부터 안전하지는 않지만 &lt;code&gt;development&lt;/code&gt; 모드 에서 일반적으로 사용되는 자동 로딩이 활성화 된 경우 웹 요청을 스레드로부터 안전하도록 레일에 잠금이 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbea1064e6ea6ea28f1cd658ca6b70717d29b6f7" translate="yes" xml:space="preserve">
          <source>In classic mode, constant autoloading is not thread-safe, though Rails has locks in place for example to make web requests thread-safe when autoloading is enabled, as it is common in the development environment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28098f98cbee672e634d74ee1a9d3673205d6cdb" translate="yes" xml:space="preserve">
          <source>In database terms, the &lt;code&gt;belongs_to&lt;/code&gt; association says that this model's table contains a column which represents a reference to another table. This can be used to set up one-to-one or one-to-many relations, depending on the setup. If the table of the other class contains the reference in a one-to-one relation, then you should use &lt;code&gt;has_one&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a6c46a95f9b3a44f98f5f588dade7b6ceb8aa0" translate="yes" xml:space="preserve">
          <source>In designing a data model, you will sometimes find a model that should have a relation to itself. For example, you may want to store all employees in a single database model, but be able to trace relationships such as between manager and subordinates. This situation can be modeled with self-joining associations:</source>
          <target state="translated">데이터 모델을 설계 할 때 때때로 자신과 관련이있는 모델을 찾을 수 있습니다. 예를 들어 모든 직원을 단일 데이터베이스 모델로 저장하고 관리자와 부하 직원 간의 관계를 추적 할 수 있습니다. 이 상황은 자체 결합 연관을 사용하여 모델링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd40f53ba75e011c7a28f5ec65b729053cc27ab" translate="yes" xml:space="preserve">
          <source>In development and test, this is randomly generated and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;.</source>
          <target state="translated">개발 및 테스트에서 이는 무작위로 생성되어 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 의 임시 파일에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="7dc3433693fc4166beebd7acff85f8551ec0ef84" translate="yes" xml:space="preserve">
          <source>In development mode (which is what you're working in by default), Rails reloads your application with every browser request, so there's no need to stop and restart the web server when a change is made.</source>
          <target state="translated">개발 모드 (기본적으로 작업중인 모드)에서 Rails는 모든 브라우저 요청에 따라 애플리케이션을 다시로드하므로 변경시 웹 서버를 중지했다가 다시 시작할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cbbe35a8e7fc2586eee8dc5f2c42cbf40cb2cdf" translate="yes" xml:space="preserve">
          <source>In development mode, assets are served as separate files in the order they are specified in the manifest file.</source>
          <target state="translated">개발 모드에서 자산은 매니페스트 파일에 지정된 순서대로 별도의 파일로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d0117c9022aff8e1edf96d1640e0ef23c9aa8e0c" translate="yes" xml:space="preserve">
          <source>In development mode, or if the asset pipeline is disabled, when these files are requested they are processed by the processors provided by the &lt;code&gt;coffee-script&lt;/code&gt; and &lt;code&gt;sass&lt;/code&gt; gems and then sent back to the browser as JavaScript and CSS respectively. When asset pipelining is enabled, these files are preprocessed and placed in the &lt;code&gt;public/assets&lt;/code&gt; directory for serving by either the Rails app or web server.</source>
          <target state="translated">개발 모드에서 또는 자산 파이프 라인이 비활성화 된 경우 이러한 파일이 요청되면 &lt;code&gt;coffee-script&lt;/code&gt; 및 &lt;code&gt;sass&lt;/code&gt; gem 에서 제공하는 프로세서에서 처리 한 다음 각각 JavaScript 및 CSS로 브라우저로 다시 보냅니다. 자산 파이프 라이닝이 활성화되면 이러한 파일은 사전 처리 되어 Rails 앱 또는 웹 서버에서 제공 할 수 있도록 &lt;code&gt;public/assets&lt;/code&gt; 디렉토리에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="1773fc4f2eb1b5bf260699298ded25b98aa2cb83" translate="yes" xml:space="preserve">
          <source>In development mode, or if the asset pipeline is disabled, when this file is requested it is processed by the processor provided by the &lt;code&gt;sass-rails&lt;/code&gt; gem and then sent back to the browser as CSS. When asset pipelining is enabled, this file is preprocessed and placed in the &lt;code&gt;public/assets&lt;/code&gt; directory for serving by either the Rails app or web server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72ca04501631185f7baec6402ca5840b1ff7811b" translate="yes" xml:space="preserve">
          <source>In development, it's very usual to have to run another process next to the &lt;code&gt;Rails&lt;/code&gt;&lt;code&gt;Server&lt;/code&gt;. In example you might want to start the Webpack or React server. Or maybe you need to run your job scheduler process like Sidekiq. This is usually done by opening a new shell and running the program from here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3786ad74fa4fe0940b68fbf7d2f8c00871af10e7" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use &lt;code&gt;scope&lt;/code&gt;. In the last case, the following paths map to &lt;code&gt;ArticlesController&lt;/code&gt;:</source>
          <target state="translated">이러한 각 경우에 명명 된 경로는 &lt;code&gt;scope&lt;/code&gt; 를 사용하지 않은 것과 동일하게 유지 됩니다 . 마지막 경우 다음 경로는 &lt;code&gt;ArticlesController&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="dc0da6ec76022c06eb655cd87ccef507cdb3d8d8" translate="yes" xml:space="preserve">
          <source>In each of these cases, the named routes remain the same as if you did not use scope. In the last case, the following paths map to &lt;code&gt;PostsController&lt;/code&gt;:</source>
          <target state="translated">이러한 각 경우에 명명 된 경로는 범위를 사용하지 않은 것과 동일하게 유지됩니다. 마지막 경우 다음 경로는 &lt;code&gt;PostsController&lt;/code&gt; 에 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="60058368d765b422ebd5cb786a5a52790ae2abe4" translate="yes" xml:space="preserve">
          <source>In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/Base.html#method-i-request&quot;&gt;&lt;code&gt;request&lt;/code&gt;&lt;/a&gt; method contains an instance of &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Request.html&quot;&gt;&lt;code&gt;ActionDispatch::Request&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/Base.html#method-i-response&quot;&gt;&lt;code&gt;response&lt;/code&gt;&lt;/a&gt; method returns a response object representing what is going to be sent back to the client.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d609cba35afc0d9cbede9275222dd86903f0402f" translate="yes" xml:space="preserve">
          <source>In every controller there are two accessor methods pointing to the request and the response objects associated with the request cycle that is currently in execution. The &lt;code&gt;request&lt;/code&gt; method contains an instance of &lt;code&gt;ActionDispatch::Request&lt;/code&gt; and the &lt;code&gt;response&lt;/code&gt; method returns a response object representing what is going to be sent back to the client.</source>
          <target state="translated">모든 컨트롤러에는 현재 실행중인 요청주기와 관련된 요청 및 응답 객체를 가리키는 두 가지 접근 자 메서드가 있습니다. &lt;code&gt;request&lt;/code&gt; 방법은 인스턴스 포함 &lt;code&gt;ActionDispatch::Request&lt;/code&gt; 과 &lt;code&gt;response&lt;/code&gt; 응답 객체가 클라이언트로 전송 될 것입니다 무엇을 나타내는 방법을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10d1c3f7b24ff0cd15fba1526043f7d57ca81a41" translate="yes" xml:space="preserve">
          <source>In fact, in the BooksController class, inside of the update action where we want to render the edit template if the book does not update successfully, all of the following render calls would all render the &lt;code&gt;edit.html.erb&lt;/code&gt; template in the &lt;code&gt;views/books&lt;/code&gt; directory:</source>
          <target state="translated">실제로 BooksController 클래스에서 책이 성공적으로 업데이트되지 않은 경우 편집 템플릿을 렌더링하려는 업데이트 작업 내에서 다음 렌더링 호출은 모두 &lt;code&gt;views/books&lt;/code&gt; 에서 &lt;code&gt;edit.html.erb&lt;/code&gt; 템플릿을 렌더링합니다. 예배 규칙서:</target>
        </trans-unit>
        <trans-unit id="2a136ee58e677ffa9a8948ad3664e874d61587d7" translate="yes" xml:space="preserve">
          <source>In fact, the &lt;code&gt;options&lt;/code&gt; method here does quite a lot. This method is defined in &lt;code&gt;Rack::Server&lt;/code&gt; like this:</source>
          <target state="translated">사실, 여기 의 &lt;code&gt;options&lt;/code&gt; 방법은 상당히 많이합니다. 이 방법은 &lt;code&gt;Rack::Server&lt;/code&gt; 과 같이 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="abd53ed7ec9bbce4777f7ebf39b859fff4f5d42f" translate="yes" xml:space="preserve">
          <source>In fact, the result string is wrapped in an instance of &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt;.</source>
          <target state="translated">실제로 결과 문자열은 &lt;code&gt;ActiveSupport::Multibyte::Chars&lt;/code&gt; 인스턴스에 래핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="0e8382f13be7db86341dbb74cd26348b30c534d2" translate="yes" xml:space="preserve">
          <source>In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the &lt;code&gt;Comment&lt;/code&gt; model (app/models/comment.rb) that makes each comment belong to an Article:</source>
          <target state="translated">실제로 이것은 Rails가이 연관성을 선언하는 데 사용하는 구문과 매우 유사합니다. &lt;code&gt;Comment&lt;/code&gt; 모델 (app / models / comment.rb)에서 각 주석이 기사에 속하도록하는 코드 줄을 이미 보았습니다 .</target>
        </trans-unit>
        <trans-unit id="cdd8ad375719e4ab6835063d47e1a972802da964" translate="yes" xml:space="preserve">
          <source>In general there is no such thing as plug-n-play security. Security depends on the people using the framework, and sometimes on the development method. And it depends on all layers of a web application environment: The back-end storage, the web server, and the web application itself (and possibly other layers or applications).</source>
          <target state="translated">일반적으로 플러그 앤 플레이 보안은 없습니다. 보안은 프레임 워크를 사용하는 사람과 개발 방법에 따라 다릅니다. 또한 백엔드 스토리지, 웹 서버 및 웹 애플리케이션 자체 (및 기타 계층 또는 애플리케이션)와 같은 웹 애플리케이션 환경의 모든 계층에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7859df51f6b2aa1d976967648705ec81c4e55e0c" translate="yes" xml:space="preserve">
          <source>In general, Rails encourages using resources objects instead of declaring routes manually. For more information about routing, see &lt;a href=&quot;routing&quot;&gt;Rails Routing from the Outside In&lt;/a&gt;.</source>
          <target state="translated">일반적으로 Rails는 경로를 수동으로 선언하는 대신 자원 객체를 사용하도록 권장합니다. 라우팅에 대한 자세한 내용은 &lt;a href=&quot;routing&quot;&gt;외부에서 레일 라우팅을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="50540acc55f3de829c0940388140fb1e249e65eb" translate="yes" xml:space="preserve">
          <source>In general, applications do not need to use the API of Zeitwerk directly. Rails sets things up according to the existing contract: &lt;code&gt;config.autoload_paths&lt;/code&gt;, &lt;code&gt;config.cache_classes&lt;/code&gt;, etc.</source>
          <target state="translated">일반적으로 응용 프로그램은 Zeitwerk의 API를 직접 사용할 필요가 없습니다. Rails는 기존 계약에 따라 설정합니다 : &lt;code&gt;config.autoload_paths&lt;/code&gt; , &lt;code&gt;config.cache_classes&lt;/code&gt; 등</target>
        </trans-unit>
        <trans-unit id="009e5cde90877d092ff3fb64ff8f83cd2b9360b9" translate="yes" xml:space="preserve">
          <source>In general, editing existing migrations is not a good idea. You will be creating extra work for yourself and your co-workers and cause major headaches if the existing version of the migration has already been run on production machines. Instead, you should write a new migration that performs the changes you require. Editing a freshly generated migration that has not yet been committed to source control (or, more generally, which has not been propagated beyond your development machine) is relatively harmless.</source>
          <target state="translated">일반적으로 기존 마이그레이션을 편집하는 것은 좋지 않습니다. 기존 버전의 마이그레이션이 이미 프로덕션 시스템에서 실행 된 경우 자신과 동료를 위해 추가 작업을 작성하고 심각한 두통을 유발할 수 있습니다. 대신 필요한 변경을 수행하는 새 마이그레이션을 작성해야합니다. 아직 소스 제어를 수행하지 않은 (또는 일반적으로 개발 시스템을 넘어 전파되지 않은) 새로 생성 된 마이그레이션을 편집하는 것은 상대적으로 무해합니다.</target>
        </trans-unit>
        <trans-unit id="cfa4f37960ac63db4c1e0581d458aa91965fd49b" translate="yes" xml:space="preserve">
          <source>In general, the work of configuring Rails means configuring the components of Rails, as well as configuring Rails itself. The configuration file &lt;code&gt;config/application.rb&lt;/code&gt; and environment-specific configuration files (such as &lt;code&gt;config/environments/production.rb&lt;/code&gt;) allow you to specify the various settings that you want to pass down to all of the components.</source>
          <target state="translated">일반적으로 Rails 구성 작업은 Rails 자체 구성뿐만 아니라 Rails 구성 요소 구성도 의미합니다. 구성 파일 &lt;code&gt;config/application.rb&lt;/code&gt; 및 환경 별 구성 파일 (예 : &lt;code&gt;config/environments/production.rb&lt;/code&gt; )을 사용하면 모든 구성 요소에 전달할 다양한 설정을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ba2b0f04d81bdf445c82110d1b2a735d4926f1c" translate="yes" xml:space="preserve">
          <source>In general, this approach is far less reliable than using the language header and is not recommended for most web applications.</source>
          <target state="translated">일반적으로이 방법은 언어 헤더를 사용하는 것보다 훨씬 덜 안정적이며 대부분의 웹 응용 프로그램에는 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="05d3f7c12b05724d16ed0c24ed8019b8a5ebfbc8" translate="yes" xml:space="preserve">
          <source>In general, views will be rendered in the &lt;code&gt;main&lt;/code&gt; layout</source>
          <target state="translated">일반적으로 뷰는 &lt;code&gt;main&lt;/code&gt; 레이아웃 으로 렌더링됩니다</target>
        </trans-unit>
        <trans-unit id="17f645dc79304b40ff354686d5297d407712a36c" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/HttpHelpers.html#method-i-get&quot;&gt;&lt;code&gt;get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/HttpHelpers.html#method-i-post&quot;&gt;&lt;code&gt;post&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/HttpHelpers.html#method-i-put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/HttpHelpers.html#method-i-patch&quot;&gt;&lt;code&gt;patch&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/HttpHelpers.html#method-i-delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; methods to constrain a route to a particular verb. You can use the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Base.html#method-i-match&quot;&gt;&lt;code&gt;match&lt;/code&gt;&lt;/a&gt; method with the &lt;code&gt;:via&lt;/code&gt; option to match multiple verbs at once:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="561ed79dc42d8cf5921bed84b25cc1b1d859875b" translate="yes" xml:space="preserve">
          <source>In general, you should use the &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; methods to constrain a route to a particular verb. You can use the &lt;code&gt;match&lt;/code&gt; method with the &lt;code&gt;:via&lt;/code&gt; option to match multiple verbs at once:</source>
          <target state="translated">일반적으로 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 메소드를 사용하여 특정 동사에 대한 경로를 제한해야합니다. &lt;code&gt;match&lt;/code&gt; 메소드를 &lt;code&gt;:via&lt;/code&gt; 옵션 과 함께 사용하여 여러 동사를 한 번에 일치 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1bd774faaf94fcd3bfa62b756b86b0055c4640b8" translate="yes" xml:space="preserve">
          <source>In many cases you will want to wrap the above in another helper, so you could do something like the following:</source>
          <target state="translated">대부분의 경우 위의 내용을 다른 도우미로 감싸서 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4038dff4cecd3f066b2d24d2f7447a5cd95089" translate="yes" xml:space="preserve">
          <source>In many languages &amp;mdash; including English &amp;mdash; there are only two forms, a singular and a plural, for a given string, e.g. &quot;1 message&quot; and &quot;2 messages&quot;. Other languages (&lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;Arabic&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;Japanese&lt;/a&gt;, &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;Russian&lt;/a&gt; and many more) have different grammars that have additional or fewer &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;plural forms&lt;/a&gt;. Thus, the I18n API provides a flexible pluralization feature.</source>
          <target state="translated">영어를 포함한 많은 언어에서는 주어진 문자열에 대해 단수형과 복수형, 즉 &quot;1 메시지&quot;와 &quot;2 메시지&quot;의 두 가지 형식 만 있습니다. 다른 언어 ( &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ar&quot;&gt;아랍어&lt;/a&gt; , &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ja&quot;&gt;일본어&lt;/a&gt; , &lt;a href=&quot;http://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html#ru&quot;&gt;러시아어&lt;/a&gt; 등)는 &lt;a href=&quot;http://cldr.unicode.org/index/cldr-spec/plural-rules&quot;&gt;복수형&lt;/a&gt; 이 추가되거나 적은 문법이 다릅니다 . 따라서 I18n API는 유연한 복수 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="80fd14ee0705f257e5f31eb4d9dd647ce74d257c" translate="yes" xml:space="preserve">
          <source>In many of the examples just shown, the &lt;code&gt;:model&lt;/code&gt; passed to &lt;code&gt;form_with&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;. It corresponds to a set of RESTful routes, most likely defined via &lt;code&gt;resources&lt;/code&gt; in &lt;code&gt;config/routes.rb&lt;/code&gt;.</source>
          <target state="translated">방금 표시된 많은 예제 에서 &lt;code&gt;form_with&lt;/code&gt; 로 전달 된 &lt;code&gt;:model&lt;/code&gt; 은 &lt;em&gt;resource&lt;/em&gt; 입니다. &lt;code&gt;config/routes.rb&lt;/code&gt; 의 &lt;code&gt;resources&lt;/code&gt; 을 통해 정의 된 RESTful 라우트 세트에 해당합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ef6ef665603c985acc7fe36f2e58ee464bdd2d68" translate="yes" xml:space="preserve">
          <source>In many ways this is exactly what it is. This file is created by inspecting the database and expressing its structure using &lt;code&gt;create_table&lt;/code&gt;, &lt;code&gt;add_index&lt;/code&gt;, and so on.</source>
          <target state="translated">여러면에서 이것은 정확히 무엇입니까. 이 파일은 데이터베이스를 검사하고 &lt;code&gt;create_table&lt;/code&gt; , &lt;code&gt;add_index&lt;/code&gt; 등을 사용하여 구조를 표현하여 작성됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1503f11656b8d1ff7d917aa789c3193af3aea8f" translate="yes" xml:space="preserve">
          <source>In most cases form controls will be tied to a specific model and as you might expect Rails provides helpers tailored for that purpose. Consistent with other form helpers, when dealing with a model object drop the &lt;code&gt;_tag&lt;/code&gt; suffix from &lt;code&gt;select_tag&lt;/code&gt;:</source>
          <target state="translated">대부분의 경우 양식 컨트롤은 특정 모델에 연결되며 Rails는 해당 목적에 맞는 도우미를 제공합니다. 다른 폼 헬퍼와 일치하여 모델 객체를 다룰 때 &lt;code&gt;select_tag&lt;/code&gt; 에서 &lt;code&gt;_tag&lt;/code&gt; 접미사를 삭제하십시오 .</target>
        </trans-unit>
        <trans-unit id="49d05bef68167e6b51e8cc8c24d282e468b2a8ce" translate="yes" xml:space="preserve">
          <source>In most cases, fetching large number of records can be performed efficiently using the &lt;a href=&quot;../batches&quot;&gt;&lt;code&gt;ActiveRecord::Batches&lt;/code&gt;&lt;/a&gt; methods. See &lt;a href=&quot;../batches&quot;&gt;&lt;code&gt;ActiveRecord::Batches&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283fed243a06178888cb8100163ceca9e14989cb" translate="yes" xml:space="preserve">
          <source>In most cases, fetching large number of records can be performed efficiently using the &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; methods. See &lt;a href=&quot;../batches&quot;&gt;ActiveRecord::Batches&lt;/a&gt; for more information.</source>
          <target state="translated">대부분의 경우 &lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt; 메서드를 사용하여 많은 수의 레코드를 효율적으로 가져올 수 있습니다 . 자세한 내용은 &lt;a href=&quot;../batches&quot;&gt;ActiveRecord :: Batches&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eaa0df2a0434277646399904ea9e3879a2dbb3f8" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/AbstractController/Rendering.html#method-i-render&quot;&gt;&lt;code&gt;ActionController::Base#render&lt;/code&gt;&lt;/a&gt; method does the heavy lifting of rendering your application's content for use by a browser. There are a variety of ways to customize the behavior of &lt;code&gt;render&lt;/code&gt;. You can render the default view for a Rails template, or a specific template, or a file, or inline code, or nothing at all. You can render text, JSON, or XML. You can specify the content type or HTTP status of the rendered response as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a148fbaa7aee69002a1ac5f21efa423a9e3c30e" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;ActionController::Base#render&lt;/code&gt; method does the heavy lifting of rendering your application's content for use by a browser. There are a variety of ways to customize the behavior of &lt;code&gt;render&lt;/code&gt;. You can render the default view for a Rails template, or a specific template, or a file, or inline code, or nothing at all. You can render text, JSON, or XML. You can specify the content type or HTTP status of the rendered response as well.</source>
          <target state="translated">대부분의 경우 &lt;code&gt;ActionController::Base#render&lt;/code&gt; 메소드는 브라우저에서 사용할 수 있도록 애플리케이션 컨텐츠를 렌더링하는 작업을 많이 수행합니다. &lt;code&gt;render&lt;/code&gt; 의 동작을 사용자 정의하는 다양한 방법이 있습니다 . Rails 템플릿, 특정 템플릿, 파일 또는 인라인 코드에 대한 기본 뷰를 렌더링하거나 전혀 렌더링하지 않을 수 있습니다. 텍스트, JSON 또는 XML을 렌더링 할 수 있습니다. 렌더링 된 응답의 컨텐츠 유형 또는 HTTP 상태도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="845cacdf9af459c9ecab3fe3b4510b4778e6725a" translate="yes" xml:space="preserve">
          <source>In most database systems, on selecting fields with &lt;code&gt;distinct&lt;/code&gt; from a result set using methods like &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;pluck&lt;/code&gt; and &lt;code&gt;ids&lt;/code&gt;; the &lt;code&gt;order&lt;/code&gt; method will raise an &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; exception unless the field(s) used in &lt;code&gt;order&lt;/code&gt; clause are included in the select list. See the next section for selecting fields from the result set.</source>
          <target state="translated">대부분의 데이터베이스 시스템에서 &lt;code&gt;select&lt;/code&gt; , &lt;code&gt;pluck&lt;/code&gt; 및 &lt;code&gt;ids&lt;/code&gt; 와 같은 메소드를 사용하여 결과 세트 와 &lt;code&gt;distinct&lt;/code&gt; 되는 필드를 선택합니다 . &lt;code&gt;order&lt;/code&gt; 방법은 올릴 것이다 &lt;code&gt;ActiveRecord::StatementInvalid&lt;/code&gt; 에 사용되는 필드 (들)하지 않는 예외를 &lt;code&gt;order&lt;/code&gt; 절을 선택 목록에 포함되어 있습니다. 결과 집합에서 필드를 선택하려면 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9cb5f676660b8c29fc4145374c10ee3d76b54507" translate="yes" xml:space="preserve">
          <source>In order for this example to work, you have to add the PDF MIME type to Rails. This can be done by adding the following line to the file &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt;:</source>
          <target state="translated">이 예제가 작동하려면 PDF MIME 유형을 Rails에 추가해야합니다. &lt;code&gt;config/initializers/mime_types.rb&lt;/code&gt; 파일에 다음 줄을 추가하면됩니다 :</target>
        </trans-unit>
        <trans-unit id="1c259d151655b1917e97acadee79d5579af946a0" translate="yes" xml:space="preserve">
          <source>In order to change engine's priority you can use &lt;code&gt;config.railties_order&lt;/code&gt; in the main application. It will affect the priority of loading views, helpers, assets, and all the other files related to engine or application.</source>
          <target state="translated">엔진 우선 순위를 변경하기 위해 기본 애플리케이션에서 &lt;code&gt;config.railties_order&lt;/code&gt; 를 사용할 수 있습니다 . 뷰, 도우미, 자산 및 엔진 또는 응용 프로그램과 관련된 다른 모든 파일의 우선 순위에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="f7199abd7ed7d1a2fbcfd4e2d260b9e8d6a648b3" translate="yes" xml:space="preserve">
          <source>In order to correctly invalidate the cache, you need to properly define the caching dependencies. Rails is clever enough to handle common cases so you don't have to specify anything. However, sometimes, when you're dealing with custom helpers for instance, you need to explicitly define them.</source>
          <target state="translated">캐시를 올바르게 무효화하려면 캐싱 종속성을 올바르게 정의해야합니다. Rails는 일반적인 경우를 처리하기에 충분히 영리하므로 아무 것도 지정할 필요가 없습니다. 그러나 때로는 예를 들어 사용자 지정 도우미를 처리 할 때 명시 적으로 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="d0a530ba61d4811b2b142c8b4e65c31a5d957a7f" translate="yes" xml:space="preserve">
          <source>In order to develop secure web applications you have to keep up to date on all layers and know your enemies. To keep up to date subscribe to security mailing lists, read security blogs, and make updating and security checks a habit (check the &lt;a href=&quot;#additional-resources&quot;&gt;Additional Resources&lt;/a&gt; chapter). It is done manually because that's how you find the nasty logical security problems.</source>
          <target state="translated">안전한 웹 응용 프로그램을 개발하려면 모든 계층에 대한 최신 정보를 유지하고 적을 알아야합니다. 최신 보안 메일 링리스트를 구독하고 보안 블로그를 읽고 업데이트 및 보안 검사를 습관화하십시오 ( &lt;a href=&quot;#additional-resources&quot;&gt;추가 자료&lt;/a&gt; 장 참조). 그것은 당신이 불쾌한 논리적 보안 문제를 찾는 방법이기 때문에 수동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c80eb3d9bc865a25159d18d747353ab8f8e5787e" translate="yes" xml:space="preserve">
          <source>In order to find the first address that is (probably) accurate, we take the list of IPs, remove known and trusted proxies, and then take the last address left, which was presumably set by one of those proxies.</source>
          <target state="translated">(아마도) 정확한 첫 번째 주소를 찾기 위해 IP 목록을 가져오고 알려진 프록시와 신뢰할 수있는 프록시를 제거한 다음 마지막 프록시 주소 중 하나를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6354c48f70c32d4750012cacd9da8ac279600087" translate="yes" xml:space="preserve">
          <source>In order to get a ROLLBACK for the nested transaction you may ask for a real sub-transaction by passing &lt;code&gt;requires_new: true&lt;/code&gt;. If anything goes wrong, the database rolls back to the beginning of the sub-transaction without rolling back the parent transaction. If we add it to the previous example:</source>
          <target state="translated">중첩 트랜잭션에 대한 ROLLBACK을 얻으려면 require_new &lt;code&gt;requires_new: true&lt;/code&gt; 를 전달하여 실제 하위 트랜잭션을 요청할 수 있습니다 . 문제가 발생하면 데이터베이스는 상위 트랜잭션을 롤백하지 않고 서브 트랜잭션의 시작 부분으로 롤백합니다. 이전 예제에 추가하면 :</target>
        </trans-unit>
        <trans-unit id="e26649ba097d4b8921bb548f0cb7e181f098517c" translate="yes" xml:space="preserve">
          <source>In order to get around this problem, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;&lt;code&gt;transaction&lt;/code&gt;&lt;/a&gt; will emulate the effect of nested transactions, by using savepoints: &lt;a href=&quot;https://dev.mysql.com/doc/refman/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/en/savepoint.html&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="410e25b9e9888fb013e4964fa7a83949db21bdb0" translate="yes" xml:space="preserve">
          <source>In order to get around this problem, &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;transaction&lt;/a&gt; will emulate the effect of nested transactions, by using savepoints: &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt;Savepoints are supported by MySQL and PostgreSQL. SQLite3 version &amp;gt;= '3.6.8' supports savepoints.</source>
          <target state="translated">이 문제를 해결하기 위해 &lt;a href=&quot;databasestatements#method-i-transaction&quot;&gt;트랜잭션&lt;/a&gt; 은 저장 점을 사용하여 중첩 된 트랜잭션의 효과를 에뮬레이션합니다. &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/savepoint.html&quot;&gt;dev.mysql.com/doc/refman/5.7/en/savepoint.html&lt;/a&gt; 저장 점 은 MySQL 및 PostgreSQL에서 지원됩니다. SQLite3 버전&amp;gt; = '3.6.8'은 저장 점을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="dd11742e858f6334bdad83633d6fa6c8c53354ab" translate="yes" xml:space="preserve">
          <source>In order to have a near-zero default footprint, Active Support does not load anything by default. It is broken in small pieces so that you can load just what you need, and also has some convenience entry points to load related extensions in one shot, even everything.</source>
          <target state="translated">기본 설치 공간이 거의 제로에 가깝도록 Active Support는 기본적으로 아무것도로드하지 않습니다. 필요한 부분 만로드 할 수 있도록 작은 조각으로 나뉘어 있으며 관련 확장을 한 번에, 심지어 모든 항목에로드 할 수있는 편리한 진입 점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d82c837ad4838a769498f05c39e5cc7258777bc1" translate="yes" xml:space="preserve">
          <source>In order to load &lt;code&gt;ApplicationController&lt;/code&gt;, Rails iterates over &lt;code&gt;autoload_paths&lt;/code&gt;. First it checks if &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; exists. If it does not, which is normally the case, it continues and finds &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ApplicationController&lt;/code&gt; 를로드하기 위해 Rails는 &lt;code&gt;autoload_paths&lt;/code&gt; 를 반복 합니다. 먼저 &lt;code&gt;app/assets/application_controller.rb&lt;/code&gt; 가 있는지 확인 합니다. 그렇지 않은 경우 (일반적으로) &lt;code&gt;app/controllers/application_controller.rb&lt;/code&gt; 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="4446192ce96a4398b61fcdab3b6475fcb7381eb8" translate="yes" xml:space="preserve">
          <source>In order to make your custom transliterations available, you must set them as the &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n key:</source>
          <target state="translated">사용자 정의 음역을 사용 가능하게하려면 &lt;code&gt;i18n.transliterate.rule&lt;/code&gt; i18n 키로 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="73d914ea93f06da557242e0d8ce9a09c0b88f5d6" translate="yes" xml:space="preserve">
          <source>In order to mitigate SSL attacks, &lt;code&gt;form_authenticity_token&lt;/code&gt; is now masked so that it varies with each request. Thus, tokens are validated by unmasking and then decrypting. As a result, any strategies for verifying requests from non-rails forms that relied on a static session CSRF token have to take this into account.</source>
          <target state="translated">SSL 공격을 완화하기 위해 각 요청에 따라 &lt;code&gt;form_authenticity_token&lt;/code&gt; 이 마스크 처리됩니다. 따라서 토큰은 마스크를 해제 한 다음 해독하여 유효성을 검사합니다. 결과적으로 정적 세션 CSRF 토큰에 의존하는 비 레일 형식의 요청을 확인하기위한 모든 전략이이를 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="cc82d22a9f284ef62e02e9541120ccbb65275b2b" translate="yes" xml:space="preserve">
          <source>In order to mitigate such attacks, &lt;em&gt;display a generic error message on forgot-password pages, too&lt;/em&gt;. Moreover, you can &lt;em&gt;require to enter a CAPTCHA after a number of failed logins from a certain IP address&lt;/em&gt;. Note, however, that this is not a bullet-proof solution against automatic programs, because these programs may change their IP address exactly as often. However, it raises the barrier of an attack.</source>
          <target state="translated">이러한 공격을 완화하려면 &lt;em&gt;잊어 버린 비밀번호 페이지에도 일반적인 오류 메시지를 표시하십시오&lt;/em&gt; . 또한 &lt;em&gt;특정 IP 주소에서 여러 번 로그인에 실패한 후 보안 문자를 입력해야&lt;/em&gt; 할 수도 있습니다 . 그러나 자동 프로그램에 대한 방탄 솔루션은 아닙니다. 이러한 프로그램은 IP 주소를 정확하게 변경할 수 있기 때문입니다. 그러나 공격의 장벽을 높입니다.</target>
        </trans-unit>
        <trans-unit id="b8932dfdb433984f20a34dffa003cc8435f6ddf0" translate="yes" xml:space="preserve">
          <source>In order to remove existing data from the database, Rails tries to disable referential integrity triggers (like foreign keys and check constraints). If you are getting annoying permission errors on running tests, make sure the database user has privilege to disable these triggers in testing environment. (In PostgreSQL, only superusers can disable all triggers. Read more about PostgreSQL permissions &lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;here&lt;/a&gt;).</source>
          <target state="translated">Rails는 데이터베이스에서 기존 데이터를 제거하기 위해 외래 키 및 검사 제약 조건과 같은 참조 무결성 트리거를 비활성화하려고합니다. 테스트를 실행할 때 성가신 권한 오류가 발생하는 경우 데이터베이스 사용자에게 테스트 환경에서 이러한 트리거를 비활성화 할 권한이 있는지 확인하십시오. (PostgreSQL에서는 수퍼 유저 만 모든 트리거를 비활성화 할 수 있습니다. PostgreSQL 권한에 대한 자세한 내용은 &lt;a href=&quot;http://blog.endpoint.com/2012/10/postgres-system-triggers-error.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 ).</target>
        </trans-unit>
        <trans-unit id="5a4a7a0f642197b841efadf70eba60e4f93b6dab" translate="yes" xml:space="preserve">
          <source>In order to run your tests, your test database will need to have the current structure. The test helper checks whether your test database has any pending migrations. It will try to load your &lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/structure.sql&lt;/code&gt; into the test database. If migrations are still pending, an error will be raised. Usually this indicates that your schema is not fully migrated. Running the migrations against the development database (&lt;code&gt;bin/rails db:migrate&lt;/code&gt;) will bring the schema up to date.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591a364b06e24638cd2bbe248317d0147d336890" translate="yes" xml:space="preserve">
          <source>In order to run your tests, your test database will need to have the current structure. The test helper checks whether your test database has any pending migrations. It will try to load your &lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/structure.sql&lt;/code&gt; into the test database. If migrations are still pending, an error will be raised. Usually this indicates that your schema is not fully migrated. Running the migrations against the development database (&lt;code&gt;rails db:migrate&lt;/code&gt;) will bring the schema up to date.</source>
          <target state="translated">테스트를 실행하려면 테스트 데이터베이스에 현재 구조가 있어야합니다. 테스트 도우미는 테스트 데이터베이스에 보류중인 마이그레이션이 있는지 확인합니다. &lt;code&gt;db/schema.rb&lt;/code&gt; 또는 &lt;code&gt;db/structure.sql&lt;/code&gt; 을 테스트 데이터베이스 에로드하려고 시도 합니다. 마이그레이션이 여전히 보류 중이면 오류가 발생합니다. 일반적으로 이는 스키마가 완전히 마이그레이션되지 않았 음을 나타냅니다. 개발 데이터베이스 ( &lt;code&gt;rails db:migrate&lt;/code&gt; ) 에 대해 마이그레이션을 실행하면 스키마가 최신 상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="58f575461fcf64d202b669e6b7c232ec89e9af74" translate="yes" xml:space="preserve">
          <source>In order to test helpers, all you need to do is check that the output of the helper method matches what you'd expect. Tests related to the helpers are located under the &lt;code&gt;test/helpers&lt;/code&gt; directory.</source>
          <target state="translated">헬퍼를 테스트하려면 헬퍼 메소드의 출력이 예상 한 것과 일치하는지 확인하면됩니다. 헬퍼와 관련된 테스트는 &lt;code&gt;test/helpers&lt;/code&gt; 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ceb97c0e3b59e713cb40747cecd51d611b98bbe" translate="yes" xml:space="preserve">
          <source>In order to test that your mailer is working as expected, you can use unit tests to compare the actual results of the mailer with pre-written examples of what should be produced.</source>
          <target state="translated">메일러가 예상대로 작동하는지 테스트하기 위해 단위 테스트를 사용하여 메일러의 실제 결과를 미리 작성된 예제의 미리 작성된 예제와 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ed14a4839497197db3034ba8b5734ade36f0cf" translate="yes" xml:space="preserve">
          <source>In order to understand Ajax, you must first understand what a web browser does normally.</source>
          <target state="translated">Ajax를 이해하려면 먼저 웹 브라우저가 정상적으로 수행하는 작업을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="46312161d035588213184c9f80aa1fb2fc07cd0c" translate="yes" xml:space="preserve">
          <source>In order to understand what a generator template means, let's create the file &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; with the following content:</source>
          <target state="translated">생성기 템플릿의 의미를 이해하기 위해 다음 내용으로 &lt;code&gt;lib/generators/initializer/templates/initializer.rb&lt;/code&gt; 파일을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="2dafc9d9596d13d715d332c34c77662537a84e00" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; with Strong Parameters, you will need to specify which nested attributes should be permitted. You might want to allow &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:_destroy&lt;/code&gt;, see &lt;code&gt;ActiveRecord::NestedAttributes&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="107547c56e4f88408e05c37dbf186d51ea22566e" translate="yes" xml:space="preserve">
          <source>In order to use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; with Strong Parameters, you will need to specify which nested attributes should be permitted. You might want to allow &lt;code&gt;:id&lt;/code&gt; and &lt;code&gt;:_destroy&lt;/code&gt;, see ActiveRecord::NestedAttributes for more information.</source>
          <target state="translated">강한 매개 변수와 함께 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 를 사용하려면 허용 할 중첩 속성을 지정해야합니다. &lt;code&gt;:id&lt;/code&gt; 및 &lt;code&gt;:_destroy&lt;/code&gt; 를 허용 할 수 있습니다 . 자세한 정보는 ActiveRecord :: NestedAttributes를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="40d37692f2f31f03a36c5e7dcd20c22020868c24" translate="yes" xml:space="preserve">
          <source>In order to use a different file, call &lt;code&gt;layout&lt;/code&gt; in your mailer:</source>
          <target state="translated">다른 파일을 사용하려면 메일러에서 &lt;code&gt;layout&lt;/code&gt; 을 호출 하십시오.</target>
        </trans-unit>
        <trans-unit id="6d85767016fa3a495331b4fb23a752c703fee817" translate="yes" xml:space="preserve">
          <source>In order to use instantiated fixtures with preloaded data, set &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; to true. This will provide access to fixture data for every table that has been loaded through fixtures (depending on the value of &lt;code&gt;use_instantiated_fixtures&lt;/code&gt;).</source>
          <target state="translated">사전로드 된 데이터와 함께 인스턴스화 된 조명기를 사용하려면 &lt;code&gt;self.pre_loaded_fixtures&lt;/code&gt; 를 true로 설정 하십시오 . 이것은 조명기를 통해로드 된 모든 테이블에 대한 조명기 데이터에 대한 액세스를 제공합니다 ( &lt;code&gt;use_instantiated_fixtures&lt;/code&gt; 값에 따라 다름 ).</target>
        </trans-unit>
        <trans-unit id="8aa6dfda7fe6d0a2e28b88ecf5778900099c604b" translate="yes" xml:space="preserve">
          <source>In order to use optimistic locking, the table needs to have a column called &lt;code&gt;lock_version&lt;/code&gt; of type integer. Each time the record is updated, Active Record increments the &lt;code&gt;lock_version&lt;/code&gt; column. If an update request is made with a lower value in the &lt;code&gt;lock_version&lt;/code&gt; field than is currently in the &lt;code&gt;lock_version&lt;/code&gt; column in the database, the update request will fail with an &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18bdaed8e369471a7df6f869f483701a9bf4a802" translate="yes" xml:space="preserve">
          <source>In order to use optimistic locking, the table needs to have a column called &lt;code&gt;lock_version&lt;/code&gt; of type integer. Each time the record is updated, Active Record increments the &lt;code&gt;lock_version&lt;/code&gt; column. If an update request is made with a lower value in the &lt;code&gt;lock_version&lt;/code&gt; field than is currently in the &lt;code&gt;lock_version&lt;/code&gt; column in the database, the update request will fail with an &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt;. Example:</source>
          <target state="translated">낙관적 잠금을 사용하려면 테이블에 정수 유형의 &lt;code&gt;lock_version&lt;/code&gt; 이라는 열이 있어야합니다 . 레코드가 업데이트 될 때마다 활성 레코드는 &lt;code&gt;lock_version&lt;/code&gt; 열을 증가시킵니다 . 데이터베이스 의 &lt;code&gt;lock_version&lt;/code&gt; 열에있는 것보다 &lt;code&gt;lock_version&lt;/code&gt; 필드 에서 더 낮은 값으로 업데이트 요청을하는 경우 &lt;code&gt;ActiveRecord::StaleObjectError&lt;/code&gt; 와 함께 업데이트 요청이 실패 합니다. 예:</target>
        </trans-unit>
        <trans-unit id="97f8db0543047a0b8ca16dbd131cc3b42104554f" translate="yes" xml:space="preserve">
          <source>In order to use streaming, you will need to use a Ruby version that supports fibers (fibers are supported since version 1.9.2 of the main Ruby implementation).</source>
          <target state="translated">스트리밍을 사용하려면 파이버를 지원하는 Ruby 버전을 사용해야합니다 (기본 Ruby 구현 버전 1.9.2부터 파이버가 지원됨).</target>
        </trans-unit>
        <trans-unit id="dba418ad8c83fa1633e3b40c0d2bddfc1c0342ec" translate="yes" xml:space="preserve">
          <source>In order to use the PostgreSQL adapter you need to have at least version 9.3 installed. Older versions are not supported.</source>
          <target state="translated">PostgreSQL 어댑터를 사용하려면 버전 9.3 이상이 설치되어 있어야합니다. 이전 버전은 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8a387461da518b7b0ce941ea8ccc2c1adfc8d6" translate="yes" xml:space="preserve">
          <source>In order to use the available callbacks, you need to register them. You can implement the callbacks as ordinary methods and use a macro-style class method to register them as callbacks:</source>
          <target state="translated">사용 가능한 콜백을 사용하려면 콜백을 등록해야합니다. 콜백을 일반 메소드로 구현하고 매크로 스타일 클래스 메소드를 사용하여 콜백으로 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d0b40146c6f65e6dde8c5670a9643e8aee5e87" translate="yes" xml:space="preserve">
          <source>In order to use these methods to access fixtured data within your test cases, you must specify one of the following in your ActiveSupport::TestCase-derived class:</source>
          <target state="translated">이러한 방법을 사용하여 테스트 사례 내에서 고정 된 데이터에 액세스하려면 ActiveSupport :: TestCase 파생 클래스에서 다음 중 하나를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="651da9723da705d25ae3a7c22c950d1248914e1f" translate="yes" xml:space="preserve">
          <source>In order to use this helper, you need to install &lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem by adding this line to your &lt;code&gt;Gemfile&lt;/code&gt;: &lt;code&gt;gem 'dynamic_form'&lt;/code&gt;.</source>
          <target state="translated">이 도우미를 사용하려면 &lt;code&gt;Gemfile&lt;/code&gt; 에 다음 줄을 추가하여 &lt;a href=&quot;https://github.com/joelmoss/dynamic_form&quot;&gt;DynamicForm&lt;/a&gt; gem 을 설치해야합니다 : &lt;code&gt;gem 'dynamic_form'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ab4e37bd8136ae2e3df92d16165dff5ee0c42e5" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose absence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">부재가 필요한 관련 레코드의 유효성을 검사하려면 연결에 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4f288ff2a7ae3e4f9c2eb79749ecb68121c66351" translate="yes" xml:space="preserve">
          <source>In order to validate associated records whose presence is required, you must specify the &lt;code&gt;:inverse_of&lt;/code&gt; option for the association:</source>
          <target state="translated">프레즌스가 필요한 관련 레코드의 유효성을 검사하려면 연결에 &lt;code&gt;:inverse_of&lt;/code&gt; 옵션을 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6ad8911afee8f018433af65d3c5c48e90882bf70" translate="yes" xml:space="preserve">
          <source>In order to work with Action Controller, a &lt;a href=&quot;context&quot;&gt;&lt;code&gt;Context&lt;/code&gt;&lt;/a&gt; must just include this module. The initialization of the variables used by the context (@output_buffer, @view_flow, and @virtual_path) is responsibility of the object that includes this module (although you can call &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;&lt;code&gt;_prepare_context&lt;/code&gt;&lt;/a&gt; defined below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="218a79265ec0fd7c85e83c35da82e6a7ffce9b16" translate="yes" xml:space="preserve">
          <source>In order to work with Action Controller, a &lt;a href=&quot;context&quot;&gt;Context&lt;/a&gt; must just include this module. The initialization of the variables used by the context (@output_buffer, @view_flow, and @virtual_path) is responsibility of the object that includes this module (although you can call &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;#_prepare_context&lt;/a&gt; defined below).</source>
          <target state="translated">Action Controller로 작업 하려면 &lt;a href=&quot;context&quot;&gt;컨텍스트&lt;/a&gt; 에이 모듈 만 포함해야합니다. 컨텍스트에 사용되는 변수 (@output_buffer, @view_flow 및 @virtual_path)의 초기화는이 모듈을 포함하는 객체의 책임입니다 ( 아래에 정의 된 &lt;a href=&quot;context#method-i-_prepare_context&quot;&gt;#_prepare_context&lt;/a&gt; 를 호출 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b483ca18407dce764b375bf3103a7eee8c3384af" translate="yes" xml:space="preserve">
          <source>In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with &lt;code&gt;#call&lt;/code&gt; method:</source>
          <target state="translated">다른 상황에서는이 동작을 변경하고 싶을 수도 있습니다. 예를 들어 기본 예외 처리는 자동화 된 테스트 중에 누락 된 번역을 쉽게 잡을 수 없습니다. 이를 위해 다른 예외 처리기를 지정할 수 있습니다. 지정된 예외 핸들러는 I18n 모듈의 메소드이거나 &lt;code&gt;#call&lt;/code&gt; 메소드가 있는 클래스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="781ae875a5c05903197dc86e271bf311559a5cc2" translate="yes" xml:space="preserve">
          <source>In other contexts you might want to change this behavior, though. E.g. the default exception handling does not allow to catch missing translations during automated tests easily. For this purpose a different exception handler can be specified. The specified exception handler must be a method on the I18n module or a class with a &lt;code&gt;call&lt;/code&gt; method:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="877dfae80b5d0ddfc07be49dc93d9293f1279a0c" translate="yes" xml:space="preserve">
          <source>In other environments &lt;code&gt;Rails.application.config.hosts&lt;/code&gt; is empty and no &lt;code&gt;Host&lt;/code&gt; header checks will be done. If you want to guard against header attacks on production, you have to manually permit the allowed hosts with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="393cd9beea03d987167d30b004ade204e3cf72ad" translate="yes" xml:space="preserve">
          <source>In other words, this query can be generated by calling &lt;code&gt;where&lt;/code&gt; with no argument, then immediately chain with &lt;code&gt;not&lt;/code&gt; passing &lt;code&gt;where&lt;/code&gt; conditions. This will generate SQL like this:</source>
          <target state="translated">즉,이 쿼리는 인수없이 &lt;code&gt;where&lt;/code&gt; 를 호출 한 다음 &lt;code&gt;where&lt;/code&gt; 조건을 전달 &lt;code&gt;not&lt;/code&gt; 즉시 연결하여 생성 할 수 있습니다 . 다음과 같은 SQL이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="f14055d795b486afde1a4cf285f261794af7f815" translate="yes" xml:space="preserve">
          <source>In other words, we make the request so that it operates on a single entity's person. Then, in the action, we extract the company data from the request, find or create the company, and then create the new person with the remaining data.</source>
          <target state="translated">다시 말해, 우리는 단일 실체의 개인에 대해 운영되도록 요청합니다. 그런 다음 작업에서 요청에서 회사 데이터를 추출하고 회사를 찾거나 생성 한 다음 나머지 데이터로 새 사람을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8c47a20f437054f4ca7a327a1a842acd08b76b69" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;Colors::RED&lt;/code&gt; is totally unrelated to any other &lt;code&gt;RED&lt;/code&gt; constant that may live in any other class or module object. If there were any, they would have separate entries in their respective constant tables.</source>
          <target state="translated">특히, &lt;code&gt;Colors::RED&lt;/code&gt; 는 다른 클래스 또는 모듈 객체에있을 수 있는 다른 &lt;code&gt;RED&lt;/code&gt; 상수 와 전혀 관련이 없습니다 . 존재하는 경우 해당 상수 테이블에 별도의 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bbc81dc05e3ca5c6f8c3d2409439a68ba3f44d" translate="yes" xml:space="preserve">
          <source>In particular, simple routing makes it very easy to map legacy URLs to new Rails actions.</source>
          <target state="translated">특히 간단한 라우팅을 통해 레거시 URL을 새로운 Rails 액션에 매우 쉽게 매핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b80c87979c07427dbbadbad87cc7038c0873204" translate="yes" xml:space="preserve">
          <source>In particular, thanks to the conventions followed in the generated field names, the controller gets a nested hash &lt;code&gt;params[:person]&lt;/code&gt; with the person attributes set in the form. That hash is ready to be passed to &lt;code&gt;Person.new&lt;/code&gt;:</source>
          <target state="translated">특히, 생성 된 필드 이름의 규칙에 따라 컨트롤러는 person 속성이 양식에 설정된 중첩 해시 &lt;code&gt;params[:person]&lt;/code&gt; 를 얻습니다 . 해시는 &lt;code&gt;Person.new&lt;/code&gt; 에 전달 될 준비가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="a9a2eb08117638628d90ba0302a5370951bb7703" translate="yes" xml:space="preserve">
          <source>In practice, more robust code is necessary to do this reliably. Iain Hecker's &lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt; library or Ryan Tomayko's &lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;locale&lt;/a&gt; Rack middleware provide solutions to this problem.</source>
          <target state="translated">실제로이 작업을 안정적으로 수행하려면보다 강력한 코드가 필요합니다. Iain Hecker의 &lt;a href=&quot;https://github.com/iain/http_accept_language/tree/master&quot;&gt;http_accept_language&lt;/a&gt; 라이브러리 또는 Ryan Tomayko의 &lt;a href=&quot;https://github.com/rack/rack-contrib/blob/master/lib/rack/contrib/locale.rb&quot;&gt;로케일&lt;/a&gt; 랙 미들웨어가이 문제에 대한 솔루션을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0802cfe51fdef2c921e267ee151179358a255e95" translate="yes" xml:space="preserve">
          <source>In practice, this will allow you to precompile locally, have those files in your working tree, and commit those files to source control when needed. Development mode will work as expected.</source>
          <target state="translated">실제로이를 통해 로컬로 사전 컴파일하고 작업 트리에 해당 파일을 보유하고 필요할 때 해당 파일을 소스 제어에 커밋 할 수 있습니다. 개발 모드가 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bfb8683e07369e8581df19e40a7fbd85c022d176" translate="yes" xml:space="preserve">
          <source>In practice, this works quite well as long as the nesting matches all parent namespaces respectively and the constants that make the rule apply are known at that time.</source>
          <target state="translated">실제로 이것은 중첩이 모든 부모 네임 스페이스와 각각 일치하고 규칙을 적용하는 상수가 그 시간에 알려진 한 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="9f32eee395899344bec411ccbf6930fd17ef9d92" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails the controller will include a helper which matches the name of the controller, e.g., &lt;code&gt;MyController&lt;/code&gt; will automatically include &lt;code&gt;MyHelper&lt;/code&gt;. To return old behavior set &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">이전 버전의 Rails에는 컨트롤러 이름과 일치하는 도우미가 컨트롤러에 포함 &lt;code&gt;MyHelper&lt;/code&gt; . 예를 들어 &lt;code&gt;MyController&lt;/code&gt; 는 자동으로 MyHelper를 포함 합니다 . 이전 동작을 반환하려면 &lt;code&gt;config.action_controller.include_all_helpers&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="000873b5afa3c22fba1eb16efc6a7ef51c867059" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails the controller will include a helper which matches the name of the controller, e.g., &lt;code&gt;MyController&lt;/code&gt; will automatically include &lt;code&gt;MyHelper&lt;/code&gt;. You can revert to the old behavior with the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="387fca91ce034b1ccf78d7b329410a4b592846a5" translate="yes" xml:space="preserve">
          <source>In previous versions of Rails, all assets were located in subdirectories of &lt;code&gt;public&lt;/code&gt; such as &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;javascripts&lt;/code&gt; and &lt;code&gt;stylesheets&lt;/code&gt;. With the asset pipeline, the preferred location for these assets is now the &lt;code&gt;app/assets&lt;/code&gt; directory. Files in this directory are served by the Sprockets middleware.</source>
          <target state="translated">레일스의 이전 버전에서는 모든 자산이 &lt;code&gt;images&lt;/code&gt; , &lt;code&gt;javascripts&lt;/code&gt; 및 &lt;code&gt;stylesheets&lt;/code&gt; 와 같은 &lt;code&gt;public&lt;/code&gt; 하위 디렉토리에있었습니다 . 자산 파이프 라인에서 이러한 자산의 선호 위치는 이제 &lt;code&gt;app/assets&lt;/code&gt; 디렉토리입니다. 이 디렉토리의 파일은 Sprockets 미들웨어에서 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7dc5570153310ae5658bb85dc33107a7d11c2edb" translate="yes" xml:space="preserve">
          <source>In previous versions when you defined a &lt;code&gt;default_scope&lt;/code&gt; in a model it was overridden by chained conditions in the same field. Now it is merged like any other scope.</source>
          <target state="translated">이전 버전에서는 모델에서 &lt;code&gt;default_scope&lt;/code&gt; 를 정의 할 때 동일한 필드의 체인 조건으로 재정의되었습니다. 이제 다른 범위와 같이 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="acdc2b5830d037a308e1f80820fc64001fe34307" translate="yes" xml:space="preserve">
          <source>In production, Rails precompiles these files to &lt;code&gt;public/assets&lt;/code&gt; by default. The precompiled copies are then served as static assets by the web server. The files in &lt;code&gt;app/assets&lt;/code&gt; are never served directly in production.</source>
          <target state="translated">프로덕션 환경에서 Rails 는 기본적으로 이러한 파일을 &lt;code&gt;public/assets&lt;/code&gt; 으로 사전 컴파일합니다 . 그런 다음 사전 컴파일 된 사본은 웹 서버에서 정적 자산으로 제공됩니다. &lt;code&gt;app/assets&lt;/code&gt; 의 파일은 프로덕션에서 직접 제공되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bd1c2f4bacd2e42e0926f761088b2fa08f639486" translate="yes" xml:space="preserve">
          <source>In production-like environments it is generally better to load all the application code when the application boots. Eager loading puts everything in memory ready to serve requests right away, and it is also &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt;-friendly.</source>
          <target state="translated">프로덕션 환경에서는 일반적으로 응용 프로그램이 부팅 될 때 모든 응용 프로그램 코드를로드하는 것이 좋습니다. 빠른 로딩은 요청을 즉시 처리 할 수 ​​있도록 메모리의 모든 것을 준비하고 &lt;a href=&quot;https://en.wikipedia.org/wiki/Copy-on-write&quot;&gt;CoW&lt;/a&gt; 친화적입니다.</target>
        </trans-unit>
        <trans-unit id="867aa3c331895802d160c399e93401a07e010863" translate="yes" xml:space="preserve">
          <source>In rare circumstances you might need to access the mapping directly. The mappings are exposed through a class method with the pluralized attribute name, which return the mapping in a &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt;:</source>
          <target state="translated">드문 경우이지만 매핑에 직접 액세스해야 할 수도 있습니다. 맵핑은 복수화 된 속성 이름을 가진 클래스 메소드를 통해 노출되며 &lt;code&gt;HashWithIndifferentAccess&lt;/code&gt; 의 맵핑을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="f6955c0b68123d164c5a31f6ca257fa2c43af53a" translate="yes" xml:space="preserve">
          <source>In rare instances, web servers or front proxies strip authorization headers before they reach your application. You can debug this situation by logging all environment variables, and check for HTTP_AUTHORIZATION, amongst others.</source>
          <target state="translated">드문 경우지만 웹 서버 또는 프론트 프록시는 권한 헤더를 애플리케이션에 도달하기 전에 제거합니다. 모든 환경 변수를 로깅하여이 상황을 디버그하고 특히 HTTP_AUTHORIZATION을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="448cd91c5ca45a692c6ec9543871b6564930e128" translate="yes" xml:space="preserve">
          <source>In regular views you can access images in the &lt;code&gt;app/assets/images&lt;/code&gt; directory like this:</source>
          <target state="translated">일반보기에서 다음과 같이 &lt;code&gt;app/assets/images&lt;/code&gt; 디렉토리의 이미지에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3c3559ebe5972927b5ff92b63c5594a0c6c88bf8" translate="yes" xml:space="preserve">
          <source>In some cases we may want to improve the user experience by grouping related options together. We can do so by passing a &lt;code&gt;Hash&lt;/code&gt; (or comparable &lt;code&gt;Array&lt;/code&gt;) to &lt;code&gt;select&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ae7ad8ee810f01851d88cc659fdf8a687fed96" translate="yes" xml:space="preserve">
          <source>In some cases you may want to prevent writes to the database even if you are on a database that can write. `while_preventing_writes` will prevent writes to the database for the duration of the block.</source>
          <target state="translated">어떤 경우에는 쓰기 가능한 데이터베이스에 있더라도 데이터베이스에 쓰지 못하게 할 수 있습니다. `while_preventing_writes`는 블록 동안 데이터베이스에 대한 쓰기를 방지합니다.</target>
        </trans-unit>
        <trans-unit id="63907cb4d7bbd2358a6c2a5dc4424176f3b96f9a" translate="yes" xml:space="preserve">
          <source>In some cases you might want to override a default service for a specific attachment. You can configure specific services per attachment using the &lt;code&gt;service&lt;/code&gt; option:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f80e06d03640ad157d5355c15d46fb341b319a3" translate="yes" xml:space="preserve">
          <source>In some cases, like a single table inheritance setup, you might have a bunch of explicit dependencies. Instead of writing every template out, you can use a wildcard to match any template in a directory:</source>
          <target state="translated">경우에 따라 단일 테이블 상속 설정과 같이 명시적인 종속성이 많이있을 수 있습니다. 모든 템플리트를 작성하는 대신 와일드 카드를 사용하여 디렉토리의 모든 템플리트를 일치시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3131b4ceda57af774c0368b496b38c23e7f116b4" translate="yes" xml:space="preserve">
          <source>In some cases, you may want to provide a boolean hook. For example, webrat developers might want to have webrat available on controller generator. This can be achieved as:</source>
          <target state="translated">경우에 따라 부울 후크를 제공 할 수도 있습니다. 예를 들어, Webrat 개발자는 컨트롤러 생성기에서 Webrat를 사용할 수 있습니다. 이것은 다음과 같이 달성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="47b358a6bb6300b251cb348fc564a8833f7d939e" translate="yes" xml:space="preserve">
          <source>In some circumstances you may wish to use live compilation. In this mode all requests for assets in the pipeline are handled by Sprockets directly.</source>
          <target state="translated">경우에 따라 라이브 컴파일을 사용하고자 할 수도 있습니다. 이 모드에서는 파이프 라인의 자산에 대한 모든 요청이 Sprockets에서 직접 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="5f915ed8669a78a1a735442736b9533062f4ecfc" translate="yes" xml:space="preserve">
          <source>In some scenarios you may want to add back some functionality provided by &lt;code&gt;ActionController::Base&lt;/code&gt; that is not present by default in &lt;code&gt;ActionController::API&lt;/code&gt;, for instance &lt;code&gt;MimeResponds&lt;/code&gt;. This module gives you the &lt;code&gt;respond_to&lt;/code&gt; method. Adding it is quite simple, you just need to include the module in a specific controller or in &lt;code&gt;ApplicationController&lt;/code&gt; in case you want it available in your entire application:</source>
          <target state="translated">일부 시나리오에서는 기본적으로 &lt;code&gt;ActionController::API&lt;/code&gt; 에없는 &lt;code&gt;ActionController::Base&lt;/code&gt; 가 제공하는 일부 기능 ( 예 : &lt;code&gt;MimeResponds&lt;/code&gt; )을 다시 추가 할 수 있습니다 . 이 모듈은 &lt;code&gt;respond_to&lt;/code&gt; 메소드를 제공합니다 . 추가하는 것은 매우 간단 합니다. 전체 응용 &lt;code&gt;ApplicationController&lt;/code&gt; 에서 모듈을 사용하려는 경우 특정 컨트롤러 또는 ApplicationController 에 모듈을 포함하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="17f0250b4e2377f22078b52d68151700c5137bc6" translate="yes" xml:space="preserve">
          <source>In special situations, where someone from the Core Team agrees to support more series, they are included in the list of supported series.</source>
          <target state="translated">핵심 팀의 누군가가 더 많은 시리즈를 지원하기로 동의 한 특별한 상황에서는 지원되는 시리즈 목록에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d3f08fa535d4de28e332a84e5bf7432c5065e585" translate="yes" xml:space="preserve">
          <source>In such actions, you want to delay queries execution as much as you can. For example, imagine the following &lt;code&gt;dashboard&lt;/code&gt; action:</source>
          <target state="translated">이러한 작업에서 쿼리 실행을 최대한 지연 시키려고합니다. 예를 들어 다음 &lt;code&gt;dashboard&lt;/code&gt; 작업을 상상해보십시오 .</target>
        </trans-unit>
        <trans-unit id="e22a8c55bcb2ac30014d38e167eb68330f7cd298" translate="yes" xml:space="preserve">
          <source>In such case, it could even happen that the reassigned &lt;code&gt;A&lt;/code&gt; held a new class or module called also &quot;A&quot;!</source>
          <target state="translated">이 경우, 재 할당 된 &lt;code&gt;A&lt;/code&gt; 가 &quot;A&quot;라고하는 새로운 클래스 나 모듈을 보유 하게 될 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="7bc9b2fd355ec60ad8bae876600fcb6906d3ef26" translate="yes" xml:space="preserve">
          <source>In such cases, Ruby's core &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;Date&lt;/a&gt; and &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;Time&lt;/a&gt; should be used for precision date and time arithmetic.</source>
          <target state="translated">이러한 경우 Ruby의 핵심 &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;날짜&lt;/a&gt; 및 &lt;a href=&quot;http://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;시간&lt;/a&gt; 을 정확한 날짜 및 시간 산술에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b35f4f026cddbe44eea63654bf719e4b9893d80" translate="yes" xml:space="preserve">
          <source>In such cases, Ruby's core &lt;a href=&quot;https://ruby-doc.org/stdlib/libdoc/date/rdoc/Date.html&quot;&gt;Date&lt;/a&gt; and &lt;a href=&quot;https://ruby-doc.org/stdlib/libdoc/time/rdoc/Time.html&quot;&gt;Time&lt;/a&gt; should be used for precision date and time arithmetic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6e5eee5ecf78f3cd3e2e32b24d1737913f42f09" translate="yes" xml:space="preserve">
          <source>In such cases, you can precompile assets &lt;em&gt;locally&lt;/em&gt; &amp;mdash; that is, add a finalized set of compiled, production-ready assets to your source code repository before pushing to production. This way, they do not need to be precompiled separately on the production server upon each deployment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0bff25e8a434cb2634348ccc8de80859c72d3c" translate="yes" xml:space="preserve">
          <source>In terms of implementation: Routes are rules written in a Ruby &lt;a href=&quot;https://en.wikipedia.org/wiki/Domain-specific_language&quot;&gt;DSL (Domain-Specific Language)&lt;/a&gt;. Controllers are Ruby classes, and their public methods are actions. And views are templates, usually written in a mixture of HTML and Ruby.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3aac43b2be2d07c0a420f20d829b8934449b3c17" translate="yes" xml:space="preserve">
          <source>In test and development applications get a &lt;code&gt;secret_key_base&lt;/code&gt; derived from the app name. Other environments must use a random key present in &lt;code&gt;config/credentials.yml.enc&lt;/code&gt;, shown here in its decrypted state:</source>
          <target state="translated">테스트 및 개발 애플리케이션 에서 앱 이름에서 파생 된 &lt;code&gt;secret_key_base&lt;/code&gt; 를 얻습니다 . 다른 환경에서는 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 에있는 임의의 키를 사용해야합니다 ( 암호화 된 상태로 여기 표시됨).</target>
        </trans-unit>
        <trans-unit id="0b604c981536c6f7a57e350835fcc0cf00e3e7d1" translate="yes" xml:space="preserve">
          <source>In tests you can simply pass the URL or named route to &lt;code&gt;get&lt;/code&gt; or &lt;code&gt;post&lt;/code&gt;.</source>
          <target state="translated">테스트에서 단순히 URL이나 이름 지정된 경로를 전달하여 &lt;code&gt;get&lt;/code&gt; 또는 &lt;code&gt;post&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbfb856b113f8aa7f20649d6800d05bfc1f91454" translate="yes" xml:space="preserve">
          <source>In that case it is preferable to either use &lt;code&gt;check_box_tag&lt;/code&gt; or to use hashes instead of arrays.</source>
          <target state="translated">이 경우 &lt;code&gt;check_box_tag&lt;/code&gt; 를 사용하거나 배열 대신 해시를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e8a94c0205e8998c88c2b83ec95edd58bd84adb0" translate="yes" xml:space="preserve">
          <source>In that case, &lt;code&gt;app/models/concerns&lt;/code&gt; is assumed to be a root directory (because it belongs to the autoload paths), and it is ignored as namespace. So, &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; should define &lt;code&gt;Foo&lt;/code&gt;, not &lt;code&gt;Concerns::Foo&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;app/models/concerns&lt;/code&gt; 는 루트 디렉토리 (오토로드 경로에 속하기 때문에)로 간주되며 네임 스페이스로 무시됩니다. 따라서 &lt;code&gt;app/models/concerns/foo.rb&lt;/code&gt; 는 &lt;code&gt;Concerns::Foo&lt;/code&gt; 아니라 &lt;code&gt;Foo&lt;/code&gt; 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b13a5797f6fc9e1292d0609d2b1de532169ec70b" translate="yes" xml:space="preserve">
          <source>In that case, batch processing methods allow you to work with the records in batches, thereby greatly reducing memory consumption.</source>
          <target state="translated">이 경우 일괄 처리 방법을 사용하면 레코드를 일괄 처리하여 메모리 소비를 크게 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c1c021f721c684135b59830f5b970354577a47" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;#sessions&quot;&gt;session chapter&lt;/a&gt; you have learned that most Rails applications use cookie-based sessions. Either they store the session ID in the cookie and have a server-side session hash, or the entire session hash is on the client-side. In either case the browser will automatically send along the cookie on every request to a domain, if it can find a cookie for that domain. The controversial point is that if the request comes from a site of a different domain, it will also send the cookie. Let's start with an example:</source>
          <target state="translated">에서 &lt;a href=&quot;#sessions&quot;&gt;세션 장&lt;/a&gt; 당신은 대부분의 레일 응용 프로그램은 쿠키 기반 세션을 사용하는 것이 배웠습니다. 쿠키에 세션 ID를 저장하고 서버 측 세션 해시를 갖거나 전체 세션 해시가 클라이언트 측에 있습니다. 두 경우 모두 브라우저는 도메인에 대한 쿠키를 찾을 수있는 경우 모든 요청에 ​​따라 쿠키를 도메인으로 자동 전송합니다. 논란의 여지가있는 점은 요청이 다른 도메인의 사이트에서 온 경우 쿠키도 전송한다는 것입니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="cda842a28317aed91dd703e8e2c47e5c82db26d0" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ArticlesController&lt;/code&gt; we need to have a way to block access to the various actions if the person is not authenticated. Here we can use the Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; method, which allows access to the requested action if that method allows it.</source>
          <target state="translated">에서 &lt;code&gt;ArticlesController&lt;/code&gt; 우리는 사람이 인증되지 않은 경우 다양한 작업에 대한 액세스를 차단하는 방법이 필요합니다. 여기서 우리는 Rails &lt;code&gt;http_basic_authenticate_with&lt;/code&gt; 메소드를 사용할 수 있습니다.이 메소드는 요청 된 조치가 허용하는 경우 요청 된 조치에 대한 액세스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="109d17caa7860bcdee4fd3c758460f7d4c9a3bc5" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;show&lt;/code&gt; template, we'll render the &lt;code&gt;_article&lt;/code&gt; partial wrapped in the &lt;code&gt;box&lt;/code&gt; layout:</source>
          <target state="translated">에서 &lt;code&gt;show&lt;/code&gt; 템플릿, 우리는 렌더링 것이다 &lt;code&gt;_article&lt;/code&gt; 에 싸여 부분 &lt;code&gt;box&lt;/code&gt; 레이아웃 :</target>
        </trans-unit>
        <trans-unit id="932111316617cc42b0f847695447a92081a2e91f" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;test_should_get_index&lt;/code&gt; test, Rails simulates a request on the action called &lt;code&gt;index&lt;/code&gt;, making sure the request was successful and also ensuring that the right response body has been generated.</source>
          <target state="translated">에서 &lt;code&gt;test_should_get_index&lt;/code&gt; 의 테스트, 레일라는 작업에 요청 시뮬레이션 &lt;code&gt;index&lt;/code&gt; 확인 요청이 성공하고도 적절한 응답 본문이 생성 된 것을 보장하고,.</target>
        </trans-unit>
        <trans-unit id="b0dd914d44cf11ff05a98e10708f475b57b6904b" translate="yes" xml:space="preserve">
          <source>In the Blog application, you will now create a new &lt;em&gt;resource&lt;/em&gt;. A resource is the term used for a collection of similar objects, such as articles, people, or animals. You can create, read, update, and destroy items for a resource and these operations are referred to as &lt;em&gt;CRUD&lt;/em&gt; operations.</source>
          <target state="translated">블로그 애플리케이션에서 이제 새 &lt;em&gt;자원을&lt;/em&gt; 작성 &lt;em&gt;합니다&lt;/em&gt; . 자원은 기사, 사람 또는 동물과 같은 유사한 개체의 모음에 사용되는 용어입니다. 자원에 대한 항목을 작성, 읽기, 업데이트 및 제거 할 수 있으며 이러한 작업을 &lt;em&gt;CRUD&lt;/em&gt; 작업 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="24db4d3c8293c09d3f0c65d469d2a51f794699b9" translate="yes" xml:space="preserve">
          <source>In the Rails framework these hooks are called when a specific library is loaded. For example, when &lt;code&gt;ActionController::Base&lt;/code&gt; is loaded, the &lt;code&gt;:action_controller_base&lt;/code&gt; hook is called. This means that all &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; calls with &lt;code&gt;:action_controller_base&lt;/code&gt; hooks will be called in the context of &lt;code&gt;ActionController::Base&lt;/code&gt; (that means &lt;code&gt;self&lt;/code&gt; will be an &lt;code&gt;ActionController::Base&lt;/code&gt;).</source>
          <target state="translated">Rails 프레임 워크에서 이러한 후크는 특정 라이브러리가로드 될 때 호출됩니다. 예를 들어 &lt;code&gt;ActionController::Base&lt;/code&gt; &lt;code&gt;:action_controller_base&lt;/code&gt; 드되면 : action_controller_base 후크가 호출됩니다. 이는 &lt;code&gt;:action_controller_base&lt;/code&gt; 후크를 사용 하는 모든 &lt;code&gt;ActiveSupport.on_load&lt;/code&gt; 호출 이 &lt;code&gt;ActionController::Base&lt;/code&gt; 의 컨텍스트에서 호출 됨을 의미합니다 (즉, &lt;code&gt;self&lt;/code&gt; 는 &lt;code&gt;ActionController::Base&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="018cf8fd21b3afc27f24b270e9c9f004f622eeca" translate="yes" xml:space="preserve">
          <source>In the above block, a &lt;code&gt;FormBuilder&lt;/code&gt; object is yielded as the &lt;code&gt;person_form&lt;/code&gt; variable. This allows you to generate the &lt;code&gt;text_field&lt;/code&gt; and &lt;code&gt;check_box&lt;/code&gt; fields by specifying their eponymous methods, which modify the underlying template and associates the &lt;code&gt;@person&lt;/code&gt; model object with the form.</source>
          <target state="translated">위의 블록에서 &lt;code&gt;FormBuilder&lt;/code&gt; 객체는 &lt;code&gt;person_form&lt;/code&gt; 변수 로 생성됩니다 . 이를 통해 기본 템플릿을 수정하고 &lt;code&gt;@person&lt;/code&gt; 모델 객체를 양식 과 연결하는 시연 메서드를 지정 하여 &lt;code&gt;text_field&lt;/code&gt; 및 &lt;code&gt;check_box&lt;/code&gt; 필드 를 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9e8f8ae805ddb6dd1112cbcc45e4fc5957590768" translate="yes" xml:space="preserve">
          <source>In the above case as long as Subclass does not assign a value to setting by performing &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt;, &lt;code&gt;Subclass.setting&lt;/code&gt; would read value assigned to parent class. Once Subclass assigns a value then the value assigned by Subclass would be returned.</source>
          <target state="translated">긴 서브 클래스가 수행하여 설정 값을 할당하지 않는 한 위의 경우 &lt;code&gt;Subclass.setting = &lt;em&gt;something&lt;/em&gt;&lt;/code&gt; , &lt;code&gt;Subclass.setting&lt;/code&gt; 는 상위 클래스에 할당 된 값을 읽을 것입니다. 서브 클래스가 값을 할당하면 서브 클래스가 할당 한 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b1cb73fc73094a58e195dd6ca9b80ae9df2dfa1" translate="yes" xml:space="preserve">
          <source>In the above case it would make more sense to use the &lt;code&gt;content_type&lt;/code&gt; setter directly.</source>
          <target state="translated">위의 경우 &lt;code&gt;content_type&lt;/code&gt; setter를 직접 사용하는 것이 더 합리적 입니다.</target>
        </trans-unit>
        <trans-unit id="7e163be244fe8bdb5f530f0935c88b0adb00fc3e" translate="yes" xml:space="preserve">
          <source>In the above case there are still two readings. However &lt;code&gt;person.articles&lt;/code&gt; shows only one article because the collection loads only unique records.</source>
          <target state="translated">위의 경우에는 여전히 두 개의 판독 값이 있습니다. 그러나 컬렉션에는 고유 한 레코드 만로드되므로 &lt;code&gt;person.articles&lt;/code&gt; 에는 하나의 기사 만 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="176a9dc5fbcfae20c994660d52dd8f429b5d77c6" translate="yes" xml:space="preserve">
          <source>In the above case there are two readings and &lt;code&gt;person.articles&lt;/code&gt; brings out both of them even though these records are pointing to the same article.</source>
          <target state="translated">위의 경우이 수치가하고 &lt;code&gt;person.articles&lt;/code&gt; 는 이 기록이 같은 기사를 가리키는 경우에도 그들을 모두 밖으로 제공합니다.</target>
        </trans-unit>
        <trans-unit id="690cd0e61c2000224f7b44dbcc541e9443157e34" translate="yes" xml:space="preserve">
          <source>In the above case whenever you save an account the method &lt;code&gt;Audit#before&lt;/code&gt; will be called. On the other hand</source>
          <target state="translated">위의 경우 계정을 저장할 때마다 &lt;code&gt;Audit#before&lt;/code&gt; 메소드 가 호출됩니다. 반면에</target>
        </trans-unit>
        <trans-unit id="3595b964417e13215c9ef9874bb30f942c3b95bd" translate="yes" xml:space="preserve">
          <source>In the above code, we're passing a few additional options to &lt;code&gt;link_to&lt;/code&gt;. The &lt;code&gt;method: :delete&lt;/code&gt; option causes the link to make a &lt;code&gt;DELETE&lt;/code&gt; request instead of a &lt;code&gt;GET&lt;/code&gt; request. The &lt;code&gt;data: { confirm: &quot;Are you sure?&quot; }&lt;/code&gt; option causes a confirmation dialog to appear when the link is clicked. If the user cancels the dialog, the request is aborted. Both of these options are powered by a feature of Rails called &lt;em&gt;Unobtrusive JavaScript&lt;/em&gt; (UJS). The JavaScript file that implements these behaviors is included by default in fresh Rails applications.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61c2086e20f432dc1f6a9e74cf5ee1fefe93428a" translate="yes" xml:space="preserve">
          <source>In the above example, 'base' will be ignored when creating fixtures. This can be used for common attributes inheriting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20fa2b618a41090d64744e8886e56741eb7768e0" translate="yes" xml:space="preserve">
          <source>In the above example, &lt;code&gt;render&lt;/code&gt; takes 2 options: &lt;code&gt;partial&lt;/code&gt; and &lt;code&gt;locals&lt;/code&gt;. But if these are the only options you want to pass, you can skip using these options. For example, instead of:</source>
          <target state="translated">위의 예에서 &lt;code&gt;render&lt;/code&gt; 는 &lt;code&gt;partial&lt;/code&gt; 및 &lt;code&gt;locals&lt;/code&gt; 의 두 가지 옵션을 사용 합니다. 그러나이 옵션 만 전달하려는 경우이 옵션을 사용하여 건너 뛸 수 있습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="157feea9492cf83c86be261458171459bd27095d" translate="yes" xml:space="preserve">
          <source>In the above example, the configuration from the first application was used to initialize the second application. You can also use the &lt;code&gt;initialize_copy&lt;/code&gt; on one of the applications to create a copy of the application which shares the configuration.</source>
          <target state="translated">위 예에서 첫 번째 응용 프로그램의 구성을 사용하여 두 번째 응용 프로그램을 초기화했습니다. 응용 프로그램 중 하나 에서 &lt;code&gt;initialize_copy&lt;/code&gt; 를 사용 하여 구성을 공유하는 응용 프로그램의 복사본을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="df36d3cfbd0f81e1fcee7ab6ea34d9b1530ff453" translate="yes" xml:space="preserve">
          <source>In the above example, there will be a performance impact even if the allowed output level doesn't include debug. The reason is that Ruby has to evaluate these strings, which includes instantiating the somewhat heavy &lt;code&gt;String&lt;/code&gt; object and interpolating the variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb83d7ff54804b12fe50b173335aa3b0288d1172" translate="yes" xml:space="preserve">
          <source>In the above example, there will be a performance impact even if the allowed output level doesn't include debug. The reason is that Ruby has to evaluate these strings, which includes instantiating the somewhat heavy &lt;code&gt;String&lt;/code&gt; object and interpolating the variables. Therefore, it's recommended to pass blocks to the logger methods, as these are only evaluated if the output level is the same as &amp;mdash; or included in &amp;mdash; the allowed level (i.e. lazy loading). The same code rewritten would be:</source>
          <target state="translated">위의 예에서 허용 된 출력 레벨에 디버그가 포함되지 않은 경우에도 성능에 영향을 미칩니다. 그 이유는 Ruby가이 문자열을 평가해야하기 때문입니다. 여기에는 다소 무거운 &lt;code&gt;String&lt;/code&gt; 객체를 인스턴스화 하고 변수를 보간하는 것이 포함됩니다 . 따라서 출력 레벨이 허용 레벨과 같거나 포함 된 경우 (예 : 지연 로딩) 로거 메소드에 블록을 전달하는 것이 좋습니다. 다시 작성된 동일한 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="378a590ed7ea217bc157b04f767bbce3a298baf9" translate="yes" xml:space="preserve">
          <source>In the above template we specify that the application relies on the &lt;code&gt;rspec-rails&lt;/code&gt; and &lt;code&gt;cucumber-rails&lt;/code&gt; gem so these two will be added to the &lt;code&gt;test&lt;/code&gt; group in the &lt;code&gt;Gemfile&lt;/code&gt;. Then we pose a question to the user about whether or not they would like to install Devise. If the user replies &quot;y&quot; or &quot;yes&quot; to this question, then the template will add Devise to the &lt;code&gt;Gemfile&lt;/code&gt; outside of any group and then runs the &lt;code&gt;devise:install&lt;/code&gt; generator. This template then takes the users input and runs the &lt;code&gt;devise&lt;/code&gt; generator, with the user's answer from the last question being passed to this generator.</source>
          <target state="translated">위의 템플릿에서 애플리케이션이 &lt;code&gt;rspec-rails&lt;/code&gt; 및 &lt;code&gt;cucumber-rails&lt;/code&gt; gem을 사용하도록 지정 &lt;code&gt;Gemfile&lt;/code&gt; 두 개가 Gemfile 의 &lt;code&gt;test&lt;/code&gt; 그룹에 추가되도록 지정합니다 . 그런 다음 사용자에게 Devise 설치 여부에 대한 질문을합니다. 사용자가이 질문에 &quot;y&quot;또는 &quot;yes&quot;로 응답하면 템플릿은 그룹 외부의 &lt;code&gt;Gemfile&lt;/code&gt; 에 Devise를 추가 한 다음 &lt;code&gt;devise:install&lt;/code&gt; 생성기 를 실행합니다 . 그런 다음이 템플릿은 사용자 입력을 가져 와서 &lt;code&gt;devise&lt;/code&gt; 생성기를 실행 하며 마지막 질문에 대한 사용자의 답변이이 생성기로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="d28329a81b72878163d25972277a4b07abf621a9" translate="yes" xml:space="preserve">
          <source>In the authentication filter:</source>
          <target state="translated">인증 필터에서 :</target>
        </trans-unit>
        <trans-unit id="b9a1952af56540f70e0738c20b1efb6e624ed304" translate="yes" xml:space="preserve">
          <source>In the case above we could implement a dynamic access point:</source>
          <target state="translated">위의 경우 동적 액세스 포인트를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f25318373ee6540d313c907563cd8943b7d8fc2a" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an &lt;a href=&quot;../activerecord&quot;&gt;&lt;code&gt;ActiveRecord&lt;/code&gt;&lt;/a&gt; object is used as the value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca6413dd0b8621bd4954d0e4a4e829ed7492594" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an &lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; object is used as the value.</source>
          <target state="translated">belongs_to 관계의 경우, &lt;a href=&quot;../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; 객체가 값으로 사용되는 경우 연관 키를 사용하여 모델을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05db8fea52973334b7d1041a94daa538e6e41de9" translate="yes" xml:space="preserve">
          <source>In the case of a belongs_to relationship, an association key can be used to specify the model if an Active Record object is used as the value. This method works with polymorphic relationships as well.</source>
          <target state="translated">belong_to 관계의 경우, 활성 레코드 오브젝트가 값으로 사용되는 경우 연관 키를 사용하여 모델을 지정할 수 있습니다. 이 방법은 다형성 관계에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d93756087be58618e833c25f67ba938827e554d3" translate="yes" xml:space="preserve">
          <source>In the case of in-place transformations like &lt;code&gt;gsub!&lt;/code&gt; the receiver itself becomes unsafe.</source>
          <target state="translated">&lt;code&gt;gsub!&lt;/code&gt; 와 같은 내부 변환의 경우 ! 수신기 자체가 안전하지 않게됩니다.</target>
        </trans-unit>
        <trans-unit id="f90f4443b51bcdba4e9b77cbfad0537dffd722d4" translate="yes" xml:space="preserve">
          <source>In the case where the &lt;code&gt;reorder&lt;/code&gt; clause is not used, the SQL executed would be:</source>
          <target state="translated">&lt;code&gt;reorder&lt;/code&gt; 절이 사용되지 않는 경우 실행 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="043c45971093b99cfaa59be2aec6275bba7ade66" translate="yes" xml:space="preserve">
          <source>In the development and test environments your application's secret key base is generated by Rails and stored in a temporary file in &lt;code&gt;tmp/development_secret.txt&lt;/code&gt;. In all other environments, it is stored encrypted in the &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; file.</source>
          <target state="translated">개발 및 테스트 환경에서 애플리케이션의 비밀 키베이스는 Rails에 의해 생성되며 &lt;code&gt;tmp/development_secret.txt&lt;/code&gt; 의 임시 파일에 저장됩니다 . 다른 모든 환경에서는 &lt;code&gt;config/credentials.yml.enc&lt;/code&gt; 파일 에 암호화되어 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="c75681960dd180c7b1234a9df577a41edc756ce2" translate="yes" xml:space="preserve">
          <source>In the end, he got a 4 KB worm, which he injected into his profile page.</source>
          <target state="translated">결국 4 KB 웜이 생겼으며 프로필 페이지에 주입되었습니다.</target>
        </trans-unit>
        <trans-unit id="a9a0668d9e8b01d60ee00fef66c5a4fe3b886bf5" translate="yes" xml:space="preserve">
          <source>In the event that the collection is empty, &lt;code&gt;render&lt;/code&gt; will return nil, so it should be fairly simple to provide alternative content.</source>
          <target state="translated">컬렉션이 비어있는 경우 &lt;code&gt;render&lt;/code&gt; 는 nil을 반환하므로 대체 콘텐츠를 제공하는 것은 매우 간단해야합니다.</target>
        </trans-unit>
        <trans-unit id="59270391c73875761b1bc79e7f69878ff7f7d24a" translate="yes" xml:space="preserve">
          <source>In the event you need to access nested attributes within a given model, you should nest these under &lt;code&gt;model/attribute&lt;/code&gt; at the model level of your translation file:</source>
          <target state="translated">주어진 모델 내에서 중첩 된 속성에 액세스해야하는 경우 변환 파일의 모델 수준에서 &lt;code&gt;model/attribute&lt;/code&gt; 아래에 중첩되어야 합니다.</target>
        </trans-unit>
        <trans-unit id="6bcd3a44538f064cef6c5ae28aa20a97b263d372" translate="yes" xml:space="preserve">
          <source>In the example above &lt;code&gt;render&lt;/code&gt; is the name of the event, and the rest is called the &lt;em&gt;payload&lt;/em&gt;. The payload is a mechanism that allows instrumenters to pass extra information to subscribers. Payloads consist of a hash whose contents are arbitrary and generally depend on the event.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;render&lt;/code&gt; 는 이벤트 이름이며 나머지는 &lt;em&gt;payload&lt;/em&gt; 라고합니다 . 페이로드는 인스트루먼트가 추가 정보를 가입자에게 전달할 수있는 메커니즘입니다. 페이로드는 내용이 임의적이며 일반적으로 이벤트에 의존하는 해시로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="7f3d1821b9f0f188e97d2cc4c5d27dd0bb5e0290" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@post&lt;/code&gt; 가 새 레코드 인 경우 &quot;Create Post&quot;를 단추 레이블로 사용합니다. 그렇지 않으면 &quot;Update Post&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="12de8b2a7a4948b5a6d00dcc981ef44ca582121c" translate="yes" xml:space="preserve">
          <source>In the example above, if &lt;code&gt;@post&lt;/code&gt; is a new record, it will use &amp;ldquo;Create Post&amp;rdquo; as submit button label; otherwise, it uses &amp;ldquo;Update Post&amp;rdquo;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;@post&lt;/code&gt; 가 새 레코드 인 경우 &quot;Create Post&quot;를 제출 단추 레이블로 사용합니다. 그렇지 않으면 &quot;Update Post&quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3f14b2fb242760f899c366a5e39f1bd828c37f48" translate="yes" xml:space="preserve">
          <source>In the example above, if the format is xml, it will render:</source>
          <target state="translated">위의 예에서 형식이 xml이면 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="a12f2deb8f1230067d03dc82012f59d41652e60e" translate="yes" xml:space="preserve">
          <source>In the examples above, the object to be created or edited was represented by a symbol passed to &lt;code&gt;form_for&lt;/code&gt;, and we noted that a string can also be used equivalently. It is also possible, however, to pass a model object itself to &lt;code&gt;form_for&lt;/code&gt;. For example, if &lt;code&gt;@post&lt;/code&gt; is an existing record you wish to edit, you can create the form using</source>
          <target state="translated">위의 예제에서 작성 또는 편집 할 오브젝트는 &lt;code&gt;form_for&lt;/code&gt; 에 전달 된 기호로 표시되었으며 문자열도 동일하게 사용할 수 있습니다. 그러나 모델 객체 자체를 &lt;code&gt;form_for&lt;/code&gt; 로 전달할 수도 있습니다 . 예를 들어, &lt;code&gt;@post&lt;/code&gt; 가 편집하려는 기존 레코드 인 경우 다음을 사용하여 양식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eed6ef156bb24a3a66221694c274d09c46bead3c" translate="yes" xml:space="preserve">
          <source>In the examples just shown, although not indicated explicitly, we still need to use the &lt;code&gt;:url&lt;/code&gt; option in order to specify where the form is going to be sent. However, further simplification is possible if the record passed to &lt;code&gt;form_for&lt;/code&gt; is a &lt;em&gt;resource&lt;/em&gt;, i.e. it corresponds to a set of RESTful routes, e.g. defined using the &lt;code&gt;resources&lt;/code&gt; method in &lt;code&gt;config/routes.rb&lt;/code&gt;. In this case Rails will simply infer the appropriate URL from the record itself. For example,</source>
          <target state="translated">방금 표시된 예제에서 명시 적으로 표시되지는 않았지만 양식을 보낼 위치를 지정하려면 여전히 &lt;code&gt;:url&lt;/code&gt; 옵션 을 사용해야합니다 . 그러나 &lt;code&gt;form_for&lt;/code&gt; 에 전달 된 레코드 가 &lt;em&gt;자원 인 경우&lt;/em&gt; , 즉 &lt;code&gt;config/routes.rb&lt;/code&gt; 의 &lt;code&gt;resources&lt;/code&gt; 메소드를 사용하여 정의 된 RESTful 라우트 세트에 해당하는 경우 추가 단순화가 가능합니다 . 이 경우 Rails는 단순히 레코드 자체에서 적절한 URL을 유추합니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="aa0683ade2679737cbdc05a148fe8c06a05a2542" translate="yes" xml:space="preserve">
          <source>In the first case, you can simply avoid using the same name for multiple routes. In the second, you can use the &lt;code&gt;only&lt;/code&gt; or &lt;code&gt;except&lt;/code&gt; options provided by the &lt;code&gt;resources&lt;/code&gt; method to restrict the routes created as detailed in the &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;Routing Guide&lt;/a&gt;.</source>
          <target state="translated">첫 번째 경우에는 여러 경로에 동일한 이름을 사용하지 않아도됩니다. 두 번째로, &lt;code&gt;resources&lt;/code&gt; 방법에서 제공 하는 &lt;code&gt;only&lt;/code&gt; 옵션 또는 &lt;code&gt;except&lt;/code&gt; 옵션 을 사용하여 &lt;a href=&quot;routing#restricting-the-routes-created&quot;&gt;라우팅 가이드에&lt;/a&gt; 설명 된대로 생성 된 경로를 제한 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdaeba8b8091b87a8ab856794d2cb5912acdd5a6" translate="yes" xml:space="preserve">
          <source>In the following example the Post model has many Comments stored within it in a NoSQL database, thus there is no primary key for comments.</source>
          <target state="translated">다음 예제에서 Post 모델에는 NoSQL 데이터베이스에 많은 주석이 저장되어 있으므로 주석의 기본 키가 없습니다.</target>
        </trans-unit>
        <trans-unit id="c4a3d8485ceda8e58b6d1bfce4e3d31c308fca89" translate="yes" xml:space="preserve">
          <source>In the following example, the inner &lt;code&gt;assert_select&lt;/code&gt; for &lt;code&gt;li.menu_item&lt;/code&gt; runs within the collection of elements selected by the outer block:</source>
          <target state="translated">다음 예에서, 내부 &lt;code&gt;assert_select&lt;/code&gt; 위한 &lt;code&gt;li.menu_item&lt;/code&gt; 이 외측 블록에 의해 선택된 요소의 컬렉션 내에서 실행 :</target>
        </trans-unit>
        <trans-unit id="f7bef9cb53d38149013bd74d2990ec374d378858" translate="yes" xml:space="preserve">
          <source>In the following example, the looping on users will always be done when the three columns 'first_name', 'last_name' and 'full_name' exist, even when migrating down:</source>
          <target state="translated">다음 예에서는 마이그레이션시에도 'first_name', 'last_name'및 'full_name'이라는 세 개의 열이 존재하면 사용자에 대한 루핑이 항상 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="a22f54b5a9f917ca16377381a398c8ffa97e40c4" translate="yes" xml:space="preserve">
          <source>In the following example, the new column &lt;code&gt;published&lt;/code&gt; will be given the value &lt;code&gt;true&lt;/code&gt; for all existing records.</source>
          <target state="translated">다음 예에서 &lt;code&gt;published&lt;/code&gt; 새 열에 는 모든 기존 레코드에 대해 &lt;code&gt;true&lt;/code&gt; 값이 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cf32ccab8bfedf8d3bd009f8023805f13eb7150" translate="yes" xml:space="preserve">
          <source>In the next section, you will add the ability to create new articles in your application and be able to view them. This is the &quot;C&quot; and the &quot;R&quot; from CRUD: create and read. The form for doing this will look like this:</source>
          <target state="translated">다음 섹션에서는 애플리케이션에서 새 기사를 작성하고 볼 수있는 기능을 추가합니다. CRUD의 &quot;C&quot;와 &quot;R&quot;은 create and read입니다. 이 작업을 수행하는 양식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf8117729c34fd38f858f62c942b31df3e2602c4" translate="yes" xml:space="preserve">
          <source>In the output, &lt;code&gt;F&lt;/code&gt; denotes a failure. You can see the corresponding trace shown under &lt;code&gt;Failure&lt;/code&gt; along with the name of the failing test. The next few lines contain the stack trace followed by a message that mentions the actual value and the expected value by the assertion. The default assertion messages provide just enough information to help pinpoint the error. To make the assertion failure message more readable, every assertion provides an optional message parameter, as shown here:</source>
          <target state="translated">출력에서 &lt;code&gt;F&lt;/code&gt; 는 실패를 나타냅니다. 실패한 테스트 이름과 함께 &lt;code&gt;Failure&lt;/code&gt; 아래에 해당 추적이 표시됩니다 . 다음 몇 줄에는 스택 추적과 실제 값 및 어설 션의 예상 값을 언급하는 메시지가옵니다. 기본 어설 션 메시지는 오류를 정확히 찾아 낼 수있는 충분한 정보를 제공합니다. 어설 션 실패 메시지를보다 읽기 쉽게하기 위해 모든 어설 션은 다음과 같이 선택적 메시지 매개 변수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4db67d28b943836cff0a68073645d31f62ee1a8f" translate="yes" xml:space="preserve">
          <source>In the previous example it could be the case that &lt;code&gt;:log_level&lt;/code&gt; does not belong to the public interface of the library and it is only used for development. The client code, unaware of the potential conflict, subclasses and defines its own &lt;code&gt;:log_level&lt;/code&gt;. Thanks to &lt;code&gt;attr_internal&lt;/code&gt; there's no collision.</source>
          <target state="translated">이전 예제에서 &lt;code&gt;:log_level&lt;/code&gt; 이 라이브러리의 공용 인터페이스에 속하지 않고 개발에만 사용되는 경우가 있습니다. 잠재적 충돌을 인식하지 못하는 클라이언트 코드는 자신의 &lt;code&gt;:log_level&lt;/code&gt; 을 서브 클래스 화하고 정의합니다 . &lt;code&gt;attr_internal&lt;/code&gt; 덕분에 충돌이 없습니다.</target>
        </trans-unit>
        <trans-unit id="3908f2e1774247ac628c78d28b4387e97fe76ec2" translate="yes" xml:space="preserve">
          <source>In the previous example the macro generates &lt;code&gt;avatar_size&lt;/code&gt; rather than &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">이전 예제에서 매크로는 &lt;code&gt;avatar_size&lt;/code&gt; 아닌 avatar_size를 생성 &lt;code&gt;size&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35dfd724e5592aa2978efe9cdd4cbb5436938ecd" translate="yes" xml:space="preserve">
          <source>In the previous scenarios M would no longer be reachable through &lt;code&gt;A::B&lt;/code&gt; but the module object itself could still be alive somewhere and its name would still be &quot;A::B&quot;.</source>
          <target state="translated">이전 시나리오에서 M은 더 이상 &lt;code&gt;A::B&lt;/code&gt; 통해 도달 할 수 없지만 모듈 객체 자체는 여전히 어딘가에있을 수 있으며 이름은 여전히 ​​&quot;A :: B&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="240be3d54a3302b13164d042110cd1f87453480c" translate="yes" xml:space="preserve">
          <source>In the process of &lt;em&gt;localizing&lt;/em&gt; your application you'll probably want to do the following three things:</source>
          <target state="translated">응용 프로그램을 &lt;em&gt;지역화&lt;/em&gt; 하는 과정 에서 다음 세 가지를 수행하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6966b7531fe1cf3228dbcc40ef51e48619f56ef9" translate="yes" xml:space="preserve">
          <source>In the production environment Sprockets uses the fingerprinting scheme outlined above. By default Rails assumes assets have been precompiled and will be served as static assets by your web server.</source>
          <target state="translated">프로덕션 환경에서 Sprockets는 위에서 설명한 지문 체계를 사용합니다. 기본적으로 Rails는 자산이 사전 컴파일되어 웹 서버에서 정적 자산으로 제공된다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="6fd699f9c03765d18ac7eeda7b127958136df039" translate="yes" xml:space="preserve">
          <source>In the rare case you don't want this hidden field, you can pass the &lt;code&gt;include_hidden: false&lt;/code&gt; option to the helper method.</source>
          <target state="translated">드문 경우이지만이 숨겨진 필드를 원하지 않으면 &lt;code&gt;include_hidden: false&lt;/code&gt; 옵션을 도우미 메소드에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1c58d2a65fecbb47b85c6d0f89eaf470432fb80" translate="yes" xml:space="preserve">
          <source>In the rare event that your application needs to run some code before Rails itself is loaded, put it above the call to &lt;code&gt;require &quot;rails/all&quot;&lt;/code&gt; in &lt;code&gt;config/application.rb&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="907dc721c200adc34c9cd1a38a774d66172f7072" translate="yes" xml:space="preserve">
          <source>In the rare event that your application needs to run some code before Rails itself is loaded, put it above the call to &lt;code&gt;require 'rails/all'&lt;/code&gt; in &lt;code&gt;config/application.rb&lt;/code&gt;.</source>
          <target state="translated">드문 경우지만 Rails 자체가로드되기 전에 애플리케이션이 일부 코드를 실행 &lt;code&gt;require 'rails/all'&lt;/code&gt; &lt;code&gt;config/application.rb&lt;/code&gt; 에서 'rails / all' 을 요구 하는 호출 위에 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="e343b15a5c1979c12b2ce78c1a6e9b635664460e" translate="yes" xml:space="preserve">
          <source>In the remainder of this guide, you'll learn how to declare and use the various forms of associations. But first, a quick introduction to the situations where each association type is appropriate.</source>
          <target state="translated">이 가이드의 나머지 부분에서는 다양한 형식의 연결을 선언하고 사용하는 방법을 배웁니다. 그러나 먼저 각 연관 유형이 적합한 상황에 대한 빠른 소개입니다.</target>
        </trans-unit>
        <trans-unit id="f1ecfbad640a171b281df19ce17b6db703c115aa" translate="yes" xml:space="preserve">
          <source>In the step above we simply wanted to add a line to the generated helper, without adding any extra functionality. There is a simpler way to do that, and it's by replacing the templates of already existing generators, in that case &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt;.</source>
          <target state="translated">위의 단계에서 추가 기능을 추가하지 않고 생성 된 도우미에 행을 추가하려고했습니다. 이를 수행하는 더 간단한 방법이 있으며 기존 생성기의 템플릿 (이 경우 &lt;code&gt;Rails::Generators::HelperGenerator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d4aca72171cec217a6a6f8419ee4e2bc7dffd58d" translate="yes" xml:space="preserve">
          <source>In the test we create the email and store the returned object in the &lt;code&gt;email&lt;/code&gt; variable. We then ensure that it was sent (the first assert), then, in the second batch of assertions, we ensure that the email does indeed contain what we expect. The helper &lt;code&gt;read_fixture&lt;/code&gt; is used to read in the content from this file.</source>
          <target state="translated">테스트에서 이메일을 작성하고 리턴 된 오브젝트를 &lt;code&gt;email&lt;/code&gt; 변수 에 저장합니다 . 그런 다음이 메시지가 전송되었는지 확인하고 (첫 번째 어설 션) 두 번째 어설 션에서 이메일에 실제로 예상 한 내용이 포함되도록합니다. 도우미 &lt;code&gt;read_fixture&lt;/code&gt; 는이 파일의 내용을 읽는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffe3c0b50c71cf9044af6117e77e0043e0f0f60" translate="yes" xml:space="preserve">
          <source>In these cases the interpreter issues a warning though:</source>
          <target state="translated">이 경우 통역사는 다음과 같은 경고를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="93ce4a58cfac5b635c26f22549185d914a6bdf90" translate="yes" xml:space="preserve">
          <source>In these examples, we have three implicit lookup scenarios:</source>
          <target state="translated">이 예제에는 세 가지 암시 적 조회 시나리오가 있습니다.</target>
        </trans-unit>
        <trans-unit id="502f55decb79b29eb1515742d9f6251647206e2e" translate="yes" xml:space="preserve">
          <source>In this application:</source>
          <target state="translated">이 응용 프로그램에서 :</target>
        </trans-unit>
        <trans-unit id="f245011a3468e934666f54bb9f814c5d90ff5341" translate="yes" xml:space="preserve">
          <source>In this case it will look for templates at &lt;code&gt;app/views/notifications&lt;/code&gt; with name &lt;code&gt;another&lt;/code&gt;. You can also specify an array of paths for &lt;code&gt;template_path&lt;/code&gt;, and they will be searched in order.</source>
          <target state="translated">이 경우 &lt;code&gt;app/views/notifications&lt;/code&gt; 에서 이름이 &lt;code&gt;another&lt;/code&gt; 인 템플릿을 찾습니다 . &lt;code&gt;template_path&lt;/code&gt; 의 경로 배열을 지정할 수도 있으며 순서대로 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="0d9d06832166b95bcc20a680a541dfc7390292e7" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;do_something_else&lt;/code&gt; gets executed before &lt;code&gt;log_children&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;do_something_else&lt;/code&gt; 가 &lt;code&gt;log_children&lt;/code&gt; 보다 먼저 실행 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a17b869302b0bead2264b28725d9921dabb42d5" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;do_something_else&lt;/code&gt; is executed before &lt;code&gt;log_children&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8ae7818af6dd8e94846acb9a537d14c62858b73" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;log_children&lt;/code&gt; gets executed before &lt;code&gt;do_something_else&lt;/code&gt;. The same applies to all non-transactional callbacks.</source>
          <target state="translated">이 경우 &lt;code&gt;log_children&lt;/code&gt; 은 &lt;code&gt;do_something_else&lt;/code&gt; 보다 먼저 실행 됩니다. 모든 비 트랜잭션 콜백에도 동일하게 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="b50ddef23392520efa7bfca9ad24a01b0ab3fec7" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;log_children&lt;/code&gt; is executed before &lt;code&gt;do_something_else&lt;/code&gt;. The same applies to all non-transactional callbacks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95b5def6a1eafc74bdaaae9878cf5714bb14081e" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;options&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt; so nothing happens in this method.</source>
          <target state="translated">이 경우, &lt;code&gt;options&lt;/code&gt; 은 &lt;code&gt;nil&lt;/code&gt; 아니므로이 방법에서는 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4dc79e30fed233fc8c2b2718746ea33166b3079" translate="yes" xml:space="preserve">
          <source>In this case, Rails will create all of the normal routes except the route for &lt;code&gt;destroy&lt;/code&gt; (a &lt;code&gt;DELETE&lt;/code&gt; request to &lt;code&gt;/photos/:id&lt;/code&gt;).</source>
          <target state="translated">이 경우 Rails는 &lt;code&gt;destroy&lt;/code&gt; ( &lt;code&gt;/photos/:id&lt;/code&gt; 에 대한 &lt;code&gt;DELETE&lt;/code&gt; 요청) 경로를 제외한 모든 일반 경로를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8af14d976d9ce80f23b3242ec266f5b8244e100c" translate="yes" xml:space="preserve">
          <source>In this case, Rails will see that &lt;code&gt;@magazine&lt;/code&gt; is a &lt;code&gt;Magazine&lt;/code&gt; and &lt;code&gt;@ad&lt;/code&gt; is an &lt;code&gt;Ad&lt;/code&gt; and will therefore use the &lt;code&gt;magazine_ad_path&lt;/code&gt; helper. In helpers like &lt;code&gt;link_to&lt;/code&gt;, you can specify just the object in place of the full &lt;code&gt;url_for&lt;/code&gt; call:</source>
          <target state="translated">이 경우 Rails는 &lt;code&gt;@magazine&lt;/code&gt; 은 &lt;code&gt;Magazine&lt;/code&gt; 이고 &lt;code&gt;@ad&lt;/code&gt; 는 &lt;code&gt;Ad&lt;/code&gt; 이므로 &lt;code&gt;magazine_ad_path&lt;/code&gt; 도우미를 사용합니다 . &lt;code&gt;link_to&lt;/code&gt; 와 같은 도우미에서는 전체 &lt;code&gt;url_for&lt;/code&gt; 호출 대신 객체 만 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec98966b432fd02dd889acb0e3ae363d24f7331a" translate="yes" xml:space="preserve">
          <source>In this case, Rails will use the customer or employee partials as appropriate for each member of the collection.</source>
          <target state="translated">이 경우 Rails는 컬렉션의 각 멤버에 따라 고객 또는 직원 부분을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="324afa7d33283fa836e991ed242a0c763e9a50ca" translate="yes" xml:space="preserve">
          <source>In this case, after saving our new entry to the database, the user is redirected to the &lt;code&gt;show&lt;/code&gt; method, which is then executed. Note that this is an external HTTP-level redirection which will cause the browser to make a second request (a GET to the show action), and not some internal re-routing which calls both &amp;ldquo;create&amp;rdquo; and then &amp;ldquo;show&amp;rdquo; within one request.</source>
          <target state="translated">이 경우, 새 항목을 데이터베이스에 저장 한 후 사용자는 &lt;code&gt;show&lt;/code&gt; 메소드로 경로 재 지정된 후 실행됩니다. 이는 외부 HTTP 레벨 리디렉션으로, 브라우저가 두 번째 요청 (show 조치에 대한 GET)을 작성하지만 한 요청 내에서 &quot;create&quot;와 &quot;show&quot;를 모두 호출하는 일부 내부 경로 재 지정이 아닙니다. .</target>
        </trans-unit>
        <trans-unit id="90d76c0d057ec80df1313425905dbf5fc8817833" translate="yes" xml:space="preserve">
          <source>In this case, if you use this:</source>
          <target state="translated">이 경우에 이것을 사용하면 :</target>
        </trans-unit>
        <trans-unit id="1be8ecd1ff257edb9a048d380cba8d414155c70d" translate="yes" xml:space="preserve">
          <source>In this case, if you use:</source>
          <target state="translated">이 경우 다음을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="45910dcc6fa37937e878c391486df7457ff27ceb" translate="yes" xml:space="preserve">
          <source>In this case, instead of the default block, which would return &lt;code&gt;content_for(:layout)&lt;/code&gt;, this method returns the block that was passed in to &lt;code&gt;render :layout&lt;/code&gt;, and the response would be</source>
          <target state="translated">이 경우 &lt;code&gt;content_for(:layout)&lt;/code&gt; 반환하는 기본 블록 대신 이 메소드는 &lt;code&gt;render :layout&lt;/code&gt; 에 전달 된 블록을 반환 하며 응답은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="23294ab6faccc1c47ad44363cc9caeae8dba7046" translate="yes" xml:space="preserve">
          <source>In this case, it is usually more natural to include an association which has conditions defined on it:</source>
          <target state="translated">이 경우 일반적으로 조건이 정의 된 연관을 포함시키는 것이 더 자연 스럽습니다.</target>
        </trans-unit>
        <trans-unit id="16a50dfba857e4a6040bd1ca958b551f8acea120" translate="yes" xml:space="preserve">
          <source>In this case, return value of &lt;code&gt;Rails::Command::ServerCommand#server_options&lt;/code&gt; will be assigned to &lt;code&gt;options&lt;/code&gt;. When lines inside if statement is evaluated, a couple of instance variables will be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3682a82419f80b6aaba8341e83ca11b591eb3f0f" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a book will update the timestamp on the associated author. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">이 경우 책을 저장하거나 삭제하면 관련 작성자의 타임 스탬프가 업데이트됩니다. 업데이트 할 특정 타임 스탬프 속성을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="46550e2dc92461d1a9bec5aa815cb8c7643c013c" translate="yes" xml:space="preserve">
          <source>In this case, saving or destroying a supplier will update the timestamp on the associated account. You can also specify a particular timestamp attribute to update:</source>
          <target state="translated">이 경우 공급 업체를 저장하거나 폐기하면 관련 계정의 타임 스탬프가 업데이트됩니다. 업데이트 할 특정 타임 스탬프 속성을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06a3fa81533cea880dc23c87f021c293fd2df3af" translate="yes" xml:space="preserve">
          <source>In this case, the checkbox field will be represented by an HTML &lt;code&gt;input&lt;/code&gt; tag with the &lt;code&gt;name&lt;/code&gt; attribute &lt;code&gt;permission[admin]&lt;/code&gt;, and the submitted value will appear in the controller as &lt;code&gt;params[:permission][:admin]&lt;/code&gt;. If &lt;code&gt;@person.permission&lt;/code&gt; is an existing record with an attribute &lt;code&gt;admin&lt;/code&gt;, the initial state of the checkbox when first displayed will reflect the value of &lt;code&gt;@person.permission.admin&lt;/code&gt;.</source>
          <target state="translated">이 경우, 확인란 필드는 &lt;code&gt;name&lt;/code&gt; 속성 &lt;code&gt;permission[admin]&lt;/code&gt; 과 함께 HTML &lt;code&gt;input&lt;/code&gt; 태그로 표시되며 제출 된 값은 컨트롤러에 &lt;code&gt;params[:permission][:admin]&lt;/code&gt; 으로 나타납니다 . 경우 &lt;code&gt;@person.permission&lt;/code&gt; 속성을 가진 기존의 기록이다 &lt;code&gt;admin&lt;/code&gt; , 최초의 값이 반영됩니다 표시 체크 박스의 초기 상태 &lt;code&gt;@person.permission.admin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e31b43893b5d7d80c3642e5735940479c8a39085" translate="yes" xml:space="preserve">
          <source>In this case, the layout would receive the block passed into &lt;code&gt;render
:layout&lt;/code&gt;, and the struct specified would be passed into the block as an argument. The result would be</source>
          <target state="translated">이 경우 레이아웃은 &lt;code&gt;render :layout&lt;/code&gt; 전달 된 블록을 수신하고 지정된 struct가 인수로 블록에 전달됩니다. 결과는</target>
        </trans-unit>
        <trans-unit id="eb428f6fa982c5a012e150312c045633b5daa11c" translate="yes" xml:space="preserve">
          <source>In this case, the partial will have access to a local variable &lt;code&gt;title&lt;/code&gt; with the value &quot;Products Page&quot;.</source>
          <target state="translated">이 경우 부분은 값이 &quot;Products Page&quot;인 로컬 변수 &lt;code&gt;title&lt;/code&gt; 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88dfc4e56cdc793acf40bfdb1165f2c619bf9038" translate="yes" xml:space="preserve">
          <source>In this case, the problem is that when the &lt;code&gt;before_destroy&lt;/code&gt; callback is executed, records in the &lt;code&gt;children&lt;/code&gt; association no longer exist because the &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord::Base#destroy&lt;/a&gt; callback was executed first. You can use the &lt;code&gt;prepend&lt;/code&gt; option on the &lt;code&gt;before_destroy&lt;/code&gt; callback to avoid this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0271f9329c9956c7be3a8dd886bdf6c333e85c14" translate="yes" xml:space="preserve">
          <source>In this case, the problem is that when the &lt;code&gt;before_destroy&lt;/code&gt; callback is executed, the children are not available because the &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord::Base#destroy&lt;/a&gt; callback gets executed first. You can use the &lt;code&gt;prepend&lt;/code&gt; option on the &lt;code&gt;before_destroy&lt;/code&gt; callback to avoid this.</source>
          <target state="translated">이 경우, &lt;code&gt;before_destroy&lt;/code&gt; 콜백이 실행될 때 &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;ActiveRecord :: Base # destroy&lt;/a&gt; 콜백이 먼저 실행 되므로 자식을 사용할 수 없다는 문제가 있습니다 . 이를 방지하기 위해 &lt;code&gt;before_destroy&lt;/code&gt; 콜백 에서 &lt;code&gt;prepend&lt;/code&gt; 옵션을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9baf39f668787b7ea9b2708f867d659f69a15343" translate="yes" xml:space="preserve">
          <source>In this case, when a user opens the URL &lt;code&gt;/clients/active&lt;/code&gt;, &lt;code&gt;params[:status]&lt;/code&gt; will be set to &quot;active&quot;. When this route is used, &lt;code&gt;params[:foo]&lt;/code&gt; will also be set to &quot;bar&quot;, as if it were passed in the query string. Your controller will also receive &lt;code&gt;params[:action]&lt;/code&gt; as &quot;index&quot; and &lt;code&gt;params[:controller]&lt;/code&gt; as &quot;clients&quot;.</source>
          <target state="translated">사용자가 URL 열면이 경우 &lt;code&gt;/clients/active&lt;/code&gt; , &lt;code&gt;params[:status]&lt;/code&gt; &quot;활성&quot;으로 설정한다. 이 경로를 사용하면 &lt;code&gt;params[:foo]&lt;/code&gt; 도 마치 쿼리 문자열에 전달 된 것처럼 &quot;bar&quot;로 설정됩니다. 또한 컨트롤러는 &lt;code&gt;params[:action]&lt;/code&gt; 을 &quot;index&quot;로, &lt;code&gt;params[:controller]&lt;/code&gt; 를 &quot;clients&quot;로받습니다.</target>
        </trans-unit>
        <trans-unit id="0a36fec3659c2de19ce884ca0a800b73a334ea2d" translate="yes" xml:space="preserve">
          <source>In this case, you would need to configure the proxy server (NGINX, Apache, etc) to accept connections from your application server (Unicorn). By default Unicorn will listen for TCP connections on port 8080, but you can change the port or configure it to use sockets instead.</source>
          <target state="translated">이 경우 응용 프로그램 서버 (유니콘)의 연결을 허용하도록 프록시 서버 (NGINX, Apache 등)를 구성해야합니다. 기본적으로 Unicorn은 포트 8080에서 TCP 연결을 수신하지만 포트를 변경하거나 소켓을 대신 사용하도록 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eae33b5ffd3d9c9556903778ce1a2447bd12864" translate="yes" xml:space="preserve">
          <source>In this example a &lt;code&gt;balance&lt;/code&gt; record is transactionally saved even though &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;&lt;code&gt;transaction&lt;/code&gt;&lt;/a&gt; is called on the &lt;code&gt;Account&lt;/code&gt; class:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ede2f597296609c3cbf7e0fc1896d94a0128407a" translate="yes" xml:space="preserve">
          <source>In this example a &lt;code&gt;balance&lt;/code&gt; record is transactionally saved even though &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;transaction&lt;/a&gt; is called on the &lt;code&gt;Account&lt;/code&gt; class:</source>
          <target state="translated">이 예에서는 &lt;a href=&quot;classmethods#method-i-transaction&quot;&gt;거래가 &lt;/a&gt; &lt;code&gt;Account&lt;/code&gt; 클래스 에서 호출 되더라도 &lt;code&gt;balance&lt;/code&gt; 레코드가 거래 방식으로 저장 됩니다.</target>
        </trans-unit>
        <trans-unit id="5981716553c9eee36422c751c4b27ad722d5eee4" translate="yes" xml:space="preserve">
          <source>In this example the filter is added to &lt;code&gt;ApplicationController&lt;/code&gt; and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/AbstractController/Callbacks/ClassMethods.html#method-i-skip_before_action&quot;&gt;&lt;code&gt;skip_before_action&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8315e856964911dcdef9965da60bf232cff0ef4f" translate="yes" xml:space="preserve">
          <source>In this example the filter is added to &lt;code&gt;ApplicationController&lt;/code&gt; and thus all controllers in the application inherit it. This will make everything in the application require the user to be logged in in order to use it. For obvious reasons (the user wouldn't be able to log in in the first place!), not all controllers or actions should require this. You can prevent this filter from running before particular actions with &lt;code&gt;skip_before_action&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 필터는 &lt;code&gt;ApplicationController&lt;/code&gt; 에 추가 되므로 애플리케이션의 모든 컨트롤러가이를 상속합니다. 응용 프로그램의 모든 것을 사용하려면 사용자가 로그인해야합니다. 명백한 이유로 (사용자가 처음에 로그인 할 수 없습니다!), 모든 컨트롤러 나 작업에서이를 요구하지는 않습니다. &lt;code&gt;skip_before_action&lt;/code&gt; 을 사용 하여 특정 조치 전에이 필터가 실행되지 않도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6ed05101913eb841250d9350938e2a1cbfaa622" translate="yes" xml:space="preserve">
          <source>In this example you will add a method to String named &lt;code&gt;to_squawk&lt;/code&gt;. To begin, create a new test file with a few assertions:</source>
          <target state="translated">이 예제에서는 &lt;code&gt;to_squawk&lt;/code&gt; 라는 문자열에 메소드를 추가합니다 . 시작하려면 몇 가지 주장으로 새 테스트 파일을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="fedd050168d34065a17d9d68e74077e8c1d0a4f1" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;require_self&lt;/code&gt; is used. This puts the CSS contained within the file (if any) at the precise location of the &lt;code&gt;require_self&lt;/code&gt; call.</source>
          <target state="translated">이 예에서는 &lt;code&gt;require_self&lt;/code&gt; 가 사용됩니다. 이렇게하면 &lt;code&gt;require_self&lt;/code&gt; 호출 의 정확한 위치에 파일에 포함 된 CSS가 있습니다 (있는 경우) .</target>
        </trans-unit>
        <trans-unit id="5d763f0c08a6e36b13bfd4f55c2b0c56d55c2060" translate="yes" xml:space="preserve">
          <source>In this example, if any before validate callbacks returns &lt;code&gt;false&lt;/code&gt;, any successive before and around callback is not executed.</source>
          <target state="translated">이 예에서 before validate 콜백이 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 연속적인 전후 콜백이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b577440c4b67419e3dd43e87c84951cf5901392" translate="yes" xml:space="preserve">
          <source>In this example, the :iphone format will be used if it's available, otherwise it'll fallback to the :html format.</source>
          <target state="translated">이 예에서 : iphone 형식은 사용 가능한 경우에 사용되며 그렇지 않으면 : html 형식으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="7e25f6b231c3e7a583a15488e6962be811bbb8cb" translate="yes" xml:space="preserve">
          <source>In this example, the &lt;code&gt;articles_path&lt;/code&gt; helper is passed to the &lt;code&gt;:url&lt;/code&gt; option. To see what Rails will do with this, we look back at the output of &lt;code&gt;rails routes&lt;/code&gt;:</source>
          <target state="translated">이 예제에서 &lt;code&gt;articles_path&lt;/code&gt; 헬퍼는 &lt;code&gt;:url&lt;/code&gt; 옵션으로 전달됩니다 . Rails가 이것으로 무엇을하는지보기 위해, 우리는 &lt;code&gt;rails routes&lt;/code&gt; 의 출력을 되돌아 봅니다 :</target>
        </trans-unit>
        <trans-unit id="cefad5f74cb38773452302635f93e20f8d80d081" translate="yes" xml:space="preserve">
          <source>In this example, the first question mark will be replaced with the value in &lt;code&gt;params[:orders]&lt;/code&gt; and the second will be replaced with the SQL representation of &lt;code&gt;false&lt;/code&gt;, which depends on the adapter.</source>
          <target state="translated">이 예에서 첫 번째 물음표는 &lt;code&gt;params[:orders]&lt;/code&gt; 의 값으로 대체되고 두 번째 물음표는 어댑터에 따라 &lt;code&gt;false&lt;/code&gt; 의 SQL 표시로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="da19c67a2341d7413002c18c5c6b8ca791b4d7a8" translate="yes" xml:space="preserve">
          <source>In this example, the first question mark will be replaced with the value in &lt;code&gt;params[:title]&lt;/code&gt; and the second will be replaced with the SQL representation of &lt;code&gt;false&lt;/code&gt;, which depends on the adapter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbabf0da18d1208c082d2a4f0c887028c4ef916" translate="yes" xml:space="preserve">
          <source>In this example, the subscribed and unsubscribed methods are not callable methods, as they were already declared in &lt;a href=&quot;base&quot;&gt;&lt;code&gt;ActionCable::Channel::Base&lt;/code&gt;&lt;/a&gt;, but &lt;code&gt;#appear&lt;/code&gt; and &lt;code&gt;#away&lt;/code&gt; are. &lt;code&gt;#generate_connection_token&lt;/code&gt; is also not callable, since it's a private method. You'll see that appear accepts a data parameter, which it then uses as part of its model call. &lt;code&gt;#away&lt;/code&gt; does not, since it's simply a trigger action.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c27b9227975c797fa6b2e2b282ef1471c2fa42" translate="yes" xml:space="preserve">
          <source>In this example, the subscribed and unsubscribed methods are not callable methods, as they were already declared in &lt;a href=&quot;base&quot;&gt;ActionCable::Channel::Base&lt;/a&gt;, but &lt;code&gt;#appear&lt;/code&gt; and &lt;code&gt;#away&lt;/code&gt; are. &lt;code&gt;#generate_connection_token&lt;/code&gt; is also not callable, since it's a private method. You'll see that appear accepts a data parameter, which it then uses as part of its model call. &lt;code&gt;#away&lt;/code&gt; does not, since it's simply a trigger action.</source>
          <target state="translated">이 예제에서 구독 및 구독 취소 된 메소드는 &lt;a href=&quot;base&quot;&gt;ActionCable :: Channel :: Base&lt;/a&gt; 에서 이미 선언되었으므로 호출 가능한 메소드는 아니지만 &lt;code&gt;#appear&lt;/code&gt; 및 &lt;code&gt;#away&lt;/code&gt; 는 호출 가능한 메소드 입니다. &lt;code&gt;#generate_connection_token&lt;/code&gt; 도 비공개 메소드이므로 호출 할 수 없습니다. appear는 데이터 매개 변수를 승인 한 후 모델 호출의 일부로 사용함을 알 수 있습니다. &lt;code&gt;#away&lt;/code&gt; 는 단순히 트리거 작업 이므로 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9e06e6bc72e0675f6e83f410d12668e53aa905bf" translate="yes" xml:space="preserve">
          <source>In this example, the subscription will be rejected if the &lt;code&gt;current_user&lt;/code&gt; does not have access to the chat room. On the client-side, the &lt;code&gt;Channel#rejected&lt;/code&gt; callback will get invoked when the server rejects the subscription request.</source>
          <target state="translated">이 예에서 &lt;code&gt;current_user&lt;/code&gt; 가 대화방에 액세스 할 수없는 경우 구독이 거부됩니다 . 클라이언트 측 에서 서버가 구독 요청을 거부하면 &lt;code&gt;Channel#rejected&lt;/code&gt; 콜백이 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="e4189c06b24b1d007060ef87497a67e0f217bf84" translate="yes" xml:space="preserve">
          <source>In this guide you will learn about engines and how they can be used to provide additional functionality to their host applications through a clean and very easy-to-use interface.</source>
          <target state="translated">이 안내서에서는 엔진에 대해 배우고 엔진을 사용하여 깨끗하고 사용하기 쉬운 인터페이스를 통해 호스트 응용 프로그램에 추가 기능을 제공하는 방법에 대해 학습합니다.</target>
        </trans-unit>
        <trans-unit id="62fddb8ee2378135835c382d27251f82d4d91a62" translate="yes" xml:space="preserve">
          <source>In this guide you will learn how controllers work and how they fit into the request cycle in your application.</source>
          <target state="translated">이 안내서에서는 컨트롤러의 작동 방식과 컨트롤러가 애플리케이션의 요청주기에 어떻게 적용되는지 배웁니다.</target>
        </trans-unit>
        <trans-unit id="cf19788f5357ece34c60a8480d19af8f12bf7ec6" translate="yes" xml:space="preserve">
          <source>In this guide you will learn:</source>
          <target state="translated">이 안내서에서는 다음을 배우게됩니다.</target>
        </trans-unit>
        <trans-unit id="cf6643c2d1d2064aadb116664a08bad47743e0a1" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how Action Cable works and how to use WebSockets to incorporate real-time features into your Rails application.</source>
          <target state="translated">이 가이드에서는 Action Cable의 작동 방식과 WebSockets를 사용하여 실시간 기능을 Rails 애플리케이션에 통합하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="bdf3816ba71ddd3fd76041fa284bf113f06c1558" translate="yes" xml:space="preserve">
          <source>In this guide, you will learn how to use the instrumentation API inside of Active Support to measure events inside of Rails and other Ruby code.</source>
          <target state="translated">이 안내서에서는 Active Support 내에서 인스 트루먼 테이션 API를 사용하여 Rails 및 기타 Ruby 코드 내의 이벤트를 측정하는 방법을 학습합니다.</target>
        </trans-unit>
        <trans-unit id="17d6f3660a8d0024f2df0642dcac76b33986119b" translate="yes" xml:space="preserve">
          <source>In this instance the &lt;code&gt;params&lt;/code&gt; object comes from the context in which the block is executed, e.g. generating a URL inside a controller action or a view. If the block is executed where there isn't a &lt;code&gt;params&lt;/code&gt; object such as this:</source>
          <target state="translated">이 경우 &lt;code&gt;params&lt;/code&gt; 객체는 블록이 실행되는 컨텍스트에서 가져옵니다 (예 : 컨트롤러 작업 또는보기 내부에 URL 생성). 다음 과 같은 &lt;code&gt;params&lt;/code&gt; 객체 가없는 곳에서 블록을 실행하는 경우 :</target>
        </trans-unit>
        <trans-unit id="e775a416c0401e99c05491f16f2e3ad2f0b37cf9" translate="yes" xml:space="preserve">
          <source>In this section, you will learn how to find and fix such leaks by using tool such as Valgrind.</source>
          <target state="translated">이 섹션에서는 Valgrind와 같은 도구를 사용하여 이러한 누수를 찾고 수정하는 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="43ee8d423dd4beb0652585c12ecb71a52f0ee729" translate="yes" xml:space="preserve">
          <source>In this section, you will learn how to find and fix such leaks by using tools such as Valgrind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0084e91e7dec41c05dea12c47a8e853442ad896c" translate="yes" xml:space="preserve">
          <source>In this usage, the argument passed to the block (&lt;code&gt;format&lt;/code&gt; above) is an instance of the &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;ActionController::MimeResponds::Collector&lt;/code&gt;&lt;/a&gt; class. This object serves as a container in which available responses can be stored by calling any of the dynamically generated, mime-type-specific methods such as &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; etc on the &lt;a href=&quot;collector&quot;&gt;&lt;code&gt;Collector&lt;/code&gt;&lt;/a&gt;. Each response is represented by a corresponding block if present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7264044f5a1a998f82bc2a0fb68556ba4a58797d" translate="yes" xml:space="preserve">
          <source>In this usage, the argument passed to the block (&lt;code&gt;format&lt;/code&gt; above) is an instance of the &lt;a href=&quot;collector&quot;&gt;ActionController::MimeResponds::Collector&lt;/a&gt; class. This object serves as a container in which available responses can be stored by calling any of the dynamically generated, mime-type-specific methods such as &lt;code&gt;html&lt;/code&gt;, &lt;code&gt;xml&lt;/code&gt; etc on the &lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt;. Each response is represented by a corresponding block if present.</source>
          <target state="translated">이 사용법에서 블록에 전달 된 인수 ( 위 &lt;code&gt;format&lt;/code&gt; )는 &lt;a href=&quot;collector&quot;&gt;ActionController :: MimeResponds :: Collector&lt;/a&gt; 클래스 의 인스턴스입니다 . 이 객체는 &lt;a href=&quot;collector&quot;&gt;Collector&lt;/a&gt; 에서 &lt;code&gt;html&lt;/code&gt; , &lt;code&gt;xml&lt;/code&gt; 등과 같이 동적으로 생성 된 MIME 유형별 메소드를 호출하여 사용 가능한 응답을 저장할 수있는 컨테이너 역할을합니다 . 각 응답은 해당 블록이 있으면 해당 블록으로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba593c77f08ee47c3d8a495930397389dfb5d77" translate="yes" xml:space="preserve">
          <source>In those cases, you may give an options hash a distinguished treatment with &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/Array.html#method-i-extract_options-21&quot;&gt;&lt;code&gt;extract_options!&lt;/code&gt;&lt;/a&gt;. This method checks the type of the last item of an array. If it is a hash it pops it and returns it, otherwise it returns an empty hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33174322f55d37e3ac00f4a987ec114066590e1a" translate="yes" xml:space="preserve">
          <source>In those cases, you may give an options hash a distinguished treatment with &lt;code&gt;extract_options!&lt;/code&gt;. This method checks the type of the last item of an array. If it is a hash it pops it and returns it, otherwise it returns an empty hash.</source>
          <target state="translated">이 경우 &lt;code&gt;extract_options!&lt;/code&gt; 사용하여 옵션 해시에 고유 처리를 제공 할 수 있습니다 ! . 이 메소드는 배열의 마지막 항목 유형을 확인합니다. 해시 인 경우 팝업하여 반환하고, 그렇지 않으면 빈 해시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a550daa4f417c340f8beea7b13981602f9c09f42" translate="yes" xml:space="preserve">
          <source>In your &lt;code&gt;test_helper.rb&lt;/code&gt; add the following:</source>
          <target state="translated">당신에 &lt;code&gt;test_helper.rb&lt;/code&gt; 다음을 추가합니다 :</target>
        </trans-unit>
        <trans-unit id="6d1f8e8d9a788b93b49454806edd8d6f19ea0326" translate="yes" xml:space="preserve">
          <source>In your controller you can access the session through the &lt;code&gt;session&lt;/code&gt; instance method.</source>
          <target state="translated">컨트롤러에서 &lt;code&gt;session&lt;/code&gt; 인스턴스 방법을 통해 세션에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20313399289d6ad32ea0f25486fb25f73b6a1650" translate="yes" xml:space="preserve">
          <source>In your integration tests, you can do something like this:</source>
          <target state="translated">통합 테스트에서 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77569b20d1403399dd78bff7dad56dca4c39d837" translate="yes" xml:space="preserve">
          <source>In your migrations/schema, you will add a references column to the model itself.</source>
          <target state="translated">마이그레이션 / 스키마에서 모델 자체에 참조 열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ed89d3298ab08bf564636e9e1eea9e37ffc2f147" translate="yes" xml:space="preserve">
          <source>In your view template you could use something like</source>
          <target state="translated">뷰 템플릿에서 다음과 같은 것을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="82340ae6007cc58d7c548a04779b98577444585b" translate="yes" xml:space="preserve">
          <source>InboundEmail</source>
          <target state="translated">InboundEmail</target>
        </trans-unit>
        <trans-unit id="a2ca380949bd2057d6cdc7b1a64745c4fb788fad" translate="yes" xml:space="preserve">
          <source>InboundEmail#mail</source>
          <target state="translated">InboundEmail#mail</target>
        </trans-unit>
        <trans-unit id="54414ba50dcb2d80fb74313ab3fda2b9f0df9706" translate="yes" xml:space="preserve">
          <source>InboundEmail#processed?</source>
          <target state="translated">InboundEmail#processed?</target>
        </trans-unit>
        <trans-unit id="824dd431201525fd3c331dec03aa796e0bdf2999" translate="yes" xml:space="preserve">
          <source>InboundEmail#source</source>
          <target state="translated">InboundEmail#source</target>
        </trans-unit>
        <trans-unit id="a4b17cd6aa1bb27eacde79de6be6eb12a19d8fb5" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable</source>
          <target state="translated">InboundEmail::Incineratable</target>
        </trans-unit>
        <trans-unit id="8f576111d92a7d2712339c8f9909670add70e0da" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate</source>
          <target state="translated">InboundEmail::Incineratable#incinerate</target>
        </trans-unit>
        <trans-unit id="ab3295021ae0509b9a0423771d3bb8027490f71f" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable#incinerate_later</source>
          <target state="translated">InboundEmail::Incineratable#incinerate_later</target>
        </trans-unit>
        <trans-unit id="4a96b1371404b43e410f57979e0fc13280a27420" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration</source>
          <target state="translated">InboundEmail::Incineratable::Incineration</target>
        </trans-unit>
        <trans-unit id="4f0b1cec59ebbd3a8456fb217fa4aca34edbfa2c" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration#run</source>
          <target state="translated">InboundEmail::Incineratable::Incineration#run</target>
        </trans-unit>
        <trans-unit id="51cfcbf40a300479b6e6bcbd940a6d346920ecf1" translate="yes" xml:space="preserve">
          <source>InboundEmail::Incineratable::Incineration::new</source>
          <target state="translated">InboundEmail::Incineratable::Incineration::new</target>
        </trans-unit>
        <trans-unit id="40bbbecf96c6d12682faff9578d52533226f3c97" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId</source>
          <target state="translated">InboundEmail::MessageId</target>
        </trans-unit>
        <trans-unit id="154e37c7872ea04e9018c3d4634f5f5f366b70d0" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#create_and_extract_message_id!</source>
          <target state="translated">InboundEmail::MessageId#create_and_extract_message_id!</target>
        </trans-unit>
        <trans-unit id="3e18904aabd7444b3358c765ab98ff3e7a93289b" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#extract_message_id</source>
          <target state="translated">InboundEmail::MessageId#extract_message_id</target>
        </trans-unit>
        <trans-unit id="f5912d0e9fb9f1a27f3fcc3d7157b541ab860c0f" translate="yes" xml:space="preserve">
          <source>InboundEmail::MessageId#generate_missing_message_id</source>
          <target state="translated">InboundEmail::MessageId#generate_missing_message_id</target>
        </trans-unit>
        <trans-unit id="2c0be3c66e86606aab01bf26322bb4ede14060b8" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable</source>
          <target state="translated">InboundEmail::Routable</target>
        </trans-unit>
        <trans-unit id="6c6b1b612c3911b90fce7e2e5e0d1ef6e415c371" translate="yes" xml:space="preserve">
          <source>InboundEmail::Routable#route</source>
          <target state="translated">InboundEmail::Routable#route</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
