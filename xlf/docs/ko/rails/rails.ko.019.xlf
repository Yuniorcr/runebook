<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rails">
    <body>
      <group id="rails">
        <trans-unit id="a9ccc58789e06b5780acca188cdfd5ea8c3ea857" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;capture&lt;/code&gt; method allows you to extract part of a template into a variable. You can then use this variable anywhere in your templates or layout.</source>
          <target state="translated">&lt;code&gt;capture&lt;/code&gt; 방법을 사용하면 변수에 템플릿의 일부를 추출 할 수 있습니다. 그런 다음 템플릿이나 레이아웃의 어느 곳에서나이 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4de7f88df38279a3722cff216b9b16c2e45b9e77" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;change&lt;/code&gt; method is the primary way of writing migrations. It works for the majority of cases, where Active Record knows how to reverse the migration automatically. Currently, the &lt;code&gt;change&lt;/code&gt; method supports only these migration definitions:</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 방법은 마이그레이션을 작성하는 기본 방법입니다. Active Record가 마이그레이션을 자동으로 되 돌리는 방법을 알고있는 대부분의 경우에 작동합니다. 현재 &lt;code&gt;change&lt;/code&gt; 방법은 다음 마이그레이션 정의 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="52363d1f5d46bcb294b35d60ee3388ba22f43eac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;clear&lt;/code&gt; method is used when you intentionally want to clear all the messages in the &lt;code&gt;errors&lt;/code&gt; collection. Of course, calling &lt;code&gt;errors.clear&lt;/code&gt; upon an invalid object won't actually make it valid: the &lt;code&gt;errors&lt;/code&gt; collection will now be empty, but the next time you call &lt;code&gt;valid?&lt;/code&gt; or any method that tries to save this object to the database, the validations will run again. If any of the validations fail, the &lt;code&gt;errors&lt;/code&gt; collection will be filled again.</source>
          <target state="translated">&lt;code&gt;clear&lt;/code&gt; 의도적으로 모든 메시지를 삭제하고자 할 때 방법이 사용되는 &lt;code&gt;errors&lt;/code&gt; 모음. 물론 유효하지 않은 객체에 대해 &lt;code&gt;errors.clear&lt;/code&gt; 를 호출 하면 실제로 유효하지 않습니다. 이제 &lt;code&gt;errors&lt;/code&gt; 모음이 비어 있지만 다음에 호출 할 때는 &lt;code&gt;valid?&lt;/code&gt; 또는이 개체를 데이터베이스에 저장하려고 시도하는 방법이면 유효성 검사가 다시 실행됩니다. 유효성 검사 중 하나라도 실패하면 &lt;code&gt;errors&lt;/code&gt; 수집이 다시 채워집니다.</target>
        </trans-unit>
        <trans-unit id="747426e03fbb67e61fd2ae08fcc3cfb653a768ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection&amp;lt;&amp;lt;&lt;/code&gt; method adds one or more objects to the collection by creating records in the join table.</source>
          <target state="translated">&lt;code&gt;collection&amp;lt;&amp;lt;&lt;/code&gt; 방법 조인 테이블의 레코드를 생성하여 수집하는 하나 개 이상의 객체를 추가한다.</target>
        </trans-unit>
        <trans-unit id="52c2e305157f0a7acd1f52b19c909ce36a4af12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection&amp;lt;&amp;lt;&lt;/code&gt; method adds one or more objects to the collection by setting their foreign keys to the primary key of the calling model.</source>
          <target state="translated">&lt;code&gt;collection&amp;lt;&amp;lt;&lt;/code&gt; 메소드 호출 모델의 기본 키에 자신의 외래 키를 설정하여 컬렉션에 하나 개 이상의 객체를 추가한다.</target>
        </trans-unit>
        <trans-unit id="0bda4b98ab37ef84ebed66286bb597e3970c7422" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.build&lt;/code&gt; method returns a new object of the associated type. This object will be instantiated from the passed attributes, and the link through the join table will be created, but the associated object will &lt;em&gt;not&lt;/em&gt; yet be saved.</source>
          <target state="translated">&lt;code&gt;collection.build&lt;/code&gt; 의 방법은 관련 유형의 새 개체를 반환합니다. 이 오브젝트는 전달 된 속성에서 인스턴스화되고 결합 테이블을 통한 링크가 작성되지만 연관된 오브젝트는 아직 저장 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="da44299648048b8c8fd4e652c2a5ca454c468e1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.build&lt;/code&gt; method returns a single or array of new objects of the associated type. The object(s) will be instantiated from the passed attributes, and the link through their foreign key will be created, but the associated objects will &lt;em&gt;not&lt;/em&gt; yet be saved.</source>
          <target state="translated">&lt;code&gt;collection.build&lt;/code&gt; 의 방법은 단일 또는 관련 유형의 새 개체의 배열을 반환합니다. 전달 된 속성에서 객체가 인스턴스화되고 외래 키를 통한 링크가 생성되지만 관련 객체는 아직 저장 &lt;em&gt;되지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c64eb83a83c405a15636c5df770868b792e1feb6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.clear&lt;/code&gt; method removes all objects from the collection according to the strategy specified by the &lt;code&gt;dependent&lt;/code&gt; option. If no option is given, it follows the default strategy. The default strategy for &lt;code&gt;has_many :through&lt;/code&gt; associations is &lt;code&gt;delete_all&lt;/code&gt;, and for &lt;code&gt;has_many&lt;/code&gt; associations is to set the foreign keys to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection.clear&lt;/code&gt; 방법은에 의해 지정된 전략에 따라 컬렉션에서 모든 개체를 제거 &lt;code&gt;dependent&lt;/code&gt; 옵션을 선택합니다. 옵션이 제공되지 않으면 기본 전략을 따릅니다. &lt;code&gt;has_many :through&lt;/code&gt; 연관 의 기본 전략 은 &lt;code&gt;delete_all&lt;/code&gt; 이며 &lt;code&gt;has_many&lt;/code&gt; 연관의 경우 외래 키를 &lt;code&gt;NULL&lt;/code&gt; 로 설정하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="e57955c9268a65980fe9cbdb9519ca7edb4fda95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.clear&lt;/code&gt; method removes every object from the collection by deleting the rows from the joining table. This does not destroy the associated objects.</source>
          <target state="translated">&lt;code&gt;collection.clear&lt;/code&gt; 방법은 가입 테이블에서 행을 삭제하여 컬렉션에서 모든 객체를 제거합니다. 연결된 객체가 손상되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79aea364e14abf64ed5b39bad446dff98746df59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.create&lt;/code&gt; method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through the join table will be created, and, once it passes all of the validations specified on the associated model, the associated object &lt;em&gt;will&lt;/em&gt; be saved.</source>
          <target state="translated">&lt;code&gt;collection.create&lt;/code&gt; 의 방법은 관련 유형의 새 개체를 반환합니다. 이 오브젝트는 전달 된 속성에서 인스턴스화되고 결합 테이블을 통한 링크가 작성되며 연관된 모델에 지정된 모든 유효성 검증을 통과하면 연관된 오브젝트 &lt;em&gt;가&lt;/em&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="1f1d86ca6c46c7edff29fe46d1d4bf565405a9f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.create&lt;/code&gt; method returns a single or array of new objects of the associated type. The object(s) will be instantiated from the passed attributes, the link through its foreign key will be created, and, once it passes all of the validations specified on the associated model, the associated object &lt;em&gt;will&lt;/em&gt; be saved.</source>
          <target state="translated">&lt;code&gt;collection.create&lt;/code&gt; 의 방법은 단일 또는 관련 유형의 새 개체의 배열을 반환합니다. 전달 된 속성에서 객체가 인스턴스화되고 외래 키를 통한 링크가 생성되며 연결된 모델에 지정된 모든 유효성 검사를 통과하면 관련 객체 &lt;em&gt;가&lt;/em&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3f94a02d5529be33dd9be69fd479c955d67ac228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.delete&lt;/code&gt; method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.</source>
          <target state="translated">&lt;code&gt;collection.delete&lt;/code&gt; 의 방법은 테이블을 조인에서 레코드를 삭제하여 컬렉션에서 하나 이상의 개체를 제거합니다. 이것은 객체를 파괴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d1cff808e84834ec38fabb007acbd37987ea6cd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.delete&lt;/code&gt; method removes one or more objects from the collection by setting their foreign keys to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;collection.delete&lt;/code&gt; 의 방법은 자신의 외래 키를 설정하여 컬렉션에서 하나 이상의 개체를 제거 &lt;code&gt;NULL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e024fd3e84ada74d6a57d4ac8f10d7498ff038cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.destroy&lt;/code&gt; method removes one or more objects from the collection by deleting records in the join table. This does not destroy the objects.</source>
          <target state="translated">&lt;code&gt;collection.destroy&lt;/code&gt; 의 방법은 테이블을 조인에서 레코드를 삭제하여 컬렉션에서 하나 이상의 개체를 제거합니다. 이것은 객체를 파괴하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86960d901693f692a364bb363e848dfc5b9ad8ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.destroy&lt;/code&gt; method removes one or more objects from the collection by running &lt;code&gt;destroy&lt;/code&gt; on each object.</source>
          <target state="translated">&lt;code&gt;collection.destroy&lt;/code&gt; 의 방법을 실행하여 컬렉션에서 하나 이상의 개체를 제거 &lt;code&gt;destroy&lt;/code&gt; 각 개체에.</target>
        </trans-unit>
        <trans-unit id="dccf6e678bc8fa88ffc5ac217bb601392c83279d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.empty?&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the collection does not contain any associated objects.</source>
          <target state="translated">&lt;code&gt;collection.empty?&lt;/code&gt; 컬렉션에 연결된 개체가없는 경우 메서드는 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="2078c200f57bc84e51d0e94e10a5f288f37d2bd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.exists?&lt;/code&gt; method checks whether an object meeting the supplied conditions exists in the collection. It uses the same syntax and options as &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F&quot;&gt;&lt;code&gt;ActiveRecord::Base.exists?&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;collection.exists?&lt;/code&gt; 메소드는 제공된 조건을 충족하는 오브젝트가 콜렉션에 존재하는지 확인합니다. &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-exists-3F&quot;&gt; &lt;code&gt;ActiveRecord::Base.exists?&lt;/code&gt; &lt;/a&gt; 와 동일한 구문 및 옵션을 사용합니까? .</target>
        </trans-unit>
        <trans-unit id="0f39d9f47ccaaecc0652f9871a10515043c71e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.find&lt;/code&gt; method finds objects within the collection. It uses the same syntax and options as &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find&quot;&gt;&lt;code&gt;ActiveRecord::Base.find&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;collection.find&lt;/code&gt; 방법의 발견 컬렉션 내에서 객체. &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveRecord/FinderMethods.html#method-i-find&quot;&gt; &lt;code&gt;ActiveRecord::Base.find&lt;/code&gt; &lt;/a&gt; 와 동일한 구문 및 옵션을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7bf6cbd5227f99cf9aafbac09b4cee01b2d29f9f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.reload&lt;/code&gt; method returns a Relation of all of the associated objects, forcing a database read. If there are no associated objects, it returns an empty Relation.</source>
          <target state="translated">&lt;code&gt;collection.reload&lt;/code&gt; 의 방법은 데이터베이스 읽기를 강요 관련된 모든 객체의 관계를 반환합니다. 연결된 객체가 없으면 빈 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5b6961f00cdeaf4f39851a5c526f17f9d49e753c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.size&lt;/code&gt; method returns the number of objects in the collection.</source>
          <target state="translated">&lt;code&gt;collection.size&lt;/code&gt; 의 방법은 컬렉션의 개체 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="73b01b4a44936bdc17f5df3c4b75af136e09f5e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection.where&lt;/code&gt; method finds objects within the collection based on the conditions supplied but the objects are loaded lazily meaning that the database is queried only when the object(s) are accessed.</source>
          <target state="translated">&lt;code&gt;collection.where&lt;/code&gt; 의 방법 발견은 주어진 조건에 따라 집합 내의 개체하지만 객체는 객체 (들)에 액세스 할 때 데이터베이스에서만 쿼리 즉 느리게 로딩된다.</target>
        </trans-unit>
        <trans-unit id="18fdcd242505e917fac431cfc51df7e21bfaeaf2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection&lt;/code&gt; method returns a Relation of all of the associated objects. If there are no associated objects, it returns an empty Relation.</source>
          <target state="translated">&lt;code&gt;collection&lt;/code&gt; 방법은 관련된 모든 객체의 관계를 반환합니다. 연결된 객체가 없으면 빈 관계를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bfaaefd4db4f3cd04e948d95b96abdd865effecd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection=&lt;/code&gt; method makes the collection contain only the supplied objects, by adding and deleting as appropriate. The changes are persisted to the database.</source>
          <target state="translated">&lt;code&gt;collection=&lt;/code&gt; 방법은 컬렉션 추가하고 적절하게 삭제함으로써, 반드시 제공된 객체를 포함한다. 변경 사항은 데이터베이스에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="d37e627506324620457a4e0665ed9847e99698ce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection_select&lt;/code&gt;, &lt;code&gt;select&lt;/code&gt; and &lt;code&gt;time_zone_select&lt;/code&gt; methods take an &lt;code&gt;options&lt;/code&gt; parameter, a hash:</source>
          <target state="translated">&lt;code&gt;collection_select&lt;/code&gt; 은 , &lt;code&gt;select&lt;/code&gt; 및 &lt;code&gt;time_zone_select&lt;/code&gt; 방법은 걸릴 &lt;code&gt;options&lt;/code&gt; 매개 변수 해시를 :</target>
        </trans-unit>
        <trans-unit id="42b13ad548b39d592b9e016b4ba688178912bda7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection_singular_ids&lt;/code&gt; method returns an array of the ids of the objects in the collection.</source>
          <target state="translated">&lt;code&gt;collection_singular_ids&lt;/code&gt; 의 방법은 컬렉션 내의 오브젝트 ID의 배열을 반환한다.</target>
        </trans-unit>
        <trans-unit id="b23d977aaa3c3719b6d91d2ec216cbcb0f193d0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;collection_singular_ids=&lt;/code&gt; method makes the collection contain only the objects identified by the supplied primary key values, by adding and deleting as appropriate. The changes are persisted to the database.</source>
          <target state="translated">&lt;code&gt;collection_singular_ids=&lt;/code&gt; 방법은 컬렉션 추가하고 적절하게 삭제함으로써, 제공된 차 키 값에 의해 식별되는 오브젝트 만 포함한다. 변경 사항은 데이터베이스에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e952b938d58d6084d7b7f0b5dd92fc081db2f4b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comment_counter&lt;/code&gt; local variable is given to us by the &lt;code&gt;&amp;lt;%= render
@article.comments %&amp;gt;&lt;/code&gt; call, which will define it automatically and increment the counter as it iterates through each comment. It's used in this example to display a small number next to each comment when it's created.</source>
          <target state="translated">&lt;code&gt;comment_counter&lt;/code&gt; 지역 변수는 우리에게 주어진 &lt;code&gt;&amp;lt;%= render @article.comments %&amp;gt;&lt;/code&gt; 자동으로 정의하고 각 주석을 통해 반복 할 때마다 카운터를 증가시킵니다 전화를. 이 예제에서는 생성 될 때 각 주석 옆에 작은 숫자를 표시하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="b5a18ffd54b8d06fa059d1aa72036ea6be911b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; resource here will have the following routes generated for it:</source>
          <target state="translated">&lt;code&gt;comments&lt;/code&gt; 자원은 여기에 대해 생성 된 다음과 같은 경로를해야합니다 :</target>
        </trans-unit>
        <trans-unit id="bcddb145915983f232e89d8b60105fdad174ef82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config.assets.compress&lt;/code&gt; option should be changed to &lt;code&gt;config.assets.js_compressor&lt;/code&gt; like so for instance:</source>
          <target state="translated">&lt;code&gt;config.assets.compress&lt;/code&gt; 의 옵션을 변경해야 &lt;code&gt;config.assets.js_compressor&lt;/code&gt; 그래서 예를 들어 같은 :</target>
        </trans-unit>
        <trans-unit id="81ea9d1a743856ce330b80944082aed773e77cd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config/database.yml&lt;/code&gt; file can contain ERB tags &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;. Anything in the tags will be evaluated as Ruby code. You can use this to pull out data from an environment variable or to perform calculations to generate the needed connection information.</source>
          <target state="translated">&lt;code&gt;config/database.yml&lt;/code&gt; 파일 ERB 태그를 포함 할 수있는 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; . 태그의 모든 것은 루비 코드로 평가됩니다. 이를 사용하여 환경 변수에서 데이터를 가져 오거나 계산을 수행하여 필요한 연결 정보를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b5b26498ab5ce6ae7e3eaf238a18e4fe8751e40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;config/database.yml&lt;/code&gt; file contains sections for three different environments in which Rails can run by default:</source>
          <target state="translated">&lt;code&gt;config/database.yml&lt;/code&gt; 파일 레일 기본적으로 실행할 수있는 세 가지 환경에 대한 섹션이 포함되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fbb767edbee15e6b4db32c2ef7f30c52f1f8b7aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;console&lt;/code&gt; command lets you interact with your Rails application from the command line. On the underside, &lt;code&gt;rails console&lt;/code&gt; uses IRB, so if you've ever used it, you'll be right at home. This is useful for testing out quick ideas with code and changing data server-side without touching the website.</source>
          <target state="translated">&lt;code&gt;console&lt;/code&gt; 명령은 명령 줄에서 레일즈 응용 프로그램을 상호 작용할 수 있습니다. 밑면에서 &lt;code&gt;rails console&lt;/code&gt; 은 IRB를 사용하므로,이를 사용한 적이 있다면 집에있을 것입니다. 웹 사이트를 건드리지 않고 코드로 빠른 아이디어를 테스트하고 데이터를 서버 측에서 변경하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="cf7909e4645ce0f8e3bc57c99609c96524b74007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content_for&lt;/code&gt; method allows you to insert content into a named &lt;code&gt;yield&lt;/code&gt; block in your layout. For example, this view would work with the layout that you just saw:</source>
          <target state="translated">&lt;code&gt;content_for&lt;/code&gt; 방법은 당신이 이름에 내용을 삽입 할 수 있습니다 &lt;code&gt;yield&lt;/code&gt; 레이아웃의 블록. 예를 들어,이보기는 방금 본 레이아웃에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b57aacef775f5d5de17020f91a0370ba1db4293c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;content_for&lt;/code&gt; method is very helpful when your layout contains distinct regions such as sidebars and footers that should get their own blocks of content inserted. It's also useful for inserting tags that load page-specific JavaScript or css files into the header of an otherwise generic layout.</source>
          <target state="translated">&lt;code&gt;content_for&lt;/code&gt; 레이아웃은 삽입 된 콘텐츠를 자신의 블록을 받아야 사이드 바 및 바닥 글 등의 특정 영역이 포함 된 경우 방법은 매우 유용합니다. 또한 페이지 별 JavaScript 또는 CSS 파일을로드하는 태그를 그렇지 않은 경우 일반 레이아웃의 헤더에 삽입하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4ee85edc9c6c2aca0740d9a87c79c1479e3bb5d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create_association&lt;/code&gt; method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through its foreign key will be set, and, once it passes all of the validations specified on the associated model, the associated object &lt;em&gt;will&lt;/em&gt; be saved.</source>
          <target state="translated">&lt;code&gt;create_association&lt;/code&gt; 의 방법은 관련 유형의 새 개체를 반환합니다. 이 객체는 전달 된 속성에서 인스턴스화되고 외래 키를 통한 링크가 설정되며 연결된 모델에 지정된 모든 유효성 검사를 통과하면 관련 객체 &lt;em&gt;가&lt;/em&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="15fecea2b55267fcd907c56315c3dd462ead23df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create_association&lt;/code&gt; method returns a new object of the associated type. This object will be instantiated from the passed attributes, the link through this object's foreign key will be set, and, once it passes all of the validations specified on the associated model, the associated object &lt;em&gt;will&lt;/em&gt; be saved.</source>
          <target state="translated">&lt;code&gt;create_association&lt;/code&gt; 의 방법은 관련 유형의 새 개체를 반환합니다. 이 객체는 전달 된 속성에서 인스턴스화되고이 객체의 외래 키를 통한 링크가 설정되며 연결된 모델에 지정된 모든 유효성 검사를 통과하면 관련 객체 &lt;em&gt;가&lt;/em&gt; 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="415ddd2cfe56689235d4b9ff68703679c48f943a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create_table&lt;/code&gt; method is one of the most fundamental, but most of the time, will be generated for you from using a model or scaffold generator. A typical use would be</source>
          <target state="translated">&lt;code&gt;create_table&lt;/code&gt; 방법은 가장 기본적인 중 하나이지만, 대부분의 시간은 모델 또는 비계 생성기를 사용하는 당신을 위해 생성됩니다. 일반적인 용도는</target>
        </trans-unit>
        <trans-unit id="4c057485bb8f81f79e0625b19f3e5ee882e09353" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;custom_proxies&lt;/code&gt; argument can take an &lt;a href=&quot;../array&quot;&gt;Array&lt;/a&gt; of string, IPAddr, or Regexp objects which will be used instead of &lt;code&gt;TRUSTED_PROXIES&lt;/code&gt;. If a single string, IPAddr, or Regexp object is provided, it will be used in addition to &lt;code&gt;TRUSTED_PROXIES&lt;/code&gt;. Any proxy setup will put the value you want in the middle (or at the beginning) of the X-Forwarded-For list, with your proxy servers after it. If your proxies aren't removed, pass them in via the &lt;code&gt;custom_proxies&lt;/code&gt; parameter. That way, the middleware will ignore those IP addresses, and return the one that you want.</source>
          <target state="translated">&lt;code&gt;custom_proxies&lt;/code&gt; 의 인수는 취할 수 &lt;a href=&quot;../array&quot;&gt;배열&lt;/a&gt; 대신 사용됩니다 문자열, IPADDR, 또는 정규 표현식 객체의 &lt;code&gt;TRUSTED_PROXIES&lt;/code&gt; 을 . 하나의 문자열이, IPADDR, 또는 정규 표현식 객체가 제공되는 경우, 추가로 사용됩니다 &lt;code&gt;TRUSTED_PROXIES&lt;/code&gt; . 모든 프록시 설정은 원하는 값을 X-Forwarded-For 목록의 중간 (또는 시작 부분)에 프록시 서버와 함께 배치합니다. 프록시가 제거되지 않은 경우 &lt;code&gt;custom_proxies&lt;/code&gt; 매개 변수 를 통해 전달하십시오 . 이렇게하면 미들웨어가 해당 IP 주소를 무시하고 원하는 IP 주소를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="c41ad3da2e0319cfebdab41da97da525b45dbc0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;database.yml&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;database.yml&lt;/code&gt; 을의 다음과 같다 :</target>
        </trans-unit>
        <trans-unit id="7d1859ca9424072fe323d72e6dd2599b2ab66287" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;database&lt;/code&gt; argument for &lt;code&gt;connected_to&lt;/code&gt; will take a symbol or a config hash.</source>
          <target state="translated">&lt;code&gt;connected_to&lt;/code&gt; 의 &lt;code&gt;database&lt;/code&gt; 인수 는 기호 또는 구성 해시를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="db3d724cfc4019016e901b91b11e52305a4a8714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;db/schema.rb&lt;/code&gt; or &lt;code&gt;db/structure.sql&lt;/code&gt; is a snapshot of the current state of your database and is the authoritative source for rebuilding that database. This makes it possible to delete old migration files.</source>
          <target state="translated">&lt;code&gt;db/schema.rb&lt;/code&gt; 또는 &lt;code&gt;db/structure.sql&lt;/code&gt; 된 스냅 샷 데이터베이스의 현재 상태와 해당 데이터베이스를 다시 작성에 대한 권위있는 소스입니다. 이전 마이그레이션 파일을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3959eb49c6c937e7b51e91468daafd97372bf861" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;db:migrate:redo&lt;/code&gt; command is a shortcut for doing a rollback and then migrating back up again. As with the &lt;code&gt;db:rollback&lt;/code&gt; command, you can use the &lt;code&gt;STEP&lt;/code&gt; parameter if you need to go more than one version back, for example:</source>
          <target state="translated">&lt;code&gt;db:migrate:redo&lt;/code&gt; 명령은 롤백을 수행 한 후 최대 다시 마이그레이션에 대한 바로 가기입니다. 와 마찬가지로 &lt;code&gt;db:rollback&lt;/code&gt; 명령, 당신은 사용할 수 있습니다 &lt;code&gt;STEP&lt;/code&gt; 의 당신은 예를 들어, 하나의 버전 다시보다 더 이동해야하는 경우 매개 변수를 :</target>
        </trans-unit>
        <trans-unit id="75cef429e1feebd2a6d33d0cbdbdbdc2ea720667" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;debug&lt;/code&gt; helper will return a &amp;lt;pre&amp;gt; tag that renders the object using the YAML format. This will generate human-readable data from any object. For example, if you have this code in a view:</source>
          <target state="translated">&lt;code&gt;debug&lt;/code&gt; 도우미는 YAML 형식을 사용하여 객체를 렌더링하는 &amp;lt;전&amp;gt; 태그를 반환합니다. 모든 객체에서 사람이 읽을 수있는 데이터를 생성합니다. 예를 들어,보기에이 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="b493d0854984f2584246afbcb36a7be9ece90272" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;deep_dup&lt;/code&gt; method returns a deep copy of a given object. Normally, when you &lt;code&gt;dup&lt;/code&gt; an object that contains other objects, Ruby does not &lt;code&gt;dup&lt;/code&gt; them, so it creates a shallow copy of the object. If you have an array with a string, for example, it will look like this:</source>
          <target state="translated">&lt;code&gt;deep_dup&lt;/code&gt; 방법은 주어진 객체의 전체 복사본을 반환합니다. 일반적으로,이 때 &lt;code&gt;dup&lt;/code&gt; 다른 개체를 포함하는 개체를, 루비하지 않습니다 &lt;code&gt;dup&lt;/code&gt; 는 개체의 단순 복사본을 생성, 그래서 그들을. 예를 들어 문자열이있는 배열이있는 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d355c3365b621ded8bdfdde3fa1040a426821f06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;default&lt;/code&gt; and &lt;code&gt;scope&lt;/code&gt; keywords are reserved and can't be used as variable names. If used, an &lt;code&gt;I18n::ReservedInterpolationKey&lt;/code&gt; exception is raised. If a translation expects an interpolation variable, but this has not been passed to &lt;code&gt;#translate&lt;/code&gt;, an &lt;code&gt;I18n::MissingInterpolationArgument&lt;/code&gt; exception is raised.</source>
          <target state="translated">&lt;code&gt;default&lt;/code&gt; 및 &lt;code&gt;scope&lt;/code&gt; 키워드는 예약되어 변수 이름으로 사용할 수 없습니다. 사용되는 경우 &lt;code&gt;I18n::ReservedInterpolationKey&lt;/code&gt; 예외가 발생합니다. 변환에 보간 변수가 필요하지만 &lt;code&gt;#translate&lt;/code&gt; 로 전달되지 않은 경우 &lt;code&gt;I18n::MissingInterpolationArgument&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0efd92da2bceb986cab71b9630a216f1f94a3f4c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;default_scope&lt;/code&gt; is also applied while creating/building a record when the scope arguments are given as a &lt;code&gt;Hash&lt;/code&gt;. It is not applied while updating a record. E.g.:</source>
          <target state="translated">&lt;code&gt;default_scope&lt;/code&gt; 은 또한 범위를 인수로 주어진이 때 기록 건축 / 만드는 동안인가 &lt;code&gt;Hash&lt;/code&gt; . 레코드를 업데이트하는 동안 적용되지 않습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="f2d51c1146ecac1b7522a33b089ece83ff01d819" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaults&lt;/code&gt; parameter is unused.</source>
          <target state="translated">&lt;code&gt;defaults&lt;/code&gt; 매개 변수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10515ea55b6aaa14662e42d4f249c7bdf7584ed9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delegate&lt;/code&gt; macro accepts several methods:</source>
          <target state="translated">&lt;code&gt;delegate&lt;/code&gt; 매크로는 여러 가지 방법을 받아 들인다 :</target>
        </trans-unit>
        <trans-unit id="d9862d702a5231c262fe75d4cdd615251c770144" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; method in collection associations can now receive &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; arguments as record ids, besides records, pretty much like the &lt;code&gt;destroy&lt;/code&gt; method does. Previously it raised &lt;code&gt;ActiveRecord::AssociationTypeMismatch&lt;/code&gt; for such arguments. From Rails 4.0 on &lt;code&gt;delete&lt;/code&gt; automatically tries to find the records matching the given ids before deleting them.</source>
          <target state="translated">콜렉션 연관 의 &lt;code&gt;delete&lt;/code&gt; 메소드는 이제 &lt;code&gt;destroy&lt;/code&gt; 메소드 와 거의 비슷하게 레코드 외에 &lt;code&gt;Integer&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 인수를 레코드 ID로 수신 할 수 있습니다 . 이전에는 이러한 인수에 대해 &lt;code&gt;ActiveRecord::AssociationTypeMismatch&lt;/code&gt; 발생했습니다 . &lt;code&gt;delete&lt;/code&gt; Rails 4.0부터는 주어진 ID와 일치하는 레코드를 삭제하기 전에 자동으로 찾습니다.</target>
        </trans-unit>
        <trans-unit id="6252c621b15137a9455c19049b370dfca7fa87ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete&lt;/code&gt; routing method should be used for routes that destroy resources. If this was left as a typical &lt;code&gt;get&lt;/code&gt; route, it could be possible for people to craft malicious URLs like this:</source>
          <target state="translated">&lt;code&gt;delete&lt;/code&gt; 라우팅 방법은 자원을 파괴하는 경로를 사용해야합니다. 이것이 일반적인 &lt;code&gt;get&lt;/code&gt; 경로 로 남은 경우 사람들이 다음과 같은 악성 URL을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b37ac1a053bd42ff87ff2e12ac547bf6084b7ab5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;descendants&lt;/code&gt; method returns all classes that are &lt;code&gt;&amp;lt;&lt;/code&gt; than its receiver:</source>
          <target state="translated">&lt;code&gt;descendants&lt;/code&gt; 방법은 모든 클래스 반환 &lt;code&gt;&amp;lt;&lt;/code&gt; 리시버보다를 :</target>
        </trans-unit>
        <trans-unit id="11d85c3ba681016840334511693e1c6850e3d79c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destroy&lt;/code&gt; action redirects to the application's &lt;code&gt;root_url&lt;/code&gt;, where the message will be displayed. Note that it's entirely up to the next action to decide what, if anything, it will do with what the previous action put in the flash. It's conventional to display any error alerts or notices from the flash in the application's layout:</source>
          <target state="translated">는 &lt;code&gt;destroy&lt;/code&gt; 응용 프로그램의에 액션 리디렉션 &lt;code&gt;root_url&lt;/code&gt; 메시지가 표시됩니다. 이전 액션이 플래시에 어떤 영향을 미치는지 결정하는 것은 전적으로 다음 액션에 달려 있습니다. 응용 프로그램 레이아웃에서 플래시의 오류 경고 또는 알림을 표시하는 것이 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="c21e61cb7247256721b1b304dc61c75bbdff3a81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;destroy&lt;/code&gt; action will find the article we are looking at, locate the comment within the &lt;code&gt;@article.comments&lt;/code&gt; collection, and then remove it from the database and send us back to the show action for the article.</source>
          <target state="translated">&lt;code&gt;destroy&lt;/code&gt; 우리가 찾고있는 문서를 찾을 행동은 내 의견 찾을 &lt;code&gt;@article.comments&lt;/code&gt; 수집, 다음 데이터베이스에서 제거하고 기사의 show 액션으로 우리를 다시 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a254d60cd7f9d05012eea0abcf72cf44d6a965e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;development&lt;/code&gt; environment is used on your development/local computer as you interact manually with the application.</source>
          <target state="translated">&lt;code&gt;development&lt;/code&gt; 환경은 응용 프로그램과 상호 작용 수동으로 개발 / 로컬 컴퓨터에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="793dd0d609355dd91493a40856db4e7bac65ca4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;div_radio_button&lt;/code&gt; code from above can now be used as follows:</source>
          <target state="translated">위의 &lt;code&gt;div_radio_button&lt;/code&gt; 코드를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04d3819f2490117215396990c85b6d2c2099121e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;download_pdf&lt;/code&gt; action in the example above will call a private method which actually generates the PDF document and returns it as a string. This string will then be streamed to the client as a file download and a filename will be suggested to the user. Sometimes when streaming files to the user, you may not want them to download the file. Take images, for example, which can be embedded into HTML pages. To tell the browser a file is not meant to be downloaded, you can set the &lt;code&gt;:disposition&lt;/code&gt; option to &quot;inline&quot;. The opposite and default value for this option is &quot;attachment&quot;.</source>
          <target state="translated">위 예제 의 &lt;code&gt;download_pdf&lt;/code&gt; 액션은 실제로 PDF 문서를 생성하고이를 문자열로 반환하는 private 메소드를 호출합니다. 이 문자열은 파일 다운로드로 클라이언트에 스트리밍되고 파일 이름이 사용자에게 제안됩니다. 때로는 파일을 사용자에게 스트리밍 할 때 파일을 다운로드하지 않을 수 있습니다. 예를 들어 HTML 페이지에 포함 할 수있는 이미지를 촬영하십시오. 브라우저에 파일을 다운로드하지 않으려면 &lt;code&gt;:disposition&lt;/code&gt; 옵션을 &quot;inline&quot;으로 설정하면 됩니다. 이 옵션의 반대 및 기본값은 &quot;첨부 파일&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="302a65d72eda980fa138b8f99f35f1838dd35a0b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;enum&lt;/code&gt; macro maps an integer column to a set of possible values.</source>
          <target state="translated">&lt;code&gt;enum&lt;/code&gt; 매크로 가능한 값들의 세트에 정수 열을 맵핑한다.</target>
        </trans-unit>
        <trans-unit id="680d859d659528ea29dc798cbd6d7fb95120da45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errors.full_messages&lt;/code&gt; method (or its equivalent, &lt;code&gt;errors.to_a&lt;/code&gt;) returns the error messages in a user-friendly format, with the capitalized attribute name prepended to each message, as shown in the examples below.</source>
          <target state="translated">&lt;code&gt;errors.full_messages&lt;/code&gt; 의 방법 (또는 그와 동등한, &lt;code&gt;errors.to_a&lt;/code&gt; 는 ) 아래 예와 같이, 각각의 메시지 앞에 추가 대문자 속성 이름, 사용자 친화적 인 형태로 에러 메시지를 반환한다.</target>
        </trans-unit>
        <trans-unit id="3be084dae615fd05f276a20e304dbd1661339942" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exclusion&lt;/code&gt; helper has an option &lt;code&gt;:in&lt;/code&gt; that receives the set of values that will not be accepted for the validated attributes. The &lt;code&gt;:in&lt;/code&gt; option has an alias called &lt;code&gt;:within&lt;/code&gt; that you can use for the same purpose, if you'd like to. This example uses the &lt;code&gt;:message&lt;/code&gt; option to show how you can include the attribute's value. For full options to the message argument please see the &lt;a href=&quot;#message&quot;&gt;message documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;exclusion&lt;/code&gt; 도우미는 옵션이 있습니다 &lt;code&gt;:in&lt;/code&gt; 그 유효성이 검증 된 속성에 대해 허용되지 않습니다 값 세트를받습니다. 는 &lt;code&gt;:in&lt;/code&gt; 옵션라는 별칭이 &lt;code&gt;:within&lt;/code&gt; 당신이 원하는 경우, 같은 목적으로 사용할 수 있습니다. 이 예제는 &lt;code&gt;:message&lt;/code&gt; 옵션을 사용 하여 속성 값을 포함하는 방법을 보여줍니다. 메시지 인수에 대한 전체 옵션은 &lt;a href=&quot;#message&quot;&gt;메시지 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="027d9be8c0f72dc7f6ad32ab9c17f75b4b37a3e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exists?&lt;/code&gt; method also takes multiple values, but the catch is that it will return &lt;code&gt;true&lt;/code&gt; if any one of those records exists.</source>
          <target state="translated">은 &lt;code&gt;exists?&lt;/code&gt; 이 메소드는 여러 값을 취하지 만, 그 레코드 중 하나가 존재하면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="4fb4ebc6ce4fc6fd7fa99d5a532549a67f6bb54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extending&lt;/code&gt; method specifies a named module to extend the association proxy. Association extensions are discussed in detail &lt;a href=&quot;#association-extensions&quot;&gt;later in this guide&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;extending&lt;/code&gt; 방법은 연관 프록시 확장하는 모듈의 이름을 지정한다. 연결 확장에 대해서는 &lt;a href=&quot;#association-extensions&quot;&gt;이 가이드의 뒷부분에서&lt;/a&gt; 자세히 설명 합니다.</target>
        </trans-unit>
        <trans-unit id="54a74e3ec495e190713f8a3009fabb5c19b1430e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extension&lt;/code&gt; argument allows you to pass a block into a &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;#has_and_belongs_to_many&lt;/a&gt; association. This is useful for adding new finders, creators and other factory-type methods to be used as part of the association.</source>
          <target state="translated">&lt;code&gt;extension&lt;/code&gt; 인수는 당신이에 블록을 전달할 수 있습니다 &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;#has_and_belongs_to_many의&lt;/a&gt; 협회. 이는 새로운 파인더, 작성자 및 기타 팩토리 유형 메소드를 추가하여 연관의 일부로 사용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9a1f2ffe32fde6785207ea099518f4814d3bc55b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extension&lt;/code&gt; argument allows you to pass a block into a &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;#has_many&lt;/a&gt; association. This is useful for adding new finders, creators and other factory-type methods to be used as part of the association.</source>
          <target state="translated">&lt;code&gt;extension&lt;/code&gt; 인수는 당신이에 블록을 전달할 수 있습니다 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;#has_many의&lt;/a&gt; 협회. 이는 새로운 파인더, 작성자 및 기타 팩토리 유형 메소드를 추가하여 연관의 일부로 사용하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2f5d5c953a2fbc0f3b6e6dfcf6e85f31dcd54aaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extras&lt;/code&gt; hash allows you to specify options that would normally be provided as a query string to the action. The &lt;code&gt;message&lt;/code&gt; parameter allows you to specify a custom error message to display upon failure.</source>
          <target state="translated">&lt;code&gt;extras&lt;/code&gt; 해시는 일반적으로 작업에 쿼리 문자열로 제공 될 것이다 옵션을 지정할 수 있습니다. &lt;code&gt;message&lt;/code&gt; 매개 변수는 장애에 표시 할 사용자 지정 오류 메시지를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1895a4603c8d1474d1635c3d4d969d69334d7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields_for&lt;/code&gt; yields a form builder. The parameters' name will be what &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; expects. For example, when creating a user with 2 addresses, the submitted parameters would look like:</source>
          <target state="translated">&lt;code&gt;fields_for&lt;/code&gt; 는 양식 빌더를 얻을 수 있습니다. 매개 변수의 이름은 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 가 기대 하는 이름입니다 . 예를 들어, 주소가 2 개인 사용자를 작성할 때 제출 된 매개 변수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="799c5f4334b11a22099289d7df13055f9c21a6bb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find&lt;/code&gt; method will raise an &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; exception if no matching record is found.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 방법은 올릴 것이다 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 일치 레코드를 찾을 수없는 경우 예외를.</target>
        </trans-unit>
        <trans-unit id="1533c80d477480d7066aa763788f092fca9e885a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find&lt;/code&gt; method will raise an &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; exception unless a matching record is found for &lt;strong&gt;all&lt;/strong&gt; of the supplied primary keys.</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 방법은 올릴 것이다 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 일치하는 레코드를 찾을되지 않는 예외를 &lt;strong&gt;모두&lt;/strong&gt; 제공되는 기본 키의.</target>
        </trans-unit>
        <trans-unit id="63b6a2239c4baaf6fda412a24e05cc4530881b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_by!&lt;/code&gt; method behaves exactly like &lt;code&gt;find_by&lt;/code&gt;, except that it will raise &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; if no matching record is found. For example:</source>
          <target state="translated">&lt;code&gt;find_by!&lt;/code&gt; 이 메서드 는 일치하는 레코드가 없으면 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 발생 &lt;code&gt;find_by&lt;/code&gt; 점을 제외하고 find_by 와 똑같이 동작합니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="20e937bb20da5bd568c6dd7d794226eb2667add3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_by&lt;/code&gt; method finds the first record matching some conditions. For example:</source>
          <target state="translated">&lt;code&gt;find_by&lt;/code&gt; 방법은 특정 조건과 일치하는 상기 제 레코드를 찾는다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ad4e5671336f3d13dac0a9ba0003917813c7ffd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_by_*&lt;/code&gt; and &lt;code&gt;find_by_*!&lt;/code&gt; methods are dynamic finders generated automatically for every attribute. Learn more about them at the &lt;a href=&quot;active_record_querying#dynamic-finders&quot;&gt;Dynamic finders section&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;find_by_*&lt;/code&gt; 및 &lt;code&gt;find_by_*!&lt;/code&gt; 메소드는 모든 속성에 대해 자동으로 생성되는 동적 파인더입니다. &lt;a href=&quot;active_record_querying#dynamic-finders&quot;&gt;동적 파인더 섹션&lt;/a&gt; 에서 이에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="12f7cd64b69f5769cebd13d0d9ee39bd4203da76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_each&lt;/code&gt; and &lt;code&gt;find_in_batches&lt;/code&gt; methods are intended for use in the batch processing of a large number of records that wouldn't fit in memory all at once. If you just need to loop over a thousand records the regular find methods are the preferred option.</source>
          <target state="translated">&lt;code&gt;find_each&lt;/code&gt; 및 &lt;code&gt;find_in_batches&lt;/code&gt; 방법은 모두 한 번에 메모리에 맞지 않는 것 많은 수의 레코드의 일괄 처리에 사용하기위한 것입니다. 수천 개의 레코드를 반복해야하는 경우 일반 찾기 방법이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="117c36d726970df8a08e1c3d127237f2e2e5bc62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_each&lt;/code&gt; method retrieves records in batches and then yields &lt;em&gt;each&lt;/em&gt; one to the block. In the following example, &lt;code&gt;find_each&lt;/code&gt; retrieves users in batches of 1000 and yields them to the block one by one:</source>
          <target state="translated">&lt;code&gt;find_each&lt;/code&gt; 에 있어서 일괄 적으로 레코드를 검색하고 수득 &lt;em&gt;각&lt;/em&gt; 블록에 하나. 다음 예제에서 &lt;code&gt;find_each&lt;/code&gt; 는 1000 단위로 사용자를 검색하여 하나씩 블록에 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5fd7bc75c818774b29b3aa8e727f31bb56804fd3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_in_batches&lt;/code&gt; method accepts the same options as &lt;code&gt;find_each&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;find_in_batches&lt;/code&gt; 의 방법과 같은 옵션을 받아 &lt;code&gt;find_each&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="dd7b4cacd74f1745152d358909ca6b5f582de89e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_in_batches&lt;/code&gt; method is similar to &lt;code&gt;find_each&lt;/code&gt;, since both retrieve batches of records. The difference is that &lt;code&gt;find_in_batches&lt;/code&gt; yields &lt;em&gt;batches&lt;/em&gt; to the block as an array of models, instead of individually. The following example will yield to the supplied block an array of up to 1000 invoices at a time, with the final block containing any remaining invoices:</source>
          <target state="translated">&lt;code&gt;find_in_batches&lt;/code&gt; 의 방법과 유사하다 &lt;code&gt;find_each&lt;/code&gt; 모두 레코드의 일괄 처리를 검색하기 때문에. 차이점은 &lt;code&gt;find_in_batches&lt;/code&gt; 는 개별적으로가 아니라 모델의 배열로 블록에 &lt;em&gt;배치&lt;/em&gt; 를 생성 한다는 것입니다. 다음 예제는 제공된 블록에 한 번에 최대 1000 개의 송장 배열을 생성하고 마지막 블록에는 남은 송장이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6159f520e181d7df651dcb14058e80d760f3616c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_or_create_by&lt;/code&gt; method checks whether a record with the specified attributes exists. If it doesn't, then &lt;code&gt;create&lt;/code&gt; is called. Let's see an example.</source>
          <target state="translated">&lt;code&gt;find_or_create_by&lt;/code&gt; 방법을 확인 지정된 속성을 가진 레코드가 존재하는지 여부. 그렇지 않으면 &lt;code&gt;create&lt;/code&gt; 가 호출됩니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="78010177e32b144c3eb611cb4727270fa751e68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find_or_initialize_by&lt;/code&gt; method will work just like &lt;code&gt;find_or_create_by&lt;/code&gt; but it will call &lt;code&gt;new&lt;/code&gt; instead of &lt;code&gt;create&lt;/code&gt;. This means that a new model instance will be created in memory but won't be saved to the database. Continuing with the &lt;code&gt;find_or_create_by&lt;/code&gt; example, we now want the client named 'Nick':</source>
          <target state="translated">&lt;code&gt;find_or_initialize_by&lt;/code&gt; 의 방법처럼 작동 &lt;code&gt;find_or_create_by&lt;/code&gt; 하지만 호출 &lt;code&gt;new&lt;/code&gt; 대신 &lt;code&gt;create&lt;/code&gt; . 이는 새 모델 인스턴스가 메모리에 생성되지만 데이터베이스에는 저장되지 않음을 의미합니다. &lt;code&gt;find_or_create_by&lt;/code&gt; 예제로 계속해서 , 우리는 'Nick'이라는 클라이언트를 원합니다 :</target>
        </trans-unit>
        <trans-unit id="d5bfb14e15cd31edc4264528b391597824a39d14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;first!&lt;/code&gt; method behaves exactly like &lt;code&gt;first&lt;/code&gt;, except that it will raise &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; if no matching record is found.</source>
          <target state="translated">첫 &lt;code&gt;first!&lt;/code&gt; 이 메서드 는 일치하는 레코드가 없으면 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 발생 시킨다는 점을 제외하고는 정확히 &lt;code&gt;first&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1a13d1386958cd6c653bb308bb0491ae16eb9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;first&lt;/code&gt; method finds the first record ordered by primary key (default). For example:</source>
          <target state="translated">첫 &lt;code&gt;first&lt;/code&gt; 방법은 기본 키로 정렬 된 첫 번째 레코드를 찾습니다 (기본값). 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f0fb551b67c343e2cbfc70d0613f5d2b8370f1a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;first&lt;/code&gt; method returns &lt;code&gt;nil&lt;/code&gt; if no matching record is found and no exception will be raised.</source>
          <target state="translated">첫 &lt;code&gt;first&lt;/code&gt; 메소드는 일치하는 레코드가없고 예외가 발생 &lt;code&gt;nil&lt;/code&gt; 않으면 nil을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="ea5ce53b46ae0e7a449d83e1f68edbcaa2b0afff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force_ssl&lt;/code&gt; method on controllers has been deprecated and will be removed in Rails 6.1. You are encouraged to enable &lt;code&gt;config.force_ssl&lt;/code&gt; to enforce HTTPS connections throughout your application. If you need to exempt certain endpoints from redirection, you can use &lt;code&gt;config.ssl_options&lt;/code&gt; to configure that behavior.</source>
          <target state="translated">컨트롤러 의 &lt;code&gt;force_ssl&lt;/code&gt; 메소드는 더 이상 사용되지 않으며 Rails 6.1에서 제거 될 것입니다. 응용 프로그램 전체에서 HTTPS 연결을 적용 하려면 &lt;code&gt;config.force_ssl&lt;/code&gt; 을 활성화하는 것이 좋습니다 . 특정 엔드 포인트를 리디렉션에서 제외해야하는 경우 &lt;code&gt;config.ssl_options&lt;/code&gt; 를 사용 하여 해당 동작을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="344b9c8a8ca4e68f1a7c0f83112c009f61ba5ac2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form_authenticity_token&lt;/code&gt; generates a valid authentication token. That's useful in places where Rails does not add it automatically, like in custom Ajax calls.</source>
          <target state="translated">&lt;code&gt;form_authenticity_token&lt;/code&gt; 는 유효한 인증 토큰을 생성한다. 이는 커스텀 Ajax 호출과 같이 Rails가 자동으로 추가하지 않는 곳에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="83c8cda0a7befe81fa34ed9e2be2e9caffacbb87" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form_with&lt;/code&gt; method automatically includes the model id as a hidden field in the form. This is used to maintain the correlation between the form data and its associated model. Some ORM systems do not use IDs on nested models so in this case you want to be able to disable the hidden id.</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 의 방법은 자동 형태의 숨겨진 필드로 모델 ID를 포함합니다. 양식 데이터와 관련 모델 간의 상관 관계를 유지하는 데 사용됩니다. 일부 ORM 시스템은 중첩 모델에서 ID를 사용하지 않으므로이 경우 숨겨진 ID를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69b130065a1e0f0936a7a4c2a9440c1ccdf9ed14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;form_with&lt;/code&gt; method yields a &lt;strong&gt;form builder&lt;/strong&gt; object (the &lt;code&gt;f&lt;/code&gt; variable).</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 의 방법은 수득 &lt;strong&gt;형태 빌더&lt;/strong&gt; 객체 ( &lt;code&gt;f&lt;/code&gt; 변수).</target>
        </trans-unit>
        <trans-unit id="44b683ea2740c611d87c006631f44e94224b00ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get&lt;/code&gt; method kicks off the web request and populates the results into the &lt;code&gt;@response&lt;/code&gt;. It can accept up to 6 arguments:</source>
          <target state="translated">&lt;code&gt;get&lt;/code&gt; 에 웹 요청 및 채우는 결과를 방법 차기 &lt;code&gt;@response&lt;/code&gt; . 최대 6 개의 인수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="684e7970be410bc1763730f6ba7c50c76eba1826" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;given_day_in_next_week&lt;/code&gt; defaults to the beginning of the week which is determined by &lt;code&gt;Date.beginning_of_week&lt;/code&gt; or &lt;code&gt;config.beginning_of_week&lt;/code&gt; when set.</source>
          <target state="translated">&lt;code&gt;given_day_in_next_week&lt;/code&gt; 에 의해 결정된다 주초 기본값 &lt;code&gt;Date.beginning_of_week&lt;/code&gt; 또는 &lt;code&gt;config.beginning_of_week&lt;/code&gt; 때 세트.</target>
        </trans-unit>
        <trans-unit id="fd64719a3e7570f62505c4a5411d3c9a04fdcb58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;group&lt;/code&gt; method supplies an attribute name to group the result set by, using a &lt;code&gt;GROUP BY&lt;/code&gt; clause in the finder SQL.</source>
          <target state="translated">&lt;code&gt;group&lt;/code&gt; 방법은 사용에 의해 그룹에 결과 집합을 속성 이름을 제공 &lt;code&gt;GROUP BY&lt;/code&gt; 파인더 SQL에서 절.</target>
        </trans-unit>
        <trans-unit id="7bccb856953557417d83909f7ee9f194969cc46d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; Association</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="990ad7e13d9022e01031f9bf91820b53a9d094e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association creates a many-to-many relationship with another model. In database terms, this associates two classes via an intermediate join table that includes foreign keys referring to each of the classes.</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 의 연관은 다른 모델 대다 관계를 생성한다. 데이터베이스 용어로 이것은 각 클래스를 참조하는 외래 키를 포함하는 중간 조인 테이블을 통해 두 클래스를 연결합니다.</target>
        </trans-unit>
        <trans-unit id="cffbff7161adc30713ca9ac8aa68e31364d2c6ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association supports these options:</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 의 협회는이 옵션을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="4c339ffc43e59d5b7bac471326071768bad11a0a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many :through&lt;/code&gt; Association</source>
          <target state="translated">&lt;code&gt;has_many :through&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="0320dc713b5b5162baacb06b3460aea3196f3d92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many :through&lt;/code&gt; association is also useful for setting up &quot;shortcuts&quot; through nested &lt;code&gt;has_many&lt;/code&gt; associations. For example, if a document has many sections, and a section has many paragraphs, you may sometimes want to get a simple collection of all paragraphs in the document. You could set that up this way:</source>
          <target state="translated">&lt;code&gt;has_many :through&lt;/code&gt; 협회는 중첩을 통해 &quot;바로 가기&quot;를 설정하는 데 유용 &lt;code&gt;has_many&lt;/code&gt; 의 협회. 예를 들어, 문서에 섹션이 많고 섹션에 단락이 많은 경우 문서의 모든 단락을 간단하게 수집 할 수 있습니다. 이런 식으로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91762b98054d56233edda898e227d94549207b8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many&lt;/code&gt; Association</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="f5f8222264d2a934b6a2f0314860a01f8c5dd183" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many&lt;/code&gt; association creates a one-to-many relationship with another model. In database terms, this association says that the other class will have a foreign key that refers to instances of this class.</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 의 연관은 다른 모델에 일대 다 관계를 생성한다. 데이터베이스 용어로이 연관은 다른 클래스에이 클래스의 인스턴스를 참조하는 외래 키가있을 것이라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="cd4c76225002c233fb6f5aaa5ed1cb5cb57aa2e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many&lt;/code&gt; association supports these options:</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 의 협회는이 옵션을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="988b6859618033e3bb9a1f92e122ae95323801aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_many_attached&lt;/code&gt; macro sets up a one-to-many relationship between records and files. Each record can have many files attached to it.</source>
          <target state="translated">&lt;code&gt;has_many_attached&lt;/code&gt; 기록과 파일 간의 일대 다 관계 매크로 설정합니다. 각 레코드에는 많은 파일이 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd6ec3cb173d0126311c08fe199fe6a9dfaad806" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_one :through&lt;/code&gt; Association</source>
          <target state="translated">&lt;code&gt;has_one :through&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="17ffb0a0d0319348df4ab2443529d1f4904e218e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_one&lt;/code&gt; Association</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 협회</target>
        </trans-unit>
        <trans-unit id="747dba40bbb7c673870bd76088956d8cb5402a92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_one&lt;/code&gt; association creates a one-to-one match with another model. In database terms, this association says that the other class contains the foreign key. If this class contains the foreign key, then you should use &lt;code&gt;belongs_to&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 의 관계는 다른 모델과 일대일 대응을 만듭니다. 데이터베이스 용어로이 연관은 다른 클래스에 외래 키가 포함되어 있다고 말합니다. 이 클래스에 외래 키가 포함되어 있으면 &lt;code&gt;belongs_to&lt;/code&gt; 를 대신 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c993fa09f4ebc59995e28ea1df0b80627218145e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_one&lt;/code&gt; association supports these options:</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 의 협회는이 옵션을 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="97b25b608327cbb38067515dd761a2bb2b7b5c97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has_one_attached&lt;/code&gt; macro sets up a one-to-one mapping between records and files. Each record can have one file attached to it.</source>
          <target state="translated">&lt;code&gt;has_one_attached&lt;/code&gt; 기록과 파일 사이의 일대일 매핑 매크로 설정합니다. 각 레코드에는 하나의 파일이 첨부 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16c2a4f91819f8b86c509d7a07ac7d73161aa050" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;head&lt;/code&gt; method can be used to send responses with only headers to the browser. The &lt;code&gt;head&lt;/code&gt; method accepts a number or symbol (see &lt;a href=&quot;#the-status-option&quot;&gt;reference table&lt;/a&gt;) representing an HTTP status code. The options argument is interpreted as a hash of header names and values. For example, you can return only an error header:</source>
          <target state="translated">&lt;code&gt;head&lt;/code&gt; 방법은 브라우저 만 헤더와 응답을 보내는 데 사용할 수 있습니다. &lt;code&gt;head&lt;/code&gt; 있어서 숫자 또는 기호 (참조 허용 &lt;a href=&quot;#the-status-option&quot;&gt;기준 테이블&lt;/a&gt; HTTP 상태 코드를 나타내는). 옵션 인수는 헤더 이름과 값의 해시로 해석됩니다. 예를 들어 오류 헤더 만 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8293b26d129f95bbddddfcb98829fe4fda5149e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;helper&lt;/code&gt; class method can take a series of helper module names, a block, or both.</source>
          <target state="translated">&lt;code&gt;helper&lt;/code&gt; 클래스 메소드는 도우미 모듈 이름, 블록, 또는이 둘의 시리즈를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21d9b5aa0da0f73ed93d8f9453e61e0eeb514e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;helpers&lt;/code&gt;, &lt;code&gt;mailers&lt;/code&gt;, and &lt;code&gt;models&lt;/code&gt; directories are meant to hold tests for view helpers, mailers, and models, respectively. The &lt;code&gt;channels&lt;/code&gt; directory is meant to hold tests for Action Cable connection and channels. The &lt;code&gt;controllers&lt;/code&gt; directory is meant to hold tests for controllers, routes, and views. The &lt;code&gt;integration&lt;/code&gt; directory is meant to hold tests for interactions between controllers.</source>
          <target state="translated">&lt;code&gt;helpers&lt;/code&gt; , &lt;code&gt;mailers&lt;/code&gt; 및 &lt;code&gt;models&lt;/code&gt; 디렉토리는 각각보기 도우미, 우편물 및 모델에 대한 테스트를 유지하기위한 것입니다. &lt;code&gt;channels&lt;/code&gt; 디렉토리는 동작 케이블 연결 및 채널 홀드 시험을 의미한다. &lt;code&gt;controllers&lt;/code&gt; 디렉토리는 컨트롤러, 경로 및 뷰 보류 테스트하기위한 것입니다. &lt;code&gt;integration&lt;/code&gt; 디렉토리는 컨트롤러 사이의 상호 작용에 대한 보류 테스트하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="16e1462ad66cf4f6068f520debadf44e4c54fe3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;image_tag&lt;/code&gt; helper builds an HTML &lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt; tag to the specified file. By default, files are loaded from &lt;code&gt;public/images&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;image_tag&lt;/code&gt; 도우미는 HTML 기반으로 &lt;code&gt;&amp;lt;img /&amp;gt;&lt;/code&gt; 지정된 파일에 태그를. 기본적으로 파일은 &lt;code&gt;public/images&lt;/code&gt; 에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="925aed193e567156d3b8bff8e407b7d17dcd02c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inclusion&lt;/code&gt; helper has an option &lt;code&gt;:in&lt;/code&gt; that receives the set of values that will be accepted. The &lt;code&gt;:in&lt;/code&gt; option has an alias called &lt;code&gt;:within&lt;/code&gt; that you can use for the same purpose, if you'd like to. The previous example uses the &lt;code&gt;:message&lt;/code&gt; option to show how you can include the attribute's value. For full options please see the &lt;a href=&quot;#message&quot;&gt;message documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;inclusion&lt;/code&gt; 도우미는 옵션이 있습니다 &lt;code&gt;:in&lt;/code&gt; 그 허용됩니다 값 세트를받습니다. 는 &lt;code&gt;:in&lt;/code&gt; 옵션라는 별칭이 &lt;code&gt;:within&lt;/code&gt; 당신이 원하는 경우, 같은 목적으로 사용할 수 있습니다. 이전 예제에서는 &lt;code&gt;:message&lt;/code&gt; 옵션을 사용 하여 속성 값을 포함하는 방법을 보여줍니다. 전체 옵션에 대해서는 &lt;a href=&quot;#message&quot;&gt;메시지 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d77d8e7832ddfe4407eeae4a6fbbf808f4ad4747" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;indent!&lt;/code&gt; method performs indentation in-place.</source>
          <target state="translated">&lt;code&gt;indent!&lt;/code&gt; 메소드는 들여 쓰기를 제자리에서 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b5f94b3d78b6eb65988b0f525e0dd3017e47aeff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;info&lt;/code&gt; hash is optional, and if given is used to define metadata about the current schema (currently, only the schema's version):</source>
          <target state="translated">&lt;code&gt;info&lt;/code&gt; 해시는 선택 사항이며, 주어진 경우 현재 스키마 (현재는 스키마의 버전)에 대한 메타 데이터를 정의하는 데 사용됩니다 :</target>
        </trans-unit>
        <trans-unit id="d6043a5ac1dd3bda69ff91de1e86b4cbd79537d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialize!&lt;/code&gt; method looks like this:</source>
          <target state="translated">&lt;code&gt;initialize!&lt;/code&gt; 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e815e929a8a1b21e10c40e9bae542b99fe343fcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialize&lt;/code&gt; method in &lt;code&gt;Rack::Server&lt;/code&gt; simply sets a couple of variables:</source>
          <target state="translated">&lt;code&gt;Rack::Server&lt;/code&gt; 의 &lt;code&gt;initialize&lt;/code&gt; 메소드는 단순히 몇 가지 변수를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8d933a4dec33afb4edf7cb6141c5ca44070aed0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initialize&lt;/code&gt; method of &lt;code&gt;Rack::Builder&lt;/code&gt; will take the block here and execute it within an instance of &lt;code&gt;Rack::Builder&lt;/code&gt;. This is where the majority of the initialization process of Rails happens. The &lt;code&gt;require&lt;/code&gt; line for &lt;code&gt;config/environment.rb&lt;/code&gt; in &lt;code&gt;config.ru&lt;/code&gt; is the first to run:</source>
          <target state="translated">&lt;code&gt;Rack::Builder&lt;/code&gt; 의 &lt;code&gt;initialize&lt;/code&gt; 메소드는 여기서 블록을 가져와 &lt;code&gt;Rack::Builder&lt;/code&gt; 인스턴스 내에서 실행합니다 . Rails의 초기화 과정이 대부분 발생합니다. (가) &lt;code&gt;require&lt;/code&gt; 에 라인을 &lt;code&gt;config/environment.rb&lt;/code&gt; 있는 &lt;code&gt;config.ru&lt;/code&gt; 실행 처음이다 :</target>
        </trans-unit>
        <trans-unit id="eb8cf7bc7fde4ca0f2119f95fa23bd1458b04a97" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;initializer&lt;/code&gt; method takes three arguments with the first being the name for the initializer and the second being an options hash (not shown here) and the third being a block. The &lt;code&gt;:before&lt;/code&gt; key in the options hash can be specified to specify which initializer this new initializer must run before, and the &lt;code&gt;:after&lt;/code&gt; key will specify which initializer to run this initializer &lt;em&gt;after&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;initializer&lt;/code&gt; 방법은, 먼저 초기화에 대한 이름 인 두 번째 옵션은 해시 (여기되지 않음)과 블록 인 인 세 번째 인자 걸린다. 옵션 해시 의 &lt;code&gt;:before&lt;/code&gt; 키는이 새 이니셜 라이저가 이전에 실행해야하는 이니셜 라이저를 지정하기 위해 지정 될 수 있으며 &lt;code&gt;:after&lt;/code&gt; 키는이 이니셜 라이저를 &lt;em&gt;이후&lt;/em&gt; 에 실행할 이니셜 라이저를 지정 합니다.</target>
        </trans-unit>
        <trans-unit id="0cbb628221c6b56bd4cc12f278d4d7ec1fad447e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;inquiry&lt;/code&gt; method converts a string into a &lt;code&gt;StringInquirer&lt;/code&gt; object making equality checks prettier.</source>
          <target state="translated">&lt;code&gt;inquiry&lt;/code&gt; 방법은로 문자열을 변환 &lt;code&gt;StringInquirer&lt;/code&gt; 의 평등 검사가 예뻐 만드는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="4368356824c1f90a719a11b26d9d2b80cca5b47a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ip_spoofing_check&lt;/code&gt; option is on by default. When on, an exception is raised if it looks like the client is trying to lie about its own IP address. It makes sense to turn off this check on sites aimed at non-IP clients (like WAP devices), or behind proxies that set headers in an incorrect or confusing way (like AWS ELB).</source>
          <target state="translated">&lt;code&gt;ip_spoofing_check&lt;/code&gt; 의 옵션은 기본적으로 켜져 있습니다. 설정하면 클라이언트가 자신의 IP 주소에 대해 거짓말을하는 것처럼 보이는 경우 예외가 발생합니다. IP 클라이언트가 아닌 클라이언트 (WAP 디바이스 등)를 대상으로하거나 AWS ELB와 같이 부정확하거나 혼동되는 방식으로 헤더를 설정 한 프록시 뒤에있는 사이트에서는이 확인을 해제하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b09401c9b414a2395b8d42f97438cccb9d785a4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isolate_namespace&lt;/code&gt; method here deserves special notice. This call is responsible for isolating the controllers, models, routes, and other things into their own namespace, away from similar components inside the application. Without this, there is a possibility that the engine's components could &quot;leak&quot; into the application, causing unwanted disruption, or that important engine components could be overridden by similarly named things within the application. One of the examples of such conflicts is helpers. Without calling &lt;code&gt;isolate_namespace&lt;/code&gt;, the engine's helpers would be included in an application's controllers.</source>
          <target state="translated">여기서 &lt;code&gt;isolate_namespace&lt;/code&gt; 메소드는 특별한주의를 기울여야 합니다. 이 호출은 컨트롤러, 모델, 라우트 및 기타 사항을 응용 프로그램 내부의 유사한 구성 요소와 별도로 고유 네임 스페이스로 격리합니다. 이것이 없으면 엔진 구성 요소가 응용 프로그램에 &quot;누설&quot;되어 원치 않는 중단이 발생하거나 응용 프로그램 내에서 비슷한 이름의 항목으로 인해 중요한 엔진 구성 요소가 재정의 될 수 있습니다. 그러한 갈등의 예 중 하나는 조력자입니다. &lt;code&gt;isolate_namespace&lt;/code&gt; 를 호출하지 않으면 엔진의 헬퍼가 애플리케이션의 컨트롤러에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="210734494bd9582718be117c54236d0ce2f71684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;javascript_include_tag&lt;/code&gt; helper returns an HTML &lt;code&gt;script&lt;/code&gt; tag for each source provided.</source>
          <target state="translated">&lt;code&gt;javascript_include_tag&lt;/code&gt; 의 도우미는 HTML 반환 &lt;code&gt;script&lt;/code&gt; 제공 각 소스에 대한 태그를.</target>
        </trans-unit>
        <trans-unit id="395b2f4e52dd2af3fff86366e9d256770074e3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;key&lt;/code&gt; argument can also respond to &lt;code&gt;cache_key&lt;/code&gt; or &lt;code&gt;to_param&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 인수도에 응답 할 수 있습니다 &lt;code&gt;cache_key&lt;/code&gt; 또는 &lt;code&gt;to_param&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d196e27638d0ab8144821979efc4319dd575947" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last!&lt;/code&gt; method behaves exactly like &lt;code&gt;last&lt;/code&gt;, except that it will raise &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; if no matching record is found.</source>
          <target state="translated">&lt;code&gt;last!&lt;/code&gt; 이 메서드 는 일치하는 레코드가 없으면 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 발생 시킨다는 점을 제외하고는 정확히 &lt;code&gt;last&lt;/code&gt; 처럼 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="e4f7263f68aef61de417c358848e682be43e5c06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; method finds the last record ordered by primary key (default). For example:</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 방법은 기본 키 (기본값)으로 정렬 마지막 레코드를 찾습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64d5bd344522049e769fc7e252235d647288a734" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; method returns &lt;code&gt;nil&lt;/code&gt; if no matching record is found and no exception will be raised.</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 메소드가 반환 &lt;code&gt;nil&lt;/code&gt; 을 일치하는 기록이 발견되지 않고, 예외가 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a629205deccecaae41339c758aaf5cab1094b60f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limit&lt;/code&gt; may be anything that can evaluate to a string via to_s. It should look like an integer, or an Arel SQL literal.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 그리고 to_s를 통해 문자열로 평가할 수있는 일이 될 수 있습니다. 정수 또는 Arel SQL 리터럴과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="6863f1f9bdb068d9211a342efe3ace4921baf955" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;limit&lt;/code&gt; method lets you restrict the total number of objects that will be fetched through an association.</source>
          <target state="translated">&lt;code&gt;limit&lt;/code&gt; 방법은 당신이 협회를 통해 인출 될 것입니다 개체의 총 수를 제한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93dafc5d57f7c4f2df3b95398b538516ed45fdb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;link_to&lt;/code&gt; method is one of Rails' built-in view helpers. It creates a hyperlink based on text to display and where to go - in this case, to the path for articles.</source>
          <target state="translated">&lt;code&gt;link_to&lt;/code&gt; 방법은 레일 '내장에서보기 도우미 중 하나입니다. 표시 할 텍스트와 이동 위치 (이 경우 기사 경로)를 기반으로 하이퍼 링크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d2ef0bb7823f7404afca03b304638d73f26532cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method, if not passed a block, will inspect your views and send all the views with the same name as the method, so the above action would send the &lt;code&gt;welcome.text.erb&lt;/code&gt; view file as well as the &lt;code&gt;welcome.html.erb&lt;/code&gt; view file in a &lt;code&gt;multipart/alternative&lt;/code&gt; email.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 블록을 통과하지 않으면 위의 작업이 보낼 것입니다, 그래서 방법은, 귀하의 의견을 검사하고 메소드와 같은 이름을 가진 모든 의견을 보내드립니다 &lt;code&gt;welcome.text.erb&lt;/code&gt; 뿐만 아니라보기 파일을 &lt;code&gt;welcome.html.erb&lt;/code&gt; &lt;code&gt;multipart/alternative&lt;/code&gt; 이메일로 파일을 봅니다 .</target>
        </trans-unit>
        <trans-unit id="64bef344d8bafd389738a69f91f6d48578dbc8d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;marshal_dump&lt;/code&gt; and &lt;code&gt;_dump&lt;/code&gt; methods are exempt from delegation due to possible interference when calling &lt;code&gt;Marshal.dump(object)&lt;/code&gt;, should the delegation target method of &lt;code&gt;object&lt;/code&gt; add or remove instance variables.</source>
          <target state="translated">&lt;code&gt;marshal_dump&lt;/code&gt; 및 &lt;code&gt;_dump&lt;/code&gt; 호출 할 때 위임 방법에서 간섭을 일으킬 수 있으므로 면제 &lt;code&gt;Marshal.dump(object)&lt;/code&gt; ,해야 위임 대상있어서 &lt;code&gt;object&lt;/code&gt; 추가 또는 삭제 인스턴스 변수.</target>
        </trans-unit>
        <trans-unit id="2dda7e6e1d7a859abcdcd7093c062fa329eb30a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mass_assignment_sanitizer&lt;/code&gt; configuration setting should also be added to &lt;code&gt;config/environments/test.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mass_assignment_sanitizer&lt;/code&gt; 의 구성 설정도 추가해야합니다 &lt;code&gt;config/environments/test.rb&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1d2229bad9d20be4d5c14231e078e5bed654f193" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;message&lt;/code&gt; parameter allows you to pass in an error message that is displayed upon failure.</source>
          <target state="translated">&lt;code&gt;message&lt;/code&gt; 매개 변수는 실패에 표시되는 오류 메시지를 전달 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4692d88e80909e2abfa7e56cbda2dce78df9f4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_parent&lt;/code&gt; method on a nested named module returns the module that contains its corresponding constant:</source>
          <target state="translated">중첩 된 명명 된 모듈 의 &lt;code&gt;module_parent&lt;/code&gt; 메소드는 해당 상수를 포함하는 모듈을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="b955e08bb61f3588b54c4779732b1848ec4f0c42" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module_parent_name&lt;/code&gt; method on a nested named module returns the fully qualified name of the module that contains its corresponding constant:</source>
          <target state="translated">중첩 된 명명 된 모듈 의 &lt;code&gt;module_parent_name&lt;/code&gt; 메소드는 해당 상수를 포함하는 모듈의 완전한 이름을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e110b06f1da8ca5b78b8c4e2e0e1c08716055da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;namespace&lt;/code&gt; scope will automatically add &lt;code&gt;:as&lt;/code&gt; as well as &lt;code&gt;:module&lt;/code&gt; and &lt;code&gt;:path&lt;/code&gt; prefixes.</source>
          <target state="translated">&lt;code&gt;namespace&lt;/code&gt; 범위가 자동으로 추가됩니다 &lt;code&gt;:as&lt;/code&gt; 뿐만 아니라 &lt;code&gt;:module&lt;/code&gt; 과 &lt;code&gt;:path&lt;/code&gt; 접두사를.</target>
        </trans-unit>
        <trans-unit id="ca791e115afb12d1675478a6b277d337d19197b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; action is now creating a new instance variable called &lt;code&gt;@article&lt;/code&gt;, and you'll see why that is in just a few moments.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 조치는 지금이라는 새로운 인스턴스 변수 만드는 &lt;code&gt;@article&lt;/code&gt; 을 , 그리고 그 몇 순간에 당신은 왜 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dbe1c959706ba4c12410c4ae5ad42676358e85f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;none&lt;/code&gt; method returns a chainable relation with no records. Any subsequent conditions chained to the returned relation will continue generating empty relations. This is useful in scenarios where you need a chainable response to a method or a scope that could return zero results.</source>
          <target state="translated">&lt;code&gt;none&lt;/code&gt; 메서드는 기록이있는 체인 방식의 관계를 반환합니다. 리턴 된 관계에 연결된 모든 후속 조건은 계속 빈 관계를 생성합니다. 이는 0 개의 결과를 반환 할 수있는 메서드 또는 범위에 대한 연결 가능한 응답이 필요한 시나리오에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8aef3a8817f4235a86b882fb368e88d769094dc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;number_to_currency&lt;/code&gt;, &lt;code&gt;number_with_precision&lt;/code&gt;, &lt;code&gt;number_to_percentage&lt;/code&gt;, &lt;code&gt;number_with_delimiter&lt;/code&gt;, and &lt;code&gt;number_to_human_size&lt;/code&gt; helpers use the number format settings located in the &lt;a href=&quot;https://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml#L37&quot;&gt;number&lt;/a&gt; scope.</source>
          <target state="translated">&lt;code&gt;number_to_currency&lt;/code&gt; , &lt;code&gt;number_with_precision&lt;/code&gt; , &lt;code&gt;number_to_percentage&lt;/code&gt; , &lt;code&gt;number_with_delimiter&lt;/code&gt; 및 &lt;code&gt;number_to_human_size&lt;/code&gt; 의 도우미가에있는 숫자 형식 설정을 사용하는 &lt;a href=&quot;https://github.com/rails/rails/blob/master/activesupport/lib/active_support/locale/en.yml#L37&quot;&gt;번호&lt;/a&gt; 범위를.</target>
        </trans-unit>
        <trans-unit id="eb2caecbac1e3a41d5817cf394dd84287443eb03" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;object&lt;/code&gt; option can be used to directly specify which object is rendered into the partial; useful when the template's object is elsewhere (e.g. in a different instance variable or in a local variable).</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 옵션은 직접 부분적으로 렌더링되는 오브젝트를 지정하는데 사용될 수있다; 템플릿의 객체가 다른 곳에있을 때 유용합니다 (예 : 다른 인스턴스 변수 또는 로컬 변수).</target>
        </trans-unit>
        <trans-unit id="15dc0abfaa617e737b51863f4174d38cbd829c38" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; method lets you specify the starting offset for fetching objects via an association. For example, &lt;code&gt;-&amp;gt; { offset(11) }&lt;/code&gt; will skip the first 11 records.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 방법은 협회를 통해 객체를 가져 오는에 대한 개시 오프셋 (offset)를 지정할 수 있습니다. 예를 들어, &lt;code&gt;-&amp;gt; { offset(11) }&lt;/code&gt; 은 처음 11 개의 레코드를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="77c1c66e8d05e9af003c64e1262319407e478374" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;offset&lt;/code&gt; method lets you specify the starting offset for fetching objects via an association. For example, if you set &lt;code&gt;offset(11)&lt;/code&gt;, it will skip the first 11 records.</source>
          <target state="translated">&lt;code&gt;offset&lt;/code&gt; 방법은 협회를 통해 객체를 가져 오는에 대한 개시 오프셋 (offset)를 지정할 수 있습니다. 예를 들어, &lt;code&gt;offset(11)&lt;/code&gt; 을 설정 하면 처음 11 개 레코드를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="82334672065635b4f19c688accdc8a95575615a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash accepts the same keys as &lt;a href=&quot;schemastatements#method-i-add_foreign_key&quot;&gt;#add_foreign_key&lt;/a&gt; with an addition of</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시는 같은 키를 받아 &lt;a href=&quot;schemastatements#method-i-add_foreign_key&quot;&gt;#add_foreign_key을&lt;/a&gt; 의 추가와 함께</target>
        </trans-unit>
        <trans-unit id="77f26f90bfe39c40f22dd7d79c62cd21ab2dd6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash accepts the same keys as SchemaStatements#add_foreign_key.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시 SchemaStatements 번호의 add_foreign_key과 같은 키를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="233878fefa4f6993f4e6f5ec1818e5bb0379fab5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash accepts the same options as &lt;code&gt;url_for&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시와 같은 옵션을 받아 &lt;code&gt;url_for&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="1bef9f9982c6deff18008de93564cb624e7ea8c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash can be used with attributes with no value like (&lt;code&gt;disabled&lt;/code&gt; and &lt;code&gt;readonly&lt;/code&gt;), which you can give a value of true in the &lt;code&gt;options&lt;/code&gt; hash. You can use symbols or strings for the attribute names.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시 (같은 값없이 속성을 사용할 수 있습니다 &lt;code&gt;disabled&lt;/code&gt; 및 &lt;code&gt;readonly&lt;/code&gt; 당신이에 true 값을 제공 할 수 있습니다), &lt;code&gt;options&lt;/code&gt; 해시. 속성 이름에 기호 또는 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f258ac1e3cd63f1069683f25d07a803b0e381bdf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash can include the following keys:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시는 다음 키를 포함 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="88b2044b2765a19a12f430e88806032c881746a3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; hash is passed downwards:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 해시 통과 아래입니다 :</target>
        </trans-unit>
        <trans-unit id="52b8a463e8a7b937f0e298a783a9634891e4d51e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options&lt;/code&gt; parameter takes a hash with any of these keys: &lt;code&gt;:years&lt;/code&gt;, &lt;code&gt;:months&lt;/code&gt;, &lt;code&gt;:weeks&lt;/code&gt;, &lt;code&gt;:days&lt;/code&gt;, &lt;code&gt;:hours&lt;/code&gt;, &lt;code&gt;:minutes&lt;/code&gt;, &lt;code&gt;:seconds&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 이 키 중 하나와 해시를 취 매개 변수 : &lt;code&gt;:years&lt;/code&gt; , &lt;code&gt;:months&lt;/code&gt; , &lt;code&gt;:weeks&lt;/code&gt; , &lt;code&gt;:days&lt;/code&gt; , &lt;code&gt;:hours&lt;/code&gt; , &lt;code&gt;:minutes&lt;/code&gt; , &lt;code&gt;:seconds&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5159943b41f8754e74b0dcfeee4e2c01bede8a26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;options[:config]&lt;/code&gt; value defaults to &lt;code&gt;config.ru&lt;/code&gt; which contains this:</source>
          <target state="translated">&lt;code&gt;options[:config]&lt;/code&gt; 에 대한 디폴트 값은 &lt;code&gt;config.ru&lt;/code&gt; 이 포함되어 있습니다 :</target>
        </trans-unit>
        <trans-unit id="81355a8a084d3ec1d4336bde462d2bfcb0e6803f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; method dictates the order in which associated objects will be received (in the syntax used by an SQL &lt;code&gt;ORDER BY&lt;/code&gt; clause).</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 방법 지시 (AN SQL에서 사용되는 구문에 관련 오브젝트가 수신되는 순서 &lt;code&gt;ORDER BY&lt;/code&gt; 의 절).</target>
        </trans-unit>
        <trans-unit id="0f58260847673fd06f904238242c4986e4cabccb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parallelize_setup&lt;/code&gt; method is called right after the processes are forked. The &lt;code&gt;parallelize_teardown&lt;/code&gt; method is called right before the processes are closed.</source>
          <target state="translated">&lt;code&gt;parallelize_setup&lt;/code&gt; 의 프로세스가 포크 후 방법은 바로 호출된다. &lt;code&gt;parallelize_teardown&lt;/code&gt; 의 프로세스가 종료되기 전에 방법은 바로 호출된다.</target>
        </trans-unit>
        <trans-unit id="99d07f59c39ca0960a8e1e3fd108379947f6f596" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; hash is not limited to one-dimensional keys and values. It can contain nested arrays and hashes. To send an array of values, append an empty pair of square brackets &quot;[]&quot; to the key name:</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 해시 일차원 키와 값에 한정되지 않는다. 중첩 배열과 해시를 포함 할 수 있습니다. 값의 배열을 보내려면 키 쌍에 빈 대괄호 &quot;[]&quot;쌍을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dc658a3f446cb8a8a972e259ffe7e8b1d0c86ff0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; hash will always contain the &lt;code&gt;:controller&lt;/code&gt; and &lt;code&gt;:action&lt;/code&gt; keys, but you should use the methods &lt;code&gt;controller_name&lt;/code&gt; and &lt;code&gt;action_name&lt;/code&gt; instead to access these values. Any other parameters defined by the routing, such as &lt;code&gt;:id&lt;/code&gt;, will also be available. As an example, consider a listing of clients where the list can show either active or inactive clients. We can add a route which captures the &lt;code&gt;:status&lt;/code&gt; parameter in a &quot;pretty&quot; URL:</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 해시는 항상 포함됩니다 &lt;code&gt;:controller&lt;/code&gt; 및 &lt;code&gt;:action&lt;/code&gt; 키를,하지만 당신은 방법을 사용해야합니다 &lt;code&gt;controller_name&lt;/code&gt; 과 &lt;code&gt;action_name&lt;/code&gt; 액세스 대신이 값을. 라우팅에 의해 정의 된 다른 매개 변수 (예 &lt;code&gt;:id&lt;/code&gt; )도 사용할 수 있습니다. 예를 들어, 목록이 활성 또는 비활성 클라이언트를 표시 할 수있는 클라이언트 목록을 고려하십시오. &quot;pretty&quot;URL에서 &lt;code&gt;:status&lt;/code&gt; 매개 변수 를 캡처하는 경로를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ebe6591f871aeb257c13a5ccdbc3912607f65b19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; object acts like a Hash, but lets you use symbols and strings interchangeably as keys.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 객체는 해시 같은 역할을하지만 키로 상호 교환 기호와 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ffa62b0f52258df4b98f9c2d2c5c49d327c41e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;params&lt;/code&gt; will also include any parameters from the query string. For example, with this route:</source>
          <target state="translated">이 &lt;code&gt;params&lt;/code&gt; 변수에는 쿼리 문자열의 매개 변수도 포함됩니다. 예를 들어이 경로를 사용하면</target>
        </trans-unit>
        <trans-unit id="460759985e7c91f3604cb13e28098a536fedbec9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prefix&lt;/code&gt; change makes Sprockets use a different URL for serving assets in development mode, and pass all requests to Sprockets. The prefix is still set to &lt;code&gt;/assets&lt;/code&gt; in the production environment. Without this change, the application would serve the precompiled assets from &lt;code&gt;/assets&lt;/code&gt; in development, and you would not see any local changes until you compile assets again.</source>
          <target state="translated">&lt;code&gt;prefix&lt;/code&gt; 변화는 톱니가 개발 모드에 자산을 제공하기위한 다른 URL을 사용하고, 톱니에 대한 모든 요청을 전달합니다. 프로덕션 환경에서는 접두사가 여전히 &lt;code&gt;/assets&lt;/code&gt; 로 설정되어 있습니다. 이 변경 사항이 없으면 응용 프로그램은 개발중인 &lt;code&gt;/assets&lt;/code&gt; 에서 사전 컴파일 된 자산을 제공하므로 자산을 다시 컴파일 할 때까지 로컬 변경 사항이 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d191a69b7f80bba0c53acf74330c66d5f3045a7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;presence&lt;/code&gt; method returns its receiver if &lt;code&gt;present?&lt;/code&gt;, and &lt;code&gt;nil&lt;/code&gt; otherwise. It is useful for idioms like this:</source>
          <target state="translated">&lt;code&gt;presence&lt;/code&gt; 방법은 수신기의 경우 반환 &lt;code&gt;present?&lt;/code&gt; 그리고는 &lt;code&gt;nil&lt;/code&gt; , 그렇지. 다음과 같은 관용구에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="30aac7526a4d04e818ddc2edd7f3e6feeabd5821" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;production&lt;/code&gt; environment is used when you deploy your application for the world to use.</source>
          <target state="translated">&lt;code&gt;production&lt;/code&gt; 이 사용하는 세계에 대한 응용 프로그램을 배포 할 때 환경이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2604ea7c0d6684b35fc204cfb671e038ba1657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;protected_attributes&lt;/code&gt; gem is no longer supported in Rails 5.</source>
          <target state="translated">&lt;code&gt;protected_attributes&lt;/code&gt; 의 보석은 더 이상 레일 (5)에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a8019779e958edd656a6bbbb8f4e51c5112725eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails db:migrate&lt;/code&gt; command needs to be run here to ensure that our application has the &lt;code&gt;users&lt;/code&gt; table for future use.</source>
          <target state="translated">&lt;code&gt;rails db:migrate&lt;/code&gt; 명령은 우리의 응용 프로그램이 있는지 확인하려면 여기를 실행해야하는 &lt;code&gt;users&lt;/code&gt; 향후 사용을 위해 테이블을.</target>
        </trans-unit>
        <trans-unit id="5d810de5c7cf4f0510f5cb85c0a4fc14508e6078" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails db:reset&lt;/code&gt; command will drop the database and set it up again. This is functionally equivalent to &lt;code&gt;rails db:drop db:setup&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rails db:reset&lt;/code&gt; 명령은 데이터베이스를 삭제하고 다시 설정합니다. 이것은 기능적으로 &lt;code&gt;rails db:drop db:setup&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a745961032af95b5ffc9718dee6cf39a9435fe19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails db:setup&lt;/code&gt; command will create the database, load the schema, and initialize it with the seed data.</source>
          <target state="translated">&lt;code&gt;rails db:setup&lt;/code&gt; 명령이 스키마를 데이터베이스를 생성로드 및 종자 데이터를 초기화합니다.</target>
        </trans-unit>
        <trans-unit id="f753b17b3a855c5b955535febb622c728d3a01a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails generate&lt;/code&gt; command uses templates to create a whole lot of things. Running &lt;code&gt;rails generate&lt;/code&gt; by itself gives a list of available generators:</source>
          <target state="translated">&lt;code&gt;rails generate&lt;/code&gt; 명령을 사용하는 템플릿 사물의 전체를 많이 만들 수 있습니다. 실행 &lt;code&gt;rails generate&lt;/code&gt; 가능한 발전기의 목록은 그 자체로 제공합니다</target>
        </trans-unit>
        <trans-unit id="e10bc93faabcae783aad93be82a9263c515fe6a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails server&lt;/code&gt; command launches a web server named Puma which comes bundled with Rails. You'll use this any time you want to access your application through a web browser.</source>
          <target state="translated">는 &lt;code&gt;rails server&lt;/code&gt; 명령 출시 레일과 함께 제공되는 푸마라는 이름의 웹 서버를. 웹 브라우저를 통해 응용 프로그램에 액세스하려는 경우 언제든지이 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="856e7d1a72bb43c8034a0eeba1725262865a59b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rails&lt;/code&gt; in the command &lt;code&gt;rails server&lt;/code&gt; is a ruby executable in your load path. This executable contains the following lines:</source>
          <target state="translated">&lt;code&gt;rails&lt;/code&gt; 명령에는 &lt;code&gt;rails server&lt;/code&gt; 부하 경로에서 루비 실행 파일입니다. 이 실행 파일에는 다음 줄이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73a8a72ff4008b41a69bd7ae69aa453d80578d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;raw&lt;/code&gt; helper calls &lt;code&gt;html_safe&lt;/code&gt; for you:</source>
          <target state="translated">&lt;code&gt;raw&lt;/code&gt; 도우미 호출 &lt;code&gt;html_safe&lt;/code&gt; 당신을 위해 :</target>
        </trans-unit>
        <trans-unit id="4ff579f13be9f5a047f32881693454aef1037470" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; helper can also cache individual templates rendered for a collection. It can even one up the previous example with &lt;code&gt;each&lt;/code&gt; by reading all cache templates at once instead of one by one. This is done by passing &lt;code&gt;cached: true&lt;/code&gt; when rendering the collection:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 도우미는 또한 컬렉션에 대한 렌더링 개별 템플릿을 캐시 할 수 있습니다. 모든 캐시 템플릿을 &lt;code&gt;each&lt;/code&gt; 읽지 않고 한 번에 하나씩 읽어서 이전 예제를 하나로 만들 수도 있습니다 . 컬렉션을 렌더링 할 때 &lt;code&gt;cached: true&lt;/code&gt; 를 전달 하면됩니다.</target>
        </trans-unit>
        <trans-unit id="165f3b8f711d92b6cd136faa486fafc9b24bb7c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method can do without a view completely, if you're willing to use the &lt;code&gt;:inline&lt;/code&gt; option to supply ERB as part of the method call. This is perfectly valid:</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 당신이 사용하고자하는 경우 방법은 완전히보기없이 할 수 &lt;code&gt;:inline&lt;/code&gt; 메서드 호출의 일부로 공급 ERB에 대한 옵션을 선택합니다. 이것은 완벽하게 유효합니다 :</target>
        </trans-unit>
        <trans-unit id="733a882de1c1e6400a9cfd13f2c40a35ce15c94c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;render&lt;/code&gt; method here is taking a very simple hash with a key of &lt;code&gt;:plain&lt;/code&gt; and value of &lt;code&gt;params[:article].inspect&lt;/code&gt;. The &lt;code&gt;params&lt;/code&gt; method is the object which represents the parameters (or fields) coming in from the form. The &lt;code&gt;params&lt;/code&gt; method returns an &lt;code&gt;ActionController::Parameters&lt;/code&gt; object, which allows you to access the keys of the hash using either strings or symbols. In this situation, the only parameters that matter are the ones from the form.</source>
          <target state="translated">여기서 &lt;code&gt;render&lt;/code&gt; 메소드는 &lt;code&gt;:plain&lt;/code&gt; 키 와 &lt;code&gt;params[:article].inspect&lt;/code&gt; 값으로 매우 간단한 해시를 사용합니다 . &lt;code&gt;params&lt;/code&gt; 있어서, 상기 파라미터들 (또는 필드)의 형태에서 들어오는 나타내는 오브젝트이다. &lt;code&gt;params&lt;/code&gt; 방법을 다시 표시 &lt;code&gt;ActionController::Parameters&lt;/code&gt; 는 문자열 또는 기호를 사용하여 해시의 키에 액세스 할 수 있도록 객체. 이 상황에서 중요한 매개 변수는 양식의 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="215859271da22edb5037c0e406abee5b2136db7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reorder&lt;/code&gt; method overrides the default scope order. For example:</source>
          <target state="translated">&lt;code&gt;reorder&lt;/code&gt; 방법은 기본 범위 순서를 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="82d41c6ec3db0472c61f038efb37182e6f5618fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; Object</source>
          <target state="translated">&lt;code&gt;request&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="4cde4b61de54df6c90bf6be6006a2191eeb28f5d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;require_tree&lt;/code&gt; directive tells Sprockets to recursively include &lt;em&gt;all&lt;/em&gt; JavaScript files in the specified directory into the output. These paths must be specified relative to the manifest file. You can also use the &lt;code&gt;require_directory&lt;/code&gt; directive which includes all JavaScript files only in the directory specified, without recursion.</source>
          <target state="translated">&lt;code&gt;require_tree&lt;/code&gt; 의 지시어는 반복적으로 포함에 톱니 알려줍니다 &lt;em&gt;모든&lt;/em&gt; 출력에 지정된 디렉토리에 자바 스크립트 파일을. 이러한 경로는 매니페스트 파일을 기준으로 지정해야합니다. 또한 재귀없이 지정된 디렉토리에서만 모든 JavaScript 파일을 포함 하는 &lt;code&gt;require_directory&lt;/code&gt; 지시문을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcb8dba4bd5390bf4a1e6a4ef6c8f64056e4c8a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reselect&lt;/code&gt; method overrides an existing select statement. For example:</source>
          <target state="translated">&lt;code&gt;reselect&lt;/code&gt; 방법은 기존 SELECT 문을 무시합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="511dd58b52c6e6960c4e97f83646beb31c3362f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; method allows customizing polymorphic mapping of models. For example:</source>
          <target state="translated">&lt;code&gt;resolve&lt;/code&gt; 방법은 모델의 다형성 매핑을 사용자 정의 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="719208d2b6dc747a9f7d5a078cd40cb087cd1d1f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;response&lt;/code&gt; Object</source>
          <target state="translated">&lt;code&gt;response&lt;/code&gt; 객체</target>
        </trans-unit>
        <trans-unit id="afd966c2717d53315097ee93b83209f36ff780fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reverse_order&lt;/code&gt; method reverses the ordering clause if specified.</source>
          <target state="translated">&lt;code&gt;reverse_order&lt;/code&gt; 지정한 경우 방법은 주문 절을 반전시킵니다.</target>
        </trans-unit>
        <trans-unit id="6178a7a6ac2036a9eff7c4ec9e4e239cdf56392b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revert&lt;/code&gt; method also accepts a block of instructions to reverse. This could be useful to revert selected parts of previous migrations. For example, let's imagine that &lt;code&gt;ExampleMigration&lt;/code&gt; is committed and it is later decided it would be best to use Active Record validations, in place of the &lt;code&gt;CHECK&lt;/code&gt; constraint, to verify the zipcode.</source>
          <target state="translated">&lt;code&gt;revert&lt;/code&gt; 방법은 리버스 명령들의 블록을 받아 들인다. 이전 마이그레이션에서 선택한 부분을 되 돌리는 데 유용 할 수 있습니다. 예를 들어 &lt;code&gt;ExampleMigration&lt;/code&gt; 이 커밋되고 나중에 &lt;code&gt;CHECK&lt;/code&gt; 제약 조건 대신 Active Record 유효성 검사 를 사용하여 우편 번호를 확인하는 것이 가장 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="974d37374d8c671ae8578960538e6a04b18e04d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;revert&lt;/code&gt; method can be helpful when writing a new migration to undo previous migrations in whole or in part (see &lt;a href=&quot;#reverting-previous-migrations&quot;&gt;Reverting Previous Migrations&lt;/a&gt; above).</source>
          <target state="translated">&lt;code&gt;revert&lt;/code&gt; 의 전부 또는 일부를 취소 이전 마이그레이션 (참조에 대한 새로운 마이그레이션을 작성할 때 방법은 도움이 될 수 있습니다 &lt;a href=&quot;#reverting-previous-migrations&quot;&gt;이전 마이그레이션 되돌리기&lt;/a&gt; 위).</target>
        </trans-unit>
        <trans-unit id="9d205c768adeae2ccae3ad6686e3cb7311fe2147" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rewhere&lt;/code&gt; method overrides an existing, named where condition. For example:</source>
          <target state="translated">&lt;code&gt;rewhere&lt;/code&gt; 의 방법은이 곳 조건이라는 기존보다 우선합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb49cc4771c30e552fbd32c7086499f40195d7a8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;root&lt;/code&gt; route only routes &lt;code&gt;GET&lt;/code&gt; requests to the action.</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 경로는 노선 &lt;code&gt;GET&lt;/code&gt; 작업 요청을.</target>
        </trans-unit>
        <trans-unit id="a6ed7f28279db3db360582e45431b41c1011f54e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run_initializers&lt;/code&gt; code itself is tricky. What Rails is doing here is traversing all the class ancestors looking for those that respond to an &lt;code&gt;initializers&lt;/code&gt; method. It then sorts the ancestors by name, and runs them. For example, the &lt;code&gt;Engine&lt;/code&gt; class will make all the engines available by providing an &lt;code&gt;initializers&lt;/code&gt; method on them.</source>
          <target state="translated">&lt;code&gt;run_initializers&lt;/code&gt; 의 코드 자체는 까다 롭습니다. Rails가 여기서하는 일은 &lt;code&gt;initializers&lt;/code&gt; 메소드에 응답하는 클래스를 찾는 모든 클래스 조상을 순회하는 것입니다 . 그런 다음 조상을 이름별로 정렬하고 실행합니다. 예를 들어 &lt;code&gt;Engine&lt;/code&gt; 클래스는 &lt;code&gt;initializers&lt;/code&gt; 메소드를 제공하여 모든 엔진을 사용할 수있게 합니다.</target>
        </trans-unit>
        <trans-unit id="029bbe250a2a951e17d3262b18bb5fb66ea4e28c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sass-rails&lt;/code&gt; gem is automatically used for CSS compression if included in the &lt;code&gt;Gemfile&lt;/code&gt; and no &lt;code&gt;config.assets.css_compressor&lt;/code&gt; option is set.</source>
          <target state="translated">&lt;code&gt;sass-rails&lt;/code&gt; 에 포함하면 보석이 자동으로 CSS 압축에 사용되는 &lt;code&gt;Gemfile&lt;/code&gt; 더 &lt;code&gt;config.assets.css_compressor&lt;/code&gt; 의 옵션이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d45c792f31fe05e604435719cd4e528a90aadad4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; method lets you override the SQL &lt;code&gt;SELECT&lt;/code&gt; clause that is used to retrieve data about the associated object. By default, Rails retrieves all columns.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 방법을 사용하면 SQL 재정의 할 수 &lt;code&gt;SELECT&lt;/code&gt; 의 관련 개체에 대한 데이터를 검색하는 데 사용되는 절을. 기본적으로 Rails는 모든 열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="470ede3c07878b0d5ce0cac029155fb229ceb42a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select&lt;/code&gt; method lets you override the SQL &lt;code&gt;SELECT&lt;/code&gt; clause that is used to retrieve data about the associated objects. By default, Rails retrieves all columns.</source>
          <target state="translated">&lt;code&gt;select&lt;/code&gt; 방법을 사용하면 SQL 재정의 할 수 &lt;code&gt;SELECT&lt;/code&gt; 의 관련 개체에 대한 데이터를 검색하는 데 사용되는 절을. 기본적으로 Rails는 모든 열을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="b01a0de3c555c240ce70e23c379248155e06194a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;select_*&lt;/code&gt; family of helpers take as their first argument an instance of &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, or &lt;code&gt;DateTime&lt;/code&gt; that is used as the currently selected value. You may omit this parameter, in which case the current date is used. For example:</source>
          <target state="translated">&lt;code&gt;select_*&lt;/code&gt; 헬퍼의 가족은 자신의 첫 번째 인수로의 인스턴스 걸릴 &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; , 또는 &lt;code&gt;DateTime&lt;/code&gt; 현재 선택된 값으로 사용됩니다. 이 매개 변수를 생략 할 수 있으며이 경우 현재 날짜가 사용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0aefbcedb30dbd6567f5253a1883f41b650dd429" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;selected&lt;/code&gt; parameter must be either &lt;code&gt;nil&lt;/code&gt;, or a string that names an &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport::TimeZone&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;selected&lt;/code&gt; 매개 변수이어야합니다 &lt;code&gt;nil&lt;/code&gt; , 또는 문자열 이름을한다는 &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport :: 시간대&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe848ea6858d33fcfc6cf7ec8404c22fe8dfbfa7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send_early_hints&lt;/code&gt; method accepts a hash of links as follows:</source>
          <target state="translated">&lt;code&gt;send_early_hints&lt;/code&gt; 의 메서드는 다음과 같이 링크의 해시를 허용합니다</target>
        </trans-unit>
        <trans-unit id="c9bcd16a96b262d3703aada51fe66fc8fe1da0c4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;set_author&lt;/code&gt; method in the &lt;code&gt;Blorgh::Article&lt;/code&gt; model should also use this class:</source>
          <target state="translated">&lt;code&gt;Blorgh::Article&lt;/code&gt; 모델 의 &lt;code&gt;set_author&lt;/code&gt; 메소드 도이 클래스를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9679ebab247813d491583d5018968660c55b1778" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;shallow&lt;/code&gt; method of the DSL creates a scope inside of which every nesting is shallow. This generates the same routes as the previous example:</source>
          <target state="translated">DSL 의 &lt;code&gt;shallow&lt;/code&gt; 방법은 모든 중첩이 얕은 범위를 만듭니다. 이전 예제와 동일한 경로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="9e78e6f176cdc03622a61cf9b3a5939510e015d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;size&lt;/code&gt; method returns the total number of error messages for the object.</source>
          <target state="translated">&lt;code&gt;size&lt;/code&gt; 방법은 개체에 대한 오류 메시지의 총 수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3f18ffe49ae279bf3e247c1494d4d00a3a47c779" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sql&lt;/code&gt; parameter is a full SQL query as a string. It will be called as is; there will be no database agnostic conversions performed. This should be a last resort because using database-specific terms will lock you into using that particular database engine, or require you to change your call if you switch engines.</source>
          <target state="translated">&lt;code&gt;sql&lt;/code&gt; 매개 변수는 문자열로 전체 SQL 쿼리입니다. 그대로 호출됩니다. 데이터베이스에 관계없이 변환이 수행되지 않습니다. 데이터베이스 별 용어를 사용하면 특정 데이터베이스 엔진을 사용할 수 없게되거나 엔진을 전환 할 경우 통화를 변경해야하므로 이는 최후의 수단입니다.</target>
        </trans-unit>
        <trans-unit id="23aaaa02a8a9386d5ad24467ff74665edeeaf0b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;stylesheet_link_tag&lt;/code&gt; helper returns an HTML &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; tag for each source provided.</source>
          <target state="translated">&lt;code&gt;stylesheet_link_tag&lt;/code&gt; 의 도우미는 HTML 반환 &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; 제공 각 소스에 대한 태그를.</target>
        </trans-unit>
        <trans-unit id="194dc076a7d69a7c21f87fdbade43b55cb03d20f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subclasses&lt;/code&gt; method returns the subclasses of the receiver:</source>
          <target state="translated">&lt;code&gt;subclasses&lt;/code&gt; 방법은 수신기의 서브 클래스를 반환</target>
        </trans-unit>
        <trans-unit id="f1fb13cdbd34f03a4ed8b6202e3d52f897527006" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;subscribe&lt;/code&gt; method returns a subscriber object:</source>
          <target state="translated">는 &lt;code&gt;subscribe&lt;/code&gt; 메서드가 반환을 가입자 개체를 :</target>
        </trans-unit>
        <trans-unit id="4813ab4f370a4419f11fbfacb67109254c7695b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;super&lt;/code&gt; method will call &lt;code&gt;Rack::Server.start&lt;/code&gt; which begins its definition like this:</source>
          <target state="translated">&lt;code&gt;super&lt;/code&gt; 방법은 호출 &lt;code&gt;Rack::Server.start&lt;/code&gt; 다음과 같이 정의를 시작합니다 :</target>
        </trans-unit>
        <trans-unit id="039af7b58f5bcb13ffe0355e617b6f338974c393" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;t.references&lt;/code&gt; line creates an integer column called &lt;code&gt;article_id&lt;/code&gt;, an index for it, and a foreign key constraint that points to the &lt;code&gt;id&lt;/code&gt; column of the &lt;code&gt;articles&lt;/code&gt; table. Go ahead and run the migration:</source>
          <target state="translated">&lt;code&gt;t.references&lt;/code&gt; 의 라인라는 정수 열 생성 &lt;code&gt;article_id&lt;/code&gt; 를 , 그것을 위해 인덱스 및 포인트가 외래 키 제약 &lt;code&gt;id&lt;/code&gt; 의 칼럼 &lt;code&gt;articles&lt;/code&gt; 테이블을. 계속해서 마이그레이션을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="552b36d59c2f885f1540170dd6ce5d223e1ad9f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take!&lt;/code&gt; method behaves exactly like &lt;code&gt;take&lt;/code&gt;, except that it will raise &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; if no matching record is found.</source>
          <target state="translated">&lt;code&gt;take!&lt;/code&gt; 이 메소드 는 일치하는 레코드가 없으면 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 발생 시킨다는 점을 제외하고 &lt;code&gt;take&lt;/code&gt; 와 정확히 동일하게 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3d867d8e76972eed1ca32771f86e357e8946bbff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method retrieves a record without any implicit ordering. For example:</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 메서드는 암시 적 순서없이 기록을 검색합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab23d40b84da426b638ca1624e56d7bbde28a7b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take&lt;/code&gt; method returns &lt;code&gt;nil&lt;/code&gt; if no record is found and no exception will be raised.</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 메소드가 반환 &lt;code&gt;nil&lt;/code&gt; 을 더 기록이 발견되지 않고, 예외가 발생되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83836a7d3a3d29f487e62b58a8e7d0c925e91944" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;take_screenshot&lt;/code&gt; helper method can be included anywhere in your tests to take a screenshot of the browser.</source>
          <target state="translated">&lt;code&gt;take_screenshot&lt;/code&gt; 의 도우미 메서드는 브라우저의 스크린 샷을 당신의 시험에서 어느 곳을 포함 할 수있다.</target>
        </trans-unit>
        <trans-unit id="186f978915d5da16498fc2a31ce5738b6e7a61d3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;target&lt;/code&gt; result set is not loaded until needed. For example,</source>
          <target state="translated">&lt;code&gt;target&lt;/code&gt; 필요할 때까지 결과 세트가로드되지 않습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="d6caaddc3c48d3dbe705a48fef1cd8c4ce0ede76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; directory is where tests for the engine will go. To test the engine, there is a cut-down version of a Rails application embedded within it at &lt;code&gt;test/dummy&lt;/code&gt;. This application will mount the engine in the &lt;code&gt;test/dummy/config/routes.rb&lt;/code&gt; file:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 엔진에 대한 테스트가 갈 곳 디렉토리입니다. 엔진을 테스트하기 위해 test &lt;code&gt;test/dummy&lt;/code&gt; 엔진 내에 포함 된 Rails 애플리케이션의 컷 다운 버전이 있습니다. 이 응용 프로그램은 엔진을 &lt;code&gt;test/dummy/config/routes.rb&lt;/code&gt; 파일에 마운트 합니다.</target>
        </trans-unit>
        <trans-unit id="b71371631fafbfc0ff3a4609264ec18900eb44ad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; directory should be treated like a typical Rails testing environment, allowing for unit, functional, and integration tests.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 디렉토리는 전형적인 레일, 환경 시험 장치, 기능 및 통합 테스트를 허용처럼 취급되어야한다.</target>
        </trans-unit>
        <trans-unit id="5004018241d9fedd09f648b2beaf6672bc5926c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test&lt;/code&gt; environment is used when running automated tests.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 자동화 된 테스트를 실행할 때 환경이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cd770f311d6bb1e03d0ab6b309f15428d9f10e15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_helper.rb&lt;/code&gt; file holds the default configuration for your tests.</source>
          <target state="translated">&lt;code&gt;test_helper.rb&lt;/code&gt; 의 파일은 테스트의 기본 구성을 보유하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b45bff0931d256831572e50dafddadbd42b3679c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tmp:&lt;/code&gt; namespaced commands will help you clear and create the &lt;code&gt;Rails.root/tmp&lt;/code&gt; directory:</source>
          <target state="translated">&lt;code&gt;tmp:&lt;/code&gt; 네임 스페이스 명령은 취소 돕고 만듭니다 &lt;code&gt;Rails.root/tmp&lt;/code&gt; 디렉토리를 :</target>
        </trans-unit>
        <trans-unit id="1ea0aa9f98de14affd66ef910261ea292d087ab3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;to_s&lt;/code&gt; method from the Time class can be wrapped in a helper method to display a custom message if a Time object is blank:</source>
          <target state="translated">Time 클래스 의 &lt;code&gt;to_s&lt;/code&gt; 메소드는 Time 오브젝트가 비어있는 경우 사용자 정의 메시지를 표시하기 위해 헬퍼 메소드로 랩핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48dfe3a8392aaf7467b50e78ee4608869d75ff1b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;translate&lt;/code&gt; method also takes a &lt;code&gt;:scope&lt;/code&gt; option which can contain one or more additional keys that will be used to specify a &quot;namespace&quot; or scope for a translation key:</source>
          <target state="translated">또한 &lt;code&gt;translate&lt;/code&gt; 메소드는 &lt;code&gt;:scope&lt;/code&gt; 옵션을 사용하는데, 여기에는 &quot;namespace&quot;또는 번역 키의 범위를 지정하는 데 사용되는 하나 이상의 추가 키가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e7b91934dd423361fe5b4d7f4c04cecdccaab4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;traps&lt;/code&gt; association on &lt;code&gt;Dungeon&lt;/code&gt; and the &lt;code&gt;dungeon&lt;/code&gt; association on &lt;code&gt;Trap&lt;/code&gt; are the inverse of each other, and the inverse of the &lt;code&gt;dungeon&lt;/code&gt; association on &lt;code&gt;EvilWizard&lt;/code&gt; is the &lt;code&gt;evil_wizard&lt;/code&gt; association on &lt;code&gt;Dungeon&lt;/code&gt; (and vice-versa). By default, Active Record can guess the inverse of the association based on the name of the class. The result is the following:</source>
          <target state="translated">&lt;code&gt;traps&lt;/code&gt; 에 연관 &lt;code&gt;Dungeon&lt;/code&gt; 과 &lt;code&gt;dungeon&lt;/code&gt; 에 연관 &lt;code&gt;Trap&lt;/code&gt; 서로 반대이고, 상기의 역 &lt;code&gt;dungeon&lt;/code&gt; 에 연관 &lt;code&gt;EvilWizard&lt;/code&gt; 은 은 IS &lt;code&gt;evil_wizard&lt;/code&gt; 의 에 연관 &lt;code&gt;Dungeon&lt;/code&gt; (반대로). 기본적으로 Active Record는 클래스 이름을 기준으로 연관의 역수를 추측 할 수 있습니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b608af069145d7a1a229cd8736c90ecbb1e2808" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; parameters will be ignored if present. It can be helpful to provide these in a migration's &lt;code&gt;change&lt;/code&gt; method so it can be reverted. In that case, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; will be used by &lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;add_column&lt;/a&gt;. Indexes on the column are automatically removed.</source>
          <target state="translated">존재하는 경우 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 매개 변수는 무시됩니다. 이를 마이그레이션의 &lt;code&gt;change&lt;/code&gt; 방법 으로 제공하면 되돌릴 수 있습니다. 이 경우 &lt;a href=&quot;schemastatements#method-i-add_column&quot;&gt;add_column&lt;/a&gt; 에서 &lt;code&gt;type&lt;/code&gt; 및 &lt;code&gt;options&lt;/code&gt; 을 사용합니다 . 열의 색인이 자동으로 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="74f20ebf68e4d50c0c1c19380093127edbdf2148" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; parameter is normally one of the migrations native types, which is one of the following: &lt;code&gt;:primary_key&lt;/code&gt;, &lt;code&gt;:string&lt;/code&gt;, &lt;code&gt;:text&lt;/code&gt;, &lt;code&gt;:integer&lt;/code&gt;, &lt;code&gt;:bigint&lt;/code&gt;, &lt;code&gt;:float&lt;/code&gt;, &lt;code&gt;:decimal&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:datetime&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, &lt;code&gt;:date&lt;/code&gt;, &lt;code&gt;:binary&lt;/code&gt;, &lt;code&gt;:boolean&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;type&lt;/code&gt; : 매개 변수는 일반적으로 마이그레이션 기본 다음 중 하나입니다 유형 중 하나입니다 &lt;code&gt;:primary_key&lt;/code&gt; 와 , &lt;code&gt;:string&lt;/code&gt; , &lt;code&gt;:text&lt;/code&gt; , &lt;code&gt;:integer&lt;/code&gt; , &lt;code&gt;:bigint&lt;/code&gt; , &lt;code&gt;:float&lt;/code&gt; , &lt;code&gt;:decimal&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:datetime&lt;/code&gt; , &lt;code&gt;:time&lt;/code&gt; , &lt;code&gt;:date&lt;/code&gt; , &lt;code&gt;:binary&lt;/code&gt; , &lt;code&gt;:boolean&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="909c1e2f7e1700ca721bfb300acd87916d137b8c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;users&lt;/code&gt; resource here will have the following routes generated for it:</source>
          <target state="translated">여기에 있는 &lt;code&gt;users&lt;/code&gt; 리소스에는 다음과 같은 경로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7b64979286dc25c90c1549f6b8c3de8ea8f19a2c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;valid?&lt;/code&gt; method will verify that the errors collection is empty, so your custom validation methods should add errors to it when you wish validation to fail:</source>
          <target state="translated">&lt;code&gt;valid?&lt;/code&gt; 메소드는 오류 콜렉션이 비어 있는지 확인하므로 사용자 정의 유효성 검증 메소드는 유효성 검증에 실패하려는 경우 오류를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="51da5d2d391d1141e0b796d1f1e389987efeacf9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;validates_with&lt;/code&gt; helper takes a class, or a list of classes to use for validation. There is no default error message for &lt;code&gt;validates_with&lt;/code&gt;. You must manually add errors to the record's errors collection in the validator class.</source>
          <target state="translated">&lt;code&gt;validates_with&lt;/code&gt; 의 도우미 클래스를 취하거나, 클래스의 목록 확인을 위해 사용하는. &lt;code&gt;validates_with&lt;/code&gt; 에 대한 기본 오류 메시지는 없습니다 . 유효성 검증기 클래스의 레코드 오류 콜렉션에 수동으로 오류를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="7223765fdb4392dac5134b286d36fda58b5447c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;var&lt;/code&gt; method is the most convenient way to show variables and their values. Let's have &lt;code&gt;byebug&lt;/code&gt; help us with it.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 방법은 변수와 값을 표시하는 가장 편리한 방법입니다. 의가 보자 &lt;code&gt;byebug&lt;/code&gt; 그것으로 도움이 우리를.</target>
        </trans-unit>
        <trans-unit id="db56453ade5f0bcdfd93cb86efe38e07aeea201a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;video_tag&lt;/code&gt; helper builds an HTML 5 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; tag to the specified file. By default, files are loaded from &lt;code&gt;public/videos&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;video_tag&lt;/code&gt; 의 도우미는 HTML 5 기반으로 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 지정된 파일에 태그를. 기본적으로 파일은 &lt;code&gt;public/videos&lt;/code&gt; 에서로드됩니다 .</target>
        </trans-unit>
        <trans-unit id="786f5cd577d9cf7c08731cfd3c22f2b4d08a4b01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; method allows you to specify conditions to limit the records returned, representing the &lt;code&gt;WHERE&lt;/code&gt;-part of the SQL statement. Conditions can either be specified as a string, array, or hash.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 방법은 당신이 나타내는 레코드가 반환 제한하는 조건을 지정할 수 있습니다 &lt;code&gt;WHERE&lt;/code&gt; part의 SQL 문을. 조건은 문자열, 배열 또는 해시로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05a4f9cbdfb67dd3d7071bbe8edd4c8495a28fff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;where&lt;/code&gt; method lets you specify the conditions that the associated object must meet.</source>
          <target state="translated">&lt;code&gt;where&lt;/code&gt; 방법은 당신이 연관된 객체가 충족해야하는 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c19f48c1a86ef523c124f8954e3c372f6c11764a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; and &lt;code&gt;fetch&lt;/code&gt; methods on this cache accept two additional options that take advantage of features specific to memcached. You can specify &lt;code&gt;:raw&lt;/code&gt; to send a value directly to the server with no serialization. The value must be a string or number. You can use memcached direct operations like &lt;code&gt;increment&lt;/code&gt; and &lt;code&gt;decrement&lt;/code&gt; only on raw values. You can also specify &lt;code&gt;:unless_exist&lt;/code&gt; if you don't want memcached to overwrite an existing entry.</source>
          <target state="translated">이 캐시 의 &lt;code&gt;write&lt;/code&gt; 및 &lt;code&gt;fetch&lt;/code&gt; 메소드는 memcached 관련 기능을 이용하는 두 가지 추가 옵션을 허용합니다. 직렬화없이 서버로 직접 값을 보내려면 &lt;code&gt;:raw&lt;/code&gt; 를 지정할 수 있습니다 . 값은 문자열 또는 숫자 여야합니다. 원시 값에 대해서만 &lt;code&gt;increment&lt;/code&gt; 및 &lt;code&gt;decrement&lt;/code&gt; 와 같은 memcached 직접 조작을 사용할 수 있습니다 . memcached가 기존 항목을 덮어 쓰지 않게하려면 &lt;code&gt;:unless_exist&lt;/code&gt; 를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afa4bfe437a4fc0805dd6be42774dd49262312e4" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;nesting&lt;/em&gt; at any given place is the collection of enclosing nested class and module objects outwards. The nesting at any given place can be inspected with &lt;code&gt;Module.nesting&lt;/code&gt;. For example, in the previous example, the nesting at (1) is</source>
          <target state="translated">&lt;em&gt;중첩&lt;/em&gt; 주어진 장소에서 중첩 클래스를 둘러싸의 수집과 모듈은 바깥쪽으로 객체. 특정 장소에서의 중첩은 &lt;code&gt;Module.nesting&lt;/code&gt; 으로 검사 할 수 있습니다 . 예를 들어, 이전 예에서 (1)의 중첩은</target>
        </trans-unit>
        <trans-unit id="c5a3ef47071c621cb202c268e30836a0a9eec39c" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;translations load path&lt;/strong&gt; (&lt;code&gt;I18n.load_path&lt;/code&gt;) is an array of paths to files that will be loaded automatically. Configuring this path allows for customization of translations directory structure and file naming scheme.</source>
          <target state="translated">&lt;strong&gt;번역 부하 경로&lt;/strong&gt; ( &lt;code&gt;I18n.load_path&lt;/code&gt; 는 ) 자동으로로드 될 파일 경로의 배열이다. 이 경로를 구성하면 변환 디렉토리 구조 및 파일 이름 지정 체계를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86d5174bea0411f873c2bb5dd4bc4ed345931f0a" translate="yes" xml:space="preserve">
          <source>The API has the same methods as &lt;a href=&quot;../../activerecord&quot;&gt;ActiveRecord&lt;/a&gt;, but each method returns a string that matches the ORM API.</source>
          <target state="translated">API에는 &lt;a href=&quot;../../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; 와 동일한 메소드가 있지만 각 메소드는 ORM API와 일치하는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="55e793a2888b49a29894bdca339ead6c9fe679c8" translate="yes" xml:space="preserve">
          <source>The Accept header to send.</source>
          <target state="translated">보낼 Accept 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="6d5f016001371703e3307c75f0487c4b68163b8b" translate="yes" xml:space="preserve">
          <source>The Action Cable JavaScript package has been converted from CoffeeScript to ES2015, and we now publish the source code in the npm distribution.</source>
          <target state="translated">Action Cable JavaScript 패키지가 CoffeeScript에서 ES2015로 변환되었으며, 이제 npm 배포판에 소스 코드를 게시합니다.</target>
        </trans-unit>
        <trans-unit id="d4cdb1176348337a161b520cc8ddf9d538ca5295" translate="yes" xml:space="preserve">
          <source>The Action Cable server implements the Rack socket hijacking API, thereby allowing the use of a multithreaded pattern for managing connections internally, irrespective of whether the application server is multi-threaded or not.</source>
          <target state="translated">Action Cable 서버는 랙 소켓 하이재킹 API를 구현하여 애플리케이션 서버가 멀티 스레드인지 여부에 관계없이 내부적으로 연결을 관리하기 위해 멀티 스레드 패턴을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c476dfe6844359be0597b529c523d1db0da895f" translate="yes" xml:space="preserve">
          <source>The Active Record Pattern</source>
          <target state="translated">활성 레코드 패턴</target>
        </trans-unit>
        <trans-unit id="c991c23e383794b1a2ce5fb6ec92d816927cb078" translate="yes" xml:space="preserve">
          <source>The Active Record pattern implements &lt;a href=&quot;https://en.wikipedia.org/wiki/Method_chaining&quot;&gt;Method Chaining&lt;/a&gt;, which allow us to use multiple Active Record methods together in a simple and straightforward way.</source>
          <target state="translated">Active Record 패턴은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Method_chaining&quot;&gt;Method Chaining을&lt;/a&gt; 구현 하여 단순하고 간단한 방식으로 여러 Active Record 메소드를 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0878293154da66102be3276c6af12ef4384d6b2d" translate="yes" xml:space="preserve">
          <source>The Active Record way claims that intelligence belongs in your models, not in the database. As such, features such as triggers or constraints, which push some of that intelligence back into the database, are not heavily used.</source>
          <target state="translated">Active Record 방식은 지능이 데이터베이스가 아닌 모델에 속한다고 주장합니다. 따라서 일부 인텔리전스를 데이터베이스로 다시 가져 오는 트리거 또는 제약 조건과 같은 기능은 많이 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="437d5c829ecb969158193552a1e5f1fcea031bd9" translate="yes" xml:space="preserve">
          <source>The Article model is directly available to users of the application, so - following the best practices for developing with Rails - you should declare it &lt;strong&gt;a resource&lt;/strong&gt;:</source>
          <target state="translated">기사 모델은 애플리케이션 사용자가 직접 사용할 수 있으므로 Rails로 개발하기위한 모범 사례에 &lt;strong&gt;따라 리소스를&lt;/strong&gt; 선언해야 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="62aeb8f445266c127d5322b7e3e47469fab89364" translate="yes" xml:space="preserve">
          <source>The Asset Pipeline</source>
          <target state="translated">자산 파이프 라인</target>
        </trans-unit>
        <trans-unit id="bf015d4f3767ea2825797ed8725414de46523dc4" translate="yes" xml:space="preserve">
          <source>The Async adapter runs jobs with an in-process thread pool.</source>
          <target state="translated">비동기 어댑터는 프로세스 중 스레드 풀로 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fa08b5bc17bc0e5cf864e09a2b41bfab03da6a03" translate="yes" xml:space="preserve">
          <source>The Atom spec defines five elements (content rights title subtitle summary) which may directly contain xhtml content if type: 'xhtml' is specified as an attribute. If so, this helper will take care of the enclosing div and xhtml namespace declaration. Example usage:</source>
          <target state="translated">Atom 스펙은 type : 'xhtml'이 속성으로 지정된 경우 xhtml 컨텐츠를 직접 포함 할 수있는 5 가지 요소 (콘텐츠 권리 제목 자막 요약)를 정의합니다. 그렇다면이 도우미는 둘러싸는 div 및 xhtml 네임 스페이스 선언을 처리합니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="f2059d1c5a7ee7ea550ab849fa2357509e7e68c2" translate="yes" xml:space="preserve">
          <source>The Basic Configuration</source>
          <target state="translated">기본 구성</target>
        </trans-unit>
        <trans-unit id="7e1ba6fb909a534eed2ef634c34f5b5fb5818eb5" translate="yes" xml:space="preserve">
          <source>The Basics of Creating Rails Plugins</source>
          <target state="translated">Rails 플러그인 생성의 기초</target>
        </trans-unit>
        <trans-unit id="cd15cbd8be53475b1988d013b85b6bbc6577b599" translate="yes" xml:space="preserve">
          <source>The CDN you provisioned should give you a custom subdomain for your application such as &lt;code&gt;mycdnsubdomain.fictional-cdn.com&lt;/code&gt; (note fictional-cdn.com is not a valid CDN provider at the time of this writing). Now that you have configured your CDN server, you need to tell browsers to use your CDN to grab assets instead of your Rails server directly. You can do this by configuring Rails to set your CDN as the asset host instead of using a relative path. To set your asset host in Rails, you need to set &lt;code&gt;config.action_controller.asset_host&lt;/code&gt; in &lt;code&gt;config/environments/production.rb&lt;/code&gt;:</source>
          <target state="translated">프로비저닝 한 CDN은 &lt;code&gt;mycdnsubdomain.fictional-cdn.com&lt;/code&gt; 과 같이 응용 프로그램에 대한 사용자 지정 하위 도메인을 제공해야합니다 (이 문서 작성 시점에서 fictional-cdn.com은 유효한 CDN 공급자가 아닙니다). CDN 서버를 구성 했으므로 CDN을 사용하여 Rails 서버 대신 자산을 가져 오도록 브라우저에 지시해야합니다. 상대 경로를 사용하는 대신 CDN을 자산 호스트로 설정하도록 Rails를 구성하여이를 수행 할 수 있습니다. Rails에서 자산 호스트를 설정하려면 &lt;code&gt;config/environments/production.rb&lt;/code&gt; 에서 &lt;code&gt;config.action_controller.asset_host&lt;/code&gt; 를 설정해야합니다 :</target>
        </trans-unit>
        <trans-unit id="6cea6c7fe74b0f93c1f9ab54fa152d0c2e279f8e" translate="yes" xml:space="preserve">
          <source>The Chars object tries to be as interchangeable with &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; objects as possible: sorting and comparing between &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; and Char work like expected. The bang! methods change the internal string representation in the Chars object. Interoperability problems can be resolved easily with a &lt;code&gt;to_s&lt;/code&gt; call.</source>
          <target state="translated">Chars 객체는 가능한 한 &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; 객체 와 상호 교환이 가능합니다. &lt;a href=&quot;string&quot;&gt;String&lt;/a&gt; 과 Char의 정렬 및 비교는 예상대로 작동합니다. 쾅! 메소드는 Chars 객체의 내부 문자열 표현을 변경합니다. &lt;code&gt;to_s&lt;/code&gt; 호출로 상호 운용성 문제를 쉽게 해결할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03e12ed22cac9637ee0a620316efab5b04dd783a" translate="yes" xml:space="preserve">
          <source>The Comment model</source>
          <target state="translated">댓글 모델</target>
        </trans-unit>
        <trans-unit id="61562e3418ad09bfee7afa928e1cdff150afeb86" translate="yes" xml:space="preserve">
          <source>The Comments controller</source>
          <target state="translated">댓글 컨트롤러</target>
        </trans-unit>
        <trans-unit id="238e63febc701a9b94f9f64b1bc7f8600b013b00" translate="yes" xml:space="preserve">
          <source>The Configuration instance used to configure the Rails environment</source>
          <target state="translated">Rails 환경을 구성하는 데 사용되는 구성 인스턴스</target>
        </trans-unit>
        <trans-unit id="26a1adaa03161aa757dfdd7900a0e22880fc1a32" translate="yes" xml:space="preserve">
          <source>The Context</source>
          <target state="translated">문맥</target>
        </trans-unit>
        <trans-unit id="650fce6a189ad476c932744182820a86cd85c4ed" translate="yes" xml:space="preserve">
          <source>The Controller</source>
          <target state="translated">컨트롤러</target>
        </trans-unit>
        <trans-unit id="e37cd191bc90ccf488a78e204b6fc81493a5691d" translate="yes" xml:space="preserve">
          <source>The CookieStore can store around 4kB of data - much less than the others - but this is usually enough. Storing large amounts of data in the session is discouraged no matter which session store your application uses. You should especially avoid storing complex objects (anything other than basic Ruby objects, the most common example being model instances) in the session, as the server might not be able to reassemble them between requests, which will result in an error.</source>
          <target state="translated">CookieStore는 다른 것보다 훨씬 적은 약 4kB의 데이터를 저장할 수 있지만 일반적으로 충분합니다. 응용 프로그램이 사용하는 세션 저장소에 관계없이 세션에 많은 양의 데이터를 저장하지 않는 것이 좋습니다. 서버가 요청간에 객체를 다시 어셈블 할 수 없으므로 오류가 발생할 수 있으므로 세션에 복잡한 객체 (기본 Ruby 객체 이외의 다른 모델, 가장 일반적인 예는 모델 인스턴스)를 저장하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="388ca69f840860706f49139a7e82fe3c50fa738a" translate="yes" xml:space="preserve">
          <source>The DOM class convention is to use the singular form of an object or class.</source>
          <target state="translated">DOM 클래스 규칙은 객체 또는 클래스의 단일 형식을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b84555bfbd95f52af7de1fb3b917316088e87148" translate="yes" xml:space="preserve">
          <source>The DOM id convention is to use the singular form of an object or class with the id following an underscore. If no id is found, prefix with &amp;ldquo;new_&amp;rdquo; instead.</source>
          <target state="translated">DOM id 규칙은 밑줄 다음에 id가있는 단일 형식의 객체 또는 클래스를 사용하는 것입니다. 아이디가 없으면 대신 &quot;new_&quot;를 접두사로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="014b99805115373da3292429d6b5602d56b4cc92" translate="yes" xml:space="preserve">
          <source>The Default 500 and 404 Templates</source>
          <target state="translated">기본 500 및 404 템플릿</target>
        </trans-unit>
        <trans-unit id="abd403f7a8d76d19d9bb9d3ded23ba251e716e1e" translate="yes" xml:space="preserve">
          <source>The Executor always has important work to do, like database connection management. When &lt;code&gt;cache_classes&lt;/code&gt; and &lt;code&gt;eager_load&lt;/code&gt; are both true (&lt;code&gt;production&lt;/code&gt;), no autoloading or class reloading will occur, so it does not need the Load Interlock. If either of those are false (&lt;code&gt;development&lt;/code&gt;), then the Executor will use the Load Interlock to ensure constants are only loaded when it is safe.</source>
          <target state="translated">Executor는 데이터베이스 연결 관리와 같은 중요한 작업을 항상 수행합니다. 때 &lt;code&gt;cache_classes&lt;/code&gt; 및 &lt;code&gt;eager_load&lt;/code&gt; 이 모두 사실 (있는 &lt;code&gt;production&lt;/code&gt; )는로드 연동을 필요로하지 않도록, 더 자동 로딩 또는 클래스 다시로드가 발생하지 않습니다. 둘 중 하나라도 거짓 인 경우 ( &lt;code&gt;development&lt;/code&gt; ), Executor는 Load Interlock을 사용하여 상수가 안전 할 때만로드되도록합니다.</target>
        </trans-unit>
        <trans-unit id="75336e82f6983b96195933e136772c6606001209" translate="yes" xml:space="preserve">
          <source>The Executor automatically acquires a &lt;code&gt;running&lt;/code&gt; lock for the duration of its block, and autoload knows when to upgrade to a &lt;code&gt;load&lt;/code&gt; lock, and switch back to &lt;code&gt;running&lt;/code&gt; again afterwards.</source>
          <target state="translated">Executor 는 블록 기간 동안 자동으로 &lt;code&gt;running&lt;/code&gt; 잠금을 획득하고 , 자동 &lt;code&gt;load&lt;/code&gt; 는 로드 잠금 으로 업그레이드 할시기를 알고 나중에 다시 &lt;code&gt;running&lt;/code&gt; 전환 합니다.</target>
        </trans-unit>
        <trans-unit id="e9f08908119107f5db3031447da1ce37388431b6" translate="yes" xml:space="preserve">
          <source>The Executor consists of two callbacks: &lt;code&gt;to_run&lt;/code&gt; and &lt;code&gt;to_complete&lt;/code&gt;. The Run callback is called before the application code, and the Complete callback is called after.</source>
          <target state="translated">실행기는 두 개의 콜백 ( &lt;code&gt;to_run&lt;/code&gt; 및 &lt;code&gt;to_complete&lt;/code&gt; )으로 구성 됩니다. Run 콜백은 응용 프로그램 코드보다 먼저 호출되고 Complete 콜백은 이후에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="45a617537bd07da4443c0b99fc8d1f05a6994528" translate="yes" xml:space="preserve">
          <source>The Executor is safely re-entrant; if it is already active on the current thread, &lt;code&gt;wrap&lt;/code&gt; is a no-op.</source>
          <target state="translated">집행자는 안전하게 재진입한다. 현재 스레드에서 이미 활성화 된 경우 &lt;code&gt;wrap&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8fb3b8ff046a74e5630fe92937b42561babff75e" translate="yes" xml:space="preserve">
          <source>The Executor will put the current thread into &lt;code&gt;running&lt;/code&gt; mode in the Load Interlock. This operation will block temporarily if another thread is currently either autoloading a constant or unloading/reloading the application.</source>
          <target state="translated">Executor는 현재 쓰레드를 Load Interlock에서 &lt;code&gt;running&lt;/code&gt; 모드 로 전환합니다. 다른 스레드가 현재 상수를 자동로드하거나 응용 프로그램을 언로드 / 재로드하는 경우이 작업은 일시적으로 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="2505bfbdb161d7a745f8f681afd58a70fea8e2e1" translate="yes" xml:space="preserve">
          <source>The Flash</source>
          <target state="translated">플래시</target>
        </trans-unit>
        <trans-unit id="acb817e66f48334fcea25df1629a6dc4c5749d27" translate="yes" xml:space="preserve">
          <source>The Gartner Group, however, estimates that 75% of attacks are at the web application layer, and found out &quot;that out of 300 audited sites, 97% are vulnerable to attack&quot;. This is because web applications are relatively easy to attack, as they are simple to understand and manipulate, even by the lay person.</source>
          <target state="translated">그러나 가트너 그룹은 75 %의 공격이 웹 애플리케이션 계층에 있다고 추정하고 &quot;감사 한 300 개의 사이트 중 97 %가 공격에 취약하다&quot;는 사실을 발견했습니다. 이것은 평범한 사람조차 이해하기 쉽고 조작하기 쉬운 웹 응용 프로그램을 비교적 공격하기 쉽기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="72c8a581a8b0fe9bb67d895a76de753b4c5d3c55" translate="yes" xml:space="preserve">
          <source>The HTML generated for this would be (modulus formatting):</source>
          <target state="translated">이를 위해 생성 된 HTML은 다음과 같습니다 (모듈러스 형식화).</target>
        </trans-unit>
        <trans-unit id="5edfbd463ec7bca173f09112f6284f3dbbc7cfb4" translate="yes" xml:space="preserve">
          <source>The HTML generated for this would be:</source>
          <target state="translated">이를 위해 생성 된 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50f731bf3cc87314f9c9f75bec0eb8bea16e0b6f" translate="yes" xml:space="preserve">
          <source>The HTML specification says unchecked check boxes are not successful, and thus web browsers do not send them. Unfortunately this introduces a gotcha: if an &lt;code&gt;Invoice&lt;/code&gt; model has a &lt;code&gt;paid&lt;/code&gt; flag, and in the form that edits a paid invoice the user unchecks its check box, no &lt;code&gt;paid&lt;/code&gt; parameter is sent. So, any mass-assignment idiom like</source>
          <target state="translated">HTML 사양에서는 선택하지 않은 확인란이 실패하여 웹 브라우저가이를 보내지 않는다고 말합니다. 불행하게도 이것은 &lt;code&gt;Invoice&lt;/code&gt; 도입합니다. 송장 모델에 &lt;code&gt;paid&lt;/code&gt; 플래그가 있고 유료 송장을 편집하는 형식으로 사용자가 해당 확인란의 선택을 취소하면 &lt;code&gt;paid&lt;/code&gt; 매개 변수가 전송 되지 않습니다 . 따라서 질량 할당 관용구는</target>
        </trans-unit>
        <trans-unit id="561b8f280fcf9fe1d7be986e8c7bf7171b53ad45" translate="yes" xml:space="preserve">
          <source>The HTML specification says when &lt;code&gt;multiple&lt;/code&gt; parameter passed to select and all options got deselected web browsers do not send any value to server. Unfortunately this introduces a gotcha: if an &lt;code&gt;User&lt;/code&gt; model has many &lt;code&gt;roles&lt;/code&gt; and have &lt;code&gt;role_ids&lt;/code&gt; accessor, and in the form that edits roles of the user the user deselects all roles from &lt;code&gt;role_ids&lt;/code&gt; multiple select box, no &lt;code&gt;role_ids&lt;/code&gt; parameter is sent. So, any mass-assignment idiom like</source>
          <target state="translated">HTML 사양에 따르면 &lt;code&gt;multiple&lt;/code&gt; 매개 변수가 select에 전달되고 모든 옵션이 선택 취소 된 경우 웹 브라우저가 서버에 값을 보내지 않습니다. 불행히도 이것은 &lt;code&gt;User&lt;/code&gt; 모델에 많은 &lt;code&gt;roles&lt;/code&gt; 있고 &lt;code&gt;role_ids&lt;/code&gt; 접근자가있는 경우 사용자의 역할을 편집하는 형식으로 &lt;code&gt;role_ids&lt;/code&gt; 다중 선택 상자 에서 모든 역할을 선택 취소하면 &lt;code&gt;role_ids&lt;/code&gt; 매개 변수가 전송 되지 않습니다 . 따라서 질량 할당 관용구는</target>
        </trans-unit>
        <trans-unit id="3f0041908b4b4bfd5dd709624c1e43cb18c24394" translate="yes" xml:space="preserve">
          <source>The HTML specification says when nothing is selected on a collection of radio buttons web browsers do not send any value to server. Unfortunately this introduces a gotcha: if a &lt;code&gt;User&lt;/code&gt; model has a &lt;code&gt;category_id&lt;/code&gt; field and in the form no category is selected, no &lt;code&gt;category_id&lt;/code&gt; parameter is sent. So, any strong parameters idiom like:</source>
          <target state="translated">HTML 사양에 따르면 라디오 버튼 모음에서 아무것도 선택하지 않으면 웹 브라우저는 서버에 값을 보내지 않습니다. 유감스럽게도 &lt;code&gt;User&lt;/code&gt; 모델에 &lt;code&gt;category_id&lt;/code&gt; 필드가 있고 범주가 선택되지 않은 형식 인 경우 &lt;code&gt;category_id&lt;/code&gt; 매개 변수가 전송 되지 않습니다 . 따라서 강력한 매개 변수 관용구는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9671636efea31cc6fb67c1628270deba9f54723" translate="yes" xml:space="preserve">
          <source>The HTTP method used for the request.</source>
          <target state="translated">요청에 사용 된 HTTP 메소드입니다.</target>
        </trans-unit>
        <trans-unit id="8438c391a65a4d84a0a1b9361d30e878c7739074" translate="yes" xml:space="preserve">
          <source>The HTTP protocol basically provides two main types of requests - GET and POST (DELETE, PUT, and PATCH should be used like POST). The World Wide Web Consortium (W3C) provides a checklist for choosing HTTP GET or POST:</source>
          <target state="translated">HTTP 프로토콜은 기본적으로 GET 및 POST의 두 가지 주요 요청 유형을 제공합니다 (DELETE, PUT 및 PATCH는 POST와 같이 사용해야 함). W3C (World Wide Web Consortium)는 HTTP GET 또는 POST를 선택하기위한 점검 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f6151c5f4ec17089bb792c86658138e1ec1847e3" translate="yes" xml:space="preserve">
          <source>The HTTP status code for the response, like 200 for a successful request or 404 for file not found.</source>
          <target state="translated">성공적인 요청의 경우 200 또는 파일의 경우 404와 같은 응답의 HTTP 상태 코드입니다.</target>
        </trans-unit>
        <trans-unit id="00d3a26093b532d414271679dbec9e6e2a73f34f" translate="yes" xml:space="preserve">
          <source>The HTTP status code.</source>
          <target state="translated">HTTP 상태 코드</target>
        </trans-unit>
        <trans-unit id="c869f06c0412e1c18b764dcdd4db3189abeed4c4" translate="yes" xml:space="preserve">
          <source>The HTTP verb used (if the route doesn't respond to all verbs)</source>
          <target state="translated">사용 된 HTTP 동사 (경로가 모든 동사에 응답하지 않는 경우)</target>
        </trans-unit>
        <trans-unit id="58b72fee534ffa7b9863e14bb030a14129cf1689" translate="yes" xml:space="preserve">
          <source>The I18n API defines the following exceptions that will be raised by backends when the corresponding unexpected conditions occur:</source>
          <target state="translated">I18n API는 해당 예기치 않은 조건이 발생할 때 백엔드에서 발생하는 다음 예외를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3f776bc1e6f04254a055047cf44eb1ce42e19b30" translate="yes" xml:space="preserve">
          <source>The I18n API described in this guide is primarily intended for translating interface strings. If you are looking to translate model content (e.g. blog posts), you will need a different solution to help with this.</source>
          <target state="translated">이 안내서에 설명 된 I18n API는 주로 인터페이스 문자열을 번역하기위한 것입니다. 모델 컨텐츠 (예 : 블로그 게시물)를 번역하려는 경우이를 위해 다른 솔루션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b84fdeefd4f3de8bdbe34a4d9309382548aacc9a" translate="yes" xml:space="preserve">
          <source>The I18n API will catch all of these exceptions when they are thrown in the backend and pass them to the default_exception_handler method. This method will re-raise all exceptions except for &lt;code&gt;MissingTranslationData&lt;/code&gt; exceptions. When a &lt;code&gt;MissingTranslationData&lt;/code&gt; exception has been caught, it will return the exception's error message string containing the missing key/scope.</source>
          <target state="translated">I18n API는 백엔드에서 throw 될 때 이러한 예외를 모두 포착하여 default_exception_handler 메소드로 전달합니다. 이 메소드는 &lt;code&gt;MissingTranslationData&lt;/code&gt; 예외를 제외한 모든 예외를 다시 발생시킵니다. 때 &lt;code&gt;MissingTranslationData&lt;/code&gt; 의 예외가 잡힌되었습니다, 그것은 누락 된 키 / 범위를 포함하는 예외의 오류 메시지 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5176c661f763c5f64792b55880936106ad4867fd" translate="yes" xml:space="preserve">
          <source>The I18n gem provides a Pluralization backend that can be used to enable locale-specific rules. Include it to the Simple backend, then add the localized pluralization algorithms to translation store, as &lt;code&gt;i18n.plural.rule&lt;/code&gt;.</source>
          <target state="translated">I18n gem은 로캘 별 규칙을 활성화하는 데 사용할 수있는 Pluralization 백엔드를 제공합니다. 이를 단순 백엔드에 포함시킨 다음 현지화 된 복수화 알고리즘을 번역 저장소에 &lt;code&gt;i18n.plural.rule&lt;/code&gt; 로 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1ffc295b865af5f7e8df8aa5588c7c113e36461b" translate="yes" xml:space="preserve">
          <source>The I18n library will use &lt;strong&gt;English&lt;/strong&gt; as a &lt;strong&gt;default locale&lt;/strong&gt;, i.e. if a different locale is not set, &lt;code&gt;:en&lt;/code&gt; will be used for looking up translations.</source>
          <target state="translated">I18n 라이브러리는 &lt;strong&gt;영어&lt;/strong&gt; 를 &lt;strong&gt;기본 로케일로 사용합니다&lt;/strong&gt; . 즉, 다른 로케일이 설정되지 않은 경우 &lt;code&gt;:en&lt;/code&gt; 이 번역을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78001ab8dd2e74a370f820afc118839e328baae4" translate="yes" xml:space="preserve">
          <source>The IP address of the client making the request can be used to infer the client's region and thus their locale. Services such as &lt;a href=&quot;http://www.maxmind.com/app/geolitecountry&quot;&gt;GeoIP Lite Country&lt;/a&gt; or gems like &lt;a href=&quot;https://github.com/alexreisner/geocoder&quot;&gt;geocoder&lt;/a&gt; can be used to implement this approach.</source>
          <target state="translated">요청을하는 클라이언트의 IP 주소는 클라이언트의 지역 및 그 로케일을 유추하는 데 사용될 수 있습니다. &lt;a href=&quot;http://www.maxmind.com/app/geolitecountry&quot;&gt;GeoIP Lite Country&lt;/a&gt; 와 같은 서비스 또는 &lt;a href=&quot;https://github.com/alexreisner/geocoder&quot;&gt;geocoder&lt;/a&gt; 와 같은 gem을 사용하여이 방법을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3fc261360a76b743e82f1c59ab21837cd1b4510" translate="yes" xml:space="preserve">
          <source>The IP address of the client.</source>
          <target state="translated">클라이언트의 IP 주소</target>
        </trans-unit>
        <trans-unit id="805cd68838c38454ac0296fdd39138c33d07b47f" translate="yes" xml:space="preserve">
          <source>The JSON encoder in Rails 4.1 has been rewritten to take advantage of the JSON gem. For most applications, this should be a transparent change. However, as part of the rewrite, the following features have been removed from the encoder:</source>
          <target state="translated">Rails 4.1의 JSON 인코더는 JSON gem을 활용하기 위해 다시 작성되었습니다. 대부분의 응용 프로그램에서 이것은 투명한 변경이어야합니다. 그러나 다시 쓰기의 일부로 다음 기능이 인코더에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="6ee74dcd0b48fe9d8a0549d0dab99caf52bc54d5" translate="yes" xml:space="preserve">
          <source>The Load Interlock allows autoloading and reloading to be enabled in a multi-threaded runtime environment.</source>
          <target state="translated">로드 인터록을 사용하면 다중 스레드 런타임 환경에서 자동로드 및 다시로드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0066f1020e13839690b68171c9c79efdae49082e" translate="yes" xml:space="preserve">
          <source>The Logger</source>
          <target state="translated">로거</target>
        </trans-unit>
        <trans-unit id="eb1d2ad016c09651c6e672d3bbec314bb16cc9f9" translate="yes" xml:space="preserve">
          <source>The Low-Down on Fixtures</source>
          <target state="translated">비품의 로우 다운</target>
        </trans-unit>
        <trans-unit id="4efd89956b023e4f734c9e7b62864d1e8137e6b7" translate="yes" xml:space="preserve">
          <source>The MIME type of the HTTP request, such as Mime.</source>
          <target state="translated">HTTP 요청의 MIME 유형 (예 : Mime)</target>
        </trans-unit>
        <trans-unit id="acd24d6d5cb6a9f5800a5ffad9287bdc4bb26ccf" translate="yes" xml:space="preserve">
          <source>The MySQL adapter adds one additional configuration option:</source>
          <target state="translated">MySQL 어댑터는 하나의 추가 구성 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="3c84e45d278374333357b9276a241aca8efccd8b" translate="yes" xml:space="preserve">
          <source>The Object Life Cycle</source>
          <target state="translated">객체 수명주기</target>
        </trans-unit>
        <trans-unit id="98f2bbb0f67f9b09d323527720d93b69faf00d50" translate="yes" xml:space="preserve">
          <source>The Overall Architecture of the Library</source>
          <target state="translated">도서관의 전체 아키텍처</target>
        </trans-unit>
        <trans-unit id="2e6caff8462f9eed2c3308f7ae4c782815a5a81f" translate="yes" xml:space="preserve">
          <source>The PostgreSQL adapter adds one additional configuration option:</source>
          <target state="translated">PostgreSQL 어댑터는 하나의 추가 구성 옵션을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="797285a5529ca40d8ceaff9e2ba1aca92e64887a" translate="yes" xml:space="preserve">
          <source>The PostgreSQL adapter uses Active Record's connection pool, and thus the application's &lt;code&gt;config/database.yml&lt;/code&gt; database configuration, for its connection. This may change in the future. &lt;a href=&quot;https://github.com/rails/rails/issues/27214&quot;&gt;#27214&lt;/a&gt;</source>
          <target state="translated">PostgreSQL 어댑터는 연결을 위해 Active Record의 연결 풀과 애플리케이션의 &lt;code&gt;config/database.yml&lt;/code&gt; 데이터베이스 구성을 사용합니다. 향후 변경 될 수 있습니다. &lt;a href=&quot;https://github.com/rails/rails/issues/27214&quot;&gt;# 27214&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="82edc0df5cb4ce3a1e8a8538ebb647f5bf208d63" translate="yes" xml:space="preserve">
          <source>The PostgreSQL adapter works with the native C (&lt;a href=&quot;https://bitbucket.org/ged/ruby-pg&quot;&gt;bitbucket.org/ged/ruby-pg&lt;/a&gt;) driver.</source>
          <target state="translated">PostgreSQL 어댑터는 네이티브 C ( &lt;a href=&quot;https://bitbucket.org/ged/ruby-pg&quot;&gt;bitbucket.org/ged/ruby-pg&lt;/a&gt; ) 드라이버 와 함께 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc823aa9daad3a923502fbafa41a04a8554d952" translate="yes" xml:space="preserve">
          <source>The Public I18n API</source>
          <target state="translated">공개 I18n API</target>
        </trans-unit>
        <trans-unit id="4ee35b8c1b691b08db3bdbe0256144ced1cee71d" translate="yes" xml:space="preserve">
          <source>The Purpose of Active Job</source>
          <target state="translated">활동적인 직업의 목적</target>
        </trans-unit>
        <trans-unit id="823c1a0091442b782c0e1668bc5aaf1b4f1f90f5" translate="yes" xml:space="preserve">
          <source>The Purpose of the Rails Router</source>
          <target state="translated">레일스 라우터의 목적</target>
        </trans-unit>
        <trans-unit id="51c22eed0065efc3555e03456648dab85e559aef" translate="yes" xml:space="preserve">
          <source>The Query String</source>
          <target state="translated">쿼리 문자열</target>
        </trans-unit>
        <trans-unit id="035bae956c3ed41d7d32de1e706edbb0e2eb039c" translate="yes" xml:space="preserve">
          <source>The Rails Advanced Command Line</source>
          <target state="translated">레일스 어드밴스드 커맨드 라인</target>
        </trans-unit>
        <trans-unit id="04795c00f3224f73f84948a0c1b60589db3b1a7b" translate="yes" xml:space="preserve">
          <source>The Rails Command Line</source>
          <target state="translated">레일스 커맨드 라인</target>
        </trans-unit>
        <trans-unit id="88a3d15a4e54b01428b036ceb885418ae6638e2b" translate="yes" xml:space="preserve">
          <source>The Rails Executor separates application code from framework code: any time the framework invokes code you've written in your application, it will be wrapped by the Executor.</source>
          <target state="translated">Rails Executor는 애플리케이션 코드를 프레임 워크 코드와 분리합니다. 프레임 워크가 애플리케이션에서 작성한 코드를 호출 할 때마다 Executor에 의해 랩핑됩니다.</target>
        </trans-unit>
        <trans-unit id="2f680a004274bb183c69fa22ff0ed3836a4e7d58" translate="yes" xml:space="preserve">
          <source>The Rails Initialization Process</source>
          <target state="translated">레일즈 초기화 프로세스</target>
        </trans-unit>
        <trans-unit id="40b90d2be490ac85e4afd082c51767a902a0b57e" translate="yes" xml:space="preserve">
          <source>The Rails Test Runner</source>
          <target state="translated">레일즈 테스트 러너</target>
        </trans-unit>
        <trans-unit id="e21e7573f446b6773b246324ac22155fda204953" translate="yes" xml:space="preserve">
          <source>The Rails core team has stated patches for the inflections library will not be accepted in order to avoid breaking legacy applications which may be relying on errant inflections. If you discover an incorrect inflection and require it for your application or wish to define rules for languages other than English, please correct or add them yourself (explained below).</source>
          <target state="translated">Rails의 핵심 팀은 잘못된 변곡에 의존 할 수있는 레거시 응용 프로그램의 중단을 피하기 위해 변곡 라이브러리에 대한 패치는 허용되지 않을 것이라고 언급했습니다. 잘못된 변곡을 발견하여 응용 프로그램에 요구하거나 영어 이외의 언어에 대한 규칙을 정의하려는 경우 직접 수정하거나 추가하십시오 (아래 설명).</target>
        </trans-unit>
        <trans-unit id="ff87ad6b1e96b780f28e55c9eebab32afd566d1a" translate="yes" xml:space="preserve">
          <source>The Rails environment;</source>
          <target state="translated">Rails 환경;</target>
        </trans-unit>
        <trans-unit id="95ee7e0b9ac7f4840ef97ae6dc2dad314a98ae35" translate="yes" xml:space="preserve">
          <source>The Rails framework components use these tools to manage their own concurrency needs too.</source>
          <target state="translated">Rails 프레임 워크 컴포넌트는 이러한 툴을 사용하여 자체 동시성 요구도 관리합니다.</target>
        </trans-unit>
        <trans-unit id="d74133a805ebbdaee19ace506605a8d40d4ea5f7" translate="yes" xml:space="preserve">
          <source>The Rails framework encourages RESTful design of your applications, which means you'll be making a lot of &quot;PATCH&quot;, &quot;PUT&quot;, and &quot;DELETE&quot; requests (besides &quot;GET&quot; and &quot;POST&quot;). However, most browsers &lt;em&gt;don't support&lt;/em&gt; methods other than &quot;GET&quot; and &quot;POST&quot; when it comes to submitting forms.</source>
          <target state="translated">Rails 프레임 워크는 애플리케이션의 RESTful 디자인을 권장합니다. 즉, &quot;PATCH&quot;, &quot;PUT&quot;및 &quot;DELETE&quot;요청을 많이 수행하게됩니다 ( &quot;GET&quot;및 &quot;POST&quot;제외). 그러나 대부분의 브라우저 &lt;em&gt;는&lt;/em&gt; 양식을 제출할 때 &quot;GET&quot;및 &quot;POST&quot;이외의 방법을 &lt;em&gt;지원하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ca74aea3b00b63d989ab4ef5c91331bc9e61c181" translate="yes" xml:space="preserve">
          <source>The Rails framework provides a large number of helpers for working with assets, dates, forms, numbers and model objects, to name a few. These helpers are available to all templates by default.</source>
          <target state="translated">Rails 프레임 워크는 자산, 날짜, 양식, 숫자 및 모델 객체를 다루는 데 도움이되는 많은 도우미를 제공합니다. 이러한 도우미는 기본적으로 모든 템플릿에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c41247006949c5d3d9f932c821a6c3cf8f4698c7" translate="yes" xml:space="preserve">
          <source>The Rails logger is still not ready in &lt;code&gt;config/application.rb&lt;/code&gt;, but it is in initializers:</source>
          <target state="translated">Rails 로거는 여전히 &lt;code&gt;config/application.rb&lt;/code&gt; 에서 준비되지 않았지만 초기화 프로그램 에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a733d5d1f65b90aaed94e807b50100a618408998" translate="yes" xml:space="preserve">
          <source>The Rails package has several tools to help create and apply migrations.</source>
          <target state="translated">Rails 패키지에는 마이그레이션을 만들고 적용하는 데 도움이되는 몇 가지 도구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="593159354abcc7d9d78af190a120bc0af6170627" translate="yes" xml:space="preserve">
          <source>The Rails philosophy includes two major guiding principles:</source>
          <target state="translated">Rails 철학에는 두 가지 주요 지침 원칙이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="cda932bf81a4b19c4d705c223d0b8a2d173cc1f3" translate="yes" xml:space="preserve">
          <source>The Rails router recognizes URLs and dispatches them to a controller's action, or to a Rack application. It can also generate paths and URLs, avoiding the need to hardcode strings in your views.</source>
          <target state="translated">Rails 라우터는 URL을 인식하여이를 컨트롤러의 작업 또는 랙 응용 프로그램으로 발송합니다. 또한 뷰에서 문자열을 하드 코딩 할 필요없이 경로와 URL을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a8a034a3468de652837bb7bef00583aaa629f6d" translate="yes" xml:space="preserve">
          <source>The Rails team strongly encourages you to write your CoffeeScript (and JavaScript) in this style, and you can expect that many libraries will also follow this pattern.</source>
          <target state="translated">Rails 팀은이 스타일로 CoffeeScript (및 JavaScript)를 작성하도록 강력히 권장하며 많은 라이브러리가이 패턴을 따를 것으로 예상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a826a423a820b9f720b5b58cbba295c504f9247" translate="yes" xml:space="preserve">
          <source>The Rails templates API is easy to understand. Here's an example of a typical Rails template:</source>
          <target state="translated">Rails 템플릿 API는 이해하기 쉽습니다. 일반적인 Rails 템플릿의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="632b26a07949b11988987eee440a5719dc26a9d8" translate="yes" xml:space="preserve">
          <source>The Redis adapter requires users to provide a URL pointing to the Redis server. Additionally, a &lt;code&gt;channel_prefix&lt;/code&gt; may be provided to avoid channel name collisions when using the same Redis server for multiple applications. See the &lt;a href=&quot;https://redis.io/topics/pubsub#database-amp-scoping&quot;&gt;Redis PubSub documentation&lt;/a&gt; for more details.</source>
          <target state="translated">Redis 어댑터를 사용하려면 사용자가 Redis 서버를 가리키는 URL을 제공해야합니다. 또한 여러 애플리케이션에 동일한 Redis 서버를 사용할 때 채널 이름 충돌을 피하기 위해 &lt;code&gt;channel_prefix&lt;/code&gt; 가 제공 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://redis.io/topics/pubsub#database-amp-scoping&quot;&gt;Redis PubSub 설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3c704b7ebbdeafd48ffdd5317faa6e6b92774c98" translate="yes" xml:space="preserve">
          <source>The Redis cache store takes advantage of Redis support for automatic eviction when it reaches max memory, allowing it to behave much like a Memcached cache server.</source>
          <target state="translated">Redis 캐시 저장소는 최대 메모리에 도달 할 때 자동 제거에 대한 Redis 지원을 활용하여 Memcached 캐시 서버와 매우 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="3afd49deda20ee111e85e89523cd5f862cb2d618" translate="yes" xml:space="preserve">
          <source>The Reloader also provides &lt;code&gt;to_run&lt;/code&gt; and &lt;code&gt;to_complete&lt;/code&gt; callbacks; they are invoked at the same points as those of the Executor, but only when the current execution has initiated an application reload. When no reload is deemed necessary, the Reloader will invoke the wrapped block with no other callbacks.</source>
          <target state="translated">리 로더는 또한 &lt;code&gt;to_run&lt;/code&gt; 및 &lt;code&gt;to_complete&lt;/code&gt; 콜백을 제공합니다 . 이들은 현재 실행이 응용 프로그램 재로드를 시작한 경우에만 Executor와 같은 지점에서 호출됩니다. 재로드가 필요하지 않은 것으로 간주되면 리 로더는 다른 콜백없이 래핑 된 블록을 호출합니다.</target>
        </trans-unit>
        <trans-unit id="27f7a0ffc99388b49237665de5ff68303700f136" translate="yes" xml:space="preserve">
          <source>The Reloader is only suitable where a long-running framework-level process repeatedly calls into application code, such as for a web server or job queue. Rails automatically wraps web requests and Active Job workers, so you'll rarely need to invoke the Reloader for yourself. Always consider whether the Executor is a better fit for your use case.</source>
          <target state="translated">Reloader는 장기 실행 프레임 워크 레벨 프로세스가 웹 서버 또는 작업 큐와 같은 애플리케이션 코드를 반복적으로 호출하는 경우에만 적합합니다. Rails는 자동으로 웹 요청과 활동 작업 작업자를 랩핑하므로 리 로더를 직접 호출 할 필요가 거의 없습니다. 집행자가 귀하의 사용 사례에 더 적합한 지 항상 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="c4920f22e9905615d85ce18cbe0e6bf2d8b790db" translate="yes" xml:space="preserve">
          <source>The Reloader only checks for file changes when &lt;code&gt;cache_classes&lt;/code&gt; is false and &lt;code&gt;reload_classes_only_on_change&lt;/code&gt; is true (which is the default in the &lt;code&gt;development&lt;/code&gt; environment).</source>
          <target state="translated">&lt;code&gt;reload_classes_only_on_change&lt;/code&gt; 는 &lt;code&gt;cache_classes&lt;/code&gt; 가 false이고 reload_classes_only_on_change 가 true ( &lt;code&gt;development&lt;/code&gt; 환경 의 기본값) 인 경우에만 파일 변경 사항을 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="3d92ef5461af56707e01485e0f7ae7d305f30718" translate="yes" xml:space="preserve">
          <source>The Request and Response Objects</source>
          <target state="translated">요청 및 응답 객체</target>
        </trans-unit>
        <trans-unit id="ac77713566ecac234db86f07a2d605d8bef7929a" translate="yes" xml:space="preserve">
          <source>The Ruby I18n (shorthand for &lt;em&gt;internationalization&lt;/em&gt;) gem which is shipped with Ruby on Rails (starting from Rails 2.2) provides an easy-to-use and extensible framework for &lt;strong&gt;translating your application to a single custom language&lt;/strong&gt; other than English or for &lt;strong&gt;providing multi-language support&lt;/strong&gt; in your application.</source>
          <target state="translated">루비 국제화 (속기 &lt;em&gt;국제화&lt;/em&gt; ) 루비 온 레일즈와 함께 제공되는 보석 (레일 2.2부터 시작)을 위해 사용하기 쉽고 확장 가능한 프레임 워크 제공 &lt;strong&gt;한 사용자 정의 언어로 응용 프로그램을 번역하는&lt;/strong&gt; 영어 이외의 나에 대한 &lt;strong&gt;다중 언어를 제공하는&lt;/strong&gt; 응용 프로그램에서 &lt;strong&gt;지원&lt;/strong&gt; 하십시오.</target>
        </trans-unit>
        <trans-unit id="42aacfdd276ea141df87aa8835afc941f3ccc4c6" translate="yes" xml:space="preserve">
          <source>The Ruby I18n framework provides you with all necessary means for internationalization/localization of your Rails application. You may, also use various gems available to add additional functionality or features. See the &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n&quot;&gt;rails-i18n gem&lt;/a&gt; for more information.</source>
          <target state="translated">Ruby I18n 프레임 워크는 Rails 애플리케이션의 국제화 / 현지화에 필요한 모든 수단을 제공합니다. 사용 가능한 다양한 보석을 사용하여 기능을 추가 할 수도 있습니다. 자세한 내용은 &lt;a href=&quot;https://github.com/svenfuchs/rails-i18n&quot;&gt;rails-i18n gem&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8e337110e0c683f629e6bb18b30ce5e3b59cc397" translate="yes" xml:space="preserve">
          <source>The Ruby side of things is built on top of &lt;a href=&quot;https://github.com/faye/websocket-driver-ruby&quot;&gt;websocket-driver&lt;/a&gt;, &lt;a href=&quot;https://github.com/celluloid/nio4r&quot;&gt;nio4r&lt;/a&gt;, and &lt;a href=&quot;https://github.com/ruby-concurrency/concurrent-ruby&quot;&gt;concurrent-ruby&lt;/a&gt;.</source>
          <target state="translated">사물의 루비 쪽은 &lt;a href=&quot;https://github.com/faye/websocket-driver-ruby&quot;&gt;websocket-driver&lt;/a&gt; , &lt;a href=&quot;https://github.com/celluloid/nio4r&quot;&gt;nio4r&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/ruby-concurrency/concurrent-ruby&quot;&gt;동시 루비&lt;/a&gt; 위에 구축됩니다 .</target>
        </trans-unit>
        <trans-unit id="6b6723a4f8c0d953e73e03aae1b14fc27c7512db" translate="yes" xml:space="preserve">
          <source>The SQL block comment delimiters, &amp;ldquo;/*&amp;rdquo; and &amp;ldquo;*/&amp;rdquo;, will be added automatically.</source>
          <target state="translated">SQL 블록 주석 분리 문자&amp;ldquo;/ *&amp;rdquo;및&amp;ldquo;* /&amp;rdquo;가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a3ff3f0c959e89d4d9826baccc445991894a616c" translate="yes" xml:space="preserve">
          <source>The SQL equivalent of the above is:</source>
          <target state="translated">위와 동등한 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="48ee3db9f90bca3492f769cd0e217a07c48877b5" translate="yes" xml:space="preserve">
          <source>The SQL generated by this method looks like this:</source>
          <target state="translated">이 방법으로 생성 된 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c52f2acac81f8672d8952a4c611589f1d6d04f3" translate="yes" xml:space="preserve">
          <source>The SQL query used by this find call will be somewhat like:</source>
          <target state="translated">이 찾기 호출에서 사용되는 SQL 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ec1b1bcef208ca24dd0a059757079680286748f" translate="yes" xml:space="preserve">
          <source>The SQL standard says the default scale should be 0, &lt;code&gt;:scale&lt;/code&gt; &amp;lt;= &lt;code&gt;:precision&lt;/code&gt;, and makes no comments about the requirements of &lt;code&gt;:precision&lt;/code&gt;.</source>
          <target state="translated">표준 SQL 기본 스케일은 0이어야한다 말한다 &lt;code&gt;:scale&lt;/code&gt; &amp;lt;= &lt;code&gt;:precision&lt;/code&gt; , 그리고 요구 사항에 대해 언급하지 않습니다 &lt;code&gt;:precision&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82f607296c32433c4cb7befd9993fe8cccfea80b" translate="yes" xml:space="preserve">
          <source>The SQL that would be executed would be something like this:</source>
          <target state="translated">실행될 SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1f6c9e636ac2a9f9ff0f0206994c40e67707fdf" translate="yes" xml:space="preserve">
          <source>The SQL that would be executed:</source>
          <target state="translated">실행될 SQL :</target>
        </trans-unit>
        <trans-unit id="8143ba5cf6e9b775e16dedc348918b2663c90343" translate="yes" xml:space="preserve">
          <source>The SQLite3 adapter works SQLite 3.6.16 or newer with the sqlite3-ruby drivers (available as gem from &lt;a href=&quot;https://rubygems.org/gems/sqlite3&quot;&gt;rubygems.org/gems/sqlite3&lt;/a&gt;).</source>
          <target state="translated">SQLite3 어댑터는 sqlite3-ruby 드라이버 ( &lt;a href=&quot;https://rubygems.org/gems/sqlite3&quot;&gt;rubygems.org/gems/sqlite3&lt;/a&gt; 에서 gem으로 사용 가능)와 함께 SQLite 3.6.16 이상을 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="e8f7e80a80f6468d8f9ae5d5de949af73d120a75" translate="yes" xml:space="preserve">
          <source>The SanitizeHelper module provides a set of methods for scrubbing text of undesired HTML elements.</source>
          <target state="translated">SanitizeHelper 모듈은 원하지 않는 HTML 요소의 텍스트를 스크러빙하기위한 일련의 메소드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="69b4e4cb76edfd97771ce996cb3f21bee81207c1" translate="yes" xml:space="preserve">
          <source>The Select and Option Tags</source>
          <target state="translated">선택 및 옵션 태그</target>
        </trans-unit>
        <trans-unit id="fd5aaa349d586181e9c831d5189a8981895b58d8" translate="yes" xml:space="preserve">
          <source>The Shell</source>
          <target state="translated">껍질</target>
        </trans-unit>
        <trans-unit id="ccd5038386b0375e4cca123c96f2d46e26ad35c9" translate="yes" xml:space="preserve">
          <source>The Simple backend shipped with Active Support allows you to store translations in both plain Ruby and YAML format.&lt;sup id=&quot;footnote-2-ref&quot;&gt;&lt;a href=&quot;#footnote-2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Active Support와 함께 제공되는 단순 백엔드는 일반 Ruby 및 YAML 형식으로 번역을 저장할 수 있습니다. &lt;sup id=&quot;footnote-2-ref&quot;&gt;&lt;a href=&quot;#footnote-2&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="44f540d6a81a77dfe961b48b208b2e50861d6943" translate="yes" xml:space="preserve">
          <source>The Test Database</source>
          <target state="translated">테스트 데이터베이스</target>
        </trans-unit>
        <trans-unit id="4551ad2147cfbe96a34eb24767274883e46642f9" translate="yes" xml:space="preserve">
          <source>The Test Environment</source>
          <target state="translated">테스트 환경</target>
        </trans-unit>
        <trans-unit id="7b8b577799c7cd20afbbb4c696c99be3f86d5986" translate="yes" xml:space="preserve">
          <source>The Three Hashes of the Apocalypse</source>
          <target state="translated">묵시록의 세 가지 해시</target>
        </trans-unit>
        <trans-unit id="074d2bba09f66b0ffbe5affc5c1d5beed0e1ee24" translate="yes" xml:space="preserve">
          <source>The Turbolinks gem.</source>
          <target state="translated">터보 링크 보석.</target>
        </trans-unit>
        <trans-unit id="889fe8495df2cc2ff8ba2185e5e0df25779c0bf2" translate="yes" xml:space="preserve">
          <source>The Types of Associations</source>
          <target state="translated">협회의 유형</target>
        </trans-unit>
        <trans-unit id="118d27c20bdd84af2faa31057e475c43ad77fd11" translate="yes" xml:space="preserve">
          <source>The UNION statement connects two SQL queries and returns the data in one set. An attacker can use it to read arbitrary data from the database. Let's take the example from above:</source>
          <target state="translated">UNION 문은 두 개의 SQL 쿼리를 연결하고 한 세트의 데이터를 반환합니다. 침입자는이를 사용하여 데이터베이스에서 임의의 데이터를 읽을 수 있습니다. 위에서 예제를 보자.</target>
        </trans-unit>
        <trans-unit id="c67be5b4a37fd08a53752aa322ac424ca3d80813" translate="yes" xml:space="preserve">
          <source>The URI of the controller action you are requesting. This can be in the form of a string or a route helper (e.g. &lt;code&gt;articles_url&lt;/code&gt;).</source>
          <target state="translated">요청한 컨트롤러 작업의 URI입니다. 문자열 또는 경로 도우미 형식 일 수 있습니다 (예 : &lt;code&gt;articles_url&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1a09ce01af578355210f828c8be6872f13ef3ec2" translate="yes" xml:space="preserve">
          <source>The URL pattern to match</source>
          <target state="translated">일치하는 URL 패턴</target>
        </trans-unit>
        <trans-unit id="224ff9feebc0dca5825aaec3ef51c1cbb6fd7b32" translate="yes" xml:space="preserve">
          <source>The URL the client is being redirected to, if any.</source>
          <target state="translated">클라이언트가 리디렉션되는 URL입니다 (있는 경우).</target>
        </trans-unit>
        <trans-unit id="30bc92ff4cc52c0f2fe25a6261b7a8aa165e6769" translate="yes" xml:space="preserve">
          <source>The URL will be http://localhost:3000/greetings/hello.</source>
          <target state="translated">URL은 http : // localhost : 3000 / greetings / hello입니다.</target>
        </trans-unit>
        <trans-unit id="7e2c09e26eec62441ea0fb0a75f4fa90c6807fb2" translate="yes" xml:space="preserve">
          <source>The Update Task</source>
          <target state="translated">업데이트 작업</target>
        </trans-unit>
        <trans-unit id="e66d0a1d165c09f974cce4589624585a59b072f3" translate="yes" xml:space="preserve">
          <source>The Upgrade Process</source>
          <target state="translated">업그레이드 과정</target>
        </trans-unit>
        <trans-unit id="ee6880520f2ade45dd630ac080bcb6b84b14bdab" translate="yes" xml:space="preserve">
          <source>The WebSocket server doesn't have access to the session, but it has access to the cookies. This can be used when you need to handle authentication. You can see one way of doing that with Devise in this &lt;a href=&quot;https://greg.molnar.io/blog/actioncable-devise-authentication/&quot;&gt;article&lt;/a&gt;.</source>
          <target state="translated">WebSocket 서버는 세션에 액세스 할 수 없지만 쿠키에는 액세스 할 수 있습니다. 인증을 처리해야 할 때 사용할 수 있습니다. 이 &lt;a href=&quot;https://greg.molnar.io/blog/actioncable-devise-authentication/&quot;&gt;기사&lt;/a&gt; 에서 Devise를 사용하여 한 가지 방법을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4d90a33c3b15a9fe985897b10c527204739b11d6" translate="yes" xml:space="preserve">
          <source>The X-Sendfile header is a directive to the web server to ignore the response from the application, and instead serve a specified file from disk. This option is off by default, but can be enabled if your server supports it. When enabled, this passes responsibility for serving the file to the web server, which is faster. Have a look at &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/DataStreaming.html#method-i-send_file&quot;&gt;send_file&lt;/a&gt; on how to use this feature.</source>
          <target state="translated">X-Sendfile 헤더는 응용 프로그램의 응답을 무시하고 대신 디스크에서 지정된 파일을 제공하도록 웹 서버에 대한 지시문입니다. 이 옵션은 기본적으로 해제되어 있지만 서버에서 지원하는 경우 활성화 할 수 있습니다. 활성화되면 파일을 웹 서버에 제공하는 책임이 더 빠릅니다. 한 번 봐 가지고 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/DataStreaming.html#method-i-send_file&quot;&gt;send_file&lt;/a&gt; 이 기능을 사용하는 방법에 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2e6b86fdb23fbddf5d458a1e31cd113b26be790" translate="yes" xml:space="preserve">
          <source>The XML serializer of models uses this method to dasherize node names:</source>
          <target state="translated">모델의 XML serializer는이 방법을 사용하여 노드 이름을 대시합니다.</target>
        </trans-unit>
        <trans-unit id="4d4d9cc06a5435e5a861665944f1af59ae407b13" translate="yes" xml:space="preserve">
          <source>The Zeitwerk instances managing your application are available at</source>
          <target state="translated">애플리케이션을 관리하는 Zeitwerk 인스턴스는</target>
        </trans-unit>
        <trans-unit id="99d7379157f8fd9c44a683315c173317d4abe69d" translate="yes" xml:space="preserve">
          <source>The `&amp;ldquo;%{attribute} %{message}&amp;rdquo;` error format can be overridden with either</source>
          <target state="translated">'% {attribute} % {message}'오류 형식은 다음 중 하나로 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac7566800fde6c78d2fde9cdc964d45f3dba592" translate="yes" xml:space="preserve">
          <source>The ability to access a params hash.</source>
          <target state="translated">params hash에 액세스하는 기능</target>
        </trans-unit>
        <trans-unit id="99a9c260613085a62b40ef65baea6234d501c155" translate="yes" xml:space="preserve">
          <source>The ability to utilise layouts and partials.</source>
          <target state="translated">레이아웃과 부분을 활용하는 기능.</target>
        </trans-unit>
        <trans-unit id="9299e4fd9a1abfa8cd0b3397ccd93dbb30b79799" translate="yes" xml:space="preserve">
          <source>The above allows you to do:</source>
          <target state="translated">위의 방법으로 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f7f61b78ae6248f37388b0ba18d1c9a120df9947" translate="yes" xml:space="preserve">
          <source>The above are a subset of assertions that minitest supports. For an exhaustive &amp;amp; more up-to-date list, please check &lt;a href=&quot;http://docs.seattlerb.org/minitest/&quot;&gt;Minitest API documentation&lt;/a&gt;, specifically &lt;a href=&quot;http://docs.seattlerb.org/minitest/Minitest/Assertions.html&quot;&gt;&lt;code&gt;Minitest::Assertions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">위의 내용은 최소한의 지원을 제공하는 주장의 일부입니다. 전체 목록과 최신 목록을 보려면 &lt;a href=&quot;http://docs.seattlerb.org/minitest/&quot;&gt;Minitest API documentation&lt;/a&gt; , 특히 &lt;a href=&quot;http://docs.seattlerb.org/minitest/Minitest/Assertions.html&quot;&gt; &lt;code&gt;Minitest::Assertions&lt;/code&gt; &lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e96c640d214ad6ce3629349ac57901dd79560eba" translate="yes" xml:space="preserve">
          <source>The above are the entry points to the framework, so they are responsible for ensuring their respective threads are protected, and deciding whether a reload is necessary. Other components only need to use the Executor when they spawn additional threads.</source>
          <target state="translated">위의 내용은 프레임 워크의 진입 점이므로 각 스레드를 보호하고 재로드가 필요한지 여부를 결정해야합니다. 다른 구성 요소는 추가 스레드를 생성 할 때 Executor 만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5aeaeb2946270f1ca3880251f48504cd2adb8b8b" translate="yes" xml:space="preserve">
          <source>The above calls to &lt;a href=&quot;classmethods#method-i-scope&quot;&gt;scope&lt;/a&gt; define class methods &lt;code&gt;Shirt.red&lt;/code&gt; and &lt;code&gt;Shirt.dry_clean_only&lt;/code&gt;. &lt;code&gt;Shirt.red&lt;/code&gt;, in effect, represents the query &lt;code&gt;Shirt.where(color: 'red')&lt;/code&gt;.</source>
          <target state="translated">위의 &lt;a href=&quot;classmethods#method-i-scope&quot;&gt;범위&lt;/a&gt; 호출 은 클래스 메소드 &lt;code&gt;Shirt.red&lt;/code&gt; 및 &lt;code&gt;Shirt.dry_clean_only&lt;/code&gt; 를 정의 합니다. &lt;code&gt;Shirt.red&lt;/code&gt; 는 &lt;code&gt;Shirt.where(color: 'red')&lt;/code&gt; 쿼리를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="333dc05e53733069b4c66544cc0447cb09af75f4" translate="yes" xml:space="preserve">
          <source>The above code creates a new method &lt;code&gt;div_radio_button&lt;/code&gt; which wraps a div around the new radio button. Note that when options are passed in, you must call &lt;code&gt;objectify_options&lt;/code&gt; in order for the model object to get correctly passed to the method. If &lt;code&gt;objectify_options&lt;/code&gt; is not called, then the newly created helper will not be linked back to the model.</source>
          <target state="translated">위의 코드 는 새로운 라디오 버튼 주위에 div를 감싸는 새로운 메소드 &lt;code&gt;div_radio_button&lt;/code&gt; 을 만듭니다 . 옵션이 전달 될 때 모델 객체가 메소드에 올바르게 전달 되려면 &lt;code&gt;objectify_options&lt;/code&gt; 를 호출해야합니다 . 경우 &lt;code&gt;objectify_options&lt;/code&gt; 가 호출되지 않습니다, 다음 새로 만든 도우미 다시 모델에 연결되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d46ac95b0d8d36f9261f2a5ca369c3866c13669" translate="yes" xml:space="preserve">
          <source>The above code sends the next line only after the singer has completed the previous line.</source>
          <target state="translated">위 코드는 가수가 이전 줄을 완료 한 후에 만 ​​다음 줄을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="803eb105f9f7cbc0c7e4e1643e3cb6b23529dfb8" translate="yes" xml:space="preserve">
          <source>The above code will execute just &lt;strong&gt;2&lt;/strong&gt; queries, as opposed to &lt;strong&gt;11&lt;/strong&gt; queries in the previous case:</source>
          <target state="translated">위의 코드는 이전의 경우 &lt;strong&gt;11 개의&lt;/strong&gt; 쿼리 와 달리 &lt;strong&gt;2 개의&lt;/strong&gt; 쿼리 만 실행 합니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8cd4efb617a7fc9e41e0c91d777b42961eaabd0a" translate="yes" xml:space="preserve">
          <source>The above code will keep a persistent connection with the browser and send 100 messages of &lt;code&gt;&quot;hello world\n&quot;&lt;/code&gt;, each one second apart.</source>
          <target state="translated">위의 코드는 브라우저와 지속적으로 연결되어 있으며 1 초 간격 으로 &lt;code&gt;&quot;hello world\n&quot;&lt;/code&gt; 메시지를 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="06ed41b8974172e2024fe67cddd4885b67fed26a" translate="yes" xml:space="preserve">
          <source>The above code will load all the comments and all of their associated authors and gravatars. You can mix and match any combination of symbols, arrays, and hashes to retrieve the associations you want to load.</source>
          <target state="translated">위의 코드는 모든 주석과 관련 작성자 및 그라바타를 모두로드합니다. 심볼, 배열 및 해시의 조합을 혼합하여 일치시키려는로드를 연관시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5008900696401673bf09ac6edc201e88c7f704eb" translate="yes" xml:space="preserve">
          <source>The above code will put the following line into &lt;code&gt;Gemfile&lt;/code&gt;:</source>
          <target state="translated">위의 코드는 다음 줄을 &lt;code&gt;Gemfile&lt;/code&gt; 에 넣 습니다 .</target>
        </trans-unit>
        <trans-unit id="f3cfad1c129d3cb4168ebeef7de404377a78ae6b" translate="yes" xml:space="preserve">
          <source>The above code will render something like this:</source>
          <target state="translated">위의 코드는 다음과 같이 렌더링됩니다.</target>
        </trans-unit>
        <trans-unit id="cda7b27130cd0d8392911a7c1b552935b99feae1" translate="yes" xml:space="preserve">
          <source>The above command creates a new root object and adds &amp;ldquo;app/controllers&amp;rdquo; as a path. This means we can get a &lt;code&gt;Rails::Paths::Path&lt;/code&gt; object back like below:</source>
          <target state="translated">위 명령은 새로운 루트 객체를 생성하고&amp;ldquo;앱 / 컨트롤러&amp;rdquo;를 경로로 추가합니다. 즉, 아래와 같이 &lt;code&gt;Rails::Paths::Path&lt;/code&gt; 객체를 다시 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21adbcdcc9c588834a54ae91663e685f9573a361" translate="yes" xml:space="preserve">
          <source>The above creates &lt;code&gt;lib/tasks/bootstrap.rake&lt;/code&gt; with a &lt;code&gt;boot:strap&lt;/code&gt; rake task.</source>
          <target state="translated">위의 내용은 &lt;code&gt;boot:strap&lt;/code&gt; 레이크 작업으로 &lt;code&gt;lib/tasks/bootstrap.rake&lt;/code&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="9b2052de2e0ef8a9f9937a0b6634c8b93020776e" translate="yes" xml:space="preserve">
          <source>The above example will now change /posts/new to /posts/brand_new.</source>
          <target state="translated">위의 예는 이제 / posts / new를 / posts / brand_new로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="c40abd9828061ab6077a0eac3687cfc218a726b6" translate="yes" xml:space="preserve">
          <source>The above inputs would result in &lt;code&gt;params[:start_date]&lt;/code&gt; being a hash with keys &lt;code&gt;:year&lt;/code&gt;, &lt;code&gt;:month&lt;/code&gt;, &lt;code&gt;:day&lt;/code&gt;. To get an actual &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, or &lt;code&gt;DateTime&lt;/code&gt; object you would have to extract these values and pass them to the appropriate constructor, for example:</source>
          <target state="translated">위의 입력은 &lt;code&gt;params[:start_date]&lt;/code&gt; 가 키가 &lt;code&gt;:year&lt;/code&gt; , &lt;code&gt;:month&lt;/code&gt; , &lt;code&gt;:day&lt;/code&gt; 인 해시 입니다 . 실제 &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; 또는 &lt;code&gt;DateTime&lt;/code&gt; 객체 를 얻으려면 이러한 값을 추출하여 적절한 생성자에 전달해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66cda868f6fc20fd14d5b7af309fe1788514078b" translate="yes" xml:space="preserve">
          <source>The above is equivalent to:</source>
          <target state="translated">위의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9b11b94e39c8ebd45d8aa9d1e8b8fa0034a1b4bd" translate="yes" xml:space="preserve">
          <source>The above method can be placed in the &lt;code&gt;ApplicationController&lt;/code&gt; and will be called when a CSRF token is not present or is incorrect on a non-GET request.</source>
          <target state="translated">위의 메소드는 &lt;code&gt;ApplicationController&lt;/code&gt; 에 위치 할 수 있으며 비 GET 요청에서 CSRF 토큰이 없거나 올바르지 않은 경우 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="084842552bdf468007e85432716d1181acbd4e51" translate="yes" xml:space="preserve">
          <source>The above migration creates a method named &lt;code&gt;change&lt;/code&gt; which will be called when you run this migration. The action defined in this method is also reversible, which means Rails knows how to reverse the change made by this migration, in case you want to reverse it later. When you run this migration it will create an &lt;code&gt;articles&lt;/code&gt; table with one string column and a text column. It also creates two timestamp fields to allow Rails to track article creation and update times.</source>
          <target state="translated">위의 마이그레이션은 이 마이그레이션을 실행할 때 호출되는 &lt;code&gt;change&lt;/code&gt; 라는 메서드를 만듭니다 . 이 방법으로 정의 된 작업도 되돌릴 수 있습니다. 이는 나중에 변경하려는 경우를 대비하여 Rails가이 마이그레이션으로 변경 한 사항을 되 돌리는 방법을 알고 있음을 의미합니다. 이 마이그레이션을 실행하면 하나의 문자열 열과 텍스트 열이 있는 &lt;code&gt;articles&lt;/code&gt; 테이블 이 생성 됩니다. 또한 Rails가 기사 생성 및 업데이트 시간을 추적 할 수 있도록 두 개의 타임 스탬프 필드를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="2081bff9ce4c1de0f2a3baa9acaa7e3aa193a443" translate="yes" xml:space="preserve">
          <source>The above returns &lt;code&gt;false&lt;/code&gt; if the &lt;code&gt;clients&lt;/code&gt; table is empty and &lt;code&gt;true&lt;/code&gt; otherwise.</source>
          <target state="translated">위의 경우 &lt;code&gt;clients&lt;/code&gt; 테이블이 비어 있으면 &lt;code&gt;false&lt;/code&gt; 를, 그렇지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87a2259ed564f17322e9e93ec92fc820ba4abdaa" translate="yes" xml:space="preserve">
          <source>The above returns &lt;code&gt;true&lt;/code&gt; if there is at least one client with the &lt;code&gt;first_name&lt;/code&gt; 'Ryan' and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">위의 내용은 &lt;code&gt;first_name&lt;/code&gt; 이 'Ryan'인 클라이언트가 하나 이상 있으면 &lt;code&gt;true&lt;/code&gt; 를 , 그렇지 않으면 &lt;code&gt;false&lt;/code&gt; 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="741a44e0eadfb12bb82ba1bc8ee02c6ee7e16594" translate="yes" xml:space="preserve">
          <source>The above session produces the following SQL for a MySQL backend:</source>
          <target state="translated">위 세션은 MySQL 백엔드에 대해 다음 SQL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="eb79507ca343976d6fe284ecb89e3baf8c55aa6c" translate="yes" xml:space="preserve">
          <source>The above should generate:</source>
          <target state="translated">위의 내용은 다음을 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="a7d55be777d62e8c226bb4dc4fa51a123043fd58" translate="yes" xml:space="preserve">
          <source>The above three ways of rendering (rendering another template within the controller, rendering a template within another controller, and rendering an arbitrary file on the file system) are actually variants of the same action.</source>
          <target state="translated">위의 세 가지 렌더링 방법 (컨트롤러 내에서 다른 템플릿 렌더링, 다른 컨트롤러 내에서 템플릿 렌더링 및 파일 시스템에서 임의의 파일 렌더링)은 실제로 동일한 동작의 변형입니다.</target>
        </trans-unit>
        <trans-unit id="4a2c5591869abf4b65b38276a779f93ca75e3f8b" translate="yes" xml:space="preserve">
          <source>The above will start a cable server on port 28080.</source>
          <target state="translated">위는 포트 28080에서 케이블 서버를 시작합니다.</target>
        </trans-unit>
        <trans-unit id="4718acd5158219e392bc97351223f6f32d152dcf" translate="yes" xml:space="preserve">
          <source>The acronym, however, must occur as a delimited unit and not be part of another word for conversions to recognize it:</source>
          <target state="translated">그러나 약어는 구분 된 단위로 나타나야하며 변환에서 인식 할 수있는 다른 단어의 일부가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="4dfee46b00dea4df8ec13bc55371a4aa2ff5b5f8" translate="yes" xml:space="preserve">
          <source>The action</source>
          <target state="translated">행동</target>
        </trans-unit>
        <trans-unit id="c8a70bf93b527ef8019fa644660d5f525054e6c7" translate="yes" xml:space="preserve">
          <source>The actual URL in this example will be encoded as &quot;/clients?ids%5b%5d=1&amp;amp;ids%5b%5d=2&amp;amp;ids%5b%5d=3&quot; as the &quot;[&quot; and &quot;]&quot; characters are not allowed in URLs. Most of the time you don't have to worry about this because the browser will encode it for you, and Rails will decode it automatically, but if you ever find yourself having to send those requests to the server manually you should keep this in mind.</source>
          <target state="translated">이 예에서 실제 URL은 &quot;/&quot;및 &quot;]&quot;문자가 URL에 허용되지 않으므로 &quot;/ clients? ids % 5b % 5d = 1 &amp;amp; ids % 5b % 5d = 2 &amp;amp; ids % 5b % 5d = 3&quot;로 인코딩됩니다. 브라우저가 자동으로 인코딩하고 Rails가 자동으로 디코딩하기 때문에 걱정할 필요가 없습니다. 그러나 수동으로 요청을 서버로 보내야하는 경우에는이를 명심해야합니다. .</target>
        </trans-unit>
        <trans-unit id="0bc31e7fe5c26aa453e3b9b806025004a0d38777" translate="yes" xml:space="preserve">
          <source>The actual action names aren't changed by this option. The two paths shown would still route to the &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;edit&lt;/code&gt; actions.</source>
          <target state="translated">실제 작업 이름은이 옵션으로 변경되지 않습니다. 표시된 두 경로는 여전히 &lt;code&gt;new&lt;/code&gt; 작업 및 &lt;code&gt;edit&lt;/code&gt; 작업으로 라우팅됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c8f767e536a7eab6c28a28ee958f2354a95ab65" translate="yes" xml:space="preserve">
          <source>The actual before_action that is used to verify the CSRF token. Don't override this directly. Provide your own forgery protection strategy instead. If you override, you'll disable same-origin &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; verification.</source>
          <target state="translated">CSRF 토큰을 확인하는 데 사용되는 실제 before_action. 이것을 직접 무시하지 마십시오. 대신 자신의 위조 방지 전략을 제공하십시오. 재정의하면 동일 출처 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 확인 이 사용 중지 됩니다.</target>
        </trans-unit>
        <trans-unit id="d3421f7b3e0e5c676942813e39ba280bb8ec3251" translate="yes" xml:space="preserve">
          <source>The actual file is accessible via the &lt;code&gt;tempfile&lt;/code&gt; accessor, though some of its interface is available directly for convenience.</source>
          <target state="translated">실제 파일은 &lt;code&gt;tempfile&lt;/code&gt; 파일 접근 자를 통해 액세스 할 수 있지만 일부 인터페이스는 편의를 위해 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d860e48de9b9205aa74ce3904d07501023b838f" translate="yes" xml:space="preserve">
          <source>The actual incineration is done via the &lt;code&gt;IncinerationJob&lt;/code&gt; that's scheduled to run after &lt;code&gt;config.action_mailbox.incinerate_after&lt;/code&gt; time. This value is by default set to &lt;code&gt;30.days&lt;/code&gt;, but you can change it in your production.rb configuration. (Note that this far-future incineration scheduling relies on your job queue being able to hold jobs for that long.)</source>
          <target state="translated">실제 소각은 &lt;code&gt;config.action_mailbox.incinerate_after&lt;/code&gt; 시간 이후에 예정된 &lt;code&gt;IncinerationJob&lt;/code&gt; 을 통해 수행됩니다 . 이 값은 기본적으로 &lt;code&gt;30.days&lt;/code&gt; 로 설정 되지만 production.rb 구성에서 변경할 수 있습니다. (이 장래의 소각 일정은 작업 대기열을 오랫동안 보유 할 수있는 작업 대기열에 의존합니다.)</target>
        </trans-unit>
        <trans-unit id="b535db32f4b8e6c49f06a143c6d9848467dd2543" translate="yes" xml:space="preserve">
          <source>The actual method that is called is determined by calling method_for_action. If no method can handle the action, then an &lt;a href=&quot;actionnotfound&quot;&gt;AbstractController::ActionNotFound&lt;/a&gt; error is raised.</source>
          <target state="translated">호출되는 실제 메소드는 method_for_action을 호출하여 결정됩니다. 메소드가 조치를 처리 할 수없는 경우 &lt;a href=&quot;actionnotfound&quot;&gt;AbstractController :: ActionNotFound&lt;/a&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a63053bbf82b11790da7704223ce0765d21dc88" translate="yes" xml:space="preserve">
          <source>The actual rendering is done by nested classes of the module &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Template/Handlers.html&quot;&gt;&lt;code&gt;ActionView::Template::Handlers&lt;/code&gt;&lt;/a&gt;. This guide does not dig into that process, but it's important to know that the file extension on your view controls the choice of template handler.</source>
          <target state="translated">실제 렌더링은 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Template/Handlers.html&quot;&gt; &lt;code&gt;ActionView::Template::Handlers&lt;/code&gt; &lt;/a&gt; 모듈의 중첩 클래스에 의해 수행됩니다 . 이 가이드는 해당 프로세스를 다루지는 않지만 뷰의 파일 확장자가 템플릿 처리기의 선택을 제어한다는 것을 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="2eace6d8c317af052d4a9ce36f70996f4f18477c" translate="yes" xml:space="preserve">
          <source>The adapter does not support setting the isolation level</source>
          <target state="translated">어댑터가 분리 레벨 설정을 지원하지 않습니다</target>
        </trans-unit>
        <trans-unit id="f58fae5bb8a41020e3e5cc9b2cc0494b730cb5f4" translate="yes" xml:space="preserve">
          <source>The adapter uses a &lt;a href=&quot;https://github.com/ruby-concurrency/concurrent-ruby&quot;&gt;Concurrent Ruby&lt;/a&gt; thread pool to schedule and execute jobs. Since jobs share a single thread pool, long-running jobs will block short-lived jobs. Fine for dev/test; bad for production.</source>
          <target state="translated">어댑터는 &lt;a href=&quot;https://github.com/ruby-concurrency/concurrent-ruby&quot;&gt;동시 Ruby&lt;/a&gt; 스레드 풀을 사용하여 작업을 스케줄하고 실행합니다. 작업은 단일 스레드 풀을 공유하므로 장기 실행 작업은 단기 작업을 차단합니다. 개발 / 테스트에 적합; 생산에 나쁘다.</target>
        </trans-unit>
        <trans-unit id="5ed49990b114649e9cf864cab935d54f830e410f" translate="yes" xml:space="preserve">
          <source>The adapters will add their own data as well.</source>
          <target state="translated">어댑터는 자체 데이터도 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f8d0cf85bdd1178136b864d2a0322afc33f58b8d" translate="yes" xml:space="preserve">
          <source>The added &lt;code&gt;password_confirmation&lt;/code&gt; attribute is virtual; it exists only as an in-memory attribute for validating the password. To achieve this, the validation adds accessors to the model for the confirmation attribute.</source>
          <target state="translated">추가 된 &lt;code&gt;password_confirmation&lt;/code&gt; 속성은 virtual입니다. 암호를 확인하기위한 메모리 내 속성으로 만 존재합니다. 이를 위해 유효성 검사는 확인 속성에 대한 접근자를 모델에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="9cbba5c44f15bf44eb1bb7c847d1598bf89ac630" translate="yes" xml:space="preserve">
          <source>The advantage of Russian doll caching is that if a single product is updated, all the other inner fragments can be reused when regenerating the outer fragment.</source>
          <target state="translated">러시아 인형 캐싱의 장점은 단일 제품이 업데이트되면 외부 조각을 재생성 할 때 다른 모든 내부 조각을 재사용 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7508b7e3879dc7eed43e6755794e11a2266cc714" translate="yes" xml:space="preserve">
          <source>The algorithm for pluralizations in &lt;code&gt;:en&lt;/code&gt; is as simple as:</source>
          <target state="translated">&lt;code&gt;:en&lt;/code&gt; 의 복수화 알고리즘은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="d95f184af6a22fac572c69661f48cdfc6fc482d3" translate="yes" xml:space="preserve">
          <source>The answer is that it is assumed that deletion on an association is about removing the &lt;em&gt;link&lt;/em&gt; between the owner and the associated object(s), rather than necessarily the associated objects themselves. So with &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; and &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;&lt;code&gt;:through&lt;/code&gt;, the join records will be deleted, but the associated records won't.</source>
          <target state="translated">답은 연관을 삭제 하는 것이 반드시 연관된 오브젝트 자체가 아니라 소유자와 연관된 오브젝트 사이의 &lt;em&gt;링크&lt;/em&gt; 를 제거하는 것이라고 가정합니다 . 따라서 &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; 및 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many &lt;/a&gt; &lt;code&gt;:through&lt;/code&gt; 를 사용하면 결합 레코드는 삭제되지만 관련 레코드는 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="353bd424fd13e095ac75fc42f9927d735d0d1c2f" translate="yes" xml:space="preserve">
          <source>The appearance example was all about exposing server functionality to client-side invocation over the WebSocket connection. But the great thing about WebSockets is that it's a two-way street. So now let's show an example where the server invokes an action on the client.</source>
          <target state="translated">모양 예제는 WebSocket 연결을 통해 서버 기능을 클라이언트 측 호출에 노출시키는 것입니다. 그러나 WebSockets의 장점은 양방향 거리라는 것입니다. 이제 서버가 클라이언트에서 작업을 호출하는 예를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="8fde979a35183a10d65ad95dba16fa9e6c002a01" translate="yes" xml:space="preserve">
          <source>The application is also responsible for setting up and executing the booting process. From the moment you require &amp;ldquo;config/application.rb&amp;rdquo; in your app, the booting process goes like this:</source>
          <target state="translated">응용 프로그램은 부팅 프로세스를 설정하고 실행하는 역할도합니다. 앱에&amp;ldquo;config / application.rb&amp;rdquo;가 필요한 순간부터 부팅 프로세스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3d0a1ecb7f1256fe4d16764400ce4d4d5314c359" translate="yes" xml:space="preserve">
          <source>The application object is also responsible for holding the routes and reloading routes whenever the files change in development.</source>
          <target state="translated">응용 프로그램 객체는 또한 파일이 개발 중에 변경 될 때마다 경로를 유지하고 경로를 다시로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="d6a741da9207ca1806a38069676ef5f5dd1bcfc7" translate="yes" xml:space="preserve">
          <source>The application template is evaluated in the context of a &lt;code&gt;Rails::Generators::AppGenerator&lt;/code&gt; instance. It uses the &lt;code&gt;apply&lt;/code&gt; action provided by &lt;a href=&quot;https://github.com/erikhuda/thor/blob/master/lib/thor/actions.rb#L207&quot;&gt;Thor&lt;/a&gt;. This means you can extend and change the instance to match your needs.</source>
          <target state="translated">애플리케이션 템플릿은 &lt;code&gt;Rails::Generators::AppGenerator&lt;/code&gt; 인스턴스 의 컨텍스트에서 평가됩니다 . &lt;a href=&quot;https://github.com/erikhuda/thor/blob/master/lib/thor/actions.rb#L207&quot;&gt;Thor에서&lt;/a&gt; 제공 하는 &lt;code&gt;apply&lt;/code&gt; 조치를 사용합니다 . 즉, 필요에 따라 인스턴스를 확장하고 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57608d3d8a63da3b4eeb802f9cffbdf520f3d3af" translate="yes" xml:space="preserve">
          <source>The argument &lt;em&gt;n&lt;/em&gt; specifies the length of the random string to be generated.</source>
          <target state="translated">인수 &lt;em&gt;n&lt;/em&gt; 은 생성 될 무작위 문자열의 길이를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="a5de69b46e606eb78424a600549646ba791e34a5" translate="yes" xml:space="preserve">
          <source>The argument can be either an &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; or a regular &lt;code&gt;Hash&lt;/code&gt;. In either case the merge respects the semantics of indifferent access.</source>
          <target state="translated">인수는 &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; 또는 일반 &lt;code&gt;Hash&lt;/code&gt; 일 수 있습니다. 두 경우 모두 병합은 무관 한 액세스의 의미를 존중합니다.</target>
        </trans-unit>
        <trans-unit id="5c30784dd868d0b2a3de1d8c041fd8b543b7be28" translate="yes" xml:space="preserve">
          <source>The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and check box for the current item in the collection, with proper text and value. Using it, you can change the label and check box display order or even use the label as wrapper, as in the example above.</source>
          <target state="translated">블록에 전달 된 인수는이 컬렉션에 대한 특수한 종류의 빌더이며, 적절한 텍스트와 값을 사용하여 컬렉션의 현재 항목에 대한 레이블과 확인란을 생성 할 수 있습니다. 이를 사용하면 위의 예와 같이 레이블 및 확인란 표시 순서를 변경하거나 레이블을 래퍼로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1e3d901aa2a402261442ec2c7ebd8329f10aa33" translate="yes" xml:space="preserve">
          <source>The argument passed to the block is a special kind of builder for this collection, which has the ability to generate the label and radio button for the current item in the collection, with proper text and value. Using it, you can change the label and radio button display order or even use the label as wrapper, as in the example above.</source>
          <target state="translated">블록에 전달 된 인수는이 컬렉션에 대한 특수한 종류의 빌더이며, 적절한 텍스트와 값을 사용하여 컬렉션의 현재 항목에 대한 레이블과 라디오 버튼을 생성 할 수 있습니다. 이를 사용하면 위의 예와 같이 레이블 및 단일 선택 단추 표시 순서를 변경하거나 레이블을 랩퍼로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1a9576f4a2b223a09361d11dd1dc6b658ae1532" translate="yes" xml:space="preserve">
          <source>The argument to the method can also be an array of fields.</source>
          <target state="translated">메소드에 대한 인수는 필드 배열 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d61b8b36e01219e1fd275a42844d956d215f5ac" translate="yes" xml:space="preserve">
          <source>The arguments</source>
          <target state="translated">인수</target>
        </trans-unit>
        <trans-unit id="355e19400456a3fe1f26ca11cc6c7b7a8ecf2d0d" translate="yes" xml:space="preserve">
          <source>The array of autoload paths can be extended by mutating &lt;code&gt;config.autoload_paths&lt;/code&gt;, in &lt;code&gt;config/application.rb&lt;/code&gt;, but nowadays this is discouraged.</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 에서 &lt;code&gt;config.autoload_paths&lt;/code&gt; 를 변경하여 자동로드 경로 배열을 확장 할 수 있지만 현재는 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="943fbe6c6be26526a4abc96639fa39121c1412ac" translate="yes" xml:space="preserve">
          <source>The array of names of environments where destructive actions should be prohibited. By default, the value is &lt;code&gt;[&quot;production&quot;]&lt;/code&gt;.</source>
          <target state="translated">파괴적인 행동을 금지해야하는 환경 이름의 배열. 기본적으로 값은 &lt;code&gt;[&quot;production&quot;]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a30865759f8ba34ea99a4762dc963aa4ce5642fe" translate="yes" xml:space="preserve">
          <source>The array or hash form is only available in model instances. You can try &lt;code&gt;sanitize_sql()&lt;/code&gt; elsewhere. &lt;em&gt;Make it a habit to think about the security consequences when using an external string in SQL&lt;/em&gt;.</source>
          <target state="translated">배열 또는 해시 양식은 모델 인스턴스에서만 사용할 수 있습니다. 다른 곳에서 &lt;code&gt;sanitize_sql()&lt;/code&gt; 시도 할 수 있습니다 . &lt;em&gt;SQL에서 외부 문자열을 사용할 때 보안 결과에 대해 생각하는 습관을들이십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea4e3572396cf97dec471b476f6e4fb172527901" translate="yes" xml:space="preserve">
          <source>The assertion is useful to test side effects. The passed block can be anything that can be converted to string with to_s.</source>
          <target state="translated">어설 션은 부작용을 테스트하는 데 유용합니다. 전달 된 블록은 to_s를 사용하여 문자열로 변환 할 수있는 모든 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c93d658e05dd9a1c5eae6aef5c9a16bc9ced6067" translate="yes" xml:space="preserve">
          <source>The asset pipeline automatically evaluates ERB. This means if you add an &lt;code&gt;erb&lt;/code&gt; extension to a CSS asset (for example, &lt;code&gt;application.css.erb&lt;/code&gt;), then helpers like &lt;code&gt;asset_path&lt;/code&gt; are available in your CSS rules:</source>
          <target state="translated">자산 파이프 라인은 ERB를 자동으로 평가합니다. 즉 , CSS 자산에 &lt;code&gt;erb&lt;/code&gt; 확장자를 추가하면 (예 : &lt;code&gt;application.css.erb&lt;/code&gt; ) &lt;code&gt;asset_path&lt;/code&gt; 와 같은 헬퍼를 CSS 규칙에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3011fda96b1ca8753841bf3b898af6dbd4f057" translate="yes" xml:space="preserve">
          <source>The asset pipeline is implemented by the &lt;a href=&quot;https://github.com/rails/sprockets-rails&quot;&gt;sprockets-rails&lt;/a&gt; gem, and is enabled by default. You can disable it while creating a new application by passing the &lt;code&gt;--skip-sprockets&lt;/code&gt; option.</source>
          <target state="translated">자산 파이프 라인은 &lt;a href=&quot;https://github.com/rails/sprockets-rails&quot;&gt;스프로킷 레일&lt;/a&gt; 보석으로 구현되며 기본적으로 활성화되어 있습니다. &lt;code&gt;--skip-sprockets&lt;/code&gt; 옵션 을 전달하여 새 응용 프로그램을 만드는 동안 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f878c6151e69b269ab4433fa5848e5efa53bde9b" translate="yes" xml:space="preserve">
          <source>The asset pipeline provides a framework to concatenate and minify or compress JavaScript and CSS assets. It also adds the ability to write these assets in other languages and pre-processors such as CoffeeScript, Sass, and ERB. It allows assets in your application to be automatically combined with assets from other gems.</source>
          <target state="translated">자산 파이프 라인은 JavaScript 및 CSS 자산을 연결하고 최소화하거나 압축하는 프레임 워크를 제공합니다. 또한 이러한 자산을 다른 언어 및 CoffeeScript, Sass 및 ERB와 같은 프리 프로세서로 작성할 수있는 기능이 추가되었습니다. 응용 프로그램의 자산을 다른 보석의 자산과 자동으로 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77a3d803d07d408010feccc57fa433b773c69c13" translate="yes" xml:space="preserve">
          <source>The asset pipeline requires the following additions:</source>
          <target state="translated">자산 파이프 라인에는 다음을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="020ec0a3484e16c339a2ef064894893cf7244347" translate="yes" xml:space="preserve">
          <source>The asset tag helpers do &lt;em&gt;not&lt;/em&gt; verify the existence of the assets at the specified locations; they simply assume that you know what you're doing and generate the link.</source>
          <target state="translated">자산 태그 도우미는 지정된 위치에 자산이 있는지 확인 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그들은 단순히 당신이하고있는 것을 알고 링크를 생성한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0fc7be0de976ccd2622628358c16d6f5f67c7961" translate="yes" xml:space="preserve">
          <source>The association methods module is included immediately after the generated attributes methods module, meaning an association will override the methods for an attribute with the same name.</source>
          <target state="translated">연관 메소드 모듈은 생성 된 속성 메소드 모듈 바로 뒤에 포함됩니다. 즉, 연관은 동일한 이름을 가진 속성의 메소드를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e55dd8733ce7e8c29594190c08e43e1a9e8c9dd8" translate="yes" xml:space="preserve">
          <source>The async adapter is intended for development/testing and should not be used in production.</source>
          <target state="translated">비동기 어댑터는 개발 / 테스트 용이므로 프로덕션 환경에서 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="3e1a7da90bdc196924fb861662b91e7b9e28a1e0" translate="yes" xml:space="preserve">
          <source>The attacker creates a valid session ID: They load the login page of the web application where they want to fix the session, and take the session ID in the cookie from the response (see number 1 and 2 in the image).</source>
          <target state="translated">공격자는 유효한 세션 ID를 만듭니다. 세션을 수정하려는 웹 응용 프로그램의 로그인 페이지를로드하고 응답에서 쿠키의 세션 ID를 가져옵니다 (이미지의 번호 1 및 2 참조).</target>
        </trans-unit>
        <trans-unit id="4be31d12233318ca5b32a5c7576e0a8a66ea7e83" translate="yes" xml:space="preserve">
          <source>The attacker forces the user's browser into using this session ID (see number 3 in the image). As you may not change a cookie of another domain (because of the same origin policy), the attacker has to run a JavaScript from the domain of the target web application. Injecting the JavaScript code into the application by XSS accomplishes this attack. Here is an example: &lt;code&gt;&amp;lt;script&amp;gt;document.cookie=&quot;_session_id=16d5b78abb28e3d6206b60f22a03c8d9&quot;;&amp;lt;/script&amp;gt;&lt;/code&gt;. Read more about XSS and injection later on.</source>
          <target state="translated">공격자는 사용자의 브라우저가이 세션 ID를 사용하도록 강제합니다 (이미지의 3 번 참조). 동일한 원본 정책으로 인해 다른 도메인의 쿠키를 변경할 수 없으므로 공격자는 대상 웹 응용 프로그램의 도메인에서 JavaScript를 실행해야합니다. XSS가 JavaScript 코드를 응용 프로그램에 삽입하면이 공격이 수행됩니다. 예는 다음과 같습니다. &lt;code&gt;&amp;lt;script&amp;gt;document.cookie=&quot;_session_id=16d5b78abb28e3d6206b60f22a03c8d9&quot;;&amp;lt;/script&amp;gt;&lt;/code&gt; . 나중에 XSS 및 주입에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="472aaec9cf17ab5457945e279dd6b89369f1abcb" translate="yes" xml:space="preserve">
          <source>The attacker lures the victim to the infected page with the JavaScript code. By viewing the page, the victim's browser will change the session ID to the trap session ID.</source>
          <target state="translated">공격자는 JavaScript 코드를 사용하여 감염된 페이지로 피해자를 유인합니다. 페이지를 보면, 피해자의 브라우저가 세션 ID를 트랩 세션 ID로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="1d7484930a38883801baf19ed274c8a6f14ef377" translate="yes" xml:space="preserve">
          <source>The attribute is also allowed on form submit buttons. This allows you to customize the warning message depending on the button which was activated. In this case, you should &lt;strong&gt;not&lt;/strong&gt; have &lt;code&gt;data-confirm&lt;/code&gt; on the form itself.</source>
          <target state="translated">속성은 양식 제출 단추에서도 허용됩니다. 활성화 된 버튼에 따라 경고 메시지를 사용자 정의 할 수 있습니다. 이 경우에, 당신은해야 &lt;strong&gt;하지&lt;/strong&gt; 이 &lt;code&gt;data-confirm&lt;/code&gt; 양식 자체에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e7ba74405d043fac8cffb4688e871995459f16e" translate="yes" xml:space="preserve">
          <source>The attribute name must be a valid method name in Ruby.</source>
          <target state="translated">속성 이름은 Ruby에서 유효한 메소드 이름이어야합니다.</target>
        </trans-unit>
        <trans-unit id="19f710237a4cdfb777c8c502e54db11bea3253d7" translate="yes" xml:space="preserve">
          <source>The attribute writer is named after the association, which means that in the following example, two new methods are added to your model:</source>
          <target state="translated">속성 작성기는 연결의 이름을 따서 명명됩니다. 이는 다음 예에서 두 가지 새로운 방법이 모델에 추가됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b1adaffe133610f0521b942bc7e0a2ed64cf70bf" translate="yes" xml:space="preserve">
          <source>The autoloading &lt;code&gt;zeitwerk&lt;/code&gt; mode is enabled by default in Rails 6 applications running on CRuby:</source>
          <target state="translated">자동 로딩 &lt;code&gt;zeitwerk&lt;/code&gt; 모드는 CRuby 에서 실행되는 Rails 6 애플리케이션에서 기본적으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="51a5f61ccda015537358800f0ed14b17759b5b24" translate="yes" xml:space="preserve">
          <source>The automatic connection switching in Rails is relatively primitive and deliberately doesn't do a whole lot. The goal was a system that demonstrated how to do automatic connection switching that was flexible enough to be customizable by app developers.</source>
          <target state="translated">Rails의 자동 연결 전환은 비교적 원시적이며 의도적으로 많은 작업을 수행하지 않습니다. 목표는 앱 개발자가 사용자 정의 할 수있을 정도로 유연한 자동 연결 전환을 수행하는 방법을 보여주는 시스템이었습니다.</target>
        </trans-unit>
        <trans-unit id="cd498d8f00a55adbd388db8254946597ced7c8ea" translate="yes" xml:space="preserve">
          <source>The automatic guessing of the inverse association uses a heuristic based on the name of the class, so it may not work for all associations, especially the ones with non-standard names.</source>
          <target state="translated">역 연관의 자동 추측은 클래스 이름을 기반으로하는 휴리스틱을 사용하므로 모든 연관, 특히 비표준 이름을 가진 연관에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fca70fc363db0694103c1c3ee5d464d957e1244a" translate="yes" xml:space="preserve">
          <source>The auxiliary file is written in a standard directory for temporary files, but you can pass a directory of your choice as second argument.</source>
          <target state="translated">보조 파일은 임시 파일의 표준 디렉토리에 작성되지만 선택한 디렉토리를 두 ​​번째 인수로 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b0da80781abc5c9cb6bed2a2370dad19e10b560" translate="yes" xml:space="preserve">
          <source>The available log levels are: &lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt;, &lt;code&gt;:fatal&lt;/code&gt;, and &lt;code&gt;:unknown&lt;/code&gt;, corresponding to the log level numbers from 0 up to 5, respectively. To change the default log level, use</source>
          <target state="translated">사용 가능한 로그 레벨은 다음 &lt;code&gt;:debug&lt;/code&gt; 같습니다. : debug , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; , &lt;code&gt;:error&lt;/code&gt; , &lt;code&gt;:fatal&lt;/code&gt; 및 &lt;code&gt;:unknown&lt;/code&gt; 은 각각 0에서 5까지의 로그 레벨 번호에 해당합니다. 기본 로그 수준을 변경하려면</target>
        </trans-unit>
        <trans-unit id="fca1ba2bb526fb57febfb060696498224cd1049e" translate="yes" xml:space="preserve">
          <source>The available paths in an engine are:</source>
          <target state="translated">엔진에서 사용 가능한 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb8d0fec98ef93ac9f78e7dfd28d986dc0cd2738" translate="yes" xml:space="preserve">
          <source>The available services are:</source>
          <target state="translated">사용 가능한 서비스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef6b1867b4c9436cd93c4b9cfa16ca0f109c4dea" translate="yes" xml:space="preserve">
          <source>The available variables are the same as if you were running the code line by line. After all, that's what debugging is.</source>
          <target state="translated">사용 가능한 변수는 코드를 한 줄씩 실행하는 것과 같습니다. 결국, 그것이 디버깅입니다.</target>
        </trans-unit>
        <trans-unit id="3e6568f0d6fca19e054683295306fc2923394571" translate="yes" xml:space="preserve">
          <source>The backend lazy-loads these translations when a translation is looked up for the first time. This backend can be swapped with something else even after translations have already been announced.</source>
          <target state="translated">백엔드는 번역을 처음 조회 할 때 이러한 번역을 지연로드합니다. 이 백엔드는 번역이 이미 발표 된 후에도 다른 것으로 교체 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad438901d54f922f7e3a38fbb64669716721c2e" translate="yes" xml:space="preserve">
          <source>The bang versions (e.g. &lt;code&gt;save!&lt;/code&gt;) raise an exception if the record is invalid. The non-bang versions don't: &lt;code&gt;save&lt;/code&gt; and &lt;code&gt;update&lt;/code&gt; return &lt;code&gt;false&lt;/code&gt;, and &lt;code&gt;create&lt;/code&gt; just returns the object.</source>
          <target state="translated">뱅 버전 (예 : &lt;code&gt;save!&lt;/code&gt; )은 레코드가 유효하지 않은 경우 예외를 발생시킵니다. : 비 뱅 버전은하지 않는 &lt;code&gt;save&lt;/code&gt; 및 &lt;code&gt;update&lt;/code&gt; 반환 &lt;code&gt;false&lt;/code&gt; , 그리고 &lt;code&gt;create&lt;/code&gt; 단지 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="62d4d2b30d3f29b1f5a9302fcfcde5019f96fad5" translate="yes" xml:space="preserve">
          <source>The base class for all Action Mailbox ingress controllers.</source>
          <target state="translated">모든 Action Mailbox 수신 컨트롤러의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fd76dbe2c67c754bf19c5b00612085a2ebb4cc46" translate="yes" xml:space="preserve">
          <source>The base class for all Active Storage controllers.</source>
          <target state="translated">모든 Active Storage 컨트롤러의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="b0359296c2d971bb520b61869223dc237fbef902" translate="yes" xml:space="preserve">
          <source>The base class for all application mailboxes. Not intended to be inherited from directly. Inherit from &lt;code&gt;ApplicationMailbox&lt;/code&gt; instead, as that's where the app-specific routing is configured. This routing is specified in the following ways:</source>
          <target state="translated">모든 응용 프로그램 사서함의 기본 클래스입니다. 직접 상속되지 않습니다. 대신 앱별 라우팅이 구성되어 있으므로 &lt;code&gt;ApplicationMailbox&lt;/code&gt; 에서 상속하십시오 . 이 라우팅은 다음과 같은 방식으로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="0514ba9362faf5e557150c734ea710fda9e209d8" translate="yes" xml:space="preserve">
          <source>The basename of the file in the client.</source>
          <target state="translated">클라이언트에서 파일의 기본 이름입니다.</target>
        </trans-unit>
        <trans-unit id="354bf92980b650e2e529e6489176a97f3181b18f" translate="yes" xml:space="preserve">
          <source>The basic idea is that &lt;code&gt;:only =&amp;gt; :index&lt;/code&gt; gets converted to &lt;code&gt;:if =&amp;gt; proc {|c| c.action_name == &quot;index&quot; }&lt;/code&gt;.</source>
          <target state="translated">기본 아이디어는 &lt;code&gt;:only =&amp;gt; :index&lt;/code&gt; 가 &lt;code&gt;:if =&amp;gt; proc {|c| c.action_name == &quot;index&quot; }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3341838bd6d04f628d28e8b08b6c39bd9610e33a" translate="yes" xml:space="preserve">
          <source>The basic idea is that given</source>
          <target state="translated">기본 아이디어는</target>
        </trans-unit>
        <trans-unit id="97784f6c14c00e72c6eeaa70b198d4868255bce2" translate="yes" xml:space="preserve">
          <source>The basic principles of MVC (Model, View, Controller) and RESTful design.</source>
          <target state="translated">MVC (모델, 뷰, 컨트롤러) 및 RESTful 디자인의 기본 원칙.</target>
        </trans-unit>
        <trans-unit id="3b73c2346832dbfb68e3f58b0769a3474d8edbcf" translate="yes" xml:space="preserve">
          <source>The basics of Ajax.</source>
          <target state="translated">Ajax의 기본 사항.</target>
        </trans-unit>
        <trans-unit id="139e7c28bc4fac9ee5dfd3a3d5d10a14eb9708cf" translate="yes" xml:space="preserve">
          <source>The beauty of system testing is that it is similar to integration testing in that it tests the user's interaction with your controller, model, and view, but system testing is much more robust and actually tests your application as if a real user were using it. Going forward, you can test anything that the user themselves would do in your application such as commenting, deleting articles, publishing draft articles, etc.</source>
          <target state="translated">시스템 테스트의 장점은 사용자가 컨트롤러, 모델 및 뷰와의 상호 작용을 테스트한다는 점에서 통합 테스트와 유사하지만 시스템 테스트는 훨씬 강력하며 실제 사용자가 사용하는 것처럼 애플리케이션을 실제로 테스트한다는 것입니다. 앞으로 주석 달기, 기사 삭제, 초안 기사 게시 등과 같이 사용자가 응용 프로그램에서 수행하는 모든 작업을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2a45f963646700d1f65d81d8560e98bd6909900" translate="yes" xml:space="preserve">
          <source>The benefits of the asset pipeline.</source>
          <target state="translated">자산 파이프 라인의 이점.</target>
        </trans-unit>
        <trans-unit id="9f5df1eea74d738dad34595b55bcf14eb6952a3a" translate="yes" xml:space="preserve">
          <source>The best &lt;em&gt;solution against it is not to store this kind of data in a session, but in the database&lt;/em&gt;. In this case store the credit in the database and the logged_in_user_id in the session.</source>
          <target state="translated">이에 대한 가장 좋은 &lt;em&gt;해결책은 이러한 종류의 데이터를 세션에 저장하는 것이 아니라 데이터베이스에 저장하는 것&lt;/em&gt; 입니다. 이 경우 크레딧을 데이터베이스에 저장하고 세션에서 logs_in_user_id를 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="7b8ad0381a4c987306f2cb168ce73b88e410de21" translate="yes" xml:space="preserve">
          <source>The best place to add a module is in your &lt;code&gt;ApplicationController&lt;/code&gt;, but you can also add modules to individual controllers.</source>
          <target state="translated">모듈을 추가하는 가장 좋은 곳은 &lt;code&gt;ApplicationController&lt;/code&gt; 에 있지만 개별 컨트롤러에 모듈을 추가 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4b5ed9443e66b3e0110749709b60139c3380001" translate="yes" xml:space="preserve">
          <source>The best way to be sure that your application still works after upgrading is to have good test coverage before you start the process. If you don't have automated tests that exercise the bulk of your application, you'll need to spend time manually exercising all the parts that have changed. In the case of a Rails upgrade, that will mean every single piece of functionality in the application. Do yourself a favor and make sure your test coverage is good &lt;em&gt;before&lt;/em&gt; you start an upgrade.</source>
          <target state="translated">업그레이드 후에도 응용 프로그램이 계속 작동하는지 확인하는 가장 좋은 방법은 프로세스를 시작하기 전에 테스트 범위를 넓히는 것입니다. 대부분의 응용 프로그램을 테스트하는 자동화 된 테스트가없는 경우 변경된 모든 부품을 수동으로 연습하는 데 시간을 소비해야합니다. Rails 업그레이드의 경우 이는 애플리케이션의 모든 단일 기능을 의미합니다. 업그레이드를 시작 &lt;em&gt;하기 전에&lt;/em&gt; 자신에게 유리한 입장을 취하고 테스트 적용 범위가 양호한 지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="a3d872feade1acb29bcd57807ca7d41970991f9d" translate="yes" xml:space="preserve">
          <source>The best way to follow what the loaders are doing is to inspect their activity.</source>
          <target state="translated">로더가하는 일을 따르는 가장 좋은 방법은 활동을 점검하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7cfb77e11e82da7663f457bc5a1147bff6a3dfe2" translate="yes" xml:space="preserve">
          <source>The best way to read this guide is to follow it step by step. All steps are essential to run this example application and no additional code or steps are needed.</source>
          <target state="translated">이 안내서를 읽는 가장 좋은 방법은 단계별로 따르는 것입니다. 이 예제 애플리케이션을 실행하려면 모든 단계가 필수적이며 추가 코드 나 단계가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2b50ab89ed47c343fdd3e342181514c408e3d5d" translate="yes" xml:space="preserve">
          <source>The best way to use this is by doing recyclable key-based cache expiration on top of a cache store like Memcached or Redis that'll automatically kick out old entries.</source>
          <target state="translated">이것을 사용하는 가장 좋은 방법은 Memcached 또는 Redis와 같은 캐시 저장소에서 재활용 가능한 키 기반 캐시 만료를 수행하여 오래된 항목을 자동으로 시작하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71772b8fb2f4b466d969e8e4d46babbcf646c9f3" translate="yes" xml:space="preserve">
          <source>The best way to work around this problem is to add a unique index to the database table using &lt;a href=&quot;../connectionadapters/schemastatements#method-i-add_index&quot;&gt;connection.add_index&lt;/a&gt;. In the rare case that a race condition occurs, the database will guarantee the field's uniqueness.</source>
          <target state="translated">이 문제를 해결하는 가장 좋은 방법은 &lt;a href=&quot;../connectionadapters/schemastatements#method-i-add_index&quot;&gt;connection.add_index를&lt;/a&gt; 사용하여 데이터베이스 테이블에 고유 인덱스를 추가하는 것 입니다. 드문 경우이지만 경쟁 조건이 발생하면 데이터베이스는 필드의 고유성을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="adb17d60435cd58ba82f08adc8591fefc01e70ee" translate="yes" xml:space="preserve">
          <source>The block argument of the &lt;code&gt;initializer&lt;/code&gt; method is the instance of the application itself, and so we can access the configuration on it by using the &lt;code&gt;config&lt;/code&gt; method as done in the example.</source>
          <target state="translated">&lt;code&gt;initializer&lt;/code&gt; 메소드 의 블록 인수는 애플리케이션 자체의 인스턴스이므로 예제에서 수행 한대로 &lt;code&gt;config&lt;/code&gt; 메소드를 사용하여 구성에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caaa4fd86f379445e99ffabab0eee855f27afa89" translate="yes" xml:space="preserve">
          <source>The block form supports filtering. If the &lt;code&gt;:only&lt;/code&gt; option is specified, then only the listed job(s) will not be performed.</source>
          <target state="translated">블록 형태는 필터링을 지원합니다. 는 IF &lt;code&gt;:only&lt;/code&gt; 옵션을 지정, 만 나열된 작업 (들)을 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="26d5b2739dfdb39220eba018836ffc384a52f3e7" translate="yes" xml:space="preserve">
          <source>The block in the &lt;code&gt;subscribe&lt;/code&gt; call gets the name of the event, start timestamp, end timestamp, a string with a unique identifier for that event's instrumenter (something like &amp;ldquo;535801666f04d0298cd6&amp;rdquo;), and a hash with the payload, in that order.</source>
          <target state="translated">&lt;code&gt;subscribe&lt;/code&gt; 호출 의 블록 은 이벤트 이름, 시작 타임 스탬프, 종료 타임 스탬프, 해당 이벤트의 기기에 대한 고유 식별자가있는 문자열 ( &quot;535801666f04d0298cd6&quot;등) 및 페이로드가 포함 된 해시를 순서대로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1cc5d52d9718a61420c1b73dd368fe9cb04a4603" translate="yes" xml:space="preserve">
          <source>The block receives the following arguments:</source>
          <target state="translated">블록은 다음과 같은 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="c5f3cc776a881a65a70477c8470d7ee47f5932e1" translate="yes" xml:space="preserve">
          <source>The block receives the record, the attribute's name, and the attribute's value. You can do anything you like to check for valid data within the block. If your validation fails, you should add an error message to the model, therefore making it invalid.</source>
          <target state="translated">블록은 레코드, 속성 이름 및 속성 값을받습니다. 블록 내에서 유효한 데이터를 확인하려는 모든 작업을 수행 할 수 있습니다. 유효성 검사에 실패하면 모델에 오류 메시지를 추가하여 유효하지 않게해야합니다.</target>
        </trans-unit>
        <trans-unit id="3dc7e6fbe0f58390efcaaa176ed65f3ad8037794" translate="yes" xml:space="preserve">
          <source>The block syntax also allows you to customize the part headers if desired:</source>
          <target state="translated">블록 구문을 사용하면 원하는 경우 부품 헤더를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80bfc2cdef2492355bfa550b3bf082d136bf5e1e" translate="yes" xml:space="preserve">
          <source>The block syntax is also useful in providing information specific to a part:</source>
          <target state="translated">블록 구문은 부품 관련 정보를 제공하는 데에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61669ac19ca4302d41af19d88cf28cfd8b55fefc" translate="yes" xml:space="preserve">
          <source>The block version of redirect allows for the easy encapsulation of any logic associated with the redirect in question. Either the params and request are supplied as arguments, or just params, depending of how many arguments your block accepts. A string is required as a return value.</source>
          <target state="translated">리디렉션의 블록 버전을 사용하면 해당 리디렉션과 관련된 모든 논리를 쉽게 캡슐화 할 수 있습니다. 매개 변수와 요청은 블록으로 허용되는 인수 수에 따라 인수로 제공되거나 매개 변수로 제공됩니다. 반환 값으로 문자열이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="73a19852ff729852791eb4cf72a4ea37280b2756" translate="yes" xml:space="preserve">
          <source>The block will be passed an instance of &lt;code&gt;&amp;lt;Driver&amp;gt;::Options&lt;/code&gt; where you can define the capabilities you want. Please refer to your driver documentation to learn about supported options.</source>
          <target state="translated">블록에는 원하는 기능을 정의 할 수있는 &lt;code&gt;&amp;lt;Driver&amp;gt;::Options&lt;/code&gt; 인스턴스가 전달됩니다 . 지원되는 옵션에 대한 자세한 내용은 드라이버 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0aa523374f201c463856cfce5f5635f277140ee6" translate="yes" xml:space="preserve">
          <source>The block will be run without doing anything. All database statements that happen within the block are effectively appended to the already open database transaction.</source>
          <target state="translated">아무것도하지 않고 블록이 실행됩니다. 블록 내에서 발생하는 모든 데이터베이스 문은 이미 열려있는 데이터베이스 트랜잭션에 효과적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="40ae4060cc10353f22b7cd78ee03f141631014ca" translate="yes" xml:space="preserve">
          <source>The block will only be executed if the client is being created. The second time we run this code, the block will be ignored.</source>
          <target state="translated">클라이언트가 생성되는 경우에만 블록이 실행됩니다. 이 코드를 두 번째로 실행하면 블록이 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="be97ed4602139a7a506baea761907565044556e5" translate="yes" xml:space="preserve">
          <source>The bottom form will call the &lt;code&gt;create&lt;/code&gt; action on the &lt;code&gt;UsersController&lt;/code&gt;. Because the form's remote option is set to true, the request will be posted to the &lt;code&gt;UsersController&lt;/code&gt; as an Ajax request, looking for JavaScript. In order to serve that request, the &lt;code&gt;create&lt;/code&gt; action of your controller would look like this:</source>
          <target state="translated">맨 아래 양식은 &lt;code&gt;UsersController&lt;/code&gt; 에서 &lt;code&gt;create&lt;/code&gt; 조치를 호출합니다 . 폼의 remote 옵션이 true로 설정 &lt;code&gt;UsersController&lt;/code&gt; 요청은 JavaScript를 찾기 위해 Ajax 요청으로 UsersController에 게시됩니다 . 해당 요청을 처리하기 위해 컨트롤러 의 &lt;code&gt;create&lt;/code&gt; 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dd9e979a08fdef32b1d7a6d2105255de16e8948" translate="yes" xml:space="preserve">
          <source>The builder methods &lt;code&gt;label&lt;/code&gt; and &lt;code&gt;check_box&lt;/code&gt; also accept extra HTML options:</source>
          <target state="translated">빌더 메소드 &lt;code&gt;label&lt;/code&gt; 및 &lt;code&gt;check_box&lt;/code&gt; 는 추가 HTML 옵션도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7c57627e121234f1b558999cf69b228dc10eb497" translate="yes" xml:space="preserve">
          <source>The builder methods &lt;code&gt;label&lt;/code&gt; and &lt;code&gt;radio_button&lt;/code&gt; also accept extra HTML options:</source>
          <target state="translated">빌더 메소드 &lt;code&gt;label&lt;/code&gt; 및 &lt;code&gt;radio_button&lt;/code&gt; 은 추가 HTML 옵션도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="a589cc48c0ceff9cfef89e767e0c28b3788894fc" translate="yes" xml:space="preserve">
          <source>The built-in previewers rely on third-party system libraries. Specifically, the built-in video previewer requires &lt;a href=&quot;https://www.ffmpeg.org&quot;&gt;FFmpeg&lt;/a&gt;. Two PDF previewers are provided: one requires &lt;a href=&quot;https://poppler.freedesktop.org&quot;&gt;Poppler&lt;/a&gt;, and the other requires &lt;a href=&quot;https://mupdf.com&quot;&gt;muPDF&lt;/a&gt; (version 1.8 or newer). To preview PDFs, install either Poppler or muPDF.</source>
          <target state="translated">내장 미리보기 프로그램은 타사 시스템 라이브러리를 사용합니다. 특히 내장 비디오 미리보기에는 &lt;a href=&quot;https://www.ffmpeg.org&quot;&gt;FFmpeg&lt;/a&gt; 가 필요합니다 . 두 개의 PDF 미리보기가 제공됩니다. 하나는 &lt;a href=&quot;https://poppler.freedesktop.org&quot;&gt;Poppler&lt;/a&gt; 가 필요하고 다른 하나는 &lt;a href=&quot;https://mupdf.com&quot;&gt;muPDF&lt;/a&gt; (버전 1.8 이상)가 필요합니다. PDF를 미리 보려면 Poppler 또는 muPDF를 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="d0db978acd87eba4fe90cf76850afede1a41cfca" translate="yes" xml:space="preserve">
          <source>The bundled ActiveRecord::ConnectionAdapters distinguish unique index constraint errors from other types of database errors by throwing an &lt;a href=&quot;../recordnotunique&quot;&gt;ActiveRecord::RecordNotUnique&lt;/a&gt; exception. For other adapters you will have to parse the (database-specific) exception message to detect such a case.</source>
          <target state="translated">번들로 제공되는 ActiveRecord :: ConnectionAdapters는 &lt;a href=&quot;../recordnotunique&quot;&gt;ActiveRecord :: RecordNotUnique&lt;/a&gt; 예외를 발생시켜 다른 유형의 데이터베이스 오류와 고유 인덱스 제약 조건 오류를 구별 합니다 . 다른 어댑터의 경우 이러한 경우를 감지하기 위해 (데이터베이스 별) 예외 메시지를 구문 분석해야합니다.</target>
        </trans-unit>
        <trans-unit id="9af11b8b548eca91a377d8c9d48134b4d4aba9da" translate="yes" xml:space="preserve">
          <source>The cable servers can be separated from your normal application server. It's still a Rack application, but it is its own Rack application. The recommended basic setup is as follows:</source>
          <target state="translated">케이블 서버는 일반 응용 프로그램 서버와 분리 될 수 있습니다. 여전히 랙 응용 프로그램이지만 자체 랙 응용 프로그램입니다. 권장되는 기본 설정은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc4f7d12feba94bbfb7fa24ce8fc851cb8a3c09e" translate="yes" xml:space="preserve">
          <source>The caching method changed between Rails 3.x and 4.0. You should &lt;a href=&quot;https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store&quot;&gt;change the cache namespace&lt;/a&gt; and roll out with a cold cache.</source>
          <target state="translated">캐싱 방법은 Rails 3.x와 4.0 사이에서 변경되었습니다. &lt;a href=&quot;https://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store&quot;&gt;캐시 네임 스페이스를 변경하고&lt;/a&gt; 콜드 캐시로 롤아웃 해야 합니다.</target>
        </trans-unit>
        <trans-unit id="940974ebea639855c356755dfb99ea6a3861125c" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;str.first(n)&lt;/code&gt; is equivalent to &lt;code&gt;str.to(n-1)&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; &amp;gt; 0, and returns an empty string for &lt;code&gt;n&lt;/code&gt; == 0.</source>
          <target state="translated">&lt;code&gt;str.first(n)&lt;/code&gt; 호출 은 &lt;code&gt;n&lt;/code&gt; &amp;gt; 0 인 경우 &lt;code&gt;str.to(n-1)&lt;/code&gt; 과 동일 하며 &lt;code&gt;n&lt;/code&gt; == 0에 대해 빈 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="833c68ae0ff28d5dc9c986e34e3da0f69c98f213" translate="yes" xml:space="preserve">
          <source>The call &lt;code&gt;str.last(n)&lt;/code&gt; is equivalent to &lt;code&gt;str.from(-n)&lt;/code&gt; if &lt;code&gt;n&lt;/code&gt; &amp;gt; 0, and returns an empty string for &lt;code&gt;n&lt;/code&gt; == 0.</source>
          <target state="translated">&lt;code&gt;str.last(n)&lt;/code&gt; 호출 은 &lt;code&gt;n&lt;/code&gt; &amp;gt; 0 인 경우 &lt;code&gt;str.from(-n)&lt;/code&gt; 과 동일 하며 &lt;code&gt;n&lt;/code&gt; == 0에 대해 빈 문자열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1bd262d49ac02ad093f21a4c44e0f8d9da2a38d1" translate="yes" xml:space="preserve">
          <source>The call to &lt;code&gt;stale?&lt;/code&gt; will compare the &lt;code&gt;If-Modified-Since&lt;/code&gt; header in the request with &lt;code&gt;@post.updated_at&lt;/code&gt;. If the header is newer than the last modified, this action will return a &quot;304 Not Modified&quot; response. Otherwise, it will render the response and include a &lt;code&gt;Last-Modified&lt;/code&gt; header in it.</source>
          <target state="translated">&lt;code&gt;stale?&lt;/code&gt; 전화 ? 요청 의 &lt;code&gt;If-Modified-Since&lt;/code&gt; 헤더를 &lt;code&gt;@post.updated_at&lt;/code&gt; 과 비교합니다 . 헤더가 마지막으로 수정 된 것보다 최신 인 경우이 작업은 &quot;304 Not Modified&quot;응답을 반환합니다. 그렇지 않으면 응답을 렌더링하고 &lt;code&gt;Last-Modified&lt;/code&gt; 헤더를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="bec300411ed42dc8fd8c704fa67d4cdaa9736042" translate="yes" xml:space="preserve">
          <source>The callback can be specified as a symbol naming an instance method; as a proc, lambda, or block; or as an object that responds to a certain method determined by the &lt;code&gt;:scope&lt;/code&gt; argument to &lt;code&gt;define_callbacks&lt;/code&gt;.</source>
          <target state="translated">콜백은 인스턴스 메소드를 명명하는 심볼로 지정할 수 있습니다. proc, lambda 또는 block으로; 또는 &lt;code&gt;:scope&lt;/code&gt; 인수에 의해 &lt;code&gt;define_callbacks&lt;/code&gt; 에 의해 결정된 특정 메소드에 응답하는 객체로서 .</target>
        </trans-unit>
        <trans-unit id="c0144d847fe6227e22630e607a1ac2c22b100548" translate="yes" xml:space="preserve">
          <source>The callback chain is accessible via the &lt;code&gt;_*_callbacks&lt;/code&gt; method on an object. Active Model Callbacks support &lt;code&gt;:before&lt;/code&gt;, &lt;code&gt;:after&lt;/code&gt; and &lt;code&gt;:around&lt;/code&gt; as values for the &lt;code&gt;kind&lt;/code&gt; property. The &lt;code&gt;kind&lt;/code&gt; property defines what part of the chain the callback runs in.</source>
          <target state="translated">콜백 체인은 객체 의 &lt;code&gt;_*_callbacks&lt;/code&gt; 메소드를 통해 액세스 할 수 있습니다 . 활성 모델 콜백 은 &lt;code&gt;kind&lt;/code&gt; 속성의 값으로 &lt;code&gt;:before&lt;/code&gt; , &lt;code&gt;:after&lt;/code&gt; 및 &lt;code&gt;:around&lt;/code&gt; 를 지원합니다 . &lt;code&gt;kind&lt;/code&gt; 콜백에서 실행 체인의 어떤 부분 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="ced64514dadc85e7a45902c82df5f158760ecefb" translate="yes" xml:space="preserve">
          <source>The callback objects have methods named after the callback called with the record as the only parameter, such as:</source>
          <target state="translated">콜백 객체에는 다음과 같은 유일한 매개 변수로 레코드와 함께 호출 된 콜백 이름이 지정된 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdbd9eccba5bd5b7285092c65f704cd90f4be3f3" translate="yes" xml:space="preserve">
          <source>The callback only runs when all the &lt;code&gt;:if&lt;/code&gt; conditions and none of the &lt;code&gt;:unless&lt;/code&gt; conditions are evaluated to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">콜백은 모든 &lt;code&gt;:if&lt;/code&gt; 조건이 있고 &lt;code&gt;:unless&lt;/code&gt; 조건이 &lt;code&gt;true&lt;/code&gt; 로 평가 되지 않는 경우 에만 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="77e7c816645fffb0a5b04100cbb7d18b7fb9b070" translate="yes" xml:space="preserve">
          <source>The callbacks gets executed even if &lt;code&gt;--skip-bundle&lt;/code&gt; and/or &lt;code&gt;--skip-spring&lt;/code&gt; has been passed.</source>
          <target state="translated">&lt;code&gt;--skip-bundle&lt;/code&gt; 및 / 또는 &lt;code&gt;--skip-spring&lt;/code&gt; 이 전달 된 경우에도 콜백이 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="97f831f93b6a1f8242aab9535f18bc367e2e8fb6" translate="yes" xml:space="preserve">
          <source>The capitalization of the first word can be turned off by setting the &lt;code&gt;:capitalize&lt;/code&gt; option to false (default is true).</source>
          <target state="translated">&lt;code&gt;:capitalize&lt;/code&gt; 옵션을 false 로 설정하여 첫 단어의 대문자를 끌 수 있습니다 (기본값은 true).</target>
        </trans-unit>
        <trans-unit id="35068c0b99fe0172d1d7159a2e5bf5702ff3b360" translate="yes" xml:space="preserve">
          <source>The capitalization of the first word can be turned off by setting the optional parameter &lt;code&gt;capitalize&lt;/code&gt; to false. By default, this parameter is true.</source>
          <target state="translated">선택적 매개 변수 &lt;code&gt;capitalize&lt;/code&gt; 를 false 로 설정하면 첫 단어의 대문자를 끌 수 있습니다 . 기본적으로이 매개 변수는 true입니다.</target>
        </trans-unit>
        <trans-unit id="7505289652865a62f15db2bf2880fe217d91218d" translate="yes" xml:space="preserve">
          <source>The capture method can be used in ERB templates&amp;hellip;</source>
          <target state="translated">캡처 방법은 ERB 템플릿에서 사용할 수 있습니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="68c2dbb421ebf30117a200669e773362d65e7054" translate="yes" xml:space="preserve">
          <source>The capture method extracts part of a template as a &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; object. You can then use this object anywhere in your templates, layout, or helpers.</source>
          <target state="translated">캡처 방법은 템플릿의 일부를 &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; 객체 로 추출 합니다. 그런 다음 템플릿, 레이아웃 또는 도우미의 어느 곳에서나이 개체를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6038704237cf96642934bb442e0da7a55ec883a" translate="yes" xml:space="preserve">
          <source>The captured variable can then be used anywhere else.</source>
          <target state="translated">그런 다음 캡처 된 변수를 다른 곳에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a7cca56328d52d2a11596166f75f3e5651a8081" translate="yes" xml:space="preserve">
          <source>The channel has been instructed to stream everything that arrives at &lt;code&gt;web_notifications:1&lt;/code&gt; directly to the client by invoking the &lt;code&gt;received&lt;/code&gt; callback.</source>
          <target state="translated">&lt;code&gt;received&lt;/code&gt; 콜백 을 호출하여 &lt;code&gt;web_notifications:1&lt;/code&gt; 에 도착하는 모든 것을 클라이언트로 직접 스트리밍하도록 채널에 지시했습니다 .</target>
        </trans-unit>
        <trans-unit id="4b9de0a84a384ce524e586226d5b0f40e2186f22" translate="yes" xml:space="preserve">
          <source>The channel has been instructed to stream everything that arrives at &lt;code&gt;web_notifications:1&lt;/code&gt; directly to the client by invoking the &lt;code&gt;received&lt;/code&gt; callback. The data passed as argument is the hash sent as the second parameter to the server-side broadcast call, JSON encoded for the trip across the wire and unpacked for the data argument arriving as &lt;code&gt;received&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;received&lt;/code&gt; 콜백 을 호출하여 &lt;code&gt;web_notifications:1&lt;/code&gt; 에 도착하는 모든 것을 클라이언트로 직접 스트리밍하도록 채널에 지시했습니다 . 인수로 전달 된 데이터는 두 번째 매개 변수로 서버 측 브로드 캐스트 호출에 전송 된 해시입니다. JSON은 유선으로의 트립을 위해 인코딩되고 &lt;code&gt;received&lt;/code&gt; 도착한 데이터 인수에 대해 압축이 풀 립니다.</target>
        </trans-unit>
        <trans-unit id="6baa8358f54c0de7f5162dbaeb03235b5c79ab40" translate="yes" xml:space="preserve">
          <source>The channel provides the basic structure of grouping behavior into logical units when communicating over the WebSocket connection. You can think of a channel like a form of controller, but one that's capable of pushing content to the subscriber in addition to simply responding to the subscriber's direct requests.</source>
          <target state="translated">채널은 WebSocket 연결을 통해 통신 할 때 동작을 논리 단위로 그룹화하는 기본 구조를 제공합니다. 채널을 컨트롤러 형태로 생각할 수 있지만 가입자의 직접 요청에 단순히 응답하는 것 외에도 가입자에게 콘텐츠를 푸시 할 수있는 채널을 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6d579397c5bdac0fe33ecdf6e2a0cdff8bc330e" translate="yes" xml:space="preserve">
          <source>The character set being used for the response. Default is &quot;utf-8&quot;.</source>
          <target state="translated">응답에 사용되는 문자 세트입니다. 기본값은 &quot;utf-8&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="71882d36ed0d03f3e65d077d09fd3ffab83a0a54" translate="yes" xml:space="preserve">
          <source>The charset of the response. HTML wants to know the encoding of the content you're giving them, so we need to send that along.</source>
          <target state="translated">응답의 문자셋. HTML은 사용자가 제공하는 콘텐츠의 인코딩을 알고 싶어하므로이를 함께 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="65188e551d2286e8dce2576c678a2674897adda4" translate="yes" xml:space="preserve">
          <source>The cipher text and initialization vector are base64 encoded and returned to you.</source>
          <target state="translated">암호문 및 초기화 벡터는 base64로 인코딩되어 사용자에게 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="b673759369e7231ead32eb00ab425afce042f51f" translate="yes" xml:space="preserve">
          <source>The class &lt;code&gt;DateTime&lt;/code&gt; is a subclass of &lt;code&gt;Date&lt;/code&gt; so by loading &lt;code&gt;active_support/core_ext/date/calculations.rb&lt;/code&gt; you inherit these methods and their aliases, except that they will always return datetimes.</source>
          <target state="translated">클래스 &lt;code&gt;DateTime&lt;/code&gt; 의 서브 클래스 &lt;code&gt;Date&lt;/code&gt; 그래서 로딩으로 &lt;code&gt;active_support/core_ext/date/calculations.rb&lt;/code&gt; 그들은 항상 날짜 시간을 반환하는 것을 제외하고는, 이러한 방법과 자신의 별명을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="6968c660131cb878dd7653f49687204b7db61a98" translate="yes" xml:space="preserve">
          <source>The class &lt;strong&gt;is&lt;/strong&gt; defined in &lt;code&gt;Rack::Server&lt;/code&gt;, but is overwritten in &lt;code&gt;Rails::Server&lt;/code&gt; to take different arguments. Its &lt;code&gt;parse!&lt;/code&gt; method looks like this:</source>
          <target state="translated">이 클래스 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;Rack::Server&lt;/code&gt; 정의되어 있지만 &lt;code&gt;Rails::Server&lt;/code&gt; 로 덮어 써서 다른 인수를 취합니다. 그 &lt;code&gt;parse!&lt;/code&gt; 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d9472e83f43b35d872e4a578ebf8461fa5e4488" translate="yes" xml:space="preserve">
          <source>The class object following a &lt;code&gt;class&lt;/code&gt; keyword gets pushed when its body is executed, and popped after it.</source>
          <target state="translated">본문이 실행될 때 &lt;code&gt;class&lt;/code&gt; 키워드 뒤의 클래스 객체 가 푸시되고 그 다음에 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="af86f952fa9511ca82932ee1393dc187d0ec2258" translate="yes" xml:space="preserve">
          <source>The class of the object that will be serialized.</source>
          <target state="translated">직렬화 될 객체의 클래스.</target>
        </trans-unit>
        <trans-unit id="55a3142b2051edb930ee46b026db101e1fddf3f3" translate="yes" xml:space="preserve">
          <source>The code evaluating &lt;code&gt;Hotel::Image&lt;/code&gt; needs to make sure &lt;code&gt;app/models/hotel/image.rb&lt;/code&gt; has been loaded, possibly with &lt;code&gt;require_dependency&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Hotel::Image&lt;/code&gt; 평가하는 코드는 &lt;code&gt;app/models/hotel/image.rb&lt;/code&gt; 가로드 되어 있는지 , &lt;code&gt;require_dependency&lt;/code&gt; 로로드 되었는지 확인해야 합니다 .</target>
        </trans-unit>
        <trans-unit id="f2abcc6222e668f83e74fb7940530a8065dda4e1" translate="yes" xml:space="preserve">
          <source>The code executed within &lt;code&gt;after_commit&lt;/code&gt; or &lt;code&gt;after_rollback&lt;/code&gt; callbacks is itself not enclosed within a transaction.</source>
          <target state="translated">&lt;code&gt;after_commit&lt;/code&gt; 또는 &lt;code&gt;after_rollback&lt;/code&gt; 콜백 내에서 실행 된 코드 자체는 트랜잭션 내에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8f19278505fd168de6c555f502a1dfd0b17e712" translate="yes" xml:space="preserve">
          <source>The code is equivalent to:</source>
          <target state="translated">코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0315c0a4d2c5d7db5ad3c357745a96d7a8f7a40" translate="yes" xml:space="preserve">
          <source>The coder</source>
          <target state="translated">코더</target>
        </trans-unit>
        <trans-unit id="9d50665bddf50354931c2dafee55e08156cf93ff" translate="yes" xml:space="preserve">
          <source>The collection of join models can be managed via the &lt;a href=&quot;#has-many-association-reference&quot;&gt;&lt;code&gt;has_many&lt;/code&gt; association methods&lt;/a&gt;. For example, if you assign:</source>
          <target state="translated">조인 모델 모음은 &lt;a href=&quot;#has-many-association-reference&quot;&gt; &lt;code&gt;has_many&lt;/code&gt; 연관 방법을&lt;/a&gt; 통해 관리 할 수 ​​있습니다 . 예를 들어 다음을 할당하면</target>
        </trans-unit>
        <trans-unit id="ffc68b1561cf18b53a6825ca34ebd3013c124934" translate="yes" xml:space="preserve">
          <source>The collection proxy returned by &lt;code&gt;blog.posts&lt;/code&gt; is built from a &lt;code&gt;:has_many&lt;/code&gt;&lt;code&gt;association&lt;/code&gt;, and delegates to a collection of posts as the &lt;code&gt;target&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;blog.posts&lt;/code&gt; 에 의해 리턴 된 콜렉션 프록시 는 &lt;code&gt;:has_many&lt;/code&gt; &lt;code&gt;association&lt;/code&gt; 에서 빌드되며 &lt;code&gt;target&lt;/code&gt; 으로서 게시물 콜렉션에 위임됩니다 .</target>
        </trans-unit>
        <trans-unit id="6182787d0262c6c7b1359fe37e373545a1c0bed3" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;catch exception-name&lt;/code&gt; (or just &lt;code&gt;cat exception-name&lt;/code&gt;) can be used to intercept an exception of type &lt;em&gt;exception-name&lt;/em&gt; when there would otherwise be no handler for it.</source>
          <target state="translated">명령 &lt;code&gt;catch exception-name&lt;/code&gt; (또는 &lt;code&gt;cat exception-name&lt;/code&gt; ) 형식의 예외 차단하는 데 사용할 수있는 &lt;em&gt;예외 이름을&lt;/em&gt; 그렇지 않은 경우에 대한 핸들러가 없을 것이다 때.</target>
        </trans-unit>
        <trans-unit id="80da790259c679e4e01e02f3c1ec2a6cdb498e07" translate="yes" xml:space="preserve">
          <source>The command also generates a &lt;code&gt;.sprockets-manifest-randomhex.json&lt;/code&gt; (where &lt;code&gt;randomhex&lt;/code&gt; is a 16-byte random hex string) that contains a list with all your assets and their respective fingerprints. This is used by the Rails helper methods to avoid handing the mapping requests back to Sprockets. A typical manifest file looks like:</source>
          <target state="translated">이 명령은 또한 생성 &lt;code&gt;.sprockets-manifest-randomhex.json&lt;/code&gt; ( &lt;code&gt;randomhex&lt;/code&gt; 는 자산 및 각각의 지문 모두와 목록을 포함하는 16 바이트 임의의 16 진수 문자열입니다). 이는 Rails 헬퍼 메소드에서 매핑 요청을 다시 스프라켓으로 전달하는 것을 피하기 위해 사용됩니다. 일반적인 매니페스트 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc549bd20274f0695384007247bbbda10162ffc6" translate="yes" xml:space="preserve">
          <source>The command is:</source>
          <target state="translated">명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fa70b028a21d0022e10ac55779cf6987002c2c13" translate="yes" xml:space="preserve">
          <source>The command line arguments are accessed through the &lt;code&gt;options&lt;/code&gt; method inside the generator class. e.g:</source>
          <target state="translated">명령 행 인수는 생성기 클래스 내의 &lt;code&gt;options&lt;/code&gt; 메소드를 통해 액세스됩니다 . 예 :</target>
        </trans-unit>
        <trans-unit id="d2883a7196ed191d0b1930e857380aaceb624c12" translate="yes" xml:space="preserve">
          <source>The comments resource here will have the following routes generated for it:</source>
          <target state="translated">여기에 설명 리소스에는 다음과 같은 경로가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="1ca196984fa3076e444df6fe8fba096623852a03" translate="yes" xml:space="preserve">
          <source>The common admin interface works like this: it's located at &lt;a href=&quot;http://www.example.com/admin&quot;&gt;www.example.com/admin&lt;/a&gt;, may be accessed only if the admin flag is set in the User model, re-displays user input and allows the admin to delete/add/edit whatever data desired. Here are some thoughts about this:</source>
          <target state="translated">일반적인 관리 인터페이스는 다음과 같이 작동합니다. &lt;a href=&quot;http://www.example.com/admin&quot;&gt;www.example.com/admin&lt;/a&gt; 에 있으며, admin 플래그가 사용자 모델에 설정되어 있고 사용자 입력을 다시 표시하고 관리자가 무엇이든 삭제 / 추가 / 편집 할 수있는 경우에만 액세스 할 수 있습니다. 원하는 데이터. 여기에 대한 몇 가지 생각이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc2f83d5a1ad109565a4d74b0b6682016333b02" translate="yes" xml:space="preserve">
          <source>The complete &lt;code&gt;ArticlesController&lt;/code&gt; in the &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; file should now look like this:</source>
          <target state="translated">전체 &lt;code&gt;ArticlesController&lt;/code&gt; 에서 &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; 파일은 이제 다음과 같아야합니다 :</target>
        </trans-unit>
        <trans-unit id="99863ff5886b28045cd1462c63f145b1dd9d863d" translate="yes" xml:space="preserve">
          <source>The complete key</source>
          <target state="translated">완전한 키</target>
        </trans-unit>
        <trans-unit id="e53929ec98b2233f0d54281d4c3c091285f783c3" translate="yes" xml:space="preserve">
          <source>The complete path</source>
          <target state="translated">완전한 경로</target>
        </trans-unit>
        <trans-unit id="1c27854a720a25987ef08e89474e0a1a6ecf7142" translate="yes" xml:space="preserve">
          <source>The compressor config settings for CSS and JavaScript also take any object. This object must have a &lt;code&gt;compress&lt;/code&gt; method that takes a string as the sole argument and it must return a string.</source>
          <target state="translated">CSS 및 JavaScript에 대한 컴프레서 구성 설정에는 모든 개체가 사용됩니다. 이 객체 에는 문자열을 유일한 인수로 사용 하는 &lt;code&gt;compress&lt;/code&gt; 메서드가 있어야하며 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba08f59113b11226b0617d5a0de72beaf8f9a124" translate="yes" xml:space="preserve">
          <source>The concept of sessions in Rails, what to put in there and popular attack methods.</source>
          <target state="translated">Rails의 세션 개념, 거기에 넣을 대상 및 인기있는 공격 방법.</target>
        </trans-unit>
        <trans-unit id="d5de646b54e2f7c5029b74a8b4e4fa98d6731e57" translate="yes" xml:space="preserve">
          <source>The concepts of database migrations, validations, and callbacks.</source>
          <target state="translated">데이터베이스 마이그레이션, 유효성 검사 및 콜백의 개념</target>
        </trans-unit>
        <trans-unit id="0aac594320228947fb8fa734325687d3f3454def" translate="yes" xml:space="preserve">
          <source>The concern object, if supplied, should respond to &lt;code&gt;call&lt;/code&gt;, which will receive two parameters:</source>
          <target state="translated">관심 객체가 제공되는 경우 &lt;code&gt;call&lt;/code&gt; 에 응답해야하며이 매개 변수에는 두 개의 매개 변수가 수신됩니다.</target>
        </trans-unit>
        <trans-unit id="a63f0d5d4473dcccd1b3ca31ae61a55113c2a709" translate="yes" xml:space="preserve">
          <source>The console autoloads, the test suite autoloads, and of course the application autoloads.</source>
          <target state="translated">콘솔 자동로드, 테스트 스위트 자동로드 및 응용 프로그램 자동로드.</target>
        </trans-unit>
        <trans-unit id="aabbadbe522f11b3d0d499a83d76f7386f175280" translate="yes" xml:space="preserve">
          <source>The console executes pure Ruby code: You can define and instantiate custom classes, create new models, and inspect variables.</source>
          <target state="translated">콘솔은 순수 Ruby 코드를 실행합니다. 사용자 정의 클래스를 정의 및 인스턴스화하고 새 모델을 작성하며 변수를 검사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7220a786640255689868500968affcdf580ec6d9" translate="yes" xml:space="preserve">
          <source>The constant &lt;code&gt;A&lt;/code&gt; may no longer exist, some code could have removed it from &lt;code&gt;Object&lt;/code&gt;.</source>
          <target state="translated">상수 &lt;code&gt;A&lt;/code&gt; 가 더 이상 존재하지 않을 수 있으며 일부 코드는 &lt;code&gt;Object&lt;/code&gt; 에서 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b63f60bb1f9563c7247d9bacbad6fe17817b660" translate="yes" xml:space="preserve">
          <source>The constant WidgetsController can be resolved from the name. The following code will resolve the constant:</source>
          <target state="translated">상수 WidgetsController는 이름에서 확인할 수 있습니다. 다음 코드는 상수를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="674c1279d8b2dacd6774e80d3eac1f6f865f5df4" translate="yes" xml:space="preserve">
          <source>The constant is looked up in the parent and its ancestors. In Ruby &amp;gt;= 2.5, &lt;code&gt;Object&lt;/code&gt; is skipped if present among the ancestors. &lt;code&gt;Kernel&lt;/code&gt; and &lt;code&gt;BasicObject&lt;/code&gt; are still checked though.</source>
          <target state="translated">상수는 부모와 조상에서 조회됩니다. Ruby&amp;gt; = 2.5 에서 조상 사이에 &lt;code&gt;Object&lt;/code&gt; 가 있으면 건너 뜁니다. 그래도 &lt;code&gt;Kernel&lt;/code&gt; 과 &lt;code&gt;BasicObject&lt;/code&gt; 는 점검됩니다.</target>
        </trans-unit>
        <trans-unit id="082b680fd1c3b37550d012a6b71e24a4e0b9e577" translate="yes" xml:space="preserve">
          <source>The constraint name. Defaults to &lt;code&gt;fk_rails_&amp;lt;identifier&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">제약 조건 이름. 기본값은 &lt;code&gt;fk_rails_&amp;lt;identifier&amp;gt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a2e3639f8fef012d7a8c083c1d6181192ee280b5" translate="yes" xml:space="preserve">
          <source>The consumer can optionally take an argument that specifies the URL to connect to. This can be a string, or a function that returns a string that will be called when the WebSocket is opened.</source>
          <target state="translated">소비자는 선택적으로 연결할 URL을 지정하는 인수를 취할 수 있습니다. 문자열이거나 WebSocket을 열 때 호출 될 문자열을 반환하는 함수일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20f6ba7495c1ca28ab054f3520e5fac50e367c5d" translate="yes" xml:space="preserve">
          <source>The content type of the response.</source>
          <target state="translated">응답의 컨텐츠 유형입니다.</target>
        </trans-unit>
        <trans-unit id="e5c334ab1d810760f26bd9954ec98a6cbf41eef3" translate="yes" xml:space="preserve">
          <source>The content type requested by the client.</source>
          <target state="translated">클라이언트가 요청한 컨텐츠 유형.</target>
        </trans-unit>
        <trans-unit id="6e881217ecc3145c8db968851552e51cd8f45bf0" translate="yes" xml:space="preserve">
          <source>The contents of the block, and therefore the string interpolation, are only evaluated if debug is enabled. This performance savings are only really noticeable with large amounts of logging, but it's a good practice to employ.</source>
          <target state="translated">블록의 내용 및 따라서 문자열 보간은 디버그가 활성화 된 경우에만 평가됩니다. 이 성능 절감은 대량의 로깅을 통해서만 눈에 띄지 만 채택하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7d621c311adb11f8027c2dcc7b29dc66f7c07bdd" translate="yes" xml:space="preserve">
          <source>The contents of the nonce are implementation dependent. The quality of the implementation depends on a good choice. A nonce might, for example, be constructed as the base 64 encoding of</source>
          <target state="translated">nonce의 내용은 구현에 따라 다릅니다. 구현의 질은 좋은 선택에 달려 있습니다. 예를 들어 nonce는 기본 64 인코딩으로 구성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79cd1b7501b6b6f01a8ed691037aa929e5a70570" translate="yes" xml:space="preserve">
          <source>The controller generator is expecting parameters in the form of &lt;code&gt;generate controller ControllerName action1 action2&lt;/code&gt;. Let's make a &lt;code&gt;Greetings&lt;/code&gt; controller with an action of &lt;strong&gt;hello&lt;/strong&gt;, which will say something nice to us.</source>
          <target state="translated">컨트롤러 생성기는 &lt;code&gt;generate controller ControllerName action1 action2&lt;/code&gt; 형식의 매개 변수를 예상 합니다. &lt;strong&gt;hello&lt;/strong&gt; 액션을 사용하여 &lt;code&gt;Greetings&lt;/code&gt; 컨트롤러를 만들어 봅시다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8e08338cd0b1efee95e6b15a145de00ca8c2592" translate="yes" xml:space="preserve">
          <source>The controller generator will then try to invoke the following generators:</source>
          <target state="translated">그런 다음 컨트롤러 생성기는 다음 생성기를 호출하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="04cae75b5b556346c3da0fc2b55f4f5406e79d74" translate="yes" xml:space="preserve">
          <source>The controller instance that will be tested.</source>
          <target state="translated">테스트 할 컨트롤러 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="ba4e4a23e337dd486854ab7fd4de7b5b21c9ce42" translate="yes" xml:space="preserve">
          <source>The controller name</source>
          <target state="translated">컨트롤러 이름</target>
        </trans-unit>
        <trans-unit id="52b3d62a80b893c0af96954722743dc733ac244f" translate="yes" xml:space="preserve">
          <source>The controller naming convention differs from the naming convention of models, which are expected to be named in singular form.</source>
          <target state="translated">컨트롤러 이름 지정 규칙은 모델의 이름 지정 규칙과 다르며 단일 형식으로 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="a90a98546ad209e6f30fc6ff251c11291addd85d" translate="yes" xml:space="preserve">
          <source>The controller specifies a form builder as its default:</source>
          <target state="translated">컨트롤러는 양식 빌더를 기본값으로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="7be5224e20df3dc10e5cf3e8d85eaa5d4b308f70" translate="yes" xml:space="preserve">
          <source>The controller would receive the form data again in &lt;code&gt;params[:person]&lt;/code&gt;, ready to be passed to &lt;code&gt;Person#update&lt;/code&gt;:</source>
          <target state="translated">컨트롤러는 &lt;code&gt;params[:person]&lt;/code&gt; 에서 양식 데이터를 다시 수신하여 &lt;code&gt;Person#update&lt;/code&gt; 에 전달 될 준비를합니다 .</target>
        </trans-unit>
        <trans-unit id="e93c04fcb7f426a21bc3c650cf6a666d160cdd94" translate="yes" xml:space="preserve">
          <source>The cookie is then automatically sent to the connection instance when a new connection is attempted, and you use that to set the &lt;code&gt;current_user&lt;/code&gt;. By identifying the connection by this same current user, you're also ensuring that you can later retrieve all open connections by a given user (and potentially disconnect them all if the user is deleted or unauthorized).</source>
          <target state="translated">그런 다음 쿠키는 새 연결을 시도 할 때 연결 인스턴스로 자동 전송되며이를 사용하여 &lt;code&gt;current_user&lt;/code&gt; 를 설정합니다 . 동일한 현재 사용자가 연결을 식별하면 나중에 지정된 사용자가 열려있는 모든 연결을 검색 할 수 있습니다 (사용자가 삭제되거나 권한이없는 경우 연결을 모두 끊을 수 있음).</target>
        </trans-unit>
        <trans-unit id="3b978663c88fcd057d23578b5892ec1015819225" translate="yes" xml:space="preserve">
          <source>The cookie jar used for storage is automatically configured to be the best possible option given your application's configuration.</source>
          <target state="translated">스토리지에 사용되는 쿠키 jar는 애플리케이션 구성에 따라 가능한 최상의 옵션으로 자동 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a1a69e495ad347de251d66e9dc711b0b85146a28" translate="yes" xml:space="preserve">
          <source>The cookies being read are the ones received along with the request, the cookies being written will be sent out with the response. Reading a cookie does not get the cookie object itself back, just the value it holds.</source>
          <target state="translated">읽고있는 쿠키는 요청과 함께 수신 된 쿠키이며, 작성된 쿠키는 응답과 함께 발송됩니다. 쿠키를 읽으면 쿠키 개체 자체를 다시 가져 오지 않고 쿠키 값만 유지합니다.</target>
        </trans-unit>
        <trans-unit id="d2ec0a6c857355d2a77edc69892b6454accdc087" translate="yes" xml:space="preserve">
          <source>The cookies of the request that initiated the WebSocket connection. Useful for performing authorization checks.</source>
          <target state="translated">WebSocket 연결을 시작한 요청 쿠키. 권한 확인을 수행하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d24e6f7bfad20509e5ec611cc5185e0596d388f6" translate="yes" xml:space="preserve">
          <source>The core features of Active Storage require the following permissions: &lt;code&gt;s3:ListBucket&lt;/code&gt;, &lt;code&gt;s3:PutObject&lt;/code&gt;, &lt;code&gt;s3:GetObject&lt;/code&gt;, and &lt;code&gt;s3:DeleteObject&lt;/code&gt;. If you have additional upload options configured such as setting ACLs then additional permissions may be required.</source>
          <target state="translated">Active Storage의 핵심 기능에는 &lt;code&gt;s3:ListBucket&lt;/code&gt; , &lt;code&gt;s3:PutObject&lt;/code&gt; , &lt;code&gt;s3:GetObject&lt;/code&gt; 및 &lt;code&gt;s3:DeleteObject&lt;/code&gt; 권한이 필요합니다 . ACL 설정과 같은 추가 업로드 옵션이 구성된 경우 추가 권한이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89dba8ea66f6ccf7268e1acbe6bfce7be69806f0" translate="yes" xml:space="preserve">
          <source>The core method of this helper, &lt;code&gt;form_for&lt;/code&gt;, gives you the ability to create a form for a model instance; for example, let's say that you have a model Person and want to create a new instance of it:</source>
          <target state="translated">이 헬퍼의 핵심 메소드 인 &lt;code&gt;form_for&lt;/code&gt; 는 모델 인스턴스의 양식을 작성하는 기능을 제공합니다. 예를 들어, Person 모델이 있고 새로운 인스턴스를 작성하려고한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="22182258bb24434e2f5ce14455e2da22cd0f35b3" translate="yes" xml:space="preserve">
          <source>The corresponding migration might look like this:</source>
          <target state="translated">해당 마이그레이션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e2f3e193087bef642d879558a359d9a7d2b3b7c" translate="yes" xml:space="preserve">
          <source>The corresponding route helper would be &lt;code&gt;publisher_magazine_photo_url&lt;/code&gt;, requiring you to specify objects at all three levels. Indeed, this situation is confusing enough that a popular &lt;a href=&quot;http://weblog.jamisbuck.org/2007/2/5/nesting-resources&quot;&gt;article&lt;/a&gt; by Jamis Buck proposes a rule of thumb for good Rails design:</source>
          <target state="translated">해당 경로 도우미는 &lt;code&gt;publisher_magazine_photo_url&lt;/code&gt; 이므로 세 수준에서 모두 개체를 지정해야합니다. 실제로 이러한 상황은 Jamis Buck 의 인기있는 &lt;a href=&quot;http://weblog.jamisbuck.org/2007/2/5/nesting-resources&quot;&gt;기사&lt;/a&gt; 가 훌륭한 Rails 디자인을위한 경험 법칙을 제안 할 정도로 충분히 혼란스러워합니다 .</target>
        </trans-unit>
        <trans-unit id="d600c0a250e0928ac6de22ac20a4fbd9eca881c9" translate="yes" xml:space="preserve">
          <source>The corresponding view &lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; using &lt;code&gt;form_with&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;app/views/articles/new.html.erb&lt;/code&gt; 사용 하는 해당보기 app / views / articles / &lt;code&gt;form_with&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a577608768a71c2c08295f75630ffb78a1a65cf" translate="yes" xml:space="preserve">
          <source>The currency unit and number formatting of the current locale will be used unless otherwise specified in the provided options. No currency conversion is performed. If the user is given a way to change their locale, they will also be able to change the relative value of the currency displayed with this helper. If your application will ever support multiple locales, you may want to specify a constant &lt;code&gt;:locale&lt;/code&gt; option or consider using a library capable of currency conversion.</source>
          <target state="translated">제공된 옵션에서 달리 지정하지 않는 한 현재 로캘의 통화 단위 및 숫자 형식이 사용됩니다. 통화 변환이 수행되지 않습니다. 사용자에게 로케일을 변경할 수있는 방법이 제공되면이 헬퍼와 함께 표시되는 통화의 상대적인 값을 변경할 수도 있습니다. 응용 프로그램에서 여러 로캘을 지원하는 경우 상수 &lt;code&gt;:locale&lt;/code&gt; 옵션 을 지정 하거나 통화 변환이 가능한 라이브러리를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="88858758e548e1fb8c2e4b0554808d46b298c330" translate="yes" xml:space="preserve">
          <source>The current frame is marked with &lt;code&gt;--&amp;gt;&lt;/code&gt;. You can move anywhere you want in this trace (thus changing the context) by using the &lt;code&gt;frame n&lt;/code&gt; command, where &lt;em&gt;n&lt;/em&gt; is the specified frame number. If you do that, &lt;code&gt;byebug&lt;/code&gt; will display your new context.</source>
          <target state="translated">현재 프레임은 &lt;code&gt;--&amp;gt;&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;frame n&lt;/code&gt; 명령 을 사용하여이 추적에서 원하는 곳으로 이동할 수 있습니다 (따라서 컨텍스트 변경) . 여기서 &lt;em&gt;n&lt;/em&gt; 은 지정된 프레임 번호입니다. 그렇게하면 &lt;code&gt;byebug&lt;/code&gt; 가 새로운 컨텍스트를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="de70478027d378d1cfe8224088c01c2644f724e1" translate="yes" xml:space="preserve">
          <source>The current iteration of the partial.</source>
          <target state="translated">부분의 현재 반복입니다.</target>
        </trans-unit>
        <trans-unit id="6268442757ea009174f8acb5e84aea3dd8362229" translate="yes" xml:space="preserve">
          <source>The current object being rendered, as well as the object_counter, will be available as local variables inside the layout template under the same names as available in the partial.</source>
          <target state="translated">렌더링중인 현재 객체와 object_counter는 레이아웃 템플릿 내에서 부분 변수에서 사용 가능한 것과 동일한 이름으로 로컬 변수로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="092a267cca37a3c80e64302819266668fd7ce2e6" translate="yes" xml:space="preserve">
          <source>The current release series and the next most recent one will receive patches and new versions in case of a security issue.</source>
          <target state="translated">현재 릴리스 시리즈와 다음 최신 릴리스는 보안 문제가 발생할 경우 패치와 새 버전을받습니다.</target>
        </trans-unit>
        <trans-unit id="37fe7ad050bfe08450ff7b69abfaee12f63ea922" translate="yes" xml:space="preserve">
          <source>The custom &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; class is automatically merged with the options of a nested &lt;a href=&quot;formhelper#method-i-fields_for&quot;&gt;#fields_for&lt;/a&gt; call, unless it's explicitly set.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 클래스는 명시 적으로 설정되어 있지 않으면 중첩 된 &lt;a href=&quot;formhelper#method-i-fields_for&quot;&gt;#fields_for&lt;/a&gt; 호출 옵션과 자동으로 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="680d7ec1de33e8fa716b48ba4e0e304e4df83a85" translate="yes" xml:space="preserve">
          <source>The custom &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; class is automatically merged with the options of a nested &lt;code&gt;fields&lt;/code&gt; call, unless it's explicitly set.</source>
          <target state="translated">사용자 정의 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 클래스는 명시 적으로 설정되어 있지 않으면 중첩 된 &lt;code&gt;fields&lt;/code&gt; 호출 옵션과 자동으로 병합됩니다 .</target>
        </trans-unit>
        <trans-unit id="49271f8c4deb70ba6d14f37c6d32084ffa8bbedf" translate="yes" xml:space="preserve">
          <source>The customer class now has the following methods to manipulate the value objects:</source>
          <target state="translated">customer 클래스에는 값 객체를 조작하는 다음과 같은 메소드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb5d4b3c92a99df5c5226c0136446a9d44e487fa" translate="yes" xml:space="preserve">
          <source>The debugger can also help you if you want to learn about the Rails source code but don't know where to start. Just debug any request to your application and use this guide to learn how to move from the code you have written into the underlying Rails code.</source>
          <target state="translated">Rails 소스 코드에 대해 배우고 싶지만 시작 위치를 모르는 경우 디버거가 도움이 될 수 있습니다. 애플리케이션에 대한 요청을 디버그하고이 가이드를 사용하여 작성한 Rails 코드에서 작성한 코드에서 이동하는 방법을 배우십시오.</target>
        </trans-unit>
        <trans-unit id="b5935b676f3b260677cf3404e8139a226e615c40" translate="yes" xml:space="preserve">
          <source>The debugger can list, stop, resume, and switch between running threads by using the &lt;code&gt;thread&lt;/code&gt; command (or the abbreviated &lt;code&gt;th&lt;/code&gt;). This command has a handful of options:</source>
          <target state="translated">디버거는 &lt;code&gt;thread&lt;/code&gt; 명령 (또는 축약 된 &lt;code&gt;th&lt;/code&gt; ) 을 사용하여 실행중인 스레드를 나열, 중지, 재개 및 전환 할 수 있습니다 . 이 명령에는 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="40c1b56945614754ba8bcd9b896199640af123be" translate="yes" xml:space="preserve">
          <source>The debugger creates a context when a stopping point or an event is reached. The context has information about the suspended program which enables the debugger to inspect the frame stack, evaluate variables from the perspective of the debugged program, and know the place where the debugged program is stopped.</source>
          <target state="translated">디버거는 중지 지점 또는 이벤트에 도달하면 컨텍스트를 작성합니다. 이 컨텍스트에는 디버거가 프레임 스택을 검사하고 디버깅 된 프로그램의 관점에서 변수를 평가하며 디버깅 된 프로그램이 중지 된 위치를 알 수 있도록하는 일시 중단 된 프로그램에 대한 정보가 있습니다.</target>
        </trans-unit>
        <trans-unit id="21886789df11ea9338c71bc1e713dc0ce0b78495" translate="yes" xml:space="preserve">
          <source>The declaration can also include an &lt;code&gt;options&lt;/code&gt; hash to specialize the behavior of the association.</source>
          <target state="translated">선언에는 연결 동작을 특수화하기위한 해시 &lt;code&gt;options&lt;/code&gt; 도 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="49199abadcd9f974ed88dc3d7ccd19edc4680383" translate="yes" xml:space="preserve">
          <source>The declaration may include an &lt;code&gt;options&lt;/code&gt; hash to specialize the behavior of the association.</source>
          <target state="translated">선언에는 연관 동작을 특수화하기 위한 &lt;code&gt;options&lt;/code&gt; 해시 가 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2ab15d11218b04ab1e55edd9e2351474404876f9" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; Controller stack includes all renderers, which means you can use &lt;code&gt;render :json&lt;/code&gt; and brothers freely in your controllers. Keep in mind that templates are not going to be rendered, so you need to ensure your controller is calling either &lt;code&gt;render&lt;/code&gt; or &lt;code&gt;redirect_to&lt;/code&gt; in all actions, otherwise it will return 204 No Content.</source>
          <target state="translated">기본 &lt;a href=&quot;api&quot;&gt;API&lt;/a&gt; 컨트롤러 스택에는 모든 렌더러가 포함 되므로 컨트롤러에서 &lt;code&gt;render :json&lt;/code&gt; 및 brothers를 자유롭게 사용할 수 있습니다 . 템플릿은 렌더링되지 않으므로 컨트롤러가 모든 작업에서 &lt;code&gt;render&lt;/code&gt; 또는 &lt;code&gt;redirect_to&lt;/code&gt; 를 호출하는지 확인해야합니다 . 그렇지 않으면 204 No Content가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="dc90e3304a747d9958eb86ef66ce3055efc93b4d" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt; implementation assumes that the encoding of the string is UTF-8, if you want to handle different encodings you can write your own multibyte string handler and configure it through &lt;a href=&quot;../multibyte#method-c-proxy_class&quot;&gt;ActiveSupport::Multibyte.proxy_class&lt;/a&gt;.</source>
          <target state="translated">기본 &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt; 구현은 문자열의 인코딩이 UTF-8이라고 가정합니다. 다른 인코딩을 처리하려면 자체 멀티 바이트 문자열 핸들러를 작성하고 &lt;a href=&quot;../multibyte#method-c-proxy_class&quot;&gt;ActiveSupport :: Multibyte.proxy_class를&lt;/a&gt; 통해이를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b0d39dd78e8545ab21333b000c8adbc3abe6b759" translate="yes" xml:space="preserve">
          <source>The default &lt;a href=&quot;connectionpool&quot;&gt;ConnectionPool&lt;/a&gt; maximum size is 5.</source>
          <target state="translated">기본 &lt;a href=&quot;connectionpool&quot;&gt;ConnectionPool&lt;/a&gt; 최대 크기는 5입니다.</target>
        </trans-unit>
        <trans-unit id="417f6a3218aa19f90d2676b492b9137303dbd659" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;en.yml&lt;/code&gt; locale in this directory contains a sample pair of translation strings:</source>
          <target state="translated">이 디렉토리 의 기본 &lt;code&gt;en.yml&lt;/code&gt; 로켈에는 샘플 번역 문자열 쌍이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d259d82af709edf493880239feb894d39f182f" translate="yes" xml:space="preserve">
          <source>The default Content-Type and Content-Disposition headers are set to download arbitrary binary files in as many browsers as possible. IE versions 4, 5, 5.5, and 6 are all known to have a variety of quirks (especially when downloading over SSL).</source>
          <target state="translated">기본 Content-Type 및 Content-Disposition 헤더는 가능한 많은 브라우저에서 임의의 이진 파일을 다운로드하도록 설정되어 있습니다. IE 버전 4, 5, 5.5 및 6은 모두 다양한 특징을 가지고있는 것으로 알려져 있습니다 (특히 SSL을 통해 다운로드 할 때).</target>
        </trans-unit>
        <trans-unit id="db07404c73b8a2a45b04e8b6ffb034a810331405" translate="yes" xml:space="preserve">
          <source>The default Rails log level is &lt;code&gt;debug&lt;/code&gt; in all environments.</source>
          <target state="translated">기본 Rails 로그 레벨은 모든 환경에서 &lt;code&gt;debug&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="38a0c4e49d718aec7078c57bc4c8099a64d09f22" translate="yes" xml:space="preserve">
          <source>The default XML builder is a fresh instance of &lt;code&gt;Builder::XmlMarkup&lt;/code&gt;. You can configure your own builder via the &lt;code&gt;:builder&lt;/code&gt; option. The method also accepts options like &lt;code&gt;:dasherize&lt;/code&gt; and friends, they are forwarded to the builder:</source>
          <target state="translated">기본 XML 빌더는 &lt;code&gt;Builder::XmlMarkup&lt;/code&gt; 의 새로운 인스턴스입니다 . &lt;code&gt;:builder&lt;/code&gt; 옵션을 통해 자체 빌더를 구성 할 수 있습니다 . 이 방법은 또한 &lt;code&gt;:dasherize&lt;/code&gt; 및 friends와 같은 옵션을 허용 하며 빌더로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="4ff911b45d3f05d4d40816676a3ed43ffe82d1a8" translate="yes" xml:space="preserve">
          <source>The default XML builder is a fresh instance of &lt;code&gt;Builder::XmlMarkup&lt;/code&gt;. You can configure your own builder with the &lt;code&gt;:builder&lt;/code&gt; option. The method also accepts options like &lt;code&gt;:dasherize&lt;/code&gt; and friends, they are forwarded to the builder.</source>
          <target state="translated">기본 XML 빌더는 &lt;code&gt;Builder::XmlMarkup&lt;/code&gt; 의 새로운 인스턴스입니다 . &lt;code&gt;:builder&lt;/code&gt; 옵션을 사용하여 자체 빌더를 구성 할 수 있습니다 . 이 방법은 또한 &lt;code&gt;:dasherize&lt;/code&gt; 및 friends와 같은 옵션을 허용 하며 빌더로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="fdfbcaff28aa74fc6b3972d42c3a0b707432a40f" translate="yes" xml:space="preserve">
          <source>The default behavior can be changed by setting the config options to a custom class:</source>
          <target state="translated">구성 옵션을 사용자 정의 클래스로 설정하여 기본 동작을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964deb4deb137c72b1a8c946cd6ea798ee2b77c0" translate="yes" xml:space="preserve">
          <source>The default configuration for Rails 6</source>
          <target state="translated">Rails 6의 기본 구성</target>
        </trans-unit>
        <trans-unit id="e5118e78e0f72e8d201c79ffa5ee19f3bb74d601" translate="yes" xml:space="preserve">
          <source>The default confirmation uses a JavaScript confirm dialog, but you can customize this by listening to the &lt;code&gt;confirm&lt;/code&gt; event, which is fired just before the confirmation window appears to the user. To cancel this default confirmation, have the confirm handler to return &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">기본 확인은 JavaScript 확인 ​​대화 상자를 사용하지만 확인 창이 사용자에게 표시되기 직전에 시작되는 &lt;code&gt;confirm&lt;/code&gt; 이벤트 를 수신하여이를 사용자 정의 할 수 있습니다 . 이 기본 확인을 취소하려면 확인 핸들러가 &lt;code&gt;false&lt;/code&gt; 를 리턴하도록하십시오 .</target>
        </trans-unit>
        <trans-unit id="6bbe748864f65ace153e63b32d9fb9aae5ccc443" translate="yes" xml:space="preserve">
          <source>The default error message for &lt;code&gt;validates_associated&lt;/code&gt; is &lt;em&gt;&quot;is invalid&quot;&lt;/em&gt;. Note that each associated object will contain its own &lt;code&gt;errors&lt;/code&gt; collection; errors do not bubble up to the calling model.</source>
          <target state="translated">&lt;code&gt;validates_associated&lt;/code&gt; 의 기본 오류 메시지 는 &lt;em&gt;&quot;잘못된&quot;&lt;/em&gt; 입니다. 연결된 각 객체에는 자체 &lt;code&gt;errors&lt;/code&gt; 수집 이 포함됩니다 . 오류는 호출 모델에 영향을 미치지 않습니다.</target>
        </trans-unit>
        <trans-unit id="867423ae48db625181e81d46b4c69e62f28c825d" translate="yes" xml:space="preserve">
          <source>The default error message for this helper is &lt;em&gt;&quot;doesn't match confirmation&quot;&lt;/em&gt;.</source>
          <target state="translated">이 헬퍼의 기본 오류 메시지는 &lt;em&gt;&quot;일치하지 않습니다 확인&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="191962cf0a53a5a6e818b0f1aca5743ac55311d9" translate="yes" xml:space="preserve">
          <source>The default error message for this helper is &lt;em&gt;&quot;is not included in the list&quot;&lt;/em&gt;.</source>
          <target state="translated">이 헬퍼의 기본 오류 메시지는 &lt;em&gt;&quot;목록에 포함되어 있지 않습니다&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1fb5c5ae103bf01f69e90eaa63675b328ed1a1c" translate="yes" xml:space="preserve">
          <source>The default error message is &lt;em&gt;&quot;has already been taken&quot;&lt;/em&gt;.</source>
          <target state="translated">기본 오류 메시지는 &lt;em&gt;&quot;이미 사용되었습니다&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9457ef49196b5a4950348b7a27e4d880cb9c20c8" translate="yes" xml:space="preserve">
          <source>The default error message is &lt;em&gt;&quot;is invalid&quot;&lt;/em&gt;.</source>
          <target state="translated">기본 오류 메시지는 &lt;em&gt;&quot;잘못된&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ba637f7bfb2bf214d7ab58eb7fa9d57e04657f8f" translate="yes" xml:space="preserve">
          <source>The default error message is &lt;em&gt;&quot;is not a number&quot;&lt;/em&gt;.</source>
          <target state="translated">기본 오류 메시지는 &lt;em&gt;&quot;숫자가 아닙니다&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="9335fb9ba4197c3649d79cacccddab3b123bd729" translate="yes" xml:space="preserve">
          <source>The default error message is &lt;em&gt;&quot;is reserved&quot;&lt;/em&gt;.</source>
          <target state="translated">기본 오류 메시지는 &lt;em&gt;&quot;is reserved&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f4903f326fc4f8f3dc2774dfae143f7d309b858" translate="yes" xml:space="preserve">
          <source>The default error message is &lt;em&gt;&quot;must be blank&quot;&lt;/em&gt;.</source>
          <target state="translated">기본 오류 메시지는 &lt;em&gt;&quot;must be blank&quot;&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e1ac826384501a459391f77dccc506bc756093f" translate="yes" xml:space="preserve">
          <source>The default error messages depend on the type of length validation being performed. You can personalize these messages using the &lt;code&gt;:wrong_length&lt;/code&gt;, &lt;code&gt;:too_long&lt;/code&gt;, and &lt;code&gt;:too_short&lt;/code&gt; options and &lt;code&gt;%{count}&lt;/code&gt; as a placeholder for the number corresponding to the length constraint being used. You can still use the &lt;code&gt;:message&lt;/code&gt; option to specify an error message.</source>
          <target state="translated">기본 오류 메시지는 수행중인 길이 유효성 검사 유형에 따라 다릅니다. 이러한 사용하여 메시지를 개인화 할 수 &lt;code&gt;:wrong_length&lt;/code&gt; , &lt;code&gt;:too_long&lt;/code&gt; 및 &lt;code&gt;:too_short&lt;/code&gt; 옵션 &lt;code&gt;%{count}&lt;/code&gt; 수가 사용되는 길이 제한에 해당위한 자리 표시 자입니다. 여전히 &lt;code&gt;:message&lt;/code&gt; 옵션을 사용하여 오류 메시지를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b13f3a7afb4a9725957b1897d9ead715643512bb" translate="yes" xml:space="preserve">
          <source>The default implementation does nothing; the implementation should be overridden by concrete adapters.</source>
          <target state="translated">기본 구현은 아무 것도 수행하지 않습니다. 구현은 콘크리트 어댑터로 대체되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3e74ab6be939a5c78f62ad5e60efb485ede92294" translate="yes" xml:space="preserve">
          <source>The default inheritance column name is &lt;code&gt;type&lt;/code&gt;, which means it's a reserved word inside Active Record. To be able to use single-table inheritance with another column name, or to use the column &lt;code&gt;type&lt;/code&gt; in your own model for something else, you can set &lt;code&gt;inheritance_column&lt;/code&gt;:</source>
          <target state="translated">기본 상속 열 이름은 &lt;code&gt;type&lt;/code&gt; 이며 이는 Active Record 내부의 예약어임을 의미합니다. 다른 테이블 이름으로 단일 테이블 상속을 사용하거나 다른 모델 의 열 &lt;code&gt;type&lt;/code&gt; 을 사용하려면 &lt;code&gt;inheritance_column&lt;/code&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b04d3ac6d07f3c41ce5d77eae396450a01409f4" translate="yes" xml:space="preserve">
          <source>The default is 5 minutes.</source>
          <target state="translated">기본값은 5 분입니다.</target>
        </trans-unit>
        <trans-unit id="1b67e281a2d48140c816abd25a470778ff77b5bf" translate="yes" xml:space="preserve">
          <source>The default is &lt;code&gt;/rails/active_storage&lt;/code&gt;.</source>
          <target state="translated">기본값은 &lt;code&gt;/rails/active_storage&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c3000af20082800ed1719b2c75850c9c000fd27e" translate="yes" xml:space="preserve">
          <source>The default locale is used for all translations unless &lt;code&gt;I18n.locale=&lt;/code&gt; or &lt;code&gt;I18n.with_locale&lt;/code&gt; is used.</source>
          <target state="translated">&lt;code&gt;I18n.locale=&lt;/code&gt; 또는 &lt;code&gt;I18n.with_locale&lt;/code&gt; 을 사용 하지 않으면 모든 번역에 기본 로캘이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="bdea9edbdc10997d0fc7eb472e80325679677f90" translate="yes" xml:space="preserve">
          <source>The default locale loading mechanism in Rails does not load locale files in nested dictionaries, like we have here. So, for this to work, we must explicitly tell Rails to look further:</source>
          <target state="translated">Rails의 기본 로케일 로딩 메커니즘은 여기에서와 같이 중첩 된 사전에 로케일 파일을로드하지 않습니다. 따라서 이것이 작동하려면 Rails에 명시 적으로 추가로 지시해야합니다.</target>
        </trans-unit>
        <trans-unit id="0c2d50ec5de29e7e39e2abf4cdda42eed22420e0" translate="yes" xml:space="preserve">
          <source>The default location for the manifest is the root of the location specified in &lt;code&gt;config.assets.prefix&lt;/code&gt; ('/assets' by default).</source>
          <target state="translated">매니페스트의 기본 위치는 &lt;code&gt;config.assets.prefix&lt;/code&gt; 에 지정된 위치의 루트입니다 (기본적으로 '/ assets').</target>
        </trans-unit>
        <trans-unit id="f81c8358ebf064bc1b12157c51e2df2cc81232bf" translate="yes" xml:space="preserve">
          <source>The default locations are: the &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;javascripts&lt;/code&gt; and &lt;code&gt;stylesheets&lt;/code&gt; directories under the &lt;code&gt;app/assets&lt;/code&gt; folder, but these subdirectories are not special - any path under &lt;code&gt;assets/*&lt;/code&gt; will be searched.</source>
          <target state="translated">기본 위치는 &lt;code&gt;app/assets&lt;/code&gt; 폴더 아래 의 &lt;code&gt;images&lt;/code&gt; , &lt;code&gt;javascripts&lt;/code&gt; 및 &lt;code&gt;stylesheets&lt;/code&gt; 디렉토리 이지만 이러한 하위 디렉토리는 특별하지 않습니다 . &lt;code&gt;assets/*&lt;/code&gt; 아래의 경로 가 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="1c2b4eace4f7484f211975650ac9a2dae6cb21cb" translate="yes" xml:space="preserve">
          <source>The default mailer queue name is &lt;code&gt;mailers&lt;/code&gt;. This configuration option allows you to globally change the queue name. Set the following in your config:</source>
          <target state="translated">기본 메일러 큐 이름은 &lt;code&gt;mailers&lt;/code&gt; 입니다. 이 구성 옵션을 사용하면 큐 이름을 전체적으로 변경할 수 있습니다. 구성에서 다음을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="d40a6c3b3003507f3c7ed2c5fd5c5f76c65efea7" translate="yes" xml:space="preserve">
          <source>The default matcher for compiling files includes &lt;code&gt;application.js&lt;/code&gt;, &lt;code&gt;application.css&lt;/code&gt; and all non-JS/CSS files (this will include all image assets automatically) from &lt;code&gt;app/assets&lt;/code&gt; folders including your gems:</source>
          <target state="translated">파일 컴파일의 기본 매처에는 gem을 포함하여 &lt;code&gt;app/assets&lt;/code&gt; 폴더의 &lt;code&gt;application.js&lt;/code&gt; , &lt;code&gt;application.css&lt;/code&gt; 및 모든 비 JS / CSS 파일 (모든 이미지 자산이 자동으로 포함됨)이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="ed073a8405e9ab34fc3dac43c68ab0a495c2a384" translate="yes" xml:space="preserve">
          <source>The default middlewares shown here (and some others) are each summarized in the &lt;a href=&quot;#internal-middleware-stack&quot;&gt;Internal Middlewares&lt;/a&gt; section, below.</source>
          <target state="translated">여기에 표시된 기본 미들웨어 및 기타 미들웨어는 각각 &lt;a href=&quot;#internal-middleware-stack&quot;&gt;내부 미들웨어&lt;/a&gt; 섹션에 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a3c7bfab60bb2a9340081d984047c607d31607f" translate="yes" xml:space="preserve">
          <source>The default normalization used for operations that require normalization. It can be set to any of the normalizations in &lt;a href=&quot;unicode#NORMALIZATION_FORMS&quot;&gt;NORMALIZATION_FORMS&lt;/a&gt;.</source>
          <target state="translated">정규화가 필요한 작업에 사용되는 기본 정규화입니다. &lt;a href=&quot;unicode#NORMALIZATION_FORMS&quot;&gt;NORMALIZATION_FORMS&lt;/a&gt; 의 정규화 중 하나로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8a301994a79c75534c49b79a61a4664b4e721cdd" translate="yes" xml:space="preserve">
          <source>The default parallelization method is to fork processes using Ruby's DRb system. The processes are forked based on the number of workers provided. The default number is the actual core count on the machine you are on, but can be changed by the number passed to the parallelize method.</source>
          <target state="translated">기본 병렬화 방법은 Ruby의 DRb 시스템을 사용하여 프로세스를 분기하는 것입니다. 프로세스는 제공된 작업자 수에 따라 분기됩니다. 기본 숫자는 사용중인 머신의 실제 코어 수이지만 parallelize 메소드에 전달 된 숫자로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f767b8f5ac6c561f9d1d4776585774fb62693a4e" translate="yes" xml:space="preserve">
          <source>The default parallelization method is to fork processes. If you'd like to use threads instead you can pass &lt;code&gt;with: :threads&lt;/code&gt; to the &lt;code&gt;parallelize&lt;/code&gt; method. Note the threaded parallelization does not create multiple database and will not work with system tests at this time.</source>
          <target state="translated">기본 병렬화 방법은 프로세스를 분기하는 것입니다. 당신이 스레드를 사용하려는 경우 대신 당신은 전달할 수 있습니다 &lt;code&gt;with: :threads&lt;/code&gt; 받는 &lt;code&gt;parallelize&lt;/code&gt; 방법. 스레드 병렬화는 여러 데이터베이스를 작성하지 않으며 현재 시스템 테스트에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b1d81ea25551b6dbe82955f22e7b61026f6857f" translate="yes" xml:space="preserve">
          <source>The default query string in Rails 2.x is based on the modification time of the files. When assets are deployed to a cluster, there is no guarantee that the timestamps will be the same, resulting in different values being used depending on which server handles the request.</source>
          <target state="translated">Rails 2.x의 기본 쿼리 문자열은 파일 수정 시간을 기반으로합니다. 자산이 클러스터에 배포 될 때 타임 스탬프가 동일하다는 보장이 없으므로 요청을 처리하는 서버에 따라 다른 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="147c7acadfc41f5f5e59a90b1e7884d58638c717" translate="yes" xml:space="preserve">
          <source>The default queue name prefix delimiter is '_'. This can be changed by setting &lt;code&gt;config.active_job.queue_name_delimiter&lt;/code&gt; in &lt;code&gt;application.rb&lt;/code&gt;:</source>
          <target state="translated">기본 큐 이름 접두어 분리 문자는 '_'입니다. &lt;code&gt;application.rb&lt;/code&gt; 에서 &lt;code&gt;config.active_job.queue_name_delimiter&lt;/code&gt; 를 설정하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8552b825d22023630bc90a85bfa0ff7ef0a73f83" translate="yes" xml:space="preserve">
          <source>The default sanitizer is Rails::Html::SafeListSanitizer. See &lt;a href=&quot;https://github.com/rails/rails-html-sanitizer&quot;&gt;Rails HTML Sanitizers&lt;/a&gt; for more information.</source>
          <target state="translated">기본 소독제는 Rails :: Html :: SafeListSanitizer입니다. 자세한 내용은 &lt;a href=&quot;https://github.com/rails/rails-html-sanitizer&quot;&gt;Rails HTML Sanitizer&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b2016ca14211876c1edaa8337a906e443cb4b6a4" translate="yes" xml:space="preserve">
          <source>The default serializer for new applications is &lt;code&gt;:json&lt;/code&gt;. For compatibility with old applications with existing cookies, &lt;code&gt;:marshal&lt;/code&gt; is used when &lt;code&gt;serializer&lt;/code&gt; option is not specified.</source>
          <target state="translated">새 응용 프로그램의 기본 직렬 변환기는 &lt;code&gt;:json&lt;/code&gt; 입니다. 기존 쿠키와 함께 이전 응용 프로그램과의 호환성을 위해 &lt;code&gt;serializer&lt;/code&gt; 옵션이 지정되지 않은 경우 &lt;code&gt;:marshal&lt;/code&gt; 이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f47159673cb495ccbabe040b7bed54c0ab255c7c" translate="yes" xml:space="preserve">
          <source>The default setting is &lt;code&gt;true&lt;/code&gt;, which uses the partial at &lt;code&gt;/admin/articles/_article.erb&lt;/code&gt;. Setting the value to &lt;code&gt;false&lt;/code&gt; would render &lt;code&gt;/articles/_article.erb&lt;/code&gt;, which is the same behavior as rendering from a non-namespaced controller such as &lt;code&gt;ArticlesController&lt;/code&gt;.</source>
          <target state="translated">기본 설정은 &lt;code&gt;true&lt;/code&gt; 이며 &lt;code&gt;/admin/articles/_article.erb&lt;/code&gt; 부분을 ​​사용합니다 . 값을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 &lt;code&gt;/articles/_article.erb&lt;/code&gt; 가 렌더링 되며 &lt;code&gt;ArticlesController&lt;/code&gt; 와 같이 네임 스페이스가없는 컨트롤러에서 렌더링하는 것과 동일한 동작 입니다.</target>
        </trans-unit>
        <trans-unit id="515503b563ee9a5bbb4ae3beb0127d46d8fa5713" translate="yes" xml:space="preserve">
          <source>The default settings are Selenium, using Chrome, with a screen size of 1400x1400.</source>
          <target state="translated">기본 설정은 Chrome을 사용하는 화면 크기가 1400x1400 인 Selenium입니다.</target>
        </trans-unit>
        <trans-unit id="c5f8f103612c80ac874538744f53c5fe3b5cd267" translate="yes" xml:space="preserve">
          <source>The default sum of an empty list is zero. You can override this default:</source>
          <target state="translated">빈 목록의 기본 합계는 0입니다. 이 기본값을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="071a72da76e5b74a031c70449265c7fa7a2297fe" translate="yes" xml:space="preserve">
          <source>The default terminator halts the chain when a callback throws &lt;code&gt;:abort&lt;/code&gt;.</source>
          <target state="translated">콜백에서 &lt;code&gt;:abort&lt;/code&gt; 가 발생하면 기본 종료자가 체인을 중단 합니다.</target>
        </trans-unit>
        <trans-unit id="4697708713aa6085f40190002f8d6e33c97a56cf" translate="yes" xml:space="preserve">
          <source>The default test stub in &lt;code&gt;test/models/article_test.rb&lt;/code&gt; looks like this:</source>
          <target state="translated">&lt;code&gt;test/models/article_test.rb&lt;/code&gt; 의 기본 테스트 스텁은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a1270eb0f735549a1008a4527b95f164d8e96ac" translate="yes" xml:space="preserve">
          <source>The default trusted IPs list simply includes IP addresses that are guaranteed by the IP specification to be private addresses. Those will not be the ultimate client IP in production, and so are discarded. See &lt;a href=&quot;https://en.wikipedia.org/wiki/Private_network&quot;&gt;en.wikipedia.org/wiki/Private_network&lt;/a&gt; for details.</source>
          <target state="translated">기본 신뢰할 수있는 IP 목록에는 IP 사양에서 개인 주소로 보장되는 IP 주소 만 포함됩니다. 이들은 프로덕션에서 궁극적 인 클라이언트 IP가 아니므로 폐기됩니다. 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Private_network&quot;&gt;en.wikipedia.org/wiki/Private_network&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="23f60753d7620ad7eea0f11cae021bf7e9adc787" translate="yes" xml:space="preserve">
          <source>The default value for &lt;code&gt;include_root&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. You can change it to &lt;code&gt;true&lt;/code&gt; if the given &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; string includes a single root node.</source>
          <target state="translated">&lt;code&gt;include_root&lt;/code&gt; 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다. 주어진 &lt;a href=&quot;json&quot;&gt;JSON&lt;/a&gt; 문자열에 단일 루트 노드가 포함되어 있으면이 를 &lt;code&gt;true&lt;/code&gt; 로 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2995a2cd89ccb1c807ab761506e22c3579641b10" translate="yes" xml:space="preserve">
          <source>The default value is generated by trying to call &lt;code&gt;strftime&lt;/code&gt; with &amp;ldquo;%T.%L&amp;rdquo; on the object's value. It is still possible to override that by passing the &amp;ldquo;value&amp;rdquo; option.</source>
          <target state="translated">기본값 은 객체 값에서&amp;ldquo;% T. % L&amp;rdquo;로 &lt;code&gt;strftime&lt;/code&gt; 을 호출하여 생성됩니다 . &quot;value&quot;옵션을 전달하여이를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fce923ebd77135ee6e5a64fb412ca563cbb9a2f4" translate="yes" xml:space="preserve">
          <source>The default value is generated by trying to call &lt;code&gt;strftime&lt;/code&gt; with &amp;ldquo;%Y-%m&amp;rdquo; on the object's value, which makes it behave as expected for instances of &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; and &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport::TimeWithZone&lt;/a&gt;.</source>
          <target state="translated">기본값 은 객체 값에 &quot;% Y- % m&quot;을 사용하여 &lt;code&gt;strftime&lt;/code&gt; 을 호출하여 생성 되므로 &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; 및 &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport :: TimeWithZone&lt;/a&gt; 인스턴스에 대해 예상대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="51b813ed49344540ac2076972a7ceaf113ab8138" translate="yes" xml:space="preserve">
          <source>The default value is generated by trying to call &lt;code&gt;strftime&lt;/code&gt; with &amp;ldquo;%Y-%m-%d&amp;rdquo; on the object's value, which makes it behave as expected for instances of &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; and &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport::TimeWithZone&lt;/a&gt;. You can still override that by passing the &amp;ldquo;value&amp;rdquo; option explicitly, e.g.</source>
          <target state="translated">기본값 은 개체 값에 &quot;% Y- % m- % d&quot;를 사용하여 &lt;code&gt;strftime&lt;/code&gt; 을 호출하여 생성 되므로 &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; 및 &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport :: TimeWithZone&lt;/a&gt; 인스턴스에 대해 예상대로 동작합니다 . &quot;value&quot;옵션을 명시 적으로 전달하여이를 무시할 수 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="155f523aa7dab7eaef4a73cf5262806f48843b57" translate="yes" xml:space="preserve">
          <source>The default value is generated by trying to call &lt;code&gt;strftime&lt;/code&gt; with &amp;ldquo;%Y-%m-%dT%T&amp;rdquo; on the object's value, which makes it behave as expected for instances of &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; and &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport::TimeWithZone&lt;/a&gt;.</source>
          <target state="translated">기본값 은 개체 값에 &quot;% Y- % m- % dT % T&quot;를 사용하여 &lt;code&gt;strftime&lt;/code&gt; 을 호출하여 생성 되므로 &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; 및 &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport :: TimeWithZone&lt;/a&gt; 인스턴스에 대해 예상대로 동작합니다 .</target>
        </trans-unit>
        <trans-unit id="5e75e0fbb28eddbbcf15907c13cd835044074f14" translate="yes" xml:space="preserve">
          <source>The default value is generated by trying to call &lt;code&gt;strftime&lt;/code&gt; with &amp;ldquo;%Y-W%W&amp;rdquo; on the object's value, which makes it behave as expected for instances of &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; and &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport::TimeWithZone&lt;/a&gt;.</source>
          <target state="translated">기본값 은 객체 값에서&amp;ldquo;% YW % W&amp;rdquo;를 사용하여 &lt;code&gt;strftime&lt;/code&gt; 을 호출하여 생성 되므로 &lt;a href=&quot;../../datetime&quot;&gt;DateTime&lt;/a&gt; 및 &lt;a href=&quot;../../activesupport/timewithzone&quot;&gt;ActiveSupport :: TimeWithZone&lt;/a&gt; 인스턴스에 대해 예상대로 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="302a80951efeb150725e12d390b168e285d9d6c7" translate="yes" xml:space="preserve">
          <source>The defaults for these options can be localized, their keys are:</source>
          <target state="translated">이러한 옵션의 기본값은 현지화 될 수 있으며 해당 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1405dbd52b41e365289863e28f99fa1bd2332eb9" translate="yes" xml:space="preserve">
          <source>The delay of the retry</source>
          <target state="translated">재시도 지연</target>
        </trans-unit>
        <trans-unit id="0ddcccd9c048d80e5af182b551f880e6af315c21" translate="yes" xml:space="preserve">
          <source>The delegated method must be public on the target, otherwise it will raise &lt;code&gt;NoMethodError&lt;/code&gt;.</source>
          <target state="translated">위임 된 메소드는 대상에서 공개되어야합니다 . 그렇지 않으면 &lt;code&gt;NoMethodError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="4b09ac1b3fc3753d4f13bde06b487a8da159ea06" translate="yes" xml:space="preserve">
          <source>The delegated methods are public by default. Pass &lt;code&gt;private:
true&lt;/code&gt; to change that.</source>
          <target state="translated">위임 된 메소드는 기본적으로 공용입니다. 합격 &lt;code&gt;private: true&lt;/code&gt; 이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="b561c6d24076a191c3806cfbab4b44dc868d9533" translate="yes" xml:space="preserve">
          <source>The dependent &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; model will also automatically process attachments links as sent via the Trix-powered editor. These attachments are associated with the &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; model using Active Storage.</source>
          <target state="translated">종속 &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; 모델은 Trix 제공 편집기를 통해 전송 된 첨부 파일 링크도 자동으로 처리합니다. 이러한 첨부 파일은 Active Storage를 사용 하는 &lt;a href=&quot;richtext&quot;&gt;RichText&lt;/a&gt; 모델 과 연관됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b896f7775194663df7f16876df2a84f94b10d3b" translate="yes" xml:space="preserve">
          <source>The deprecated constant now returns the same object as the new one rather than a proxy object, so it can be used transparently in &lt;code&gt;rescue&lt;/code&gt; blocks etc.</source>
          <target state="translated">더 이상 사용되지 않는 상수는 이제 프록시 개체가 아닌 새 개체와 동일한 개체를 반환하므로 &lt;code&gt;rescue&lt;/code&gt; 블록 등에서 투명하게 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="036245d5d96624f479702d772eb72dcb5e11e8c4" translate="yes" xml:space="preserve">
          <source>The deprecation warning</source>
          <target state="translated">지원 중단 경고</target>
        </trans-unit>
        <trans-unit id="296534b4b5c0114d9b09d904b18e264419c9274a" translate="yes" xml:space="preserve">
          <source>The desired result can be accomplished by wrapping the known-safe string in Arel.sql:</source>
          <target state="translated">알려진 안전 문자열을 Arel.sql에 래핑하여 원하는 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f01e3ce935b75a14bcd55aaf7d5d0bb040f17e93" translate="yes" xml:space="preserve">
          <source>The differences with &lt;code&gt;Kernel#Array&lt;/code&gt; explained above apply to the rest of &lt;code&gt;object&lt;/code&gt;s.</source>
          <target state="translated">위에서 설명한 &lt;code&gt;Kernel#Array&lt;/code&gt; 와의 차이점 은 나머지 &lt;code&gt;object&lt;/code&gt; 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4f7d49b1ac826abef81ba5b39c283b9cef02d95" translate="yes" xml:space="preserve">
          <source>The different ways of debugging.</source>
          <target state="translated">다양한 디버깅 방법.</target>
        </trans-unit>
        <trans-unit id="4e465a9e2c0e5bd338b7983c7a2d3ecf29038df0" translate="yes" xml:space="preserve">
          <source>The digest will be generated using &lt;code&gt;virtual_path:&lt;/code&gt; if it is provided.</source>
          <target state="translated">요약 은 제공된 경우 &lt;code&gt;virtual_path:&lt;/code&gt; 사용하여 생성 됩니다.</target>
        </trans-unit>
        <trans-unit id="87e9e845de388090f6fedfdef8cbb1972b1b0d42" translate="yes" xml:space="preserve">
          <source>The digestor can be bypassed by passing skip_digest: true as an option to the cache call:</source>
          <target state="translated">캐시 호출에 옵션으로 skip_digest : true를 전달하면 다이제스트를 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9880525eeb47dcc8b1a61a667bcb1ac06388bf9" translate="yes" xml:space="preserve">
          <source>The directives that work in JavaScript files also work in stylesheets (though obviously including stylesheets rather than JavaScript files). The &lt;code&gt;require_tree&lt;/code&gt; directive in a CSS manifest works the same way as the JavaScript one, requiring all stylesheets from the current directory.</source>
          <target state="translated">JavaScript 파일에서 작동하는 지시문은 스타일 시트에서도 작동합니다 (JavaScript 파일이 아닌 스타일 시트 포함). CSS 매니페스트 의 &lt;code&gt;require_tree&lt;/code&gt; 지시문은 현재 디렉토리의 모든 스타일 시트를 요구하는 JavaScript의 지시문과 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="213bb5462a19fb4d16c75c50df8bd7cb3bb8fb11" translate="yes" xml:space="preserve">
          <source>The directory &lt;code&gt;test/mailers/previews&lt;/code&gt;.</source>
          <target state="translated">디렉토리 &lt;code&gt;test/mailers/previews&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db0a97cd4a13a2cce5468ae004d2f87eec98fccd" translate="yes" xml:space="preserve">
          <source>The distinction is in where you place the foreign key (it goes on the table for the class declaring the &lt;code&gt;belongs_to&lt;/code&gt; association), but you should give some thought to the actual meaning of the data as well. The &lt;code&gt;has_one&lt;/code&gt; relationship says that one of something is yours - that is, that something points back to you. For example, it makes more sense to say that a supplier owns an account than that an account owns a supplier. This suggests that the correct relationships are like this:</source>
          <target state="translated">구별은 외래 키를 배치하는 위치에 있으며 ( &lt;code&gt;belongs_to&lt;/code&gt; 연관을 선언하는 클래스의 테이블에서 진행 ) 데이터의 실제 의미에 대해서도 고려해야합니다. &lt;code&gt;has_one&lt;/code&gt; 의 입니다, 뭔가 포인트가 당신에게 다시 - 관계는 무엇인가 중 하나가 당신이라고 말한다. 예를 들어 공급 업체가 계정을 소유 한 것보다 공급 업체를 소유하고 있다고 말하는 것이 더 합리적입니다. 올바른 관계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="985c59a63de601354797a9003df4ab4f40409519" translate="yes" xml:space="preserve">
          <source>The documentation for &lt;code&gt;PermitScrubber&lt;/code&gt; and &lt;code&gt;TargetScrubber&lt;/code&gt; explains how you can gain complete control over when and how elements should be stripped.</source>
          <target state="translated">&lt;code&gt;PermitScrubber&lt;/code&gt; 및 &lt;code&gt;TargetScrubber&lt;/code&gt; 에 대한 설명서에는 요소 제거시기와 방법을 완벽하게 제어 할 수있는 방법이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a30f95b69b46783ce610879e86f95b33971917c" translate="yes" xml:space="preserve">
          <source>The driver name is a required argument for &lt;code&gt;driven_by&lt;/code&gt;. The optional arguments that can be passed to &lt;code&gt;driven_by&lt;/code&gt; are &lt;code&gt;:using&lt;/code&gt; for the browser (this will only be used by Selenium), &lt;code&gt;:screen_size&lt;/code&gt; to change the size of the screen for screenshots, and &lt;code&gt;:options&lt;/code&gt; which can be used to set options supported by the driver.</source>
          <target state="translated">&lt;code&gt;driven_by&lt;/code&gt; 의 드라이버 이름은 필수 인수입니다 . &lt;code&gt;driven_by&lt;/code&gt; 에 전달할 수있는 선택적 인수 는 브라우저의 경우 &lt;code&gt;:using&lt;/code&gt; (이는 Selenium에서만 사용됨), &lt;code&gt;:screen_size&lt;/code&gt; 는 스크린 샷의 화면 크기를 변경하고, &lt;code&gt;:options&lt;/code&gt; 는 지원되는 옵션을 설정하는 데 사용할 수 있습니다. 운전사.</target>
        </trans-unit>
        <trans-unit id="4997e6afb5b4fcd0fc1edb4cdc05bfb0a531e68e" translate="yes" xml:space="preserve">
          <source>The easiest way to add custom validators for validating individual attributes is with the convenient &lt;code&gt;ActiveModel::EachValidator&lt;/code&gt;.</source>
          <target state="translated">개별 속성의 유효성을 검사하기 위해 사용자 지정 유효성 검사기를 추가하는 가장 쉬운 방법은 편리한 &lt;code&gt;ActiveModel::EachValidator&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="98faafe30a9e70db0e0977f135231c7feded8674" translate="yes" xml:space="preserve">
          <source>The easiest way to add custom validators for validating individual attributes is with the convenient &lt;code&gt;ActiveModel::EachValidator&lt;/code&gt;. In this case, the custom validator class must implement a &lt;code&gt;validate_each&lt;/code&gt; method which takes three arguments: record, attribute, and value. These correspond to the instance, the attribute to be validated, and the value of the attribute in the passed instance.</source>
          <target state="translated">개별 속성의 유효성을 검사하기 위해 사용자 지정 유효성 검사기를 추가하는 가장 쉬운 방법은 편리한 &lt;code&gt;ActiveModel::EachValidator&lt;/code&gt; 입니다. 이 경우, 사용자 정의 유효성 검증기 클래스 는 세 가지 인수 (record, attribute 및 value)를 취하는 &lt;code&gt;validate_each&lt;/code&gt; 메소드를 구현해야합니다 . 이들은 인스턴스, 유효성을 검사 할 속성 및 전달 된 인스턴스의 속성 값에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="91e62d62a76a3d0d1a18977f96d9d5517a4cc465" translate="yes" xml:space="preserve">
          <source>The easiest way to do that is to throw</source>
          <target state="translated">가장 쉬운 방법은 던지는 것입니다</target>
        </trans-unit>
        <trans-unit id="67abd7985beb12edf1df94d4e24d4ac0499aedde" translate="yes" xml:space="preserve">
          <source>The easiest way to see functional tests in action is to generate a controller using the scaffold generator:</source>
          <target state="translated">작동중인 기능 테스트를 확인하는 가장 쉬운 방법은 스캐 폴드 생성기를 사용하여 컨트롤러를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="71f9b218d0a717f2a34e6fb5f6eed95f85739bd8" translate="yes" xml:space="preserve">
          <source>The easiest way to work with Rails is to store all external data as UTF-8. If you don't, Ruby libraries and Rails will often be able to convert your native data into UTF-8, but this doesn't always work reliably, so you're better off ensuring that all external data is UTF-8.</source>
          <target state="translated">Rails를 사용하는 가장 쉬운 방법은 모든 외부 데이터를 UTF-8로 저장하는 것입니다. 그렇지 않으면 Ruby 라이브러리와 Rails는 종종 네이티브 데이터를 UTF-8로 변환 할 수 있지만 항상 안정적으로 작동하는 것은 아니므로 모든 외부 데이터가 UTF-8인지 확인하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="de8bad23dcd8917481e25590ac072420ea7cda7e" translate="yes" xml:space="preserve">
          <source>The encoded form of the mail</source>
          <target state="translated">메일의 인코딩 된 형식</target>
        </trans-unit>
        <trans-unit id="603d901a7533f7d4b81087cd4d5da75a04f6dc77" translate="yes" xml:space="preserve">
          <source>The engine contains migrations for the &lt;code&gt;blorgh_articles&lt;/code&gt; and &lt;code&gt;blorgh_comments&lt;/code&gt; table which need to be created in the application's database so that the engine's models can query them correctly. To copy these migrations into the application run the following command from the application's root:</source>
          <target state="translated">엔진에는 엔진 모델이 올바르게 쿼리 할 수 ​​있도록 애플리케이션 데이터베이스에서 작성해야하는 &lt;code&gt;blorgh_articles&lt;/code&gt; 및 &lt;code&gt;blorgh_comments&lt;/code&gt; 테이블에 대한 마이그레이션이 포함되어 있습니다 . 이러한 마이그레이션을 응용 프로그램에 복사하려면 응용 프로그램의 루트에서 다음 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="2465fb9cdbf0b80704e99d5b2da49be290d0b4c9" translate="yes" xml:space="preserve">
          <source>The engine is unable to find the partial required for rendering the comments. Rails looks first in the application's (&lt;code&gt;test/dummy&lt;/code&gt;) &lt;code&gt;app/views&lt;/code&gt; directory and then in the engine's &lt;code&gt;app/views&lt;/code&gt; directory. When it can't find it, it will throw this error. The engine knows to look for &lt;code&gt;blorgh/comments/_comment&lt;/code&gt; because the model object it is receiving is from the &lt;code&gt;Blorgh::Comment&lt;/code&gt; class.</source>
          <target state="translated">엔진이 주석을 렌더링하는 데 필요한 부분을 찾을 수 없습니다. Rails는 먼저 애플리케이션의 ( &lt;code&gt;test/dummy&lt;/code&gt; ) &lt;code&gt;app/views&lt;/code&gt; 디렉토리에서 찾은 다음 엔진의 &lt;code&gt;app/views&lt;/code&gt; 디렉토리 에서 찾습니다 . 찾을 수 없으면이 오류가 발생합니다. 수신하는 모델 오브젝트가 &lt;code&gt;Blorgh::Comment&lt;/code&gt; 클래스 에서 &lt;code&gt;blorgh/comments/_comment&lt;/code&gt; 때문에 엔진은 blorgh / comments / _comment 를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="ea6b332efc300c274b97a32b7ce8d8e009ab65ef" translate="yes" xml:space="preserve">
          <source>The engine that this guide covers provides submitting articles and commenting functionality and follows a similar thread to the &lt;a href=&quot;getting_started&quot;&gt;Getting Started Guide&lt;/a&gt;, with some new twists.</source>
          <target state="translated">이 안내서에서 다루는 엔진은 기사 제출 및 주석 기능을 제공하며 &lt;a href=&quot;getting_started&quot;&gt;시작 안내서&lt;/a&gt; 와 유사한 주제를 따르며 약간의 변형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7b01cfd4565a85c2dbb4f19156a363391250255" translate="yes" xml:space="preserve">
          <source>The engine that will be created in this guide will be called &quot;blorgh&quot;. This engine will provide blogging functionality to its host applications, allowing for new articles and comments to be created. At the beginning of this guide, you will be working solely within the engine itself, but in later sections you'll see how to hook it into an application.</source>
          <target state="translated">이 가이드에서 생성 될 엔진을 &quot;blorgh&quot;라고합니다. 이 엔진은 호스트 애플리케이션에 블로그 기능을 제공하여 새로운 기사와 의견을 작성할 수 있습니다. 이 안내서의 시작 부분에서는 엔진 자체에서만 작업하지만 이후 섹션에서는 엔진을 응용 프로그램에 연결하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="527b2aac30ef582fdc0a45802b88ee7ae5e7ffc7" translate="yes" xml:space="preserve">
          <source>The entire URL used for the request.</source>
          <target state="translated">요청에 사용 된 전체 URL입니다.</target>
        </trans-unit>
        <trans-unit id="d99c9a66d0b0be0a02769838a20ac0b1925f5311" translate="yes" xml:space="preserve">
          <source>The entire callback chain of a &lt;a href=&quot;persistence#method-i-save&quot;&gt;#save&lt;/a&gt;, &lt;a href=&quot;persistence#method-i-save-21&quot;&gt;#save!&lt;/a&gt;, or &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;#destroy&lt;/a&gt; call runs within a transaction. That includes &lt;code&gt;after_*&lt;/code&gt; hooks. If everything goes fine a COMMIT is executed once the chain has been completed.</source>
          <target state="translated">&lt;a href=&quot;persistence#method-i-save&quot;&gt;#save&lt;/a&gt; , &lt;a href=&quot;persistence#method-i-save-21&quot;&gt;#save&lt;/a&gt; 의 전체 콜백 체인 ! 또는 &lt;a href=&quot;persistence#method-i-destroy&quot;&gt;#destroy&lt;/a&gt; 호출이 트랜잭션 내에서 실행됩니다. &lt;code&gt;after_*&lt;/code&gt; 후크가 포함됩니다 . 모든 것이 잘되면 체인이 완료되면 COMMIT가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f16e4fc1970700778bf53ca3a20a8ccb854a9165" translate="yes" xml:space="preserve">
          <source>The environment variable RAILS_GROUPS;</source>
          <target state="translated">환경 변수 RAILS_GROUPS;</target>
        </trans-unit>
        <trans-unit id="47fccb458c4924179eb7ab520146ad2f2e5b5da5" translate="yes" xml:space="preserve">
          <source>The equivalent YAML file would look like this:</source>
          <target state="translated">동등한 YAML 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46b064b6decece00517a4ae80500c5b520897a0b" translate="yes" xml:space="preserve">
          <source>The errata for the &lt;code&gt;PATCH&lt;/code&gt; verb &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5789&quot;&gt;specifies that a 'diff' media type should be used with &lt;code&gt;PATCH&lt;/code&gt;&lt;/a&gt;. One such format is &lt;a href=&quot;https://tools.ietf.org/html/rfc6902&quot;&gt;JSON Patch&lt;/a&gt;. While Rails does not support JSON Patch natively, it's easy enough to add support:</source>
          <target state="translated">&lt;code&gt;PATCH&lt;/code&gt; 동사 의 정오표 &lt;a href=&quot;http://www.rfc-editor.org/errata_search.php?rfc=5789&quot;&gt;는 'diff'미디어 유형이 &lt;code&gt;PATCH&lt;/code&gt; &lt;/a&gt; 와 함께 사용되도록 지정합니다 . 이러한 형식 중 하나는 &lt;a href=&quot;https://tools.ietf.org/html/rfc6902&quot;&gt;JSON 패치&lt;/a&gt; 입니다. Rails는 기본적으로 JSON 패치를 지원하지 않지만 지원을 쉽게 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517f5495378b09403c3a338eae8b0225a24b8aff" translate="yes" xml:space="preserve">
          <source>The error that caused the discard</source>
          <target state="translated">폐기의 원인이 된 오류</target>
        </trans-unit>
        <trans-unit id="202c080109e967ceac7ed5f3b20a32c657e5c762" translate="yes" xml:space="preserve">
          <source>The error that caused the retry</source>
          <target state="translated">재 시도를 일으킨 오류</target>
        </trans-unit>
        <trans-unit id="4e43b8e70ed522e58308259bcdb4debbfad5afa2" translate="yes" xml:space="preserve">
          <source>The escaping performed in this method is identical to those performed in the Active Support JSON encoder when &lt;code&gt;ActiveSupport.escape_html_entities_in_json&lt;/code&gt; is set to true. Because this transformation is idempotent, this helper can be applied even if &lt;code&gt;ActiveSupport.escape_html_entities_in_json&lt;/code&gt; is already true.</source>
          <target state="translated">이 방법으로 수행되는 이스케이프 처리는 &lt;code&gt;ActiveSupport.escape_html_entities_in_json&lt;/code&gt; 이 true로 설정된 경우 Active Support JSON 인코더에서 수행되는 이스케이프 처리와 동일 합니다. 이 변환은 &lt;code&gt;ActiveSupport.escape_html_entities_in_json&lt;/code&gt; 이므로 ActiveSupport.escape_html_entities_in_json 이 이미 true 인 경우에도이 헬퍼를 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6cd9b6aa0872547b71e432f2132c47e1b23d564" translate="yes" xml:space="preserve">
          <source>The eval() function is a nightmare for restricted list input filters, as it allows the style attribute to hide the word &quot;innerHTML&quot;:</source>
          <target state="translated">eval () 함수는 스타일 목록에서 &quot;innerHTML&quot;이라는 단어를 숨길 수 있으므로 제한된 목록 입력 필터의 악몽입니다.</target>
        </trans-unit>
        <trans-unit id="3970e1a2fc0e3743d76d2b4beaa13f39ba8d4504" translate="yes" xml:space="preserve">
          <source>The example above generates &amp;ldquo;&lt;a href=&quot;http://assets1.example.com&quot;&gt;assets1.example.com&lt;/a&gt;&amp;rdquo; and &amp;ldquo;&lt;a href=&quot;http://assets2.example.com&quot;&gt;assets2.example.com&lt;/a&gt;&amp;rdquo;. This option is useful for example if you need fewer/more than four hosts, custom host names, etc.</source>
          <target state="translated">위의 예는&amp;ldquo; &lt;a href=&quot;http://assets1.example.com&quot;&gt;asset1.example.com&lt;/a&gt; &amp;rdquo;및&amp;ldquo; &lt;a href=&quot;http://assets2.example.com&quot;&gt;asset2.example.com&lt;/a&gt; &amp;rdquo;을 생성합니다. 이 옵션은 예를 들어 4 개보다 적거나 많은 호스트, 사용자 정의 호스트 이름 등이 필요한 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="dd5763a2636a74bdb09de576f848b626740d358c" translate="yes" xml:space="preserve">
          <source>The example above uses a custom environment called &quot;staging&quot; for a production like server but for testing purposes. You can read &lt;a href=&quot;configuring#creating-rails-environments&quot;&gt;Creating Rails environments&lt;/a&gt; for more information about custom Rails environments.</source>
          <target state="translated">위의 예제는 서버와 같은 프로덕션에 테스트 목적으로 &quot;스테이징&quot;이라는 사용자 정의 환경을 사용합니다. 사용자 정의 Rails 환경에 대한 자세한 정보는 &lt;a href=&quot;configuring#creating-rails-environments&quot;&gt;Rails 환경 작성&lt;/a&gt; 을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecb3184dee5c579a473cebc5475c09e72e149629" translate="yes" xml:space="preserve">
          <source>The example above will create a test framework option and will invoke a generator based on the user supplied value.</source>
          <target state="translated">위의 예제는 테스트 프레임 워크 옵션을 만들고 사용자가 제공 한 값을 기반으로 생성기를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="344add1bda36def193aec6a1db38dc0ecd133c78" translate="yes" xml:space="preserve">
          <source>The example of partial use describes a familiar pattern where a template needs to iterate over an array and render a sub template for each of the elements. This pattern has been implemented as a single method that accepts an array and renders a partial by the same name as the elements contained within. So the three-lined example in &amp;ldquo;Using partials&amp;rdquo; can be rewritten with a single line:</source>
          <target state="translated">부분 사용의 예는 템플릿이 배열을 반복하고 각 요소에 대한 하위 템플릿을 렌더링해야하는 익숙한 패턴을 설명합니다. 이 패턴은 배열을 허용하고 그 안에 포함 된 요소와 동일한 이름으로 부분을 렌더링하는 단일 메소드로 구현되었습니다. 따라서 &quot;부분 사용&quot;의 3 줄짜리 예제를 한 줄로 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="513e1d35af00b7b4857d0001cb9d96cd14237d06" translate="yes" xml:space="preserve">
          <source>The examples above put files under the application's &lt;code&gt;lib&lt;/code&gt; because said directory belongs to &lt;code&gt;$LOAD_PATH&lt;/code&gt;.</source>
          <target state="translated">위의 예제 는 해당 디렉토리가 &lt;code&gt;$LOAD_PATH&lt;/code&gt; 속하기 때문에 파일을 응용 프로그램의 &lt;code&gt;lib&lt;/code&gt; 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="1c74c9a07fb4e60ccadc9e321e8eb5e6ad8dd588" translate="yes" xml:space="preserve">
          <source>The examples above show that &lt;code&gt;in_groups&lt;/code&gt; fills some groups with a trailing &lt;code&gt;nil&lt;/code&gt; element as needed. A group can get at most one of these extra elements, the rightmost one if any. And the groups that have them are always the last ones.</source>
          <target state="translated">위의 예는 &lt;code&gt;in_groups&lt;/code&gt; 가 일부 그룹을 필요에 따라 후미 &lt;code&gt;nil&lt;/code&gt; 요소로 채운다 는 것을 보여줍니다 . 그룹은 이러한 추가 요소 중 최대 하나를 얻을 수 있습니다 (있는 경우). 그리고 그것들을 가진 그룹은 항상 마지막 그룹입니다.</target>
        </trans-unit>
        <trans-unit id="61162445c5595b6fb1ee7e3f0721291476b564b0" translate="yes" xml:space="preserve">
          <source>The examples below use &lt;code&gt;$&lt;/code&gt; to represent your terminal prompt in a UNIX-like OS, though it may have been customized to appear differently. If you are using Windows, your prompt will look something like &lt;code&gt;c:\source_code&amp;gt;&lt;/code&gt;</source>
          <target state="translated">아래 예 는 UNIX와 유사한 OS에서 터미널 프롬프트를 나타내는 데 &lt;code&gt;$&lt;/code&gt; 를 사용 하지만 다르게 표시되도록 사용자 정의되었을 수 있습니다. Windows를 사용하는 경우 프롬프트는 &lt;code&gt;c:\source_code&amp;gt;&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="13335fd46e437958bd49212b4d657196ad9ffa75" translate="yes" xml:space="preserve">
          <source>The exceptions &lt;a href=&quot;adapternotspecified&quot;&gt;AdapterNotSpecified&lt;/a&gt;, &lt;a href=&quot;adapternotfound&quot;&gt;AdapterNotFound&lt;/a&gt; and &lt;code&gt;ArgumentError&lt;/code&gt; may be returned on an error.</source>
          <target state="translated">&lt;a href=&quot;adapternotspecified&quot;&gt;AdapterNotSpecified&lt;/a&gt; , &lt;a href=&quot;adapternotfound&quot;&gt;AdapterNotFound&lt;/a&gt; 및 &lt;code&gt;ArgumentError&lt;/code&gt; 예외 가 오류로 리턴 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2268f470fa1e4f224984a46fe5b66988eea0dd2c" translate="yes" xml:space="preserve">
          <source>The execution context of a block passed to &lt;code&gt;Class.new&lt;/code&gt; or &lt;code&gt;Module.new&lt;/code&gt; is not entirely equivalent to the one of the body of the definitions using the &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;module&lt;/code&gt; keywords. But both idioms result in the same constant assignment.</source>
          <target state="translated">&lt;code&gt;Class.new&lt;/code&gt; 또는 &lt;code&gt;Module.new&lt;/code&gt; 에 전달 된 블록의 실행 컨텍스트 는 &lt;code&gt;class&lt;/code&gt; 및 &lt;code&gt;module&lt;/code&gt; 키워드를 사용하는 정의 본문 중 하나와 완전히 동일하지 않습니다 . 그러나 두 관용구 모두 동일한 상수 할당을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="d1560f51490992d361bd33ce4f84967240b07850" translate="yes" xml:space="preserve">
          <source>The execution of each test method stops as soon as any error or an assertion failure is encountered, and the test suite continues with the next method. All test methods are executed in random order. The &lt;a href=&quot;configuring#configuring-active-support&quot;&gt;&lt;code&gt;config.active_support.test_order&lt;/code&gt; option&lt;/a&gt; can be used to configure test order.</source>
          <target state="translated">오류나 어설 션 오류가 발생하면 각 테스트 방법의 실행이 중지되고 테스트 스위트는 다음 방법으로 계속 진행됩니다. 모든 테스트 방법은 무작위 순서로 실행됩니다. &lt;a href=&quot;configuring#configuring-active-support&quot;&gt; &lt;code&gt;config.active_support.test_order&lt;/code&gt; 의 옵션&lt;/a&gt; 구성 테스트 순서를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86f2a88639b58b6dc320a26b779f9c83492793d1" translate="yes" xml:space="preserve">
          <source>The face attribute must be in the object and it cannot be blank or marked for destruction.</source>
          <target state="translated">면 속성은 객체에 있어야하며 비워 두거나 파괴 표시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="cd2e2325522f51d93172fabd30184210ad6758e4" translate="yes" xml:space="preserve">
          <source>The field name can also be a string:</source>
          <target state="translated">필드 이름은 문자열 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23f5a2d4fe414d9b9dccdb276434ede248d4038" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;railties/lib/rails/cli&lt;/code&gt; in turn calls &lt;code&gt;Rails::AppLoader.exec_app&lt;/code&gt;.</source>
          <target state="translated">파일 &lt;code&gt;railties/lib/rails/cli&lt;/code&gt; 는 차례로 &lt;code&gt;Rails::AppLoader.exec_app&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bac5d2c07bdf6dfba37a9dd229fabf112d19ceeb" translate="yes" xml:space="preserve">
          <source>The file extensions used on an asset determine what preprocessing is applied. When a controller or a scaffold is generated with the default Rails gemset, a CoffeeScript file and a SCSS file are generated in place of a regular JavaScript and CSS file. The example used before was a controller called &quot;projects&quot;, which generated an &lt;code&gt;app/assets/stylesheets/projects.scss&lt;/code&gt; file.</source>
          <target state="translated">자산에 사용 된 파일 확장자에 따라 적용되는 전처리가 결정됩니다. 기본 Rails gemset을 사용하여 컨트롤러 나 스캐 폴드를 생성하면 일반 JavaScript 및 CSS 파일 대신 CoffeeScript 파일과 SCSS 파일이 생성됩니다. 이전에 사용 된 예는 &lt;code&gt;app/assets/stylesheets/projects.scss&lt;/code&gt; 파일 을 생성하는 &quot;projects&quot;라는 컨트롤러였습니다 .</target>
        </trans-unit>
        <trans-unit id="693c5053c620072ba87006436392f9198d81b36c" translate="yes" xml:space="preserve">
          <source>The files or configs can also be encrypted with a custom key. To decrypt with a key in the &lt;code&gt;ENV&lt;/code&gt;, use:</source>
          <target state="translated">파일 또는 구성은 사용자 정의 키로 암호화 할 수도 있습니다. &lt;code&gt;ENV&lt;/code&gt; 의 키로 암호를 해독하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="79590c5db1b2aa3e6f7401ef520c2cc7cf875c50" translate="yes" xml:space="preserve">
          <source>The final caveat is that your actions are executed in a separate thread than the main thread. Make sure your actions are thread safe, and this shouldn't be a problem (don't share state across threads, etc).</source>
          <target state="translated">마지막 경고는 작업이 기본 스레드와 다른 스레드에서 실행된다는 것입니다. 작업이 스레드로부터 안전해야하며 문제가되지 않아야합니다 (스레드간에 상태를 공유하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="421c547ed96034c7fdf98ebd07b149c41367cd02" translate="yes" xml:space="preserve">
          <source>The final result would be:</source>
          <target state="translated">최종 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b6e8a878c6d566279c79dabab5729cf9f687141e" translate="yes" xml:space="preserve">
          <source>The fingerprinting behavior is controlled by the &lt;code&gt;config.assets.digest&lt;/code&gt; initialization option (which defaults to &lt;code&gt;true&lt;/code&gt;).</source>
          <target state="translated">지문 동작은 &lt;code&gt;config.assets.digest&lt;/code&gt; 초기화 옵션 (기본값은 &lt;code&gt;true&lt;/code&gt; )으로 제어됩니다.</target>
        </trans-unit>
        <trans-unit id="0e5b88eb961587020694ec62f77f764be5c16bf8" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;link_to&lt;/code&gt; will generate &amp;ldquo;/profile&amp;rdquo; but the second will generate the standard polymorphic URL of &amp;ldquo;/admin/users/1&amp;rdquo;.</source>
          <target state="translated">첫 번째 &lt;code&gt;link_to&lt;/code&gt; 는 &quot;/ profile&quot;을 생성하지만 두 번째는 &quot;/ admin / users / 1&quot;의 표준 다형성 URL을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cd20ffb3e2140e1113ddfc3b288c6aa57e901460" translate="yes" xml:space="preserve">
          <source>The first and last part used to find the generator to be invoked are guessed based on class invokes &lt;a href=&quot;base#method-c-hook_for&quot;&gt;::hook_for&lt;/a&gt;, as noticed in the example above. This can be customized with two options: :in and :as.</source>
          <target state="translated">호출 할 생성기를 찾는 데 사용 된 첫 번째 부분과 마지막 부분은 위의 예에서 &lt;a href=&quot;base#method-c-hook_for&quot;&gt;알 수 있듯이 :: voke_for&lt;/a&gt; 클래스 호출을 기반으로 추측됩니다 . : in 및 : as의 두 가지 옵션으로 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b2feec48312de884813c60913a1cd3ef59e3f70" translate="yes" xml:space="preserve">
          <source>The first argument to &lt;code&gt;options_for_select&lt;/code&gt; is a nested array where each element has two elements: option text (city name) and option value (city id). The option value is what will be submitted to your controller. Often this will be the id of a corresponding database object but this does not have to be the case.</source>
          <target state="translated">&lt;code&gt;options_for_select&lt;/code&gt; 의 첫 번째 인수 는 각 요소에 옵션 텍스트 (도시 이름)와 옵션 값 (도시 ID)의 두 요소가있는 중첩 배열입니다. 옵션 값은 컨트롤러에 제출됩니다. 종종 이것은 해당 데이터베이스 오브젝트의 ID가되지만 반드시 그럴 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c35a6654821cab50b0d48eb9aec811dba267ad71" translate="yes" xml:space="preserve">
          <source>The first example shows &lt;code&gt;in_groups_of&lt;/code&gt; fills the last group with as many &lt;code&gt;nil&lt;/code&gt; elements as needed to have the requested size. You can change this padding value using the second optional argument:</source>
          <target state="translated">첫 번째 예는 &lt;code&gt;in_groups_of&lt;/code&gt; 가 요청한 크기를 갖는 데 필요한 만큼 많은 &lt;code&gt;nil&lt;/code&gt; 요소로 마지막 그룹을 채우는 것을 보여줍니다 . 두 번째 선택적 인수를 사용하여이 패딩 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f47fe60e70f182e1be5811a83b6e1289320cec3" translate="yes" xml:space="preserve">
          <source>The first feature of the pipeline is to concatenate assets, which can reduce the number of requests that a browser makes to render a web page. Web browsers are limited in the number of requests that they can make in parallel, so fewer requests can mean faster loading for your application.</source>
          <target state="translated">파이프 라인의 첫 번째 기능은 자산을 연결하여 브라우저가 웹 페이지를 렌더링하기 위해 요청하는 횟수를 줄일 수 있습니다. 웹 브라우저는 병렬로 수행 할 수있는 요청 수가 제한되어 있으므로 요청이 적을수록 응용 프로그램의 로딩 속도가 빨라질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7fda4a618b934b655302ec63bac10bfdaa3385c" translate="yes" xml:space="preserve">
          <source>The first form</source>
          <target state="translated">첫 번째 형태</target>
        </trans-unit>
        <trans-unit id="c779e7cdfc5b1f836df5b6e50b3fb3f8e6ec3015" translate="yes" xml:space="preserve">
          <source>The first is to use a block directly with the *_action methods. The block receives the controller as an argument. The &lt;code&gt;require_login&lt;/code&gt; filter from above could be rewritten to use a block:</source>
          <target state="translated">첫 번째는 * _action 메소드와 함께 직접 블록을 사용하는 것입니다. 블록은 컨트롤러를 인수로받습니다. 위의 &lt;code&gt;require_login&lt;/code&gt; 필터는 블록을 사용하도록 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="decf5a49fc6e6d01f58f977387f90ce1c0e78cbb" translate="yes" xml:space="preserve">
          <source>The first option doesn't require any client-side JavaScript integration, and can be used by any other back-end service that deals with files. The second option is faster, since you're not using your own server as a staging point for uploads, and can work with deployments like Heroku that do not provide large amounts of disk space.</source>
          <target state="translated">첫 번째 옵션은 클라이언트 측 JavaScript 통합이 필요하지 않으며 파일을 처리하는 다른 백엔드 서비스에서 사용할 수 있습니다. 두 번째 옵션은 자체 서버를 업로드의 스테이징 지점으로 사용하지 않기 때문에 더 빠르며, 대량의 디스크 공간을 제공하지 않는 Heroku와 같은 배포에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3018e7bc52b5fa1b4994063800ecfef2cab4f995" translate="yes" xml:space="preserve">
          <source>The first parameter specifies which value should be selected and can either be an instance of a &lt;code&gt;Date&lt;/code&gt;, &lt;code&gt;Time&lt;/code&gt;, or &lt;code&gt;DateTime&lt;/code&gt;, in which case the relevant component will be extracted, or a numerical value. For example:</source>
          <target state="translated">첫 번째 매개 변수는 선택해야 할 값을 지정하며 &lt;code&gt;Date&lt;/code&gt; , &lt;code&gt;Time&lt;/code&gt; 또는 &lt;code&gt;DateTime&lt;/code&gt; 의 인스턴스 일 수 있으며 ,이 경우 관련 구성 요소가 추출되거나 숫자 값이 될 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f933693c0140825dd1f189e2779b8fe6cb715c9" translate="yes" xml:space="preserve">
          <source>The first parameter to &lt;code&gt;check_box_tag&lt;/code&gt;, of course, is the name of the input. The second parameter, naturally, is the value of the input. This value will be included in the form data (and be present in &lt;code&gt;params&lt;/code&gt;) when the checkbox is checked.</source>
          <target state="translated">물론 &lt;code&gt;check_box_tag&lt;/code&gt; 의 첫 번째 매개 변수 는 입력 이름입니다. 두 번째 매개 변수는 당연히 입력 값입니다. 이 값은 확인란을 선택 하면 양식 데이터에 포함되며 &lt;code&gt;params&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="ceab9ee28778e0cd198e4bb4c0d9830c53ea674c" translate="yes" xml:space="preserve">
          <source>The first question a lot of people have when thinking about building a JSON API using Rails is: &quot;isn't using Rails to spit out some JSON overkill? Shouldn't I just use something like Sinatra?&quot;.</source>
          <target state="translated">Rails를 사용하여 JSON API를 구축 할 때 많은 사람들이 알아야 할 첫 번째 질문은 &quot;일부 JSON 과잉을 뱉기 위해 Rails를 사용하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="dbb1590aff8add787236e67ae78ae8bec4308b59" translate="yes" xml:space="preserve">
          <source>The first step is to call &lt;code&gt;visit articles_path&lt;/code&gt;. This will take the test to the articles index page.</source>
          <target state="translated">첫 번째 단계는 &lt;code&gt;visit articles_path&lt;/code&gt; 를 호출하는 것 입니다. 기사 색인 페이지에서 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="a5f38744e3441897f904e05dbaada4d430125ad6" translate="yes" xml:space="preserve">
          <source>The first step is to create a file at &lt;code&gt;lib/generators/initializer_generator.rb&lt;/code&gt; with the following content:</source>
          <target state="translated">첫 번째 단계는 &lt;code&gt;lib/generators/initializer_generator.rb&lt;/code&gt; 에 다음 내용 으로 파일을 작성하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="7647b789ce905eead162df1c2d4deef59320a6d1" translate="yes" xml:space="preserve">
          <source>The first step is to update the README file with detailed information about how to use your plugin. A few key things to include are:</source>
          <target state="translated">첫 번째 단계는 플러그인 사용 방법에 대한 자세한 정보로 README 파일을 업데이트하는 것입니다. 포함해야 할 몇 가지 주요 사항은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59c512882e34836962c0651a7f7bce0b3070c1e6" translate="yes" xml:space="preserve">
          <source>The first step to avoid this is to make sure all &quot;destructive&quot; actions (create, update, and destroy) can only be accessed with non-GET requests. If you're following RESTful conventions you're already doing this. However, a malicious site can still send a non-GET request to your site quite easily, and that's where the request forgery protection comes in. As the name says, it protects from forged requests.</source>
          <target state="translated">이를 피하기위한 첫 번째 단계는 모든 &quot;파괴적인&quot;작업 (만들기, 업데이트 및 삭제)이 비 GET 요청으로 만 액세스 할 수 있도록하는 것입니다. RESTful 규칙을 따르는 경우 이미 수행 중입니다. 그러나 악의적 인 사이트는 여전히 GET 이외의 요청을 귀하의 사이트로 매우 쉽게 보낼 수 있으며, 이는 위조 방지 요청이 들어오는 곳입니다. 이름에서 알 수 있듯이 위조 된 요청으로부터 보호합니다.</target>
        </trans-unit>
        <trans-unit id="5109762b5d7c74ae179ab67654f35f303d74031b" translate="yes" xml:space="preserve">
          <source>The first step we'll take is adding an &lt;code&gt;edit&lt;/code&gt; action to the &lt;code&gt;ArticlesController&lt;/code&gt;, generally between the &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt; actions, as shown:</source>
          <target state="translated">첫 번째로 수행 할 단계는 &lt;code&gt;edit&lt;/code&gt; 과 같이 일반적으로 &lt;code&gt;new&lt;/code&gt; 작업 과 &lt;code&gt;create&lt;/code&gt; 작업 사이에 편집 작업을 &lt;code&gt;ArticlesController&lt;/code&gt; 에 추가하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="ca590be262eb1b3454e67886b520ae65c0895075" translate="yes" xml:space="preserve">
          <source>The first thing that the scaffold generator does is invoke the &lt;code&gt;active_record&lt;/code&gt; generator, which generates a migration and a model for the resource. Note here, however, that the migration is called &lt;code&gt;create_blorgh_articles&lt;/code&gt; rather than the usual &lt;code&gt;create_articles&lt;/code&gt;. This is due to the &lt;code&gt;isolate_namespace&lt;/code&gt; method called in the &lt;code&gt;Blorgh::Engine&lt;/code&gt; class's definition. The model here is also namespaced, being placed at &lt;code&gt;app/models/blorgh/article.rb&lt;/code&gt; rather than &lt;code&gt;app/models/article.rb&lt;/code&gt; due to the &lt;code&gt;isolate_namespace&lt;/code&gt; call within the &lt;code&gt;Engine&lt;/code&gt; class.</source>
          <target state="translated">스캐 폴드 생성기의 첫 번째 작업 은 자원에 대한 마이그레이션 및 모델을 생성하는 &lt;code&gt;active_record&lt;/code&gt; 생성기를 호출하는 것입니다 . 그러나 여기서는 일반적인 &lt;code&gt;create_articles&lt;/code&gt; 대신 마이그레이션을 &lt;code&gt;create_blorgh_articles&lt;/code&gt; 라고 합니다. 이는 &lt;code&gt;Blorgh::Engine&lt;/code&gt; 클래스의 정의 에서 호출 된 &lt;code&gt;isolate_namespace&lt;/code&gt; 메소드 때문 입니다. 여기서 모델은 네임 스페이스 로 지정되며 &lt;code&gt;Engine&lt;/code&gt; 클래스 내의 &lt;code&gt;isolate_namespace&lt;/code&gt; 호출 로 인해 &lt;code&gt;app/models/article.rb&lt;/code&gt; 가 아닌 &lt;code&gt;app/models/blorgh/article.rb&lt;/code&gt; 에 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="bf247db1b15a4a0665a1fff0a86d0b8b870286c8" translate="yes" xml:space="preserve">
          <source>The first thing to generate for a blog engine is the &lt;code&gt;Article&lt;/code&gt; model and related controller. To quickly generate this, you can use the Rails scaffold generator.</source>
          <target state="translated">블로그 엔진을 위해 먼저 생성하는 것은 &lt;code&gt;Article&lt;/code&gt; 모델 및 관련 컨트롤러입니다. 이를 빠르게 생성하기 위해 Rails 스캐 폴드 생성기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67ac826f249d2df18239a1cdc76f0b3ffea39836" translate="yes" xml:space="preserve">
          <source>The first thing we'll want to do is create a new Rails application by running the &lt;code&gt;rails new&lt;/code&gt; command after installing Rails.</source>
          <target state="translated">가장 먼저 할 일은 Rails 를 설치 한 후 &lt;code&gt;rails new&lt;/code&gt; 명령 을 실행하여 새로운 Rails 애플리케이션을 만드는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="0ee7285a99cf6559d8f8b5329c15cff3b597d8f9" translate="yes" xml:space="preserve">
          <source>The first timestamp (&lt;code&gt;[timestamp_1]&lt;/code&gt;) will be the current time, and the second timestamp (&lt;code&gt;[timestamp_2]&lt;/code&gt;) will be the current time plus a second. The reason for this is so that the migrations for the engine are run after any existing migrations in the application.</source>
          <target state="translated">첫 번째 타임 스탬프 ( &lt;code&gt;[timestamp_1]&lt;/code&gt; )는 현재 시간이고 두 번째 타임 스탬프 ( &lt;code&gt;[timestamp_2]&lt;/code&gt; )는 현재 시간에 1 초를 더한 값입니다. 그 이유는 애플리케이션의 기존 마이그레이션 후에 엔진 마이그레이션이 실행되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3e6b2570d51c28085531d230e84b5d63f1e48272" translate="yes" xml:space="preserve">
          <source>The first two characters (&amp;ldquo;&amp;gt;) are required in case the exception happens while rendering attributes for a given tag. You can check the real cause for the exception in your logger.</source>
          <target state="translated">지정된 태그의 속성을 렌더링하는 동안 예외가 발생하는 경우 처음 두 문자 (&amp;ldquo;&amp;gt;)가 필요합니다. 로거에서 예외의 실제 원인을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72aa6535de6074bb6bd46b9d2d9f30007e42e7a1" translate="yes" xml:space="preserve">
          <source>The first way uses a &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; association with the &lt;code&gt;:through&lt;/code&gt; option and a join model, so there are two stages of associations.</source>
          <target state="translated">첫 번째 방법은 &lt;code&gt;:through&lt;/code&gt; 옵션 및 조인 모델과 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; 연관을 사용 하므로 두 가지 연관 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9cd0c75ac26aeaf1392bf739898212b29b06c34" translate="yes" xml:space="preserve">
          <source>The first_name attribute must be in the object and it cannot be blank.</source>
          <target state="translated">first_name 속성은 오브젝트에 있어야하며 비워 둘 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f7deeb91723eb6307c03873779ac20d588eb92a" translate="yes" xml:space="preserve">
          <source>The first_name attribute must be in the object and it must be blank.</source>
          <target state="translated">first_name 속성은 오브젝트에 있어야하며 비어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="55bef31fcee581ecc39fbeffc0faa4743f90075a" translate="yes" xml:space="preserve">
          <source>The flash is a special part of the session which is cleared with each request. This means that values stored there will only be available in the next request, which is useful for passing error messages etc.</source>
          <target state="translated">플래시는 세션의 특별한 부분으로 각 요청마다 지워집니다. 즉, 저장된 값은 다음 요청에서만 사용할 수 있으며 오류 메시지 등을 전달하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="89b509889e32d8f793986316afbb6c7d8a102d1b" translate="yes" xml:space="preserve">
          <source>The flash provides a way to pass temporary primitive-types (String, &lt;a href=&quot;../array&quot;&gt;Array&lt;/a&gt;, &lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt;) between actions. Anything you place in the flash will be exposed to the very next action and then cleared out. This is a great way of doing notices and alerts, such as a create action that sets &lt;code&gt;flash[:notice] = &quot;Post
successfully created&quot;&lt;/code&gt; before redirecting to a display action that can then expose the flash to its template. Actually, that exposure is automatically done.</source>
          <target state="translated">플래시는 조치간에 임시 기본 유형 (String, &lt;a href=&quot;../array&quot;&gt;Array&lt;/a&gt; , &lt;a href=&quot;../hash&quot;&gt;Hash&lt;/a&gt; ) 을 전달하는 방법을 제공합니다 . 플래시에 넣은 것은 바로 다음 동작에 노출 된 다음 지워집니다. 플래시를 템플릿에 노출시킬 수있는 표시 액션으로 리디렉션하기 전에 &lt;code&gt;flash[:notice] = &quot;Post successfully created&quot;&lt;/code&gt; 를 설정하는 액션 만들기와 같은 알림 및 경고를 수행하는 좋은 방법입니다 . 실제로 노출은 자동으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6361541543365d2f737ca6fb21692e2f0f63b28" translate="yes" xml:space="preserve">
          <source>The following are methods available for both generators and templates for Rails.</source>
          <target state="translated">다음은 생성기 및 Rails 용 템플릿 모두에 사용할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ffee53ad3ec5b77a2f9a08d7a6e4adedc900dee5" translate="yes" xml:space="preserve">
          <source>The following bundled adapters throw the &lt;a href=&quot;../recordnotunique&quot;&gt;ActiveRecord::RecordNotUnique&lt;/a&gt; exception:</source>
          <target state="translated">다음 번들 어댑터는 &lt;a href=&quot;../recordnotunique&quot;&gt;ActiveRecord :: RecordNotUnique&lt;/a&gt; 예외를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4f1c96675ae6b9570b50e212e3ae027ef8570ca5" translate="yes" xml:space="preserve">
          <source>The following calculation methods have edge cases in October 1582, since days 5..14 just do not exist. This guide does not document their behavior around those days for brevity, but it is enough to say that they do what you would expect. That is, &lt;code&gt;Date.new(1582, 10, 4).tomorrow&lt;/code&gt; returns &lt;code&gt;Date.new(1582, 10, 15)&lt;/code&gt; and so on. Please check &lt;code&gt;test/core_ext/date_ext_test.rb&lt;/code&gt; in the Active Support test suite for expected behavior.</source>
          <target state="translated">다음 계산 방법에는 5.82 일이 존재하지 않기 때문에 1582 년 10 월에 중요한 경우가 있습니다. 이 안내서는 간결성을 위해 그 당시의 행동을 문서화하지는 않았지만 그들이 기대하는 바를 행한다고 말하는 것으로 충분합니다. 즉, &lt;code&gt;Date.new(1582, 10, 4).tomorrow&lt;/code&gt; 는 &lt;code&gt;Date.new(1582, 10, 15)&lt;/code&gt; 등을 반환합니다 . 예상되는 동작에 대해서는 Active Support 테스트 스위트에서 &lt;code&gt;test/core_ext/date_ext_test.rb&lt;/code&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="70d4c9f719378844b4409a52323353064e172572" translate="yes" xml:space="preserve">
          <source>The following changes are meant for upgrading your application to Rails 3.1.12, the last 3.1.x version of Rails.</source>
          <target state="translated">다음 변경 사항은 애플리케이션을 Rails의 마지막 3.1.x 버전 인 Rails 3.1.12로 업그레이드하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="a21909e1f363f954735463d953a47620a34d0ecc" translate="yes" xml:space="preserve">
          <source>The following changes are meant for upgrading your application to Rails 4.0.</source>
          <target state="translated">다음 변경 사항은 응용 프로그램을 Rails 4.0으로 업그레이드하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f4eba11712b688c04dbd32d2ec745a16224dc68" translate="yes" xml:space="preserve">
          <source>The following changes are meant for upgrading your application to the latest 3.2.x version of Rails.</source>
          <target state="translated">다음 변경 사항은 애플리케이션을 최신 3.2.x 버전의 Rails로 업그레이드하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a17e0ad99303eed4359cff4d8da7d88c45ebc56" translate="yes" xml:space="preserve">
          <source>The following checks can also be supplied with a proc or a symbol which corresponds to a method:</source>
          <target state="translated">다음 검사에는 방법에 해당하는 proc 또는 기호가 제공 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="46a28b7e917344b9bee0503c9f816514c89eeea1" translate="yes" xml:space="preserve">
          <source>The following code summarizes the situation:</source>
          <target state="translated">다음 코드는 상황을 요약합니다.</target>
        </trans-unit>
        <trans-unit id="c281ebe2a035df9fc9b458fe9d16552fd19ecc0a" translate="yes" xml:space="preserve">
          <source>The following concrete subclasses are included in Active Storage:</source>
          <target state="translated">다음과 같은 구체적인 하위 클래스가 Active Storage에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="96657eda8232590db12df6e4e53baab705d4dc34" translate="yes" xml:space="preserve">
          <source>The following configuration options are best made in one of the environment files (environment.rb, production.rb, etc...)</source>
          <target state="translated">다음 구성 옵션은 환경 파일 중 하나 (environment.rb, production.rb 등)에서 가장 잘 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="30177bc5b6729d79742e2ee030efdfe4f950f932" translate="yes" xml:space="preserve">
          <source>The following configuration would queue the given job on the &lt;code&gt;production_high_priority&lt;/code&gt; queue when run in production:</source>
          <target state="translated">다음 구성은 &lt;code&gt;production_high_priority&lt;/code&gt; 에서 실행될 때 production_high_priority 큐 에서 지정된 작업을 큐에 넣습니다.</target>
        </trans-unit>
        <trans-unit id="48b002c00bb39650ea2c3d72da1338bb50128142" translate="yes" xml:space="preserve">
          <source>The following configuration would queue the provided job on the &lt;code&gt;video_server.low_priority&lt;/code&gt; queue:</source>
          <target state="translated">다음 구성은 제공된 작업을 &lt;code&gt;video_server.low_priority&lt;/code&gt; 대기열에 대기 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="5f452617bef02933cc7f6d371891f371f7e4b779" translate="yes" xml:space="preserve">
          <source>The following example demonstrates an extension which can be used with or without Rails.</source>
          <target state="translated">다음 예제는 Rails와 함께 또는 Rails없이 사용할 수있는 확장을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="99962e504be8e6840c8589ad9d05120d1cb4146f" translate="yes" xml:space="preserve">
          <source>The following features are not (yet) supported:</source>
          <target state="translated">다음 기능은 (아직) 지원되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="013180286a901d766bcc39db17dc989369dbd41a" translate="yes" xml:space="preserve">
          <source>The following form allows a user to create a &lt;code&gt;Person&lt;/code&gt; and its associated addresses.</source>
          <target state="translated">다음 양식을 통해 사용자는 &lt;code&gt;Person&lt;/code&gt; 및 관련 주소 를 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc83f277cf7da9fe5a7029905b527298a6aa3ec1" translate="yes" xml:space="preserve">
          <source>The following format is for legacy syntax support. It will be deprecated in future versions of Rails.</source>
          <target state="translated">다음 형식은 레거시 구문 지원을위한 것입니다. 차후 버전의 Rails에서는 더 이상 사용되지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d8548d239e9c484f9cc69b4404f594147009b4fe" translate="yes" xml:space="preserve">
          <source>The following full app-like example demonstrates how to use a Current class to facilitate easy access to the global, per-request attributes without passing them deeply around everywhere:</source>
          <target state="translated">다음과 같은 전체 앱과 유사한 예제는 Current 클래스를 사용하여 전역에 필요한 전역 속성을 전달하지 않고도 전역 요청 속성에 쉽게 액세스 할 수있는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="58d425cd8d652b864ae1fe65a46c847b1c3552b2" translate="yes" xml:space="preserve">
          <source>The following is a list of the most commonly used methods. Please refer to the &lt;code&gt;ActiveModel::Errors&lt;/code&gt; documentation for a list of all the available methods.</source>
          <target state="translated">다음은 가장 일반적으로 사용되는 방법의 목록입니다. 사용 가능한 모든 방법의 목록은 &lt;code&gt;ActiveModel::Errors&lt;/code&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="12aabb098cae3591d87c543791e9cbc757195d40" translate="yes" xml:space="preserve">
          <source>The following is an excerpt from the &lt;a href=&quot;http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&amp;amp;tabid=1&quot;&gt;Js.Yamanner@m&lt;/a&gt; Yahoo! Mail &lt;a href=&quot;http://groovin.net/stuff/yammer.txt&quot;&gt;worm&lt;/a&gt;. It appeared on June 11, 2006 and was the first webmail interface worm:</source>
          <target state="translated">다음은 &lt;a href=&quot;http://www.symantec.com/security_response/writeup.jsp?docid=2006-061211-4111-99&amp;amp;tabid=1&quot;&gt;Js.Yamanner@m&lt;/a&gt; Yahoo! 에서 발췌 한 것입니다. 메일 &lt;a href=&quot;http://groovin.net/stuff/yammer.txt&quot;&gt;웜&lt;/a&gt; . 2006 년 6 월 11 일에 나타 났으며 최초의 웹 메일 인터페이스 웜이었습니다.</target>
        </trans-unit>
        <trans-unit id="579d8c42dd4ef8c57843a057efd4713ac1241a02" translate="yes" xml:space="preserve">
          <source>The following is only a brief overview summary of the helpers available in Action View. It's recommended that you review the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers.html&quot;&gt;API Documentation&lt;/a&gt;, which covers all of the helpers in more detail, but this should serve as a good starting point.</source>
          <target state="translated">다음은 액션 뷰에서 사용할 수있는 헬퍼에 대한 간략한 개요입니다. 모든 헬퍼에 대해 자세히 다루는 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers.html&quot;&gt;API Documentation&lt;/a&gt; 을 검토하는 것이 좋지만 , 좋은 출발점이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="d28f8549e31b151dd0222afe166ac626a4278627" translate="yes" xml:space="preserve">
          <source>The following line enables YUI compression, and requires the &lt;code&gt;yui-compressor&lt;/code&gt; gem.</source>
          <target state="translated">다음 줄은 YUI 압축을 활성화하며 &lt;code&gt;yui-compressor&lt;/code&gt; gem이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="f47cec262f30e06d8f4686db19c2d636b84a9271" translate="yes" xml:space="preserve">
          <source>The following line invokes &lt;code&gt;uglifier&lt;/code&gt; for JavaScript compression.</source>
          <target state="translated">다음 줄은 JavaScript 압축을 위해 &lt;code&gt;uglifier&lt;/code&gt; 을 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3a19c4339274251eb0bf0254401868be2ad510d0" translate="yes" xml:space="preserve">
          <source>The following methods are only implemented in &lt;code&gt;active_support/core_ext/date_time/calculations.rb&lt;/code&gt; as they only make sense when used with a &lt;code&gt;DateTime&lt;/code&gt; instance:</source>
          <target state="translated">다음 메소드는 &lt;code&gt;DateTime&lt;/code&gt; 인스턴스 와 함께 사용하는 경우에만 의미가 있으므로 &lt;code&gt;active_support/core_ext/date_time/calculations.rb&lt;/code&gt; 에서만 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="f43faaf33bf2c0cdf7480bc0b867a519fa0ab48b" translate="yes" xml:space="preserve">
          <source>The following methods are reimplemented so you do &lt;strong&gt;not&lt;/strong&gt; need to load &lt;code&gt;active_support/core_ext/date/calculations.rb&lt;/code&gt; for these ones:</source>
          <target state="translated">다음 방법이 다시 구현되므로 이러한 방법에 대해 &lt;code&gt;active_support/core_ext/date/calculations.rb&lt;/code&gt; 를로드 할 필요 가 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="3a5dee795f797c6e7d2a27bbce6ab149fb9ee6ba" translate="yes" xml:space="preserve">
          <source>The following methods for retrieval and query of a single associated object will be added:</source>
          <target state="translated">연관된 단일 객체의 검색 및 조회를위한 다음 방법이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d5783a97e1eb9d3a76a908a48921fa3c38071460" translate="yes" xml:space="preserve">
          <source>The following methods return a &lt;code&gt;Time&lt;/code&gt; object if possible, otherwise a &lt;code&gt;DateTime&lt;/code&gt;. If set, they honor the user time zone.</source>
          <target state="translated">다음 메소드는 가능 하면 &lt;code&gt;Time&lt;/code&gt; 객체를, 그렇지 않으면 &lt;code&gt;DateTime&lt;/code&gt; 을 반환합니다 . 설정된 경우 사용자 시간대를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="657070cc7bdd9e1b035ac61f00a01849f933d950" translate="yes" xml:space="preserve">
          <source>The following methods skip validations, and will save the object to the database regardless of its validity. They should be used with caution.</source>
          <target state="translated">다음 방법은 유효성 검사를 건너 뛰고 유효성에 관계없이 개체를 데이터베이스에 저장합니다. 주의해서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1f465129a4fb90e4527101bf731f2963373a56d8" translate="yes" xml:space="preserve">
          <source>The following methods trigger callbacks:</source>
          <target state="translated">다음 메소드는 콜백을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="cfbc7fa8f557720dad3b43f60910ef4eb36a6082" translate="yes" xml:space="preserve">
          <source>The following methods trigger validations, and will save the object to the database only if the object is valid:</source>
          <target state="translated">다음 메소드는 유효성 검증을 트리거하고 오브젝트가 유효한 경우에만 오브젝트를 데이터베이스에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="36cf22b1fa5b113b06014631879e53072ca8ace1" translate="yes" xml:space="preserve">
          <source>The following migration will remove the table 'horses' and create the table 'apples' on the way up, and the reverse on the way down.</source>
          <target state="translated">다음 마이그레이션은 테이블 'horses'를 제거하고 올라가는 동안 테이블 'apples'를 만들고 내리는 길의 테이블을 'apples'로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e4d77afab2cb5c0e79177397fed4c21c74e5e9f3" translate="yes" xml:space="preserve">
          <source>The following options are accepted:</source>
          <target state="translated">다음과 같은 옵션이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="07868184f0badaae70ea74815fedb13374262579" translate="yes" xml:space="preserve">
          <source>The following sections give the details of each type of association, including the methods that they add and the options that you can use when declaring an association.</source>
          <target state="translated">다음 섹션에서는 추가하는 방법 및 연결을 선언 할 때 사용할 수있는 옵션을 포함하여 각 연결 유형에 대한 세부 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="2562708af49a0bfce89266564bd6292133c83b57" translate="yes" xml:space="preserve">
          <source>The following sections outline the primary methods provided by the API:</source>
          <target state="translated">다음 섹션에서는 API에서 제공하는 기본 방법을 간략하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="609de3a69e18bad3684cc06e831d02068915f957" translate="yes" xml:space="preserve">
          <source>The following setup steps are common to both examples:</source>
          <target state="translated">다음 설정 단계는 두 예제 모두에 공통입니다.</target>
        </trans-unit>
        <trans-unit id="68ac9096c207d6e6fc7e824e70e5b3e0bab909e1" translate="yes" xml:space="preserve">
          <source>The following symbols are special:</source>
          <target state="translated">다음 기호는 특별합니다.</target>
        </trans-unit>
        <trans-unit id="9ff0dc756e7049a9d9d1160dc09667c5d872c2b2" translate="yes" xml:space="preserve">
          <source>The following two forms both upload a file.</source>
          <target state="translated">다음 두 가지 형식 모두 파일을 업로드합니다.</target>
        </trans-unit>
        <trans-unit id="1b73d642411f485e10316d22f8c12e0959b92a7e" translate="yes" xml:space="preserve">
          <source>The following validations are added automatically:</source>
          <target state="translated">다음 유효성 검사가 자동으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="392904f5f0a66b4200b7691949066a9831c1859a" translate="yes" xml:space="preserve">
          <source>The following values are considered to be blank in a Rails application:</source>
          <target state="translated">Rails 애플리케이션에서 다음 값은 공백으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="deee9509446ecf108a516105821dd5478062ac54" translate="yes" xml:space="preserve">
          <source>The foreign key column name on &lt;code&gt;from_table&lt;/code&gt;. Defaults to &lt;code&gt;to_table.singularize + &quot;_id&quot;&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;from_table&lt;/code&gt; 의 외래 키 열 이름입니다 . 기본적으로 &lt;code&gt;to_table.singularize + &quot;_id&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3326729145fe6394d473ee7cb8400c3bea60f441" translate="yes" xml:space="preserve">
          <source>The foreign key will be named after the following pattern: &lt;code&gt;fk_rails_&amp;lt;identifier&amp;gt;&lt;/code&gt;. &lt;code&gt;identifier&lt;/code&gt; is a 10 character long string which is deterministically generated from the &lt;code&gt;from_table&lt;/code&gt; and &lt;code&gt;column&lt;/code&gt;. A custom name can be specified with the &lt;code&gt;:name&lt;/code&gt; option.</source>
          <target state="translated">외래 키는 &lt;code&gt;fk_rails_&amp;lt;identifier&amp;gt;&lt;/code&gt; 패턴에 따라 이름이 지정됩니다 . &lt;code&gt;identifier&lt;/code&gt; 는 &lt;code&gt;from_table&lt;/code&gt; 및 &lt;code&gt;column&lt;/code&gt; 에서 결정적으로 생성되는 10 자 길이의 문자열입니다 . &lt;code&gt;:name&lt;/code&gt; 옵션으로 사용자 정의 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="090e93106d4fe15776dd64af77237f6b9a5104b9" translate="yes" xml:space="preserve">
          <source>The form builder used also determines what happens when you do</source>
          <target state="translated">사용 된 양식 빌더는 수행 할 때 수행되는 작업도 결정합니다.</target>
        </trans-unit>
        <trans-unit id="60342ada4ced98a39f41de5586ec3ad3944ed28b" translate="yes" xml:space="preserve">
          <source>The form needs to use a different URL in order to go somewhere else. This can be done quite simply with the &lt;code&gt;:url&lt;/code&gt; option of &lt;code&gt;form_with&lt;/code&gt;. Typically in Rails, the action that is used for new form submissions like this is called &quot;create&quot;, and so the form should be pointed to that action.</source>
          <target state="translated">다른 곳으로 이동하려면 양식에서 다른 URL을 사용해야합니다. 이는 &lt;code&gt;form_with&lt;/code&gt; 의 &lt;code&gt;:url&lt;/code&gt; 옵션을 사용하여 간단하게 수행 할 수 있습니다 . 일반적으로 Rails에서는 이와 같은 새 양식 제출에 사용되는 동작을 &quot;만들기&quot;라고하므로 해당 형식을 해당 동작으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="db75dbcbdc0e093bbfc719f467a241d7e67a2520" translate="yes" xml:space="preserve">
          <source>The form will be making a &lt;code&gt;POST&lt;/code&gt; request to &lt;code&gt;/articles/:article_id/comments&lt;/code&gt;, which will correspond with the &lt;code&gt;create&lt;/code&gt; action in &lt;code&gt;Blorgh::CommentsController&lt;/code&gt;. This action needs to be created, which can be done by putting the following lines inside the class definition in &lt;code&gt;app/controllers/blorgh/comments_controller.rb&lt;/code&gt;:</source>
          <target state="translated">양식은 &lt;code&gt;/articles/:article_id/comments&lt;/code&gt; 에 &lt;code&gt;POST&lt;/code&gt; 요청을 하는데 이는 &lt;code&gt;Blorgh::CommentsController&lt;/code&gt; 의 &lt;code&gt;create&lt;/code&gt; 조치에 해당합니다 . 이 조치는 &lt;code&gt;app/controllers/blorgh/comments_controller.rb&lt;/code&gt; 의 클래스 정의 안에 다음 행을 넣어서 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7fbb9ae7852d624b58a411bef42e33a47388b020" translate="yes" xml:space="preserve">
          <source>The form's authenticity parameter. Override to provide your own.</source>
          <target state="translated">양식의 진위 매개 변수. 직접 제공하도록 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="3a13d407b622c23af95f052897df47515f94470f" translate="yes" xml:space="preserve">
          <source>The format of a fixture file looks like this:</source>
          <target state="translated">조명기 파일의 형식은 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="2f7cb81c43eb0277bcb09abdbdfa4f95cbea41c6" translate="yes" xml:space="preserve">
          <source>The format of the schema dump generated by Rails is controlled by the &lt;code&gt;config.active_record.schema_format&lt;/code&gt; setting in &lt;code&gt;config/application.rb&lt;/code&gt;. By default, the format is &lt;code&gt;:ruby&lt;/code&gt;, but can also be set to &lt;code&gt;:sql&lt;/code&gt;.</source>
          <target state="translated">Rails가 생성 한 스키마 덤프의 형식은 &lt;code&gt;config/application.rb&lt;/code&gt; 의 &lt;code&gt;config.active_record.schema_format&lt;/code&gt; 설정에 의해 제어됩니다 . 기본적으로 형식은 &lt;code&gt;:ruby&lt;/code&gt; 이지만 &lt;code&gt;:sql&lt;/code&gt; 로 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2bcbf7d68f15e27fc0dd857f9971c15c0d46bd3" translate="yes" xml:space="preserve">
          <source>The former is the main one. The latter is there mostly for backwards compatibility reasons, in case the application has something in &lt;code&gt;config.autoload_once_paths&lt;/code&gt; (this is discouraged nowadays).</source>
          <target state="translated">전자가 주요 제품입니다. 후자는 대부분 &lt;code&gt;config.autoload_once_paths&lt;/code&gt; 에 응용 프로그램이있는 경우 (이것은 권장하지 않음) 이전 버전과의 호환성을 위해 주로 존재 합니다.</target>
        </trans-unit>
        <trans-unit id="82fadfffe8a017d8cc4cbac60f0f81c907522668" translate="yes" xml:space="preserve">
          <source>The full list of options for the plugin generator may be seen by typing:</source>
          <target state="translated">플러그인 생성기의 전체 옵션 목록은 다음을 입력하여 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bde2b1b890d3a726aec51e0fcf264cdac863fa" translate="yes" xml:space="preserve">
          <source>The full request object is available via the request accessor and is primarily used to query for HTTP headers:</source>
          <target state="translated">전체 요청 객체는 요청 접근자를 통해 사용할 수 있으며 주로 HTTP 헤더를 쿼리하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="15558a932ce7d5ec8c2377322dcd833861fe3a97" translate="yes" xml:space="preserve">
          <source>The full set of methods that can be used in this block are as follows:</source>
          <target state="translated">이 블록에서 사용할 수있는 전체 메소드 세트는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46bd57d06a4ef9cdd161560d193f0e40b2eb8282" translate="yes" xml:space="preserve">
          <source>The general layout of a Rails application.</source>
          <target state="translated">Rails 애플리케이션의 일반적인 레이아웃.</target>
        </trans-unit>
        <trans-unit id="e7eeed51b86202389059cb757e688e04f990154f" translate="yes" xml:space="preserve">
          <source>The generated ID for a given label is constant, so we can discover any fixture's ID without loading anything, as long as we know the label.</source>
          <target state="translated">주어진 레이블에 대해 생성 된 ID는 일정하므로 레이블을 알고있는 한 아무 것도로드하지 않고 조명기의 ID를 발견 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c89bd0c48d5da0f02788cadbf5279ad7b0b6ae74" translate="yes" xml:space="preserve">
          <source>The generated attributes are escaped by default. This can be disabled using &lt;code&gt;escape_attributes&lt;/code&gt;.</source>
          <target state="translated">생성 된 속성은 기본적으로 이스케이프됩니다. &lt;code&gt;escape_attributes&lt;/code&gt; 를 사용하여 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83ab849c0e0913321228afc5541b5041a5ce971d" translate="yes" xml:space="preserve">
          <source>The generated model inherits from &lt;code&gt;ApplicationMailer&lt;/code&gt; which in turn inherits from &lt;code&gt;ActionMailer::Base&lt;/code&gt;. A mailer model defines methods used to generate an email message. In these methods, you can setup variables to be used in the mailer views, options on the mail itself such as the &lt;code&gt;:from&lt;/code&gt; address, and attachments.</source>
          <target state="translated">생성 된 모델은 &lt;code&gt;ApplicationMailer&lt;/code&gt; 에서 상속되며,이 &lt;code&gt;ActionMailer::Base&lt;/code&gt; 는 ActionMailer :: Base 에서 상속됩니다 . 메일러 모델은 전자 메일 메시지를 생성하는 데 사용되는 방법을 정의합니다. 이 방법에서는 메일러보기, 메일 자체의 옵션 (예 &lt;code&gt;:from&lt;/code&gt; 주소 및 첨부 파일)에 사용할 변수를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9642127f67417f40c4b17b7ca6fba9837a5b3709" translate="yes" xml:space="preserve">
          <source>The generated model will look like this:</source>
          <target state="translated">생성 된 모델은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ebb94072c2ba22e483813ad1a85b01320851bc6" translate="yes" xml:space="preserve">
          <source>The generation of the reader instance method can be prevented by setting &lt;code&gt;:instance_reader&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; and the generation of the writer instance method can be prevented by setting &lt;code&gt;:instance_writer&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. Generation of both methods can be prevented by setting &lt;code&gt;:instance_accessor&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. In all cases, the value must be exactly &lt;code&gt;false&lt;/code&gt; and not any false value.</source>
          <target state="translated">리더 인스턴스 메소드의 생성을 설정함으로써 방지 될 수있다 &lt;code&gt;:instance_reader&lt;/code&gt; 에 &lt;code&gt;false&lt;/code&gt; 및 라이터 인스턴스 메소드의 발생을 설정함으로써 방지 될 수있다 &lt;code&gt;:instance_writer&lt;/code&gt; 에 &lt;code&gt;false&lt;/code&gt; . &lt;code&gt;:instance_accessor&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하면 두 방법의 생성을 막을 수 있습니다 . 모든 경우에, 값은 거짓 값이 아닌 정확하게 &lt;code&gt;false&lt;/code&gt; 이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="d4bf2ad59eb23553637bb6ad74e918f26165d9a9" translate="yes" xml:space="preserve">
          <source>The generation of the reader instance method can be prevented by setting the option &lt;code&gt;:instance_reader&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:instance_reader&lt;/code&gt; 옵션 을 &lt;code&gt;false&lt;/code&gt; 로 설정하면 리더 인스턴스 메소드 생성을 막을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96923220f999eee1905ec339692e505269b44e49" translate="yes" xml:space="preserve">
          <source>The generation of the writer instance method can be prevented by setting the option &lt;code&gt;:instance_writer&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:instance_writer&lt;/code&gt; 옵션 을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 라이터 인스턴스 메소드 생성을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03b7c6a99d34c4aaf65fc166f48dc469d58dfbbc" translate="yes" xml:space="preserve">
          <source>The generator checks that there exist the directories for models, controllers, helpers, layouts, functional and unit tests, stylesheets, creates the views, controller, model and database migration for HighScore (creating the &lt;code&gt;high_scores&lt;/code&gt; table and fields), takes care of the route for the &lt;strong&gt;resource&lt;/strong&gt;, and new tests for everything.</source>
          <target state="translated">생성기는 모델, 컨트롤러, 도우미, 레이아웃, 기능 및 단위 테스트, 스타일 시트에 대한 디렉토리가 있는지 확인하고 HighScore에 대한보기, 컨트롤러, 모델 및 데이터베이스 마이그레이션 ( &lt;code&gt;high_scores&lt;/code&gt; 테이블 및 필드 작성)을 작성 하고 경로를 처리합니다. 을위한 &lt;strong&gt;자원&lt;/strong&gt; 및 모두를위한 새로운 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7b39f749f99948f5914a83edc800a368fad145a9" translate="yes" xml:space="preserve">
          <source>The generators you can use to create them.</source>
          <target state="translated">생성기를 사용하여 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a11e822e465e85b59074ad8222bc49591cdfb25" translate="yes" xml:space="preserve">
          <source>The goals of testing your mailer classes are to ensure that:</source>
          <target state="translated">메일러 클래스 테스트의 목표는 다음을 보장하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="362978286aa17bd104be42963df61dd594f4d276" translate="yes" xml:space="preserve">
          <source>The guides for earlier releases: &lt;a href=&quot;https://guides.rubyonrails.org/v5.2/&quot;&gt;Rails 5.2&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v5.1/&quot;&gt;Rails 5.1&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v5.0/&quot;&gt;Rails 5.0&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v4.2/&quot;&gt;Rails 4.2&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v4.1/&quot;&gt;Rails 4.1&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v4.0/&quot;&gt;Rails 4.0&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v3.2/&quot;&gt;Rails 3.2&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v3.1/&quot;&gt;Rails 3.1&lt;/a&gt;, &lt;a href=&quot;https://guides.rubyonrails.org/v3.0/&quot;&gt;Rails 3.0&lt;/a&gt;, and &lt;a href=&quot;https://guides.rubyonrails.org/v2.3/&quot;&gt;Rails 2.3&lt;/a&gt;.</source>
          <target state="translated">이전 릴리스에 대한 안내서 : &lt;a href=&quot;https://guides.rubyonrails.org/v5.2/&quot;&gt;Rails 5.2&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v5.1/&quot;&gt;Rails 5.1&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v5.0/&quot;&gt;Rails 5.0&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v4.2/&quot;&gt;Rails 4.2&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v4.1/&quot;&gt;Rails 4.1&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v4.0/&quot;&gt;Rails 4.0&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v3.2/&quot;&gt;Rails 3.2&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v3.1/&quot;&gt;Rails 3.1&lt;/a&gt; , &lt;a href=&quot;https://guides.rubyonrails.org/v3.0/&quot;&gt;Rails 3.0&lt;/a&gt; 및 &lt;a href=&quot;https://guides.rubyonrails.org/v2.3/&quot;&gt;Rails 2.3&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0769462d4182a8d7e15fc285a42e4195eb77d38c" translate="yes" xml:space="preserve">
          <source>The hash keys are the attribute names, and the hash values are the original attribute values in the database (as opposed to the in-memory values about to be saved).</source>
          <target state="translated">해시 키는 속성 이름이고 해시 값은 데이터베이스의 원래 속성 값입니다 (메모리 내 값이 저장 되려고하는 것과 반대).</target>
        </trans-unit>
        <trans-unit id="058d050ee7d540ed9e563b384b80cef28a9d82ce" translate="yes" xml:space="preserve">
          <source>The hash passed to the mail method allows you to specify any header that a &lt;code&gt;Mail::Message&lt;/code&gt; will accept (any valid email header including optional fields).</source>
          <target state="translated">mail 메소드에 전달 된 해시는 &lt;code&gt;Mail::Message&lt;/code&gt; 가 수락 할 헤더 (옵션 필드를 포함한 유효한 이메일 헤더) 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6f5c290181dabdf6559a851bcac9bcc0636e995f" translate="yes" xml:space="preserve">
          <source>The helper gets the name of the favicon file as first argument, which defaults to &amp;ldquo;favicon.ico&amp;rdquo;, and also supports &lt;code&gt;:rel&lt;/code&gt; and &lt;code&gt;:type&lt;/code&gt; options to override their defaults, &amp;ldquo;shortcut icon&amp;rdquo; and &amp;ldquo;image/x-icon&amp;rdquo; respectively:</source>
          <target state="translated">도우미는 favicon 파일의 이름을 첫 번째 인수로 가져옵니다. 기본값은 &quot;favicon.ico&quot;이며 기본값은 &quot;shortcut icon&quot;및 &quot;image / x-icon&quot;을 재정의 하는 &lt;code&gt;:rel&lt;/code&gt; 및 &lt;code&gt;:type&lt;/code&gt; 옵션을 지원합니다 .</target>
        </trans-unit>
        <trans-unit id="c8f3b49cd9e3cb6be9a8ff2c3fb102ef6cfdd129" translate="yes" xml:space="preserve">
          <source>The helper inside &lt;code&gt;app/helpers/blorgh/articles_helper.rb&lt;/code&gt; is also namespaced:</source>
          <target state="translated">&lt;code&gt;app/helpers/blorgh/articles_helper.rb&lt;/code&gt; 내부의 도우미 도 네임 스페이스입니다.</target>
        </trans-unit>
        <trans-unit id="3b93bd5de48450a8776f0c3f464e327c151c1f12" translate="yes" xml:space="preserve">
          <source>The helper method &lt;code&gt;full_messages&lt;/code&gt; uses &lt;code&gt;humanize&lt;/code&gt; as a fallback to include attribute names:</source>
          <target state="translated">헬퍼 메소드 &lt;code&gt;full_messages&lt;/code&gt; 는 &lt;code&gt;humanize&lt;/code&gt; 를 대체 이름으로 사용 하여 속성 이름을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c03db03c2478cc4beefab4ef9e28af6f4d551a14" translate="yes" xml:space="preserve">
          <source>The helper methods called on the form builder are identical to the model object helpers except that it is not necessary to specify which object is being edited since this is already managed by the form builder.</source>
          <target state="translated">양식 빌더에서 호출 된 헬퍼 메소드는 양식 작성기에서 이미 관리하고 있으므로 편집중인 오브젝트를 지정할 필요가 없다는 점을 제외하고 모델 오브젝트 헬퍼와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="48e6e57e3a5816d496cf9346b7b10113bd662a20" translate="yes" xml:space="preserve">
          <source>The hooks inside the Rails framework for instrumentation.</source>
          <target state="translated">계측을위한 Rails 프레임 워크 내부의 후크.</target>
        </trans-unit>
        <trans-unit id="4b21621570d8c2b68888621ecdd2bf376d3c4875" translate="yes" xml:space="preserve">
          <source>The hooks lookup is similar as above:</source>
          <target state="translated">후크 조회는 위와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="465f83962e2239cb19550b0b54f391531039b74a" translate="yes" xml:space="preserve">
          <source>The hostname used for this request.</source>
          <target state="translated">이 요청에 사용 된 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="df619d8c4ceafae7f4ef07c3343b96da7296ae57" translate="yes" xml:space="preserve">
          <source>The hostname used in the last request.</source>
          <target state="translated">마지막 요청에 사용 된 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="d729a8f7d6c2e7248811f11389969b4f75002255" translate="yes" xml:space="preserve">
          <source>The hostname's first &lt;code&gt;n&lt;/code&gt; segments, starting from the right (the TLD).</source>
          <target state="translated">오른쪽에서 시작하여 호스트 이름의 첫 번째 &lt;code&gt;n&lt;/code&gt; 세그먼트 (TLD)입니다.</target>
        </trans-unit>
        <trans-unit id="42fa67d833d76b1422c347fe803ccf6a40acbd46" translate="yes" xml:space="preserve">
          <source>The i18n library takes a &lt;strong&gt;pragmatic approach&lt;/strong&gt; to locale keys (after &lt;a href=&quot;https://groups.google.com/forum/#!topic/rails-i18n/FN7eLH2-lHA&quot;&gt;some discussion&lt;/a&gt;), including only the &lt;em&gt;locale&lt;/em&gt; (&quot;language&quot;) part, like &lt;code&gt;:en&lt;/code&gt;, &lt;code&gt;:pl&lt;/code&gt;, not the &lt;em&gt;region&lt;/em&gt; part, like &lt;code&gt;:en-US&lt;/code&gt; or &lt;code&gt;:en-GB&lt;/code&gt;, which are traditionally used for separating &quot;languages&quot; and &quot;regional setting&quot; or &quot;dialects&quot;. Many international applications use only the &quot;language&quot; element of a locale such as &lt;code&gt;:cs&lt;/code&gt;, &lt;code&gt;:th&lt;/code&gt;, or &lt;code&gt;:es&lt;/code&gt; (for Czech, Thai, and Spanish). However, there are also regional differences within different language groups that may be important. For instance, in the &lt;code&gt;:en-US&lt;/code&gt; locale you would have $ as a currency symbol, while in &lt;code&gt;:en-GB&lt;/code&gt;, you would have &amp;pound;. Nothing stops you from separating regional and other settings in this way: you just have to provide full &quot;English - United Kingdom&quot; locale in a &lt;code&gt;:en-GB&lt;/code&gt; dictionary.</source>
          <target state="translated">국제화 (i18n) 라이브러리가 소요 &lt;strong&gt;실용적인 접근&lt;/strong&gt; (후 로케일 키를 &lt;a href=&quot;https://groups.google.com/forum/#!topic/rails-i18n/FN7eLH2-lHA&quot;&gt;논의&lt;/a&gt; 에만 포함) &lt;em&gt;로케일&lt;/em&gt; ( &quot;언어&quot;) 부분, 같은 &lt;code&gt;:en&lt;/code&gt; , &lt;code&gt;:pl&lt;/code&gt; 아닌 &lt;em&gt;지역의&lt;/em&gt; 부분, 같은 &lt;code&gt;:en-US&lt;/code&gt; 또는 &lt;code&gt;:en-GB&lt;/code&gt; , &quot;언어&quot;와 &quot;지역 설정&quot;또는 &quot;방언&quot;을 분리하는 데 전통적으로 사용됩니다. 많은 국제 응용 프로그램에서는 &lt;code&gt;:cs&lt;/code&gt; , &lt;code&gt;:th&lt;/code&gt; 또는 &lt;code&gt;:es&lt;/code&gt; (체코 어, 태국어 및 스페인어)와 같은 로캘의 &quot;language&quot;요소 만 사용합니다 . 그러나 다른 언어 그룹에는 중요한 지역적 차이도 있습니다. 예를 들어 &lt;code&gt;:en-US&lt;/code&gt; 에서로케일에는 통화 기호로 $가 있고, &lt;code&gt;:en-GB&lt;/code&gt; 에 &amp;pound;가 있습니다. 이런 식으로 지역 및 기타 설정을 분리하는 것을 막을 수있는 것은 없습니다 &lt;code&gt;:en-GB&lt;/code&gt; 사전 에서 &quot;영어-영국&quot;로케일을 제공하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="7f53afb305af92309a3fdf213ca6a51b59f8138a" translate="yes" xml:space="preserve">
          <source>The idea of a parent namespace is at the core of the autoloading algorithms and helps explain and understand their motivation intuitively, but as you see that metaphor leaks easily. Given an edge case to reason about, take always into account that by &quot;parent namespace&quot; the guide means exactly that specific string derivation.</source>
          <target state="translated">부모 네임 스페이스에 대한 아이디어는 자동로드 알고리즘의 핵심이며 동기 부여를 직관적으로 설명하고 이해하는 데 도움이되지만 메타포가 쉽게 누출되는 것을 알 수 있습니다. 추론해야 할 중요한 경우를 고려할 때, 항상 &quot;부모 네임 스페이스&quot;에 의해이 가이드는 특정 문자열 파생을 정확히 의미한다는 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5f19b540681118fdd893c06bdeb7c6925c5febfb" translate="yes" xml:space="preserve">
          <source>The immutable requirement is enforced by Active Record by freezing any object assigned as a value object. Attempting to change it afterwards will result in a &lt;code&gt;RuntimeError&lt;/code&gt;.</source>
          <target state="translated">불변 요구 사항은 값 개체로 할당 된 개체를 고정하여 Active Record에 의해 적용됩니다. 나중에 변경하려고하면 &lt;code&gt;RuntimeError&lt;/code&gt; 가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="54381883e6c09b4dc43d4ac46bee21b9cc5395a7" translate="yes" xml:space="preserve">
          <source>The implicit block given to &lt;code&gt;link_to_unless_current&lt;/code&gt; is evaluated if the current action is the action given. So, if we had a comments page and wanted to render a &amp;ldquo;Go Back&amp;rdquo; link instead of a link to the comments page, we could do something like this&amp;hellip;</source>
          <target state="translated">&lt;code&gt;link_to_unless_current&lt;/code&gt; 에 제공된 내재적 블록 은 현재 조치가 제공된 조치인지 평가됩니다. 따라서 댓글 페이지가 있고 댓글 페이지에 대한 링크 대신 &quot;돌아 가기&quot;링크를 렌더링하려는 경우 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae13bd63f4cdb460db67da0c75a77a0f55f7ea5c" translate="yes" xml:space="preserve">
          <source>The inbound emails are turned into &lt;code&gt;InboundEmail&lt;/code&gt; records using Active Record and feature lifecycle tracking, storage of the original email on cloud storage via Active Storage, and responsible data handling with on-by-default incineration.</source>
          <target state="translated">인바운드 이메일은 Active Record 및 기능 수명주기 추적, Active Storage를 통한 클라우드 스토리지의 원본 이메일 저장 및 기본 소각을 통한 책임있는 데이터 처리를 사용하여 &lt;code&gt;InboundEmail&lt;/code&gt; 레코드 로 변환 됩니다.</target>
        </trans-unit>
        <trans-unit id="869236c95820445e727ad51587da6b23b472304d" translate="yes" xml:space="preserve">
          <source>The index view (&lt;code&gt;app/views/users/index.html.erb&lt;/code&gt;) contains:</source>
          <target state="translated">색인보기 ( &lt;code&gt;app/views/users/index.html.erb&lt;/code&gt; )에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="b32f9511f66640e563df5e34e2c7c0a6fab3ddf3" translate="yes" xml:space="preserve">
          <source>The index will be named after the table and the column name(s), unless you pass &lt;code&gt;:name&lt;/code&gt; as an option.</source>
          <target state="translated">&lt;code&gt;:name&lt;/code&gt; 을 옵션으로 전달하지 않으면 인덱스 이름은 테이블과 열 이름을 따라 이름이 지정 됩니다.</target>
        </trans-unit>
        <trans-unit id="648e623dacab4b9af4b014df64075bd0547875ce" translate="yes" xml:space="preserve">
          <source>The initializer wants to create a &lt;code&gt;BellX1::FlightModel&lt;/code&gt; and nesting has &lt;code&gt;BellX1&lt;/code&gt;, that looks good. But if the default flight model is loaded and the one for the Bell-X1 is not, the interpreter is able to resolve the top-level &lt;code&gt;FlightModel&lt;/code&gt; and autoloading is thus not triggered for &lt;code&gt;BellX1::FlightModel&lt;/code&gt;.</source>
          <target state="translated">이니셜 라이저는 &lt;code&gt;BellX1::FlightModel&lt;/code&gt; 을 만들고 싶어 하고 중첩에는 &lt;code&gt;BellX1&lt;/code&gt; 이 있습니다. 그러나 기본 비행 모델이로드되고 Bell-X1에 대한 비행 모델이로드되지 않으면 인터프리터는 최상위 &lt;code&gt;FlightModel&lt;/code&gt; 을 해석 할 수 있으므로 &lt;code&gt;BellX1::FlightModel&lt;/code&gt; 에 대해 자동로드가 트리거되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="7c80d611760f565bf27d46366137ae2e4fd9731f" translate="yes" xml:space="preserve">
          <source>The instrumentation API provided by Active Support allows developers to provide hooks which other developers may hook into. There are several of these within the &lt;a href=&quot;#rails-framework-hooks&quot;&gt;Rails framework&lt;/a&gt;. With this API, developers can choose to be notified when certain events occur inside their application or another piece of Ruby code.</source>
          <target state="translated">Active Support에서 제공하는 계측 API를 통해 개발자는 다른 개발자가 연결할 수있는 후크를 제공 할 수 있습니다. &lt;a href=&quot;#rails-framework-hooks&quot;&gt;Rails 프레임 워크&lt;/a&gt; 에는 몇 가지가 있습니다 . 이 API를 사용하면 개발자는 애플리케이션 또는 다른 Ruby 코드 내에서 특정 이벤트가 발생할 때 알림을 받도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b71bf98dd0cdf4cb43c535aaee7d46af03287d" translate="yes" xml:space="preserve">
          <source>The intended use case for this method is to escape JSON strings before including them inside a script tag to avoid XSS vulnerability:</source>
          <target state="translated">이 방법의 의도 된 사용 사례는 JSON 문자열을 스크립트 태그에 포함시키기 전에 JSON 문자열을 이스케이프하여 XSS 취약점을 피하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="79f2c35a7b9a90149c8abcd1a54d9b8fc7aa6157" translate="yes" xml:space="preserve">
          <source>The interaction &lt;em&gt;changes the state&lt;/em&gt; of the resource in a way that the user would perceive (e.g., a subscription to a service), or</source>
          <target state="translated">상호 작용 은 사용자가 인식하는 방식 (예 : 서비스 가입)으로 리소스 &lt;em&gt;상태&lt;/em&gt; 를 &lt;em&gt;변경&lt;/em&gt; 하거나</target>
        </trans-unit>
        <trans-unit id="a5762c80b87c2c4c3a9e18dfd534cadedd2d6b35" translate="yes" xml:space="preserve">
          <source>The interaction is more &lt;em&gt;like a question&lt;/em&gt; (i.e., it is a safe operation such as a query, read operation, or lookup).</source>
          <target state="translated">상호 작용은 &lt;em&gt;질문과 유사합니다&lt;/em&gt; (예 : 쿼리, 읽기 작업 또는 조회와 같은 안전한 작업).</target>
        </trans-unit>
        <trans-unit id="7962fec553e1f444a5bd713ae1675baca557a15e" translate="yes" xml:space="preserve">
          <source>The interaction is more &lt;em&gt;like an order&lt;/em&gt;, or</source>
          <target state="translated">상호 작용은 &lt;em&gt;주문과 비슷&lt;/em&gt; 하거나</target>
        </trans-unit>
        <trans-unit id="95f3d55c11448516ef4cf2c075e8257c9652b19b" translate="yes" xml:space="preserve">
          <source>The interesting part for a Rails app is the last line, &lt;code&gt;server.run&lt;/code&gt;. Here we encounter the &lt;code&gt;wrapped_app&lt;/code&gt; method again, which this time we're going to explore more (even though it was executed before, and thus memoized by now).</source>
          <target state="translated">Rails 앱의 흥미로운 부분은 마지막 줄 &lt;code&gt;server.run&lt;/code&gt; 입니다. 여기서는 &lt;code&gt;wrapped_app&lt;/code&gt; 메소드를 다시 만나게 되는데, 이번에는 더 많이 살펴볼 것입니다.</target>
        </trans-unit>
        <trans-unit id="b459fda0fb539be04b0a909ef219de4e5a2b39af" translate="yes" xml:space="preserve">
          <source>The interpretation of a parent namespace when thinking about classes and modules is tricky though. Let's consider a module M named &quot;A::B&quot;:</source>
          <target state="translated">클래스와 모듈을 생각할 때 부모 네임 스페이스를 해석하는 것은 까다 롭습니다. &quot;A :: B&quot;라는 모듈 M을 생각해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b088dc4a33ac210d77c1458749a93ed8bf4c34fc" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;String#include?&lt;/code&gt;. Returns true if the string does not include the other string.</source>
          <target state="translated">&lt;code&gt;String#include?&lt;/code&gt; 의 역 ? . 문자열에 다른 문자열이 포함되어 있지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d3b045c64486cd3543aa4c92eac840cd5ff4ee1a" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;code&gt;pluralize&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;pluralize&lt;/code&gt; 의 역수 :</target>
        </trans-unit>
        <trans-unit id="5dd1404e8fb1e4a2f3428a87a501d557bbc475c1" translate="yes" xml:space="preserve">
          <source>The join table should not have a primary key or a model associated with it. You must manually generate the join table with a migration such as this:</source>
          <target state="translated">조인 테이블에는 기본 키 또는 이와 관련된 모델이 없어야합니다. 다음과 같은 마이그레이션으로 조인 테이블을 수동으로 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="052d7b38c38526d06bad1945b5b98f5f66c7d437" translate="yes" xml:space="preserve">
          <source>The key for the error message in this case is &lt;code&gt;:blank&lt;/code&gt;. Active Record will look up this key in the namespaces:</source>
          <target state="translated">이 경우 오류 메시지의 키는 &lt;code&gt;:blank&lt;/code&gt; 입니다. Active Record는 네임 스페이스에서이 키를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a03e001b53b8dfaae3a1107e4ec8266dabdface7" translate="yes" xml:space="preserve">
          <source>The keys must be the fixture names, that coincide with the short paths to the fixture files.</source>
          <target state="translated">키는 조명기 이름이어야하며, 조명기 파일의 짧은 경로와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="1d3e3365229f6940a1c09a4628bdc8177d9404b5" translate="yes" xml:space="preserve">
          <source>The keys of the &lt;code&gt;:addresses_attributes&lt;/code&gt; hash are unimportant, they need merely be different for each address.</source>
          <target state="translated">&lt;code&gt;:addresses_attributes&lt;/code&gt; 해시 의 키 는 중요하지 않으며 각 주소마다 다르면됩니다.</target>
        </trans-unit>
        <trans-unit id="437996ad7c0e04b8e7fa0c7a7527aa0f661baec9" translate="yes" xml:space="preserve">
          <source>The keys of the hash which is the value for &lt;code&gt;:posts_attributes&lt;/code&gt; are ignored in this case. However, it is not allowed to use &lt;code&gt;'id'&lt;/code&gt; or &lt;code&gt;:id&lt;/code&gt; for one of such keys, otherwise the hash will be wrapped in an array and interpreted as an attribute hash for a single post.</source>
          <target state="translated">이 경우 &lt;code&gt;:posts_attributes&lt;/code&gt; 의 값인 해시 키 는 무시됩니다. 그러나 이러한 키 중 하나에 &lt;code&gt;'id'&lt;/code&gt; 또는 &lt;code&gt;:id&lt;/code&gt; 를 사용할 수 없습니다 . 그렇지 않으면 해시가 배열로 랩핑되어 단일 게시물의 속성 해시로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="bff0237eaabfc7db91da8d08231c80475092cb7e" translate="yes" xml:space="preserve">
          <source>The keys used in a cache can be any object that responds to either &lt;code&gt;cache_key&lt;/code&gt; or &lt;code&gt;to_param&lt;/code&gt;. You can implement the &lt;code&gt;cache_key&lt;/code&gt; method on your classes if you need to generate custom keys. Active Record will generate keys based on the class name and record id.</source>
          <target state="translated">캐시에 사용 된 키는 &lt;code&gt;cache_key&lt;/code&gt; 또는 &lt;code&gt;to_param&lt;/code&gt; 에 응답하는 모든 객체 일 수 있습니다 . 사용자 정의 키를 생성해야하는 경우 클래스 에서 &lt;code&gt;cache_key&lt;/code&gt; 메소드를 구현할 수 있습니다 . 활성 레코드는 클래스 이름과 레코드 ID를 기반으로 키를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f7776f2c4b88c4d6b494aa2092d34ebd03edd32c" translate="yes" xml:space="preserve">
          <source>The keys you use on &lt;code&gt;Rails.cache&lt;/code&gt; will not be the same as those actually used with the storage engine. They may be modified with a namespace or altered to fit technology backend constraints. This means, for instance, that you can't save values with &lt;code&gt;Rails.cache&lt;/code&gt; and then try to pull them out with the &lt;code&gt;dalli&lt;/code&gt; gem. However, you also don't need to worry about exceeding the memcached size limit or violating syntax rules.</source>
          <target state="translated">&lt;code&gt;Rails.cache&lt;/code&gt; 에서 사용하는 키 는 실제로 스토리지 엔진에 사용되는 키와 동일하지 않습니다. 네임 스페이스로 수정하거나 기술 백엔드 제약 조건에 맞게 변경할 수 있습니다. 예를 들어 &lt;code&gt;Rails.cache&lt;/code&gt; 로 값을 저장 하고 &lt;code&gt;dalli&lt;/code&gt; gem을 사용하여 값 을 가져올 수 없음을 의미합니다 . 그러나 memcached 크기 제한을 초과하거나 구문 규칙을 위반하는 것에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="9a7613a9e24c1242511419e1adb78550681bc52d" translate="yes" xml:space="preserve">
          <source>The keyword arguments :from and :to can be given to specify the expected initial value and the expected value after the block was executed.</source>
          <target state="translated">키워드 인수 : from 및 : to는 블록이 실행 된 후 예상 초기 값과 예상 값을 지정하도록 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3349b4c7e79a27feec027e09eaaf6fe241addad" translate="yes" xml:space="preserve">
          <source>The label of the current fixture is always available as a column value:</source>
          <target state="translated">현재 조명기의 레이블은 항상 열 값으로 사용 가능합니다 :</target>
        </trans-unit>
        <trans-unit id="5a7bea3f7592b166f30ea2c09e8e9abb723ec914" translate="yes" xml:space="preserve">
          <source>The last characters will be replaced with the &lt;code&gt;:omission&lt;/code&gt; string (defaults to &amp;ldquo;&amp;hellip;&amp;rdquo;) for a total length not exceeding &lt;code&gt;length&lt;/code&gt;:</source>
          <target state="translated">마지막 문자는 대체됩니다 &lt;code&gt;:omission&lt;/code&gt; 초과하지 않는 총 길이 문자열 (디폴트는 &quot;...&quot;) &lt;code&gt;length&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5104bffaf01d4231666775a1d668f8d8ffd8c52" translate="yes" xml:space="preserve">
          <source>The last characters will be replaced with the &lt;code&gt;:omission&lt;/code&gt; string (defaults to &amp;ldquo;&amp;hellip;&amp;rdquo;):</source>
          <target state="translated">마지막 문자는 &lt;code&gt;:omission&lt;/code&gt; 문자열 로 대체됩니다 (기본값은&amp;ldquo;&amp;hellip;&amp;rdquo;).</target>
        </trans-unit>
        <trans-unit id="5b1fbe78e9957e7cf09f70c95db9866dfc8c504c" translate="yes" xml:space="preserve">
          <source>The last line ought to save the through record (a &lt;code&gt;Tagging&lt;/code&gt;). This will only work if the &lt;code&gt;:inverse_of&lt;/code&gt; is set:</source>
          <target state="translated">마지막 줄은 통과 기록 ( &lt;code&gt;Tagging&lt;/code&gt; ) 을 저장해야합니다 . &lt;code&gt;:inverse_of&lt;/code&gt; 가 설정된 경우에만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="67a572e784d49a5e26efa0baf5210771e08bc0d2" translate="yes" xml:space="preserve">
          <source>The last point is easily explained with some enumerables:</source>
          <target state="translated">마지막 요점은 몇 가지 열거 형으로 쉽게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6bf06164b55dbf97e284223c0efd4152256ea1e6" translate="yes" xml:space="preserve">
          <source>The last point is particularly worth comparing for some enumerables:</source>
          <target state="translated">마지막 요점은 일부 열거 형을 비교할 때 특히 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c184c4cc81fa679b5807f802db648819174c0a80" translate="yes" xml:space="preserve">
          <source>The last three methods are required in your object for &lt;code&gt;Errors&lt;/code&gt; to be able to generate error messages correctly and also handle multiple languages. Of course, if you extend your object with &lt;code&gt;ActiveModel::Translation&lt;/code&gt; you will not need to implement the last two. Likewise, using &lt;code&gt;ActiveModel::Validations&lt;/code&gt; will handle the validation related methods for you.</source>
          <target state="translated">&lt;code&gt;Errors&lt;/code&gt; 가 오류 메시지를 올바르게 생성하고 여러 언어를 처리하려면 개체에 마지막 세 가지 방법이 필요 합니다. 물론 &lt;code&gt;ActiveModel::Translation&lt;/code&gt; 을 사용하여 개체를 확장 하면 마지막 두 개를 구현할 필요가 없습니다. 마찬가지로 &lt;code&gt;ActiveModel::Validations&lt;/code&gt; 를 사용하면 유효성 검사 관련 메서드를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="01d4583e92db9c0607227e88af967aeb5072f75c" translate="yes" xml:space="preserve">
          <source>The latter is a shortcut for:</source>
          <target state="translated">후자는 다음에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="d60eb064146a6c7d8808535fb46ffe1d06c0ef35" translate="yes" xml:space="preserve">
          <source>The layout will be rendered together with the partial for each item in the collection. The current object and object_counter variables will be available in the layout as well, the same way they are within the partial.</source>
          <target state="translated">레이아웃은 컬렉션의 각 항목에 대한 부분과 함께 렌더링됩니다. 현재 object 및 object_counter 변수는 부분 내에서와 같은 방식으로 레이아웃에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f284415c6d146c7afcb0672e6e0f0abf85ffd823" translate="yes" xml:space="preserve">
          <source>The library as a whole can be accessed in the application manifest like so:</source>
          <target state="translated">다음과 같이 애플리케이션 매니페스트에서 라이브러리 전체에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba58133a93884c30ef1d3cc05d18c16fa410026" translate="yes" xml:space="preserve">
          <source>The life cycle of Active Record objects.</source>
          <target state="translated">활성 레코드 개체의 수명주기</target>
        </trans-unit>
        <trans-unit id="92a217a341fa19e51932070fc99d9da0f3f4d7cb" translate="yes" xml:space="preserve">
          <source>The link looks innocent to visitors, but when it's clicked, it will execute the JavaScript function &quot;exploit_code&quot; or any other JavaScript the attacker provides.</source>
          <target state="translated">링크는 방문자에게 무해한 것으로 보이지만 클릭하면 JavaScript 기능 &quot;exploit_code&quot;또는 공격자가 제공하는 다른 JavaScript가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="140864c4a27c61fd406b6f614287fbce60f18f97" translate="yes" xml:space="preserve">
          <source>The list of columns names the model should ignore. Ignored columns won't have attribute accessors defined, and won't be referenced in SQL queries.</source>
          <target state="translated">모델이 무시해야하는 열 이름 목록입니다. 무시 된 열에는 속성 접근자가 정의되어 있지 않으며 SQL 쿼리에서 참조되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e01fcb5edebcaa447ba52d13d4044f5a0666630b" translate="yes" xml:space="preserve">
          <source>The load path must be specified before any translations are looked up. To change the default locale from an initializer instead of &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">변환을 조회하기 전에로드 경로를 지정해야합니다. &lt;code&gt;config/application.rb&lt;/code&gt; 대신 초기화 프로그램 에서 기본 로케일을 변경하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="b91abe0a3bab1667a08a85ecc6e8da70adbd94e0" translate="yes" xml:space="preserve">
          <source>The local variables passed to sub templates can be accessed as a hash using the &lt;code&gt;local_assigns&lt;/code&gt; hash. This lets you access the variables as:</source>
          <target state="translated">하위 템플릿에 전달 된 로컬 변수는 &lt;code&gt;local_assigns&lt;/code&gt; 해시를 사용하여 해시로 액세스 할 수 있습니다 . 이를 통해 다음과 같이 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2dceed55b6b0e02bd26ebf3baea2208a19abe67" translate="yes" xml:space="preserve">
          <source>The locale can be either set pseudo-globally to &lt;code&gt;I18n.locale&lt;/code&gt; (which uses &lt;code&gt;Thread.current&lt;/code&gt; like, e.g., &lt;code&gt;Time.zone&lt;/code&gt;) or can be passed as an option to &lt;code&gt;#translate&lt;/code&gt; and &lt;code&gt;#localize&lt;/code&gt;.</source>
          <target state="translated">로케일은 의사 전역으로 &lt;code&gt;I18n.locale&lt;/code&gt; ( 예 : &lt;code&gt;Time.zone&lt;/code&gt; 과 같은 &lt;code&gt;Thread.current&lt;/code&gt; 사용 )으로 설정하거나 &lt;code&gt;#translate&lt;/code&gt; 및 &lt;code&gt;#localize&lt;/code&gt; 옵션으로 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="413c8092d1383ea347a5974fbaadfa780f3120e9" translate="yes" xml:space="preserve">
          <source>The locale can be set in an &lt;code&gt;around_action&lt;/code&gt; in the &lt;code&gt;ApplicationController&lt;/code&gt;:</source>
          <target state="translated">로케일은 &lt;code&gt;ApplicationController&lt;/code&gt; 의 &lt;code&gt;around_action&lt;/code&gt; 에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="daf31176920b1d84600a05b4b96e3cdf806b6a98" translate="yes" xml:space="preserve">
          <source>The locale can be set using one of many different approaches.</source>
          <target state="translated">로케일은 다양한 방법 중 하나를 사용하여 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dacee22f44c5ce441593543b2c1e7a3944349db1" translate="yes" xml:space="preserve">
          <source>The locale is an &lt;em&gt;obvious&lt;/em&gt; part of the URL.</source>
          <target state="translated">로케일은 URL 의 &lt;em&gt;명백한&lt;/em&gt; 부분입니다.</target>
        </trans-unit>
        <trans-unit id="7cbd4a2a8191fc3188f26e69e32667e5d3e6d197" translate="yes" xml:space="preserve">
          <source>The log files on &lt;a href=&quot;http://www.attacker.com&quot;&gt;www.attacker.com&lt;/a&gt; will read like this:</source>
          <target state="translated">&lt;a href=&quot;http://www.attacker.com&quot;&gt;www.attacker.com&lt;/a&gt; 의 로그 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cc00365603b4266cf1c98299376d51ed6a9302f8" translate="yes" xml:space="preserve">
          <source>The lookup in this case for test_unit as input is:</source>
          <target state="translated">이 경우 입력으로 test_unit에 대한 조회는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc77ccb96283466ad3dd5c3db6e697992a0f4424" translate="yes" xml:space="preserve">
          <source>The lookup order for an &lt;code&gt;admin/products#index&lt;/code&gt; action will be:</source>
          <target state="translated">&lt;code&gt;admin/products#index&lt;/code&gt; 작업 의 조회 순서 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="89708913768e17e0f4e9ebf21fe3c90dedbbdee1" translate="yes" xml:space="preserve">
          <source>The loop is set up using regular embedding tags (&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;) and the name is inserted using the output embedding tags (&lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt;). Note that this is not just a usage suggestion: regular output functions such as &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;puts&lt;/code&gt; won't be rendered to the view with ERB templates. So this would be wrong:</source>
          <target state="translated">루프는 일반 임베드 태그 ( &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; )를 사용하여 설정되고 이름은 출력 임베드 태그 ( &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; )를 사용하여 삽입됩니다 . 이것은 사용법 제안이 아니라 &lt;code&gt;print&lt;/code&gt; 및 &lt;code&gt;puts&lt;/code&gt; 와 같은 일반 출력 함수 는 ERB 템플릿을 사용하여 뷰에 렌더링되지 않습니다. 따라서 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc30761df747a5ac678de0e1485ab435952394e1" translate="yes" xml:space="preserve">
          <source>The loop is setup in regular embedding tags &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;, and the name is written using the output embedding tag &lt;code&gt;&amp;lt;%=
%&amp;gt;&lt;/code&gt;. Note that this is not just a usage suggestion. Regular output functions like print or puts won't work with ERB templates. So this would be wrong:</source>
          <target state="translated">루프는 일반 임베드 태그 &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; 에 설정되며 이름은 출력 임베드 태그 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 사용하여 작성됩니다 . 이것은 단지 사용 제안이 아닙니다. 인쇄 또는 넣기와 같은 일반 출력 기능은 ERB 템플릿에서 작동하지 않습니다. 따라서 이것은 잘못된 것입니다.</target>
        </trans-unit>
        <trans-unit id="4782d45cb3bff384195fc3fa74f6ae6e493a63ea" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;attr_internal&lt;/code&gt; is a synonym for &lt;code&gt;attr_internal_accessor&lt;/code&gt;:</source>
          <target state="translated">매크로 &lt;code&gt;attr_internal&lt;/code&gt; 는 동의어입니다 &lt;code&gt;attr_internal_accessor&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a2f7c6d14cf5071e8ad6bb4bd27649a2b165b18f" translate="yes" xml:space="preserve">
          <source>The macro &lt;code&gt;delegate&lt;/code&gt; offers an easy way to forward methods.</source>
          <target state="translated">매크로 &lt;code&gt;delegate&lt;/code&gt; 는 메서드를 전달하는 쉬운 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="415498318beba7b40f9b5611af8461964ca6a83e" translate="yes" xml:space="preserve">
          <source>The macro receives one or more method names (specified as symbols or strings) and the name of the target object via the &lt;code&gt;:to&lt;/code&gt; option (also a symbol or string).</source>
          <target state="translated">매크로는 &lt;code&gt;:to&lt;/code&gt; 옵션 (기호 또는 문자열) 을 통해 하나 이상의 메소드 이름 (기호 또는 문자열로 지정됨)과 대상 객체의 이름을 받습니다.</target>
        </trans-unit>
        <trans-unit id="60baf372c6c437b91d26d4adf2d9c721e5ed9c08" translate="yes" xml:space="preserve">
          <source>The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in a single line. For example, you could send metrics for every job enqueued:</source>
          <target state="translated">매크로 스타일 클래스 메서드는 블록을받을 수도 있습니다. 블록 내부의 코드가 너무 짧아 한 줄에 들어가는 경우이 스타일을 사용하십시오. 예를 들어, 대기중인 모든 작업에 대한 메트릭을 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae8d13b0e4b30afca687a27a2a6bcee77b82e1f5" translate="yes" xml:space="preserve">
          <source>The macro-style class methods can also receive a block. Consider using this style if the code inside your block is so short that it fits in a single line:</source>
          <target state="translated">매크로 스타일 클래스 메서드는 블록을받을 수도 있습니다. 블록 내부의 코드가 너무 짧아 한 줄에 들어가는 경우이 스타일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7bf8a2a68d5bb7d9bdce0e3db1b7396a5f8c4dbe" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;cattr_reader&lt;/code&gt;, &lt;code&gt;cattr_writer&lt;/code&gt;, and &lt;code&gt;cattr_accessor&lt;/code&gt; are analogous to their &lt;code&gt;attr_*&lt;/code&gt; counterparts but for classes. They initialize a class variable to &lt;code&gt;nil&lt;/code&gt; unless it already exists, and generate the corresponding class methods to access it:</source>
          <target state="translated">&lt;code&gt;cattr_reader&lt;/code&gt; , &lt;code&gt;cattr_writer&lt;/code&gt; 및 &lt;code&gt;cattr_accessor&lt;/code&gt; 매크로 는 &lt;code&gt;attr_*&lt;/code&gt; 와 유사하지만 클래스 용입니다. 클래스 변수가 존재하지 않는 한 클래스 변수를 &lt;code&gt;nil&lt;/code&gt; 로 초기화 하고 해당 클래스 메소드를 생성하여 액세스합니다.</target>
        </trans-unit>
        <trans-unit id="75c1b4fe1ccf8d7f2c382dea52c838eafc63998f" translate="yes" xml:space="preserve">
          <source>The macros &lt;code&gt;mattr_reader&lt;/code&gt;, &lt;code&gt;mattr_writer&lt;/code&gt;, and &lt;code&gt;mattr_accessor&lt;/code&gt; are the same as the &lt;code&gt;cattr_*&lt;/code&gt; macros defined for class. In fact, the &lt;code&gt;cattr_*&lt;/code&gt; macros are just aliases for the &lt;code&gt;mattr_*&lt;/code&gt; macros. Check &lt;a href=&quot;#class-attributes&quot;&gt;Class Attributes&lt;/a&gt;.</source>
          <target state="translated">매크로는 &lt;code&gt;mattr_reader&lt;/code&gt; , &lt;code&gt;mattr_writer&lt;/code&gt; 을 하고 &lt;code&gt;mattr_accessor&lt;/code&gt; 과 동일 &lt;code&gt;cattr_*&lt;/code&gt; 매크로는 클래스에 대해 정의. 실제로 &lt;code&gt;cattr_*&lt;/code&gt; 매크로는 mattr_ * 매크로의 별명 &lt;code&gt;mattr_*&lt;/code&gt; 입니다. &lt;a href=&quot;#class-attributes&quot;&gt;클래스 속성&lt;/a&gt; 확인 .</target>
        </trans-unit>
        <trans-unit id="58b4dccf4abf64be6b0a0ec46a36c74305dc1844" translate="yes" xml:space="preserve">
          <source>The main body of the view will always render into the unnamed &lt;code&gt;yield&lt;/code&gt;. To render content into a named &lt;code&gt;yield&lt;/code&gt;, you use the &lt;code&gt;content_for&lt;/code&gt; method.</source>
          <target state="translated">뷰의 본체는 항상 명명되지 않은 &lt;code&gt;yield&lt;/code&gt; 로 렌더링됩니다 . 컨텐츠를 이름 지정된 &lt;code&gt;yield&lt;/code&gt; 로 렌더링하려면 &lt;code&gt;content_for&lt;/code&gt; 메소드 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="79f6a395f84dfa52f266c952a76eb19193188b76" translate="yes" xml:space="preserve">
          <source>The main form helper is &lt;code&gt;form_with&lt;/code&gt;.</source>
          <target state="translated">기본 폼 헬퍼는 &lt;code&gt;form_with&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7fc515176450fdd7cbfab7c1b8954dc09f9c2dce" translate="yes" xml:space="preserve">
          <source>The main method that creates the message and renders the email templates. There are two ways to call this method, with a block, or without a block.</source>
          <target state="translated">메시지를 작성하고 이메일 템플리트를 렌더링하는 기본 방법입니다. 블록을 사용하거나 사용하지 않고이 메소드를 호출하는 방법에는 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="495929d2ad1e03b5a3e61a6dfafb4d72fa178b9c" translate="yes" xml:space="preserve">
          <source>The main methods to call are &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, &lt;code&gt;exist?&lt;/code&gt;, and &lt;code&gt;fetch&lt;/code&gt;. The fetch method takes a block and will either return an existing value from the cache, or evaluate the block and write the result to the cache if no value exists.</source>
          <target state="translated">호출 할 주요 메소드는 &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 이며 &lt;code&gt;exist?&lt;/code&gt; , &lt;code&gt;fetch&lt;/code&gt; . fetch 메서드는 블록을 가져 와서 캐시에서 기존 값을 반환하거나 값이 없으면 블록을 평가하여 결과를 캐시에 씁니다.</target>
        </trans-unit>
        <trans-unit id="14c39f5026611e3921bac887dbcc489606e1d7f4" translate="yes" xml:space="preserve">
          <source>The main objective of most attackers is to make money. The underground prices for stolen bank login accounts range from 0.5%-10% of account balance, $0.5-$30 for credit card numbers ($20-$60 with full details), $0.1-$1.5 for identities (Name, SSN &amp;amp; DOB), $20-$50 for retailer accounts, and $6-$10 for cloud service provider accounts, according to the &lt;a href=&quot;https://www.symantec.com/content/dam/symantec/docs/reports/istr-22-2017-en.pdf&quot;&gt;Symantec Internet Security Threat Report (2017)&lt;/a&gt;.</source>
          <target state="translated">대부분의 공격자의 주요 목표는 돈을 버는 것입니다. 도난당한 은행 로그인 계정의 지하 가격은 계좌 잔고의 0.5 % -10 %, 신용 카드 번호는 $ 0.5- $ 30 (자세한 내용은 $ 20- $ 60), 신원은 $ 0.1- $ 1.5 (이름, SSN &amp;amp; DOB), $ 20- &lt;a href=&quot;https://www.symantec.com/content/dam/symantec/docs/reports/istr-22-2017-en.pdf&quot;&gt;Symantec Internet Security Threat Report (2017)&lt;/a&gt; 에 따르면 소매 업체 계정은 $ 50, 클라우드 서비스 제공 업체 계정은 $ 6- $ 10입니다 .</target>
        </trans-unit>
        <trans-unit id="21599ae78681ea4faf08ff08a657288956a915b6" translate="yes" xml:space="preserve">
          <source>The main point is to ensure that all Rails apps will have a job infrastructure in place. We can then have framework features and other gems build on top of that, without having to worry about API differences between various job runners such as Delayed Job and Resque. Picking your queuing backend becomes more of an operational concern, then. And you'll be able to switch between them without having to rewrite your jobs.</source>
          <target state="translated">요점은 모든 Rails 앱이 작업 인프라를 갖추도록하는 것입니다. 그런 다음 Delayed Job 및 Resque와 같은 다양한 작업 러너 간의 API 차이점에 대해 걱정할 필요없이 프레임 워크 기능 및 기타 gem을 빌드 할 수 있습니다. 그러면 큐 백엔드를 선택하는 것이 운영상의 문제가됩니다. 또한 작업을 다시 작성하지 않고도 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="71619b344378d256ebf3fdb56f4d5efbf0440f8d" translate="yes" xml:space="preserve">
          <source>The main purpose of Rails' migration feature is to issue commands that modify the schema using a consistent process. Migrations can also be used to add or modify data. This is useful in an existing database that can't be destroyed and recreated, such as a production database.</source>
          <target state="translated">Rails의 마이그레이션 기능의 주요 목적은 일관된 프로세스를 사용하여 스키마를 수정하는 명령을 실행하는 것입니다. 마이그레이션을 사용하여 데이터를 추가하거나 수정할 수도 있습니다. 프로덕션 데이터베이스와 같이 파괴하거나 다시 만들 수없는 기존 데이터베이스에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9f79a2a93cfc18ecc7090835c969528751a32baa" translate="yes" xml:space="preserve">
          <source>The matcher (and other members of the precompile array; see below) is applied to final compiled file names. This means anything that compiles to JS/CSS is excluded, as well as raw JS/CSS files; for example, &lt;code&gt;.coffee&lt;/code&gt; and &lt;code&gt;.scss&lt;/code&gt; files are &lt;strong&gt;not&lt;/strong&gt; automatically included as they compile to JS/CSS.</source>
          <target state="translated">매처 (및 프리 컴파일 배열의 다른 멤버, 아래 참조)는 최종 컴파일 된 파일 이름에 적용됩니다. 이는 원시 JS / CSS 파일뿐만 아니라 JS / CSS로 컴파일되는 모든 것이 제외됨을 의미합니다. 예를 들어 &lt;code&gt;.coffee&lt;/code&gt; 및 &lt;code&gt;.scss&lt;/code&gt; 파일은 JS / CSS로 컴파일 할 때 자동으로 포함 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5a5326dc8382eb380da680fd49ebf42711f48794" translate="yes" xml:space="preserve">
          <source>The maximum length of a password is 72 (required by &lt;code&gt;bcrypt&lt;/code&gt; on which ActiveModel::SecurePassword depends)</source>
          <target state="translated">암호의 최대 길이는 72입니다 ( ActiveModel :: SecurePassword가 의존하는 &lt;code&gt;bcrypt&lt;/code&gt; 에 필요 ).</target>
        </trans-unit>
        <trans-unit id="efc00f941fcc8767657069623c7b30577861e458" translate="yes" xml:space="preserve">
          <source>The message identifies which template is missing. In this case, it's the &lt;code&gt;articles/new&lt;/code&gt; template. Rails will first look for this template. If not found, then it will attempt to load a template called &lt;code&gt;application/new&lt;/code&gt;, because the &lt;code&gt;ArticlesController&lt;/code&gt; inherits from &lt;code&gt;ApplicationController&lt;/code&gt;.</source>
          <target state="translated">이 메시지는 누락 된 템플릿을 식별합니다. 이 경우 &lt;code&gt;articles/new&lt;/code&gt; 템플릿입니다. Rails는 먼저이 템플릿을 찾습니다. 찾을 수없는 경우 &lt;code&gt;ArticlesController&lt;/code&gt; 는 &lt;code&gt;ApplicationController&lt;/code&gt; 에서 상속 하므로 &lt;code&gt;application/new&lt;/code&gt; 라는 템플리트를로드하려고 시도합니다 .</target>
        </trans-unit>
        <trans-unit id="687ac77baf1c88b97b2fe37f68e7a236164e70b0" translate="yes" xml:space="preserve">
          <source>The message is signed with the &lt;code&gt;MessageVerifier&lt;/code&gt;'s secret. Without knowing the secret, the original value cannot be extracted from the message.</source>
          <target state="translated">메시지는 &lt;code&gt;MessageVerifier&lt;/code&gt; 의 비밀로 서명됩니다 . 비밀을 모르면 메시지에서 원래 값을 추출 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="093a0fd1eecb6d23d318f6fc14f9ed0c2e8da44c" translate="yes" xml:space="preserve">
          <source>The messages are available in the @logger instance, which is a logger with limited powers (it actually does not send anything to your output), and you can collect them doing @logger.logged(level), where level is the level used in logging, like info, debug, warn and so on.</source>
          <target state="translated">@logger 인스턴스에서 메시지를 사용할 수 있습니다.이 기능은 전력이 제한된 로거 (실제로는 출력으로 아무것도 보내지 않습니다)이며 @ logger.logged (level)를 사용하여 수집 할 수 있습니다. 여기서 level은 정보, 디버그, 경고 등과 같은 로깅.</target>
        </trans-unit>
        <trans-unit id="e32772287becf00004ac3c06bca75256d6389810" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Array#deep_dup&lt;/code&gt; duplicates itself and all objects inside recursively with Active Support method &lt;code&gt;Object#deep_dup&lt;/code&gt;. It works like &lt;code&gt;Array#map&lt;/code&gt; with sending &lt;code&gt;deep_dup&lt;/code&gt; method to each object inside.</source>
          <target state="translated">&lt;code&gt;Array#deep_dup&lt;/code&gt; 메소드 는 Active Support 메소드 &lt;code&gt;Object#deep_dup&lt;/code&gt; 을 사용 하여 자신과 내부의 모든 오브젝트를 재귀 적으로 복제합니다 . 그것은 내부의 각 객체에 &lt;code&gt;deep_dup&lt;/code&gt; 메소드를 보내는 &lt;code&gt;Array#map&lt;/code&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="c1e33e74fb4fd7f607ac4ec9c062ba47e1d98a83" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Array.wrap&lt;/code&gt; wraps its argument in an array unless it is already an array (or array-like).</source>
          <target state="translated">&lt;code&gt;Array.wrap&lt;/code&gt; 메소드 는 이미 배열 (또는 배열 유사)이 아닌 한 인수를 배열로 랩핑합니다.</target>
        </trans-unit>
        <trans-unit id="d6b82f431ad6d4eddf847396d46b04b6fd616ec1" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Hash#deep_dup&lt;/code&gt; duplicates itself and all keys and values inside recursively with Active Support method &lt;code&gt;Object#deep_dup&lt;/code&gt;. It works like &lt;code&gt;Enumerator#each_with_object&lt;/code&gt; with sending &lt;code&gt;deep_dup&lt;/code&gt; method to each pair inside.</source>
          <target state="translated">&lt;code&gt;Hash#deep_dup&lt;/code&gt; 메소드 는 Active Support 메소드 &lt;code&gt;Object#deep_dup&lt;/code&gt; 을 사용하여 자체 및 모든 키와 값을 재귀 적으로 복제합니다 . 그것은 각 쌍에 &lt;code&gt;deep_dup&lt;/code&gt; 메소드를 보내는 &lt;code&gt;Enumerator#each_with_object&lt;/code&gt; each_with_object 와 같이 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="7de965296f37e83a90fa8fad4aeb58775b5f8602" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Hash#to_query&lt;/code&gt; accepts an optional namespace for the keys:</source>
          <target state="translated">&lt;code&gt;Hash#to_query&lt;/code&gt; 메소드 는 키에 대한 선택적 네임 스페이스를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d0eeaa0bdef1015a3d295e8021c903df196a0661" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;Range#overlaps?&lt;/code&gt; says whether any two given ranges have non-void intersection:</source>
          <target state="translated">&lt;code&gt;Range#overlaps?&lt;/code&gt; 방법 ? 주어진 두 범위에 비 공백 교차가 있는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2179f3488c189a7d1b1ae889f5df7a90d0add093" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;acts_like?&lt;/code&gt; provides a way to check whether some class acts like some other class based on a simple convention: a class that provides the same interface as &lt;code&gt;String&lt;/code&gt; defines</source>
          <target state="translated">방법 &lt;code&gt;acts_like?&lt;/code&gt; 같은 인터페이스를 제공하는 클래스 : 일부 클래스는 간단한 규칙에 따라 다른 클래스처럼 작동 여부를 확인하는 방법을 제공 &lt;code&gt;String&lt;/code&gt; 을 정의를</target>
        </trans-unit>
        <trans-unit id="3f8c125e2741bd24b350323c120868d16ec18dbf" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;advance&lt;/code&gt; advances first one month, and then one day, the result is:</source>
          <target state="translated">방법의 &lt;code&gt;advance&lt;/code&gt; 첫 달을 진행하고, 어느 날의 결과이다 :</target>
        </trans-unit>
        <trans-unit id="552f54883f3f33b594f06d41ba5b2220bba8453d" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ago&lt;/code&gt; receives a number of seconds as argument and returns a timestamp those many seconds ago from midnight:</source>
          <target state="translated">이 방법은 &lt;code&gt;ago&lt;/code&gt; 인수로 (초)을 받고 자정부터 그 많은 초 전 타임 스탬프를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="8f2e4acf7ddddd85645952fc4aa279e137c99b5a" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;all_day&lt;/code&gt; returns a range representing the whole day of the current time.</source>
          <target state="translated">&lt;code&gt;all_day&lt;/code&gt; 메소드 는 현재 시간의 하루 전체를 나타내는 범위를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="541b5c428abe6077b2427df44c06151cabbe2505" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;assert_valid_keys&lt;/code&gt; receives an arbitrary number of arguments, and checks whether the receiver has any key outside that white list. If it does &lt;code&gt;ArgumentError&lt;/code&gt; is raised.</source>
          <target state="translated">&lt;code&gt;assert_valid_keys&lt;/code&gt; 메소드 는 임의의 수의 인수를 수신하고 수신자가 해당 화이트리스트 외부에 키가 있는지 확인합니다. 만약 그렇다면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="91964bd2587b244f8090ac94f24f6de56fc458e7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;beginning_of_day&lt;/code&gt; returns a timestamp at the beginning of the day (00:00:00):</source>
          <target state="translated">메소드 &lt;code&gt;beginning_of_day&lt;/code&gt; 는 하루 (0시 0분 0초)의 시작 부분에 타임 스탬프를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="e085bbffe1ea485f880a3af6f70c393c243f7720" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;beginning_of_hour&lt;/code&gt; returns a timestamp at the beginning of the hour (hh:00:00):</source>
          <target state="translated">메소드 &lt;code&gt;beginning_of_hour&lt;/code&gt; 는 시간 (: 00 : 00 HH)의 시작 부분에 타임 스탬프를 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="f577d04c9de8bcd3e4d8ba5950192cbedbcd4c33" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;beginning_of_minute&lt;/code&gt; returns a timestamp at the beginning of the minute (hh:mm:00):</source>
          <target state="translated">메소드 &lt;code&gt;beginning_of_minute&lt;/code&gt; 은 분 (: mm : 00 HH)의 시작시에 타임 스탬프를 반환</target>
        </trans-unit>
        <trans-unit id="c36a6bddcb246413376decd5b3e385ac52a3c55d" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;camelize&lt;/code&gt; returns its receiver in camel case:</source>
          <target state="translated">&lt;code&gt;camelize&lt;/code&gt; 메소드 는 낙타의 경우 수신자를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="50d58e637eefa0c2f54a8097a5a26358508ed881" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;change&lt;/code&gt; allows you to get a new date which is the same as the receiver except for the given year, month, or day:</source>
          <target state="translated">메소드 &lt;code&gt;change&lt;/code&gt; 통해 주어진 연도, 월 또는 일을 제외하고 수신자와 동일한 새 날짜를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c1693ffe243f5ff35dd83e523a87b2b0e6b7ce09" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;change&lt;/code&gt; allows you to get a new datetime which is the same as the receiver except for the given options, which may include &lt;code&gt;:year&lt;/code&gt;, &lt;code&gt;:month&lt;/code&gt;, &lt;code&gt;:day&lt;/code&gt;, &lt;code&gt;:hour&lt;/code&gt;, &lt;code&gt;:min&lt;/code&gt;, &lt;code&gt;:sec&lt;/code&gt;, &lt;code&gt;:offset&lt;/code&gt;, &lt;code&gt;:start&lt;/code&gt;:</source>
          <target state="translated">메소드 &lt;code&gt;change&lt;/code&gt; 사용하면 주어진 옵션을 제외하고 수신자와 동일한 새 날짜 시간을 얻을 수 있습니다 &lt;code&gt;:year&lt;/code&gt; 여기에는 : year , &lt;code&gt;:month&lt;/code&gt; , &lt;code&gt;:day&lt;/code&gt; , &lt;code&gt;:hour&lt;/code&gt; , &lt;code&gt;:min&lt;/code&gt; , &lt;code&gt;:sec&lt;/code&gt; , &lt;code&gt;:offset&lt;/code&gt; , &lt;code&gt;:start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c90aa7f827d4f56fea49a7ae34641b299c94c4bd" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;class_attribute&lt;/code&gt; declares one or more inheritable class attributes that can be overridden at any level down the hierarchy.</source>
          <target state="translated">&lt;code&gt;class_attribute&lt;/code&gt; 메소드 는 계층의 모든 레벨에서 재정의 할 수있는 하나 이상의 상속 가능한 클래스 속성을 선언합니다.</target>
        </trans-unit>
        <trans-unit id="c9e96da64b1b8279c4e0994f0fb0a8adae7dac72" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;classify&lt;/code&gt; is the inverse of &lt;code&gt;tableize&lt;/code&gt;. It gives you the class name corresponding to a table name:</source>
          <target state="translated">&lt;code&gt;classify&lt;/code&gt; 메소드 는 &lt;code&gt;tableize&lt;/code&gt; 의 반대입니다 . 테이블 이름에 해당하는 클래스 이름을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="078c50f28bde0d9e8cd63a6c910aaaf2320cfc2f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;constantize&lt;/code&gt; resolves the constant reference expression in its receiver:</source>
          <target state="translated">&lt;code&gt;constantize&lt;/code&gt; 메소드 는 수신자의 상수 참조 표현식을 분석합니다.</target>
        </trans-unit>
        <trans-unit id="357988408dbb70c115cb0dfc7514cae03b651c01" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;dasherize&lt;/code&gt; replaces the underscores in the receiver with dashes:</source>
          <target state="translated">&lt;code&gt;dasherize&lt;/code&gt; 메소드 는 수신자의 밑줄을 대시로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="e211c70f6c4329e28772a26b56c394e16d3ce068" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;deep_merge!&lt;/code&gt; performs a deep merge in place.</source>
          <target state="translated">&lt;code&gt;deep_merge!&lt;/code&gt; 메소드 ! 깊은 병합을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="d78f3750e4c5052b90fcbd5bea5e723036a174b5" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;end_of_day&lt;/code&gt; returns a timestamp at the end of the day (23:59:59):</source>
          <target state="translated">&lt;code&gt;end_of_day&lt;/code&gt; 메소드 는 하루가 끝날 때 타임 스탬프를 리턴합니다 (23:59:59).</target>
        </trans-unit>
        <trans-unit id="d46bf9d09c3a7c7fd408440a7e9a40f95118e29f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;end_of_hour&lt;/code&gt; returns a timestamp at the end of the hour (hh:59:59):</source>
          <target state="translated">&lt;code&gt;end_of_hour&lt;/code&gt; 메소드 는 시간 종료시 타임 스탬프를 리턴합니다 (hh : 59 : 59).</target>
        </trans-unit>
        <trans-unit id="de74d561fab3abfbd50e4756cde750b0a3935f48" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;end_of_minute&lt;/code&gt; returns a timestamp at the end of the minute (hh:mm:59):</source>
          <target state="translated">&lt;code&gt;end_of_minute&lt;/code&gt; 메소드 는 분 끝에 타임 스탬프를 리턴합니다 (hh : mm : 59).</target>
        </trans-unit>
        <trans-unit id="0b221ae8dbe130744caad5199d2d97fbc76c565f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;except&lt;/code&gt; returns a hash with the keys in the argument list removed, if present:</source>
          <target state="translated">&lt;code&gt;except&lt;/code&gt; 메소드 는 존재하는 경우 인수 목록의 키가 제거 된 해시를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="aaf6f40b5a5a4af9d91c806cce7c3bbcea4835d2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;extract!&lt;/code&gt; removes and returns the elements for which the block returns a true value. If no block is given, an Enumerator is returned instead.</source>
          <target state="translated">방법 &lt;code&gt;extract!&lt;/code&gt; 블록이 참 값을 반환하는 요소를 제거하고 반환합니다. 블록이 없으면 대신 열거자가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="99ed6b8b4541116327e8d0e7a6633713b0532871" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;extract!&lt;/code&gt; removes and returns the key/value pairs matching the given keys.</source>
          <target state="translated">방법 &lt;code&gt;extract!&lt;/code&gt; 주어진 키와 일치하는 키 / 값 쌍을 제거하고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ea9f782cf4d463d7fa0c6babbe898a4179c215a0" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;extract!&lt;/code&gt; returns the same subclass of Hash, that the receiver is.</source>
          <target state="translated">방법 &lt;code&gt;extract!&lt;/code&gt; 수신자와 동일한 Hash의 서브 클래스를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="2ff5d88d672e86390c7f851883bc096da7e53d01" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;foreign_key&lt;/code&gt; gives a foreign key column name from a class name. To do so it demodulizes, underscores, and adds &quot;_id&quot;:</source>
          <target state="translated">&lt;code&gt;foreign_key&lt;/code&gt; 메소드 는 클래스 이름에서 외부 키 열 이름을 제공합니다. 이를 위해 복조, 밑줄 및 &quot;_id&quot;를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e7a5c875313a703800a91a074d810febde910dd4" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;humanize&lt;/code&gt; tweaks an attribute name for display to end users.</source>
          <target state="translated">&lt;code&gt;humanize&lt;/code&gt; 방법 은 최종 사용자에게 표시 할 속성 이름을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="fb26c0817d6731204de3f5269480a99a26d221bd" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;in_groups&lt;/code&gt; splits an array into a certain number of groups. The method returns an array with the groups:</source>
          <target state="translated">&lt;code&gt;in_groups&lt;/code&gt; 메소드 는 배열을 특정 수의 그룹으로 분할합니다. 이 메소드는 그룹이있는 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bcda912a9181a0c10cda3df95ea77faada8fc3fd" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;in_groups_of&lt;/code&gt; splits an array into consecutive groups of a certain size. It returns an array with the groups:</source>
          <target state="translated">&lt;code&gt;in_groups_of&lt;/code&gt; 메소드 는 배열을 특정 크기의 연속 그룹으로 분할합니다. 그룹이 포함 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="435c8a187b47719a1cd22951879b4182144227d5" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;index_by&lt;/code&gt; generates a hash with the elements of an enumerable indexed by some key.</source>
          <target state="translated">&lt;code&gt;index_by&lt;/code&gt; 메소드 는 일부 키로 색인화 된 열거 가능한 요소로 해시를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="da8b1a27cc1c31e946af6fde23476e92ede82db2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;index_with&lt;/code&gt; generates a hash with the elements of an enumerable as keys. The value is either a passed default or returned in a block.</source>
          <target state="translated">&lt;code&gt;index_with&lt;/code&gt; 메소드 는 열거 가능한 요소를 키로 사용하여 해시를 생성합니다. 값은 전달 된 기본값이거나 블록으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d1f20a3ddef2c375b761522691412f7214b57d0f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;instance_values&lt;/code&gt; returns a hash that maps instance variable names without &quot;@&quot; to their corresponding values. Keys are strings:</source>
          <target state="translated">&lt;code&gt;instance_values&lt;/code&gt; 메소드 는 &quot;@&quot;가없는 인스턴스 변수 이름을 해당 값에 맵핑하는 해시를 리턴합니다. 키는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c321602f17827d8217a980646e121648d496bb1c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;instance_variable_names&lt;/code&gt; returns an array. Each name includes the &quot;@&quot; sign.</source>
          <target state="translated">&lt;code&gt;instance_variable_names&lt;/code&gt; 메소드 는 배열을 리턴합니다. 각 이름에는 &quot;@&quot;기호가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="20ff505780bbd3782af13427c34a1855014975cb" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;many?&lt;/code&gt; is shorthand for &lt;code&gt;collection.size &amp;gt; 1&lt;/code&gt;:</source>
          <target state="translated">방법은 &lt;code&gt;many?&lt;/code&gt; &lt;code&gt;collection.size &amp;gt; 1&lt;/code&gt; 줄임말 :</target>
        </trans-unit>
        <trans-unit id="bb55847e5bf51aa79a7903f73ec506aacf7196a6" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;module_parents&lt;/code&gt; calls &lt;code&gt;module_parent&lt;/code&gt; on the receiver and upwards until &lt;code&gt;Object&lt;/code&gt; is reached. The chain is returned in an array, from bottom to top:</source>
          <target state="translated">메소드 &lt;code&gt;module_parents&lt;/code&gt; 의 호출은 &lt;code&gt;module_parent&lt;/code&gt; 수신기에 위쪽까지 &lt;code&gt;Object&lt;/code&gt; 에 도달. 체인은 아래에서 위로 배열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6089bffe83adf640f1613660fa0462ada9ab1360" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;multiline?&lt;/code&gt; says whether a regexp has the &lt;code&gt;/m&lt;/code&gt; flag set, that is, whether the dot matches newlines.</source>
          <target state="translated">방법은 여러 줄 &lt;code&gt;multiline?&lt;/code&gt; 정규 표현식에 &lt;code&gt;/m&lt;/code&gt; 플래그가 설정되어 있는지, 즉 점이 개행과 일치하는지 여부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b85ea67c1af5da35bcf6a98d0598b5cd5fe12943" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;multiple_of?&lt;/code&gt; tests whether an integer is multiple of the argument:</source>
          <target state="translated">&lt;code&gt;multiple_of?&lt;/code&gt; 방법은 ? 정수가 인수의 배수인지 여부를 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="f15df0993a61ed439f2d1c9e3f00efd157cf7c77" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;next_week&lt;/code&gt; receives a symbol with a day name in English (default is the thread local &lt;code&gt;Date.beginning_of_week&lt;/code&gt;, or &lt;code&gt;config.beginning_of_week&lt;/code&gt;, or &lt;code&gt;:monday&lt;/code&gt;) and it returns the date corresponding to that day.</source>
          <target state="translated">&lt;code&gt;next_week&lt;/code&gt; 메소드 는 영어로 요일 이름이있는 기호를 수신하고 (기본값은 스레드 로컬 &lt;code&gt;Date.beginning_of_week&lt;/code&gt; 또는 &lt;code&gt;config.beginning_of_week&lt;/code&gt; 또는 &lt;code&gt;:monday&lt;/code&gt; ) 해당 날짜에 해당하는 날짜를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="a33b8ded9323df6fd86cb09ff5d011f7e28769a0" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ordinal&lt;/code&gt; returns the ordinal suffix string corresponding to the receiver integer:</source>
          <target state="translated">메소드 &lt;code&gt;ordinal&lt;/code&gt; 는 수신자 정수에 해당하는 서수 접미사 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d1761b81eab5a13ce24b2d3f37ede256550af29c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;ordinalize&lt;/code&gt; returns the ordinal string corresponding to the receiver integer. In comparison, note that the &lt;code&gt;ordinal&lt;/code&gt; method returns &lt;strong&gt;only&lt;/strong&gt; the suffix string.</source>
          <target state="translated">&lt;code&gt;ordinalize&lt;/code&gt; 메소드 는 수신자 정수에 해당하는 서수 문자열을 리턴합니다. 반면에 &lt;code&gt;ordinal&lt;/code&gt; 메서드는 접미사 문자열 &lt;strong&gt;만&lt;/strong&gt; 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="97392ecc57bbe19c9ee47fe2e7e60d101f006c2d" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;parameterize&lt;/code&gt; normalizes its receiver in a way that can be used in pretty URLs.</source>
          <target state="translated">&lt;code&gt;parameterize&lt;/code&gt; 메소드 는 예쁜 URL에서 사용할 수있는 방식으로 수신자를 정규화합니다.</target>
        </trans-unit>
        <trans-unit id="6e7420cd00a473a7a6d8483f9261f0ddfd51a128" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pluck&lt;/code&gt; returns an array based on the given key:</source>
          <target state="translated">&lt;code&gt;pluck&lt;/code&gt; 메소드 는 주어진 키를 기반으로 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ee6516c7f56f1ba0ed077fbc2e7db598686ac08" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;pluralize&lt;/code&gt; returns the plural of its receiver:</source>
          <target state="translated">&lt;code&gt;pluralize&lt;/code&gt; 메소드 는 수신자의 복수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="41bb7c4e58183037bcfd42551f575ed0b14097d0" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;present?&lt;/code&gt; is equivalent to &lt;code&gt;!blank?&lt;/code&gt;. This example is taken from &lt;code&gt;ActionDispatch::Http::Cache::Response&lt;/code&gt;:</source>
          <target state="translated">방법 &lt;code&gt;present?&lt;/code&gt; &lt;code&gt;!blank?&lt;/code&gt; 와 동일 합니까? . 이 예제는 &lt;code&gt;ActionDispatch::Http::Cache::Response&lt;/code&gt; 에서 가져 왔습니다 .</target>
        </trans-unit>
        <trans-unit id="b91d6be6b7e138a340af57a72512784b971a9ee1" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;prev_week&lt;/code&gt; is analogous:</source>
          <target state="translated">&lt;code&gt;prev_week&lt;/code&gt; 메소드 는 유사합니다.</target>
        </trans-unit>
        <trans-unit id="f12cfe07736bb5bbc05da705235c306e033463f5" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;redefine_method&lt;/code&gt; prevents such a potential warning, removing the existing method before if needed.</source>
          <target state="translated">&lt;code&gt;redefine_method&lt;/code&gt; 메소드 는 이러한 잠재적 인 경고를 방지하여 필요한 경우 기존 메소드를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="dd8539a782376af5d21222e2cb75190799a1d16b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;remove&lt;/code&gt; will remove all occurrences of the pattern:</source>
          <target state="translated">메소드 &lt;code&gt;remove&lt;/code&gt; 는 패턴의 모든 항목을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="387ce0f8010addda4cde39eee52ccea1d12762fd" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;reverse_update&lt;/code&gt; is an alias for &lt;code&gt;reverse_merge!&lt;/code&gt;, explained above.</source>
          <target state="translated">&lt;code&gt;reverse_update&lt;/code&gt; 메소드는 reverse_merge 의 별명입니다 &lt;code&gt;reverse_merge!&lt;/code&gt; 위에서 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="ff4b75d9e257aba1e8fc283a1b01585233e460b4" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;seconds_since_midnight&lt;/code&gt; returns the number of seconds since midnight:</source>
          <target state="translated">&lt;code&gt;seconds_since_midnight&lt;/code&gt; 메소드 는 자정 이후의 시간 (초)을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4a0dfce079234958f39d2ac44a20f44086af21e6" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;slice!&lt;/code&gt; replaces the hash with only the given keys and returns a hash containing the removed key/value pairs.</source>
          <target state="translated">방법 &lt;code&gt;slice!&lt;/code&gt; 해시를 지정된 키로 만 교체하고 제거 된 키 / 값 쌍을 포함하는 해시를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="115efaa72ec871de6e14307a19a958b113979000" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;split&lt;/code&gt; divides an array by a separator and returns the resulting chunks.</source>
          <target state="translated">&lt;code&gt;split&lt;/code&gt; 메소드 는 배열을 구분 기호로 나누고 결과 청크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="706387e27a1798aff7654f080c37fe4327344e38" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;squish&lt;/code&gt; strips leading and trailing whitespace, and substitutes runs of whitespace with a single space each:</source>
          <target state="translated">메소드 &lt;code&gt;squish&lt;/code&gt; 스트립 하나의 공간을 각각 공백의 실행을 선도하고 후행 공백 및 대체 :</target>
        </trans-unit>
        <trans-unit id="f0869d8f033f9cae7ed0fb46925e26e58694dd80" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;stringify_keys&lt;/code&gt; returns a hash that has a stringified version of the keys in the receiver. It does so by sending &lt;code&gt;to_s&lt;/code&gt; to them:</source>
          <target state="translated">&lt;code&gt;stringify_keys&lt;/code&gt; 메소드 는 수신자에 문자열 화 된 버전의 키가있는 해시를 리턴합니다. 그들에게 &lt;code&gt;to_s&lt;/code&gt; 를 보내면 됩니다 :</target>
        </trans-unit>
        <trans-unit id="a2a91721cba9308202438adc6d39cc57e1518bfd" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;strip_heredoc&lt;/code&gt; strips indentation in heredocs.</source>
          <target state="translated">&lt;code&gt;strip_heredoc&lt;/code&gt; 메소드는 heredoc 에서 들여 쓰기를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="c0907a71fc4ec4c8ff7e86f4c1da60f559bdf3f6" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;sum&lt;/code&gt; adds the elements of an enumerable:</source>
          <target state="translated">메소드 &lt;code&gt;sum&lt;/code&gt; 는 열거 가능한 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="bcd37680102e0da1447d329b81f3e01b33deeae9" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;symbolize_keys&lt;/code&gt; returns a hash that has a symbolized version of the keys in the receiver, where possible. It does so by sending &lt;code&gt;to_sym&lt;/code&gt; to them:</source>
          <target state="translated">&lt;code&gt;symbolize_keys&lt;/code&gt; 메소드 는 가능한 경우 수신자에 키 버전의 키가있는 해시를 리턴합니다. 그들에게 &lt;code&gt;to_sym&lt;/code&gt; 을 보내면 됩니다 :</target>
        </trans-unit>
        <trans-unit id="bd6b9963429952cd5d8efa1a81a122b83c576304" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;tableize&lt;/code&gt; is &lt;code&gt;underscore&lt;/code&gt; followed by &lt;code&gt;pluralize&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;tableize&lt;/code&gt; 메소드 는 &lt;code&gt;underscore&lt;/code&gt; 뒤에 &lt;code&gt;pluralize&lt;/code&gt; 이옵니다 .</target>
        </trans-unit>
        <trans-unit id="4811f4d445cab7099f3493b7e741d51ccb0dfb69" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;titleize&lt;/code&gt; capitalizes the words in the receiver:</source>
          <target state="translated">메소드 &lt;code&gt;titleize&lt;/code&gt; 는 수신기에있는 단어를 대문자로 :</target>
        </trans-unit>
        <trans-unit id="b25ddab50687e5e7168c2e3221c5982ea48aaa35" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;to_formatted_s&lt;/code&gt; acts like &lt;code&gt;to_s&lt;/code&gt; by default.</source>
          <target state="translated">메소드 &lt;code&gt;to_formatted_s&lt;/code&gt; 이 같은 역할을 &lt;code&gt;to_s&lt;/code&gt; 기본적으로.</target>
        </trans-unit>
        <trans-unit id="2800ff6f2b96de9b72d620a5f58ae1e0841c919b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;to_s&lt;/code&gt; provides a default specifier of &quot;F&quot;. This means that a simple call to &lt;code&gt;to_s&lt;/code&gt; will result in floating point representation instead of engineering notation:</source>
          <target state="translated">메소드 &lt;code&gt;to_s&lt;/code&gt; &quot;F&quot;의 기본 지정자를 제공합니다. 즉, 간단한 &lt;code&gt;to_s&lt;/code&gt; 호출 은 엔지니어링 표기법 대신 부동 소수점 표현을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="b7c050e5958ce1fe8f9c1bab0bac53bdcf120f3c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;to_sentence&lt;/code&gt; turns an array into a string containing a sentence that enumerates its items:</source>
          <target state="translated">&lt;code&gt;to_sentence&lt;/code&gt; 메소드 는 배열을 항목을 열거하는 문장을 포함하는 문자열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="2524a9e324636fcdd082cb9a29ef299c0ddea118" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;to_xml&lt;/code&gt; returns a string containing an XML representation of its receiver:</source>
          <target state="translated">&lt;code&gt;to_xml&lt;/code&gt; 메소드 는 수신자의 XML 표현을 포함하는 문자열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="59c0bc92f01100a9cc031a421d333b37a09ddef7" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;truncate&lt;/code&gt; returns a copy of its receiver truncated after a given &lt;code&gt;length&lt;/code&gt;:</source>
          <target state="translated">메소드 &lt;code&gt;truncate&lt;/code&gt; 는 주어진 &lt;code&gt;length&lt;/code&gt; 후에 잘린 수신자의 사본을 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="b1562a387389afb4f581f9b1a1ebd89caf5ecb3c" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;truncate_words&lt;/code&gt; returns a copy of its receiver truncated after a given number of words:</source>
          <target state="translated">&lt;code&gt;truncate_words&lt;/code&gt; 메소드 는 주어진 단어 수만큼 잘린 수신자의 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="770445ffcdb5e5d9f57ab10d842bffa5bd0051ec" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;underscore&lt;/code&gt; goes the other way around, from camel case to paths:</source>
          <target state="translated">메소드 &lt;code&gt;underscore&lt;/code&gt; 경로에 낙타 케이스에서, 주위에 다른 길을 간다 :</target>
        </trans-unit>
        <trans-unit id="c982543515f1362bd3befc11f73b8e85e6f34c9f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;utc&lt;/code&gt; gives you the same datetime in the receiver expressed in UTC.</source>
          <target state="translated">&lt;code&gt;utc&lt;/code&gt; 메소드 는 UTC로 표시된 수신자에서 동일한 날짜 시간을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3ce902d2fa93d5680d9025389c8b3d49da865a6" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;weeks_ago&lt;/code&gt; works analogously for weeks:</source>
          <target state="translated">&lt;code&gt;weeks_ago&lt;/code&gt; 방법 은 몇 주 동안 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2e30119f0c67cfd57bce9d6914c30134d947806b" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;welcome_email&lt;/code&gt; returns an &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; object which can then just be told &lt;code&gt;deliver_now&lt;/code&gt; or &lt;code&gt;deliver_later&lt;/code&gt; to send itself out. The &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; object is just a wrapper around a &lt;code&gt;Mail::Message&lt;/code&gt;. If you want to inspect, alter, or do anything else with the &lt;code&gt;Mail::Message&lt;/code&gt; object you can access it with the &lt;code&gt;message&lt;/code&gt; method on the &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;welcome_email&lt;/code&gt; 메소드 는 &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; 객체를 반환하는데, 이를 그냥 &lt;code&gt;deliver_now&lt;/code&gt; 또는 &lt;code&gt;deliver_later&lt;/code&gt; 에게 알려 주면 됩니다. &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; 목적은 단지 래퍼입니다 &lt;code&gt;Mail::Message&lt;/code&gt; . &lt;code&gt;Mail::Message&lt;/code&gt; 객체 로 검사, 변경 또는 다른 작업을 수행하려는 경우 &lt;code&gt;ActionMailer::MessageDelivery&lt;/code&gt; 객체 의 &lt;code&gt;message&lt;/code&gt; 메소드를 사용하여 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="143476ef54c29a1ec148780dbea92c40c0a25b4e" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;with_indifferent_access&lt;/code&gt; returns an &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; out of its receiver:</source>
          <target state="translated">&lt;code&gt;with_indifferent_access&lt;/code&gt; 메소드 는 수신기 에서 &lt;code&gt;ActiveSupport::HashWithIndifferentAccess&lt;/code&gt; HashWithIndifferentAccess를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="376cd7ee7cb616a24d413450adee82f6527d2b4f" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;with_options&lt;/code&gt; provides a way to factor out common options in a series of method calls.</source>
          <target state="translated">&lt;code&gt;with_options&lt;/code&gt; 메소드 는 일련의 메소드 호출에서 공통 옵션을 인수 분해 하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d918b0efff2157c8c8e66e095e36340c8d9725bb" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;without&lt;/code&gt; returns a copy of an enumerable with the specified elements removed:</source>
          <target state="translated">&lt;code&gt;without&lt;/code&gt; 메소드 는 지정된 요소가 제거 된 열거 가능한 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="749ed452302f0bfc6da535e793254e8dd6d7ddc2" translate="yes" xml:space="preserve">
          <source>The method &lt;code&gt;years_ago&lt;/code&gt; receives a number of years and returns the same date those many years ago:</source>
          <target state="translated">&lt;code&gt;years_ago&lt;/code&gt; 메소드 는 여러 해를 수신하고 몇 년 전과 동일한 날짜를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="4eaf50f86f012b22cbcfd5d0712981b9b5c8c600" translate="yes" xml:space="preserve">
          <source>The method accepts an optional fourth argument to replace existing &lt;code&gt;NULL&lt;/code&gt;s with some other value. Use that one when enabling the constraint if needed, since otherwise those rows would not be valid.</source>
          <target state="translated">이 메소드는 선택적인 네 번째 인수를 허용하여 기존 &lt;code&gt;NULL&lt;/code&gt; 을 다른 값 으로 대체 합니다. 필요한 경우 제약 조건을 활성화 할 때이 행을 사용하십시오. 그렇지 않으면 해당 행이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72a3e85771e7d5da34d4a62058419ff2db1527a9" translate="yes" xml:space="preserve">
          <source>The method arguments are symbols which correspond to the names of the methods which should be unscoped. The valid arguments are given in &lt;a href=&quot;querymethods#VALID_UNSCOPING_VALUES&quot;&gt;VALID_UNSCOPING_VALUES&lt;/a&gt;. The method can also be called with multiple arguments. For example:</source>
          <target state="translated">메소드 인수는 범위를 지정하지 않아야하는 메소드의 이름에 해당하는 기호입니다. 유효한 인수는 &lt;a href=&quot;querymethods#VALID_UNSCOPING_VALUES&quot;&gt;VALID_UNSCOPING_VALUES에 제공&lt;/a&gt; 됩니다. 이 메소드는 여러 개의 인수로 호출 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f29811b2344f3c781cc85f6126a7eba350e8f54e" translate="yes" xml:space="preserve">
          <source>The method can be used in several slightly different ways, depending on how much you wish to rely on Rails to infer automatically from the model how the form should be constructed. For a generic model object, a form can be created by passing &lt;code&gt;form_for&lt;/code&gt; a string or symbol representing the object we are concerned with:</source>
          <target state="translated">이 방법은 모델에서 양식을 구성하는 방법을 자동으로 추론하기 위해 Rails에 의존하는 정도에 따라 몇 가지 약간 다른 방식으로 사용될 수 있습니다. 일반 모델 객체의 경우 &lt;code&gt;form_for&lt;/code&gt; 와 관련된 객체를 나타내는 문자열 또는 기호 를 전달하여 양식을 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df59aa5f4379b6a7b3027cf6de35b290d184f6f8" translate="yes" xml:space="preserve">
          <source>The method must be public in the target.</source>
          <target state="translated">메소드는 대상에서 공개되어야합니다.</target>
        </trans-unit>
        <trans-unit id="0ea58e33d4325a5441c0ed44a3d6618cc3feba41" translate="yes" xml:space="preserve">
          <source>The method name is generated by replacing spaces with underscores. The result does not need to be a valid Ruby identifier though, the name may contain punctuation characters etc. That's because in Ruby technically any string may be a method name. This may require use of &lt;code&gt;define_method&lt;/code&gt; and &lt;code&gt;send&lt;/code&gt; calls to function properly, but formally there's little restriction on the name.</source>
          <target state="translated">메소드 이름은 공백을 밑줄로 대체하여 생성됩니다. 결과는 유효한 Ruby 식별자 일 필요는 없지만 이름에는 문장 부호 문자 등이 포함될 수 있습니다. 이는 Ruby에서 기술적으로 모든 문자열이 메소드 이름 일 수 있기 때문입니다. 이 경우 &lt;code&gt;define_method&lt;/code&gt; 를 사용해야 하고 제대로 호출하기 위해 호출을 &lt;code&gt;send&lt;/code&gt; 하지만 공식적으로는 이름에 제한이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="3f48950e7a1291930ff3ceba91618afc3d58f76d" translate="yes" xml:space="preserve">
          <source>The method reference callbacks work by specifying a protected or private method available in the object, like this:</source>
          <target state="translated">메소드 참조 콜백은 다음과 같이 객체에서 사용 가능한 보호 또는 개인 메소드를 지정하여 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4c103e976f66c3afee2e0a77e51963a42f30a430" translate="yes" xml:space="preserve">
          <source>The method reference is the preferred approach to variable layouts and is used like this:</source>
          <target state="translated">메소드 참조는 변수 레이아웃에 선호되는 접근 방식이며 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0177f2d4e9121bd990bbdc6e21ee4939f478d0b6" translate="yes" xml:space="preserve">
          <source>The method simply stores an error message in the flash and redirects to the login form if the user is not logged in. If a &quot;before&quot; filter renders or redirects, the action will not run. If there are additional filters scheduled to run after that filter, they are also cancelled.</source>
          <target state="translated">이 방법은 단순히 오류 메시지를 플래시에 저장하고 사용자가 로그인하지 않은 경우 로그인 양식으로 리디렉션합니다. &quot;이전&quot;필터가 렌더링되거나 리디렉션되면 작업이 실행되지 않습니다. 해당 필터 이후에 추가로 실행되도록 예약 된 필터가 있으면 취소됩니다.</target>
        </trans-unit>
        <trans-unit id="e51ca83b78ed3a96cbc5befd362957c1169c765e" translate="yes" xml:space="preserve">
          <source>The method understands qualified table names:</source>
          <target state="translated">이 메소드는 규정 된 테이블 이름을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="c350fc830645f9176dfd3818099b11ae3983bdbf" translate="yes" xml:space="preserve">
          <source>The method will also ensure an HTTP &lt;a href=&quot;../date&quot;&gt;Date&lt;/a&gt; header for client compatibility.</source>
          <target state="translated">이 방법은 또한 클라이언트 호환성을 위해 HTTP &lt;a href=&quot;../date&quot;&gt;날짜&lt;/a&gt; 헤더를 보장합니다 .</target>
        </trans-unit>
        <trans-unit id="c7c7f5ee384fe2044ad32d25e79e26d5f3aa690a" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;Range#===&lt;/code&gt;, &lt;code&gt;Range#include?&lt;/code&gt;, and &lt;code&gt;Range#cover?&lt;/code&gt; say whether some value falls between the ends of a given instance:</source>
          <target state="translated">&lt;code&gt;Range#===&lt;/code&gt; , &lt;code&gt;Range#include?&lt;/code&gt; 메서드 및 &lt;code&gt;Range#cover?&lt;/code&gt; 주어진 인스턴스의 끝 사이에 어떤 가치가 있는지 여부를 말하십시오.</target>
        </trans-unit>
        <trans-unit id="d9a7edd36cd3f87a9ac106594572cc990797d90a" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;beginning_of_month&lt;/code&gt; and &lt;code&gt;end_of_month&lt;/code&gt; return the dates for the beginning and end of the month:</source>
          <target state="translated">방법은 &lt;code&gt;beginning_of_month&lt;/code&gt; 및 &lt;code&gt;end_of_month&lt;/code&gt; 월의 시작과 끝의 날짜를 반환 :</target>
        </trans-unit>
        <trans-unit id="b082ddf7d0327c04320194626ffb003ed515c178" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;beginning_of_quarter&lt;/code&gt; and &lt;code&gt;end_of_quarter&lt;/code&gt; return the dates for the beginning and end of the quarter of the receiver's calendar year:</source>
          <target state="translated">방법 &lt;code&gt;beginning_of_quarter&lt;/code&gt; 및 &lt;code&gt;end_of_quarter&lt;/code&gt; 시작과 수신기의 연도의 분기의 끝 날짜를 반환 :</target>
        </trans-unit>
        <trans-unit id="d9a727e15831861050a8ad7462355064dc28ab58" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;beginning_of_week&lt;/code&gt; and &lt;code&gt;end_of_week&lt;/code&gt; return the dates for the beginning and end of the week, respectively. Weeks are assumed to start on Monday, but that can be changed passing an argument, setting thread local &lt;code&gt;Date.beginning_of_week&lt;/code&gt; or &lt;code&gt;config.beginning_of_week&lt;/code&gt;.</source>
          <target state="translated">방법은 &lt;code&gt;beginning_of_week&lt;/code&gt; 및 &lt;code&gt;end_of_week&lt;/code&gt; 각각 일주일의 시작과 끝의 날짜를 돌려줍니다. 주는 월요일에 시작한다고 가정하지만 스레드 로컬 &lt;code&gt;Date.beginning_of_week&lt;/code&gt; 또는 &lt;code&gt;config.beginning_of_week&lt;/code&gt; 를 설정하여 인수를 전달하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc61fc2dcfd38d754ffc1b03fdf37a7ac79771a6" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;beginning_of_year&lt;/code&gt; and &lt;code&gt;end_of_year&lt;/code&gt; return the dates for the beginning and end of the year:</source>
          <target state="translated">방법은 &lt;code&gt;beginning_of_year&lt;/code&gt; 및 &lt;code&gt;end_of_year&lt;/code&gt; 년의 시작과 끝의 날짜를 반환 :</target>
        </trans-unit>
        <trans-unit id="c93442f75ad37d78087c0cd7de4798ce7440226e" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;monday&lt;/code&gt; and &lt;code&gt;sunday&lt;/code&gt; return the dates for the previous Monday and next Sunday, respectively.</source>
          <target state="translated">&lt;code&gt;monday&lt;/code&gt; 및 &lt;code&gt;sunday&lt;/code&gt; 메소드 는 각각 이전 월요일 및 다음 일요일의 날짜를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="101e739f5a98fcc8679ad2d254272635b35eb22b" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;months_ago&lt;/code&gt; and &lt;code&gt;months_since&lt;/code&gt; work analogously for months:</source>
          <target state="translated">&lt;code&gt;months_ago&lt;/code&gt; 및 &lt;code&gt;months_since&lt;/code&gt; 메소드 는 몇 달 동안 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a57bf9a6a89002a3c34cc6c1d424b2ec54e1d27a" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;second&lt;/code&gt;, &lt;code&gt;third&lt;/code&gt;, &lt;code&gt;fourth&lt;/code&gt;, and &lt;code&gt;fifth&lt;/code&gt; return the corresponding element, as do &lt;code&gt;second_to_last&lt;/code&gt; and &lt;code&gt;third_to_last&lt;/code&gt; (&lt;code&gt;first&lt;/code&gt; and &lt;code&gt;last&lt;/code&gt; are built-in). Thanks to social wisdom and positive constructiveness all around, &lt;code&gt;forty_two&lt;/code&gt; is also available.</source>
          <target state="translated">방법은 &lt;code&gt;second&lt;/code&gt; , &lt;code&gt;third&lt;/code&gt; , &lt;code&gt;fourth&lt;/code&gt; 및 &lt;code&gt;fifth&lt;/code&gt; 과 같이, 해당 요소를 반환 &lt;code&gt;second_to_last&lt;/code&gt; 및 &lt;code&gt;third_to_last&lt;/code&gt; ( &lt;code&gt;first&lt;/code&gt; 및 &lt;code&gt;last&lt;/code&gt; 내장된다). 사방의 사회적 지혜와 긍정적 건설 덕분에 &lt;code&gt;forty_two&lt;/code&gt; 도 가능합니다.</target>
        </trans-unit>
        <trans-unit id="302a64dec0c184391c6bcb15ca258c399575c5b1" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;silence_warnings&lt;/code&gt; and &lt;code&gt;enable_warnings&lt;/code&gt; change the value of &lt;code&gt;$VERBOSE&lt;/code&gt; accordingly for the duration of their block, and reset it afterwards:</source>
          <target state="translated">&lt;code&gt;silence_warnings&lt;/code&gt; 및 &lt;code&gt;enable_warnings&lt;/code&gt; 메소드 는 블록 기간 동안 이에 따라 &lt;code&gt;$VERBOSE&lt;/code&gt; 값을 변경하고 나중에 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="10ee15491942712a1e41b76c89b0f5f1b22a509f" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;to_date&lt;/code&gt;, &lt;code&gt;to_time&lt;/code&gt;, and &lt;code&gt;to_datetime&lt;/code&gt; are basically convenience wrappers around &lt;code&gt;Date._parse&lt;/code&gt;:</source>
          <target state="translated">방법은 &lt;code&gt;to_date&lt;/code&gt; , &lt;code&gt;to_time&lt;/code&gt; 및 &lt;code&gt;to_datetime&lt;/code&gt; 는 기본적으로 주변 편의 래퍼 &lt;code&gt;Date._parse&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbe25a0862b8a2b5ae25688ccd92978edff13bd7" translate="yes" xml:space="preserve">
          <source>The methods &lt;code&gt;to_options&lt;/code&gt; and &lt;code&gt;to_options!&lt;/code&gt; are respectively aliases of &lt;code&gt;symbolize_keys&lt;/code&gt; and &lt;code&gt;symbolize_keys!&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;to_options&lt;/code&gt; 및 &lt;code&gt;to_options!&lt;/code&gt; 메소드 ! &lt;code&gt;symbolize_keys&lt;/code&gt; 및 &lt;code&gt;symbolize_keys!&lt;/code&gt; 별명입니다 . .</target>
        </trans-unit>
        <trans-unit id="28acdf93546eacce94f3d9bcd3f859094ac99119" translate="yes" xml:space="preserve">
          <source>The methods Active Record provides to manipulate your database.</source>
          <target state="translated">Active Record가 데이터베이스를 조작하기 위해 제공하는 방법.</target>
        </trans-unit>
        <trans-unit id="e01fbc4ac2e1415be0e05e3a36a4769e572ae738" translate="yes" xml:space="preserve">
          <source>The methods are:</source>
          <target state="translated">방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85ead67c11e5371c2a532edbb9f016817232ba42" translate="yes" xml:space="preserve">
          <source>The methods that are available for generators are covered in the &lt;a href=&quot;#generator-methods&quot;&gt;final section&lt;/a&gt; of this guide.</source>
          <target state="translated">발전기에 사용할 수있는 방법 은이 안내서 의 &lt;a href=&quot;#generator-methods&quot;&gt;마지막 섹션&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="632757f8db9c26f8fc3f69acc6499d156989d659" translate="yes" xml:space="preserve">
          <source>The migration DSL has been expanded to support foreign key definitions. If you've been using the Foreigner gem, you might want to consider removing it. Note that the foreign key support of Rails is a subset of Foreigner. This means that not every Foreigner definition can be fully replaced by its Rails migration DSL counterpart.</source>
          <target state="translated">마이그레이션 DSL은 외래 키 정의를 지원하도록 확장되었습니다. Foreigner gem을 사용하고 있다면 제거하는 것이 좋습니다. Rails의 외래 키 지원은 외국인의 하위 집합입니다. 즉, 모든 외국인 정의를 Rails 마이그레이션 DSL로 완전히 대체 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="064ad71d72802cf5173a957b04d66eaf6ae10a67" translate="yes" xml:space="preserve">
          <source>The migration method &lt;code&gt;create_join_table&lt;/code&gt; creates an HABTM (has and belongs to many) join table. A typical use would be:</source>
          <target state="translated">마이그레이션 방법 &lt;code&gt;create_join_table&lt;/code&gt; 은 HABTM (많은 테이블이 있고 그에 속하는) 결합 테이블을 만듭니다. 일반적인 용도는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="46f69d5e49bda7d74e75c9f40f69e27e28ae44b1" translate="yes" xml:space="preserve">
          <source>The migration procedure is as follows:</source>
          <target state="translated">마이그레이션 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ab24c1cdb4bc14a36f9680163589fdc69716d944" translate="yes" xml:space="preserve">
          <source>The migration requires that we &lt;strong&gt;migrate&lt;/strong&gt;, that is, run some Ruby code (living in that &lt;code&gt;20130717151933_create_high_scores.rb&lt;/code&gt;) to modify the schema of our database. Which database? The SQLite3 database that Rails will create for you when we run the &lt;code&gt;rails db:migrate&lt;/code&gt; command. We'll talk more about that command below.</source>
          <target state="translated">마이그레이션을 위해서는 데이터베이스 스키마를 수정하기 위해 &lt;strong&gt;마이그레이션&lt;/strong&gt; (즉, 일부 Ruby 코드 ( &lt;code&gt;20130717151933_create_high_scores.rb&lt;/code&gt; 에 있음 ))을 실행 해야합니다. 어떤 데이터베이스? &lt;code&gt;rails db:migrate&lt;/code&gt; 명령을 실행할 때 Rails가 생성 할 SQLite3 데이터베이스 . 아래에서 해당 명령에 대해 자세히 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="106794560ae8481f1f8e790f3f30a20620d4b2b3" translate="yes" xml:space="preserve">
          <source>The migration version, migration file name, migration class name are available as instance variables in the template to be rendered.</source>
          <target state="translated">마이그레이션 버전, 마이그레이션 파일 이름, 마이그레이션 클래스 이름은 렌더링 할 템플리트에서 인스턴스 변수로 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="264fdcd063a5b992cffc029bb74fd19a7ee3ecc8" translate="yes" xml:space="preserve">
          <source>The migrations paths for a database configuration. If the &lt;code&gt;migrations_paths&lt;/code&gt; key is present in the config, &lt;code&gt;migrations_paths&lt;/code&gt; will return its value.</source>
          <target state="translated">데이터베이스 구성의 마이그레이션 경로 구성에 &lt;code&gt;migrations_paths&lt;/code&gt; 키가 있으면 &lt;code&gt;migrations_paths&lt;/code&gt; 가 해당 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1ffa60f96218aefefa017b3600936d844a777339" translate="yes" xml:space="preserve">
          <source>The model and scaffold generators will create migrations appropriate for adding a new model. This migration will already contain instructions for creating the relevant table. If you tell Rails what columns you want, then statements for adding these columns will also be created. For example, running:</source>
          <target state="translated">모델 및 스캐 폴드 생성기는 새 모델 추가에 적합한 마이그레이션을 작성합니다. 이 마이그레이션에는 관련 테이블 작성에 대한 지시 사항이 이미 포함되어 있습니다. 원하는 열을 Rails에 알려 주면이 열을 추가하기위한 명령문도 작성됩니다. 예를 들어 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="249b19b94a2baf19802b3a383ce518c8761e1284" translate="yes" xml:space="preserve">
          <source>The model class method &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; allows you to update and destroy associated records. This is based on the &lt;code&gt;id&lt;/code&gt; and &lt;code&gt;_destroy&lt;/code&gt; parameters:</source>
          <target state="translated">모델 클래스 메소드 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 를 사용하면 연관된 레코드를 업데이트하고 삭제할 수 있습니다. 이는 &lt;code&gt;id&lt;/code&gt; 및 &lt;code&gt;_destroy&lt;/code&gt; 매개 변수를 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="e14cc259f2fce88b090eb2cb7128b471b333c1e8" translate="yes" xml:space="preserve">
          <source>The model file, &lt;code&gt;app/models/article.rb&lt;/code&gt; is about as simple as it can get:</source>
          <target state="translated">&lt;code&gt;app/models/article.rb&lt;/code&gt; 모델 파일 은 다음과 같이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="eba21083dc8e4e9c25ca1f480fd47c8b083c4073" translate="yes" xml:space="preserve">
          <source>The module object following a &lt;code&gt;module&lt;/code&gt; keyword gets pushed when its body is executed, and popped after it.</source>
          <target state="translated">&lt;code&gt;module&lt;/code&gt; 키워드 다음에 나오는 모듈 객체 는 본문이 실행될 때 푸시되어 그 다음에 팝됩니다.</target>
        </trans-unit>
        <trans-unit id="83bfde6905a12029da10ae0302da14e944a33572" translate="yes" xml:space="preserve">
          <source>The more generic form can also be used:</source>
          <target state="translated">보다 일반적인 형태를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8749a8b69f507a203077616aca924230b98cbb6b" translate="yes" xml:space="preserve">
          <source>The more prepared statements in use: the more memory your database will require. If your PostgreSQL database is hitting memory limits, try lowering &lt;code&gt;statement_limit&lt;/code&gt; or disabling prepared statements.</source>
          <target state="translated">사용중인 준비 문이 많을수록 데이터베이스에 더 많은 메모리가 필요합니다. PostgreSQL 데이터베이스가 메모리 한계에 도달하면 &lt;code&gt;statement_limit&lt;/code&gt; 를 낮추 거나 준비된 명령문을 비활성화하십시오.</target>
        </trans-unit>
        <trans-unit id="559aa9c854f2130ef8fac1dca2f96f39aeb3d7e4" translate="yes" xml:space="preserve">
          <source>The most common XSS language is of course the most popular client-side scripting language JavaScript, often in combination with HTML. &lt;em&gt;Escaping user input is essential&lt;/em&gt;.</source>
          <target state="translated">가장 일반적인 XSS 언어는 물론 HTML과 함께 가장 인기있는 클라이언트 측 스크립트 언어 JavaScript입니다. &lt;em&gt;탈출 사용자 입력이 필수적&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a394aaf66692ca993ee720ec89c38286621984ad" translate="yes" xml:space="preserve">
          <source>The most common commands of the &lt;code&gt;db:&lt;/code&gt; rails namespace are &lt;code&gt;migrate&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt;, and it will pay off to try out all of the migration rails commands (&lt;code&gt;up&lt;/code&gt;, &lt;code&gt;down&lt;/code&gt;, &lt;code&gt;redo&lt;/code&gt;, &lt;code&gt;reset&lt;/code&gt;). &lt;code&gt;rails db:version&lt;/code&gt; is useful when troubleshooting, telling you the current version of the database.</source>
          <target state="translated">&lt;code&gt;db:&lt;/code&gt; rails 네임 스페이스 의 가장 일반적인 명령 은 &lt;code&gt;migrate&lt;/code&gt; 및 &lt;code&gt;create&lt;/code&gt; 이며 모든 마이그레이션 rails 명령 ( &lt;code&gt;up&lt;/code&gt; , &lt;code&gt;down&lt;/code&gt; , &lt;code&gt;redo&lt;/code&gt; , &lt;code&gt;reset&lt;/code&gt; ) 을 사용해보아야합니다 . &lt;code&gt;rails db:version&lt;/code&gt; 은 문제 해결시 데이터베이스의 현재 버전을 알려주는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="2d09f26c4b080f0da2d9b5d96ee1a38b054f08f7" translate="yes" xml:space="preserve">
          <source>The most common entry points are message posts, user comments, and guest books, but project titles, document names, and search result pages have also been vulnerable - just about everywhere where the user can input data. But the input does not necessarily have to come from input boxes on web sites, it can be in any URL parameter - obvious, hidden or internal. Remember that the user may intercept any traffic. Applications or client-site proxies make it easy to change requests. There are also other attack vectors like banner advertisements.</source>
          <target state="translated">가장 일반적인 진입 점은 메시지 게시물, 사용자 의견 및 방명록이지만 프로젝트 제목, 문서 이름 및 검색 결과 페이지도 사용자가 데이터를 입력 할 수있는 모든 곳에서 취약했습니다. 그러나 입력은 반드시 웹 사이트의 입력 상자에서 올 필요는 없으며 명백하거나 숨겨 지거나 내부의 모든 URL 매개 변수에있을 수 있습니다. 사용자는 모든 트래픽을 가로 챌 수 있습니다. 응용 프로그램 또는 클라이언트 사이트 프록시를 사용하면 요청을 쉽게 변경할 수 있습니다. 배너 광고와 같은 다른 공격 경로도 있습니다.</target>
        </trans-unit>
        <trans-unit id="445653008345676d9901d54b1dd03fc1df7ab282" translate="yes" xml:space="preserve">
          <source>The most common parameter that a user might tamper with, is the id parameter, as in &lt;code&gt;http://www.domain.com/project/1&lt;/code&gt;, whereas 1 is the id. It will be available in params in the controller. There, you will most likely do something like this:</source>
          <target state="translated">사용자가 조작 할 수있는 가장 일반적인 매개 변수는 &lt;code&gt;http://www.domain.com/project/1&lt;/code&gt; 에서와 같이 id 매개 변수 이며 1은 id입니다. 컨트롤러의 매개 변수로 사용할 수 있습니다. 거기에서 다음과 같이 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="539024df1130477692163b826318e13606156156" translate="yes" xml:space="preserve">
          <source>The most common usage pattern for this method is probably in a migration, when just after creating a table you want to populate it with some default values, eg:</source>
          <target state="translated">이 방법의 가장 일반적인 사용 패턴은 아마도 테이블을 생성 한 직후에 몇 가지 기본값으로 채울 때의 마이그레이션 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="53c94369ca312f2c571a25a01b217c63a4032152" translate="yes" xml:space="preserve">
          <source>The most effective countermeasure is to &lt;em&gt;issue a new session identifier&lt;/em&gt; and declare the old one invalid after a successful login. That way, an attacker cannot use the fixed session identifier. This is a good countermeasure against session hijacking, as well. Here is how to create a new session in Rails:</source>
          <target state="translated">가장 효과적인 대책은 &lt;em&gt;새 세션 식별자&lt;/em&gt; 를 &lt;em&gt;발급하고&lt;/em&gt; 로그인에 성공한 후 이전 &lt;em&gt;세션 식별자를&lt;/em&gt; 유효하지 않은 것으로 선언하는 것입니다. 이렇게하면 공격자가 고정 세션 식별자를 사용할 수 없습니다. 이것은 세션 도용에 대한 좋은 대책이기도합니다. Rails에서 새 세션을 생성하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed10c5c1398c3d0f83d0fb9826f7a006d60d6b58" translate="yes" xml:space="preserve">
          <source>The most efficient way to implement low-level caching is using the &lt;code&gt;Rails.cache.fetch&lt;/code&gt; method. This method does both reading and writing to the cache. When passed only a single argument, the key is fetched and value from the cache is returned. If a block is passed, that block will be executed in the event of a cache miss. The return value of the block will be written to the cache under the given cache key, and that return value will be returned. In case of cache hit, the cached value will be returned without executing the block.</source>
          <target state="translated">저수준 캐싱을 구현하는 가장 효율적인 방법은 &lt;code&gt;Rails.cache.fetch&lt;/code&gt; 메서드를 사용하는 것 입니다. 이 방법은 캐시를 읽고 쓰는 작업을 모두 수행합니다. 단일 인수 만 전달하면 키가 페치되고 캐시의 값이 리턴됩니다. 블록이 전달되면 캐시 누락시 해당 블록이 실행됩니다. 주어진 캐시 키에 따라 블록의 반환 값이 캐시에 기록되고 해당 반환 값이 반환됩니다. 캐시 적중의 경우, 블록을 실행하지 않고 캐시 된 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1bf4622040a1d5fcf3d59cf7f1f8b690e8a3cdf9" translate="yes" xml:space="preserve">
          <source>The most generic helper is &lt;code&gt;select_tag&lt;/code&gt;, which - as the name implies - simply generates the &lt;code&gt;SELECT&lt;/code&gt; tag that encapsulates an options string:</source>
          <target state="translated">가장 일반적인 도우미는 &lt;code&gt;select_tag&lt;/code&gt; 이며, 이름에서 알 수 있듯이 옵션 문자열을 캡슐화하는 &lt;code&gt;SELECT&lt;/code&gt; 태그를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="0509ac0ca8c10723fb1e7121e2ee0f87534275c0" translate="yes" xml:space="preserve">
          <source>The most generic way to jump to another datetime is &lt;code&gt;advance&lt;/code&gt;. This method receives a hash with keys &lt;code&gt;:years&lt;/code&gt;, &lt;code&gt;:months&lt;/code&gt;, &lt;code&gt;:weeks&lt;/code&gt;, &lt;code&gt;:days&lt;/code&gt;, &lt;code&gt;:hours&lt;/code&gt;, &lt;code&gt;:minutes&lt;/code&gt;, and &lt;code&gt;:seconds&lt;/code&gt;, and returns a datetime advanced as much as the present keys indicate.</source>
          <target state="translated">다른 날짜 시간으로 이동하는 가장 일반적인 방법은 &lt;code&gt;advance&lt;/code&gt; 입니다. 이 메소드는 &lt;code&gt;:years&lt;/code&gt; , &lt;code&gt;:months&lt;/code&gt; , &lt;code&gt;:weeks&lt;/code&gt; , &lt;code&gt;:days&lt;/code&gt; , &lt;code&gt;:hours&lt;/code&gt; , &lt;code&gt;:minutes&lt;/code&gt; 및 &lt;code&gt;:seconds&lt;/code&gt; 키가 포함 된 해시를 수신 하고 현재 키가 나타내는만큼 날짜 시간이 경과 한 것을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="12e7e7cea726db9dc19377303f26cc2abd058530" translate="yes" xml:space="preserve">
          <source>The most generic way to jump to other days is &lt;code&gt;advance&lt;/code&gt;. This method receives a hash with keys &lt;code&gt;:years&lt;/code&gt;, &lt;code&gt;:months&lt;/code&gt;, &lt;code&gt;:weeks&lt;/code&gt;, &lt;code&gt;:days&lt;/code&gt;, and returns a date advanced as much as the present keys indicate:</source>
          <target state="translated">다른 날로 이동하는 가장 일반적인 방법은 &lt;code&gt;advance&lt;/code&gt; 입니다. 이 메소드는 &lt;code&gt;:years&lt;/code&gt; , &lt;code&gt;:months&lt;/code&gt; , &lt;code&gt;:weeks&lt;/code&gt; , &lt;code&gt;:days&lt;/code&gt; 키가있는 해시를 수신 하고 현재 키가 나타내는만큼 날짜를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="ab1db0eb26e081fb619f5c2ecda6a3dfcb20b5b0" translate="yes" xml:space="preserve">
          <source>The most important methods of the I18n API are:</source>
          <target state="translated">I18n API의 가장 중요한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de5193516e477d3a63bb08f8e687e1bad99cf2fe" translate="yes" xml:space="preserve">
          <source>The most lightweight way to get &lt;code&gt;blank?&lt;/code&gt; is to cherry-pick the file that defines it.</source>
          <target state="translated">비우는 가장 가벼운 방법 &lt;code&gt;blank?&lt;/code&gt; 파일을 정의하는 파일을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="deaa5c007cdde26cbe743db657315259b43d7a47" translate="yes" xml:space="preserve">
          <source>The most significant part of the reloading process is the Class Unload, where all autoloaded classes are removed, ready to be loaded again. This will occur immediately before either the Run or Complete callback, depending on the &lt;code&gt;reload_classes_only_on_change&lt;/code&gt; setting.</source>
          <target state="translated">재로드 프로세스의 가장 중요한 부분은 모든 자동로드 된 클래스가 제거되어 다시로드 될 수있는 클래스 언로드입니다. &lt;code&gt;reload_classes_only_on_change&lt;/code&gt; 설정 에 따라 Run 또는 Complete 콜백 직전에 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="f22b7e6bbaf30a8c9243fc72a0dbaa5e651e526a" translate="yes" xml:space="preserve">
          <source>The most simple negative CAPTCHA is one hidden honeypot field. On the server side, you will check the value of the field: If it contains any text, it must be a bot. Then, you can either ignore the post or return a positive result, but not saving the post to the database. This way the bot will be satisfied and moves on.</source>
          <target state="translated">가장 간단한 네거티브 CAPTCHA는 숨겨진 허니팟 필드입니다. 서버 측에서 필드 값을 확인합니다. 텍스트가 포함 된 경우 봇이어야합니다. 그런 다음 게시물을 무시하거나 긍정적 인 결과를 반환 할 수 있지만 게시물을 데이터베이스에 저장하지는 마십시오. 이 방법으로 봇은 만족하고 계속 움직입니다.</target>
        </trans-unit>
        <trans-unit id="5b08222207f915df820834ca331365d73b1692b3" translate="yes" xml:space="preserve">
          <source>The most usual way of setting (and passing) the locale would be to include it in URL params, as we did in the &lt;code&gt;I18n.with_locale(params[:locale], &amp;amp;action)&lt;/code&gt;&lt;em&gt;around_action&lt;/em&gt; in the first example. We would like to have URLs like &lt;code&gt;www.example.com/books?locale=ja&lt;/code&gt; or &lt;code&gt;www.example.com/ja/books&lt;/code&gt; in this case.</source>
          <target state="translated">로케일을 설정하고 전달하는 가장 일반적인 방법은 첫 번째 예에서 &lt;code&gt;I18n.with_locale(params[:locale], &amp;amp;action)&lt;/code&gt; &lt;em&gt;around_action&lt;/em&gt; 에서 와 같이 로케일 을 URL 매개 변수에 포함시키는 것입니다 . 이 경우 &lt;code&gt;www.example.com/books?locale=ja&lt;/code&gt; 또는 &lt;code&gt;www.example.com/ja/books&lt;/code&gt; 와 같은 URL이 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="7e572f11bc576cfa35e26cdda3779b627b91359a" translate="yes" xml:space="preserve">
          <source>The mysql2 and postgresql adapters support setting the transaction isolation level.</source>
          <target state="translated">mysql2 및 postgresql 어댑터는 트랜잭션 격리 레벨 설정을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="7abd2783257ce5c418b69249f67d3cccad19bd9b" translate="yes" xml:space="preserve">
          <source>The name is assumed to be the one of a top-level constant, no matter whether it starts with &amp;ldquo;::&amp;rdquo; or not. No lexical context is taken into account:</source>
          <target state="translated">이름은&amp;ldquo;::&amp;rdquo;로 시작하든 아니든 최상위 상수 중 하나 인 것으로 가정합니다. 어휘 적 맥락은 고려되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="7682be9c1ac3480a8408c4e7c8381256b4759439" translate="yes" xml:space="preserve">
          <source>The name may be given as a symbol or string. A symbol is tested against the bare constant name, a string is against the fully qualified constant name.</source>
          <target state="translated">이름은 기호 또는 문자열로 제공 될 수 있습니다. 기호는 완전 상수 이름에 대해 테스트되고 문자열은 완전한 상수 이름에 대해 테스트됩니다.</target>
        </trans-unit>
        <trans-unit id="ff2cc46757b67b828a3611568ef0999be93f8863" translate="yes" xml:space="preserve">
          <source>The name of children nodes is by default the name of the root node singularized. In the examples above we've seen &quot;contributor&quot; and &quot;object&quot;. The option &lt;code&gt;:children&lt;/code&gt; allows you to set these node names.</source>
          <target state="translated">하위 노드의 이름은 기본적으로 루트 노드의 이름이 단일화됩니다. 위의 예에서 우리는 &quot;기여자&quot;와 &quot;개체&quot;를 보았습니다. &lt;code&gt;:children&lt;/code&gt; 옵션을 사용하면 이러한 노드 이름을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c6ce84bb5ee288c0d73a45b947b0bd4d166718a" translate="yes" xml:space="preserve">
          <source>The name of the column records are ordered by if no explicit order clause is used during an ordered finder call. If not set the primary key is used.</source>
          <target state="translated">정렬 된 파인더 호출 중에 명시 적 순서 절이 사용되지 않으면 열 레코드의 이름이 순서화됩니다. 설정하지 않으면 기본 키가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d5cd10d5efb705d95ff6ef881164cb30052e176" translate="yes" xml:space="preserve">
          <source>The name of the event</source>
          <target state="translated">행사 명</target>
        </trans-unit>
        <trans-unit id="99cde37466813b73e8fdf6722f4504527670a021" translate="yes" xml:space="preserve">
          <source>The name of the file is passed as an argument, and the method yields a file handle opened for writing. Once the block is done &lt;code&gt;atomic_write&lt;/code&gt; closes the file handle and completes its job.</source>
          <target state="translated">파일 이름이 인수로 전달되고이 메소드는 쓰기 위해 열린 파일 핸들을 생성합니다. 블록이 완료되면 &lt;code&gt;atomic_write&lt;/code&gt; 는 파일 핸들을 닫고 작업을 완료합니다.</target>
        </trans-unit>
        <trans-unit id="0521ba09d337a2d778bfca23d5ae64a4f07775ab" translate="yes" xml:space="preserve">
          <source>The name of the internal metadata table. By default, the value is &lt;code&gt;&quot;ar_internal_metadata&quot;&lt;/code&gt;.</source>
          <target state="translated">내부 메타 데이터 테이블의 이름입니다. 기본적으로 값은 &lt;code&gt;&quot;ar_internal_metadata&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="87b9d571692332990b0d9ecc4d38d8bf64d75f30" translate="yes" xml:space="preserve">
          <source>The name of the other model is pluralized when declaring a &lt;code&gt;has_many&lt;/code&gt; association.</source>
          <target state="translated">다른 모델의 이름은 &lt;code&gt;has_many&lt;/code&gt; 연관을 선언 할 때 복수형 입니다.</target>
        </trans-unit>
        <trans-unit id="fae05eeb96ed23d05d4d24f0db744b426f26af4b" translate="yes" xml:space="preserve">
          <source>The name of the primary key, if one is to be added automatically. Defaults to &lt;code&gt;id&lt;/code&gt;. If &lt;code&gt;:id&lt;/code&gt; is false, then this option is ignored.</source>
          <target state="translated">기본 키의 이름 (자동으로 추가 될 경우) 기본값은 &lt;code&gt;id&lt;/code&gt; 입니다. 경우 &lt;code&gt;:id&lt;/code&gt; 거짓,이 옵션은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="da0fc804bd180d28e2d8888d63d2769586922e81" translate="yes" xml:space="preserve">
          <source>The name of the schema migrations table. By default, the value is &lt;code&gt;&quot;schema_migrations&quot;&lt;/code&gt;.</source>
          <target state="translated">스키마 마이그레이션 테이블의 이름입니다. 기본적으로 값은 &lt;code&gt;&quot;schema_migrations&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e6c80f6f8b2cab6f8d72af40fb12b078c9f2364a" translate="yes" xml:space="preserve">
          <source>The name of the table that contains the referenced primary key.</source>
          <target state="translated">참조 된 기본 키가 포함 된 테이블의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7b4e2235c7c60d1a2f073929cfea99b7c7914199" translate="yes" xml:space="preserve">
          <source>The name used to generate routing helpers.</source>
          <target state="translated">라우팅 헬퍼를 생성하는 데 사용되는 이름입니다.</target>
        </trans-unit>
        <trans-unit id="3964abe7f918479b2abff91c768cdbbc000a3785" translate="yes" xml:space="preserve">
          <source>The namespace for :controller.</source>
          <target state="translated">: controller의 네임 스페이스</target>
        </trans-unit>
        <trans-unit id="c0a61dcbd71b123c4388becd07a60ebdedcd55c9" translate="yes" xml:space="preserve">
          <source>The naming convention of controllers in Rails favors pluralization of the last word in the controller's name, although it is not strictly required (e.g. &lt;code&gt;ApplicationController&lt;/code&gt;). For example, &lt;code&gt;ClientsController&lt;/code&gt; is preferable to &lt;code&gt;ClientController&lt;/code&gt;, &lt;code&gt;SiteAdminsController&lt;/code&gt; is preferable to &lt;code&gt;SiteAdminController&lt;/code&gt; or &lt;code&gt;SitesAdminsController&lt;/code&gt;, and so on.</source>
          <target state="translated">Rails에서 컨트롤러의 이름 지정 규칙은 컨트롤러 이름에서 마지막 단어의 복수화를 선호하지만 엄격하게 요구되지는 않습니다 (예 : &lt;code&gt;ApplicationController&lt;/code&gt; ). 예를 들어, &lt;code&gt;ClientsController&lt;/code&gt; 는 것이 바람직하다 &lt;code&gt;ClientController&lt;/code&gt; , &lt;code&gt;SiteAdminsController&lt;/code&gt; 는 것이 바람직하다 &lt;code&gt;SiteAdminController&lt;/code&gt; 또는 &lt;code&gt;SitesAdminsController&lt;/code&gt; 등.</target>
        </trans-unit>
        <trans-unit id="da43aa56708a046e9d919ba08558af7f2b7c90f6" translate="yes" xml:space="preserve">
          <source>The native Range#=== behavior is untouched.</source>
          <target state="translated">기본 Range # === 동작은 그대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="01d960ee2f543130c2fa5e0f4bbe3a7d3b4d5d58" translate="yes" xml:space="preserve">
          <source>The native Range#cover? behavior is untouched.</source>
          <target state="translated">네이티브 Range # cover? 행동은 그대로입니다.</target>
        </trans-unit>
        <trans-unit id="addd76f14ed86b37f8794f1949371e30871af465" translate="yes" xml:space="preserve">
          <source>The native Range#include? behavior is untouched.</source>
          <target state="translated">네이티브 범위 #include? 행동은 그대로입니다.</target>
        </trans-unit>
        <trans-unit id="955570bf5e30a267b95e2b19e01795ab5b90fe19" translate="yes" xml:space="preserve">
          <source>The negative of the &lt;code&gt;Enumerable#include?&lt;/code&gt;. Returns &lt;code&gt;true&lt;/code&gt; if the collection does not include the object.</source>
          <target state="translated">&lt;code&gt;Enumerable#include?&lt;/code&gt; 의 부정 ? . 컬렉션에 개체가 포함되어 있지 않으면 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="aa592105289e44cdc2fe7058b0d283c263374192" translate="yes" xml:space="preserve">
          <source>The nesting at the top-level of code interpreted by &lt;code&gt;Kernel#load&lt;/code&gt; is empty unless the &lt;code&gt;load&lt;/code&gt; call receives a true value as second argument, in which case a newly created anonymous module is pushed by Ruby.</source>
          <target state="translated">&lt;code&gt;load&lt;/code&gt; 호출이 두 번째 인수로 true 값을 수신 하지 않는 한 &lt;code&gt;Kernel#load&lt;/code&gt; 로 해석 된 최상위 코드의 중첩 은 비어 있습니다 .이 경우 새로 작성된 익명 모듈이 Ruby에 의해 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="44f681ce3d5bf281490d9093acabc279f90b97b0" translate="yes" xml:space="preserve">
          <source>The nesting in (3) consists of two module objects:</source>
          <target state="translated">(3)의 중첩은 두 개의 모듈 객체로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="1f2776db1df9e895a5437fc06cd98a8e3f712806" translate="yes" xml:space="preserve">
          <source>The nesting is an internal stack maintained by the interpreter, and it gets modified according to these rules:</source>
          <target state="translated">중첩은 인터프리터가 유지 관리하는 내부 스택이며 다음 규칙에 따라 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="d8132f087b3a3c8f4dbbe4d6d5c2d07c8a3b1719" translate="yes" xml:space="preserve">
          <source>The new Rails version might have different configuration defaults than the previous version. However, after following the steps described above, your application would still run with configuration defaults from the &lt;em&gt;previous&lt;/em&gt; Rails version. That's because the value for &lt;code&gt;config.load_defaults&lt;/code&gt; in &lt;code&gt;config/application.rb&lt;/code&gt; has not been changed yet.</source>
          <target state="translated">새로운 Rails 버전은 이전 버전과 다른 구성 기본값을 가질 수 있습니다. 그러나 위에서 설명한 단계를 수행 한 후에도 애플리케이션은 여전히 &lt;em&gt;이전&lt;/em&gt; Rails 버전 의 구성 기본값으로 실행됩니다 . 그의는 값 때문에 &lt;code&gt;config.load_defaults&lt;/code&gt; 에서 &lt;code&gt;config/application.rb&lt;/code&gt; 아직 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5cd4f4aaeecefdcd80f1ff388b96a1c0963cfd34" translate="yes" xml:space="preserve">
          <source>The new adjusted credit value is stored in the session.</source>
          <target state="translated">새로운 조정 된 크레딧 값이 세션에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="3236ac103406c4313c28858fa0a2054906ffe321" translate="yes" xml:space="preserve">
          <source>The new configuration point</source>
          <target state="translated">새로운 구성 지점</target>
        </trans-unit>
        <trans-unit id="0da16999f13727907b8b87c6035cd8e31952aef2" translate="yes" xml:space="preserve">
          <source>The new instance is yielded to the passed block. Typically the block will create some routes using &lt;code&gt;set.draw { match ... }&lt;/code&gt;:</source>
          <target state="translated">새로운 인스턴스는 전달 된 블록에 양보됩니다. 일반적으로 블록은 &lt;code&gt;set.draw { match ... }&lt;/code&gt; 사용하여 일부 경로를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="361f89f47f1ce3ba7058a4305e31979330927e55" translate="yes" xml:space="preserve">
          <source>The new method, &lt;code&gt;update&lt;/code&gt;, is used when you want to update a record that already exists, and it accepts a hash containing the attributes that you want to update. As before, if there was an error updating the article we want to show the form back to the user.</source>
          <target state="translated">새로운 메소드 인 &lt;code&gt;update&lt;/code&gt; 는 이미 존재하는 레코드를 업데이트하려고 할 때 사용되며 업데이트하려는 속성이 포함 된 해시를 허용합니다. 이전과 마찬가지로 기사를 업데이트하는 동안 오류가 발생하면 양식을 사용자에게 다시 표시하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6412348bc9179e1b6361749c95aec125c2d79269" translate="yes" xml:space="preserve">
          <source>The new record might not be saved to the database; that depends on whether validations passed or not (just like &lt;code&gt;create&lt;/code&gt;).</source>
          <target state="translated">새 레코드가 데이터베이스에 저장되지 않았을 수 있습니다. 유효성 검사가 통과했는지 여부에 따라 다릅니다 ( &lt;code&gt;create&lt;/code&gt; 처럼 ).</target>
        </trans-unit>
        <trans-unit id="74f8325afa2e53ab911c7dd3a1bd0b5d96aac1df" translate="yes" xml:space="preserve">
          <source>The new version updates &lt;code&gt;sanitize&lt;/code&gt;, so it can take a &lt;code&gt;Loofah::Scrubber&lt;/code&gt; for powerful scrubbing. &lt;a href=&quot;https://github.com/flavorjones/loofah#loofahscrubber&quot;&gt;See some examples of scrubbers here&lt;/a&gt;.</source>
          <target state="translated">새 버전 업데이트는 &lt;code&gt;sanitize&lt;/code&gt; 이므로 강력한 제거를 위해 &lt;code&gt;Loofah::Scrubber&lt;/code&gt; 가 필요할 수 있습니다 . &lt;a href=&quot;https://github.com/flavorjones/loofah#loofahscrubber&quot;&gt;여기에서 세정기의 예를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1894e9581c114e574d8b39a2616de5b78a0f089" translate="yes" xml:space="preserve">
          <source>The next customization on the workflow will be to stop generating stylesheet and test fixture files for scaffolds altogether. We can achieve that by changing our configuration to the following:</source>
          <target state="translated">워크 플로우의 다음 사용자 정의는 스캐 폴드에 대한 스타일 시트 및 테스트 픽스처 파일 생성을 중지하는 것입니다. 구성을 다음과 같이 변경하여이를 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b49bfc24f4c677b6906642f014ecee042d3e62" translate="yes" xml:space="preserve">
          <source>The next level is to simply load all extensions to &lt;code&gt;Object&lt;/code&gt;. As a rule of thumb, extensions to &lt;code&gt;SomeClass&lt;/code&gt; are available in one shot by loading &lt;code&gt;active_support/core_ext/some_class&lt;/code&gt;.</source>
          <target state="translated">다음 단계는 모든 확장을 &lt;code&gt;Object&lt;/code&gt; 에 간단히로드하는 것 입니다. 경험상 &lt;code&gt;SomeClass&lt;/code&gt; 의 확장 은 &lt;code&gt;active_support/core_ext/some_class&lt;/code&gt; 를 로드하여 한 번에 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b6a1f1dbc7d882abfb6cfb4b67d27a4e28897661" translate="yes" xml:space="preserve">
          <source>The next line in &lt;code&gt;config/application.rb&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 의 다음 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="890dcab656e3faff6f378319839d5ff9b37f86c6" translate="yes" xml:space="preserve">
          <source>The next problem was MySpace filtering the word &quot;javascript&quot;, so the author used &quot;java&amp;lt;NEWLINE&amp;gt;script&quot; to get around this:</source>
          <target state="translated">다음 문제는 MySpace가 단어 &quot;javascript&quot;를 필터링하는 것이므로 저자는 &quot;java &amp;lt;NEWLINE&amp;gt; script&quot;를 사용하여이 문제를 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="86ab928a1a7619a09a73390e50d76a97c8e90778" translate="yes" xml:space="preserve">
          <source>The next step is to make the class that represents a &lt;code&gt;User&lt;/code&gt; in the application customizable for the engine. This is because that class may not always be &lt;code&gt;User&lt;/code&gt;, as previously explained. To make this setting customizable, the engine will have a configuration setting called &lt;code&gt;author_class&lt;/code&gt; that will be used to specify which class represents users inside the application.</source>
          <target state="translated">다음 단계는 애플리케이션에서 &lt;code&gt;User&lt;/code&gt; 를 나타내는 클래스를 엔진에 대해 사용자 정의 할 수있게 만드는 것 입니다. 이전에 설명한 것처럼 해당 클래스가 항상 &lt;code&gt;User&lt;/code&gt; 가 아닐 수도 있기 때문입니다 . 이 설정을 사용자 정의 할 수 있도록 엔진에는 &lt;code&gt;author_class&lt;/code&gt; 라는 구성 설정이 있으며,이 설정 은 애플리케이션 내부의 사용자를 나타내는 클래스를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="79e3f57a1b3ee60f1474c6b0b6b6f30307fee9e6" translate="yes" xml:space="preserve">
          <source>The next step is to switch the &lt;code&gt;Blorgh::Article&lt;/code&gt; model over to this new setting. Change the &lt;code&gt;belongs_to&lt;/code&gt; association inside this model (&lt;code&gt;app/models/blorgh/article.rb&lt;/code&gt;) to this:</source>
          <target state="translated">다음 단계는 &lt;code&gt;Blorgh::Article&lt;/code&gt; 모델을이 새로운 설정 으로 전환하는 것 입니다. 이 모델 ( &lt;code&gt;app/models/blorgh/article.rb&lt;/code&gt; ) 내의 &lt;code&gt;belongs_to&lt;/code&gt; 연관을 다음과 같이 변경하십시오 :</target>
        </trans-unit>
        <trans-unit id="665b7f33f63099c0b1cea4b1fb4ebac3b0e2d737" translate="yes" xml:space="preserve">
          <source>The next thing that changes in isolated engines is the behavior of routes. Normally, when you namespace your controllers, you also need to namespace the related routes. With an isolated engine, the engine's namespace is automatically applied, so you don't need to specify it explicitly in your routes:</source>
          <target state="translated">격리 된 엔진에서 변경되는 다음 사항은 경로의 동작입니다. 일반적으로 컨트롤러의 네임 스페이스를 만들 때 관련 경로의 네임 스페이스도 지정해야합니다. 격리 된 엔진을 사용하면 엔진의 네임 스페이스가 자동으로 적용되므로 경로에서 명시 적으로 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="93d819b142e381f44914883470304c3b40e5adf1" translate="yes" xml:space="preserve">
          <source>The nonce is opaque to the client. Composed of &lt;a href=&quot;../../time&quot;&gt;Time&lt;/a&gt;, and hash of &lt;a href=&quot;../../time&quot;&gt;Time&lt;/a&gt; with secret key from the Rails session secret generated upon creation of project. Ensures the time cannot be modified by client.</source>
          <target state="translated">nonce는 클라이언트에게 불투명합니다. 로 구성 &lt;a href=&quot;../../time&quot;&gt;시간&lt;/a&gt; , 그리고 해시 &lt;a href=&quot;../../time&quot;&gt;시간&lt;/a&gt; 프로젝트 생성시 생성 된 레일 세션의 비밀에서 비밀 키. 클라이언트가 시간을 수정할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="d6afe7561df1d98a902707f851ee94efab958e53" translate="yes" xml:space="preserve">
          <source>The number in the middle is the &lt;code&gt;product_id&lt;/code&gt; followed by the timestamp value in the &lt;code&gt;updated_at&lt;/code&gt; attribute of the product record. Rails uses the timestamp value to make sure it is not serving stale data. If the value of &lt;code&gt;updated_at&lt;/code&gt; has changed, a new key will be generated. Then Rails will write a new cache to that key, and the old cache written to the old key will never be used again. This is called key-based expiration.</source>
          <target state="translated">중간에있는 숫자는 &lt;code&gt;product_id&lt;/code&gt; 와 제품 레코드 의 &lt;code&gt;updated_at&lt;/code&gt; 속성 에있는 타임 스탬프 값입니다 . Rails는 타임 스탬프 값을 사용하여 오래된 데이터를 제공하지 않도록합니다. &lt;code&gt;updated_at&lt;/code&gt; 의 값 이 변경되면 새 키가 생성됩니다. 그런 다음 Rails는 해당 키에 새 캐시를 작성하고 이전 키에 작성된 이전 캐시는 다시 사용되지 않습니다. 이것을 키 기반 만료라고합니다.</target>
        </trans-unit>
        <trans-unit id="8ee1df042709719100df6be6c3b0a3fd04dc19b3" translate="yes" xml:space="preserve">
          <source>The number of arguments in the signature must match. If the object responds to the method the call is attempted and &lt;code&gt;ArgumentError&lt;/code&gt; is still raised in case of argument mismatch.</source>
          <target state="translated">서명의 인수 수가 일치해야합니다. 객체가 메소드에 응답하면 호출이 시도되고 인수 불일치가 발생하면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 계속 발생합니다.</target>
        </trans-unit>
        <trans-unit id="505e9d95ab3606901bc6ffa80ead6b281f7cb035" translate="yes" xml:space="preserve">
          <source>The number of iterations that will be done by the partial.</source>
          <target state="translated">부분적으로 수행 될 반복 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="038422c23b9cb97bfa4b6a6b66a4d0be0680f470" translate="yes" xml:space="preserve">
          <source>The number of workers passed is the number of times the process will be forked. You may want to parallelize your local test suite differently from your CI, so an environment variable is provided to be able to easily change the number of workers a test run should use:</source>
          <target state="translated">통과 한 작업자 수는 프로세스가 분기되는 횟수입니다. 로컬 테스트 스위트를 CI와 다르게 병렬화 할 수 있으므로 테스트 실행에 사용해야하는 작업자 수를 쉽게 변경할 수있는 환경 변수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="33d090a4862daa4700aeb1957ac30a3aad04f48a" translate="yes" xml:space="preserve">
          <source>The number of workers passed to &lt;code&gt;parallelize&lt;/code&gt; determines the number of threads the tests will use. You may want to parallelize your local test suite differently from your CI, so an environment variable is provided to be able to easily change the number of workers a test run should use:</source>
          <target state="translated">&lt;code&gt;parallelize&lt;/code&gt; 전달 된 작업자 수에 따라 테스트에서 사용할 스레드 수가 결정됩니다. 로컬 테스트 스위트를 CI와 다르게 병렬화 할 수 있으므로 테스트 실행에 사용해야하는 작업자 수를 쉽게 변경할 수있는 환경 변수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="bec8710416db3a7f64fed68d9b0b0bf55970a04e" translate="yes" xml:space="preserve">
          <source>The object in the &lt;code&gt;params&lt;/code&gt; hash is an instance of &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Http/UploadedFile.html&quot;&gt;&lt;code&gt;ActionDispatch::Http::UploadedFile&lt;/code&gt;&lt;/a&gt;. The following snippet saves the uploaded file in &lt;code&gt;#{Rails.root}/public/uploads&lt;/code&gt; under the same name as the original file.</source>
          <target state="translated">&lt;code&gt;params&lt;/code&gt; 해시 의 객체 는 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Http/UploadedFile.html&quot;&gt; &lt;code&gt;ActionDispatch::Http::UploadedFile&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다 . 다음 스 니펫은 업로드 된 파일을 원본 파일과 동일한 이름으로 &lt;code&gt;#{Rails.root}/public/uploads&lt;/code&gt; 에 저장합니다.</target>
        </trans-unit>
        <trans-unit id="638d1c2387bff55fda430b14e4440039041a5b60" translate="yes" xml:space="preserve">
          <source>The object passed as &lt;code&gt;:model&lt;/code&gt; in &lt;code&gt;form_with&lt;/code&gt; controls the key used in &lt;code&gt;params&lt;/code&gt; to access the form's values. Here the name is &lt;code&gt;article&lt;/code&gt; and so all the inputs have names of the form &lt;code&gt;article[attribute_name]&lt;/code&gt;. Accordingly, in the &lt;code&gt;create&lt;/code&gt; action &lt;code&gt;params[:article]&lt;/code&gt; will be a hash with keys &lt;code&gt;:title&lt;/code&gt; and &lt;code&gt;:body&lt;/code&gt;. You can read more about the significance of input names in chapter &lt;a href=&quot;#understanding-parameter-naming-conventions&quot;&gt;Understanding Parameter Naming Conventions&lt;/a&gt; of this guide.</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 에서 &lt;code&gt;:model&lt;/code&gt; 로 전달 된 객체 는 &lt;code&gt;params&lt;/code&gt; 에 사용 된 키를 제어 하여 양식 값에 액세스합니다. 여기서 이름은 &lt;code&gt;article&lt;/code&gt; 이므로 모든 입력은 &lt;code&gt;article[attribute_name]&lt;/code&gt; 형식의 이름을 갖습니다 . 따라서 &lt;code&gt;create&lt;/code&gt; action에서 &lt;code&gt;params[:article]&lt;/code&gt; 은 키 &lt;code&gt;:title&lt;/code&gt; 및 &lt;code&gt;:body&lt;/code&gt; 가있는 해시입니다 . 이 안내서의 &lt;a href=&quot;#understanding-parameter-naming-conventions&quot;&gt;매개 변수 명명 규칙 이해&lt;/a&gt; 장에서 입력 이름의 중요성에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3db7e74818e7069b61951f9db787751ef0935d02" translate="yes" xml:space="preserve">
          <source>The object returned is a relation, which can be further extended.</source>
          <target state="translated">리턴 된 오브젝트는 관계이며 추가로 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ebeb64ea392c06389da82d15b57e2dc0fb1998e" translate="yes" xml:space="preserve">
          <source>The object yielded by &lt;code&gt;fields_for&lt;/code&gt; is a form builder like the one yielded by &lt;code&gt;form_with&lt;/code&gt;.</source>
          <target state="translated">에 의해 산출 개체 &lt;code&gt;fields_for&lt;/code&gt; 은 에 의해 산출 것과 같은 형태 빌더입니다 &lt;code&gt;form_with&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57072ad448de4139f9cc538a750565d5bae03dd9" translate="yes" xml:space="preserve">
          <source>The object yielded by &lt;code&gt;form_with&lt;/code&gt; and &lt;code&gt;fields_for&lt;/code&gt; is an instance of &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html&quot;&gt;&lt;code&gt;ActionView::Helpers::FormBuilder&lt;/code&gt;&lt;/a&gt;. Form builders encapsulate the notion of displaying form elements for a single object. While you can write helpers for your forms in the usual way, you can also create subclass &lt;code&gt;ActionView::Helpers::FormBuilder&lt;/code&gt; and add the helpers there. For example:</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 와 &lt;code&gt;fields_for&lt;/code&gt; 가 생성 한 객체는 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormBuilder.html&quot;&gt; &lt;code&gt;ActionView::Helpers::FormBuilder&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다 . 양식 작성기는 단일 객체에 대한 양식 요소를 표시하는 개념을 요약합니다. 일반적인 방법으로 양식에 대한 헬퍼를 작성할 수 있지만 서브 클래스 &lt;code&gt;ActionView::Helpers::FormBuilder&lt;/code&gt; 작성 하고 헬퍼를 추가 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3de27dfed2e4c78b35ecc58982517007c169ac2a" translate="yes" xml:space="preserve">
          <source>The only ActiveStorage service that provides this hook so far is GCS.</source>
          <target state="translated">지금까지이 후크를 제공하는 유일한 ActiveStorage 서비스는 GCS입니다.</target>
        </trans-unit>
        <trans-unit id="caaae6a0029374b4c88ed2f441090956efc2faaa" translate="yes" xml:space="preserve">
          <source>The only catch with using the SCM options is that you have to make your application's directory first, then initialize your SCM, then you can run the &lt;code&gt;rails new&lt;/code&gt; command to generate the basis of your app.</source>
          <target state="translated">SCM 옵션을 사용하는 유일한 방법은 응용 프로그램의 디렉토리를 먼저 만든 다음 SCM을 초기화 한 다음 &lt;code&gt;rails new&lt;/code&gt; 명령을 실행 하여 앱의 기초를 생성해야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7c023b3703738247136fd6b3e082be811c39b62e" translate="yes" xml:space="preserve">
          <source>The only downside to this code is that it requires a round trip to the browser: the browser requested the show action with &lt;code&gt;/books/1&lt;/code&gt; and the controller finds that there are no books, so the controller sends out a 302 redirect response to the browser telling it to go to &lt;code&gt;/books/&lt;/code&gt;, the browser complies and sends a new request back to the controller asking now for the &lt;code&gt;index&lt;/code&gt; action, the controller then gets all the books in the database and renders the index template, sending it back down to the browser which then shows it on your screen.</source>
          <target state="translated">이 코드의 유일한 단점은 브라우저로의 왕복 여행이 필요하다는 것입니다. 브라우저는 &lt;code&gt;/books/1&lt;/code&gt; 로 show 작업을 요청 했고 컨트롤러는 책이 없다는 것을 발견하여 컨트롤러가 브라우저에 302 리디렉션 응답을 보냅니다. 브라우저 가 &lt;code&gt;/books/&lt;/code&gt; 로 이동 하면 브라우저는 &lt;code&gt;index&lt;/code&gt; 작업을 요청하는 컨트롤러에 새로운 요청을 다시 보내고 다시 보내면 컨트롤러는 데이터베이스의 모든 책을 가져 와서 색인 템플릿을 렌더링하여 브라우저가 화면에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e864bfdb02d383ce40daeb3ce7e75a9c7a05ef9f" translate="yes" xml:space="preserve">
          <source>The only exception in &lt;a href=&quot;activemodel&quot;&gt;ActiveModel&lt;/a&gt; for &lt;a href=&quot;../../activerecord&quot;&gt;ActiveRecord&lt;/a&gt; is the use of self.build instead of self.new.</source>
          <target state="translated">의 유일한 예외 &lt;a href=&quot;activemodel&quot;&gt;ActiveModel&lt;/a&gt; 을위한 &lt;a href=&quot;../../activerecord&quot;&gt;액티브는&lt;/a&gt; self.build 대신 self.new의 사용이다.</target>
        </trans-unit>
        <trans-unit id="34c0aabafc22ecd298ab851ec0d24c56c1e88a3c" translate="yes" xml:space="preserve">
          <source>The only folder seen by the world as-is. Contains static files and compiled assets.</source>
          <target state="translated">세계에서 볼 수있는 유일한 폴더는 그대로입니다. 정적 파일 및 컴파일 된 자산을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="663af767fd7a7f252ce4ee85857ca02667951d37" translate="yes" xml:space="preserve">
          <source>The only option specific to &lt;code&gt;link_to&lt;/code&gt; (&lt;code&gt;:method&lt;/code&gt;) is used as follows:</source>
          <target state="translated">&lt;code&gt;link_to&lt;/code&gt; ( &lt;code&gt;:method&lt;/code&gt; )와 관련된 유일한 옵션 은 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7c0ff2b98d6f31ee4756bfd1d58b0f4832f27608" translate="yes" xml:space="preserve">
          <source>The only way to explicitly not use the connection information in &lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; is to specify an explicit URL connection using the &lt;code&gt;&quot;url&quot;&lt;/code&gt; sub key:</source>
          <target state="translated">&lt;code&gt;ENV['DATABASE_URL']&lt;/code&gt; 에서 연결 정보를 명시 적으로 사용하지 않는 유일한 방법 은 &lt;code&gt;&quot;url&quot;&lt;/code&gt; 하위 키 를 사용하여 명시 적 URL 연결을 지정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="485f1b08d0393f65ac194833dc19f2f4b02d18c0" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;:prefix&lt;/code&gt; adds a prefix to the name of the generated method. This may be handy for example to get a better name:</source>
          <target state="translated">&lt;code&gt;:prefix&lt;/code&gt; 옵션 은 생성 된 메소드의 이름에 접 두부를 추가합니다. 예를 들어 더 나은 이름을 얻는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="d676be4f5f3aec25fb5d02ebd5821b65122eba01" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;:private&lt;/code&gt; changes methods scope:</source>
          <target state="translated">&lt;code&gt;:private&lt;/code&gt; 옵션 변경 방법 범위 :</target>
        </trans-unit>
        <trans-unit id="ebf24d67cdabeb37ae32a041724d968a479a51ca" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;:separator&lt;/code&gt; can be a regexp:</source>
          <target state="translated">&lt;code&gt;:separator&lt;/code&gt; 옵션 은 정규 표현식이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0490cc17857480b9ef81752f108a7a4d9fbadfb9" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;include_root_in_json&lt;/code&gt; controls the top-level behavior of &lt;code&gt;as_json&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;as_json&lt;/code&gt; will emit a single root node named after the object's type. The default value for &lt;code&gt;include_root_in_json&lt;/code&gt; option is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;include_root_in_json&lt;/code&gt; 옵션 은 &lt;code&gt;as_json&lt;/code&gt; 의 최상위 동작을 제어합니다 . &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;as_json&lt;/code&gt; 은 객체 유형의 이름을 딴 단일 루트 노드를 생성합니다. &lt;code&gt;include_root_in_json&lt;/code&gt; 옵션 의 기본값 은 &lt;code&gt;false&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0ce777a5e57cdf17270d4c689d41bf2c6a2b14b4" translate="yes" xml:space="preserve">
          <source>The option symbols for setting cookies are:</source>
          <target state="translated">쿠키 설정을위한 옵션 기호는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc84187c74ec254bde3266c466aa3c582e0b4eff" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;:lock&lt;/code&gt; flag option allows you to lock the reloaded record:</source>
          <target state="translated">선택적 &lt;code&gt;:lock&lt;/code&gt; 플래그 옵션을 사용하면 다시로드 된 레코드를 잠글 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb1b69daa018b38b7e714147d617a0beace3731" translate="yes" xml:space="preserve">
          <source>The optional envs given as argument and the hash with group dependencies;</source>
          <target state="translated">인자로 주어진 선택적 envs와 그룹 의존성을 가진 해시;</target>
        </trans-unit>
        <trans-unit id="8bad16bbf06e5c49b47b6289efd545cfe8573f00" translate="yes" xml:space="preserve">
          <source>The options &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;finish&lt;/code&gt; are especially useful if you want multiple workers dealing with the same processing queue. You can make worker 1 handle all the records between id 1 and 9999 and worker 2 handle from 10000 and beyond by setting the &lt;code&gt;:start&lt;/code&gt; and &lt;code&gt;:finish&lt;/code&gt; option on each worker.</source>
          <target state="translated">&lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;finish&lt;/code&gt; 옵션 은 여러 작업자가 동일한 처리 큐를 처리하려는 경우 특히 유용합니다. 각 작업자에 대해 &lt;code&gt;:start&lt;/code&gt; 및 &lt;code&gt;:finish&lt;/code&gt; 옵션을 설정하여 작업자 1이 id 1과 9999 사이의 모든 레코드와 10000 이상의 작업자 2 핸들을 처리하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fedec4d892fc12eab521b8368ec8823d40ac4794" translate="yes" xml:space="preserve">
          <source>The options for &lt;a href=&quot;atomfeedhelper#method-i-atom_feed&quot;&gt;#atom_feed&lt;/a&gt; are:</source>
          <target state="translated">&lt;a href=&quot;atomfeedhelper#method-i-atom_feed&quot;&gt;#atom_feed&lt;/a&gt; 의 옵션은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="41953f0040392b7d0f4ad2663cc42a50b8be8ed0" translate="yes" xml:space="preserve">
          <source>The options hash is passed to the underlying cache implementation.</source>
          <target state="translated">옵션 해시는 기본 캐시 구현으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="92b1bd4dfe279a0b6d6f24784cc22f88f3542d92" translate="yes" xml:space="preserve">
          <source>The options map directly to &lt;a href=&quot;https://github.com/janko-m/image_processing&quot;&gt;ImageProcessing&lt;/a&gt; commands.</source>
          <target state="translated">옵션은 &lt;a href=&quot;https://github.com/janko-m/image_processing&quot;&gt;ImageProcessing&lt;/a&gt; 명령에 직접 매핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="7eeb5a5bc634b08fc4f1b6083706e1781ce77e46" translate="yes" xml:space="preserve">
          <source>The options version of redirect allows you to supply only the parts of the URL which need to change, it also supports interpolation of the path similar to the first example.</source>
          <target state="translated">리디렉션의 옵션 버전을 사용하면 변경해야하는 URL 부분 만 제공 할 수 있으며 첫 번째 예제와 유사한 경로의 보간도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="45cc4dd11762c701415947a3cd200605db900701" translate="yes" xml:space="preserve">
          <source>The order in which files are eager loaded is undefined.</source>
          <target state="translated">파일을 열망하는 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="338f8ced7409f9b6ec13ebf9eab9b58b6549e163" translate="yes" xml:space="preserve">
          <source>The order in which helpers from more than one directory are loaded has changed in Rails 4.0. Previously, they were gathered and then sorted alphabetically. After upgrading to Rails 4.0, helpers will preserve the order of loaded directories and will be sorted alphabetically only within each directory. Unless you explicitly use the &lt;code&gt;helpers_path&lt;/code&gt; parameter, this change will only impact the way of loading helpers from engines. If you rely on the ordering, you should check if correct methods are available after upgrade. If you would like to change the order in which engines are loaded, you can use &lt;code&gt;config.railties_order=&lt;/code&gt; method.</source>
          <target state="translated">Rails 4.0에서는 둘 이상의 디렉토리에서 헬퍼가로드되는 순서가 변경되었습니다. 이전에는 모아 알파벳순으로 정렬했습니다. Rails 4.0으로 업그레이드 한 후, 헬퍼는로드 된 디렉토리의 순서를 유지하고 각 디렉토리 내에서만 알파벳순으로 정렬됩니다. &lt;code&gt;helpers_path&lt;/code&gt; 매개 변수 를 명시 적으로 사용하지 않으면 이 변경 사항은 엔진에서 헬퍼를로드하는 방법에만 영향을줍니다. 주문에 의존하는 경우 업그레이드 후 올바른 방법을 사용할 수 있는지 확인해야합니다. 엔진로드 순서를 변경하려면 &lt;code&gt;config.railties_order=&lt;/code&gt; 메소드를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7f79a6fadd87c66fa259266c738bf34142097f62" translate="yes" xml:space="preserve">
          <source>The order in which jobs are processed can be configured differently depending on the adapter.</source>
          <target state="translated">작업 처리 순서는 어댑터에 따라 다르게 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4660c5ab3c3d9ae3dd6bf0c0e1eaefdf8ef89ec0" translate="yes" xml:space="preserve">
          <source>The order in which these classes are returned is unspecified.</source>
          <target state="translated">이러한 클래스가 리턴되는 순서는 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="80069d6fee26801de2e5e79b49b962b023fa71f9" translate="yes" xml:space="preserve">
          <source>The order of the parts getting inserted is determined by the &lt;code&gt;:parts_order&lt;/code&gt; inside of the &lt;code&gt;ActionMailer::Base.default&lt;/code&gt; method.</source>
          <target state="translated">삽입되는 파트의 순서 는 &lt;code&gt;ActionMailer::Base.default&lt;/code&gt; 메소드 의 &lt;code&gt;:parts_order&lt;/code&gt; 에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="e2922c4f0610a60fd83d95bc4625e590fe1de4c8" translate="yes" xml:space="preserve">
          <source>The other common option to configure is the log tags applied to the per-connection logger. Here's an example that uses the user account id if available, else &quot;no-account&quot; while tagging:</source>
          <target state="translated">구성하는 다른 일반적인 옵션은 연결 별 로거에 적용되는 로그 태그입니다. 다음은 사용 가능한 경우 사용자 계정 ID를 사용하고 태그 지정 중에 &quot;계정 없음&quot;을 사용하는 예입니다.</target>
        </trans-unit>
        <trans-unit id="b590272dbc4291a5ec0f0a787d5da3c74a48aa22" translate="yes" xml:space="preserve">
          <source>The other option for compressing CSS if you have the sass-rails gem installed is</source>
          <target state="translated">sass-rails gem이 설치된 경우 CSS를 압축하는 다른 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="196e3e845bbd8998ec86973e62e45a7a873a74bc" translate="yes" xml:space="preserve">
          <source>The output tempfile is opened in the directory returned by &lt;a href=&quot;previewer#method-i-tmpdir&quot;&gt;tmpdir&lt;/a&gt;.</source>
          <target state="translated">출력 임시 파일은 &lt;a href=&quot;previewer#method-i-tmpdir&quot;&gt;tmpdir이&lt;/a&gt; 리턴 한 디렉토리에서 열립니다 .</target>
        </trans-unit>
        <trans-unit id="781ad50fc530a421e9d27dbfa906b4aebe4123b2" translate="yes" xml:space="preserve">
          <source>The parameters in the forms are accessible in controllers according to their name nesting. So inputs named &lt;code&gt;title&lt;/code&gt; and &lt;code&gt;post[title]&lt;/code&gt; are accessible as &lt;code&gt;params[:title]&lt;/code&gt; and &lt;code&gt;params[:post][:title]&lt;/code&gt; respectively.</source>
          <target state="translated">폼의 매개 변수는 이름 중첩에 따라 컨트롤러에서 액세스 할 수 있습니다. 따라서 &lt;code&gt;title&lt;/code&gt; 및 &lt;code&gt;post[title]&lt;/code&gt; 이라는 입력 은 각각 &lt;code&gt;params[:title]&lt;/code&gt; 및 &lt;code&gt;params[:post][:title]&lt;/code&gt; 로 액세스 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
